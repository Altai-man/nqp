.include 'cclass.pasm'
.include 'except_severity.pasm'
.include 'except_types.pasm'
.include 'iglobals.pasm'
.include 'interpinfo.pasm'
.include 'iterator.pasm'
.include 'sysinfo.pasm'
.include 'stat.pasm'
.include 'datatypes.pasm'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.loadlib "trans_ops"

.loadlib "io_ops"

.namespace []
.sub "_block1000"  :anon :subid("10_1312646121.678")
    .param pmc param_1002 :slurpy
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P3754 = "630_1312646121.678" 
    capture_lex $P3754
    .const 'Sub' $P3717 = "622_1312646121.678" 
    capture_lex $P3717
    .const 'Sub' $P2379 = "440_1312646121.678" 
    capture_lex $P2379
    .const 'Sub' $P2324 = "419_1312646121.678" 
    capture_lex $P2324
    .const 'Sub' $P1219 = "40_1312646121.678" 
    capture_lex $P1219
    .const 'Sub' $P1025 = "13_1312646121.678" 
    capture_lex $P1025
    .const 'Sub' $P1019 = "12_1312646121.678" 
    capture_lex $P1019
    .const 'Sub' $P1006 = "11_1312646121.678" 
    capture_lex $P1006
.annotate 'line', 1
    .lex "@ARGS", param_1002
    .lex "GLOBALish", $P1003
    .lex "$?PACKAGE", $P1004
.annotate 'line', 2788
    .const 'Sub' $P1006 = "11_1312646121.678" 
    newclosure $P1017, $P1006
    set $P1005, $P1017
    .lex "MAIN", $P1005
.annotate 'line', 2811
    .const 'Sub' $P1019 = "12_1312646121.678" 
    newclosure $P1023, $P1019
    set $P1018, $P1023
    .lex "hll-config", $P1018
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P1025 = "13_1312646121.678" 
    capture_lex $P1025
    $P1025()
.annotate 'line', 440
    .const 'Sub' $P1219 = "40_1312646121.678" 
    capture_lex $P1219
    $P1219()
.annotate 'line', 1172
    .const 'Sub' $P2324 = "419_1312646121.678" 
    capture_lex $P2324
    $P2324()
.annotate 'line', 1215
    .const 'Sub' $P2379 = "440_1312646121.678" 
    capture_lex $P2379
    $P2379()
.annotate 'line', 2730
    .const 'Sub' $P3717 = "622_1312646121.678" 
    capture_lex $P3717
    $P3717()
.annotate 'line', 2785
    .const 'Sub' $P3754 = "630_1312646121.678" 
    capture_lex $P3754
    $P3754()
.annotate 'line', 1
    find_lex $P103, "MAIN"
    find_lex $P103, "hll-config"
    find_lex $P104, "@ARGS"
    if $P104, if_3757
    set $P103, $P104
    goto if_3757_end
  if_3757:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P105, "ModuleLoader"
    getinterp $P106
    set $P107, $P106["context"]
    $P105."set_mainline_module"($P107)
    .const 'Sub' $P3758 = "11_1312646121.678" 
    find_lex $P108, "@ARGS"
    $P109 = $P3758($P108 :flat)
    set $P103, $P109
  if_3757_end:
    .return ($P103)
    .const 'Sub' $P3760 = "631_1312646121.678" 
    .return ($P3760)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post632") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P1001 = "10_1312646121.678" 
    .local pmc block
    set block, $P1001
    nqp_get_sc $P111, "1312646107.691"
    isnull $I100, $P111
    if $I100, if_3762
    goto if_3762_end
  if_3762:
    nqp_dynop_setup 
    getinterp $P112
    get_class $P113, "LexPad"
    get_class $P114, "NQPLexPad"
    $P112."hll_map"($P113, $P114)
    nqp_create_sc $P115, "1312646107.691"
    .local pmc cur_sc
    set cur_sc, $P115
    cur_sc."set_description"("src\\stage2\\gen\\NQP.pm")
    nqp_get_sc $P116, "__6MODEL_CORE__"
    isnull $I101, $P116
    unless $I101, if_3763_end
    set $S100, "Incorrect pre-compiled version of <unknown> loaded"
    die $S100
  if_3763_end:
    nqp_get_sc_object $P116, "__6MODEL_CORE__", 0
    $P117 = $P116."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 0, $P117
    .const 'Sub' $P3764 = "10_1312646121.678" 
    $P116 = $P3764."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 0
    $P116."set_static_lexpad_value"("GLOBALish", $P117)
    .const 'Sub' $P3765 = "10_1312646121.678" 
    $P118 = $P3765."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P3766 = "10_1312646121.678" 
    $P116 = $P3766."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 0
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P3767 = "10_1312646121.678" 
    $P118 = $P3767."get_lexinfo"()
    $P118."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    $P117 = $P116."load_setting"("NQPCORE")
    block."set_outer_ctx"($P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "1312646107.691", 0
    $P116."load_module"("NQPRegex", $P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "1312646107.691", 0
    $P116."load_module"("NQPP6Regex", $P117)
    nqp_get_sc $P116, "1312646082.215"
    isnull $I101, $P116
    unless $I101, if_3768_end
    set $S100, "Incorrect pre-compiled version of src\\stage2\\gen\\nqp-mo.pm loaded"
    die $S100
  if_3768_end:
    nqp_get_sc_object $P116, "1312646082.215", 42
    $P117 = $P116."new_type"("NQP::SymbolTable" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 1, $P117
    nqp_get_sc_object $P116, "1312646107.691", 1
    nqp_get_sc_object $P117, "1312646107.691", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["SymbolTable"], $P116
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3769 = "14_1312646121.678" 
    $P117."add_method"($P118, "load_setting", $P3769)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3770 = "16_1312646121.678" 
    $P117."add_method"($P118, "load_module", $P3770)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3771 = "17_1312646121.678" 
    $P117."add_method"($P118, "install_package_symbol", $P3771)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3772 = "20_1312646121.678" 
    $P117."add_method"($P118, "install_lexical_symbol", $P3772)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3773 = "21_1312646121.678" 
    $P117."add_method"($P118, "install_package_routine", $P3773)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3774 = "22_1312646121.678" 
    $P117."add_method"($P118, "pkg_create_mo", $P3774)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3775 = "23_1312646121.678" 
    $P117."add_method"($P118, "pkg_add_attribute", $P3775)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3776 = "26_1312646121.678" 
    $P117."add_method"($P118, "pkg_add_method", $P3776)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3777 = "29_1312646121.678" 
    $P117."add_method"($P118, "set_routine_signature", $P3777)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3778 = "30_1312646121.678" 
    $P117."add_method"($P118, "pkg_set_body_block", $P3778)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3779 = "35_1312646121.678" 
    $P117."add_method"($P118, "pkg_add_parent_or_role", $P3779)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3780 = "36_1312646121.678" 
    $P117."add_method"($P118, "pkg_add_parrot_vtable_handler_mapping", $P3780)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3781 = "37_1312646121.678" 
    $P117."add_method"($P118, "pkg_compose", $P3781)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    .const 'Sub' $P3782 = "38_1312646121.678" 
    $P117."add_method"($P118, "to_past", $P3782)
    .const 'Sub' $P3783 = "13_1312646121.678" 
    $P116 = $P3783."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 1
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P3784 = "13_1312646121.678" 
    $P118 = $P3784."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P3785 = "13_1312646121.678" 
    $P116 = $P3785."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 1
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P3786 = "13_1312646121.678" 
    $P118 = $P3786."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc $P116, "1312646090.24"
    isnull $I101, $P116
    unless $I101, if_3787_end
    set $S100, "Incorrect pre-compiled version of src\\stage2\\gen\\NQPHLL.pm loaded"
    die $S100
  if_3787_end:
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    nqp_get_sc_object $P119, "1312646090.24", 196
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1312646107.691", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 1
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1312646082.215", 42
    $P117 = $P116."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 16, $P117
    nqp_get_sc_object $P116, "1312646107.691", 16
    nqp_get_sc_object $P117, "1312646107.691", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Grammar"], $P116
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3788 = "41_1312646121.678" 
    $P117."add_method"($P118, "TOP", $P3788)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3789 = "42_1312646121.678" 
    $P117."add_method"($P118, "identifier", $P3789)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3790 = "43_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__identifier", $P3790)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3791 = "44_1312646121.678" 
    $P117."add_method"($P118, "name", $P3791)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3792 = "45_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__name", $P3792)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3793 = "46_1312646121.678" 
    $P117."add_method"($P118, "deflongname", $P3793)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3794 = "47_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__deflongname", $P3794)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3795 = "48_1312646121.678" 
    $P117."add_method"($P118, "ENDSTMT", $P3795)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3796 = "49_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__ENDSTMT", $P3796)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3797 = "50_1312646121.678" 
    $P117."add_method"($P118, "ws", $P3797)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3798 = "51_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__ws", $P3798)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3799 = "52_1312646121.678" 
    $P117."add_method"($P118, "unv", $P3799)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3800 = "54_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__unv", $P3800)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3801 = "55_1312646121.678" 
    $P117."add_method"($P118, "pod_comment", $P3801)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3802 = "57_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__pod_comment", $P3802)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3803 = "58_1312646121.678" 
    $P117."add_method"($P118, "comp_unit", $P3803)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3804 = "59_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__comp_unit", $P3804)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3805 = "60_1312646121.678" 
    $P117."add_method"($P118, "statementlist", $P3805)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3806 = "61_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statementlist", $P3806)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3807 = "62_1312646121.678" 
    $P117."add_method"($P118, "statement", $P3807)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3808 = "64_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement", $P3808)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3809 = "65_1312646121.678" 
    $P117."add_method"($P118, "eat_terminator", $P3809)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3810 = "66_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__eat_terminator", $P3810)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3811 = "67_1312646121.678" 
    $P117."add_method"($P118, "xblock", $P3811)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3812 = "68_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__xblock", $P3812)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3813 = "69_1312646121.678" 
    $P117."add_method"($P118, "pblock", $P3813)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3814 = "70_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__pblock", $P3814)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3815 = "71_1312646121.678" 
    $P117."add_method"($P118, "lambda", $P3815)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3816 = "72_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__lambda", $P3816)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3817 = "73_1312646121.678" 
    $P117."add_method"($P118, "block", $P3817)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3818 = "74_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__block", $P3818)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3819 = "75_1312646121.678" 
    $P117."add_method"($P118, "blockoid", $P3819)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3820 = "76_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__blockoid", $P3820)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3821 = "77_1312646121.678" 
    $P117."add_method"($P118, "newpad", $P3821)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3822 = "78_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__newpad", $P3822)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3823 = "79_1312646121.678" 
    $P117."add_method"($P118, "outerctx", $P3823)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3824 = "80_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__outerctx", $P3824)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3825 = "81_1312646121.678" 
    $P117."add_method"($P118, "GLOBALish", $P3825)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3826 = "82_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__GLOBALish", $P3826)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3827 = "83_1312646121.678" 
    $P117."add_method"($P118, "finishpad", $P3827)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3828 = "84_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__finishpad", $P3828)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3829 = "85_1312646121.678" 
    $P117."add_method"($P118, "you_are_here", $P3829)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3830 = "86_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__you_are_here", $P3830)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3831 = "87_1312646121.678" 
    $P117."add_method"($P118, "terminator", $P3831)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3832 = "88_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__terminator", $P3832)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3833 = "89_1312646121.678" 
    $P117."add_method"($P118, "terminator:sym<;>", $P3833)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3834 = "90_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<;>", $P3834)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3835 = "91_1312646121.678" 
    $P117."add_method"($P118, "terminator:sym<}>", $P3835)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3836 = "92_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<}>", $P3836)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3837 = "93_1312646121.678" 
    $P117."add_method"($P118, "statement_control", $P3837)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3838 = "94_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control", $P3838)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3839 = "95_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P3839)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3840 = "96_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<use>", $P3840)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3841 = "97_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P3841)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3842 = "98_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<if>", $P3842)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3843 = "99_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P3843)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3844 = "101_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<unless>", $P3844)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3845 = "102_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P3845)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3846 = "103_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<while>", $P3846)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3847 = "104_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P3847)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3848 = "105_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<repeat>", $P3848)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3849 = "106_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P3849)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3850 = "107_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<for>", $P3850)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3851 = "108_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P3851)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3852 = "109_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CATCH>", $P3852)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3853 = "110_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P3853)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3854 = "111_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CONTROL>", $P3854)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3855 = "112_1312646121.678" 
    $P117."add_method"($P118, "statement_prefix", $P3855)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3856 = "113_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix", $P3856)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3857 = "114_1312646121.678" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P3857)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3858 = "115_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<INIT>", $P3858)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3859 = "116_1312646121.678" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P3859)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3860 = "117_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<try>", $P3860)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3861 = "118_1312646121.678" 
    $P117."add_method"($P118, "blorst", $P3861)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3862 = "119_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__blorst", $P3862)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3863 = "120_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_cond", $P3863)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3864 = "121_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond", $P3864)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3865 = "122_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P3865)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3866 = "123_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<if>", $P3866)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3867 = "124_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P3867)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3868 = "125_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<unless>", $P3868)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3869 = "126_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_loop", $P3869)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3870 = "127_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop", $P3870)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3871 = "128_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P3871)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3872 = "129_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<while>", $P3872)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3873 = "130_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P3873)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3874 = "131_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<until>", $P3874)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3875 = "132_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_loop:sym<for>", $P3875)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3876 = "133_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<for>", $P3876)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3877 = "134_1312646121.678" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P3877)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3878 = "135_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<fatarrow>", $P3878)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3879 = "136_1312646121.678" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P3879)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3880 = "137_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<colonpair>", $P3880)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3881 = "138_1312646121.678" 
    $P117."add_method"($P118, "term:sym<variable>", $P3881)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3882 = "139_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<variable>", $P3882)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3883 = "140_1312646121.678" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P3883)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3884 = "141_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<package_declarator>", $P3884)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3885 = "142_1312646121.678" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P3885)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3886 = "143_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<scope_declarator>", $P3886)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3887 = "144_1312646121.678" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P3887)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3888 = "145_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<routine_declarator>", $P3888)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3889 = "146_1312646121.678" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P3889)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3890 = "149_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<multi_declarator>", $P3890)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3891 = "150_1312646121.678" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P3891)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3892 = "151_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<regex_declarator>", $P3892)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3893 = "152_1312646121.678" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P3893)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3894 = "153_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<statement_prefix>", $P3894)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3895 = "154_1312646121.678" 
    $P117."add_method"($P118, "term:sym<lambda>", $P3895)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3896 = "155_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<lambda>", $P3896)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3897 = "156_1312646121.678" 
    $P117."add_method"($P118, "fatarrow", $P3897)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3898 = "157_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__fatarrow", $P3898)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3899 = "158_1312646121.678" 
    $P117."add_method"($P118, "colonpair", $P3899)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3900 = "159_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__colonpair", $P3900)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3901 = "160_1312646121.678" 
    $P117."add_method"($P118, "variable", $P3901)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3902 = "161_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__variable", $P3902)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3903 = "162_1312646121.678" 
    $P117."add_method"($P118, "sigil", $P3903)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3904 = "163_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__sigil", $P3904)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3905 = "164_1312646121.678" 
    $P117."add_method"($P118, "twigil", $P3905)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3906 = "165_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__twigil", $P3906)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3907 = "166_1312646121.678" 
    $P117."add_method"($P118, "package_declarator", $P3907)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3908 = "167_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator", $P3908)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3909 = "168_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P3909)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3910 = "169_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<module>", $P3910)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3911 = "170_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P3911)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3912 = "171_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<knowhow>", $P3912)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3913 = "172_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P3913)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3914 = "173_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<class>", $P3914)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3915 = "174_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P3915)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3916 = "175_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<grammar>", $P3916)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3917 = "176_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P3917)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3918 = "177_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<role>", $P3918)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3919 = "178_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P3919)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3920 = "179_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<native>", $P3920)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3921 = "180_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P3921)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3922 = "181_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<stub>", $P3922)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3923 = "182_1312646121.678" 
    $P117."add_method"($P118, "package_def", $P3923)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3924 = "184_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__package_def", $P3924)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3925 = "185_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator", $P3925)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3926 = "186_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator", $P3926)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3927 = "187_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P3927)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3928 = "188_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<my>", $P3928)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3929 = "189_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P3929)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3930 = "190_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<our>", $P3930)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3931 = "191_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P3931)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3932 = "192_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<has>", $P3932)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3933 = "193_1312646121.678" 
    $P117."add_method"($P118, "scoped", $P3933)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3934 = "194_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__scoped", $P3934)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3935 = "195_1312646121.678" 
    $P117."add_method"($P118, "typename", $P3935)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3936 = "197_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__typename", $P3936)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3937 = "198_1312646121.678" 
    $P117."add_method"($P118, "declarator", $P3937)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3938 = "199_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__declarator", $P3938)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3939 = "200_1312646121.678" 
    $P117."add_method"($P118, "variable_declarator", $P3939)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3940 = "202_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__variable_declarator", $P3940)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3941 = "203_1312646121.678" 
    $P117."add_method"($P118, "routine_declarator", $P3941)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3942 = "204_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator", $P3942)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3943 = "205_1312646121.678" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P3943)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3944 = "206_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<sub>", $P3944)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3945 = "207_1312646121.678" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P3945)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3946 = "208_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<method>", $P3946)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3947 = "209_1312646121.678" 
    $P117."add_method"($P118, "routine_def", $P3947)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3948 = "210_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__routine_def", $P3948)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3949 = "211_1312646121.678" 
    $P117."add_method"($P118, "method_def", $P3949)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3950 = "213_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__method_def", $P3950)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3951 = "214_1312646121.678" 
    $P117."add_method"($P118, "onlystar", $P3951)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3952 = "216_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__onlystar", $P3952)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3953 = "217_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator", $P3953)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3954 = "218_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator", $P3954)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3955 = "219_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P3955)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3956 = "220_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<multi>", $P3956)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3957 = "221_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P3957)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3958 = "222_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<proto>", $P3958)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3959 = "223_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P3959)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3960 = "224_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<null>", $P3960)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3961 = "225_1312646121.678" 
    $P117."add_method"($P118, "signature", $P3961)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3962 = "227_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__signature", $P3962)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3963 = "228_1312646121.678" 
    $P117."add_method"($P118, "parameter", $P3963)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3964 = "229_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__parameter", $P3964)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3965 = "230_1312646121.678" 
    $P117."add_method"($P118, "param_var", $P3965)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3966 = "231_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__param_var", $P3966)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3967 = "232_1312646121.678" 
    $P117."add_method"($P118, "named_param", $P3967)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3968 = "233_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__named_param", $P3968)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3969 = "234_1312646121.678" 
    $P117."add_method"($P118, "default_value", $P3969)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3970 = "235_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__default_value", $P3970)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3971 = "236_1312646121.678" 
    $P117."add_method"($P118, "trait", $P3971)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3972 = "237_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__trait", $P3972)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3973 = "238_1312646121.678" 
    $P117."add_method"($P118, "trait_mod", $P3973)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3974 = "239_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__trait_mod", $P3974)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3975 = "240_1312646121.678" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P3975)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3976 = "241_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__trait_mod:sym<is>", $P3976)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3977 = "242_1312646121.678" 
    $P117."add_method"($P118, "regex_declarator", $P3977)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3978 = "243_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__regex_declarator", $P3978)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3979 = "244_1312646121.678" 
    $P117."add_method"($P118, "dotty", $P3979)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3980 = "245_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__dotty", $P3980)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3981 = "246_1312646121.678" 
    $P117."add_method"($P118, "term", $P3981)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3982 = "247_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term", $P3982)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3983 = "248_1312646121.678" 
    $P117."add_method"($P118, "term:sym<self>", $P3983)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3984 = "249_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<self>", $P3984)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3985 = "250_1312646121.678" 
    $P117."add_method"($P118, "term:sym<identifier>", $P3985)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3986 = "251_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<identifier>", $P3986)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3987 = "252_1312646121.678" 
    $P117."add_method"($P118, "term:sym<name>", $P3987)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3988 = "253_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<name>", $P3988)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3989 = "254_1312646121.678" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P3989)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3990 = "255_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::op>", $P3990)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3991 = "256_1312646121.678" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P3991)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3992 = "257_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::const>", $P3992)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3993 = "258_1312646121.678" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P3993)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3994 = "259_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<nqp::op>", $P3994)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3995 = "260_1312646121.678" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P3995)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3996 = "262_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<onlystar>", $P3996)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3997 = "263_1312646121.678" 
    $P117."add_method"($P118, "args", $P3997)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3998 = "264_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__args", $P3998)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P3999 = "265_1312646121.678" 
    $P117."add_method"($P118, "arglist", $P3999)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4000 = "266_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__arglist", $P4000)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4001 = "267_1312646121.678" 
    $P117."add_method"($P118, "term:sym<value>", $P4001)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4002 = "268_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<value>", $P4002)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4003 = "269_1312646121.678" 
    $P117."add_method"($P118, "value", $P4003)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4004 = "270_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__value", $P4004)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4005 = "271_1312646121.678" 
    $P117."add_method"($P118, "number", $P4005)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4006 = "272_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__number", $P4006)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4007 = "273_1312646121.678" 
    $P117."add_method"($P118, "quote", $P4007)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4008 = "274_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote", $P4008)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4009 = "275_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4009)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4010 = "276_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<apos>", $P4010)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4011 = "277_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4011)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4012 = "278_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<dblq>", $P4012)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4013 = "279_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<q>", $P4013)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4014 = "280_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<q>", $P4014)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4015 = "281_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4015)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4016 = "282_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<qq>", $P4016)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4017 = "283_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4017)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4018 = "284_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q>", $P4018)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4019 = "285_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4019)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4020 = "286_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q:PIR>", $P4020)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4021 = "287_1312646121.678" 
    $P117."add_method"($P118, "quote:sym</ />", $P4021)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4022 = "288_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote:sym</ />", $P4022)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4023 = "289_1312646121.678" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4023)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4024 = "290_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<$>", $P4024)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4025 = "291_1312646121.678" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4025)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4026 = "292_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<{ }>", $P4026)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4027 = "293_1312646121.678" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4027)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4028 = "294_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<esc>", $P4028)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4029 = "295_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4029)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4030 = "296_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<( )>", $P4030)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4031 = "297_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4031)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4032 = "298_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<[ ]>", $P4032)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4033 = "299_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4033)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4034 = "300_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<ang>", $P4034)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4035 = "301_1312646121.678" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4035)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4036 = "302_1312646121.678" 
    $P117."add_method"($P118, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P4036)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4037 = "303_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4037)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4038 = "304_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<{ }>", $P4038)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4039 = "305_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4039)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4040 = "306_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<sigil>", $P4040)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4041 = "307_1312646121.678" 
    $P117."add_method"($P118, "semilist", $P4041)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4042 = "308_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__semilist", $P4042)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4043 = "309_1312646121.678" 
    $P117."add_method"($P118, "infixish", $P4043)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4044 = "310_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infixish", $P4044)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4045 = "311_1312646121.678" 
    $P117."add_method"($P118, "infixstopper", $P4045)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4046 = "312_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infixstopper", $P4046)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4047 = "313_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4047)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4048 = "314_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<[ ]>", $P4048)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4049 = "315_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4049)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4050 = "316_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<{ }>", $P4050)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4051 = "317_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4051)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4052 = "318_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<ang>", $P4052)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4053 = "319_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4053)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4054 = "320_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<( )>", $P4054)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4055 = "321_1312646121.678" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4055)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4056 = "322_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<.>", $P4056)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4057 = "323_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<++>", $P4057)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4058 = "324_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<++>", $P4058)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4059 = "325_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<-->", $P4059)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4060 = "326_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<-->", $P4060)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4061 = "327_1312646121.678" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4061)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4062 = "328_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<++>", $P4062)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4063 = "329_1312646121.678" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4063)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4064 = "330_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<-->", $P4064)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4065 = "331_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<**>", $P4065)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4066 = "332_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<**>", $P4066)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4067 = "333_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<+>", $P4067)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4068 = "334_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<+>", $P4068)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4069 = "335_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<~>", $P4069)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4070 = "336_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<~>", $P4070)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4071 = "337_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<->", $P4071)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4072 = "338_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<->", $P4072)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4073 = "339_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<?>", $P4073)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4074 = "340_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<?>", $P4074)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4075 = "341_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<!>", $P4075)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4076 = "342_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<!>", $P4076)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4077 = "343_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<|>", $P4077)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4078 = "344_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<|>", $P4078)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4079 = "345_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<*>", $P4079)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4080 = "346_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<*>", $P4080)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4081 = "347_1312646121.678" 
    $P117."add_method"($P118, "infix:sym</>", $P4081)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4082 = "348_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym</>", $P4082)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4083 = "349_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<%>", $P4083)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4084 = "350_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<%>", $P4084)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4085 = "351_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<+&>", $P4085)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4086 = "352_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+&>", $P4086)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4087 = "353_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<+>", $P4087)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4088 = "354_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+>", $P4088)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4089 = "355_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<->", $P4089)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4090 = "356_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<->", $P4090)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4091 = "357_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<+|>", $P4091)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4092 = "358_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+|>", $P4092)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4093 = "359_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<+^>", $P4093)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4094 = "360_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+^>", $P4094)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4095 = "361_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<~>", $P4095)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4096 = "362_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~>", $P4096)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4097 = "363_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<==>", $P4097)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4098 = "364_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<==>", $P4098)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4099 = "365_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<!=>", $P4099)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4100 = "366_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<!=>", $P4100)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4101 = "367_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<<=>", $P4101)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4102 = "368_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<=>", $P4102)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4103 = "369_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<>=>", $P4103)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4104 = "370_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>=>", $P4104)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4105 = "371_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<<>", $P4105)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4106 = "372_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<>", $P4106)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4107 = "373_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<>>", $P4107)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4108 = "374_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>>", $P4108)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4109 = "375_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<eq>", $P4109)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4110 = "376_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<eq>", $P4110)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4111 = "377_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<ne>", $P4111)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4112 = "378_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ne>", $P4112)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4113 = "379_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<le>", $P4113)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4114 = "380_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<le>", $P4114)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4115 = "381_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<ge>", $P4115)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4116 = "382_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ge>", $P4116)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4117 = "383_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<lt>", $P4117)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4118 = "384_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<lt>", $P4118)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4119 = "385_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<gt>", $P4119)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4120 = "386_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<gt>", $P4120)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4121 = "387_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<=:=>", $P4121)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4122 = "388_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=:=>", $P4122)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4123 = "389_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4123)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4124 = "390_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~~>", $P4124)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4125 = "391_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<&&>", $P4125)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4126 = "392_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<&&>", $P4126)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4127 = "393_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<||>", $P4127)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4128 = "394_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<||>", $P4128)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4129 = "395_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<//>", $P4129)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4130 = "396_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<//>", $P4130)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4131 = "397_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<?? !!>", $P4131)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4132 = "398_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<?? !!>", $P4132)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4133 = "399_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<=>", $P4133)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4134 = "400_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=>", $P4134)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4135 = "401_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<:=>", $P4135)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4136 = "402_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<:=>", $P4136)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4137 = "403_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<::=>", $P4137)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4138 = "404_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<::=>", $P4138)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4139 = "405_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<,>", $P4139)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4140 = "406_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<,>", $P4140)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4141 = "407_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<return>", $P4141)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4142 = "409_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<return>", $P4142)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4143 = "410_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4143)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4144 = "411_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<make>", $P4144)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4145 = "412_1312646121.678" 
    $P117."add_method"($P118, "term:sym<last>", $P4145)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4146 = "413_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<last>", $P4146)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4147 = "414_1312646121.678" 
    $P117."add_method"($P118, "term:sym<next>", $P4147)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4148 = "415_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<next>", $P4148)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4149 = "416_1312646121.678" 
    $P117."add_method"($P118, "term:sym<redo>", $P4149)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4150 = "417_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__term:sym<redo>", $P4150)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    .const 'Sub' $P4151 = "418_1312646121.678" 
    $P117."add_method"($P118, "smartmatch", $P4151)
    .const 'Sub' $P4152 = "40_1312646121.678" 
    $P116 = $P4152."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 16
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4153 = "40_1312646121.678" 
    $P118 = $P4153."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4154 = "40_1312646121.678" 
    $P116 = $P4154."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 16
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4155 = "40_1312646121.678" 
    $P118 = $P4155."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    nqp_get_sc_object $P119, "1312646090.24", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1312646107.691", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 16
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1312646082.215", 42
    $P117 = $P116."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 381, $P117
    nqp_get_sc_object $P116, "1312646107.691", 381
    nqp_get_sc_object $P117, "1312646107.691", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Regex"], $P116
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4156 = "420_1312646121.678" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4156)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4157 = "422_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<:my>", $P4157)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4158 = "423_1312646121.678" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4158)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4159 = "424_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<{ }>", $P4159)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4160 = "425_1312646121.678" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4160)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4161 = "427_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<nqpvar>", $P4161)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4162 = "428_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4162)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4163 = "429_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<{ }>", $P4163)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4164 = "430_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4164)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4165 = "432_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<?{ }>", $P4165)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4166 = "433_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<name>", $P4166)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4167 = "435_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<name>", $P4167)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4168 = "436_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4168)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4169 = "437_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<var>", $P4169)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4170 = "438_1312646121.678" 
    $P117."add_method"($P118, "codeblock", $P4170)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    .const 'Sub' $P4171 = "439_1312646121.678" 
    $P117."add_method"($P118, "!PREFIX__codeblock", $P4171)
    .const 'Sub' $P4172 = "419_1312646121.678" 
    $P116 = $P4172."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 381
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4173 = "419_1312646121.678" 
    $P118 = $P4173."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4174 = "419_1312646121.678" 
    $P116 = $P4174."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 381
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4175 = "419_1312646121.678" 
    $P118 = $P4175."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc $P116, "1312646100.581"
    isnull $I101, $P116
    unless $I101, if_4176_end
    set $S100, "Incorrect pre-compiled version of src\\stage2\\gen\\NQPP6Regex.pm loaded"
    die $S100
  if_4176_end:
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    nqp_get_sc_object $P119, "1312646100.581", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1312646107.691", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 381
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1312646082.215", 42
    $P117 = $P116."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 398, $P117
    nqp_get_sc_object $P116, "1312646107.691", 398
    nqp_get_sc_object $P117, "1312646107.691", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Actions"], $P116
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4177 = "467_1312646121.678" 
    $P117."add_method"($P118, "TOP", $P4177)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4178 = "468_1312646121.678" 
    $P117."add_method"($P118, "deflongname", $P4178)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4179 = "469_1312646121.678" 
    $P117."add_method"($P118, "comp_unit", $P4179)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4180 = "471_1312646121.678" 
    $P117."add_method"($P118, "statementlist", $P4180)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4181 = "473_1312646121.678" 
    $P117."add_method"($P118, "statement", $P4181)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4182 = "475_1312646121.678" 
    $P117."add_method"($P118, "xblock", $P4182)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4183 = "476_1312646121.678" 
    $P117."add_method"($P118, "pblock", $P4183)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4184 = "477_1312646121.678" 
    $P117."add_method"($P118, "block", $P4184)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4185 = "478_1312646121.678" 
    $P117."add_method"($P118, "blockoid", $P4185)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4186 = "480_1312646121.678" 
    $P117."add_method"($P118, "newpad", $P4186)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4187 = "481_1312646121.678" 
    $P117."add_method"($P118, "outerctx", $P4187)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4188 = "483_1312646121.678" 
    $P117."add_method"($P118, "GLOBALish", $P4188)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4189 = "484_1312646121.678" 
    $P117."add_method"($P118, "you_are_here", $P4189)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4190 = "485_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P4190)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4191 = "486_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P4191)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4192 = "488_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P4192)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4193 = "489_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P4193)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4194 = "490_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P4194)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4195 = "491_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P4195)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4196 = "492_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P4196)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4197 = "493_1312646121.678" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P4197)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4198 = "494_1312646121.678" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P4198)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4199 = "495_1312646121.678" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P4199)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4200 = "496_1312646121.678" 
    $P117."add_method"($P118, "blorst", $P4200)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4201 = "497_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P4201)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4202 = "498_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P4202)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4203 = "499_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P4203)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4204 = "500_1312646121.678" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P4204)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4205 = "501_1312646121.678" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P4205)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4206 = "502_1312646121.678" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P4206)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4207 = "503_1312646121.678" 
    $P117."add_method"($P118, "term:sym<variable>", $P4207)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4208 = "504_1312646121.678" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P4208)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4209 = "505_1312646121.678" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P4209)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4210 = "506_1312646121.678" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P4210)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4211 = "507_1312646121.678" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P4211)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4212 = "508_1312646121.678" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P4212)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4213 = "509_1312646121.678" 
    $P117."add_method"($P118, "term:sym<lambda>", $P4213)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4214 = "510_1312646121.678" 
    $P117."add_method"($P118, "fatarrow", $P4214)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4215 = "511_1312646121.678" 
    $P117."add_method"($P118, "colonpair", $P4215)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4216 = "512_1312646121.678" 
    $P117."add_method"($P118, "variable", $P4216)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4217 = "518_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P4217)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4218 = "519_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P4218)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4219 = "520_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P4219)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4220 = "521_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P4220)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4221 = "522_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P4221)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4222 = "523_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P4222)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4223 = "524_1312646121.678" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P4223)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4224 = "525_1312646121.678" 
    $P117."add_method"($P118, "package_def", $P4224)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4225 = "531_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P4225)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4226 = "532_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P4226)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4227 = "533_1312646121.678" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P4227)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4228 = "534_1312646121.678" 
    $P117."add_method"($P118, "scoped", $P4228)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4229 = "535_1312646121.678" 
    $P117."add_method"($P118, "declarator", $P4229)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4230 = "536_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P4230)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4231 = "537_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P4231)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4232 = "538_1312646121.678" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P4232)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4233 = "539_1312646121.678" 
    $P117."add_method"($P118, "variable_declarator", $P4233)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4234 = "542_1312646121.678" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P4234)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4235 = "543_1312646121.678" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P4235)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4236 = "544_1312646121.678" 
    $P117."add_method"($P118, "routine_def", $P4236)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4237 = "551_1312646121.678" 
    $P117."add_method"($P118, "method_def", $P4237)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4238 = "554_1312646121.678" 
    $P117."add_method"($P118, "signature", $P4238)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4239 = "557_1312646121.678" 
    $P117."add_method"($P118, "parameter", $P4239)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4240 = "558_1312646121.678" 
    $P117."add_method"($P118, "param_var", $P4240)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4241 = "559_1312646121.678" 
    $P117."add_method"($P118, "named_param", $P4241)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4242 = "560_1312646121.678" 
    $P117."add_method"($P118, "typename", $P4242)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4243 = "562_1312646121.678" 
    $P117."add_method"($P118, "trait", $P4243)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4244 = "563_1312646121.678" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P4244)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4245 = "568_1312646121.678" 
    $P117."add_method"($P118, "regex_declarator", $P4245)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4246 = "573_1312646121.678" 
    $P117."add_method"($P118, "dotty", $P4246)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4247 = "574_1312646121.678" 
    $P117."add_method"($P118, "term:sym<self>", $P4247)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4248 = "575_1312646121.678" 
    $P117."add_method"($P118, "term:sym<identifier>", $P4248)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4249 = "576_1312646121.678" 
    $P117."add_method"($P118, "term:sym<name>", $P4249)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4250 = "578_1312646121.678" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P4250)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4251 = "579_1312646121.678" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P4251)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4252 = "580_1312646121.678" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P4252)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4253 = "581_1312646121.678" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P4253)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4254 = "582_1312646121.678" 
    $P117."add_method"($P118, "args", $P4254)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4255 = "583_1312646121.678" 
    $P117."add_method"($P118, "arglist", $P4255)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4256 = "586_1312646121.678" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P4256)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4257 = "587_1312646121.678" 
    $P117."add_method"($P118, "term:sym<value>", $P4257)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4258 = "588_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4258)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4259 = "589_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4259)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4260 = "590_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4260)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4261 = "591_1312646121.678" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4261)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4262 = "592_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4262)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4263 = "594_1312646121.678" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4263)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4264 = "595_1312646121.678" 
    $P117."add_method"($P118, "semilist", $P4264)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4265 = "596_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4265)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4266 = "597_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4266)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4267 = "598_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4267)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4268 = "599_1312646121.678" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4268)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4269 = "600_1312646121.678" 
    $P117."add_method"($P118, "value", $P4269)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4270 = "601_1312646121.678" 
    $P117."add_method"($P118, "number", $P4270)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4271 = "602_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4271)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4272 = "603_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4272)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4273 = "604_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4273)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4274 = "605_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<q>", $P4274)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4275 = "606_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4275)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4276 = "607_1312646121.678" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4276)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4277 = "608_1312646121.678" 
    $P117."add_method"($P118, "quote:sym</ />", $P4277)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4278 = "609_1312646121.678" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4278)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4279 = "610_1312646121.678" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4279)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4280 = "611_1312646121.678" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4280)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4281 = "612_1312646121.678" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4281)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4282 = "613_1312646121.678" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4282)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4283 = "614_1312646121.678" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4283)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4284 = "615_1312646121.678" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4284)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4285 = "616_1312646121.678" 
    $P117."add_method"($P118, "term:sym<next>", $P4285)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4286 = "617_1312646121.678" 
    $P117."add_method"($P118, "term:sym<last>", $P4286)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4287 = "618_1312646121.678" 
    $P117."add_method"($P118, "term:sym<redo>", $P4287)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4288 = "619_1312646121.678" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4288)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    .const 'Sub' $P4289 = "620_1312646121.678" 
    $P117."add_method"($P118, "known_sym", $P4289)
    .const 'Sub' $P4290 = "440_1312646121.678" 
    $P116 = $P4290."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 398
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4291 = "440_1312646121.678" 
    $P118 = $P4291."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4292 = "440_1312646121.678" 
    $P116 = $P4292."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 398
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4293 = "440_1312646121.678" 
    $P118 = $P4293."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    nqp_get_sc_object $P119, "1312646090.24", 105
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1312646107.691", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 398
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1312646082.215", 42
    $P117 = $P116."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 512, $P117
    nqp_get_sc_object $P116, "1312646107.691", 512
    nqp_get_sc_object $P117, "1312646107.691", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["RegexActions"], $P116
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4294 = "623_1312646121.678" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4294)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4295 = "624_1312646121.678" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4295)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4296 = "625_1312646121.678" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4296)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4297 = "626_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4297)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4298 = "627_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4298)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4299 = "628_1312646121.678" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4299)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    .const 'Sub' $P4300 = "629_1312646121.678" 
    $P117."add_method"($P118, "codeblock", $P4300)
    .const 'Sub' $P4301 = "622_1312646121.678" 
    $P116 = $P4301."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 512
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4302 = "622_1312646121.678" 
    $P118 = $P4302."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4303 = "622_1312646121.678" 
    $P116 = $P4303."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 512
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4304 = "622_1312646121.678" 
    $P118 = $P4304."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    nqp_get_sc_object $P119, "1312646100.581", 145
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1312646107.691", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 512
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1312646082.215", 42
    $P117 = $P116."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P117, cur_sc
    nqp_set_sc_object "1312646107.691", 520, $P117
    nqp_get_sc_object $P116, "1312646107.691", 520
    nqp_get_sc_object $P117, "1312646107.691", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Compiler"], $P116
    .const 'Sub' $P4305 = "630_1312646121.678" 
    $P116 = $P4305."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 520
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4306 = "630_1312646121.678" 
    $P118 = $P4306."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4307 = "630_1312646121.678" 
    $P116 = $P4307."get_lexinfo"()
    nqp_get_sc_object $P117, "1312646107.691", 520
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4308 = "630_1312646121.678" 
    $P118 = $P4308."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1312646107.691", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 520
    nqp_get_sc_object $P119, "1312646090.24", 138
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1312646107.691", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1312646107.691", 520
    $P117."compose"($P118)
  if_3762_end:
    nqp_get_sc_object $P116, "1312646107.691", 0
    set_hll_global "GLOBAL", $P116
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1312646121.678") :outer("10_1312646121.678")
    .param pmc param_1007
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2788
    .lex "@ARGS", param_1007
.annotate 'line', 2790
    new $P100, "Undef"
    set $P1008, $P100
    .lex "$nqpcomp", $P1008
.annotate 'line', 2797
    $P1010 = root_new ['parrot';'ResizablePMCArray']
    set $P1009, $P1010
    .lex "@clo", $P1009
.annotate 'line', 2790
    get_hll_global $P101, "GLOBAL"
    nqp_get_package_through_who $P102, $P101, "NQP"
    get_who $P103, $P102
    set $P104, $P103["Compiler"]
    $P105 = $P104."new"()
    store_lex "$nqpcomp", $P105
.annotate 'line', 2791
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_633
    new $P101, "Undef"
  vivify_633:
    $P101."language"("nqp")
.annotate 'line', 2792
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_634
    new $P101, "Undef"
  vivify_634:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P101."parsegrammar"($P105)
.annotate 'line', 2793
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_635
    new $P101, "Undef"
  vivify_635:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Actions"]
    $P101."parseactions"($P105)
.annotate 'line', 2794
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_636
    new $P101, "Undef"
  vivify_636:
    $P102 = $P101."config"()
    "hll-config"($P102)
.annotate 'line', 2797
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_637
    new $P101, "Undef"
  vivify_637:
    $P102 = $P101."commandline_options"()
    store_lex "@clo", $P102
.annotate 'line', 2798
    find_lex $P1011, "@clo"
    unless_null $P1011, vivify_638
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_638:
    $P1011."push"("parsetrace")
.annotate 'line', 2799
    find_lex $P1012, "@clo"
    unless_null $P1012, vivify_639
    $P1012 = root_new ['parrot';'ResizablePMCArray']
  vivify_639:
    $P1012."push"("setting=s")
.annotate 'line', 2800
    find_lex $P1013, "@clo"
    unless_null $P1013, vivify_640
    $P1013 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    $P1013."push"("setting-path=s")
.annotate 'line', 2801
    find_lex $P1014, "@clo"
    unless_null $P1014, vivify_641
    $P1014 = root_new ['parrot';'ResizablePMCArray']
  vivify_641:
    $P1014."push"("module-path=s")
.annotate 'line', 2802
    find_lex $P1015, "@clo"
    unless_null $P1015, vivify_642
    $P1015 = root_new ['parrot';'ResizablePMCArray']
  vivify_642:
    $P1015."push"("vmlibs=s")
.annotate 'line', 2805
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_643
    new $P101, "Undef"
  vivify_643:
    find_lex $P1016, "@ARGS"
    unless_null $P1016, vivify_644
    $P1016 = root_new ['parrot';'ResizablePMCArray']
  vivify_644:
    $P101."command_line"($P1016, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2807
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_645
    new $P101, "Undef"
  vivify_645:
    $P102 = $P101."nqpevent"()
.annotate 'line', 2788
    .return ($P102)
.end


.HLL "nqp"

.namespace []
.sub "hll-config"  :subid("12_1312646121.678") :outer("10_1312646121.678")
    .param pmc param_1020
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2811
    .lex "$config", param_1020
.annotate 'line', 2812
    new $P101, "String"
    assign $P101, "2011.06-145-g2bd6964"
    find_lex $P1021, "$config"
    unless_null $P1021, vivify_646
    $P1021 = root_new ['parrot';'Hash']
    store_lex "$config", $P1021
  vivify_646:
    set $P1021["version"], $P101
.annotate 'line', 2813
    new $P101, "String"
    assign $P101, "2011-08-06T15:55:07Z"
    find_lex $P1022, "$config"
    unless_null $P1022, vivify_647
    $P1022 = root_new ['parrot';'Hash']
    store_lex "$config", $P1022
  vivify_647:
    set $P1022["build-date"], $P101
.annotate 'line', 2811
    .return ($P101)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1024"  :subid("13_1312646121.678") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 9
    .const 'Sub' $P1207 = "38_1312646121.678" 
    capture_lex $P1207
    .const 'Sub' $P1203 = "37_1312646121.678" 
    capture_lex $P1203
    .const 'Sub' $P1197 = "36_1312646121.678" 
    capture_lex $P1197
    .const 'Sub' $P1191 = "35_1312646121.678" 
    capture_lex $P1191
    .const 'Sub' $P1164 = "30_1312646121.678" 
    capture_lex $P1164
    .const 'Sub' $P1154 = "29_1312646121.678" 
    capture_lex $P1154
    .const 'Sub' $P1125 = "26_1312646121.678" 
    capture_lex $P1125
    .const 'Sub' $P1103 = "23_1312646121.678" 
    capture_lex $P1103
    .const 'Sub' $P1079 = "22_1312646121.678" 
    capture_lex $P1079
    .const 'Sub' $P1073 = "21_1312646121.678" 
    capture_lex $P1073
    .const 'Sub' $P1066 = "20_1312646121.678" 
    capture_lex $P1066
    .const 'Sub' $P1046 = "17_1312646121.678" 
    capture_lex $P1046
    .const 'Sub' $P1039 = "16_1312646121.678" 
    capture_lex $P1039
    .const 'Sub' $P1029 = "14_1312646121.678" 
    capture_lex $P1029
.annotate 'line', 14
    new $P103, "Undef"
    set $P1026, $P103
    .lex "$loader", $P1026
    .lex "$?PACKAGE", $P1027
    .lex "$?CLASS", $P1028
    get_hll_global $P104, "ModuleLoader"
    store_lex "$loader", $P104
.annotate 'line', 401
    .const 'Sub' $P1207 = "38_1312646121.678" 
    newclosure $P1217, $P1207
.annotate 'line', 9
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("14_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1032
    .param pmc param_1033
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 17
    .const 'Sub' $P1036 = "15_1312646121.678" 
    capture_lex $P1036
    new $P1031, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1031, control_1030
    push_eh $P1031
    .lex "self", param_1032
    .lex "$setting_name", param_1033
.annotate 'line', 19
    find_lex $P105, "$setting_name"
    unless_null $P105, vivify_648
    new $P105, "Undef"
  vivify_648:
    set $S100, $P105
    isne $I100, $S100, "NULL"
    if $I100, if_1034
    new $P104, 'Integer'
    set $P104, $I100
    goto if_1034_end
  if_1034:
    .const 'Sub' $P1036 = "15_1312646121.678" 
    capture_lex $P1036
    $P107 = $P1036()
    set $P104, $P107
  if_1034_end:
.annotate 'line', 17
    .return ($P104)
  control_1030:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1035"  :anon :subid("15_1312646121.678") :outer("14_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 23
    new $P106, "Undef"
    set $P1037, $P106
    .lex "$setting", $P1037
.annotate 'line', 24
    find_lex $P107, "$loader"
    unless_null $P107, vivify_649
    new $P107, "Undef"
  vivify_649:
    find_lex $P108, "$setting_name"
    unless_null $P108, vivify_650
    new $P108, "Undef"
  vivify_650:
    $P109 = $P107."load_setting"($P108)
    find_dynamic_lex $P112, "%*COMPILING"
    unless_null $P112, vivify_651
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%COMPILING"]
    unless_null $P112, vivify_652
    die "Contextual %*COMPILING not found"
  vivify_652:
    store_dynamic_lex "%*COMPILING", $P112
  vivify_651:
    set $P1038, $P112["%?OPTIONS"]
    unless_null $P1038, vivify_653
    $P1038 = root_new ['parrot';'Hash']
    set $P112["%?OPTIONS"], $P1038
  vivify_653:
    set $P1038["outer_ctx"], $P109
    store_lex "$setting", $P109
.annotate 'line', 27
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
.annotate 'line', 28
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 31
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Op"]
.annotate 'line', 33
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Var"]
    $P125 = $P124."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 34
    get_hll_global $P126, "GLOBAL"
    nqp_get_package_through_who $P127, $P126, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
.annotate 'line', 36
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Var"]
    new $P134, "ResizablePMCArray"
    $P135 = $P133."new"("ModuleLoader" :named("name"), $P134 :named("namespace"), "package" :named("scope"))
    find_lex $P136, "$setting_name"
    unless_null $P136, vivify_654
    new $P136, "Undef"
  vivify_654:
    $P137 = $P129."new"($P135, $P136, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 34
    $P138 = $P120."new"($P125, $P137, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 31
    $P139 = $P111."new"($P116, $P138)
.annotate 'line', 27
    $P107."add_event"($P139 :named("deserialize_past"))
.annotate 'line', 42
    new $P107, "Exception"
    set $P107['type'], .CONTROL_RETURN
    find_lex $P108, "$setting"
    unless_null $P108, vivify_655
    new $P108, "Undef"
  vivify_655:
    getattribute $P109, $P108, "lex_pad"
    setattribute $P107, 'payload', $P109
    throw $P107
.annotate 'line', 19
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("16_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1042
    .param pmc param_1043
    .param pmc param_1044
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 48
    new $P1041, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1041, control_1040
    push_eh $P1041
    .lex "self", param_1042
    .lex "$module_name", param_1043
    .lex "$cur_GLOBALish", param_1044
.annotate 'line', 50
    new $P104, "Undef"
    set $P1045, $P104
    .lex "$module", $P1045
    find_lex $P105, "$loader"
    unless_null $P105, vivify_656
    new $P105, "Undef"
  vivify_656:
    find_lex $P106, "$module_name"
    unless_null $P106, vivify_657
    new $P106, "Undef"
  vivify_657:
    find_lex $P107, "$cur_GLOBALish"
    unless_null $P107, vivify_658
    new $P107, "Undef"
  vivify_658:
    $P108 = $P105."load_module"($P106, $P107)
    store_lex "$module", $P108
.annotate 'line', 53
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
.annotate 'line', 54
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    $P114 = $P113."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 57
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
.annotate 'line', 59
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Var"]
    new $P123, "ResizablePMCArray"
    $P124 = $P122."new"("ModuleLoader" :named("name"), $P123 :named("namespace"), "package" :named("scope"))
    find_lex $P125, "$module_name"
    unless_null $P125, vivify_659
    new $P125, "Undef"
  vivify_659:
.annotate 'line', 61
    find_lex $P126, "self"
    find_lex $P127, "$cur_GLOBALish"
    unless_null $P127, vivify_660
    new $P127, "Undef"
  vivify_660:
    $P128 = $P126."get_slot_past_for_object"($P127)
    $P129 = $P118."new"($P124, $P125, $P128, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 57
    $P130 = $P109."new"($P114, $P129)
.annotate 'line', 53
    $P105."add_event"($P130 :named("deserialize_past"))
.annotate 'line', 64
    new $P105, "Exception"
    set $P105['type'], .CONTROL_RETURN
    find_lex $P106, "$module"
    unless_null $P106, vivify_661
    new $P106, "Undef"
  vivify_661:
    getattribute $P107, $P106, "lex_pad"
    setattribute $P105, 'payload', $P107
    throw $P105
.annotate 'line', 48
    .return ()
  control_1040:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("17_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1047
    .param pmc param_1048
    .param pmc param_1049
    .param pmc param_1050
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 69
    .const 'Sub' $P1063 = "19_1312646121.678" 
    capture_lex $P1063
    .const 'Sub' $P1058 = "18_1312646121.678" 
    capture_lex $P1058
    .lex "self", param_1047
    .lex "$package", param_1048
    .lex "@sym", param_1049
    .lex "$obj", param_1050
.annotate 'line', 71
    new $P104, "Undef"
    set $P1051, $P104
    .lex "$name", $P1051
.annotate 'line', 74
    new $P105, "Undef"
    set $P1052, $P105
    .lex "$target", $P1052
.annotate 'line', 81
    new $P106, "Undef"
    set $P1053, $P106
    .lex "$path", $P1053
.annotate 'line', 70
    find_lex $P1054, "@sym"
    unless_null $P1054, vivify_662
    $P1054 = root_new ['parrot';'ResizablePMCArray']
  vivify_662:
    clone $P107, $P1054
    store_lex "@sym", $P107
.annotate 'line', 71
    find_lex $P1055, "@sym"
    unless_null $P1055, vivify_663
    $P1055 = root_new ['parrot';'ResizablePMCArray']
  vivify_663:
    $P107 = $P1055."pop"()
    set $S100, $P107
    new $P108, 'String'
    set $P108, $S100
    store_lex "$name", $P108
.annotate 'line', 74
    find_lex $P107, "$package"
    unless_null $P107, vivify_664
    new $P107, "Undef"
  vivify_664:
    store_lex "$target", $P107
.annotate 'line', 75
    find_lex $P1056, "@sym"
    unless_null $P1056, vivify_665
    $P1056 = root_new ['parrot';'ResizablePMCArray']
  vivify_665:
    defined $I100, $P1056
    unless $I100, for_undef_666
    iter $P107, $P1056
    new $P109, 'ExceptionHandler'
    set_label $P109, loop1060_handler
    $P109."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P109
  loop1060_test:
    unless $P107, loop1060_done
    shift $P108, $P107
  loop1060_redo:
    .const 'Sub' $P1058 = "18_1312646121.678" 
    capture_lex $P1058
    $P1058($P108)
  loop1060_next:
    goto loop1060_test
  loop1060_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, 'type'
    eq $P110, .CONTROL_LOOP_NEXT, loop1060_next
    eq $P110, .CONTROL_LOOP_REDO, loop1060_redo
  loop1060_done:
    pop_eh 
  for_undef_666:
.annotate 'line', 78
    find_lex $P107, "$obj"
    unless_null $P107, vivify_669
    new $P107, "Undef"
  vivify_669:
    find_lex $P108, "$name"
    unless_null $P108, vivify_670
    new $P108, "Undef"
  vivify_670:
    find_lex $P109, "$target"
    unless_null $P109, vivify_671
    new $P109, "Undef"
    store_lex "$target", $P109
  vivify_671:
    get_who $P110, $P109
    set $P110[$P108], $P107
.annotate 'line', 81
    find_lex $P107, "self"
    find_lex $P108, "$package"
    unless_null $P108, vivify_672
    new $P108, "Undef"
  vivify_672:
    $P109 = $P107."get_slot_past_for_object"($P108)
    store_lex "$path", $P109
.annotate 'line', 82
    find_lex $P1061, "@sym"
    unless_null $P1061, vivify_673
    $P1061 = root_new ['parrot';'ResizablePMCArray']
  vivify_673:
    defined $I100, $P1061
    unless $I100, for_undef_674
    iter $P107, $P1061
    new $P109, 'ExceptionHandler'
    set_label $P109, loop1065_handler
    $P109."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P109
  loop1065_test:
    unless $P107, loop1065_done
    shift $P108, $P107
  loop1065_redo:
    .const 'Sub' $P1063 = "19_1312646121.678" 
    capture_lex $P1063
    $P1063($P108)
  loop1065_next:
    goto loop1065_test
  loop1065_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, 'type'
    eq $P110, .CONTROL_LOOP_NEXT, loop1065_next
    eq $P110, .CONTROL_LOOP_REDO, loop1065_redo
  loop1065_done:
    pop_eh 
  for_undef_674:
.annotate 'line', 85
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 87
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Var"]
.annotate 'line', 89
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Op"]
    find_lex $P120, "$path"
    unless_null $P120, vivify_677
    new $P120, "Undef"
  vivify_677:
    $P121 = $P119."new"($P120, "get_who PP" :named("pirop"))
    find_lex $P122, "$name"
    unless_null $P122, vivify_678
    new $P122, "Undef"
  vivify_678:
    $P123 = $P115."new"($P121, $P122, "keyed" :named("scope"))
.annotate 'line', 92
    find_lex $P124, "self"
    find_lex $P125, "$obj"
    unless_null $P125, vivify_679
    new $P125, "Undef"
  vivify_679:
    $P126 = $P124."get_slot_past_for_object"($P125)
    $P127 = $P111."new"($P123, $P126, "bind_6model" :named("pasttype"))
.annotate 'line', 85
    $P128 = $P107."add_event"($P127 :named("deserialize_past"))
.annotate 'line', 69
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1057"  :anon :subid("18_1312646121.678") :outer("17_1312646121.678")
    .param pmc param_1059
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 75
    .lex "$_", param_1059
.annotate 'line', 76
    find_lex $P109, "$target"
    unless_null $P109, vivify_667
    new $P109, "Undef"
  vivify_667:
    find_lex $P110, "$_"
    unless_null $P110, vivify_668
    new $P110, "Undef"
  vivify_668:
    set $S100, $P110
    nqp_get_package_through_who $P111, $P109, $S100
    store_lex "$target", $P111
.annotate 'line', 75
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1062"  :anon :subid("19_1312646121.678") :outer("17_1312646121.678")
    .param pmc param_1064
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 82
    .lex "$_", param_1064
.annotate 'line', 83
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
    find_lex $P113, "$path"
    unless_null $P113, vivify_675
    new $P113, "Undef"
  vivify_675:
    find_lex $P114, "$_"
    unless_null $P114, vivify_676
    new $P114, "Undef"
  vivify_676:
    set $S100, $P114
    $P115 = $P112."new"($P113, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P115
.annotate 'line', 82
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol" :anon :subid("20_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1067
    .param pmc param_1068
    .param pmc param_1069
    .param pmc param_1070
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 100
    .lex "self", param_1067
    .lex "$block", param_1068
    .lex "$name", param_1069
    .lex "$obj", param_1070
.annotate 'line', 106
    new $P104, "Undef"
    set $P1071, $P104
    .lex "$fixup", $P1071
.annotate 'line', 102
    find_lex $P105, "$block"
    unless_null $P105, vivify_680
    new $P105, "Undef"
  vivify_680:
    find_lex $P106, "$name"
    unless_null $P106, vivify_681
    new $P106, "Undef"
  vivify_681:
    find_lex $P107, "$obj"
    unless_null $P107, vivify_682
    new $P107, "Undef"
  vivify_682:
    $P105."symbol"($P106, "lexical" :named("scope"), $P107 :named("value"))
.annotate 'line', 103
    new $P105, "Float"
    assign $P105, 0
    set $I100, $P105
    find_lex $P1072, "$block"
    unless_null $P1072, vivify_683
    $P1072 = root_new ['parrot';'ResizablePMCArray']
  vivify_683:
    set $P106, $P1072[$I100]
    unless_null $P106, vivify_684
    new $P106, "Undef"
  vivify_684:
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Var"]
    find_lex $P111, "$name"
    unless_null $P111, vivify_685
    new $P111, "Undef"
  vivify_685:
    $P112 = $P110."new"("lexical" :named("scope"), $P111 :named("name"), 1 :named("isdecl"))
    $P106."push"($P112)
.annotate 'line', 106
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 107
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 109
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
.annotate 'line', 111
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Val"]
    find_lex $P121, "$block"
    unless_null $P121, vivify_686
    new $P121, "Undef"
  vivify_686:
    $P122 = $P120."new"($P121 :named("value"))
    $P123 = $P116."new"($P122, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 113
    find_lex $P124, "$name"
    unless_null $P124, vivify_687
    new $P124, "Undef"
  vivify_687:
    set $S100, $P124
    find_lex $P125, "self"
    find_lex $P126, "$obj"
    unless_null $P126, vivify_688
    new $P126, "Undef"
  vivify_688:
    $P127 = $P125."get_slot_past_for_object"($P126)
    $P128 = $P112."new"($P123, $S100, $P127, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 117
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
.annotate 'line', 119
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
.annotate 'line', 121
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Val"]
    find_lex $P141, "$block"
    unless_null $P141, vivify_689
    new $P141, "Undef"
  vivify_689:
    $P142 = $P140."new"($P141 :named("value"))
    $P143 = $P136."new"($P142, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 119
    $P144 = $P132."new"($P143, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 117
    $P145 = $P108."new"($P128, $P144)
.annotate 'line', 106
    store_lex "$fixup", $P145
.annotate 'line', 125
    find_lex $P105, "self"
    find_lex $P106, "$fixup"
    unless_null $P106, vivify_690
    new $P106, "Undef"
  vivify_690:
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_691
    new $P107, "Undef"
  vivify_691:
    $P108 = $P105."add_event"($P106 :named("deserialize_past"), $P107 :named("fixup_past"))
.annotate 'line', 100
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine" :anon :subid("21_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1074
    .param pmc param_1075
    .param pmc param_1076
    .param pmc param_1077
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 130
    .lex "self", param_1074
    .lex "$package", param_1075
    .lex "$name", param_1076
    .lex "$past_block", param_1077
.annotate 'line', 131
    new $P104, "Undef"
    set $P1078, $P104
    .lex "$fixup", $P1078
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Op"]
.annotate 'line', 133
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Var"]
.annotate 'line', 135
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "self"
    find_lex $P118, "$package"
    unless_null $P118, vivify_692
    new $P118, "Undef"
  vivify_692:
    $P119 = $P117."get_slot_past_for_object"($P118)
    $P120 = $P116."new"($P119, "get_who PP" :named("pirop"))
.annotate 'line', 136
    find_lex $P121, "$name"
    unless_null $P121, vivify_693
    new $P121, "Undef"
  vivify_693:
    set $S100, $P121
    $P122 = $P112."new"($P120, $S100, "keyed" :named("scope"))
.annotate 'line', 138
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Val"]
    find_lex $P127, "$past_block"
    unless_null $P127, vivify_694
    new $P127, "Undef"
  vivify_694:
    $P128 = $P126."new"($P127 :named("value"))
    $P129 = $P108."new"($P122, $P128, "bind_6model" :named("pasttype"))
.annotate 'line', 131
    store_lex "$fixup", $P129
.annotate 'line', 140
    find_lex $P105, "self"
    find_lex $P106, "$fixup"
    unless_null $P106, vivify_695
    new $P106, "Undef"
  vivify_695:
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_696
    new $P107, "Undef"
  vivify_696:
    $P108 = $P105."add_event"($P106 :named("deserialize_past"), $P107 :named("fixup_past"))
.annotate 'line', 130
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("22_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1082
    .param pmc param_1083
    .param pmc param_1084 :optional :named("name")
    .param int has_param_1084 :opt_flag
    .param pmc param_1085 :optional :named("repr")
    .param int has_param_1085 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 145
    new $P1081, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1081, control_1080
    push_eh $P1081
    .lex "self", param_1082
    .lex "$how", param_1083
    if has_param_1084, optparam_697
    new $P104, "Undef"
    set param_1084, $P104
  optparam_697:
    .lex "$name", param_1084
    if has_param_1085, optparam_698
    new $P105, "Undef"
    set param_1085, $P105
  optparam_698:
    .lex "$repr", param_1085
.annotate 'line', 147
    $P1087 = root_new ['parrot';'Hash']
    set $P1086, $P1087
    .lex "%args", $P1086
.annotate 'line', 150
    new $P106, "Undef"
    set $P1088, $P106
    .lex "$mo", $P1088
.annotate 'line', 151
    new $P107, "Undef"
    set $P1089, $P107
    .lex "$slot", $P1089
.annotate 'line', 155
    $P1091 = root_new ['parrot';'ResizablePMCArray']
    set $P1090, $P1091
    .lex "@how_ns", $P1090
.annotate 'line', 156
    new $P108, "Undef"
    set $P1092, $P108
    .lex "$how_name", $P1092
.annotate 'line', 157
    new $P109, "Undef"
    set $P1093, $P109
    .lex "$setup_call", $P1093
.annotate 'line', 145
    find_lex $P1094, "%args"
    unless_null $P1094, vivify_699
    $P1094 = root_new ['parrot';'Hash']
  vivify_699:
.annotate 'line', 148
    find_lex $P110, "$name"
    unless_null $P110, vivify_700
    new $P110, "Undef"
  vivify_700:
    defined $I100, $P110
    unless $I100, if_1095_end
    find_lex $P111, "$name"
    unless_null $P111, vivify_701
    new $P111, "Undef"
  vivify_701:
    find_lex $P1096, "%args"
    unless_null $P1096, vivify_702
    $P1096 = root_new ['parrot';'Hash']
    store_lex "%args", $P1096
  vivify_702:
    set $P1096["name"], $P111
  if_1095_end:
.annotate 'line', 149
    find_lex $P110, "$repr"
    unless_null $P110, vivify_703
    new $P110, "Undef"
  vivify_703:
    defined $I100, $P110
    unless $I100, if_1097_end
    find_lex $P111, "$repr"
    unless_null $P111, vivify_704
    new $P111, "Undef"
  vivify_704:
    find_lex $P1098, "%args"
    unless_null $P1098, vivify_705
    $P1098 = root_new ['parrot';'Hash']
    store_lex "%args", $P1098
  vivify_705:
    set $P1098["repr"], $P111
  if_1097_end:
.annotate 'line', 150
    find_lex $P110, "$how"
    unless_null $P110, vivify_706
    new $P110, "Undef"
  vivify_706:
    find_lex $P1099, "%args"
    unless_null $P1099, vivify_707
    $P1099 = root_new ['parrot';'Hash']
  vivify_707:
    $P111 = $P110."new_type"($P1099 :flat)
    store_lex "$mo", $P111
.annotate 'line', 151
    find_lex $P110, "self"
    find_lex $P111, "$mo"
    unless_null $P111, vivify_708
    new $P111, "Undef"
  vivify_708:
    $P112 = $P110."add_object"($P111)
    store_lex "$slot", $P112
.annotate 'line', 155
    find_lex $P110, "$how"
    unless_null $P110, vivify_709
    new $P110, "Undef"
  vivify_709:
    get_how $P111, $P110
    find_lex $P112, "$how"
    unless_null $P112, vivify_710
    new $P112, "Undef"
  vivify_710:
    $S100 = $P111."name"($P112)
    split $P113, "::", $S100
    store_lex "@how_ns", $P113
.annotate 'line', 156
    find_lex $P1100, "@how_ns"
    unless_null $P1100, vivify_711
    $P1100 = root_new ['parrot';'ResizablePMCArray']
  vivify_711:
    $P110 = $P1100."pop"()
    store_lex "$how_name", $P110
.annotate 'line', 157
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
.annotate 'line', 159
    find_lex $P114, "self"
    find_lex $P115, "$how"
    unless_null $P115, vivify_712
    new $P115, "Undef"
  vivify_712:
    $P116 = $P114."get_object_sc_ref_past"($P115)
    $P117 = $P113."new"($P116, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 157
    store_lex "$setup_call", $P117
.annotate 'line', 161
    find_lex $P110, "$name"
    unless_null $P110, vivify_713
    new $P110, "Undef"
  vivify_713:
    defined $I100, $P110
    unless $I100, if_1101_end
.annotate 'line', 162
    find_lex $P111, "$setup_call"
    unless_null $P111, vivify_714
    new $P111, "Undef"
  vivify_714:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Val"]
    find_lex $P116, "$name"
    unless_null $P116, vivify_715
    new $P116, "Undef"
  vivify_715:
    $P117 = $P115."new"($P116 :named("value"), "name" :named("named"))
    $P111."push"($P117)
  if_1101_end:
.annotate 'line', 164
    find_lex $P110, "$repr"
    unless_null $P110, vivify_716
    new $P110, "Undef"
  vivify_716:
    defined $I100, $P110
    unless $I100, if_1102_end
.annotate 'line', 165
    find_lex $P111, "$setup_call"
    unless_null $P111, vivify_717
    new $P111, "Undef"
  vivify_717:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Val"]
    find_lex $P116, "$repr"
    unless_null $P116, vivify_718
    new $P116, "Undef"
  vivify_718:
    $P117 = $P115."new"($P116 :named("value"), "repr" :named("named"))
    $P111."push"($P117)
  if_1102_end:
.annotate 'line', 167
    find_lex $P110, "self"
.annotate 'line', 168
    find_lex $P111, "self"
    find_lex $P112, "$slot"
    unless_null $P112, vivify_719
    new $P112, "Undef"
  vivify_719:
    find_lex $P113, "self"
    find_lex $P114, "$setup_call"
    unless_null $P114, vivify_720
    new $P114, "Undef"
  vivify_720:
    $P115 = $P113."set_cur_sc"($P114)
    $P116 = $P111."set_slot_past"($P112, $P115)
.annotate 'line', 167
    $P110."add_event"($P116 :named("deserialize_past"))
.annotate 'line', 171
    new $P110, "Exception"
    set $P110['type'], .CONTROL_RETURN
    find_lex $P111, "$mo"
    unless_null $P111, vivify_721
    new $P111, "Undef"
  vivify_721:
    setattribute $P110, 'payload', $P111
    throw $P110
.annotate 'line', 145
    .return ()
  control_1080:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, "payload"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_add_attribute" :anon :subid("23_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1104
    .param pmc param_1105
    .param pmc param_1106
    .param pmc param_1107
    .param pmc param_1108
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 179
    .const 'Sub' $P1121 = "25_1312646121.678" 
    capture_lex $P1121
    .const 'Sub' $P1116 = "24_1312646121.678" 
    capture_lex $P1116
    .lex "self", param_1104
    .lex "$obj", param_1105
    .lex "$meta_attr", param_1106
    .lex "%lit_args", param_1107
    .lex "%obj_args", param_1108
.annotate 'line', 181
    new $P104, "Undef"
    set $P1109, $P104
    .lex "$attr", $P1109
.annotate 'line', 185
    new $P105, "Undef"
    set $P1110, $P105
    .lex "$create_call", $P1110
.annotate 'line', 197
    new $P106, "Undef"
    set $P1111, $P106
    .lex "$obj_slot_past", $P1111
.annotate 'line', 181
    find_lex $P107, "$meta_attr"
    unless_null $P107, vivify_722
    new $P107, "Undef"
  vivify_722:
    find_lex $P1112, "%lit_args"
    unless_null $P1112, vivify_723
    $P1112 = root_new ['parrot';'Hash']
  vivify_723:
    find_lex $P1113, "%obj_args"
    unless_null $P1113, vivify_724
    $P1113 = root_new ['parrot';'Hash']
  vivify_724:
    $P108 = $P107."new"($P1112 :flat, $P1113 :flat)
    store_lex "$attr", $P108
.annotate 'line', 182
    find_lex $P107, "$obj"
    unless_null $P107, vivify_725
    new $P107, "Undef"
  vivify_725:
    get_how $P108, $P107
    find_lex $P109, "$obj"
    unless_null $P109, vivify_726
    new $P109, "Undef"
  vivify_726:
    find_lex $P110, "$attr"
    unless_null $P110, vivify_727
    new $P110, "Undef"
  vivify_727:
    $P108."add_attribute"($P109, $P110)
.annotate 'line', 185
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
.annotate 'line', 187
    find_lex $P111, "self"
    find_lex $P112, "$meta_attr"
    unless_null $P112, vivify_728
    new $P112, "Undef"
  vivify_728:
    $P113 = $P111."get_object_sc_ref_past"($P112)
    $P114 = $P110."new"($P113, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 185
    store_lex "$create_call", $P114
.annotate 'line', 189
    find_lex $P1114, "%lit_args"
    unless_null $P1114, vivify_729
    $P1114 = root_new ['parrot';'Hash']
  vivify_729:
    defined $I100, $P1114
    unless $I100, for_undef_730
    iter $P107, $P1114
    new $P109, 'ExceptionHandler'
    set_label $P109, loop1118_handler
    $P109."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P109
  loop1118_test:
    unless $P107, loop1118_done
    shift $P108, $P107
  loop1118_redo:
    .const 'Sub' $P1116 = "24_1312646121.678" 
    capture_lex $P1116
    $P1116($P108)
  loop1118_next:
    goto loop1118_test
  loop1118_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, 'type'
    eq $P110, .CONTROL_LOOP_NEXT, loop1118_next
    eq $P110, .CONTROL_LOOP_REDO, loop1118_redo
  loop1118_done:
    pop_eh 
  for_undef_730:
.annotate 'line', 192
    find_lex $P1119, "%obj_args"
    unless_null $P1119, vivify_734
    $P1119 = root_new ['parrot';'Hash']
  vivify_734:
    defined $I100, $P1119
    unless $I100, for_undef_735
    iter $P107, $P1119
    new $P110, 'ExceptionHandler'
    set_label $P110, loop1124_handler
    $P110."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P110
  loop1124_test:
    unless $P107, loop1124_done
    shift $P108, $P107
  loop1124_redo:
    .const 'Sub' $P1121 = "25_1312646121.678" 
    capture_lex $P1121
    $P1121($P108)
  loop1124_next:
    goto loop1124_test
  loop1124_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P111, exception, 'type'
    eq $P111, .CONTROL_LOOP_NEXT, loop1124_next
    eq $P111, .CONTROL_LOOP_REDO, loop1124_redo
  loop1124_done:
    pop_eh 
  for_undef_735:
.annotate 'line', 197
    find_lex $P107, "self"
    find_lex $P108, "$obj"
    unless_null $P108, vivify_741
    new $P108, "Undef"
  vivify_741:
    $P109 = $P107."get_slot_past_for_object"($P108)
    store_lex "$obj_slot_past", $P109
.annotate 'line', 198
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 200
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    find_lex $P116, "$obj_slot_past"
    unless_null $P116, vivify_742
    new $P116, "Undef"
  vivify_742:
    $P117 = $P115."new"($P116, "get_how PP" :named("pirop"))
    find_lex $P118, "$obj_slot_past"
    unless_null $P118, vivify_743
    new $P118, "Undef"
  vivify_743:
    find_lex $P119, "$create_call"
    unless_null $P119, vivify_744
    new $P119, "Undef"
  vivify_744:
    $P120 = $P111."new"($P117, $P118, $P119, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 198
    $P121 = $P107."add_event"($P120 :named("deserialize_past"))
.annotate 'line', 179
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1115"  :anon :subid("24_1312646121.678") :outer("23_1312646121.678")
    .param pmc param_1117
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 189
    .lex "$_", param_1117
.annotate 'line', 190
    find_lex $P109, "$create_call"
    unless_null $P109, vivify_731
    new $P109, "Undef"
  vivify_731:
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Val"]
    find_lex $P114, "$_"
    unless_null $P114, vivify_732
    new $P114, "Undef"
  vivify_732:
    $P115 = $P114."value"()
    find_lex $P116, "$_"
    unless_null $P116, vivify_733
    new $P116, "Undef"
  vivify_733:
    $P117 = $P116."key"()
    $P118 = $P113."new"($P115 :named("value"), $P117 :named("named"))
    $P119 = $P109."push"($P118)
.annotate 'line', 189
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1120"  :anon :subid("25_1312646121.678") :outer("23_1312646121.678")
    .param pmc param_1123
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 193
    new $P109, "Undef"
    set $P1122, $P109
    .lex "$lookup", $P1122
    .lex "$_", param_1123
    find_lex $P110, "self"
    find_lex $P111, "$_"
    unless_null $P111, vivify_736
    new $P111, "Undef"
  vivify_736:
    $P112 = $P111."value"()
    $P113 = $P110."get_object_sc_ref_past"($P112)
    store_lex "$lookup", $P113
.annotate 'line', 194
    find_lex $P110, "$lookup"
    unless_null $P110, vivify_737
    new $P110, "Undef"
  vivify_737:
    find_lex $P111, "$_"
    unless_null $P111, vivify_738
    new $P111, "Undef"
  vivify_738:
    $P112 = $P111."key"()
    $P110."named"($P112)
.annotate 'line', 195
    find_lex $P110, "$create_call"
    unless_null $P110, vivify_739
    new $P110, "Undef"
  vivify_739:
    find_lex $P111, "$lookup"
    unless_null $P111, vivify_740
    new $P111, "Undef"
  vivify_740:
    $P112 = $P110."push"($P111)
.annotate 'line', 192
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method" :anon :subid("26_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1126
    .param pmc param_1127
    .param pmc param_1128
    .param pmc param_1129
    .param pmc param_1130
    .param pmc param_1131
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 209
    .const 'Sub' $P1149 = "28_1312646121.678" 
    capture_lex $P1149
    .const 'Sub' $P1137 = "27_1312646121.678" 
    capture_lex $P1137
    .lex "self", param_1126
    .lex "$obj", param_1127
    .lex "$meta_method_name", param_1128
    .lex "$name", param_1129
    .lex "$method_past", param_1130
    .lex "$is_dispatcher", param_1131
.annotate 'line', 215
    new $P104, "Undef"
    set $P1132, $P104
    .lex "$stub_code", $P1132
.annotate 'line', 221
    new $P105, "Undef"
    set $P1133, $P105
    .lex "$fixups", $P1133
.annotate 'line', 222
    new $P106, "Undef"
    set $P1134, $P106
    .lex "$dummy", $P1134
.annotate 'line', 267
    new $P107, "Undef"
    set $P1135, $P107
    .lex "$slot_past", $P1135
.annotate 'line', 215
    .const 'Sub' $P1137 = "27_1312646121.678" 
    newclosure $P1143, $P1137
    store_lex "$stub_code", $P1143
.annotate 'line', 221
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    store_lex "$fixups", $P112
.annotate 'line', 209
    find_lex $P108, "$dummy"
    unless_null $P108, vivify_749
    new $P108, "Undef"
  vivify_749:
.annotate 'line', 223
    find_lex $P1145, "$method_past"
    unless_null $P1145, vivify_750
    $P1145 = root_new ['parrot';'Hash']
  vivify_750:
    set $P108, $P1145["compile_time_dummy"]
    unless_null $P108, vivify_751
    new $P108, "Undef"
  vivify_751:
    defined $I100, $P108
    if $I100, if_1144
.annotate 'line', 230
    find_lex $P109, "$is_dispatcher"
    unless_null $P109, vivify_752
    new $P109, "Undef"
  vivify_752:
    if $P109, if_1147
.annotate 'line', 246
    find_lex $P110, "$stub_code"
    unless_null $P110, vivify_753
    new $P110, "Undef"
  vivify_753:
    clone $P111, $P110
    store_lex "$dummy", $P111
.annotate 'line', 245
    goto if_1147_end
  if_1147:
.annotate 'line', 231
    find_lex $P110, "$method_past"
    unless_null $P110, vivify_754
    new $P110, "Undef"
  vivify_754:
    $P110."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 232
    new $P110, "DispatcherSub"
    find_lex $P111, "$stub_code"
    unless_null $P111, vivify_755
    new $P111, "Undef"
  vivify_755:
    assign $P110, $P111
    store_lex "$dummy", $P110
.annotate 'line', 236
    find_lex $P110, "$dummy"
    unless_null $P110, vivify_756
    new $P110, "Undef"
  vivify_756:
    .const 'Sub' $P1149 = "28_1312646121.678" 
    newclosure $P1152, $P1149
    setprop $P110, "CLONE_CALLBACK", $P1152
  if_1147_end:
.annotate 'line', 248
    find_lex $P109, "$dummy"
    unless_null $P109, vivify_761
    new $P109, "Undef"
  vivify_761:
    find_lex $P110, "$name"
    unless_null $P110, vivify_762
    new $P110, "Undef"
  vivify_762:
    set $S100, $P110
    assign $P109, $S100
.annotate 'line', 249
    find_lex $P109, "self"
    find_lex $P110, "$dummy"
    unless_null $P110, vivify_763
    new $P110, "Undef"
  vivify_763:
    $P109."add_code"($P110)
.annotate 'line', 250
    find_lex $P109, "$dummy"
    unless_null $P109, vivify_764
    new $P109, "Undef"
  vivify_764:
    find_lex $P1153, "$method_past"
    unless_null $P1153, vivify_765
    $P1153 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P1153
  vivify_765:
    set $P1153["compile_time_dummy"], $P109
.annotate 'line', 226
    goto if_1144_end
  if_1144:
.annotate 'line', 224
    find_lex $P1146, "$method_past"
    unless_null $P1146, vivify_766
    $P1146 = root_new ['parrot';'Hash']
  vivify_766:
    set $P109, $P1146["compile_time_dummy"]
    unless_null $P109, vivify_767
    new $P109, "Undef"
  vivify_767:
    store_lex "$dummy", $P109
  if_1144_end:
.annotate 'line', 254
    find_lex $P108, "$dummy"
    unless_null $P108, vivify_768
    new $P108, "Undef"
  vivify_768:
    find_lex $P109, "$method_past"
    unless_null $P109, vivify_769
    new $P109, "Undef"
  vivify_769:
    setprop $P108, "PAST", $P109
.annotate 'line', 257
    find_lex $P108, "$obj"
    unless_null $P108, vivify_770
    new $P108, "Undef"
  vivify_770:
    get_how $P109, $P108
    find_lex $P110, "$obj"
    unless_null $P110, vivify_771
    new $P110, "Undef"
  vivify_771:
    find_lex $P111, "$name"
    unless_null $P111, vivify_772
    new $P111, "Undef"
  vivify_772:
    find_lex $P112, "$dummy"
    unless_null $P112, vivify_773
    new $P112, "Undef"
  vivify_773:
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_774
    new $P113, "Undef"
  vivify_774:
    set $S100, $P113
    $P109.$S100($P110, $P111, $P112)
.annotate 'line', 262
    find_lex $P108, "$fixups"
    unless_null $P108, vivify_775
    new $P108, "Undef"
  vivify_775:
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 264
    find_lex $P113, "self"
    find_lex $P114, "$dummy"
    unless_null $P114, vivify_776
    new $P114, "Undef"
  vivify_776:
    $P115 = $P113."get_slot_past_for_object"($P114)
.annotate 'line', 265
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Val"]
    find_lex $P120, "$method_past"
    unless_null $P120, vivify_777
    new $P120, "Undef"
  vivify_777:
    $P121 = $P119."new"($P120 :named("value"))
    $P122 = $P112."new"($P115, $P121, "assign vPP" :named("pirop"))
.annotate 'line', 262
    $P108."push"($P122)
.annotate 'line', 267
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_778
    new $P109, "Undef"
  vivify_778:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 268
    find_lex $P108, "self"
.annotate 'line', 269
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_779
    new $P113, "Undef"
  vivify_779:
.annotate 'line', 271
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_780
    new $P118, "Undef"
  vivify_780:
    $P119 = $P117."new"($P118, "get_how PP" :named("pirop"))
    find_lex $P120, "$slot_past"
    unless_null $P120, vivify_781
    new $P120, "Undef"
  vivify_781:
    find_lex $P121, "$name"
    unless_null $P121, vivify_782
    new $P121, "Undef"
  vivify_782:
.annotate 'line', 274
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Val"]
    find_lex $P126, "$method_past"
    unless_null $P126, vivify_783
    new $P126, "Undef"
  vivify_783:
    $P127 = $P125."new"($P126 :named("value"))
    $P128 = $P112."new"($P119, $P120, $P121, $P127, "callmethod" :named("pasttype"), $P113 :named("name"))
.annotate 'line', 268
    find_lex $P129, "$fixups"
    unless_null $P129, vivify_784
    new $P129, "Undef"
  vivify_784:
    $P130 = $P108."add_event"($P128 :named("deserialize_past"), $P129 :named("fixup_past"))
.annotate 'line', 209
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1136"  :anon :subid("27_1312646121.678") :outer("26_1312646121.678")
    .param pmc param_1138 :slurpy
    .param pmc param_1139 :slurpy :named
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 215
    .lex "@args", param_1138
    .lex "%named", param_1139
.annotate 'line', 216
    new $P108, "Undef"
    set $P1140, $P108
    .lex "$compiled", $P1140
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Compiler"]
    find_lex $P113, "$method_past"
    unless_null $P113, vivify_745
    new $P113, "Undef"
  vivify_745:
    $P114 = $P112."compile"($P113)
    store_lex "$compiled", $P114
.annotate 'line', 217
    find_lex $P109, "$compiled"
    unless_null $P109, vivify_746
    new $P109, "Undef"
  vivify_746:
    find_lex $P1141, "@args"
    unless_null $P1141, vivify_747
    $P1141 = root_new ['parrot';'ResizablePMCArray']
  vivify_747:
    find_lex $P1142, "%named"
    unless_null $P1142, vivify_748
    $P1142 = root_new ['parrot';'Hash']
  vivify_748:
    $P110 = $P109($P1141 :flat, $P1142 :flat)
.annotate 'line', 215
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1148"  :anon :subid("28_1312646121.678") :outer("26_1312646121.678")
    .param pmc param_1150
    .param pmc param_1151
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 236
    .lex "$orig", param_1150
    .lex "$clone", param_1151
.annotate 'line', 237
    find_lex $P111, "self"
    find_lex $P112, "$clone"
    unless_null $P112, vivify_757
    new $P112, "Undef"
  vivify_757:
    $P111."add_code"($P112)
.annotate 'line', 238
    find_lex $P111, "$fixups"
    unless_null $P111, vivify_758
    new $P111, "Undef"
  vivify_758:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
.annotate 'line', 240
    find_lex $P116, "self"
    find_lex $P117, "$clone"
    unless_null $P117, vivify_759
    new $P117, "Undef"
  vivify_759:
    $P118 = $P116."get_slot_past_for_object"($P117)
.annotate 'line', 241
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$orig"
    unless_null $P123, vivify_760
    new $P123, "Undef"
  vivify_760:
    getprop $P124, "PAST", $P123
    $P125 = $P122."new"($P124 :named("value"))
    $P126 = $P115."new"($P118, $P125, "assign vPP" :named("pirop"))
.annotate 'line', 238
    $P127 = $P111."push"($P126)
.annotate 'line', 236
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature" :anon :subid("29_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1155
    .param pmc param_1156
    .param pmc param_1157
    .param pmc param_1158
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 280
    .lex "self", param_1155
    .lex "$routine", param_1156
    .lex "$types", param_1157
    .lex "$definednesses", param_1158
.annotate 'line', 283
    new $P104, "Undef"
    set $P1159, $P104
    .lex "$fixup", $P1159
.annotate 'line', 290
    new $P105, "Undef"
    set $P1160, $P105
    .lex "$des", $P1160
.annotate 'line', 283
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
    find_lex $P110, "$types"
    unless_null $P110, vivify_785
    new $P110, "Undef"
  vivify_785:
    find_lex $P111, "$definednesses"
    unless_null $P111, vivify_786
    new $P111, "Undef"
  vivify_786:
    $P112 = $P109."new"($P110, $P111, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P112
.annotate 'line', 284
    find_lex $P1162, "$routine"
    unless_null $P1162, vivify_787
    $P1162 = root_new ['parrot';'Hash']
  vivify_787:
    set $P106, $P1162["compile_time_dummy"]
    unless_null $P106, vivify_788
    new $P106, "Undef"
  vivify_788:
    defined $I100, $P106
    if $I100, if_1161
.annotate 'line', 288
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_789
    new $P107, "Undef"
  vivify_789:
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Val"]
    find_lex $P112, "$routine"
    unless_null $P112, vivify_790
    new $P112, "Undef"
  vivify_790:
    $P113 = $P111."new"($P112 :named("value"))
    $P107."unshift"($P113)
.annotate 'line', 287
    goto if_1161_end
  if_1161:
.annotate 'line', 285
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_791
    new $P107, "Undef"
  vivify_791:
    find_lex $P108, "self"
    find_lex $P1163, "$routine"
    unless_null $P1163, vivify_792
    $P1163 = root_new ['parrot';'Hash']
  vivify_792:
    set $P109, $P1163["compile_time_dummy"]
    unless_null $P109, vivify_793
    new $P109, "Undef"
  vivify_793:
    $P110 = $P108."get_slot_past_for_object"($P109)
    $P107."unshift"($P110)
  if_1161_end:
.annotate 'line', 290
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 291
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Val"]
    find_lex $P114, "$routine"
    unless_null $P114, vivify_794
    new $P114, "Undef"
  vivify_794:
    $P115 = $P113."new"($P114 :named("value"))
    find_lex $P116, "$types"
    unless_null $P116, vivify_795
    new $P116, "Undef"
  vivify_795:
    find_lex $P117, "$definednesses"
    unless_null $P117, vivify_796
    new $P117, "Undef"
  vivify_796:
    $P118 = $P109."new"($P115, $P116, $P117, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 290
    store_lex "$des", $P118
.annotate 'line', 293
    find_lex $P106, "self"
    find_lex $P107, "$des"
    unless_null $P107, vivify_797
    new $P107, "Undef"
  vivify_797:
    find_lex $P108, "$fixup"
    unless_null $P108, vivify_798
    new $P108, "Undef"
  vivify_798:
    $P109 = $P106."add_event"($P107 :named("deserialize_past"), $P108 :named("fixup_past"))
.annotate 'line', 280
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block" :anon :subid("30_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1165
    .param pmc param_1166
    .param pmc param_1167
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 297
    .const 'Sub' $P1173 = "31_1312646121.678" 
    capture_lex $P1173
    .lex "self", param_1165
    .lex "$obj", param_1166
    .lex "$body_past", param_1167
.annotate 'line', 308
    new $P104, "Undef"
    set $P1168, $P104
    .lex "$fixups", $P1168
.annotate 'line', 309
    new $P105, "Undef"
    set $P1169, $P105
    .lex "$dummy", $P1169
.annotate 'line', 344
    new $P106, "Undef"
    set $P1170, $P106
    .lex "$slot_past", $P1170
.annotate 'line', 345
    new $P107, "Undef"
    set $P1171, $P107
    .lex "$des", $P1171
.annotate 'line', 308
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    store_lex "$fixups", $P112
.annotate 'line', 309
    .const 'Sub' $P1173 = "31_1312646121.678" 
    newclosure $P1190, $P1173
    store_lex "$dummy", $P1190
.annotate 'line', 341
    find_lex $P108, "$obj"
    unless_null $P108, vivify_816
    new $P108, "Undef"
  vivify_816:
    get_how $P109, $P108
    find_lex $P110, "$obj"
    unless_null $P110, vivify_817
    new $P110, "Undef"
  vivify_817:
    find_lex $P111, "$dummy"
    unless_null $P111, vivify_818
    new $P111, "Undef"
  vivify_818:
    $P109."set_body_block"($P110, $P111)
.annotate 'line', 344
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_819
    new $P109, "Undef"
  vivify_819:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 345
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 347
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_820
    new $P116, "Undef"
  vivify_820:
    $P117 = $P115."new"($P116, "get_how PP" :named("pirop"))
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_821
    new $P118, "Undef"
  vivify_821:
.annotate 'line', 349
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$body_past"
    unless_null $P123, vivify_822
    new $P123, "Undef"
  vivify_822:
    $P124 = $P122."new"($P123 :named("value"))
    $P125 = $P111."new"($P117, $P118, $P124, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 345
    store_lex "$des", $P125
.annotate 'line', 352
    find_lex $P108, "self"
    find_lex $P109, "$des"
    unless_null $P109, vivify_823
    new $P109, "Undef"
  vivify_823:
    find_lex $P110, "$fixups"
    unless_null $P110, vivify_824
    new $P110, "Undef"
  vivify_824:
    $P111 = $P108."add_event"($P109 :named("deserialize_past"), $P110 :named("fixup_past"))
.annotate 'line', 297
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1172"  :anon :subid("31_1312646121.678") :outer("30_1312646121.678")
    .param pmc param_1174 :slurpy
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 309
    .const 'Sub' $P1182 = "33_1312646121.678" 
    capture_lex $P1182
    .const 'Sub' $P1178 = "32_1312646121.678" 
    capture_lex $P1178
    .lex "@type_args", param_1174
.annotate 'line', 311
    new $P108, "Undef"
    set $P1175, $P108
    .lex "$invoke_body", $P1175
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 313
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Val"]
    find_lex $P117, "$body_past"
    unless_null $P117, vivify_799
    new $P117, "Undef"
  vivify_799:
    $P118 = $P116."new"($P117 :named("value"))
    $P119 = $P112."new"($P118, "call" :named("pasttype"))
.annotate 'line', 311
    store_lex "$invoke_body", $P119
.annotate 'line', 315
    find_lex $P1176, "@type_args"
    unless_null $P1176, vivify_800
    $P1176 = root_new ['parrot';'ResizablePMCArray']
  vivify_800:
    defined $I100, $P1176
    unless $I100, for_undef_801
    iter $P109, $P1176
    new $P111, 'ExceptionHandler'
    set_label $P111, loop1180_handler
    $P111."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P111
  loop1180_test:
    unless $P109, loop1180_done
    shift $P110, $P109
  loop1180_redo:
    .const 'Sub' $P1178 = "32_1312646121.678" 
    capture_lex $P1178
    $P1178($P110)
  loop1180_next:
    goto loop1180_test
  loop1180_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1180_next
    eq $P112, .CONTROL_LOOP_REDO, loop1180_redo
  loop1180_done:
    pop_eh 
  for_undef_801:
.annotate 'line', 318
    find_lex $P109, "$fixups"
    unless_null $P109, vivify_804
    new $P109, "Undef"
  vivify_804:
    find_lex $P110, "$invoke_body"
    unless_null $P110, vivify_805
    new $P110, "Undef"
  vivify_805:
    $P109."push"($P110)
.annotate 'line', 321
    find_lex $P110, "$obj"
    unless_null $P110, vivify_806
    new $P110, "Undef"
  vivify_806:
    get_how $P111, $P110
    find_lex $P112, "$obj"
    unless_null $P112, vivify_807
    new $P112, "Undef"
  vivify_807:
    $P113 = $P111."methods"($P112, 1 :named("local"))
    defined $I100, $P113
    unless $I100, for_undef_808
    iter $P109, $P113
    new $P115, 'ExceptionHandler'
    set_label $P115, loop1189_handler
    $P115."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P115
  loop1189_test:
    unless $P109, loop1189_done
    shift $P114, $P109
  loop1189_redo:
    .const 'Sub' $P1182 = "33_1312646121.678" 
    capture_lex $P1182
    $P1182($P114)
  loop1189_next:
    goto loop1189_test
  loop1189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P116, exception, 'type'
    eq $P116, .CONTROL_LOOP_NEXT, loop1189_next
    eq $P116, .CONTROL_LOOP_REDO, loop1189_redo
  loop1189_done:
    pop_eh 
  for_undef_808:
.annotate 'line', 309
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1177"  :anon :subid("32_1312646121.678") :outer("31_1312646121.678")
    .param pmc param_1179
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 315
    .lex "$_", param_1179
.annotate 'line', 316
    find_lex $P111, "$invoke_body"
    unless_null $P111, vivify_802
    new $P111, "Undef"
  vivify_802:
    find_lex $P112, "self"
    find_lex $P113, "$_"
    unless_null $P113, vivify_803
    new $P113, "Undef"
  vivify_803:
    $P114 = $P112."get_slot_past_for_object"($P113)
    $P115 = $P111."push"($P114)
.annotate 'line', 315
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1181"  :anon :subid("33_1312646121.678") :outer("31_1312646121.678")
    .param pmc param_1183
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 321
    .const 'Sub' $P1185 = "34_1312646121.678" 
    capture_lex $P1185
    .lex "$_", param_1183
.annotate 'line', 322
    find_lex $P115, "$_"
    unless_null $P115, vivify_809
    new $P115, "Undef"
  vivify_809:
    .const 'Sub' $P1185 = "34_1312646121.678" 
    newclosure $P1188, $P1185
    setprop $P115, "REIFY_CALLBACK", $P1188
.annotate 'line', 321
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1184"  :anon :subid("34_1312646121.678") :outer("33_1312646121.678")
    .param pmc param_1186
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 322
    .lex "$meth", param_1186
.annotate 'line', 324
    new $P116, "Undef"
    set $P1187, $P116
    .lex "$clone", $P1187
    find_lex $P117, "$meth"
    unless_null $P117, vivify_810
    new $P117, "Undef"
  vivify_810:
    clone $P118, $P117
    store_lex "$clone", $P118
.annotate 'line', 325
    find_lex $P117, "self"
    find_lex $P118, "$clone"
    unless_null $P118, vivify_811
    new $P118, "Undef"
  vivify_811:
    $P117."add_code"($P118)
.annotate 'line', 328
    find_lex $P117, "$fixups"
    unless_null $P117, vivify_812
    new $P117, "Undef"
  vivify_812:
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 330
    find_lex $P122, "self"
    find_lex $P123, "$clone"
    unless_null $P123, vivify_813
    new $P123, "Undef"
  vivify_813:
    $P124 = $P122."get_slot_past_for_object"($P123)
.annotate 'line', 331
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "PAST"
    get_who $P127, $P126
    set $P128, $P127["Val"]
    find_lex $P129, "$meth"
    unless_null $P129, vivify_814
    new $P129, "Undef"
  vivify_814:
    getprop $P130, "PAST", $P129
    $P131 = $P128."new"($P130 :named("value"))
    $P132 = $P121."new"($P124, $P131, "assign vPP" :named("pirop"))
.annotate 'line', 328
    $P117."push"($P132)
.annotate 'line', 322
    find_lex $P117, "$clone"
    unless_null $P117, vivify_815
    new $P117, "Undef"
  vivify_815:
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role" :anon :subid("35_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1192
    .param pmc param_1193
    .param pmc param_1194
    .param pmc param_1195
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 357
    .lex "self", param_1192
    .lex "$obj", param_1193
    .lex "$meta_method_name", param_1194
    .lex "$to_add", param_1195
.annotate 'line', 362
    new $P104, "Undef"
    set $P1196, $P104
    .lex "$slot_past", $P1196
.annotate 'line', 359
    find_lex $P105, "$obj"
    unless_null $P105, vivify_825
    new $P105, "Undef"
  vivify_825:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_826
    new $P107, "Undef"
  vivify_826:
    find_lex $P108, "$to_add"
    unless_null $P108, vivify_827
    new $P108, "Undef"
  vivify_827:
    find_lex $P109, "$meta_method_name"
    unless_null $P109, vivify_828
    new $P109, "Undef"
  vivify_828:
    set $S100, $P109
    $P106.$S100($P107, $P108)
.annotate 'line', 362
    find_lex $P105, "self"
    find_lex $P106, "$obj"
    unless_null $P106, vivify_829
    new $P106, "Undef"
  vivify_829:
    $P107 = $P105."get_slot_past_for_object"($P106)
    store_lex "$slot_past", $P107
.annotate 'line', 363
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
    find_lex $P110, "$meta_method_name"
    unless_null $P110, vivify_830
    new $P110, "Undef"
  vivify_830:
.annotate 'line', 365
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
    find_lex $P115, "$slot_past"
    unless_null $P115, vivify_831
    new $P115, "Undef"
  vivify_831:
    $P116 = $P114."new"($P115, "get_how PP" :named("pirop"))
    find_lex $P117, "$slot_past"
    unless_null $P117, vivify_832
    new $P117, "Undef"
  vivify_832:
.annotate 'line', 367
    find_lex $P118, "self"
    find_lex $P119, "$to_add"
    unless_null $P119, vivify_833
    new $P119, "Undef"
  vivify_833:
    $P120 = $P118."get_object_sc_ref_past"($P119)
    $P121 = $P109."new"($P116, $P117, $P120, "callmethod" :named("pasttype"), $P110 :named("name"))
.annotate 'line', 363
    $P122 = $P105."add_event"($P121 :named("deserialize_past"))
.annotate 'line', 357
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("36_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1198
    .param pmc param_1199
    .param pmc param_1200
    .param pmc param_1201
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 371
    .lex "self", param_1198
    .lex "$obj", param_1199
    .lex "$name", param_1200
    .lex "$att_name", param_1201
.annotate 'line', 376
    new $P104, "Undef"
    set $P1202, $P104
    .lex "$slot_past", $P1202
.annotate 'line', 373
    find_lex $P105, "$obj"
    unless_null $P105, vivify_834
    new $P105, "Undef"
  vivify_834:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_835
    new $P107, "Undef"
  vivify_835:
    find_lex $P108, "$name"
    unless_null $P108, vivify_836
    new $P108, "Undef"
  vivify_836:
    find_lex $P109, "$att_name"
    unless_null $P109, vivify_837
    new $P109, "Undef"
  vivify_837:
    $P106."add_parrot_vtable_handler_mapping"($P107, $P108, $P109)
.annotate 'line', 376
    find_lex $P105, "self"
    find_lex $P106, "$obj"
    unless_null $P106, vivify_838
    new $P106, "Undef"
  vivify_838:
    $P107 = $P105."get_slot_past_for_object"($P106)
    store_lex "$slot_past", $P107
.annotate 'line', 377
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 379
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    find_lex $P114, "$slot_past"
    unless_null $P114, vivify_839
    new $P114, "Undef"
  vivify_839:
    $P115 = $P113."new"($P114, "get_how PP" :named("pirop"))
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_840
    new $P116, "Undef"
  vivify_840:
    find_lex $P117, "$name"
    unless_null $P117, vivify_841
    new $P117, "Undef"
  vivify_841:
    find_lex $P118, "$att_name"
    unless_null $P118, vivify_842
    new $P118, "Undef"
  vivify_842:
    $P119 = $P109."new"($P115, $P116, $P117, $P118, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 377
    $P120 = $P105."add_event"($P119 :named("deserialize_past"))
.annotate 'line', 371
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose" :anon :subid("37_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1204
    .param pmc param_1205
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 386
    .lex "self", param_1204
    .lex "$obj", param_1205
.annotate 'line', 391
    new $P104, "Undef"
    set $P1206, $P104
    .lex "$slot_past", $P1206
.annotate 'line', 388
    find_lex $P105, "$obj"
    unless_null $P105, vivify_843
    new $P105, "Undef"
  vivify_843:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_844
    new $P107, "Undef"
  vivify_844:
    $P106."compose"($P107)
.annotate 'line', 391
    find_lex $P105, "self"
    find_lex $P106, "$obj"
    unless_null $P106, vivify_845
    new $P106, "Undef"
  vivify_845:
    $P107 = $P105."get_slot_past_for_object"($P106)
    store_lex "$slot_past", $P107
.annotate 'line', 392
    find_lex $P105, "self"
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 394
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    find_lex $P114, "$slot_past"
    unless_null $P114, vivify_846
    new $P114, "Undef"
  vivify_846:
    $P115 = $P113."new"($P114, "get_how PP" :named("pirop"))
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_847
    new $P116, "Undef"
  vivify_847:
    $P117 = $P109."new"($P115, $P116, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 392
    $P118 = $P105."add_event"($P117 :named("deserialize_past"))
.annotate 'line', 386
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("38_1312646121.678") :outer("13_1312646121.678")
    .param pmc param_1208
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 401
    .const 'Sub' $P1212 = "39_1312646121.678" 
    capture_lex $P1212
    .lex "self", param_1208
.annotate 'line', 402
    new $P104, "Undef"
    set $P1209, $P104
    .lex "$des", $P1209
.annotate 'line', 403
    new $P105, "Undef"
    set $P1210, $P105
    .lex "$fix", $P1210
.annotate 'line', 402
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    store_lex "$des", $P110
.annotate 'line', 403
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    store_lex "$fix", $P110
.annotate 'line', 404
    find_lex $P107, "self"
    $P108 = $P107."event_stream"()
    defined $I100, $P108
    unless $I100, for_undef_848
    iter $P106, $P108
    new $P111, 'ExceptionHandler'
    set_label $P111, loop1216_handler
    $P111."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P111
  loop1216_test:
    unless $P106, loop1216_done
    shift $P109, $P106
  loop1216_redo:
    .const 'Sub' $P1212 = "39_1312646121.678" 
    capture_lex $P1212
    $P1212($P109)
  loop1216_next:
    goto loop1216_test
  loop1216_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1216_next
    eq $P112, .CONTROL_LOOP_REDO, loop1216_redo
  loop1216_done:
    pop_eh 
  for_undef_848:
.annotate 'line', 408
    find_dynamic_lex $P106, "$/"
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
.annotate 'line', 410
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 412
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    find_lex $P119, "self"
    $P120 = $P119."handle"()
    $P121 = $P118."new"($P120, "nqp_get_sc Ps" :named("pirop"))
    $P122 = $P114."new"($P121, "isnull IP" :named("pirop"))
.annotate 'line', 414
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Stmts"]
.annotate 'line', 415
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    $P131 = $P130."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 416
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 418
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
    $P140 = $P139."new"("getinterp P" :named("pirop"))
.annotate 'line', 419
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Op"]
    $P145 = $P144."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 420
    get_hll_global $P146, "GLOBAL"
    nqp_get_package_through_who $P147, $P146, "PAST"
    get_who $P148, $P147
    set $P149, $P148["Op"]
    $P150 = $P149."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P151 = $P135."new"($P140, $P145, $P150, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 422
    get_hll_global $P152, "GLOBAL"
    nqp_get_package_through_who $P153, $P152, "PAST"
    get_who $P154, $P153
    set $P155, $P154["Op"]
.annotate 'line', 424
    get_hll_global $P156, "GLOBAL"
    nqp_get_package_through_who $P157, $P156, "PAST"
    get_who $P158, $P157
    set $P159, $P158["Var"]
    $P160 = $P159."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 425
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Op"]
    find_lex $P165, "self"
    $P166 = $P165."handle"()
    $P167 = $P164."new"($P166, "nqp_create_sc Ps" :named("pirop"))
    $P168 = $P155."new"($P160, $P167, "bind_6model" :named("pasttype"))
.annotate 'line', 427
    get_hll_global $P169, "GLOBAL"
    nqp_get_package_through_who $P170, $P169, "PAST"
    get_who $P171, $P170
    set $P172, $P171["Op"]
.annotate 'line', 429
    get_hll_global $P173, "GLOBAL"
    nqp_get_package_through_who $P174, $P173, "PAST"
    get_who $P175, $P174
    set $P176, $P175["Var"]
    $P177 = $P176."new"("cur_sc" :named("name"), "register" :named("scope"))
.annotate 'line', 430
    find_lex $P178, "self"
    $P179 = $P178."sc"()
    $P180 = $P179."description"()
    $P181 = $P172."new"($P177, $P180, "callmethod" :named("pasttype"), "set_description" :named("name"))
.annotate 'line', 427
    find_lex $P182, "$des"
    unless_null $P182, vivify_855
    new $P182, "Undef"
  vivify_855:
    $P183 = $P126."new"($P131, $P151, $P168, $P181, $P182)
.annotate 'line', 414
    find_lex $P184, "$fix"
    unless_null $P184, vivify_856
    new $P184, "Undef"
  vivify_856:
    $P185 = $P110."new"($P122, $P183, $P184, "if" :named("pasttype"))
.annotate 'line', 408
    $P186 = $P106."!make"($P185)
.annotate 'line', 401
    .return ($P186)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1211"  :anon :subid("39_1312646121.678") :outer("38_1312646121.678")
    .param pmc param_1213
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 404
    .lex "$_", param_1213
.annotate 'line', 405
    find_lex $P110, "$_"
    unless_null $P110, vivify_849
    new $P110, "Undef"
  vivify_849:
    $P111 = $P110."deserialize_past"()
    defined $I101, $P111
    unless $I101, if_1214_end
    find_lex $P112, "$des"
    unless_null $P112, vivify_850
    new $P112, "Undef"
  vivify_850:
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Stmt"]
    find_lex $P117, "$_"
    unless_null $P117, vivify_851
    new $P117, "Undef"
  vivify_851:
    $P118 = $P117."deserialize_past"()
    $P119 = $P116."new"($P118)
    $P112."push"($P119)
  if_1214_end:
.annotate 'line', 406
    find_lex $P111, "$_"
    unless_null $P111, vivify_852
    new $P111, "Undef"
  vivify_852:
    $P112 = $P111."fixup_past"()
    defined $I101, $P112
    if $I101, if_1215
    new $P110, 'Integer'
    set $P110, $I101
    goto if_1215_end
  if_1215:
    find_lex $P113, "$fix"
    unless_null $P113, vivify_853
    new $P113, "Undef"
  vivify_853:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Stmt"]
    find_lex $P118, "$_"
    unless_null $P118, vivify_854
    new $P118, "Undef"
  vivify_854:
    $P119 = $P118."fixup_past"()
    $P120 = $P117."new"($P119)
    $P121 = $P113."push"($P120)
    set $P110, $P121
  if_1215_end:
.annotate 'line', 404
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1218"  :subid("40_1312646121.678") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P2314 = "418_1312646121.678" 
    capture_lex $P2314
    .const 'Sub' $P2313 = "417_1312646121.678" 
    capture_lex $P2313
    .const 'Sub' $P2309 = "416_1312646121.678" 
    capture_lex $P2309
    .const 'Sub' $P2308 = "415_1312646121.678" 
    capture_lex $P2308
    .const 'Sub' $P2304 = "414_1312646121.678" 
    capture_lex $P2304
    .const 'Sub' $P2303 = "413_1312646121.678" 
    capture_lex $P2303
    .const 'Sub' $P2299 = "412_1312646121.678" 
    capture_lex $P2299
    .const 'Sub' $P2298 = "411_1312646121.678" 
    capture_lex $P2298
    .const 'Sub' $P2294 = "410_1312646121.678" 
    capture_lex $P2294
    .const 'Sub' $P2293 = "409_1312646121.678" 
    capture_lex $P2293
    .const 'Sub' $P2287 = "407_1312646121.678" 
    capture_lex $P2287
    .const 'Sub' $P2286 = "406_1312646121.678" 
    capture_lex $P2286
    .const 'Sub' $P2282 = "405_1312646121.678" 
    capture_lex $P2282
    .const 'Sub' $P2281 = "404_1312646121.678" 
    capture_lex $P2281
    .const 'Sub' $P2277 = "403_1312646121.678" 
    capture_lex $P2277
    .const 'Sub' $P2276 = "402_1312646121.678" 
    capture_lex $P2276
    .const 'Sub' $P2272 = "401_1312646121.678" 
    capture_lex $P2272
    .const 'Sub' $P2271 = "400_1312646121.678" 
    capture_lex $P2271
    .const 'Sub' $P2267 = "399_1312646121.678" 
    capture_lex $P2267
    .const 'Sub' $P2266 = "398_1312646121.678" 
    capture_lex $P2266
    .const 'Sub' $P2263 = "397_1312646121.678" 
    capture_lex $P2263
    .const 'Sub' $P2262 = "396_1312646121.678" 
    capture_lex $P2262
    .const 'Sub' $P2258 = "395_1312646121.678" 
    capture_lex $P2258
    .const 'Sub' $P2257 = "394_1312646121.678" 
    capture_lex $P2257
    .const 'Sub' $P2253 = "393_1312646121.678" 
    capture_lex $P2253
    .const 'Sub' $P2252 = "392_1312646121.678" 
    capture_lex $P2252
    .const 'Sub' $P2248 = "391_1312646121.678" 
    capture_lex $P2248
    .const 'Sub' $P2247 = "390_1312646121.678" 
    capture_lex $P2247
    .const 'Sub' $P2243 = "389_1312646121.678" 
    capture_lex $P2243
    .const 'Sub' $P2242 = "388_1312646121.678" 
    capture_lex $P2242
    .const 'Sub' $P2238 = "387_1312646121.678" 
    capture_lex $P2238
    .const 'Sub' $P2237 = "386_1312646121.678" 
    capture_lex $P2237
    .const 'Sub' $P2233 = "385_1312646121.678" 
    capture_lex $P2233
    .const 'Sub' $P2232 = "384_1312646121.678" 
    capture_lex $P2232
    .const 'Sub' $P2228 = "383_1312646121.678" 
    capture_lex $P2228
    .const 'Sub' $P2227 = "382_1312646121.678" 
    capture_lex $P2227
    .const 'Sub' $P2223 = "381_1312646121.678" 
    capture_lex $P2223
    .const 'Sub' $P2222 = "380_1312646121.678" 
    capture_lex $P2222
    .const 'Sub' $P2218 = "379_1312646121.678" 
    capture_lex $P2218
    .const 'Sub' $P2217 = "378_1312646121.678" 
    capture_lex $P2217
    .const 'Sub' $P2213 = "377_1312646121.678" 
    capture_lex $P2213
    .const 'Sub' $P2212 = "376_1312646121.678" 
    capture_lex $P2212
    .const 'Sub' $P2208 = "375_1312646121.678" 
    capture_lex $P2208
    .const 'Sub' $P2207 = "374_1312646121.678" 
    capture_lex $P2207
    .const 'Sub' $P2203 = "373_1312646121.678" 
    capture_lex $P2203
    .const 'Sub' $P2202 = "372_1312646121.678" 
    capture_lex $P2202
    .const 'Sub' $P2198 = "371_1312646121.678" 
    capture_lex $P2198
    .const 'Sub' $P2197 = "370_1312646121.678" 
    capture_lex $P2197
    .const 'Sub' $P2193 = "369_1312646121.678" 
    capture_lex $P2193
    .const 'Sub' $P2192 = "368_1312646121.678" 
    capture_lex $P2192
    .const 'Sub' $P2188 = "367_1312646121.678" 
    capture_lex $P2188
    .const 'Sub' $P2187 = "366_1312646121.678" 
    capture_lex $P2187
    .const 'Sub' $P2183 = "365_1312646121.678" 
    capture_lex $P2183
    .const 'Sub' $P2182 = "364_1312646121.678" 
    capture_lex $P2182
    .const 'Sub' $P2178 = "363_1312646121.678" 
    capture_lex $P2178
    .const 'Sub' $P2177 = "362_1312646121.678" 
    capture_lex $P2177
    .const 'Sub' $P2173 = "361_1312646121.678" 
    capture_lex $P2173
    .const 'Sub' $P2172 = "360_1312646121.678" 
    capture_lex $P2172
    .const 'Sub' $P2168 = "359_1312646121.678" 
    capture_lex $P2168
    .const 'Sub' $P2167 = "358_1312646121.678" 
    capture_lex $P2167
    .const 'Sub' $P2163 = "357_1312646121.678" 
    capture_lex $P2163
    .const 'Sub' $P2162 = "356_1312646121.678" 
    capture_lex $P2162
    .const 'Sub' $P2158 = "355_1312646121.678" 
    capture_lex $P2158
    .const 'Sub' $P2157 = "354_1312646121.678" 
    capture_lex $P2157
    .const 'Sub' $P2153 = "353_1312646121.678" 
    capture_lex $P2153
    .const 'Sub' $P2152 = "352_1312646121.678" 
    capture_lex $P2152
    .const 'Sub' $P2148 = "351_1312646121.678" 
    capture_lex $P2148
    .const 'Sub' $P2147 = "350_1312646121.678" 
    capture_lex $P2147
    .const 'Sub' $P2143 = "349_1312646121.678" 
    capture_lex $P2143
    .const 'Sub' $P2142 = "348_1312646121.678" 
    capture_lex $P2142
    .const 'Sub' $P2138 = "347_1312646121.678" 
    capture_lex $P2138
    .const 'Sub' $P2137 = "346_1312646121.678" 
    capture_lex $P2137
    .const 'Sub' $P2133 = "345_1312646121.678" 
    capture_lex $P2133
    .const 'Sub' $P2132 = "344_1312646121.678" 
    capture_lex $P2132
    .const 'Sub' $P2128 = "343_1312646121.678" 
    capture_lex $P2128
    .const 'Sub' $P2127 = "342_1312646121.678" 
    capture_lex $P2127
    .const 'Sub' $P2123 = "341_1312646121.678" 
    capture_lex $P2123
    .const 'Sub' $P2122 = "340_1312646121.678" 
    capture_lex $P2122
    .const 'Sub' $P2118 = "339_1312646121.678" 
    capture_lex $P2118
    .const 'Sub' $P2117 = "338_1312646121.678" 
    capture_lex $P2117
    .const 'Sub' $P2113 = "337_1312646121.678" 
    capture_lex $P2113
    .const 'Sub' $P2112 = "336_1312646121.678" 
    capture_lex $P2112
    .const 'Sub' $P2108 = "335_1312646121.678" 
    capture_lex $P2108
    .const 'Sub' $P2107 = "334_1312646121.678" 
    capture_lex $P2107
    .const 'Sub' $P2103 = "333_1312646121.678" 
    capture_lex $P2103
    .const 'Sub' $P2102 = "332_1312646121.678" 
    capture_lex $P2102
    .const 'Sub' $P2098 = "331_1312646121.678" 
    capture_lex $P2098
    .const 'Sub' $P2097 = "330_1312646121.678" 
    capture_lex $P2097
    .const 'Sub' $P2093 = "329_1312646121.678" 
    capture_lex $P2093
    .const 'Sub' $P2092 = "328_1312646121.678" 
    capture_lex $P2092
    .const 'Sub' $P2088 = "327_1312646121.678" 
    capture_lex $P2088
    .const 'Sub' $P2087 = "326_1312646121.678" 
    capture_lex $P2087
    .const 'Sub' $P2083 = "325_1312646121.678" 
    capture_lex $P2083
    .const 'Sub' $P2082 = "324_1312646121.678" 
    capture_lex $P2082
    .const 'Sub' $P2078 = "323_1312646121.678" 
    capture_lex $P2078
    .const 'Sub' $P2077 = "322_1312646121.678" 
    capture_lex $P2077
    .const 'Sub' $P2074 = "321_1312646121.678" 
    capture_lex $P2074
    .const 'Sub' $P2073 = "320_1312646121.678" 
    capture_lex $P2073
    .const 'Sub' $P2070 = "319_1312646121.678" 
    capture_lex $P2070
    .const 'Sub' $P2069 = "318_1312646121.678" 
    capture_lex $P2069
    .const 'Sub' $P2066 = "317_1312646121.678" 
    capture_lex $P2066
    .const 'Sub' $P2065 = "316_1312646121.678" 
    capture_lex $P2065
    .const 'Sub' $P2062 = "315_1312646121.678" 
    capture_lex $P2062
    .const 'Sub' $P2061 = "314_1312646121.678" 
    capture_lex $P2061
    .const 'Sub' $P2058 = "313_1312646121.678" 
    capture_lex $P2058
    .const 'Sub' $P2057 = "312_1312646121.678" 
    capture_lex $P2057
    .const 'Sub' $P2054 = "311_1312646121.678" 
    capture_lex $P2054
    .const 'Sub' $P2053 = "310_1312646121.678" 
    capture_lex $P2053
    .const 'Sub' $P2050 = "309_1312646121.678" 
    capture_lex $P2050
    .const 'Sub' $P2049 = "308_1312646121.678" 
    capture_lex $P2049
    .const 'Sub' $P2046 = "307_1312646121.678" 
    capture_lex $P2046
    .const 'Sub' $P2045 = "306_1312646121.678" 
    capture_lex $P2045
    .const 'Sub' $P2040 = "305_1312646121.678" 
    capture_lex $P2040
    .const 'Sub' $P2039 = "304_1312646121.678" 
    capture_lex $P2039
    .const 'Sub' $P2036 = "303_1312646121.678" 
    capture_lex $P2036
    .const 'Sub' $P2035 = "302_1312646121.678" 
    capture_lex $P2035
    .const 'Sub' $P2032 = "301_1312646121.678" 
    capture_lex $P2032
    .const 'Sub' $P2031 = "300_1312646121.678" 
    capture_lex $P2031
    .const 'Sub' $P2028 = "299_1312646121.678" 
    capture_lex $P2028
    .const 'Sub' $P2027 = "298_1312646121.678" 
    capture_lex $P2027
    .const 'Sub' $P2022 = "297_1312646121.678" 
    capture_lex $P2022
    .const 'Sub' $P2021 = "296_1312646121.678" 
    capture_lex $P2021
    .const 'Sub' $P2016 = "295_1312646121.678" 
    capture_lex $P2016
    .const 'Sub' $P2015 = "294_1312646121.678" 
    capture_lex $P2015
    .const 'Sub' $P2012 = "293_1312646121.678" 
    capture_lex $P2012
    .const 'Sub' $P2011 = "292_1312646121.678" 
    capture_lex $P2011
    .const 'Sub' $P2008 = "291_1312646121.678" 
    capture_lex $P2008
    .const 'Sub' $P2007 = "290_1312646121.678" 
    capture_lex $P2007
    .const 'Sub' $P2004 = "289_1312646121.678" 
    capture_lex $P2004
    .const 'Sub' $P2003 = "288_1312646121.678" 
    capture_lex $P2003
    .const 'Sub' $P2000 = "287_1312646121.678" 
    capture_lex $P2000
    .const 'Sub' $P1999 = "286_1312646121.678" 
    capture_lex $P1999
    .const 'Sub' $P1995 = "285_1312646121.678" 
    capture_lex $P1995
    .const 'Sub' $P1994 = "284_1312646121.678" 
    capture_lex $P1994
    .const 'Sub' $P1990 = "283_1312646121.678" 
    capture_lex $P1990
    .const 'Sub' $P1989 = "282_1312646121.678" 
    capture_lex $P1989
    .const 'Sub' $P1985 = "281_1312646121.678" 
    capture_lex $P1985
    .const 'Sub' $P1984 = "280_1312646121.678" 
    capture_lex $P1984
    .const 'Sub' $P1980 = "279_1312646121.678" 
    capture_lex $P1980
    .const 'Sub' $P1979 = "278_1312646121.678" 
    capture_lex $P1979
    .const 'Sub' $P1976 = "277_1312646121.678" 
    capture_lex $P1976
    .const 'Sub' $P1975 = "276_1312646121.678" 
    capture_lex $P1975
    .const 'Sub' $P1972 = "275_1312646121.678" 
    capture_lex $P1972
    .const 'Sub' $P1967 = "272_1312646121.678" 
    capture_lex $P1967
    .const 'Sub' $P1961 = "271_1312646121.678" 
    capture_lex $P1961
    .const 'Sub' $P1960 = "270_1312646121.678" 
    capture_lex $P1960
    .const 'Sub' $P1956 = "269_1312646121.678" 
    capture_lex $P1956
    .const 'Sub' $P1955 = "268_1312646121.678" 
    capture_lex $P1955
    .const 'Sub' $P1952 = "267_1312646121.678" 
    capture_lex $P1952
    .const 'Sub' $P1951 = "266_1312646121.678" 
    capture_lex $P1951
    .const 'Sub' $P1947 = "265_1312646121.678" 
    capture_lex $P1947
    .const 'Sub' $P1946 = "264_1312646121.678" 
    capture_lex $P1946
    .const 'Sub' $P1943 = "263_1312646121.678" 
    capture_lex $P1943
    .const 'Sub' $P1942 = "262_1312646121.678" 
    capture_lex $P1942
    .const 'Sub' $P1936 = "260_1312646121.678" 
    capture_lex $P1936
    .const 'Sub' $P1935 = "259_1312646121.678" 
    capture_lex $P1935
    .const 'Sub' $P1929 = "258_1312646121.678" 
    capture_lex $P1929
    .const 'Sub' $P1928 = "257_1312646121.678" 
    capture_lex $P1928
    .const 'Sub' $P1924 = "256_1312646121.678" 
    capture_lex $P1924
    .const 'Sub' $P1923 = "255_1312646121.678" 
    capture_lex $P1923
    .const 'Sub' $P1917 = "254_1312646121.678" 
    capture_lex $P1917
    .const 'Sub' $P1916 = "253_1312646121.678" 
    capture_lex $P1916
    .const 'Sub' $P1911 = "252_1312646121.678" 
    capture_lex $P1911
    .const 'Sub' $P1910 = "251_1312646121.678" 
    capture_lex $P1910
    .const 'Sub' $P1907 = "250_1312646121.678" 
    capture_lex $P1907
    .const 'Sub' $P1906 = "249_1312646121.678" 
    capture_lex $P1906
    .const 'Sub' $P1902 = "248_1312646121.678" 
    capture_lex $P1902
    .const 'Sub' $P1897 = "245_1312646121.678" 
    capture_lex $P1897
    .const 'Sub' $P1890 = "244_1312646121.678" 
    capture_lex $P1890
    .const 'Sub' $P1889 = "243_1312646121.678" 
    capture_lex $P1889
    .const 'Sub' $P1879 = "242_1312646121.678" 
    capture_lex $P1879
    .const 'Sub' $P1878 = "241_1312646121.678" 
    capture_lex $P1878
    .const 'Sub' $P1872 = "240_1312646121.678" 
    capture_lex $P1872
    .const 'Sub' $P1867 = "237_1312646121.678" 
    capture_lex $P1867
    .const 'Sub' $P1864 = "236_1312646121.678" 
    capture_lex $P1864
    .const 'Sub' $P1863 = "235_1312646121.678" 
    capture_lex $P1863
    .const 'Sub' $P1860 = "234_1312646121.678" 
    capture_lex $P1860
    .const 'Sub' $P1859 = "233_1312646121.678" 
    capture_lex $P1859
    .const 'Sub' $P1856 = "232_1312646121.678" 
    capture_lex $P1856
    .const 'Sub' $P1855 = "231_1312646121.678" 
    capture_lex $P1855
    .const 'Sub' $P1848 = "230_1312646121.678" 
    capture_lex $P1848
    .const 'Sub' $P1847 = "229_1312646121.678" 
    capture_lex $P1847
    .const 'Sub' $P1834 = "228_1312646121.678" 
    capture_lex $P1834
    .const 'Sub' $P1833 = "227_1312646121.678" 
    capture_lex $P1833
    .const 'Sub' $P1825 = "225_1312646121.678" 
    capture_lex $P1825
    .const 'Sub' $P1824 = "224_1312646121.678" 
    capture_lex $P1824
    .const 'Sub' $P1820 = "223_1312646121.678" 
    capture_lex $P1820
    .const 'Sub' $P1819 = "222_1312646121.678" 
    capture_lex $P1819
    .const 'Sub' $P1813 = "221_1312646121.678" 
    capture_lex $P1813
    .const 'Sub' $P1812 = "220_1312646121.678" 
    capture_lex $P1812
    .const 'Sub' $P1806 = "219_1312646121.678" 
    capture_lex $P1806
    .const 'Sub' $P1801 = "216_1312646121.678" 
    capture_lex $P1801
    .const 'Sub' $P1796 = "214_1312646121.678" 
    capture_lex $P1796
    .const 'Sub' $P1795 = "213_1312646121.678" 
    capture_lex $P1795
    .const 'Sub' $P1780 = "211_1312646121.678" 
    capture_lex $P1780
    .const 'Sub' $P1779 = "210_1312646121.678" 
    capture_lex $P1779
    .const 'Sub' $P1768 = "209_1312646121.678" 
    capture_lex $P1768
    .const 'Sub' $P1767 = "208_1312646121.678" 
    capture_lex $P1767
    .const 'Sub' $P1763 = "207_1312646121.678" 
    capture_lex $P1763
    .const 'Sub' $P1762 = "206_1312646121.678" 
    capture_lex $P1762
    .const 'Sub' $P1758 = "205_1312646121.678" 
    capture_lex $P1758
    .const 'Sub' $P1753 = "202_1312646121.678" 
    capture_lex $P1753
    .const 'Sub' $P1743 = "200_1312646121.678" 
    capture_lex $P1743
    .const 'Sub' $P1742 = "199_1312646121.678" 
    capture_lex $P1742
    .const 'Sub' $P1738 = "198_1312646121.678" 
    capture_lex $P1738
    .const 'Sub' $P1737 = "197_1312646121.678" 
    capture_lex $P1737
    .const 'Sub' $P1730 = "195_1312646121.678" 
    capture_lex $P1730
    .const 'Sub' $P1729 = "194_1312646121.678" 
    capture_lex $P1729
    .const 'Sub' $P1724 = "193_1312646121.678" 
    capture_lex $P1724
    .const 'Sub' $P1723 = "192_1312646121.678" 
    capture_lex $P1723
    .const 'Sub' $P1719 = "191_1312646121.678" 
    capture_lex $P1719
    .const 'Sub' $P1718 = "190_1312646121.678" 
    capture_lex $P1718
    .const 'Sub' $P1714 = "189_1312646121.678" 
    capture_lex $P1714
    .const 'Sub' $P1713 = "188_1312646121.678" 
    capture_lex $P1713
    .const 'Sub' $P1709 = "187_1312646121.678" 
    capture_lex $P1709
    .const 'Sub' $P1704 = "184_1312646121.678" 
    capture_lex $P1704
    .const 'Sub' $P1660 = "182_1312646121.678" 
    capture_lex $P1660
    .const 'Sub' $P1659 = "181_1312646121.678" 
    capture_lex $P1659
    .const 'Sub' $P1653 = "180_1312646121.678" 
    capture_lex $P1653
    .const 'Sub' $P1652 = "179_1312646121.678" 
    capture_lex $P1652
    .const 'Sub' $P1646 = "178_1312646121.678" 
    capture_lex $P1646
    .const 'Sub' $P1645 = "177_1312646121.678" 
    capture_lex $P1645
    .const 'Sub' $P1639 = "176_1312646121.678" 
    capture_lex $P1639
    .const 'Sub' $P1638 = "175_1312646121.678" 
    capture_lex $P1638
    .const 'Sub' $P1632 = "174_1312646121.678" 
    capture_lex $P1632
    .const 'Sub' $P1631 = "173_1312646121.678" 
    capture_lex $P1631
    .const 'Sub' $P1625 = "172_1312646121.678" 
    capture_lex $P1625
    .const 'Sub' $P1624 = "171_1312646121.678" 
    capture_lex $P1624
    .const 'Sub' $P1618 = "170_1312646121.678" 
    capture_lex $P1618
    .const 'Sub' $P1617 = "169_1312646121.678" 
    capture_lex $P1617
    .const 'Sub' $P1611 = "168_1312646121.678" 
    capture_lex $P1611
    .const 'Sub' $P1606 = "165_1312646121.678" 
    capture_lex $P1606
    .const 'Sub' $P1603 = "164_1312646121.678" 
    capture_lex $P1603
    .const 'Sub' $P1602 = "163_1312646121.678" 
    capture_lex $P1602
    .const 'Sub' $P1599 = "162_1312646121.678" 
    capture_lex $P1599
    .const 'Sub' $P1598 = "161_1312646121.678" 
    capture_lex $P1598
    .const 'Sub' $P1590 = "160_1312646121.678" 
    capture_lex $P1590
    .const 'Sub' $P1589 = "159_1312646121.678" 
    capture_lex $P1589
    .const 'Sub' $P1582 = "158_1312646121.678" 
    capture_lex $P1582
    .const 'Sub' $P1581 = "157_1312646121.678" 
    capture_lex $P1581
    .const 'Sub' $P1577 = "156_1312646121.678" 
    capture_lex $P1577
    .const 'Sub' $P1576 = "155_1312646121.678" 
    capture_lex $P1576
    .const 'Sub' $P1573 = "154_1312646121.678" 
    capture_lex $P1573
    .const 'Sub' $P1572 = "153_1312646121.678" 
    capture_lex $P1572
    .const 'Sub' $P1569 = "152_1312646121.678" 
    capture_lex $P1569
    .const 'Sub' $P1568 = "151_1312646121.678" 
    capture_lex $P1568
    .const 'Sub' $P1565 = "150_1312646121.678" 
    capture_lex $P1565
    .const 'Sub' $P1564 = "149_1312646121.678" 
    capture_lex $P1564
    .const 'Sub' $P1551 = "146_1312646121.678" 
    capture_lex $P1551
    .const 'Sub' $P1550 = "145_1312646121.678" 
    capture_lex $P1550
    .const 'Sub' $P1547 = "144_1312646121.678" 
    capture_lex $P1547
    .const 'Sub' $P1546 = "143_1312646121.678" 
    capture_lex $P1546
    .const 'Sub' $P1543 = "142_1312646121.678" 
    capture_lex $P1543
    .const 'Sub' $P1542 = "141_1312646121.678" 
    capture_lex $P1542
    .const 'Sub' $P1539 = "140_1312646121.678" 
    capture_lex $P1539
    .const 'Sub' $P1538 = "139_1312646121.678" 
    capture_lex $P1538
    .const 'Sub' $P1535 = "138_1312646121.678" 
    capture_lex $P1535
    .const 'Sub' $P1534 = "137_1312646121.678" 
    capture_lex $P1534
    .const 'Sub' $P1531 = "136_1312646121.678" 
    capture_lex $P1531
    .const 'Sub' $P1530 = "135_1312646121.678" 
    capture_lex $P1530
    .const 'Sub' $P1527 = "134_1312646121.678" 
    capture_lex $P1527
    .const 'Sub' $P1526 = "133_1312646121.678" 
    capture_lex $P1526
    .const 'Sub' $P1522 = "132_1312646121.678" 
    capture_lex $P1522
    .const 'Sub' $P1521 = "131_1312646121.678" 
    capture_lex $P1521
    .const 'Sub' $P1517 = "130_1312646121.678" 
    capture_lex $P1517
    .const 'Sub' $P1516 = "129_1312646121.678" 
    capture_lex $P1516
    .const 'Sub' $P1512 = "128_1312646121.678" 
    capture_lex $P1512
    .const 'Sub' $P1507 = "125_1312646121.678" 
    capture_lex $P1507
    .const 'Sub' $P1503 = "124_1312646121.678" 
    capture_lex $P1503
    .const 'Sub' $P1502 = "123_1312646121.678" 
    capture_lex $P1502
    .const 'Sub' $P1498 = "122_1312646121.678" 
    capture_lex $P1498
    .const 'Sub' $P1493 = "119_1312646121.678" 
    capture_lex $P1493
    .const 'Sub' $P1489 = "118_1312646121.678" 
    capture_lex $P1489
    .const 'Sub' $P1488 = "117_1312646121.678" 
    capture_lex $P1488
    .const 'Sub' $P1484 = "116_1312646121.678" 
    capture_lex $P1484
    .const 'Sub' $P1483 = "115_1312646121.678" 
    capture_lex $P1483
    .const 'Sub' $P1479 = "114_1312646121.678" 
    capture_lex $P1479
    .const 'Sub' $P1474 = "111_1312646121.678" 
    capture_lex $P1474
    .const 'Sub' $P1470 = "110_1312646121.678" 
    capture_lex $P1470
    .const 'Sub' $P1469 = "109_1312646121.678" 
    capture_lex $P1469
    .const 'Sub' $P1465 = "108_1312646121.678" 
    capture_lex $P1465
    .const 'Sub' $P1464 = "107_1312646121.678" 
    capture_lex $P1464
    .const 'Sub' $P1460 = "106_1312646121.678" 
    capture_lex $P1460
    .const 'Sub' $P1459 = "105_1312646121.678" 
    capture_lex $P1459
    .const 'Sub' $P1450 = "104_1312646121.678" 
    capture_lex $P1450
    .const 'Sub' $P1449 = "103_1312646121.678" 
    capture_lex $P1449
    .const 'Sub' $P1444 = "102_1312646121.678" 
    capture_lex $P1444
    .const 'Sub' $P1443 = "101_1312646121.678" 
    capture_lex $P1443
    .const 'Sub' $P1434 = "99_1312646121.678" 
    capture_lex $P1434
    .const 'Sub' $P1433 = "98_1312646121.678" 
    capture_lex $P1433
    .const 'Sub' $P1427 = "97_1312646121.678" 
    capture_lex $P1427
    .const 'Sub' $P1426 = "96_1312646121.678" 
    capture_lex $P1426
    .const 'Sub' $P1422 = "95_1312646121.678" 
    capture_lex $P1422
    .const 'Sub' $P1417 = "92_1312646121.678" 
    capture_lex $P1417
    .const 'Sub' $P1414 = "91_1312646121.678" 
    capture_lex $P1414
    .const 'Sub' $P1413 = "90_1312646121.678" 
    capture_lex $P1413
    .const 'Sub' $P1410 = "89_1312646121.678" 
    capture_lex $P1410
    .const 'Sub' $P1405 = "86_1312646121.678" 
    capture_lex $P1405
    .const 'Sub' $P1402 = "85_1312646121.678" 
    capture_lex $P1402
    .const 'Sub' $P1401 = "84_1312646121.678" 
    capture_lex $P1401
    .const 'Sub' $P1398 = "83_1312646121.678" 
    capture_lex $P1398
    .const 'Sub' $P1397 = "82_1312646121.678" 
    capture_lex $P1397
    .const 'Sub' $P1394 = "81_1312646121.678" 
    capture_lex $P1394
    .const 'Sub' $P1393 = "80_1312646121.678" 
    capture_lex $P1393
    .const 'Sub' $P1390 = "79_1312646121.678" 
    capture_lex $P1390
    .const 'Sub' $P1389 = "78_1312646121.678" 
    capture_lex $P1389
    .const 'Sub' $P1386 = "77_1312646121.678" 
    capture_lex $P1386
    .const 'Sub' $P1385 = "76_1312646121.678" 
    capture_lex $P1385
    .const 'Sub' $P1379 = "75_1312646121.678" 
    capture_lex $P1379
    .const 'Sub' $P1378 = "74_1312646121.678" 
    capture_lex $P1378
    .const 'Sub' $P1374 = "73_1312646121.678" 
    capture_lex $P1374
    .const 'Sub' $P1373 = "72_1312646121.678" 
    capture_lex $P1373
    .const 'Sub' $P1369 = "71_1312646121.678" 
    capture_lex $P1369
    .const 'Sub' $P1368 = "70_1312646121.678" 
    capture_lex $P1368
    .const 'Sub' $P1364 = "69_1312646121.678" 
    capture_lex $P1364
    .const 'Sub' $P1363 = "68_1312646121.678" 
    capture_lex $P1363
    .const 'Sub' $P1360 = "67_1312646121.678" 
    capture_lex $P1360
    .const 'Sub' $P1359 = "66_1312646121.678" 
    capture_lex $P1359
    .const 'Sub' $P1355 = "65_1312646121.678" 
    capture_lex $P1355
    .const 'Sub' $P1354 = "64_1312646121.678" 
    capture_lex $P1354
    .const 'Sub' $P1341 = "62_1312646121.678" 
    capture_lex $P1341
    .const 'Sub' $P1340 = "61_1312646121.678" 
    capture_lex $P1340
    .const 'Sub' $P1335 = "60_1312646121.678" 
    capture_lex $P1335
    .const 'Sub' $P1334 = "59_1312646121.678" 
    capture_lex $P1334
    .const 'Sub' $P1325 = "58_1312646121.678" 
    capture_lex $P1325
    .const 'Sub' $P1324 = "57_1312646121.678" 
    capture_lex $P1324
    .const 'Sub' $P1288 = "55_1312646121.678" 
    capture_lex $P1288
    .const 'Sub' $P1287 = "54_1312646121.678" 
    capture_lex $P1287
    .const 'Sub' $P1274 = "52_1312646121.678" 
    capture_lex $P1274
    .const 'Sub' $P1273 = "51_1312646121.678" 
    capture_lex $P1273
    .const 'Sub' $P1264 = "50_1312646121.678" 
    capture_lex $P1264
    .const 'Sub' $P1263 = "49_1312646121.678" 
    capture_lex $P1263
    .const 'Sub' $P1253 = "48_1312646121.678" 
    capture_lex $P1253
    .const 'Sub' $P1252 = "47_1312646121.678" 
    capture_lex $P1252
    .const 'Sub' $P1247 = "46_1312646121.678" 
    capture_lex $P1247
    .const 'Sub' $P1246 = "45_1312646121.678" 
    capture_lex $P1246
    .const 'Sub' $P1241 = "44_1312646121.678" 
    capture_lex $P1241
    .const 'Sub' $P1240 = "43_1312646121.678" 
    capture_lex $P1240
    .const 'Sub' $P1236 = "42_1312646121.678" 
    capture_lex $P1236
    .const 'Sub' $P1222 = "41_1312646121.678" 
    capture_lex $P1222
    .lex "$?PACKAGE", $P1220
    .lex "$?CLASS", $P1221
.annotate 'line', 1053
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1054
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1055
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1056
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1057
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1058
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1059
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1060
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1061
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1062
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1063
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1064
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1065
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1066
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1067
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1166
    .const 'Sub' $P2314 = "418_1312646121.678" 
    newclosure $P2322, $P2314
.annotate 'line', 440
    .return ($P2322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("41_1312646121.678") :outer("40_1312646121.678")
    .param pmc param_1223
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 441
    .lex "self", param_1223
.annotate 'line', 443
    $P1225 = root_new ['parrot';'Hash']
    set $P1224, $P1225
    .lex "%*LANG", $P1224
.annotate 'line', 452
    $P1227 = root_new ['parrot';'Hash']
    set $P1226, $P1227
    .lex "%*HOW", $P1226
.annotate 'line', 459
    new $P103, "Undef"
    set $P1228, $P103
    .lex "$file", $P1228
.annotate 'line', 460
    new $P104, "Undef"
    set $P1229, $P104
    .lex "$*SC", $P1229
.annotate 'line', 464
    new $P105, "Undef"
    set $P1230, $P105
    .lex "$*SCOPE", $P1230
.annotate 'line', 465
    new $P106, "Undef"
    set $P1231, $P106
    .lex "$*MULTINESS", $P1231
.annotate 'line', 466
    new $P107, "Undef"
    set $P1232, $P107
    .lex "$*PKGDECL", $P1232
.annotate 'line', 467
    new $P108, "Undef"
    set $P1233, $P108
    .lex "$*INVOCANT_OK", $P1233
.annotate 'line', 468
    new $P109, "Undef"
    set $P1234, $P109
    .lex "$*RETURN_USED", $P1234
.annotate 'line', 441
    find_lex $P112, "%*LANG"
    unless_null $P112, vivify_857
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%LANG"]
    unless_null $P112, vivify_858
    die "Contextual %*LANG not found"
  vivify_858:
  vivify_857:
.annotate 'line', 444
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["Regex"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_859
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_860
    die "Contextual %*LANG not found"
  vivify_860:
    store_lex "%*LANG", $P116
  vivify_859:
    set $P116["Regex"], $P113
.annotate 'line', 445
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["RegexActions"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_861
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_862
    die "Contextual %*LANG not found"
  vivify_862:
    store_lex "%*LANG", $P116
  vivify_861:
    set $P116["Regex-actions"], $P113
.annotate 'line', 446
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["Grammar"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_863
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_864
    die "Contextual %*LANG not found"
  vivify_864:
    store_lex "%*LANG", $P116
  vivify_863:
    set $P116["MAIN"], $P113
.annotate 'line', 447
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["Actions"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_865
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_866
    die "Contextual %*LANG not found"
  vivify_866:
    store_lex "%*LANG", $P116
  vivify_865:
    set $P116["MAIN-actions"], $P113
.annotate 'line', 441
    find_lex $P112, "%*HOW"
    unless_null $P112, vivify_867
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%HOW"]
    unless_null $P112, vivify_868
    die "Contextual %*HOW not found"
  vivify_868:
  vivify_867:
.annotate 'line', 453
    get_knowhow $P110
    find_lex $P113, "%*HOW"
    unless_null $P113, vivify_869
    get_hll_global $P111, "GLOBAL"
    get_who $P112, $P111
    set $P113, $P112["%HOW"]
    unless_null $P113, vivify_870
    die "Contextual %*HOW not found"
  vivify_870:
    store_lex "%*HOW", $P113
  vivify_869:
    set $P113["knowhow"], $P110
.annotate 'line', 454
    get_knowhow_attribute $P110
    find_lex $P113, "%*HOW"
    unless_null $P113, vivify_871
    get_hll_global $P111, "GLOBAL"
    get_who $P112, $P111
    set $P113, $P112["%HOW"]
    unless_null $P113, vivify_872
    die "Contextual %*HOW not found"
  vivify_872:
    store_lex "%*HOW", $P113
  vivify_871:
    set $P113["knowhow-attr"], $P110
.annotate 'line', 459
    find_caller_lex $P110, "$?FILES"
    store_lex "$file", $P110
.annotate 'line', 460
    find_lex $P111, "$file"
    unless_null $P111, vivify_873
    new $P111, "Undef"
  vivify_873:
    isnull $I100, $P111
    if $I100, if_1235
.annotate 'line', 462
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P120, $P119["SymbolTable"]
    time $N101
    set $S101, $N101
    find_lex $P121, "$file"
    unless_null $P121, vivify_874
    new $P121, "Undef"
  vivify_874:
    $P122 = $P120."new"($S101 :named("handle"), $P121 :named("description"))
    set $P110, $P122
.annotate 'line', 460
    goto if_1235_end
  if_1235:
.annotate 'line', 461
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "NQP"
    get_who $P114, $P113
    set $P115, $P114["SymbolTable"]
    time $N100
    set $S100, $N100
    $P116 = $P115."new"($S100 :named("handle"))
    set $P110, $P116
  if_1235_end:
.annotate 'line', 460
    store_lex "$*SC", $P110
.annotate 'line', 464
    new $P110, "String"
    assign $P110, ""
    store_lex "$*SCOPE", $P110
.annotate 'line', 465
    new $P110, "String"
    assign $P110, ""
    store_lex "$*MULTINESS", $P110
.annotate 'line', 466
    new $P110, "String"
    assign $P110, ""
    store_lex "$*PKGDECL", $P110
.annotate 'line', 467
    new $P110, "Float"
    assign $P110, 0
    store_lex "$*INVOCANT_OK", $P110
.annotate 'line', 468
    new $P110, "Float"
    assign $P110, 0
    store_lex "$*RETURN_USED", $P110
.annotate 'line', 469
    find_lex $P110, "self"
    $P111 = $P110."comp_unit"()
.annotate 'line', 441
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("42_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_875
    rx1237_cur."!cursor_debug"("START", "identifier")
  debug_875:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1238_done
    goto rxscan1238_scan
  rxscan1238_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1238_done
  rxscan1238_scan:
    set_addr $I10, rxscan1238_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1238_done:
.annotate 'line', 474
  # rx subrule "ident" subtype=method negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."ident"()
    unless $P10, rx1237_fail
    rx1237_pos = $P10."pos"()
  # rx rxquantr1239 ** 0..*
    set_addr $I10, rxquantr1239_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1239_loop:
  # rx enumcharlist negate=0 
    ge rx1237_pos, rx1237_eos, rx1237_fail
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1237_fail
    inc rx1237_pos
  # rx subrule "ident" subtype=method negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."ident"()
    unless $P10, rx1237_fail
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1239_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1239_done
    rx1237_cur."!mark_push"(rx1237_rep, rx1237_pos, $I10)
    goto rxquantr1239_loop
  rxquantr1239_done:
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "identifier")
    if_null rx1237_debug, debug_876
    rx1237_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1237_pos)
  debug_876:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 440
    if_null rx1237_debug, debug_877
    rx1237_cur."!cursor_debug"("NEXT", "identifier")
  debug_877:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_878
    rx1237_cur."!cursor_debug"("FAIL", "identifier")
  debug_878:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("43_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ident", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("44_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    rx1242_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_879
    rx1242_cur."!cursor_debug"("START", "name")
  debug_879:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1243_done
    goto rxscan1243_scan
  rxscan1243_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1243_done
  rxscan1243_scan:
    set_addr $I10, rxscan1243_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1243_done:
.annotate 'line', 476
  # rx rxquantr1244 ** 1..*
    set_addr $I10, rxquantr1244_done
    rx1242_cur."!mark_push"(0, -1, $I10)
  rxquantr1244_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."identifier"()
    unless $P10, rx1242_fail
    goto rxsubrule1245_pass
  rxsubrule1245_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1242_fail
  rxsubrule1245_pass:
    set_addr $I10, rxsubrule1245_back
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1242_pos = $P10."pos"()
    set_addr $I10, rxquantr1244_done
    (rx1242_rep) = rx1242_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1244_done
    rx1242_cur."!mark_push"(rx1242_rep, rx1242_pos, $I10)
  # rx literal  "::"
    add $I11, rx1242_pos, 2
    gt $I11, rx1242_eos, rx1242_fail
    sub $I11, rx1242_pos, rx1242_off
    substr $S10, rx1242_tgt, $I11, 2
    ne $S10, "::", rx1242_fail
    add rx1242_pos, 2
    goto rxquantr1244_loop
  rxquantr1244_done:
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "name")
    if_null rx1242_debug, debug_880
    rx1242_cur."!cursor_debug"("PASS", "name", " at pos=", rx1242_pos)
  debug_880:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 440
    if_null rx1242_debug, debug_881
    rx1242_cur."!cursor_debug"("NEXT", "name")
  debug_881:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_882
    rx1242_cur."!cursor_debug"("FAIL", "name")
  debug_882:
    .return (rx1242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("45_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("46_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1248_tgt
    .local int rx1248_pos
    .local int rx1248_off
    .local int rx1248_eos
    .local int rx1248_rep
    .local pmc rx1248_cur
    .local pmc rx1248_debug
    (rx1248_cur, rx1248_pos, rx1248_tgt, $I10) = self."!cursor_start"()
    rx1248_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1248_cur
    .local pmc match
    .lex "$/", match
    length rx1248_eos, rx1248_tgt
    gt rx1248_pos, rx1248_eos, rx1248_done
    set rx1248_off, 0
    lt rx1248_pos, 2, rx1248_start
    sub rx1248_off, rx1248_pos, 1
    substr rx1248_tgt, rx1248_tgt, rx1248_off
  rx1248_start:
    eq $I10, 1, rx1248_restart
    if_null rx1248_debug, debug_883
    rx1248_cur."!cursor_debug"("START", "deflongname")
  debug_883:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1249_done
    goto rxscan1249_scan
  rxscan1249_loop:
    (rx1248_pos) = rx1248_cur."from"()
    inc rx1248_pos
    rx1248_cur."!cursor_from"(rx1248_pos)
    ge rx1248_pos, rx1248_eos, rxscan1249_done
  rxscan1249_scan:
    set_addr $I10, rxscan1249_loop
    rx1248_cur."!mark_push"(0, rx1248_pos, $I10)
  rxscan1249_done:
.annotate 'line', 479
  # rx subrule "identifier" subtype=capture negate=
    rx1248_cur."!cursor_pos"(rx1248_pos)
    $P10 = rx1248_cur."identifier"()
    unless $P10, rx1248_fail
    rx1248_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1248_pos = $P10."pos"()
  # rx rxquantr1250 ** 0..1
    set_addr $I10, rxquantr1250_done
    rx1248_cur."!mark_push"(0, rx1248_pos, $I10)
  rxquantr1250_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1248_cur."!cursor_pos"(rx1248_pos)
    $P10 = rx1248_cur."colonpair"()
    unless $P10, rx1248_fail
    goto rxsubrule1251_pass
  rxsubrule1251_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1248_fail
  rxsubrule1251_pass:
    set_addr $I10, rxsubrule1251_back
    rx1248_cur."!mark_push"(0, rx1248_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1248_pos = $P10."pos"()
    set_addr $I10, rxquantr1250_done
    (rx1248_rep) = rx1248_cur."!mark_commit"($I10)
  rxquantr1250_done:
.annotate 'line', 478
  # rx pass
    rx1248_cur."!cursor_pass"(rx1248_pos, "deflongname")
    if_null rx1248_debug, debug_884
    rx1248_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1248_pos)
  debug_884:
    .return (rx1248_cur)
  rx1248_restart:
.annotate 'line', 440
    if_null rx1248_debug, debug_885
    rx1248_cur."!cursor_debug"("NEXT", "deflongname")
  debug_885:
  rx1248_fail:
    (rx1248_rep, rx1248_pos, $I10, $P10) = rx1248_cur."!mark_fail"(0)
    lt rx1248_pos, -1, rx1248_done
    eq rx1248_pos, -1, rx1248_fail
    jump $I10
  rx1248_done:
    rx1248_cur."!cursor_fail"()
    if_null rx1248_debug, debug_886
    rx1248_cur."!cursor_debug"("FAIL", "deflongname")
  debug_886:
    .return (rx1248_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("47_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("48_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1254_tgt
    .local int rx1254_pos
    .local int rx1254_off
    .local int rx1254_eos
    .local int rx1254_rep
    .local pmc rx1254_cur
    .local pmc rx1254_debug
    (rx1254_cur, rx1254_pos, rx1254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1254_cur
    .local pmc match
    .lex "$/", match
    length rx1254_eos, rx1254_tgt
    gt rx1254_pos, rx1254_eos, rx1254_done
    set rx1254_off, 0
    lt rx1254_pos, 2, rx1254_start
    sub rx1254_off, rx1254_pos, 1
    substr rx1254_tgt, rx1254_tgt, rx1254_off
  rx1254_start:
    eq $I10, 1, rx1254_restart
    if_null rx1254_debug, debug_887
    rx1254_cur."!cursor_debug"("START", "ENDSTMT")
  debug_887:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1254_pos) = rx1254_cur."from"()
    inc rx1254_pos
    rx1254_cur."!cursor_from"(rx1254_pos)
    ge rx1254_pos, rx1254_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10)
  rxscan1255_done:
.annotate 'line', 486
  # rx rxquantr1256 ** 0..1
    set_addr $I10, rxquantr1256_done
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10)
  rxquantr1256_loop:
  alt1257_0:
.annotate 'line', 483
    set_addr $I10, alt1257_1
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10)
.annotate 'line', 484
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1254_pos, rx1254_off
    set rx1254_rep, 0
    sub $I12, rx1254_eos, rx1254_pos
  rxenumcharlistq1258_loop:
    le $I12, 0, rxenumcharlistq1258_done
    substr $S10, rx1254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1258_done
    inc rx1254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1258_loop
  rxenumcharlistq1258_done:
    add rx1254_pos, rx1254_pos, rx1254_rep
  # rxanchor eol
    sub $I10, rx1254_pos, rx1254_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1254_tgt, $I10
    if $I11, rxanchor1259_done
    ne rx1254_pos, rx1254_eos, rx1254_fail
    eq rx1254_pos, 0, rxanchor1259_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1254_tgt, $I10
    if $I11, rx1254_fail
  rxanchor1259_done:
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."MARKER"("endstmt")
    unless $P10, rx1254_fail
    goto alt1257_end
  alt1257_1:
.annotate 'line', 485
  # rx rxquantr1260 ** 0..1
    set_addr $I10, rxquantr1260_done
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10)
  rxquantr1260_loop:
  # rx subrule "unv" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."unv"()
    unless $P10, rx1254_fail
    goto rxsubrule1261_pass
  rxsubrule1261_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1254_fail
  rxsubrule1261_pass:
    set_addr $I10, rxsubrule1261_back
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10, $P10)
    rx1254_pos = $P10."pos"()
    set_addr $I10, rxquantr1260_done
    (rx1254_rep) = rx1254_cur."!mark_commit"($I10)
  rxquantr1260_done:
  # rxanchor eol
    sub $I10, rx1254_pos, rx1254_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1254_tgt, $I10
    if $I11, rxanchor1262_done
    ne rx1254_pos, rx1254_eos, rx1254_fail
    eq rx1254_pos, 0, rxanchor1262_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1254_tgt, $I10
    if $I11, rx1254_fail
  rxanchor1262_done:
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."MARKER"("endstmt")
    unless $P10, rx1254_fail
  alt1257_end:
.annotate 'line', 486
    set_addr $I10, rxquantr1256_done
    (rx1254_rep) = rx1254_cur."!mark_commit"($I10)
  rxquantr1256_done:
.annotate 'line', 482
  # rx pass
    rx1254_cur."!cursor_pass"(rx1254_pos, "ENDSTMT")
    if_null rx1254_debug, debug_888
    rx1254_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1254_pos)
  debug_888:
    .return (rx1254_cur)
  rx1254_restart:
.annotate 'line', 440
    if_null rx1254_debug, debug_889
    rx1254_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_889:
  rx1254_fail:
    (rx1254_rep, rx1254_pos, $I10, $P10) = rx1254_cur."!mark_fail"(0)
    lt rx1254_pos, -1, rx1254_done
    eq rx1254_pos, -1, rx1254_fail
    jump $I10
  rx1254_done:
    rx1254_cur."!cursor_fail"()
    if_null rx1254_debug, debug_890
    rx1254_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_890:
    .return (rx1254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("49_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("50_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1265_tgt
    .local int rx1265_pos
    .local int rx1265_off
    .local int rx1265_eos
    .local int rx1265_rep
    .local pmc rx1265_cur
    .local pmc rx1265_debug
    (rx1265_cur, rx1265_pos, rx1265_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1265_cur
    .local pmc match
    .lex "$/", match
    length rx1265_eos, rx1265_tgt
    gt rx1265_pos, rx1265_eos, rx1265_done
    set rx1265_off, 0
    lt rx1265_pos, 2, rx1265_start
    sub rx1265_off, rx1265_pos, 1
    substr rx1265_tgt, rx1265_tgt, rx1265_off
  rx1265_start:
    eq $I10, 1, rx1265_restart
    if_null rx1265_debug, debug_891
    rx1265_cur."!cursor_debug"("START", "ws")
  debug_891:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1266_done
    goto rxscan1266_scan
  rxscan1266_loop:
    (rx1265_pos) = rx1265_cur."from"()
    inc rx1265_pos
    rx1265_cur."!cursor_from"(rx1265_pos)
    ge rx1265_pos, rx1265_eos, rxscan1266_done
  rxscan1266_scan:
    set_addr $I10, rxscan1266_loop
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  rxscan1266_done:
  alt1267_0:
.annotate 'line', 489
    set_addr $I10, alt1267_1
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
.annotate 'line', 490
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1265_cur."!cursor_pos"(rx1265_pos)
    $P10 = rx1265_cur."MARKED"("ws")
    unless $P10, rx1265_fail
    goto alt1267_end
  alt1267_1:
.annotate 'line', 491
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1265_cur."!cursor_pos"(rx1265_pos)
    $P10 = rx1265_cur."ww"()
    if $P10, rx1265_fail
.annotate 'line', 496
  # rx rxquantr1268 ** 0..*
    set_addr $I10, rxquantr1268_done
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  rxquantr1268_loop:
  alt1269_0:
.annotate 'line', 492
    set_addr $I10, alt1269_1
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1265_pos, rx1265_off
    set rx1265_rep, 0
    sub $I12, rx1265_eos, rx1265_pos
  rxenumcharlistq1270_loop:
    le $I12, 0, rxenumcharlistq1270_done
    substr $S10, rx1265_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1270_done
    inc rx1265_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1270_loop
  rxenumcharlistq1270_done:
    lt rx1265_rep, 1, rx1265_fail
    add rx1265_pos, rx1265_pos, rx1265_rep
    goto alt1269_end
  alt1269_1:
    set_addr $I10, alt1269_2
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
.annotate 'line', 493
  # rx literal  "#"
    add $I11, rx1265_pos, 1
    gt $I11, rx1265_eos, rx1265_fail
    sub $I11, rx1265_pos, rx1265_off
    ord $I11, rx1265_tgt, $I11
    ne $I11, 35, rx1265_fail
    add rx1265_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1265_pos, rx1265_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1265_tgt, $I10, rx1265_eos
    add rx1265_pos, rx1265_off, $I11
    goto alt1269_end
  alt1269_2:
    set_addr $I10, alt1269_3
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
.annotate 'line', 494
  # rxanchor bol
    eq rx1265_pos, 0, rxanchor1271_done
    ge rx1265_pos, rx1265_eos, rx1265_fail
    sub $I10, rx1265_pos, rx1265_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1265_tgt, $I10
    unless $I11, rx1265_fail
  rxanchor1271_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1265_cur."!cursor_pos"(rx1265_pos)
    $P10 = rx1265_cur."pod_comment"()
    unless $P10, rx1265_fail
    rx1265_pos = $P10."pos"()
    goto alt1269_end
  alt1269_3:
.annotate 'line', 495
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1265_pos, rx1265_off
    set rx1265_rep, 0
    sub $I12, rx1265_eos, rx1265_pos
  rxenumcharlistq1272_loop:
    le $I12, 0, rxenumcharlistq1272_done
    substr $S10, rx1265_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1272_done
    inc rx1265_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1272_loop
  rxenumcharlistq1272_done:
    lt rx1265_rep, 1, rx1265_fail
    add rx1265_pos, rx1265_pos, rx1265_rep
  alt1269_end:
.annotate 'line', 496
    set_addr $I10, rxquantr1268_done
    (rx1265_rep) = rx1265_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1268_done
    rx1265_cur."!mark_push"(rx1265_rep, rx1265_pos, $I10)
    goto rxquantr1268_loop
  rxquantr1268_done:
.annotate 'line', 497
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1265_cur."!cursor_pos"(rx1265_pos)
    $P10 = rx1265_cur."MARKER"("ws")
    unless $P10, rx1265_fail
  alt1267_end:
.annotate 'line', 489
  # rx pass
    rx1265_cur."!cursor_pass"(rx1265_pos, "ws")
    if_null rx1265_debug, debug_892
    rx1265_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1265_pos)
  debug_892:
    .return (rx1265_cur)
  rx1265_restart:
.annotate 'line', 440
    if_null rx1265_debug, debug_893
    rx1265_cur."!cursor_debug"("NEXT", "ws")
  debug_893:
  rx1265_fail:
    (rx1265_rep, rx1265_pos, $I10, $P10) = rx1265_cur."!mark_fail"(0)
    lt rx1265_pos, -1, rx1265_done
    eq rx1265_pos, -1, rx1265_fail
    jump $I10
  rx1265_done:
    rx1265_cur."!cursor_fail"()
    if_null rx1265_debug, debug_894
    rx1265_cur."!cursor_debug"("FAIL", "ws")
  debug_894:
    .return (rx1265_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("51_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("52_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1280 = "53_1312646121.678" 
    capture_lex $P1280
    .local string rx1275_tgt
    .local int rx1275_pos
    .local int rx1275_off
    .local int rx1275_eos
    .local int rx1275_rep
    .local pmc rx1275_cur
    .local pmc rx1275_debug
    (rx1275_cur, rx1275_pos, rx1275_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1275_cur
    .local pmc match
    .lex "$/", match
    length rx1275_eos, rx1275_tgt
    gt rx1275_pos, rx1275_eos, rx1275_done
    set rx1275_off, 0
    lt rx1275_pos, 2, rx1275_start
    sub rx1275_off, rx1275_pos, 1
    substr rx1275_tgt, rx1275_tgt, rx1275_off
  rx1275_start:
    eq $I10, 1, rx1275_restart
    if_null rx1275_debug, debug_895
    rx1275_cur."!cursor_debug"("START", "unv")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1276_done
    goto rxscan1276_scan
  rxscan1276_loop:
    (rx1275_pos) = rx1275_cur."from"()
    inc rx1275_pos
    rx1275_cur."!cursor_from"(rx1275_pos)
    ge rx1275_pos, rx1275_eos, rxscan1276_done
  rxscan1276_scan:
    set_addr $I10, rxscan1276_loop
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
  rxscan1276_done:
  alt1277_0:
.annotate 'line', 502
    set_addr $I10, alt1277_1
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
.annotate 'line', 503
  # rxanchor bol
    eq rx1275_pos, 0, rxanchor1278_done
    ge rx1275_pos, rx1275_eos, rx1275_fail
    sub $I10, rx1275_pos, rx1275_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1275_tgt, $I10
    unless $I11, rx1275_fail
  rxanchor1278_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    .const 'Sub' $P1280 = "53_1312646121.678" 
    capture_lex $P1280
    $P10 = rx1275_cur."before"($P1280)
    unless $P10, rx1275_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    $P10 = rx1275_cur."pod_comment"()
    unless $P10, rx1275_fail
    rx1275_pos = $P10."pos"()
    goto alt1277_end
  alt1277_1:
    set_addr $I10, alt1277_2
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
.annotate 'line', 504
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1275_pos, rx1275_off
    set rx1275_rep, 0
    sub $I12, rx1275_eos, rx1275_pos
  rxenumcharlistq1285_loop:
    le $I12, 0, rxenumcharlistq1285_done
    substr $S10, rx1275_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1285_done
    inc rx1275_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1285_loop
  rxenumcharlistq1285_done:
    add rx1275_pos, rx1275_pos, rx1275_rep
  # rx literal  "#"
    add $I11, rx1275_pos, 1
    gt $I11, rx1275_eos, rx1275_fail
    sub $I11, rx1275_pos, rx1275_off
    ord $I11, rx1275_tgt, $I11
    ne $I11, 35, rx1275_fail
    add rx1275_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1275_pos, rx1275_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1275_tgt, $I10, rx1275_eos
    add rx1275_pos, rx1275_off, $I11
    goto alt1277_end
  alt1277_2:
.annotate 'line', 505
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1275_pos, rx1275_off
    set rx1275_rep, 0
    sub $I12, rx1275_eos, rx1275_pos
  rxenumcharlistq1286_loop:
    le $I12, 0, rxenumcharlistq1286_done
    substr $S10, rx1275_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1286_done
    inc rx1275_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1286_loop
  rxenumcharlistq1286_done:
    lt rx1275_rep, 1, rx1275_fail
    add rx1275_pos, rx1275_pos, rx1275_rep
  alt1277_end:
.annotate 'line', 500
  # rx pass
    rx1275_cur."!cursor_pass"(rx1275_pos, "unv")
    if_null rx1275_debug, debug_900
    rx1275_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1275_pos)
  debug_900:
    .return (rx1275_cur)
  rx1275_restart:
.annotate 'line', 440
    if_null rx1275_debug, debug_901
    rx1275_cur."!cursor_debug"("NEXT", "unv")
  debug_901:
  rx1275_fail:
    (rx1275_rep, rx1275_pos, $I10, $P10) = rx1275_cur."!mark_fail"(0)
    lt rx1275_pos, -1, rx1275_done
    eq rx1275_pos, -1, rx1275_fail
    jump $I10
  rx1275_done:
    rx1275_cur."!cursor_fail"()
    if_null rx1275_debug, debug_902
    rx1275_cur."!cursor_debug"("FAIL", "unv")
  debug_902:
    .return (rx1275_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1279"  :anon :subid("53_1312646121.678") :method :outer("52_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 503
    .local string rx1281_tgt
    .local int rx1281_pos
    .local int rx1281_off
    .local int rx1281_eos
    .local int rx1281_rep
    .local pmc rx1281_cur
    .local pmc rx1281_debug
    (rx1281_cur, rx1281_pos, rx1281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1281_cur
    .local pmc match
    .lex "$/", match
    length rx1281_eos, rx1281_tgt
    gt rx1281_pos, rx1281_eos, rx1281_done
    set rx1281_off, 0
    lt rx1281_pos, 2, rx1281_start
    sub rx1281_off, rx1281_pos, 1
    substr rx1281_tgt, rx1281_tgt, rx1281_off
  rx1281_start:
    eq $I10, 1, rx1281_restart
    if_null rx1281_debug, debug_896
    rx1281_cur."!cursor_debug"("START", "")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1282_done
    goto rxscan1282_scan
  rxscan1282_loop:
    (rx1281_pos) = rx1281_cur."from"()
    inc rx1281_pos
    rx1281_cur."!cursor_from"(rx1281_pos)
    ge rx1281_pos, rx1281_eos, rxscan1282_done
  rxscan1282_scan:
    set_addr $I10, rxscan1282_loop
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  rxscan1282_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1281_pos, rx1281_off
    set rx1281_rep, 0
    sub $I12, rx1281_eos, rx1281_pos
  rxenumcharlistq1283_loop:
    le $I12, 0, rxenumcharlistq1283_done
    substr $S10, rx1281_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1283_done
    inc rx1281_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1283_loop
  rxenumcharlistq1283_done:
    add rx1281_pos, rx1281_pos, rx1281_rep
  # rx literal  "="
    add $I11, rx1281_pos, 1
    gt $I11, rx1281_eos, rx1281_fail
    sub $I11, rx1281_pos, rx1281_off
    ord $I11, rx1281_tgt, $I11
    ne $I11, 61, rx1281_fail
    add rx1281_pos, 1
  alt1284_0:
    set_addr $I10, alt1284_1
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  # rx charclass w
    ge rx1281_pos, rx1281_eos, rx1281_fail
    sub $I10, rx1281_pos, rx1281_off
    is_cclass $I11, .CCLASS_WORD, rx1281_tgt, $I10
    unless $I11, rx1281_fail
    inc rx1281_pos
    goto alt1284_end
  alt1284_1:
  # rx literal  "\\"
    add $I11, rx1281_pos, 1
    gt $I11, rx1281_eos, rx1281_fail
    sub $I11, rx1281_pos, rx1281_off
    ord $I11, rx1281_tgt, $I11
    ne $I11, 92, rx1281_fail
    add rx1281_pos, 1
  alt1284_end:
  # rx pass
    rx1281_cur."!cursor_pass"(rx1281_pos, "")
    if_null rx1281_debug, debug_897
    rx1281_cur."!cursor_debug"("PASS", "", " at pos=", rx1281_pos)
  debug_897:
    .return (rx1281_cur)
  rx1281_restart:
    if_null rx1281_debug, debug_898
    rx1281_cur."!cursor_debug"("NEXT", "")
  debug_898:
  rx1281_fail:
    (rx1281_rep, rx1281_pos, $I10, $P10) = rx1281_cur."!mark_fail"(0)
    lt rx1281_pos, -1, rx1281_done
    eq rx1281_pos, -1, rx1281_fail
    jump $I10
  rx1281_done:
    rx1281_cur."!cursor_fail"()
    if_null rx1281_debug, debug_899
    rx1281_cur."!cursor_debug"("FAIL", "")
  debug_899:
    .return (rx1281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("54_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("55_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1317 = "56_1312646121.678" 
    capture_lex $P1317
    .local string rx1289_tgt
    .local int rx1289_pos
    .local int rx1289_off
    .local int rx1289_eos
    .local int rx1289_rep
    .local pmc rx1289_cur
    .local pmc rx1289_debug
    (rx1289_cur, rx1289_pos, rx1289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1289_cur
    .local pmc match
    .lex "$/", match
    length rx1289_eos, rx1289_tgt
    gt rx1289_pos, rx1289_eos, rx1289_done
    set rx1289_off, 0
    lt rx1289_pos, 2, rx1289_start
    sub rx1289_off, rx1289_pos, 1
    substr rx1289_tgt, rx1289_tgt, rx1289_off
  rx1289_start:
    eq $I10, 1, rx1289_restart
    if_null rx1289_debug, debug_903
    rx1289_cur."!cursor_debug"("START", "pod_comment")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1290_done
    goto rxscan1290_scan
  rxscan1290_loop:
    (rx1289_pos) = rx1289_cur."from"()
    inc rx1289_pos
    rx1289_cur."!cursor_from"(rx1289_pos)
    ge rx1289_pos, rx1289_eos, rxscan1290_done
  rxscan1290_scan:
    set_addr $I10, rxscan1290_loop
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
  rxscan1290_done:
.annotate 'line', 510
  # rxanchor bol
    eq rx1289_pos, 0, rxanchor1291_done
    ge rx1289_pos, rx1289_eos, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  rxanchor1291_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1292_loop:
    le $I12, 0, rxenumcharlistq1292_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1292_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1292_loop
  rxenumcharlistq1292_done:
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx literal  "="
    add $I11, rx1289_pos, 1
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    ord $I11, rx1289_tgt, $I11
    ne $I11, 61, rx1289_fail
    add rx1289_pos, 1
  alt1293_0:
.annotate 'line', 511
    set_addr $I10, alt1293_1
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
.annotate 'line', 512
  # rx literal  "begin"
    add $I11, rx1289_pos, 5
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 5
    ne $S10, "begin", rx1289_fail
    add rx1289_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1294_loop:
    le $I12, 0, rxenumcharlistq1294_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1294_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1294_loop
  rxenumcharlistq1294_done:
    lt rx1289_rep, 1, rx1289_fail
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx literal  "END"
    add $I11, rx1289_pos, 3
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 3
    ne $S10, "END", rx1289_fail
    add rx1289_pos, 3
  # rxanchor rwb
    le rx1289_pos, 0, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    if $I11, rx1289_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  alt1295_0:
.annotate 'line', 513
    set_addr $I10, alt1295_1
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
  # rx rxquantf1296 ** 0..*
    set_addr $I10, rxquantf1296_loop
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
    goto rxquantf1296_done
  rxquantf1296_loop:
  # rx charclass .
    ge rx1289_pos, rx1289_eos, rx1289_fail
    inc rx1289_pos
    set_addr $I10, rxquantf1296_loop
    rx1289_cur."!mark_push"(rx1289_rep, rx1289_pos, $I10)
  rxquantf1296_done:
  # rx charclass nl
    ge rx1289_pos, rx1289_eos, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    unless $I11, rx1289_fail
    substr $S10, rx1289_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1289_pos, $I11
    inc rx1289_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1298_loop:
    le $I12, 0, rxenumcharlistq1298_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1298_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1298_loop
  rxenumcharlistq1298_done:
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx literal  "=end"
    add $I11, rx1289_pos, 4
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 4
    ne $S10, "=end", rx1289_fail
    add rx1289_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1299_loop:
    le $I12, 0, rxenumcharlistq1299_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1299_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1299_loop
  rxenumcharlistq1299_done:
    lt rx1289_rep, 1, rx1289_fail
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx literal  "END"
    add $I11, rx1289_pos, 3
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 3
    ne $S10, "END", rx1289_fail
    add rx1289_pos, 3
  # rxanchor rwb
    le rx1289_pos, 0, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    if $I11, rx1289_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10, rx1289_eos
    add rx1289_pos, rx1289_off, $I11
    goto alt1295_end
  alt1295_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    find_not_cclass $I11, .CCLASS_ANY, rx1289_tgt, $I10, rx1289_eos
    add rx1289_pos, rx1289_off, $I11
  alt1295_end:
.annotate 'line', 512
    goto alt1293_end
  alt1293_1:
    set_addr $I10, alt1293_2
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
.annotate 'line', 514
  # rx literal  "begin"
    add $I11, rx1289_pos, 5
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 5
    ne $S10, "begin", rx1289_fail
    add rx1289_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1300_loop:
    le $I12, 0, rxenumcharlistq1300_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1300_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1300_loop
  rxenumcharlistq1300_done:
    lt rx1289_rep, 1, rx1289_fail
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."identifier"()
    unless $P10, rx1289_fail
    rx1289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1289_pos = $P10."pos"()
  alt1301_0:
.annotate 'line', 515
    set_addr $I10, alt1301_1
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
.annotate 'line', 516
  # rx rxquantf1302 ** 0..*
    set_addr $I10, rxquantf1302_loop
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
    goto rxquantf1302_done
  rxquantf1302_loop:
  # rx charclass .
    ge rx1289_pos, rx1289_eos, rx1289_fail
    inc rx1289_pos
    set_addr $I10, rxquantf1302_loop
    rx1289_cur."!mark_push"(rx1289_rep, rx1289_pos, $I10)
  rxquantf1302_done:
  # rx charclass nl
    ge rx1289_pos, rx1289_eos, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    unless $I11, rx1289_fail
    substr $S10, rx1289_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1289_pos, $I11
    inc rx1289_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1304_loop:
    le $I12, 0, rxenumcharlistq1304_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1304_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1304_loop
  rxenumcharlistq1304_done:
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx literal  "=end"
    add $I11, rx1289_pos, 4
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 4
    ne $S10, "=end", rx1289_fail
    add rx1289_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1305_loop:
    le $I12, 0, rxenumcharlistq1305_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1305_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1305_loop
  rxenumcharlistq1305_done:
    lt rx1289_rep, 1, rx1289_fail
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."!BACKREF"("identifier")
    unless $P10, rx1289_fail
    rx1289_pos = $P10."pos"()
  # rxanchor rwb
    le rx1289_pos, 0, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    if $I11, rx1289_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10, rx1289_eos
    add rx1289_pos, rx1289_off, $I11
    goto alt1301_end
  alt1301_1:
.annotate 'line', 517
  # rx subrule "panic" subtype=method negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."panic"("=begin without matching =end")
    unless $P10, rx1289_fail
    rx1289_pos = $P10."pos"()
  alt1301_end:
.annotate 'line', 514
    goto alt1293_end
  alt1293_2:
    set_addr $I10, alt1293_3
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
.annotate 'line', 519
  # rx literal  "begin"
    add $I11, rx1289_pos, 5
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 5
    ne $S10, "begin", rx1289_fail
    add rx1289_pos, 5
  # rxanchor rwb
    le rx1289_pos, 0, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    if $I11, rx1289_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1306_loop:
    le $I12, 0, rxenumcharlistq1306_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1306_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1306_loop
  rxenumcharlistq1306_done:
    add rx1289_pos, rx1289_pos, rx1289_rep
  alt1307_0:
.annotate 'line', 520
    set_addr $I10, alt1307_1
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
  # rxanchor eol
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    if $I11, rxanchor1308_done
    ne rx1289_pos, rx1289_eos, rx1289_fail
    eq rx1289_pos, 0, rxanchor1308_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    if $I11, rx1289_fail
  rxanchor1308_done:
    goto alt1307_end
  alt1307_1:
    set_addr $I10, alt1307_2
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
  # rx literal  "#"
    add $I11, rx1289_pos, 1
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    ord $I11, rx1289_tgt, $I11
    ne $I11, 35, rx1289_fail
    add rx1289_pos, 1
    goto alt1307_end
  alt1307_2:
  # rx subrule "panic" subtype=method negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1289_fail
    rx1289_pos = $P10."pos"()
  alt1307_end:
  alt1309_0:
.annotate 'line', 521
    set_addr $I10, alt1309_1
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
.annotate 'line', 522
  # rx rxquantf1310 ** 0..*
    set_addr $I10, rxquantf1310_loop
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
    goto rxquantf1310_done
  rxquantf1310_loop:
  # rx charclass .
    ge rx1289_pos, rx1289_eos, rx1289_fail
    inc rx1289_pos
    set_addr $I10, rxquantf1310_loop
    rx1289_cur."!mark_push"(rx1289_rep, rx1289_pos, $I10)
  rxquantf1310_done:
  # rx charclass nl
    ge rx1289_pos, rx1289_eos, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    unless $I11, rx1289_fail
    substr $S10, rx1289_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1289_pos, $I11
    inc rx1289_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    set rx1289_rep, 0
    sub $I12, rx1289_eos, rx1289_pos
  rxenumcharlistq1312_loop:
    le $I12, 0, rxenumcharlistq1312_done
    substr $S10, rx1289_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1312_done
    inc rx1289_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1312_loop
  rxenumcharlistq1312_done:
    add rx1289_pos, rx1289_pos, rx1289_rep
  # rx literal  "=end"
    add $I11, rx1289_pos, 4
    gt $I11, rx1289_eos, rx1289_fail
    sub $I11, rx1289_pos, rx1289_off
    substr $S10, rx1289_tgt, $I11, 4
    ne $S10, "=end", rx1289_fail
    add rx1289_pos, 4
  # rxanchor rwb
    le rx1289_pos, 0, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    if $I11, rx1289_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10, rx1289_eos
    add rx1289_pos, rx1289_off, $I11
    goto alt1309_end
  alt1309_1:
.annotate 'line', 523
  # rx subrule "panic" subtype=method negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."panic"("=begin without matching =end")
    unless $P10, rx1289_fail
    rx1289_pos = $P10."pos"()
  alt1309_end:
.annotate 'line', 519
    goto alt1293_end
  alt1293_3:
    set_addr $I10, alt1293_4
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
.annotate 'line', 525
  # rx subrule "identifier" subtype=capture negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."identifier"()
    unless $P10, rx1289_fail
    rx1289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1289_pos = $P10."pos"()
.annotate 'line', 526
  # rx rxquantf1313 ** 0..*
    set_addr $I10, rxquantf1313_loop
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
    goto rxquantf1313_done
  rxquantf1313_loop:
  # rx charclass .
    ge rx1289_pos, rx1289_eos, rx1289_fail
    inc rx1289_pos
    set_addr $I10, rxquantf1313_loop
    rx1289_cur."!mark_push"(rx1289_rep, rx1289_pos, $I10)
  rxquantf1313_done:
  # rxanchor bol
    eq rx1289_pos, 0, rxanchor1315_done
    ge rx1289_pos, rx1289_eos, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10
    unless $I11, rx1289_fail
  rxanchor1315_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    .const 'Sub' $P1317 = "56_1312646121.678" 
    capture_lex $P1317
    $P10 = rx1289_cur."before"($P1317)
    unless $P10, rx1289_fail
.annotate 'line', 525
    goto alt1293_end
  alt1293_4:
  alt1323_0:
.annotate 'line', 532
    set_addr $I10, alt1323_1
    rx1289_cur."!mark_push"(0, rx1289_pos, $I10)
  # rx charclass s
    ge rx1289_pos, rx1289_eos, rx1289_fail
    sub $I10, rx1289_pos, rx1289_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1289_tgt, $I10
    unless $I11, rx1289_fail
    inc rx1289_pos
    goto alt1323_end
  alt1323_1:
  # rx subrule "panic" subtype=method negate=
    rx1289_cur."!cursor_pos"(rx1289_pos)
    $P10 = rx1289_cur."panic"("Illegal pod directive")
    unless $P10, rx1289_fail
    rx1289_pos = $P10."pos"()
  alt1323_end:
.annotate 'line', 533
  # rx charclass_q N r 0..-1
    sub $I10, rx1289_pos, rx1289_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1289_tgt, $I10, rx1289_eos
    add rx1289_pos, rx1289_off, $I11
  alt1293_end:
.annotate 'line', 509
  # rx pass
    rx1289_cur."!cursor_pass"(rx1289_pos, "pod_comment")
    if_null rx1289_debug, debug_908
    rx1289_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1289_pos)
  debug_908:
    .return (rx1289_cur)
  rx1289_restart:
.annotate 'line', 440
    if_null rx1289_debug, debug_909
    rx1289_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_909:
  rx1289_fail:
    (rx1289_rep, rx1289_pos, $I10, $P10) = rx1289_cur."!mark_fail"(0)
    lt rx1289_pos, -1, rx1289_done
    eq rx1289_pos, -1, rx1289_fail
    jump $I10
  rx1289_done:
    rx1289_cur."!cursor_fail"()
    if_null rx1289_debug, debug_910
    rx1289_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_910:
    .return (rx1289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1316"  :anon :subid("56_1312646121.678") :method :outer("55_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 526
    .local string rx1318_tgt
    .local int rx1318_pos
    .local int rx1318_off
    .local int rx1318_eos
    .local int rx1318_rep
    .local pmc rx1318_cur
    .local pmc rx1318_debug
    (rx1318_cur, rx1318_pos, rx1318_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1318_cur
    .local pmc match
    .lex "$/", match
    length rx1318_eos, rx1318_tgt
    gt rx1318_pos, rx1318_eos, rx1318_done
    set rx1318_off, 0
    lt rx1318_pos, 2, rx1318_start
    sub rx1318_off, rx1318_pos, 1
    substr rx1318_tgt, rx1318_tgt, rx1318_off
  rx1318_start:
    eq $I10, 1, rx1318_restart
    if_null rx1318_debug, debug_904
    rx1318_cur."!cursor_debug"("START", "")
  debug_904:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1319_done
    goto rxscan1319_scan
  rxscan1319_loop:
    (rx1318_pos) = rx1318_cur."from"()
    inc rx1318_pos
    rx1318_cur."!cursor_from"(rx1318_pos)
    ge rx1318_pos, rx1318_eos, rxscan1319_done
  rxscan1319_scan:
    set_addr $I10, rxscan1319_loop
    rx1318_cur."!mark_push"(0, rx1318_pos, $I10)
  rxscan1319_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1318_pos, rx1318_off
    set rx1318_rep, 0
    sub $I12, rx1318_eos, rx1318_pos
  rxenumcharlistq1320_loop:
    le $I12, 0, rxenumcharlistq1320_done
    substr $S10, rx1318_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1320_done
    inc rx1318_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1320_loop
  rxenumcharlistq1320_done:
    add rx1318_pos, rx1318_pos, rx1318_rep
  alt1321_0:
    set_addr $I10, alt1321_1
    rx1318_cur."!mark_push"(0, rx1318_pos, $I10)
.annotate 'line', 527
  # rx literal  "="
    add $I11, rx1318_pos, 1
    gt $I11, rx1318_eos, rx1318_fail
    sub $I11, rx1318_pos, rx1318_off
    ord $I11, rx1318_tgt, $I11
    ne $I11, 61, rx1318_fail
    add rx1318_pos, 1
.annotate 'line', 529
  # rx rxquantr1322 ** 0..1
    set_addr $I10, rxquantr1322_done
    rx1318_cur."!mark_push"(0, rx1318_pos, $I10)
  rxquantr1322_loop:
.annotate 'line', 528
  # rx literal  "cut"
    add $I11, rx1318_pos, 3
    gt $I11, rx1318_eos, rx1318_fail
    sub $I11, rx1318_pos, rx1318_off
    substr $S10, rx1318_tgt, $I11, 3
    ne $S10, "cut", rx1318_fail
    add rx1318_pos, 3
  # rxanchor rwb
    le rx1318_pos, 0, rx1318_fail
    sub $I10, rx1318_pos, rx1318_off
    is_cclass $I11, .CCLASS_WORD, rx1318_tgt, $I10
    if $I11, rx1318_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1318_tgt, $I10
    unless $I11, rx1318_fail
.annotate 'line', 529
  # rx subrule "panic" subtype=method negate=
    rx1318_cur."!cursor_pos"(rx1318_pos)
    $P10 = rx1318_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1318_fail
    rx1318_pos = $P10."pos"()
    set_addr $I10, rxquantr1322_done
    (rx1318_rep) = rx1318_cur."!mark_commit"($I10)
  rxquantr1322_done:
.annotate 'line', 526
    goto alt1321_end
  alt1321_1:
.annotate 'line', 530
  # rx charclass nl
    ge rx1318_pos, rx1318_eos, rx1318_fail
    sub $I10, rx1318_pos, rx1318_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1318_tgt, $I10
    unless $I11, rx1318_fail
    substr $S10, rx1318_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1318_pos, $I11
    inc rx1318_pos
  alt1321_end:
.annotate 'line', 526
  # rx pass
    rx1318_cur."!cursor_pass"(rx1318_pos, "")
    if_null rx1318_debug, debug_905
    rx1318_cur."!cursor_debug"("PASS", "", " at pos=", rx1318_pos)
  debug_905:
    .return (rx1318_cur)
  rx1318_restart:
    if_null rx1318_debug, debug_906
    rx1318_cur."!cursor_debug"("NEXT", "")
  debug_906:
  rx1318_fail:
    (rx1318_rep, rx1318_pos, $I10, $P10) = rx1318_cur."!mark_fail"(0)
    lt rx1318_pos, -1, rx1318_done
    eq rx1318_pos, -1, rx1318_fail
    jump $I10
  rx1318_done:
    rx1318_cur."!cursor_fail"()
    if_null rx1318_debug, debug_907
    rx1318_cur."!cursor_debug"("FAIL", "")
  debug_907:
    .return (rx1318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("57_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P104, "ResizablePMCArray"
    push $P104, ""
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("58_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 541
    new $P103, "Undef"
    set $P1326, $P103
    .lex "$*IN_DECL", $P1326
.annotate 'line', 543
    new $P104, "Undef"
    set $P1327, $P104
    .lex "$*HAS_YOU_ARE_HERE", $P1327
.annotate 'line', 544
    new $P105, "Undef"
    set $P1328, $P105
    .lex "$*MAIN_SUB", $P1328
.annotate 'line', 547
    new $P106, "Undef"
    set $P1329, $P106
    .lex "$*PACKAGE", $P1329
.annotate 'line', 548
    new $P107, "Undef"
    set $P1330, $P107
    .lex "$*GLOBALish", $P1330
.annotate 'line', 440
    .local string rx1331_tgt
    .local int rx1331_pos
    .local int rx1331_off
    .local int rx1331_eos
    .local int rx1331_rep
    .local pmc rx1331_cur
    .local pmc rx1331_debug
    (rx1331_cur, rx1331_pos, rx1331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1331_cur
    .local pmc match
    .lex "$/", match
    length rx1331_eos, rx1331_tgt
    gt rx1331_pos, rx1331_eos, rx1331_done
    set rx1331_off, 0
    lt rx1331_pos, 2, rx1331_start
    sub rx1331_off, rx1331_pos, 1
    substr rx1331_tgt, rx1331_tgt, rx1331_off
  rx1331_start:
    eq $I10, 1, rx1331_restart
    if_null rx1331_debug, debug_911
    rx1331_cur."!cursor_debug"("START", "comp_unit")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1331_pos) = rx1331_cur."from"()
    inc rx1331_pos
    rx1331_cur."!cursor_from"(rx1331_pos)
    ge rx1331_pos, rx1331_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  rxscan1332_done:
.annotate 'line', 541
    rx1331_cur."!cursor_pos"(rx1331_pos)
    new $P108, "String"
    assign $P108, ""
    store_lex "$*IN_DECL", $P108
.annotate 'line', 543
    rx1331_cur."!cursor_pos"(rx1331_pos)
    new $P109, "Float"
    assign $P109, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P109
.annotate 'line', 544
    rx1331_cur."!cursor_pos"(rx1331_pos)
    find_lex $P112, "$*MAIN_SUB"
    unless_null $P112, vivify_912
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["$MAIN_SUB"]
    unless_null $P112, vivify_913
    die "Contextual $*MAIN_SUB not found"
  vivify_913:
  vivify_912:
.annotate 'line', 545
  # rx subrule "newpad" subtype=method negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."newpad"()
    unless $P10, rx1331_fail
    rx1331_pos = $P10."pos"()
.annotate 'line', 547
    rx1331_cur."!cursor_pos"(rx1331_pos)
    find_lex $P115, "$*PACKAGE"
    unless_null $P115, vivify_914
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["$PACKAGE"]
    unless_null $P115, vivify_915
    die "Contextual $*PACKAGE not found"
  vivify_915:
  vivify_914:
.annotate 'line', 548
    rx1331_cur."!cursor_pos"(rx1331_pos)
    find_lex $P118, "$*GLOBALish"
    unless_null $P118, vivify_916
    get_hll_global $P116, "GLOBAL"
    get_who $P117, $P116
    set $P118, $P117["$GLOBALish"]
    unless_null $P118, vivify_917
    die "Contextual $*GLOBALish not found"
  vivify_917:
  vivify_916:
.annotate 'line', 549
  # rx subrule "GLOBALish" subtype=method negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."GLOBALish"()
    unless $P10, rx1331_fail
    rx1331_pos = $P10."pos"()
.annotate 'line', 551
  # rx subrule "outerctx" subtype=method negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."outerctx"()
    unless $P10, rx1331_fail
    rx1331_pos = $P10."pos"()
.annotate 'line', 553
  # rx subrule "statementlist" subtype=capture negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."statementlist"()
    unless $P10, rx1331_fail
    rx1331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1331_pos = $P10."pos"()
  alt1333_0:
.annotate 'line', 554
    set_addr $I10, alt1333_1
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  # rxanchor eos
    ne rx1331_pos, rx1331_eos, rx1331_fail
    goto alt1333_end
  alt1333_1:
  # rx subrule "panic" subtype=method negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."panic"("Confused")
    unless $P10, rx1331_fail
    rx1331_pos = $P10."pos"()
  alt1333_end:
.annotate 'line', 540
  # rx pass
    rx1331_cur."!cursor_pass"(rx1331_pos, "comp_unit")
    if_null rx1331_debug, debug_918
    rx1331_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1331_pos)
  debug_918:
    .return (rx1331_cur)
  rx1331_restart:
.annotate 'line', 440
    if_null rx1331_debug, debug_919
    rx1331_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_919:
  rx1331_fail:
    (rx1331_rep, rx1331_pos, $I10, $P10) = rx1331_cur."!mark_fail"(0)
    lt rx1331_pos, -1, rx1331_done
    eq rx1331_pos, -1, rx1331_fail
    jump $I10
  rx1331_done:
    rx1331_cur."!cursor_fail"()
    if_null rx1331_debug, debug_920
    rx1331_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_920:
    .return (rx1331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("59_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P119 = self."!PREFIX__!subrule"("newpad", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("60_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1336_tgt
    .local int rx1336_pos
    .local int rx1336_off
    .local int rx1336_eos
    .local int rx1336_rep
    .local pmc rx1336_cur
    .local pmc rx1336_debug
    (rx1336_cur, rx1336_pos, rx1336_tgt, $I10) = self."!cursor_start"()
    rx1336_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1336_cur
    .local pmc match
    .lex "$/", match
    length rx1336_eos, rx1336_tgt
    gt rx1336_pos, rx1336_eos, rx1336_done
    set rx1336_off, 0
    lt rx1336_pos, 2, rx1336_start
    sub rx1336_off, rx1336_pos, 1
    substr rx1336_tgt, rx1336_tgt, rx1336_off
  rx1336_start:
    eq $I10, 1, rx1336_restart
    if_null rx1336_debug, debug_921
    rx1336_cur."!cursor_debug"("START", "statementlist")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1337_done
    goto rxscan1337_scan
  rxscan1337_loop:
    (rx1336_pos) = rx1336_cur."from"()
    inc rx1336_pos
    rx1336_cur."!cursor_from"(rx1336_pos)
    ge rx1336_pos, rx1336_eos, rxscan1337_done
  rxscan1337_scan:
    set_addr $I10, rxscan1337_loop
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  rxscan1337_done:
  alt1338_0:
.annotate 'line', 557
    set_addr $I10, alt1338_1
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
.annotate 'line', 558
  # rx subrule "ws" subtype=method negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."ws"()
    unless $P10, rx1336_fail
    rx1336_pos = $P10."pos"()
  # rxanchor eos
    ne rx1336_pos, rx1336_eos, rx1336_fail
  # rx subrule "ws" subtype=method negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."ws"()
    unless $P10, rx1336_fail
    rx1336_pos = $P10."pos"()
    goto alt1338_end
  alt1338_1:
.annotate 'line', 559
  # rx subrule "ws" subtype=method negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."ws"()
    unless $P10, rx1336_fail
    rx1336_pos = $P10."pos"()
  # rx rxquantr1339 ** 0..*
    set_addr $I10, rxquantr1339_done
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  rxquantr1339_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."statement"()
    unless $P10, rx1336_fail
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1336_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."eat_terminator"()
    unless $P10, rx1336_fail
    rx1336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."ws"()
    unless $P10, rx1336_fail
    rx1336_pos = $P10."pos"()
    set_addr $I10, rxquantr1339_done
    (rx1336_rep) = rx1336_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1339_done
    rx1336_cur."!mark_push"(rx1336_rep, rx1336_pos, $I10)
    goto rxquantr1339_loop
  rxquantr1339_done:
  # rx subrule "ws" subtype=method negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."ws"()
    unless $P10, rx1336_fail
    rx1336_pos = $P10."pos"()
  alt1338_end:
.annotate 'line', 557
  # rx pass
    rx1336_cur."!cursor_pass"(rx1336_pos, "statementlist")
    if_null rx1336_debug, debug_922
    rx1336_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1336_pos)
  debug_922:
    .return (rx1336_cur)
  rx1336_restart:
.annotate 'line', 440
    if_null rx1336_debug, debug_923
    rx1336_cur."!cursor_debug"("NEXT", "statementlist")
  debug_923:
  rx1336_fail:
    (rx1336_rep, rx1336_pos, $I10, $P10) = rx1336_cur."!mark_fail"(0)
    lt rx1336_pos, -1, rx1336_done
    eq rx1336_pos, -1, rx1336_fail
    jump $I10
  rx1336_done:
    rx1336_cur."!cursor_fail"()
    if_null rx1336_debug, debug_924
    rx1336_cur."!cursor_debug"("FAIL", "statementlist")
  debug_924:
    .return (rx1336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("61_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P108 = self."!PREFIX__!subrule"("ws", "")
    $P109 = self."!PREFIX__!subrule"("ws", "")
    new $P110, "ResizablePMCArray"
    push $P110, $P108
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("62_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1345 = "63_1312646121.678" 
    capture_lex $P1345
    .local string rx1342_tgt
    .local int rx1342_pos
    .local int rx1342_off
    .local int rx1342_eos
    .local int rx1342_rep
    .local pmc rx1342_cur
    .local pmc rx1342_debug
    (rx1342_cur, rx1342_pos, rx1342_tgt, $I10) = self."!cursor_start"()
    rx1342_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1342_cur
    .local pmc match
    .lex "$/", match
    length rx1342_eos, rx1342_tgt
    gt rx1342_pos, rx1342_eos, rx1342_done
    set rx1342_off, 0
    lt rx1342_pos, 2, rx1342_start
    sub rx1342_off, rx1342_pos, 1
    substr rx1342_tgt, rx1342_tgt, rx1342_off
  rx1342_start:
    eq $I10, 1, rx1342_restart
    if_null rx1342_debug, debug_925
    rx1342_cur."!cursor_debug"("START", "statement")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1343_done
    goto rxscan1343_scan
  rxscan1343_loop:
    (rx1342_pos) = rx1342_cur."from"()
    inc rx1342_pos
    rx1342_cur."!cursor_from"(rx1342_pos)
    ge rx1342_pos, rx1342_eos, rxscan1343_done
  rxscan1343_scan:
    set_addr $I10, rxscan1343_loop
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxscan1343_done:
.annotate 'line', 563
  # rx subrule "before" subtype=zerowidth negate=1
    rx1342_cur."!cursor_pos"(rx1342_pos)
    .const 'Sub' $P1345 = "63_1312646121.678" 
    capture_lex $P1345
    $P10 = rx1342_cur."before"($P1345)
    if $P10, rx1342_fail
  alt1349_0:
.annotate 'line', 564
    set_addr $I10, alt1349_1
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
.annotate 'line', 565
  # rx subrule "statement_control" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."statement_control"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1342_pos = $P10."pos"()
    goto alt1349_end
  alt1349_1:
.annotate 'line', 566
  # rx subrule "EXPR" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."EXPR"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 571
  # rx rxquantr1350 ** 0..1
    set_addr $I10, rxquantr1350_done
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxquantr1350_loop:
  alt1351_0:
.annotate 'line', 567
    set_addr $I10, alt1351_1
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
.annotate 'line', 568
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."MARKED"("endstmt")
    unless $P10, rx1342_fail
    goto alt1351_end
  alt1351_1:
    set_addr $I10, alt1351_2
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
.annotate 'line', 569
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."statement_mod_cond"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1342_pos = $P10."pos"()
  # rx rxquantr1352 ** 0..1
    set_addr $I10, rxquantr1352_done
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxquantr1352_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."statement_mod_loop"()
    unless $P10, rx1342_fail
    goto rxsubrule1353_pass
  rxsubrule1353_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1342_fail
  rxsubrule1353_pass:
    set_addr $I10, rxsubrule1353_back
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1342_pos = $P10."pos"()
    set_addr $I10, rxquantr1352_done
    (rx1342_rep) = rx1342_cur."!mark_commit"($I10)
  rxquantr1352_done:
    goto alt1351_end
  alt1351_2:
.annotate 'line', 570
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."statement_mod_loop"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1342_pos = $P10."pos"()
  alt1351_end:
.annotate 'line', 571
    set_addr $I10, rxquantr1350_done
    (rx1342_rep) = rx1342_cur."!mark_commit"($I10)
  rxquantr1350_done:
  alt1349_end:
.annotate 'line', 562
  # rx pass
    rx1342_cur."!cursor_pass"(rx1342_pos, "statement")
    if_null rx1342_debug, debug_930
    rx1342_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1342_pos)
  debug_930:
    .return (rx1342_cur)
  rx1342_restart:
.annotate 'line', 440
    if_null rx1342_debug, debug_931
    rx1342_cur."!cursor_debug"("NEXT", "statement")
  debug_931:
  rx1342_fail:
    (rx1342_rep, rx1342_pos, $I10, $P10) = rx1342_cur."!mark_fail"(0)
    lt rx1342_pos, -1, rx1342_done
    eq rx1342_pos, -1, rx1342_fail
    jump $I10
  rx1342_done:
    rx1342_cur."!cursor_fail"()
    if_null rx1342_debug, debug_932
    rx1342_cur."!cursor_debug"("FAIL", "statement")
  debug_932:
    .return (rx1342_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1344"  :anon :subid("63_1312646121.678") :method :outer("62_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 563
    .local string rx1346_tgt
    .local int rx1346_pos
    .local int rx1346_off
    .local int rx1346_eos
    .local int rx1346_rep
    .local pmc rx1346_cur
    .local pmc rx1346_debug
    (rx1346_cur, rx1346_pos, rx1346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1346_cur
    .local pmc match
    .lex "$/", match
    length rx1346_eos, rx1346_tgt
    gt rx1346_pos, rx1346_eos, rx1346_done
    set rx1346_off, 0
    lt rx1346_pos, 2, rx1346_start
    sub rx1346_off, rx1346_pos, 1
    substr rx1346_tgt, rx1346_tgt, rx1346_off
  rx1346_start:
    eq $I10, 1, rx1346_restart
    if_null rx1346_debug, debug_926
    rx1346_cur."!cursor_debug"("START", "")
  debug_926:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1346_pos) = rx1346_cur."from"()
    inc rx1346_pos
    rx1346_cur."!cursor_from"(rx1346_pos)
    ge rx1346_pos, rx1346_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1346_cur."!mark_push"(0, rx1346_pos, $I10)
  rxscan1347_done:
  alt1348_0:
    set_addr $I10, alt1348_1
    rx1346_cur."!mark_push"(0, rx1346_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1346_pos, rx1346_eos, rx1346_fail
    sub $I10, rx1346_pos, rx1346_off
    substr $S10, rx1346_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1346_fail
    inc rx1346_pos
    goto alt1348_end
  alt1348_1:
  # rxanchor eos
    ne rx1346_pos, rx1346_eos, rx1346_fail
  alt1348_end:
  # rx pass
    rx1346_cur."!cursor_pass"(rx1346_pos, "")
    if_null rx1346_debug, debug_927
    rx1346_cur."!cursor_debug"("PASS", "", " at pos=", rx1346_pos)
  debug_927:
    .return (rx1346_cur)
  rx1346_restart:
    if_null rx1346_debug, debug_928
    rx1346_cur."!cursor_debug"("NEXT", "")
  debug_928:
  rx1346_fail:
    (rx1346_rep, rx1346_pos, $I10, $P10) = rx1346_cur."!mark_fail"(0)
    lt rx1346_pos, -1, rx1346_done
    eq rx1346_pos, -1, rx1346_fail
    jump $I10
  rx1346_done:
    rx1346_cur."!cursor_fail"()
    if_null rx1346_debug, debug_929
    rx1346_cur."!cursor_debug"("FAIL", "")
  debug_929:
    .return (rx1346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("64_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("65_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_933
    rx1356_cur."!cursor_debug"("START", "eat_terminator")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1357_done
    goto rxscan1357_scan
  rxscan1357_loop:
    (rx1356_pos) = rx1356_cur."from"()
    inc rx1356_pos
    rx1356_cur."!cursor_from"(rx1356_pos)
    ge rx1356_pos, rx1356_eos, rxscan1357_done
  rxscan1357_scan:
    set_addr $I10, rxscan1357_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1357_done:
  alt1358_0:
.annotate 'line', 575
    set_addr $I10, alt1358_1
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
.annotate 'line', 576
  # rx literal  ";"
    add $I11, rx1356_pos, 1
    gt $I11, rx1356_eos, rx1356_fail
    sub $I11, rx1356_pos, rx1356_off
    ord $I11, rx1356_tgt, $I11
    ne $I11, 59, rx1356_fail
    add rx1356_pos, 1
    goto alt1358_end
  alt1358_1:
    set_addr $I10, alt1358_2
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
.annotate 'line', 577
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."MARKED"("endstmt")
    unless $P10, rx1356_fail
    goto alt1358_end
  alt1358_2:
    set_addr $I10, alt1358_3
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
.annotate 'line', 578
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."terminator"()
    unless $P10, rx1356_fail
    goto alt1358_end
  alt1358_3:
.annotate 'line', 579
  # rxanchor eos
    ne rx1356_pos, rx1356_eos, rx1356_fail
  alt1358_end:
.annotate 'line', 575
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "eat_terminator")
    if_null rx1356_debug, debug_934
    rx1356_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1356_pos)
  debug_934:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 440
    if_null rx1356_debug, debug_935
    rx1356_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_935:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_936
    rx1356_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_936:
    .return (rx1356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("66_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("67_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1361_tgt
    .local int rx1361_pos
    .local int rx1361_off
    .local int rx1361_eos
    .local int rx1361_rep
    .local pmc rx1361_cur
    .local pmc rx1361_debug
    (rx1361_cur, rx1361_pos, rx1361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1361_cur
    .local pmc match
    .lex "$/", match
    length rx1361_eos, rx1361_tgt
    gt rx1361_pos, rx1361_eos, rx1361_done
    set rx1361_off, 0
    lt rx1361_pos, 2, rx1361_start
    sub rx1361_off, rx1361_pos, 1
    substr rx1361_tgt, rx1361_tgt, rx1361_off
  rx1361_start:
    eq $I10, 1, rx1361_restart
    if_null rx1361_debug, debug_937
    rx1361_cur."!cursor_debug"("START", "xblock")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1362_done
    goto rxscan1362_scan
  rxscan1362_loop:
    (rx1361_pos) = rx1361_cur."from"()
    inc rx1361_pos
    rx1361_cur."!cursor_from"(rx1361_pos)
    ge rx1361_pos, rx1361_eos, rxscan1362_done
  rxscan1362_scan:
    set_addr $I10, rxscan1362_loop
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  rxscan1362_done:
.annotate 'line', 583
  # rx subrule "EXPR" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."EXPR"()
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1361_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."ws"()
    unless $P10, rx1361_fail
    rx1361_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."pblock"()
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1361_pos = $P10."pos"()
.annotate 'line', 582
  # rx pass
    rx1361_cur."!cursor_pass"(rx1361_pos, "xblock")
    if_null rx1361_debug, debug_938
    rx1361_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1361_pos)
  debug_938:
    .return (rx1361_cur)
  rx1361_restart:
.annotate 'line', 440
    if_null rx1361_debug, debug_939
    rx1361_cur."!cursor_debug"("NEXT", "xblock")
  debug_939:
  rx1361_fail:
    (rx1361_rep, rx1361_pos, $I10, $P10) = rx1361_cur."!mark_fail"(0)
    lt rx1361_pos, -1, rx1361_done
    eq rx1361_pos, -1, rx1361_fail
    jump $I10
  rx1361_done:
    rx1361_cur."!cursor_fail"()
    if_null rx1361_debug, debug_940
    rx1361_cur."!cursor_debug"("FAIL", "xblock")
  debug_940:
    .return (rx1361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("68_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("EXPR", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("69_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_941
    rx1365_cur."!cursor_debug"("START", "pblock")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1366_done
    goto rxscan1366_scan
  rxscan1366_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1366_done
  rxscan1366_scan:
    set_addr $I10, rxscan1366_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1366_done:
  alt1367_0:
.annotate 'line', 586
    set_addr $I10, alt1367_1
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
.annotate 'line', 587
  # rx subrule "lambda" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."lambda"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 588
  # rx subrule "newpad" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."newpad"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 589
  # rx subrule "signature" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."signature"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1365_pos = $P10."pos"()
.annotate 'line', 590
  # rx subrule "blockoid" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."blockoid"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1365_pos = $P10."pos"()
.annotate 'line', 587
    goto alt1367_end
  alt1367_1:
    set_addr $I10, alt1367_2
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
.annotate 'line', 591
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1365_fail
.annotate 'line', 592
  # rx subrule "newpad" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."newpad"()
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
.annotate 'line', 593
  # rx subrule "blockoid" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."blockoid"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1365_pos = $P10."pos"()
.annotate 'line', 591
    goto alt1367_end
  alt1367_2:
.annotate 'line', 594
  # rx subrule "panic" subtype=method negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."panic"("Missing block")
    unless $P10, rx1365_fail
    rx1365_pos = $P10."pos"()
  alt1367_end:
.annotate 'line', 586
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "pblock")
    if_null rx1365_debug, debug_942
    rx1365_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1365_pos)
  debug_942:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 440
    if_null rx1365_debug, debug_943
    rx1365_cur."!cursor_debug"("NEXT", "pblock")
  debug_943:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_944
    rx1365_cur."!cursor_debug"("FAIL", "pblock")
  debug_944:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("70_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("panic", "")
    $P104 = self."!PREFIX__!subrule"("lambda", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, "{"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("71_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_945
    rx1370_cur."!cursor_debug"("START", "lambda")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1371_done
    goto rxscan1371_scan
  rxscan1371_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1371_done
  rxscan1371_scan:
    set_addr $I10, rxscan1371_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1371_done:
  alt1372_0:
.annotate 'line', 597
    set_addr $I10, alt1372_1
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "->"
    add $I11, rx1370_pos, 2
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I11, 2
    ne $S10, "->", rx1370_fail
    add rx1370_pos, 2
    goto alt1372_end
  alt1372_1:
  # rx literal  "<->"
    add $I11, rx1370_pos, 3
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I11, 3
    ne $S10, "<->", rx1370_fail
    add rx1370_pos, 3
  alt1372_end:
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "lambda")
    if_null rx1370_debug, debug_946
    rx1370_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1370_pos)
  debug_946:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 440
    if_null rx1370_debug, debug_947
    rx1370_cur."!cursor_debug"("NEXT", "lambda")
  debug_947:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_948
    rx1370_cur."!cursor_debug"("FAIL", "lambda")
  debug_948:
    .return (rx1370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("72_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "<->"
    push $P103, "->"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("73_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_949
    rx1375_cur."!cursor_debug"("START", "block")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1376_done
    goto rxscan1376_scan
  rxscan1376_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1376_done
  rxscan1376_scan:
    set_addr $I10, rxscan1376_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1376_done:
  alt1377_0:
.annotate 'line', 600
    set_addr $I10, alt1377_1
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1375_pos, rx1375_off
    substr $S10, rx1375_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1375_fail
    goto alt1377_end
  alt1377_1:
  # rx subrule "panic" subtype=method negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."panic"("Missing block")
    unless $P10, rx1375_fail
    rx1375_pos = $P10."pos"()
  alt1377_end:
.annotate 'line', 601
  # rx subrule "newpad" subtype=method negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."newpad"()
    unless $P10, rx1375_fail
    rx1375_pos = $P10."pos"()
.annotate 'line', 602
  # rx subrule "blockoid" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."blockoid"()
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1375_pos = $P10."pos"()
.annotate 'line', 599
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "block")
    if_null rx1375_debug, debug_950
    rx1375_cur."!cursor_debug"("PASS", "block", " at pos=", rx1375_pos)
  debug_950:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 440
    if_null rx1375_debug, debug_951
    rx1375_cur."!cursor_debug"("NEXT", "block")
  debug_951:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_952
    rx1375_cur."!cursor_debug"("FAIL", "block")
  debug_952:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("74_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("panic", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    push $P104, "{"
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("75_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1380_tgt
    .local int rx1380_pos
    .local int rx1380_off
    .local int rx1380_eos
    .local int rx1380_rep
    .local pmc rx1380_cur
    .local pmc rx1380_debug
    (rx1380_cur, rx1380_pos, rx1380_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1380_cur
    .local pmc match
    .lex "$/", match
    length rx1380_eos, rx1380_tgt
    gt rx1380_pos, rx1380_eos, rx1380_done
    set rx1380_off, 0
    lt rx1380_pos, 2, rx1380_start
    sub rx1380_off, rx1380_pos, 1
    substr rx1380_tgt, rx1380_tgt, rx1380_off
  rx1380_start:
    eq $I10, 1, rx1380_restart
    if_null rx1380_debug, debug_953
    rx1380_cur."!cursor_debug"("START", "blockoid")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1380_pos) = rx1380_cur."from"()
    inc rx1380_pos
    rx1380_cur."!cursor_from"(rx1380_pos)
    ge rx1380_pos, rx1380_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
  rxscan1381_done:
.annotate 'line', 606
  # rx subrule "finishpad" subtype=method negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."finishpad"()
    unless $P10, rx1380_fail
    rx1380_pos = $P10."pos"()
  alt1382_0:
.annotate 'line', 607
    set_addr $I10, alt1382_1
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
.annotate 'line', 608
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1380_pos, 14
    gt $I11, rx1380_eos, rx1380_fail
    sub $I11, rx1380_pos, rx1380_off
    substr $S10, rx1380_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1380_fail
    add rx1380_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."you_are_here"()
    unless $P10, rx1380_fail
    rx1380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1380_pos = $P10."pos"()
    goto alt1382_end
  alt1382_1:
.annotate 'line', 609
  # rx literal  "{"
    add $I11, rx1380_pos, 1
    gt $I11, rx1380_eos, rx1380_fail
    sub $I11, rx1380_pos, rx1380_off
    ord $I11, rx1380_tgt, $I11
    ne $I11, 123, rx1380_fail
    add rx1380_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."statementlist"()
    unless $P10, rx1380_fail
    rx1380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1380_pos = $P10."pos"()
  alt1383_0:
    set_addr $I10, alt1383_1
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
  # rx literal  "}"
    add $I11, rx1380_pos, 1
    gt $I11, rx1380_eos, rx1380_fail
    sub $I11, rx1380_pos, rx1380_off
    ord $I11, rx1380_tgt, $I11
    ne $I11, 125, rx1380_fail
    add rx1380_pos, 1
    goto alt1383_end
  alt1383_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."FAILGOAL"("'}'")
    unless $P10, rx1380_fail
    goto rxsubrule1384_pass
  rxsubrule1384_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1380_fail
  rxsubrule1384_pass:
    set_addr $I10, rxsubrule1384_back
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10, $P10)
    rx1380_pos = $P10."pos"()
  alt1383_end:
  alt1382_end:
.annotate 'line', 611
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."ENDSTMT"()
    unless $P10, rx1380_fail
.annotate 'line', 605
  # rx pass
    rx1380_cur."!cursor_pass"(rx1380_pos, "blockoid")
    if_null rx1380_debug, debug_954
    rx1380_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1380_pos)
  debug_954:
    .return (rx1380_cur)
  rx1380_restart:
.annotate 'line', 440
    if_null rx1380_debug, debug_955
    rx1380_cur."!cursor_debug"("NEXT", "blockoid")
  debug_955:
  rx1380_fail:
    (rx1380_rep, rx1380_pos, $I10, $P10) = rx1380_cur."!mark_fail"(0)
    lt rx1380_pos, -1, rx1380_done
    eq rx1380_pos, -1, rx1380_fail
    jump $I10
  rx1380_done:
    rx1380_cur."!cursor_fail"()
    if_null rx1380_debug, debug_956
    rx1380_cur."!cursor_debug"("FAIL", "blockoid")
  debug_956:
    .return (rx1380_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("76_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P104 = self."!PREFIX__!subrule"("finishpad", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("77_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_957
    rx1387_cur."!cursor_debug"("START", "newpad")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1388_done:
.annotate 'line', 614
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "newpad")
    if_null rx1387_debug, debug_958
    rx1387_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1387_pos)
  debug_958:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 440
    if_null rx1387_debug, debug_959
    rx1387_cur."!cursor_debug"("NEXT", "newpad")
  debug_959:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_960
    rx1387_cur."!cursor_debug"("FAIL", "newpad")
  debug_960:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("78_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("79_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_961
    rx1391_cur."!cursor_debug"("START", "outerctx")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1392_done
    goto rxscan1392_scan
  rxscan1392_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1392_done
  rxscan1392_scan:
    set_addr $I10, rxscan1392_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1392_done:
.annotate 'line', 615
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "outerctx")
    if_null rx1391_debug, debug_962
    rx1391_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1391_pos)
  debug_962:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 440
    if_null rx1391_debug, debug_963
    rx1391_cur."!cursor_debug"("NEXT", "outerctx")
  debug_963:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_964
    rx1391_cur."!cursor_debug"("FAIL", "outerctx")
  debug_964:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("80_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("81_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1395_tgt
    .local int rx1395_pos
    .local int rx1395_off
    .local int rx1395_eos
    .local int rx1395_rep
    .local pmc rx1395_cur
    .local pmc rx1395_debug
    (rx1395_cur, rx1395_pos, rx1395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1395_cur
    .local pmc match
    .lex "$/", match
    length rx1395_eos, rx1395_tgt
    gt rx1395_pos, rx1395_eos, rx1395_done
    set rx1395_off, 0
    lt rx1395_pos, 2, rx1395_start
    sub rx1395_off, rx1395_pos, 1
    substr rx1395_tgt, rx1395_tgt, rx1395_off
  rx1395_start:
    eq $I10, 1, rx1395_restart
    if_null rx1395_debug, debug_965
    rx1395_cur."!cursor_debug"("START", "GLOBALish")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1395_pos) = rx1395_cur."from"()
    inc rx1395_pos
    rx1395_cur."!cursor_from"(rx1395_pos)
    ge rx1395_pos, rx1395_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  rxscan1396_done:
.annotate 'line', 616
  # rx pass
    rx1395_cur."!cursor_pass"(rx1395_pos, "GLOBALish")
    if_null rx1395_debug, debug_966
    rx1395_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1395_pos)
  debug_966:
    .return (rx1395_cur)
  rx1395_restart:
.annotate 'line', 440
    if_null rx1395_debug, debug_967
    rx1395_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_967:
  rx1395_fail:
    (rx1395_rep, rx1395_pos, $I10, $P10) = rx1395_cur."!mark_fail"(0)
    lt rx1395_pos, -1, rx1395_done
    eq rx1395_pos, -1, rx1395_fail
    jump $I10
  rx1395_done:
    rx1395_cur."!cursor_fail"()
    if_null rx1395_debug, debug_968
    rx1395_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_968:
    .return (rx1395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("82_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("83_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1399_tgt
    .local int rx1399_pos
    .local int rx1399_off
    .local int rx1399_eos
    .local int rx1399_rep
    .local pmc rx1399_cur
    .local pmc rx1399_debug
    (rx1399_cur, rx1399_pos, rx1399_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1399_cur
    .local pmc match
    .lex "$/", match
    length rx1399_eos, rx1399_tgt
    gt rx1399_pos, rx1399_eos, rx1399_done
    set rx1399_off, 0
    lt rx1399_pos, 2, rx1399_start
    sub rx1399_off, rx1399_pos, 1
    substr rx1399_tgt, rx1399_tgt, rx1399_off
  rx1399_start:
    eq $I10, 1, rx1399_restart
    if_null rx1399_debug, debug_969
    rx1399_cur."!cursor_debug"("START", "finishpad")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1400_done
    goto rxscan1400_scan
  rxscan1400_loop:
    (rx1399_pos) = rx1399_cur."from"()
    inc rx1399_pos
    rx1399_cur."!cursor_from"(rx1399_pos)
    ge rx1399_pos, rx1399_eos, rxscan1400_done
  rxscan1400_scan:
    set_addr $I10, rxscan1400_loop
    rx1399_cur."!mark_push"(0, rx1399_pos, $I10)
  rxscan1400_done:
.annotate 'line', 617
  # rx pass
    rx1399_cur."!cursor_pass"(rx1399_pos, "finishpad")
    if_null rx1399_debug, debug_970
    rx1399_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1399_pos)
  debug_970:
    .return (rx1399_cur)
  rx1399_restart:
.annotate 'line', 440
    if_null rx1399_debug, debug_971
    rx1399_cur."!cursor_debug"("NEXT", "finishpad")
  debug_971:
  rx1399_fail:
    (rx1399_rep, rx1399_pos, $I10, $P10) = rx1399_cur."!mark_fail"(0)
    lt rx1399_pos, -1, rx1399_done
    eq rx1399_pos, -1, rx1399_fail
    jump $I10
  rx1399_done:
    rx1399_cur."!cursor_fail"()
    if_null rx1399_debug, debug_972
    rx1399_cur."!cursor_debug"("FAIL", "finishpad")
  debug_972:
    .return (rx1399_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("84_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("85_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_973
    rx1403_cur."!cursor_debug"("START", "you_are_here")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1404_done
    goto rxscan1404_scan
  rxscan1404_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1404_done
  rxscan1404_scan:
    set_addr $I10, rxscan1404_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1404_done:
.annotate 'line', 618
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "you_are_here")
    if_null rx1403_debug, debug_974
    rx1403_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1403_pos)
  debug_974:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 440
    if_null rx1403_debug, debug_975
    rx1403_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_975:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_976
    rx1403_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_976:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("86_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("87_1312646121.678")
    .param pmc param_1407
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 620
    .lex "self", param_1407
    $P103 = param_1407."!protoregex"("terminator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("88_1312646121.678")
    .param pmc param_1409
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 620
    .lex "self", param_1409
    $P104 = param_1409."!PREFIX__!protoregex"("terminator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("89_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_977
    rx1411_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1412_done:
.annotate 'line', 622
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1411_pos, rx1411_off
    substr $S10, rx1411_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1411_fail
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "terminator:sym<;>")
    if_null rx1411_debug, debug_978
    rx1411_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1411_pos)
  debug_978:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 440
    if_null rx1411_debug, debug_979
    rx1411_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_979:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_980
    rx1411_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_980:
    .return (rx1411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("90_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("91_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1415_tgt
    .local int rx1415_pos
    .local int rx1415_off
    .local int rx1415_eos
    .local int rx1415_rep
    .local pmc rx1415_cur
    .local pmc rx1415_debug
    (rx1415_cur, rx1415_pos, rx1415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1415_cur
    .local pmc match
    .lex "$/", match
    length rx1415_eos, rx1415_tgt
    gt rx1415_pos, rx1415_eos, rx1415_done
    set rx1415_off, 0
    lt rx1415_pos, 2, rx1415_start
    sub rx1415_off, rx1415_pos, 1
    substr rx1415_tgt, rx1415_tgt, rx1415_off
  rx1415_start:
    eq $I10, 1, rx1415_restart
    if_null rx1415_debug, debug_981
    rx1415_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    (rx1415_pos) = rx1415_cur."from"()
    inc rx1415_pos
    rx1415_cur."!cursor_from"(rx1415_pos)
    ge rx1415_pos, rx1415_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  rxscan1416_done:
.annotate 'line', 623
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1415_pos, rx1415_off
    substr $S10, rx1415_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1415_fail
  # rx pass
    rx1415_cur."!cursor_pass"(rx1415_pos, "terminator:sym<}>")
    if_null rx1415_debug, debug_982
    rx1415_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1415_pos)
  debug_982:
    .return (rx1415_cur)
  rx1415_restart:
.annotate 'line', 440
    if_null rx1415_debug, debug_983
    rx1415_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_983:
  rx1415_fail:
    (rx1415_rep, rx1415_pos, $I10, $P10) = rx1415_cur."!mark_fail"(0)
    lt rx1415_pos, -1, rx1415_done
    eq rx1415_pos, -1, rx1415_fail
    jump $I10
  rx1415_done:
    rx1415_cur."!cursor_fail"()
    if_null rx1415_debug, debug_984
    rx1415_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_984:
    .return (rx1415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("92_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("93_1312646121.678")
    .param pmc param_1419
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 627
    .lex "self", param_1419
    $P103 = param_1419."!protoregex"("statement_control")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("94_1312646121.678")
    .param pmc param_1421
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 627
    .lex "self", param_1421
    $P104 = param_1421."!PREFIX__!protoregex"("statement_control")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("95_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1423_tgt
    .local int rx1423_pos
    .local int rx1423_off
    .local int rx1423_eos
    .local int rx1423_rep
    .local pmc rx1423_cur
    .local pmc rx1423_debug
    (rx1423_cur, rx1423_pos, rx1423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1423_cur
    .local pmc match
    .lex "$/", match
    length rx1423_eos, rx1423_tgt
    gt rx1423_pos, rx1423_eos, rx1423_done
    set rx1423_off, 0
    lt rx1423_pos, 2, rx1423_start
    sub rx1423_off, rx1423_pos, 1
    substr rx1423_tgt, rx1423_tgt, rx1423_off
  rx1423_start:
    eq $I10, 1, rx1423_restart
    if_null rx1423_debug, debug_985
    rx1423_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1424_done
    goto rxscan1424_scan
  rxscan1424_loop:
    (rx1423_pos) = rx1423_cur."from"()
    inc rx1423_pos
    rx1423_cur."!cursor_from"(rx1423_pos)
    ge rx1423_pos, rx1423_eos, rxscan1424_done
  rxscan1424_scan:
    set_addr $I10, rxscan1424_loop
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  rxscan1424_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1425_fail
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  # rx literal  "use"
    add $I11, rx1423_pos, 3
    gt $I11, rx1423_eos, rx1423_fail
    sub $I11, rx1423_pos, rx1423_off
    substr $S10, rx1423_tgt, $I11, 3
    ne $S10, "use", rx1423_fail
    add rx1423_pos, 3
    set_addr $I10, rxcap_1425_fail
    ($I12, $I11) = rx1423_cur."!mark_peek"($I10)
    rx1423_cur."!cursor_pos"($I11)
    ($P10) = rx1423_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1423_pos, "")
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1425_done
  rxcap_1425_fail:
    goto rx1423_fail
  rxcap_1425_done:
  # rx charclass s
    ge rx1423_pos, rx1423_eos, rx1423_fail
    sub $I10, rx1423_pos, rx1423_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1423_tgt, $I10
    unless $I11, rx1423_fail
    inc rx1423_pos
  # rx subrule "ws" subtype=method negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."ws"()
    unless $P10, rx1423_fail
    rx1423_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."name"()
    unless $P10, rx1423_fail
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1423_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."ws"()
    unless $P10, rx1423_fail
    rx1423_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1423_cur."!cursor_pass"(rx1423_pos, "statement_control:sym<use>")
    if_null rx1423_debug, debug_986
    rx1423_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1423_pos)
  debug_986:
    .return (rx1423_cur)
  rx1423_restart:
.annotate 'line', 440
    if_null rx1423_debug, debug_987
    rx1423_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_987:
  rx1423_fail:
    (rx1423_rep, rx1423_pos, $I10, $P10) = rx1423_cur."!mark_fail"(0)
    lt rx1423_pos, -1, rx1423_done
    eq rx1423_pos, -1, rx1423_fail
    jump $I10
  rx1423_done:
    rx1423_cur."!cursor_fail"()
    if_null rx1423_debug, debug_988
    rx1423_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_988:
    .return (rx1423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("96_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P105, "ResizablePMCArray"
    push $P105, "use"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("97_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1428_tgt
    .local int rx1428_pos
    .local int rx1428_off
    .local int rx1428_eos
    .local int rx1428_rep
    .local pmc rx1428_cur
    .local pmc rx1428_debug
    (rx1428_cur, rx1428_pos, rx1428_tgt, $I10) = self."!cursor_start"()
    rx1428_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1428_cur
    .local pmc match
    .lex "$/", match
    length rx1428_eos, rx1428_tgt
    gt rx1428_pos, rx1428_eos, rx1428_done
    set rx1428_off, 0
    lt rx1428_pos, 2, rx1428_start
    sub rx1428_off, rx1428_pos, 1
    substr rx1428_tgt, rx1428_tgt, rx1428_off
  rx1428_start:
    eq $I10, 1, rx1428_restart
    if_null rx1428_debug, debug_989
    rx1428_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1429_done
    goto rxscan1429_scan
  rxscan1429_loop:
    (rx1428_pos) = rx1428_cur."from"()
    inc rx1428_pos
    rx1428_cur."!cursor_from"(rx1428_pos)
    ge rx1428_pos, rx1428_eos, rxscan1429_done
  rxscan1429_scan:
    set_addr $I10, rxscan1429_loop
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxscan1429_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1430_fail
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  # rx literal  "if"
    add $I11, rx1428_pos, 2
    gt $I11, rx1428_eos, rx1428_fail
    sub $I11, rx1428_pos, rx1428_off
    substr $S10, rx1428_tgt, $I11, 2
    ne $S10, "if", rx1428_fail
    add rx1428_pos, 2
    set_addr $I10, rxcap_1430_fail
    ($I12, $I11) = rx1428_cur."!mark_peek"($I10)
    rx1428_cur."!cursor_pos"($I11)
    ($P10) = rx1428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1428_pos, "")
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1430_done
  rxcap_1430_fail:
    goto rx1428_fail
  rxcap_1430_done:
  # rx charclass s
    ge rx1428_pos, rx1428_eos, rx1428_fail
    sub $I10, rx1428_pos, rx1428_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1428_tgt, $I10
    unless $I11, rx1428_fail
    inc rx1428_pos
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
.annotate 'line', 635
  # rx subrule "xblock" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."xblock"()
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
.annotate 'line', 636
  # rx rxquantr1431 ** 0..*
    set_addr $I10, rxquantr1431_done
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxquantr1431_loop:
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1428_pos, 5
    gt $I11, rx1428_eos, rx1428_fail
    sub $I11, rx1428_pos, rx1428_off
    substr $S10, rx1428_tgt, $I11, 5
    ne $S10, "elsif", rx1428_fail
    add rx1428_pos, 5
  # rx charclass s
    ge rx1428_pos, rx1428_eos, rx1428_fail
    sub $I10, rx1428_pos, rx1428_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1428_tgt, $I10
    unless $I11, rx1428_fail
    inc rx1428_pos
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."xblock"()
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
    set_addr $I10, rxquantr1431_done
    (rx1428_rep) = rx1428_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1431_done
    rx1428_cur."!mark_push"(rx1428_rep, rx1428_pos, $I10)
    goto rxquantr1431_loop
  rxquantr1431_done:
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
.annotate 'line', 637
  # rx rxquantr1432 ** 0..1
    set_addr $I10, rxquantr1432_done
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxquantr1432_loop:
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1428_pos, 4
    gt $I11, rx1428_eos, rx1428_fail
    sub $I11, rx1428_pos, rx1428_off
    substr $S10, rx1428_tgt, $I11, 4
    ne $S10, "else", rx1428_fail
    add rx1428_pos, 4
  # rx charclass s
    ge rx1428_pos, rx1428_eos, rx1428_fail
    sub $I10, rx1428_pos, rx1428_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1428_tgt, $I10
    unless $I11, rx1428_fail
    inc rx1428_pos
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."pblock"()
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
    set_addr $I10, rxquantr1432_done
    (rx1428_rep) = rx1428_cur."!mark_commit"($I10)
  rxquantr1432_done:
  # rx subrule "ws" subtype=method negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."ws"()
    unless $P10, rx1428_fail
    rx1428_pos = $P10."pos"()
.annotate 'line', 633
  # rx pass
    rx1428_cur."!cursor_pass"(rx1428_pos, "statement_control:sym<if>")
    if_null rx1428_debug, debug_990
    rx1428_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1428_pos)
  debug_990:
    .return (rx1428_cur)
  rx1428_restart:
.annotate 'line', 440
    if_null rx1428_debug, debug_991
    rx1428_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_991:
  rx1428_fail:
    (rx1428_rep, rx1428_pos, $I10, $P10) = rx1428_cur."!mark_fail"(0)
    lt rx1428_pos, -1, rx1428_done
    eq rx1428_pos, -1, rx1428_fail
    jump $I10
  rx1428_done:
    rx1428_cur."!cursor_fail"()
    if_null rx1428_debug, debug_992
    rx1428_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_992:
    .return (rx1428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("98_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P113, "ResizablePMCArray"
    push $P113, "if"
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("99_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1440 = "100_1312646121.678" 
    capture_lex $P1440
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_993
    rx1435_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1436_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1435_pos, 6
    gt $I11, rx1435_eos, rx1435_fail
    sub $I11, rx1435_pos, rx1435_off
    substr $S10, rx1435_tgt, $I11, 6
    ne $S10, "unless", rx1435_fail
    add rx1435_pos, 6
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1435_cur."!mark_peek"($I10)
    rx1435_cur."!cursor_pos"($I11)
    ($P10) = rx1435_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1435_pos, "")
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1435_fail
  rxcap_1437_done:
  # rx charclass s
    ge rx1435_pos, rx1435_eos, rx1435_fail
    sub $I10, rx1435_pos, rx1435_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1435_tgt, $I10
    unless $I11, rx1435_fail
    inc rx1435_pos
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
.annotate 'line', 642
  # rx subrule "xblock" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."xblock"()
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1435_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  alt1438_0:
.annotate 'line', 643
    set_addr $I10, alt1438_1
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1435_cur."!cursor_pos"(rx1435_pos)
    .const 'Sub' $P1440 = "100_1312646121.678" 
    capture_lex $P1440
    $P10 = rx1435_cur."before"($P1440)
    if $P10, rx1435_fail
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
    goto alt1438_end
  alt1438_1:
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  alt1438_end:
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
.annotate 'line', 640
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "statement_control:sym<unless>")
    if_null rx1435_debug, debug_998
    rx1435_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1435_pos)
  debug_998:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 440
    if_null rx1435_debug, debug_999
    rx1435_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_999:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1000
    rx1435_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_1000:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1439"  :anon :subid("100_1312646121.678") :method :outer("99_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 643
    .local string rx1441_tgt
    .local int rx1441_pos
    .local int rx1441_off
    .local int rx1441_eos
    .local int rx1441_rep
    .local pmc rx1441_cur
    .local pmc rx1441_debug
    (rx1441_cur, rx1441_pos, rx1441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1441_cur
    .local pmc match
    .lex "$/", match
    length rx1441_eos, rx1441_tgt
    gt rx1441_pos, rx1441_eos, rx1441_done
    set rx1441_off, 0
    lt rx1441_pos, 2, rx1441_start
    sub rx1441_off, rx1441_pos, 1
    substr rx1441_tgt, rx1441_tgt, rx1441_off
  rx1441_start:
    eq $I10, 1, rx1441_restart
    if_null rx1441_debug, debug_994
    rx1441_cur."!cursor_debug"("START", "")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1442_done
    goto rxscan1442_scan
  rxscan1442_loop:
    (rx1441_pos) = rx1441_cur."from"()
    inc rx1441_pos
    rx1441_cur."!cursor_from"(rx1441_pos)
    ge rx1441_pos, rx1441_eos, rxscan1442_done
  rxscan1442_scan:
    set_addr $I10, rxscan1442_loop
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
  rxscan1442_done:
  # rx literal  "else"
    add $I11, rx1441_pos, 4
    gt $I11, rx1441_eos, rx1441_fail
    sub $I11, rx1441_pos, rx1441_off
    substr $S10, rx1441_tgt, $I11, 4
    ne $S10, "else", rx1441_fail
    add rx1441_pos, 4
  # rx pass
    rx1441_cur."!cursor_pass"(rx1441_pos, "")
    if_null rx1441_debug, debug_995
    rx1441_cur."!cursor_debug"("PASS", "", " at pos=", rx1441_pos)
  debug_995:
    .return (rx1441_cur)
  rx1441_restart:
    if_null rx1441_debug, debug_996
    rx1441_cur."!cursor_debug"("NEXT", "")
  debug_996:
  rx1441_fail:
    (rx1441_rep, rx1441_pos, $I10, $P10) = rx1441_cur."!mark_fail"(0)
    lt rx1441_pos, -1, rx1441_done
    eq rx1441_pos, -1, rx1441_fail
    jump $I10
  rx1441_done:
    rx1441_cur."!cursor_fail"()
    if_null rx1441_debug, debug_997
    rx1441_cur."!cursor_debug"("FAIL", "")
  debug_997:
    .return (rx1441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("101_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P110, "ResizablePMCArray"
    push $P110, "unless"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("102_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1445_tgt
    .local int rx1445_pos
    .local int rx1445_off
    .local int rx1445_eos
    .local int rx1445_rep
    .local pmc rx1445_cur
    .local pmc rx1445_debug
    (rx1445_cur, rx1445_pos, rx1445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1445_cur
    .local pmc match
    .lex "$/", match
    length rx1445_eos, rx1445_tgt
    gt rx1445_pos, rx1445_eos, rx1445_done
    set rx1445_off, 0
    lt rx1445_pos, 2, rx1445_start
    sub rx1445_off, rx1445_pos, 1
    substr rx1445_tgt, rx1445_tgt, rx1445_off
  rx1445_start:
    eq $I10, 1, rx1445_restart
    if_null rx1445_debug, debug_1001
    rx1445_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1446_done
    goto rxscan1446_scan
  rxscan1446_loop:
    (rx1445_pos) = rx1445_cur."from"()
    inc rx1445_pos
    rx1445_cur."!cursor_from"(rx1445_pos)
    ge rx1445_pos, rx1445_eos, rxscan1446_done
  rxscan1446_scan:
    set_addr $I10, rxscan1446_loop
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  rxscan1446_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1448_fail
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  alt1447_0:
    set_addr $I10, alt1447_1
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  # rx literal  "while"
    add $I11, rx1445_pos, 5
    gt $I11, rx1445_eos, rx1445_fail
    sub $I11, rx1445_pos, rx1445_off
    substr $S10, rx1445_tgt, $I11, 5
    ne $S10, "while", rx1445_fail
    add rx1445_pos, 5
    goto alt1447_end
  alt1447_1:
  # rx literal  "until"
    add $I11, rx1445_pos, 5
    gt $I11, rx1445_eos, rx1445_fail
    sub $I11, rx1445_pos, rx1445_off
    substr $S10, rx1445_tgt, $I11, 5
    ne $S10, "until", rx1445_fail
    add rx1445_pos, 5
  alt1447_end:
    set_addr $I10, rxcap_1448_fail
    ($I12, $I11) = rx1445_cur."!mark_peek"($I10)
    rx1445_cur."!cursor_pos"($I11)
    ($P10) = rx1445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1445_pos, "")
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1448_done
  rxcap_1448_fail:
    goto rx1445_fail
  rxcap_1448_done:
  # rx charclass s
    ge rx1445_pos, rx1445_eos, rx1445_fail
    sub $I10, rx1445_pos, rx1445_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1445_tgt, $I10
    unless $I11, rx1445_fail
    inc rx1445_pos
  # rx subrule "ws" subtype=method negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."ws"()
    unless $P10, rx1445_fail
    rx1445_pos = $P10."pos"()
.annotate 'line', 648
  # rx subrule "xblock" subtype=capture negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."xblock"()
    unless $P10, rx1445_fail
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1445_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."ws"()
    unless $P10, rx1445_fail
    rx1445_pos = $P10."pos"()
.annotate 'line', 646
  # rx pass
    rx1445_cur."!cursor_pass"(rx1445_pos, "statement_control:sym<while>")
    if_null rx1445_debug, debug_1002
    rx1445_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1445_pos)
  debug_1002:
    .return (rx1445_cur)
  rx1445_restart:
.annotate 'line', 440
    if_null rx1445_debug, debug_1003
    rx1445_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_1003:
  rx1445_fail:
    (rx1445_rep, rx1445_pos, $I10, $P10) = rx1445_cur."!mark_fail"(0)
    lt rx1445_pos, -1, rx1445_done
    eq rx1445_pos, -1, rx1445_fail
    jump $I10
  rx1445_done:
    rx1445_cur."!cursor_fail"()
    if_null rx1445_debug, debug_1004
    rx1445_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_1004:
    .return (rx1445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("103_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P105, "ResizablePMCArray"
    push $P105, "until"
    push $P105, "while"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("104_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1451_tgt
    .local int rx1451_pos
    .local int rx1451_off
    .local int rx1451_eos
    .local int rx1451_rep
    .local pmc rx1451_cur
    .local pmc rx1451_debug
    (rx1451_cur, rx1451_pos, rx1451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1451_cur
    .local pmc match
    .lex "$/", match
    length rx1451_eos, rx1451_tgt
    gt rx1451_pos, rx1451_eos, rx1451_done
    set rx1451_off, 0
    lt rx1451_pos, 2, rx1451_start
    sub rx1451_off, rx1451_pos, 1
    substr rx1451_tgt, rx1451_tgt, rx1451_off
  rx1451_start:
    eq $I10, 1, rx1451_restart
    if_null rx1451_debug, debug_1005
    rx1451_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1451_pos) = rx1451_cur."from"()
    inc rx1451_pos
    rx1451_cur."!cursor_from"(rx1451_pos)
    ge rx1451_pos, rx1451_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  rxscan1452_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1453_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1451_pos, 6
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    substr $S10, rx1451_tgt, $I11, 6
    ne $S10, "repeat", rx1451_fail
    add rx1451_pos, 6
    set_addr $I10, rxcap_1453_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1453_done
  rxcap_1453_fail:
    goto rx1451_fail
  rxcap_1453_done:
  # rx charclass s
    ge rx1451_pos, rx1451_eos, rx1451_fail
    sub $I10, rx1451_pos, rx1451_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1451_tgt, $I10
    unless $I11, rx1451_fail
    inc rx1451_pos
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  alt1454_0:
.annotate 'line', 653
    set_addr $I10, alt1454_1
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
.annotate 'line', 654
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1456_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  alt1455_0:
    set_addr $I10, alt1455_1
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "while"
    add $I11, rx1451_pos, 5
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    substr $S10, rx1451_tgt, $I11, 5
    ne $S10, "while", rx1451_fail
    add rx1451_pos, 5
    goto alt1455_end
  alt1455_1:
  # rx literal  "until"
    add $I11, rx1451_pos, 5
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    substr $S10, rx1451_tgt, $I11, 5
    ne $S10, "until", rx1451_fail
    add rx1451_pos, 5
  alt1455_end:
    set_addr $I10, rxcap_1456_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1456_done
  rxcap_1456_fail:
    goto rx1451_fail
  rxcap_1456_done:
  # rx charclass s
    ge rx1451_pos, rx1451_eos, rx1451_fail
    sub $I10, rx1451_pos, rx1451_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1451_tgt, $I10
    unless $I11, rx1451_fail
    inc rx1451_pos
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."xblock"()
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
    goto alt1454_end
  alt1454_1:
.annotate 'line', 655
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."pblock"()
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1458_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  alt1457_0:
    set_addr $I10, alt1457_1
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "while"
    add $I11, rx1451_pos, 5
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    substr $S10, rx1451_tgt, $I11, 5
    ne $S10, "while", rx1451_fail
    add rx1451_pos, 5
    goto alt1457_end
  alt1457_1:
  # rx literal  "until"
    add $I11, rx1451_pos, 5
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    substr $S10, rx1451_tgt, $I11, 5
    ne $S10, "until", rx1451_fail
    add rx1451_pos, 5
  alt1457_end:
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1451_fail
  rxcap_1458_done:
  # rx charclass s
    ge rx1451_pos, rx1451_eos, rx1451_fail
    sub $I10, rx1451_pos, rx1451_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1451_tgt, $I10
    unless $I11, rx1451_fail
    inc rx1451_pos
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."EXPR"()
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
  alt1454_end:
.annotate 'line', 656
  # rx subrule "ws" subtype=method negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."ws"()
    unless $P10, rx1451_fail
    rx1451_pos = $P10."pos"()
.annotate 'line', 651
  # rx pass
    rx1451_cur."!cursor_pass"(rx1451_pos, "statement_control:sym<repeat>")
    if_null rx1451_debug, debug_1006
    rx1451_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1451_pos)
  debug_1006:
    .return (rx1451_cur)
  rx1451_restart:
.annotate 'line', 440
    if_null rx1451_debug, debug_1007
    rx1451_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_1007:
  rx1451_fail:
    (rx1451_rep, rx1451_pos, $I10, $P10) = rx1451_cur."!mark_fail"(0)
    lt rx1451_pos, -1, rx1451_done
    eq rx1451_pos, -1, rx1451_fail
    jump $I10
  rx1451_done:
    rx1451_cur."!cursor_fail"()
    if_null rx1451_debug, debug_1008
    rx1451_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_1008:
    .return (rx1451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("105_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P112, "ResizablePMCArray"
    push $P112, "repeat"
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("106_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1009
    rx1461_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1462_done
    goto rxscan1462_scan
  rxscan1462_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1462_done
  rxscan1462_scan:
    set_addr $I10, rxscan1462_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1462_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1463_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "for"
    add $I11, rx1461_pos, 3
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 3
    ne $S10, "for", rx1461_fail
    add rx1461_pos, 3
    set_addr $I10, rxcap_1463_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1463_done
  rxcap_1463_fail:
    goto rx1461_fail
  rxcap_1463_done:
  # rx charclass s
    ge rx1461_pos, rx1461_eos, rx1461_fail
    sub $I10, rx1461_pos, rx1461_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1461_tgt, $I10
    unless $I11, rx1461_fail
    inc rx1461_pos
  # rx subrule "ws" subtype=method negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."ws"()
    unless $P10, rx1461_fail
    rx1461_pos = $P10."pos"()
.annotate 'line', 661
  # rx subrule "xblock" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."xblock"()
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1461_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."ws"()
    unless $P10, rx1461_fail
    rx1461_pos = $P10."pos"()
.annotate 'line', 659
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "statement_control:sym<for>")
    if_null rx1461_debug, debug_1010
    rx1461_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1461_pos)
  debug_1010:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 440
    if_null rx1461_debug, debug_1011
    rx1461_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_1011:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1012
    rx1461_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_1012:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("107_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P105, "ResizablePMCArray"
    push $P105, "for"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("108_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1013
    rx1466_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1467_done
    goto rxscan1467_scan
  rxscan1467_loop:
    (rx1466_pos) = rx1466_cur."from"()
    inc rx1466_pos
    rx1466_cur."!cursor_from"(rx1466_pos)
    ge rx1466_pos, rx1466_eos, rxscan1467_done
  rxscan1467_scan:
    set_addr $I10, rxscan1467_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1467_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1468_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1466_pos, 5
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    substr $S10, rx1466_tgt, $I11, 5
    ne $S10, "CATCH", rx1466_fail
    add rx1466_pos, 5
    set_addr $I10, rxcap_1468_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1468_done
  rxcap_1468_fail:
    goto rx1466_fail
  rxcap_1468_done:
  # rx charclass s
    ge rx1466_pos, rx1466_eos, rx1466_fail
    sub $I10, rx1466_pos, rx1466_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1466_tgt, $I10
    unless $I11, rx1466_fail
    inc rx1466_pos
  # rx subrule "ws" subtype=method negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."ws"()
    unless $P10, rx1466_fail
    rx1466_pos = $P10."pos"()
.annotate 'line', 666
  # rx subrule "block" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."block"()
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1466_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."ws"()
    unless $P10, rx1466_fail
    rx1466_pos = $P10."pos"()
.annotate 'line', 664
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "statement_control:sym<CATCH>")
    if_null rx1466_debug, debug_1014
    rx1466_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1466_pos)
  debug_1014:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 440
    if_null rx1466_debug, debug_1015
    rx1466_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1015:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1016
    rx1466_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1016:
    .return (rx1466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("109_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P105, "ResizablePMCArray"
    push $P105, "CATCH"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("110_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1471_tgt
    .local int rx1471_pos
    .local int rx1471_off
    .local int rx1471_eos
    .local int rx1471_rep
    .local pmc rx1471_cur
    .local pmc rx1471_debug
    (rx1471_cur, rx1471_pos, rx1471_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1471_cur
    .local pmc match
    .lex "$/", match
    length rx1471_eos, rx1471_tgt
    gt rx1471_pos, rx1471_eos, rx1471_done
    set rx1471_off, 0
    lt rx1471_pos, 2, rx1471_start
    sub rx1471_off, rx1471_pos, 1
    substr rx1471_tgt, rx1471_tgt, rx1471_off
  rx1471_start:
    eq $I10, 1, rx1471_restart
    if_null rx1471_debug, debug_1017
    rx1471_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1471_pos) = rx1471_cur."from"()
    inc rx1471_pos
    rx1471_cur."!cursor_from"(rx1471_pos)
    ge rx1471_pos, rx1471_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  rxscan1472_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1471_pos, 7
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 7
    ne $S10, "CONTROL", rx1471_fail
    add rx1471_pos, 7
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1471_cur."!mark_peek"($I10)
    rx1471_cur."!cursor_pos"($I11)
    ($P10) = rx1471_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1471_pos, "")
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1471_fail
  rxcap_1473_done:
  # rx charclass s
    ge rx1471_pos, rx1471_eos, rx1471_fail
    sub $I10, rx1471_pos, rx1471_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1471_tgt, $I10
    unless $I11, rx1471_fail
    inc rx1471_pos
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
.annotate 'line', 671
  # rx subrule "block" subtype=capture negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."block"()
    unless $P10, rx1471_fail
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1471_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
.annotate 'line', 669
  # rx pass
    rx1471_cur."!cursor_pass"(rx1471_pos, "statement_control:sym<CONTROL>")
    if_null rx1471_debug, debug_1018
    rx1471_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1471_pos)
  debug_1018:
    .return (rx1471_cur)
  rx1471_restart:
.annotate 'line', 440
    if_null rx1471_debug, debug_1019
    rx1471_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1019:
  rx1471_fail:
    (rx1471_rep, rx1471_pos, $I10, $P10) = rx1471_cur."!mark_fail"(0)
    lt rx1471_pos, -1, rx1471_done
    eq rx1471_pos, -1, rx1471_fail
    jump $I10
  rx1471_done:
    rx1471_cur."!cursor_fail"()
    if_null rx1471_debug, debug_1020
    rx1471_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1020:
    .return (rx1471_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("111_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P105, "ResizablePMCArray"
    push $P105, "CONTROL"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("112_1312646121.678")
    .param pmc param_1476
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 674
    .lex "self", param_1476
    $P103 = param_1476."!protoregex"("statement_prefix")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("113_1312646121.678")
    .param pmc param_1478
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 674
    .lex "self", param_1478
    $P104 = param_1478."!PREFIX__!protoregex"("statement_prefix")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("114_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1480_tgt
    .local int rx1480_pos
    .local int rx1480_off
    .local int rx1480_eos
    .local int rx1480_rep
    .local pmc rx1480_cur
    .local pmc rx1480_debug
    (rx1480_cur, rx1480_pos, rx1480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1480_cur
    .local pmc match
    .lex "$/", match
    length rx1480_eos, rx1480_tgt
    gt rx1480_pos, rx1480_eos, rx1480_done
    set rx1480_off, 0
    lt rx1480_pos, 2, rx1480_start
    sub rx1480_off, rx1480_pos, 1
    substr rx1480_tgt, rx1480_tgt, rx1480_off
  rx1480_start:
    eq $I10, 1, rx1480_restart
    if_null rx1480_debug, debug_1021
    rx1480_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1481_done
    goto rxscan1481_scan
  rxscan1481_loop:
    (rx1480_pos) = rx1480_cur."from"()
    inc rx1480_pos
    rx1480_cur."!cursor_from"(rx1480_pos)
    ge rx1480_pos, rx1480_eos, rxscan1481_done
  rxscan1481_scan:
    set_addr $I10, rxscan1481_loop
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  rxscan1481_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1482_fail
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1480_pos, 4
    gt $I11, rx1480_eos, rx1480_fail
    sub $I11, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I11, 4
    ne $S10, "INIT", rx1480_fail
    add rx1480_pos, 4
    set_addr $I10, rxcap_1482_fail
    ($I12, $I11) = rx1480_cur."!mark_peek"($I10)
    rx1480_cur."!cursor_pos"($I11)
    ($P10) = rx1480_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1480_pos, "")
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1482_done
  rxcap_1482_fail:
    goto rx1480_fail
  rxcap_1482_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."blorst"()
    unless $P10, rx1480_fail
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1480_pos = $P10."pos"()
  # rx pass
    rx1480_cur."!cursor_pass"(rx1480_pos, "statement_prefix:sym<INIT>")
    if_null rx1480_debug, debug_1022
    rx1480_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1480_pos)
  debug_1022:
    .return (rx1480_cur)
  rx1480_restart:
.annotate 'line', 440
    if_null rx1480_debug, debug_1023
    rx1480_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1023:
  rx1480_fail:
    (rx1480_rep, rx1480_pos, $I10, $P10) = rx1480_cur."!mark_fail"(0)
    lt rx1480_pos, -1, rx1480_done
    eq rx1480_pos, -1, rx1480_fail
    jump $I10
  rx1480_done:
    rx1480_cur."!cursor_fail"()
    if_null rx1480_debug, debug_1024
    rx1480_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1024:
    .return (rx1480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("115_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("116_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1485_tgt
    .local int rx1485_pos
    .local int rx1485_off
    .local int rx1485_eos
    .local int rx1485_rep
    .local pmc rx1485_cur
    .local pmc rx1485_debug
    (rx1485_cur, rx1485_pos, rx1485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1485_cur
    .local pmc match
    .lex "$/", match
    length rx1485_eos, rx1485_tgt
    gt rx1485_pos, rx1485_eos, rx1485_done
    set rx1485_off, 0
    lt rx1485_pos, 2, rx1485_start
    sub rx1485_off, rx1485_pos, 1
    substr rx1485_tgt, rx1485_tgt, rx1485_off
  rx1485_start:
    eq $I10, 1, rx1485_restart
    if_null rx1485_debug, debug_1025
    rx1485_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1485_pos) = rx1485_cur."from"()
    inc rx1485_pos
    rx1485_cur."!cursor_from"(rx1485_pos)
    ge rx1485_pos, rx1485_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  rxscan1486_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1487_fail
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  # rx literal  "try"
    add $I11, rx1485_pos, 3
    gt $I11, rx1485_eos, rx1485_fail
    sub $I11, rx1485_pos, rx1485_off
    substr $S10, rx1485_tgt, $I11, 3
    ne $S10, "try", rx1485_fail
    add rx1485_pos, 3
    set_addr $I10, rxcap_1487_fail
    ($I12, $I11) = rx1485_cur."!mark_peek"($I10)
    rx1485_cur."!cursor_pos"($I11)
    ($P10) = rx1485_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1485_pos, "")
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1487_done
  rxcap_1487_fail:
    goto rx1485_fail
  rxcap_1487_done:
.annotate 'line', 679
  # rx subrule "blorst" subtype=capture negate=
    rx1485_cur."!cursor_pos"(rx1485_pos)
    $P10 = rx1485_cur."blorst"()
    unless $P10, rx1485_fail
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1485_pos = $P10."pos"()
.annotate 'line', 677
  # rx pass
    rx1485_cur."!cursor_pass"(rx1485_pos, "statement_prefix:sym<try>")
    if_null rx1485_debug, debug_1026
    rx1485_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1485_pos)
  debug_1026:
    .return (rx1485_cur)
  rx1485_restart:
.annotate 'line', 440
    if_null rx1485_debug, debug_1027
    rx1485_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1027:
  rx1485_fail:
    (rx1485_rep, rx1485_pos, $I10, $P10) = rx1485_cur."!mark_fail"(0)
    lt rx1485_pos, -1, rx1485_done
    eq rx1485_pos, -1, rx1485_fail
    jump $I10
  rx1485_done:
    rx1485_cur."!cursor_fail"()
    if_null rx1485_debug, debug_1028
    rx1485_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1028:
    .return (rx1485_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("117_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("blorst", "try")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("118_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1490_tgt
    .local int rx1490_pos
    .local int rx1490_off
    .local int rx1490_eos
    .local int rx1490_rep
    .local pmc rx1490_cur
    .local pmc rx1490_debug
    (rx1490_cur, rx1490_pos, rx1490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1490_cur
    .local pmc match
    .lex "$/", match
    length rx1490_eos, rx1490_tgt
    gt rx1490_pos, rx1490_eos, rx1490_done
    set rx1490_off, 0
    lt rx1490_pos, 2, rx1490_start
    sub rx1490_off, rx1490_pos, 1
    substr rx1490_tgt, rx1490_tgt, rx1490_off
  rx1490_start:
    eq $I10, 1, rx1490_restart
    if_null rx1490_debug, debug_1029
    rx1490_cur."!cursor_debug"("START", "blorst")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1490_pos) = rx1490_cur."from"()
    inc rx1490_pos
    rx1490_cur."!cursor_from"(rx1490_pos)
    ge rx1490_pos, rx1490_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1490_cur."!mark_push"(0, rx1490_pos, $I10)
  rxscan1491_done:
.annotate 'line', 683
  # rx charclass s
    ge rx1490_pos, rx1490_eos, rx1490_fail
    sub $I10, rx1490_pos, rx1490_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1490_tgt, $I10
    unless $I11, rx1490_fail
    inc rx1490_pos
  # rx subrule "ws" subtype=method negate=
    rx1490_cur."!cursor_pos"(rx1490_pos)
    $P10 = rx1490_cur."ws"()
    unless $P10, rx1490_fail
    rx1490_pos = $P10."pos"()
  alt1492_0:
    set_addr $I10, alt1492_1
    rx1490_cur."!mark_push"(0, rx1490_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1490_pos, rx1490_off
    substr $S10, rx1490_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1490_fail
  # rx subrule "block" subtype=capture negate=
    rx1490_cur."!cursor_pos"(rx1490_pos)
    $P10 = rx1490_cur."block"()
    unless $P10, rx1490_fail
    rx1490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1490_pos = $P10."pos"()
    goto alt1492_end
  alt1492_1:
  # rx subrule "statement" subtype=capture negate=
    rx1490_cur."!cursor_pos"(rx1490_pos)
    $P10 = rx1490_cur."statement"()
    unless $P10, rx1490_fail
    rx1490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1490_pos = $P10."pos"()
  alt1492_end:
.annotate 'line', 682
  # rx pass
    rx1490_cur."!cursor_pass"(rx1490_pos, "blorst")
    if_null rx1490_debug, debug_1030
    rx1490_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1490_pos)
  debug_1030:
    .return (rx1490_cur)
  rx1490_restart:
.annotate 'line', 440
    if_null rx1490_debug, debug_1031
    rx1490_cur."!cursor_debug"("NEXT", "blorst")
  debug_1031:
  rx1490_fail:
    (rx1490_rep, rx1490_pos, $I10, $P10) = rx1490_cur."!mark_fail"(0)
    lt rx1490_pos, -1, rx1490_done
    eq rx1490_pos, -1, rx1490_fail
    jump $I10
  rx1490_done:
    rx1490_cur."!cursor_fail"()
    if_null rx1490_debug, debug_1032
    rx1490_cur."!cursor_debug"("FAIL", "blorst")
  debug_1032:
    .return (rx1490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("119_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("120_1312646121.678")
    .param pmc param_1495
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 688
    .lex "self", param_1495
    $P103 = param_1495."!protoregex"("statement_mod_cond")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("121_1312646121.678")
    .param pmc param_1497
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 688
    .lex "self", param_1497
    $P104 = param_1497."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("122_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1499_tgt
    .local int rx1499_pos
    .local int rx1499_off
    .local int rx1499_eos
    .local int rx1499_rep
    .local pmc rx1499_cur
    .local pmc rx1499_debug
    (rx1499_cur, rx1499_pos, rx1499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1499_cur
    .local pmc match
    .lex "$/", match
    length rx1499_eos, rx1499_tgt
    gt rx1499_pos, rx1499_eos, rx1499_done
    set rx1499_off, 0
    lt rx1499_pos, 2, rx1499_start
    sub rx1499_off, rx1499_pos, 1
    substr rx1499_tgt, rx1499_tgt, rx1499_off
  rx1499_start:
    eq $I10, 1, rx1499_restart
    if_null rx1499_debug, debug_1033
    rx1499_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1500_done
    goto rxscan1500_scan
  rxscan1500_loop:
    (rx1499_pos) = rx1499_cur."from"()
    inc rx1499_pos
    rx1499_cur."!cursor_from"(rx1499_pos)
    ge rx1499_pos, rx1499_eos, rxscan1500_done
  rxscan1500_scan:
    set_addr $I10, rxscan1500_loop
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  rxscan1500_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1501_fail
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  # rx literal  "if"
    add $I11, rx1499_pos, 2
    gt $I11, rx1499_eos, rx1499_fail
    sub $I11, rx1499_pos, rx1499_off
    substr $S10, rx1499_tgt, $I11, 2
    ne $S10, "if", rx1499_fail
    add rx1499_pos, 2
    set_addr $I10, rxcap_1501_fail
    ($I12, $I11) = rx1499_cur."!mark_peek"($I10)
    rx1499_cur."!cursor_pos"($I11)
    ($P10) = rx1499_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1499_pos, "")
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1501_done
  rxcap_1501_fail:
    goto rx1499_fail
  rxcap_1501_done:
  # rx subrule "ws" subtype=method negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."ws"()
    unless $P10, rx1499_fail
    rx1499_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."EXPR"()
    unless $P10, rx1499_fail
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1499_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."ws"()
    unless $P10, rx1499_fail
    rx1499_pos = $P10."pos"()
  # rx pass
    rx1499_cur."!cursor_pass"(rx1499_pos, "statement_mod_cond:sym<if>")
    if_null rx1499_debug, debug_1034
    rx1499_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1499_pos)
  debug_1034:
    .return (rx1499_cur)
  rx1499_restart:
.annotate 'line', 440
    if_null rx1499_debug, debug_1035
    rx1499_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1035:
  rx1499_fail:
    (rx1499_rep, rx1499_pos, $I10, $P10) = rx1499_cur."!mark_fail"(0)
    lt rx1499_pos, -1, rx1499_done
    eq rx1499_pos, -1, rx1499_fail
    jump $I10
  rx1499_done:
    rx1499_cur."!cursor_fail"()
    if_null rx1499_debug, debug_1036
    rx1499_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1036:
    .return (rx1499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("123_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "if")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("124_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1504_tgt
    .local int rx1504_pos
    .local int rx1504_off
    .local int rx1504_eos
    .local int rx1504_rep
    .local pmc rx1504_cur
    .local pmc rx1504_debug
    (rx1504_cur, rx1504_pos, rx1504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1504_cur
    .local pmc match
    .lex "$/", match
    length rx1504_eos, rx1504_tgt
    gt rx1504_pos, rx1504_eos, rx1504_done
    set rx1504_off, 0
    lt rx1504_pos, 2, rx1504_start
    sub rx1504_off, rx1504_pos, 1
    substr rx1504_tgt, rx1504_tgt, rx1504_off
  rx1504_start:
    eq $I10, 1, rx1504_restart
    if_null rx1504_debug, debug_1037
    rx1504_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1505_done
    goto rxscan1505_scan
  rxscan1505_loop:
    (rx1504_pos) = rx1504_cur."from"()
    inc rx1504_pos
    rx1504_cur."!cursor_from"(rx1504_pos)
    ge rx1504_pos, rx1504_eos, rxscan1505_done
  rxscan1505_scan:
    set_addr $I10, rxscan1505_loop
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  rxscan1505_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1506_fail
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1504_pos, 6
    gt $I11, rx1504_eos, rx1504_fail
    sub $I11, rx1504_pos, rx1504_off
    substr $S10, rx1504_tgt, $I11, 6
    ne $S10, "unless", rx1504_fail
    add rx1504_pos, 6
    set_addr $I10, rxcap_1506_fail
    ($I12, $I11) = rx1504_cur."!mark_peek"($I10)
    rx1504_cur."!cursor_pos"($I11)
    ($P10) = rx1504_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1504_pos, "")
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1506_done
  rxcap_1506_fail:
    goto rx1504_fail
  rxcap_1506_done:
  # rx subrule "ws" subtype=method negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."ws"()
    unless $P10, rx1504_fail
    rx1504_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."EXPR"()
    unless $P10, rx1504_fail
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1504_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."ws"()
    unless $P10, rx1504_fail
    rx1504_pos = $P10."pos"()
  # rx pass
    rx1504_cur."!cursor_pass"(rx1504_pos, "statement_mod_cond:sym<unless>")
    if_null rx1504_debug, debug_1038
    rx1504_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1504_pos)
  debug_1038:
    .return (rx1504_cur)
  rx1504_restart:
.annotate 'line', 440
    if_null rx1504_debug, debug_1039
    rx1504_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1039:
  rx1504_fail:
    (rx1504_rep, rx1504_pos, $I10, $P10) = rx1504_cur."!mark_fail"(0)
    lt rx1504_pos, -1, rx1504_done
    eq rx1504_pos, -1, rx1504_fail
    jump $I10
  rx1504_done:
    rx1504_cur."!cursor_fail"()
    if_null rx1504_debug, debug_1040
    rx1504_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1040:
    .return (rx1504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("125_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "unless")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("126_1312646121.678")
    .param pmc param_1509
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 693
    .lex "self", param_1509
    $P103 = param_1509."!protoregex"("statement_mod_loop")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("127_1312646121.678")
    .param pmc param_1511
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 693
    .lex "self", param_1511
    $P104 = param_1511."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("128_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1513_tgt
    .local int rx1513_pos
    .local int rx1513_off
    .local int rx1513_eos
    .local int rx1513_rep
    .local pmc rx1513_cur
    .local pmc rx1513_debug
    (rx1513_cur, rx1513_pos, rx1513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1513_cur
    .local pmc match
    .lex "$/", match
    length rx1513_eos, rx1513_tgt
    gt rx1513_pos, rx1513_eos, rx1513_done
    set rx1513_off, 0
    lt rx1513_pos, 2, rx1513_start
    sub rx1513_off, rx1513_pos, 1
    substr rx1513_tgt, rx1513_tgt, rx1513_off
  rx1513_start:
    eq $I10, 1, rx1513_restart
    if_null rx1513_debug, debug_1041
    rx1513_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1514_done
    goto rxscan1514_scan
  rxscan1514_loop:
    (rx1513_pos) = rx1513_cur."from"()
    inc rx1513_pos
    rx1513_cur."!cursor_from"(rx1513_pos)
    ge rx1513_pos, rx1513_eos, rxscan1514_done
  rxscan1514_scan:
    set_addr $I10, rxscan1514_loop
    rx1513_cur."!mark_push"(0, rx1513_pos, $I10)
  rxscan1514_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_1515_fail
    rx1513_cur."!mark_push"(0, rx1513_pos, $I10)
  # rx literal  "while"
    add $I11, rx1513_pos, 5
    gt $I11, rx1513_eos, rx1513_fail
    sub $I11, rx1513_pos, rx1513_off
    substr $S10, rx1513_tgt, $I11, 5
    ne $S10, "while", rx1513_fail
    add rx1513_pos, 5
    set_addr $I10, rxcap_1515_fail
    ($I12, $I11) = rx1513_cur."!mark_peek"($I10)
    rx1513_cur."!cursor_pos"($I11)
    ($P10) = rx1513_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1513_pos, "")
    rx1513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1515_done
  rxcap_1515_fail:
    goto rx1513_fail
  rxcap_1515_done:
  # rx subrule "ws" subtype=method negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."ws"()
    unless $P10, rx1513_fail
    rx1513_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."EXPR"()
    unless $P10, rx1513_fail
    rx1513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1513_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."ws"()
    unless $P10, rx1513_fail
    rx1513_pos = $P10."pos"()
  # rx pass
    rx1513_cur."!cursor_pass"(rx1513_pos, "statement_mod_loop:sym<while>")
    if_null rx1513_debug, debug_1042
    rx1513_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1513_pos)
  debug_1042:
    .return (rx1513_cur)
  rx1513_restart:
.annotate 'line', 440
    if_null rx1513_debug, debug_1043
    rx1513_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1043:
  rx1513_fail:
    (rx1513_rep, rx1513_pos, $I10, $P10) = rx1513_cur."!mark_fail"(0)
    lt rx1513_pos, -1, rx1513_done
    eq rx1513_pos, -1, rx1513_fail
    jump $I10
  rx1513_done:
    rx1513_cur."!cursor_fail"()
    if_null rx1513_debug, debug_1044
    rx1513_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1044:
    .return (rx1513_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("129_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "while")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("130_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1518_tgt
    .local int rx1518_pos
    .local int rx1518_off
    .local int rx1518_eos
    .local int rx1518_rep
    .local pmc rx1518_cur
    .local pmc rx1518_debug
    (rx1518_cur, rx1518_pos, rx1518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1518_cur
    .local pmc match
    .lex "$/", match
    length rx1518_eos, rx1518_tgt
    gt rx1518_pos, rx1518_eos, rx1518_done
    set rx1518_off, 0
    lt rx1518_pos, 2, rx1518_start
    sub rx1518_off, rx1518_pos, 1
    substr rx1518_tgt, rx1518_tgt, rx1518_off
  rx1518_start:
    eq $I10, 1, rx1518_restart
    if_null rx1518_debug, debug_1045
    rx1518_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1519_done
    goto rxscan1519_scan
  rxscan1519_loop:
    (rx1518_pos) = rx1518_cur."from"()
    inc rx1518_pos
    rx1518_cur."!cursor_from"(rx1518_pos)
    ge rx1518_pos, rx1518_eos, rxscan1519_done
  rxscan1519_scan:
    set_addr $I10, rxscan1519_loop
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  rxscan1519_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1520_fail
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  # rx literal  "until"
    add $I11, rx1518_pos, 5
    gt $I11, rx1518_eos, rx1518_fail
    sub $I11, rx1518_pos, rx1518_off
    substr $S10, rx1518_tgt, $I11, 5
    ne $S10, "until", rx1518_fail
    add rx1518_pos, 5
    set_addr $I10, rxcap_1520_fail
    ($I12, $I11) = rx1518_cur."!mark_peek"($I10)
    rx1518_cur."!cursor_pos"($I11)
    ($P10) = rx1518_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1518_pos, "")
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1520_done
  rxcap_1520_fail:
    goto rx1518_fail
  rxcap_1520_done:
  # rx subrule "ws" subtype=method negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."ws"()
    unless $P10, rx1518_fail
    rx1518_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."EXPR"()
    unless $P10, rx1518_fail
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1518_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."ws"()
    unless $P10, rx1518_fail
    rx1518_pos = $P10."pos"()
  # rx pass
    rx1518_cur."!cursor_pass"(rx1518_pos, "statement_mod_loop:sym<until>")
    if_null rx1518_debug, debug_1046
    rx1518_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1518_pos)
  debug_1046:
    .return (rx1518_cur)
  rx1518_restart:
.annotate 'line', 440
    if_null rx1518_debug, debug_1047
    rx1518_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1047:
  rx1518_fail:
    (rx1518_rep, rx1518_pos, $I10, $P10) = rx1518_cur."!mark_fail"(0)
    lt rx1518_pos, -1, rx1518_done
    eq rx1518_pos, -1, rx1518_fail
    jump $I10
  rx1518_done:
    rx1518_cur."!cursor_fail"()
    if_null rx1518_debug, debug_1048
    rx1518_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1048:
    .return (rx1518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("131_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "until")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("132_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1523_tgt
    .local int rx1523_pos
    .local int rx1523_off
    .local int rx1523_eos
    .local int rx1523_rep
    .local pmc rx1523_cur
    .local pmc rx1523_debug
    (rx1523_cur, rx1523_pos, rx1523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1523_cur
    .local pmc match
    .lex "$/", match
    length rx1523_eos, rx1523_tgt
    gt rx1523_pos, rx1523_eos, rx1523_done
    set rx1523_off, 0
    lt rx1523_pos, 2, rx1523_start
    sub rx1523_off, rx1523_pos, 1
    substr rx1523_tgt, rx1523_tgt, rx1523_off
  rx1523_start:
    eq $I10, 1, rx1523_restart
    if_null rx1523_debug, debug_1049
    rx1523_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1524_done
    goto rxscan1524_scan
  rxscan1524_loop:
    (rx1523_pos) = rx1523_cur."from"()
    inc rx1523_pos
    rx1523_cur."!cursor_from"(rx1523_pos)
    ge rx1523_pos, rx1523_eos, rxscan1524_done
  rxscan1524_scan:
    set_addr $I10, rxscan1524_loop
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  rxscan1524_done:
.annotate 'line', 697
  # rx subcapture "sym"
    set_addr $I10, rxcap_1525_fail
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  # rx literal  "for"
    add $I11, rx1523_pos, 3
    gt $I11, rx1523_eos, rx1523_fail
    sub $I11, rx1523_pos, rx1523_off
    substr $S10, rx1523_tgt, $I11, 3
    ne $S10, "for", rx1523_fail
    add rx1523_pos, 3
    set_addr $I10, rxcap_1525_fail
    ($I12, $I11) = rx1523_cur."!mark_peek"($I10)
    rx1523_cur."!cursor_pos"($I11)
    ($P10) = rx1523_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1523_pos, "")
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1525_done
  rxcap_1525_fail:
    goto rx1523_fail
  rxcap_1525_done:
  # rx subrule "ws" subtype=method negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."ws"()
    unless $P10, rx1523_fail
    rx1523_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."EXPR"()
    unless $P10, rx1523_fail
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1523_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."ws"()
    unless $P10, rx1523_fail
    rx1523_pos = $P10."pos"()
  # rx pass
    rx1523_cur."!cursor_pass"(rx1523_pos, "statement_mod_loop:sym<for>")
    if_null rx1523_debug, debug_1050
    rx1523_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1523_pos)
  debug_1050:
    .return (rx1523_cur)
  rx1523_restart:
.annotate 'line', 440
    if_null rx1523_debug, debug_1051
    rx1523_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1051:
  rx1523_fail:
    (rx1523_rep, rx1523_pos, $I10, $P10) = rx1523_cur."!mark_fail"(0)
    lt rx1523_pos, -1, rx1523_done
    eq rx1523_pos, -1, rx1523_fail
    jump $I10
  rx1523_done:
    rx1523_cur."!cursor_fail"()
    if_null rx1523_debug, debug_1052
    rx1523_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1052:
    .return (rx1523_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("133_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "for")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("134_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1053
    rx1528_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1529_done
    goto rxscan1529_scan
  rxscan1529_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1529_done
  rxscan1529_scan:
    set_addr $I10, rxscan1529_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1529_done:
.annotate 'line', 701
  # rx subrule "fatarrow" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."fatarrow"()
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "term:sym<fatarrow>")
    if_null rx1528_debug, debug_1054
    rx1528_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1528_pos)
  debug_1054:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 440
    if_null rx1528_debug, debug_1055
    rx1528_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1055:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1056
    rx1528_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1056:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("135_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("136_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1532_tgt
    .local int rx1532_pos
    .local int rx1532_off
    .local int rx1532_eos
    .local int rx1532_rep
    .local pmc rx1532_cur
    .local pmc rx1532_debug
    (rx1532_cur, rx1532_pos, rx1532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1532_cur
    .local pmc match
    .lex "$/", match
    length rx1532_eos, rx1532_tgt
    gt rx1532_pos, rx1532_eos, rx1532_done
    set rx1532_off, 0
    lt rx1532_pos, 2, rx1532_start
    sub rx1532_off, rx1532_pos, 1
    substr rx1532_tgt, rx1532_tgt, rx1532_off
  rx1532_start:
    eq $I10, 1, rx1532_restart
    if_null rx1532_debug, debug_1057
    rx1532_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1532_pos) = rx1532_cur."from"()
    inc rx1532_pos
    rx1532_cur."!cursor_from"(rx1532_pos)
    ge rx1532_pos, rx1532_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1532_cur."!mark_push"(0, rx1532_pos, $I10)
  rxscan1533_done:
.annotate 'line', 702
  # rx subrule "colonpair" subtype=capture negate=
    rx1532_cur."!cursor_pos"(rx1532_pos)
    $P10 = rx1532_cur."colonpair"()
    unless $P10, rx1532_fail
    rx1532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1532_pos = $P10."pos"()
  # rx pass
    rx1532_cur."!cursor_pass"(rx1532_pos, "term:sym<colonpair>")
    if_null rx1532_debug, debug_1058
    rx1532_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1532_pos)
  debug_1058:
    .return (rx1532_cur)
  rx1532_restart:
.annotate 'line', 440
    if_null rx1532_debug, debug_1059
    rx1532_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1059:
  rx1532_fail:
    (rx1532_rep, rx1532_pos, $I10, $P10) = rx1532_cur."!mark_fail"(0)
    lt rx1532_pos, -1, rx1532_done
    eq rx1532_pos, -1, rx1532_fail
    jump $I10
  rx1532_done:
    rx1532_cur."!cursor_fail"()
    if_null rx1532_debug, debug_1060
    rx1532_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1060:
    .return (rx1532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("137_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("colonpair", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("138_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1536_tgt
    .local int rx1536_pos
    .local int rx1536_off
    .local int rx1536_eos
    .local int rx1536_rep
    .local pmc rx1536_cur
    .local pmc rx1536_debug
    (rx1536_cur, rx1536_pos, rx1536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1536_cur
    .local pmc match
    .lex "$/", match
    length rx1536_eos, rx1536_tgt
    gt rx1536_pos, rx1536_eos, rx1536_done
    set rx1536_off, 0
    lt rx1536_pos, 2, rx1536_start
    sub rx1536_off, rx1536_pos, 1
    substr rx1536_tgt, rx1536_tgt, rx1536_off
  rx1536_start:
    eq $I10, 1, rx1536_restart
    if_null rx1536_debug, debug_1061
    rx1536_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1537_done
    goto rxscan1537_scan
  rxscan1537_loop:
    (rx1536_pos) = rx1536_cur."from"()
    inc rx1536_pos
    rx1536_cur."!cursor_from"(rx1536_pos)
    ge rx1536_pos, rx1536_eos, rxscan1537_done
  rxscan1537_scan:
    set_addr $I10, rxscan1537_loop
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  rxscan1537_done:
.annotate 'line', 703
  # rx subrule "variable" subtype=capture negate=
    rx1536_cur."!cursor_pos"(rx1536_pos)
    $P10 = rx1536_cur."variable"()
    unless $P10, rx1536_fail
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1536_pos = $P10."pos"()
  # rx pass
    rx1536_cur."!cursor_pass"(rx1536_pos, "term:sym<variable>")
    if_null rx1536_debug, debug_1062
    rx1536_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1536_pos)
  debug_1062:
    .return (rx1536_cur)
  rx1536_restart:
.annotate 'line', 440
    if_null rx1536_debug, debug_1063
    rx1536_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1063:
  rx1536_fail:
    (rx1536_rep, rx1536_pos, $I10, $P10) = rx1536_cur."!mark_fail"(0)
    lt rx1536_pos, -1, rx1536_done
    eq rx1536_pos, -1, rx1536_fail
    jump $I10
  rx1536_done:
    rx1536_cur."!cursor_fail"()
    if_null rx1536_debug, debug_1064
    rx1536_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1064:
    .return (rx1536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("139_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("variable", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("140_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1540_tgt
    .local int rx1540_pos
    .local int rx1540_off
    .local int rx1540_eos
    .local int rx1540_rep
    .local pmc rx1540_cur
    .local pmc rx1540_debug
    (rx1540_cur, rx1540_pos, rx1540_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1540_cur
    .local pmc match
    .lex "$/", match
    length rx1540_eos, rx1540_tgt
    gt rx1540_pos, rx1540_eos, rx1540_done
    set rx1540_off, 0
    lt rx1540_pos, 2, rx1540_start
    sub rx1540_off, rx1540_pos, 1
    substr rx1540_tgt, rx1540_tgt, rx1540_off
  rx1540_start:
    eq $I10, 1, rx1540_restart
    if_null rx1540_debug, debug_1065
    rx1540_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1541_done
    goto rxscan1541_scan
  rxscan1541_loop:
    (rx1540_pos) = rx1540_cur."from"()
    inc rx1540_pos
    rx1540_cur."!cursor_from"(rx1540_pos)
    ge rx1540_pos, rx1540_eos, rxscan1541_done
  rxscan1541_scan:
    set_addr $I10, rxscan1541_loop
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  rxscan1541_done:
.annotate 'line', 704
  # rx subrule "package_declarator" subtype=capture negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."package_declarator"()
    unless $P10, rx1540_fail
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1540_pos = $P10."pos"()
  # rx pass
    rx1540_cur."!cursor_pass"(rx1540_pos, "term:sym<package_declarator>")
    if_null rx1540_debug, debug_1066
    rx1540_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1540_pos)
  debug_1066:
    .return (rx1540_cur)
  rx1540_restart:
.annotate 'line', 440
    if_null rx1540_debug, debug_1067
    rx1540_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1067:
  rx1540_fail:
    (rx1540_rep, rx1540_pos, $I10, $P10) = rx1540_cur."!mark_fail"(0)
    lt rx1540_pos, -1, rx1540_done
    eq rx1540_pos, -1, rx1540_fail
    jump $I10
  rx1540_done:
    rx1540_cur."!cursor_fail"()
    if_null rx1540_debug, debug_1068
    rx1540_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1068:
    .return (rx1540_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("141_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("142_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1544_tgt
    .local int rx1544_pos
    .local int rx1544_off
    .local int rx1544_eos
    .local int rx1544_rep
    .local pmc rx1544_cur
    .local pmc rx1544_debug
    (rx1544_cur, rx1544_pos, rx1544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1544_cur
    .local pmc match
    .lex "$/", match
    length rx1544_eos, rx1544_tgt
    gt rx1544_pos, rx1544_eos, rx1544_done
    set rx1544_off, 0
    lt rx1544_pos, 2, rx1544_start
    sub rx1544_off, rx1544_pos, 1
    substr rx1544_tgt, rx1544_tgt, rx1544_off
  rx1544_start:
    eq $I10, 1, rx1544_restart
    if_null rx1544_debug, debug_1069
    rx1544_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1545_done
    goto rxscan1545_scan
  rxscan1545_loop:
    (rx1544_pos) = rx1544_cur."from"()
    inc rx1544_pos
    rx1544_cur."!cursor_from"(rx1544_pos)
    ge rx1544_pos, rx1544_eos, rxscan1545_done
  rxscan1545_scan:
    set_addr $I10, rxscan1545_loop
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  rxscan1545_done:
.annotate 'line', 705
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."scope_declarator"()
    unless $P10, rx1544_fail
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1544_pos = $P10."pos"()
  # rx pass
    rx1544_cur."!cursor_pass"(rx1544_pos, "term:sym<scope_declarator>")
    if_null rx1544_debug, debug_1070
    rx1544_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1544_pos)
  debug_1070:
    .return (rx1544_cur)
  rx1544_restart:
.annotate 'line', 440
    if_null rx1544_debug, debug_1071
    rx1544_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1071:
  rx1544_fail:
    (rx1544_rep, rx1544_pos, $I10, $P10) = rx1544_cur."!mark_fail"(0)
    lt rx1544_pos, -1, rx1544_done
    eq rx1544_pos, -1, rx1544_fail
    jump $I10
  rx1544_done:
    rx1544_cur."!cursor_fail"()
    if_null rx1544_debug, debug_1072
    rx1544_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1072:
    .return (rx1544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("143_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("144_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1548_tgt
    .local int rx1548_pos
    .local int rx1548_off
    .local int rx1548_eos
    .local int rx1548_rep
    .local pmc rx1548_cur
    .local pmc rx1548_debug
    (rx1548_cur, rx1548_pos, rx1548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1548_cur
    .local pmc match
    .lex "$/", match
    length rx1548_eos, rx1548_tgt
    gt rx1548_pos, rx1548_eos, rx1548_done
    set rx1548_off, 0
    lt rx1548_pos, 2, rx1548_start
    sub rx1548_off, rx1548_pos, 1
    substr rx1548_tgt, rx1548_tgt, rx1548_off
  rx1548_start:
    eq $I10, 1, rx1548_restart
    if_null rx1548_debug, debug_1073
    rx1548_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1548_pos) = rx1548_cur."from"()
    inc rx1548_pos
    rx1548_cur."!cursor_from"(rx1548_pos)
    ge rx1548_pos, rx1548_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  rxscan1549_done:
.annotate 'line', 706
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."routine_declarator"()
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1548_pos = $P10."pos"()
  # rx pass
    rx1548_cur."!cursor_pass"(rx1548_pos, "term:sym<routine_declarator>")
    if_null rx1548_debug, debug_1074
    rx1548_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1548_pos)
  debug_1074:
    .return (rx1548_cur)
  rx1548_restart:
.annotate 'line', 440
    if_null rx1548_debug, debug_1075
    rx1548_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1075:
  rx1548_fail:
    (rx1548_rep, rx1548_pos, $I10, $P10) = rx1548_cur."!mark_fail"(0)
    lt rx1548_pos, -1, rx1548_done
    eq rx1548_pos, -1, rx1548_fail
    jump $I10
  rx1548_done:
    rx1548_cur."!cursor_fail"()
    if_null rx1548_debug, debug_1076
    rx1548_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1076:
    .return (rx1548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("145_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("146_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1560 = "148_1312646121.678" 
    capture_lex $P1560
    .const 'Sub' $P1555 = "147_1312646121.678" 
    capture_lex $P1555
    .local string rx1552_tgt
    .local int rx1552_pos
    .local int rx1552_off
    .local int rx1552_eos
    .local int rx1552_rep
    .local pmc rx1552_cur
    .local pmc rx1552_debug
    (rx1552_cur, rx1552_pos, rx1552_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1552_cur
    .local pmc match
    .lex "$/", match
    length rx1552_eos, rx1552_tgt
    gt rx1552_pos, rx1552_eos, rx1552_done
    set rx1552_off, 0
    lt rx1552_pos, 2, rx1552_start
    sub rx1552_off, rx1552_pos, 1
    substr rx1552_tgt, rx1552_tgt, rx1552_off
  rx1552_start:
    eq $I10, 1, rx1552_restart
    if_null rx1552_debug, debug_1077
    rx1552_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1552_pos) = rx1552_cur."from"()
    inc rx1552_pos
    rx1552_cur."!cursor_from"(rx1552_pos)
    ge rx1552_pos, rx1552_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  rxscan1553_done:
.annotate 'line', 708
  # rx subrule "before" subtype=zerowidth negate=
    rx1552_cur."!cursor_pos"(rx1552_pos)
    .const 'Sub' $P1555 = "147_1312646121.678" 
    capture_lex $P1555
    $P10 = rx1552_cur."before"($P1555)
    unless $P10, rx1552_fail
.annotate 'line', 709
  # rx subrule "before" subtype=zerowidth negate=1
    rx1552_cur."!cursor_pos"(rx1552_pos)
    .const 'Sub' $P1560 = "148_1312646121.678" 
    capture_lex $P1560
    $P10 = rx1552_cur."before"($P1560)
    if $P10, rx1552_fail
.annotate 'line', 710
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1552_cur."!cursor_pos"(rx1552_pos)
    $P10 = rx1552_cur."multi_declarator"()
    unless $P10, rx1552_fail
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1552_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx1552_cur."!cursor_pass"(rx1552_pos, "term:sym<multi_declarator>")
    if_null rx1552_debug, debug_1086
    rx1552_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1552_pos)
  debug_1086:
    .return (rx1552_cur)
  rx1552_restart:
.annotate 'line', 440
    if_null rx1552_debug, debug_1087
    rx1552_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1087:
  rx1552_fail:
    (rx1552_rep, rx1552_pos, $I10, $P10) = rx1552_cur."!mark_fail"(0)
    lt rx1552_pos, -1, rx1552_done
    eq rx1552_pos, -1, rx1552_fail
    jump $I10
  rx1552_done:
    rx1552_cur."!cursor_fail"()
    if_null rx1552_debug, debug_1088
    rx1552_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1088:
    .return (rx1552_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1554"  :anon :subid("147_1312646121.678") :method :outer("146_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 708
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1078
    rx1556_cur."!cursor_debug"("START", "")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1557_done
    goto rxscan1557_scan
  rxscan1557_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1557_done
  rxscan1557_scan:
    set_addr $I10, rxscan1557_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1557_done:
  alt1558_0:
    set_addr $I10, alt1558_1
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1556_pos, 5
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 5
    ne $S10, "multi", rx1556_fail
    add rx1556_pos, 5
    goto alt1558_end
  alt1558_1:
    set_addr $I10, alt1558_2
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1556_pos, 5
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 5
    ne $S10, "proto", rx1556_fail
    add rx1556_pos, 5
    goto alt1558_end
  alt1558_2:
  # rx literal  "only"
    add $I11, rx1556_pos, 4
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 4
    ne $S10, "only", rx1556_fail
    add rx1556_pos, 4
  alt1558_end:
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "")
    if_null rx1556_debug, debug_1079
    rx1556_cur."!cursor_debug"("PASS", "", " at pos=", rx1556_pos)
  debug_1079:
    .return (rx1556_cur)
  rx1556_restart:
    if_null rx1556_debug, debug_1080
    rx1556_cur."!cursor_debug"("NEXT", "")
  debug_1080:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1081
    rx1556_cur."!cursor_debug"("FAIL", "")
  debug_1081:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1559"  :anon :subid("148_1312646121.678") :method :outer("146_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 709
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1082
    rx1561_cur."!cursor_debug"("START", "")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1562_done:
  # rx literal  "proto"
    add $I11, rx1561_pos, 5
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    substr $S10, rx1561_tgt, $I11, 5
    ne $S10, "proto", rx1561_fail
    add rx1561_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."ws"()
    unless $P10, rx1561_fail
    rx1561_pos = $P10."pos"()
  alt1563_0:
    set_addr $I10, alt1563_1
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1561_pos, 5
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    substr $S10, rx1561_tgt, $I11, 5
    ne $S10, "regex", rx1561_fail
    add rx1561_pos, 5
    goto alt1563_end
  alt1563_1:
    set_addr $I10, alt1563_2
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  # rx literal  "token"
    add $I11, rx1561_pos, 5
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    substr $S10, rx1561_tgt, $I11, 5
    ne $S10, "token", rx1561_fail
    add rx1561_pos, 5
    goto alt1563_end
  alt1563_2:
  # rx literal  "rule"
    add $I11, rx1561_pos, 4
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    substr $S10, rx1561_tgt, $I11, 4
    ne $S10, "rule", rx1561_fail
    add rx1561_pos, 4
  alt1563_end:
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "")
    if_null rx1561_debug, debug_1083
    rx1561_cur."!cursor_debug"("PASS", "", " at pos=", rx1561_pos)
  debug_1083:
    .return (rx1561_cur)
  rx1561_restart:
    if_null rx1561_debug, debug_1084
    rx1561_cur."!cursor_debug"("NEXT", "")
  debug_1084:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1085
    rx1561_cur."!cursor_debug"("FAIL", "")
  debug_1085:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("149_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("150_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1566_tgt
    .local int rx1566_pos
    .local int rx1566_off
    .local int rx1566_eos
    .local int rx1566_rep
    .local pmc rx1566_cur
    .local pmc rx1566_debug
    (rx1566_cur, rx1566_pos, rx1566_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1566_cur
    .local pmc match
    .lex "$/", match
    length rx1566_eos, rx1566_tgt
    gt rx1566_pos, rx1566_eos, rx1566_done
    set rx1566_off, 0
    lt rx1566_pos, 2, rx1566_start
    sub rx1566_off, rx1566_pos, 1
    substr rx1566_tgt, rx1566_tgt, rx1566_off
  rx1566_start:
    eq $I10, 1, rx1566_restart
    if_null rx1566_debug, debug_1089
    rx1566_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1567_done
    goto rxscan1567_scan
  rxscan1567_loop:
    (rx1566_pos) = rx1566_cur."from"()
    inc rx1566_pos
    rx1566_cur."!cursor_from"(rx1566_pos)
    ge rx1566_pos, rx1566_eos, rxscan1567_done
  rxscan1567_scan:
    set_addr $I10, rxscan1567_loop
    rx1566_cur."!mark_push"(0, rx1566_pos, $I10)
  rxscan1567_done:
.annotate 'line', 712
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1566_cur."!cursor_pos"(rx1566_pos)
    $P10 = rx1566_cur."regex_declarator"()
    unless $P10, rx1566_fail
    rx1566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1566_pos = $P10."pos"()
  # rx pass
    rx1566_cur."!cursor_pass"(rx1566_pos, "term:sym<regex_declarator>")
    if_null rx1566_debug, debug_1090
    rx1566_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1566_pos)
  debug_1090:
    .return (rx1566_cur)
  rx1566_restart:
.annotate 'line', 440
    if_null rx1566_debug, debug_1091
    rx1566_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1091:
  rx1566_fail:
    (rx1566_rep, rx1566_pos, $I10, $P10) = rx1566_cur."!mark_fail"(0)
    lt rx1566_pos, -1, rx1566_done
    eq rx1566_pos, -1, rx1566_fail
    jump $I10
  rx1566_done:
    rx1566_cur."!cursor_fail"()
    if_null rx1566_debug, debug_1092
    rx1566_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1092:
    .return (rx1566_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("151_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("152_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1093
    rx1570_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1571_done
    goto rxscan1571_scan
  rxscan1571_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1571_done
  rxscan1571_scan:
    set_addr $I10, rxscan1571_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1571_done:
.annotate 'line', 713
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."statement_prefix"()
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "term:sym<statement_prefix>")
    if_null rx1570_debug, debug_1094
    rx1570_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1570_pos)
  debug_1094:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 440
    if_null rx1570_debug, debug_1095
    rx1570_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1095:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1096
    rx1570_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1096:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("153_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("154_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1574_tgt
    .local int rx1574_pos
    .local int rx1574_off
    .local int rx1574_eos
    .local int rx1574_rep
    .local pmc rx1574_cur
    .local pmc rx1574_debug
    (rx1574_cur, rx1574_pos, rx1574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1574_cur
    .local pmc match
    .lex "$/", match
    length rx1574_eos, rx1574_tgt
    gt rx1574_pos, rx1574_eos, rx1574_done
    set rx1574_off, 0
    lt rx1574_pos, 2, rx1574_start
    sub rx1574_off, rx1574_pos, 1
    substr rx1574_tgt, rx1574_tgt, rx1574_off
  rx1574_start:
    eq $I10, 1, rx1574_restart
    if_null rx1574_debug, debug_1097
    rx1574_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1575_done
    goto rxscan1575_scan
  rxscan1575_loop:
    (rx1574_pos) = rx1574_cur."from"()
    inc rx1574_pos
    rx1574_cur."!cursor_from"(rx1574_pos)
    ge rx1574_pos, rx1574_eos, rxscan1575_done
  rxscan1575_scan:
    set_addr $I10, rxscan1575_loop
    rx1574_cur."!mark_push"(0, rx1574_pos, $I10)
  rxscan1575_done:
.annotate 'line', 714
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1574_cur."!cursor_pos"(rx1574_pos)
    $P10 = rx1574_cur."lambda"()
    unless $P10, rx1574_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1574_cur."!cursor_pos"(rx1574_pos)
    $P10 = rx1574_cur."pblock"()
    unless $P10, rx1574_fail
    rx1574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1574_pos = $P10."pos"()
  # rx pass
    rx1574_cur."!cursor_pass"(rx1574_pos, "term:sym<lambda>")
    if_null rx1574_debug, debug_1098
    rx1574_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1574_pos)
  debug_1098:
    .return (rx1574_cur)
  rx1574_restart:
.annotate 'line', 440
    if_null rx1574_debug, debug_1099
    rx1574_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1099:
  rx1574_fail:
    (rx1574_rep, rx1574_pos, $I10, $P10) = rx1574_cur."!mark_fail"(0)
    lt rx1574_pos, -1, rx1574_done
    eq rx1574_pos, -1, rx1574_fail
    jump $I10
  rx1574_done:
    rx1574_cur."!cursor_fail"()
    if_null rx1574_debug, debug_1100
    rx1574_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1100:
    .return (rx1574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("155_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("156_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1101
    rx1578_cur."!cursor_debug"("START", "fatarrow")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1579_done
    goto rxscan1579_scan
  rxscan1579_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1579_done
  rxscan1579_scan:
    set_addr $I10, rxscan1579_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1579_done:
.annotate 'line', 717
  # rx subrule "identifier" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."identifier"()
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1578_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1578_pos, rx1578_off
    set rx1578_rep, 0
    sub $I12, rx1578_eos, rx1578_pos
  rxenumcharlistq1580_loop:
    le $I12, 0, rxenumcharlistq1580_done
    substr $S10, rx1578_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1580_done
    inc rx1578_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1580_loop
  rxenumcharlistq1580_done:
    add rx1578_pos, rx1578_pos, rx1578_rep
  # rx literal  "=>"
    add $I11, rx1578_pos, 2
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    substr $S10, rx1578_tgt, $I11, 2
    ne $S10, "=>", rx1578_fail
    add rx1578_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."ws"()
    unless $P10, rx1578_fail
    rx1578_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."EXPR"("i=")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1578_pos = $P10."pos"()
.annotate 'line', 716
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "fatarrow")
    if_null rx1578_debug, debug_1102
    rx1578_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1578_pos)
  debug_1102:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 440
    if_null rx1578_debug, debug_1103
    rx1578_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1103:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1104
    rx1578_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1104:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("157_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("158_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1583_tgt
    .local int rx1583_pos
    .local int rx1583_off
    .local int rx1583_eos
    .local int rx1583_rep
    .local pmc rx1583_cur
    .local pmc rx1583_debug
    (rx1583_cur, rx1583_pos, rx1583_tgt, $I10) = self."!cursor_start"()
    rx1583_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1583_cur
    .local pmc match
    .lex "$/", match
    length rx1583_eos, rx1583_tgt
    gt rx1583_pos, rx1583_eos, rx1583_done
    set rx1583_off, 0
    lt rx1583_pos, 2, rx1583_start
    sub rx1583_off, rx1583_pos, 1
    substr rx1583_tgt, rx1583_tgt, rx1583_off
  rx1583_start:
    eq $I10, 1, rx1583_restart
    if_null rx1583_debug, debug_1105
    rx1583_cur."!cursor_debug"("START", "colonpair")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1584_done
    goto rxscan1584_scan
  rxscan1584_loop:
    (rx1583_pos) = rx1583_cur."from"()
    inc rx1583_pos
    rx1583_cur."!cursor_from"(rx1583_pos)
    ge rx1583_pos, rx1583_eos, rxscan1584_done
  rxscan1584_scan:
    set_addr $I10, rxscan1584_loop
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  rxscan1584_done:
.annotate 'line', 721
  # rx literal  ":"
    add $I11, rx1583_pos, 1
    gt $I11, rx1583_eos, rx1583_fail
    sub $I11, rx1583_pos, rx1583_off
    ord $I11, rx1583_tgt, $I11
    ne $I11, 58, rx1583_fail
    add rx1583_pos, 1
  alt1585_0:
.annotate 'line', 722
    set_addr $I10, alt1585_1
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
.annotate 'line', 723
  # rx subcapture "not"
    set_addr $I10, rxcap_1586_fail
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  # rx literal  "!"
    add $I11, rx1583_pos, 1
    gt $I11, rx1583_eos, rx1583_fail
    sub $I11, rx1583_pos, rx1583_off
    ord $I11, rx1583_tgt, $I11
    ne $I11, 33, rx1583_fail
    add rx1583_pos, 1
    set_addr $I10, rxcap_1586_fail
    ($I12, $I11) = rx1583_cur."!mark_peek"($I10)
    rx1583_cur."!cursor_pos"($I11)
    ($P10) = rx1583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1583_pos, "")
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1586_done
  rxcap_1586_fail:
    goto rx1583_fail
  rxcap_1586_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1583_cur."!cursor_pos"(rx1583_pos)
    $P10 = rx1583_cur."identifier"()
    unless $P10, rx1583_fail
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1583_pos = $P10."pos"()
    goto alt1585_end
  alt1585_1:
    set_addr $I10, alt1585_2
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
.annotate 'line', 724
  # rx subrule "identifier" subtype=capture negate=
    rx1583_cur."!cursor_pos"(rx1583_pos)
    $P10 = rx1583_cur."identifier"()
    unless $P10, rx1583_fail
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1583_pos = $P10."pos"()
  # rx rxquantr1587 ** 0..1
    set_addr $I10, rxquantr1587_done
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  rxquantr1587_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1583_cur."!cursor_pos"(rx1583_pos)
    $P10 = rx1583_cur."circumfix"()
    unless $P10, rx1583_fail
    goto rxsubrule1588_pass
  rxsubrule1588_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1583_fail
  rxsubrule1588_pass:
    set_addr $I10, rxsubrule1588_back
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1583_pos = $P10."pos"()
    set_addr $I10, rxquantr1587_done
    (rx1583_rep) = rx1583_cur."!mark_commit"($I10)
  rxquantr1587_done:
    goto alt1585_end
  alt1585_2:
.annotate 'line', 725
  # rx subrule "circumfix" subtype=capture negate=
    rx1583_cur."!cursor_pos"(rx1583_pos)
    $P10 = rx1583_cur."circumfix"()
    unless $P10, rx1583_fail
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1583_pos = $P10."pos"()
  alt1585_end:
.annotate 'line', 720
  # rx pass
    rx1583_cur."!cursor_pass"(rx1583_pos, "colonpair")
    if_null rx1583_debug, debug_1106
    rx1583_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1583_pos)
  debug_1106:
    .return (rx1583_cur)
  rx1583_restart:
.annotate 'line', 440
    if_null rx1583_debug, debug_1107
    rx1583_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1107:
  rx1583_fail:
    (rx1583_rep, rx1583_pos, $I10, $P10) = rx1583_cur."!mark_fail"(0)
    lt rx1583_pos, -1, rx1583_done
    eq rx1583_pos, -1, rx1583_fail
    jump $I10
  rx1583_done:
    rx1583_cur."!cursor_fail"()
    if_null rx1583_debug, debug_1108
    rx1583_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1108:
    .return (rx1583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("159_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("circumfix", ":")
    $P104 = self."!PREFIX__!subrule"("identifier", ":")
    $P105 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P106, "ResizablePMCArray"
    push $P106, $P103
    push $P106, $P104
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("160_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    rx1591_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1109
    rx1591_cur."!cursor_debug"("START", "variable")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1592_done:
  alt1593_0:
.annotate 'line', 729
    set_addr $I10, alt1593_1
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
.annotate 'line', 730
  # rx subrule "sigil" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."sigil"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1591_pos = $P10."pos"()
  # rx rxquantr1594 ** 0..1
    set_addr $I10, rxquantr1594_done
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxquantr1594_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."twigil"()
    unless $P10, rx1591_fail
    goto rxsubrule1595_pass
  rxsubrule1595_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1591_fail
  rxsubrule1595_pass:
    set_addr $I10, rxsubrule1595_back
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1591_pos = $P10."pos"()
    set_addr $I10, rxquantr1594_done
    (rx1591_rep) = rx1591_cur."!mark_commit"($I10)
  rxquantr1594_done:
  # rx subrule "name" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."name"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1591_pos = $P10."pos"()
    goto alt1593_end
  alt1593_1:
    set_addr $I10, alt1593_2
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
.annotate 'line', 731
  # rx subrule "sigil" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."sigil"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1591_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1591_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."postcircumfix"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1591_pos = $P10."pos"()
    goto alt1593_end
  alt1593_2:
.annotate 'line', 732
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  "$"
    add $I11, rx1591_pos, 1
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    ord $I11, rx1591_tgt, $I11
    ne $I11, 36, rx1591_fail
    add rx1591_pos, 1
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1597_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1591_pos, rx1591_eos, rx1591_fail
    sub $I10, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1591_fail
    inc rx1591_pos
    set_addr $I10, rxcap_1597_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1597_done
  rxcap_1597_fail:
    goto rx1591_fail
  rxcap_1597_done:
  alt1593_end:
.annotate 'line', 729
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "variable")
    if_null rx1591_debug, debug_1110
    rx1591_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1591_pos)
  debug_1110:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 440
    if_null rx1591_debug, debug_1111
    rx1591_cur."!cursor_debug"("NEXT", "variable")
  debug_1111:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1112
    rx1591_cur."!cursor_debug"("FAIL", "variable")
  debug_1112:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("161_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, "/"
    push $P105, "_"
    push $P105, "!"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("162_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1600_tgt
    .local int rx1600_pos
    .local int rx1600_off
    .local int rx1600_eos
    .local int rx1600_rep
    .local pmc rx1600_cur
    .local pmc rx1600_debug
    (rx1600_cur, rx1600_pos, rx1600_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1600_cur
    .local pmc match
    .lex "$/", match
    length rx1600_eos, rx1600_tgt
    gt rx1600_pos, rx1600_eos, rx1600_done
    set rx1600_off, 0
    lt rx1600_pos, 2, rx1600_start
    sub rx1600_off, rx1600_pos, 1
    substr rx1600_tgt, rx1600_tgt, rx1600_off
  rx1600_start:
    eq $I10, 1, rx1600_restart
    if_null rx1600_debug, debug_1113
    rx1600_cur."!cursor_debug"("START", "sigil")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1600_pos) = rx1600_cur."from"()
    inc rx1600_pos
    rx1600_cur."!cursor_from"(rx1600_pos)
    ge rx1600_pos, rx1600_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  rxscan1601_done:
.annotate 'line', 735
  # rx enumcharlist negate=0 
    ge rx1600_pos, rx1600_eos, rx1600_fail
    sub $I10, rx1600_pos, rx1600_off
    substr $S10, rx1600_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1600_fail
    inc rx1600_pos
  # rx pass
    rx1600_cur."!cursor_pass"(rx1600_pos, "sigil")
    if_null rx1600_debug, debug_1114
    rx1600_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1600_pos)
  debug_1114:
    .return (rx1600_cur)
  rx1600_restart:
.annotate 'line', 440
    if_null rx1600_debug, debug_1115
    rx1600_cur."!cursor_debug"("NEXT", "sigil")
  debug_1115:
  rx1600_fail:
    (rx1600_rep, rx1600_pos, $I10, $P10) = rx1600_cur."!mark_fail"(0)
    lt rx1600_pos, -1, rx1600_done
    eq rx1600_pos, -1, rx1600_fail
    jump $I10
  rx1600_done:
    rx1600_cur."!cursor_fail"()
    if_null rx1600_debug, debug_1116
    rx1600_cur."!cursor_debug"("FAIL", "sigil")
  debug_1116:
    .return (rx1600_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("163_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    push $P103, "%"
    push $P103, "&"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("164_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1117
    rx1604_cur."!cursor_debug"("START", "twigil")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1605_done
    goto rxscan1605_scan
  rxscan1605_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1605_done
  rxscan1605_scan:
    set_addr $I10, rxscan1605_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1605_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 
    ge rx1604_pos, rx1604_eos, rx1604_fail
    sub $I10, rx1604_pos, rx1604_off
    substr $S10, rx1604_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1604_fail
    inc rx1604_pos
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "twigil")
    if_null rx1604_debug, debug_1118
    rx1604_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1604_pos)
  debug_1118:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 440
    if_null rx1604_debug, debug_1119
    rx1604_cur."!cursor_debug"("NEXT", "twigil")
  debug_1119:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1120
    rx1604_cur."!cursor_debug"("FAIL", "twigil")
  debug_1120:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("165_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "*"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("166_1312646121.678")
    .param pmc param_1608
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 739
    .lex "self", param_1608
    $P103 = param_1608."!protoregex"("package_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("167_1312646121.678")
    .param pmc param_1610
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 739
    .lex "self", param_1610
    $P104 = param_1610."!PREFIX__!protoregex"("package_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("168_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 741
    new $P103, "Undef"
    set $P1612, $P103
    .lex "$*OUTERPACKAGE", $P1612
.annotate 'line', 742
    new $P104, "Undef"
    set $P1613, $P104
    .lex "$*PKGDECL", $P1613
.annotate 'line', 440
    .local string rx1614_tgt
    .local int rx1614_pos
    .local int rx1614_off
    .local int rx1614_eos
    .local int rx1614_rep
    .local pmc rx1614_cur
    .local pmc rx1614_debug
    (rx1614_cur, rx1614_pos, rx1614_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1614_cur
    .local pmc match
    .lex "$/", match
    length rx1614_eos, rx1614_tgt
    gt rx1614_pos, rx1614_eos, rx1614_done
    set rx1614_off, 0
    lt rx1614_pos, 2, rx1614_start
    sub rx1614_off, rx1614_pos, 1
    substr rx1614_tgt, rx1614_tgt, rx1614_off
  rx1614_start:
    eq $I10, 1, rx1614_restart
    if_null rx1614_debug, debug_1121
    rx1614_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1121:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1614_pos) = rx1614_cur."from"()
    inc rx1614_pos
    rx1614_cur."!cursor_from"(rx1614_pos)
    ge rx1614_pos, rx1614_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
  rxscan1615_done:
.annotate 'line', 741
    rx1614_cur."!cursor_pos"(rx1614_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1122
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1123
    die "Contextual $*PACKAGE not found"
  vivify_1123:
  vivify_1122:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 742
    rx1614_cur."!cursor_pos"(rx1614_pos)
    new $P108, "String"
    assign $P108, "module"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 743
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1614_cur."!mark_push"(0, rx1614_pos, $I10)
  # rx literal  "module"
    add $I11, rx1614_pos, 6
    gt $I11, rx1614_eos, rx1614_fail
    sub $I11, rx1614_pos, rx1614_off
    substr $S10, rx1614_tgt, $I11, 6
    ne $S10, "module", rx1614_fail
    add rx1614_pos, 6
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1614_cur."!mark_peek"($I10)
    rx1614_cur."!cursor_pos"($I11)
    ($P10) = rx1614_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1614_pos, "")
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1614_fail
  rxcap_1616_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1614_cur."!cursor_pos"(rx1614_pos)
    $P10 = rx1614_cur."package_def"()
    unless $P10, rx1614_fail
    rx1614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1614_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx1614_cur."!cursor_pass"(rx1614_pos, "package_declarator:sym<module>")
    if_null rx1614_debug, debug_1124
    rx1614_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1614_pos)
  debug_1124:
    .return (rx1614_cur)
  rx1614_restart:
.annotate 'line', 440
    if_null rx1614_debug, debug_1125
    rx1614_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1125:
  rx1614_fail:
    (rx1614_rep, rx1614_pos, $I10, $P10) = rx1614_cur."!mark_fail"(0)
    lt rx1614_pos, -1, rx1614_done
    eq rx1614_pos, -1, rx1614_fail
    jump $I10
  rx1614_done:
    rx1614_cur."!cursor_fail"()
    if_null rx1614_debug, debug_1126
    rx1614_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1126:
    .return (rx1614_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("169_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("package_def", "module")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("170_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 746
    new $P103, "Undef"
    set $P1619, $P103
    .lex "$*OUTERPACKAGE", $P1619
.annotate 'line', 747
    new $P104, "Undef"
    set $P1620, $P104
    .lex "$*PKGDECL", $P1620
.annotate 'line', 440
    .local string rx1621_tgt
    .local int rx1621_pos
    .local int rx1621_off
    .local int rx1621_eos
    .local int rx1621_rep
    .local pmc rx1621_cur
    .local pmc rx1621_debug
    (rx1621_cur, rx1621_pos, rx1621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1621_cur
    .local pmc match
    .lex "$/", match
    length rx1621_eos, rx1621_tgt
    gt rx1621_pos, rx1621_eos, rx1621_done
    set rx1621_off, 0
    lt rx1621_pos, 2, rx1621_start
    sub rx1621_off, rx1621_pos, 1
    substr rx1621_tgt, rx1621_tgt, rx1621_off
  rx1621_start:
    eq $I10, 1, rx1621_restart
    if_null rx1621_debug, debug_1127
    rx1621_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1621_pos) = rx1621_cur."from"()
    inc rx1621_pos
    rx1621_cur."!cursor_from"(rx1621_pos)
    ge rx1621_pos, rx1621_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  rxscan1622_done:
.annotate 'line', 746
    rx1621_cur."!cursor_pos"(rx1621_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1128
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1129
    die "Contextual $*PACKAGE not found"
  vivify_1129:
  vivify_1128:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 747
    rx1621_cur."!cursor_pos"(rx1621_pos)
    new $P108, "String"
    assign $P108, "knowhow"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 748
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1621_pos, 7
    gt $I11, rx1621_eos, rx1621_fail
    sub $I11, rx1621_pos, rx1621_off
    substr $S10, rx1621_tgt, $I11, 7
    ne $S10, "knowhow", rx1621_fail
    add rx1621_pos, 7
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1621_cur."!mark_peek"($I10)
    rx1621_cur."!cursor_pos"($I11)
    ($P10) = rx1621_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1621_pos, "")
    rx1621_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1621_fail
  rxcap_1623_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1621_cur."!cursor_pos"(rx1621_pos)
    $P10 = rx1621_cur."package_def"()
    unless $P10, rx1621_fail
    rx1621_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1621_pos = $P10."pos"()
.annotate 'line', 745
  # rx pass
    rx1621_cur."!cursor_pass"(rx1621_pos, "package_declarator:sym<knowhow>")
    if_null rx1621_debug, debug_1130
    rx1621_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1621_pos)
  debug_1130:
    .return (rx1621_cur)
  rx1621_restart:
.annotate 'line', 440
    if_null rx1621_debug, debug_1131
    rx1621_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1131:
  rx1621_fail:
    (rx1621_rep, rx1621_pos, $I10, $P10) = rx1621_cur."!mark_fail"(0)
    lt rx1621_pos, -1, rx1621_done
    eq rx1621_pos, -1, rx1621_fail
    jump $I10
  rx1621_done:
    rx1621_cur."!cursor_fail"()
    if_null rx1621_debug, debug_1132
    rx1621_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1132:
    .return (rx1621_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("171_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("172_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 751
    new $P103, "Undef"
    set $P1626, $P103
    .lex "$*OUTERPACKAGE", $P1626
.annotate 'line', 752
    new $P104, "Undef"
    set $P1627, $P104
    .lex "$*PKGDECL", $P1627
.annotate 'line', 440
    .local string rx1628_tgt
    .local int rx1628_pos
    .local int rx1628_off
    .local int rx1628_eos
    .local int rx1628_rep
    .local pmc rx1628_cur
    .local pmc rx1628_debug
    (rx1628_cur, rx1628_pos, rx1628_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1628_cur
    .local pmc match
    .lex "$/", match
    length rx1628_eos, rx1628_tgt
    gt rx1628_pos, rx1628_eos, rx1628_done
    set rx1628_off, 0
    lt rx1628_pos, 2, rx1628_start
    sub rx1628_off, rx1628_pos, 1
    substr rx1628_tgt, rx1628_tgt, rx1628_off
  rx1628_start:
    eq $I10, 1, rx1628_restart
    if_null rx1628_debug, debug_1133
    rx1628_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1133:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1628_pos) = rx1628_cur."from"()
    inc rx1628_pos
    rx1628_cur."!cursor_from"(rx1628_pos)
    ge rx1628_pos, rx1628_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1628_cur."!mark_push"(0, rx1628_pos, $I10)
  rxscan1629_done:
.annotate 'line', 751
    rx1628_cur."!cursor_pos"(rx1628_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1134
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1135
    die "Contextual $*PACKAGE not found"
  vivify_1135:
  vivify_1134:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 752
    rx1628_cur."!cursor_pos"(rx1628_pos)
    new $P108, "String"
    assign $P108, "class"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 753
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1628_cur."!mark_push"(0, rx1628_pos, $I10)
  # rx literal  "class"
    add $I11, rx1628_pos, 5
    gt $I11, rx1628_eos, rx1628_fail
    sub $I11, rx1628_pos, rx1628_off
    substr $S10, rx1628_tgt, $I11, 5
    ne $S10, "class", rx1628_fail
    add rx1628_pos, 5
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1628_cur."!mark_peek"($I10)
    rx1628_cur."!cursor_pos"($I11)
    ($P10) = rx1628_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1628_pos, "")
    rx1628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1628_fail
  rxcap_1630_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1628_cur."!cursor_pos"(rx1628_pos)
    $P10 = rx1628_cur."package_def"()
    unless $P10, rx1628_fail
    rx1628_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1628_pos = $P10."pos"()
.annotate 'line', 750
  # rx pass
    rx1628_cur."!cursor_pass"(rx1628_pos, "package_declarator:sym<class>")
    if_null rx1628_debug, debug_1136
    rx1628_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1628_pos)
  debug_1136:
    .return (rx1628_cur)
  rx1628_restart:
.annotate 'line', 440
    if_null rx1628_debug, debug_1137
    rx1628_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1137:
  rx1628_fail:
    (rx1628_rep, rx1628_pos, $I10, $P10) = rx1628_cur."!mark_fail"(0)
    lt rx1628_pos, -1, rx1628_done
    eq rx1628_pos, -1, rx1628_fail
    jump $I10
  rx1628_done:
    rx1628_cur."!cursor_fail"()
    if_null rx1628_debug, debug_1138
    rx1628_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1138:
    .return (rx1628_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("173_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("package_def", "class")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("174_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 756
    new $P103, "Undef"
    set $P1633, $P103
    .lex "$*OUTERPACKAGE", $P1633
.annotate 'line', 757
    new $P104, "Undef"
    set $P1634, $P104
    .lex "$*PKGDECL", $P1634
.annotate 'line', 440
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1139
    rx1635_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1636_done:
.annotate 'line', 756
    rx1635_cur."!cursor_pos"(rx1635_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1140
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1141
    die "Contextual $*PACKAGE not found"
  vivify_1141:
  vivify_1140:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 757
    rx1635_cur."!cursor_pos"(rx1635_pos)
    new $P108, "String"
    assign $P108, "grammar"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 758
  # rx subcapture "sym"
    set_addr $I10, rxcap_1637_fail
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1635_pos, 7
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    substr $S10, rx1635_tgt, $I11, 7
    ne $S10, "grammar", rx1635_fail
    add rx1635_pos, 7
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1635_cur."!mark_peek"($I10)
    rx1635_cur."!cursor_pos"($I11)
    ($P10) = rx1635_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1635_pos, "")
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1635_fail
  rxcap_1637_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."package_def"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1635_pos = $P10."pos"()
.annotate 'line', 755
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "package_declarator:sym<grammar>")
    if_null rx1635_debug, debug_1142
    rx1635_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1635_pos)
  debug_1142:
    .return (rx1635_cur)
  rx1635_restart:
.annotate 'line', 440
    if_null rx1635_debug, debug_1143
    rx1635_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1143:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1144
    rx1635_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1144:
    .return (rx1635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("175_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("176_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 761
    new $P103, "Undef"
    set $P1640, $P103
    .lex "$*OUTERPACKAGE", $P1640
.annotate 'line', 762
    new $P104, "Undef"
    set $P1641, $P104
    .lex "$*PKGDECL", $P1641
.annotate 'line', 440
    .local string rx1642_tgt
    .local int rx1642_pos
    .local int rx1642_off
    .local int rx1642_eos
    .local int rx1642_rep
    .local pmc rx1642_cur
    .local pmc rx1642_debug
    (rx1642_cur, rx1642_pos, rx1642_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1642_cur
    .local pmc match
    .lex "$/", match
    length rx1642_eos, rx1642_tgt
    gt rx1642_pos, rx1642_eos, rx1642_done
    set rx1642_off, 0
    lt rx1642_pos, 2, rx1642_start
    sub rx1642_off, rx1642_pos, 1
    substr rx1642_tgt, rx1642_tgt, rx1642_off
  rx1642_start:
    eq $I10, 1, rx1642_restart
    if_null rx1642_debug, debug_1145
    rx1642_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1643_done
    goto rxscan1643_scan
  rxscan1643_loop:
    (rx1642_pos) = rx1642_cur."from"()
    inc rx1642_pos
    rx1642_cur."!cursor_from"(rx1642_pos)
    ge rx1642_pos, rx1642_eos, rxscan1643_done
  rxscan1643_scan:
    set_addr $I10, rxscan1643_loop
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  rxscan1643_done:
.annotate 'line', 761
    rx1642_cur."!cursor_pos"(rx1642_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1146
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1147
    die "Contextual $*PACKAGE not found"
  vivify_1147:
  vivify_1146:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 762
    rx1642_cur."!cursor_pos"(rx1642_pos)
    new $P108, "String"
    assign $P108, "role"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 763
  # rx subcapture "sym"
    set_addr $I10, rxcap_1644_fail
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  # rx literal  "role"
    add $I11, rx1642_pos, 4
    gt $I11, rx1642_eos, rx1642_fail
    sub $I11, rx1642_pos, rx1642_off
    substr $S10, rx1642_tgt, $I11, 4
    ne $S10, "role", rx1642_fail
    add rx1642_pos, 4
    set_addr $I10, rxcap_1644_fail
    ($I12, $I11) = rx1642_cur."!mark_peek"($I10)
    rx1642_cur."!cursor_pos"($I11)
    ($P10) = rx1642_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1642_pos, "")
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1644_done
  rxcap_1644_fail:
    goto rx1642_fail
  rxcap_1644_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1642_cur."!cursor_pos"(rx1642_pos)
    $P10 = rx1642_cur."package_def"()
    unless $P10, rx1642_fail
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1642_pos = $P10."pos"()
.annotate 'line', 760
  # rx pass
    rx1642_cur."!cursor_pass"(rx1642_pos, "package_declarator:sym<role>")
    if_null rx1642_debug, debug_1148
    rx1642_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1642_pos)
  debug_1148:
    .return (rx1642_cur)
  rx1642_restart:
.annotate 'line', 440
    if_null rx1642_debug, debug_1149
    rx1642_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1149:
  rx1642_fail:
    (rx1642_rep, rx1642_pos, $I10, $P10) = rx1642_cur."!mark_fail"(0)
    lt rx1642_pos, -1, rx1642_done
    eq rx1642_pos, -1, rx1642_fail
    jump $I10
  rx1642_done:
    rx1642_cur."!cursor_fail"()
    if_null rx1642_debug, debug_1150
    rx1642_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1150:
    .return (rx1642_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("177_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("package_def", "role")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("178_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 766
    new $P103, "Undef"
    set $P1647, $P103
    .lex "$*OUTERPACKAGE", $P1647
.annotate 'line', 767
    new $P104, "Undef"
    set $P1648, $P104
    .lex "$*PKGDECL", $P1648
.annotate 'line', 440
    .local string rx1649_tgt
    .local int rx1649_pos
    .local int rx1649_off
    .local int rx1649_eos
    .local int rx1649_rep
    .local pmc rx1649_cur
    .local pmc rx1649_debug
    (rx1649_cur, rx1649_pos, rx1649_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1649_cur
    .local pmc match
    .lex "$/", match
    length rx1649_eos, rx1649_tgt
    gt rx1649_pos, rx1649_eos, rx1649_done
    set rx1649_off, 0
    lt rx1649_pos, 2, rx1649_start
    sub rx1649_off, rx1649_pos, 1
    substr rx1649_tgt, rx1649_tgt, rx1649_off
  rx1649_start:
    eq $I10, 1, rx1649_restart
    if_null rx1649_debug, debug_1151
    rx1649_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1650_done
    goto rxscan1650_scan
  rxscan1650_loop:
    (rx1649_pos) = rx1649_cur."from"()
    inc rx1649_pos
    rx1649_cur."!cursor_from"(rx1649_pos)
    ge rx1649_pos, rx1649_eos, rxscan1650_done
  rxscan1650_scan:
    set_addr $I10, rxscan1650_loop
    rx1649_cur."!mark_push"(0, rx1649_pos, $I10)
  rxscan1650_done:
.annotate 'line', 766
    rx1649_cur."!cursor_pos"(rx1649_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1152
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1153
    die "Contextual $*PACKAGE not found"
  vivify_1153:
  vivify_1152:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 767
    rx1649_cur."!cursor_pos"(rx1649_pos)
    new $P108, "String"
    assign $P108, "native"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 768
  # rx subcapture "sym"
    set_addr $I10, rxcap_1651_fail
    rx1649_cur."!mark_push"(0, rx1649_pos, $I10)
  # rx literal  "native"
    add $I11, rx1649_pos, 6
    gt $I11, rx1649_eos, rx1649_fail
    sub $I11, rx1649_pos, rx1649_off
    substr $S10, rx1649_tgt, $I11, 6
    ne $S10, "native", rx1649_fail
    add rx1649_pos, 6
    set_addr $I10, rxcap_1651_fail
    ($I12, $I11) = rx1649_cur."!mark_peek"($I10)
    rx1649_cur."!cursor_pos"($I11)
    ($P10) = rx1649_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1649_pos, "")
    rx1649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1651_done
  rxcap_1651_fail:
    goto rx1649_fail
  rxcap_1651_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1649_cur."!cursor_pos"(rx1649_pos)
    $P10 = rx1649_cur."package_def"()
    unless $P10, rx1649_fail
    rx1649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1649_pos = $P10."pos"()
.annotate 'line', 765
  # rx pass
    rx1649_cur."!cursor_pass"(rx1649_pos, "package_declarator:sym<native>")
    if_null rx1649_debug, debug_1154
    rx1649_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1649_pos)
  debug_1154:
    .return (rx1649_cur)
  rx1649_restart:
.annotate 'line', 440
    if_null rx1649_debug, debug_1155
    rx1649_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1155:
  rx1649_fail:
    (rx1649_rep, rx1649_pos, $I10, $P10) = rx1649_cur."!mark_fail"(0)
    lt rx1649_pos, -1, rx1649_done
    eq rx1649_pos, -1, rx1649_fail
    jump $I10
  rx1649_done:
    rx1649_cur."!cursor_fail"()
    if_null rx1649_debug, debug_1156
    rx1649_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1156:
    .return (rx1649_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("179_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("package_def", "native")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("180_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 771
    new $P103, "Undef"
    set $P1654, $P103
    .lex "$*OUTERPACKAGE", $P1654
.annotate 'line', 772
    new $P104, "Undef"
    set $P1655, $P104
    .lex "$*PKGDECL", $P1655
.annotate 'line', 440
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1157
    rx1656_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1157:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1657_done
    goto rxscan1657_scan
  rxscan1657_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1657_done
  rxscan1657_scan:
    set_addr $I10, rxscan1657_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1657_done:
.annotate 'line', 770
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
.annotate 'line', 771
    rx1656_cur."!cursor_pos"(rx1656_pos)
    find_dynamic_lex $P108, "$*PACKAGE"
    unless_null $P108, vivify_1158
    get_hll_global $P106, "GLOBAL"
    get_who $P107, $P106
    set $P108, $P107["$PACKAGE"]
    unless_null $P108, vivify_1159
    die "Contextual $*PACKAGE not found"
  vivify_1159:
  vivify_1158:
    store_lex "$*OUTERPACKAGE", $P108
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
.annotate 'line', 772
    rx1656_cur."!cursor_pos"(rx1656_pos)
    new $P110, "String"
    assign $P110, "stub"
    store_lex "$*PKGDECL", $P110
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
.annotate 'line', 773
  # rx subcapture "sym"
    set_addr $I10, rxcap_1658_fail
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1656_pos, 4
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 4
    ne $S10, "stub", rx1656_fail
    add rx1656_pos, 4
    set_addr $I10, rxcap_1658_fail
    ($I12, $I11) = rx1656_cur."!mark_peek"($I10)
    rx1656_cur."!cursor_pos"($I11)
    ($P10) = rx1656_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1656_pos, "")
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1658_done
  rxcap_1658_fail:
    goto rx1656_fail
  rxcap_1658_done:
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."name"()
    unless $P10, rx1656_fail
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1656_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
.annotate 'line', 774
  # rx literal  "metaclass"
    add $I11, rx1656_pos, 9
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 9
    ne $S10, "metaclass", rx1656_fail
    add rx1656_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."name"()
    unless $P10, rx1656_fail
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1656_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
.annotate 'line', 775
  # rx literal  "{"
    add $I11, rx1656_pos, 1
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    ord $I11, rx1656_tgt, $I11
    ne $I11, 123, rx1656_fail
    add rx1656_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1656_pos, 3
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 3
    ne $S10, "...", rx1656_fail
    add rx1656_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1656_pos, 1
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    ord $I11, rx1656_tgt, $I11
    ne $I11, 125, rx1656_fail
    add rx1656_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."ws"()
    unless $P10, rx1656_fail
    rx1656_pos = $P10."pos"()
.annotate 'line', 770
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "package_declarator:sym<stub>")
    if_null rx1656_debug, debug_1160
    rx1656_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1656_pos)
  debug_1160:
    .return (rx1656_cur)
  rx1656_restart:
.annotate 'line', 440
    if_null rx1656_debug, debug_1161
    rx1656_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1161:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1162
    rx1656_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1162:
    .return (rx1656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("181_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P119 = self."!PREFIX__!subrule"("ws", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("182_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1666 = "183_1312646121.678" 
    capture_lex $P1666
.annotate 'line', 779
    new $P103, "Undef"
    set $P1661, $P103
    .lex "$*PACKAGE", $P1661
.annotate 'line', 440
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    rx1662_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1163
    rx1662_cur."!cursor_debug"("START", "package_def")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1663_done
    goto rxscan1663_scan
  rxscan1663_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1663_done
  rxscan1663_scan:
    set_addr $I10, rxscan1663_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1663_done:
.annotate 'line', 778
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 779
    rx1662_cur."!cursor_pos"(rx1662_pos)
    find_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1164
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1165
    die "Contextual $*PACKAGE not found"
  vivify_1165:
  vivify_1164:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 781
  # rx subrule "name" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."name"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 782
  # rx rxquantr1664 ** 0..1
    set_addr $I10, rxquantr1664_done
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxquantr1664_loop:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1662_pos, 2
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 2
    ne $S10, "is", rx1662_fail
    add rx1662_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1662_pos, 5
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 5
    ne $S10, "repr(", rx1662_fail
    add rx1662_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."quote_EXPR"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1662_pos, 1
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    ord $I11, rx1662_tgt, $I11
    ne $I11, 41, rx1662_fail
    add rx1662_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
    set_addr $I10, rxquantr1664_done
    (rx1662_rep) = rx1662_cur."!mark_commit"($I10)
  rxquantr1664_done:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 784
    rx1662_cur."!cursor_pos"(rx1662_pos)
    find_lex $P116, unicode:"$\x{a2}"
    $P117 = $P116."MATCH"()
    store_lex "$/", $P117
    .const 'Sub' $P1666 = "183_1312646121.678" 
    capture_lex $P1666
    $P119 = $P1666()
.annotate 'line', 810
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 812
  # rx rxquantr1701 ** 0..1
    set_addr $I10, rxquantr1701_done
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxquantr1701_loop:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1662_pos, 2
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 2
    ne $S10, "is", rx1662_fail
    add rx1662_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."name"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
    set_addr $I10, rxquantr1701_done
    (rx1662_rep) = rx1662_cur."!mark_commit"($I10)
  rxquantr1701_done:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 813
  # rx rxquantr1702 ** 0..*
    set_addr $I10, rxquantr1702_done
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxquantr1702_loop:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1662_pos, 4
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 4
    ne $S10, "does", rx1662_fail
    add rx1662_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."name"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
    set_addr $I10, rxquantr1702_done
    (rx1662_rep) = rx1662_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1702_done
    rx1662_cur."!mark_push"(rx1662_rep, rx1662_pos, $I10)
    goto rxquantr1702_loop
  rxquantr1702_done:
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  alt1703_0:
.annotate 'line', 814
    set_addr $I10, alt1703_1
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
.annotate 'line', 815
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1662_pos, 1
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    ord $I11, rx1662_tgt, $I11
    ne $I11, 59, rx1662_fail
    add rx1662_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."comp_unit"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
    goto alt1703_end
  alt1703_1:
    set_addr $I10, alt1703_2
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
.annotate 'line', 816
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1662_fail
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."block"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
    goto alt1703_end
  alt1703_2:
.annotate 'line', 817
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."panic"("Malformed package declaration")
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
  alt1703_end:
.annotate 'line', 818
  # rx subrule "ws" subtype=method negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."ws"()
    unless $P10, rx1662_fail
    rx1662_pos = $P10."pos"()
.annotate 'line', 778
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "package_def")
    if_null rx1662_debug, debug_1233
    rx1662_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1662_pos)
  debug_1233:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 440
    if_null rx1662_debug, debug_1234
    rx1662_cur."!cursor_debug"("NEXT", "package_def")
  debug_1234:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1235
    rx1662_cur."!cursor_debug"("FAIL", "package_def")
  debug_1235:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1665"  :anon :subid("183_1312646121.678") :outer("182_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 787
    $P1668 = root_new ['parrot';'Hash']
    set $P1667, $P1668
    .lex "%args", $P1667
.annotate 'line', 784
    find_lex $P1669, "%args"
    unless_null $P1669, vivify_1166
    $P1669 = root_new ['parrot';'Hash']
  vivify_1166:
.annotate 'line', 788
    find_lex $P1670, "$/"
    unless_null $P1670, vivify_1167
    $P1670 = root_new ['parrot';'Hash']
  vivify_1167:
    set $P118, $P1670["name"]
    unless_null $P118, vivify_1168
    new $P118, "Undef"
  vivify_1168:
    set $S100, $P118
    new $P119, 'String'
    set $P119, $S100
    find_lex $P1671, "%args"
    unless_null $P1671, vivify_1169
    $P1671 = root_new ['parrot';'Hash']
    store_lex "%args", $P1671
  vivify_1169:
    set $P1671["name"], $P119
.annotate 'line', 789
    find_lex $P1673, "$/"
    unless_null $P1673, vivify_1170
    $P1673 = root_new ['parrot';'Hash']
  vivify_1170:
    set $P118, $P1673["repr"]
    unless_null $P118, vivify_1171
    new $P118, "Undef"
  vivify_1171:
    unless $P118, if_1672_end
.annotate 'line', 790
    new $P119, "Float"
    assign $P119, 0
    set $I100, $P119
    new $P120, "Float"
    assign $P120, 0
    set $I101, $P120
    find_lex $P1674, "$/"
    unless_null $P1674, vivify_1172
    $P1674 = root_new ['parrot';'Hash']
  vivify_1172:
    set $P1675, $P1674["repr"]
    unless_null $P1675, vivify_1173
    $P1675 = root_new ['parrot';'ResizablePMCArray']
  vivify_1173:
    set $P1676, $P1675[$I101]
    unless_null $P1676, vivify_1174
    $P1676 = root_new ['parrot';'Hash']
  vivify_1174:
    set $P1677, $P1676["quote_delimited"]
    unless_null $P1677, vivify_1175
    $P1677 = root_new ['parrot';'Hash']
  vivify_1175:
    set $P1678, $P1677["quote_atom"]
    unless_null $P1678, vivify_1176
    $P1678 = root_new ['parrot';'ResizablePMCArray']
  vivify_1176:
    set $P121, $P1678[$I100]
    unless_null $P121, vivify_1177
    new $P121, "Undef"
  vivify_1177:
    set $S100, $P121
    new $P122, 'String'
    set $P122, $S100
    find_lex $P1679, "%args"
    unless_null $P1679, vivify_1178
    $P1679 = root_new ['parrot';'Hash']
    store_lex "%args", $P1679
  vivify_1178:
    set $P1679["repr"], $P122
  if_1672_end:
.annotate 'line', 792
    find_dynamic_lex $P120, "$*SC"
    unless_null $P120, vivify_1179
    get_hll_global $P118, "GLOBAL"
    get_who $P119, $P118
    set $P120, $P119["$SC"]
    unless_null $P120, vivify_1180
    die "Contextual $*SC not found"
  vivify_1180:
  vivify_1179:
    find_dynamic_lex $P123, "$*PKGDECL"
    unless_null $P123, vivify_1181
    get_hll_global $P121, "GLOBAL"
    get_who $P122, $P121
    set $P123, $P122["$PKGDECL"]
    unless_null $P123, vivify_1182
    die "Contextual $*PKGDECL not found"
  vivify_1182:
  vivify_1181:
    find_dynamic_lex $P126, "%*HOW"
    unless_null $P126, vivify_1183
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P126, $P125["%HOW"]
    unless_null $P126, vivify_1184
    die "Contextual %*HOW not found"
  vivify_1184:
  vivify_1183:
    set $P127, $P126[$P123]
    unless_null $P127, vivify_1185
    new $P127, "Undef"
  vivify_1185:
    find_lex $P1680, "%args"
    unless_null $P1680, vivify_1186
    $P1680 = root_new ['parrot';'Hash']
  vivify_1186:
    $P128 = $P120."pkg_create_mo"($P127, $P1680 :flat)
    store_dynamic_lex "$*PACKAGE", $P128
.annotate 'line', 795
    find_dynamic_lex $P122, "$*SCOPE"
    unless_null $P122, vivify_1187
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$SCOPE"]
    unless_null $P122, vivify_1188
    die "Contextual $*SCOPE not found"
  vivify_1188:
  vivify_1187:
    set $S100, $P122
    iseq $I100, $S100, "our"
    unless $I100, unless_1682
    new $P119, 'Integer'
    set $P119, $I100
    goto unless_1682_end
  unless_1682:
    find_dynamic_lex $P125, "$*SCOPE"
    unless_null $P125, vivify_1189
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SCOPE"]
    unless_null $P125, vivify_1190
    die "Contextual $*SCOPE not found"
  vivify_1190:
  vivify_1189:
    set $S101, $P125
    iseq $I101, $S101, ""
    new $P119, 'Integer'
    set $P119, $I101
  unless_1682_end:
    if $P119, if_1681
.annotate 'line', 801
    find_dynamic_lex $P130, "$*SCOPE"
    unless_null $P130, vivify_1191
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SCOPE"]
    unless_null $P130, vivify_1192
    die "Contextual $*SCOPE not found"
  vivify_1192:
  vivify_1191:
    set $S102, $P130
    iseq $I102, $S102, "my"
    if $I102, if_1692
.annotate 'line', 808
    find_lex $P131, "$/"
    unless_null $P131, vivify_1193
    new $P131, "Undef"
  vivify_1193:
    $P132 = $P131."CURSOR"()
    find_dynamic_lex $P135, "$*SCOPE"
    unless_null $P135, vivify_1194
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SCOPE"]
    unless_null $P135, vivify_1195
    die "Contextual $*SCOPE not found"
  vivify_1195:
  vivify_1194:
    concat $P136, $P135, " scoped packages are not supported"
    $P137 = $P132."panic"($P136)
.annotate 'line', 807
    set $P127, $P137
.annotate 'line', 801
    goto if_1692_end
  if_1692:
.annotate 'line', 802
    find_lex $P1694, "$/"
    unless_null $P1694, vivify_1196
    $P1694 = root_new ['parrot';'Hash']
  vivify_1196:
    set $P1695, $P1694["name"]
    unless_null $P1695, vivify_1197
    $P1695 = root_new ['parrot';'Hash']
  vivify_1197:
    set $P131, $P1695["identifier"]
    unless_null $P131, vivify_1198
    new $P131, "Undef"
  vivify_1198:
    set $N100, $P131
    set $N101, 1
    isne $I103, $N100, $N101
    unless $I103, if_1693_end
.annotate 'line', 803
    find_lex $P1696, "$/"
    unless_null $P1696, vivify_1199
    $P1696 = root_new ['parrot';'Hash']
  vivify_1199:
    set $P132, $P1696["name"]
    unless_null $P132, vivify_1200
    new $P132, "Undef"
  vivify_1200:
    $P133 = $P132."CURSOR"()
    $P133."panic"("A my scoped package cannot have a multi-part name yet")
  if_1693_end:
.annotate 'line', 805
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_1201
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_1202
    die "Contextual $*SC not found"
  vivify_1202:
  vivify_1201:
    new $P134, "Float"
    assign $P134, 0
    set $I103, $P134
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "NQP"
    nqp_get_package_through_who $P137, $P136, "Actions"
    get_who $P138, $P137
    set $P1697, $P138["@BLOCK"]
    unless_null $P1697, vivify_1203
    $P1697 = root_new ['parrot';'ResizablePMCArray']
  vivify_1203:
    set $P139, $P1697[$I103]
    unless_null $P139, vivify_1204
    new $P139, "Undef"
  vivify_1204:
    new $P140, "Float"
    assign $P140, 0
    set $I104, $P140
    find_lex $P1698, "$/"
    unless_null $P1698, vivify_1205
    $P1698 = root_new ['parrot';'Hash']
  vivify_1205:
    set $P1699, $P1698["name"]
    unless_null $P1699, vivify_1206
    $P1699 = root_new ['parrot';'Hash']
  vivify_1206:
    set $P1700, $P1699["identifier"]
    unless_null $P1700, vivify_1207
    $P1700 = root_new ['parrot';'ResizablePMCArray']
  vivify_1207:
    set $P141, $P1700[$I104]
    unless_null $P141, vivify_1208
    new $P141, "Undef"
  vivify_1208:
    find_dynamic_lex $P144, "$*PACKAGE"
    unless_null $P144, vivify_1209
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$PACKAGE"]
    unless_null $P144, vivify_1210
    die "Contextual $*PACKAGE not found"
  vivify_1210:
  vivify_1209:
    $P145 = $P133."install_lexical_symbol"($P139, $P141, $P144)
.annotate 'line', 801
    set $P127, $P145
  if_1692_end:
    set $P118, $P127
.annotate 'line', 795
    goto if_1681_end
  if_1681:
.annotate 'line', 796
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_1211
    get_hll_global $P126, "GLOBAL"
    get_who $P127, $P126
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_1212
    die "Contextual $*SC not found"
  vivify_1212:
  vivify_1211:
    find_dynamic_lex $P131, "$*OUTERPACKAGE"
    unless_null $P131, vivify_1213
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$OUTERPACKAGE"]
    unless_null $P131, vivify_1214
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1214:
  vivify_1213:
    find_lex $P1683, "$/"
    unless_null $P1683, vivify_1215
    $P1683 = root_new ['parrot';'Hash']
  vivify_1215:
    set $P1684, $P1683["name"]
    unless_null $P1684, vivify_1216
    $P1684 = root_new ['parrot';'Hash']
  vivify_1216:
    set $P132, $P1684["identifier"]
    unless_null $P132, vivify_1217
    new $P132, "Undef"
  vivify_1217:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_1218
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_1219
    die "Contextual $*PACKAGE not found"
  vivify_1219:
  vivify_1218:
    $P128."install_package_symbol"($P131, $P132, $P135)
.annotate 'line', 797
    find_lex $P1686, "$/"
    unless_null $P1686, vivify_1220
    $P1686 = root_new ['parrot';'Hash']
  vivify_1220:
    set $P1687, $P1686["name"]
    unless_null $P1687, vivify_1221
    $P1687 = root_new ['parrot';'Hash']
  vivify_1221:
    set $P127, $P1687["identifier"]
    unless_null $P127, vivify_1222
    new $P127, "Undef"
  vivify_1222:
    set $N100, $P127
    set $N101, 1
    iseq $I102, $N100, $N101
    if $I102, if_1685
    new $P126, 'Integer'
    set $P126, $I102
    goto if_1685_end
  if_1685:
.annotate 'line', 798
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_1223
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_1224
    die "Contextual $*SC not found"
  vivify_1224:
  vivify_1223:
    new $P131, "Float"
    assign $P131, 0
    set $I103, $P131
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "NQP"
    nqp_get_package_through_who $P134, $P133, "Actions"
    get_who $P135, $P134
    set $P1688, $P135["@BLOCK"]
    unless_null $P1688, vivify_1225
    $P1688 = root_new ['parrot';'ResizablePMCArray']
  vivify_1225:
    set $P136, $P1688[$I103]
    unless_null $P136, vivify_1226
    new $P136, "Undef"
  vivify_1226:
    new $P137, "Float"
    assign $P137, 0
    set $I104, $P137
    find_lex $P1689, "$/"
    unless_null $P1689, vivify_1227
    $P1689 = root_new ['parrot';'Hash']
  vivify_1227:
    set $P1690, $P1689["name"]
    unless_null $P1690, vivify_1228
    $P1690 = root_new ['parrot';'Hash']
  vivify_1228:
    set $P1691, $P1690["identifier"]
    unless_null $P1691, vivify_1229
    $P1691 = root_new ['parrot';'ResizablePMCArray']
  vivify_1229:
    set $P138, $P1691[$I104]
    unless_null $P138, vivify_1230
    new $P138, "Undef"
  vivify_1230:
    find_dynamic_lex $P141, "$*PACKAGE"
    unless_null $P141, vivify_1231
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PACKAGE"]
    unless_null $P141, vivify_1232
    die "Contextual $*PACKAGE not found"
  vivify_1232:
  vivify_1231:
    $P142 = $P130."install_lexical_symbol"($P136, $P138, $P141)
.annotate 'line', 797
    set $P126, $P142
  if_1685_end:
.annotate 'line', 795
    set $P118, $P126
  if_1681_end:
.annotate 'line', 784
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("184_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P138 = self."!PREFIX__!subrule"("ws", "")
    new $P139, "ResizablePMCArray"
    push $P139, $P138
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("185_1312646121.678")
    .param pmc param_1706
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 821
    .lex "self", param_1706
    $P103 = param_1706."!protoregex"("scope_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("186_1312646121.678")
    .param pmc param_1708
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 821
    .lex "self", param_1708
    $P104 = param_1708."!PREFIX__!protoregex"("scope_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("187_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1710_tgt
    .local int rx1710_pos
    .local int rx1710_off
    .local int rx1710_eos
    .local int rx1710_rep
    .local pmc rx1710_cur
    .local pmc rx1710_debug
    (rx1710_cur, rx1710_pos, rx1710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1710_cur
    .local pmc match
    .lex "$/", match
    length rx1710_eos, rx1710_tgt
    gt rx1710_pos, rx1710_eos, rx1710_done
    set rx1710_off, 0
    lt rx1710_pos, 2, rx1710_start
    sub rx1710_off, rx1710_pos, 1
    substr rx1710_tgt, rx1710_tgt, rx1710_off
  rx1710_start:
    eq $I10, 1, rx1710_restart
    if_null rx1710_debug, debug_1236
    rx1710_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1236:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1711_done
    goto rxscan1711_scan
  rxscan1711_loop:
    (rx1710_pos) = rx1710_cur."from"()
    inc rx1710_pos
    rx1710_cur."!cursor_from"(rx1710_pos)
    ge rx1710_pos, rx1710_eos, rxscan1711_done
  rxscan1711_scan:
    set_addr $I10, rxscan1711_loop
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  rxscan1711_done:
.annotate 'line', 822
  # rx subcapture "sym"
    set_addr $I10, rxcap_1712_fail
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  # rx literal  "my"
    add $I11, rx1710_pos, 2
    gt $I11, rx1710_eos, rx1710_fail
    sub $I11, rx1710_pos, rx1710_off
    substr $S10, rx1710_tgt, $I11, 2
    ne $S10, "my", rx1710_fail
    add rx1710_pos, 2
    set_addr $I10, rxcap_1712_fail
    ($I12, $I11) = rx1710_cur."!mark_peek"($I10)
    rx1710_cur."!cursor_pos"($I11)
    ($P10) = rx1710_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1710_pos, "")
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1712_done
  rxcap_1712_fail:
    goto rx1710_fail
  rxcap_1712_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1710_cur."!cursor_pos"(rx1710_pos)
    $P10 = rx1710_cur."scoped"("my")
    unless $P10, rx1710_fail
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1710_pos = $P10."pos"()
  # rx pass
    rx1710_cur."!cursor_pass"(rx1710_pos, "scope_declarator:sym<my>")
    if_null rx1710_debug, debug_1237
    rx1710_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1710_pos)
  debug_1237:
    .return (rx1710_cur)
  rx1710_restart:
.annotate 'line', 440
    if_null rx1710_debug, debug_1238
    rx1710_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1238:
  rx1710_fail:
    (rx1710_rep, rx1710_pos, $I10, $P10) = rx1710_cur."!mark_fail"(0)
    lt rx1710_pos, -1, rx1710_done
    eq rx1710_pos, -1, rx1710_fail
    jump $I10
  rx1710_done:
    rx1710_cur."!cursor_fail"()
    if_null rx1710_debug, debug_1239
    rx1710_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1239:
    .return (rx1710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("188_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("scoped", "my")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("189_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1715_tgt
    .local int rx1715_pos
    .local int rx1715_off
    .local int rx1715_eos
    .local int rx1715_rep
    .local pmc rx1715_cur
    .local pmc rx1715_debug
    (rx1715_cur, rx1715_pos, rx1715_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1715_cur
    .local pmc match
    .lex "$/", match
    length rx1715_eos, rx1715_tgt
    gt rx1715_pos, rx1715_eos, rx1715_done
    set rx1715_off, 0
    lt rx1715_pos, 2, rx1715_start
    sub rx1715_off, rx1715_pos, 1
    substr rx1715_tgt, rx1715_tgt, rx1715_off
  rx1715_start:
    eq $I10, 1, rx1715_restart
    if_null rx1715_debug, debug_1240
    rx1715_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1240:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1716_done
    goto rxscan1716_scan
  rxscan1716_loop:
    (rx1715_pos) = rx1715_cur."from"()
    inc rx1715_pos
    rx1715_cur."!cursor_from"(rx1715_pos)
    ge rx1715_pos, rx1715_eos, rxscan1716_done
  rxscan1716_scan:
    set_addr $I10, rxscan1716_loop
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  rxscan1716_done:
.annotate 'line', 823
  # rx subcapture "sym"
    set_addr $I10, rxcap_1717_fail
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  # rx literal  "our"
    add $I11, rx1715_pos, 3
    gt $I11, rx1715_eos, rx1715_fail
    sub $I11, rx1715_pos, rx1715_off
    substr $S10, rx1715_tgt, $I11, 3
    ne $S10, "our", rx1715_fail
    add rx1715_pos, 3
    set_addr $I10, rxcap_1717_fail
    ($I12, $I11) = rx1715_cur."!mark_peek"($I10)
    rx1715_cur."!cursor_pos"($I11)
    ($P10) = rx1715_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1715_pos, "")
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1717_done
  rxcap_1717_fail:
    goto rx1715_fail
  rxcap_1717_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1715_cur."!cursor_pos"(rx1715_pos)
    $P10 = rx1715_cur."scoped"("our")
    unless $P10, rx1715_fail
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1715_pos = $P10."pos"()
  # rx pass
    rx1715_cur."!cursor_pass"(rx1715_pos, "scope_declarator:sym<our>")
    if_null rx1715_debug, debug_1241
    rx1715_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1715_pos)
  debug_1241:
    .return (rx1715_cur)
  rx1715_restart:
.annotate 'line', 440
    if_null rx1715_debug, debug_1242
    rx1715_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1242:
  rx1715_fail:
    (rx1715_rep, rx1715_pos, $I10, $P10) = rx1715_cur."!mark_fail"(0)
    lt rx1715_pos, -1, rx1715_done
    eq rx1715_pos, -1, rx1715_fail
    jump $I10
  rx1715_done:
    rx1715_cur."!cursor_fail"()
    if_null rx1715_debug, debug_1243
    rx1715_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1243:
    .return (rx1715_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("190_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("scoped", "our")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("191_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1720_tgt
    .local int rx1720_pos
    .local int rx1720_off
    .local int rx1720_eos
    .local int rx1720_rep
    .local pmc rx1720_cur
    .local pmc rx1720_debug
    (rx1720_cur, rx1720_pos, rx1720_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1720_cur
    .local pmc match
    .lex "$/", match
    length rx1720_eos, rx1720_tgt
    gt rx1720_pos, rx1720_eos, rx1720_done
    set rx1720_off, 0
    lt rx1720_pos, 2, rx1720_start
    sub rx1720_off, rx1720_pos, 1
    substr rx1720_tgt, rx1720_tgt, rx1720_off
  rx1720_start:
    eq $I10, 1, rx1720_restart
    if_null rx1720_debug, debug_1244
    rx1720_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1244:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1721_done
    goto rxscan1721_scan
  rxscan1721_loop:
    (rx1720_pos) = rx1720_cur."from"()
    inc rx1720_pos
    rx1720_cur."!cursor_from"(rx1720_pos)
    ge rx1720_pos, rx1720_eos, rxscan1721_done
  rxscan1721_scan:
    set_addr $I10, rxscan1721_loop
    rx1720_cur."!mark_push"(0, rx1720_pos, $I10)
  rxscan1721_done:
.annotate 'line', 824
  # rx subcapture "sym"
    set_addr $I10, rxcap_1722_fail
    rx1720_cur."!mark_push"(0, rx1720_pos, $I10)
  # rx literal  "has"
    add $I11, rx1720_pos, 3
    gt $I11, rx1720_eos, rx1720_fail
    sub $I11, rx1720_pos, rx1720_off
    substr $S10, rx1720_tgt, $I11, 3
    ne $S10, "has", rx1720_fail
    add rx1720_pos, 3
    set_addr $I10, rxcap_1722_fail
    ($I12, $I11) = rx1720_cur."!mark_peek"($I10)
    rx1720_cur."!cursor_pos"($I11)
    ($P10) = rx1720_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1720_pos, "")
    rx1720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1722_done
  rxcap_1722_fail:
    goto rx1720_fail
  rxcap_1722_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1720_cur."!cursor_pos"(rx1720_pos)
    $P10 = rx1720_cur."scoped"("has")
    unless $P10, rx1720_fail
    rx1720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1720_pos = $P10."pos"()
  # rx pass
    rx1720_cur."!cursor_pass"(rx1720_pos, "scope_declarator:sym<has>")
    if_null rx1720_debug, debug_1245
    rx1720_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1720_pos)
  debug_1245:
    .return (rx1720_cur)
  rx1720_restart:
.annotate 'line', 440
    if_null rx1720_debug, debug_1246
    rx1720_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1246:
  rx1720_fail:
    (rx1720_rep, rx1720_pos, $I10, $P10) = rx1720_cur."!mark_fail"(0)
    lt rx1720_pos, -1, rx1720_done
    eq rx1720_pos, -1, rx1720_fail
    jump $I10
  rx1720_done:
    rx1720_cur."!cursor_fail"()
    if_null rx1720_debug, debug_1247
    rx1720_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1247:
    .return (rx1720_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("192_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("scoped", "has")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("193_1312646121.678") :method :outer("40_1312646121.678")
    .param pmc param_1725
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 826
    .lex "$*SCOPE", param_1725
.annotate 'line', 440
    .local string rx1726_tgt
    .local int rx1726_pos
    .local int rx1726_off
    .local int rx1726_eos
    .local int rx1726_rep
    .local pmc rx1726_cur
    .local pmc rx1726_debug
    (rx1726_cur, rx1726_pos, rx1726_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1726_cur
    .local pmc match
    .lex "$/", match
    length rx1726_eos, rx1726_tgt
    gt rx1726_pos, rx1726_eos, rx1726_done
    set rx1726_off, 0
    lt rx1726_pos, 2, rx1726_start
    sub rx1726_off, rx1726_pos, 1
    substr rx1726_tgt, rx1726_tgt, rx1726_off
  rx1726_start:
    eq $I10, 1, rx1726_restart
    if_null rx1726_debug, debug_1248
    rx1726_cur."!cursor_debug"("START", "scoped")
  debug_1248:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1727_done
    goto rxscan1727_scan
  rxscan1727_loop:
    (rx1726_pos) = rx1726_cur."from"()
    inc rx1726_pos
    rx1726_cur."!cursor_from"(rx1726_pos)
    ge rx1726_pos, rx1726_eos, rxscan1727_done
  rxscan1727_scan:
    set_addr $I10, rxscan1727_loop
    rx1726_cur."!mark_push"(0, rx1726_pos, $I10)
  rxscan1727_done:
  alt1728_0:
.annotate 'line', 826
    set_addr $I10, alt1728_1
    rx1726_cur."!mark_push"(0, rx1726_pos, $I10)
.annotate 'line', 827
  # rx subrule "ws" subtype=method negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."ws"()
    unless $P10, rx1726_fail
    rx1726_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."declarator"()
    unless $P10, rx1726_fail
    rx1726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."ws"()
    unless $P10, rx1726_fail
    rx1726_pos = $P10."pos"()
    goto alt1728_end
  alt1728_1:
    set_addr $I10, alt1728_2
    rx1726_cur."!mark_push"(0, rx1726_pos, $I10)
.annotate 'line', 828
  # rx subrule "ws" subtype=method negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."ws"()
    unless $P10, rx1726_fail
    rx1726_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."multi_declarator"()
    unless $P10, rx1726_fail
    rx1726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."ws"()
    unless $P10, rx1726_fail
    rx1726_pos = $P10."pos"()
    goto alt1728_end
  alt1728_2:
.annotate 'line', 829
  # rx subrule "ws" subtype=method negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."ws"()
    unless $P10, rx1726_fail
    rx1726_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."package_declarator"()
    unless $P10, rx1726_fail
    rx1726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1726_cur."!cursor_pos"(rx1726_pos)
    $P10 = rx1726_cur."ws"()
    unless $P10, rx1726_fail
    rx1726_pos = $P10."pos"()
  alt1728_end:
.annotate 'line', 826
  # rx pass
    rx1726_cur."!cursor_pass"(rx1726_pos, "scoped")
    if_null rx1726_debug, debug_1249
    rx1726_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1726_pos)
  debug_1249:
    .return (rx1726_cur)
  rx1726_restart:
.annotate 'line', 440
    if_null rx1726_debug, debug_1250
    rx1726_cur."!cursor_debug"("NEXT", "scoped")
  debug_1250:
  rx1726_fail:
    (rx1726_rep, rx1726_pos, $I10, $P10) = rx1726_cur."!mark_fail"(0)
    lt rx1726_pos, -1, rx1726_done
    eq rx1726_pos, -1, rx1726_fail
    jump $I10
  rx1726_done:
    rx1726_cur."!cursor_fail"()
    if_null rx1726_debug, debug_1251
    rx1726_cur."!cursor_debug"("FAIL", "scoped")
  debug_1251:
    .return (rx1726_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("194_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P109 = self."!PREFIX__!subrule"("ws", "")
    $P110 = self."!PREFIX__!subrule"("ws", "")
    $P111 = self."!PREFIX__!subrule"("ws", "")
    new $P112, "ResizablePMCArray"
    push $P112, $P109
    push $P112, $P110
    push $P112, $P111
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("195_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1734 = "196_1312646121.678" 
    capture_lex $P1734
    .local string rx1731_tgt
    .local int rx1731_pos
    .local int rx1731_off
    .local int rx1731_eos
    .local int rx1731_rep
    .local pmc rx1731_cur
    .local pmc rx1731_debug
    (rx1731_cur, rx1731_pos, rx1731_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1731_cur
    .local pmc match
    .lex "$/", match
    length rx1731_eos, rx1731_tgt
    gt rx1731_pos, rx1731_eos, rx1731_done
    set rx1731_off, 0
    lt rx1731_pos, 2, rx1731_start
    sub rx1731_off, rx1731_pos, 1
    substr rx1731_tgt, rx1731_tgt, rx1731_off
  rx1731_start:
    eq $I10, 1, rx1731_restart
    if_null rx1731_debug, debug_1252
    rx1731_cur."!cursor_debug"("START", "typename")
  debug_1252:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1732_done
    goto rxscan1732_scan
  rxscan1732_loop:
    (rx1731_pos) = rx1731_cur."from"()
    inc rx1731_pos
    rx1731_cur."!cursor_from"(rx1731_pos)
    ge rx1731_pos, rx1731_eos, rxscan1732_done
  rxscan1732_scan:
    set_addr $I10, rxscan1732_loop
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  rxscan1732_done:
.annotate 'line', 833
  # rx subrule "name" subtype=capture negate=
    rx1731_cur."!cursor_pos"(rx1731_pos)
    $P10 = rx1731_cur."name"()
    unless $P10, rx1731_fail
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1731_pos = $P10."pos"()
.annotate 'line', 834
    rx1731_cur."!cursor_pos"(rx1731_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1734 = "196_1312646121.678" 
    capture_lex $P1734
    $P105 = $P1734()
    unless $P105, rx1731_fail
.annotate 'line', 832
  # rx pass
    rx1731_cur."!cursor_pass"(rx1731_pos, "typename")
    if_null rx1731_debug, debug_1259
    rx1731_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1731_pos)
  debug_1259:
    .return (rx1731_cur)
  rx1731_restart:
.annotate 'line', 440
    if_null rx1731_debug, debug_1260
    rx1731_cur."!cursor_debug"("NEXT", "typename")
  debug_1260:
  rx1731_fail:
    (rx1731_rep, rx1731_pos, $I10, $P10) = rx1731_cur."!mark_fail"(0)
    lt rx1731_pos, -1, rx1731_done
    eq rx1731_pos, -1, rx1731_fail
    jump $I10
  rx1731_done:
    rx1731_cur."!cursor_fail"()
    if_null rx1731_debug, debug_1261
    rx1731_cur."!cursor_debug"("FAIL", "typename")
  debug_1261:
    .return (rx1731_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1733"  :anon :subid("196_1312646121.678") :outer("195_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 834
    find_dynamic_lex $P107, "$*ACTIONS"
    unless_null $P107, vivify_1253
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$ACTIONS"]
    unless_null $P107, vivify_1254
    die "Contextual $*ACTIONS not found"
  vivify_1254:
  vivify_1253:
    find_lex $P108, "$/"
    unless_null $P108, vivify_1255
    new $P108, "Undef"
  vivify_1255:
    find_lex $P1735, "$/"
    unless_null $P1735, vivify_1256
    $P1735 = root_new ['parrot';'Hash']
  vivify_1256:
    set $P1736, $P1735["name"]
    unless_null $P1736, vivify_1257
    $P1736 = root_new ['parrot';'Hash']
  vivify_1257:
    set $P109, $P1736["identifier"]
    unless_null $P109, vivify_1258
    new $P109, "Undef"
  vivify_1258:
    $P110 = $P107."known_sym"($P108, $P109)
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("197_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P106 = self."!PREFIX__!subrule"("name", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("198_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1739_tgt
    .local int rx1739_pos
    .local int rx1739_off
    .local int rx1739_eos
    .local int rx1739_rep
    .local pmc rx1739_cur
    .local pmc rx1739_debug
    (rx1739_cur, rx1739_pos, rx1739_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1739_cur
    .local pmc match
    .lex "$/", match
    length rx1739_eos, rx1739_tgt
    gt rx1739_pos, rx1739_eos, rx1739_done
    set rx1739_off, 0
    lt rx1739_pos, 2, rx1739_start
    sub rx1739_off, rx1739_pos, 1
    substr rx1739_tgt, rx1739_tgt, rx1739_off
  rx1739_start:
    eq $I10, 1, rx1739_restart
    if_null rx1739_debug, debug_1262
    rx1739_cur."!cursor_debug"("START", "declarator")
  debug_1262:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1740_done
    goto rxscan1740_scan
  rxscan1740_loop:
    (rx1739_pos) = rx1739_cur."from"()
    inc rx1739_pos
    rx1739_cur."!cursor_from"(rx1739_pos)
    ge rx1739_pos, rx1739_eos, rxscan1740_done
  rxscan1740_scan:
    set_addr $I10, rxscan1740_loop
    rx1739_cur."!mark_push"(0, rx1739_pos, $I10)
  rxscan1740_done:
  alt1741_0:
.annotate 'line', 837
    set_addr $I10, alt1741_1
    rx1739_cur."!mark_push"(0, rx1739_pos, $I10)
.annotate 'line', 838
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1739_cur."!cursor_pos"(rx1739_pos)
    $P10 = rx1739_cur."variable_declarator"()
    unless $P10, rx1739_fail
    rx1739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1739_pos = $P10."pos"()
    goto alt1741_end
  alt1741_1:
.annotate 'line', 839
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1739_cur."!cursor_pos"(rx1739_pos)
    $P10 = rx1739_cur."routine_declarator"()
    unless $P10, rx1739_fail
    rx1739_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1739_pos = $P10."pos"()
  alt1741_end:
.annotate 'line', 837
  # rx pass
    rx1739_cur."!cursor_pass"(rx1739_pos, "declarator")
    if_null rx1739_debug, debug_1263
    rx1739_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1739_pos)
  debug_1263:
    .return (rx1739_cur)
  rx1739_restart:
.annotate 'line', 440
    if_null rx1739_debug, debug_1264
    rx1739_cur."!cursor_debug"("NEXT", "declarator")
  debug_1264:
  rx1739_fail:
    (rx1739_rep, rx1739_pos, $I10, $P10) = rx1739_cur."!mark_fail"(0)
    lt rx1739_pos, -1, rx1739_done
    eq rx1739_pos, -1, rx1739_fail
    jump $I10
  rx1739_done:
    rx1739_cur."!cursor_fail"()
    if_null rx1739_debug, debug_1265
    rx1739_cur."!cursor_debug"("FAIL", "declarator")
  debug_1265:
    .return (rx1739_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("199_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P104 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("200_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1750 = "201_1312646121.678" 
    capture_lex $P1750
.annotate 'line', 844
    new $P103, "Undef"
    set $P1744, $P103
    .lex "$*IN_DECL", $P1744
.annotate 'line', 440
    .local string rx1745_tgt
    .local int rx1745_pos
    .local int rx1745_off
    .local int rx1745_eos
    .local int rx1745_rep
    .local pmc rx1745_cur
    .local pmc rx1745_debug
    (rx1745_cur, rx1745_pos, rx1745_tgt, $I10) = self."!cursor_start"()
    rx1745_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1745_cur
    .local pmc match
    .lex "$/", match
    length rx1745_eos, rx1745_tgt
    gt rx1745_pos, rx1745_eos, rx1745_done
    set rx1745_off, 0
    lt rx1745_pos, 2, rx1745_start
    sub rx1745_off, rx1745_pos, 1
    substr rx1745_tgt, rx1745_tgt, rx1745_off
  rx1745_start:
    eq $I10, 1, rx1745_restart
    if_null rx1745_debug, debug_1266
    rx1745_cur."!cursor_debug"("START", "variable_declarator")
  debug_1266:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1746_done
    goto rxscan1746_scan
  rxscan1746_loop:
    (rx1745_pos) = rx1745_cur."from"()
    inc rx1745_pos
    rx1745_cur."!cursor_from"(rx1745_pos)
    ge rx1745_pos, rx1745_eos, rxscan1746_done
  rxscan1746_scan:
    set_addr $I10, rxscan1746_loop
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  rxscan1746_done:
.annotate 'line', 842
  # rx subrule "ws" subtype=method negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."ws"()
    unless $P10, rx1745_fail
    rx1745_pos = $P10."pos"()
.annotate 'line', 843
  # rx rxquantr1747 ** 0..1
    set_addr $I10, rxquantr1747_done
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  rxquantr1747_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."typename"()
    unless $P10, rx1745_fail
    goto rxsubrule1748_pass
  rxsubrule1748_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1745_fail
  rxsubrule1748_pass:
    set_addr $I10, rxsubrule1748_back
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1745_pos = $P10."pos"()
    set_addr $I10, rxquantr1747_done
    (rx1745_rep) = rx1745_cur."!mark_commit"($I10)
  rxquantr1747_done:
  # rx subrule "ws" subtype=method negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."ws"()
    unless $P10, rx1745_fail
    rx1745_pos = $P10."pos"()
.annotate 'line', 844
    rx1745_cur."!cursor_pos"(rx1745_pos)
    new $P106, "String"
    assign $P106, "variable"
    store_lex "$*IN_DECL", $P106
  # rx subrule "ws" subtype=method negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."ws"()
    unless $P10, rx1745_fail
    rx1745_pos = $P10."pos"()
.annotate 'line', 845
  # rx subrule "variable" subtype=capture negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."variable"()
    unless $P10, rx1745_fail
    rx1745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."ws"()
    unless $P10, rx1745_fail
    rx1745_pos = $P10."pos"()
.annotate 'line', 846
    rx1745_cur."!cursor_pos"(rx1745_pos)
    find_lex $P109, unicode:"$\x{a2}"
    $P110 = $P109."MATCH"()
    store_lex "$/", $P110
    .const 'Sub' $P1750 = "201_1312646121.678" 
    capture_lex $P1750
    $P112 = $P1750()
  # rx subrule "ws" subtype=method negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."ws"()
    unless $P10, rx1745_fail
    rx1745_pos = $P10."pos"()
.annotate 'line', 847
  # rx rxquantr1751 ** 0..*
    set_addr $I10, rxquantr1751_done
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  rxquantr1751_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."trait"()
    unless $P10, rx1745_fail
    goto rxsubrule1752_pass
  rxsubrule1752_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1745_fail
  rxsubrule1752_pass:
    set_addr $I10, rxsubrule1752_back
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1745_pos = $P10."pos"()
    set_addr $I10, rxquantr1751_done
    (rx1745_rep) = rx1745_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1751_done
    rx1745_cur."!mark_push"(rx1745_rep, rx1745_pos, $I10)
    goto rxquantr1751_loop
  rxquantr1751_done:
  # rx subrule "ws" subtype=method negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."ws"()
    unless $P10, rx1745_fail
    rx1745_pos = $P10."pos"()
.annotate 'line', 842
  # rx pass
    rx1745_cur."!cursor_pass"(rx1745_pos, "variable_declarator")
    if_null rx1745_debug, debug_1267
    rx1745_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1745_pos)
  debug_1267:
    .return (rx1745_cur)
  rx1745_restart:
.annotate 'line', 440
    if_null rx1745_debug, debug_1268
    rx1745_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1268:
  rx1745_fail:
    (rx1745_rep, rx1745_pos, $I10, $P10) = rx1745_cur."!mark_fail"(0)
    lt rx1745_pos, -1, rx1745_done
    eq rx1745_pos, -1, rx1745_fail
    jump $I10
  rx1745_done:
    rx1745_cur."!cursor_fail"()
    if_null rx1745_debug, debug_1269
    rx1745_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1269:
    .return (rx1745_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1749"  :anon :subid("201_1312646121.678") :outer("200_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 846
    new $P111, "Float"
    assign $P111, 0
    store_dynamic_lex "$*IN_DECL", $P111
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("202_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P115 = self."!PREFIX__!subrule"("ws", "")
    new $P116, "ResizablePMCArray"
    push $P116, $P115
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("203_1312646121.678")
    .param pmc param_1755
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 850
    .lex "self", param_1755
    $P103 = param_1755."!protoregex"("routine_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("204_1312646121.678")
    .param pmc param_1757
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 850
    .lex "self", param_1757
    $P104 = param_1757."!PREFIX__!protoregex"("routine_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("205_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1759_tgt
    .local int rx1759_pos
    .local int rx1759_off
    .local int rx1759_eos
    .local int rx1759_rep
    .local pmc rx1759_cur
    .local pmc rx1759_debug
    (rx1759_cur, rx1759_pos, rx1759_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1759_cur
    .local pmc match
    .lex "$/", match
    length rx1759_eos, rx1759_tgt
    gt rx1759_pos, rx1759_eos, rx1759_done
    set rx1759_off, 0
    lt rx1759_pos, 2, rx1759_start
    sub rx1759_off, rx1759_pos, 1
    substr rx1759_tgt, rx1759_tgt, rx1759_off
  rx1759_start:
    eq $I10, 1, rx1759_restart
    if_null rx1759_debug, debug_1270
    rx1759_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1270:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1760_done
    goto rxscan1760_scan
  rxscan1760_loop:
    (rx1759_pos) = rx1759_cur."from"()
    inc rx1759_pos
    rx1759_cur."!cursor_from"(rx1759_pos)
    ge rx1759_pos, rx1759_eos, rxscan1760_done
  rxscan1760_scan:
    set_addr $I10, rxscan1760_loop
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  rxscan1760_done:
.annotate 'line', 851
  # rx subcapture "sym"
    set_addr $I10, rxcap_1761_fail
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1759_pos, 3
    gt $I11, rx1759_eos, rx1759_fail
    sub $I11, rx1759_pos, rx1759_off
    substr $S10, rx1759_tgt, $I11, 3
    ne $S10, "sub", rx1759_fail
    add rx1759_pos, 3
    set_addr $I10, rxcap_1761_fail
    ($I12, $I11) = rx1759_cur."!mark_peek"($I10)
    rx1759_cur."!cursor_pos"($I11)
    ($P10) = rx1759_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1759_pos, "")
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1761_done
  rxcap_1761_fail:
    goto rx1759_fail
  rxcap_1761_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1759_cur."!cursor_pos"(rx1759_pos)
    $P10 = rx1759_cur."routine_def"()
    unless $P10, rx1759_fail
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1759_pos = $P10."pos"()
  # rx pass
    rx1759_cur."!cursor_pass"(rx1759_pos, "routine_declarator:sym<sub>")
    if_null rx1759_debug, debug_1271
    rx1759_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1759_pos)
  debug_1271:
    .return (rx1759_cur)
  rx1759_restart:
.annotate 'line', 440
    if_null rx1759_debug, debug_1272
    rx1759_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1272:
  rx1759_fail:
    (rx1759_rep, rx1759_pos, $I10, $P10) = rx1759_cur."!mark_fail"(0)
    lt rx1759_pos, -1, rx1759_done
    eq rx1759_pos, -1, rx1759_fail
    jump $I10
  rx1759_done:
    rx1759_cur."!cursor_fail"()
    if_null rx1759_debug, debug_1273
    rx1759_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1273:
    .return (rx1759_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("206_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("207_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1764_tgt
    .local int rx1764_pos
    .local int rx1764_off
    .local int rx1764_eos
    .local int rx1764_rep
    .local pmc rx1764_cur
    .local pmc rx1764_debug
    (rx1764_cur, rx1764_pos, rx1764_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1764_cur
    .local pmc match
    .lex "$/", match
    length rx1764_eos, rx1764_tgt
    gt rx1764_pos, rx1764_eos, rx1764_done
    set rx1764_off, 0
    lt rx1764_pos, 2, rx1764_start
    sub rx1764_off, rx1764_pos, 1
    substr rx1764_tgt, rx1764_tgt, rx1764_off
  rx1764_start:
    eq $I10, 1, rx1764_restart
    if_null rx1764_debug, debug_1274
    rx1764_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1274:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1765_done
    goto rxscan1765_scan
  rxscan1765_loop:
    (rx1764_pos) = rx1764_cur."from"()
    inc rx1764_pos
    rx1764_cur."!cursor_from"(rx1764_pos)
    ge rx1764_pos, rx1764_eos, rxscan1765_done
  rxscan1765_scan:
    set_addr $I10, rxscan1765_loop
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  rxscan1765_done:
.annotate 'line', 852
  # rx subcapture "sym"
    set_addr $I10, rxcap_1766_fail
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  # rx literal  "method"
    add $I11, rx1764_pos, 6
    gt $I11, rx1764_eos, rx1764_fail
    sub $I11, rx1764_pos, rx1764_off
    substr $S10, rx1764_tgt, $I11, 6
    ne $S10, "method", rx1764_fail
    add rx1764_pos, 6
    set_addr $I10, rxcap_1766_fail
    ($I12, $I11) = rx1764_cur."!mark_peek"($I10)
    rx1764_cur."!cursor_pos"($I11)
    ($P10) = rx1764_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1764_pos, "")
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1766_done
  rxcap_1766_fail:
    goto rx1764_fail
  rxcap_1766_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1764_cur."!cursor_pos"(rx1764_pos)
    $P10 = rx1764_cur."method_def"()
    unless $P10, rx1764_fail
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1764_pos = $P10."pos"()
  # rx pass
    rx1764_cur."!cursor_pass"(rx1764_pos, "routine_declarator:sym<method>")
    if_null rx1764_debug, debug_1275
    rx1764_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1764_pos)
  debug_1275:
    .return (rx1764_cur)
  rx1764_restart:
.annotate 'line', 440
    if_null rx1764_debug, debug_1276
    rx1764_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1276:
  rx1764_fail:
    (rx1764_rep, rx1764_pos, $I10, $P10) = rx1764_cur."!mark_fail"(0)
    lt rx1764_pos, -1, rx1764_done
    eq rx1764_pos, -1, rx1764_fail
    jump $I10
  rx1764_done:
    rx1764_cur."!cursor_fail"()
    if_null rx1764_debug, debug_1277
    rx1764_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1277:
    .return (rx1764_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("208_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("method_def", "method")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("209_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 855
    new $P103, "Undef"
    set $P1769, $P103
    .lex "$*RETURN_USED", $P1769
.annotate 'line', 440
    .local string rx1770_tgt
    .local int rx1770_pos
    .local int rx1770_off
    .local int rx1770_eos
    .local int rx1770_rep
    .local pmc rx1770_cur
    .local pmc rx1770_debug
    (rx1770_cur, rx1770_pos, rx1770_tgt, $I10) = self."!cursor_start"()
    rx1770_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1770_cur
    .local pmc match
    .lex "$/", match
    length rx1770_eos, rx1770_tgt
    gt rx1770_pos, rx1770_eos, rx1770_done
    set rx1770_off, 0
    lt rx1770_pos, 2, rx1770_start
    sub rx1770_off, rx1770_pos, 1
    substr rx1770_tgt, rx1770_tgt, rx1770_off
  rx1770_start:
    eq $I10, 1, rx1770_restart
    if_null rx1770_debug, debug_1278
    rx1770_cur."!cursor_debug"("START", "routine_def")
  debug_1278:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1771_done
    goto rxscan1771_scan
  rxscan1771_loop:
    (rx1770_pos) = rx1770_cur."from"()
    inc rx1770_pos
    rx1770_cur."!cursor_from"(rx1770_pos)
    ge rx1770_pos, rx1770_eos, rxscan1771_done
  rxscan1771_scan:
    set_addr $I10, rxscan1771_loop
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  rxscan1771_done:
.annotate 'line', 854
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
.annotate 'line', 855
    rx1770_cur."!cursor_pos"(rx1770_pos)
    new $P105, "Float"
    assign $P105, 0
    store_lex "$*RETURN_USED", $P105
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
.annotate 'line', 856
  # rx rxquantr1772 ** 0..1
    set_addr $I10, rxquantr1772_done
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  rxquantr1772_loop:
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1774_fail
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  # rx rxquantr1773 ** 0..1
    set_addr $I10, rxquantr1773_done
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  rxquantr1773_loop:
  # rx literal  "&"
    add $I11, rx1770_pos, 1
    gt $I11, rx1770_eos, rx1770_fail
    sub $I11, rx1770_pos, rx1770_off
    ord $I11, rx1770_tgt, $I11
    ne $I11, 38, rx1770_fail
    add rx1770_pos, 1
    set_addr $I10, rxquantr1773_done
    (rx1770_rep) = rx1770_cur."!mark_commit"($I10)
  rxquantr1773_done:
    set_addr $I10, rxcap_1774_fail
    ($I12, $I11) = rx1770_cur."!mark_peek"($I10)
    rx1770_cur."!cursor_pos"($I11)
    ($P10) = rx1770_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1770_pos, "")
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1774_done
  rxcap_1774_fail:
    goto rx1770_fail
  rxcap_1774_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."deflongname"()
    unless $P10, rx1770_fail
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1770_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
    set_addr $I10, rxquantr1772_done
    (rx1770_rep) = rx1770_cur."!mark_commit"($I10)
  rxquantr1772_done:
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
.annotate 'line', 857
  # rx subrule "newpad" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."newpad"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  alt1775_0:
.annotate 'line', 858
    set_addr $I10, alt1775_1
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1770_pos, 1
    gt $I11, rx1770_eos, rx1770_fail
    sub $I11, rx1770_pos, rx1770_off
    ord $I11, rx1770_tgt, $I11
    ne $I11, 40, rx1770_fail
    add rx1770_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."signature"()
    unless $P10, rx1770_fail
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1770_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1770_pos, 1
    gt $I11, rx1770_eos, rx1770_fail
    sub $I11, rx1770_pos, rx1770_off
    ord $I11, rx1770_tgt, $I11
    ne $I11, 41, rx1770_fail
    add rx1770_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
    goto alt1775_end
  alt1775_1:
.annotate 'line', 859
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  alt1775_end:
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
.annotate 'line', 860
  # rx rxquantr1776 ** 0..*
    set_addr $I10, rxquantr1776_done
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  rxquantr1776_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."trait"()
    unless $P10, rx1770_fail
    goto rxsubrule1777_pass
  rxsubrule1777_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1770_fail
  rxsubrule1777_pass:
    set_addr $I10, rxsubrule1777_back
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1770_pos = $P10."pos"()
    set_addr $I10, rxquantr1776_done
    (rx1770_rep) = rx1770_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1776_done
    rx1770_cur."!mark_push"(rx1770_rep, rx1770_pos, $I10)
    goto rxquantr1776_loop
  rxquantr1776_done:
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  alt1778_0:
.annotate 'line', 861
    set_addr $I10, alt1778_1
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
.annotate 'line', 862
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."onlystar"()
    unless $P10, rx1770_fail
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1770_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
    goto alt1778_end
  alt1778_1:
.annotate 'line', 863
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."blockoid"()
    unless $P10, rx1770_fail
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1770_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
  alt1778_end:
.annotate 'line', 864
  # rx subrule "ws" subtype=method negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."ws"()
    unless $P10, rx1770_fail
    rx1770_pos = $P10."pos"()
.annotate 'line', 854
  # rx pass
    rx1770_cur."!cursor_pass"(rx1770_pos, "routine_def")
    if_null rx1770_debug, debug_1279
    rx1770_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1770_pos)
  debug_1279:
    .return (rx1770_cur)
  rx1770_restart:
.annotate 'line', 440
    if_null rx1770_debug, debug_1280
    rx1770_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1280:
  rx1770_fail:
    (rx1770_rep, rx1770_pos, $I10, $P10) = rx1770_cur."!mark_fail"(0)
    lt rx1770_pos, -1, rx1770_done
    eq rx1770_pos, -1, rx1770_fail
    jump $I10
  rx1770_done:
    rx1770_cur."!cursor_fail"()
    if_null rx1770_debug, debug_1281
    rx1770_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1281:
    .return (rx1770_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("210_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P124 = self."!PREFIX__!subrule"("ws", "")
    new $P125, "ResizablePMCArray"
    push $P125, $P124
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("211_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1791 = "212_1312646121.678" 
    capture_lex $P1791
.annotate 'line', 868
    new $P103, "Undef"
    set $P1781, $P103
    .lex "$*RETURN_USED", $P1781
.annotate 'line', 869
    new $P104, "Undef"
    set $P1782, $P104
    .lex "$*INVOCANT_OK", $P1782
.annotate 'line', 440
    .local string rx1783_tgt
    .local int rx1783_pos
    .local int rx1783_off
    .local int rx1783_eos
    .local int rx1783_rep
    .local pmc rx1783_cur
    .local pmc rx1783_debug
    (rx1783_cur, rx1783_pos, rx1783_tgt, $I10) = self."!cursor_start"()
    rx1783_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1783_cur
    .local pmc match
    .lex "$/", match
    length rx1783_eos, rx1783_tgt
    gt rx1783_pos, rx1783_eos, rx1783_done
    set rx1783_off, 0
    lt rx1783_pos, 2, rx1783_start
    sub rx1783_off, rx1783_pos, 1
    substr rx1783_tgt, rx1783_tgt, rx1783_off
  rx1783_start:
    eq $I10, 1, rx1783_restart
    if_null rx1783_debug, debug_1282
    rx1783_cur."!cursor_debug"("START", "method_def")
  debug_1282:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1784_done
    goto rxscan1784_scan
  rxscan1784_loop:
    (rx1783_pos) = rx1783_cur."from"()
    inc rx1783_pos
    rx1783_cur."!cursor_from"(rx1783_pos)
    ge rx1783_pos, rx1783_eos, rxscan1784_done
  rxscan1784_scan:
    set_addr $I10, rxscan1784_loop
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  rxscan1784_done:
.annotate 'line', 867
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 868
    rx1783_cur."!cursor_pos"(rx1783_pos)
    new $P106, "Float"
    assign $P106, 0
    store_lex "$*RETURN_USED", $P106
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 869
    rx1783_cur."!cursor_pos"(rx1783_pos)
    new $P108, "Float"
    assign $P108, 1
    store_lex "$*INVOCANT_OK", $P108
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 870
  # rx subcapture "private"
    set_addr $I10, rxcap_1786_fail
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  # rx rxquantr1785 ** 0..1
    set_addr $I10, rxquantr1785_done
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  rxquantr1785_loop:
  # rx literal  "!"
    add $I11, rx1783_pos, 1
    gt $I11, rx1783_eos, rx1783_fail
    sub $I11, rx1783_pos, rx1783_off
    ord $I11, rx1783_tgt, $I11
    ne $I11, 33, rx1783_fail
    add rx1783_pos, 1
    set_addr $I10, rxquantr1785_done
    (rx1783_rep) = rx1783_cur."!mark_commit"($I10)
  rxquantr1785_done:
    set_addr $I10, rxcap_1786_fail
    ($I12, $I11) = rx1783_cur."!mark_peek"($I10)
    rx1783_cur."!cursor_pos"($I11)
    ($P10) = rx1783_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1783_pos, "")
    rx1783_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1786_done
  rxcap_1786_fail:
    goto rx1783_fail
  rxcap_1786_done:
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 871
  # rx rxquantr1787 ** 0..1
    set_addr $I10, rxquantr1787_done
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  rxquantr1787_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."deflongname"()
    unless $P10, rx1783_fail
    goto rxsubrule1788_pass
  rxsubrule1788_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1783_fail
  rxsubrule1788_pass:
    set_addr $I10, rxsubrule1788_back
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1783_pos = $P10."pos"()
    set_addr $I10, rxquantr1787_done
    (rx1783_rep) = rx1783_cur."!mark_commit"($I10)
  rxquantr1787_done:
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 872
  # rx subrule "newpad" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."newpad"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  alt1789_0:
.annotate 'line', 873
    set_addr $I10, alt1789_1
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1783_pos, 1
    gt $I11, rx1783_eos, rx1783_fail
    sub $I11, rx1783_pos, rx1783_off
    ord $I11, rx1783_tgt, $I11
    ne $I11, 40, rx1783_fail
    add rx1783_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."signature"()
    unless $P10, rx1783_fail
    rx1783_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1783_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1783_pos, 1
    gt $I11, rx1783_eos, rx1783_fail
    sub $I11, rx1783_pos, rx1783_off
    ord $I11, rx1783_tgt, $I11
    ne $I11, 41, rx1783_fail
    add rx1783_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
    goto alt1789_end
  alt1789_1:
.annotate 'line', 874
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  alt1789_end:
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 875
    rx1783_cur."!cursor_pos"(rx1783_pos)
    find_lex $P120, unicode:"$\x{a2}"
    $P121 = $P120."MATCH"()
    store_lex "$/", $P121
    .const 'Sub' $P1791 = "212_1312646121.678" 
    capture_lex $P1791
    $P123 = $P1791()
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 876
  # rx rxquantr1792 ** 0..*
    set_addr $I10, rxquantr1792_done
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
  rxquantr1792_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."trait"()
    unless $P10, rx1783_fail
    goto rxsubrule1793_pass
  rxsubrule1793_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1783_fail
  rxsubrule1793_pass:
    set_addr $I10, rxsubrule1793_back
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1783_pos = $P10."pos"()
    set_addr $I10, rxquantr1792_done
    (rx1783_rep) = rx1783_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1792_done
    rx1783_cur."!mark_push"(rx1783_rep, rx1783_pos, $I10)
    goto rxquantr1792_loop
  rxquantr1792_done:
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  alt1794_0:
.annotate 'line', 877
    set_addr $I10, alt1794_1
    rx1783_cur."!mark_push"(0, rx1783_pos, $I10)
.annotate 'line', 878
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."onlystar"()
    unless $P10, rx1783_fail
    rx1783_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1783_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
    goto alt1794_end
  alt1794_1:
.annotate 'line', 879
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."blockoid"()
    unless $P10, rx1783_fail
    rx1783_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1783_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
  alt1794_end:
.annotate 'line', 880
  # rx subrule "ws" subtype=method negate=
    rx1783_cur."!cursor_pos"(rx1783_pos)
    $P10 = rx1783_cur."ws"()
    unless $P10, rx1783_fail
    rx1783_pos = $P10."pos"()
.annotate 'line', 867
  # rx pass
    rx1783_cur."!cursor_pass"(rx1783_pos, "method_def")
    if_null rx1783_debug, debug_1283
    rx1783_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1783_pos)
  debug_1283:
    .return (rx1783_cur)
  rx1783_restart:
.annotate 'line', 440
    if_null rx1783_debug, debug_1284
    rx1783_cur."!cursor_debug"("NEXT", "method_def")
  debug_1284:
  rx1783_fail:
    (rx1783_rep, rx1783_pos, $I10, $P10) = rx1783_cur."!mark_fail"(0)
    lt rx1783_pos, -1, rx1783_done
    eq rx1783_pos, -1, rx1783_fail
    jump $I10
  rx1783_done:
    rx1783_cur."!cursor_fail"()
    if_null rx1783_debug, debug_1285
    rx1783_cur."!cursor_debug"("FAIL", "method_def")
  debug_1285:
    .return (rx1783_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1790"  :anon :subid("212_1312646121.678") :outer("211_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 875
    new $P122, "Float"
    assign $P122, 0
    store_dynamic_lex "$*INVOCANT_OK", $P122
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("213_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("214_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1800 = "215_1312646121.678" 
    capture_lex $P1800
    .local string rx1797_tgt
    .local int rx1797_pos
    .local int rx1797_off
    .local int rx1797_eos
    .local int rx1797_rep
    .local pmc rx1797_cur
    .local pmc rx1797_debug
    (rx1797_cur, rx1797_pos, rx1797_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1797_cur
    .local pmc match
    .lex "$/", match
    length rx1797_eos, rx1797_tgt
    gt rx1797_pos, rx1797_eos, rx1797_done
    set rx1797_off, 0
    lt rx1797_pos, 2, rx1797_start
    sub rx1797_off, rx1797_pos, 1
    substr rx1797_tgt, rx1797_tgt, rx1797_off
  rx1797_start:
    eq $I10, 1, rx1797_restart
    if_null rx1797_debug, debug_1286
    rx1797_cur."!cursor_debug"("START", "onlystar")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1798_done
    goto rxscan1798_scan
  rxscan1798_loop:
    (rx1797_pos) = rx1797_cur."from"()
    inc rx1797_pos
    rx1797_cur."!cursor_from"(rx1797_pos)
    ge rx1797_pos, rx1797_eos, rxscan1798_done
  rxscan1798_scan:
    set_addr $I10, rxscan1798_loop
    rx1797_cur."!mark_push"(0, rx1797_pos, $I10)
  rxscan1798_done:
.annotate 'line', 884
    rx1797_cur."!cursor_pos"(rx1797_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1800 = "215_1312646121.678" 
    capture_lex $P1800
    $P105 = $P1800()
    unless $P105, rx1797_fail
.annotate 'line', 885
  # rx literal  "{"
    add $I11, rx1797_pos, 1
    gt $I11, rx1797_eos, rx1797_fail
    sub $I11, rx1797_pos, rx1797_off
    ord $I11, rx1797_tgt, $I11
    ne $I11, 123, rx1797_fail
    add rx1797_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1797_cur."!cursor_pos"(rx1797_pos)
    $P10 = rx1797_cur."ws"()
    unless $P10, rx1797_fail
    rx1797_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1797_pos, 1
    gt $I11, rx1797_eos, rx1797_fail
    sub $I11, rx1797_pos, rx1797_off
    ord $I11, rx1797_tgt, $I11
    ne $I11, 42, rx1797_fail
    add rx1797_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1797_cur."!cursor_pos"(rx1797_pos)
    $P10 = rx1797_cur."ws"()
    unless $P10, rx1797_fail
    rx1797_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1797_pos, 1
    gt $I11, rx1797_eos, rx1797_fail
    sub $I11, rx1797_pos, rx1797_off
    ord $I11, rx1797_tgt, $I11
    ne $I11, 125, rx1797_fail
    add rx1797_pos, 1
.annotate 'line', 886
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1797_cur."!cursor_pos"(rx1797_pos)
    $P10 = rx1797_cur."ENDSTMT"()
    unless $P10, rx1797_fail
.annotate 'line', 887
  # rx subrule "finishpad" subtype=method negate=
    rx1797_cur."!cursor_pos"(rx1797_pos)
    $P10 = rx1797_cur."finishpad"()
    unless $P10, rx1797_fail
    rx1797_pos = $P10."pos"()
.annotate 'line', 883
  # rx pass
    rx1797_cur."!cursor_pass"(rx1797_pos, "onlystar")
    if_null rx1797_debug, debug_1289
    rx1797_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1797_pos)
  debug_1289:
    .return (rx1797_cur)
  rx1797_restart:
.annotate 'line', 440
    if_null rx1797_debug, debug_1290
    rx1797_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1290:
  rx1797_fail:
    (rx1797_rep, rx1797_pos, $I10, $P10) = rx1797_cur."!mark_fail"(0)
    lt rx1797_pos, -1, rx1797_done
    eq rx1797_pos, -1, rx1797_fail
    jump $I10
  rx1797_done:
    rx1797_cur."!cursor_fail"()
    if_null rx1797_debug, debug_1291
    rx1797_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1291:
    .return (rx1797_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1799"  :anon :subid("215_1312646121.678") :outer("214_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 884
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1287
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1288
    die "Contextual $*MULTINESS not found"
  vivify_1288:
  vivify_1287:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("216_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("217_1312646121.678")
    .param pmc param_1803
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 890
    .lex "self", param_1803
    $P103 = param_1803."!protoregex"("multi_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("218_1312646121.678")
    .param pmc param_1805
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 890
    .lex "self", param_1805
    $P104 = param_1805."!PREFIX__!protoregex"("multi_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("219_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 892
    new $P103, "Undef"
    set $P1807, $P103
    .lex "$*MULTINESS", $P1807
.annotate 'line', 440
    .local string rx1808_tgt
    .local int rx1808_pos
    .local int rx1808_off
    .local int rx1808_eos
    .local int rx1808_rep
    .local pmc rx1808_cur
    .local pmc rx1808_debug
    (rx1808_cur, rx1808_pos, rx1808_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1808_cur
    .local pmc match
    .lex "$/", match
    length rx1808_eos, rx1808_tgt
    gt rx1808_pos, rx1808_eos, rx1808_done
    set rx1808_off, 0
    lt rx1808_pos, 2, rx1808_start
    sub rx1808_off, rx1808_pos, 1
    substr rx1808_tgt, rx1808_tgt, rx1808_off
  rx1808_start:
    eq $I10, 1, rx1808_restart
    if_null rx1808_debug, debug_1292
    rx1808_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1292:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1809_done
    goto rxscan1809_scan
  rxscan1809_loop:
    (rx1808_pos) = rx1808_cur."from"()
    inc rx1808_pos
    rx1808_cur."!cursor_from"(rx1808_pos)
    ge rx1808_pos, rx1808_eos, rxscan1809_done
  rxscan1809_scan:
    set_addr $I10, rxscan1809_loop
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  rxscan1809_done:
.annotate 'line', 892
    rx1808_cur."!cursor_pos"(rx1808_pos)
    new $P104, "String"
    assign $P104, "multi"
    store_lex "$*MULTINESS", $P104
.annotate 'line', 893
  # rx subcapture "sym"
    set_addr $I10, rxcap_1810_fail
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1808_pos, 5
    gt $I11, rx1808_eos, rx1808_fail
    sub $I11, rx1808_pos, rx1808_off
    substr $S10, rx1808_tgt, $I11, 5
    ne $S10, "multi", rx1808_fail
    add rx1808_pos, 5
    set_addr $I10, rxcap_1810_fail
    ($I12, $I11) = rx1808_cur."!mark_peek"($I10)
    rx1808_cur."!cursor_pos"($I11)
    ($P10) = rx1808_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1808_pos, "")
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1810_done
  rxcap_1810_fail:
    goto rx1808_fail
  rxcap_1810_done:
.annotate 'line', 894
  # rx subrule "ws" subtype=method negate=
    rx1808_cur."!cursor_pos"(rx1808_pos)
    $P10 = rx1808_cur."ws"()
    unless $P10, rx1808_fail
    rx1808_pos = $P10."pos"()
  alt1811_0:
    set_addr $I10, alt1811_1
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1808_cur."!cursor_pos"(rx1808_pos)
    $P10 = rx1808_cur."declarator"()
    unless $P10, rx1808_fail
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1808_pos = $P10."pos"()
    goto alt1811_end
  alt1811_1:
    set_addr $I10, alt1811_2
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1808_cur."!cursor_pos"(rx1808_pos)
    $P10 = rx1808_cur."routine_def"()
    unless $P10, rx1808_fail
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1808_pos = $P10."pos"()
    goto alt1811_end
  alt1811_2:
  # rx subrule "panic" subtype=method negate=
    rx1808_cur."!cursor_pos"(rx1808_pos)
    $P10 = rx1808_cur."panic"("Malformed multi")
    unless $P10, rx1808_fail
    rx1808_pos = $P10."pos"()
  alt1811_end:
.annotate 'line', 891
  # rx pass
    rx1808_cur."!cursor_pass"(rx1808_pos, "multi_declarator:sym<multi>")
    if_null rx1808_debug, debug_1293
    rx1808_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1808_pos)
  debug_1293:
    .return (rx1808_cur)
  rx1808_restart:
.annotate 'line', 440
    if_null rx1808_debug, debug_1294
    rx1808_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1294:
  rx1808_fail:
    (rx1808_rep, rx1808_pos, $I10, $P10) = rx1808_cur."!mark_fail"(0)
    lt rx1808_pos, -1, rx1808_done
    eq rx1808_pos, -1, rx1808_fail
    jump $I10
  rx1808_done:
    rx1808_cur."!cursor_fail"()
    if_null rx1808_debug, debug_1295
    rx1808_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1295:
    .return (rx1808_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("220_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "multi")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("221_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 897
    new $P103, "Undef"
    set $P1814, $P103
    .lex "$*MULTINESS", $P1814
.annotate 'line', 440
    .local string rx1815_tgt
    .local int rx1815_pos
    .local int rx1815_off
    .local int rx1815_eos
    .local int rx1815_rep
    .local pmc rx1815_cur
    .local pmc rx1815_debug
    (rx1815_cur, rx1815_pos, rx1815_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1815_cur
    .local pmc match
    .lex "$/", match
    length rx1815_eos, rx1815_tgt
    gt rx1815_pos, rx1815_eos, rx1815_done
    set rx1815_off, 0
    lt rx1815_pos, 2, rx1815_start
    sub rx1815_off, rx1815_pos, 1
    substr rx1815_tgt, rx1815_tgt, rx1815_off
  rx1815_start:
    eq $I10, 1, rx1815_restart
    if_null rx1815_debug, debug_1296
    rx1815_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1296:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1816_done
    goto rxscan1816_scan
  rxscan1816_loop:
    (rx1815_pos) = rx1815_cur."from"()
    inc rx1815_pos
    rx1815_cur."!cursor_from"(rx1815_pos)
    ge rx1815_pos, rx1815_eos, rxscan1816_done
  rxscan1816_scan:
    set_addr $I10, rxscan1816_loop
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  rxscan1816_done:
.annotate 'line', 897
    rx1815_cur."!cursor_pos"(rx1815_pos)
    new $P104, "String"
    assign $P104, "proto"
    store_lex "$*MULTINESS", $P104
.annotate 'line', 898
  # rx subcapture "sym"
    set_addr $I10, rxcap_1817_fail
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1815_pos, 5
    gt $I11, rx1815_eos, rx1815_fail
    sub $I11, rx1815_pos, rx1815_off
    substr $S10, rx1815_tgt, $I11, 5
    ne $S10, "proto", rx1815_fail
    add rx1815_pos, 5
    set_addr $I10, rxcap_1817_fail
    ($I12, $I11) = rx1815_cur."!mark_peek"($I10)
    rx1815_cur."!cursor_pos"($I11)
    ($P10) = rx1815_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1815_pos, "")
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1817_done
  rxcap_1817_fail:
    goto rx1815_fail
  rxcap_1817_done:
.annotate 'line', 899
  # rx subrule "ws" subtype=method negate=
    rx1815_cur."!cursor_pos"(rx1815_pos)
    $P10 = rx1815_cur."ws"()
    unless $P10, rx1815_fail
    rx1815_pos = $P10."pos"()
  alt1818_0:
    set_addr $I10, alt1818_1
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1815_cur."!cursor_pos"(rx1815_pos)
    $P10 = rx1815_cur."declarator"()
    unless $P10, rx1815_fail
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1815_pos = $P10."pos"()
    goto alt1818_end
  alt1818_1:
    set_addr $I10, alt1818_2
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1815_cur."!cursor_pos"(rx1815_pos)
    $P10 = rx1815_cur."routine_def"()
    unless $P10, rx1815_fail
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1815_pos = $P10."pos"()
    goto alt1818_end
  alt1818_2:
  # rx subrule "panic" subtype=method negate=
    rx1815_cur."!cursor_pos"(rx1815_pos)
    $P10 = rx1815_cur."panic"("Malformed proto")
    unless $P10, rx1815_fail
    rx1815_pos = $P10."pos"()
  alt1818_end:
.annotate 'line', 896
  # rx pass
    rx1815_cur."!cursor_pass"(rx1815_pos, "multi_declarator:sym<proto>")
    if_null rx1815_debug, debug_1297
    rx1815_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1815_pos)
  debug_1297:
    .return (rx1815_cur)
  rx1815_restart:
.annotate 'line', 440
    if_null rx1815_debug, debug_1298
    rx1815_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1298:
  rx1815_fail:
    (rx1815_rep, rx1815_pos, $I10, $P10) = rx1815_cur."!mark_fail"(0)
    lt rx1815_pos, -1, rx1815_done
    eq rx1815_pos, -1, rx1815_fail
    jump $I10
  rx1815_done:
    rx1815_cur."!cursor_fail"()
    if_null rx1815_debug, debug_1299
    rx1815_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1299:
    .return (rx1815_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("222_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "proto")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("223_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 902
    new $P103, "Undef"
    set $P1821, $P103
    .lex "$*MULTINESS", $P1821
.annotate 'line', 440
    .local string rx1822_tgt
    .local int rx1822_pos
    .local int rx1822_off
    .local int rx1822_eos
    .local int rx1822_rep
    .local pmc rx1822_cur
    .local pmc rx1822_debug
    (rx1822_cur, rx1822_pos, rx1822_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1822_cur
    .local pmc match
    .lex "$/", match
    length rx1822_eos, rx1822_tgt
    gt rx1822_pos, rx1822_eos, rx1822_done
    set rx1822_off, 0
    lt rx1822_pos, 2, rx1822_start
    sub rx1822_off, rx1822_pos, 1
    substr rx1822_tgt, rx1822_tgt, rx1822_off
  rx1822_start:
    eq $I10, 1, rx1822_restart
    if_null rx1822_debug, debug_1300
    rx1822_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1300:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1823_done
    goto rxscan1823_scan
  rxscan1823_loop:
    (rx1822_pos) = rx1822_cur."from"()
    inc rx1822_pos
    rx1822_cur."!cursor_from"(rx1822_pos)
    ge rx1822_pos, rx1822_eos, rxscan1823_done
  rxscan1823_scan:
    set_addr $I10, rxscan1823_loop
    rx1822_cur."!mark_push"(0, rx1822_pos, $I10)
  rxscan1823_done:
.annotate 'line', 902
    rx1822_cur."!cursor_pos"(rx1822_pos)
    new $P104, "String"
    assign $P104, ""
    store_lex "$*MULTINESS", $P104
.annotate 'line', 903
  # rx subrule "declarator" subtype=capture negate=
    rx1822_cur."!cursor_pos"(rx1822_pos)
    $P10 = rx1822_cur."declarator"()
    unless $P10, rx1822_fail
    rx1822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1822_pos = $P10."pos"()
.annotate 'line', 901
  # rx pass
    rx1822_cur."!cursor_pass"(rx1822_pos, "multi_declarator:sym<null>")
    if_null rx1822_debug, debug_1301
    rx1822_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1822_pos)
  debug_1301:
    .return (rx1822_cur)
  rx1822_restart:
.annotate 'line', 440
    if_null rx1822_debug, debug_1302
    rx1822_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1302:
  rx1822_fail:
    (rx1822_rep, rx1822_pos, $I10, $P10) = rx1822_cur."!mark_fail"(0)
    lt rx1822_pos, -1, rx1822_done
    eq rx1822_pos, -1, rx1822_fail
    jump $I10
  rx1822_done:
    rx1822_cur."!cursor_fail"()
    if_null rx1822_debug, debug_1303
    rx1822_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1303:
    .return (rx1822_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("224_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("declarator", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("225_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1830 = "226_1312646121.678" 
    capture_lex $P1830
    .local string rx1826_tgt
    .local int rx1826_pos
    .local int rx1826_off
    .local int rx1826_eos
    .local int rx1826_rep
    .local pmc rx1826_cur
    .local pmc rx1826_debug
    (rx1826_cur, rx1826_pos, rx1826_tgt, $I10) = self."!cursor_start"()
    rx1826_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1826_cur
    .local pmc match
    .lex "$/", match
    length rx1826_eos, rx1826_tgt
    gt rx1826_pos, rx1826_eos, rx1826_done
    set rx1826_off, 0
    lt rx1826_pos, 2, rx1826_start
    sub rx1826_off, rx1826_pos, 1
    substr rx1826_tgt, rx1826_tgt, rx1826_off
  rx1826_start:
    eq $I10, 1, rx1826_restart
    if_null rx1826_debug, debug_1304
    rx1826_cur."!cursor_debug"("START", "signature")
  debug_1304:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1827_done
    goto rxscan1827_scan
  rxscan1827_loop:
    (rx1826_pos) = rx1826_cur."from"()
    inc rx1826_pos
    rx1826_cur."!cursor_from"(rx1826_pos)
    ge rx1826_pos, rx1826_eos, rxscan1827_done
  rxscan1827_scan:
    set_addr $I10, rxscan1827_loop
    rx1826_cur."!mark_push"(0, rx1826_pos, $I10)
  rxscan1827_done:
.annotate 'line', 907
  # rx rxquantr1828 ** 0..1
    set_addr $I10, rxquantr1828_done
    rx1826_cur."!mark_push"(0, rx1826_pos, $I10)
  rxquantr1828_loop:
    rx1826_cur."!cursor_pos"(rx1826_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1830 = "226_1312646121.678" 
    capture_lex $P1830
    $P105 = $P1830()
    unless $P105, rx1826_fail
  # rx subrule "ws" subtype=method negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."ws"()
    unless $P10, rx1826_fail
    rx1826_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."parameter"()
    unless $P10, rx1826_fail
    rx1826_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1826_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."ws"()
    unless $P10, rx1826_fail
    rx1826_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1826_pos, 1
    gt $I11, rx1826_eos, rx1826_fail
    sub $I11, rx1826_pos, rx1826_off
    ord $I11, rx1826_tgt, $I11
    ne $I11, 58, rx1826_fail
    add rx1826_pos, 1
    set_addr $I10, rxquantr1828_done
    (rx1826_rep) = rx1826_cur."!mark_commit"($I10)
  rxquantr1828_done:
.annotate 'line', 908
  # rx rxquantr1831 ** 0..1
    set_addr $I10, rxquantr1831_done
    rx1826_cur."!mark_push"(0, rx1826_pos, $I10)
  rxquantr1831_loop:
  # rx rxquantr1832 ** 1..*
    set_addr $I10, rxquantr1832_done
    rx1826_cur."!mark_push"(0, -1, $I10)
  rxquantr1832_loop:
  # rx subrule "ws" subtype=method negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."ws"()
    unless $P10, rx1826_fail
    rx1826_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."parameter"()
    unless $P10, rx1826_fail
    rx1826_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1826_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."ws"()
    unless $P10, rx1826_fail
    rx1826_pos = $P10."pos"()
    set_addr $I10, rxquantr1832_done
    (rx1826_rep) = rx1826_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1832_done
    rx1826_cur."!mark_push"(rx1826_rep, rx1826_pos, $I10)
  # rx literal  ","
    add $I11, rx1826_pos, 1
    gt $I11, rx1826_eos, rx1826_fail
    sub $I11, rx1826_pos, rx1826_off
    ord $I11, rx1826_tgt, $I11
    ne $I11, 44, rx1826_fail
    add rx1826_pos, 1
    goto rxquantr1832_loop
  rxquantr1832_done:
    set_addr $I10, rxquantr1831_done
    (rx1826_rep) = rx1826_cur."!mark_commit"($I10)
  rxquantr1831_done:
.annotate 'line', 906
  # rx pass
    rx1826_cur."!cursor_pass"(rx1826_pos, "signature")
    if_null rx1826_debug, debug_1307
    rx1826_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1826_pos)
  debug_1307:
    .return (rx1826_cur)
  rx1826_restart:
.annotate 'line', 440
    if_null rx1826_debug, debug_1308
    rx1826_cur."!cursor_debug"("NEXT", "signature")
  debug_1308:
  rx1826_fail:
    (rx1826_rep, rx1826_pos, $I10, $P10) = rx1826_cur."!mark_fail"(0)
    lt rx1826_pos, -1, rx1826_done
    eq rx1826_pos, -1, rx1826_fail
    jump $I10
  rx1826_done:
    rx1826_cur."!cursor_fail"()
    if_null rx1826_debug, debug_1309
    rx1826_cur."!cursor_debug"("FAIL", "signature")
  debug_1309:
    .return (rx1826_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1829"  :anon :subid("226_1312646121.678") :outer("225_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 907
    find_dynamic_lex $P107, "$*INVOCANT_OK"
    unless_null $P107, vivify_1305
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$INVOCANT_OK"]
    unless_null $P107, vivify_1306
    die "Contextual $*INVOCANT_OK not found"
  vivify_1306:
  vivify_1305:
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("227_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("228_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1835_tgt
    .local int rx1835_pos
    .local int rx1835_off
    .local int rx1835_eos
    .local int rx1835_rep
    .local pmc rx1835_cur
    .local pmc rx1835_debug
    (rx1835_cur, rx1835_pos, rx1835_tgt, $I10) = self."!cursor_start"()
    rx1835_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1835_cur
    .local pmc match
    .lex "$/", match
    length rx1835_eos, rx1835_tgt
    gt rx1835_pos, rx1835_eos, rx1835_done
    set rx1835_off, 0
    lt rx1835_pos, 2, rx1835_start
    sub rx1835_off, rx1835_pos, 1
    substr rx1835_tgt, rx1835_tgt, rx1835_off
  rx1835_start:
    eq $I10, 1, rx1835_restart
    if_null rx1835_debug, debug_1310
    rx1835_cur."!cursor_debug"("START", "parameter")
  debug_1310:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1836_done
    goto rxscan1836_scan
  rxscan1836_loop:
    (rx1835_pos) = rx1835_cur."from"()
    inc rx1835_pos
    rx1835_cur."!cursor_from"(rx1835_pos)
    ge rx1835_pos, rx1835_eos, rxscan1836_done
  rxscan1836_scan:
    set_addr $I10, rxscan1836_loop
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxscan1836_done:
.annotate 'line', 912
  # rx rxquantr1837 ** 0..*
    set_addr $I10, rxquantr1837_done
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxquantr1837_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."typename"()
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1835_pos = $P10."pos"()
  # rx rxquantr1838 ** 0..1
    set_addr $I10, rxquantr1838_done
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxquantr1838_loop:
  # rx literal  ":"
    add $I11, rx1835_pos, 1
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    ord $I11, rx1835_tgt, $I11
    ne $I11, 58, rx1835_fail
    add rx1835_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1839_fail
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1835_pos, rx1835_eos, rx1835_fail
    sub $I10, rx1835_pos, rx1835_off
    substr $S10, rx1835_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1835_fail
    inc rx1835_pos
    set_addr $I10, rxcap_1839_fail
    ($I12, $I11) = rx1835_cur."!mark_peek"($I10)
    rx1835_cur."!cursor_pos"($I11)
    ($P10) = rx1835_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1835_pos, "")
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1839_done
  rxcap_1839_fail:
    goto rx1835_fail
  rxcap_1839_done:
    set_addr $I10, rxquantr1838_done
    (rx1835_rep) = rx1835_cur."!mark_commit"($I10)
  rxquantr1838_done:
  # rx subrule "ws" subtype=method negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."ws"()
    unless $P10, rx1835_fail
    rx1835_pos = $P10."pos"()
    set_addr $I10, rxquantr1837_done
    (rx1835_rep) = rx1835_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1837_done
    rx1835_cur."!mark_push"(rx1835_rep, rx1835_pos, $I10)
    goto rxquantr1837_loop
  rxquantr1837_done:
  alt1840_0:
.annotate 'line', 913
    set_addr $I10, alt1840_1
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
.annotate 'line', 914
  # rx subcapture "quant"
    set_addr $I10, rxcap_1841_fail
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx literal  "*"
    add $I11, rx1835_pos, 1
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    ord $I11, rx1835_tgt, $I11
    ne $I11, 42, rx1835_fail
    add rx1835_pos, 1
    set_addr $I10, rxcap_1841_fail
    ($I12, $I11) = rx1835_cur."!mark_peek"($I10)
    rx1835_cur."!cursor_pos"($I11)
    ($P10) = rx1835_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1835_pos, "")
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1841_done
  rxcap_1841_fail:
    goto rx1835_fail
  rxcap_1841_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."param_var"()
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1835_pos = $P10."pos"()
    goto alt1840_end
  alt1840_1:
  alt1842_0:
.annotate 'line', 915
    set_addr $I10, alt1842_1
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."param_var"()
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1835_pos = $P10."pos"()
    goto alt1842_end
  alt1842_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."named_param"()
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1835_pos = $P10."pos"()
  alt1842_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1844_fail
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  alt1843_0:
    set_addr $I10, alt1843_1
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx literal  "?"
    add $I11, rx1835_pos, 1
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    ord $I11, rx1835_tgt, $I11
    ne $I11, 63, rx1835_fail
    add rx1835_pos, 1
    goto alt1843_end
  alt1843_1:
    set_addr $I10, alt1843_2
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx literal  "!"
    add $I11, rx1835_pos, 1
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    ord $I11, rx1835_tgt, $I11
    ne $I11, 33, rx1835_fail
    add rx1835_pos, 1
    goto alt1843_end
  alt1843_2:
  alt1843_end:
    set_addr $I10, rxcap_1844_fail
    ($I12, $I11) = rx1835_cur."!mark_peek"($I10)
    rx1835_cur."!cursor_pos"($I11)
    ($P10) = rx1835_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1835_pos, "")
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1844_done
  rxcap_1844_fail:
    goto rx1835_fail
  rxcap_1844_done:
  alt1840_end:
.annotate 'line', 917
  # rx rxquantr1845 ** 0..1
    set_addr $I10, rxquantr1845_done
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxquantr1845_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."default_value"()
    unless $P10, rx1835_fail
    goto rxsubrule1846_pass
  rxsubrule1846_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1835_fail
  rxsubrule1846_pass:
    set_addr $I10, rxsubrule1846_back
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1835_pos = $P10."pos"()
    set_addr $I10, rxquantr1845_done
    (rx1835_rep) = rx1835_cur."!mark_commit"($I10)
  rxquantr1845_done:
.annotate 'line', 911
  # rx pass
    rx1835_cur."!cursor_pass"(rx1835_pos, "parameter")
    if_null rx1835_debug, debug_1311
    rx1835_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1835_pos)
  debug_1311:
    .return (rx1835_cur)
  rx1835_restart:
.annotate 'line', 440
    if_null rx1835_debug, debug_1312
    rx1835_cur."!cursor_debug"("NEXT", "parameter")
  debug_1312:
  rx1835_fail:
    (rx1835_rep, rx1835_pos, $I10, $P10) = rx1835_cur."!mark_fail"(0)
    lt rx1835_pos, -1, rx1835_done
    eq rx1835_pos, -1, rx1835_fail
    jump $I10
  rx1835_done:
    rx1835_cur."!cursor_fail"()
    if_null rx1835_debug, debug_1313
    rx1835_cur."!cursor_debug"("FAIL", "parameter")
  debug_1313:
    .return (rx1835_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("229_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("230_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1849_tgt
    .local int rx1849_pos
    .local int rx1849_off
    .local int rx1849_eos
    .local int rx1849_rep
    .local pmc rx1849_cur
    .local pmc rx1849_debug
    (rx1849_cur, rx1849_pos, rx1849_tgt, $I10) = self."!cursor_start"()
    rx1849_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1849_cur
    .local pmc match
    .lex "$/", match
    length rx1849_eos, rx1849_tgt
    gt rx1849_pos, rx1849_eos, rx1849_done
    set rx1849_off, 0
    lt rx1849_pos, 2, rx1849_start
    sub rx1849_off, rx1849_pos, 1
    substr rx1849_tgt, rx1849_tgt, rx1849_off
  rx1849_start:
    eq $I10, 1, rx1849_restart
    if_null rx1849_debug, debug_1314
    rx1849_cur."!cursor_debug"("START", "param_var")
  debug_1314:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1850_done
    goto rxscan1850_scan
  rxscan1850_loop:
    (rx1849_pos) = rx1849_cur."from"()
    inc rx1849_pos
    rx1849_cur."!cursor_from"(rx1849_pos)
    ge rx1849_pos, rx1849_eos, rxscan1850_done
  rxscan1850_scan:
    set_addr $I10, rxscan1850_loop
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  rxscan1850_done:
.annotate 'line', 921
  # rx subrule "sigil" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."sigil"()
    unless $P10, rx1849_fail
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1849_pos = $P10."pos"()
  # rx rxquantr1851 ** 0..1
    set_addr $I10, rxquantr1851_done
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  rxquantr1851_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."twigil"()
    unless $P10, rx1849_fail
    goto rxsubrule1852_pass
  rxsubrule1852_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1849_fail
  rxsubrule1852_pass:
    set_addr $I10, rxsubrule1852_back
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1849_pos = $P10."pos"()
    set_addr $I10, rxquantr1851_done
    (rx1849_rep) = rx1849_cur."!mark_commit"($I10)
  rxquantr1851_done:
  alt1853_0:
.annotate 'line', 922
    set_addr $I10, alt1853_1
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."ident"()
    unless $P10, rx1849_fail
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1849_pos = $P10."pos"()
    goto alt1853_end
  alt1853_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1854_fail
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1849_pos, rx1849_eos, rx1849_fail
    sub $I10, rx1849_pos, rx1849_off
    substr $S10, rx1849_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1849_fail
    inc rx1849_pos
    set_addr $I10, rxcap_1854_fail
    ($I12, $I11) = rx1849_cur."!mark_peek"($I10)
    rx1849_cur."!cursor_pos"($I11)
    ($P10) = rx1849_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1849_pos, "")
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1854_done
  rxcap_1854_fail:
    goto rx1849_fail
  rxcap_1854_done:
  alt1853_end:
.annotate 'line', 920
  # rx pass
    rx1849_cur."!cursor_pass"(rx1849_pos, "param_var")
    if_null rx1849_debug, debug_1315
    rx1849_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1849_pos)
  debug_1315:
    .return (rx1849_cur)
  rx1849_restart:
.annotate 'line', 440
    if_null rx1849_debug, debug_1316
    rx1849_cur."!cursor_debug"("NEXT", "param_var")
  debug_1316:
  rx1849_fail:
    (rx1849_rep, rx1849_pos, $I10, $P10) = rx1849_cur."!mark_fail"(0)
    lt rx1849_pos, -1, rx1849_done
    eq rx1849_pos, -1, rx1849_fail
    jump $I10
  rx1849_done:
    rx1849_cur."!cursor_fail"()
    if_null rx1849_debug, debug_1317
    rx1849_cur."!cursor_debug"("FAIL", "param_var")
  debug_1317:
    .return (rx1849_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("231_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("232_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1857_tgt
    .local int rx1857_pos
    .local int rx1857_off
    .local int rx1857_eos
    .local int rx1857_rep
    .local pmc rx1857_cur
    .local pmc rx1857_debug
    (rx1857_cur, rx1857_pos, rx1857_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1857_cur
    .local pmc match
    .lex "$/", match
    length rx1857_eos, rx1857_tgt
    gt rx1857_pos, rx1857_eos, rx1857_done
    set rx1857_off, 0
    lt rx1857_pos, 2, rx1857_start
    sub rx1857_off, rx1857_pos, 1
    substr rx1857_tgt, rx1857_tgt, rx1857_off
  rx1857_start:
    eq $I10, 1, rx1857_restart
    if_null rx1857_debug, debug_1318
    rx1857_cur."!cursor_debug"("START", "named_param")
  debug_1318:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1858_done
    goto rxscan1858_scan
  rxscan1858_loop:
    (rx1857_pos) = rx1857_cur."from"()
    inc rx1857_pos
    rx1857_cur."!cursor_from"(rx1857_pos)
    ge rx1857_pos, rx1857_eos, rxscan1858_done
  rxscan1858_scan:
    set_addr $I10, rxscan1858_loop
    rx1857_cur."!mark_push"(0, rx1857_pos, $I10)
  rxscan1858_done:
.annotate 'line', 926
  # rx literal  ":"
    add $I11, rx1857_pos, 1
    gt $I11, rx1857_eos, rx1857_fail
    sub $I11, rx1857_pos, rx1857_off
    ord $I11, rx1857_tgt, $I11
    ne $I11, 58, rx1857_fail
    add rx1857_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1857_cur."!cursor_pos"(rx1857_pos)
    $P10 = rx1857_cur."param_var"()
    unless $P10, rx1857_fail
    rx1857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1857_pos = $P10."pos"()
.annotate 'line', 925
  # rx pass
    rx1857_cur."!cursor_pass"(rx1857_pos, "named_param")
    if_null rx1857_debug, debug_1319
    rx1857_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1857_pos)
  debug_1319:
    .return (rx1857_cur)
  rx1857_restart:
.annotate 'line', 440
    if_null rx1857_debug, debug_1320
    rx1857_cur."!cursor_debug"("NEXT", "named_param")
  debug_1320:
  rx1857_fail:
    (rx1857_rep, rx1857_pos, $I10, $P10) = rx1857_cur."!mark_fail"(0)
    lt rx1857_pos, -1, rx1857_done
    eq rx1857_pos, -1, rx1857_fail
    jump $I10
  rx1857_done:
    rx1857_cur."!cursor_fail"()
    if_null rx1857_debug, debug_1321
    rx1857_cur."!cursor_debug"("FAIL", "named_param")
  debug_1321:
    .return (rx1857_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("233_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("param_var", ":")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("234_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1861_tgt
    .local int rx1861_pos
    .local int rx1861_off
    .local int rx1861_eos
    .local int rx1861_rep
    .local pmc rx1861_cur
    .local pmc rx1861_debug
    (rx1861_cur, rx1861_pos, rx1861_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1861_cur
    .local pmc match
    .lex "$/", match
    length rx1861_eos, rx1861_tgt
    gt rx1861_pos, rx1861_eos, rx1861_done
    set rx1861_off, 0
    lt rx1861_pos, 2, rx1861_start
    sub rx1861_off, rx1861_pos, 1
    substr rx1861_tgt, rx1861_tgt, rx1861_off
  rx1861_start:
    eq $I10, 1, rx1861_restart
    if_null rx1861_debug, debug_1322
    rx1861_cur."!cursor_debug"("START", "default_value")
  debug_1322:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1862_done
    goto rxscan1862_scan
  rxscan1862_loop:
    (rx1861_pos) = rx1861_cur."from"()
    inc rx1861_pos
    rx1861_cur."!cursor_from"(rx1861_pos)
    ge rx1861_pos, rx1861_eos, rxscan1862_done
  rxscan1862_scan:
    set_addr $I10, rxscan1862_loop
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  rxscan1862_done:
.annotate 'line', 929
  # rx subrule "ws" subtype=method negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."ws"()
    unless $P10, rx1861_fail
    rx1861_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1861_pos, 1
    gt $I11, rx1861_eos, rx1861_fail
    sub $I11, rx1861_pos, rx1861_off
    ord $I11, rx1861_tgt, $I11
    ne $I11, 61, rx1861_fail
    add rx1861_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."ws"()
    unless $P10, rx1861_fail
    rx1861_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."EXPR"("i=")
    unless $P10, rx1861_fail
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1861_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."ws"()
    unless $P10, rx1861_fail
    rx1861_pos = $P10."pos"()
  # rx pass
    rx1861_cur."!cursor_pass"(rx1861_pos, "default_value")
    if_null rx1861_debug, debug_1323
    rx1861_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1861_pos)
  debug_1323:
    .return (rx1861_cur)
  rx1861_restart:
.annotate 'line', 440
    if_null rx1861_debug, debug_1324
    rx1861_cur."!cursor_debug"("NEXT", "default_value")
  debug_1324:
  rx1861_fail:
    (rx1861_rep, rx1861_pos, $I10, $P10) = rx1861_cur."!mark_fail"(0)
    lt rx1861_pos, -1, rx1861_done
    eq rx1861_pos, -1, rx1861_fail
    jump $I10
  rx1861_done:
    rx1861_cur."!cursor_fail"()
    if_null rx1861_debug, debug_1325
    rx1861_cur."!cursor_debug"("FAIL", "default_value")
  debug_1325:
    .return (rx1861_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("235_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P106 = self."!PREFIX__!subrule"("ws", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("236_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1865_tgt
    .local int rx1865_pos
    .local int rx1865_off
    .local int rx1865_eos
    .local int rx1865_rep
    .local pmc rx1865_cur
    .local pmc rx1865_debug
    (rx1865_cur, rx1865_pos, rx1865_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1865_cur
    .local pmc match
    .lex "$/", match
    length rx1865_eos, rx1865_tgt
    gt rx1865_pos, rx1865_eos, rx1865_done
    set rx1865_off, 0
    lt rx1865_pos, 2, rx1865_start
    sub rx1865_off, rx1865_pos, 1
    substr rx1865_tgt, rx1865_tgt, rx1865_off
  rx1865_start:
    eq $I10, 1, rx1865_restart
    if_null rx1865_debug, debug_1326
    rx1865_cur."!cursor_debug"("START", "trait")
  debug_1326:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1866_done
    goto rxscan1866_scan
  rxscan1866_loop:
    (rx1865_pos) = rx1865_cur."from"()
    inc rx1865_pos
    rx1865_cur."!cursor_from"(rx1865_pos)
    ge rx1865_pos, rx1865_eos, rxscan1866_done
  rxscan1866_scan:
    set_addr $I10, rxscan1866_loop
    rx1865_cur."!mark_push"(0, rx1865_pos, $I10)
  rxscan1866_done:
.annotate 'line', 931
  # rx subrule "ws" subtype=method negate=
    rx1865_cur."!cursor_pos"(rx1865_pos)
    $P10 = rx1865_cur."ws"()
    unless $P10, rx1865_fail
    rx1865_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1865_cur."!cursor_pos"(rx1865_pos)
    $P10 = rx1865_cur."trait_mod"()
    unless $P10, rx1865_fail
    rx1865_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1865_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1865_cur."!cursor_pos"(rx1865_pos)
    $P10 = rx1865_cur."ws"()
    unless $P10, rx1865_fail
    rx1865_pos = $P10."pos"()
  # rx pass
    rx1865_cur."!cursor_pass"(rx1865_pos, "trait")
    if_null rx1865_debug, debug_1327
    rx1865_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1865_pos)
  debug_1327:
    .return (rx1865_cur)
  rx1865_restart:
.annotate 'line', 440
    if_null rx1865_debug, debug_1328
    rx1865_cur."!cursor_debug"("NEXT", "trait")
  debug_1328:
  rx1865_fail:
    (rx1865_rep, rx1865_pos, $I10, $P10) = rx1865_cur."!mark_fail"(0)
    lt rx1865_pos, -1, rx1865_done
    eq rx1865_pos, -1, rx1865_fail
    jump $I10
  rx1865_done:
    rx1865_cur."!cursor_fail"()
    if_null rx1865_debug, debug_1329
    rx1865_cur."!cursor_debug"("FAIL", "trait")
  debug_1329:
    .return (rx1865_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("237_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("238_1312646121.678")
    .param pmc param_1869
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 933
    .lex "self", param_1869
    $P103 = param_1869."!protoregex"("trait_mod")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("239_1312646121.678")
    .param pmc param_1871
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 933
    .lex "self", param_1871
    $P104 = param_1871."!PREFIX__!protoregex"("trait_mod")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("240_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1873_tgt
    .local int rx1873_pos
    .local int rx1873_off
    .local int rx1873_eos
    .local int rx1873_rep
    .local pmc rx1873_cur
    .local pmc rx1873_debug
    (rx1873_cur, rx1873_pos, rx1873_tgt, $I10) = self."!cursor_start"()
    rx1873_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1873_cur
    .local pmc match
    .lex "$/", match
    length rx1873_eos, rx1873_tgt
    gt rx1873_pos, rx1873_eos, rx1873_done
    set rx1873_off, 0
    lt rx1873_pos, 2, rx1873_start
    sub rx1873_off, rx1873_pos, 1
    substr rx1873_tgt, rx1873_tgt, rx1873_off
  rx1873_start:
    eq $I10, 1, rx1873_restart
    if_null rx1873_debug, debug_1330
    rx1873_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1330:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1874_done
    goto rxscan1874_scan
  rxscan1874_loop:
    (rx1873_pos) = rx1873_cur."from"()
    inc rx1873_pos
    rx1873_cur."!cursor_from"(rx1873_pos)
    ge rx1873_pos, rx1873_eos, rxscan1874_done
  rxscan1874_scan:
    set_addr $I10, rxscan1874_loop
    rx1873_cur."!mark_push"(0, rx1873_pos, $I10)
  rxscan1874_done:
.annotate 'line', 934
  # rx subcapture "sym"
    set_addr $I10, rxcap_1875_fail
    rx1873_cur."!mark_push"(0, rx1873_pos, $I10)
  # rx literal  "is"
    add $I11, rx1873_pos, 2
    gt $I11, rx1873_eos, rx1873_fail
    sub $I11, rx1873_pos, rx1873_off
    substr $S10, rx1873_tgt, $I11, 2
    ne $S10, "is", rx1873_fail
    add rx1873_pos, 2
    set_addr $I10, rxcap_1875_fail
    ($I12, $I11) = rx1873_cur."!mark_peek"($I10)
    rx1873_cur."!cursor_pos"($I11)
    ($P10) = rx1873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1873_pos, "")
    rx1873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1875_done
  rxcap_1875_fail:
    goto rx1873_fail
  rxcap_1875_done:
  # rx subrule "ws" subtype=method negate=
    rx1873_cur."!cursor_pos"(rx1873_pos)
    $P10 = rx1873_cur."ws"()
    unless $P10, rx1873_fail
    rx1873_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1873_cur."!cursor_pos"(rx1873_pos)
    $P10 = rx1873_cur."deflongname"()
    unless $P10, rx1873_fail
    rx1873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1873_pos = $P10."pos"()
  # rx rxquantr1876 ** 0..1
    set_addr $I10, rxquantr1876_done
    rx1873_cur."!mark_push"(0, rx1873_pos, $I10)
  rxquantr1876_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1873_cur."!cursor_pos"(rx1873_pos)
    $P10 = rx1873_cur."circumfix"()
    unless $P10, rx1873_fail
    goto rxsubrule1877_pass
  rxsubrule1877_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1873_fail
  rxsubrule1877_pass:
    set_addr $I10, rxsubrule1877_back
    rx1873_cur."!mark_push"(0, rx1873_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1873_pos = $P10."pos"()
    set_addr $I10, rxquantr1876_done
    (rx1873_rep) = rx1873_cur."!mark_commit"($I10)
  rxquantr1876_done:
  # rx subrule "ws" subtype=method negate=
    rx1873_cur."!cursor_pos"(rx1873_pos)
    $P10 = rx1873_cur."ws"()
    unless $P10, rx1873_fail
    rx1873_pos = $P10."pos"()
  # rx pass
    rx1873_cur."!cursor_pass"(rx1873_pos, "trait_mod:sym<is>")
    if_null rx1873_debug, debug_1331
    rx1873_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1873_pos)
  debug_1331:
    .return (rx1873_cur)
  rx1873_restart:
.annotate 'line', 440
    if_null rx1873_debug, debug_1332
    rx1873_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1332:
  rx1873_fail:
    (rx1873_rep, rx1873_pos, $I10, $P10) = rx1873_cur."!mark_fail"(0)
    lt rx1873_pos, -1, rx1873_done
    eq rx1873_pos, -1, rx1873_fail
    jump $I10
  rx1873_done:
    rx1873_cur."!cursor_fail"()
    if_null rx1873_debug, debug_1333
    rx1873_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1333:
    .return (rx1873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("241_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "is")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("242_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1880_tgt
    .local int rx1880_pos
    .local int rx1880_off
    .local int rx1880_eos
    .local int rx1880_rep
    .local pmc rx1880_cur
    .local pmc rx1880_debug
    (rx1880_cur, rx1880_pos, rx1880_tgt, $I10) = self."!cursor_start"()
    rx1880_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1880_cur
    .local pmc match
    .lex "$/", match
    length rx1880_eos, rx1880_tgt
    gt rx1880_pos, rx1880_eos, rx1880_done
    set rx1880_off, 0
    lt rx1880_pos, 2, rx1880_start
    sub rx1880_off, rx1880_pos, 1
    substr rx1880_tgt, rx1880_tgt, rx1880_off
  rx1880_start:
    eq $I10, 1, rx1880_restart
    if_null rx1880_debug, debug_1334
    rx1880_cur."!cursor_debug"("START", "regex_declarator")
  debug_1334:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1881_done
    goto rxscan1881_scan
  rxscan1881_loop:
    (rx1880_pos) = rx1880_cur."from"()
    inc rx1880_pos
    rx1880_cur."!cursor_from"(rx1880_pos)
    ge rx1880_pos, rx1880_eos, rxscan1881_done
  rxscan1881_scan:
    set_addr $I10, rxscan1881_loop
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  rxscan1881_done:
.annotate 'line', 936
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  alt1882_0:
.annotate 'line', 937
    set_addr $I10, alt1882_1
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
.annotate 'line', 938
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1883_fail
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1880_pos, 5
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 5
    ne $S10, "proto", rx1880_fail
    add rx1880_pos, 5
    set_addr $I10, rxcap_1883_fail
    ($I12, $I11) = rx1880_cur."!mark_peek"($I10)
    rx1880_cur."!cursor_pos"($I11)
    ($P10) = rx1880_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1880_pos, "")
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1883_done
  rxcap_1883_fail:
    goto rx1880_fail
  rxcap_1883_done:
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  alt1884_0:
    set_addr $I10, alt1884_1
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1880_pos, 5
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 5
    ne $S10, "regex", rx1880_fail
    add rx1880_pos, 5
    goto alt1884_end
  alt1884_1:
    set_addr $I10, alt1884_2
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  # rx literal  "token"
    add $I11, rx1880_pos, 5
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 5
    ne $S10, "token", rx1880_fail
    add rx1880_pos, 5
    goto alt1884_end
  alt1884_2:
  # rx literal  "rule"
    add $I11, rx1880_pos, 4
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 4
    ne $S10, "rule", rx1880_fail
    add rx1880_pos, 4
  alt1884_end:
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 939
  # rx subrule "deflongname" subtype=capture negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."deflongname"()
    unless $P10, rx1880_fail
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  alt1885_0:
.annotate 'line', 940
    set_addr $I10, alt1885_1
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
.annotate 'line', 941
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 123, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1880_pos, 5
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 5
    ne $S10, "<...>", rx1880_fail
    add rx1880_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 125, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ENDSTMT"()
    unless $P10, rx1880_fail
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
    goto alt1885_end
  alt1885_1:
    set_addr $I10, alt1885_2
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
.annotate 'line', 942
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 123, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1880_pos, 3
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 3
    ne $S10, "<*>", rx1880_fail
    add rx1880_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 125, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ENDSTMT"()
    unless $P10, rx1880_fail
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
    goto alt1885_end
  alt1885_2:
.annotate 'line', 943
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  alt1885_end:
.annotate 'line', 944
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 938
    goto alt1882_end
  alt1882_1:
.annotate 'line', 945
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1887_fail
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  alt1886_0:
    set_addr $I10, alt1886_1
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1880_pos, 5
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 5
    ne $S10, "regex", rx1880_fail
    add rx1880_pos, 5
    goto alt1886_end
  alt1886_1:
    set_addr $I10, alt1886_2
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  # rx literal  "token"
    add $I11, rx1880_pos, 5
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 5
    ne $S10, "token", rx1880_fail
    add rx1880_pos, 5
    goto alt1886_end
  alt1886_2:
  # rx literal  "rule"
    add $I11, rx1880_pos, 4
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    substr $S10, rx1880_tgt, $I11, 4
    ne $S10, "rule", rx1880_fail
    add rx1880_pos, 4
  alt1886_end:
    set_addr $I10, rxcap_1887_fail
    ($I12, $I11) = rx1880_cur."!mark_peek"($I10)
    rx1880_cur."!cursor_pos"($I11)
    ($P10) = rx1880_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1880_pos, "")
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1887_done
  rxcap_1887_fail:
    goto rx1880_fail
  rxcap_1887_done:
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 946
  # rx subrule "deflongname" subtype=capture negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."deflongname"()
    unless $P10, rx1880_fail
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 947
  # rx subrule "newpad" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."newpad"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 948
  # rx rxquantr1888 ** 0..1
    set_addr $I10, rxquantr1888_done
    rx1880_cur."!mark_push"(0, rx1880_pos, $I10)
  rxquantr1888_loop:
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 40, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."signature"()
    unless $P10, rx1880_fail
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1880_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 41, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
    set_addr $I10, rxquantr1888_done
    (rx1880_rep) = rx1880_cur."!mark_commit"($I10)
  rxquantr1888_done:
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 949
  # rx reduce name="regex_declarator" key="open"
    rx1880_cur."!cursor_pos"(rx1880_pos)
    rx1880_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 950
  # rx literal  "{"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 123, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1880_fail
    rx1880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1880_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1880_pos, 1
    gt $I11, rx1880_eos, rx1880_fail
    sub $I11, rx1880_pos, rx1880_off
    ord $I11, rx1880_tgt, $I11
    ne $I11, 125, rx1880_fail
    add rx1880_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ENDSTMT"()
    unless $P10, rx1880_fail
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
  alt1882_end:
.annotate 'line', 951
  # rx subrule "ws" subtype=method negate=
    rx1880_cur."!cursor_pos"(rx1880_pos)
    $P10 = rx1880_cur."ws"()
    unless $P10, rx1880_fail
    rx1880_pos = $P10."pos"()
.annotate 'line', 936
  # rx pass
    rx1880_cur."!cursor_pass"(rx1880_pos, "regex_declarator")
    if_null rx1880_debug, debug_1335
    rx1880_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1880_pos)
  debug_1335:
    .return (rx1880_cur)
  rx1880_restart:
.annotate 'line', 440
    if_null rx1880_debug, debug_1336
    rx1880_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1336:
  rx1880_fail:
    (rx1880_rep, rx1880_pos, $I10, $P10) = rx1880_cur."!mark_fail"(0)
    lt rx1880_pos, -1, rx1880_done
    eq rx1880_pos, -1, rx1880_fail
    jump $I10
  rx1880_done:
    rx1880_cur."!cursor_fail"()
    if_null rx1880_debug, debug_1337
    rx1880_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1337:
    .return (rx1880_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("243_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("244_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1891_tgt
    .local int rx1891_pos
    .local int rx1891_off
    .local int rx1891_eos
    .local int rx1891_rep
    .local pmc rx1891_cur
    .local pmc rx1891_debug
    (rx1891_cur, rx1891_pos, rx1891_tgt, $I10) = self."!cursor_start"()
    rx1891_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1891_cur
    .local pmc match
    .lex "$/", match
    length rx1891_eos, rx1891_tgt
    gt rx1891_pos, rx1891_eos, rx1891_done
    set rx1891_off, 0
    lt rx1891_pos, 2, rx1891_start
    sub rx1891_off, rx1891_pos, 1
    substr rx1891_tgt, rx1891_tgt, rx1891_off
  rx1891_start:
    eq $I10, 1, rx1891_restart
    if_null rx1891_debug, debug_1338
    rx1891_cur."!cursor_debug"("START", "dotty")
  debug_1338:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1892_done
    goto rxscan1892_scan
  rxscan1892_loop:
    (rx1891_pos) = rx1891_cur."from"()
    inc rx1891_pos
    rx1891_cur."!cursor_from"(rx1891_pos)
    ge rx1891_pos, rx1891_eos, rxscan1892_done
  rxscan1892_scan:
    set_addr $I10, rxscan1892_loop
    rx1891_cur."!mark_push"(0, rx1891_pos, $I10)
  rxscan1892_done:
.annotate 'line', 955
  # rx literal  "."
    add $I11, rx1891_pos, 1
    gt $I11, rx1891_eos, rx1891_fail
    sub $I11, rx1891_pos, rx1891_off
    ord $I11, rx1891_tgt, $I11
    ne $I11, 46, rx1891_fail
    add rx1891_pos, 1
  alt1893_0:
.annotate 'line', 956
    set_addr $I10, alt1893_1
    rx1891_cur."!mark_push"(0, rx1891_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1891_cur."!cursor_pos"(rx1891_pos)
    $P10 = rx1891_cur."deflongname"()
    unless $P10, rx1891_fail
    rx1891_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1891_pos = $P10."pos"()
    goto alt1893_end
  alt1893_1:
.annotate 'line', 957
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1891_pos, rx1891_off
    substr $S10, rx1891_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1891_fail
  # rx subrule "quote" subtype=capture negate=
    rx1891_cur."!cursor_pos"(rx1891_pos)
    $P10 = rx1891_cur."quote"()
    unless $P10, rx1891_fail
    rx1891_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1891_pos = $P10."pos"()
  alt1894_0:
.annotate 'line', 958
    set_addr $I10, alt1894_1
    rx1891_cur."!mark_push"(0, rx1891_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1891_pos, rx1891_off
    substr $S10, rx1891_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1891_fail
    goto alt1894_end
  alt1894_1:
  # rx subrule "panic" subtype=method negate=
    rx1891_cur."!cursor_pos"(rx1891_pos)
    $P10 = rx1891_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1891_fail
    rx1891_pos = $P10."pos"()
  alt1894_end:
  alt1893_end:
.annotate 'line', 964
  # rx rxquantr1895 ** 0..1
    set_addr $I10, rxquantr1895_done
    rx1891_cur."!mark_push"(0, rx1891_pos, $I10)
  rxquantr1895_loop:
  alt1896_0:
.annotate 'line', 961
    set_addr $I10, alt1896_1
    rx1891_cur."!mark_push"(0, rx1891_pos, $I10)
.annotate 'line', 962
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1891_pos, rx1891_off
    substr $S10, rx1891_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1891_fail
  # rx subrule "args" subtype=capture negate=
    rx1891_cur."!cursor_pos"(rx1891_pos)
    $P10 = rx1891_cur."args"()
    unless $P10, rx1891_fail
    rx1891_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1891_pos = $P10."pos"()
    goto alt1896_end
  alt1896_1:
.annotate 'line', 963
  # rx literal  ":"
    add $I11, rx1891_pos, 1
    gt $I11, rx1891_eos, rx1891_fail
    sub $I11, rx1891_pos, rx1891_off
    ord $I11, rx1891_tgt, $I11
    ne $I11, 58, rx1891_fail
    add rx1891_pos, 1
  # rx charclass s
    ge rx1891_pos, rx1891_eos, rx1891_fail
    sub $I10, rx1891_pos, rx1891_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1891_tgt, $I10
    unless $I11, rx1891_fail
    inc rx1891_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1891_cur."!cursor_pos"(rx1891_pos)
    $P10 = rx1891_cur."arglist"()
    unless $P10, rx1891_fail
    rx1891_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1891_pos = $P10."pos"()
  alt1896_end:
.annotate 'line', 964
    set_addr $I10, rxquantr1895_done
    (rx1891_rep) = rx1891_cur."!mark_commit"($I10)
  rxquantr1895_done:
.annotate 'line', 954
  # rx pass
    rx1891_cur."!cursor_pass"(rx1891_pos, "dotty")
    if_null rx1891_debug, debug_1339
    rx1891_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1891_pos)
  debug_1339:
    .return (rx1891_cur)
  rx1891_restart:
.annotate 'line', 440
    if_null rx1891_debug, debug_1340
    rx1891_cur."!cursor_debug"("NEXT", "dotty")
  debug_1340:
  rx1891_fail:
    (rx1891_rep, rx1891_pos, $I10, $P10) = rx1891_cur."!mark_fail"(0)
    lt rx1891_pos, -1, rx1891_done
    eq rx1891_pos, -1, rx1891_fail
    jump $I10
  rx1891_done:
    rx1891_cur."!cursor_fail"()
    if_null rx1891_debug, debug_1341
    rx1891_cur."!cursor_debug"("FAIL", "dotty")
  debug_1341:
    .return (rx1891_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("245_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P104, "ResizablePMCArray"
    push $P104, "'"
    push $P104, "\""
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("246_1312646121.678")
    .param pmc param_1899
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 968
    .lex "self", param_1899
    $P103 = param_1899."!protoregex"("term")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("247_1312646121.678")
    .param pmc param_1901
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 968
    .lex "self", param_1901
    $P104 = param_1901."!PREFIX__!protoregex"("term")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("248_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1903_tgt
    .local int rx1903_pos
    .local int rx1903_off
    .local int rx1903_eos
    .local int rx1903_rep
    .local pmc rx1903_cur
    .local pmc rx1903_debug
    (rx1903_cur, rx1903_pos, rx1903_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1903_cur
    .local pmc match
    .lex "$/", match
    length rx1903_eos, rx1903_tgt
    gt rx1903_pos, rx1903_eos, rx1903_done
    set rx1903_off, 0
    lt rx1903_pos, 2, rx1903_start
    sub rx1903_off, rx1903_pos, 1
    substr rx1903_tgt, rx1903_tgt, rx1903_off
  rx1903_start:
    eq $I10, 1, rx1903_restart
    if_null rx1903_debug, debug_1342
    rx1903_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1342:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1904_done
    goto rxscan1904_scan
  rxscan1904_loop:
    (rx1903_pos) = rx1903_cur."from"()
    inc rx1903_pos
    rx1903_cur."!cursor_from"(rx1903_pos)
    ge rx1903_pos, rx1903_eos, rxscan1904_done
  rxscan1904_scan:
    set_addr $I10, rxscan1904_loop
    rx1903_cur."!mark_push"(0, rx1903_pos, $I10)
  rxscan1904_done:
.annotate 'line', 970
  # rx subcapture "sym"
    set_addr $I10, rxcap_1905_fail
    rx1903_cur."!mark_push"(0, rx1903_pos, $I10)
  # rx literal  "self"
    add $I11, rx1903_pos, 4
    gt $I11, rx1903_eos, rx1903_fail
    sub $I11, rx1903_pos, rx1903_off
    substr $S10, rx1903_tgt, $I11, 4
    ne $S10, "self", rx1903_fail
    add rx1903_pos, 4
    set_addr $I10, rxcap_1905_fail
    ($I12, $I11) = rx1903_cur."!mark_peek"($I10)
    rx1903_cur."!cursor_pos"($I11)
    ($P10) = rx1903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1903_pos, "")
    rx1903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1905_done
  rxcap_1905_fail:
    goto rx1903_fail
  rxcap_1905_done:
  # rxanchor rwb
    le rx1903_pos, 0, rx1903_fail
    sub $I10, rx1903_pos, rx1903_off
    is_cclass $I11, .CCLASS_WORD, rx1903_tgt, $I10
    if $I11, rx1903_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1903_tgt, $I10
    unless $I11, rx1903_fail
  # rx pass
    rx1903_cur."!cursor_pass"(rx1903_pos, "term:sym<self>")
    if_null rx1903_debug, debug_1343
    rx1903_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1903_pos)
  debug_1343:
    .return (rx1903_cur)
  rx1903_restart:
.annotate 'line', 440
    if_null rx1903_debug, debug_1344
    rx1903_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1344:
  rx1903_fail:
    (rx1903_rep, rx1903_pos, $I10, $P10) = rx1903_cur."!mark_fail"(0)
    lt rx1903_pos, -1, rx1903_done
    eq rx1903_pos, -1, rx1903_fail
    jump $I10
  rx1903_done:
    rx1903_cur."!cursor_fail"()
    if_null rx1903_debug, debug_1345
    rx1903_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1345:
    .return (rx1903_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("249_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "self"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("250_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1908_tgt
    .local int rx1908_pos
    .local int rx1908_off
    .local int rx1908_eos
    .local int rx1908_rep
    .local pmc rx1908_cur
    .local pmc rx1908_debug
    (rx1908_cur, rx1908_pos, rx1908_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1908_cur
    .local pmc match
    .lex "$/", match
    length rx1908_eos, rx1908_tgt
    gt rx1908_pos, rx1908_eos, rx1908_done
    set rx1908_off, 0
    lt rx1908_pos, 2, rx1908_start
    sub rx1908_off, rx1908_pos, 1
    substr rx1908_tgt, rx1908_tgt, rx1908_off
  rx1908_start:
    eq $I10, 1, rx1908_restart
    if_null rx1908_debug, debug_1346
    rx1908_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1346:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1909_done
    goto rxscan1909_scan
  rxscan1909_loop:
    (rx1908_pos) = rx1908_cur."from"()
    inc rx1908_pos
    rx1908_cur."!cursor_from"(rx1908_pos)
    ge rx1908_pos, rx1908_eos, rxscan1909_done
  rxscan1909_scan:
    set_addr $I10, rxscan1909_loop
    rx1908_cur."!mark_push"(0, rx1908_pos, $I10)
  rxscan1909_done:
.annotate 'line', 973
  # rx subrule "deflongname" subtype=capture negate=
    rx1908_cur."!cursor_pos"(rx1908_pos)
    $P10 = rx1908_cur."deflongname"()
    unless $P10, rx1908_fail
    rx1908_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1908_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1908_pos, rx1908_off
    substr $S10, rx1908_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1908_fail
  # rx subrule "args" subtype=capture negate=
    rx1908_cur."!cursor_pos"(rx1908_pos)
    $P10 = rx1908_cur."args"()
    unless $P10, rx1908_fail
    rx1908_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1908_pos = $P10."pos"()
.annotate 'line', 972
  # rx pass
    rx1908_cur."!cursor_pass"(rx1908_pos, "term:sym<identifier>")
    if_null rx1908_debug, debug_1347
    rx1908_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1908_pos)
  debug_1347:
    .return (rx1908_cur)
  rx1908_restart:
.annotate 'line', 440
    if_null rx1908_debug, debug_1348
    rx1908_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1348:
  rx1908_fail:
    (rx1908_rep, rx1908_pos, $I10, $P10) = rx1908_cur."!mark_fail"(0)
    lt rx1908_pos, -1, rx1908_done
    eq rx1908_pos, -1, rx1908_fail
    jump $I10
  rx1908_done:
    rx1908_cur."!cursor_fail"()
    if_null rx1908_debug, debug_1349
    rx1908_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1349:
    .return (rx1908_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("251_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("deflongname", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("252_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1912_tgt
    .local int rx1912_pos
    .local int rx1912_off
    .local int rx1912_eos
    .local int rx1912_rep
    .local pmc rx1912_cur
    .local pmc rx1912_debug
    (rx1912_cur, rx1912_pos, rx1912_tgt, $I10) = self."!cursor_start"()
    rx1912_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1912_cur
    .local pmc match
    .lex "$/", match
    length rx1912_eos, rx1912_tgt
    gt rx1912_pos, rx1912_eos, rx1912_done
    set rx1912_off, 0
    lt rx1912_pos, 2, rx1912_start
    sub rx1912_off, rx1912_pos, 1
    substr rx1912_tgt, rx1912_tgt, rx1912_off
  rx1912_start:
    eq $I10, 1, rx1912_restart
    if_null rx1912_debug, debug_1350
    rx1912_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1350:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1913_done
    goto rxscan1913_scan
  rxscan1913_loop:
    (rx1912_pos) = rx1912_cur."from"()
    inc rx1912_pos
    rx1912_cur."!cursor_from"(rx1912_pos)
    ge rx1912_pos, rx1912_eos, rxscan1913_done
  rxscan1913_scan:
    set_addr $I10, rxscan1913_loop
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxscan1913_done:
.annotate 'line', 977
  # rx subrule "name" subtype=capture negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."name"()
    unless $P10, rx1912_fail
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1912_pos = $P10."pos"()
  # rx rxquantr1914 ** 0..1
    set_addr $I10, rxquantr1914_done
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxquantr1914_loop:
  # rx subrule "args" subtype=capture negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."args"()
    unless $P10, rx1912_fail
    goto rxsubrule1915_pass
  rxsubrule1915_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1912_fail
  rxsubrule1915_pass:
    set_addr $I10, rxsubrule1915_back
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1912_pos = $P10."pos"()
    set_addr $I10, rxquantr1914_done
    (rx1912_rep) = rx1912_cur."!mark_commit"($I10)
  rxquantr1914_done:
.annotate 'line', 976
  # rx pass
    rx1912_cur."!cursor_pass"(rx1912_pos, "term:sym<name>")
    if_null rx1912_debug, debug_1351
    rx1912_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1912_pos)
  debug_1351:
    .return (rx1912_cur)
  rx1912_restart:
.annotate 'line', 440
    if_null rx1912_debug, debug_1352
    rx1912_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1352:
  rx1912_fail:
    (rx1912_rep, rx1912_pos, $I10, $P10) = rx1912_cur."!mark_fail"(0)
    lt rx1912_pos, -1, rx1912_done
    eq rx1912_pos, -1, rx1912_fail
    jump $I10
  rx1912_done:
    rx1912_cur."!cursor_fail"()
    if_null rx1912_debug, debug_1353
    rx1912_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1353:
    .return (rx1912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("253_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("name", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("254_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1918_tgt
    .local int rx1918_pos
    .local int rx1918_off
    .local int rx1918_eos
    .local int rx1918_rep
    .local pmc rx1918_cur
    .local pmc rx1918_debug
    (rx1918_cur, rx1918_pos, rx1918_tgt, $I10) = self."!cursor_start"()
    rx1918_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1918_cur
    .local pmc match
    .lex "$/", match
    length rx1918_eos, rx1918_tgt
    gt rx1918_pos, rx1918_eos, rx1918_done
    set rx1918_off, 0
    lt rx1918_pos, 2, rx1918_start
    sub rx1918_off, rx1918_pos, 1
    substr rx1918_tgt, rx1918_tgt, rx1918_off
  rx1918_start:
    eq $I10, 1, rx1918_restart
    if_null rx1918_debug, debug_1354
    rx1918_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1354:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1919_done
    goto rxscan1919_scan
  rxscan1919_loop:
    (rx1918_pos) = rx1918_cur."from"()
    inc rx1918_pos
    rx1918_cur."!cursor_from"(rx1918_pos)
    ge rx1918_pos, rx1918_eos, rxscan1919_done
  rxscan1919_scan:
    set_addr $I10, rxscan1919_loop
    rx1918_cur."!mark_push"(0, rx1918_pos, $I10)
  rxscan1919_done:
.annotate 'line', 981
  # rx literal  "pir::"
    add $I11, rx1918_pos, 5
    gt $I11, rx1918_eos, rx1918_fail
    sub $I11, rx1918_pos, rx1918_off
    substr $S10, rx1918_tgt, $I11, 5
    ne $S10, "pir::", rx1918_fail
    add rx1918_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1920_fail
    rx1918_cur."!mark_push"(0, rx1918_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1918_pos, rx1918_off
    find_not_cclass $I11, .CCLASS_WORD, rx1918_tgt, $I10, rx1918_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1918_fail
    add rx1918_pos, rx1918_off, $I11
    set_addr $I10, rxcap_1920_fail
    ($I12, $I11) = rx1918_cur."!mark_peek"($I10)
    rx1918_cur."!cursor_pos"($I11)
    ($P10) = rx1918_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1918_pos, "")
    rx1918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1920_done
  rxcap_1920_fail:
    goto rx1918_fail
  rxcap_1920_done:
  # rx rxquantr1921 ** 0..1
    set_addr $I10, rxquantr1921_done
    rx1918_cur."!mark_push"(0, rx1918_pos, $I10)
  rxquantr1921_loop:
  # rx subrule "args" subtype=capture negate=
    rx1918_cur."!cursor_pos"(rx1918_pos)
    $P10 = rx1918_cur."args"()
    unless $P10, rx1918_fail
    goto rxsubrule1922_pass
  rxsubrule1922_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1918_fail
  rxsubrule1922_pass:
    set_addr $I10, rxsubrule1922_back
    rx1918_cur."!mark_push"(0, rx1918_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1918_pos = $P10."pos"()
    set_addr $I10, rxquantr1921_done
    (rx1918_rep) = rx1918_cur."!mark_commit"($I10)
  rxquantr1921_done:
.annotate 'line', 980
  # rx pass
    rx1918_cur."!cursor_pass"(rx1918_pos, "term:sym<pir::op>")
    if_null rx1918_debug, debug_1355
    rx1918_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1918_pos)
  debug_1355:
    .return (rx1918_cur)
  rx1918_restart:
.annotate 'line', 440
    if_null rx1918_debug, debug_1356
    rx1918_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1356:
  rx1918_fail:
    (rx1918_rep, rx1918_pos, $I10, $P10) = rx1918_cur."!mark_fail"(0)
    lt rx1918_pos, -1, rx1918_done
    eq rx1918_pos, -1, rx1918_fail
    jump $I10
  rx1918_done:
    rx1918_cur."!cursor_fail"()
    if_null rx1918_debug, debug_1357
    rx1918_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1357:
    .return (rx1918_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("255_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "pir::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::const>"  :subid("256_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1925_tgt
    .local int rx1925_pos
    .local int rx1925_off
    .local int rx1925_eos
    .local int rx1925_rep
    .local pmc rx1925_cur
    .local pmc rx1925_debug
    (rx1925_cur, rx1925_pos, rx1925_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1925_cur
    .local pmc match
    .lex "$/", match
    length rx1925_eos, rx1925_tgt
    gt rx1925_pos, rx1925_eos, rx1925_done
    set rx1925_off, 0
    lt rx1925_pos, 2, rx1925_start
    sub rx1925_off, rx1925_pos, 1
    substr rx1925_tgt, rx1925_tgt, rx1925_off
  rx1925_start:
    eq $I10, 1, rx1925_restart
    if_null rx1925_debug, debug_1358
    rx1925_cur."!cursor_debug"("START", "term:sym<pir::const>")
  debug_1358:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1926_done
    goto rxscan1926_scan
  rxscan1926_loop:
    (rx1925_pos) = rx1925_cur."from"()
    inc rx1925_pos
    rx1925_cur."!cursor_from"(rx1925_pos)
    ge rx1925_pos, rx1925_eos, rxscan1926_done
  rxscan1926_scan:
    set_addr $I10, rxscan1926_loop
    rx1925_cur."!mark_push"(0, rx1925_pos, $I10)
  rxscan1926_done:
.annotate 'line', 985
  # rx literal  "pir::const::"
    add $I11, rx1925_pos, 12
    gt $I11, rx1925_eos, rx1925_fail
    sub $I11, rx1925_pos, rx1925_off
    substr $S10, rx1925_tgt, $I11, 12
    ne $S10, "pir::const::", rx1925_fail
    add rx1925_pos, 12
  # rx subcapture "const"
    set_addr $I10, rxcap_1927_fail
    rx1925_cur."!mark_push"(0, rx1925_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1925_pos, rx1925_off
    find_not_cclass $I11, .CCLASS_WORD, rx1925_tgt, $I10, rx1925_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1925_fail
    add rx1925_pos, rx1925_off, $I11
    set_addr $I10, rxcap_1927_fail
    ($I12, $I11) = rx1925_cur."!mark_peek"($I10)
    rx1925_cur."!cursor_pos"($I11)
    ($P10) = rx1925_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1925_pos, "")
    rx1925_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("const")
    goto rxcap_1927_done
  rxcap_1927_fail:
    goto rx1925_fail
  rxcap_1927_done:
.annotate 'line', 984
  # rx pass
    rx1925_cur."!cursor_pass"(rx1925_pos, "term:sym<pir::const>")
    if_null rx1925_debug, debug_1359
    rx1925_cur."!cursor_debug"("PASS", "term:sym<pir::const>", " at pos=", rx1925_pos)
  debug_1359:
    .return (rx1925_cur)
  rx1925_restart:
.annotate 'line', 440
    if_null rx1925_debug, debug_1360
    rx1925_cur."!cursor_debug"("NEXT", "term:sym<pir::const>")
  debug_1360:
  rx1925_fail:
    (rx1925_rep, rx1925_pos, $I10, $P10) = rx1925_cur."!mark_fail"(0)
    lt rx1925_pos, -1, rx1925_done
    eq rx1925_pos, -1, rx1925_fail
    jump $I10
  rx1925_done:
    rx1925_cur."!cursor_fail"()
    if_null rx1925_debug, debug_1361
    rx1925_cur."!cursor_debug"("FAIL", "term:sym<pir::const>")
  debug_1361:
    .return (rx1925_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::const>"  :subid("257_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "pir::const::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<nqp::op>"  :subid("258_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1930_tgt
    .local int rx1930_pos
    .local int rx1930_off
    .local int rx1930_eos
    .local int rx1930_rep
    .local pmc rx1930_cur
    .local pmc rx1930_debug
    (rx1930_cur, rx1930_pos, rx1930_tgt, $I10) = self."!cursor_start"()
    rx1930_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1930_cur
    .local pmc match
    .lex "$/", match
    length rx1930_eos, rx1930_tgt
    gt rx1930_pos, rx1930_eos, rx1930_done
    set rx1930_off, 0
    lt rx1930_pos, 2, rx1930_start
    sub rx1930_off, rx1930_pos, 1
    substr rx1930_tgt, rx1930_tgt, rx1930_off
  rx1930_start:
    eq $I10, 1, rx1930_restart
    if_null rx1930_debug, debug_1362
    rx1930_cur."!cursor_debug"("START", "term:sym<nqp::op>")
  debug_1362:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1931_done
    goto rxscan1931_scan
  rxscan1931_loop:
    (rx1930_pos) = rx1930_cur."from"()
    inc rx1930_pos
    rx1930_cur."!cursor_from"(rx1930_pos)
    ge rx1930_pos, rx1930_eos, rxscan1931_done
  rxscan1931_scan:
    set_addr $I10, rxscan1931_loop
    rx1930_cur."!mark_push"(0, rx1930_pos, $I10)
  rxscan1931_done:
.annotate 'line', 989
  # rx literal  "nqp::"
    add $I11, rx1930_pos, 5
    gt $I11, rx1930_eos, rx1930_fail
    sub $I11, rx1930_pos, rx1930_off
    substr $S10, rx1930_tgt, $I11, 5
    ne $S10, "nqp::", rx1930_fail
    add rx1930_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1932_fail
    rx1930_cur."!mark_push"(0, rx1930_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1930_pos, rx1930_off
    find_not_cclass $I11, .CCLASS_WORD, rx1930_tgt, $I10, rx1930_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1930_fail
    add rx1930_pos, rx1930_off, $I11
    set_addr $I10, rxcap_1932_fail
    ($I12, $I11) = rx1930_cur."!mark_peek"($I10)
    rx1930_cur."!cursor_pos"($I11)
    ($P10) = rx1930_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1930_pos, "")
    rx1930_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1932_done
  rxcap_1932_fail:
    goto rx1930_fail
  rxcap_1932_done:
  # rx rxquantr1933 ** 0..1
    set_addr $I10, rxquantr1933_done
    rx1930_cur."!mark_push"(0, rx1930_pos, $I10)
  rxquantr1933_loop:
  # rx subrule "args" subtype=capture negate=
    rx1930_cur."!cursor_pos"(rx1930_pos)
    $P10 = rx1930_cur."args"()
    unless $P10, rx1930_fail
    goto rxsubrule1934_pass
  rxsubrule1934_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1930_fail
  rxsubrule1934_pass:
    set_addr $I10, rxsubrule1934_back
    rx1930_cur."!mark_push"(0, rx1930_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1930_pos = $P10."pos"()
    set_addr $I10, rxquantr1933_done
    (rx1930_rep) = rx1930_cur."!mark_commit"($I10)
  rxquantr1933_done:
.annotate 'line', 988
  # rx pass
    rx1930_cur."!cursor_pass"(rx1930_pos, "term:sym<nqp::op>")
    if_null rx1930_debug, debug_1363
    rx1930_cur."!cursor_debug"("PASS", "term:sym<nqp::op>", " at pos=", rx1930_pos)
  debug_1363:
    .return (rx1930_cur)
  rx1930_restart:
.annotate 'line', 440
    if_null rx1930_debug, debug_1364
    rx1930_cur."!cursor_debug"("NEXT", "term:sym<nqp::op>")
  debug_1364:
  rx1930_fail:
    (rx1930_rep, rx1930_pos, $I10, $P10) = rx1930_cur."!mark_fail"(0)
    lt rx1930_pos, -1, rx1930_done
    eq rx1930_pos, -1, rx1930_fail
    jump $I10
  rx1930_done:
    rx1930_cur."!cursor_fail"()
    if_null rx1930_debug, debug_1365
    rx1930_cur."!cursor_debug"("FAIL", "term:sym<nqp::op>")
  debug_1365:
    .return (rx1930_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<nqp::op>"  :subid("259_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "nqp::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("260_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P1941 = "261_1312646121.678" 
    capture_lex $P1941
    .local string rx1937_tgt
    .local int rx1937_pos
    .local int rx1937_off
    .local int rx1937_eos
    .local int rx1937_rep
    .local pmc rx1937_cur
    .local pmc rx1937_debug
    (rx1937_cur, rx1937_pos, rx1937_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1937_cur
    .local pmc match
    .lex "$/", match
    length rx1937_eos, rx1937_tgt
    gt rx1937_pos, rx1937_eos, rx1937_done
    set rx1937_off, 0
    lt rx1937_pos, 2, rx1937_start
    sub rx1937_off, rx1937_pos, 1
    substr rx1937_tgt, rx1937_tgt, rx1937_off
  rx1937_start:
    eq $I10, 1, rx1937_restart
    if_null rx1937_debug, debug_1366
    rx1937_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1366:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1938_done
    goto rxscan1938_scan
  rxscan1938_loop:
    (rx1937_pos) = rx1937_cur."from"()
    inc rx1937_pos
    rx1937_cur."!cursor_from"(rx1937_pos)
    ge rx1937_pos, rx1937_eos, rxscan1938_done
  rxscan1938_scan:
    set_addr $I10, rxscan1938_loop
    rx1937_cur."!mark_push"(0, rx1937_pos, $I10)
  rxscan1938_done:
.annotate 'line', 993
  # rx literal  "{*}"
    add $I11, rx1937_pos, 3
    gt $I11, rx1937_eos, rx1937_fail
    sub $I11, rx1937_pos, rx1937_off
    substr $S10, rx1937_tgt, $I11, 3
    ne $S10, "{*}", rx1937_fail
    add rx1937_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1937_cur."!cursor_pos"(rx1937_pos)
    $P10 = rx1937_cur."ENDSTMT"()
    unless $P10, rx1937_fail
  alt1939_0:
.annotate 'line', 994
    set_addr $I10, alt1939_1
    rx1937_cur."!mark_push"(0, rx1937_pos, $I10)
    rx1937_cur."!cursor_pos"(rx1937_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1941 = "261_1312646121.678" 
    capture_lex $P1941
    $P105 = $P1941()
    unless $P105, rx1937_fail
    goto alt1939_end
  alt1939_1:
  # rx subrule "panic" subtype=method negate=
    rx1937_cur."!cursor_pos"(rx1937_pos)
    $P10 = rx1937_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1937_fail
    rx1937_pos = $P10."pos"()
  alt1939_end:
.annotate 'line', 992
  # rx pass
    rx1937_cur."!cursor_pass"(rx1937_pos, "term:sym<onlystar>")
    if_null rx1937_debug, debug_1369
    rx1937_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1937_pos)
  debug_1369:
    .return (rx1937_cur)
  rx1937_restart:
.annotate 'line', 440
    if_null rx1937_debug, debug_1370
    rx1937_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1370:
  rx1937_fail:
    (rx1937_rep, rx1937_pos, $I10, $P10) = rx1937_cur."!mark_fail"(0)
    lt rx1937_pos, -1, rx1937_done
    eq rx1937_pos, -1, rx1937_fail
    jump $I10
  rx1937_done:
    rx1937_cur."!cursor_fail"()
    if_null rx1937_debug, debug_1371
    rx1937_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1371:
    .return (rx1937_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1940"  :anon :subid("261_1312646121.678") :outer("260_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 994
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1367
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1368
    die "Contextual $*MULTINESS not found"
  vivify_1368:
  vivify_1367:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("262_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P106, "ResizablePMCArray"
    push $P106, "{*}"
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("263_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1944_tgt
    .local int rx1944_pos
    .local int rx1944_off
    .local int rx1944_eos
    .local int rx1944_rep
    .local pmc rx1944_cur
    .local pmc rx1944_debug
    (rx1944_cur, rx1944_pos, rx1944_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1944_cur
    .local pmc match
    .lex "$/", match
    length rx1944_eos, rx1944_tgt
    gt rx1944_pos, rx1944_eos, rx1944_done
    set rx1944_off, 0
    lt rx1944_pos, 2, rx1944_start
    sub rx1944_off, rx1944_pos, 1
    substr rx1944_tgt, rx1944_tgt, rx1944_off
  rx1944_start:
    eq $I10, 1, rx1944_restart
    if_null rx1944_debug, debug_1372
    rx1944_cur."!cursor_debug"("START", "args")
  debug_1372:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1945_done
    goto rxscan1945_scan
  rxscan1945_loop:
    (rx1944_pos) = rx1944_cur."from"()
    inc rx1944_pos
    rx1944_cur."!cursor_from"(rx1944_pos)
    ge rx1944_pos, rx1944_eos, rxscan1945_done
  rxscan1945_scan:
    set_addr $I10, rxscan1945_loop
    rx1944_cur."!mark_push"(0, rx1944_pos, $I10)
  rxscan1945_done:
.annotate 'line', 998
  # rx literal  "("
    add $I11, rx1944_pos, 1
    gt $I11, rx1944_eos, rx1944_fail
    sub $I11, rx1944_pos, rx1944_off
    ord $I11, rx1944_tgt, $I11
    ne $I11, 40, rx1944_fail
    add rx1944_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1944_cur."!cursor_pos"(rx1944_pos)
    $P10 = rx1944_cur."arglist"()
    unless $P10, rx1944_fail
    rx1944_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1944_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1944_pos, 1
    gt $I11, rx1944_eos, rx1944_fail
    sub $I11, rx1944_pos, rx1944_off
    ord $I11, rx1944_tgt, $I11
    ne $I11, 41, rx1944_fail
    add rx1944_pos, 1
  # rx pass
    rx1944_cur."!cursor_pass"(rx1944_pos, "args")
    if_null rx1944_debug, debug_1373
    rx1944_cur."!cursor_debug"("PASS", "args", " at pos=", rx1944_pos)
  debug_1373:
    .return (rx1944_cur)
  rx1944_restart:
.annotate 'line', 440
    if_null rx1944_debug, debug_1374
    rx1944_cur."!cursor_debug"("NEXT", "args")
  debug_1374:
  rx1944_fail:
    (rx1944_rep, rx1944_pos, $I10, $P10) = rx1944_cur."!mark_fail"(0)
    lt rx1944_pos, -1, rx1944_done
    eq rx1944_pos, -1, rx1944_fail
    jump $I10
  rx1944_done:
    rx1944_cur."!cursor_fail"()
    if_null rx1944_debug, debug_1375
    rx1944_cur."!cursor_debug"("FAIL", "args")
  debug_1375:
    .return (rx1944_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("264_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("arglist", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("265_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1948_tgt
    .local int rx1948_pos
    .local int rx1948_off
    .local int rx1948_eos
    .local int rx1948_rep
    .local pmc rx1948_cur
    .local pmc rx1948_debug
    (rx1948_cur, rx1948_pos, rx1948_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1948_cur
    .local pmc match
    .lex "$/", match
    length rx1948_eos, rx1948_tgt
    gt rx1948_pos, rx1948_eos, rx1948_done
    set rx1948_off, 0
    lt rx1948_pos, 2, rx1948_start
    sub rx1948_off, rx1948_pos, 1
    substr rx1948_tgt, rx1948_tgt, rx1948_off
  rx1948_start:
    eq $I10, 1, rx1948_restart
    if_null rx1948_debug, debug_1376
    rx1948_cur."!cursor_debug"("START", "arglist")
  debug_1376:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1949_done
    goto rxscan1949_scan
  rxscan1949_loop:
    (rx1948_pos) = rx1948_cur."from"()
    inc rx1948_pos
    rx1948_cur."!cursor_from"(rx1948_pos)
    ge rx1948_pos, rx1948_eos, rxscan1949_done
  rxscan1949_scan:
    set_addr $I10, rxscan1949_loop
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
  rxscan1949_done:
.annotate 'line', 1002
  # rx subrule "ws" subtype=method negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."ws"()
    unless $P10, rx1948_fail
    rx1948_pos = $P10."pos"()
  alt1950_0:
.annotate 'line', 1003
    set_addr $I10, alt1950_1
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
.annotate 'line', 1004
  # rx subrule "EXPR" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."EXPR"("f=")
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1948_pos = $P10."pos"()
    goto alt1950_end
  alt1950_1:
  alt1950_end:
.annotate 'line', 1001
  # rx pass
    rx1948_cur."!cursor_pass"(rx1948_pos, "arglist")
    if_null rx1948_debug, debug_1377
    rx1948_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1948_pos)
  debug_1377:
    .return (rx1948_cur)
  rx1948_restart:
.annotate 'line', 440
    if_null rx1948_debug, debug_1378
    rx1948_cur."!cursor_debug"("NEXT", "arglist")
  debug_1378:
  rx1948_fail:
    (rx1948_rep, rx1948_pos, $I10, $P10) = rx1948_cur."!mark_fail"(0)
    lt rx1948_pos, -1, rx1948_done
    eq rx1948_pos, -1, rx1948_fail
    jump $I10
  rx1948_done:
    rx1948_cur."!cursor_fail"()
    if_null rx1948_debug, debug_1379
    rx1948_cur."!cursor_debug"("FAIL", "arglist")
  debug_1379:
    .return (rx1948_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("266_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("267_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1953_tgt
    .local int rx1953_pos
    .local int rx1953_off
    .local int rx1953_eos
    .local int rx1953_rep
    .local pmc rx1953_cur
    .local pmc rx1953_debug
    (rx1953_cur, rx1953_pos, rx1953_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1953_cur
    .local pmc match
    .lex "$/", match
    length rx1953_eos, rx1953_tgt
    gt rx1953_pos, rx1953_eos, rx1953_done
    set rx1953_off, 0
    lt rx1953_pos, 2, rx1953_start
    sub rx1953_off, rx1953_pos, 1
    substr rx1953_tgt, rx1953_tgt, rx1953_off
  rx1953_start:
    eq $I10, 1, rx1953_restart
    if_null rx1953_debug, debug_1380
    rx1953_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1380:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1954_done
    goto rxscan1954_scan
  rxscan1954_loop:
    (rx1953_pos) = rx1953_cur."from"()
    inc rx1953_pos
    rx1953_cur."!cursor_from"(rx1953_pos)
    ge rx1953_pos, rx1953_eos, rxscan1954_done
  rxscan1954_scan:
    set_addr $I10, rxscan1954_loop
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
  rxscan1954_done:
.annotate 'line', 1010
  # rx subrule "value" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."value"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1953_pos = $P10."pos"()
  # rx pass
    rx1953_cur."!cursor_pass"(rx1953_pos, "term:sym<value>")
    if_null rx1953_debug, debug_1381
    rx1953_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1953_pos)
  debug_1381:
    .return (rx1953_cur)
  rx1953_restart:
.annotate 'line', 440
    if_null rx1953_debug, debug_1382
    rx1953_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1382:
  rx1953_fail:
    (rx1953_rep, rx1953_pos, $I10, $P10) = rx1953_cur."!mark_fail"(0)
    lt rx1953_pos, -1, rx1953_done
    eq rx1953_pos, -1, rx1953_fail
    jump $I10
  rx1953_done:
    rx1953_cur."!cursor_fail"()
    if_null rx1953_debug, debug_1383
    rx1953_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1383:
    .return (rx1953_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("268_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("value", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("269_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1957_tgt
    .local int rx1957_pos
    .local int rx1957_off
    .local int rx1957_eos
    .local int rx1957_rep
    .local pmc rx1957_cur
    .local pmc rx1957_debug
    (rx1957_cur, rx1957_pos, rx1957_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1957_cur
    .local pmc match
    .lex "$/", match
    length rx1957_eos, rx1957_tgt
    gt rx1957_pos, rx1957_eos, rx1957_done
    set rx1957_off, 0
    lt rx1957_pos, 2, rx1957_start
    sub rx1957_off, rx1957_pos, 1
    substr rx1957_tgt, rx1957_tgt, rx1957_off
  rx1957_start:
    eq $I10, 1, rx1957_restart
    if_null rx1957_debug, debug_1384
    rx1957_cur."!cursor_debug"("START", "value")
  debug_1384:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1958_done
    goto rxscan1958_scan
  rxscan1958_loop:
    (rx1957_pos) = rx1957_cur."from"()
    inc rx1957_pos
    rx1957_cur."!cursor_from"(rx1957_pos)
    ge rx1957_pos, rx1957_eos, rxscan1958_done
  rxscan1958_scan:
    set_addr $I10, rxscan1958_loop
    rx1957_cur."!mark_push"(0, rx1957_pos, $I10)
  rxscan1958_done:
  alt1959_0:
.annotate 'line', 1012
    set_addr $I10, alt1959_1
    rx1957_cur."!mark_push"(0, rx1957_pos, $I10)
.annotate 'line', 1013
  # rx subrule "quote" subtype=capture negate=
    rx1957_cur."!cursor_pos"(rx1957_pos)
    $P10 = rx1957_cur."quote"()
    unless $P10, rx1957_fail
    rx1957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1957_pos = $P10."pos"()
    goto alt1959_end
  alt1959_1:
.annotate 'line', 1014
  # rx subrule "number" subtype=capture negate=
    rx1957_cur."!cursor_pos"(rx1957_pos)
    $P10 = rx1957_cur."number"()
    unless $P10, rx1957_fail
    rx1957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1957_pos = $P10."pos"()
  alt1959_end:
.annotate 'line', 1012
  # rx pass
    rx1957_cur."!cursor_pass"(rx1957_pos, "value")
    if_null rx1957_debug, debug_1385
    rx1957_cur."!cursor_debug"("PASS", "value", " at pos=", rx1957_pos)
  debug_1385:
    .return (rx1957_cur)
  rx1957_restart:
.annotate 'line', 440
    if_null rx1957_debug, debug_1386
    rx1957_cur."!cursor_debug"("NEXT", "value")
  debug_1386:
  rx1957_fail:
    (rx1957_rep, rx1957_pos, $I10, $P10) = rx1957_cur."!mark_fail"(0)
    lt rx1957_pos, -1, rx1957_done
    eq rx1957_pos, -1, rx1957_fail
    jump $I10
  rx1957_done:
    rx1957_cur."!cursor_fail"()
    if_null rx1957_debug, debug_1387
    rx1957_cur."!cursor_debug"("FAIL", "value")
  debug_1387:
    .return (rx1957_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("270_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("number", "")
    $P104 = self."!PREFIX__!subrule"("quote", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("271_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1962_tgt
    .local int rx1962_pos
    .local int rx1962_off
    .local int rx1962_eos
    .local int rx1962_rep
    .local pmc rx1962_cur
    .local pmc rx1962_debug
    (rx1962_cur, rx1962_pos, rx1962_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1962_cur
    .local pmc match
    .lex "$/", match
    length rx1962_eos, rx1962_tgt
    gt rx1962_pos, rx1962_eos, rx1962_done
    set rx1962_off, 0
    lt rx1962_pos, 2, rx1962_start
    sub rx1962_off, rx1962_pos, 1
    substr rx1962_tgt, rx1962_tgt, rx1962_off
  rx1962_start:
    eq $I10, 1, rx1962_restart
    if_null rx1962_debug, debug_1388
    rx1962_cur."!cursor_debug"("START", "number")
  debug_1388:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1963_done
    goto rxscan1963_scan
  rxscan1963_loop:
    (rx1962_pos) = rx1962_cur."from"()
    inc rx1962_pos
    rx1962_cur."!cursor_from"(rx1962_pos)
    ge rx1962_pos, rx1962_eos, rxscan1963_done
  rxscan1963_scan:
    set_addr $I10, rxscan1963_loop
    rx1962_cur."!mark_push"(0, rx1962_pos, $I10)
  rxscan1963_done:
.annotate 'line', 1018
  # rx subcapture "sign"
    set_addr $I10, rxcap_1965_fail
    rx1962_cur."!mark_push"(0, rx1962_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1962_pos, rx1962_off
    set rx1962_rep, 0
    sub $I12, rx1962_eos, rx1962_pos
    le $I12, 1, rxenumcharlistq1964_loop
    set $I12, 1
  rxenumcharlistq1964_loop:
    le $I12, 0, rxenumcharlistq1964_done
    substr $S10, rx1962_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1964_done
    inc rx1962_rep
  rxenumcharlistq1964_done:
    add rx1962_pos, rx1962_pos, rx1962_rep
    set_addr $I10, rxcap_1965_fail
    ($I12, $I11) = rx1962_cur."!mark_peek"($I10)
    rx1962_cur."!cursor_pos"($I11)
    ($P10) = rx1962_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1962_pos, "")
    rx1962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1965_done
  rxcap_1965_fail:
    goto rx1962_fail
  rxcap_1965_done:
  alt1966_0:
.annotate 'line', 1019
    set_addr $I10, alt1966_1
    rx1962_cur."!mark_push"(0, rx1962_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1962_cur."!cursor_pos"(rx1962_pos)
    $P10 = rx1962_cur."dec_number"()
    unless $P10, rx1962_fail
    rx1962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1962_pos = $P10."pos"()
    goto alt1966_end
  alt1966_1:
  # rx subrule "integer" subtype=capture negate=
    rx1962_cur."!cursor_pos"(rx1962_pos)
    $P10 = rx1962_cur."integer"()
    unless $P10, rx1962_fail
    rx1962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1962_pos = $P10."pos"()
  alt1966_end:
.annotate 'line', 1017
  # rx pass
    rx1962_cur."!cursor_pass"(rx1962_pos, "number")
    if_null rx1962_debug, debug_1389
    rx1962_cur."!cursor_debug"("PASS", "number", " at pos=", rx1962_pos)
  debug_1389:
    .return (rx1962_cur)
  rx1962_restart:
.annotate 'line', 440
    if_null rx1962_debug, debug_1390
    rx1962_cur."!cursor_debug"("NEXT", "number")
  debug_1390:
  rx1962_fail:
    (rx1962_rep, rx1962_pos, $I10, $P10) = rx1962_cur."!mark_fail"(0)
    lt rx1962_pos, -1, rx1962_done
    eq rx1962_pos, -1, rx1962_fail
    jump $I10
  rx1962_done:
    rx1962_cur."!cursor_fail"()
    if_null rx1962_debug, debug_1391
    rx1962_cur."!cursor_debug"("FAIL", "number")
  debug_1391:
    .return (rx1962_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("272_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("273_1312646121.678")
    .param pmc param_1969
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1022
    .lex "self", param_1969
    $P103 = param_1969."!protoregex"("quote")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("274_1312646121.678")
    .param pmc param_1971
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1022
    .lex "self", param_1971
    $P104 = param_1971."!PREFIX__!protoregex"("quote")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("275_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1973_tgt
    .local int rx1973_pos
    .local int rx1973_off
    .local int rx1973_eos
    .local int rx1973_rep
    .local pmc rx1973_cur
    .local pmc rx1973_debug
    (rx1973_cur, rx1973_pos, rx1973_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1973_cur
    .local pmc match
    .lex "$/", match
    length rx1973_eos, rx1973_tgt
    gt rx1973_pos, rx1973_eos, rx1973_done
    set rx1973_off, 0
    lt rx1973_pos, 2, rx1973_start
    sub rx1973_off, rx1973_pos, 1
    substr rx1973_tgt, rx1973_tgt, rx1973_off
  rx1973_start:
    eq $I10, 1, rx1973_restart
    if_null rx1973_debug, debug_1392
    rx1973_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1392:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1974_done
    goto rxscan1974_scan
  rxscan1974_loop:
    (rx1973_pos) = rx1973_cur."from"()
    inc rx1973_pos
    rx1973_cur."!cursor_from"(rx1973_pos)
    ge rx1973_pos, rx1973_eos, rxscan1974_done
  rxscan1974_scan:
    set_addr $I10, rxscan1974_loop
    rx1973_cur."!mark_push"(0, rx1973_pos, $I10)
  rxscan1974_done:
.annotate 'line', 1023
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1973_pos, rx1973_off
    substr $S10, rx1973_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1973_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1973_cur."!cursor_pos"(rx1973_pos)
    $P10 = rx1973_cur."quote_EXPR"(":q")
    unless $P10, rx1973_fail
    rx1973_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1973_pos = $P10."pos"()
  # rx pass
    rx1973_cur."!cursor_pass"(rx1973_pos, "quote:sym<apos>")
    if_null rx1973_debug, debug_1393
    rx1973_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1973_pos)
  debug_1393:
    .return (rx1973_cur)
  rx1973_restart:
.annotate 'line', 440
    if_null rx1973_debug, debug_1394
    rx1973_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1394:
  rx1973_fail:
    (rx1973_rep, rx1973_pos, $I10, $P10) = rx1973_cur."!mark_fail"(0)
    lt rx1973_pos, -1, rx1973_done
    eq rx1973_pos, -1, rx1973_fail
    jump $I10
  rx1973_done:
    rx1973_cur."!cursor_fail"()
    if_null rx1973_debug, debug_1395
    rx1973_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1395:
    .return (rx1973_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("276_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "'"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("277_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1977_tgt
    .local int rx1977_pos
    .local int rx1977_off
    .local int rx1977_eos
    .local int rx1977_rep
    .local pmc rx1977_cur
    .local pmc rx1977_debug
    (rx1977_cur, rx1977_pos, rx1977_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1977_cur
    .local pmc match
    .lex "$/", match
    length rx1977_eos, rx1977_tgt
    gt rx1977_pos, rx1977_eos, rx1977_done
    set rx1977_off, 0
    lt rx1977_pos, 2, rx1977_start
    sub rx1977_off, rx1977_pos, 1
    substr rx1977_tgt, rx1977_tgt, rx1977_off
  rx1977_start:
    eq $I10, 1, rx1977_restart
    if_null rx1977_debug, debug_1396
    rx1977_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1396:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1978_done
    goto rxscan1978_scan
  rxscan1978_loop:
    (rx1977_pos) = rx1977_cur."from"()
    inc rx1977_pos
    rx1977_cur."!cursor_from"(rx1977_pos)
    ge rx1977_pos, rx1977_eos, rxscan1978_done
  rxscan1978_scan:
    set_addr $I10, rxscan1978_loop
    rx1977_cur."!mark_push"(0, rx1977_pos, $I10)
  rxscan1978_done:
.annotate 'line', 1024
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1977_pos, rx1977_off
    substr $S10, rx1977_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1977_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1977_cur."!cursor_pos"(rx1977_pos)
    $P10 = rx1977_cur."quote_EXPR"(":qq")
    unless $P10, rx1977_fail
    rx1977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1977_pos = $P10."pos"()
  # rx pass
    rx1977_cur."!cursor_pass"(rx1977_pos, "quote:sym<dblq>")
    if_null rx1977_debug, debug_1397
    rx1977_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1977_pos)
  debug_1397:
    .return (rx1977_cur)
  rx1977_restart:
.annotate 'line', 440
    if_null rx1977_debug, debug_1398
    rx1977_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1398:
  rx1977_fail:
    (rx1977_rep, rx1977_pos, $I10, $P10) = rx1977_cur."!mark_fail"(0)
    lt rx1977_pos, -1, rx1977_done
    eq rx1977_pos, -1, rx1977_fail
    jump $I10
  rx1977_done:
    rx1977_cur."!cursor_fail"()
    if_null rx1977_debug, debug_1399
    rx1977_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1399:
    .return (rx1977_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("278_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "\""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("279_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1981_tgt
    .local int rx1981_pos
    .local int rx1981_off
    .local int rx1981_eos
    .local int rx1981_rep
    .local pmc rx1981_cur
    .local pmc rx1981_debug
    (rx1981_cur, rx1981_pos, rx1981_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1981_cur
    .local pmc match
    .lex "$/", match
    length rx1981_eos, rx1981_tgt
    gt rx1981_pos, rx1981_eos, rx1981_done
    set rx1981_off, 0
    lt rx1981_pos, 2, rx1981_start
    sub rx1981_off, rx1981_pos, 1
    substr rx1981_tgt, rx1981_tgt, rx1981_off
  rx1981_start:
    eq $I10, 1, rx1981_restart
    if_null rx1981_debug, debug_1400
    rx1981_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1400:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1982_done
    goto rxscan1982_scan
  rxscan1982_loop:
    (rx1981_pos) = rx1981_cur."from"()
    inc rx1981_pos
    rx1981_cur."!cursor_from"(rx1981_pos)
    ge rx1981_pos, rx1981_eos, rxscan1982_done
  rxscan1982_scan:
    set_addr $I10, rxscan1982_loop
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10)
  rxscan1982_done:
.annotate 'line', 1025
  # rx subcapture "sym"
    set_addr $I10, rxcap_1983_fail
    rx1981_cur."!mark_push"(0, rx1981_pos, $I10)
  # rx literal  "q"
    add $I11, rx1981_pos, 1
    gt $I11, rx1981_eos, rx1981_fail
    sub $I11, rx1981_pos, rx1981_off
    ord $I11, rx1981_tgt, $I11
    ne $I11, 113, rx1981_fail
    add rx1981_pos, 1
    set_addr $I10, rxcap_1983_fail
    ($I12, $I11) = rx1981_cur."!mark_peek"($I10)
    rx1981_cur."!cursor_pos"($I11)
    ($P10) = rx1981_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1981_pos, "")
    rx1981_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1983_done
  rxcap_1983_fail:
    goto rx1981_fail
  rxcap_1983_done:
  # rxanchor rwb
    le rx1981_pos, 0, rx1981_fail
    sub $I10, rx1981_pos, rx1981_off
    is_cclass $I11, .CCLASS_WORD, rx1981_tgt, $I10
    if $I11, rx1981_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1981_tgt, $I10
    unless $I11, rx1981_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1981_pos, rx1981_off
    substr $S10, rx1981_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1981_fail
  # rx subrule "ws" subtype=method negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."ws"()
    unless $P10, rx1981_fail
    rx1981_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1981_cur."!cursor_pos"(rx1981_pos)
    $P10 = rx1981_cur."quote_EXPR"(":q")
    unless $P10, rx1981_fail
    rx1981_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1981_pos = $P10."pos"()
  # rx pass
    rx1981_cur."!cursor_pass"(rx1981_pos, "quote:sym<q>")
    if_null rx1981_debug, debug_1401
    rx1981_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1981_pos)
  debug_1401:
    .return (rx1981_cur)
  rx1981_restart:
.annotate 'line', 440
    if_null rx1981_debug, debug_1402
    rx1981_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1402:
  rx1981_fail:
    (rx1981_rep, rx1981_pos, $I10, $P10) = rx1981_cur."!mark_fail"(0)
    lt rx1981_pos, -1, rx1981_done
    eq rx1981_pos, -1, rx1981_fail
    jump $I10
  rx1981_done:
    rx1981_cur."!cursor_fail"()
    if_null rx1981_debug, debug_1403
    rx1981_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1403:
    .return (rx1981_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("280_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("281_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1986_tgt
    .local int rx1986_pos
    .local int rx1986_off
    .local int rx1986_eos
    .local int rx1986_rep
    .local pmc rx1986_cur
    .local pmc rx1986_debug
    (rx1986_cur, rx1986_pos, rx1986_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1986_cur
    .local pmc match
    .lex "$/", match
    length rx1986_eos, rx1986_tgt
    gt rx1986_pos, rx1986_eos, rx1986_done
    set rx1986_off, 0
    lt rx1986_pos, 2, rx1986_start
    sub rx1986_off, rx1986_pos, 1
    substr rx1986_tgt, rx1986_tgt, rx1986_off
  rx1986_start:
    eq $I10, 1, rx1986_restart
    if_null rx1986_debug, debug_1404
    rx1986_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1404:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1987_done
    goto rxscan1987_scan
  rxscan1987_loop:
    (rx1986_pos) = rx1986_cur."from"()
    inc rx1986_pos
    rx1986_cur."!cursor_from"(rx1986_pos)
    ge rx1986_pos, rx1986_eos, rxscan1987_done
  rxscan1987_scan:
    set_addr $I10, rxscan1987_loop
    rx1986_cur."!mark_push"(0, rx1986_pos, $I10)
  rxscan1987_done:
.annotate 'line', 1026
  # rx subcapture "sym"
    set_addr $I10, rxcap_1988_fail
    rx1986_cur."!mark_push"(0, rx1986_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1986_pos, 2
    gt $I11, rx1986_eos, rx1986_fail
    sub $I11, rx1986_pos, rx1986_off
    substr $S10, rx1986_tgt, $I11, 2
    ne $S10, "qq", rx1986_fail
    add rx1986_pos, 2
    set_addr $I10, rxcap_1988_fail
    ($I12, $I11) = rx1986_cur."!mark_peek"($I10)
    rx1986_cur."!cursor_pos"($I11)
    ($P10) = rx1986_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1986_pos, "")
    rx1986_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1988_done
  rxcap_1988_fail:
    goto rx1986_fail
  rxcap_1988_done:
  # rxanchor rwb
    le rx1986_pos, 0, rx1986_fail
    sub $I10, rx1986_pos, rx1986_off
    is_cclass $I11, .CCLASS_WORD, rx1986_tgt, $I10
    if $I11, rx1986_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1986_tgt, $I10
    unless $I11, rx1986_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1986_pos, rx1986_off
    substr $S10, rx1986_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1986_fail
  # rx subrule "ws" subtype=method negate=
    rx1986_cur."!cursor_pos"(rx1986_pos)
    $P10 = rx1986_cur."ws"()
    unless $P10, rx1986_fail
    rx1986_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1986_cur."!cursor_pos"(rx1986_pos)
    $P10 = rx1986_cur."quote_EXPR"(":qq")
    unless $P10, rx1986_fail
    rx1986_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1986_pos = $P10."pos"()
  # rx pass
    rx1986_cur."!cursor_pass"(rx1986_pos, "quote:sym<qq>")
    if_null rx1986_debug, debug_1405
    rx1986_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1986_pos)
  debug_1405:
    .return (rx1986_cur)
  rx1986_restart:
.annotate 'line', 440
    if_null rx1986_debug, debug_1406
    rx1986_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1406:
  rx1986_fail:
    (rx1986_rep, rx1986_pos, $I10, $P10) = rx1986_cur."!mark_fail"(0)
    lt rx1986_pos, -1, rx1986_done
    eq rx1986_pos, -1, rx1986_fail
    jump $I10
  rx1986_done:
    rx1986_cur."!cursor_fail"()
    if_null rx1986_debug, debug_1407
    rx1986_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1407:
    .return (rx1986_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("282_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "qq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("283_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1991_tgt
    .local int rx1991_pos
    .local int rx1991_off
    .local int rx1991_eos
    .local int rx1991_rep
    .local pmc rx1991_cur
    .local pmc rx1991_debug
    (rx1991_cur, rx1991_pos, rx1991_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1991_cur
    .local pmc match
    .lex "$/", match
    length rx1991_eos, rx1991_tgt
    gt rx1991_pos, rx1991_eos, rx1991_done
    set rx1991_off, 0
    lt rx1991_pos, 2, rx1991_start
    sub rx1991_off, rx1991_pos, 1
    substr rx1991_tgt, rx1991_tgt, rx1991_off
  rx1991_start:
    eq $I10, 1, rx1991_restart
    if_null rx1991_debug, debug_1408
    rx1991_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1408:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1992_done
    goto rxscan1992_scan
  rxscan1992_loop:
    (rx1991_pos) = rx1991_cur."from"()
    inc rx1991_pos
    rx1991_cur."!cursor_from"(rx1991_pos)
    ge rx1991_pos, rx1991_eos, rxscan1992_done
  rxscan1992_scan:
    set_addr $I10, rxscan1992_loop
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  rxscan1992_done:
.annotate 'line', 1027
  # rx subcapture "sym"
    set_addr $I10, rxcap_1993_fail
    rx1991_cur."!mark_push"(0, rx1991_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1991_pos, 1
    gt $I11, rx1991_eos, rx1991_fail
    sub $I11, rx1991_pos, rx1991_off
    ord $I11, rx1991_tgt, $I11
    ne $I11, 81, rx1991_fail
    add rx1991_pos, 1
    set_addr $I10, rxcap_1993_fail
    ($I12, $I11) = rx1991_cur."!mark_peek"($I10)
    rx1991_cur."!cursor_pos"($I11)
    ($P10) = rx1991_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1991_pos, "")
    rx1991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1993_done
  rxcap_1993_fail:
    goto rx1991_fail
  rxcap_1993_done:
  # rxanchor rwb
    le rx1991_pos, 0, rx1991_fail
    sub $I10, rx1991_pos, rx1991_off
    is_cclass $I11, .CCLASS_WORD, rx1991_tgt, $I10
    if $I11, rx1991_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1991_tgt, $I10
    unless $I11, rx1991_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1991_pos, rx1991_off
    substr $S10, rx1991_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1991_fail
  # rx subrule "ws" subtype=method negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."ws"()
    unless $P10, rx1991_fail
    rx1991_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1991_cur."!cursor_pos"(rx1991_pos)
    $P10 = rx1991_cur."quote_EXPR"()
    unless $P10, rx1991_fail
    rx1991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1991_pos = $P10."pos"()
  # rx pass
    rx1991_cur."!cursor_pass"(rx1991_pos, "quote:sym<Q>")
    if_null rx1991_debug, debug_1409
    rx1991_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1991_pos)
  debug_1409:
    .return (rx1991_cur)
  rx1991_restart:
.annotate 'line', 440
    if_null rx1991_debug, debug_1410
    rx1991_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1410:
  rx1991_fail:
    (rx1991_rep, rx1991_pos, $I10, $P10) = rx1991_cur."!mark_fail"(0)
    lt rx1991_pos, -1, rx1991_done
    eq rx1991_pos, -1, rx1991_fail
    jump $I10
  rx1991_done:
    rx1991_cur."!cursor_fail"()
    if_null rx1991_debug, debug_1411
    rx1991_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1411:
    .return (rx1991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("284_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "Q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("285_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx1996_tgt
    .local int rx1996_pos
    .local int rx1996_off
    .local int rx1996_eos
    .local int rx1996_rep
    .local pmc rx1996_cur
    .local pmc rx1996_debug
    (rx1996_cur, rx1996_pos, rx1996_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1996_cur
    .local pmc match
    .lex "$/", match
    length rx1996_eos, rx1996_tgt
    gt rx1996_pos, rx1996_eos, rx1996_done
    set rx1996_off, 0
    lt rx1996_pos, 2, rx1996_start
    sub rx1996_off, rx1996_pos, 1
    substr rx1996_tgt, rx1996_tgt, rx1996_off
  rx1996_start:
    eq $I10, 1, rx1996_restart
    if_null rx1996_debug, debug_1412
    rx1996_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1412:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1997_done
    goto rxscan1997_scan
  rxscan1997_loop:
    (rx1996_pos) = rx1996_cur."from"()
    inc rx1996_pos
    rx1996_cur."!cursor_from"(rx1996_pos)
    ge rx1996_pos, rx1996_eos, rxscan1997_done
  rxscan1997_scan:
    set_addr $I10, rxscan1997_loop
    rx1996_cur."!mark_push"(0, rx1996_pos, $I10)
  rxscan1997_done:
.annotate 'line', 1028
  # rx subcapture "sym"
    set_addr $I10, rxcap_1998_fail
    rx1996_cur."!mark_push"(0, rx1996_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1996_pos, 5
    gt $I11, rx1996_eos, rx1996_fail
    sub $I11, rx1996_pos, rx1996_off
    substr $S10, rx1996_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1996_fail
    add rx1996_pos, 5
    set_addr $I10, rxcap_1998_fail
    ($I12, $I11) = rx1996_cur."!mark_peek"($I10)
    rx1996_cur."!cursor_pos"($I11)
    ($P10) = rx1996_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1996_pos, "")
    rx1996_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1998_done
  rxcap_1998_fail:
    goto rx1996_fail
  rxcap_1998_done:
  # rx subrule "ws" subtype=method negate=
    rx1996_cur."!cursor_pos"(rx1996_pos)
    $P10 = rx1996_cur."ws"()
    unless $P10, rx1996_fail
    rx1996_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1996_cur."!cursor_pos"(rx1996_pos)
    $P10 = rx1996_cur."quote_EXPR"()
    unless $P10, rx1996_fail
    rx1996_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1996_pos = $P10."pos"()
  # rx pass
    rx1996_cur."!cursor_pass"(rx1996_pos, "quote:sym<Q:PIR>")
    if_null rx1996_debug, debug_1413
    rx1996_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1996_pos)
  debug_1413:
    .return (rx1996_cur)
  rx1996_restart:
.annotate 'line', 440
    if_null rx1996_debug, debug_1414
    rx1996_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1414:
  rx1996_fail:
    (rx1996_rep, rx1996_pos, $I10, $P10) = rx1996_cur."!mark_fail"(0)
    lt rx1996_pos, -1, rx1996_done
    eq rx1996_pos, -1, rx1996_fail
    jump $I10
  rx1996_done:
    rx1996_cur."!cursor_fail"()
    if_null rx1996_debug, debug_1415
    rx1996_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1415:
    .return (rx1996_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("286_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("287_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2001_tgt
    .local int rx2001_pos
    .local int rx2001_off
    .local int rx2001_eos
    .local int rx2001_rep
    .local pmc rx2001_cur
    .local pmc rx2001_debug
    (rx2001_cur, rx2001_pos, rx2001_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2001_cur
    .local pmc match
    .lex "$/", match
    length rx2001_eos, rx2001_tgt
    gt rx2001_pos, rx2001_eos, rx2001_done
    set rx2001_off, 0
    lt rx2001_pos, 2, rx2001_start
    sub rx2001_off, rx2001_pos, 1
    substr rx2001_tgt, rx2001_tgt, rx2001_off
  rx2001_start:
    eq $I10, 1, rx2001_restart
    if_null rx2001_debug, debug_1416
    rx2001_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1416:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2002_done
    goto rxscan2002_scan
  rxscan2002_loop:
    (rx2001_pos) = rx2001_cur."from"()
    inc rx2001_pos
    rx2001_cur."!cursor_from"(rx2001_pos)
    ge rx2001_pos, rx2001_eos, rxscan2002_done
  rxscan2002_scan:
    set_addr $I10, rxscan2002_loop
    rx2001_cur."!mark_push"(0, rx2001_pos, $I10)
  rxscan2002_done:
.annotate 'line', 1030
  # rx literal  "/"
    add $I11, rx2001_pos, 1
    gt $I11, rx2001_eos, rx2001_fail
    sub $I11, rx2001_pos, rx2001_off
    ord $I11, rx2001_tgt, $I11
    ne $I11, 47, rx2001_fail
    add rx2001_pos, 1
.annotate 'line', 1031
  # rx subrule "newpad" subtype=method negate=
    rx2001_cur."!cursor_pos"(rx2001_pos)
    $P10 = rx2001_cur."newpad"()
    unless $P10, rx2001_fail
    rx2001_pos = $P10."pos"()
.annotate 'line', 1032
  # rx reduce name="quote:sym</ />" key="open"
    rx2001_cur."!cursor_pos"(rx2001_pos)
    rx2001_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1033
  # rx subrule "LANG" subtype=capture negate=
    rx2001_cur."!cursor_pos"(rx2001_pos)
    $P10 = rx2001_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2001_fail
    rx2001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2001_pos = $P10."pos"()
.annotate 'line', 1034
  # rx literal  "/"
    add $I11, rx2001_pos, 1
    gt $I11, rx2001_eos, rx2001_fail
    sub $I11, rx2001_pos, rx2001_off
    ord $I11, rx2001_tgt, $I11
    ne $I11, 47, rx2001_fail
    add rx2001_pos, 1
.annotate 'line', 1029
  # rx pass
    rx2001_cur."!cursor_pass"(rx2001_pos, "quote:sym</ />")
    if_null rx2001_debug, debug_1417
    rx2001_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2001_pos)
  debug_1417:
    .return (rx2001_cur)
  rx2001_restart:
.annotate 'line', 440
    if_null rx2001_debug, debug_1418
    rx2001_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1418:
  rx2001_fail:
    (rx2001_rep, rx2001_pos, $I10, $P10) = rx2001_cur."!mark_fail"(0)
    lt rx2001_pos, -1, rx2001_done
    eq rx2001_pos, -1, rx2001_fail
    jump $I10
  rx2001_done:
    rx2001_cur."!cursor_fail"()
    if_null rx2001_debug, debug_1419
    rx2001_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1419:
    .return (rx2001_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("288_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("newpad", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("289_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2005_tgt
    .local int rx2005_pos
    .local int rx2005_off
    .local int rx2005_eos
    .local int rx2005_rep
    .local pmc rx2005_cur
    .local pmc rx2005_debug
    (rx2005_cur, rx2005_pos, rx2005_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2005_cur
    .local pmc match
    .lex "$/", match
    length rx2005_eos, rx2005_tgt
    gt rx2005_pos, rx2005_eos, rx2005_done
    set rx2005_off, 0
    lt rx2005_pos, 2, rx2005_start
    sub rx2005_off, rx2005_pos, 1
    substr rx2005_tgt, rx2005_tgt, rx2005_off
  rx2005_start:
    eq $I10, 1, rx2005_restart
    if_null rx2005_debug, debug_1420
    rx2005_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1420:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2006_done
    goto rxscan2006_scan
  rxscan2006_loop:
    (rx2005_pos) = rx2005_cur."from"()
    inc rx2005_pos
    rx2005_cur."!cursor_from"(rx2005_pos)
    ge rx2005_pos, rx2005_eos, rxscan2006_done
  rxscan2006_scan:
    set_addr $I10, rxscan2006_loop
    rx2005_cur."!mark_push"(0, rx2005_pos, $I10)
  rxscan2006_done:
.annotate 'line', 1037
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2005_pos, rx2005_off
    substr $S10, rx2005_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2005_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2005_cur."!cursor_pos"(rx2005_pos)
    $P10 = rx2005_cur."quotemod_check"("s")
    unless $P10, rx2005_fail
  # rx subrule "variable" subtype=capture negate=
    rx2005_cur."!cursor_pos"(rx2005_pos)
    $P10 = rx2005_cur."variable"()
    unless $P10, rx2005_fail
    rx2005_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2005_pos = $P10."pos"()
  # rx pass
    rx2005_cur."!cursor_pass"(rx2005_pos, "quote_escape:sym<$>")
    if_null rx2005_debug, debug_1421
    rx2005_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2005_pos)
  debug_1421:
    .return (rx2005_cur)
  rx2005_restart:
.annotate 'line', 440
    if_null rx2005_debug, debug_1422
    rx2005_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1422:
  rx2005_fail:
    (rx2005_rep, rx2005_pos, $I10, $P10) = rx2005_cur."!mark_fail"(0)
    lt rx2005_pos, -1, rx2005_done
    eq rx2005_pos, -1, rx2005_fail
    jump $I10
  rx2005_done:
    rx2005_cur."!cursor_fail"()
    if_null rx2005_debug, debug_1423
    rx2005_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1423:
    .return (rx2005_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("290_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("291_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2009_tgt
    .local int rx2009_pos
    .local int rx2009_off
    .local int rx2009_eos
    .local int rx2009_rep
    .local pmc rx2009_cur
    .local pmc rx2009_debug
    (rx2009_cur, rx2009_pos, rx2009_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2009_cur
    .local pmc match
    .lex "$/", match
    length rx2009_eos, rx2009_tgt
    gt rx2009_pos, rx2009_eos, rx2009_done
    set rx2009_off, 0
    lt rx2009_pos, 2, rx2009_start
    sub rx2009_off, rx2009_pos, 1
    substr rx2009_tgt, rx2009_tgt, rx2009_off
  rx2009_start:
    eq $I10, 1, rx2009_restart
    if_null rx2009_debug, debug_1424
    rx2009_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1424:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2010_done
    goto rxscan2010_scan
  rxscan2010_loop:
    (rx2009_pos) = rx2009_cur."from"()
    inc rx2009_pos
    rx2009_cur."!cursor_from"(rx2009_pos)
    ge rx2009_pos, rx2009_eos, rxscan2010_done
  rxscan2010_scan:
    set_addr $I10, rxscan2010_loop
    rx2009_cur."!mark_push"(0, rx2009_pos, $I10)
  rxscan2010_done:
.annotate 'line', 1038
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2009_pos, rx2009_off
    substr $S10, rx2009_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2009_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2009_cur."!cursor_pos"(rx2009_pos)
    $P10 = rx2009_cur."quotemod_check"("c")
    unless $P10, rx2009_fail
  # rx subrule "block" subtype=capture negate=
    rx2009_cur."!cursor_pos"(rx2009_pos)
    $P10 = rx2009_cur."block"()
    unless $P10, rx2009_fail
    rx2009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2009_pos = $P10."pos"()
  # rx pass
    rx2009_cur."!cursor_pass"(rx2009_pos, "quote_escape:sym<{ }>")
    if_null rx2009_debug, debug_1425
    rx2009_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2009_pos)
  debug_1425:
    .return (rx2009_cur)
  rx2009_restart:
.annotate 'line', 440
    if_null rx2009_debug, debug_1426
    rx2009_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1426:
  rx2009_fail:
    (rx2009_rep, rx2009_pos, $I10, $P10) = rx2009_cur."!mark_fail"(0)
    lt rx2009_pos, -1, rx2009_done
    eq rx2009_pos, -1, rx2009_fail
    jump $I10
  rx2009_done:
    rx2009_cur."!cursor_fail"()
    if_null rx2009_debug, debug_1427
    rx2009_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1427:
    .return (rx2009_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("292_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("293_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2013_tgt
    .local int rx2013_pos
    .local int rx2013_off
    .local int rx2013_eos
    .local int rx2013_rep
    .local pmc rx2013_cur
    .local pmc rx2013_debug
    (rx2013_cur, rx2013_pos, rx2013_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2013_cur
    .local pmc match
    .lex "$/", match
    length rx2013_eos, rx2013_tgt
    gt rx2013_pos, rx2013_eos, rx2013_done
    set rx2013_off, 0
    lt rx2013_pos, 2, rx2013_start
    sub rx2013_off, rx2013_pos, 1
    substr rx2013_tgt, rx2013_tgt, rx2013_off
  rx2013_start:
    eq $I10, 1, rx2013_restart
    if_null rx2013_debug, debug_1428
    rx2013_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1428:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2014_done
    goto rxscan2014_scan
  rxscan2014_loop:
    (rx2013_pos) = rx2013_cur."from"()
    inc rx2013_pos
    rx2013_cur."!cursor_from"(rx2013_pos)
    ge rx2013_pos, rx2013_eos, rxscan2014_done
  rxscan2014_scan:
    set_addr $I10, rxscan2014_loop
    rx2013_cur."!mark_push"(0, rx2013_pos, $I10)
  rxscan2014_done:
.annotate 'line', 1039
  # rx literal  "\\e"
    add $I11, rx2013_pos, 2
    gt $I11, rx2013_eos, rx2013_fail
    sub $I11, rx2013_pos, rx2013_off
    substr $S10, rx2013_tgt, $I11, 2
    ne $S10, "\\e", rx2013_fail
    add rx2013_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2013_cur."!cursor_pos"(rx2013_pos)
    $P10 = rx2013_cur."quotemod_check"("b")
    unless $P10, rx2013_fail
  # rx pass
    rx2013_cur."!cursor_pass"(rx2013_pos, "quote_escape:sym<esc>")
    if_null rx2013_debug, debug_1429
    rx2013_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2013_pos)
  debug_1429:
    .return (rx2013_cur)
  rx2013_restart:
.annotate 'line', 440
    if_null rx2013_debug, debug_1430
    rx2013_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1430:
  rx2013_fail:
    (rx2013_rep, rx2013_pos, $I10, $P10) = rx2013_cur."!mark_fail"(0)
    lt rx2013_pos, -1, rx2013_done
    eq rx2013_pos, -1, rx2013_fail
    jump $I10
  rx2013_done:
    rx2013_cur."!cursor_fail"()
    if_null rx2013_debug, debug_1431
    rx2013_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1431:
    .return (rx2013_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("294_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "\\e"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("295_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2017_tgt
    .local int rx2017_pos
    .local int rx2017_off
    .local int rx2017_eos
    .local int rx2017_rep
    .local pmc rx2017_cur
    .local pmc rx2017_debug
    (rx2017_cur, rx2017_pos, rx2017_tgt, $I10) = self."!cursor_start"()
    rx2017_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2017_cur
    .local pmc match
    .lex "$/", match
    length rx2017_eos, rx2017_tgt
    gt rx2017_pos, rx2017_eos, rx2017_done
    set rx2017_off, 0
    lt rx2017_pos, 2, rx2017_start
    sub rx2017_off, rx2017_pos, 1
    substr rx2017_tgt, rx2017_tgt, rx2017_off
  rx2017_start:
    eq $I10, 1, rx2017_restart
    if_null rx2017_debug, debug_1432
    rx2017_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2018_done
    goto rxscan2018_scan
  rxscan2018_loop:
    (rx2017_pos) = rx2017_cur."from"()
    inc rx2017_pos
    rx2017_cur."!cursor_from"(rx2017_pos)
    ge rx2017_pos, rx2017_eos, rxscan2018_done
  rxscan2018_scan:
    set_addr $I10, rxscan2018_loop
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  rxscan2018_done:
.annotate 'line', 1041
  # rx literal  "("
    add $I11, rx2017_pos, 1
    gt $I11, rx2017_eos, rx2017_fail
    sub $I11, rx2017_pos, rx2017_off
    ord $I11, rx2017_tgt, $I11
    ne $I11, 40, rx2017_fail
    add rx2017_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2017_cur."!cursor_pos"(rx2017_pos)
    $P10 = rx2017_cur."ws"()
    unless $P10, rx2017_fail
    rx2017_pos = $P10."pos"()
  # rx rxquantr2019 ** 0..1
    set_addr $I10, rxquantr2019_done
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  rxquantr2019_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2017_cur."!cursor_pos"(rx2017_pos)
    $P10 = rx2017_cur."EXPR"()
    unless $P10, rx2017_fail
    goto rxsubrule2020_pass
  rxsubrule2020_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2017_fail
  rxsubrule2020_pass:
    set_addr $I10, rxsubrule2020_back
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2017_pos = $P10."pos"()
    set_addr $I10, rxquantr2019_done
    (rx2017_rep) = rx2017_cur."!mark_commit"($I10)
  rxquantr2019_done:
  # rx literal  ")"
    add $I11, rx2017_pos, 1
    gt $I11, rx2017_eos, rx2017_fail
    sub $I11, rx2017_pos, rx2017_off
    ord $I11, rx2017_tgt, $I11
    ne $I11, 41, rx2017_fail
    add rx2017_pos, 1
  # rx pass
    rx2017_cur."!cursor_pass"(rx2017_pos, "circumfix:sym<( )>")
    if_null rx2017_debug, debug_1433
    rx2017_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2017_pos)
  debug_1433:
    .return (rx2017_cur)
  rx2017_restart:
.annotate 'line', 440
    if_null rx2017_debug, debug_1434
    rx2017_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1434:
  rx2017_fail:
    (rx2017_rep, rx2017_pos, $I10, $P10) = rx2017_cur."!mark_fail"(0)
    lt rx2017_pos, -1, rx2017_done
    eq rx2017_pos, -1, rx2017_fail
    jump $I10
  rx2017_done:
    rx2017_cur."!cursor_fail"()
    if_null rx2017_debug, debug_1435
    rx2017_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1435:
    .return (rx2017_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("296_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("297_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2023_tgt
    .local int rx2023_pos
    .local int rx2023_off
    .local int rx2023_eos
    .local int rx2023_rep
    .local pmc rx2023_cur
    .local pmc rx2023_debug
    (rx2023_cur, rx2023_pos, rx2023_tgt, $I10) = self."!cursor_start"()
    rx2023_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2023_cur
    .local pmc match
    .lex "$/", match
    length rx2023_eos, rx2023_tgt
    gt rx2023_pos, rx2023_eos, rx2023_done
    set rx2023_off, 0
    lt rx2023_pos, 2, rx2023_start
    sub rx2023_off, rx2023_pos, 1
    substr rx2023_tgt, rx2023_tgt, rx2023_off
  rx2023_start:
    eq $I10, 1, rx2023_restart
    if_null rx2023_debug, debug_1436
    rx2023_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1436:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2024_done
    goto rxscan2024_scan
  rxscan2024_loop:
    (rx2023_pos) = rx2023_cur."from"()
    inc rx2023_pos
    rx2023_cur."!cursor_from"(rx2023_pos)
    ge rx2023_pos, rx2023_eos, rxscan2024_done
  rxscan2024_scan:
    set_addr $I10, rxscan2024_loop
    rx2023_cur."!mark_push"(0, rx2023_pos, $I10)
  rxscan2024_done:
.annotate 'line', 1042
  # rx literal  "["
    add $I11, rx2023_pos, 1
    gt $I11, rx2023_eos, rx2023_fail
    sub $I11, rx2023_pos, rx2023_off
    ord $I11, rx2023_tgt, $I11
    ne $I11, 91, rx2023_fail
    add rx2023_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2023_cur."!cursor_pos"(rx2023_pos)
    $P10 = rx2023_cur."ws"()
    unless $P10, rx2023_fail
    rx2023_pos = $P10."pos"()
  # rx rxquantr2025 ** 0..1
    set_addr $I10, rxquantr2025_done
    rx2023_cur."!mark_push"(0, rx2023_pos, $I10)
  rxquantr2025_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2023_cur."!cursor_pos"(rx2023_pos)
    $P10 = rx2023_cur."EXPR"()
    unless $P10, rx2023_fail
    goto rxsubrule2026_pass
  rxsubrule2026_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2023_fail
  rxsubrule2026_pass:
    set_addr $I10, rxsubrule2026_back
    rx2023_cur."!mark_push"(0, rx2023_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2023_pos = $P10."pos"()
    set_addr $I10, rxquantr2025_done
    (rx2023_rep) = rx2023_cur."!mark_commit"($I10)
  rxquantr2025_done:
  # rx literal  "]"
    add $I11, rx2023_pos, 1
    gt $I11, rx2023_eos, rx2023_fail
    sub $I11, rx2023_pos, rx2023_off
    ord $I11, rx2023_tgt, $I11
    ne $I11, 93, rx2023_fail
    add rx2023_pos, 1
  # rx pass
    rx2023_cur."!cursor_pass"(rx2023_pos, "circumfix:sym<[ ]>")
    if_null rx2023_debug, debug_1437
    rx2023_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2023_pos)
  debug_1437:
    .return (rx2023_cur)
  rx2023_restart:
.annotate 'line', 440
    if_null rx2023_debug, debug_1438
    rx2023_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1438:
  rx2023_fail:
    (rx2023_rep, rx2023_pos, $I10, $P10) = rx2023_cur."!mark_fail"(0)
    lt rx2023_pos, -1, rx2023_done
    eq rx2023_pos, -1, rx2023_fail
    jump $I10
  rx2023_done:
    rx2023_cur."!cursor_fail"()
    if_null rx2023_debug, debug_1439
    rx2023_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1439:
    .return (rx2023_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("298_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("299_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2029_tgt
    .local int rx2029_pos
    .local int rx2029_off
    .local int rx2029_eos
    .local int rx2029_rep
    .local pmc rx2029_cur
    .local pmc rx2029_debug
    (rx2029_cur, rx2029_pos, rx2029_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2029_cur
    .local pmc match
    .lex "$/", match
    length rx2029_eos, rx2029_tgt
    gt rx2029_pos, rx2029_eos, rx2029_done
    set rx2029_off, 0
    lt rx2029_pos, 2, rx2029_start
    sub rx2029_off, rx2029_pos, 1
    substr rx2029_tgt, rx2029_tgt, rx2029_off
  rx2029_start:
    eq $I10, 1, rx2029_restart
    if_null rx2029_debug, debug_1440
    rx2029_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2030_done
    goto rxscan2030_scan
  rxscan2030_loop:
    (rx2029_pos) = rx2029_cur."from"()
    inc rx2029_pos
    rx2029_cur."!cursor_from"(rx2029_pos)
    ge rx2029_pos, rx2029_eos, rxscan2030_done
  rxscan2030_scan:
    set_addr $I10, rxscan2030_loop
    rx2029_cur."!mark_push"(0, rx2029_pos, $I10)
  rxscan2030_done:
.annotate 'line', 1043
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2029_pos, rx2029_off
    substr $S10, rx2029_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2029_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2029_cur."!cursor_pos"(rx2029_pos)
    $P10 = rx2029_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2029_fail
    rx2029_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2029_pos = $P10."pos"()
  # rx pass
    rx2029_cur."!cursor_pass"(rx2029_pos, "circumfix:sym<ang>")
    if_null rx2029_debug, debug_1441
    rx2029_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2029_pos)
  debug_1441:
    .return (rx2029_cur)
  rx2029_restart:
.annotate 'line', 440
    if_null rx2029_debug, debug_1442
    rx2029_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1442:
  rx2029_fail:
    (rx2029_rep, rx2029_pos, $I10, $P10) = rx2029_cur."!mark_fail"(0)
    lt rx2029_pos, -1, rx2029_done
    eq rx2029_pos, -1, rx2029_fail
    jump $I10
  rx2029_done:
    rx2029_cur."!cursor_fail"()
    if_null rx2029_debug, debug_1443
    rx2029_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1443:
    .return (rx2029_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("300_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("301_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2033_tgt
    .local int rx2033_pos
    .local int rx2033_off
    .local int rx2033_eos
    .local int rx2033_rep
    .local pmc rx2033_cur
    .local pmc rx2033_debug
    (rx2033_cur, rx2033_pos, rx2033_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2033_cur
    .local pmc match
    .lex "$/", match
    length rx2033_eos, rx2033_tgt
    gt rx2033_pos, rx2033_eos, rx2033_done
    set rx2033_off, 0
    lt rx2033_pos, 2, rx2033_start
    sub rx2033_off, rx2033_pos, 1
    substr rx2033_tgt, rx2033_tgt, rx2033_off
  rx2033_start:
    eq $I10, 1, rx2033_restart
    if_null rx2033_debug, debug_1444
    rx2033_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1444:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2034_done
    goto rxscan2034_scan
  rxscan2034_loop:
    (rx2033_pos) = rx2033_cur."from"()
    inc rx2033_pos
    rx2033_cur."!cursor_from"(rx2033_pos)
    ge rx2033_pos, rx2033_eos, rxscan2034_done
  rxscan2034_scan:
    set_addr $I10, rxscan2034_loop
    rx2033_cur."!mark_push"(0, rx2033_pos, $I10)
  rxscan2034_done:
.annotate 'line', 1044
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2033_pos, rx2033_off
    substr $S10, rx2033_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2033_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2033_cur."!cursor_pos"(rx2033_pos)
    $P10 = rx2033_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2033_fail
    rx2033_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2033_pos = $P10."pos"()
  # rx pass
    rx2033_cur."!cursor_pass"(rx2033_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2033_debug, debug_1445
    rx2033_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2033_pos)
  debug_1445:
    .return (rx2033_cur)
  rx2033_restart:
.annotate 'line', 440
    if_null rx2033_debug, debug_1446
    rx2033_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1446:
  rx2033_fail:
    (rx2033_rep, rx2033_pos, $I10, $P10) = rx2033_cur."!mark_fail"(0)
    lt rx2033_pos, -1, rx2033_done
    eq rx2033_pos, -1, rx2033_fail
    jump $I10
  rx2033_done:
    rx2033_cur."!cursor_fail"()
    if_null rx2033_debug, debug_1447
    rx2033_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1447:
    .return (rx2033_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("302_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, unicode:"\x{ab}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("303_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2037_tgt
    .local int rx2037_pos
    .local int rx2037_off
    .local int rx2037_eos
    .local int rx2037_rep
    .local pmc rx2037_cur
    .local pmc rx2037_debug
    (rx2037_cur, rx2037_pos, rx2037_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2037_cur
    .local pmc match
    .lex "$/", match
    length rx2037_eos, rx2037_tgt
    gt rx2037_pos, rx2037_eos, rx2037_done
    set rx2037_off, 0
    lt rx2037_pos, 2, rx2037_start
    sub rx2037_off, rx2037_pos, 1
    substr rx2037_tgt, rx2037_tgt, rx2037_off
  rx2037_start:
    eq $I10, 1, rx2037_restart
    if_null rx2037_debug, debug_1448
    rx2037_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2038_done
    goto rxscan2038_scan
  rxscan2038_loop:
    (rx2037_pos) = rx2037_cur."from"()
    inc rx2037_pos
    rx2037_cur."!cursor_from"(rx2037_pos)
    ge rx2037_pos, rx2037_eos, rxscan2038_done
  rxscan2038_scan:
    set_addr $I10, rxscan2038_loop
    rx2037_cur."!mark_push"(0, rx2037_pos, $I10)
  rxscan2038_done:
.annotate 'line', 1045
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2037_pos, rx2037_off
    substr $S10, rx2037_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2037_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2037_cur."!cursor_pos"(rx2037_pos)
    $P10 = rx2037_cur."pblock"()
    unless $P10, rx2037_fail
    rx2037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2037_pos = $P10."pos"()
  # rx pass
    rx2037_cur."!cursor_pass"(rx2037_pos, "circumfix:sym<{ }>")
    if_null rx2037_debug, debug_1449
    rx2037_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2037_pos)
  debug_1449:
    .return (rx2037_cur)
  rx2037_restart:
.annotate 'line', 440
    if_null rx2037_debug, debug_1450
    rx2037_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1450:
  rx2037_fail:
    (rx2037_rep, rx2037_pos, $I10, $P10) = rx2037_cur."!mark_fail"(0)
    lt rx2037_pos, -1, rx2037_done
    eq rx2037_pos, -1, rx2037_fail
    jump $I10
  rx2037_done:
    rx2037_cur."!cursor_fail"()
    if_null rx2037_debug, debug_1451
    rx2037_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1451:
    .return (rx2037_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("304_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("305_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2041_tgt
    .local int rx2041_pos
    .local int rx2041_off
    .local int rx2041_eos
    .local int rx2041_rep
    .local pmc rx2041_cur
    .local pmc rx2041_debug
    (rx2041_cur, rx2041_pos, rx2041_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2041_cur
    .local pmc match
    .lex "$/", match
    length rx2041_eos, rx2041_tgt
    gt rx2041_pos, rx2041_eos, rx2041_done
    set rx2041_off, 0
    lt rx2041_pos, 2, rx2041_start
    sub rx2041_off, rx2041_pos, 1
    substr rx2041_tgt, rx2041_tgt, rx2041_off
  rx2041_start:
    eq $I10, 1, rx2041_restart
    if_null rx2041_debug, debug_1452
    rx2041_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2042_done
    goto rxscan2042_scan
  rxscan2042_loop:
    (rx2041_pos) = rx2041_cur."from"()
    inc rx2041_pos
    rx2041_cur."!cursor_from"(rx2041_pos)
    ge rx2041_pos, rx2041_eos, rxscan2042_done
  rxscan2042_scan:
    set_addr $I10, rxscan2042_loop
    rx2041_cur."!mark_push"(0, rx2041_pos, $I10)
  rxscan2042_done:
.annotate 'line', 1046
  # rx subrule "sigil" subtype=capture negate=
    rx2041_cur."!cursor_pos"(rx2041_pos)
    $P10 = rx2041_cur."sigil"()
    unless $P10, rx2041_fail
    rx2041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2041_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2041_pos, 1
    gt $I11, rx2041_eos, rx2041_fail
    sub $I11, rx2041_pos, rx2041_off
    ord $I11, rx2041_tgt, $I11
    ne $I11, 40, rx2041_fail
    add rx2041_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2041_cur."!cursor_pos"(rx2041_pos)
    $P10 = rx2041_cur."semilist"()
    unless $P10, rx2041_fail
    rx2041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2041_pos = $P10."pos"()
  alt2043_0:
    set_addr $I10, alt2043_1
    rx2041_cur."!mark_push"(0, rx2041_pos, $I10)
  # rx literal  ")"
    add $I11, rx2041_pos, 1
    gt $I11, rx2041_eos, rx2041_fail
    sub $I11, rx2041_pos, rx2041_off
    ord $I11, rx2041_tgt, $I11
    ne $I11, 41, rx2041_fail
    add rx2041_pos, 1
    goto alt2043_end
  alt2043_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2041_cur."!cursor_pos"(rx2041_pos)
    $P10 = rx2041_cur."FAILGOAL"("')'")
    unless $P10, rx2041_fail
    goto rxsubrule2044_pass
  rxsubrule2044_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2041_fail
  rxsubrule2044_pass:
    set_addr $I10, rxsubrule2044_back
    rx2041_cur."!mark_push"(0, rx2041_pos, $I10, $P10)
    rx2041_pos = $P10."pos"()
  alt2043_end:
  # rx pass
    rx2041_cur."!cursor_pass"(rx2041_pos, "circumfix:sym<sigil>")
    if_null rx2041_debug, debug_1453
    rx2041_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2041_pos)
  debug_1453:
    .return (rx2041_cur)
  rx2041_restart:
.annotate 'line', 440
    if_null rx2041_debug, debug_1454
    rx2041_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1454:
  rx2041_fail:
    (rx2041_rep, rx2041_pos, $I10, $P10) = rx2041_cur."!mark_fail"(0)
    lt rx2041_pos, -1, rx2041_done
    eq rx2041_pos, -1, rx2041_fail
    jump $I10
  rx2041_done:
    rx2041_cur."!cursor_fail"()
    if_null rx2041_debug, debug_1455
    rx2041_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1455:
    .return (rx2041_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("306_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("307_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2047_tgt
    .local int rx2047_pos
    .local int rx2047_off
    .local int rx2047_eos
    .local int rx2047_rep
    .local pmc rx2047_cur
    .local pmc rx2047_debug
    (rx2047_cur, rx2047_pos, rx2047_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2047_cur
    .local pmc match
    .lex "$/", match
    length rx2047_eos, rx2047_tgt
    gt rx2047_pos, rx2047_eos, rx2047_done
    set rx2047_off, 0
    lt rx2047_pos, 2, rx2047_start
    sub rx2047_off, rx2047_pos, 1
    substr rx2047_tgt, rx2047_tgt, rx2047_off
  rx2047_start:
    eq $I10, 1, rx2047_restart
    if_null rx2047_debug, debug_1456
    rx2047_cur."!cursor_debug"("START", "semilist")
  debug_1456:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2048_done
    goto rxscan2048_scan
  rxscan2048_loop:
    (rx2047_pos) = rx2047_cur."from"()
    inc rx2047_pos
    rx2047_cur."!cursor_from"(rx2047_pos)
    ge rx2047_pos, rx2047_eos, rxscan2048_done
  rxscan2048_scan:
    set_addr $I10, rxscan2048_loop
    rx2047_cur."!mark_push"(0, rx2047_pos, $I10)
  rxscan2048_done:
.annotate 'line', 1048
  # rx subrule "ws" subtype=method negate=
    rx2047_cur."!cursor_pos"(rx2047_pos)
    $P10 = rx2047_cur."ws"()
    unless $P10, rx2047_fail
    rx2047_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2047_cur."!cursor_pos"(rx2047_pos)
    $P10 = rx2047_cur."statement"()
    unless $P10, rx2047_fail
    rx2047_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2047_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2047_cur."!cursor_pos"(rx2047_pos)
    $P10 = rx2047_cur."ws"()
    unless $P10, rx2047_fail
    rx2047_pos = $P10."pos"()
  # rx pass
    rx2047_cur."!cursor_pass"(rx2047_pos, "semilist")
    if_null rx2047_debug, debug_1457
    rx2047_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2047_pos)
  debug_1457:
    .return (rx2047_cur)
  rx2047_restart:
.annotate 'line', 440
    if_null rx2047_debug, debug_1458
    rx2047_cur."!cursor_debug"("NEXT", "semilist")
  debug_1458:
  rx2047_fail:
    (rx2047_rep, rx2047_pos, $I10, $P10) = rx2047_cur."!mark_fail"(0)
    lt rx2047_pos, -1, rx2047_done
    eq rx2047_pos, -1, rx2047_fail
    jump $I10
  rx2047_done:
    rx2047_cur."!cursor_fail"()
    if_null rx2047_debug, debug_1459
    rx2047_cur."!cursor_debug"("FAIL", "semilist")
  debug_1459:
    .return (rx2047_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("308_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("309_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2051_tgt
    .local int rx2051_pos
    .local int rx2051_off
    .local int rx2051_eos
    .local int rx2051_rep
    .local pmc rx2051_cur
    .local pmc rx2051_debug
    (rx2051_cur, rx2051_pos, rx2051_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2051_cur
    .local pmc match
    .lex "$/", match
    length rx2051_eos, rx2051_tgt
    gt rx2051_pos, rx2051_eos, rx2051_done
    set rx2051_off, 0
    lt rx2051_pos, 2, rx2051_start
    sub rx2051_off, rx2051_pos, 1
    substr rx2051_tgt, rx2051_tgt, rx2051_off
  rx2051_start:
    eq $I10, 1, rx2051_restart
    if_null rx2051_debug, debug_1460
    rx2051_cur."!cursor_debug"("START", "infixish")
  debug_1460:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2052_done
    goto rxscan2052_scan
  rxscan2052_loop:
    (rx2051_pos) = rx2051_cur."from"()
    inc rx2051_pos
    rx2051_cur."!cursor_from"(rx2051_pos)
    ge rx2051_pos, rx2051_eos, rxscan2052_done
  rxscan2052_scan:
    set_addr $I10, rxscan2052_loop
    rx2051_cur."!mark_push"(0, rx2051_pos, $I10)
  rxscan2052_done:
.annotate 'line', 1071
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2051_cur."!cursor_pos"(rx2051_pos)
    $P10 = rx2051_cur."infixstopper"()
    if $P10, rx2051_fail
  # rx subrule "infix" subtype=capture negate=
    rx2051_cur."!cursor_pos"(rx2051_pos)
    $P10 = rx2051_cur."infix"()
    unless $P10, rx2051_fail
    rx2051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2051_pos = $P10."pos"()
  # rx pass
    rx2051_cur."!cursor_pass"(rx2051_pos, "infixish")
    if_null rx2051_debug, debug_1461
    rx2051_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2051_pos)
  debug_1461:
    .return (rx2051_cur)
  rx2051_restart:
.annotate 'line', 440
    if_null rx2051_debug, debug_1462
    rx2051_cur."!cursor_debug"("NEXT", "infixish")
  debug_1462:
  rx2051_fail:
    (rx2051_rep, rx2051_pos, $I10, $P10) = rx2051_cur."!mark_fail"(0)
    lt rx2051_pos, -1, rx2051_done
    eq rx2051_pos, -1, rx2051_fail
    jump $I10
  rx2051_done:
    rx2051_cur."!cursor_fail"()
    if_null rx2051_debug, debug_1463
    rx2051_cur."!cursor_debug"("FAIL", "infixish")
  debug_1463:
    .return (rx2051_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("310_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("311_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2055_tgt
    .local int rx2055_pos
    .local int rx2055_off
    .local int rx2055_eos
    .local int rx2055_rep
    .local pmc rx2055_cur
    .local pmc rx2055_debug
    (rx2055_cur, rx2055_pos, rx2055_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2055_cur
    .local pmc match
    .lex "$/", match
    length rx2055_eos, rx2055_tgt
    gt rx2055_pos, rx2055_eos, rx2055_done
    set rx2055_off, 0
    lt rx2055_pos, 2, rx2055_start
    sub rx2055_off, rx2055_pos, 1
    substr rx2055_tgt, rx2055_tgt, rx2055_off
  rx2055_start:
    eq $I10, 1, rx2055_restart
    if_null rx2055_debug, debug_1464
    rx2055_cur."!cursor_debug"("START", "infixstopper")
  debug_1464:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2056_done
    goto rxscan2056_scan
  rxscan2056_loop:
    (rx2055_pos) = rx2055_cur."from"()
    inc rx2055_pos
    rx2055_cur."!cursor_from"(rx2055_pos)
    ge rx2055_pos, rx2055_eos, rxscan2056_done
  rxscan2056_scan:
    set_addr $I10, rxscan2056_loop
    rx2055_cur."!mark_push"(0, rx2055_pos, $I10)
  rxscan2056_done:
.annotate 'line', 1072
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2055_cur."!cursor_pos"(rx2055_pos)
    $P10 = rx2055_cur."lambda"()
    unless $P10, rx2055_fail
  # rx pass
    rx2055_cur."!cursor_pass"(rx2055_pos, "infixstopper")
    if_null rx2055_debug, debug_1465
    rx2055_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2055_pos)
  debug_1465:
    .return (rx2055_cur)
  rx2055_restart:
.annotate 'line', 440
    if_null rx2055_debug, debug_1466
    rx2055_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1466:
  rx2055_fail:
    (rx2055_rep, rx2055_pos, $I10, $P10) = rx2055_cur."!mark_fail"(0)
    lt rx2055_pos, -1, rx2055_done
    eq rx2055_pos, -1, rx2055_fail
    jump $I10
  rx2055_done:
    rx2055_cur."!cursor_fail"()
    if_null rx2055_debug, debug_1467
    rx2055_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1467:
    .return (rx2055_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("312_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("313_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2059_tgt
    .local int rx2059_pos
    .local int rx2059_off
    .local int rx2059_eos
    .local int rx2059_rep
    .local pmc rx2059_cur
    .local pmc rx2059_debug
    (rx2059_cur, rx2059_pos, rx2059_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2059_cur
    .local pmc match
    .lex "$/", match
    length rx2059_eos, rx2059_tgt
    gt rx2059_pos, rx2059_eos, rx2059_done
    set rx2059_off, 0
    lt rx2059_pos, 2, rx2059_start
    sub rx2059_off, rx2059_pos, 1
    substr rx2059_tgt, rx2059_tgt, rx2059_off
  rx2059_start:
    eq $I10, 1, rx2059_restart
    if_null rx2059_debug, debug_1468
    rx2059_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1468:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2060_done
    goto rxscan2060_scan
  rxscan2060_loop:
    (rx2059_pos) = rx2059_cur."from"()
    inc rx2059_pos
    rx2059_cur."!cursor_from"(rx2059_pos)
    ge rx2059_pos, rx2059_eos, rxscan2060_done
  rxscan2060_scan:
    set_addr $I10, rxscan2060_loop
    rx2059_cur."!mark_push"(0, rx2059_pos, $I10)
  rxscan2060_done:
.annotate 'line', 1075
  # rx literal  "["
    add $I11, rx2059_pos, 1
    gt $I11, rx2059_eos, rx2059_fail
    sub $I11, rx2059_pos, rx2059_off
    ord $I11, rx2059_tgt, $I11
    ne $I11, 91, rx2059_fail
    add rx2059_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2059_cur."!cursor_pos"(rx2059_pos)
    $P10 = rx2059_cur."ws"()
    unless $P10, rx2059_fail
    rx2059_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2059_cur."!cursor_pos"(rx2059_pos)
    $P10 = rx2059_cur."EXPR"()
    unless $P10, rx2059_fail
    rx2059_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2059_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2059_pos, 1
    gt $I11, rx2059_eos, rx2059_fail
    sub $I11, rx2059_pos, rx2059_off
    ord $I11, rx2059_tgt, $I11
    ne $I11, 93, rx2059_fail
    add rx2059_pos, 1
.annotate 'line', 1076
  # rx subrule "O" subtype=capture negate=
    rx2059_cur."!cursor_pos"(rx2059_pos)
    $P10 = rx2059_cur."O"("%methodop")
    unless $P10, rx2059_fail
    rx2059_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2059_pos = $P10."pos"()
.annotate 'line', 1074
  # rx pass
    rx2059_cur."!cursor_pass"(rx2059_pos, "postcircumfix:sym<[ ]>")
    if_null rx2059_debug, debug_1469
    rx2059_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2059_pos)
  debug_1469:
    .return (rx2059_cur)
  rx2059_restart:
.annotate 'line', 440
    if_null rx2059_debug, debug_1470
    rx2059_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1470:
  rx2059_fail:
    (rx2059_rep, rx2059_pos, $I10, $P10) = rx2059_cur."!mark_fail"(0)
    lt rx2059_pos, -1, rx2059_done
    eq rx2059_pos, -1, rx2059_fail
    jump $I10
  rx2059_done:
    rx2059_cur."!cursor_fail"()
    if_null rx2059_debug, debug_1471
    rx2059_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1471:
    .return (rx2059_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("314_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("315_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2063_tgt
    .local int rx2063_pos
    .local int rx2063_off
    .local int rx2063_eos
    .local int rx2063_rep
    .local pmc rx2063_cur
    .local pmc rx2063_debug
    (rx2063_cur, rx2063_pos, rx2063_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2063_cur
    .local pmc match
    .lex "$/", match
    length rx2063_eos, rx2063_tgt
    gt rx2063_pos, rx2063_eos, rx2063_done
    set rx2063_off, 0
    lt rx2063_pos, 2, rx2063_start
    sub rx2063_off, rx2063_pos, 1
    substr rx2063_tgt, rx2063_tgt, rx2063_off
  rx2063_start:
    eq $I10, 1, rx2063_restart
    if_null rx2063_debug, debug_1472
    rx2063_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1472:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2064_done
    goto rxscan2064_scan
  rxscan2064_loop:
    (rx2063_pos) = rx2063_cur."from"()
    inc rx2063_pos
    rx2063_cur."!cursor_from"(rx2063_pos)
    ge rx2063_pos, rx2063_eos, rxscan2064_done
  rxscan2064_scan:
    set_addr $I10, rxscan2064_loop
    rx2063_cur."!mark_push"(0, rx2063_pos, $I10)
  rxscan2064_done:
.annotate 'line', 1080
  # rx literal  "{"
    add $I11, rx2063_pos, 1
    gt $I11, rx2063_eos, rx2063_fail
    sub $I11, rx2063_pos, rx2063_off
    ord $I11, rx2063_tgt, $I11
    ne $I11, 123, rx2063_fail
    add rx2063_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2063_cur."!cursor_pos"(rx2063_pos)
    $P10 = rx2063_cur."ws"()
    unless $P10, rx2063_fail
    rx2063_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2063_cur."!cursor_pos"(rx2063_pos)
    $P10 = rx2063_cur."EXPR"()
    unless $P10, rx2063_fail
    rx2063_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2063_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2063_pos, 1
    gt $I11, rx2063_eos, rx2063_fail
    sub $I11, rx2063_pos, rx2063_off
    ord $I11, rx2063_tgt, $I11
    ne $I11, 125, rx2063_fail
    add rx2063_pos, 1
.annotate 'line', 1081
  # rx subrule "O" subtype=capture negate=
    rx2063_cur."!cursor_pos"(rx2063_pos)
    $P10 = rx2063_cur."O"("%methodop")
    unless $P10, rx2063_fail
    rx2063_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2063_pos = $P10."pos"()
.annotate 'line', 1079
  # rx pass
    rx2063_cur."!cursor_pass"(rx2063_pos, "postcircumfix:sym<{ }>")
    if_null rx2063_debug, debug_1473
    rx2063_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2063_pos)
  debug_1473:
    .return (rx2063_cur)
  rx2063_restart:
.annotate 'line', 440
    if_null rx2063_debug, debug_1474
    rx2063_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1474:
  rx2063_fail:
    (rx2063_rep, rx2063_pos, $I10, $P10) = rx2063_cur."!mark_fail"(0)
    lt rx2063_pos, -1, rx2063_done
    eq rx2063_pos, -1, rx2063_fail
    jump $I10
  rx2063_done:
    rx2063_cur."!cursor_fail"()
    if_null rx2063_debug, debug_1475
    rx2063_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1475:
    .return (rx2063_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("316_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "{")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("317_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2067_tgt
    .local int rx2067_pos
    .local int rx2067_off
    .local int rx2067_eos
    .local int rx2067_rep
    .local pmc rx2067_cur
    .local pmc rx2067_debug
    (rx2067_cur, rx2067_pos, rx2067_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2067_cur
    .local pmc match
    .lex "$/", match
    length rx2067_eos, rx2067_tgt
    gt rx2067_pos, rx2067_eos, rx2067_done
    set rx2067_off, 0
    lt rx2067_pos, 2, rx2067_start
    sub rx2067_off, rx2067_pos, 1
    substr rx2067_tgt, rx2067_tgt, rx2067_off
  rx2067_start:
    eq $I10, 1, rx2067_restart
    if_null rx2067_debug, debug_1476
    rx2067_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1476:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2068_done
    goto rxscan2068_scan
  rxscan2068_loop:
    (rx2067_pos) = rx2067_cur."from"()
    inc rx2067_pos
    rx2067_cur."!cursor_from"(rx2067_pos)
    ge rx2067_pos, rx2067_eos, rxscan2068_done
  rxscan2068_scan:
    set_addr $I10, rxscan2068_loop
    rx2067_cur."!mark_push"(0, rx2067_pos, $I10)
  rxscan2068_done:
.annotate 'line', 1085
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2067_pos, rx2067_off
    substr $S10, rx2067_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2067_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2067_cur."!cursor_pos"(rx2067_pos)
    $P10 = rx2067_cur."quote_EXPR"(":q")
    unless $P10, rx2067_fail
    rx2067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2067_pos = $P10."pos"()
.annotate 'line', 1086
  # rx subrule "O" subtype=capture negate=
    rx2067_cur."!cursor_pos"(rx2067_pos)
    $P10 = rx2067_cur."O"("%methodop")
    unless $P10, rx2067_fail
    rx2067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2067_pos = $P10."pos"()
.annotate 'line', 1084
  # rx pass
    rx2067_cur."!cursor_pass"(rx2067_pos, "postcircumfix:sym<ang>")
    if_null rx2067_debug, debug_1477
    rx2067_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2067_pos)
  debug_1477:
    .return (rx2067_cur)
  rx2067_restart:
.annotate 'line', 440
    if_null rx2067_debug, debug_1478
    rx2067_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1478:
  rx2067_fail:
    (rx2067_rep, rx2067_pos, $I10, $P10) = rx2067_cur."!mark_fail"(0)
    lt rx2067_pos, -1, rx2067_done
    eq rx2067_pos, -1, rx2067_fail
    jump $I10
  rx2067_done:
    rx2067_cur."!cursor_fail"()
    if_null rx2067_debug, debug_1479
    rx2067_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1479:
    .return (rx2067_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("318_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("319_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2071_tgt
    .local int rx2071_pos
    .local int rx2071_off
    .local int rx2071_eos
    .local int rx2071_rep
    .local pmc rx2071_cur
    .local pmc rx2071_debug
    (rx2071_cur, rx2071_pos, rx2071_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2071_cur
    .local pmc match
    .lex "$/", match
    length rx2071_eos, rx2071_tgt
    gt rx2071_pos, rx2071_eos, rx2071_done
    set rx2071_off, 0
    lt rx2071_pos, 2, rx2071_start
    sub rx2071_off, rx2071_pos, 1
    substr rx2071_tgt, rx2071_tgt, rx2071_off
  rx2071_start:
    eq $I10, 1, rx2071_restart
    if_null rx2071_debug, debug_1480
    rx2071_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1480:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2072_done
    goto rxscan2072_scan
  rxscan2072_loop:
    (rx2071_pos) = rx2071_cur."from"()
    inc rx2071_pos
    rx2071_cur."!cursor_from"(rx2071_pos)
    ge rx2071_pos, rx2071_eos, rxscan2072_done
  rxscan2072_scan:
    set_addr $I10, rxscan2072_loop
    rx2071_cur."!mark_push"(0, rx2071_pos, $I10)
  rxscan2072_done:
.annotate 'line', 1090
  # rx literal  "("
    add $I11, rx2071_pos, 1
    gt $I11, rx2071_eos, rx2071_fail
    sub $I11, rx2071_pos, rx2071_off
    ord $I11, rx2071_tgt, $I11
    ne $I11, 40, rx2071_fail
    add rx2071_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2071_cur."!cursor_pos"(rx2071_pos)
    $P10 = rx2071_cur."ws"()
    unless $P10, rx2071_fail
    rx2071_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2071_cur."!cursor_pos"(rx2071_pos)
    $P10 = rx2071_cur."arglist"()
    unless $P10, rx2071_fail
    rx2071_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2071_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2071_pos, 1
    gt $I11, rx2071_eos, rx2071_fail
    sub $I11, rx2071_pos, rx2071_off
    ord $I11, rx2071_tgt, $I11
    ne $I11, 41, rx2071_fail
    add rx2071_pos, 1
.annotate 'line', 1091
  # rx subrule "O" subtype=capture negate=
    rx2071_cur."!cursor_pos"(rx2071_pos)
    $P10 = rx2071_cur."O"("%methodop")
    unless $P10, rx2071_fail
    rx2071_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2071_pos = $P10."pos"()
.annotate 'line', 1089
  # rx pass
    rx2071_cur."!cursor_pass"(rx2071_pos, "postcircumfix:sym<( )>")
    if_null rx2071_debug, debug_1481
    rx2071_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2071_pos)
  debug_1481:
    .return (rx2071_cur)
  rx2071_restart:
.annotate 'line', 440
    if_null rx2071_debug, debug_1482
    rx2071_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1482:
  rx2071_fail:
    (rx2071_rep, rx2071_pos, $I10, $P10) = rx2071_cur."!mark_fail"(0)
    lt rx2071_pos, -1, rx2071_done
    eq rx2071_pos, -1, rx2071_fail
    jump $I10
  rx2071_done:
    rx2071_cur."!cursor_fail"()
    if_null rx2071_debug, debug_1483
    rx2071_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1483:
    .return (rx2071_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("320_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("321_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2075_tgt
    .local int rx2075_pos
    .local int rx2075_off
    .local int rx2075_eos
    .local int rx2075_rep
    .local pmc rx2075_cur
    .local pmc rx2075_debug
    (rx2075_cur, rx2075_pos, rx2075_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2075_cur
    .local pmc match
    .lex "$/", match
    length rx2075_eos, rx2075_tgt
    gt rx2075_pos, rx2075_eos, rx2075_done
    set rx2075_off, 0
    lt rx2075_pos, 2, rx2075_start
    sub rx2075_off, rx2075_pos, 1
    substr rx2075_tgt, rx2075_tgt, rx2075_off
  rx2075_start:
    eq $I10, 1, rx2075_restart
    if_null rx2075_debug, debug_1484
    rx2075_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1484:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2076_done
    goto rxscan2076_scan
  rxscan2076_loop:
    (rx2075_pos) = rx2075_cur."from"()
    inc rx2075_pos
    rx2075_cur."!cursor_from"(rx2075_pos)
    ge rx2075_pos, rx2075_eos, rxscan2076_done
  rxscan2076_scan:
    set_addr $I10, rxscan2076_loop
    rx2075_cur."!mark_push"(0, rx2075_pos, $I10)
  rxscan2076_done:
.annotate 'line', 1094
  # rx subrule "dotty" subtype=capture negate=
    rx2075_cur."!cursor_pos"(rx2075_pos)
    $P10 = rx2075_cur."dotty"()
    unless $P10, rx2075_fail
    rx2075_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2075_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2075_cur."!cursor_pos"(rx2075_pos)
    $P10 = rx2075_cur."O"("%methodop")
    unless $P10, rx2075_fail
    rx2075_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2075_pos = $P10."pos"()
  # rx pass
    rx2075_cur."!cursor_pass"(rx2075_pos, "postfix:sym<.>")
    if_null rx2075_debug, debug_1485
    rx2075_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2075_pos)
  debug_1485:
    .return (rx2075_cur)
  rx2075_restart:
.annotate 'line', 440
    if_null rx2075_debug, debug_1486
    rx2075_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1486:
  rx2075_fail:
    (rx2075_rep, rx2075_pos, $I10, $P10) = rx2075_cur."!mark_fail"(0)
    lt rx2075_pos, -1, rx2075_done
    eq rx2075_pos, -1, rx2075_fail
    jump $I10
  rx2075_done:
    rx2075_cur."!cursor_fail"()
    if_null rx2075_debug, debug_1487
    rx2075_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1487:
    .return (rx2075_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("322_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("dotty", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("323_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2079_tgt
    .local int rx2079_pos
    .local int rx2079_off
    .local int rx2079_eos
    .local int rx2079_rep
    .local pmc rx2079_cur
    .local pmc rx2079_debug
    (rx2079_cur, rx2079_pos, rx2079_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2079_cur
    .local pmc match
    .lex "$/", match
    length rx2079_eos, rx2079_tgt
    gt rx2079_pos, rx2079_eos, rx2079_done
    set rx2079_off, 0
    lt rx2079_pos, 2, rx2079_start
    sub rx2079_off, rx2079_pos, 1
    substr rx2079_tgt, rx2079_tgt, rx2079_off
  rx2079_start:
    eq $I10, 1, rx2079_restart
    if_null rx2079_debug, debug_1488
    rx2079_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1488:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2080_done
    goto rxscan2080_scan
  rxscan2080_loop:
    (rx2079_pos) = rx2079_cur."from"()
    inc rx2079_pos
    rx2079_cur."!cursor_from"(rx2079_pos)
    ge rx2079_pos, rx2079_eos, rxscan2080_done
  rxscan2080_scan:
    set_addr $I10, rxscan2080_loop
    rx2079_cur."!mark_push"(0, rx2079_pos, $I10)
  rxscan2080_done:
.annotate 'line', 1096
  # rx subcapture "sym"
    set_addr $I10, rxcap_2081_fail
    rx2079_cur."!mark_push"(0, rx2079_pos, $I10)
  # rx literal  "++"
    add $I11, rx2079_pos, 2
    gt $I11, rx2079_eos, rx2079_fail
    sub $I11, rx2079_pos, rx2079_off
    substr $S10, rx2079_tgt, $I11, 2
    ne $S10, "++", rx2079_fail
    add rx2079_pos, 2
    set_addr $I10, rxcap_2081_fail
    ($I12, $I11) = rx2079_cur."!mark_peek"($I10)
    rx2079_cur."!cursor_pos"($I11)
    ($P10) = rx2079_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2079_pos, "")
    rx2079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2081_done
  rxcap_2081_fail:
    goto rx2079_fail
  rxcap_2081_done:
  # rx subrule "O" subtype=capture negate=
    rx2079_cur."!cursor_pos"(rx2079_pos)
    $P10 = rx2079_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2079_fail
    rx2079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2079_pos = $P10."pos"()
  # rx pass
    rx2079_cur."!cursor_pass"(rx2079_pos, "prefix:sym<++>")
    if_null rx2079_debug, debug_1489
    rx2079_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2079_pos)
  debug_1489:
    .return (rx2079_cur)
  rx2079_restart:
.annotate 'line', 440
    if_null rx2079_debug, debug_1490
    rx2079_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1490:
  rx2079_fail:
    (rx2079_rep, rx2079_pos, $I10, $P10) = rx2079_cur."!mark_fail"(0)
    lt rx2079_pos, -1, rx2079_done
    eq rx2079_pos, -1, rx2079_fail
    jump $I10
  rx2079_done:
    rx2079_cur."!cursor_fail"()
    if_null rx2079_debug, debug_1491
    rx2079_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1491:
    .return (rx2079_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("324_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("325_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2084_tgt
    .local int rx2084_pos
    .local int rx2084_off
    .local int rx2084_eos
    .local int rx2084_rep
    .local pmc rx2084_cur
    .local pmc rx2084_debug
    (rx2084_cur, rx2084_pos, rx2084_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2084_cur
    .local pmc match
    .lex "$/", match
    length rx2084_eos, rx2084_tgt
    gt rx2084_pos, rx2084_eos, rx2084_done
    set rx2084_off, 0
    lt rx2084_pos, 2, rx2084_start
    sub rx2084_off, rx2084_pos, 1
    substr rx2084_tgt, rx2084_tgt, rx2084_off
  rx2084_start:
    eq $I10, 1, rx2084_restart
    if_null rx2084_debug, debug_1492
    rx2084_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1492:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2085_done
    goto rxscan2085_scan
  rxscan2085_loop:
    (rx2084_pos) = rx2084_cur."from"()
    inc rx2084_pos
    rx2084_cur."!cursor_from"(rx2084_pos)
    ge rx2084_pos, rx2084_eos, rxscan2085_done
  rxscan2085_scan:
    set_addr $I10, rxscan2085_loop
    rx2084_cur."!mark_push"(0, rx2084_pos, $I10)
  rxscan2085_done:
.annotate 'line', 1097
  # rx subcapture "sym"
    set_addr $I10, rxcap_2086_fail
    rx2084_cur."!mark_push"(0, rx2084_pos, $I10)
  # rx literal  "--"
    add $I11, rx2084_pos, 2
    gt $I11, rx2084_eos, rx2084_fail
    sub $I11, rx2084_pos, rx2084_off
    substr $S10, rx2084_tgt, $I11, 2
    ne $S10, "--", rx2084_fail
    add rx2084_pos, 2
    set_addr $I10, rxcap_2086_fail
    ($I12, $I11) = rx2084_cur."!mark_peek"($I10)
    rx2084_cur."!cursor_pos"($I11)
    ($P10) = rx2084_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2084_pos, "")
    rx2084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2086_done
  rxcap_2086_fail:
    goto rx2084_fail
  rxcap_2086_done:
  # rx subrule "O" subtype=capture negate=
    rx2084_cur."!cursor_pos"(rx2084_pos)
    $P10 = rx2084_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2084_fail
    rx2084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2084_pos = $P10."pos"()
  # rx pass
    rx2084_cur."!cursor_pass"(rx2084_pos, "prefix:sym<-->")
    if_null rx2084_debug, debug_1493
    rx2084_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2084_pos)
  debug_1493:
    .return (rx2084_cur)
  rx2084_restart:
.annotate 'line', 440
    if_null rx2084_debug, debug_1494
    rx2084_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1494:
  rx2084_fail:
    (rx2084_rep, rx2084_pos, $I10, $P10) = rx2084_cur."!mark_fail"(0)
    lt rx2084_pos, -1, rx2084_done
    eq rx2084_pos, -1, rx2084_fail
    jump $I10
  rx2084_done:
    rx2084_cur."!cursor_fail"()
    if_null rx2084_debug, debug_1495
    rx2084_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1495:
    .return (rx2084_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("326_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("327_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2089_tgt
    .local int rx2089_pos
    .local int rx2089_off
    .local int rx2089_eos
    .local int rx2089_rep
    .local pmc rx2089_cur
    .local pmc rx2089_debug
    (rx2089_cur, rx2089_pos, rx2089_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2089_cur
    .local pmc match
    .lex "$/", match
    length rx2089_eos, rx2089_tgt
    gt rx2089_pos, rx2089_eos, rx2089_done
    set rx2089_off, 0
    lt rx2089_pos, 2, rx2089_start
    sub rx2089_off, rx2089_pos, 1
    substr rx2089_tgt, rx2089_tgt, rx2089_off
  rx2089_start:
    eq $I10, 1, rx2089_restart
    if_null rx2089_debug, debug_1496
    rx2089_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1496:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2090_done
    goto rxscan2090_scan
  rxscan2090_loop:
    (rx2089_pos) = rx2089_cur."from"()
    inc rx2089_pos
    rx2089_cur."!cursor_from"(rx2089_pos)
    ge rx2089_pos, rx2089_eos, rxscan2090_done
  rxscan2090_scan:
    set_addr $I10, rxscan2090_loop
    rx2089_cur."!mark_push"(0, rx2089_pos, $I10)
  rxscan2090_done:
.annotate 'line', 1100
  # rx subcapture "sym"
    set_addr $I10, rxcap_2091_fail
    rx2089_cur."!mark_push"(0, rx2089_pos, $I10)
  # rx literal  "++"
    add $I11, rx2089_pos, 2
    gt $I11, rx2089_eos, rx2089_fail
    sub $I11, rx2089_pos, rx2089_off
    substr $S10, rx2089_tgt, $I11, 2
    ne $S10, "++", rx2089_fail
    add rx2089_pos, 2
    set_addr $I10, rxcap_2091_fail
    ($I12, $I11) = rx2089_cur."!mark_peek"($I10)
    rx2089_cur."!cursor_pos"($I11)
    ($P10) = rx2089_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2089_pos, "")
    rx2089_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2091_done
  rxcap_2091_fail:
    goto rx2089_fail
  rxcap_2091_done:
  # rx subrule "O" subtype=capture negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."O"("%autoincrement")
    unless $P10, rx2089_fail
    rx2089_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2089_pos = $P10."pos"()
  # rx pass
    rx2089_cur."!cursor_pass"(rx2089_pos, "postfix:sym<++>")
    if_null rx2089_debug, debug_1497
    rx2089_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2089_pos)
  debug_1497:
    .return (rx2089_cur)
  rx2089_restart:
.annotate 'line', 440
    if_null rx2089_debug, debug_1498
    rx2089_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1498:
  rx2089_fail:
    (rx2089_rep, rx2089_pos, $I10, $P10) = rx2089_cur."!mark_fail"(0)
    lt rx2089_pos, -1, rx2089_done
    eq rx2089_pos, -1, rx2089_fail
    jump $I10
  rx2089_done:
    rx2089_cur."!cursor_fail"()
    if_null rx2089_debug, debug_1499
    rx2089_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1499:
    .return (rx2089_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("328_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("329_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2094_tgt
    .local int rx2094_pos
    .local int rx2094_off
    .local int rx2094_eos
    .local int rx2094_rep
    .local pmc rx2094_cur
    .local pmc rx2094_debug
    (rx2094_cur, rx2094_pos, rx2094_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2094_cur
    .local pmc match
    .lex "$/", match
    length rx2094_eos, rx2094_tgt
    gt rx2094_pos, rx2094_eos, rx2094_done
    set rx2094_off, 0
    lt rx2094_pos, 2, rx2094_start
    sub rx2094_off, rx2094_pos, 1
    substr rx2094_tgt, rx2094_tgt, rx2094_off
  rx2094_start:
    eq $I10, 1, rx2094_restart
    if_null rx2094_debug, debug_1500
    rx2094_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1500:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2095_done
    goto rxscan2095_scan
  rxscan2095_loop:
    (rx2094_pos) = rx2094_cur."from"()
    inc rx2094_pos
    rx2094_cur."!cursor_from"(rx2094_pos)
    ge rx2094_pos, rx2094_eos, rxscan2095_done
  rxscan2095_scan:
    set_addr $I10, rxscan2095_loop
    rx2094_cur."!mark_push"(0, rx2094_pos, $I10)
  rxscan2095_done:
.annotate 'line', 1101
  # rx subcapture "sym"
    set_addr $I10, rxcap_2096_fail
    rx2094_cur."!mark_push"(0, rx2094_pos, $I10)
  # rx literal  "--"
    add $I11, rx2094_pos, 2
    gt $I11, rx2094_eos, rx2094_fail
    sub $I11, rx2094_pos, rx2094_off
    substr $S10, rx2094_tgt, $I11, 2
    ne $S10, "--", rx2094_fail
    add rx2094_pos, 2
    set_addr $I10, rxcap_2096_fail
    ($I12, $I11) = rx2094_cur."!mark_peek"($I10)
    rx2094_cur."!cursor_pos"($I11)
    ($P10) = rx2094_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2094_pos, "")
    rx2094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2096_done
  rxcap_2096_fail:
    goto rx2094_fail
  rxcap_2096_done:
  # rx subrule "O" subtype=capture negate=
    rx2094_cur."!cursor_pos"(rx2094_pos)
    $P10 = rx2094_cur."O"("%autoincrement")
    unless $P10, rx2094_fail
    rx2094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2094_pos = $P10."pos"()
  # rx pass
    rx2094_cur."!cursor_pass"(rx2094_pos, "postfix:sym<-->")
    if_null rx2094_debug, debug_1501
    rx2094_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2094_pos)
  debug_1501:
    .return (rx2094_cur)
  rx2094_restart:
.annotate 'line', 440
    if_null rx2094_debug, debug_1502
    rx2094_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1502:
  rx2094_fail:
    (rx2094_rep, rx2094_pos, $I10, $P10) = rx2094_cur."!mark_fail"(0)
    lt rx2094_pos, -1, rx2094_done
    eq rx2094_pos, -1, rx2094_fail
    jump $I10
  rx2094_done:
    rx2094_cur."!cursor_fail"()
    if_null rx2094_debug, debug_1503
    rx2094_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1503:
    .return (rx2094_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("330_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("331_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2099_tgt
    .local int rx2099_pos
    .local int rx2099_off
    .local int rx2099_eos
    .local int rx2099_rep
    .local pmc rx2099_cur
    .local pmc rx2099_debug
    (rx2099_cur, rx2099_pos, rx2099_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2099_cur
    .local pmc match
    .lex "$/", match
    length rx2099_eos, rx2099_tgt
    gt rx2099_pos, rx2099_eos, rx2099_done
    set rx2099_off, 0
    lt rx2099_pos, 2, rx2099_start
    sub rx2099_off, rx2099_pos, 1
    substr rx2099_tgt, rx2099_tgt, rx2099_off
  rx2099_start:
    eq $I10, 1, rx2099_restart
    if_null rx2099_debug, debug_1504
    rx2099_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1504:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2100_done
    goto rxscan2100_scan
  rxscan2100_loop:
    (rx2099_pos) = rx2099_cur."from"()
    inc rx2099_pos
    rx2099_cur."!cursor_from"(rx2099_pos)
    ge rx2099_pos, rx2099_eos, rxscan2100_done
  rxscan2100_scan:
    set_addr $I10, rxscan2100_loop
    rx2099_cur."!mark_push"(0, rx2099_pos, $I10)
  rxscan2100_done:
.annotate 'line', 1103
  # rx subcapture "sym"
    set_addr $I10, rxcap_2101_fail
    rx2099_cur."!mark_push"(0, rx2099_pos, $I10)
  # rx literal  "**"
    add $I11, rx2099_pos, 2
    gt $I11, rx2099_eos, rx2099_fail
    sub $I11, rx2099_pos, rx2099_off
    substr $S10, rx2099_tgt, $I11, 2
    ne $S10, "**", rx2099_fail
    add rx2099_pos, 2
    set_addr $I10, rxcap_2101_fail
    ($I12, $I11) = rx2099_cur."!mark_peek"($I10)
    rx2099_cur."!cursor_pos"($I11)
    ($P10) = rx2099_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2099_pos, "")
    rx2099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2101_done
  rxcap_2101_fail:
    goto rx2099_fail
  rxcap_2101_done:
  # rx subrule "O" subtype=capture negate=
    rx2099_cur."!cursor_pos"(rx2099_pos)
    $P10 = rx2099_cur."O"("%exponentiation, :pirop<pow__NNN>")
    unless $P10, rx2099_fail
    rx2099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2099_pos = $P10."pos"()
  # rx pass
    rx2099_cur."!cursor_pass"(rx2099_pos, "infix:sym<**>")
    if_null rx2099_debug, debug_1505
    rx2099_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2099_pos)
  debug_1505:
    .return (rx2099_cur)
  rx2099_restart:
.annotate 'line', 440
    if_null rx2099_debug, debug_1506
    rx2099_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1506:
  rx2099_fail:
    (rx2099_rep, rx2099_pos, $I10, $P10) = rx2099_cur."!mark_fail"(0)
    lt rx2099_pos, -1, rx2099_done
    eq rx2099_pos, -1, rx2099_fail
    jump $I10
  rx2099_done:
    rx2099_cur."!cursor_fail"()
    if_null rx2099_debug, debug_1507
    rx2099_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1507:
    .return (rx2099_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("332_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "**")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("333_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2104_tgt
    .local int rx2104_pos
    .local int rx2104_off
    .local int rx2104_eos
    .local int rx2104_rep
    .local pmc rx2104_cur
    .local pmc rx2104_debug
    (rx2104_cur, rx2104_pos, rx2104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2104_cur
    .local pmc match
    .lex "$/", match
    length rx2104_eos, rx2104_tgt
    gt rx2104_pos, rx2104_eos, rx2104_done
    set rx2104_off, 0
    lt rx2104_pos, 2, rx2104_start
    sub rx2104_off, rx2104_pos, 1
    substr rx2104_tgt, rx2104_tgt, rx2104_off
  rx2104_start:
    eq $I10, 1, rx2104_restart
    if_null rx2104_debug, debug_1508
    rx2104_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1508:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2105_done
    goto rxscan2105_scan
  rxscan2105_loop:
    (rx2104_pos) = rx2104_cur."from"()
    inc rx2104_pos
    rx2104_cur."!cursor_from"(rx2104_pos)
    ge rx2104_pos, rx2104_eos, rxscan2105_done
  rxscan2105_scan:
    set_addr $I10, rxscan2105_loop
    rx2104_cur."!mark_push"(0, rx2104_pos, $I10)
  rxscan2105_done:
.annotate 'line', 1105
  # rx subcapture "sym"
    set_addr $I10, rxcap_2106_fail
    rx2104_cur."!mark_push"(0, rx2104_pos, $I10)
  # rx literal  "+"
    add $I11, rx2104_pos, 1
    gt $I11, rx2104_eos, rx2104_fail
    sub $I11, rx2104_pos, rx2104_off
    ord $I11, rx2104_tgt, $I11
    ne $I11, 43, rx2104_fail
    add rx2104_pos, 1
    set_addr $I10, rxcap_2106_fail
    ($I12, $I11) = rx2104_cur."!mark_peek"($I10)
    rx2104_cur."!cursor_pos"($I11)
    ($P10) = rx2104_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2104_pos, "")
    rx2104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2106_done
  rxcap_2106_fail:
    goto rx2104_fail
  rxcap_2106_done:
  # rx subrule "O" subtype=capture negate=
    rx2104_cur."!cursor_pos"(rx2104_pos)
    $P10 = rx2104_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2104_fail
    rx2104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2104_pos = $P10."pos"()
  # rx pass
    rx2104_cur."!cursor_pass"(rx2104_pos, "prefix:sym<+>")
    if_null rx2104_debug, debug_1509
    rx2104_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2104_pos)
  debug_1509:
    .return (rx2104_cur)
  rx2104_restart:
.annotate 'line', 440
    if_null rx2104_debug, debug_1510
    rx2104_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1510:
  rx2104_fail:
    (rx2104_rep, rx2104_pos, $I10, $P10) = rx2104_cur."!mark_fail"(0)
    lt rx2104_pos, -1, rx2104_done
    eq rx2104_pos, -1, rx2104_fail
    jump $I10
  rx2104_done:
    rx2104_cur."!cursor_fail"()
    if_null rx2104_debug, debug_1511
    rx2104_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1511:
    .return (rx2104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("334_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("335_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2109_tgt
    .local int rx2109_pos
    .local int rx2109_off
    .local int rx2109_eos
    .local int rx2109_rep
    .local pmc rx2109_cur
    .local pmc rx2109_debug
    (rx2109_cur, rx2109_pos, rx2109_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2109_cur
    .local pmc match
    .lex "$/", match
    length rx2109_eos, rx2109_tgt
    gt rx2109_pos, rx2109_eos, rx2109_done
    set rx2109_off, 0
    lt rx2109_pos, 2, rx2109_start
    sub rx2109_off, rx2109_pos, 1
    substr rx2109_tgt, rx2109_tgt, rx2109_off
  rx2109_start:
    eq $I10, 1, rx2109_restart
    if_null rx2109_debug, debug_1512
    rx2109_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1512:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2110_done
    goto rxscan2110_scan
  rxscan2110_loop:
    (rx2109_pos) = rx2109_cur."from"()
    inc rx2109_pos
    rx2109_cur."!cursor_from"(rx2109_pos)
    ge rx2109_pos, rx2109_eos, rxscan2110_done
  rxscan2110_scan:
    set_addr $I10, rxscan2110_loop
    rx2109_cur."!mark_push"(0, rx2109_pos, $I10)
  rxscan2110_done:
.annotate 'line', 1106
  # rx subcapture "sym"
    set_addr $I10, rxcap_2111_fail
    rx2109_cur."!mark_push"(0, rx2109_pos, $I10)
  # rx literal  "~"
    add $I11, rx2109_pos, 1
    gt $I11, rx2109_eos, rx2109_fail
    sub $I11, rx2109_pos, rx2109_off
    ord $I11, rx2109_tgt, $I11
    ne $I11, 126, rx2109_fail
    add rx2109_pos, 1
    set_addr $I10, rxcap_2111_fail
    ($I12, $I11) = rx2109_cur."!mark_peek"($I10)
    rx2109_cur."!cursor_pos"($I11)
    ($P10) = rx2109_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2109_pos, "")
    rx2109_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2111_done
  rxcap_2111_fail:
    goto rx2109_fail
  rxcap_2111_done:
  # rx subrule "O" subtype=capture negate=
    rx2109_cur."!cursor_pos"(rx2109_pos)
    $P10 = rx2109_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2109_fail
    rx2109_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2109_pos = $P10."pos"()
  # rx pass
    rx2109_cur."!cursor_pass"(rx2109_pos, "prefix:sym<~>")
    if_null rx2109_debug, debug_1513
    rx2109_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2109_pos)
  debug_1513:
    .return (rx2109_cur)
  rx2109_restart:
.annotate 'line', 440
    if_null rx2109_debug, debug_1514
    rx2109_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1514:
  rx2109_fail:
    (rx2109_rep, rx2109_pos, $I10, $P10) = rx2109_cur."!mark_fail"(0)
    lt rx2109_pos, -1, rx2109_done
    eq rx2109_pos, -1, rx2109_fail
    jump $I10
  rx2109_done:
    rx2109_cur."!cursor_fail"()
    if_null rx2109_debug, debug_1515
    rx2109_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1515:
    .return (rx2109_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("336_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("337_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2114_tgt
    .local int rx2114_pos
    .local int rx2114_off
    .local int rx2114_eos
    .local int rx2114_rep
    .local pmc rx2114_cur
    .local pmc rx2114_debug
    (rx2114_cur, rx2114_pos, rx2114_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2114_cur
    .local pmc match
    .lex "$/", match
    length rx2114_eos, rx2114_tgt
    gt rx2114_pos, rx2114_eos, rx2114_done
    set rx2114_off, 0
    lt rx2114_pos, 2, rx2114_start
    sub rx2114_off, rx2114_pos, 1
    substr rx2114_tgt, rx2114_tgt, rx2114_off
  rx2114_start:
    eq $I10, 1, rx2114_restart
    if_null rx2114_debug, debug_1516
    rx2114_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1516:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2115_done
    goto rxscan2115_scan
  rxscan2115_loop:
    (rx2114_pos) = rx2114_cur."from"()
    inc rx2114_pos
    rx2114_cur."!cursor_from"(rx2114_pos)
    ge rx2114_pos, rx2114_eos, rxscan2115_done
  rxscan2115_scan:
    set_addr $I10, rxscan2115_loop
    rx2114_cur."!mark_push"(0, rx2114_pos, $I10)
  rxscan2115_done:
.annotate 'line', 1107
  # rx subcapture "sym"
    set_addr $I10, rxcap_2116_fail
    rx2114_cur."!mark_push"(0, rx2114_pos, $I10)
  # rx literal  "-"
    add $I11, rx2114_pos, 1
    gt $I11, rx2114_eos, rx2114_fail
    sub $I11, rx2114_pos, rx2114_off
    ord $I11, rx2114_tgt, $I11
    ne $I11, 45, rx2114_fail
    add rx2114_pos, 1
    set_addr $I10, rxcap_2116_fail
    ($I12, $I11) = rx2114_cur."!mark_peek"($I10)
    rx2114_cur."!cursor_pos"($I11)
    ($P10) = rx2114_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2114_pos, "")
    rx2114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2116_done
  rxcap_2116_fail:
    goto rx2114_fail
  rxcap_2116_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2114_pos, rx2114_off
    substr $S10, rx2114_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2114_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2114_cur."!cursor_pos"(rx2114_pos)
    $P10 = rx2114_cur."number"()
    if $P10, rx2114_fail
  # rx subrule "O" subtype=capture negate=
    rx2114_cur."!cursor_pos"(rx2114_pos)
    $P10 = rx2114_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2114_fail
    rx2114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2114_pos = $P10."pos"()
  # rx pass
    rx2114_cur."!cursor_pass"(rx2114_pos, "prefix:sym<->")
    if_null rx2114_debug, debug_1517
    rx2114_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2114_pos)
  debug_1517:
    .return (rx2114_cur)
  rx2114_restart:
.annotate 'line', 440
    if_null rx2114_debug, debug_1518
    rx2114_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1518:
  rx2114_fail:
    (rx2114_rep, rx2114_pos, $I10, $P10) = rx2114_cur."!mark_fail"(0)
    lt rx2114_pos, -1, rx2114_done
    eq rx2114_pos, -1, rx2114_fail
    jump $I10
  rx2114_done:
    rx2114_cur."!cursor_fail"()
    if_null rx2114_debug, debug_1519
    rx2114_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1519:
    .return (rx2114_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("338_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "-"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("339_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2119_tgt
    .local int rx2119_pos
    .local int rx2119_off
    .local int rx2119_eos
    .local int rx2119_rep
    .local pmc rx2119_cur
    .local pmc rx2119_debug
    (rx2119_cur, rx2119_pos, rx2119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2119_cur
    .local pmc match
    .lex "$/", match
    length rx2119_eos, rx2119_tgt
    gt rx2119_pos, rx2119_eos, rx2119_done
    set rx2119_off, 0
    lt rx2119_pos, 2, rx2119_start
    sub rx2119_off, rx2119_pos, 1
    substr rx2119_tgt, rx2119_tgt, rx2119_off
  rx2119_start:
    eq $I10, 1, rx2119_restart
    if_null rx2119_debug, debug_1520
    rx2119_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1520:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2120_done
    goto rxscan2120_scan
  rxscan2120_loop:
    (rx2119_pos) = rx2119_cur."from"()
    inc rx2119_pos
    rx2119_cur."!cursor_from"(rx2119_pos)
    ge rx2119_pos, rx2119_eos, rxscan2120_done
  rxscan2120_scan:
    set_addr $I10, rxscan2120_loop
    rx2119_cur."!mark_push"(0, rx2119_pos, $I10)
  rxscan2120_done:
.annotate 'line', 1108
  # rx subcapture "sym"
    set_addr $I10, rxcap_2121_fail
    rx2119_cur."!mark_push"(0, rx2119_pos, $I10)
  # rx literal  "?"
    add $I11, rx2119_pos, 1
    gt $I11, rx2119_eos, rx2119_fail
    sub $I11, rx2119_pos, rx2119_off
    ord $I11, rx2119_tgt, $I11
    ne $I11, 63, rx2119_fail
    add rx2119_pos, 1
    set_addr $I10, rxcap_2121_fail
    ($I12, $I11) = rx2119_cur."!mark_peek"($I10)
    rx2119_cur."!cursor_pos"($I11)
    ($P10) = rx2119_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2119_pos, "")
    rx2119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2121_done
  rxcap_2121_fail:
    goto rx2119_fail
  rxcap_2121_done:
  # rx subrule "O" subtype=capture negate=
    rx2119_cur."!cursor_pos"(rx2119_pos)
    $P10 = rx2119_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2119_fail
    rx2119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2119_pos = $P10."pos"()
  # rx pass
    rx2119_cur."!cursor_pass"(rx2119_pos, "prefix:sym<?>")
    if_null rx2119_debug, debug_1521
    rx2119_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2119_pos)
  debug_1521:
    .return (rx2119_cur)
  rx2119_restart:
.annotate 'line', 440
    if_null rx2119_debug, debug_1522
    rx2119_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1522:
  rx2119_fail:
    (rx2119_rep, rx2119_pos, $I10, $P10) = rx2119_cur."!mark_fail"(0)
    lt rx2119_pos, -1, rx2119_done
    eq rx2119_pos, -1, rx2119_fail
    jump $I10
  rx2119_done:
    rx2119_cur."!cursor_fail"()
    if_null rx2119_debug, debug_1523
    rx2119_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1523:
    .return (rx2119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("340_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "?")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("341_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2124_tgt
    .local int rx2124_pos
    .local int rx2124_off
    .local int rx2124_eos
    .local int rx2124_rep
    .local pmc rx2124_cur
    .local pmc rx2124_debug
    (rx2124_cur, rx2124_pos, rx2124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2124_cur
    .local pmc match
    .lex "$/", match
    length rx2124_eos, rx2124_tgt
    gt rx2124_pos, rx2124_eos, rx2124_done
    set rx2124_off, 0
    lt rx2124_pos, 2, rx2124_start
    sub rx2124_off, rx2124_pos, 1
    substr rx2124_tgt, rx2124_tgt, rx2124_off
  rx2124_start:
    eq $I10, 1, rx2124_restart
    if_null rx2124_debug, debug_1524
    rx2124_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1524:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2125_done
    goto rxscan2125_scan
  rxscan2125_loop:
    (rx2124_pos) = rx2124_cur."from"()
    inc rx2124_pos
    rx2124_cur."!cursor_from"(rx2124_pos)
    ge rx2124_pos, rx2124_eos, rxscan2125_done
  rxscan2125_scan:
    set_addr $I10, rxscan2125_loop
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  rxscan2125_done:
.annotate 'line', 1109
  # rx subcapture "sym"
    set_addr $I10, rxcap_2126_fail
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  # rx literal  "!"
    add $I11, rx2124_pos, 1
    gt $I11, rx2124_eos, rx2124_fail
    sub $I11, rx2124_pos, rx2124_off
    ord $I11, rx2124_tgt, $I11
    ne $I11, 33, rx2124_fail
    add rx2124_pos, 1
    set_addr $I10, rxcap_2126_fail
    ($I12, $I11) = rx2124_cur."!mark_peek"($I10)
    rx2124_cur."!cursor_pos"($I11)
    ($P10) = rx2124_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2124_pos, "")
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2126_done
  rxcap_2126_fail:
    goto rx2124_fail
  rxcap_2126_done:
  # rx subrule "O" subtype=capture negate=
    rx2124_cur."!cursor_pos"(rx2124_pos)
    $P10 = rx2124_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2124_fail
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2124_pos = $P10."pos"()
  # rx pass
    rx2124_cur."!cursor_pass"(rx2124_pos, "prefix:sym<!>")
    if_null rx2124_debug, debug_1525
    rx2124_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2124_pos)
  debug_1525:
    .return (rx2124_cur)
  rx2124_restart:
.annotate 'line', 440
    if_null rx2124_debug, debug_1526
    rx2124_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1526:
  rx2124_fail:
    (rx2124_rep, rx2124_pos, $I10, $P10) = rx2124_cur."!mark_fail"(0)
    lt rx2124_pos, -1, rx2124_done
    eq rx2124_pos, -1, rx2124_fail
    jump $I10
  rx2124_done:
    rx2124_cur."!cursor_fail"()
    if_null rx2124_debug, debug_1527
    rx2124_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1527:
    .return (rx2124_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("342_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "!")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("343_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2129_tgt
    .local int rx2129_pos
    .local int rx2129_off
    .local int rx2129_eos
    .local int rx2129_rep
    .local pmc rx2129_cur
    .local pmc rx2129_debug
    (rx2129_cur, rx2129_pos, rx2129_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2129_cur
    .local pmc match
    .lex "$/", match
    length rx2129_eos, rx2129_tgt
    gt rx2129_pos, rx2129_eos, rx2129_done
    set rx2129_off, 0
    lt rx2129_pos, 2, rx2129_start
    sub rx2129_off, rx2129_pos, 1
    substr rx2129_tgt, rx2129_tgt, rx2129_off
  rx2129_start:
    eq $I10, 1, rx2129_restart
    if_null rx2129_debug, debug_1528
    rx2129_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1528:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2130_done
    goto rxscan2130_scan
  rxscan2130_loop:
    (rx2129_pos) = rx2129_cur."from"()
    inc rx2129_pos
    rx2129_cur."!cursor_from"(rx2129_pos)
    ge rx2129_pos, rx2129_eos, rxscan2130_done
  rxscan2130_scan:
    set_addr $I10, rxscan2130_loop
    rx2129_cur."!mark_push"(0, rx2129_pos, $I10)
  rxscan2130_done:
.annotate 'line', 1110
  # rx subcapture "sym"
    set_addr $I10, rxcap_2131_fail
    rx2129_cur."!mark_push"(0, rx2129_pos, $I10)
  # rx literal  "|"
    add $I11, rx2129_pos, 1
    gt $I11, rx2129_eos, rx2129_fail
    sub $I11, rx2129_pos, rx2129_off
    ord $I11, rx2129_tgt, $I11
    ne $I11, 124, rx2129_fail
    add rx2129_pos, 1
    set_addr $I10, rxcap_2131_fail
    ($I12, $I11) = rx2129_cur."!mark_peek"($I10)
    rx2129_cur."!cursor_pos"($I11)
    ($P10) = rx2129_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2129_pos, "")
    rx2129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2131_done
  rxcap_2131_fail:
    goto rx2129_fail
  rxcap_2131_done:
  # rx subrule "O" subtype=capture negate=
    rx2129_cur."!cursor_pos"(rx2129_pos)
    $P10 = rx2129_cur."O"("%symbolic_unary")
    unless $P10, rx2129_fail
    rx2129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2129_pos = $P10."pos"()
  # rx pass
    rx2129_cur."!cursor_pass"(rx2129_pos, "prefix:sym<|>")
    if_null rx2129_debug, debug_1529
    rx2129_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2129_pos)
  debug_1529:
    .return (rx2129_cur)
  rx2129_restart:
.annotate 'line', 440
    if_null rx2129_debug, debug_1530
    rx2129_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1530:
  rx2129_fail:
    (rx2129_rep, rx2129_pos, $I10, $P10) = rx2129_cur."!mark_fail"(0)
    lt rx2129_pos, -1, rx2129_done
    eq rx2129_pos, -1, rx2129_fail
    jump $I10
  rx2129_done:
    rx2129_cur."!cursor_fail"()
    if_null rx2129_debug, debug_1531
    rx2129_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1531:
    .return (rx2129_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("344_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("345_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2134_tgt
    .local int rx2134_pos
    .local int rx2134_off
    .local int rx2134_eos
    .local int rx2134_rep
    .local pmc rx2134_cur
    .local pmc rx2134_debug
    (rx2134_cur, rx2134_pos, rx2134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2134_cur
    .local pmc match
    .lex "$/", match
    length rx2134_eos, rx2134_tgt
    gt rx2134_pos, rx2134_eos, rx2134_done
    set rx2134_off, 0
    lt rx2134_pos, 2, rx2134_start
    sub rx2134_off, rx2134_pos, 1
    substr rx2134_tgt, rx2134_tgt, rx2134_off
  rx2134_start:
    eq $I10, 1, rx2134_restart
    if_null rx2134_debug, debug_1532
    rx2134_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1532:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2135_done
    goto rxscan2135_scan
  rxscan2135_loop:
    (rx2134_pos) = rx2134_cur."from"()
    inc rx2134_pos
    rx2134_cur."!cursor_from"(rx2134_pos)
    ge rx2134_pos, rx2134_eos, rxscan2135_done
  rxscan2135_scan:
    set_addr $I10, rxscan2135_loop
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  rxscan2135_done:
.annotate 'line', 1112
  # rx subcapture "sym"
    set_addr $I10, rxcap_2136_fail
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx literal  "*"
    add $I11, rx2134_pos, 1
    gt $I11, rx2134_eos, rx2134_fail
    sub $I11, rx2134_pos, rx2134_off
    ord $I11, rx2134_tgt, $I11
    ne $I11, 42, rx2134_fail
    add rx2134_pos, 1
    set_addr $I10, rxcap_2136_fail
    ($I12, $I11) = rx2134_cur."!mark_peek"($I10)
    rx2134_cur."!cursor_pos"($I11)
    ($P10) = rx2134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2134_pos, "")
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2136_done
  rxcap_2136_fail:
    goto rx2134_fail
  rxcap_2136_done:
  # rx subrule "O" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2134_pos = $P10."pos"()
  # rx pass
    rx2134_cur."!cursor_pass"(rx2134_pos, "infix:sym<*>")
    if_null rx2134_debug, debug_1533
    rx2134_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2134_pos)
  debug_1533:
    .return (rx2134_cur)
  rx2134_restart:
.annotate 'line', 440
    if_null rx2134_debug, debug_1534
    rx2134_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1534:
  rx2134_fail:
    (rx2134_rep, rx2134_pos, $I10, $P10) = rx2134_cur."!mark_fail"(0)
    lt rx2134_pos, -1, rx2134_done
    eq rx2134_pos, -1, rx2134_fail
    jump $I10
  rx2134_done:
    rx2134_cur."!cursor_fail"()
    if_null rx2134_debug, debug_1535
    rx2134_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1535:
    .return (rx2134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("346_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "*")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("347_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2139_tgt
    .local int rx2139_pos
    .local int rx2139_off
    .local int rx2139_eos
    .local int rx2139_rep
    .local pmc rx2139_cur
    .local pmc rx2139_debug
    (rx2139_cur, rx2139_pos, rx2139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2139_cur
    .local pmc match
    .lex "$/", match
    length rx2139_eos, rx2139_tgt
    gt rx2139_pos, rx2139_eos, rx2139_done
    set rx2139_off, 0
    lt rx2139_pos, 2, rx2139_start
    sub rx2139_off, rx2139_pos, 1
    substr rx2139_tgt, rx2139_tgt, rx2139_off
  rx2139_start:
    eq $I10, 1, rx2139_restart
    if_null rx2139_debug, debug_1536
    rx2139_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1536:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2140_done
    goto rxscan2140_scan
  rxscan2140_loop:
    (rx2139_pos) = rx2139_cur."from"()
    inc rx2139_pos
    rx2139_cur."!cursor_from"(rx2139_pos)
    ge rx2139_pos, rx2139_eos, rxscan2140_done
  rxscan2140_scan:
    set_addr $I10, rxscan2140_loop
    rx2139_cur."!mark_push"(0, rx2139_pos, $I10)
  rxscan2140_done:
.annotate 'line', 1113
  # rx subcapture "sym"
    set_addr $I10, rxcap_2141_fail
    rx2139_cur."!mark_push"(0, rx2139_pos, $I10)
  # rx literal  "/"
    add $I11, rx2139_pos, 1
    gt $I11, rx2139_eos, rx2139_fail
    sub $I11, rx2139_pos, rx2139_off
    ord $I11, rx2139_tgt, $I11
    ne $I11, 47, rx2139_fail
    add rx2139_pos, 1
    set_addr $I10, rxcap_2141_fail
    ($I12, $I11) = rx2139_cur."!mark_peek"($I10)
    rx2139_cur."!cursor_pos"($I11)
    ($P10) = rx2139_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2139_pos, "")
    rx2139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2141_done
  rxcap_2141_fail:
    goto rx2139_fail
  rxcap_2141_done:
  # rx subrule "O" subtype=capture negate=
    rx2139_cur."!cursor_pos"(rx2139_pos)
    $P10 = rx2139_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2139_fail
    rx2139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2139_pos = $P10."pos"()
  # rx pass
    rx2139_cur."!cursor_pass"(rx2139_pos, "infix:sym</>")
    if_null rx2139_debug, debug_1537
    rx2139_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2139_pos)
  debug_1537:
    .return (rx2139_cur)
  rx2139_restart:
.annotate 'line', 440
    if_null rx2139_debug, debug_1538
    rx2139_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1538:
  rx2139_fail:
    (rx2139_rep, rx2139_pos, $I10, $P10) = rx2139_cur."!mark_fail"(0)
    lt rx2139_pos, -1, rx2139_done
    eq rx2139_pos, -1, rx2139_fail
    jump $I10
  rx2139_done:
    rx2139_cur."!cursor_fail"()
    if_null rx2139_debug, debug_1539
    rx2139_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1539:
    .return (rx2139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("348_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("349_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2144_tgt
    .local int rx2144_pos
    .local int rx2144_off
    .local int rx2144_eos
    .local int rx2144_rep
    .local pmc rx2144_cur
    .local pmc rx2144_debug
    (rx2144_cur, rx2144_pos, rx2144_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2144_cur
    .local pmc match
    .lex "$/", match
    length rx2144_eos, rx2144_tgt
    gt rx2144_pos, rx2144_eos, rx2144_done
    set rx2144_off, 0
    lt rx2144_pos, 2, rx2144_start
    sub rx2144_off, rx2144_pos, 1
    substr rx2144_tgt, rx2144_tgt, rx2144_off
  rx2144_start:
    eq $I10, 1, rx2144_restart
    if_null rx2144_debug, debug_1540
    rx2144_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1540:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2145_done
    goto rxscan2145_scan
  rxscan2145_loop:
    (rx2144_pos) = rx2144_cur."from"()
    inc rx2144_pos
    rx2144_cur."!cursor_from"(rx2144_pos)
    ge rx2144_pos, rx2144_eos, rxscan2145_done
  rxscan2145_scan:
    set_addr $I10, rxscan2145_loop
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  rxscan2145_done:
.annotate 'line', 1114
  # rx subcapture "sym"
    set_addr $I10, rxcap_2146_fail
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx literal  "%"
    add $I11, rx2144_pos, 1
    gt $I11, rx2144_eos, rx2144_fail
    sub $I11, rx2144_pos, rx2144_off
    ord $I11, rx2144_tgt, $I11
    ne $I11, 37, rx2144_fail
    add rx2144_pos, 1
    set_addr $I10, rxcap_2146_fail
    ($I12, $I11) = rx2144_cur."!mark_peek"($I10)
    rx2144_cur."!cursor_pos"($I11)
    ($P10) = rx2144_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2144_pos, "")
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2146_done
  rxcap_2146_fail:
    goto rx2144_fail
  rxcap_2146_done:
  # rx subrule "O" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2144_pos = $P10."pos"()
  # rx pass
    rx2144_cur."!cursor_pass"(rx2144_pos, "infix:sym<%>")
    if_null rx2144_debug, debug_1541
    rx2144_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2144_pos)
  debug_1541:
    .return (rx2144_cur)
  rx2144_restart:
.annotate 'line', 440
    if_null rx2144_debug, debug_1542
    rx2144_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1542:
  rx2144_fail:
    (rx2144_rep, rx2144_pos, $I10, $P10) = rx2144_cur."!mark_fail"(0)
    lt rx2144_pos, -1, rx2144_done
    eq rx2144_pos, -1, rx2144_fail
    jump $I10
  rx2144_done:
    rx2144_cur."!cursor_fail"()
    if_null rx2144_debug, debug_1543
    rx2144_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1543:
    .return (rx2144_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("350_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "%")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("351_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2149_tgt
    .local int rx2149_pos
    .local int rx2149_off
    .local int rx2149_eos
    .local int rx2149_rep
    .local pmc rx2149_cur
    .local pmc rx2149_debug
    (rx2149_cur, rx2149_pos, rx2149_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2149_cur
    .local pmc match
    .lex "$/", match
    length rx2149_eos, rx2149_tgt
    gt rx2149_pos, rx2149_eos, rx2149_done
    set rx2149_off, 0
    lt rx2149_pos, 2, rx2149_start
    sub rx2149_off, rx2149_pos, 1
    substr rx2149_tgt, rx2149_tgt, rx2149_off
  rx2149_start:
    eq $I10, 1, rx2149_restart
    if_null rx2149_debug, debug_1544
    rx2149_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1544:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2150_done
    goto rxscan2150_scan
  rxscan2150_loop:
    (rx2149_pos) = rx2149_cur."from"()
    inc rx2149_pos
    rx2149_cur."!cursor_from"(rx2149_pos)
    ge rx2149_pos, rx2149_eos, rxscan2150_done
  rxscan2150_scan:
    set_addr $I10, rxscan2150_loop
    rx2149_cur."!mark_push"(0, rx2149_pos, $I10)
  rxscan2150_done:
.annotate 'line', 1115
  # rx subcapture "sym"
    set_addr $I10, rxcap_2151_fail
    rx2149_cur."!mark_push"(0, rx2149_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2149_pos, 2
    gt $I11, rx2149_eos, rx2149_fail
    sub $I11, rx2149_pos, rx2149_off
    substr $S10, rx2149_tgt, $I11, 2
    ne $S10, "+&", rx2149_fail
    add rx2149_pos, 2
    set_addr $I10, rxcap_2151_fail
    ($I12, $I11) = rx2149_cur."!mark_peek"($I10)
    rx2149_cur."!cursor_pos"($I11)
    ($P10) = rx2149_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2149_pos, "")
    rx2149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2151_done
  rxcap_2151_fail:
    goto rx2149_fail
  rxcap_2151_done:
  # rx subrule "O" subtype=capture negate=
    rx2149_cur."!cursor_pos"(rx2149_pos)
    $P10 = rx2149_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2149_fail
    rx2149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2149_pos = $P10."pos"()
  # rx pass
    rx2149_cur."!cursor_pass"(rx2149_pos, "infix:sym<+&>")
    if_null rx2149_debug, debug_1545
    rx2149_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2149_pos)
  debug_1545:
    .return (rx2149_cur)
  rx2149_restart:
.annotate 'line', 440
    if_null rx2149_debug, debug_1546
    rx2149_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1546:
  rx2149_fail:
    (rx2149_rep, rx2149_pos, $I10, $P10) = rx2149_cur."!mark_fail"(0)
    lt rx2149_pos, -1, rx2149_done
    eq rx2149_pos, -1, rx2149_fail
    jump $I10
  rx2149_done:
    rx2149_cur."!cursor_fail"()
    if_null rx2149_debug, debug_1547
    rx2149_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1547:
    .return (rx2149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("352_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "+&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("353_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2154_tgt
    .local int rx2154_pos
    .local int rx2154_off
    .local int rx2154_eos
    .local int rx2154_rep
    .local pmc rx2154_cur
    .local pmc rx2154_debug
    (rx2154_cur, rx2154_pos, rx2154_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2154_cur
    .local pmc match
    .lex "$/", match
    length rx2154_eos, rx2154_tgt
    gt rx2154_pos, rx2154_eos, rx2154_done
    set rx2154_off, 0
    lt rx2154_pos, 2, rx2154_start
    sub rx2154_off, rx2154_pos, 1
    substr rx2154_tgt, rx2154_tgt, rx2154_off
  rx2154_start:
    eq $I10, 1, rx2154_restart
    if_null rx2154_debug, debug_1548
    rx2154_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1548:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2155_done
    goto rxscan2155_scan
  rxscan2155_loop:
    (rx2154_pos) = rx2154_cur."from"()
    inc rx2154_pos
    rx2154_cur."!cursor_from"(rx2154_pos)
    ge rx2154_pos, rx2154_eos, rxscan2155_done
  rxscan2155_scan:
    set_addr $I10, rxscan2155_loop
    rx2154_cur."!mark_push"(0, rx2154_pos, $I10)
  rxscan2155_done:
.annotate 'line', 1117
  # rx subcapture "sym"
    set_addr $I10, rxcap_2156_fail
    rx2154_cur."!mark_push"(0, rx2154_pos, $I10)
  # rx literal  "+"
    add $I11, rx2154_pos, 1
    gt $I11, rx2154_eos, rx2154_fail
    sub $I11, rx2154_pos, rx2154_off
    ord $I11, rx2154_tgt, $I11
    ne $I11, 43, rx2154_fail
    add rx2154_pos, 1
    set_addr $I10, rxcap_2156_fail
    ($I12, $I11) = rx2154_cur."!mark_peek"($I10)
    rx2154_cur."!cursor_pos"($I11)
    ($P10) = rx2154_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2154_pos, "")
    rx2154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2156_done
  rxcap_2156_fail:
    goto rx2154_fail
  rxcap_2156_done:
  # rx subrule "O" subtype=capture negate=
    rx2154_cur."!cursor_pos"(rx2154_pos)
    $P10 = rx2154_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2154_fail
    rx2154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2154_pos = $P10."pos"()
  # rx pass
    rx2154_cur."!cursor_pass"(rx2154_pos, "infix:sym<+>")
    if_null rx2154_debug, debug_1549
    rx2154_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2154_pos)
  debug_1549:
    .return (rx2154_cur)
  rx2154_restart:
.annotate 'line', 440
    if_null rx2154_debug, debug_1550
    rx2154_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1550:
  rx2154_fail:
    (rx2154_rep, rx2154_pos, $I10, $P10) = rx2154_cur."!mark_fail"(0)
    lt rx2154_pos, -1, rx2154_done
    eq rx2154_pos, -1, rx2154_fail
    jump $I10
  rx2154_done:
    rx2154_cur."!cursor_fail"()
    if_null rx2154_debug, debug_1551
    rx2154_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1551:
    .return (rx2154_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("354_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("355_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2159_tgt
    .local int rx2159_pos
    .local int rx2159_off
    .local int rx2159_eos
    .local int rx2159_rep
    .local pmc rx2159_cur
    .local pmc rx2159_debug
    (rx2159_cur, rx2159_pos, rx2159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2159_cur
    .local pmc match
    .lex "$/", match
    length rx2159_eos, rx2159_tgt
    gt rx2159_pos, rx2159_eos, rx2159_done
    set rx2159_off, 0
    lt rx2159_pos, 2, rx2159_start
    sub rx2159_off, rx2159_pos, 1
    substr rx2159_tgt, rx2159_tgt, rx2159_off
  rx2159_start:
    eq $I10, 1, rx2159_restart
    if_null rx2159_debug, debug_1552
    rx2159_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1552:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2160_done
    goto rxscan2160_scan
  rxscan2160_loop:
    (rx2159_pos) = rx2159_cur."from"()
    inc rx2159_pos
    rx2159_cur."!cursor_from"(rx2159_pos)
    ge rx2159_pos, rx2159_eos, rxscan2160_done
  rxscan2160_scan:
    set_addr $I10, rxscan2160_loop
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  rxscan2160_done:
.annotate 'line', 1118
  # rx subcapture "sym"
    set_addr $I10, rxcap_2161_fail
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  # rx literal  "-"
    add $I11, rx2159_pos, 1
    gt $I11, rx2159_eos, rx2159_fail
    sub $I11, rx2159_pos, rx2159_off
    ord $I11, rx2159_tgt, $I11
    ne $I11, 45, rx2159_fail
    add rx2159_pos, 1
    set_addr $I10, rxcap_2161_fail
    ($I12, $I11) = rx2159_cur."!mark_peek"($I10)
    rx2159_cur."!cursor_pos"($I11)
    ($P10) = rx2159_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2159_pos, "")
    rx2159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2161_done
  rxcap_2161_fail:
    goto rx2159_fail
  rxcap_2161_done:
  # rx subrule "O" subtype=capture negate=
    rx2159_cur."!cursor_pos"(rx2159_pos)
    $P10 = rx2159_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2159_fail
    rx2159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2159_pos = $P10."pos"()
  # rx pass
    rx2159_cur."!cursor_pass"(rx2159_pos, "infix:sym<->")
    if_null rx2159_debug, debug_1553
    rx2159_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2159_pos)
  debug_1553:
    .return (rx2159_cur)
  rx2159_restart:
.annotate 'line', 440
    if_null rx2159_debug, debug_1554
    rx2159_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1554:
  rx2159_fail:
    (rx2159_rep, rx2159_pos, $I10, $P10) = rx2159_cur."!mark_fail"(0)
    lt rx2159_pos, -1, rx2159_done
    eq rx2159_pos, -1, rx2159_fail
    jump $I10
  rx2159_done:
    rx2159_cur."!cursor_fail"()
    if_null rx2159_debug, debug_1555
    rx2159_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1555:
    .return (rx2159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("356_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "-")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("357_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2164_tgt
    .local int rx2164_pos
    .local int rx2164_off
    .local int rx2164_eos
    .local int rx2164_rep
    .local pmc rx2164_cur
    .local pmc rx2164_debug
    (rx2164_cur, rx2164_pos, rx2164_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2164_cur
    .local pmc match
    .lex "$/", match
    length rx2164_eos, rx2164_tgt
    gt rx2164_pos, rx2164_eos, rx2164_done
    set rx2164_off, 0
    lt rx2164_pos, 2, rx2164_start
    sub rx2164_off, rx2164_pos, 1
    substr rx2164_tgt, rx2164_tgt, rx2164_off
  rx2164_start:
    eq $I10, 1, rx2164_restart
    if_null rx2164_debug, debug_1556
    rx2164_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1556:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2165_done
    goto rxscan2165_scan
  rxscan2165_loop:
    (rx2164_pos) = rx2164_cur."from"()
    inc rx2164_pos
    rx2164_cur."!cursor_from"(rx2164_pos)
    ge rx2164_pos, rx2164_eos, rxscan2165_done
  rxscan2165_scan:
    set_addr $I10, rxscan2165_loop
    rx2164_cur."!mark_push"(0, rx2164_pos, $I10)
  rxscan2165_done:
.annotate 'line', 1119
  # rx subcapture "sym"
    set_addr $I10, rxcap_2166_fail
    rx2164_cur."!mark_push"(0, rx2164_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2164_pos, 2
    gt $I11, rx2164_eos, rx2164_fail
    sub $I11, rx2164_pos, rx2164_off
    substr $S10, rx2164_tgt, $I11, 2
    ne $S10, "+|", rx2164_fail
    add rx2164_pos, 2
    set_addr $I10, rxcap_2166_fail
    ($I12, $I11) = rx2164_cur."!mark_peek"($I10)
    rx2164_cur."!cursor_pos"($I11)
    ($P10) = rx2164_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2164_pos, "")
    rx2164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2166_done
  rxcap_2166_fail:
    goto rx2164_fail
  rxcap_2166_done:
  # rx subrule "O" subtype=capture negate=
    rx2164_cur."!cursor_pos"(rx2164_pos)
    $P10 = rx2164_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2164_fail
    rx2164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2164_pos = $P10."pos"()
  # rx pass
    rx2164_cur."!cursor_pass"(rx2164_pos, "infix:sym<+|>")
    if_null rx2164_debug, debug_1557
    rx2164_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2164_pos)
  debug_1557:
    .return (rx2164_cur)
  rx2164_restart:
.annotate 'line', 440
    if_null rx2164_debug, debug_1558
    rx2164_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1558:
  rx2164_fail:
    (rx2164_rep, rx2164_pos, $I10, $P10) = rx2164_cur."!mark_fail"(0)
    lt rx2164_pos, -1, rx2164_done
    eq rx2164_pos, -1, rx2164_fail
    jump $I10
  rx2164_done:
    rx2164_cur."!cursor_fail"()
    if_null rx2164_debug, debug_1559
    rx2164_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1559:
    .return (rx2164_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("358_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "+|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("359_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2169_tgt
    .local int rx2169_pos
    .local int rx2169_off
    .local int rx2169_eos
    .local int rx2169_rep
    .local pmc rx2169_cur
    .local pmc rx2169_debug
    (rx2169_cur, rx2169_pos, rx2169_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2169_cur
    .local pmc match
    .lex "$/", match
    length rx2169_eos, rx2169_tgt
    gt rx2169_pos, rx2169_eos, rx2169_done
    set rx2169_off, 0
    lt rx2169_pos, 2, rx2169_start
    sub rx2169_off, rx2169_pos, 1
    substr rx2169_tgt, rx2169_tgt, rx2169_off
  rx2169_start:
    eq $I10, 1, rx2169_restart
    if_null rx2169_debug, debug_1560
    rx2169_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1560:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2170_done
    goto rxscan2170_scan
  rxscan2170_loop:
    (rx2169_pos) = rx2169_cur."from"()
    inc rx2169_pos
    rx2169_cur."!cursor_from"(rx2169_pos)
    ge rx2169_pos, rx2169_eos, rxscan2170_done
  rxscan2170_scan:
    set_addr $I10, rxscan2170_loop
    rx2169_cur."!mark_push"(0, rx2169_pos, $I10)
  rxscan2170_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2171_fail
    rx2169_cur."!mark_push"(0, rx2169_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2169_pos, 2
    gt $I11, rx2169_eos, rx2169_fail
    sub $I11, rx2169_pos, rx2169_off
    substr $S10, rx2169_tgt, $I11, 2
    ne $S10, "+^", rx2169_fail
    add rx2169_pos, 2
    set_addr $I10, rxcap_2171_fail
    ($I12, $I11) = rx2169_cur."!mark_peek"($I10)
    rx2169_cur."!cursor_pos"($I11)
    ($P10) = rx2169_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2169_pos, "")
    rx2169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2171_done
  rxcap_2171_fail:
    goto rx2169_fail
  rxcap_2171_done:
  # rx subrule "O" subtype=capture negate=
    rx2169_cur."!cursor_pos"(rx2169_pos)
    $P10 = rx2169_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2169_fail
    rx2169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2169_pos = $P10."pos"()
  # rx pass
    rx2169_cur."!cursor_pass"(rx2169_pos, "infix:sym<+^>")
    if_null rx2169_debug, debug_1561
    rx2169_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2169_pos)
  debug_1561:
    .return (rx2169_cur)
  rx2169_restart:
.annotate 'line', 440
    if_null rx2169_debug, debug_1562
    rx2169_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1562:
  rx2169_fail:
    (rx2169_rep, rx2169_pos, $I10, $P10) = rx2169_cur."!mark_fail"(0)
    lt rx2169_pos, -1, rx2169_done
    eq rx2169_pos, -1, rx2169_fail
    jump $I10
  rx2169_done:
    rx2169_cur."!cursor_fail"()
    if_null rx2169_debug, debug_1563
    rx2169_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1563:
    .return (rx2169_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("360_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "+^")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("361_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2174_tgt
    .local int rx2174_pos
    .local int rx2174_off
    .local int rx2174_eos
    .local int rx2174_rep
    .local pmc rx2174_cur
    .local pmc rx2174_debug
    (rx2174_cur, rx2174_pos, rx2174_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2174_cur
    .local pmc match
    .lex "$/", match
    length rx2174_eos, rx2174_tgt
    gt rx2174_pos, rx2174_eos, rx2174_done
    set rx2174_off, 0
    lt rx2174_pos, 2, rx2174_start
    sub rx2174_off, rx2174_pos, 1
    substr rx2174_tgt, rx2174_tgt, rx2174_off
  rx2174_start:
    eq $I10, 1, rx2174_restart
    if_null rx2174_debug, debug_1564
    rx2174_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1564:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2175_done
    goto rxscan2175_scan
  rxscan2175_loop:
    (rx2174_pos) = rx2174_cur."from"()
    inc rx2174_pos
    rx2174_cur."!cursor_from"(rx2174_pos)
    ge rx2174_pos, rx2174_eos, rxscan2175_done
  rxscan2175_scan:
    set_addr $I10, rxscan2175_loop
    rx2174_cur."!mark_push"(0, rx2174_pos, $I10)
  rxscan2175_done:
.annotate 'line', 1122
  # rx subcapture "sym"
    set_addr $I10, rxcap_2176_fail
    rx2174_cur."!mark_push"(0, rx2174_pos, $I10)
  # rx literal  "~"
    add $I11, rx2174_pos, 1
    gt $I11, rx2174_eos, rx2174_fail
    sub $I11, rx2174_pos, rx2174_off
    ord $I11, rx2174_tgt, $I11
    ne $I11, 126, rx2174_fail
    add rx2174_pos, 1
    set_addr $I10, rxcap_2176_fail
    ($I12, $I11) = rx2174_cur."!mark_peek"($I10)
    rx2174_cur."!cursor_pos"($I11)
    ($P10) = rx2174_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2174_pos, "")
    rx2174_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2176_done
  rxcap_2176_fail:
    goto rx2174_fail
  rxcap_2176_done:
  # rx subrule "O" subtype=capture negate=
    rx2174_cur."!cursor_pos"(rx2174_pos)
    $P10 = rx2174_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2174_fail
    rx2174_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2174_pos = $P10."pos"()
  # rx pass
    rx2174_cur."!cursor_pass"(rx2174_pos, "infix:sym<~>")
    if_null rx2174_debug, debug_1565
    rx2174_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2174_pos)
  debug_1565:
    .return (rx2174_cur)
  rx2174_restart:
.annotate 'line', 440
    if_null rx2174_debug, debug_1566
    rx2174_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1566:
  rx2174_fail:
    (rx2174_rep, rx2174_pos, $I10, $P10) = rx2174_cur."!mark_fail"(0)
    lt rx2174_pos, -1, rx2174_done
    eq rx2174_pos, -1, rx2174_fail
    jump $I10
  rx2174_done:
    rx2174_cur."!cursor_fail"()
    if_null rx2174_debug, debug_1567
    rx2174_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1567:
    .return (rx2174_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("362_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("363_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2179_tgt
    .local int rx2179_pos
    .local int rx2179_off
    .local int rx2179_eos
    .local int rx2179_rep
    .local pmc rx2179_cur
    .local pmc rx2179_debug
    (rx2179_cur, rx2179_pos, rx2179_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2179_cur
    .local pmc match
    .lex "$/", match
    length rx2179_eos, rx2179_tgt
    gt rx2179_pos, rx2179_eos, rx2179_done
    set rx2179_off, 0
    lt rx2179_pos, 2, rx2179_start
    sub rx2179_off, rx2179_pos, 1
    substr rx2179_tgt, rx2179_tgt, rx2179_off
  rx2179_start:
    eq $I10, 1, rx2179_restart
    if_null rx2179_debug, debug_1568
    rx2179_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1568:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2180_done
    goto rxscan2180_scan
  rxscan2180_loop:
    (rx2179_pos) = rx2179_cur."from"()
    inc rx2179_pos
    rx2179_cur."!cursor_from"(rx2179_pos)
    ge rx2179_pos, rx2179_eos, rxscan2180_done
  rxscan2180_scan:
    set_addr $I10, rxscan2180_loop
    rx2179_cur."!mark_push"(0, rx2179_pos, $I10)
  rxscan2180_done:
.annotate 'line', 1124
  # rx subcapture "sym"
    set_addr $I10, rxcap_2181_fail
    rx2179_cur."!mark_push"(0, rx2179_pos, $I10)
  # rx literal  "=="
    add $I11, rx2179_pos, 2
    gt $I11, rx2179_eos, rx2179_fail
    sub $I11, rx2179_pos, rx2179_off
    substr $S10, rx2179_tgt, $I11, 2
    ne $S10, "==", rx2179_fail
    add rx2179_pos, 2
    set_addr $I10, rxcap_2181_fail
    ($I12, $I11) = rx2179_cur."!mark_peek"($I10)
    rx2179_cur."!cursor_pos"($I11)
    ($P10) = rx2179_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2179_pos, "")
    rx2179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2181_done
  rxcap_2181_fail:
    goto rx2179_fail
  rxcap_2181_done:
  # rx subrule "O" subtype=capture negate=
    rx2179_cur."!cursor_pos"(rx2179_pos)
    $P10 = rx2179_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2179_fail
    rx2179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2179_pos = $P10."pos"()
  # rx pass
    rx2179_cur."!cursor_pass"(rx2179_pos, "infix:sym<==>")
    if_null rx2179_debug, debug_1569
    rx2179_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2179_pos)
  debug_1569:
    .return (rx2179_cur)
  rx2179_restart:
.annotate 'line', 440
    if_null rx2179_debug, debug_1570
    rx2179_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1570:
  rx2179_fail:
    (rx2179_rep, rx2179_pos, $I10, $P10) = rx2179_cur."!mark_fail"(0)
    lt rx2179_pos, -1, rx2179_done
    eq rx2179_pos, -1, rx2179_fail
    jump $I10
  rx2179_done:
    rx2179_cur."!cursor_fail"()
    if_null rx2179_debug, debug_1571
    rx2179_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1571:
    .return (rx2179_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("364_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "==")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("365_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2184_tgt
    .local int rx2184_pos
    .local int rx2184_off
    .local int rx2184_eos
    .local int rx2184_rep
    .local pmc rx2184_cur
    .local pmc rx2184_debug
    (rx2184_cur, rx2184_pos, rx2184_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2184_cur
    .local pmc match
    .lex "$/", match
    length rx2184_eos, rx2184_tgt
    gt rx2184_pos, rx2184_eos, rx2184_done
    set rx2184_off, 0
    lt rx2184_pos, 2, rx2184_start
    sub rx2184_off, rx2184_pos, 1
    substr rx2184_tgt, rx2184_tgt, rx2184_off
  rx2184_start:
    eq $I10, 1, rx2184_restart
    if_null rx2184_debug, debug_1572
    rx2184_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1572:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2185_done
    goto rxscan2185_scan
  rxscan2185_loop:
    (rx2184_pos) = rx2184_cur."from"()
    inc rx2184_pos
    rx2184_cur."!cursor_from"(rx2184_pos)
    ge rx2184_pos, rx2184_eos, rxscan2185_done
  rxscan2185_scan:
    set_addr $I10, rxscan2185_loop
    rx2184_cur."!mark_push"(0, rx2184_pos, $I10)
  rxscan2185_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2186_fail
    rx2184_cur."!mark_push"(0, rx2184_pos, $I10)
  # rx literal  "!="
    add $I11, rx2184_pos, 2
    gt $I11, rx2184_eos, rx2184_fail
    sub $I11, rx2184_pos, rx2184_off
    substr $S10, rx2184_tgt, $I11, 2
    ne $S10, "!=", rx2184_fail
    add rx2184_pos, 2
    set_addr $I10, rxcap_2186_fail
    ($I12, $I11) = rx2184_cur."!mark_peek"($I10)
    rx2184_cur."!cursor_pos"($I11)
    ($P10) = rx2184_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2184_pos, "")
    rx2184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2186_done
  rxcap_2186_fail:
    goto rx2184_fail
  rxcap_2186_done:
  # rx subrule "O" subtype=capture negate=
    rx2184_cur."!cursor_pos"(rx2184_pos)
    $P10 = rx2184_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2184_fail
    rx2184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2184_pos = $P10."pos"()
  # rx pass
    rx2184_cur."!cursor_pass"(rx2184_pos, "infix:sym<!=>")
    if_null rx2184_debug, debug_1573
    rx2184_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2184_pos)
  debug_1573:
    .return (rx2184_cur)
  rx2184_restart:
.annotate 'line', 440
    if_null rx2184_debug, debug_1574
    rx2184_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1574:
  rx2184_fail:
    (rx2184_rep, rx2184_pos, $I10, $P10) = rx2184_cur."!mark_fail"(0)
    lt rx2184_pos, -1, rx2184_done
    eq rx2184_pos, -1, rx2184_fail
    jump $I10
  rx2184_done:
    rx2184_cur."!cursor_fail"()
    if_null rx2184_debug, debug_1575
    rx2184_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1575:
    .return (rx2184_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("366_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "!=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("367_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2189_tgt
    .local int rx2189_pos
    .local int rx2189_off
    .local int rx2189_eos
    .local int rx2189_rep
    .local pmc rx2189_cur
    .local pmc rx2189_debug
    (rx2189_cur, rx2189_pos, rx2189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2189_cur
    .local pmc match
    .lex "$/", match
    length rx2189_eos, rx2189_tgt
    gt rx2189_pos, rx2189_eos, rx2189_done
    set rx2189_off, 0
    lt rx2189_pos, 2, rx2189_start
    sub rx2189_off, rx2189_pos, 1
    substr rx2189_tgt, rx2189_tgt, rx2189_off
  rx2189_start:
    eq $I10, 1, rx2189_restart
    if_null rx2189_debug, debug_1576
    rx2189_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1576:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2190_done
    goto rxscan2190_scan
  rxscan2190_loop:
    (rx2189_pos) = rx2189_cur."from"()
    inc rx2189_pos
    rx2189_cur."!cursor_from"(rx2189_pos)
    ge rx2189_pos, rx2189_eos, rxscan2190_done
  rxscan2190_scan:
    set_addr $I10, rxscan2190_loop
    rx2189_cur."!mark_push"(0, rx2189_pos, $I10)
  rxscan2190_done:
.annotate 'line', 1126
  # rx subcapture "sym"
    set_addr $I10, rxcap_2191_fail
    rx2189_cur."!mark_push"(0, rx2189_pos, $I10)
  # rx literal  "<="
    add $I11, rx2189_pos, 2
    gt $I11, rx2189_eos, rx2189_fail
    sub $I11, rx2189_pos, rx2189_off
    substr $S10, rx2189_tgt, $I11, 2
    ne $S10, "<=", rx2189_fail
    add rx2189_pos, 2
    set_addr $I10, rxcap_2191_fail
    ($I12, $I11) = rx2189_cur."!mark_peek"($I10)
    rx2189_cur."!cursor_pos"($I11)
    ($P10) = rx2189_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2189_pos, "")
    rx2189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2191_done
  rxcap_2191_fail:
    goto rx2189_fail
  rxcap_2191_done:
  # rx subrule "O" subtype=capture negate=
    rx2189_cur."!cursor_pos"(rx2189_pos)
    $P10 = rx2189_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2189_fail
    rx2189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2189_pos = $P10."pos"()
  # rx pass
    rx2189_cur."!cursor_pass"(rx2189_pos, "infix:sym<<=>")
    if_null rx2189_debug, debug_1577
    rx2189_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2189_pos)
  debug_1577:
    .return (rx2189_cur)
  rx2189_restart:
.annotate 'line', 440
    if_null rx2189_debug, debug_1578
    rx2189_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1578:
  rx2189_fail:
    (rx2189_rep, rx2189_pos, $I10, $P10) = rx2189_cur."!mark_fail"(0)
    lt rx2189_pos, -1, rx2189_done
    eq rx2189_pos, -1, rx2189_fail
    jump $I10
  rx2189_done:
    rx2189_cur."!cursor_fail"()
    if_null rx2189_debug, debug_1579
    rx2189_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1579:
    .return (rx2189_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("368_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "<=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("369_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2194_tgt
    .local int rx2194_pos
    .local int rx2194_off
    .local int rx2194_eos
    .local int rx2194_rep
    .local pmc rx2194_cur
    .local pmc rx2194_debug
    (rx2194_cur, rx2194_pos, rx2194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2194_cur
    .local pmc match
    .lex "$/", match
    length rx2194_eos, rx2194_tgt
    gt rx2194_pos, rx2194_eos, rx2194_done
    set rx2194_off, 0
    lt rx2194_pos, 2, rx2194_start
    sub rx2194_off, rx2194_pos, 1
    substr rx2194_tgt, rx2194_tgt, rx2194_off
  rx2194_start:
    eq $I10, 1, rx2194_restart
    if_null rx2194_debug, debug_1580
    rx2194_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1580:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2195_done
    goto rxscan2195_scan
  rxscan2195_loop:
    (rx2194_pos) = rx2194_cur."from"()
    inc rx2194_pos
    rx2194_cur."!cursor_from"(rx2194_pos)
    ge rx2194_pos, rx2194_eos, rxscan2195_done
  rxscan2195_scan:
    set_addr $I10, rxscan2195_loop
    rx2194_cur."!mark_push"(0, rx2194_pos, $I10)
  rxscan2195_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2196_fail
    rx2194_cur."!mark_push"(0, rx2194_pos, $I10)
  # rx literal  ">="
    add $I11, rx2194_pos, 2
    gt $I11, rx2194_eos, rx2194_fail
    sub $I11, rx2194_pos, rx2194_off
    substr $S10, rx2194_tgt, $I11, 2
    ne $S10, ">=", rx2194_fail
    add rx2194_pos, 2
    set_addr $I10, rxcap_2196_fail
    ($I12, $I11) = rx2194_cur."!mark_peek"($I10)
    rx2194_cur."!cursor_pos"($I11)
    ($P10) = rx2194_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2194_pos, "")
    rx2194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2196_done
  rxcap_2196_fail:
    goto rx2194_fail
  rxcap_2196_done:
  # rx subrule "O" subtype=capture negate=
    rx2194_cur."!cursor_pos"(rx2194_pos)
    $P10 = rx2194_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2194_fail
    rx2194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2194_pos = $P10."pos"()
  # rx pass
    rx2194_cur."!cursor_pass"(rx2194_pos, "infix:sym<>=>")
    if_null rx2194_debug, debug_1581
    rx2194_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2194_pos)
  debug_1581:
    .return (rx2194_cur)
  rx2194_restart:
.annotate 'line', 440
    if_null rx2194_debug, debug_1582
    rx2194_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1582:
  rx2194_fail:
    (rx2194_rep, rx2194_pos, $I10, $P10) = rx2194_cur."!mark_fail"(0)
    lt rx2194_pos, -1, rx2194_done
    eq rx2194_pos, -1, rx2194_fail
    jump $I10
  rx2194_done:
    rx2194_cur."!cursor_fail"()
    if_null rx2194_debug, debug_1583
    rx2194_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1583:
    .return (rx2194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("370_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", ">=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("371_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2199_tgt
    .local int rx2199_pos
    .local int rx2199_off
    .local int rx2199_eos
    .local int rx2199_rep
    .local pmc rx2199_cur
    .local pmc rx2199_debug
    (rx2199_cur, rx2199_pos, rx2199_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2199_cur
    .local pmc match
    .lex "$/", match
    length rx2199_eos, rx2199_tgt
    gt rx2199_pos, rx2199_eos, rx2199_done
    set rx2199_off, 0
    lt rx2199_pos, 2, rx2199_start
    sub rx2199_off, rx2199_pos, 1
    substr rx2199_tgt, rx2199_tgt, rx2199_off
  rx2199_start:
    eq $I10, 1, rx2199_restart
    if_null rx2199_debug, debug_1584
    rx2199_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1584:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2200_done
    goto rxscan2200_scan
  rxscan2200_loop:
    (rx2199_pos) = rx2199_cur."from"()
    inc rx2199_pos
    rx2199_cur."!cursor_from"(rx2199_pos)
    ge rx2199_pos, rx2199_eos, rxscan2200_done
  rxscan2200_scan:
    set_addr $I10, rxscan2200_loop
    rx2199_cur."!mark_push"(0, rx2199_pos, $I10)
  rxscan2200_done:
.annotate 'line', 1128
  # rx subcapture "sym"
    set_addr $I10, rxcap_2201_fail
    rx2199_cur."!mark_push"(0, rx2199_pos, $I10)
  # rx literal  "<"
    add $I11, rx2199_pos, 1
    gt $I11, rx2199_eos, rx2199_fail
    sub $I11, rx2199_pos, rx2199_off
    ord $I11, rx2199_tgt, $I11
    ne $I11, 60, rx2199_fail
    add rx2199_pos, 1
    set_addr $I10, rxcap_2201_fail
    ($I12, $I11) = rx2199_cur."!mark_peek"($I10)
    rx2199_cur."!cursor_pos"($I11)
    ($P10) = rx2199_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2199_pos, "")
    rx2199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2201_done
  rxcap_2201_fail:
    goto rx2199_fail
  rxcap_2201_done:
  # rx subrule "O" subtype=capture negate=
    rx2199_cur."!cursor_pos"(rx2199_pos)
    $P10 = rx2199_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2199_fail
    rx2199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2199_pos = $P10."pos"()
  # rx pass
    rx2199_cur."!cursor_pass"(rx2199_pos, "infix:sym<<>")
    if_null rx2199_debug, debug_1585
    rx2199_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2199_pos)
  debug_1585:
    .return (rx2199_cur)
  rx2199_restart:
.annotate 'line', 440
    if_null rx2199_debug, debug_1586
    rx2199_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1586:
  rx2199_fail:
    (rx2199_rep, rx2199_pos, $I10, $P10) = rx2199_cur."!mark_fail"(0)
    lt rx2199_pos, -1, rx2199_done
    eq rx2199_pos, -1, rx2199_fail
    jump $I10
  rx2199_done:
    rx2199_cur."!cursor_fail"()
    if_null rx2199_debug, debug_1587
    rx2199_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1587:
    .return (rx2199_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("372_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "<")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("373_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2204_tgt
    .local int rx2204_pos
    .local int rx2204_off
    .local int rx2204_eos
    .local int rx2204_rep
    .local pmc rx2204_cur
    .local pmc rx2204_debug
    (rx2204_cur, rx2204_pos, rx2204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2204_cur
    .local pmc match
    .lex "$/", match
    length rx2204_eos, rx2204_tgt
    gt rx2204_pos, rx2204_eos, rx2204_done
    set rx2204_off, 0
    lt rx2204_pos, 2, rx2204_start
    sub rx2204_off, rx2204_pos, 1
    substr rx2204_tgt, rx2204_tgt, rx2204_off
  rx2204_start:
    eq $I10, 1, rx2204_restart
    if_null rx2204_debug, debug_1588
    rx2204_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1588:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2205_done
    goto rxscan2205_scan
  rxscan2205_loop:
    (rx2204_pos) = rx2204_cur."from"()
    inc rx2204_pos
    rx2204_cur."!cursor_from"(rx2204_pos)
    ge rx2204_pos, rx2204_eos, rxscan2205_done
  rxscan2205_scan:
    set_addr $I10, rxscan2205_loop
    rx2204_cur."!mark_push"(0, rx2204_pos, $I10)
  rxscan2205_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2206_fail
    rx2204_cur."!mark_push"(0, rx2204_pos, $I10)
  # rx literal  ">"
    add $I11, rx2204_pos, 1
    gt $I11, rx2204_eos, rx2204_fail
    sub $I11, rx2204_pos, rx2204_off
    ord $I11, rx2204_tgt, $I11
    ne $I11, 62, rx2204_fail
    add rx2204_pos, 1
    set_addr $I10, rxcap_2206_fail
    ($I12, $I11) = rx2204_cur."!mark_peek"($I10)
    rx2204_cur."!cursor_pos"($I11)
    ($P10) = rx2204_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2204_pos, "")
    rx2204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2206_done
  rxcap_2206_fail:
    goto rx2204_fail
  rxcap_2206_done:
  # rx subrule "O" subtype=capture negate=
    rx2204_cur."!cursor_pos"(rx2204_pos)
    $P10 = rx2204_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2204_fail
    rx2204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2204_pos = $P10."pos"()
  # rx pass
    rx2204_cur."!cursor_pass"(rx2204_pos, "infix:sym<>>")
    if_null rx2204_debug, debug_1589
    rx2204_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2204_pos)
  debug_1589:
    .return (rx2204_cur)
  rx2204_restart:
.annotate 'line', 440
    if_null rx2204_debug, debug_1590
    rx2204_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1590:
  rx2204_fail:
    (rx2204_rep, rx2204_pos, $I10, $P10) = rx2204_cur."!mark_fail"(0)
    lt rx2204_pos, -1, rx2204_done
    eq rx2204_pos, -1, rx2204_fail
    jump $I10
  rx2204_done:
    rx2204_cur."!cursor_fail"()
    if_null rx2204_debug, debug_1591
    rx2204_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1591:
    .return (rx2204_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("374_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", ">")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("375_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2209_tgt
    .local int rx2209_pos
    .local int rx2209_off
    .local int rx2209_eos
    .local int rx2209_rep
    .local pmc rx2209_cur
    .local pmc rx2209_debug
    (rx2209_cur, rx2209_pos, rx2209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2209_cur
    .local pmc match
    .lex "$/", match
    length rx2209_eos, rx2209_tgt
    gt rx2209_pos, rx2209_eos, rx2209_done
    set rx2209_off, 0
    lt rx2209_pos, 2, rx2209_start
    sub rx2209_off, rx2209_pos, 1
    substr rx2209_tgt, rx2209_tgt, rx2209_off
  rx2209_start:
    eq $I10, 1, rx2209_restart
    if_null rx2209_debug, debug_1592
    rx2209_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1592:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2210_done
    goto rxscan2210_scan
  rxscan2210_loop:
    (rx2209_pos) = rx2209_cur."from"()
    inc rx2209_pos
    rx2209_cur."!cursor_from"(rx2209_pos)
    ge rx2209_pos, rx2209_eos, rxscan2210_done
  rxscan2210_scan:
    set_addr $I10, rxscan2210_loop
    rx2209_cur."!mark_push"(0, rx2209_pos, $I10)
  rxscan2210_done:
.annotate 'line', 1130
  # rx subcapture "sym"
    set_addr $I10, rxcap_2211_fail
    rx2209_cur."!mark_push"(0, rx2209_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2209_pos, 2
    gt $I11, rx2209_eos, rx2209_fail
    sub $I11, rx2209_pos, rx2209_off
    substr $S10, rx2209_tgt, $I11, 2
    ne $S10, "eq", rx2209_fail
    add rx2209_pos, 2
    set_addr $I10, rxcap_2211_fail
    ($I12, $I11) = rx2209_cur."!mark_peek"($I10)
    rx2209_cur."!cursor_pos"($I11)
    ($P10) = rx2209_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2209_pos, "")
    rx2209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2211_done
  rxcap_2211_fail:
    goto rx2209_fail
  rxcap_2211_done:
  # rx subrule "O" subtype=capture negate=
    rx2209_cur."!cursor_pos"(rx2209_pos)
    $P10 = rx2209_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2209_fail
    rx2209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2209_pos = $P10."pos"()
  # rx pass
    rx2209_cur."!cursor_pass"(rx2209_pos, "infix:sym<eq>")
    if_null rx2209_debug, debug_1593
    rx2209_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2209_pos)
  debug_1593:
    .return (rx2209_cur)
  rx2209_restart:
.annotate 'line', 440
    if_null rx2209_debug, debug_1594
    rx2209_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1594:
  rx2209_fail:
    (rx2209_rep, rx2209_pos, $I10, $P10) = rx2209_cur."!mark_fail"(0)
    lt rx2209_pos, -1, rx2209_done
    eq rx2209_pos, -1, rx2209_fail
    jump $I10
  rx2209_done:
    rx2209_cur."!cursor_fail"()
    if_null rx2209_debug, debug_1595
    rx2209_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1595:
    .return (rx2209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("376_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "eq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("377_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2214_tgt
    .local int rx2214_pos
    .local int rx2214_off
    .local int rx2214_eos
    .local int rx2214_rep
    .local pmc rx2214_cur
    .local pmc rx2214_debug
    (rx2214_cur, rx2214_pos, rx2214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2214_cur
    .local pmc match
    .lex "$/", match
    length rx2214_eos, rx2214_tgt
    gt rx2214_pos, rx2214_eos, rx2214_done
    set rx2214_off, 0
    lt rx2214_pos, 2, rx2214_start
    sub rx2214_off, rx2214_pos, 1
    substr rx2214_tgt, rx2214_tgt, rx2214_off
  rx2214_start:
    eq $I10, 1, rx2214_restart
    if_null rx2214_debug, debug_1596
    rx2214_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1596:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2215_done
    goto rxscan2215_scan
  rxscan2215_loop:
    (rx2214_pos) = rx2214_cur."from"()
    inc rx2214_pos
    rx2214_cur."!cursor_from"(rx2214_pos)
    ge rx2214_pos, rx2214_eos, rxscan2215_done
  rxscan2215_scan:
    set_addr $I10, rxscan2215_loop
    rx2214_cur."!mark_push"(0, rx2214_pos, $I10)
  rxscan2215_done:
.annotate 'line', 1131
  # rx subcapture "sym"
    set_addr $I10, rxcap_2216_fail
    rx2214_cur."!mark_push"(0, rx2214_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2214_pos, 2
    gt $I11, rx2214_eos, rx2214_fail
    sub $I11, rx2214_pos, rx2214_off
    substr $S10, rx2214_tgt, $I11, 2
    ne $S10, "ne", rx2214_fail
    add rx2214_pos, 2
    set_addr $I10, rxcap_2216_fail
    ($I12, $I11) = rx2214_cur."!mark_peek"($I10)
    rx2214_cur."!cursor_pos"($I11)
    ($P10) = rx2214_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2214_pos, "")
    rx2214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2216_done
  rxcap_2216_fail:
    goto rx2214_fail
  rxcap_2216_done:
  # rx subrule "O" subtype=capture negate=
    rx2214_cur."!cursor_pos"(rx2214_pos)
    $P10 = rx2214_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2214_fail
    rx2214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2214_pos = $P10."pos"()
  # rx pass
    rx2214_cur."!cursor_pass"(rx2214_pos, "infix:sym<ne>")
    if_null rx2214_debug, debug_1597
    rx2214_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2214_pos)
  debug_1597:
    .return (rx2214_cur)
  rx2214_restart:
.annotate 'line', 440
    if_null rx2214_debug, debug_1598
    rx2214_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1598:
  rx2214_fail:
    (rx2214_rep, rx2214_pos, $I10, $P10) = rx2214_cur."!mark_fail"(0)
    lt rx2214_pos, -1, rx2214_done
    eq rx2214_pos, -1, rx2214_fail
    jump $I10
  rx2214_done:
    rx2214_cur."!cursor_fail"()
    if_null rx2214_debug, debug_1599
    rx2214_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1599:
    .return (rx2214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("378_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "ne")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("379_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2219_tgt
    .local int rx2219_pos
    .local int rx2219_off
    .local int rx2219_eos
    .local int rx2219_rep
    .local pmc rx2219_cur
    .local pmc rx2219_debug
    (rx2219_cur, rx2219_pos, rx2219_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2219_cur
    .local pmc match
    .lex "$/", match
    length rx2219_eos, rx2219_tgt
    gt rx2219_pos, rx2219_eos, rx2219_done
    set rx2219_off, 0
    lt rx2219_pos, 2, rx2219_start
    sub rx2219_off, rx2219_pos, 1
    substr rx2219_tgt, rx2219_tgt, rx2219_off
  rx2219_start:
    eq $I10, 1, rx2219_restart
    if_null rx2219_debug, debug_1600
    rx2219_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1600:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2220_done
    goto rxscan2220_scan
  rxscan2220_loop:
    (rx2219_pos) = rx2219_cur."from"()
    inc rx2219_pos
    rx2219_cur."!cursor_from"(rx2219_pos)
    ge rx2219_pos, rx2219_eos, rxscan2220_done
  rxscan2220_scan:
    set_addr $I10, rxscan2220_loop
    rx2219_cur."!mark_push"(0, rx2219_pos, $I10)
  rxscan2220_done:
.annotate 'line', 1132
  # rx subcapture "sym"
    set_addr $I10, rxcap_2221_fail
    rx2219_cur."!mark_push"(0, rx2219_pos, $I10)
  # rx literal  "le"
    add $I11, rx2219_pos, 2
    gt $I11, rx2219_eos, rx2219_fail
    sub $I11, rx2219_pos, rx2219_off
    substr $S10, rx2219_tgt, $I11, 2
    ne $S10, "le", rx2219_fail
    add rx2219_pos, 2
    set_addr $I10, rxcap_2221_fail
    ($I12, $I11) = rx2219_cur."!mark_peek"($I10)
    rx2219_cur."!cursor_pos"($I11)
    ($P10) = rx2219_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2219_pos, "")
    rx2219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2221_done
  rxcap_2221_fail:
    goto rx2219_fail
  rxcap_2221_done:
  # rx subrule "O" subtype=capture negate=
    rx2219_cur."!cursor_pos"(rx2219_pos)
    $P10 = rx2219_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2219_fail
    rx2219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2219_pos = $P10."pos"()
  # rx pass
    rx2219_cur."!cursor_pass"(rx2219_pos, "infix:sym<le>")
    if_null rx2219_debug, debug_1601
    rx2219_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2219_pos)
  debug_1601:
    .return (rx2219_cur)
  rx2219_restart:
.annotate 'line', 440
    if_null rx2219_debug, debug_1602
    rx2219_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1602:
  rx2219_fail:
    (rx2219_rep, rx2219_pos, $I10, $P10) = rx2219_cur."!mark_fail"(0)
    lt rx2219_pos, -1, rx2219_done
    eq rx2219_pos, -1, rx2219_fail
    jump $I10
  rx2219_done:
    rx2219_cur."!cursor_fail"()
    if_null rx2219_debug, debug_1603
    rx2219_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1603:
    .return (rx2219_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("380_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "le")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("381_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2224_tgt
    .local int rx2224_pos
    .local int rx2224_off
    .local int rx2224_eos
    .local int rx2224_rep
    .local pmc rx2224_cur
    .local pmc rx2224_debug
    (rx2224_cur, rx2224_pos, rx2224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2224_cur
    .local pmc match
    .lex "$/", match
    length rx2224_eos, rx2224_tgt
    gt rx2224_pos, rx2224_eos, rx2224_done
    set rx2224_off, 0
    lt rx2224_pos, 2, rx2224_start
    sub rx2224_off, rx2224_pos, 1
    substr rx2224_tgt, rx2224_tgt, rx2224_off
  rx2224_start:
    eq $I10, 1, rx2224_restart
    if_null rx2224_debug, debug_1604
    rx2224_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1604:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2225_done
    goto rxscan2225_scan
  rxscan2225_loop:
    (rx2224_pos) = rx2224_cur."from"()
    inc rx2224_pos
    rx2224_cur."!cursor_from"(rx2224_pos)
    ge rx2224_pos, rx2224_eos, rxscan2225_done
  rxscan2225_scan:
    set_addr $I10, rxscan2225_loop
    rx2224_cur."!mark_push"(0, rx2224_pos, $I10)
  rxscan2225_done:
.annotate 'line', 1133
  # rx subcapture "sym"
    set_addr $I10, rxcap_2226_fail
    rx2224_cur."!mark_push"(0, rx2224_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2224_pos, 2
    gt $I11, rx2224_eos, rx2224_fail
    sub $I11, rx2224_pos, rx2224_off
    substr $S10, rx2224_tgt, $I11, 2
    ne $S10, "ge", rx2224_fail
    add rx2224_pos, 2
    set_addr $I10, rxcap_2226_fail
    ($I12, $I11) = rx2224_cur."!mark_peek"($I10)
    rx2224_cur."!cursor_pos"($I11)
    ($P10) = rx2224_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2224_pos, "")
    rx2224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2226_done
  rxcap_2226_fail:
    goto rx2224_fail
  rxcap_2226_done:
  # rx subrule "O" subtype=capture negate=
    rx2224_cur."!cursor_pos"(rx2224_pos)
    $P10 = rx2224_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2224_fail
    rx2224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2224_pos = $P10."pos"()
  # rx pass
    rx2224_cur."!cursor_pass"(rx2224_pos, "infix:sym<ge>")
    if_null rx2224_debug, debug_1605
    rx2224_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2224_pos)
  debug_1605:
    .return (rx2224_cur)
  rx2224_restart:
.annotate 'line', 440
    if_null rx2224_debug, debug_1606
    rx2224_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1606:
  rx2224_fail:
    (rx2224_rep, rx2224_pos, $I10, $P10) = rx2224_cur."!mark_fail"(0)
    lt rx2224_pos, -1, rx2224_done
    eq rx2224_pos, -1, rx2224_fail
    jump $I10
  rx2224_done:
    rx2224_cur."!cursor_fail"()
    if_null rx2224_debug, debug_1607
    rx2224_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1607:
    .return (rx2224_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("382_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "ge")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("383_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2229_tgt
    .local int rx2229_pos
    .local int rx2229_off
    .local int rx2229_eos
    .local int rx2229_rep
    .local pmc rx2229_cur
    .local pmc rx2229_debug
    (rx2229_cur, rx2229_pos, rx2229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2229_cur
    .local pmc match
    .lex "$/", match
    length rx2229_eos, rx2229_tgt
    gt rx2229_pos, rx2229_eos, rx2229_done
    set rx2229_off, 0
    lt rx2229_pos, 2, rx2229_start
    sub rx2229_off, rx2229_pos, 1
    substr rx2229_tgt, rx2229_tgt, rx2229_off
  rx2229_start:
    eq $I10, 1, rx2229_restart
    if_null rx2229_debug, debug_1608
    rx2229_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1608:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2230_done
    goto rxscan2230_scan
  rxscan2230_loop:
    (rx2229_pos) = rx2229_cur."from"()
    inc rx2229_pos
    rx2229_cur."!cursor_from"(rx2229_pos)
    ge rx2229_pos, rx2229_eos, rxscan2230_done
  rxscan2230_scan:
    set_addr $I10, rxscan2230_loop
    rx2229_cur."!mark_push"(0, rx2229_pos, $I10)
  rxscan2230_done:
.annotate 'line', 1134
  # rx subcapture "sym"
    set_addr $I10, rxcap_2231_fail
    rx2229_cur."!mark_push"(0, rx2229_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2229_pos, 2
    gt $I11, rx2229_eos, rx2229_fail
    sub $I11, rx2229_pos, rx2229_off
    substr $S10, rx2229_tgt, $I11, 2
    ne $S10, "lt", rx2229_fail
    add rx2229_pos, 2
    set_addr $I10, rxcap_2231_fail
    ($I12, $I11) = rx2229_cur."!mark_peek"($I10)
    rx2229_cur."!cursor_pos"($I11)
    ($P10) = rx2229_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2229_pos, "")
    rx2229_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2231_done
  rxcap_2231_fail:
    goto rx2229_fail
  rxcap_2231_done:
  # rx subrule "O" subtype=capture negate=
    rx2229_cur."!cursor_pos"(rx2229_pos)
    $P10 = rx2229_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2229_fail
    rx2229_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2229_pos = $P10."pos"()
  # rx pass
    rx2229_cur."!cursor_pass"(rx2229_pos, "infix:sym<lt>")
    if_null rx2229_debug, debug_1609
    rx2229_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2229_pos)
  debug_1609:
    .return (rx2229_cur)
  rx2229_restart:
.annotate 'line', 440
    if_null rx2229_debug, debug_1610
    rx2229_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1610:
  rx2229_fail:
    (rx2229_rep, rx2229_pos, $I10, $P10) = rx2229_cur."!mark_fail"(0)
    lt rx2229_pos, -1, rx2229_done
    eq rx2229_pos, -1, rx2229_fail
    jump $I10
  rx2229_done:
    rx2229_cur."!cursor_fail"()
    if_null rx2229_debug, debug_1611
    rx2229_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1611:
    .return (rx2229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("384_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "lt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("385_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2234_tgt
    .local int rx2234_pos
    .local int rx2234_off
    .local int rx2234_eos
    .local int rx2234_rep
    .local pmc rx2234_cur
    .local pmc rx2234_debug
    (rx2234_cur, rx2234_pos, rx2234_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2234_cur
    .local pmc match
    .lex "$/", match
    length rx2234_eos, rx2234_tgt
    gt rx2234_pos, rx2234_eos, rx2234_done
    set rx2234_off, 0
    lt rx2234_pos, 2, rx2234_start
    sub rx2234_off, rx2234_pos, 1
    substr rx2234_tgt, rx2234_tgt, rx2234_off
  rx2234_start:
    eq $I10, 1, rx2234_restart
    if_null rx2234_debug, debug_1612
    rx2234_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1612:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2235_done
    goto rxscan2235_scan
  rxscan2235_loop:
    (rx2234_pos) = rx2234_cur."from"()
    inc rx2234_pos
    rx2234_cur."!cursor_from"(rx2234_pos)
    ge rx2234_pos, rx2234_eos, rxscan2235_done
  rxscan2235_scan:
    set_addr $I10, rxscan2235_loop
    rx2234_cur."!mark_push"(0, rx2234_pos, $I10)
  rxscan2235_done:
.annotate 'line', 1135
  # rx subcapture "sym"
    set_addr $I10, rxcap_2236_fail
    rx2234_cur."!mark_push"(0, rx2234_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2234_pos, 2
    gt $I11, rx2234_eos, rx2234_fail
    sub $I11, rx2234_pos, rx2234_off
    substr $S10, rx2234_tgt, $I11, 2
    ne $S10, "gt", rx2234_fail
    add rx2234_pos, 2
    set_addr $I10, rxcap_2236_fail
    ($I12, $I11) = rx2234_cur."!mark_peek"($I10)
    rx2234_cur."!cursor_pos"($I11)
    ($P10) = rx2234_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2234_pos, "")
    rx2234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2236_done
  rxcap_2236_fail:
    goto rx2234_fail
  rxcap_2236_done:
  # rx subrule "O" subtype=capture negate=
    rx2234_cur."!cursor_pos"(rx2234_pos)
    $P10 = rx2234_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2234_fail
    rx2234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2234_pos = $P10."pos"()
  # rx pass
    rx2234_cur."!cursor_pass"(rx2234_pos, "infix:sym<gt>")
    if_null rx2234_debug, debug_1613
    rx2234_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2234_pos)
  debug_1613:
    .return (rx2234_cur)
  rx2234_restart:
.annotate 'line', 440
    if_null rx2234_debug, debug_1614
    rx2234_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1614:
  rx2234_fail:
    (rx2234_rep, rx2234_pos, $I10, $P10) = rx2234_cur."!mark_fail"(0)
    lt rx2234_pos, -1, rx2234_done
    eq rx2234_pos, -1, rx2234_fail
    jump $I10
  rx2234_done:
    rx2234_cur."!cursor_fail"()
    if_null rx2234_debug, debug_1615
    rx2234_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1615:
    .return (rx2234_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("386_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "gt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("387_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2239_tgt
    .local int rx2239_pos
    .local int rx2239_off
    .local int rx2239_eos
    .local int rx2239_rep
    .local pmc rx2239_cur
    .local pmc rx2239_debug
    (rx2239_cur, rx2239_pos, rx2239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2239_cur
    .local pmc match
    .lex "$/", match
    length rx2239_eos, rx2239_tgt
    gt rx2239_pos, rx2239_eos, rx2239_done
    set rx2239_off, 0
    lt rx2239_pos, 2, rx2239_start
    sub rx2239_off, rx2239_pos, 1
    substr rx2239_tgt, rx2239_tgt, rx2239_off
  rx2239_start:
    eq $I10, 1, rx2239_restart
    if_null rx2239_debug, debug_1616
    rx2239_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1616:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2240_done
    goto rxscan2240_scan
  rxscan2240_loop:
    (rx2239_pos) = rx2239_cur."from"()
    inc rx2239_pos
    rx2239_cur."!cursor_from"(rx2239_pos)
    ge rx2239_pos, rx2239_eos, rxscan2240_done
  rxscan2240_scan:
    set_addr $I10, rxscan2240_loop
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10)
  rxscan2240_done:
.annotate 'line', 1136
  # rx subcapture "sym"
    set_addr $I10, rxcap_2241_fail
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2239_pos, 3
    gt $I11, rx2239_eos, rx2239_fail
    sub $I11, rx2239_pos, rx2239_off
    substr $S10, rx2239_tgt, $I11, 3
    ne $S10, "=:=", rx2239_fail
    add rx2239_pos, 3
    set_addr $I10, rxcap_2241_fail
    ($I12, $I11) = rx2239_cur."!mark_peek"($I10)
    rx2239_cur."!cursor_pos"($I11)
    ($P10) = rx2239_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2239_pos, "")
    rx2239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2241_done
  rxcap_2241_fail:
    goto rx2239_fail
  rxcap_2241_done:
  # rx subrule "O" subtype=capture negate=
    rx2239_cur."!cursor_pos"(rx2239_pos)
    $P10 = rx2239_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2239_fail
    rx2239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2239_pos = $P10."pos"()
  # rx pass
    rx2239_cur."!cursor_pass"(rx2239_pos, "infix:sym<=:=>")
    if_null rx2239_debug, debug_1617
    rx2239_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2239_pos)
  debug_1617:
    .return (rx2239_cur)
  rx2239_restart:
.annotate 'line', 440
    if_null rx2239_debug, debug_1618
    rx2239_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1618:
  rx2239_fail:
    (rx2239_rep, rx2239_pos, $I10, $P10) = rx2239_cur."!mark_fail"(0)
    lt rx2239_pos, -1, rx2239_done
    eq rx2239_pos, -1, rx2239_fail
    jump $I10
  rx2239_done:
    rx2239_cur."!cursor_fail"()
    if_null rx2239_debug, debug_1619
    rx2239_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1619:
    .return (rx2239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("388_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "=:=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("389_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2244_tgt
    .local int rx2244_pos
    .local int rx2244_off
    .local int rx2244_eos
    .local int rx2244_rep
    .local pmc rx2244_cur
    .local pmc rx2244_debug
    (rx2244_cur, rx2244_pos, rx2244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2244_cur
    .local pmc match
    .lex "$/", match
    length rx2244_eos, rx2244_tgt
    gt rx2244_pos, rx2244_eos, rx2244_done
    set rx2244_off, 0
    lt rx2244_pos, 2, rx2244_start
    sub rx2244_off, rx2244_pos, 1
    substr rx2244_tgt, rx2244_tgt, rx2244_off
  rx2244_start:
    eq $I10, 1, rx2244_restart
    if_null rx2244_debug, debug_1620
    rx2244_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1620:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2245_done
    goto rxscan2245_scan
  rxscan2245_loop:
    (rx2244_pos) = rx2244_cur."from"()
    inc rx2244_pos
    rx2244_cur."!cursor_from"(rx2244_pos)
    ge rx2244_pos, rx2244_eos, rxscan2245_done
  rxscan2245_scan:
    set_addr $I10, rxscan2245_loop
    rx2244_cur."!mark_push"(0, rx2244_pos, $I10)
  rxscan2245_done:
.annotate 'line', 1137
  # rx subcapture "sym"
    set_addr $I10, rxcap_2246_fail
    rx2244_cur."!mark_push"(0, rx2244_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2244_pos, 2
    gt $I11, rx2244_eos, rx2244_fail
    sub $I11, rx2244_pos, rx2244_off
    substr $S10, rx2244_tgt, $I11, 2
    ne $S10, "~~", rx2244_fail
    add rx2244_pos, 2
    set_addr $I10, rxcap_2246_fail
    ($I12, $I11) = rx2244_cur."!mark_peek"($I10)
    rx2244_cur."!cursor_pos"($I11)
    ($P10) = rx2244_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2244_pos, "")
    rx2244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2246_done
  rxcap_2246_fail:
    goto rx2244_fail
  rxcap_2246_done:
  # rx subrule "O" subtype=capture negate=
    rx2244_cur."!cursor_pos"(rx2244_pos)
    $P10 = rx2244_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2244_fail
    rx2244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2244_pos = $P10."pos"()
  # rx pass
    rx2244_cur."!cursor_pass"(rx2244_pos, "infix:sym<~~>")
    if_null rx2244_debug, debug_1621
    rx2244_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2244_pos)
  debug_1621:
    .return (rx2244_cur)
  rx2244_restart:
.annotate 'line', 440
    if_null rx2244_debug, debug_1622
    rx2244_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1622:
  rx2244_fail:
    (rx2244_rep, rx2244_pos, $I10, $P10) = rx2244_cur."!mark_fail"(0)
    lt rx2244_pos, -1, rx2244_done
    eq rx2244_pos, -1, rx2244_fail
    jump $I10
  rx2244_done:
    rx2244_cur."!cursor_fail"()
    if_null rx2244_debug, debug_1623
    rx2244_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1623:
    .return (rx2244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("390_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "~~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("391_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2249_tgt
    .local int rx2249_pos
    .local int rx2249_off
    .local int rx2249_eos
    .local int rx2249_rep
    .local pmc rx2249_cur
    .local pmc rx2249_debug
    (rx2249_cur, rx2249_pos, rx2249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2249_cur
    .local pmc match
    .lex "$/", match
    length rx2249_eos, rx2249_tgt
    gt rx2249_pos, rx2249_eos, rx2249_done
    set rx2249_off, 0
    lt rx2249_pos, 2, rx2249_start
    sub rx2249_off, rx2249_pos, 1
    substr rx2249_tgt, rx2249_tgt, rx2249_off
  rx2249_start:
    eq $I10, 1, rx2249_restart
    if_null rx2249_debug, debug_1624
    rx2249_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1624:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2250_done
    goto rxscan2250_scan
  rxscan2250_loop:
    (rx2249_pos) = rx2249_cur."from"()
    inc rx2249_pos
    rx2249_cur."!cursor_from"(rx2249_pos)
    ge rx2249_pos, rx2249_eos, rxscan2250_done
  rxscan2250_scan:
    set_addr $I10, rxscan2250_loop
    rx2249_cur."!mark_push"(0, rx2249_pos, $I10)
  rxscan2250_done:
.annotate 'line', 1139
  # rx subcapture "sym"
    set_addr $I10, rxcap_2251_fail
    rx2249_cur."!mark_push"(0, rx2249_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2249_pos, 2
    gt $I11, rx2249_eos, rx2249_fail
    sub $I11, rx2249_pos, rx2249_off
    substr $S10, rx2249_tgt, $I11, 2
    ne $S10, "&&", rx2249_fail
    add rx2249_pos, 2
    set_addr $I10, rxcap_2251_fail
    ($I12, $I11) = rx2249_cur."!mark_peek"($I10)
    rx2249_cur."!cursor_pos"($I11)
    ($P10) = rx2249_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2249_pos, "")
    rx2249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2251_done
  rxcap_2251_fail:
    goto rx2249_fail
  rxcap_2251_done:
  # rx subrule "O" subtype=capture negate=
    rx2249_cur."!cursor_pos"(rx2249_pos)
    $P10 = rx2249_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2249_fail
    rx2249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2249_pos = $P10."pos"()
  # rx pass
    rx2249_cur."!cursor_pass"(rx2249_pos, "infix:sym<&&>")
    if_null rx2249_debug, debug_1625
    rx2249_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2249_pos)
  debug_1625:
    .return (rx2249_cur)
  rx2249_restart:
.annotate 'line', 440
    if_null rx2249_debug, debug_1626
    rx2249_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1626:
  rx2249_fail:
    (rx2249_rep, rx2249_pos, $I10, $P10) = rx2249_cur."!mark_fail"(0)
    lt rx2249_pos, -1, rx2249_done
    eq rx2249_pos, -1, rx2249_fail
    jump $I10
  rx2249_done:
    rx2249_cur."!cursor_fail"()
    if_null rx2249_debug, debug_1627
    rx2249_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1627:
    .return (rx2249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("392_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "&&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("393_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2254_tgt
    .local int rx2254_pos
    .local int rx2254_off
    .local int rx2254_eos
    .local int rx2254_rep
    .local pmc rx2254_cur
    .local pmc rx2254_debug
    (rx2254_cur, rx2254_pos, rx2254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2254_cur
    .local pmc match
    .lex "$/", match
    length rx2254_eos, rx2254_tgt
    gt rx2254_pos, rx2254_eos, rx2254_done
    set rx2254_off, 0
    lt rx2254_pos, 2, rx2254_start
    sub rx2254_off, rx2254_pos, 1
    substr rx2254_tgt, rx2254_tgt, rx2254_off
  rx2254_start:
    eq $I10, 1, rx2254_restart
    if_null rx2254_debug, debug_1628
    rx2254_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1628:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2255_done
    goto rxscan2255_scan
  rxscan2255_loop:
    (rx2254_pos) = rx2254_cur."from"()
    inc rx2254_pos
    rx2254_cur."!cursor_from"(rx2254_pos)
    ge rx2254_pos, rx2254_eos, rxscan2255_done
  rxscan2255_scan:
    set_addr $I10, rxscan2255_loop
    rx2254_cur."!mark_push"(0, rx2254_pos, $I10)
  rxscan2255_done:
.annotate 'line', 1141
  # rx subcapture "sym"
    set_addr $I10, rxcap_2256_fail
    rx2254_cur."!mark_push"(0, rx2254_pos, $I10)
  # rx literal  "||"
    add $I11, rx2254_pos, 2
    gt $I11, rx2254_eos, rx2254_fail
    sub $I11, rx2254_pos, rx2254_off
    substr $S10, rx2254_tgt, $I11, 2
    ne $S10, "||", rx2254_fail
    add rx2254_pos, 2
    set_addr $I10, rxcap_2256_fail
    ($I12, $I11) = rx2254_cur."!mark_peek"($I10)
    rx2254_cur."!cursor_pos"($I11)
    ($P10) = rx2254_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2254_pos, "")
    rx2254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2256_done
  rxcap_2256_fail:
    goto rx2254_fail
  rxcap_2256_done:
  # rx subrule "O" subtype=capture negate=
    rx2254_cur."!cursor_pos"(rx2254_pos)
    $P10 = rx2254_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2254_fail
    rx2254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2254_pos = $P10."pos"()
  # rx pass
    rx2254_cur."!cursor_pass"(rx2254_pos, "infix:sym<||>")
    if_null rx2254_debug, debug_1629
    rx2254_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2254_pos)
  debug_1629:
    .return (rx2254_cur)
  rx2254_restart:
.annotate 'line', 440
    if_null rx2254_debug, debug_1630
    rx2254_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1630:
  rx2254_fail:
    (rx2254_rep, rx2254_pos, $I10, $P10) = rx2254_cur."!mark_fail"(0)
    lt rx2254_pos, -1, rx2254_done
    eq rx2254_pos, -1, rx2254_fail
    jump $I10
  rx2254_done:
    rx2254_cur."!cursor_fail"()
    if_null rx2254_debug, debug_1631
    rx2254_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1631:
    .return (rx2254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("394_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "||")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("395_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2259_tgt
    .local int rx2259_pos
    .local int rx2259_off
    .local int rx2259_eos
    .local int rx2259_rep
    .local pmc rx2259_cur
    .local pmc rx2259_debug
    (rx2259_cur, rx2259_pos, rx2259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2259_cur
    .local pmc match
    .lex "$/", match
    length rx2259_eos, rx2259_tgt
    gt rx2259_pos, rx2259_eos, rx2259_done
    set rx2259_off, 0
    lt rx2259_pos, 2, rx2259_start
    sub rx2259_off, rx2259_pos, 1
    substr rx2259_tgt, rx2259_tgt, rx2259_off
  rx2259_start:
    eq $I10, 1, rx2259_restart
    if_null rx2259_debug, debug_1632
    rx2259_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1632:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2260_done
    goto rxscan2260_scan
  rxscan2260_loop:
    (rx2259_pos) = rx2259_cur."from"()
    inc rx2259_pos
    rx2259_cur."!cursor_from"(rx2259_pos)
    ge rx2259_pos, rx2259_eos, rxscan2260_done
  rxscan2260_scan:
    set_addr $I10, rxscan2260_loop
    rx2259_cur."!mark_push"(0, rx2259_pos, $I10)
  rxscan2260_done:
.annotate 'line', 1142
  # rx subcapture "sym"
    set_addr $I10, rxcap_2261_fail
    rx2259_cur."!mark_push"(0, rx2259_pos, $I10)
  # rx literal  "//"
    add $I11, rx2259_pos, 2
    gt $I11, rx2259_eos, rx2259_fail
    sub $I11, rx2259_pos, rx2259_off
    substr $S10, rx2259_tgt, $I11, 2
    ne $S10, "//", rx2259_fail
    add rx2259_pos, 2
    set_addr $I10, rxcap_2261_fail
    ($I12, $I11) = rx2259_cur."!mark_peek"($I10)
    rx2259_cur."!cursor_pos"($I11)
    ($P10) = rx2259_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2259_pos, "")
    rx2259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2261_done
  rxcap_2261_fail:
    goto rx2259_fail
  rxcap_2261_done:
  # rx subrule "O" subtype=capture negate=
    rx2259_cur."!cursor_pos"(rx2259_pos)
    $P10 = rx2259_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2259_fail
    rx2259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2259_pos = $P10."pos"()
  # rx pass
    rx2259_cur."!cursor_pass"(rx2259_pos, "infix:sym<//>")
    if_null rx2259_debug, debug_1633
    rx2259_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2259_pos)
  debug_1633:
    .return (rx2259_cur)
  rx2259_restart:
.annotate 'line', 440
    if_null rx2259_debug, debug_1634
    rx2259_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1634:
  rx2259_fail:
    (rx2259_rep, rx2259_pos, $I10, $P10) = rx2259_cur."!mark_fail"(0)
    lt rx2259_pos, -1, rx2259_done
    eq rx2259_pos, -1, rx2259_fail
    jump $I10
  rx2259_done:
    rx2259_cur."!cursor_fail"()
    if_null rx2259_debug, debug_1635
    rx2259_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1635:
    .return (rx2259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("396_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "//")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("397_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2264_tgt
    .local int rx2264_pos
    .local int rx2264_off
    .local int rx2264_eos
    .local int rx2264_rep
    .local pmc rx2264_cur
    .local pmc rx2264_debug
    (rx2264_cur, rx2264_pos, rx2264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2264_cur
    .local pmc match
    .lex "$/", match
    length rx2264_eos, rx2264_tgt
    gt rx2264_pos, rx2264_eos, rx2264_done
    set rx2264_off, 0
    lt rx2264_pos, 2, rx2264_start
    sub rx2264_off, rx2264_pos, 1
    substr rx2264_tgt, rx2264_tgt, rx2264_off
  rx2264_start:
    eq $I10, 1, rx2264_restart
    if_null rx2264_debug, debug_1636
    rx2264_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2265_done
    goto rxscan2265_scan
  rxscan2265_loop:
    (rx2264_pos) = rx2264_cur."from"()
    inc rx2264_pos
    rx2264_cur."!cursor_from"(rx2264_pos)
    ge rx2264_pos, rx2264_eos, rxscan2265_done
  rxscan2265_scan:
    set_addr $I10, rxscan2265_loop
    rx2264_cur."!mark_push"(0, rx2264_pos, $I10)
  rxscan2265_done:
.annotate 'line', 1145
  # rx literal  "??"
    add $I11, rx2264_pos, 2
    gt $I11, rx2264_eos, rx2264_fail
    sub $I11, rx2264_pos, rx2264_off
    substr $S10, rx2264_tgt, $I11, 2
    ne $S10, "??", rx2264_fail
    add rx2264_pos, 2
.annotate 'line', 1146
  # rx subrule "ws" subtype=method negate=
    rx2264_cur."!cursor_pos"(rx2264_pos)
    $P10 = rx2264_cur."ws"()
    unless $P10, rx2264_fail
    rx2264_pos = $P10."pos"()
.annotate 'line', 1147
  # rx subrule "EXPR" subtype=capture negate=
    rx2264_cur."!cursor_pos"(rx2264_pos)
    $P10 = rx2264_cur."EXPR"("i=")
    unless $P10, rx2264_fail
    rx2264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2264_pos = $P10."pos"()
.annotate 'line', 1148
  # rx literal  "!!"
    add $I11, rx2264_pos, 2
    gt $I11, rx2264_eos, rx2264_fail
    sub $I11, rx2264_pos, rx2264_off
    substr $S10, rx2264_tgt, $I11, 2
    ne $S10, "!!", rx2264_fail
    add rx2264_pos, 2
.annotate 'line', 1149
  # rx subrule "O" subtype=capture negate=
    rx2264_cur."!cursor_pos"(rx2264_pos)
    $P10 = rx2264_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2264_fail
    rx2264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2264_pos = $P10."pos"()
.annotate 'line', 1144
  # rx pass
    rx2264_cur."!cursor_pass"(rx2264_pos, "infix:sym<?? !!>")
    if_null rx2264_debug, debug_1637
    rx2264_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2264_pos)
  debug_1637:
    .return (rx2264_cur)
  rx2264_restart:
.annotate 'line', 440
    if_null rx2264_debug, debug_1638
    rx2264_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1638:
  rx2264_fail:
    (rx2264_rep, rx2264_pos, $I10, $P10) = rx2264_cur."!mark_fail"(0)
    lt rx2264_pos, -1, rx2264_done
    eq rx2264_pos, -1, rx2264_fail
    jump $I10
  rx2264_done:
    rx2264_cur."!cursor_fail"()
    if_null rx2264_debug, debug_1639
    rx2264_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1639:
    .return (rx2264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("398_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("ws", "??")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("399_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2268_tgt
    .local int rx2268_pos
    .local int rx2268_off
    .local int rx2268_eos
    .local int rx2268_rep
    .local pmc rx2268_cur
    .local pmc rx2268_debug
    (rx2268_cur, rx2268_pos, rx2268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2268_cur
    .local pmc match
    .lex "$/", match
    length rx2268_eos, rx2268_tgt
    gt rx2268_pos, rx2268_eos, rx2268_done
    set rx2268_off, 0
    lt rx2268_pos, 2, rx2268_start
    sub rx2268_off, rx2268_pos, 1
    substr rx2268_tgt, rx2268_tgt, rx2268_off
  rx2268_start:
    eq $I10, 1, rx2268_restart
    if_null rx2268_debug, debug_1640
    rx2268_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1640:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2269_done
    goto rxscan2269_scan
  rxscan2269_loop:
    (rx2268_pos) = rx2268_cur."from"()
    inc rx2268_pos
    rx2268_cur."!cursor_from"(rx2268_pos)
    ge rx2268_pos, rx2268_eos, rxscan2269_done
  rxscan2269_scan:
    set_addr $I10, rxscan2269_loop
    rx2268_cur."!mark_push"(0, rx2268_pos, $I10)
  rxscan2269_done:
.annotate 'line', 1153
  # rx subcapture "sym"
    set_addr $I10, rxcap_2270_fail
    rx2268_cur."!mark_push"(0, rx2268_pos, $I10)
  # rx literal  "="
    add $I11, rx2268_pos, 1
    gt $I11, rx2268_eos, rx2268_fail
    sub $I11, rx2268_pos, rx2268_off
    ord $I11, rx2268_tgt, $I11
    ne $I11, 61, rx2268_fail
    add rx2268_pos, 1
    set_addr $I10, rxcap_2270_fail
    ($I12, $I11) = rx2268_cur."!mark_peek"($I10)
    rx2268_cur."!cursor_pos"($I11)
    ($P10) = rx2268_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2268_pos, "")
    rx2268_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2270_done
  rxcap_2270_fail:
    goto rx2268_fail
  rxcap_2270_done:
  # rx subrule "panic" subtype=method negate=
    rx2268_cur."!cursor_pos"(rx2268_pos)
    $P10 = rx2268_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2268_fail
    rx2268_pos = $P10."pos"()
.annotate 'line', 1152
  # rx pass
    rx2268_cur."!cursor_pass"(rx2268_pos, "infix:sym<=>")
    if_null rx2268_debug, debug_1641
    rx2268_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2268_pos)
  debug_1641:
    .return (rx2268_cur)
  rx2268_restart:
.annotate 'line', 440
    if_null rx2268_debug, debug_1642
    rx2268_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1642:
  rx2268_fail:
    (rx2268_rep, rx2268_pos, $I10, $P10) = rx2268_cur."!mark_fail"(0)
    lt rx2268_pos, -1, rx2268_done
    eq rx2268_pos, -1, rx2268_fail
    jump $I10
  rx2268_done:
    rx2268_cur."!cursor_fail"()
    if_null rx2268_debug, debug_1643
    rx2268_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1643:
    .return (rx2268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("400_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("panic", "=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("401_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2273_tgt
    .local int rx2273_pos
    .local int rx2273_off
    .local int rx2273_eos
    .local int rx2273_rep
    .local pmc rx2273_cur
    .local pmc rx2273_debug
    (rx2273_cur, rx2273_pos, rx2273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2273_cur
    .local pmc match
    .lex "$/", match
    length rx2273_eos, rx2273_tgt
    gt rx2273_pos, rx2273_eos, rx2273_done
    set rx2273_off, 0
    lt rx2273_pos, 2, rx2273_start
    sub rx2273_off, rx2273_pos, 1
    substr rx2273_tgt, rx2273_tgt, rx2273_off
  rx2273_start:
    eq $I10, 1, rx2273_restart
    if_null rx2273_debug, debug_1644
    rx2273_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2274_done
    goto rxscan2274_scan
  rxscan2274_loop:
    (rx2273_pos) = rx2273_cur."from"()
    inc rx2273_pos
    rx2273_cur."!cursor_from"(rx2273_pos)
    ge rx2273_pos, rx2273_eos, rxscan2274_done
  rxscan2274_scan:
    set_addr $I10, rxscan2274_loop
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
  rxscan2274_done:
.annotate 'line', 1155
  # rx subcapture "sym"
    set_addr $I10, rxcap_2275_fail
    rx2273_cur."!mark_push"(0, rx2273_pos, $I10)
  # rx literal  ":="
    add $I11, rx2273_pos, 2
    gt $I11, rx2273_eos, rx2273_fail
    sub $I11, rx2273_pos, rx2273_off
    substr $S10, rx2273_tgt, $I11, 2
    ne $S10, ":=", rx2273_fail
    add rx2273_pos, 2
    set_addr $I10, rxcap_2275_fail
    ($I12, $I11) = rx2273_cur."!mark_peek"($I10)
    rx2273_cur."!cursor_pos"($I11)
    ($P10) = rx2273_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2273_pos, "")
    rx2273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2275_done
  rxcap_2275_fail:
    goto rx2273_fail
  rxcap_2275_done:
  # rx subrule "O" subtype=capture negate=
    rx2273_cur."!cursor_pos"(rx2273_pos)
    $P10 = rx2273_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2273_fail
    rx2273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2273_pos = $P10."pos"()
  # rx pass
    rx2273_cur."!cursor_pass"(rx2273_pos, "infix:sym<:=>")
    if_null rx2273_debug, debug_1645
    rx2273_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2273_pos)
  debug_1645:
    .return (rx2273_cur)
  rx2273_restart:
.annotate 'line', 440
    if_null rx2273_debug, debug_1646
    rx2273_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1646:
  rx2273_fail:
    (rx2273_rep, rx2273_pos, $I10, $P10) = rx2273_cur."!mark_fail"(0)
    lt rx2273_pos, -1, rx2273_done
    eq rx2273_pos, -1, rx2273_fail
    jump $I10
  rx2273_done:
    rx2273_cur."!cursor_fail"()
    if_null rx2273_debug, debug_1647
    rx2273_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1647:
    .return (rx2273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("402_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", ":=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("403_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2278_tgt
    .local int rx2278_pos
    .local int rx2278_off
    .local int rx2278_eos
    .local int rx2278_rep
    .local pmc rx2278_cur
    .local pmc rx2278_debug
    (rx2278_cur, rx2278_pos, rx2278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2278_cur
    .local pmc match
    .lex "$/", match
    length rx2278_eos, rx2278_tgt
    gt rx2278_pos, rx2278_eos, rx2278_done
    set rx2278_off, 0
    lt rx2278_pos, 2, rx2278_start
    sub rx2278_off, rx2278_pos, 1
    substr rx2278_tgt, rx2278_tgt, rx2278_off
  rx2278_start:
    eq $I10, 1, rx2278_restart
    if_null rx2278_debug, debug_1648
    rx2278_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2279_done
    goto rxscan2279_scan
  rxscan2279_loop:
    (rx2278_pos) = rx2278_cur."from"()
    inc rx2278_pos
    rx2278_cur."!cursor_from"(rx2278_pos)
    ge rx2278_pos, rx2278_eos, rxscan2279_done
  rxscan2279_scan:
    set_addr $I10, rxscan2279_loop
    rx2278_cur."!mark_push"(0, rx2278_pos, $I10)
  rxscan2279_done:
.annotate 'line', 1156
  # rx subcapture "sym"
    set_addr $I10, rxcap_2280_fail
    rx2278_cur."!mark_push"(0, rx2278_pos, $I10)
  # rx literal  "::="
    add $I11, rx2278_pos, 3
    gt $I11, rx2278_eos, rx2278_fail
    sub $I11, rx2278_pos, rx2278_off
    substr $S10, rx2278_tgt, $I11, 3
    ne $S10, "::=", rx2278_fail
    add rx2278_pos, 3
    set_addr $I10, rxcap_2280_fail
    ($I12, $I11) = rx2278_cur."!mark_peek"($I10)
    rx2278_cur."!cursor_pos"($I11)
    ($P10) = rx2278_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2278_pos, "")
    rx2278_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2280_done
  rxcap_2280_fail:
    goto rx2278_fail
  rxcap_2280_done:
  # rx subrule "O" subtype=capture negate=
    rx2278_cur."!cursor_pos"(rx2278_pos)
    $P10 = rx2278_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2278_fail
    rx2278_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2278_pos = $P10."pos"()
  # rx pass
    rx2278_cur."!cursor_pass"(rx2278_pos, "infix:sym<::=>")
    if_null rx2278_debug, debug_1649
    rx2278_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2278_pos)
  debug_1649:
    .return (rx2278_cur)
  rx2278_restart:
.annotate 'line', 440
    if_null rx2278_debug, debug_1650
    rx2278_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1650:
  rx2278_fail:
    (rx2278_rep, rx2278_pos, $I10, $P10) = rx2278_cur."!mark_fail"(0)
    lt rx2278_pos, -1, rx2278_done
    eq rx2278_pos, -1, rx2278_fail
    jump $I10
  rx2278_done:
    rx2278_cur."!cursor_fail"()
    if_null rx2278_debug, debug_1651
    rx2278_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1651:
    .return (rx2278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("404_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", "::=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("405_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2283_tgt
    .local int rx2283_pos
    .local int rx2283_off
    .local int rx2283_eos
    .local int rx2283_rep
    .local pmc rx2283_cur
    .local pmc rx2283_debug
    (rx2283_cur, rx2283_pos, rx2283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2283_cur
    .local pmc match
    .lex "$/", match
    length rx2283_eos, rx2283_tgt
    gt rx2283_pos, rx2283_eos, rx2283_done
    set rx2283_off, 0
    lt rx2283_pos, 2, rx2283_start
    sub rx2283_off, rx2283_pos, 1
    substr rx2283_tgt, rx2283_tgt, rx2283_off
  rx2283_start:
    eq $I10, 1, rx2283_restart
    if_null rx2283_debug, debug_1652
    rx2283_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1652:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2284_done
    goto rxscan2284_scan
  rxscan2284_loop:
    (rx2283_pos) = rx2283_cur."from"()
    inc rx2283_pos
    rx2283_cur."!cursor_from"(rx2283_pos)
    ge rx2283_pos, rx2283_eos, rxscan2284_done
  rxscan2284_scan:
    set_addr $I10, rxscan2284_loop
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  rxscan2284_done:
.annotate 'line', 1158
  # rx subcapture "sym"
    set_addr $I10, rxcap_2285_fail
    rx2283_cur."!mark_push"(0, rx2283_pos, $I10)
  # rx literal  ","
    add $I11, rx2283_pos, 1
    gt $I11, rx2283_eos, rx2283_fail
    sub $I11, rx2283_pos, rx2283_off
    ord $I11, rx2283_tgt, $I11
    ne $I11, 44, rx2283_fail
    add rx2283_pos, 1
    set_addr $I10, rxcap_2285_fail
    ($I12, $I11) = rx2283_cur."!mark_peek"($I10)
    rx2283_cur."!cursor_pos"($I11)
    ($P10) = rx2283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2283_pos, "")
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2285_done
  rxcap_2285_fail:
    goto rx2283_fail
  rxcap_2285_done:
  # rx subrule "O" subtype=capture negate=
    rx2283_cur."!cursor_pos"(rx2283_pos)
    $P10 = rx2283_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2283_fail
    rx2283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2283_pos = $P10."pos"()
  # rx pass
    rx2283_cur."!cursor_pass"(rx2283_pos, "infix:sym<,>")
    if_null rx2283_debug, debug_1653
    rx2283_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2283_pos)
  debug_1653:
    .return (rx2283_cur)
  rx2283_restart:
.annotate 'line', 440
    if_null rx2283_debug, debug_1654
    rx2283_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1654:
  rx2283_fail:
    (rx2283_rep, rx2283_pos, $I10, $P10) = rx2283_cur."!mark_fail"(0)
    lt rx2283_pos, -1, rx2283_done
    eq rx2283_pos, -1, rx2283_fail
    jump $I10
  rx2283_done:
    rx2283_cur."!cursor_fail"()
    if_null rx2283_debug, debug_1655
    rx2283_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1655:
    .return (rx2283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("406_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    $P103 = self."!PREFIX__!subrule"("O", ",")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("407_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .const 'Sub' $P2292 = "408_1312646121.678" 
    capture_lex $P2292
    .local string rx2288_tgt
    .local int rx2288_pos
    .local int rx2288_off
    .local int rx2288_eos
    .local int rx2288_rep
    .local pmc rx2288_cur
    .local pmc rx2288_debug
    (rx2288_cur, rx2288_pos, rx2288_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2288_cur
    .local pmc match
    .lex "$/", match
    length rx2288_eos, rx2288_tgt
    gt rx2288_pos, rx2288_eos, rx2288_done
    set rx2288_off, 0
    lt rx2288_pos, 2, rx2288_start
    sub rx2288_off, rx2288_pos, 1
    substr rx2288_tgt, rx2288_tgt, rx2288_off
  rx2288_start:
    eq $I10, 1, rx2288_restart
    if_null rx2288_debug, debug_1656
    rx2288_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2289_done
    goto rxscan2289_scan
  rxscan2289_loop:
    (rx2288_pos) = rx2288_cur."from"()
    inc rx2288_pos
    rx2288_cur."!cursor_from"(rx2288_pos)
    ge rx2288_pos, rx2288_eos, rxscan2289_done
  rxscan2289_scan:
    set_addr $I10, rxscan2289_loop
    rx2288_cur."!mark_push"(0, rx2288_pos, $I10)
  rxscan2289_done:
.annotate 'line', 1160
  # rx subcapture "sym"
    set_addr $I10, rxcap_2290_fail
    rx2288_cur."!mark_push"(0, rx2288_pos, $I10)
  # rx literal  "return"
    add $I11, rx2288_pos, 6
    gt $I11, rx2288_eos, rx2288_fail
    sub $I11, rx2288_pos, rx2288_off
    substr $S10, rx2288_tgt, $I11, 6
    ne $S10, "return", rx2288_fail
    add rx2288_pos, 6
    set_addr $I10, rxcap_2290_fail
    ($I12, $I11) = rx2288_cur."!mark_peek"($I10)
    rx2288_cur."!cursor_pos"($I11)
    ($P10) = rx2288_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2288_pos, "")
    rx2288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2290_done
  rxcap_2290_fail:
    goto rx2288_fail
  rxcap_2290_done:
  # rx charclass s
    ge rx2288_pos, rx2288_eos, rx2288_fail
    sub $I10, rx2288_pos, rx2288_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2288_tgt, $I10
    unless $I11, rx2288_fail
    inc rx2288_pos
  # rx subrule "O" subtype=capture negate=
    rx2288_cur."!cursor_pos"(rx2288_pos)
    $P10 = rx2288_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2288_fail
    rx2288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2288_pos = $P10."pos"()
    rx2288_cur."!cursor_pos"(rx2288_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P2292 = "408_1312646121.678" 
    capture_lex $P2292
    $P106 = $P2292()
  # rx pass
    rx2288_cur."!cursor_pass"(rx2288_pos, "prefix:sym<return>")
    if_null rx2288_debug, debug_1657
    rx2288_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2288_pos)
  debug_1657:
    .return (rx2288_cur)
  rx2288_restart:
.annotate 'line', 440
    if_null rx2288_debug, debug_1658
    rx2288_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1658:
  rx2288_fail:
    (rx2288_rep, rx2288_pos, $I10, $P10) = rx2288_cur."!mark_fail"(0)
    lt rx2288_pos, -1, rx2288_done
    eq rx2288_pos, -1, rx2288_fail
    jump $I10
  rx2288_done:
    rx2288_cur."!cursor_fail"()
    if_null rx2288_debug, debug_1659
    rx2288_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1659:
    .return (rx2288_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2291"  :anon :subid("408_1312646121.678") :outer("407_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1160
    new $P105, "Float"
    assign $P105, 1
    store_dynamic_lex "$*RETURN_USED", $P105
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("409_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P107, "ResizablePMCArray"
    push $P107, "return"
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("410_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2295_tgt
    .local int rx2295_pos
    .local int rx2295_off
    .local int rx2295_eos
    .local int rx2295_rep
    .local pmc rx2295_cur
    .local pmc rx2295_debug
    (rx2295_cur, rx2295_pos, rx2295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2295_cur
    .local pmc match
    .lex "$/", match
    length rx2295_eos, rx2295_tgt
    gt rx2295_pos, rx2295_eos, rx2295_done
    set rx2295_off, 0
    lt rx2295_pos, 2, rx2295_start
    sub rx2295_off, rx2295_pos, 1
    substr rx2295_tgt, rx2295_tgt, rx2295_off
  rx2295_start:
    eq $I10, 1, rx2295_restart
    if_null rx2295_debug, debug_1660
    rx2295_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2296_done
    goto rxscan2296_scan
  rxscan2296_loop:
    (rx2295_pos) = rx2295_cur."from"()
    inc rx2295_pos
    rx2295_cur."!cursor_from"(rx2295_pos)
    ge rx2295_pos, rx2295_eos, rxscan2296_done
  rxscan2296_scan:
    set_addr $I10, rxscan2296_loop
    rx2295_cur."!mark_push"(0, rx2295_pos, $I10)
  rxscan2296_done:
.annotate 'line', 1161
  # rx subcapture "sym"
    set_addr $I10, rxcap_2297_fail
    rx2295_cur."!mark_push"(0, rx2295_pos, $I10)
  # rx literal  "make"
    add $I11, rx2295_pos, 4
    gt $I11, rx2295_eos, rx2295_fail
    sub $I11, rx2295_pos, rx2295_off
    substr $S10, rx2295_tgt, $I11, 4
    ne $S10, "make", rx2295_fail
    add rx2295_pos, 4
    set_addr $I10, rxcap_2297_fail
    ($I12, $I11) = rx2295_cur."!mark_peek"($I10)
    rx2295_cur."!cursor_pos"($I11)
    ($P10) = rx2295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2295_pos, "")
    rx2295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2297_done
  rxcap_2297_fail:
    goto rx2295_fail
  rxcap_2297_done:
  # rx charclass s
    ge rx2295_pos, rx2295_eos, rx2295_fail
    sub $I10, rx2295_pos, rx2295_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2295_tgt, $I10
    unless $I11, rx2295_fail
    inc rx2295_pos
  # rx subrule "O" subtype=capture negate=
    rx2295_cur."!cursor_pos"(rx2295_pos)
    $P10 = rx2295_cur."O"("%list_prefix")
    unless $P10, rx2295_fail
    rx2295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2295_pos = $P10."pos"()
  # rx pass
    rx2295_cur."!cursor_pass"(rx2295_pos, "prefix:sym<make>")
    if_null rx2295_debug, debug_1661
    rx2295_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2295_pos)
  debug_1661:
    .return (rx2295_cur)
  rx2295_restart:
.annotate 'line', 440
    if_null rx2295_debug, debug_1662
    rx2295_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1662:
  rx2295_fail:
    (rx2295_rep, rx2295_pos, $I10, $P10) = rx2295_cur."!mark_fail"(0)
    lt rx2295_pos, -1, rx2295_done
    eq rx2295_pos, -1, rx2295_fail
    jump $I10
  rx2295_done:
    rx2295_cur."!cursor_fail"()
    if_null rx2295_debug, debug_1663
    rx2295_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1663:
    .return (rx2295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("411_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "make"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("412_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2300_tgt
    .local int rx2300_pos
    .local int rx2300_off
    .local int rx2300_eos
    .local int rx2300_rep
    .local pmc rx2300_cur
    .local pmc rx2300_debug
    (rx2300_cur, rx2300_pos, rx2300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2300_cur
    .local pmc match
    .lex "$/", match
    length rx2300_eos, rx2300_tgt
    gt rx2300_pos, rx2300_eos, rx2300_done
    set rx2300_off, 0
    lt rx2300_pos, 2, rx2300_start
    sub rx2300_off, rx2300_pos, 1
    substr rx2300_tgt, rx2300_tgt, rx2300_off
  rx2300_start:
    eq $I10, 1, rx2300_restart
    if_null rx2300_debug, debug_1664
    rx2300_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2301_done
    goto rxscan2301_scan
  rxscan2301_loop:
    (rx2300_pos) = rx2300_cur."from"()
    inc rx2300_pos
    rx2300_cur."!cursor_from"(rx2300_pos)
    ge rx2300_pos, rx2300_eos, rxscan2301_done
  rxscan2301_scan:
    set_addr $I10, rxscan2301_loop
    rx2300_cur."!mark_push"(0, rx2300_pos, $I10)
  rxscan2301_done:
.annotate 'line', 1162
  # rx subcapture "sym"
    set_addr $I10, rxcap_2302_fail
    rx2300_cur."!mark_push"(0, rx2300_pos, $I10)
  # rx literal  "last"
    add $I11, rx2300_pos, 4
    gt $I11, rx2300_eos, rx2300_fail
    sub $I11, rx2300_pos, rx2300_off
    substr $S10, rx2300_tgt, $I11, 4
    ne $S10, "last", rx2300_fail
    add rx2300_pos, 4
    set_addr $I10, rxcap_2302_fail
    ($I12, $I11) = rx2300_cur."!mark_peek"($I10)
    rx2300_cur."!cursor_pos"($I11)
    ($P10) = rx2300_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2300_pos, "")
    rx2300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2302_done
  rxcap_2302_fail:
    goto rx2300_fail
  rxcap_2302_done:
  # rx pass
    rx2300_cur."!cursor_pass"(rx2300_pos, "term:sym<last>")
    if_null rx2300_debug, debug_1665
    rx2300_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2300_pos)
  debug_1665:
    .return (rx2300_cur)
  rx2300_restart:
.annotate 'line', 440
    if_null rx2300_debug, debug_1666
    rx2300_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1666:
  rx2300_fail:
    (rx2300_rep, rx2300_pos, $I10, $P10) = rx2300_cur."!mark_fail"(0)
    lt rx2300_pos, -1, rx2300_done
    eq rx2300_pos, -1, rx2300_fail
    jump $I10
  rx2300_done:
    rx2300_cur."!cursor_fail"()
    if_null rx2300_debug, debug_1667
    rx2300_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1667:
    .return (rx2300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("413_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "last"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("414_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2305_tgt
    .local int rx2305_pos
    .local int rx2305_off
    .local int rx2305_eos
    .local int rx2305_rep
    .local pmc rx2305_cur
    .local pmc rx2305_debug
    (rx2305_cur, rx2305_pos, rx2305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2305_cur
    .local pmc match
    .lex "$/", match
    length rx2305_eos, rx2305_tgt
    gt rx2305_pos, rx2305_eos, rx2305_done
    set rx2305_off, 0
    lt rx2305_pos, 2, rx2305_start
    sub rx2305_off, rx2305_pos, 1
    substr rx2305_tgt, rx2305_tgt, rx2305_off
  rx2305_start:
    eq $I10, 1, rx2305_restart
    if_null rx2305_debug, debug_1668
    rx2305_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2306_done
    goto rxscan2306_scan
  rxscan2306_loop:
    (rx2305_pos) = rx2305_cur."from"()
    inc rx2305_pos
    rx2305_cur."!cursor_from"(rx2305_pos)
    ge rx2305_pos, rx2305_eos, rxscan2306_done
  rxscan2306_scan:
    set_addr $I10, rxscan2306_loop
    rx2305_cur."!mark_push"(0, rx2305_pos, $I10)
  rxscan2306_done:
.annotate 'line', 1163
  # rx subcapture "sym"
    set_addr $I10, rxcap_2307_fail
    rx2305_cur."!mark_push"(0, rx2305_pos, $I10)
  # rx literal  "next"
    add $I11, rx2305_pos, 4
    gt $I11, rx2305_eos, rx2305_fail
    sub $I11, rx2305_pos, rx2305_off
    substr $S10, rx2305_tgt, $I11, 4
    ne $S10, "next", rx2305_fail
    add rx2305_pos, 4
    set_addr $I10, rxcap_2307_fail
    ($I12, $I11) = rx2305_cur."!mark_peek"($I10)
    rx2305_cur."!cursor_pos"($I11)
    ($P10) = rx2305_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2305_pos, "")
    rx2305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2307_done
  rxcap_2307_fail:
    goto rx2305_fail
  rxcap_2307_done:
  # rx pass
    rx2305_cur."!cursor_pass"(rx2305_pos, "term:sym<next>")
    if_null rx2305_debug, debug_1669
    rx2305_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2305_pos)
  debug_1669:
    .return (rx2305_cur)
  rx2305_restart:
.annotate 'line', 440
    if_null rx2305_debug, debug_1670
    rx2305_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1670:
  rx2305_fail:
    (rx2305_rep, rx2305_pos, $I10, $P10) = rx2305_cur."!mark_fail"(0)
    lt rx2305_pos, -1, rx2305_done
    eq rx2305_pos, -1, rx2305_fail
    jump $I10
  rx2305_done:
    rx2305_cur."!cursor_fail"()
    if_null rx2305_debug, debug_1671
    rx2305_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1671:
    .return (rx2305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("415_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "next"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("416_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    .local string rx2310_tgt
    .local int rx2310_pos
    .local int rx2310_off
    .local int rx2310_eos
    .local int rx2310_rep
    .local pmc rx2310_cur
    .local pmc rx2310_debug
    (rx2310_cur, rx2310_pos, rx2310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2310_cur
    .local pmc match
    .lex "$/", match
    length rx2310_eos, rx2310_tgt
    gt rx2310_pos, rx2310_eos, rx2310_done
    set rx2310_off, 0
    lt rx2310_pos, 2, rx2310_start
    sub rx2310_off, rx2310_pos, 1
    substr rx2310_tgt, rx2310_tgt, rx2310_off
  rx2310_start:
    eq $I10, 1, rx2310_restart
    if_null rx2310_debug, debug_1672
    rx2310_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2311_done
    goto rxscan2311_scan
  rxscan2311_loop:
    (rx2310_pos) = rx2310_cur."from"()
    inc rx2310_pos
    rx2310_cur."!cursor_from"(rx2310_pos)
    ge rx2310_pos, rx2310_eos, rxscan2311_done
  rxscan2311_scan:
    set_addr $I10, rxscan2311_loop
    rx2310_cur."!mark_push"(0, rx2310_pos, $I10)
  rxscan2311_done:
.annotate 'line', 1164
  # rx subcapture "sym"
    set_addr $I10, rxcap_2312_fail
    rx2310_cur."!mark_push"(0, rx2310_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2310_pos, 4
    gt $I11, rx2310_eos, rx2310_fail
    sub $I11, rx2310_pos, rx2310_off
    substr $S10, rx2310_tgt, $I11, 4
    ne $S10, "redo", rx2310_fail
    add rx2310_pos, 4
    set_addr $I10, rxcap_2312_fail
    ($I12, $I11) = rx2310_cur."!mark_peek"($I10)
    rx2310_cur."!cursor_pos"($I11)
    ($P10) = rx2310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2310_pos, "")
    rx2310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2312_done
  rxcap_2312_fail:
    goto rx2310_fail
  rxcap_2312_done:
  # rx pass
    rx2310_cur."!cursor_pass"(rx2310_pos, "term:sym<redo>")
    if_null rx2310_debug, debug_1673
    rx2310_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2310_pos)
  debug_1673:
    .return (rx2310_cur)
  rx2310_restart:
.annotate 'line', 440
    if_null rx2310_debug, debug_1674
    rx2310_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1674:
  rx2310_fail:
    (rx2310_rep, rx2310_pos, $I10, $P10) = rx2310_cur."!mark_fail"(0)
    lt rx2310_pos, -1, rx2310_done
    eq rx2310_pos, -1, rx2310_fail
    jump $I10
  rx2310_done:
    rx2310_cur."!cursor_fail"()
    if_null rx2310_debug, debug_1675
    rx2310_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1675:
    .return (rx2310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("417_1312646121.678") :method :outer("40_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 440
    new $P103, "ResizablePMCArray"
    push $P103, "redo"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("418_1312646121.678") :outer("40_1312646121.678")
    .param pmc param_2315
    .param pmc param_2316
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1166
    .lex "self", param_2315
    .lex "$/", param_2316
.annotate 'line', 1168
    new $P103, "Undef"
    set $P2317, $P103
    .lex "$t", $P2317
    new $P104, "Float"
    assign $P104, 0
    set $I100, $P104
    find_lex $P2318, "$/"
    unless_null $P2318, vivify_1676
    $P2318 = root_new ['parrot';'ResizablePMCArray']
  vivify_1676:
    set $P105, $P2318[$I100]
    unless_null $P105, vivify_1677
    new $P105, "Undef"
  vivify_1677:
    store_lex "$t", $P105
    new $P104, "Float"
    assign $P104, 1
    set $I100, $P104
    find_lex $P2319, "$/"
    unless_null $P2319, vivify_1678
    $P2319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1678:
    set $P105, $P2319[$I100]
    unless_null $P105, vivify_1679
    new $P105, "Undef"
  vivify_1679:
    new $P106, "Float"
    assign $P106, 0
    set $I101, $P106
    find_lex $P2320, "$/"
    unless_null $P2320, vivify_1680
    $P2320 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2320
  vivify_1680:
    set $P2320[$I101], $P105
    find_lex $P104, "$t"
    unless_null $P104, vivify_1681
    new $P104, "Undef"
  vivify_1681:
    new $P105, "Float"
    assign $P105, 1
    set $I100, $P105
    find_lex $P2321, "$/"
    unless_null $P2321, vivify_1682
    $P2321 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2321
  vivify_1682:
    set $P2321[$I100], $P104
.annotate 'line', 1166
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2323"  :subid("419_1312646121.678") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .const 'Sub' $P2377 = "439_1312646121.678" 
    capture_lex $P2377
    .const 'Sub' $P2374 = "438_1312646121.678" 
    capture_lex $P2374
    .const 'Sub' $P2373 = "437_1312646121.678" 
    capture_lex $P2373
    .const 'Sub' $P2370 = "436_1312646121.678" 
    capture_lex $P2370
    .const 'Sub' $P2369 = "435_1312646121.678" 
    capture_lex $P2369
    .const 'Sub' $P2360 = "433_1312646121.678" 
    capture_lex $P2360
    .const 'Sub' $P2359 = "432_1312646121.678" 
    capture_lex $P2359
    .const 'Sub' $P2351 = "430_1312646121.678" 
    capture_lex $P2351
    .const 'Sub' $P2350 = "429_1312646121.678" 
    capture_lex $P2350
    .const 'Sub' $P2347 = "428_1312646121.678" 
    capture_lex $P2347
    .const 'Sub' $P2346 = "427_1312646121.678" 
    capture_lex $P2346
    .const 'Sub' $P2339 = "425_1312646121.678" 
    capture_lex $P2339
    .const 'Sub' $P2338 = "424_1312646121.678" 
    capture_lex $P2338
    .const 'Sub' $P2335 = "423_1312646121.678" 
    capture_lex $P2335
    .const 'Sub' $P2334 = "422_1312646121.678" 
    capture_lex $P2334
    .const 'Sub' $P2327 = "420_1312646121.678" 
    capture_lex $P2327
    .lex "$?PACKAGE", $P2325
    .lex "$?CLASS", $P2326
    .const 'Sub' $P2377 = "439_1312646121.678" 
    capture_lex $P2377
    .return ($P2377)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("420_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .const 'Sub' $P2331 = "421_1312646121.678" 
    capture_lex $P2331
    .local string rx2328_tgt
    .local int rx2328_pos
    .local int rx2328_off
    .local int rx2328_eos
    .local int rx2328_rep
    .local pmc rx2328_cur
    .local pmc rx2328_debug
    (rx2328_cur, rx2328_pos, rx2328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2328_cur
    .local pmc match
    .lex "$/", match
    length rx2328_eos, rx2328_tgt
    gt rx2328_pos, rx2328_eos, rx2328_done
    set rx2328_off, 0
    lt rx2328_pos, 2, rx2328_start
    sub rx2328_off, rx2328_pos, 1
    substr rx2328_tgt, rx2328_tgt, rx2328_off
  rx2328_start:
    eq $I10, 1, rx2328_restart
    if_null rx2328_debug, debug_1683
    rx2328_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2329_done
    goto rxscan2329_scan
  rxscan2329_loop:
    (rx2328_pos) = rx2328_cur."from"()
    inc rx2328_pos
    rx2328_cur."!cursor_from"(rx2328_pos)
    ge rx2328_pos, rx2328_eos, rxscan2329_done
  rxscan2329_scan:
    set_addr $I10, rxscan2329_loop
    rx2328_cur."!mark_push"(0, rx2328_pos, $I10)
  rxscan2329_done:
.annotate 'line', 1174
  # rx literal  ":"
    add $I11, rx2328_pos, 1
    gt $I11, rx2328_eos, rx2328_fail
    sub $I11, rx2328_pos, rx2328_off
    ord $I11, rx2328_tgt, $I11
    ne $I11, 58, rx2328_fail
    add rx2328_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    .const 'Sub' $P2331 = "421_1312646121.678" 
    capture_lex $P2331
    $P10 = rx2328_cur."before"($P2331)
    unless $P10, rx2328_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."LANG"("MAIN", "statement")
    unless $P10, rx2328_fail
    rx2328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2328_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2328_cur."!cursor_pos"(rx2328_pos)
    $P10 = rx2328_cur."ws"()
    unless $P10, rx2328_fail
    rx2328_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2328_pos, 1
    gt $I11, rx2328_eos, rx2328_fail
    sub $I11, rx2328_pos, rx2328_off
    ord $I11, rx2328_tgt, $I11
    ne $I11, 59, rx2328_fail
    add rx2328_pos, 1
.annotate 'line', 1173
  # rx pass
    rx2328_cur."!cursor_pass"(rx2328_pos, "metachar:sym<:my>")
    if_null rx2328_debug, debug_1688
    rx2328_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2328_pos)
  debug_1688:
    .return (rx2328_cur)
  rx2328_restart:
.annotate 'line', 1172
    if_null rx2328_debug, debug_1689
    rx2328_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1689:
  rx2328_fail:
    (rx2328_rep, rx2328_pos, $I10, $P10) = rx2328_cur."!mark_fail"(0)
    lt rx2328_pos, -1, rx2328_done
    eq rx2328_pos, -1, rx2328_fail
    jump $I10
  rx2328_done:
    rx2328_cur."!cursor_fail"()
    if_null rx2328_debug, debug_1690
    rx2328_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1690:
    .return (rx2328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2330"  :anon :subid("421_1312646121.678") :method :outer("420_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1174
    .local string rx2332_tgt
    .local int rx2332_pos
    .local int rx2332_off
    .local int rx2332_eos
    .local int rx2332_rep
    .local pmc rx2332_cur
    .local pmc rx2332_debug
    (rx2332_cur, rx2332_pos, rx2332_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2332_cur
    .local pmc match
    .lex "$/", match
    length rx2332_eos, rx2332_tgt
    gt rx2332_pos, rx2332_eos, rx2332_done
    set rx2332_off, 0
    lt rx2332_pos, 2, rx2332_start
    sub rx2332_off, rx2332_pos, 1
    substr rx2332_tgt, rx2332_tgt, rx2332_off
  rx2332_start:
    eq $I10, 1, rx2332_restart
    if_null rx2332_debug, debug_1684
    rx2332_cur."!cursor_debug"("START", "")
  debug_1684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2333_done
    goto rxscan2333_scan
  rxscan2333_loop:
    (rx2332_pos) = rx2332_cur."from"()
    inc rx2332_pos
    rx2332_cur."!cursor_from"(rx2332_pos)
    ge rx2332_pos, rx2332_eos, rxscan2333_done
  rxscan2333_scan:
    set_addr $I10, rxscan2333_loop
    rx2332_cur."!mark_push"(0, rx2332_pos, $I10)
  rxscan2333_done:
  # rx literal  "my"
    add $I11, rx2332_pos, 2
    gt $I11, rx2332_eos, rx2332_fail
    sub $I11, rx2332_pos, rx2332_off
    substr $S10, rx2332_tgt, $I11, 2
    ne $S10, "my", rx2332_fail
    add rx2332_pos, 2
  # rx pass
    rx2332_cur."!cursor_pass"(rx2332_pos, "")
    if_null rx2332_debug, debug_1685
    rx2332_cur."!cursor_debug"("PASS", "", " at pos=", rx2332_pos)
  debug_1685:
    .return (rx2332_cur)
  rx2332_restart:
    if_null rx2332_debug, debug_1686
    rx2332_cur."!cursor_debug"("NEXT", "")
  debug_1686:
  rx2332_fail:
    (rx2332_rep, rx2332_pos, $I10, $P10) = rx2332_cur."!mark_fail"(0)
    lt rx2332_pos, -1, rx2332_done
    eq rx2332_pos, -1, rx2332_fail
    jump $I10
  rx2332_done:
    rx2332_cur."!cursor_fail"()
    if_null rx2332_debug, debug_1687
    rx2332_cur."!cursor_debug"("FAIL", "")
  debug_1687:
    .return (rx2332_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("422_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    new $P103, "ResizablePMCArray"
    push $P103, ":"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("423_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .local string rx2336_tgt
    .local int rx2336_pos
    .local int rx2336_off
    .local int rx2336_eos
    .local int rx2336_rep
    .local pmc rx2336_cur
    .local pmc rx2336_debug
    (rx2336_cur, rx2336_pos, rx2336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2336_cur
    .local pmc match
    .lex "$/", match
    length rx2336_eos, rx2336_tgt
    gt rx2336_pos, rx2336_eos, rx2336_done
    set rx2336_off, 0
    lt rx2336_pos, 2, rx2336_start
    sub rx2336_off, rx2336_pos, 1
    substr rx2336_tgt, rx2336_tgt, rx2336_off
  rx2336_start:
    eq $I10, 1, rx2336_restart
    if_null rx2336_debug, debug_1691
    rx2336_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2337_done
    goto rxscan2337_scan
  rxscan2337_loop:
    (rx2336_pos) = rx2336_cur."from"()
    inc rx2336_pos
    rx2336_cur."!cursor_from"(rx2336_pos)
    ge rx2336_pos, rx2336_eos, rxscan2337_done
  rxscan2337_scan:
    set_addr $I10, rxscan2337_loop
    rx2336_cur."!mark_push"(0, rx2336_pos, $I10)
  rxscan2337_done:
.annotate 'line', 1178
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2336_pos, rx2336_off
    substr $S10, rx2336_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2336_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2336_cur."!cursor_pos"(rx2336_pos)
    $P10 = rx2336_cur."codeblock"()
    unless $P10, rx2336_fail
    rx2336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2336_pos = $P10."pos"()
.annotate 'line', 1177
  # rx pass
    rx2336_cur."!cursor_pass"(rx2336_pos, "metachar:sym<{ }>")
    if_null rx2336_debug, debug_1692
    rx2336_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2336_pos)
  debug_1692:
    .return (rx2336_cur)
  rx2336_restart:
.annotate 'line', 1172
    if_null rx2336_debug, debug_1693
    rx2336_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1693:
  rx2336_fail:
    (rx2336_rep, rx2336_pos, $I10, $P10) = rx2336_cur."!mark_fail"(0)
    lt rx2336_pos, -1, rx2336_done
    eq rx2336_pos, -1, rx2336_fail
    jump $I10
  rx2336_done:
    rx2336_cur."!cursor_fail"()
    if_null rx2336_debug, debug_1694
    rx2336_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1694:
    .return (rx2336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("424_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("425_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .const 'Sub' $P2343 = "426_1312646121.678" 
    capture_lex $P2343
    .local string rx2340_tgt
    .local int rx2340_pos
    .local int rx2340_off
    .local int rx2340_eos
    .local int rx2340_rep
    .local pmc rx2340_cur
    .local pmc rx2340_debug
    (rx2340_cur, rx2340_pos, rx2340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2340_cur
    .local pmc match
    .lex "$/", match
    length rx2340_eos, rx2340_tgt
    gt rx2340_pos, rx2340_eos, rx2340_done
    set rx2340_off, 0
    lt rx2340_pos, 2, rx2340_start
    sub rx2340_off, rx2340_pos, 1
    substr rx2340_tgt, rx2340_tgt, rx2340_off
  rx2340_start:
    eq $I10, 1, rx2340_restart
    if_null rx2340_debug, debug_1695
    rx2340_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2341_done
    goto rxscan2341_scan
  rxscan2341_loop:
    (rx2340_pos) = rx2340_cur."from"()
    inc rx2340_pos
    rx2340_cur."!cursor_from"(rx2340_pos)
    ge rx2340_pos, rx2340_eos, rxscan2341_done
  rxscan2341_scan:
    set_addr $I10, rxscan2341_loop
    rx2340_cur."!mark_push"(0, rx2340_pos, $I10)
  rxscan2341_done:
.annotate 'line', 1182
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2340_pos, rx2340_off
    substr $S10, rx2340_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2340_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2340_cur."!cursor_pos"(rx2340_pos)
    .const 'Sub' $P2343 = "426_1312646121.678" 
    capture_lex $P2343
    $P10 = rx2340_cur."before"($P2343)
    unless $P10, rx2340_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2340_cur."!cursor_pos"(rx2340_pos)
    $P10 = rx2340_cur."LANG"("MAIN", "variable")
    unless $P10, rx2340_fail
    rx2340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2340_pos = $P10."pos"()
.annotate 'line', 1181
  # rx pass
    rx2340_cur."!cursor_pass"(rx2340_pos, "metachar:sym<nqpvar>")
    if_null rx2340_debug, debug_1700
    rx2340_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2340_pos)
  debug_1700:
    .return (rx2340_cur)
  rx2340_restart:
.annotate 'line', 1172
    if_null rx2340_debug, debug_1701
    rx2340_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1701:
  rx2340_fail:
    (rx2340_rep, rx2340_pos, $I10, $P10) = rx2340_cur."!mark_fail"(0)
    lt rx2340_pos, -1, rx2340_done
    eq rx2340_pos, -1, rx2340_fail
    jump $I10
  rx2340_done:
    rx2340_cur."!cursor_fail"()
    if_null rx2340_debug, debug_1702
    rx2340_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1702:
    .return (rx2340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2342"  :anon :subid("426_1312646121.678") :method :outer("425_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1182
    .local string rx2344_tgt
    .local int rx2344_pos
    .local int rx2344_off
    .local int rx2344_eos
    .local int rx2344_rep
    .local pmc rx2344_cur
    .local pmc rx2344_debug
    (rx2344_cur, rx2344_pos, rx2344_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2344_cur
    .local pmc match
    .lex "$/", match
    length rx2344_eos, rx2344_tgt
    gt rx2344_pos, rx2344_eos, rx2344_done
    set rx2344_off, 0
    lt rx2344_pos, 2, rx2344_start
    sub rx2344_off, rx2344_pos, 1
    substr rx2344_tgt, rx2344_tgt, rx2344_off
  rx2344_start:
    eq $I10, 1, rx2344_restart
    if_null rx2344_debug, debug_1696
    rx2344_cur."!cursor_debug"("START", "")
  debug_1696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2345_done
    goto rxscan2345_scan
  rxscan2345_loop:
    (rx2344_pos) = rx2344_cur."from"()
    inc rx2344_pos
    rx2344_cur."!cursor_from"(rx2344_pos)
    ge rx2344_pos, rx2344_eos, rxscan2345_done
  rxscan2345_scan:
    set_addr $I10, rxscan2345_loop
    rx2344_cur."!mark_push"(0, rx2344_pos, $I10)
  rxscan2345_done:
  # rx charclass .
    ge rx2344_pos, rx2344_eos, rx2344_fail
    inc rx2344_pos
  # rx charclass w
    ge rx2344_pos, rx2344_eos, rx2344_fail
    sub $I10, rx2344_pos, rx2344_off
    is_cclass $I11, .CCLASS_WORD, rx2344_tgt, $I10
    unless $I11, rx2344_fail
    inc rx2344_pos
  # rx pass
    rx2344_cur."!cursor_pass"(rx2344_pos, "")
    if_null rx2344_debug, debug_1697
    rx2344_cur."!cursor_debug"("PASS", "", " at pos=", rx2344_pos)
  debug_1697:
    .return (rx2344_cur)
  rx2344_restart:
    if_null rx2344_debug, debug_1698
    rx2344_cur."!cursor_debug"("NEXT", "")
  debug_1698:
  rx2344_fail:
    (rx2344_rep, rx2344_pos, $I10, $P10) = rx2344_cur."!mark_fail"(0)
    lt rx2344_pos, -1, rx2344_done
    eq rx2344_pos, -1, rx2344_fail
    jump $I10
  rx2344_done:
    rx2344_cur."!cursor_fail"()
    if_null rx2344_debug, debug_1699
    rx2344_cur."!cursor_debug"("FAIL", "")
  debug_1699:
    .return (rx2344_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("427_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("428_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .local string rx2348_tgt
    .local int rx2348_pos
    .local int rx2348_off
    .local int rx2348_eos
    .local int rx2348_rep
    .local pmc rx2348_cur
    .local pmc rx2348_debug
    (rx2348_cur, rx2348_pos, rx2348_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2348_cur
    .local pmc match
    .lex "$/", match
    length rx2348_eos, rx2348_tgt
    gt rx2348_pos, rx2348_eos, rx2348_done
    set rx2348_off, 0
    lt rx2348_pos, 2, rx2348_start
    sub rx2348_off, rx2348_pos, 1
    substr rx2348_tgt, rx2348_tgt, rx2348_off
  rx2348_start:
    eq $I10, 1, rx2348_restart
    if_null rx2348_debug, debug_1703
    rx2348_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2349_done
    goto rxscan2349_scan
  rxscan2349_loop:
    (rx2348_pos) = rx2348_cur."from"()
    inc rx2348_pos
    rx2348_cur."!cursor_from"(rx2348_pos)
    ge rx2348_pos, rx2348_eos, rxscan2349_done
  rxscan2349_scan:
    set_addr $I10, rxscan2349_loop
    rx2348_cur."!mark_push"(0, rx2348_pos, $I10)
  rxscan2349_done:
.annotate 'line', 1186
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2348_pos, rx2348_off
    substr $S10, rx2348_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2348_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2348_cur."!cursor_pos"(rx2348_pos)
    $P10 = rx2348_cur."codeblock"()
    unless $P10, rx2348_fail
    rx2348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2348_pos = $P10."pos"()
.annotate 'line', 1185
  # rx pass
    rx2348_cur."!cursor_pass"(rx2348_pos, "assertion:sym<{ }>")
    if_null rx2348_debug, debug_1704
    rx2348_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2348_pos)
  debug_1704:
    .return (rx2348_cur)
  rx2348_restart:
.annotate 'line', 1172
    if_null rx2348_debug, debug_1705
    rx2348_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1705:
  rx2348_fail:
    (rx2348_rep, rx2348_pos, $I10, $P10) = rx2348_cur."!mark_fail"(0)
    lt rx2348_pos, -1, rx2348_done
    eq rx2348_pos, -1, rx2348_fail
    jump $I10
  rx2348_done:
    rx2348_cur."!cursor_fail"()
    if_null rx2348_debug, debug_1706
    rx2348_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1706:
    .return (rx2348_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("429_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("430_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .const 'Sub' $P2355 = "431_1312646121.678" 
    capture_lex $P2355
    .local string rx2352_tgt
    .local int rx2352_pos
    .local int rx2352_off
    .local int rx2352_eos
    .local int rx2352_rep
    .local pmc rx2352_cur
    .local pmc rx2352_debug
    (rx2352_cur, rx2352_pos, rx2352_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2352_cur
    .local pmc match
    .lex "$/", match
    length rx2352_eos, rx2352_tgt
    gt rx2352_pos, rx2352_eos, rx2352_done
    set rx2352_off, 0
    lt rx2352_pos, 2, rx2352_start
    sub rx2352_off, rx2352_pos, 1
    substr rx2352_tgt, rx2352_tgt, rx2352_off
  rx2352_start:
    eq $I10, 1, rx2352_restart
    if_null rx2352_debug, debug_1707
    rx2352_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2353_done
    goto rxscan2353_scan
  rxscan2353_loop:
    (rx2352_pos) = rx2352_cur."from"()
    inc rx2352_pos
    rx2352_cur."!cursor_from"(rx2352_pos)
    ge rx2352_pos, rx2352_eos, rxscan2353_done
  rxscan2353_scan:
    set_addr $I10, rxscan2353_loop
    rx2352_cur."!mark_push"(0, rx2352_pos, $I10)
  rxscan2353_done:
.annotate 'line', 1190
  # rx subcapture "zw"
    set_addr $I10, rxcap_2358_fail
    rx2352_cur."!mark_push"(0, rx2352_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2352_pos, rx2352_eos, rx2352_fail
    sub $I10, rx2352_pos, rx2352_off
    substr $S10, rx2352_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2352_fail
    inc rx2352_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2352_cur."!cursor_pos"(rx2352_pos)
    .const 'Sub' $P2355 = "431_1312646121.678" 
    capture_lex $P2355
    $P10 = rx2352_cur."before"($P2355)
    unless $P10, rx2352_fail
    set_addr $I10, rxcap_2358_fail
    ($I12, $I11) = rx2352_cur."!mark_peek"($I10)
    rx2352_cur."!cursor_pos"($I11)
    ($P10) = rx2352_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2352_pos, "")
    rx2352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2358_done
  rxcap_2358_fail:
    goto rx2352_fail
  rxcap_2358_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2352_cur."!cursor_pos"(rx2352_pos)
    $P10 = rx2352_cur."codeblock"()
    unless $P10, rx2352_fail
    rx2352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2352_pos = $P10."pos"()
.annotate 'line', 1189
  # rx pass
    rx2352_cur."!cursor_pass"(rx2352_pos, "assertion:sym<?{ }>")
    if_null rx2352_debug, debug_1712
    rx2352_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2352_pos)
  debug_1712:
    .return (rx2352_cur)
  rx2352_restart:
.annotate 'line', 1172
    if_null rx2352_debug, debug_1713
    rx2352_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1713:
  rx2352_fail:
    (rx2352_rep, rx2352_pos, $I10, $P10) = rx2352_cur."!mark_fail"(0)
    lt rx2352_pos, -1, rx2352_done
    eq rx2352_pos, -1, rx2352_fail
    jump $I10
  rx2352_done:
    rx2352_cur."!cursor_fail"()
    if_null rx2352_debug, debug_1714
    rx2352_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1714:
    .return (rx2352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2354"  :anon :subid("431_1312646121.678") :method :outer("430_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1190
    .local string rx2356_tgt
    .local int rx2356_pos
    .local int rx2356_off
    .local int rx2356_eos
    .local int rx2356_rep
    .local pmc rx2356_cur
    .local pmc rx2356_debug
    (rx2356_cur, rx2356_pos, rx2356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2356_cur
    .local pmc match
    .lex "$/", match
    length rx2356_eos, rx2356_tgt
    gt rx2356_pos, rx2356_eos, rx2356_done
    set rx2356_off, 0
    lt rx2356_pos, 2, rx2356_start
    sub rx2356_off, rx2356_pos, 1
    substr rx2356_tgt, rx2356_tgt, rx2356_off
  rx2356_start:
    eq $I10, 1, rx2356_restart
    if_null rx2356_debug, debug_1708
    rx2356_cur."!cursor_debug"("START", "")
  debug_1708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2357_done
    goto rxscan2357_scan
  rxscan2357_loop:
    (rx2356_pos) = rx2356_cur."from"()
    inc rx2356_pos
    rx2356_cur."!cursor_from"(rx2356_pos)
    ge rx2356_pos, rx2356_eos, rxscan2357_done
  rxscan2357_scan:
    set_addr $I10, rxscan2357_loop
    rx2356_cur."!mark_push"(0, rx2356_pos, $I10)
  rxscan2357_done:
  # rx literal  "{"
    add $I11, rx2356_pos, 1
    gt $I11, rx2356_eos, rx2356_fail
    sub $I11, rx2356_pos, rx2356_off
    ord $I11, rx2356_tgt, $I11
    ne $I11, 123, rx2356_fail
    add rx2356_pos, 1
  # rx pass
    rx2356_cur."!cursor_pass"(rx2356_pos, "")
    if_null rx2356_debug, debug_1709
    rx2356_cur."!cursor_debug"("PASS", "", " at pos=", rx2356_pos)
  debug_1709:
    .return (rx2356_cur)
  rx2356_restart:
    if_null rx2356_debug, debug_1710
    rx2356_cur."!cursor_debug"("NEXT", "")
  debug_1710:
  rx2356_fail:
    (rx2356_rep, rx2356_pos, $I10, $P10) = rx2356_cur."!mark_fail"(0)
    lt rx2356_pos, -1, rx2356_done
    eq rx2356_pos, -1, rx2356_fail
    jump $I10
  rx2356_done:
    rx2356_cur."!cursor_fail"()
    if_null rx2356_debug, debug_1711
    rx2356_cur."!cursor_debug"("FAIL", "")
  debug_1711:
    .return (rx2356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("432_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    new $P103, "ResizablePMCArray"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("433_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .const 'Sub' $P2366 = "434_1312646121.678" 
    capture_lex $P2366
    .local string rx2361_tgt
    .local int rx2361_pos
    .local int rx2361_off
    .local int rx2361_eos
    .local int rx2361_rep
    .local pmc rx2361_cur
    .local pmc rx2361_debug
    (rx2361_cur, rx2361_pos, rx2361_tgt, $I10) = self."!cursor_start"()
    rx2361_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2361_cur
    .local pmc match
    .lex "$/", match
    length rx2361_eos, rx2361_tgt
    gt rx2361_pos, rx2361_eos, rx2361_done
    set rx2361_off, 0
    lt rx2361_pos, 2, rx2361_start
    sub rx2361_off, rx2361_pos, 1
    substr rx2361_tgt, rx2361_tgt, rx2361_off
  rx2361_start:
    eq $I10, 1, rx2361_restart
    if_null rx2361_debug, debug_1715
    rx2361_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2362_done
    goto rxscan2362_scan
  rxscan2362_loop:
    (rx2361_pos) = rx2361_cur."from"()
    inc rx2361_pos
    rx2361_cur."!cursor_from"(rx2361_pos)
    ge rx2361_pos, rx2361_eos, rxscan2362_done
  rxscan2362_scan:
    set_addr $I10, rxscan2362_loop
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
  rxscan2362_done:
.annotate 'line', 1194
  # rx subrule "identifier" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."identifier"()
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2361_pos = $P10."pos"()
.annotate 'line', 1201
  # rx rxquantr2363 ** 0..1
    set_addr $I10, rxquantr2363_done
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
  rxquantr2363_loop:
  alt2364_0:
.annotate 'line', 1195
    set_addr $I10, alt2364_1
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
.annotate 'line', 1196
  # rx subrule "before" subtype=zerowidth negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    .const 'Sub' $P2366 = "434_1312646121.678" 
    capture_lex $P2366
    $P10 = rx2361_cur."before"($P2366)
    unless $P10, rx2361_fail
    goto alt2364_end
  alt2364_1:
    set_addr $I10, alt2364_2
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
.annotate 'line', 1197
  # rx literal  "="
    add $I11, rx2361_pos, 1
    gt $I11, rx2361_eos, rx2361_fail
    sub $I11, rx2361_pos, rx2361_off
    ord $I11, rx2361_tgt, $I11
    ne $I11, 61, rx2361_fail
    add rx2361_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."assertion"()
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2361_pos = $P10."pos"()
    goto alt2364_end
  alt2364_2:
    set_addr $I10, alt2364_3
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
.annotate 'line', 1198
  # rx literal  ":"
    add $I11, rx2361_pos, 1
    gt $I11, rx2361_eos, rx2361_fail
    sub $I11, rx2361_pos, rx2361_off
    ord $I11, rx2361_tgt, $I11
    ne $I11, 58, rx2361_fail
    add rx2361_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."arglist"()
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2361_pos = $P10."pos"()
    goto alt2364_end
  alt2364_3:
    set_addr $I10, alt2364_4
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
.annotate 'line', 1199
  # rx literal  "("
    add $I11, rx2361_pos, 1
    gt $I11, rx2361_eos, rx2361_fail
    sub $I11, rx2361_pos, rx2361_off
    ord $I11, rx2361_tgt, $I11
    ne $I11, 40, rx2361_fail
    add rx2361_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2361_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2361_pos, 1
    gt $I11, rx2361_eos, rx2361_fail
    sub $I11, rx2361_pos, rx2361_off
    ord $I11, rx2361_tgt, $I11
    ne $I11, 41, rx2361_fail
    add rx2361_pos, 1
    goto alt2364_end
  alt2364_4:
.annotate 'line', 1200
  # rx subrule "normspace" subtype=method negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."normspace"()
    unless $P10, rx2361_fail
    rx2361_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."nibbler"()
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2361_pos = $P10."pos"()
  alt2364_end:
.annotate 'line', 1201
    set_addr $I10, rxquantr2363_done
    (rx2361_rep) = rx2361_cur."!mark_commit"($I10)
  rxquantr2363_done:
.annotate 'line', 1193
  # rx pass
    rx2361_cur."!cursor_pass"(rx2361_pos, "assertion:sym<name>")
    if_null rx2361_debug, debug_1720
    rx2361_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2361_pos)
  debug_1720:
    .return (rx2361_cur)
  rx2361_restart:
.annotate 'line', 1172
    if_null rx2361_debug, debug_1721
    rx2361_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1721:
  rx2361_fail:
    (rx2361_rep, rx2361_pos, $I10, $P10) = rx2361_cur."!mark_fail"(0)
    lt rx2361_pos, -1, rx2361_done
    eq rx2361_pos, -1, rx2361_fail
    jump $I10
  rx2361_done:
    rx2361_cur."!cursor_fail"()
    if_null rx2361_debug, debug_1722
    rx2361_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1722:
    .return (rx2361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2365"  :anon :subid("434_1312646121.678") :method :outer("433_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .local string rx2367_tgt
    .local int rx2367_pos
    .local int rx2367_off
    .local int rx2367_eos
    .local int rx2367_rep
    .local pmc rx2367_cur
    .local pmc rx2367_debug
    (rx2367_cur, rx2367_pos, rx2367_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2367_cur
    .local pmc match
    .lex "$/", match
    length rx2367_eos, rx2367_tgt
    gt rx2367_pos, rx2367_eos, rx2367_done
    set rx2367_off, 0
    lt rx2367_pos, 2, rx2367_start
    sub rx2367_off, rx2367_pos, 1
    substr rx2367_tgt, rx2367_tgt, rx2367_off
  rx2367_start:
    eq $I10, 1, rx2367_restart
    if_null rx2367_debug, debug_1716
    rx2367_cur."!cursor_debug"("START", "")
  debug_1716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2368_done
    goto rxscan2368_scan
  rxscan2368_loop:
    (rx2367_pos) = rx2367_cur."from"()
    inc rx2367_pos
    rx2367_cur."!cursor_from"(rx2367_pos)
    ge rx2367_pos, rx2367_eos, rxscan2368_done
  rxscan2368_scan:
    set_addr $I10, rxscan2368_loop
    rx2367_cur."!mark_push"(0, rx2367_pos, $I10)
  rxscan2368_done:
  # rx literal  ">"
    add $I11, rx2367_pos, 1
    gt $I11, rx2367_eos, rx2367_fail
    sub $I11, rx2367_pos, rx2367_off
    ord $I11, rx2367_tgt, $I11
    ne $I11, 62, rx2367_fail
    add rx2367_pos, 1
  # rx pass
    rx2367_cur."!cursor_pass"(rx2367_pos, "")
    if_null rx2367_debug, debug_1717
    rx2367_cur."!cursor_debug"("PASS", "", " at pos=", rx2367_pos)
  debug_1717:
    .return (rx2367_cur)
  rx2367_restart:
    if_null rx2367_debug, debug_1718
    rx2367_cur."!cursor_debug"("NEXT", "")
  debug_1718:
  rx2367_fail:
    (rx2367_rep, rx2367_pos, $I10, $P10) = rx2367_cur."!mark_fail"(0)
    lt rx2367_pos, -1, rx2367_done
    eq rx2367_pos, -1, rx2367_fail
    jump $I10
  rx2367_done:
    rx2367_cur."!cursor_fail"()
    if_null rx2367_debug, debug_1719
    rx2367_cur."!cursor_debug"("FAIL", "")
  debug_1719:
    .return (rx2367_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("435_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("436_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .local string rx2371_tgt
    .local int rx2371_pos
    .local int rx2371_off
    .local int rx2371_eos
    .local int rx2371_rep
    .local pmc rx2371_cur
    .local pmc rx2371_debug
    (rx2371_cur, rx2371_pos, rx2371_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2371_cur
    .local pmc match
    .lex "$/", match
    length rx2371_eos, rx2371_tgt
    gt rx2371_pos, rx2371_eos, rx2371_done
    set rx2371_off, 0
    lt rx2371_pos, 2, rx2371_start
    sub rx2371_off, rx2371_pos, 1
    substr rx2371_tgt, rx2371_tgt, rx2371_off
  rx2371_start:
    eq $I10, 1, rx2371_restart
    if_null rx2371_debug, debug_1723
    rx2371_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2372_done
    goto rxscan2372_scan
  rxscan2372_loop:
    (rx2371_pos) = rx2371_cur."from"()
    inc rx2371_pos
    rx2371_cur."!cursor_from"(rx2371_pos)
    ge rx2371_pos, rx2371_eos, rxscan2372_done
  rxscan2372_scan:
    set_addr $I10, rxscan2372_loop
    rx2371_cur."!mark_push"(0, rx2371_pos, $I10)
  rxscan2372_done:
.annotate 'line', 1205
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2371_pos, rx2371_off
    substr $S10, rx2371_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2371_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2371_cur."!cursor_pos"(rx2371_pos)
    $P10 = rx2371_cur."LANG"("MAIN", "variable")
    unless $P10, rx2371_fail
    rx2371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2371_pos = $P10."pos"()
.annotate 'line', 1204
  # rx pass
    rx2371_cur."!cursor_pass"(rx2371_pos, "assertion:sym<var>")
    if_null rx2371_debug, debug_1724
    rx2371_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2371_pos)
  debug_1724:
    .return (rx2371_cur)
  rx2371_restart:
.annotate 'line', 1172
    if_null rx2371_debug, debug_1725
    rx2371_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1725:
  rx2371_fail:
    (rx2371_rep, rx2371_pos, $I10, $P10) = rx2371_cur."!mark_fail"(0)
    lt rx2371_pos, -1, rx2371_done
    eq rx2371_pos, -1, rx2371_fail
    jump $I10
  rx2371_done:
    rx2371_cur."!cursor_fail"()
    if_null rx2371_debug, debug_1726
    rx2371_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1726:
    .return (rx2371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("437_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("438_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    .local string rx2375_tgt
    .local int rx2375_pos
    .local int rx2375_off
    .local int rx2375_eos
    .local int rx2375_rep
    .local pmc rx2375_cur
    .local pmc rx2375_debug
    (rx2375_cur, rx2375_pos, rx2375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2375_cur
    .local pmc match
    .lex "$/", match
    length rx2375_eos, rx2375_tgt
    gt rx2375_pos, rx2375_eos, rx2375_done
    set rx2375_off, 0
    lt rx2375_pos, 2, rx2375_start
    sub rx2375_off, rx2375_pos, 1
    substr rx2375_tgt, rx2375_tgt, rx2375_off
  rx2375_start:
    eq $I10, 1, rx2375_restart
    if_null rx2375_debug, debug_1727
    rx2375_cur."!cursor_debug"("START", "codeblock")
  debug_1727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2376_done
    goto rxscan2376_scan
  rxscan2376_loop:
    (rx2375_pos) = rx2375_cur."from"()
    inc rx2375_pos
    rx2375_cur."!cursor_from"(rx2375_pos)
    ge rx2375_pos, rx2375_eos, rxscan2376_done
  rxscan2376_scan:
    set_addr $I10, rxscan2376_loop
    rx2375_cur."!mark_push"(0, rx2375_pos, $I10)
  rxscan2376_done:
.annotate 'line', 1209
  # rx subrule "LANG" subtype=capture negate=
    rx2375_cur."!cursor_pos"(rx2375_pos)
    $P10 = rx2375_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2375_fail
    rx2375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2375_pos = $P10."pos"()
.annotate 'line', 1208
  # rx pass
    rx2375_cur."!cursor_pass"(rx2375_pos, "codeblock")
    if_null rx2375_debug, debug_1728
    rx2375_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2375_pos)
  debug_1728:
    .return (rx2375_cur)
  rx2375_restart:
.annotate 'line', 1172
    if_null rx2375_debug, debug_1729
    rx2375_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1729:
  rx2375_fail:
    (rx2375_rep, rx2375_pos, $I10, $P10) = rx2375_cur."!mark_fail"(0)
    lt rx2375_pos, -1, rx2375_done
    eq rx2375_pos, -1, rx2375_fail
    jump $I10
  rx2375_done:
    rx2375_cur."!cursor_fail"()
    if_null rx2375_debug, debug_1730
    rx2375_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1730:
    .return (rx2375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("439_1312646121.678") :method :outer("419_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1172
    $P103 = self."!PREFIX__!subrule"("LANG", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2378"  :subid("440_1312646121.678") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1215
    .const 'Sub' $P3701 = "620_1312646121.678" 
    capture_lex $P3701
    .const 'Sub' $P3698 = "619_1312646121.678" 
    capture_lex $P3698
    .const 'Sub' $P3695 = "618_1312646121.678" 
    capture_lex $P3695
    .const 'Sub' $P3692 = "617_1312646121.678" 
    capture_lex $P3692
    .const 'Sub' $P3689 = "616_1312646121.678" 
    capture_lex $P3689
    .const 'Sub' $P3686 = "615_1312646121.678" 
    capture_lex $P3686
    .const 'Sub' $P3683 = "614_1312646121.678" 
    capture_lex $P3683
    .const 'Sub' $P3680 = "613_1312646121.678" 
    capture_lex $P3680
    .const 'Sub' $P3676 = "612_1312646121.678" 
    capture_lex $P3676
    .const 'Sub' $P3673 = "611_1312646121.678" 
    capture_lex $P3673
    .const 'Sub' $P3669 = "610_1312646121.678" 
    capture_lex $P3669
    .const 'Sub' $P3665 = "609_1312646121.678" 
    capture_lex $P3665
    .const 'Sub' $P3651 = "608_1312646121.678" 
    capture_lex $P3651
    .const 'Sub' $P3647 = "607_1312646121.678" 
    capture_lex $P3647
    .const 'Sub' $P3643 = "606_1312646121.678" 
    capture_lex $P3643
    .const 'Sub' $P3639 = "605_1312646121.678" 
    capture_lex $P3639
    .const 'Sub' $P3635 = "604_1312646121.678" 
    capture_lex $P3635
    .const 'Sub' $P3631 = "603_1312646121.678" 
    capture_lex $P3631
    .const 'Sub' $P3627 = "602_1312646121.678" 
    capture_lex $P3627
    .const 'Sub' $P3617 = "601_1312646121.678" 
    capture_lex $P3617
    .const 'Sub' $P3610 = "600_1312646121.678" 
    capture_lex $P3610
    .const 'Sub' $P3606 = "599_1312646121.678" 
    capture_lex $P3606
    .const 'Sub' $P3602 = "598_1312646121.678" 
    capture_lex $P3602
    .const 'Sub' $P3598 = "597_1312646121.678" 
    capture_lex $P3598
    .const 'Sub' $P3594 = "596_1312646121.678" 
    capture_lex $P3594
    .const 'Sub' $P3590 = "595_1312646121.678" 
    capture_lex $P3590
    .const 'Sub' $P3581 = "594_1312646121.678" 
    capture_lex $P3581
    .const 'Sub' $P3563 = "592_1312646121.678" 
    capture_lex $P3563
    .const 'Sub' $P3559 = "591_1312646121.678" 
    capture_lex $P3559
    .const 'Sub' $P3555 = "590_1312646121.678" 
    capture_lex $P3555
    .const 'Sub' $P3546 = "589_1312646121.678" 
    capture_lex $P3546
    .const 'Sub' $P3539 = "588_1312646121.678" 
    capture_lex $P3539
    .const 'Sub' $P3535 = "587_1312646121.678" 
    capture_lex $P3535
    .const 'Sub' $P3531 = "586_1312646121.678" 
    capture_lex $P3531
    .const 'Sub' $P3500 = "583_1312646121.678" 
    capture_lex $P3500
    .const 'Sub' $P3496 = "582_1312646121.678" 
    capture_lex $P3496
    .const 'Sub' $P3493 = "581_1312646121.678" 
    capture_lex $P3493
    .const 'Sub' $P3481 = "580_1312646121.678" 
    capture_lex $P3481
    .const 'Sub' $P3477 = "579_1312646121.678" 
    capture_lex $P3477
    .const 'Sub' $P3467 = "578_1312646121.678" 
    capture_lex $P3467
    .const 'Sub' $P3448 = "576_1312646121.678" 
    capture_lex $P3448
    .const 'Sub' $P3442 = "575_1312646121.678" 
    capture_lex $P3442
    .const 'Sub' $P3439 = "574_1312646121.678" 
    capture_lex $P3439
    .const 'Sub' $P3421 = "573_1312646121.678" 
    capture_lex $P3421
    .const 'Sub' $P3369 = "568_1312646121.678" 
    capture_lex $P3369
    .const 'Sub' $P3333 = "563_1312646121.678" 
    capture_lex $P3333
    .const 'Sub' $P3329 = "562_1312646121.678" 
    capture_lex $P3329
    .const 'Sub' $P3311 = "560_1312646121.678" 
    capture_lex $P3311
    .const 'Sub' $P3304 = "559_1312646121.678" 
    capture_lex $P3304
    .const 'Sub' $P3298 = "558_1312646121.678" 
    capture_lex $P3298
    .const 'Sub' $P3259 = "557_1312646121.678" 
    capture_lex $P3259
    .const 'Sub' $P3239 = "554_1312646121.678" 
    capture_lex $P3239
    .const 'Sub' $P3206 = "551_1312646121.678" 
    capture_lex $P3206
    .const 'Sub' $P3125 = "544_1312646121.678" 
    capture_lex $P3125
    .const 'Sub' $P3121 = "543_1312646121.678" 
    capture_lex $P3121
    .const 'Sub' $P3117 = "542_1312646121.678" 
    capture_lex $P3117
    .const 'Sub' $P3076 = "539_1312646121.678" 
    capture_lex $P3076
    .const 'Sub' $P3072 = "538_1312646121.678" 
    capture_lex $P3072
    .const 'Sub' $P3065 = "537_1312646121.678" 
    capture_lex $P3065
    .const 'Sub' $P3058 = "536_1312646121.678" 
    capture_lex $P3058
    .const 'Sub' $P3051 = "535_1312646121.678" 
    capture_lex $P3051
    .const 'Sub' $P3041 = "534_1312646121.678" 
    capture_lex $P3041
    .const 'Sub' $P3037 = "533_1312646121.678" 
    capture_lex $P3037
    .const 'Sub' $P3033 = "532_1312646121.678" 
    capture_lex $P3033
    .const 'Sub' $P3029 = "531_1312646121.678" 
    capture_lex $P3029
    .const 'Sub' $P2962 = "525_1312646121.678" 
    capture_lex $P2962
    .const 'Sub' $P2934 = "524_1312646121.678" 
    capture_lex $P2934
    .const 'Sub' $P2930 = "523_1312646121.678" 
    capture_lex $P2930
    .const 'Sub' $P2926 = "522_1312646121.678" 
    capture_lex $P2926
    .const 'Sub' $P2922 = "521_1312646121.678" 
    capture_lex $P2922
    .const 'Sub' $P2918 = "520_1312646121.678" 
    capture_lex $P2918
    .const 'Sub' $P2914 = "519_1312646121.678" 
    capture_lex $P2914
    .const 'Sub' $P2910 = "518_1312646121.678" 
    capture_lex $P2910
    .const 'Sub' $P2859 = "512_1312646121.678" 
    capture_lex $P2859
    .const 'Sub' $P2849 = "511_1312646121.678" 
    capture_lex $P2849
    .const 'Sub' $P2843 = "510_1312646121.678" 
    capture_lex $P2843
    .const 'Sub' $P2839 = "509_1312646121.678" 
    capture_lex $P2839
    .const 'Sub' $P2835 = "508_1312646121.678" 
    capture_lex $P2835
    .const 'Sub' $P2831 = "507_1312646121.678" 
    capture_lex $P2831
    .const 'Sub' $P2827 = "506_1312646121.678" 
    capture_lex $P2827
    .const 'Sub' $P2823 = "505_1312646121.678" 
    capture_lex $P2823
    .const 'Sub' $P2819 = "504_1312646121.678" 
    capture_lex $P2819
    .const 'Sub' $P2815 = "503_1312646121.678" 
    capture_lex $P2815
    .const 'Sub' $P2811 = "502_1312646121.678" 
    capture_lex $P2811
    .const 'Sub' $P2807 = "501_1312646121.678" 
    capture_lex $P2807
    .const 'Sub' $P2803 = "500_1312646121.678" 
    capture_lex $P2803
    .const 'Sub' $P2799 = "499_1312646121.678" 
    capture_lex $P2799
    .const 'Sub' $P2795 = "498_1312646121.678" 
    capture_lex $P2795
    .const 'Sub' $P2791 = "497_1312646121.678" 
    capture_lex $P2791
    .const 'Sub' $P2784 = "496_1312646121.678" 
    capture_lex $P2784
    .const 'Sub' $P2777 = "495_1312646121.678" 
    capture_lex $P2777
    .const 'Sub' $P2772 = "494_1312646121.678" 
    capture_lex $P2772
    .const 'Sub' $P2766 = "493_1312646121.678" 
    capture_lex $P2766
    .const 'Sub' $P2760 = "492_1312646121.678" 
    capture_lex $P2760
    .const 'Sub' $P2751 = "491_1312646121.678" 
    capture_lex $P2751
    .const 'Sub' $P2740 = "490_1312646121.678" 
    capture_lex $P2740
    .const 'Sub' $P2734 = "489_1312646121.678" 
    capture_lex $P2734
    .const 'Sub' $P2729 = "488_1312646121.678" 
    capture_lex $P2729
    .const 'Sub' $P2710 = "486_1312646121.678" 
    capture_lex $P2710
    .const 'Sub' $P2704 = "485_1312646121.678" 
    capture_lex $P2704
    .const 'Sub' $P2701 = "484_1312646121.678" 
    capture_lex $P2701
    .const 'Sub' $P2696 = "483_1312646121.678" 
    capture_lex $P2696
    .const 'Sub' $P2681 = "481_1312646121.678" 
    capture_lex $P2681
    .const 'Sub' $P2677 = "480_1312646121.678" 
    capture_lex $P2677
    .const 'Sub' $P2664 = "478_1312646121.678" 
    capture_lex $P2664
    .const 'Sub' $P2660 = "477_1312646121.678" 
    capture_lex $P2660
    .const 'Sub' $P2656 = "476_1312646121.678" 
    capture_lex $P2656
    .const 'Sub' $P2651 = "475_1312646121.678" 
    capture_lex $P2651
    .const 'Sub' $P2622 = "473_1312646121.678" 
    capture_lex $P2622
    .const 'Sub' $P2604 = "471_1312646121.678" 
    capture_lex $P2604
    .const 'Sub' $P2583 = "469_1312646121.678" 
    capture_lex $P2583
    .const 'Sub' $P2573 = "468_1312646121.678" 
    capture_lex $P2573
    .const 'Sub' $P2569 = "467_1312646121.678" 
    capture_lex $P2569
    .const 'Sub' $P2514 = "461_1312646121.678" 
    capture_lex $P2514
    .const 'Sub' $P2497 = "459_1312646121.678" 
    capture_lex $P2497
    .const 'Sub' $P2493 = "458_1312646121.678" 
    capture_lex $P2493
    .const 'Sub' $P2489 = "457_1312646121.678" 
    capture_lex $P2489
    .const 'Sub' $P2461 = "454_1312646121.678" 
    capture_lex $P2461
    .const 'Sub' $P2456 = "453_1312646121.678" 
    capture_lex $P2456
    .const 'Sub' $P2436 = "451_1312646121.678" 
    capture_lex $P2436
    .const 'Sub' $P2431 = "450_1312646121.678" 
    capture_lex $P2431
    .const 'Sub' $P2421 = "449_1312646121.678" 
    capture_lex $P2421
    .const 'Sub' $P2411 = "447_1312646121.678" 
    capture_lex $P2411
    .const 'Sub' $P2406 = "446_1312646121.678" 
    capture_lex $P2406
    .const 'Sub' $P2400 = "445_1312646121.678" 
    capture_lex $P2400
    .const 'Sub' $P2387 = "442_1312646121.678" 
    capture_lex $P2387
    .const 'Sub' $P2381 = "441_1312646121.678" 
    capture_lex $P2381
.annotate 'line', 1219
    .const 'Sub' $P2381 = "441_1312646121.678" 
    newclosure $P2385, $P2381
    set $P2380, $P2385
    .lex "xblock_immediate", $P2380
.annotate 'line', 1224
    .const 'Sub' $P2387 = "442_1312646121.678" 
    newclosure $P2398, $P2387
    set $P2386, $P2398
    .lex "block_immediate", $P2386
.annotate 'line', 1234
    .const 'Sub' $P2400 = "445_1312646121.678" 
    newclosure $P2404, $P2400
    set $P2399, $P2404
    .lex "vivitype", $P2399
.annotate 'line', 1253
    .const 'Sub' $P2406 = "446_1312646121.678" 
    newclosure $P2409, $P2406
    set $P2405, $P2409
    .lex "colonpair_str", $P2405
.annotate 'line', 1433
    .const 'Sub' $P2411 = "447_1312646121.678" 
    newclosure $P2419, $P2411
    set $P2410, $P2419
    .lex "import_HOW_exports", $P2410
.annotate 'line', 1538
    .const 'Sub' $P2421 = "449_1312646121.678" 
    newclosure $P2429, $P2421
    set $P2420, $P2429
    .lex "push_block_handler", $P2420
.annotate 'line', 2083
    .const 'Sub' $P2431 = "450_1312646121.678" 
    newclosure $P2434, $P2431
    set $P2430, $P2434
    .lex "only_star_block", $P2430
.annotate 'line', 2092
    .const 'Sub' $P2436 = "451_1312646121.678" 
    newclosure $P2454, $P2436
    set $P2435, $P2454
    .lex "attach_multi_signature", $P2435
.annotate 'line', 2570
    .const 'Sub' $P2456 = "453_1312646121.678" 
    newclosure $P2459, $P2456
    set $P2455, $P2459
    .lex "control", $P2455
.annotate 'line', 2589
    .const 'Sub' $P2461 = "454_1312646121.678" 
    newclosure $P2487, $P2461
    set $P2460, $P2487
    .lex "lexical_package_lookup", $P2460
.annotate 'line', 2638
    .const 'Sub' $P2489 = "457_1312646121.678" 
    newclosure $P2491, $P2489
    set $P2488, $P2491
    .lex "is_lexical", $P2488
.annotate 'line', 2644
    .const 'Sub' $P2493 = "458_1312646121.678" 
    newclosure $P2495, $P2493
    set $P2492, $P2495
    .lex "is_package", $P2492
.annotate 'line', 2650
    .const 'Sub' $P2497 = "459_1312646121.678" 
    newclosure $P2512, $P2497
    set $P2496, $P2512
    .lex "is_scope", $P2496
.annotate 'line', 2673
    .const 'Sub' $P2514 = "461_1312646121.678" 
    newclosure $P2566, $P2514
    set $P2513, $P2566
    .lex "find_sym", $P2513
.annotate 'line', 1215
    .lex "$?PACKAGE", $P2567
    .lex "$?CLASS", $P2568
.annotate 'line', 1217
    new $P122, "ResizablePMCArray"
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P124["@BLOCK"], $P122
.annotate 'line', 1215
    find_lex $P122, "xblock_immediate"
    find_lex $P122, "block_immediate"
    find_lex $P122, "vivitype"
    find_lex $P122, "colonpair_str"
    find_lex $P122, "import_HOW_exports"
    find_lex $P122, "push_block_handler"
    find_lex $P122, "only_star_block"
    find_lex $P122, "attach_multi_signature"
    find_lex $P122, "control"
    find_lex $P122, "lexical_package_lookup"
    find_lex $P122, "is_lexical"
    find_lex $P122, "is_package"
    find_lex $P122, "is_scope"
    find_lex $P122, "find_sym"
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("441_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2382
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1219
    .lex "$xblock", param_2382
.annotate 'line', 1220
    new $P103, "Float"
    assign $P103, 1
    set $I100, $P103
    find_lex $P2383, "$xblock"
    unless_null $P2383, vivify_1731
    $P2383 = root_new ['parrot';'ResizablePMCArray']
  vivify_1731:
    set $P104, $P2383[$I100]
    unless_null $P104, vivify_1732
    new $P104, "Undef"
  vivify_1732:
    $P105 = "block_immediate"($P104)
    new $P106, "Float"
    assign $P106, 1
    set $I101, $P106
    find_lex $P2384, "$xblock"
    unless_null $P2384, vivify_1733
    $P2384 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2384
  vivify_1733:
    set $P2384[$I101], $P105
.annotate 'line', 1219
    find_lex $P103, "$xblock"
    unless_null $P103, vivify_1734
    new $P103, "Undef"
  vivify_1734:
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("442_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2388
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1224
    .const 'Sub' $P2392 = "443_1312646121.678" 
    capture_lex $P2392
    .lex "$block", param_2388
.annotate 'line', 1225
    find_lex $P104, "$block"
    unless_null $P104, vivify_1735
    new $P104, "Undef"
  vivify_1735:
    $P104."blocktype"("immediate")
.annotate 'line', 1226
    find_lex $P105, "$block"
    unless_null $P105, vivify_1736
    new $P105, "Undef"
  vivify_1736:
    $P106 = $P105."symtable"()
    unless $P106, unless_2390
    set $P104, $P106
    goto unless_2390_end
  unless_2390:
    find_lex $P107, "$block"
    unless_null $P107, vivify_1737
    new $P107, "Undef"
  vivify_1737:
    $P108 = $P107."handlers"()
    set $P104, $P108
  unless_2390_end:
    if $P104, unless_2389_end
    .const 'Sub' $P2392 = "443_1312646121.678" 
    capture_lex $P2392
    $P2392()
  unless_2389_end:
.annotate 'line', 1224
    find_lex $P104, "$block"
    unless_null $P104, vivify_1744
    new $P104, "Undef"
  vivify_1744:
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2391"  :anon :subid("443_1312646121.678") :outer("442_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1226
    .const 'Sub' $P2395 = "444_1312646121.678" 
    capture_lex $P2395
.annotate 'line', 1227
    new $P109, "Undef"
    set $P2393, $P109
    .lex "$stmts", $P2393
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Stmts"]
    find_lex $P114, "$block"
    unless_null $P114, vivify_1738
    new $P114, "Undef"
  vivify_1738:
    $P115 = $P113."new"($P114 :named("node"))
    store_lex "$stmts", $P115
.annotate 'line', 1228
    find_lex $P111, "$block"
    unless_null $P111, vivify_1739
    new $P111, "Undef"
  vivify_1739:
    $P112 = $P111."list"()
    defined $I100, $P112
    unless $I100, for_undef_1740
    iter $P110, $P112
    new $P114, 'ExceptionHandler'
    set_label $P114, loop2397_handler
    $P114."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P114
  loop2397_test:
    unless $P110, loop2397_done
    shift $P113, $P110
  loop2397_redo:
    .const 'Sub' $P2395 = "444_1312646121.678" 
    capture_lex $P2395
    $P2395($P113)
  loop2397_next:
    goto loop2397_test
  loop2397_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2397_next
    eq $P115, .CONTROL_LOOP_REDO, loop2397_redo
  loop2397_done:
    pop_eh 
  for_undef_1740:
.annotate 'line', 1229
    find_lex $P110, "$stmts"
    unless_null $P110, vivify_1743
    new $P110, "Undef"
  vivify_1743:
    store_lex "$block", $P110
.annotate 'line', 1226
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2394"  :anon :subid("444_1312646121.678") :outer("443_1312646121.678")
    .param pmc param_2396
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1228
    .lex "$_", param_2396
    find_lex $P114, "$stmts"
    unless_null $P114, vivify_1741
    new $P114, "Undef"
  vivify_1741:
    find_lex $P115, "$_"
    unless_null $P115, vivify_1742
    new $P115, "Undef"
  vivify_1742:
    $P116 = $P114."push"($P115)
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("445_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2401
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1234
    .lex "$sigil", param_2401
.annotate 'line', 1235
    find_lex $P106, "$sigil"
    unless_null $P106, vivify_1745
    new $P106, "Undef"
  vivify_1745:
    set $S100, $P106
    iseq $I100, $S100, "%"
    if $I100, if_2402
.annotate 'line', 1237
    find_lex $P113, "$sigil"
    unless_null $P113, vivify_1746
    new $P113, "Undef"
  vivify_1746:
    set $S101, $P113
    iseq $I101, $S101, "@"
    if $I101, if_2403
    new $P119, "String"
    assign $P119, "Undef"
    set $P112, $P119
    goto if_2403_end
  if_2403:
.annotate 'line', 1238
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    $P118 = $P117."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P112, $P118
  if_2403_end:
    set $P105, $P112
.annotate 'line', 1235
    goto if_2402_end
  if_2402:
.annotate 'line', 1236
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    $P111 = $P110."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P105, $P111
  if_2402_end:
.annotate 'line', 1234
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("446_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2407
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1253
    .lex "$ast", param_2407
.annotate 'line', 1254
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    find_lex $P111, "$ast"
    unless_null $P111, vivify_1747
    new $P111, "Undef"
  vivify_1747:
    $P112 = $P110."ACCEPTS"($P111)
    if $P112, if_2408
.annotate 'line', 1256
    find_lex $P115, "$ast"
    unless_null $P115, vivify_1748
    new $P115, "Undef"
  vivify_1748:
    $P116 = $P115."value"()
    set $P106, $P116
.annotate 'line', 1254
    goto if_2408_end
  if_2408:
.annotate 'line', 1255
    find_lex $P113, "$ast"
    unless_null $P113, vivify_1749
    new $P113, "Undef"
  vivify_1749:
    $P114 = $P113."list"()
    join $S100, " ", $P114
    new $P106, 'String'
    set $P106, $S100
  if_2408_end:
.annotate 'line', 1253
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("447_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2412
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1433
    .const 'Sub' $P2416 = "448_1312646121.678" 
    capture_lex $P2416
    .lex "$UNIT", param_2412
.annotate 'line', 1435
    find_lex $P108, "$UNIT"
    unless_null $P108, vivify_1750
    new $P108, "Undef"
  vivify_1750:
    exists $I100, $P108["EXPORTHOW"]
    if $I100, if_2413
    new $P107, 'Integer'
    set $P107, $I100
    goto if_2413_end
  if_2413:
.annotate 'line', 1436
    find_lex $P2414, "$UNIT"
    unless_null $P2414, vivify_1751
    $P2414 = root_new ['parrot';'Hash']
  vivify_1751:
    set $P110, $P2414["EXPORTHOW"]
    unless_null $P110, vivify_1752
    new $P110, "Undef"
  vivify_1752:
    get_who $P111, $P110
    defined $I101, $P111
    unless $I101, for_undef_1753
    iter $P109, $P111
    new $P113, 'ExceptionHandler'
    set_label $P113, loop2418_handler
    $P113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P113
  loop2418_test:
    unless $P109, loop2418_done
    shift $P112, $P109
  loop2418_redo:
    .const 'Sub' $P2416 = "448_1312646121.678" 
    capture_lex $P2416
    $P2416($P112)
  loop2418_next:
    goto loop2418_test
  loop2418_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2418_next
    eq $P115, .CONTROL_LOOP_REDO, loop2418_redo
  loop2418_done:
    pop_eh 
  for_undef_1753:
.annotate 'line', 1435
    set $P107, $P109
  if_2413_end:
.annotate 'line', 1433
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2415"  :anon :subid("448_1312646121.678") :outer("447_1312646121.678")
    .param pmc param_2417
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1436
    .lex "$_", param_2417
.annotate 'line', 1437
    find_lex $P113, "$_"
    unless_null $P113, vivify_1754
    new $P113, "Undef"
  vivify_1754:
    $P114 = $P113."value"()
    find_lex $P115, "$_"
    unless_null $P115, vivify_1755
    new $P115, "Undef"
  vivify_1755:
    $P116 = $P115."key"()
    find_dynamic_lex $P119, "%*HOW"
    unless_null $P119, vivify_1756
    get_hll_global $P117, "GLOBAL"
    get_who $P118, $P117
    set $P119, $P118["%HOW"]
    unless_null $P119, vivify_1757
    die "Contextual %*HOW not found"
  vivify_1757:
    store_dynamic_lex "%*HOW", $P119
  vivify_1756:
    set $P119[$P116], $P114
.annotate 'line', 1436
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("449_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2422
    .param pmc param_2423
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1538
    .lex "$/", param_2422
    .lex "$block", param_2423
.annotate 'line', 1539
    new $P108, "Float"
    assign $P108, 0
    set $I100, $P108
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2425, $P110["@BLOCK"]
    unless_null $P2425, vivify_1758
    $P2425 = root_new ['parrot';'ResizablePMCArray']
  vivify_1758:
    set $P111, $P2425[$I100]
    unless_null $P111, vivify_1759
    new $P111, "Undef"
  vivify_1759:
    $P112 = $P111."handlers"()
    if $P112, unless_2424_end
.annotate 'line', 1540
    new $P113, "Float"
    assign $P113, 0
    set $I101, $P113
    find_lex $P114, "$?PACKAGE"
    get_who $P115, $P114
    set $P2426, $P115["@BLOCK"]
    unless_null $P2426, vivify_1760
    $P2426 = root_new ['parrot';'ResizablePMCArray']
  vivify_1760:
    set $P116, $P2426[$I101]
    unless_null $P116, vivify_1761
    new $P116, "Undef"
  vivify_1761:
    new $P117, "ResizablePMCArray"
    $P116."handlers"($P117)
  unless_2424_end:
.annotate 'line', 1542
    find_lex $P108, "$block"
    unless_null $P108, vivify_1762
    new $P108, "Undef"
  vivify_1762:
    $P109 = $P108."arity"()
    if $P109, unless_2427_end
.annotate 'line', 1543
    find_lex $P110, "$block"
    unless_null $P110, vivify_1763
    new $P110, "Undef"
  vivify_1763:
.annotate 'line', 1544
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 1545
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Var"]
    $P119 = $P118."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1546
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("lexical" :named("scope"), "$_" :named("name"))
    $P125 = $P114."new"($P119, $P124, "bind_6model" :named("pasttype"))
.annotate 'line', 1544
    $P110."unshift"($P125)
.annotate 'line', 1549
    find_lex $P110, "$block"
    unless_null $P110, vivify_1764
    new $P110, "Undef"
  vivify_1764:
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Var"]
    $P115 = $P114."new"("$_" :named("name"), "parameter" :named("scope"))
    $P110."unshift"($P115)
.annotate 'line', 1550
    find_lex $P110, "$block"
    unless_null $P110, vivify_1765
    new $P110, "Undef"
  vivify_1765:
    $P110."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1551
    find_lex $P110, "$block"
    unless_null $P110, vivify_1766
    new $P110, "Undef"
  vivify_1766:
    $P110."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1552
    find_lex $P110, "$block"
    unless_null $P110, vivify_1767
    new $P110, "Undef"
  vivify_1767:
    $P110."arity"(1)
  unless_2427_end:
.annotate 'line', 1554
    find_lex $P108, "$block"
    unless_null $P108, vivify_1768
    new $P108, "Undef"
  vivify_1768:
    $P108."blocktype"("declaration")
.annotate 'line', 1555
    new $P108, "Float"
    assign $P108, 0
    set $I100, $P108
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2428, $P110["@BLOCK"]
    unless_null $P2428, vivify_1769
    $P2428 = root_new ['parrot';'ResizablePMCArray']
  vivify_1769:
    set $P111, $P2428[$I100]
    unless_null $P111, vivify_1770
    new $P111, "Undef"
  vivify_1770:
    $P112 = $P111."handlers"()
.annotate 'line', 1556
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Control"]
    find_lex $P117, "$/"
    unless_null $P117, vivify_1771
    new $P117, "Undef"
  vivify_1771:
.annotate 'line', 1558
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Stmts"]
.annotate 'line', 1559
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Op"]
    find_lex $P126, "$block"
    unless_null $P126, vivify_1772
    new $P126, "Undef"
  vivify_1772:
.annotate 'line', 1561
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("register" :named("scope"), "exception" :named("name"))
    $P132 = $P125."new"($P126, $P131, "call" :named("pasttype"))
.annotate 'line', 1563
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
.annotate 'line', 1564
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Var"]
.annotate 'line', 1565
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Var"]
    $P145 = $P144."new"("register" :named("scope"), "exception" :named("name"))
    $P146 = $P140."new"($P145, "handled", "keyed" :named("scope"))
.annotate 'line', 1564
    $P147 = $P136."new"($P146, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1563
    $P148 = $P121."new"($P132, $P147)
.annotate 'line', 1558
    $P149 = $P116."new"($P148, $P117 :named("node"))
.annotate 'line', 1556
    $P150 = $P112."unshift"($P149)
.annotate 'line', 1538
    .return ($P150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("450_1312646121.678") :outer("440_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2084
    new $P108, "Undef"
    set $P2432, $P108
    .lex "$past", $P2432
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2433, $P110["@BLOCK"]
    unless_null $P2433, vivify_1773
    $P2433 = root_new ['parrot';'ResizablePMCArray']
  vivify_1773:
    $P111 = $P2433."shift"()
    store_lex "$past", $P111
.annotate 'line', 2085
    find_lex $P109, "$past"
    unless_null $P109, vivify_1774
    new $P109, "Undef"
  vivify_1774:
    $P109."closure"(1)
.annotate 'line', 2086
    find_lex $P109, "$past"
    unless_null $P109, vivify_1775
    new $P109, "Undef"
  vivify_1775:
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    $P114 = $P113."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P109."push"($P114)
.annotate 'line', 2083
    find_lex $P109, "$past"
    unless_null $P109, vivify_1776
    new $P109, "Undef"
  vivify_1776:
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("451_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2437
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2092
    .const 'Sub' $P2442 = "452_1312646121.678" 
    capture_lex $P2442
    .lex "$routine", param_2437
.annotate 'line', 2096
    new $P110, "Undef"
    set $P2438, $P110
    .lex "$types", $P2438
.annotate 'line', 2097
    new $P111, "Undef"
    set $P2439, $P111
    .lex "$definednesses", $P2439
.annotate 'line', 2096
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    store_lex "$types", $P116
.annotate 'line', 2097
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P116
.annotate 'line', 2098
    new $P113, "Float"
    assign $P113, 0
    set $I100, $P113
    find_lex $P2440, "$routine"
    unless_null $P2440, vivify_1777
    $P2440 = root_new ['parrot';'ResizablePMCArray']
  vivify_1777:
    set $P114, $P2440[$I100]
    unless_null $P114, vivify_1778
    new $P114, "Undef"
  vivify_1778:
    $P115 = $P114."list"()
    defined $I101, $P115
    unless $I101, for_undef_1779
    iter $P112, $P115
    new $P118, 'ExceptionHandler'
    set_label $P118, loop2453_handler
    $P118."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P118
  loop2453_test:
    unless $P112, loop2453_done
    shift $P116, $P112
  loop2453_redo:
    .const 'Sub' $P2442 = "452_1312646121.678" 
    capture_lex $P2442
    $P2442($P116)
  loop2453_next:
    goto loop2453_test
  loop2453_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2453_next
    eq $P119, .CONTROL_LOOP_REDO, loop2453_redo
  loop2453_done:
    pop_eh 
  for_undef_1779:
.annotate 'line', 2105
    find_dynamic_lex $P114, "$*SC"
    unless_null $P114, vivify_1789
    get_hll_global $P112, "GLOBAL"
    get_who $P113, $P112
    set $P114, $P113["$SC"]
    unless_null $P114, vivify_1790
    die "Contextual $*SC not found"
  vivify_1790:
  vivify_1789:
    find_lex $P115, "$routine"
    unless_null $P115, vivify_1791
    new $P115, "Undef"
  vivify_1791:
    find_lex $P116, "$types"
    unless_null $P116, vivify_1792
    new $P116, "Undef"
  vivify_1792:
    find_lex $P117, "$definednesses"
    unless_null $P117, vivify_1793
    new $P117, "Undef"
  vivify_1793:
    $P118 = $P114."set_routine_signature"($P115, $P116, $P117)
.annotate 'line', 2092
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2441"  :anon :subid("452_1312646121.678") :outer("451_1312646121.678")
    .param pmc param_2443
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2098
    .lex "$_", param_2443
.annotate 'line', 2099
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Var"]
    find_lex $P123, "$_"
    unless_null $P123, vivify_1780
    new $P123, "Undef"
  vivify_1780:
    $P124 = $P122."ACCEPTS"($P123)
    if $P124, if_2445
    set $P118, $P124
    goto if_2445_end
  if_2445:
    find_lex $P125, "$_"
    unless_null $P125, vivify_1781
    new $P125, "Undef"
  vivify_1781:
    $S100 = $P125."scope"()
    iseq $I102, $S100, "parameter"
    new $P118, 'Integer'
    set $P118, $I102
  if_2445_end:
    if $P118, if_2444
    set $P117, $P118
    goto if_2444_end
  if_2444:
.annotate 'line', 2100
    find_lex $P126, "$types"
    unless_null $P126, vivify_1782
    new $P126, "Undef"
  vivify_1782:
    find_lex $P127, "$_"
    unless_null $P127, vivify_1783
    new $P127, "Undef"
  vivify_1783:
    $P128 = $P127."multitype"()
    set $P2446, $P128
    defined $I2448, $P2446
    if $I2448, default_2447
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    $P133 = $P132."new"("null P" :named("pirop"))
    set $P2446, $P133
  default_2447:
    $P126."push"($P2446)
.annotate 'line', 2101
    find_lex $P126, "$definednesses"
    unless_null $P126, vivify_1784
    new $P126, "Undef"
  vivify_1784:
    find_lex $P2450, "$_"
    unless_null $P2450, vivify_1785
    $P2450 = root_new ['parrot';'Hash']
  vivify_1785:
    set $P128, $P2450["definedness"]
    unless_null $P128, vivify_1786
    new $P128, "Undef"
  vivify_1786:
    set $S101, $P128
    iseq $I103, $S101, "D"
    if $I103, if_2449
.annotate 'line', 2102
    find_lex $P2452, "$_"
    unless_null $P2452, vivify_1787
    $P2452 = root_new ['parrot';'Hash']
  vivify_1787:
    set $P131, $P2452["definedness"]
    unless_null $P131, vivify_1788
    new $P131, "Undef"
  vivify_1788:
    set $S102, $P131
    iseq $I104, $S102, "U"
    if $I104, if_2451
    new $P133, "Float"
    assign $P133, 0
    set $P130, $P133
    goto if_2451_end
  if_2451:
    new $P132, "Float"
    assign $P132, 2
    set $P130, $P132
  if_2451_end:
    set $P127, $P130
.annotate 'line', 2101
    goto if_2449_end
  if_2449:
    new $P129, "Float"
    assign $P129, 1
    set $P127, $P129
  if_2449_end:
    $P134 = $P126."push"($P127)
.annotate 'line', 2099
    set $P117, $P134
  if_2444_end:
.annotate 'line', 2098
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("453_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2457
    .param pmc param_2458
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2570
    .lex "$/", param_2457
    .lex "$type", param_2458
.annotate 'line', 2571
    find_lex $P112, "$/"
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "$/"
    unless_null $P117, vivify_1794
    new $P117, "Undef"
  vivify_1794:
.annotate 'line', 2575
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$type"
    unless_null $P123, vivify_1795
    new $P123, "Undef"
  vivify_1795:
    $P124 = $P122."new"($P123 :named("value"), "!macro_const" :named("returns"))
    $P125 = $P116."new"(0, $P124, $P117 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2571
    $P126 = $P112."!make"($P125)
.annotate 'line', 2570
    .return ($P126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("454_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2464
    .param pmc param_2465
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2589
    .const 'Sub' $P2474 = "455_1312646121.678" 
    capture_lex $P2474
    new $P2463, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2463, control_2462
    push_eh $P2463
    .lex "@name", param_2464
    .lex "$/", param_2465
.annotate 'line', 2595
    new $P112, "Undef"
    set $P2466, $P112
    .lex "$final_name", $P2466
.annotate 'line', 2596
    new $P113, "Undef"
    set $P2467, $P113
    .lex "$lookup", $P2467
.annotate 'line', 2591
    find_lex $P2469, "@name"
    unless_null $P2469, vivify_1796
    $P2469 = root_new ['parrot';'ResizablePMCArray']
  vivify_1796:
    set $N100, $P2469
    set $N101, 0
    iseq $I100, $N100, $N101
    unless $I100, if_2468_end
    find_lex $P114, "$/"
    unless_null $P114, vivify_1797
    new $P114, "Undef"
  vivify_1797:
    $P115 = $P114."CURSOR"()
    $P115."panic"("Cannot compile empty name")
  if_2468_end:
.annotate 'line', 2595
    find_lex $P2470, "@name"
    unless_null $P2470, vivify_1798
    $P2470 = root_new ['parrot';'ResizablePMCArray']
  vivify_1798:
    $P114 = $P2470."pop"()
    store_lex "$final_name", $P114
.annotate 'line', 2596
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Var"]
    find_lex $P119, "$final_name"
    unless_null $P119, vivify_1799
    new $P119, "Undef"
  vivify_1799:
    set $S100, $P119
    $P120 = $P117."new"($S100, "keyed" :named("scope"))
    store_lex "$lookup", $P120
.annotate 'line', 2600
    find_lex $P2472, "@name"
    unless_null $P2472, vivify_1800
    $P2472 = root_new ['parrot';'ResizablePMCArray']
  vivify_1800:
    set $N100, $P2472
    set $N101, 0
    iseq $I100, $N100, $N101
    if $I100, if_2471
.annotate 'line', 2618
    .const 'Sub' $P2474 = "455_1312646121.678" 
    capture_lex $P2474
    $P2474()
    goto if_2471_end
  if_2471:
.annotate 'line', 2601
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_1813
    new $P114, "Undef"
  vivify_1813:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Op"]
.annotate 'line', 2603
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P125 = $P119."new"($P124, "get_who PP" :named("pirop"))
.annotate 'line', 2601
    $P114."unshift"($P125)
.annotate 'line', 2605
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_1814
    new $P114, "Undef"
  vivify_1814:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Var"]
.annotate 'line', 2607
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Op"]
.annotate 'line', 2609
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    new $P129, "ResizablePMCArray"
    $P130 = $P128."new"("GLOBAL" :named("name"), $P129 :named("namespace"), "package" :named("scope"))
    $P131 = $P123."new"($P130, "get_who PP" :named("pirop"))
.annotate 'line', 2611
    find_lex $P132, "$final_name"
    unless_null $P132, vivify_1815
    new $P132, "Undef"
  vivify_1815:
    set $S100, $P132
    $P133 = $P119."new"($P131, $S100, "keyed" :named("scope"))
.annotate 'line', 2605
    $P114."viviself"($P133)
  if_2471_end:
.annotate 'line', 2633
    new $P114, "Exception"
    set $P114['type'], .CONTROL_RETURN
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1816
    new $P115, "Undef"
  vivify_1816:
    setattribute $P114, 'payload', $P115
    throw $P114
.annotate 'line', 2589
    .return ()
  control_2462:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P114, exception, "payload"
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2473"  :anon :subid("455_1312646121.678") :outer("454_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2618
    .const 'Sub' $P2484 = "456_1312646121.678" 
    capture_lex $P2484
.annotate 'line', 2619
    new $P114, "Undef"
    set $P2475, $P114
    .lex "$path", $P2475
    new $P116, "Float"
    assign $P116, 0
    set $I101, $P116
    find_lex $P2477, "@name"
    unless_null $P2477, vivify_1801
    $P2477 = root_new ['parrot';'ResizablePMCArray']
  vivify_1801:
    set $P117, $P2477[$I101]
    unless_null $P117, vivify_1802
    new $P117, "Undef"
  vivify_1802:
    $P119 = "is_lexical"($P117)
    if $P119, if_2476
.annotate 'line', 2621
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    new $P131, "ResizablePMCArray"
    $P132 = $P130."new"("GLOBAL" :named("name"), $P131 :named("namespace"), "package" :named("scope"))
    set $P115, $P132
.annotate 'line', 2619
    goto if_2476_end
  if_2476:
.annotate 'line', 2620
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    find_lex $P2478, "@name"
    unless_null $P2478, vivify_1803
    $P2478 = root_new ['parrot';'ResizablePMCArray']
  vivify_1803:
    $P124 = $P2478."shift"()
    $P125 = $P123."new"($P124 :named("name"), "lexical" :named("scope"))
    set $P115, $P125
  if_2476_end:
.annotate 'line', 2619
    store_lex "$path", $P115
.annotate 'line', 2622
    new $P115, "Float"
    assign $P115, 0
    set $I101, $P115
    find_lex $P2480, "@name"
    unless_null $P2480, vivify_1804
    $P2480 = root_new ['parrot';'ResizablePMCArray']
  vivify_1804:
    set $P116, $P2480[$I101]
    unless_null $P116, vivify_1805
    new $P116, "Undef"
  vivify_1805:
    set $S100, $P116
    iseq $I102, $S100, "GLOBAL"
    unless $I102, if_2479_end
.annotate 'line', 2623
    find_lex $P2481, "@name"
    unless_null $P2481, vivify_1806
    $P2481 = root_new ['parrot';'ResizablePMCArray']
  vivify_1806:
    $P2481."shift"()
  if_2479_end:
.annotate 'line', 2625
    find_lex $P2482, "@name"
    unless_null $P2482, vivify_1807
    $P2482 = root_new ['parrot';'ResizablePMCArray']
  vivify_1807:
    defined $I101, $P2482
    unless $I101, for_undef_1808
    iter $P115, $P2482
    new $P117, 'ExceptionHandler'
    set_label $P117, loop2486_handler
    $P117."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P117
  loop2486_test:
    unless $P115, loop2486_done
    shift $P116, $P115
  loop2486_redo:
    .const 'Sub' $P2484 = "456_1312646121.678" 
    capture_lex $P2484
    $P2484($P116)
  loop2486_next:
    goto loop2486_test
  loop2486_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2486_next
    eq $P119, .CONTROL_LOOP_REDO, loop2486_redo
  loop2486_done:
    pop_eh 
  for_undef_1808:
.annotate 'line', 2630
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1811
    new $P115, "Undef"
  vivify_1811:
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P119, $P117
    set $P120, $P119["Op"]
    find_lex $P121, "$path"
    unless_null $P121, vivify_1812
    new $P121, "Undef"
  vivify_1812:
    $P122 = $P120."new"($P121, "get_who PP" :named("pirop"))
    $P123 = $P115."unshift"($P122)
.annotate 'line', 2618
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2483"  :anon :subid("456_1312646121.678") :outer("455_1312646121.678")
    .param pmc param_2485
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2625
    .lex "$_", param_2485
.annotate 'line', 2626
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P119, $P117, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
    find_lex $P122, "$path"
    unless_null $P122, vivify_1809
    new $P122, "Undef"
  vivify_1809:
.annotate 'line', 2628
    find_lex $P123, "$_"
    unless_null $P123, vivify_1810
    new $P123, "Undef"
  vivify_1810:
    set $S100, $P123
    $P124 = $P121."new"($P122, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2626
    store_lex "$path", $P124
.annotate 'line', 2625
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("457_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2490
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2638
    .lex "$name", param_2490
.annotate 'line', 2639
    find_lex $P115, "$name"
    unless_null $P115, vivify_1817
    new $P115, "Undef"
  vivify_1817:
    $P116 = "is_scope"($P115, "lexical")
.annotate 'line', 2638
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("458_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2494
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2644
    .lex "$name", param_2494
.annotate 'line', 2645
    find_lex $P115, "$name"
    unless_null $P115, vivify_1818
    new $P115, "Undef"
  vivify_1818:
    $P117 = "is_scope"($P115, "package")
.annotate 'line', 2644
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("459_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2500
    .param pmc param_2501
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2650
    .const 'Sub' $P2504 = "460_1312646121.678" 
    capture_lex $P2504
    new $P2499, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2499, control_2498
    push_eh $P2499
    .lex "$name", param_2500
    .lex "$wanted_scope", param_2501
.annotate 'line', 2651
    find_lex $P119, "$?PACKAGE"
    get_who $P120, $P119
    set $P2502, $P120["@BLOCK"]
    unless_null $P2502, vivify_1819
    $P2502 = root_new ['parrot';'ResizablePMCArray']
  vivify_1819:
    defined $I100, $P2502
    unless $I100, for_undef_1820
    iter $P115, $P2502
    new $P123, 'ExceptionHandler'
    set_label $P123, loop2511_handler
    $P123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P123
  loop2511_test:
    unless $P115, loop2511_done
    shift $P121, $P115
  loop2511_redo:
    .const 'Sub' $P2504 = "460_1312646121.678" 
    capture_lex $P2504
    $P2504($P121)
  loop2511_next:
    goto loop2511_test
  loop2511_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2511_next
    eq $P124, .CONTROL_LOOP_REDO, loop2511_redo
  loop2511_done:
    pop_eh 
  for_undef_1820:
.annotate 'line', 2650
    .return (0)
  control_2498:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, "payload"
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2503"  :anon :subid("460_1312646121.678") :outer("459_1312646121.678")
    .param pmc param_2507
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2652
    $P2506 = root_new ['parrot';'Hash']
    set $P2505, $P2506
    .lex "%sym", $P2505
    .lex "$_", param_2507
    find_lex $P122, "$_"
    unless_null $P122, vivify_1821
    new $P122, "Undef"
  vivify_1821:
    find_lex $P123, "$name"
    unless_null $P123, vivify_1822
    new $P123, "Undef"
  vivify_1822:
    $P124 = $P122."symbol"($P123)
    store_lex "%sym", $P124
.annotate 'line', 2653
    find_lex $P2509, "%sym"
    unless_null $P2509, vivify_1823
    $P2509 = root_new ['parrot';'Hash']
  vivify_1823:
    set $N100, $P2509
    if $N100, if_2508
    new $P122, 'Float'
    set $P122, $N100
    goto if_2508_end
  if_2508:
.annotate 'line', 2654
    new $P123, "Exception"
    set $P123['type'], .CONTROL_RETURN
    find_lex $P2510, "%sym"
    unless_null $P2510, vivify_1824
    $P2510 = root_new ['parrot';'Hash']
  vivify_1824:
    set $P124, $P2510["scope"]
    unless_null $P124, vivify_1825
    new $P124, "Undef"
  vivify_1825:
    set $S100, $P124
    find_lex $P125, "$wanted_scope"
    unless_null $P125, vivify_1826
    new $P125, "Undef"
  vivify_1826:
    set $S101, $P125
    iseq $I101, $S100, $S101
    new $P127, 'Integer'
    set $P127, $I101
    setattribute $P123, 'payload', $P127
    throw $P123
  if_2508_end:
.annotate 'line', 2651
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("461_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2517
    .param pmc param_2518
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2673
    .const 'Sub' $P2561 = "466_1312646121.678" 
    capture_lex $P2561
    .const 'Sub' $P2543 = "464_1312646121.678" 
    capture_lex $P2543
    .const 'Sub' $P2525 = "462_1312646121.678" 
    capture_lex $P2525
    new $P2516, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2516, control_2515
    push_eh $P2516
    .lex "@name", param_2517
    .lex "$/", param_2518
.annotate 'line', 2697
    new $P119, "Undef"
    set $P2519, $P119
    .lex "$result", $P2519
.annotate 'line', 2675
    find_lex $P2521, "@name"
    unless_null $P2521, vivify_1827
    $P2521 = root_new ['parrot';'ResizablePMCArray']
  vivify_1827:
    set $N100, $P2521
    if $N100, unless_2520_end
    find_lex $P120, "$/"
    unless_null $P120, vivify_1828
    new $P120, "Undef"
  vivify_1828:
    $P121 = $P120."CURSOR"()
    $P121."panic"("Cannot look up empty name")
  unless_2520_end:
.annotate 'line', 2679
    find_lex $P2523, "@name"
    unless_null $P2523, vivify_1829
    $P2523 = root_new ['parrot';'ResizablePMCArray']
  vivify_1829:
    set $N100, $P2523
    set $N101, 1
    iseq $I100, $N100, $N101
    unless $I100, if_2522_end
    .const 'Sub' $P2525 = "462_1312646121.678" 
    capture_lex $P2525
    $P2525()
  if_2522_end:
.annotate 'line', 2697
    find_dynamic_lex $P122, "$*GLOBALish"
    unless_null $P122, vivify_1841
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$GLOBALish"]
    unless_null $P122, vivify_1842
    die "Contextual $*GLOBALish not found"
  vivify_1842:
  vivify_1841:
    store_lex "$result", $P122
.annotate 'line', 2698
    find_lex $P2541, "@name"
    unless_null $P2541, vivify_1843
    $P2541 = root_new ['parrot';'ResizablePMCArray']
  vivify_1843:
    set $N100, $P2541
    set $N101, 2
    isge $I100, $N100, $N101
    unless $I100, if_2540_end
    .const 'Sub' $P2543 = "464_1312646121.678" 
    capture_lex $P2543
    $P2543()
  if_2540_end:
.annotate 'line', 2716
    find_lex $P2559, "@name"
    unless_null $P2559, vivify_1856
    $P2559 = root_new ['parrot';'ResizablePMCArray']
  vivify_1856:
    defined $I100, $P2559
    unless $I100, for_undef_1857
    iter $P120, $P2559
    new $P123, 'ExceptionHandler'
    set_label $P123, loop2565_handler
    $P123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P123
  loop2565_test:
    unless $P120, loop2565_done
    shift $P121, $P120
  loop2565_redo:
    .const 'Sub' $P2561 = "466_1312646121.678" 
    capture_lex $P2561
    $P2561($P121)
  loop2565_next:
    goto loop2565_test
  loop2565_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2565_next
    eq $P124, .CONTROL_LOOP_REDO, loop2565_redo
  loop2565_done:
    pop_eh 
  for_undef_1857:
.annotate 'line', 2673
    find_lex $P120, "$result"
    unless_null $P120, vivify_1864
    new $P120, "Undef"
  vivify_1864:
    .return ($P120)
  control_2515:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P121, exception, "payload"
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2524"  :anon :subid("462_1312646121.678") :outer("461_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2679
    .const 'Sub' $P2530 = "463_1312646121.678" 
    capture_lex $P2530
.annotate 'line', 2680
    new $P120, "Undef"
    set $P2526, $P120
    .lex "$final_name", $P2526
    new $P121, "Float"
    assign $P121, 0
    set $I101, $P121
    find_lex $P2527, "@name"
    unless_null $P2527, vivify_1830
    $P2527 = root_new ['parrot';'ResizablePMCArray']
  vivify_1830:
    set $P122, $P2527[$I101]
    unless_null $P122, vivify_1831
    new $P122, "Undef"
  vivify_1831:
    store_lex "$final_name", $P122
.annotate 'line', 2681
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2528, $P123["@BLOCK"]
    unless_null $P2528, vivify_1832
    $P2528 = root_new ['parrot';'ResizablePMCArray']
  vivify_1832:
    defined $I101, $P2528
    unless $I101, for_undef_1833
    iter $P121, $P2528
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2539_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2539_test:
    unless $P121, loop2539_done
    shift $P124, $P121
  loop2539_redo:
    .const 'Sub' $P2530 = "463_1312646121.678" 
    capture_lex $P2530
    $P2530($P124)
  loop2539_next:
    goto loop2539_test
  loop2539_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2539_next
    eq $P128, .CONTROL_LOOP_REDO, loop2539_redo
  loop2539_done:
    pop_eh 
  for_undef_1833:
.annotate 'line', 2679
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2529"  :anon :subid("463_1312646121.678") :outer("462_1312646121.678")
    .param pmc param_2533
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2682
    $P2532 = root_new ['parrot';'Hash']
    set $P2531, $P2532
    .lex "%sym", $P2531
    .lex "$_", param_2533
    find_lex $P125, "$_"
    unless_null $P125, vivify_1834
    new $P125, "Undef"
  vivify_1834:
    find_lex $P127, "$final_name"
    unless_null $P127, vivify_1835
    new $P127, "Undef"
  vivify_1835:
    $P128 = $P125."symbol"($P127)
    store_lex "%sym", $P128
.annotate 'line', 2683
    find_lex $P2535, "%sym"
    unless_null $P2535, vivify_1836
    $P2535 = root_new ['parrot';'Hash']
  vivify_1836:
    set $N102, $P2535
    if $N102, if_2534
    new $P125, 'Float'
    set $P125, $N102
    goto if_2534_end
  if_2534:
.annotate 'line', 2684
    find_lex $P2537, "%sym"
    unless_null $P2537, vivify_1837
    $P2537 = root_new ['parrot';'Hash']
  vivify_1837:
    exists $I102, $P2537["value"]
    if $I102, if_2536
.annotate 'line', 2688
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$final_name"
    unless_null $P129, vivify_1838
    new $P129, "Undef"
  vivify_1838:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2687
    goto if_2536_end
  if_2536:
.annotate 'line', 2685
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    find_lex $P2538, "%sym"
    unless_null $P2538, vivify_1839
    $P2538 = root_new ['parrot';'Hash']
  vivify_1839:
    set $P129, $P2538["value"]
    unless_null $P129, vivify_1840
    new $P129, "Undef"
  vivify_1840:
    setattribute $P128, 'payload', $P129
    throw $P128
  if_2536_end:
.annotate 'line', 2683
    set $P125, $P127
  if_2534_end:
.annotate 'line', 2681
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2542"  :anon :subid("464_1312646121.678") :outer("461_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2698
    .const 'Sub' $P2548 = "465_1312646121.678" 
    capture_lex $P2548
.annotate 'line', 2699
    new $P120, "Undef"
    set $P2544, $P120
    .lex "$first", $P2544
    new $P121, "Float"
    assign $P121, 0
    set $I101, $P121
    find_lex $P2545, "@name"
    unless_null $P2545, vivify_1844
    $P2545 = root_new ['parrot';'ResizablePMCArray']
  vivify_1844:
    set $P122, $P2545[$I101]
    unless_null $P122, vivify_1845
    new $P122, "Undef"
  vivify_1845:
    store_lex "$first", $P122
.annotate 'line', 2700
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2546, $P123["@BLOCK"]
    unless_null $P2546, vivify_1846
    $P2546 = root_new ['parrot';'ResizablePMCArray']
  vivify_1846:
    defined $I101, $P2546
    unless $I101, for_undef_1847
    iter $P121, $P2546
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2558_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2558_test:
    unless $P121, loop2558_done
    shift $P124, $P121
  loop2558_redo:
    .const 'Sub' $P2548 = "465_1312646121.678" 
    capture_lex $P2548
    $P2548($P124)
  loop2558_next:
    goto loop2558_test
  loop2558_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2558_next
    eq $P128, .CONTROL_LOOP_REDO, loop2558_redo
  loop2558_done:
    pop_eh 
  for_undef_1847:
.annotate 'line', 2698
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2547"  :anon :subid("465_1312646121.678") :outer("464_1312646121.678")
    .param pmc param_2551
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2701
    $P2550 = root_new ['parrot';'Hash']
    set $P2549, $P2550
    .lex "%sym", $P2549
    .lex "$_", param_2551
    find_lex $P125, "$_"
    unless_null $P125, vivify_1848
    new $P125, "Undef"
  vivify_1848:
    find_lex $P127, "$first"
    unless_null $P127, vivify_1849
    new $P127, "Undef"
  vivify_1849:
    $P128 = $P125."symbol"($P127)
    store_lex "%sym", $P128
.annotate 'line', 2702
    find_lex $P2553, "%sym"
    unless_null $P2553, vivify_1850
    $P2553 = root_new ['parrot';'Hash']
  vivify_1850:
    set $N102, $P2553
    if $N102, if_2552
    new $P125, 'Float'
    set $P125, $N102
    goto if_2552_end
  if_2552:
.annotate 'line', 2703
    find_lex $P2555, "%sym"
    unless_null $P2555, vivify_1851
    $P2555 = root_new ['parrot';'Hash']
  vivify_1851:
    exists $I102, $P2555["value"]
    if $I102, if_2554
.annotate 'line', 2709
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$first"
    unless_null $P129, vivify_1852
    new $P129, "Undef"
  vivify_1852:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2708
    goto if_2554_end
  if_2554:
.annotate 'line', 2704
    find_lex $P2556, "%sym"
    unless_null $P2556, vivify_1853
    $P2556 = root_new ['parrot';'Hash']
  vivify_1853:
    set $P128, $P2556["value"]
    unless_null $P128, vivify_1854
    new $P128, "Undef"
  vivify_1854:
    store_lex "$result", $P128
.annotate 'line', 2705
    find_lex $P2557, "@name"
    unless_null $P2557, vivify_1855
    $P2557 = root_new ['parrot';'ResizablePMCArray']
  vivify_1855:
    $P2557."shift"()
.annotate 'line', 2706
    die 0, .CONTROL_LOOP_LAST
  if_2554_end:
.annotate 'line', 2702
    set $P125, $P127
  if_2552_end:
.annotate 'line', 2700
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2560"  :anon :subid("466_1312646121.678") :outer("461_1312646121.678")
    .param pmc param_2562
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2716
    .lex "$_", param_2562
.annotate 'line', 2717
    find_lex $P125, "$_"
    unless_null $P125, vivify_1858
    new $P125, "Undef"
  vivify_1858:
    set $S100, $P125
    find_lex $P123, "$result"
    unless_null $P123, vivify_1859
    new $P123, "Undef"
  vivify_1859:
    get_who $P124, $P123
    exists $I101, $P124[$S100]
    if $I101, if_2563
.annotate 'line', 2721
    new $P127, "String"
    assign $P127, "Could not locate compile-time value for symbol "
.annotate 'line', 2722
    find_lex $P2564, "@name"
    unless_null $P2564, vivify_1860
    $P2564 = root_new ['parrot';'ResizablePMCArray']
  vivify_1860:
    join $S101, "::", $P2564
    concat $P128, $P127, $S101
.annotate 'line', 2721
    die $P128
.annotate 'line', 2720
    goto if_2563_end
  if_2563:
.annotate 'line', 2718
    find_lex $P127, "$_"
    unless_null $P127, vivify_1861
    new $P127, "Undef"
  vivify_1861:
    find_lex $P128, "$result"
    unless_null $P128, vivify_1862
    new $P128, "Undef"
  vivify_1862:
    get_who $P129, $P128
    set $P130, $P129[$P127]
    unless_null $P130, vivify_1863
    new $P130, "Undef"
  vivify_1863:
    store_lex "$result", $P130
.annotate 'line', 2717
    set $P122, $P130
  if_2563_end:
.annotate 'line', 2716
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("467_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2570
    .param pmc param_2571
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1243
    .lex "self", param_2570
    .lex "$/", param_2571
    find_lex $P122, "$/"
    find_lex $P2572, "$/"
    unless_null $P2572, vivify_1865
    $P2572 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P123, $P2572["comp_unit"]
    unless_null $P123, vivify_1866
    new $P123, "Undef"
  vivify_1866:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("468_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2574
    .param pmc param_2575
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1245
    .lex "self", param_2574
    .lex "$/", param_2575
.annotate 'line', 1246
    find_lex $P122, "$/"
.annotate 'line', 1247
    find_lex $P2577, "$/"
    unless_null $P2577, vivify_1867
    $P2577 = root_new ['parrot';'Hash']
  vivify_1867:
    set $P124, $P2577["colonpair"]
    unless_null $P124, vivify_1868
    new $P124, "Undef"
  vivify_1868:
    if $P124, if_2576
.annotate 'line', 1249
    find_lex $P139, "$/"
    unless_null $P139, vivify_1869
    new $P139, "Undef"
  vivify_1869:
    set $S103, $P139
    new $P123, 'String'
    set $P123, $S103
.annotate 'line', 1247
    goto if_2576_end
  if_2576:
    find_lex $P2578, "$/"
    unless_null $P2578, vivify_1870
    $P2578 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P125, $P2578["identifier"]
    unless_null $P125, vivify_1871
    new $P125, "Undef"
  vivify_1871:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    concat $P128, $P127, ":"
    new $P129, "Float"
    assign $P129, 0
    set $I100, $P129
    find_lex $P2579, "$/"
    unless_null $P2579, vivify_1872
    $P2579 = root_new ['parrot';'Hash']
  vivify_1872:
    set $P2580, $P2579["colonpair"]
    unless_null $P2580, vivify_1873
    $P2580 = root_new ['parrot';'ResizablePMCArray']
  vivify_1873:
    set $P130, $P2580[$I100]
    unless_null $P130, vivify_1874
    new $P130, "Undef"
  vivify_1874:
    $P131 = $P130."ast"()
    $S101 = $P131."named"()
    concat $P132, $P128, $S101
    concat $P133, $P132, "<"
.annotate 'line', 1248
    new $P134, "Float"
    assign $P134, 0
    set $I101, $P134
    find_lex $P2581, "$/"
    unless_null $P2581, vivify_1875
    $P2581 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P2582, $P2581["colonpair"]
    unless_null $P2582, vivify_1876
    $P2582 = root_new ['parrot';'ResizablePMCArray']
  vivify_1876:
    set $P135, $P2582[$I101]
    unless_null $P135, vivify_1877
    new $P135, "Undef"
  vivify_1877:
    $P136 = $P135."ast"()
    $S102 = "colonpair_str"($P136)
    concat $P137, $P133, $S102
    concat $P138, $P137, ">"
    set $P123, $P138
  if_2576_end:
.annotate 'line', 1247
    $P140 = $P122."!make"($P123)
.annotate 'line', 1245
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit" :anon :subid("469_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2584
    .param pmc param_2585
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1259
    .const 'Sub' $P2598 = "470_1312646121.678" 
    capture_lex $P2598
    .lex "self", param_2584
    .lex "$/", param_2585
.annotate 'line', 1260
    new $P122, "Undef"
    set $P2586, $P122
    .lex "$mainline", $P2586
.annotate 'line', 1261
    new $P123, "Undef"
    set $P2587, $P123
    .lex "$unit", $P2587
.annotate 'line', 1284
    $P2589 = root_new ['parrot';'ResizablePMCArray']
    set $P2588, $P2589
    .lex "@loadlibs", $P2588
.annotate 'line', 1297
    new $P124, "Undef"
    set $P2590, $P124
    .lex "$main_tasks", $P2590
.annotate 'line', 1260
    find_lex $P2591, "$/"
    unless_null $P2591, vivify_1878
    $P2591 = root_new ['parrot';'Hash']
  vivify_1878:
    set $P125, $P2591["statementlist"]
    unless_null $P125, vivify_1879
    new $P125, "Undef"
  vivify_1879:
    $P127 = $P125."ast"()
    store_lex "$mainline", $P127
.annotate 'line', 1261
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2592, $P127["@BLOCK"]
    unless_null $P2592, vivify_1880
    $P2592 = root_new ['parrot';'ResizablePMCArray']
  vivify_1880:
    $P128 = $P2592."shift"()
    store_lex "$unit", $P128
.annotate 'line', 1265
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1881
    new $P125, "Undef"
  vivify_1881:
    $P127 = $P125."loadinit"()
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_1882
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_1883
    die "Contextual $*SC not found"
  vivify_1883:
  vivify_1882:
    $P131 = $P130."to_past"()
    $P127."push"($P131)
.annotate 'line', 1270
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1884
    new $P125, "Undef"
  vivify_1884:
    $P127 = $P125."loadinit"()
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
.annotate 'line', 1272
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    new $P136, "ResizablePMCArray"
    $P137 = $P135."new"("GLOBAL" :named("name"), $P136 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1273
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_1885
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_1886
    die "Contextual $*SC not found"
  vivify_1886:
  vivify_1885:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_1887
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_1888
    die "Contextual $*PACKAGE not found"
  vivify_1888:
  vivify_1887:
    $P144 = $P140."get_slot_past_for_object"($P143)
    $P145 = $P131."new"($P137, $P144, "bind_6model" :named("pasttype"))
.annotate 'line', 1270
    $P127."push"($P145)
.annotate 'line', 1279
    find_dynamic_lex $P128, "$*HAS_YOU_ARE_HERE"
    unless_null $P128, vivify_1889
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$HAS_YOU_ARE_HERE"]
    unless_null $P128, vivify_1890
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1890:
  vivify_1889:
    if $P128, unless_2593_end
.annotate 'line', 1280
    find_lex $P129, "$unit"
    unless_null $P129, vivify_1891
    new $P129, "Undef"
  vivify_1891:
    find_lex $P130, "self"
    $P131 = $P130."CTXSAVE"()
    $P129."push"($P131)
  unless_2593_end:
.annotate 'line', 1284
    new $P125, "ResizablePMCArray"
    push $P125, "nqp_group"
    push $P125, "nqp_ops"
    push $P125, "trans_ops"
    push $P125, "io_ops"
    store_lex "@loadlibs", $P125
.annotate 'line', 1285
    find_dynamic_lex $P128, "%*COMPILING"
    unless_null $P128, vivify_1892
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%COMPILING"]
    unless_null $P128, vivify_1893
    die "Contextual %*COMPILING not found"
  vivify_1893:
  vivify_1892:
    set $P2595, $P128["%?OPTIONS"]
    unless_null $P2595, vivify_1894
    $P2595 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P129, $P2595["vmlibs"]
    unless_null $P129, vivify_1895
    new $P129, "Undef"
  vivify_1895:
    unless $P129, if_2594_end
.annotate 'line', 1286
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_1896
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_1897
    die "Contextual %*COMPILING not found"
  vivify_1897:
  vivify_1896:
    set $P2596, $P133["%?OPTIONS"]
    unless_null $P2596, vivify_1898
    $P2596 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P134, $P2596["vmlibs"]
    unless_null $P134, vivify_1899
    new $P134, "Undef"
  vivify_1899:
    set $S100, $P134
    split $P135, ",", $S100
    defined $I100, $P135
    unless $I100, for_undef_1900
    iter $P130, $P135
    new $P137, 'ExceptionHandler'
    set_label $P137, loop2601_handler
    $P137."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P137
  loop2601_test:
    unless $P130, loop2601_done
    shift $P136, $P130
  loop2601_redo:
    .const 'Sub' $P2598 = "470_1312646121.678" 
    capture_lex $P2598
    $P2598($P136)
  loop2601_next:
    goto loop2601_test
  loop2601_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P139, exception, 'type'
    eq $P139, .CONTROL_LOOP_NEXT, loop2601_next
    eq $P139, .CONTROL_LOOP_REDO, loop2601_redo
  loop2601_done:
    pop_eh 
  for_undef_1900:
  if_2594_end:
.annotate 'line', 1290
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1903
    new $P125, "Undef"
  vivify_1903:
    find_lex $P2602, "@loadlibs"
    unless_null $P2602, vivify_1904
    $P2602 = root_new ['parrot';'ResizablePMCArray']
  vivify_1904:
    $P125."loadlibs"($P2602 :flat)
.annotate 'line', 1296
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1905
    new $P125, "Undef"
  vivify_1905:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P125."unshift"($P131)
.annotate 'line', 1297
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
.annotate 'line', 1298
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    $P134 = $P133."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1299
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1301
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
    new $P143, "ResizablePMCArray"
    $P144 = $P142."new"("ModuleLoader" :named("name"), $P143 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1302
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Var"]
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Op"]
    $P154 = $P153."new"("getinterp P" :named("pirop"))
    $P155 = $P148."new"($P154, "context", "keyed" :named("scope"))
    $P156 = $P138."new"($P144, $P155, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1299
    $P157 = $P129."new"($P134, $P156)
.annotate 'line', 1297
    store_lex "$main_tasks", $P157
.annotate 'line', 1305
    find_dynamic_lex $P128, "$*MAIN_SUB"
    unless_null $P128, vivify_1906
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$MAIN_SUB"]
    unless_null $P128, vivify_1907
    die "Contextual $*MAIN_SUB not found"
  vivify_1907:
  vivify_1906:
    unless $P128, if_2603_end
.annotate 'line', 1306
    find_lex $P129, "$main_tasks"
    unless_null $P129, vivify_1908
    new $P129, "Undef"
  vivify_1908:
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 1307
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "PAST"
    get_who $P136, $P135
    set $P137, $P136["Val"]
    find_dynamic_lex $P140, "$*MAIN_SUB"
    unless_null $P140, vivify_1909
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MAIN_SUB"]
    unless_null $P140, vivify_1910
    die "Contextual $*MAIN_SUB not found"
  vivify_1910:
  vivify_1909:
    $P141 = $P137."new"($P140 :named("value"))
.annotate 'line', 1308
    get_hll_global $P142, "GLOBAL"
    nqp_get_package_through_who $P143, $P142, "PAST"
    get_who $P144, $P143
    set $P145, $P144["Var"]
    $P146 = $P145."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P147 = $P133."new"($P141, $P146, "call" :named("pasttype"))
.annotate 'line', 1306
    $P129."push"($P147)
  if_2603_end:
.annotate 'line', 1311
    find_lex $P125, "$mainline"
    unless_null $P125, vivify_1911
    new $P125, "Undef"
  vivify_1911:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
.annotate 'line', 1313
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    $P135 = $P134."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P136, "$main_tasks"
    unless_null $P136, vivify_1912
    new $P136, "Undef"
  vivify_1912:
    $P137 = $P130."new"($P135, $P136, "if" :named("pasttype"))
.annotate 'line', 1311
    $P125."push"($P137)
.annotate 'line', 1320
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1913
    new $P125, "Undef"
  vivify_1913:
.annotate 'line', 1321
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    find_lex $P131, "$mainline"
    unless_null $P131, vivify_1914
    new $P131, "Undef"
  vivify_1914:
    $P132 = $P130."new"($P131, "return" :named("pirop"))
    $P125."push"($P132)
.annotate 'line', 1326
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1915
    new $P125, "Undef"
  vivify_1915:
.annotate 'line', 1327
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Block"]
.annotate 'line', 1329
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Op"]
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Val"]
    find_lex $P139, "$unit"
    unless_null $P139, vivify_1916
    new $P139, "Undef"
  vivify_1916:
    $P140 = $P138."new"($P139 :named("value"))
    $P141 = $P134."new"($P140, "call" :named("pasttype"))
    $P142 = $P130."new"($P141, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1327
    $P125."push"($P142)
.annotate 'line', 1332
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1917
    new $P125, "Undef"
  vivify_1917:
    find_lex $P127, "$/"
    unless_null $P127, vivify_1918
    new $P127, "Undef"
  vivify_1918:
    $P125."node"($P127)
.annotate 'line', 1335
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1919
    new $P125, "Undef"
  vivify_1919:
    $P125."hll"("nqp")
.annotate 'line', 1337
    find_lex $P125, "$/"
    find_lex $P127, "$unit"
    unless_null $P127, vivify_1920
    new $P127, "Undef"
  vivify_1920:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1259
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2597"  :anon :subid("470_1312646121.678") :outer("469_1312646121.678")
    .param pmc param_2599
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1286
    .lex "$_", param_2599
.annotate 'line', 1287
    find_lex $P2600, "@loadlibs"
    unless_null $P2600, vivify_1901
    $P2600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1901:
    find_lex $P137, "$_"
    unless_null $P137, vivify_1902
    new $P137, "Undef"
  vivify_1902:
    $P138 = $P2600."push"($P137)
.annotate 'line', 1286
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("471_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2605
    .param pmc param_2606
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1340
    .const 'Sub' $P2612 = "472_1312646121.678" 
    capture_lex $P2612
    .lex "self", param_2605
    .lex "$/", param_2606
.annotate 'line', 1341
    new $P122, "Undef"
    set $P2607, $P122
    .lex "$past", $P2607
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_1921
    new $P128, "Undef"
  vivify_1921:
    $P129 = $P127."new"($P128 :named("node"))
    store_lex "$past", $P129
.annotate 'line', 1342
    find_lex $P2609, "$/"
    unless_null $P2609, vivify_1922
    $P2609 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P123, $P2609["statement"]
    unless_null $P123, vivify_1923
    new $P123, "Undef"
  vivify_1923:
    unless $P123, if_2608_end
.annotate 'line', 1343
    find_lex $P2610, "$/"
    unless_null $P2610, vivify_1924
    $P2610 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P125, $P2610["statement"]
    unless_null $P125, vivify_1925
    new $P125, "Undef"
  vivify_1925:
    defined $I100, $P125
    unless $I100, for_undef_1926
    iter $P124, $P125
    new $P129, 'ExceptionHandler'
    set_label $P129, loop2621_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop2621_test:
    unless $P124, loop2621_done
    shift $P127, $P124
  loop2621_redo:
    .const 'Sub' $P2612 = "472_1312646121.678" 
    capture_lex $P2612
    $P2612($P127)
  loop2621_next:
    goto loop2621_test
  loop2621_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop2621_next
    eq $P130, .CONTROL_LOOP_REDO, loop2621_redo
  loop2621_done:
    pop_eh 
  for_undef_1926:
  if_2608_end:
.annotate 'line', 1351
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_1939
    new $P124, "Undef"
  vivify_1939:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1340
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2611"  :anon :subid("472_1312646121.678") :outer("471_1312646121.678")
    .param pmc param_2614
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1344
    new $P128, "Undef"
    set $P2613, $P128
    .lex "$ast", $P2613
    .lex "$_", param_2614
    find_lex $P129, "$_"
    unless_null $P129, vivify_1927
    new $P129, "Undef"
  vivify_1927:
    $P130 = $P129."ast"()
    store_lex "$ast", $P130
.annotate 'line', 1345
    find_lex $P2616, "$ast"
    unless_null $P2616, vivify_1928
    $P2616 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P129, $P2616["sink"]
    unless_null $P129, vivify_1929
    new $P129, "Undef"
  vivify_1929:
    defined $I101, $P129
    unless $I101, if_2615_end
    find_lex $P2617, "$ast"
    unless_null $P2617, vivify_1930
    $P2617 = root_new ['parrot';'Hash']
  vivify_1930:
    set $P130, $P2617["sink"]
    unless_null $P130, vivify_1931
    new $P130, "Undef"
  vivify_1931:
    store_lex "$ast", $P130
  if_2615_end:
.annotate 'line', 1346
    find_lex $P2619, "$ast"
    unless_null $P2619, vivify_1932
    $P2619 = root_new ['parrot';'Hash']
  vivify_1932:
    set $P129, $P2619["bareblock"]
    unless_null $P129, vivify_1933
    new $P129, "Undef"
  vivify_1933:
    unless $P129, if_2618_end
    find_lex $P130, "$ast"
    unless_null $P130, vivify_1934
    new $P130, "Undef"
  vivify_1934:
    $P131 = "block_immediate"($P130)
    store_lex "$ast", $P131
  if_2618_end:
.annotate 'line', 1347
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Node"]
    find_lex $P133, "$ast"
    unless_null $P133, vivify_1935
    new $P133, "Undef"
  vivify_1935:
    $P134 = $P132."ACCEPTS"($P133)
    unless $P134, if_2620_end
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Stmt"]
    find_lex $P139, "$ast"
    unless_null $P139, vivify_1936
    new $P139, "Undef"
  vivify_1936:
    $P140 = $P138."new"($P139)
    store_lex "$ast", $P140
  if_2620_end:
.annotate 'line', 1348
    find_lex $P129, "$past"
    unless_null $P129, vivify_1937
    new $P129, "Undef"
  vivify_1937:
    find_lex $P130, "$ast"
    unless_null $P130, vivify_1938
    new $P130, "Undef"
  vivify_1938:
    $P131 = $P129."push"($P130)
.annotate 'line', 1343
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("473_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2623
    .param pmc param_2624
    .param pmc param_2625 :optional
    .param int has_param_2625 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1354
    .const 'Sub' $P2630 = "474_1312646121.678" 
    capture_lex $P2630
    .lex "self", param_2623
    .lex "$/", param_2624
    if has_param_2625, optparam_1940
    new $P122, "Undef"
    set param_2625, $P122
  optparam_1940:
    .lex "$key", param_2625
.annotate 'line', 1355
    new $P123, "Undef"
    set $P2626, $P123
    .lex "$past", $P2626
.annotate 'line', 1354
    find_lex $P124, "$past"
    unless_null $P124, vivify_1941
    new $P124, "Undef"
  vivify_1941:
.annotate 'line', 1356
    find_lex $P2628, "$/"
    unless_null $P2628, vivify_1942
    $P2628 = root_new ['parrot';'Hash']
  vivify_1942:
    set $P124, $P2628["EXPR"]
    unless_null $P124, vivify_1943
    new $P124, "Undef"
  vivify_1943:
    if $P124, if_2627
.annotate 'line', 1377
    find_lex $P2649, "$/"
    unless_null $P2649, vivify_1944
    $P2649 = root_new ['parrot';'Hash']
  vivify_1944:
    set $P129, $P2649["statement_control"]
    unless_null $P129, vivify_1945
    new $P129, "Undef"
  vivify_1945:
    if $P129, if_2648
.annotate 'line', 1378
    new $P130, "Float"
    assign $P130, 0
    store_lex "$past", $P130
    goto if_2648_end
  if_2648:
.annotate 'line', 1377
    find_lex $P2650, "$/"
    unless_null $P2650, vivify_1946
    $P2650 = root_new ['parrot';'Hash']
  vivify_1946:
    set $P130, $P2650["statement_control"]
    unless_null $P130, vivify_1947
    new $P130, "Undef"
  vivify_1947:
    $P131 = $P130."ast"()
    store_lex "$past", $P131
  if_2648_end:
    goto if_2627_end
  if_2627:
.annotate 'line', 1356
    .const 'Sub' $P2630 = "474_1312646121.678" 
    capture_lex $P2630
    $P2630()
  if_2627_end:
.annotate 'line', 1379
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_1981
    new $P125, "Undef"
  vivify_1981:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1354
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2629"  :anon :subid("474_1312646121.678") :outer("473_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1357
    new $P125, "Undef"
    set $P2631, $P125
    .lex "$mc", $P2631
.annotate 'line', 1358
    new $P127, "Undef"
    set $P2632, $P127
    .lex "$ml", $P2632
.annotate 'line', 1357
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P2633, "$/"
    unless_null $P2633, vivify_1948
    $P2633 = root_new ['parrot';'Hash']
  vivify_1948:
    set $P2634, $P2633["statement_mod_cond"]
    unless_null $P2634, vivify_1949
    $P2634 = root_new ['parrot';'ResizablePMCArray']
  vivify_1949:
    set $P129, $P2634[$I100]
    unless_null $P129, vivify_1950
    new $P129, "Undef"
  vivify_1950:
    store_lex "$mc", $P129
.annotate 'line', 1358
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P2635, "$/"
    unless_null $P2635, vivify_1951
    $P2635 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P2636, $P2635["statement_mod_loop"]
    unless_null $P2636, vivify_1952
    $P2636 = root_new ['parrot';'ResizablePMCArray']
  vivify_1952:
    set $P129, $P2636[$I100]
    unless_null $P129, vivify_1953
    new $P129, "Undef"
  vivify_1953:
    store_lex "$ml", $P129
.annotate 'line', 1359
    find_lex $P2637, "$/"
    unless_null $P2637, vivify_1954
    $P2637 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P128, $P2637["EXPR"]
    unless_null $P128, vivify_1955
    new $P128, "Undef"
  vivify_1955:
    $P129 = $P128."ast"()
    store_lex "$past", $P129
.annotate 'line', 1360
    find_lex $P128, "$mc"
    unless_null $P128, vivify_1956
    new $P128, "Undef"
  vivify_1956:
    unless $P128, if_2638_end
.annotate 'line', 1361
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P2639, "$mc"
    unless_null $P2639, vivify_1957
    $P2639 = root_new ['parrot';'Hash']
  vivify_1957:
    set $P133, $P2639["cond"]
    unless_null $P133, vivify_1958
    new $P133, "Undef"
  vivify_1958:
    $P134 = $P133."ast"()
    find_lex $P135, "$past"
    unless_null $P135, vivify_1959
    new $P135, "Undef"
  vivify_1959:
    find_lex $P2640, "$mc"
    unless_null $P2640, vivify_1960
    $P2640 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P136, $P2640["sym"]
    unless_null $P136, vivify_1961
    new $P136, "Undef"
  vivify_1961:
    set $S100, $P136
    find_lex $P137, "$/"
    unless_null $P137, vivify_1962
    new $P137, "Undef"
  vivify_1962:
    $P138 = $P132."new"($P134, $P135, $S100 :named("pasttype"), $P137 :named("node"))
    store_lex "$past", $P138
  if_2638_end:
.annotate 'line', 1363
    find_lex $P129, "$ml"
    unless_null $P129, vivify_1963
    new $P129, "Undef"
  vivify_1963:
    if $P129, if_2641
    set $P128, $P129
    goto if_2641_end
  if_2641:
.annotate 'line', 1364
    find_lex $P2643, "$ml"
    unless_null $P2643, vivify_1964
    $P2643 = root_new ['parrot';'Hash']
  vivify_1964:
    set $P131, $P2643["sym"]
    unless_null $P131, vivify_1965
    new $P131, "Undef"
  vivify_1965:
    set $S100, $P131
    iseq $I100, $S100, "for"
    if $I100, if_2642
.annotate 'line', 1373
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    find_lex $P2646, "$ml"
    unless_null $P2646, vivify_1966
    $P2646 = root_new ['parrot';'Hash']
  vivify_1966:
    set $P136, $P2646["cond"]
    unless_null $P136, vivify_1967
    new $P136, "Undef"
  vivify_1967:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1968
    new $P138, "Undef"
  vivify_1968:
    find_lex $P2647, "$ml"
    unless_null $P2647, vivify_1969
    $P2647 = root_new ['parrot';'Hash']
  vivify_1969:
    set $P139, $P2647["sym"]
    unless_null $P139, vivify_1970
    new $P139, "Undef"
  vivify_1970:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1971
    new $P140, "Undef"
  vivify_1971:
    $P142 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P142
.annotate 'line', 1372
    set $P130, $P142
.annotate 'line', 1364
    goto if_2642_end
  if_2642:
.annotate 'line', 1365
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Block"]
.annotate 'line', 1366
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    $P140 = $P139."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P141, "$past"
    unless_null $P141, vivify_1972
    new $P141, "Undef"
  vivify_1972:
    $P142 = $P135."new"($P140, $P141, "immediate" :named("blocktype"))
.annotate 'line', 1365
    store_lex "$past", $P142
.annotate 'line', 1368
    find_lex $P132, "$past"
    unless_null $P132, vivify_1973
    new $P132, "Undef"
  vivify_1973:
    $P132."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1369
    find_lex $P132, "$past"
    unless_null $P132, vivify_1974
    new $P132, "Undef"
  vivify_1974:
    $P132."arity"(1)
.annotate 'line', 1370
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    find_lex $P2644, "$ml"
    unless_null $P2644, vivify_1975
    $P2644 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P136, $P2644["cond"]
    unless_null $P136, vivify_1976
    new $P136, "Undef"
  vivify_1976:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1977
    new $P138, "Undef"
  vivify_1977:
    find_lex $P2645, "$ml"
    unless_null $P2645, vivify_1978
    $P2645 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P139, $P2645["sym"]
    unless_null $P139, vivify_1979
    new $P139, "Undef"
  vivify_1979:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1980
    new $P140, "Undef"
  vivify_1980:
    $P141 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P141
.annotate 'line', 1364
    set $P130, $P141
  if_2642_end:
.annotate 'line', 1363
    set $P128, $P130
  if_2641_end:
.annotate 'line', 1356
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("475_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2652
    .param pmc param_2653
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1382
    .lex "self", param_2652
    .lex "$/", param_2653
.annotate 'line', 1383
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P2654, "$/"
    unless_null $P2654, vivify_1982
    $P2654 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P128, $P2654["EXPR"]
    unless_null $P128, vivify_1983
    new $P128, "Undef"
  vivify_1983:
    $P129 = $P128."ast"()
    find_lex $P2655, "$/"
    unless_null $P2655, vivify_1984
    $P2655 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P130, $P2655["pblock"]
    unless_null $P130, vivify_1985
    new $P130, "Undef"
  vivify_1985:
    $P131 = $P130."ast"()
    find_lex $P132, "$/"
    unless_null $P132, vivify_1986
    new $P132, "Undef"
  vivify_1986:
    $P133 = $P127."new"($P129, $P131, "if" :named("pasttype"), $P132 :named("node"))
    $P134 = $P122."!make"($P133)
.annotate 'line', 1382
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("476_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2657
    .param pmc param_2658
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1386
    .lex "self", param_2657
    .lex "$/", param_2658
.annotate 'line', 1387
    find_lex $P122, "$/"
    find_lex $P2659, "$/"
    unless_null $P2659, vivify_1987
    $P2659 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P123, $P2659["blockoid"]
    unless_null $P123, vivify_1988
    new $P123, "Undef"
  vivify_1988:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1386
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("477_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2661
    .param pmc param_2662
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1390
    .lex "self", param_2661
    .lex "$/", param_2662
.annotate 'line', 1391
    find_lex $P122, "$/"
    find_lex $P2663, "$/"
    unless_null $P2663, vivify_1989
    $P2663 = root_new ['parrot';'Hash']
  vivify_1989:
    set $P123, $P2663["blockoid"]
    unless_null $P123, vivify_1990
    new $P123, "Undef"
  vivify_1990:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1390
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("478_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2665
    .param pmc param_2666
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1394
    .const 'Sub' $P2672 = "479_1312646121.678" 
    capture_lex $P2672
    .lex "self", param_2665
    .lex "$/", param_2666
.annotate 'line', 1395
    new $P122, "Undef"
    set $P2667, $P122
    .lex "$BLOCK", $P2667
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2668, $P124["@BLOCK"]
    unless_null $P2668, vivify_1991
    $P2668 = root_new ['parrot';'ResizablePMCArray']
  vivify_1991:
    $P125 = $P2668."shift"()
    store_lex "$BLOCK", $P125
.annotate 'line', 1396
    find_lex $P2670, "$/"
    unless_null $P2670, vivify_1992
    $P2670 = root_new ['parrot';'Hash']
  vivify_1992:
    set $P124, $P2670["statementlist"]
    unless_null $P124, vivify_1993
    new $P124, "Undef"
  vivify_1993:
    if $P124, if_2669
.annotate 'line', 1404
    find_dynamic_lex $P131, "$*HAS_YOU_ARE_HERE"
    unless_null $P131, vivify_1994
    get_hll_global $P128, "GLOBAL"
    get_who $P130, $P128
    set $P131, $P130["$HAS_YOU_ARE_HERE"]
    unless_null $P131, vivify_1995
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1995:
  vivify_1994:
    unless $P131, if_2675_end
.annotate 'line', 1405
    find_lex $P132, "$/"
    unless_null $P132, vivify_1996
    new $P132, "Undef"
  vivify_1996:
    $P133 = $P132."CURSOR"()
    $P133."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_2675_end:
.annotate 'line', 1407
    new $P128, "Float"
    assign $P128, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P128
.annotate 'line', 1408
    find_lex $P128, "$/"
    find_lex $P2676, "$/"
    unless_null $P2676, vivify_1997
    $P2676 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P130, $P2676["you_are_here"]
    unless_null $P130, vivify_1998
    new $P130, "Undef"
  vivify_1998:
    $P131 = $P130."ast"()
    $P132 = $P128."!make"($P131)
.annotate 'line', 1403
    set $P123, $P132
.annotate 'line', 1396
    goto if_2669_end
  if_2669:
    .const 'Sub' $P2672 = "479_1312646121.678" 
    capture_lex $P2672
    $P127 = $P2672()
    set $P123, $P127
  if_2669_end:
.annotate 'line', 1394
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2671"  :anon :subid("479_1312646121.678") :outer("478_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1397
    new $P125, "Undef"
    set $P2673, $P125
    .lex "$past", $P2673
    find_lex $P2674, "$/"
    unless_null $P2674, vivify_1999
    $P2674 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P127, $P2674["statementlist"]
    unless_null $P127, vivify_2000
    new $P127, "Undef"
  vivify_2000:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 1398
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2001
    new $P127, "Undef"
  vivify_2001:
    find_lex $P128, "$past"
    unless_null $P128, vivify_2002
    new $P128, "Undef"
  vivify_2002:
    $P127."push"($P128)
.annotate 'line', 1399
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2003
    new $P127, "Undef"
  vivify_2003:
    find_lex $P128, "$/"
    unless_null $P128, vivify_2004
    new $P128, "Undef"
  vivify_2004:
    $P127."node"($P128)
.annotate 'line', 1400
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2005
    new $P127, "Undef"
  vivify_2005:
    $P127."closure"(1)
.annotate 'line', 1401
    find_dynamic_lex $P127, "$/"
    find_lex $P128, "$BLOCK"
    unless_null $P128, vivify_2006
    new $P128, "Undef"
  vivify_2006:
    $P129 = $P127."!make"($P128)
.annotate 'line', 1396
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("480_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2678
    .param pmc param_2679
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1412
    .lex "self", param_2678
    .lex "$/", param_2679
.annotate 'line', 1413
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2680, $P123["@BLOCK"]
    unless_null $P2680, vivify_2007
    $P2680 = root_new ['parrot';'ResizablePMCArray']
  vivify_2007:
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Block"]
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Stmts"]
    $P133 = $P132."new"()
    $P134 = $P128."new"($P133)
    $P135 = $P2680."unshift"($P134)
.annotate 'line', 1412
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("481_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2682
    .param pmc param_2683
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1416
    .const 'Sub' $P2687 = "482_1312646121.678" 
    capture_lex $P2687
    .lex "self", param_2682
    .lex "$/", param_2683
.annotate 'line', 1417
    find_dynamic_lex $P124, "%*COMPILING"
    unless_null $P124, vivify_2008
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%COMPILING"]
    unless_null $P124, vivify_2009
    die "Contextual %*COMPILING not found"
  vivify_2009:
  vivify_2008:
    set $P2685, $P124["%?OPTIONS"]
    unless_null $P2685, vivify_2010
    $P2685 = root_new ['parrot';'Hash']
  vivify_2010:
    set $P125, $P2685["outer_ctx"]
    unless_null $P125, vivify_2011
    new $P125, "Undef"
  vivify_2011:
    defined $I100, $P125
    if $I100, unless_2684_end
    .const 'Sub' $P2687 = "482_1312646121.678" 
    capture_lex $P2687
    $P2687()
  unless_2684_end:
.annotate 'line', 1430
    find_lex $P122, "self"
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    find_lex $P124, "$?PACKAGE"
    get_who $P125, $P124
    set $P2695, $P125["@BLOCK"]
    unless_null $P2695, vivify_2027
    $P2695 = root_new ['parrot';'ResizablePMCArray']
  vivify_2027:
    set $P127, $P2695[$I100]
    unless_null $P127, vivify_2028
    new $P127, "Undef"
  vivify_2028:
    $P128 = $P122."SET_BLOCK_OUTER_CTX"($P127)
.annotate 'line', 1416
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2686"  :anon :subid("482_1312646121.678") :outer("481_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1420
    new $P127, "Undef"
    set $P2688, $P127
    .lex "$SETTING", $P2688
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_2012
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_2013
    die "Contextual $*SC not found"
  vivify_2013:
  vivify_2012:
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_2014
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_2015
    die "Contextual %*COMPILING not found"
  vivify_2015:
  vivify_2014:
    set $P2690, $P133["%?OPTIONS"]
    unless_null $P2690, vivify_2016
    $P2690 = root_new ['parrot';'Hash']
  vivify_2016:
    set $P134, $P2690["setting"]
    unless_null $P134, vivify_2017
    new $P134, "Undef"
  vivify_2017:
    set $P2689, $P134
    defined $I2692, $P2689
    if $I2692, default_2691
    new $P135, "String"
    assign $P135, "NQPCORE"
    set $P2689, $P135
  default_2691:
    $P136 = $P130."load_setting"($P2689)
    store_lex "$SETTING", $P136
.annotate 'line', 1425
    find_dynamic_lex $P131, "%*COMPILING"
    unless_null $P131, vivify_2018
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%COMPILING"]
    unless_null $P131, vivify_2019
    die "Contextual %*COMPILING not found"
  vivify_2019:
  vivify_2018:
    set $P2694, $P131["%?OPTIONS"]
    unless_null $P2694, vivify_2020
    $P2694 = root_new ['parrot';'Hash']
  vivify_2020:
    set $P132, $P2694["setting"]
    unless_null $P132, vivify_2021
    new $P132, "Undef"
  vivify_2021:
    set $S100, $P132
    iseq $I101, $S100, "NULL"
    unless $I101, unless_2693
    new $P128, 'Integer'
    set $P128, $I101
    goto unless_2693_end
  unless_2693:
.annotate 'line', 1426
    find_lex $P133, "$SETTING"
    unless_null $P133, vivify_2022
    new $P133, "Undef"
  vivify_2022:
    "import_HOW_exports"($P133)
.annotate 'line', 1427
    find_dynamic_lex $P135, "$*SC"
    unless_null $P135, vivify_2023
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SC"]
    unless_null $P135, vivify_2024
    die "Contextual $*SC not found"
  vivify_2024:
  vivify_2023:
    find_dynamic_lex $P138, "$*GLOBALish"
    unless_null $P138, vivify_2025
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$GLOBALish"]
    unless_null $P138, vivify_2026
    die "Contextual $*GLOBALish not found"
  vivify_2026:
  vivify_2025:
    $P139 = $P135."load_module"("NQPRegex", $P138)
.annotate 'line', 1425
    set $P128, $P139
  unless_2693_end:
.annotate 'line', 1417
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("483_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2697
    .param pmc param_2698
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1442
    .lex "self", param_2697
    .lex "$/", param_2698
.annotate 'line', 1446
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2029
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2030
    die "Contextual $*SC not found"
  vivify_2030:
  vivify_2029:
    find_dynamic_lex $P128, "%*HOW"
    unless_null $P128, vivify_2031
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%HOW"]
    unless_null $P128, vivify_2032
    die "Contextual %*HOW not found"
  vivify_2032:
  vivify_2031:
    set $P129, $P128["knowhow"]
    unless_null $P129, vivify_2033
    new $P129, "Undef"
  vivify_2033:
    $P130 = $P124."pkg_create_mo"($P129, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P130
.annotate 'line', 1447
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2034
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2035
    die "Contextual $*GLOBALish not found"
  vivify_2035:
  vivify_2034:
    get_how $P125, $P124
    find_dynamic_lex $P129, "$*GLOBALish"
    unless_null $P129, vivify_2036
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$GLOBALish"]
    unless_null $P129, vivify_2037
    die "Contextual $*GLOBALish not found"
  vivify_2037:
  vivify_2036:
    $P125."compose"($P129)
.annotate 'line', 1448
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2038
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2039
    die "Contextual $*SC not found"
  vivify_2039:
  vivify_2038:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P2699, $P128["@BLOCK"]
    unless_null $P2699, vivify_2040
    $P2699 = root_new ['parrot';'ResizablePMCArray']
  vivify_2040:
    set $P129, $P2699[$I100]
    unless_null $P129, vivify_2041
    new $P129, "Undef"
  vivify_2041:
    find_dynamic_lex $P132, "$*GLOBALish"
    unless_null $P132, vivify_2042
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$GLOBALish"]
    unless_null $P132, vivify_2043
    die "Contextual $*GLOBALish not found"
  vivify_2043:
  vivify_2042:
    $P124."install_lexical_symbol"($P129, "GLOBALish", $P132)
.annotate 'line', 1451
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2044
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2045
    die "Contextual $*GLOBALish not found"
  vivify_2045:
  vivify_2044:
    store_dynamic_lex "$*PACKAGE", $P124
.annotate 'line', 1452
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2046
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2047
    die "Contextual $*SC not found"
  vivify_2047:
  vivify_2046:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P2700, $P128["@BLOCK"]
    unless_null $P2700, vivify_2048
    $P2700 = root_new ['parrot';'ResizablePMCArray']
  vivify_2048:
    set $P129, $P2700[$I100]
    unless_null $P129, vivify_2049
    new $P129, "Undef"
  vivify_2049:
    find_dynamic_lex $P132, "$*PACKAGE"
    unless_null $P132, vivify_2050
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$PACKAGE"]
    unless_null $P132, vivify_2051
    die "Contextual $*PACKAGE not found"
  vivify_2051:
  vivify_2050:
    $P133 = $P124."install_lexical_symbol"($P129, "$?PACKAGE", $P132)
.annotate 'line', 1442
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("484_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2702
    .param pmc param_2703
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1455
    .lex "self", param_2702
    .lex "$/", param_2703
.annotate 'line', 1456
    find_lex $P122, "$/"
    find_lex $P123, "self"
    $P124 = $P123."CTXSAVE"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1455
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("485_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2705
    .param pmc param_2706
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1461
    .lex "self", param_2705
    .lex "$/", param_2706
.annotate 'line', 1462
    new $P122, "Undef"
    set $P2707, $P122
    .lex "$module", $P2707
    find_dynamic_lex $P125, "$*SC"
    unless_null $P125, vivify_2052
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SC"]
    unless_null $P125, vivify_2053
    die "Contextual $*SC not found"
  vivify_2053:
  vivify_2052:
    find_lex $P2708, "$/"
    unless_null $P2708, vivify_2054
    $P2708 = root_new ['parrot';'Hash']
  vivify_2054:
    set $P127, $P2708["name"]
    unless_null $P127, vivify_2055
    new $P127, "Undef"
  vivify_2055:
    set $S100, $P127
    find_dynamic_lex $P130, "$*GLOBALish"
    unless_null $P130, vivify_2056
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$GLOBALish"]
    unless_null $P130, vivify_2057
    die "Contextual $*GLOBALish not found"
  vivify_2057:
  vivify_2056:
    $P131 = $P125."load_module"($S100, $P130)
    store_lex "$module", $P131
.annotate 'line', 1463
    find_lex $P123, "$module"
    unless_null $P123, vivify_2058
    new $P123, "Undef"
  vivify_2058:
    defined $I100, $P123
    unless $I100, if_2709_end
.annotate 'line', 1464
    find_lex $P124, "$module"
    unless_null $P124, vivify_2059
    new $P124, "Undef"
  vivify_2059:
    "import_HOW_exports"($P124)
  if_2709_end:
.annotate 'line', 1466
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    $P129 = $P128."new"()
    $P130 = $P123."!make"($P129)
.annotate 'line', 1461
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("486_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2711
    .param pmc param_2712
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1469
    .const 'Sub' $P2723 = "487_1312646121.678" 
    capture_lex $P2723
    .lex "self", param_2711
    .lex "$/", param_2712
.annotate 'line', 1470
    new $P122, "Undef"
    set $P2713, $P122
    .lex "$count", $P2713
.annotate 'line', 1471
    new $P123, "Undef"
    set $P2714, $P123
    .lex "$past", $P2714
.annotate 'line', 1470
    find_lex $P2715, "$/"
    unless_null $P2715, vivify_2060
    $P2715 = root_new ['parrot';'Hash']
  vivify_2060:
    set $P124, $P2715["xblock"]
    unless_null $P124, vivify_2061
    new $P124, "Undef"
  vivify_2061:
    set $N100, $P124
    new $P125, 'Float'
    set $P125, $N100
    sub $P127, $P125, 1
    store_lex "$count", $P127
.annotate 'line', 1471
    find_lex $P124, "$count"
    unless_null $P124, vivify_2062
    new $P124, "Undef"
  vivify_2062:
    set $I100, $P124
    find_lex $P2716, "$/"
    unless_null $P2716, vivify_2063
    $P2716 = root_new ['parrot';'Hash']
  vivify_2063:
    set $P2717, $P2716["xblock"]
    unless_null $P2717, vivify_2064
    $P2717 = root_new ['parrot';'ResizablePMCArray']
  vivify_2064:
    set $P125, $P2717[$I100]
    unless_null $P125, vivify_2065
    new $P125, "Undef"
  vivify_2065:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    store_lex "$past", $P128
.annotate 'line', 1472
    find_lex $P2719, "$/"
    unless_null $P2719, vivify_2066
    $P2719 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P124, $P2719["else"]
    unless_null $P124, vivify_2067
    new $P124, "Undef"
  vivify_2067:
    unless $P124, if_2718_end
.annotate 'line', 1473
    find_lex $P125, "$past"
    unless_null $P125, vivify_2068
    new $P125, "Undef"
  vivify_2068:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P2720, "$/"
    unless_null $P2720, vivify_2069
    $P2720 = root_new ['parrot';'Hash']
  vivify_2069:
    set $P2721, $P2720["else"]
    unless_null $P2721, vivify_2070
    $P2721 = root_new ['parrot';'ResizablePMCArray']
  vivify_2070:
    set $P128, $P2721[$I100]
    unless_null $P128, vivify_2071
    new $P128, "Undef"
  vivify_2071:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    $P125."push"($P130)
  if_2718_end:
.annotate 'line', 1476
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2728_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2728_test:
    find_lex $P124, "$count"
    unless_null $P124, vivify_2072
    new $P124, "Undef"
  vivify_2072:
    set $N100, $P124
    set $N101, 0
    isgt $I100, $N100, $N101
    unless $I100, loop2728_done
  loop2728_redo:
    .const 'Sub' $P2723 = "487_1312646121.678" 
    capture_lex $P2723
    $P2723()
  loop2728_next:
    goto loop2728_test
  loop2728_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2728_next
    eq $P128, .CONTROL_LOOP_REDO, loop2728_redo
  loop2728_done:
    pop_eh 
.annotate 'line', 1482
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2081
    new $P125, "Undef"
  vivify_2081:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1469
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2722"  :anon :subid("487_1312646121.678") :outer("486_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1478
    new $P125, "Undef"
    set $P2724, $P125
    .lex "$else", $P2724
.annotate 'line', 1476
    find_lex $P127, "$count"
    unless_null $P127, vivify_2073
    new $P127, "Undef"
  vivify_2073:
    clone $P2725, $P127
    dec $P127
.annotate 'line', 1478
    find_lex $P127, "$past"
    unless_null $P127, vivify_2074
    new $P127, "Undef"
  vivify_2074:
    store_lex "$else", $P127
.annotate 'line', 1479
    find_lex $P127, "$count"
    unless_null $P127, vivify_2075
    new $P127, "Undef"
  vivify_2075:
    set $I101, $P127
    find_lex $P2726, "$/"
    unless_null $P2726, vivify_2076
    $P2726 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P2727, $P2726["xblock"]
    unless_null $P2727, vivify_2077
    $P2727 = root_new ['parrot';'ResizablePMCArray']
  vivify_2077:
    set $P128, $P2727[$I101]
    unless_null $P128, vivify_2078
    new $P128, "Undef"
  vivify_2078:
    $P129 = $P128."ast"()
    $P130 = "xblock_immediate"($P129)
    store_lex "$past", $P130
.annotate 'line', 1480
    find_lex $P127, "$past"
    unless_null $P127, vivify_2079
    new $P127, "Undef"
  vivify_2079:
    find_lex $P128, "$else"
    unless_null $P128, vivify_2080
    new $P128, "Undef"
  vivify_2080:
    $P129 = $P127."push"($P128)
.annotate 'line', 1476
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("488_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2730
    .param pmc param_2731
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1485
    .lex "self", param_2730
    .lex "$/", param_2731
.annotate 'line', 1486
    new $P122, "Undef"
    set $P2732, $P122
    .lex "$past", $P2732
    find_lex $P2733, "$/"
    unless_null $P2733, vivify_2082
    $P2733 = root_new ['parrot';'Hash']
  vivify_2082:
    set $P123, $P2733["xblock"]
    unless_null $P123, vivify_2083
    new $P123, "Undef"
  vivify_2083:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    store_lex "$past", $P125
.annotate 'line', 1487
    find_lex $P123, "$past"
    unless_null $P123, vivify_2084
    new $P123, "Undef"
  vivify_2084:
    $P123."pasttype"("unless")
.annotate 'line', 1488
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2085
    new $P124, "Undef"
  vivify_2085:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1485
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("489_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2735
    .param pmc param_2736
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1491
    .lex "self", param_2735
    .lex "$/", param_2736
.annotate 'line', 1492
    new $P122, "Undef"
    set $P2737, $P122
    .lex "$past", $P2737
    find_lex $P2738, "$/"
    unless_null $P2738, vivify_2086
    $P2738 = root_new ['parrot';'Hash']
  vivify_2086:
    set $P123, $P2738["xblock"]
    unless_null $P123, vivify_2087
    new $P123, "Undef"
  vivify_2087:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    store_lex "$past", $P125
.annotate 'line', 1493
    find_lex $P123, "$past"
    unless_null $P123, vivify_2088
    new $P123, "Undef"
  vivify_2088:
    find_lex $P2739, "$/"
    unless_null $P2739, vivify_2089
    $P2739 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P124, $P2739["sym"]
    unless_null $P124, vivify_2090
    new $P124, "Undef"
  vivify_2090:
    set $S100, $P124
    $P123."pasttype"($S100)
.annotate 'line', 1494
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2091
    new $P124, "Undef"
  vivify_2091:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1491
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("490_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2741
    .param pmc param_2742
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1497
    .lex "self", param_2741
    .lex "$/", param_2742
.annotate 'line', 1498
    new $P122, "Undef"
    set $P2743, $P122
    .lex "$pasttype", $P2743
.annotate 'line', 1499
    new $P123, "Undef"
    set $P2744, $P123
    .lex "$past", $P2744
.annotate 'line', 1498
    new $P124, "String"
    assign $P124, "repeat_"
    find_lex $P2745, "$/"
    unless_null $P2745, vivify_2092
    $P2745 = root_new ['parrot';'Hash']
  vivify_2092:
    set $P125, $P2745["wu"]
    unless_null $P125, vivify_2093
    new $P125, "Undef"
  vivify_2093:
    set $S100, $P125
    concat $P127, $P124, $S100
    store_lex "$pasttype", $P127
.annotate 'line', 1497
    find_lex $P124, "$past"
    unless_null $P124, vivify_2094
    new $P124, "Undef"
  vivify_2094:
.annotate 'line', 1500
    find_lex $P2747, "$/"
    unless_null $P2747, vivify_2095
    $P2747 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P124, $P2747["xblock"]
    unless_null $P124, vivify_2096
    new $P124, "Undef"
  vivify_2096:
    if $P124, if_2746
.annotate 'line', 1505
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P2749, "$/"
    unless_null $P2749, vivify_2097
    $P2749 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P130, $P2749["EXPR"]
    unless_null $P130, vivify_2098
    new $P130, "Undef"
  vivify_2098:
    $P131 = $P130."ast"()
    find_lex $P2750, "$/"
    unless_null $P2750, vivify_2099
    $P2750 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P132, $P2750["pblock"]
    unless_null $P132, vivify_2100
    new $P132, "Undef"
  vivify_2100:
    $P133 = $P132."ast"()
    $P134 = "block_immediate"($P133)
    find_lex $P135, "$pasttype"
    unless_null $P135, vivify_2101
    new $P135, "Undef"
  vivify_2101:
    find_lex $P136, "$/"
    unless_null $P136, vivify_2102
    new $P136, "Undef"
  vivify_2102:
    $P137 = $P129."new"($P131, $P134, $P135 :named("pasttype"), $P136 :named("node"))
    store_lex "$past", $P137
.annotate 'line', 1504
    goto if_2746_end
  if_2746:
.annotate 'line', 1501
    find_lex $P2748, "$/"
    unless_null $P2748, vivify_2103
    $P2748 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P125, $P2748["xblock"]
    unless_null $P125, vivify_2104
    new $P125, "Undef"
  vivify_2104:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    store_lex "$past", $P128
.annotate 'line', 1502
    find_lex $P125, "$past"
    unless_null $P125, vivify_2105
    new $P125, "Undef"
  vivify_2105:
    find_lex $P127, "$pasttype"
    unless_null $P127, vivify_2106
    new $P127, "Undef"
  vivify_2106:
    $P125."pasttype"($P127)
  if_2746_end:
.annotate 'line', 1508
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2107
    new $P125, "Undef"
  vivify_2107:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1497
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("491_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2752
    .param pmc param_2753
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1511
    .lex "self", param_2752
    .lex "$/", param_2753
.annotate 'line', 1512
    new $P122, "Undef"
    set $P2754, $P122
    .lex "$past", $P2754
.annotate 'line', 1514
    new $P123, "Undef"
    set $P2755, $P123
    .lex "$block", $P2755
.annotate 'line', 1512
    find_lex $P2756, "$/"
    unless_null $P2756, vivify_2108
    $P2756 = root_new ['parrot';'Hash']
  vivify_2108:
    set $P124, $P2756["xblock"]
    unless_null $P124, vivify_2109
    new $P124, "Undef"
  vivify_2109:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 1513
    find_lex $P124, "$past"
    unless_null $P124, vivify_2110
    new $P124, "Undef"
  vivify_2110:
    $P124."pasttype"("for")
.annotate 'line', 1514
    new $P124, "Float"
    assign $P124, 1
    set $I100, $P124
    find_lex $P2757, "$past"
    unless_null $P2757, vivify_2111
    $P2757 = root_new ['parrot';'ResizablePMCArray']
  vivify_2111:
    set $P125, $P2757[$I100]
    unless_null $P125, vivify_2112
    new $P125, "Undef"
  vivify_2112:
    store_lex "$block", $P125
.annotate 'line', 1515
    find_lex $P124, "$block"
    unless_null $P124, vivify_2113
    new $P124, "Undef"
  vivify_2113:
    $P125 = $P124."arity"()
    if $P125, unless_2758_end
.annotate 'line', 1516
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P2759, "$block"
    unless_null $P2759, vivify_2114
    $P2759 = root_new ['parrot';'ResizablePMCArray']
  vivify_2114:
    set $P128, $P2759[$I100]
    unless_null $P128, vivify_2115
    new $P128, "Undef"
  vivify_2115:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Var"]
    $P133 = $P132."new"("$_" :named("name"), "parameter" :named("scope"))
    $P128."push"($P133)
.annotate 'line', 1517
    find_lex $P127, "$block"
    unless_null $P127, vivify_2116
    new $P127, "Undef"
  vivify_2116:
    $P127."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1518
    find_lex $P127, "$block"
    unless_null $P127, vivify_2117
    new $P127, "Undef"
  vivify_2117:
    $P127."arity"(1)
  unless_2758_end:
.annotate 'line', 1520
    find_lex $P124, "$block"
    unless_null $P124, vivify_2118
    new $P124, "Undef"
  vivify_2118:
    $P124."blocktype"("immediate")
.annotate 'line', 1521
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2119
    new $P125, "Undef"
  vivify_2119:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1511
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("492_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2761
    .param pmc param_2762
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1524
    .lex "self", param_2761
    .lex "$/", param_2762
.annotate 'line', 1525
    new $P122, "Undef"
    set $P2763, $P122
    .lex "$block", $P2763
    find_lex $P2764, "$/"
    unless_null $P2764, vivify_2120
    $P2764 = root_new ['parrot';'Hash']
  vivify_2120:
    set $P123, $P2764["block"]
    unless_null $P123, vivify_2121
    new $P123, "Undef"
  vivify_2121:
    $P124 = $P123."ast"()
    store_lex "$block", $P124
.annotate 'line', 1526
    find_lex $P123, "$/"
    unless_null $P123, vivify_2122
    new $P123, "Undef"
  vivify_2122:
    find_lex $P124, "$block"
    unless_null $P124, vivify_2123
    new $P124, "Undef"
  vivify_2123:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1527
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2765, $P127["@BLOCK"]
    unless_null $P2765, vivify_2124
    $P2765 = root_new ['parrot';'ResizablePMCArray']
  vivify_2124:
    set $P128, $P2765[$I101]
    unless_null $P128, vivify_2125
    new $P128, "Undef"
  vivify_2125:
    $P129 = $P128."handlers"()
    set $P130, $P129[$I100]
    unless_null $P130, vivify_2126
    new $P130, "Undef"
  vivify_2126:
    $P130."handle_types_except"("CONTROL")
.annotate 'line', 1528
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2127
    new $P129, "Undef"
  vivify_2127:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1524
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("493_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2767
    .param pmc param_2768
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1531
    .lex "self", param_2767
    .lex "$/", param_2768
.annotate 'line', 1532
    new $P122, "Undef"
    set $P2769, $P122
    .lex "$block", $P2769
    find_lex $P2770, "$/"
    unless_null $P2770, vivify_2128
    $P2770 = root_new ['parrot';'Hash']
  vivify_2128:
    set $P123, $P2770["block"]
    unless_null $P123, vivify_2129
    new $P123, "Undef"
  vivify_2129:
    $P124 = $P123."ast"()
    store_lex "$block", $P124
.annotate 'line', 1533
    find_lex $P123, "$/"
    unless_null $P123, vivify_2130
    new $P123, "Undef"
  vivify_2130:
    find_lex $P124, "$block"
    unless_null $P124, vivify_2131
    new $P124, "Undef"
  vivify_2131:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1534
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2771, $P127["@BLOCK"]
    unless_null $P2771, vivify_2132
    $P2771 = root_new ['parrot';'ResizablePMCArray']
  vivify_2132:
    set $P128, $P2771[$I101]
    unless_null $P128, vivify_2133
    new $P128, "Undef"
  vivify_2133:
    $P129 = $P128."handlers"()
    set $P130, $P129[$I100]
    unless_null $P130, vivify_2134
    new $P130, "Undef"
  vivify_2134:
    $P130."handle_types"("CONTROL")
.annotate 'line', 1535
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2135
    new $P129, "Undef"
  vivify_2135:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1531
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("494_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2773
    .param pmc param_2774
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1575
    .lex "self", param_2773
    .lex "$/", param_2774
.annotate 'line', 1576
    new $P122, "Float"
    assign $P122, 0
    set $I100, $P122
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2775, $P124["@BLOCK"]
    unless_null $P2775, vivify_2136
    $P2775 = root_new ['parrot';'ResizablePMCArray']
  vivify_2136:
    set $P125, $P2775[$I100]
    unless_null $P125, vivify_2137
    new $P125, "Undef"
  vivify_2137:
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_2138
    $P2776 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P127, $P2776["blorst"]
    unless_null $P127, vivify_2139
    new $P127, "Undef"
  vivify_2139:
    $P128 = $P127."ast"()
    $P125."push"($P128)
.annotate 'line', 1577
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    $P128 = $P127."new"()
    $P129 = $P122."!make"($P128)
.annotate 'line', 1575
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("495_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2778
    .param pmc param_2779
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1580
    .lex "self", param_2778
    .lex "$/", param_2779
.annotate 'line', 1581
    new $P122, "Undef"
    set $P2780, $P122
    .lex "$past", $P2780
    find_lex $P2781, "$/"
    unless_null $P2781, vivify_2140
    $P2781 = root_new ['parrot';'Hash']
  vivify_2140:
    set $P123, $P2781["blorst"]
    unless_null $P123, vivify_2141
    new $P123, "Undef"
  vivify_2141:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 1582
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Block"]
    find_lex $P128, "$past"
    unless_null $P128, vivify_2142
    new $P128, "Undef"
  vivify_2142:
    $P129 = $P127."ACCEPTS"($P128)
    if $P129, unless_2782_end
.annotate 'line', 1583
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Block"]
    find_lex $P134, "$past"
    unless_null $P134, vivify_2143
    new $P134, "Undef"
  vivify_2143:
    find_lex $P135, "$/"
    unless_null $P135, vivify_2144
    new $P135, "Undef"
  vivify_2144:
    $P136 = $P133."new"($P134, "immediate" :named("blocktype"), $P135 :named("node"))
    store_lex "$past", $P136
  unless_2782_end:
.annotate 'line', 1585
    find_lex $P123, "$past"
    unless_null $P123, vivify_2145
    new $P123, "Undef"
  vivify_2145:
    $P124 = $P123."handlers"()
    if $P124, unless_2783_end
.annotate 'line', 1586
    find_lex $P125, "$past"
    unless_null $P125, vivify_2146
    new $P125, "Undef"
  vivify_2146:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Control"]
.annotate 'line', 1588
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Stmts"]
.annotate 'line', 1589
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1590
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
.annotate 'line', 1591
    get_hll_global $P143, "GLOBAL"
    nqp_get_package_through_who $P144, $P143, "PAST"
    get_who $P145, $P144
    set $P146, $P145["Var"]
    $P147 = $P146."new"("register" :named("scope"), "exception" :named("name"))
    $P148 = $P142."new"($P147, "handled", "keyed" :named("scope"))
.annotate 'line', 1590
    $P149 = $P138."new"($P148, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1589
    $P151 = $P134."new"($P149)
.annotate 'line', 1588
    $P152 = $P130."new"($P151, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1586
    new $P153, "ResizablePMCArray"
    push $P153, $P152
    $P125."handlers"($P153)
  unless_2783_end:
.annotate 'line', 1600
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2147
    new $P124, "Undef"
  vivify_2147:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1580
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("496_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2785
    .param pmc param_2786
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1603
    .lex "self", param_2785
    .lex "$/", param_2786
.annotate 'line', 1604
    find_lex $P122, "$/"
.annotate 'line', 1605
    find_lex $P2788, "$/"
    unless_null $P2788, vivify_2148
    $P2788 = root_new ['parrot';'Hash']
  vivify_2148:
    set $P124, $P2788["block"]
    unless_null $P124, vivify_2149
    new $P124, "Undef"
  vivify_2149:
    if $P124, if_2787
.annotate 'line', 1606
    find_lex $P2790, "$/"
    unless_null $P2790, vivify_2150
    $P2790 = root_new ['parrot';'Hash']
  vivify_2150:
    set $P129, $P2790["statement"]
    unless_null $P129, vivify_2151
    new $P129, "Undef"
  vivify_2151:
    $P130 = $P129."ast"()
    set $P123, $P130
.annotate 'line', 1605
    goto if_2787_end
  if_2787:
    find_lex $P2789, "$/"
    unless_null $P2789, vivify_2152
    $P2789 = root_new ['parrot';'Hash']
  vivify_2152:
    set $P125, $P2789["block"]
    unless_null $P125, vivify_2153
    new $P125, "Undef"
  vivify_2153:
    $P127 = $P125."ast"()
    $P128 = "block_immediate"($P127)
    set $P123, $P128
  if_2787_end:
    $P131 = $P122."!make"($P123)
.annotate 'line', 1603
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("497_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2792
    .param pmc param_2793
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1611
    .lex "self", param_2792
    .lex "$/", param_2793
    find_lex $P122, "$/"
    find_lex $P2794, "$/"
    unless_null $P2794, vivify_2154
    $P2794 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P123, $P2794["cond"]
    unless_null $P123, vivify_2155
    new $P123, "Undef"
  vivify_2155:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("498_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2796
    .param pmc param_2797
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1612
    .lex "self", param_2796
    .lex "$/", param_2797
    find_lex $P122, "$/"
    find_lex $P2798, "$/"
    unless_null $P2798, vivify_2156
    $P2798 = root_new ['parrot';'Hash']
  vivify_2156:
    set $P123, $P2798["cond"]
    unless_null $P123, vivify_2157
    new $P123, "Undef"
  vivify_2157:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("499_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2800
    .param pmc param_2801
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1614
    .lex "self", param_2800
    .lex "$/", param_2801
    find_lex $P122, "$/"
    find_lex $P2802, "$/"
    unless_null $P2802, vivify_2158
    $P2802 = root_new ['parrot';'Hash']
  vivify_2158:
    set $P123, $P2802["cond"]
    unless_null $P123, vivify_2159
    new $P123, "Undef"
  vivify_2159:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("500_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2804
    .param pmc param_2805
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1615
    .lex "self", param_2804
    .lex "$/", param_2805
    find_lex $P122, "$/"
    find_lex $P2806, "$/"
    unless_null $P2806, vivify_2160
    $P2806 = root_new ['parrot';'Hash']
  vivify_2160:
    set $P123, $P2806["cond"]
    unless_null $P123, vivify_2161
    new $P123, "Undef"
  vivify_2161:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("501_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2808
    .param pmc param_2809
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1619
    .lex "self", param_2808
    .lex "$/", param_2809
    find_lex $P122, "$/"
    find_lex $P2810, "$/"
    unless_null $P2810, vivify_2162
    $P2810 = root_new ['parrot';'Hash']
  vivify_2162:
    set $P123, $P2810["fatarrow"]
    unless_null $P123, vivify_2163
    new $P123, "Undef"
  vivify_2163:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("502_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2812
    .param pmc param_2813
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1620
    .lex "self", param_2812
    .lex "$/", param_2813
    find_lex $P122, "$/"
    find_lex $P2814, "$/"
    unless_null $P2814, vivify_2164
    $P2814 = root_new ['parrot';'Hash']
  vivify_2164:
    set $P123, $P2814["colonpair"]
    unless_null $P123, vivify_2165
    new $P123, "Undef"
  vivify_2165:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("503_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2816
    .param pmc param_2817
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1621
    .lex "self", param_2816
    .lex "$/", param_2817
    find_lex $P122, "$/"
    find_lex $P2818, "$/"
    unless_null $P2818, vivify_2166
    $P2818 = root_new ['parrot';'Hash']
  vivify_2166:
    set $P123, $P2818["variable"]
    unless_null $P123, vivify_2167
    new $P123, "Undef"
  vivify_2167:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("504_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2820
    .param pmc param_2821
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1622
    .lex "self", param_2820
    .lex "$/", param_2821
    find_lex $P122, "$/"
    find_lex $P2822, "$/"
    unless_null $P2822, vivify_2168
    $P2822 = root_new ['parrot';'Hash']
  vivify_2168:
    set $P123, $P2822["package_declarator"]
    unless_null $P123, vivify_2169
    new $P123, "Undef"
  vivify_2169:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("505_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2824
    .param pmc param_2825
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1623
    .lex "self", param_2824
    .lex "$/", param_2825
    find_lex $P122, "$/"
    find_lex $P2826, "$/"
    unless_null $P2826, vivify_2170
    $P2826 = root_new ['parrot';'Hash']
  vivify_2170:
    set $P123, $P2826["scope_declarator"]
    unless_null $P123, vivify_2171
    new $P123, "Undef"
  vivify_2171:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("506_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2828
    .param pmc param_2829
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1624
    .lex "self", param_2828
    .lex "$/", param_2829
    find_lex $P122, "$/"
    find_lex $P2830, "$/"
    unless_null $P2830, vivify_2172
    $P2830 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P123, $P2830["routine_declarator"]
    unless_null $P123, vivify_2173
    new $P123, "Undef"
  vivify_2173:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("507_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2832
    .param pmc param_2833
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1625
    .lex "self", param_2832
    .lex "$/", param_2833
    find_lex $P122, "$/"
    find_lex $P2834, "$/"
    unless_null $P2834, vivify_2174
    $P2834 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P123, $P2834["regex_declarator"]
    unless_null $P123, vivify_2175
    new $P123, "Undef"
  vivify_2175:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("508_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2836
    .param pmc param_2837
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1626
    .lex "self", param_2836
    .lex "$/", param_2837
    find_lex $P122, "$/"
    find_lex $P2838, "$/"
    unless_null $P2838, vivify_2176
    $P2838 = root_new ['parrot';'Hash']
  vivify_2176:
    set $P123, $P2838["statement_prefix"]
    unless_null $P123, vivify_2177
    new $P123, "Undef"
  vivify_2177:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("509_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2840
    .param pmc param_2841
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1627
    .lex "self", param_2840
    .lex "$/", param_2841
    find_lex $P122, "$/"
    find_lex $P2842, "$/"
    unless_null $P2842, vivify_2178
    $P2842 = root_new ['parrot';'Hash']
  vivify_2178:
    set $P123, $P2842["pblock"]
    unless_null $P123, vivify_2179
    new $P123, "Undef"
  vivify_2179:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("510_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2844
    .param pmc param_2845
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1629
    .lex "self", param_2844
    .lex "$/", param_2845
.annotate 'line', 1630
    new $P122, "Undef"
    set $P2846, $P122
    .lex "$past", $P2846
    find_lex $P2847, "$/"
    unless_null $P2847, vivify_2180
    $P2847 = root_new ['parrot';'Hash']
  vivify_2180:
    set $P123, $P2847["val"]
    unless_null $P123, vivify_2181
    new $P123, "Undef"
  vivify_2181:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 1631
    find_lex $P123, "$past"
    unless_null $P123, vivify_2182
    new $P123, "Undef"
  vivify_2182:
    find_lex $P2848, "$/"
    unless_null $P2848, vivify_2183
    $P2848 = root_new ['parrot';'Hash']
  vivify_2183:
    set $P124, $P2848["key"]
    unless_null $P124, vivify_2184
    new $P124, "Undef"
  vivify_2184:
    $P125 = $P124."Str"()
    $P123."named"($P125)
.annotate 'line', 1632
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2185
    new $P124, "Undef"
  vivify_2185:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1629
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("511_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2850
    .param pmc param_2851
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1635
    .lex "self", param_2850
    .lex "$/", param_2851
.annotate 'line', 1636
    new $P122, "Undef"
    set $P2852, $P122
    .lex "$past", $P2852
.annotate 'line', 1637
    find_lex $P2854, "$/"
    unless_null $P2854, vivify_2186
    $P2854 = root_new ['parrot';'Hash']
  vivify_2186:
    set $P124, $P2854["circumfix"]
    unless_null $P124, vivify_2187
    new $P124, "Undef"
  vivify_2187:
    if $P124, if_2853
.annotate 'line', 1638
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    find_lex $P2857, "$/"
    unless_null $P2857, vivify_2188
    $P2857 = root_new ['parrot';'Hash']
  vivify_2188:
    set $P133, $P2857["not"]
    unless_null $P133, vivify_2189
    new $P133, "Undef"
  vivify_2189:
    isfalse $I101, $P133
    $P134 = $P132."new"($I101 :named("value"))
    set $P123, $P134
.annotate 'line', 1637
    goto if_2853_end
  if_2853:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P2855, "$/"
    unless_null $P2855, vivify_2190
    $P2855 = root_new ['parrot';'Hash']
  vivify_2190:
    set $P2856, $P2855["circumfix"]
    unless_null $P2856, vivify_2191
    $P2856 = root_new ['parrot';'ResizablePMCArray']
  vivify_2191:
    set $P127, $P2856[$I100]
    unless_null $P127, vivify_2192
    new $P127, "Undef"
  vivify_2192:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_2853_end:
    store_lex "$past", $P123
.annotate 'line', 1639
    find_lex $P123, "$past"
    unless_null $P123, vivify_2193
    new $P123, "Undef"
  vivify_2193:
    find_lex $P2858, "$/"
    unless_null $P2858, vivify_2194
    $P2858 = root_new ['parrot';'Hash']
  vivify_2194:
    set $P124, $P2858["identifier"]
    unless_null $P124, vivify_2195
    new $P124, "Undef"
  vivify_2195:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 1640
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2196
    new $P124, "Undef"
  vivify_2196:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1635
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("512_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2860
    .param pmc param_2861
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1643
    .const 'Sub' $P2867 = "513_1312646121.678" 
    capture_lex $P2867
    .lex "self", param_2860
    .lex "$/", param_2861
.annotate 'line', 1644
    new $P122, "Undef"
    set $P2862, $P122
    .lex "$past", $P2862
.annotate 'line', 1643
    find_lex $P123, "$past"
    unless_null $P123, vivify_2197
    new $P123, "Undef"
  vivify_2197:
.annotate 'line', 1645
    find_lex $P2864, "$/"
    unless_null $P2864, vivify_2198
    $P2864 = root_new ['parrot';'Hash']
  vivify_2198:
    set $P123, $P2864["postcircumfix"]
    unless_null $P123, vivify_2199
    new $P123, "Undef"
  vivify_2199:
    if $P123, if_2863
.annotate 'line', 1649
    .const 'Sub' $P2867 = "513_1312646121.678" 
    capture_lex $P2867
    $P2867()
    goto if_2863_end
  if_2863:
.annotate 'line', 1646
    find_lex $P2865, "$/"
    unless_null $P2865, vivify_2256
    $P2865 = root_new ['parrot';'Hash']
  vivify_2256:
    set $P124, $P2865["postcircumfix"]
    unless_null $P124, vivify_2257
    new $P124, "Undef"
  vivify_2257:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 1647
    find_lex $P124, "$past"
    unless_null $P124, vivify_2258
    new $P124, "Undef"
  vivify_2258:
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
    $P130 = $P129."new"("$/" :named("name"))
    $P124."unshift"($P130)
  if_2863_end:
.annotate 'line', 1708
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2259
    new $P124, "Undef"
  vivify_2259:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1643
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2866"  :anon :subid("513_1312646121.678") :outer("512_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1649
    .const 'Sub' $P2889 = "515_1312646121.678" 
    capture_lex $P2889
    .const 'Sub' $P2880 = "514_1312646121.678" 
    capture_lex $P2880
.annotate 'line', 1650
    $P2869 = root_new ['parrot';'ResizablePMCArray']
    set $P2868, $P2869
    .lex "@name", $P2868
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "NQP"
    get_who $P127, $P125
    set $P128, $P127["Compiler"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2200
    new $P129, "Undef"
  vivify_2200:
    set $S100, $P129
    $P130 = $P128."parse_name"($S100)
    store_lex "@name", $P130
.annotate 'line', 1651
    find_lex $P2871, "@name"
    unless_null $P2871, vivify_2201
    $P2871 = root_new ['parrot';'ResizablePMCArray']
  vivify_2201:
    set $N100, $P2871
    set $N101, 1
    isgt $I100, $N100, $N101
    if $I100, if_2870
.annotate 'line', 1658
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P2877, "$/"
    unless_null $P2877, vivify_2202
    $P2877 = root_new ['parrot';'Hash']
  vivify_2202:
    set $P2878, $P2877["twigil"]
    unless_null $P2878, vivify_2203
    $P2878 = root_new ['parrot';'ResizablePMCArray']
  vivify_2203:
    set $P128, $P2878[$I101]
    unless_null $P128, vivify_2204
    new $P128, "Undef"
  vivify_2204:
    set $S100, $P128
    iseq $I102, $S100, "*"
    if $I102, if_2876
.annotate 'line', 1669
    new $P133, "Float"
    assign $P133, 0
    set $I103, $P133
    find_lex $P2886, "$/"
    unless_null $P2886, vivify_2205
    $P2886 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P2887, $P2886["twigil"]
    unless_null $P2887, vivify_2206
    $P2887 = root_new ['parrot';'ResizablePMCArray']
  vivify_2206:
    set $P134, $P2887[$I103]
    unless_null $P134, vivify_2207
    new $P134, "Undef"
  vivify_2207:
    set $S101, $P134
    iseq $I104, $S101, "!"
    if $I104, if_2885
.annotate 'line', 1698
    new $P140, "Float"
    assign $P140, 0
    set $I105, $P140
    find_lex $P2905, "@name"
    unless_null $P2905, vivify_2208
    $P2905 = root_new ['parrot';'ResizablePMCArray']
  vivify_2208:
    set $P141, $P2905[$I105]
    unless_null $P141, vivify_2209
    new $P141, "Undef"
  vivify_2209:
    set $S102, $P141
    $P142 = "is_package"($S102)
    if $P142, if_2904
.annotate 'line', 1703
    get_hll_global $P143, "GLOBAL"
    nqp_get_package_through_who $P144, $P143, "PAST"
    get_who $P145, $P144
    set $P147, $P145["Var"]
.annotate 'line', 1704
    find_lex $P2908, "@name"
    unless_null $P2908, vivify_2210
    $P2908 = root_new ['parrot';'ResizablePMCArray']
  vivify_2210:
    $P148 = $P2908."pop"()
    set $S103, $P148
    find_lex $P2909, "$/"
    unless_null $P2909, vivify_2211
    $P2909 = root_new ['parrot';'Hash']
  vivify_2211:
    set $P149, $P2909["sigil"]
    unless_null $P149, vivify_2212
    new $P149, "Undef"
  vivify_2212:
    $P151 = "vivitype"($P149)
.annotate 'line', 1703
    $P152 = $P147."new"($S103 :named("name"), $P151 :named("viviself"))
    store_lex "$past", $P152
.annotate 'line', 1702
    set $P139, $P152
.annotate 'line', 1698
    goto if_2904_end
  if_2904:
.annotate 'line', 1699
    find_lex $P2906, "@name"
    unless_null $P2906, vivify_2213
    $P2906 = root_new ['parrot';'ResizablePMCArray']
  vivify_2213:
    find_lex $P143, "$/"
    unless_null $P143, vivify_2214
    new $P143, "Undef"
  vivify_2214:
    $P144 = "lexical_package_lookup"($P2906, $P143)
    store_lex "$past", $P144
.annotate 'line', 1700
    find_lex $P143, "$past"
    unless_null $P143, vivify_2215
    new $P143, "Undef"
  vivify_2215:
    find_lex $P2907, "$/"
    unless_null $P2907, vivify_2216
    $P2907 = root_new ['parrot';'Hash']
  vivify_2216:
    set $P144, $P2907["sigil"]
    unless_null $P144, vivify_2217
    new $P144, "Undef"
  vivify_2217:
    $P145 = "vivitype"($P144)
    $P146 = $P143."viviself"($P145)
.annotate 'line', 1698
    set $P139, $P146
  if_2904_end:
    set $P132, $P139
.annotate 'line', 1669
    goto if_2885_end
  if_2885:
    .const 'Sub' $P2889 = "515_1312646121.678" 
    capture_lex $P2889
    $P138 = $P2889()
    set $P132, $P138
  if_2885_end:
    set $P125, $P132
.annotate 'line', 1658
    goto if_2876_end
  if_2876:
    .const 'Sub' $P2880 = "514_1312646121.678" 
    capture_lex $P2880
    $P131 = $P2880()
    set $P125, $P131
  if_2876_end:
    set $P124, $P125
.annotate 'line', 1651
    goto if_2870_end
  if_2870:
.annotate 'line', 1652
    find_lex $P2873, "$/"
    unless_null $P2873, vivify_2248
    $P2873 = root_new ['parrot';'Hash']
  vivify_2248:
    set $P125, $P2873["twigil"]
    unless_null $P125, vivify_2249
    new $P125, "Undef"
  vivify_2249:
    unless $P125, if_2872_end
.annotate 'line', 1653
    find_lex $P127, "$/"
    unless_null $P127, vivify_2250
    new $P127, "Undef"
  vivify_2250:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Twigil not allowed on multi-part name")
  if_2872_end:
.annotate 'line', 1655
    find_lex $P2874, "@name"
    unless_null $P2874, vivify_2251
    $P2874 = root_new ['parrot';'ResizablePMCArray']
  vivify_2251:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2252
    new $P125, "Undef"
  vivify_2252:
    $P127 = "lexical_package_lookup"($P2874, $P125)
    store_lex "$past", $P127
.annotate 'line', 1656
    find_lex $P125, "$past"
    unless_null $P125, vivify_2253
    new $P125, "Undef"
  vivify_2253:
    find_lex $P2875, "$/"
    unless_null $P2875, vivify_2254
    $P2875 = root_new ['parrot';'Hash']
  vivify_2254:
    set $P127, $P2875["sigil"]
    unless_null $P127, vivify_2255
    new $P127, "Undef"
  vivify_2255:
    $P128 = "vivitype"($P127)
    $P129 = $P125."viviself"($P128)
.annotate 'line', 1651
    set $P124, $P129
  if_2870_end:
.annotate 'line', 1649
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2888"  :anon :subid("515_1312646121.678") :outer("513_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1669
    .const 'Sub' $P2895 = "516_1312646121.678" 
    capture_lex $P2895
.annotate 'line', 1671
    new $P135, "Undef"
    set $P2890, $P135
    .lex "$name", $P2890
    find_lex $P2891, "@name"
    unless_null $P2891, vivify_2218
    $P2891 = root_new ['parrot';'ResizablePMCArray']
  vivify_2218:
    $P136 = $P2891."pop"()
    set $S102, $P136
    new $P138, 'String'
    set $P138, $S102
    store_lex "$name", $P138
.annotate 'line', 1672
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P138, $P136, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Var"]
    find_lex $P141, "$name"
    unless_null $P141, vivify_2219
    new $P141, "Undef"
  vivify_2219:
.annotate 'line', 1674
    find_lex $P2892, "$/"
    unless_null $P2892, vivify_2220
    $P2892 = root_new ['parrot';'Hash']
  vivify_2220:
    set $P142, $P2892["sigil"]
    unless_null $P142, vivify_2221
    new $P142, "Undef"
  vivify_2221:
    $P143 = "vivitype"($P142)
.annotate 'line', 1675
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "PAST"
    get_who $P146, $P145
    set $P147, $P146["Op"]
    get_hll_global $P148, "GLOBAL"
    nqp_get_package_through_who $P149, $P148, "PAST"
    get_who $P151, $P149
    set $P152, $P151["Var"]
    $P153 = $P152."new"("self" :named("name"))
    $P154 = $P147."new"($P153, "nqp_decontainerize PP" :named("pirop"))
.annotate 'line', 1676
    get_hll_global $P155, "GLOBAL"
    nqp_get_package_through_who $P156, $P155, "PAST"
    get_who $P157, $P156
    set $P158, $P157["Var"]
    $P159 = $P158."new"("$?CLASS" :named("name"))
    $P160 = $P140."new"($P154, $P159, $P141 :named("name"), "attribute_6model" :named("scope"), $P143 :named("viviself"))
.annotate 'line', 1672
    store_lex "$past", $P160
.annotate 'line', 1680
    find_dynamic_lex $P140, "$*IN_DECL"
    unless_null $P140, vivify_2222
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$IN_DECL"]
    unless_null $P140, vivify_2223
    die "Contextual $*IN_DECL not found"
  vivify_2223:
  vivify_2222:
    unless $P140, unless_2893
    set $P136, $P140
    goto unless_2893_end
  unless_2893:
    .const 'Sub' $P2895 = "516_1312646121.678" 
    capture_lex $P2895
    $P143 = $P2895()
    set $P136, $P143
  unless_2893_end:
.annotate 'line', 1669
    .return ($P136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2894"  :anon :subid("516_1312646121.678") :outer("515_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1680
    .const 'Sub' $P2898 = "517_1312646121.678" 
    capture_lex $P2898
.annotate 'line', 1681
    new $P141, "Undef"
    set $P2896, $P141
    .lex "$attr", $P2896
.annotate 'line', 1680
    find_lex $P142, "$attr"
    unless_null $P142, vivify_2224
    new $P142, "Undef"
  vivify_2224:
.annotate 'line', 1682
    find_dynamic_lex $P145, "$*PACKAGE"
    unless_null $P145, vivify_2225
    get_hll_global $P143, "GLOBAL"
    get_who $P144, $P143
    set $P145, $P144["$PACKAGE"]
    unless_null $P145, vivify_2226
    die "Contextual $*PACKAGE not found"
  vivify_2226:
  vivify_2225:
    get_how $P146, $P145
    find_dynamic_lex $P149, "$*PACKAGE"
    unless_null $P149, vivify_2227
    get_hll_global $P147, "GLOBAL"
    get_who $P148, $P147
    set $P149, $P148["$PACKAGE"]
    unless_null $P149, vivify_2228
    die "Contextual $*PACKAGE not found"
  vivify_2228:
  vivify_2227:
    $P151 = $P146."attributes"($P149, 1 :named("local"))
    defined $I105, $P151
    unless $I105, for_undef_2229
    iter $P142, $P151
    new $P154, 'ExceptionHandler'
    set_label $P154, loop2901_handler
    $P154."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P154
  loop2901_test:
    unless $P142, loop2901_done
    shift $P152, $P142
  loop2901_redo:
    .const 'Sub' $P2898 = "517_1312646121.678" 
    capture_lex $P2898
    $P2898($P152)
  loop2901_next:
    goto loop2901_test
  loop2901_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P155, exception, 'type'
    eq $P155, .CONTROL_LOOP_NEXT, loop2901_next
    eq $P155, .CONTROL_LOOP_REDO, loop2901_redo
  loop2901_done:
    pop_eh 
  for_undef_2229:
.annotate 'line', 1688
    find_lex $P143, "$attr"
    unless_null $P143, vivify_2233
    new $P143, "Undef"
  vivify_2233:
    defined $I105, $P143
    if $I105, if_2902
.annotate 'line', 1694
    find_lex $P145, "$/"
    unless_null $P145, vivify_2234
    new $P145, "Undef"
  vivify_2234:
    $P146 = $P145."CURSOR"()
    new $P147, 'String'
    set $P147, "Attribute '"
    find_lex $P148, "$name"
    unless_null $P148, vivify_2235
    new $P148, "Undef"
  vivify_2235:
    concat $P149, $P147, $P148
    concat $P151, $P149, "' not declared"
    $P152 = $P146."panic"($P151)
.annotate 'line', 1693
    set $P142, $P152
.annotate 'line', 1688
    goto if_2902_end
  if_2902:
.annotate 'line', 1689
    find_lex $P145, "$attr"
    unless_null $P145, vivify_2236
    new $P145, "Undef"
  vivify_2236:
    can $I106, $P145, "type"
    if $I106, if_2903
    new $P144, 'Integer'
    set $P144, $I106
    goto if_2903_end
  if_2903:
.annotate 'line', 1690
    find_lex $P146, "$past"
    unless_null $P146, vivify_2237
    new $P146, "Undef"
  vivify_2237:
    find_lex $P147, "$attr"
    unless_null $P147, vivify_2238
    new $P147, "Undef"
  vivify_2238:
    $P148 = $P147."type"()
    $P149 = $P146."type"($P148)
.annotate 'line', 1689
    set $P144, $P149
  if_2903_end:
.annotate 'line', 1688
    set $P142, $P144
  if_2902_end:
.annotate 'line', 1680
    .return ($P142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2897"  :anon :subid("517_1312646121.678") :outer("516_1312646121.678")
    .param pmc param_2899
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1682
    .lex "$_", param_2899
.annotate 'line', 1683
    find_lex $P154, "$_"
    unless_null $P154, vivify_2230
    new $P154, "Undef"
  vivify_2230:
    $S102 = $P154."name"()
    find_lex $P155, "$name"
    unless_null $P155, vivify_2231
    new $P155, "Undef"
  vivify_2231:
    set $S103, $P155
    iseq $I106, $S102, $S103
    if $I106, if_2900
    new $P153, 'Integer'
    set $P153, $I106
    goto if_2900_end
  if_2900:
.annotate 'line', 1684
    find_lex $P156, "$_"
    unless_null $P156, vivify_2232
    new $P156, "Undef"
  vivify_2232:
    store_lex "$attr", $P156
.annotate 'line', 1685
    die 0, .CONTROL_LOOP_LAST
  if_2900_end:
.annotate 'line', 1682
    .return ($P153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2879"  :anon :subid("514_1312646121.678") :outer("513_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1659
    new $P130, "Undef"
    set $P2881, $P130
    .lex "$global_fallback", $P2881
    find_lex $P2882, "$/"
    unless_null $P2882, vivify_2239
    $P2882 = root_new ['parrot';'Hash']
  vivify_2239:
    set $P131, $P2882["sigil"]
    unless_null $P131, vivify_2240
    new $P131, "Undef"
  vivify_2240:
    set $S101, $P131
    new $P132, 'String'
    set $P132, $S101
    find_lex $P2883, "$/"
    unless_null $P2883, vivify_2241
    $P2883 = root_new ['parrot';'Hash']
  vivify_2241:
    set $P133, $P2883["desigilname"]
    unless_null $P133, vivify_2242
    new $P133, "Undef"
  vivify_2242:
    concat $P134, $P132, $P133
    new $P135, "ResizablePMCArray"
    push $P135, "GLOBAL"
    push $P135, $P134
    find_lex $P136, "$/"
    unless_null $P136, vivify_2243
    new $P136, "Undef"
  vivify_2243:
    $P137 = "lexical_package_lookup"($P135, $P136)
    store_lex "$global_fallback", $P137
.annotate 'line', 1660
    find_lex $P131, "$global_fallback"
    unless_null $P131, vivify_2244
    new $P131, "Undef"
  vivify_2244:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 1661
    new $P136, "String"
    assign $P136, "Contextual "
    find_lex $P137, "$/"
    unless_null $P137, vivify_2245
    new $P137, "Undef"
  vivify_2245:
    set $S101, $P137
    concat $P138, $P136, $S101
    concat $P139, $P138, " not found"
    $P140 = $P135."new"($P139, "die" :named("pirop"))
.annotate 'line', 1660
    $P131."viviself"($P140)
.annotate 'line', 1664
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
.annotate 'line', 1665
    find_lex $P2884, "@name"
    unless_null $P2884, vivify_2246
    $P2884 = root_new ['parrot';'ResizablePMCArray']
  vivify_2246:
    $P135 = $P2884."pop"()
    set $S101, $P135
.annotate 'line', 1664
    find_lex $P136, "$global_fallback"
    unless_null $P136, vivify_2247
    new $P136, "Undef"
  vivify_2247:
    $P137 = $P134."new"($S101 :named("name"), "contextual" :named("scope"), $P136 :named("viviself"))
    store_lex "$past", $P137
.annotate 'line', 1658
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("518_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2911
    .param pmc param_2912
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1711
    .lex "self", param_2911
    .lex "$/", param_2912
    find_lex $P122, "$/"
    find_lex $P2913, "$/"
    unless_null $P2913, vivify_2260
    $P2913 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P123, $P2913["package_def"]
    unless_null $P123, vivify_2261
    new $P123, "Undef"
  vivify_2261:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("519_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2915
    .param pmc param_2916
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1712
    .lex "self", param_2915
    .lex "$/", param_2916
    find_lex $P122, "$/"
    find_lex $P2917, "$/"
    unless_null $P2917, vivify_2262
    $P2917 = root_new ['parrot';'Hash']
  vivify_2262:
    set $P123, $P2917["package_def"]
    unless_null $P123, vivify_2263
    new $P123, "Undef"
  vivify_2263:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("520_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2919
    .param pmc param_2920
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1713
    .lex "self", param_2919
    .lex "$/", param_2920
    find_lex $P122, "$/"
    find_lex $P2921, "$/"
    unless_null $P2921, vivify_2264
    $P2921 = root_new ['parrot';'Hash']
  vivify_2264:
    set $P123, $P2921["package_def"]
    unless_null $P123, vivify_2265
    new $P123, "Undef"
  vivify_2265:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("521_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2923
    .param pmc param_2924
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1714
    .lex "self", param_2923
    .lex "$/", param_2924
    find_lex $P122, "$/"
    find_lex $P2925, "$/"
    unless_null $P2925, vivify_2266
    $P2925 = root_new ['parrot';'Hash']
  vivify_2266:
    set $P123, $P2925["package_def"]
    unless_null $P123, vivify_2267
    new $P123, "Undef"
  vivify_2267:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("522_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2927
    .param pmc param_2928
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1715
    .lex "self", param_2927
    .lex "$/", param_2928
    find_lex $P122, "$/"
    find_lex $P2929, "$/"
    unless_null $P2929, vivify_2268
    $P2929 = root_new ['parrot';'Hash']
  vivify_2268:
    set $P123, $P2929["package_def"]
    unless_null $P123, vivify_2269
    new $P123, "Undef"
  vivify_2269:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("523_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2931
    .param pmc param_2932
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1716
    .lex "self", param_2931
    .lex "$/", param_2932
    find_lex $P122, "$/"
    find_lex $P2933, "$/"
    unless_null $P2933, vivify_2270
    $P2933 = root_new ['parrot';'Hash']
  vivify_2270:
    set $P123, $P2933["package_def"]
    unless_null $P123, vivify_2271
    new $P123, "Undef"
  vivify_2271:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("524_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2935
    .param pmc param_2936
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1718
    .lex "self", param_2935
    .lex "$/", param_2936
.annotate 'line', 1721
    new $P122, "Undef"
    set $P2937, $P122
    .lex "$HOW", $P2937
.annotate 'line', 1722
    new $P123, "Undef"
    set $P2938, $P123
    .lex "$PACKAGE", $P2938
.annotate 'line', 1721
    find_lex $P2939, "$/"
    unless_null $P2939, vivify_2272
    $P2939 = root_new ['parrot';'Hash']
  vivify_2272:
    set $P2940, $P2939["metaclass"]
    unless_null $P2940, vivify_2273
    $P2940 = root_new ['parrot';'Hash']
  vivify_2273:
    set $P124, $P2940["identifier"]
    unless_null $P124, vivify_2274
    new $P124, "Undef"
  vivify_2274:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2275
    new $P125, "Undef"
  vivify_2275:
    $P127 = "find_sym"($P124, $P125)
    store_lex "$HOW", $P127
.annotate 'line', 1722
    find_dynamic_lex $P127, "$*SC"
    unless_null $P127, vivify_2276
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$SC"]
    unless_null $P127, vivify_2277
    die "Contextual $*SC not found"
  vivify_2277:
  vivify_2276:
    find_lex $P128, "$HOW"
    unless_null $P128, vivify_2278
    new $P128, "Undef"
  vivify_2278:
    find_lex $P2941, "$/"
    unless_null $P2941, vivify_2279
    $P2941 = root_new ['parrot';'Hash']
  vivify_2279:
    set $P129, $P2941["name"]
    unless_null $P129, vivify_2280
    new $P129, "Undef"
  vivify_2280:
    set $S100, $P129
    $P130 = $P127."pkg_create_mo"($P128, $S100 :named("name"))
    store_lex "$PACKAGE", $P130
.annotate 'line', 1725
    find_dynamic_lex $P128, "$*SCOPE"
    unless_null $P128, vivify_2281
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SCOPE"]
    unless_null $P128, vivify_2282
    die "Contextual $*SCOPE not found"
  vivify_2282:
  vivify_2281:
    set $S100, $P128
    iseq $I100, $S100, "our"
    unless $I100, unless_2943
    new $P124, 'Integer'
    set $P124, $I100
    goto unless_2943_end
  unless_2943:
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2283
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2284
    die "Contextual $*SCOPE not found"
  vivify_2284:
  vivify_2283:
    set $S101, $P131
    iseq $I101, $S101, ""
    new $P124, 'Integer'
    set $P124, $I101
  unless_2943_end:
    if $P124, if_2942
.annotate 'line', 1731
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2285
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2286
    die "Contextual $*SCOPE not found"
  vivify_2286:
  vivify_2285:
    set $S102, $P134
    iseq $I102, $S102, "my"
    if $I102, if_2953
.annotate 'line', 1738
    find_lex $P135, "$/"
    unless_null $P135, vivify_2287
    new $P135, "Undef"
  vivify_2287:
    $P136 = $P135."CURSOR"()
    find_dynamic_lex $P139, "$*SCOPE"
    unless_null $P139, vivify_2288
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SCOPE"]
    unless_null $P139, vivify_2289
    die "Contextual $*SCOPE not found"
  vivify_2289:
  vivify_2288:
    concat $P140, $P139, " scoped packages are not supported"
    $P136."panic"($P140)
.annotate 'line', 1737
    goto if_2953_end
  if_2953:
.annotate 'line', 1732
    find_lex $P2955, "$/"
    unless_null $P2955, vivify_2290
    $P2955 = root_new ['parrot';'Hash']
  vivify_2290:
    set $P2956, $P2955["name"]
    unless_null $P2956, vivify_2291
    $P2956 = root_new ['parrot';'Hash']
  vivify_2291:
    set $P135, $P2956["identifier"]
    unless_null $P135, vivify_2292
    new $P135, "Undef"
  vivify_2292:
    set $N100, $P135
    set $N101, 1
    isne $I103, $N100, $N101
    unless $I103, if_2954_end
.annotate 'line', 1733
    find_lex $P2957, "$/"
    unless_null $P2957, vivify_2293
    $P2957 = root_new ['parrot';'Hash']
  vivify_2293:
    set $P136, $P2957["name"]
    unless_null $P136, vivify_2294
    new $P136, "Undef"
  vivify_2294:
    $P137 = $P136."CURSOR"()
    $P137."panic"("A my scoped package cannot have a multi-part name yet")
  if_2954_end:
.annotate 'line', 1735
    find_dynamic_lex $P137, "$*SC"
    unless_null $P137, vivify_2295
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SC"]
    unless_null $P137, vivify_2296
    die "Contextual $*SC not found"
  vivify_2296:
  vivify_2295:
    new $P138, "Float"
    assign $P138, 0
    set $I103, $P138
    find_lex $P139, "$?PACKAGE"
    get_who $P140, $P139
    set $P2958, $P140["@BLOCK"]
    unless_null $P2958, vivify_2297
    $P2958 = root_new ['parrot';'ResizablePMCArray']
  vivify_2297:
    set $P141, $P2958[$I103]
    unless_null $P141, vivify_2298
    new $P141, "Undef"
  vivify_2298:
    new $P142, "Float"
    assign $P142, 0
    set $I104, $P142
    find_lex $P2959, "$/"
    unless_null $P2959, vivify_2299
    $P2959 = root_new ['parrot';'Hash']
  vivify_2299:
    set $P2960, $P2959["name"]
    unless_null $P2960, vivify_2300
    $P2960 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P2961, $P2960["identifier"]
    unless_null $P2961, vivify_2301
    $P2961 = root_new ['parrot';'ResizablePMCArray']
  vivify_2301:
    set $P143, $P2961[$I104]
    unless_null $P143, vivify_2302
    new $P143, "Undef"
  vivify_2302:
    find_lex $P144, "$PACKAGE"
    unless_null $P144, vivify_2303
    new $P144, "Undef"
  vivify_2303:
    $P137."install_lexical_symbol"($P141, $P143, $P144)
  if_2953_end:
.annotate 'line', 1731
    goto if_2942_end
  if_2942:
.annotate 'line', 1726
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2304
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2305
    die "Contextual $*SC not found"
  vivify_2305:
  vivify_2304:
    find_dynamic_lex $P137, "$*OUTERPACKAGE"
    unless_null $P137, vivify_2306
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$OUTERPACKAGE"]
    unless_null $P137, vivify_2307
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2307:
  vivify_2306:
    find_lex $P2944, "$/"
    unless_null $P2944, vivify_2308
    $P2944 = root_new ['parrot';'Hash']
  vivify_2308:
    set $P2945, $P2944["name"]
    unless_null $P2945, vivify_2309
    $P2945 = root_new ['parrot';'Hash']
  vivify_2309:
    set $P138, $P2945["identifier"]
    unless_null $P138, vivify_2310
    new $P138, "Undef"
  vivify_2310:
    find_lex $P139, "$PACKAGE"
    unless_null $P139, vivify_2311
    new $P139, "Undef"
  vivify_2311:
    $P134."install_package_symbol"($P137, $P138, $P139)
.annotate 'line', 1727
    find_lex $P2947, "$/"
    unless_null $P2947, vivify_2312
    $P2947 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P2948, $P2947["name"]
    unless_null $P2948, vivify_2313
    $P2948 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P132, $P2948["identifier"]
    unless_null $P132, vivify_2314
    new $P132, "Undef"
  vivify_2314:
    set $N100, $P132
    set $N101, 1
    iseq $I102, $N100, $N101
    unless $I102, if_2946_end
.annotate 'line', 1728
    find_dynamic_lex $P135, "$*SC"
    unless_null $P135, vivify_2315
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SC"]
    unless_null $P135, vivify_2316
    die "Contextual $*SC not found"
  vivify_2316:
  vivify_2315:
    new $P136, "Float"
    assign $P136, 0
    set $I103, $P136
    find_lex $P137, "$?PACKAGE"
    get_who $P138, $P137
    set $P2949, $P138["@BLOCK"]
    unless_null $P2949, vivify_2317
    $P2949 = root_new ['parrot';'ResizablePMCArray']
  vivify_2317:
    set $P139, $P2949[$I103]
    unless_null $P139, vivify_2318
    new $P139, "Undef"
  vivify_2318:
    new $P140, "Float"
    assign $P140, 0
    set $I104, $P140
    find_lex $P2950, "$/"
    unless_null $P2950, vivify_2319
    $P2950 = root_new ['parrot';'Hash']
  vivify_2319:
    set $P2951, $P2950["name"]
    unless_null $P2951, vivify_2320
    $P2951 = root_new ['parrot';'Hash']
  vivify_2320:
    set $P2952, $P2951["identifier"]
    unless_null $P2952, vivify_2321
    $P2952 = root_new ['parrot';'ResizablePMCArray']
  vivify_2321:
    set $P141, $P2952[$I104]
    unless_null $P141, vivify_2322
    new $P141, "Undef"
  vivify_2322:
    find_lex $P142, "$PACKAGE"
    unless_null $P142, vivify_2323
    new $P142, "Undef"
  vivify_2323:
    $P135."install_lexical_symbol"($P139, $P141, $P142)
  if_2946_end:
  if_2942_end:
.annotate 'line', 1741
    find_lex $P124, "$/"
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
    $P130 = $P129."new"()
    $P131 = $P124."!make"($P130)
.annotate 'line', 1718
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("525_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_2963
    .param pmc param_2964
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1744
    .const 'Sub' $P3013 = "529_1312646121.678" 
    capture_lex $P3013
    .const 'Sub' $P3006 = "528_1312646121.678" 
    capture_lex $P3006
    .const 'Sub' $P2986 = "526_1312646121.678" 
    capture_lex $P2986
    .lex "self", param_2963
    .lex "$/", param_2964
.annotate 'line', 1746
    $P2966 = root_new ['parrot';'ResizablePMCArray']
    set $P2965, $P2966
    .lex "@ns", $P2965
.annotate 'line', 1747
    new $P122, "Undef"
    set $P2967, $P122
    .lex "$name", $P2967
.annotate 'line', 1748
    new $P123, "Undef"
    set $P2968, $P123
    .lex "$how", $P2968
.annotate 'line', 1751
    new $P124, "Undef"
    set $P2969, $P124
    .lex "$past", $P2969
.annotate 'line', 1746
    find_lex $P2970, "$/"
    unless_null $P2970, vivify_2324
    $P2970 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P2971, $P2970["name"]
    unless_null $P2971, vivify_2325
    $P2971 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P125, $P2971["identifier"]
    unless_null $P125, vivify_2326
    new $P125, "Undef"
  vivify_2326:
    clone $P127, $P125
    store_lex "@ns", $P127
.annotate 'line', 1747
    find_lex $P2972, "@ns"
    unless_null $P2972, vivify_2327
    $P2972 = root_new ['parrot';'ResizablePMCArray']
  vivify_2327:
    $P125 = $P2972."pop"()
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    store_lex "$name", $P127
.annotate 'line', 1748
    find_dynamic_lex $P128, "$*PKGDECL"
    unless_null $P128, vivify_2328
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$PKGDECL"]
    unless_null $P128, vivify_2329
    die "Contextual $*PKGDECL not found"
  vivify_2329:
  vivify_2328:
    find_dynamic_lex $P131, "%*HOW"
    unless_null $P131, vivify_2330
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%HOW"]
    unless_null $P131, vivify_2331
    die "Contextual %*HOW not found"
  vivify_2331:
  vivify_2330:
    set $P132, $P131[$P128]
    unless_null $P132, vivify_2332
    new $P132, "Undef"
  vivify_2332:
    store_lex "$how", $P132
.annotate 'line', 1751
    find_lex $P2974, "$/"
    unless_null $P2974, vivify_2333
    $P2974 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P127, $P2974["block"]
    unless_null $P127, vivify_2334
    new $P127, "Undef"
  vivify_2334:
    if $P127, if_2973
    find_lex $P2976, "$/"
    unless_null $P2976, vivify_2335
    $P2976 = root_new ['parrot';'Hash']
  vivify_2335:
    set $P130, $P2976["comp_unit"]
    unless_null $P130, vivify_2336
    new $P130, "Undef"
  vivify_2336:
    $P131 = $P130."ast"()
    set $P125, $P131
    goto if_2973_end
  if_2973:
    find_lex $P2975, "$/"
    unless_null $P2975, vivify_2337
    $P2975 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P128, $P2975["block"]
    unless_null $P128, vivify_2338
    new $P128, "Undef"
  vivify_2338:
    $P129 = $P128."ast"()
    set $P125, $P129
  if_2973_end:
    store_lex "$past", $P125
.annotate 'line', 1752
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2339
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2340
    die "Contextual $*SCOPE not found"
  vivify_2340:
  vivify_2339:
    set $S100, $P129
    iseq $I100, $S100, "our"
    unless $I100, unless_2978
    new $P125, 'Integer'
    set $P125, $I100
    goto unless_2978_end
  unless_2978:
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2341
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2342
    die "Contextual $*SCOPE not found"
  vivify_2342:
  vivify_2341:
    set $S101, $P132
    iseq $I101, $S101, ""
    new $P125, 'Integer'
    set $P125, $I101
  unless_2978_end:
    unless $P125, if_2977_end
.annotate 'line', 1753
    find_lex $P133, "$past"
    unless_null $P133, vivify_2343
    new $P133, "Undef"
  vivify_2343:
    find_lex $P2979, "$/"
    unless_null $P2979, vivify_2344
    $P2979 = root_new ['parrot';'Hash']
  vivify_2344:
    set $P2980, $P2979["name"]
    unless_null $P2980, vivify_2345
    $P2980 = root_new ['parrot';'Hash']
  vivify_2345:
    set $P134, $P2980["identifier"]
    unless_null $P134, vivify_2346
    new $P134, "Undef"
  vivify_2346:
    $P133."namespace"($P134)
  if_2977_end:
.annotate 'line', 1760
    find_lex $P127, "$how"
    unless_null $P127, vivify_2347
    new $P127, "Undef"
  vivify_2347:
    can $I100, $P127, "parametric"
    if $I100, if_2982
    new $P125, 'Integer'
    set $P125, $I100
    goto if_2982_end
  if_2982:
    find_lex $P128, "$how"
    unless_null $P128, vivify_2348
    new $P128, "Undef"
  vivify_2348:
    find_lex $P129, "$how"
    unless_null $P129, vivify_2349
    new $P129, "Undef"
  vivify_2349:
    $P130 = $P128."parametric"($P129)
    set $P125, $P130
  if_2982_end:
    if $P125, if_2981
.annotate 'line', 1769
    find_lex $P131, "$past"
    unless_null $P131, vivify_2350
    new $P131, "Undef"
  vivify_2350:
    $P131."blocktype"("immediate")
.annotate 'line', 1770
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2351
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2352
    die "Contextual $*SC not found"
  vivify_2352:
  vivify_2351:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2353
    new $P134, "Undef"
  vivify_2353:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2354
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2355
    die "Contextual $*PACKAGE not found"
  vivify_2355:
  vivify_2354:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1771
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2356
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2357
    die "Contextual $*SC not found"
  vivify_2357:
  vivify_2356:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2358
    new $P134, "Undef"
  vivify_2358:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2359
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2360
    die "Contextual $*PACKAGE not found"
  vivify_2360:
  vivify_2359:
    $P133."install_lexical_symbol"($P134, "$?CLASS", $P137)
.annotate 'line', 1768
    goto if_2981_end
  if_2981:
.annotate 'line', 1761
    find_lex $P131, "$past"
    unless_null $P131, vivify_2361
    new $P131, "Undef"
  vivify_2361:
    $P131."blocktype"("declaration")
.annotate 'line', 1762
    find_lex $P131, "$past"
    unless_null $P131, vivify_2362
    new $P131, "Undef"
  vivify_2362:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    $P136 = $P135."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P131."unshift"($P136)
.annotate 'line', 1763
    find_lex $P131, "$past"
    unless_null $P131, vivify_2363
    new $P131, "Undef"
  vivify_2363:
    $P131."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1764
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2364
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2365
    die "Contextual $*SC not found"
  vivify_2365:
  vivify_2364:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2366
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2367
    die "Contextual $*PACKAGE not found"
  vivify_2367:
  vivify_2366:
    find_lex $P137, "$past"
    unless_null $P137, vivify_2368
    new $P137, "Undef"
  vivify_2368:
    $P133."pkg_set_body_block"($P136, $P137)
.annotate 'line', 1765
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2369
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2370
    die "Contextual $*SC not found"
  vivify_2370:
  vivify_2369:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2371
    new $P134, "Undef"
  vivify_2371:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2372
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2373
    die "Contextual $*PACKAGE not found"
  vivify_2373:
  vivify_2372:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1766
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2374
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2375
    die "Contextual $*SC not found"
  vivify_2375:
  vivify_2374:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2376
    new $P134, "Undef"
  vivify_2376:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2377
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2378
    die "Contextual $*PACKAGE not found"
  vivify_2378:
  vivify_2377:
    $P133."install_lexical_symbol"($P134, "$?ROLE", $P137)
  if_2981_end:
.annotate 'line', 1775
    find_lex $P2984, "$/"
    unless_null $P2984, vivify_2379
    $P2984 = root_new ['parrot';'Hash']
  vivify_2379:
    set $P125, $P2984["parent"]
    unless_null $P125, vivify_2380
    new $P125, "Undef"
  vivify_2380:
    if $P125, if_2983
.annotate 'line', 1789
    find_lex $P130, "$how"
    unless_null $P130, vivify_2381
    new $P130, "Undef"
  vivify_2381:
    can $I100, $P130, "set_default_parent"
    unless $I100, if_3004_end
    .const 'Sub' $P3006 = "528_1312646121.678" 
    capture_lex $P3006
    $P3006()
  if_3004_end:
    goto if_2983_end
  if_2983:
.annotate 'line', 1775
    .const 'Sub' $P2986 = "526_1312646121.678" 
    capture_lex $P2986
    $P2986()
  if_2983_end:
.annotate 'line', 1796
    find_lex $P3010, "$/"
    unless_null $P3010, vivify_2407
    $P3010 = root_new ['parrot';'Hash']
  vivify_2407:
    set $P125, $P3010["role"]
    unless_null $P125, vivify_2408
    new $P125, "Undef"
  vivify_2408:
    unless $P125, if_3009_end
.annotate 'line', 1797
    find_lex $P3011, "$/"
    unless_null $P3011, vivify_2409
    $P3011 = root_new ['parrot';'Hash']
  vivify_2409:
    set $P128, $P3011["role"]
    unless_null $P128, vivify_2410
    new $P128, "Undef"
  vivify_2410:
    defined $I100, $P128
    unless $I100, for_undef_2411
    iter $P127, $P128
    new $P133, 'ExceptionHandler'
    set_label $P133, loop3028_handler
    $P133."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P133
  loop3028_test:
    unless $P127, loop3028_done
    shift $P129, $P127
  loop3028_redo:
    .const 'Sub' $P3013 = "529_1312646121.678" 
    capture_lex $P3013
    $P3013($P129)
  loop3028_next:
    goto loop3028_test
  loop3028_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P134, exception, 'type'
    eq $P134, .CONTROL_LOOP_NEXT, loop3028_next
    eq $P134, .CONTROL_LOOP_REDO, loop3028_redo
  loop3028_done:
    pop_eh 
  for_undef_2411:
  if_3009_end:
.annotate 'line', 1814
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_2425
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_2426
    die "Contextual $*SC not found"
  vivify_2426:
  vivify_2425:
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2427
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2428
    die "Contextual $*PACKAGE not found"
  vivify_2428:
  vivify_2427:
    $P128."pkg_compose"($P131)
.annotate 'line', 1816
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_2429
    new $P127, "Undef"
  vivify_2429:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1744
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3005"  :anon :subid("528_1312646121.678") :outer("525_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1790
    new $P131, "Undef"
    set $P3007, $P131
    .lex "$default", $P3007
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2382
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2383
    die "Contextual $*PKGDECL not found"
  vivify_2383:
  vivify_2382:
    set $S100, $P135
    iseq $I101, $S100, "grammar"
    if $I101, if_3008
    new $P137, "ResizablePMCArray"
    push $P137, "NQPMu"
    set $P132, $P137
    goto if_3008_end
  if_3008:
    new $P136, "ResizablePMCArray"
    push $P136, "Regex"
    push $P136, "Cursor"
    set $P132, $P136
  if_3008_end:
    store_lex "$default", $P132
.annotate 'line', 1791
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2384
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2385
    die "Contextual $*SC not found"
  vivify_2385:
  vivify_2384:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2386
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2387
    die "Contextual $*PACKAGE not found"
  vivify_2387:
  vivify_2386:
.annotate 'line', 1792
    find_lex $P138, "$default"
    unless_null $P138, vivify_2388
    new $P138, "Undef"
  vivify_2388:
    find_lex $P139, "$/"
    unless_null $P139, vivify_2389
    new $P139, "Undef"
  vivify_2389:
    $P140 = "find_sym"($P138, $P139)
    $P141 = $P134."pkg_add_parent_or_role"($P137, "set_default_parent", $P140)
.annotate 'line', 1789
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2985"  :anon :subid("526_1312646121.678") :outer("525_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1775
    .const 'Sub' $P2990 = "527_1312646121.678" 
    capture_lex $P2990
.annotate 'line', 1776
    new $P127, "Undef"
    set $P2987, $P127
    .lex "$parent", $P2987
.annotate 'line', 1777
    new $P128, "Undef"
    set $P2988, $P128
    .lex "$parent_found", $P2988
.annotate 'line', 1775
    find_lex $P129, "$parent"
    unless_null $P129, vivify_2390
    new $P129, "Undef"
  vivify_2390:
    find_lex $P129, "$parent_found"
    unless_null $P129, vivify_2391
    new $P129, "Undef"
  vivify_2391:
.annotate 'line', 1778
    .const 'Sub' $P2990 = "527_1312646121.678" 
    capture_lex $P2990
    $P2990()
.annotate 'line', 1782
    find_lex $P130, "$parent_found"
    unless_null $P130, vivify_2397
    new $P130, "Undef"
  vivify_2397:
    if $P130, if_3001
.annotate 'line', 1786
    find_lex $P131, "$/"
    unless_null $P131, vivify_2398
    new $P131, "Undef"
  vivify_2398:
    $P132 = $P131."CURSOR"()
    new $P133, "String"
    assign $P133, "Could not find parent class '"
    new $P134, "Float"
    assign $P134, 0
    set $I100, $P134
    find_lex $P3002, "$/"
    unless_null $P3002, vivify_2399
    $P3002 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P3003, $P3002["parent"]
    unless_null $P3003, vivify_2400
    $P3003 = root_new ['parrot';'ResizablePMCArray']
  vivify_2400:
    set $P135, $P3003[$I100]
    unless_null $P135, vivify_2401
    new $P135, "Undef"
  vivify_2401:
    set $S100, $P135
    concat $P136, $P133, $S100
    concat $P137, $P136, "'"
    $P139 = $P132."panic"($P137)
.annotate 'line', 1785
    set $P129, $P139
.annotate 'line', 1782
    goto if_3001_end
  if_3001:
.annotate 'line', 1783
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2402
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2403
    die "Contextual $*SC not found"
  vivify_2403:
  vivify_2402:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2404
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2405
    die "Contextual $*PACKAGE not found"
  vivify_2405:
  vivify_2404:
    find_lex $P137, "$parent"
    unless_null $P137, vivify_2406
    new $P137, "Undef"
  vivify_2406:
    $P138 = $P133."pkg_add_parent_or_role"($P136, "add_parent", $P137)
.annotate 'line', 1782
    set $P129, $P138
  if_3001_end:
.annotate 'line', 1775
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2989"  :anon :subid("527_1312646121.678") :outer("526_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1778
    new $P2996, 'ExceptionHandler'
    set_label $P2996, control_2995
    $P2996."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P2996
.annotate 'line', 1779
    new $P129, "Float"
    assign $P129, 0
    set $I100, $P129
    find_lex $P2991, "$/"
    unless_null $P2991, vivify_2392
    $P2991 = root_new ['parrot';'Hash']
  vivify_2392:
    set $P2992, $P2991["parent"]
    unless_null $P2992, vivify_2393
    $P2992 = root_new ['parrot';'ResizablePMCArray']
  vivify_2393:
    set $P2993, $P2992[$I100]
    unless_null $P2993, vivify_2394
    $P2993 = root_new ['parrot';'Hash']
  vivify_2394:
    set $P130, $P2993["identifier"]
    unless_null $P130, vivify_2395
    new $P130, "Undef"
  vivify_2395:
    clone $P131, $P130
    find_lex $P132, "$/"
    unless_null $P132, vivify_2396
    new $P132, "Undef"
  vivify_2396:
    $P133 = "find_sym"($P131, $P132)
    store_lex "$parent", $P133
.annotate 'line', 1780
    new $P129, "Float"
    assign $P129, 1
    store_lex "$parent_found", $P129
.annotate 'line', 1778
    pop_eh 
    goto skip_handler_2994
  control_2995:
    .local pmc exception 
    .get_results (exception) 
    new $P2999, 'Integer'
    set $P2999, 1
    set exception["handled"], $P2999
    set $I3000, exception["handled"]
    ne $I3000, 1, nothandled_2998
  handled_2997:
    .return (exception)
  nothandled_2998:
    rethrow exception
  skip_handler_2994:
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3012"  :anon :subid("529_1312646121.678") :outer("525_1312646121.678")
    .param pmc param_3016
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1797
    .const 'Sub' $P3018 = "530_1312646121.678" 
    capture_lex $P3018
.annotate 'line', 1798
    new $P130, "Undef"
    set $P3014, $P130
    .lex "$role", $P3014
.annotate 'line', 1799
    new $P131, "Undef"
    set $P3015, $P131
    .lex "$role_found", $P3015
    .lex "$_", param_3016
.annotate 'line', 1797
    find_lex $P132, "$role"
    unless_null $P132, vivify_2412
    new $P132, "Undef"
  vivify_2412:
    find_lex $P132, "$role_found"
    unless_null $P132, vivify_2413
    new $P132, "Undef"
  vivify_2413:
.annotate 'line', 1800
    .const 'Sub' $P3018 = "530_1312646121.678" 
    capture_lex $P3018
    $P3018()
.annotate 'line', 1804
    find_lex $P133, "$role_found"
    unless_null $P133, vivify_2417
    new $P133, "Undef"
  vivify_2417:
    if $P133, if_3027
.annotate 'line', 1808
    find_lex $P134, "$/"
    unless_null $P134, vivify_2418
    new $P134, "Undef"
  vivify_2418:
    $P135 = $P134."CURSOR"()
    new $P136, "String"
    assign $P136, "Could not find role '"
    find_lex $P137, "$_"
    unless_null $P137, vivify_2419
    new $P137, "Undef"
  vivify_2419:
    set $S100, $P137
    concat $P138, $P136, $S100
    concat $P139, $P138, "'"
    $P140 = $P135."panic"($P139)
.annotate 'line', 1807
    set $P132, $P140
.annotate 'line', 1804
    goto if_3027_end
  if_3027:
.annotate 'line', 1805
    find_dynamic_lex $P136, "$*SC"
    unless_null $P136, vivify_2420
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$SC"]
    unless_null $P136, vivify_2421
    die "Contextual $*SC not found"
  vivify_2421:
  vivify_2420:
    find_dynamic_lex $P139, "$*PACKAGE"
    unless_null $P139, vivify_2422
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$PACKAGE"]
    unless_null $P139, vivify_2423
    die "Contextual $*PACKAGE not found"
  vivify_2423:
  vivify_2422:
    find_lex $P140, "$role"
    unless_null $P140, vivify_2424
    new $P140, "Undef"
  vivify_2424:
    $P141 = $P136."pkg_add_parent_or_role"($P139, "add_role", $P140)
.annotate 'line', 1804
    set $P132, $P141
  if_3027_end:
.annotate 'line', 1797
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3017"  :anon :subid("530_1312646121.678") :outer("529_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1800
    new $P3022, 'ExceptionHandler'
    set_label $P3022, control_3021
    $P3022."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3022
.annotate 'line', 1801
    find_lex $P3019, "$_"
    unless_null $P3019, vivify_2414
    $P3019 = root_new ['parrot';'Hash']
  vivify_2414:
    set $P132, $P3019["identifier"]
    unless_null $P132, vivify_2415
    new $P132, "Undef"
  vivify_2415:
    clone $P133, $P132
    find_lex $P134, "$/"
    unless_null $P134, vivify_2416
    new $P134, "Undef"
  vivify_2416:
    $P135 = "find_sym"($P133, $P134)
    store_lex "$role", $P135
.annotate 'line', 1802
    new $P132, "Float"
    assign $P132, 1
    store_lex "$role_found", $P132
.annotate 'line', 1800
    pop_eh 
    goto skip_handler_3020
  control_3021:
    .local pmc exception 
    .get_results (exception) 
    new $P3025, 'Integer'
    set $P3025, 1
    set exception["handled"], $P3025
    set $I3026, exception["handled"]
    ne $I3026, 1, nothandled_3024
  handled_3023:
    .return (exception)
  nothandled_3024:
    rethrow exception
  skip_handler_3020:
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("531_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3030
    .param pmc param_3031
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1819
    .lex "self", param_3030
    .lex "$/", param_3031
    find_lex $P122, "$/"
    find_lex $P3032, "$/"
    unless_null $P3032, vivify_2430
    $P3032 = root_new ['parrot';'Hash']
  vivify_2430:
    set $P123, $P3032["scoped"]
    unless_null $P123, vivify_2431
    new $P123, "Undef"
  vivify_2431:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("532_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3034
    .param pmc param_3035
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1820
    .lex "self", param_3034
    .lex "$/", param_3035
    find_lex $P122, "$/"
    find_lex $P3036, "$/"
    unless_null $P3036, vivify_2432
    $P3036 = root_new ['parrot';'Hash']
  vivify_2432:
    set $P123, $P3036["scoped"]
    unless_null $P123, vivify_2433
    new $P123, "Undef"
  vivify_2433:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("533_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3038
    .param pmc param_3039
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1821
    .lex "self", param_3038
    .lex "$/", param_3039
    find_lex $P122, "$/"
    find_lex $P3040, "$/"
    unless_null $P3040, vivify_2434
    $P3040 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P123, $P3040["scoped"]
    unless_null $P123, vivify_2435
    new $P123, "Undef"
  vivify_2435:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("534_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3042
    .param pmc param_3043
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1823
    .lex "self", param_3042
    .lex "$/", param_3043
.annotate 'line', 1824
    find_lex $P122, "$/"
    find_lex $P3045, "$/"
    unless_null $P3045, vivify_2436
    $P3045 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P124, $P3045["declarator"]
    unless_null $P124, vivify_2437
    new $P124, "Undef"
  vivify_2437:
    if $P124, if_3044
.annotate 'line', 1825
    find_lex $P3048, "$/"
    unless_null $P3048, vivify_2438
    $P3048 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P129, $P3048["multi_declarator"]
    unless_null $P129, vivify_2439
    new $P129, "Undef"
  vivify_2439:
    if $P129, if_3047
.annotate 'line', 1826
    find_lex $P3050, "$/"
    unless_null $P3050, vivify_2440
    $P3050 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P132, $P3050["package_declarator"]
    unless_null $P132, vivify_2441
    new $P132, "Undef"
  vivify_2441:
    $P133 = $P132."ast"()
    set $P128, $P133
.annotate 'line', 1825
    goto if_3047_end
  if_3047:
    find_lex $P3049, "$/"
    unless_null $P3049, vivify_2442
    $P3049 = root_new ['parrot';'Hash']
  vivify_2442:
    set $P130, $P3049["multi_declarator"]
    unless_null $P130, vivify_2443
    new $P130, "Undef"
  vivify_2443:
    $P131 = $P130."ast"()
    set $P128, $P131
  if_3047_end:
    set $P123, $P128
.annotate 'line', 1824
    goto if_3044_end
  if_3044:
    find_lex $P3046, "$/"
    unless_null $P3046, vivify_2444
    $P3046 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P125, $P3046["declarator"]
    unless_null $P125, vivify_2445
    new $P125, "Undef"
  vivify_2445:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3044_end:
    $P134 = $P122."!make"($P123)
.annotate 'line', 1823
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("535_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3052
    .param pmc param_3053
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1829
    .lex "self", param_3052
    .lex "$/", param_3053
.annotate 'line', 1830
    find_lex $P122, "$/"
.annotate 'line', 1831
    find_lex $P3055, "$/"
    unless_null $P3055, vivify_2446
    $P3055 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P124, $P3055["routine_declarator"]
    unless_null $P124, vivify_2447
    new $P124, "Undef"
  vivify_2447:
    if $P124, if_3054
.annotate 'line', 1832
    find_lex $P3057, "$/"
    unless_null $P3057, vivify_2448
    $P3057 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P128, $P3057["variable_declarator"]
    unless_null $P128, vivify_2449
    new $P128, "Undef"
  vivify_2449:
    $P129 = $P128."ast"()
    set $P123, $P129
.annotate 'line', 1831
    goto if_3054_end
  if_3054:
    find_lex $P3056, "$/"
    unless_null $P3056, vivify_2450
    $P3056 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P125, $P3056["routine_declarator"]
    unless_null $P125, vivify_2451
    new $P125, "Undef"
  vivify_2451:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3054_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 1829
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("536_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3059
    .param pmc param_3060
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1835
    .lex "self", param_3059
    .lex "$/", param_3060
    find_lex $P122, "$/"
    find_lex $P3062, "$/"
    unless_null $P3062, vivify_2452
    $P3062 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P124, $P3062["declarator"]
    unless_null $P124, vivify_2453
    new $P124, "Undef"
  vivify_2453:
    if $P124, if_3061
    find_lex $P3064, "$/"
    unless_null $P3064, vivify_2454
    $P3064 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P128, $P3064["routine_def"]
    unless_null $P128, vivify_2455
    new $P128, "Undef"
  vivify_2455:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3061_end
  if_3061:
    find_lex $P3063, "$/"
    unless_null $P3063, vivify_2456
    $P3063 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P125, $P3063["declarator"]
    unless_null $P125, vivify_2457
    new $P125, "Undef"
  vivify_2457:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3061_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("537_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3066
    .param pmc param_3067
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1836
    .lex "self", param_3066
    .lex "$/", param_3067
    find_lex $P122, "$/"
    find_lex $P3069, "$/"
    unless_null $P3069, vivify_2458
    $P3069 = root_new ['parrot';'Hash']
  vivify_2458:
    set $P124, $P3069["declarator"]
    unless_null $P124, vivify_2459
    new $P124, "Undef"
  vivify_2459:
    if $P124, if_3068
    find_lex $P3071, "$/"
    unless_null $P3071, vivify_2460
    $P3071 = root_new ['parrot';'Hash']
  vivify_2460:
    set $P128, $P3071["routine_def"]
    unless_null $P128, vivify_2461
    new $P128, "Undef"
  vivify_2461:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3068_end
  if_3068:
    find_lex $P3070, "$/"
    unless_null $P3070, vivify_2462
    $P3070 = root_new ['parrot';'Hash']
  vivify_2462:
    set $P125, $P3070["declarator"]
    unless_null $P125, vivify_2463
    new $P125, "Undef"
  vivify_2463:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3068_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("538_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3073
    .param pmc param_3074
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1837
    .lex "self", param_3073
    .lex "$/", param_3074
    find_lex $P122, "$/"
    find_lex $P3075, "$/"
    unless_null $P3075, vivify_2464
    $P3075 = root_new ['parrot';'Hash']
  vivify_2464:
    set $P123, $P3075["declarator"]
    unless_null $P123, vivify_2465
    new $P123, "Undef"
  vivify_2465:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("539_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3077
    .param pmc param_3078
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1840
    .const 'Sub' $P3114 = "541_1312646121.678" 
    capture_lex $P3114
    .const 'Sub' $P3091 = "540_1312646121.678" 
    capture_lex $P3091
    .lex "self", param_3077
    .lex "$/", param_3078
.annotate 'line', 1841
    new $P122, "Undef"
    set $P3079, $P122
    .lex "$past", $P3079
.annotate 'line', 1842
    new $P123, "Undef"
    set $P3080, $P123
    .lex "$sigil", $P3080
.annotate 'line', 1843
    new $P124, "Undef"
    set $P3081, $P124
    .lex "$name", $P3081
.annotate 'line', 1844
    new $P125, "Undef"
    set $P3082, $P125
    .lex "$BLOCK", $P3082
.annotate 'line', 1841
    find_lex $P3083, "$/"
    unless_null $P3083, vivify_2466
    $P3083 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P127, $P3083["variable"]
    unless_null $P127, vivify_2467
    new $P127, "Undef"
  vivify_2467:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 1842
    find_lex $P3084, "$/"
    unless_null $P3084, vivify_2468
    $P3084 = root_new ['parrot';'Hash']
  vivify_2468:
    set $P3085, $P3084["variable"]
    unless_null $P3085, vivify_2469
    $P3085 = root_new ['parrot';'Hash']
  vivify_2469:
    set $P127, $P3085["sigil"]
    unless_null $P127, vivify_2470
    new $P127, "Undef"
  vivify_2470:
    store_lex "$sigil", $P127
.annotate 'line', 1843
    find_lex $P127, "$past"
    unless_null $P127, vivify_2471
    new $P127, "Undef"
  vivify_2471:
    $P128 = $P127."name"()
    store_lex "$name", $P128
.annotate 'line', 1844
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3086, $P129["@BLOCK"]
    unless_null $P3086, vivify_2472
    $P3086 = root_new ['parrot';'ResizablePMCArray']
  vivify_2472:
    set $P130, $P3086[$I100]
    unless_null $P130, vivify_2473
    new $P130, "Undef"
  vivify_2473:
    store_lex "$BLOCK", $P130
.annotate 'line', 1845
    find_lex $P128, "$name"
    unless_null $P128, vivify_2474
    new $P128, "Undef"
  vivify_2474:
    if $P128, if_3088
    set $P127, $P128
    goto if_3088_end
  if_3088:
    find_lex $P129, "$BLOCK"
    unless_null $P129, vivify_2475
    new $P129, "Undef"
  vivify_2475:
    find_lex $P130, "$name"
    unless_null $P130, vivify_2476
    new $P130, "Undef"
  vivify_2476:
    $P131 = $P129."symbol"($P130)
    set $P127, $P131
  if_3088_end:
    unless $P127, if_3087_end
.annotate 'line', 1846
    find_lex $P132, "$/"
    unless_null $P132, vivify_2477
    new $P132, "Undef"
  vivify_2477:
    $P133 = $P132."CURSOR"()
    find_lex $P134, "$name"
    unless_null $P134, vivify_2478
    new $P134, "Undef"
  vivify_2478:
    $P133."panic"("Redeclaration of symbol ", $P134)
  if_3087_end:
.annotate 'line', 1848
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2479
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2480
    die "Contextual $*SCOPE not found"
  vivify_2480:
  vivify_2479:
    set $S100, $P129
    iseq $I100, $S100, "has"
    if $I100, if_3089
.annotate 'line', 1868
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2481
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2482
    die "Contextual $*SCOPE not found"
  vivify_2482:
  vivify_2481:
    set $S101, $P132
    iseq $I101, $S101, "our"
    if $I101, if_3107
.annotate 'line', 1878
    new $P133, "Float"
    assign $P133, 0
    set $I102, $P133
    find_lex $P3109, "$BLOCK"
    unless_null $P3109, vivify_2483
    $P3109 = root_new ['parrot';'ResizablePMCArray']
  vivify_2483:
    set $P135, $P3109[$I102]
    unless_null $P135, vivify_2484
    new $P135, "Undef"
  vivify_2484:
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    find_lex $P140, "$name"
    unless_null $P140, vivify_2485
    new $P140, "Undef"
  vivify_2485:
.annotate 'line', 1880
    find_lex $P141, "$sigil"
    unless_null $P141, vivify_2486
    new $P141, "Undef"
  vivify_2486:
    $P142 = "vivitype"($P141)
.annotate 'line', 1878
    find_lex $P143, "$/"
    unless_null $P143, vivify_2487
    new $P143, "Undef"
  vivify_2487:
    $P144 = $P139."new"($P140 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P142 :named("viviself"), $P143 :named("node"))
    $P135."push"($P144)
.annotate 'line', 1883
    find_lex $P133, "$BLOCK"
    unless_null $P133, vivify_2488
    new $P133, "Undef"
  vivify_2488:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2489
    new $P135, "Undef"
  vivify_2489:
    $P133."symbol"($P135, "lexical" :named("scope"))
.annotate 'line', 1877
    goto if_3107_end
  if_3107:
.annotate 'line', 1872
    find_lex $P3108, "$/"
    unless_null $P3108, vivify_2490
    $P3108 = root_new ['parrot';'Hash']
  vivify_2490:
    set $P133, $P3108["variable"]
    unless_null $P133, vivify_2491
    new $P133, "Undef"
  vivify_2491:
    set $S102, $P133
    new $P135, 'String'
    set $P135, $S102
    store_lex "$name", $P135
.annotate 'line', 1873
    find_lex $P133, "$name"
    unless_null $P133, vivify_2492
    new $P133, "Undef"
  vivify_2492:
    new $P135, "ResizablePMCArray"
    push $P135, $P133
    find_lex $P136, "$/"
    unless_null $P136, vivify_2493
    new $P136, "Undef"
  vivify_2493:
    $P137 = "lexical_package_lookup"($P135, $P136)
    store_lex "$past", $P137
.annotate 'line', 1874
    find_lex $P133, "$past"
    unless_null $P133, vivify_2494
    new $P133, "Undef"
  vivify_2494:
    find_lex $P135, "$sigil"
    unless_null $P135, vivify_2495
    new $P135, "Undef"
  vivify_2495:
    $P136 = "vivitype"($P135)
    $P133."viviself"($P136)
.annotate 'line', 1875
    find_lex $P133, "$BLOCK"
    unless_null $P133, vivify_2496
    new $P133, "Undef"
  vivify_2496:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2497
    new $P135, "Undef"
  vivify_2497:
    $P133."symbol"($P135, "package" :named("scope"))
  if_3107_end:
.annotate 'line', 1868
    goto if_3089_end
  if_3089:
.annotate 'line', 1848
    .const 'Sub' $P3091 = "540_1312646121.678" 
    capture_lex $P3091
    $P3091()
  if_3089_end:
.annotate 'line', 1887
    find_lex $P127, "$/"
    find_lex $P128, "$past"
    unless_null $P128, vivify_2527
    new $P128, "Undef"
  vivify_2527:
    $P127."!make"($P128)
.annotate 'line', 1889
    find_lex $P3111, "$/"
    unless_null $P3111, vivify_2528
    $P3111 = root_new ['parrot';'Hash']
  vivify_2528:
    set $P128, $P3111["trait"]
    unless_null $P128, vivify_2529
    new $P128, "Undef"
  vivify_2529:
    if $P128, if_3110
    set $P127, $P128
    goto if_3110_end
  if_3110:
.annotate 'line', 1890
    find_lex $P3112, "$/"
    unless_null $P3112, vivify_2530
    $P3112 = root_new ['parrot';'Hash']
  vivify_2530:
    set $P130, $P3112["trait"]
    unless_null $P130, vivify_2531
    new $P130, "Undef"
  vivify_2531:
    defined $I100, $P130
    unless $I100, for_undef_2532
    iter $P129, $P130
    new $P132, 'ExceptionHandler'
    set_label $P132, loop3116_handler
    $P132."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P132
  loop3116_test:
    unless $P129, loop3116_done
    shift $P131, $P129
  loop3116_redo:
    .const 'Sub' $P3114 = "541_1312646121.678" 
    capture_lex $P3114
    $P3114($P131)
  loop3116_next:
    goto loop3116_test
  loop3116_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P133, exception, 'type'
    eq $P133, .CONTROL_LOOP_NEXT, loop3116_next
    eq $P133, .CONTROL_LOOP_REDO, loop3116_redo
  loop3116_done:
    pop_eh 
  for_undef_2532:
.annotate 'line', 1889
    set $P127, $P129
  if_3110_end:
.annotate 'line', 1840
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3090"  :anon :subid("540_1312646121.678") :outer("539_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1855
    $P3093 = root_new ['parrot';'Hash']
    set $P3092, $P3093
    .lex "%lit_args", $P3092
.annotate 'line', 1856
    $P3095 = root_new ['parrot';'Hash']
    set $P3094, $P3095
    .lex "%obj_args", $P3094
.annotate 'line', 1850
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2498
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2499
    die "Contextual $*PKGDECL not found"
  vivify_2499:
  vivify_2498:
    concat $P136, $P135, "-attr"
    find_dynamic_lex $P132, "%*HOW"
    unless_null $P132, vivify_2500
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["%HOW"]
    unless_null $P132, vivify_2501
    die "Contextual %*HOW not found"
  vivify_2501:
  vivify_2500:
    exists $I101, $P132[$P136]
    if $I101, unless_3096_end
.annotate 'line', 1851
    find_lex $P137, "$/"
    unless_null $P137, vivify_2502
    new $P137, "Undef"
  vivify_2502:
    $P138 = $P137."CURSOR"()
    find_dynamic_lex $P141, "$*PKGDECL"
    unless_null $P141, vivify_2503
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PKGDECL"]
    unless_null $P141, vivify_2504
    die "Contextual $*PKGDECL not found"
  vivify_2504:
  vivify_2503:
    concat $P142, $P141, " packages do not support attributes"
    $P138."panic"($P142)
  unless_3096_end:
.annotate 'line', 1848
    find_lex $P3097, "%lit_args"
    unless_null $P3097, vivify_2505
    $P3097 = root_new ['parrot';'Hash']
  vivify_2505:
    find_lex $P3098, "%obj_args"
    unless_null $P3098, vivify_2506
    $P3098 = root_new ['parrot';'Hash']
  vivify_2506:
.annotate 'line', 1857
    find_lex $P130, "$name"
    unless_null $P130, vivify_2507
    new $P130, "Undef"
  vivify_2507:
    find_lex $P3099, "%lit_args"
    unless_null $P3099, vivify_2508
    $P3099 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P3099
  vivify_2508:
    set $P3099["name"], $P130
.annotate 'line', 1858
    find_lex $P3101, "$/"
    unless_null $P3101, vivify_2509
    $P3101 = root_new ['parrot';'Hash']
  vivify_2509:
    set $P130, $P3101["typename"]
    unless_null $P130, vivify_2510
    new $P130, "Undef"
  vivify_2510:
    unless $P130, if_3100_end
.annotate 'line', 1859
    new $P131, "Float"
    assign $P131, 0
    set $I101, $P131
    find_lex $P3102, "$/"
    unless_null $P3102, vivify_2511
    $P3102 = root_new ['parrot';'Hash']
  vivify_2511:
    set $P3103, $P3102["typename"]
    unless_null $P3103, vivify_2512
    $P3103 = root_new ['parrot';'ResizablePMCArray']
  vivify_2512:
    set $P132, $P3103[$I101]
    unless_null $P132, vivify_2513
    new $P132, "Undef"
  vivify_2513:
    set $S101, $P132
    new $P133, "ResizablePMCArray"
    push $P133, $S101
    find_lex $P134, "$/"
    unless_null $P134, vivify_2514
    new $P134, "Undef"
  vivify_2514:
    $P135 = "find_sym"($P133, $P134)
    find_lex $P3104, "%obj_args"
    unless_null $P3104, vivify_2515
    $P3104 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P3104
  vivify_2515:
    set $P3104["type"], $P135
  if_3100_end:
.annotate 'line', 1863
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2516
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2517
    die "Contextual $*SC not found"
  vivify_2517:
  vivify_2516:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_2518
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_2519
    die "Contextual $*PACKAGE not found"
  vivify_2519:
  vivify_2518:
    find_dynamic_lex $P138, "$*PKGDECL"
    unless_null $P138, vivify_2520
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PKGDECL"]
    unless_null $P138, vivify_2521
    die "Contextual $*PKGDECL not found"
  vivify_2521:
  vivify_2520:
    concat $P139, $P138, "-attr"
    find_dynamic_lex $P142, "%*HOW"
    unless_null $P142, vivify_2522
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["%HOW"]
    unless_null $P142, vivify_2523
    die "Contextual %*HOW not found"
  vivify_2523:
  vivify_2522:
    set $P143, $P142[$P139]
    unless_null $P143, vivify_2524
    new $P143, "Undef"
  vivify_2524:
    find_lex $P3105, "%lit_args"
    unless_null $P3105, vivify_2525
    $P3105 = root_new ['parrot';'Hash']
  vivify_2525:
    find_lex $P3106, "%obj_args"
    unless_null $P3106, vivify_2526
    $P3106 = root_new ['parrot';'Hash']
  vivify_2526:
    $P132."pkg_add_attribute"($P135, $P143, $P3105, $P3106)
.annotate 'line', 1866
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Stmts"]
    $P134 = $P133."new"()
    store_lex "$past", $P134
.annotate 'line', 1848
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3113"  :anon :subid("541_1312646121.678") :outer("539_1312646121.678")
    .param pmc param_3115
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1890
    .lex "$_", param_3115
    find_lex $P132, "$_"
    unless_null $P132, vivify_2533
    new $P132, "Undef"
  vivify_2533:
    $P133 = $P132."ast"()
    find_lex $P134, "$/"
    unless_null $P134, vivify_2534
    new $P134, "Undef"
  vivify_2534:
    $P135 = $P133($P134)
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("542_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3118
    .param pmc param_3119
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1895
    .lex "self", param_3118
    .lex "$/", param_3119
    find_lex $P122, "$/"
    find_lex $P3120, "$/"
    unless_null $P3120, vivify_2535
    $P3120 = root_new ['parrot';'Hash']
  vivify_2535:
    set $P123, $P3120["routine_def"]
    unless_null $P123, vivify_2536
    new $P123, "Undef"
  vivify_2536:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("543_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3122
    .param pmc param_3123
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1896
    .lex "self", param_3122
    .lex "$/", param_3123
    find_lex $P122, "$/"
    find_lex $P3124, "$/"
    unless_null $P3124, vivify_2537
    $P3124 = root_new ['parrot';'Hash']
  vivify_2537:
    set $P123, $P3124["method_def"]
    unless_null $P123, vivify_2538
    new $P123, "Undef"
  vivify_2538:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("544_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3126
    .param pmc param_3127
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1898
    .const 'Sub' $P3203 = "550_1312646121.678" 
    capture_lex $P3203
    .const 'Sub' $P3137 = "545_1312646121.678" 
    capture_lex $P3137
    .lex "self", param_3126
    .lex "$/", param_3127
.annotate 'line', 1901
    new $P122, "Undef"
    set $P3128, $P122
    .lex "$past", $P3128
.annotate 'line', 1912
    new $P123, "Undef"
    set $P3129, $P123
    .lex "$block", $P3129
.annotate 'line', 1898
    find_lex $P124, "$past"
    unless_null $P124, vivify_2539
    new $P124, "Undef"
  vivify_2539:
.annotate 'line', 1902
    find_lex $P3131, "$/"
    unless_null $P3131, vivify_2540
    $P3131 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P124, $P3131["onlystar"]
    unless_null $P124, vivify_2541
    new $P124, "Undef"
  vivify_2541:
    if $P124, if_3130
.annotate 'line', 1906
    find_lex $P3132, "$/"
    unless_null $P3132, vivify_2542
    $P3132 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P125, $P3132["blockoid"]
    unless_null $P125, vivify_2543
    new $P125, "Undef"
  vivify_2543:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 1907
    find_lex $P125, "$past"
    unless_null $P125, vivify_2544
    new $P125, "Undef"
  vivify_2544:
    $P125."blocktype"("declaration")
.annotate 'line', 1908
    find_dynamic_lex $P128, "$*RETURN_USED"
    unless_null $P128, vivify_2545
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$RETURN_USED"]
    unless_null $P128, vivify_2546
    die "Contextual $*RETURN_USED not found"
  vivify_2546:
  vivify_2545:
    unless $P128, if_3133_end
.annotate 'line', 1909
    find_lex $P129, "$past"
    unless_null $P129, vivify_2547
    new $P129, "Undef"
  vivify_2547:
    $P129."control"("return_pir")
  if_3133_end:
.annotate 'line', 1905
    goto if_3130_end
  if_3130:
.annotate 'line', 1903
    $P125 = "only_star_block"()
    store_lex "$past", $P125
  if_3130_end:
.annotate 'line', 1912
    find_lex $P124, "$past"
    unless_null $P124, vivify_2548
    new $P124, "Undef"
  vivify_2548:
    store_lex "$block", $P124
.annotate 'line', 1914
    find_lex $P3135, "$/"
    unless_null $P3135, vivify_2549
    $P3135 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P124, $P3135["deflongname"]
    unless_null $P124, vivify_2550
    new $P124, "Undef"
  vivify_2550:
    unless $P124, if_3134_end
    .const 'Sub' $P3137 = "545_1312646121.678" 
    capture_lex $P3137
    $P3137()
  if_3134_end:
.annotate 'line', 2015
    find_lex $P124, "$block"
    unless_null $P124, vivify_2656
    new $P124, "Undef"
  vivify_2656:
    find_lex $P3198, "$past"
    unless_null $P3198, vivify_2657
    $P3198 = root_new ['parrot';'Hash']
    store_lex "$past", $P3198
  vivify_2657:
    set $P3198["block_past"], $P124
.annotate 'line', 2016
    find_lex $P3200, "$/"
    unless_null $P3200, vivify_2658
    $P3200 = root_new ['parrot';'Hash']
  vivify_2658:
    set $P124, $P3200["trait"]
    unless_null $P124, vivify_2659
    new $P124, "Undef"
  vivify_2659:
    unless $P124, if_3199_end
.annotate 'line', 2017
    find_lex $P3201, "$/"
    unless_null $P3201, vivify_2660
    $P3201 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P127, $P3201["trait"]
    unless_null $P127, vivify_2661
    new $P127, "Undef"
  vivify_2661:
    defined $I100, $P127
    unless $I100, for_undef_2662
    iter $P125, $P127
    new $P129, 'ExceptionHandler'
    set_label $P129, loop3205_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop3205_test:
    unless $P125, loop3205_done
    shift $P128, $P125
  loop3205_redo:
    .const 'Sub' $P3203 = "550_1312646121.678" 
    capture_lex $P3203
    $P3203($P128)
  loop3205_next:
    goto loop3205_test
  loop3205_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3205_next
    eq $P130, .CONTROL_LOOP_REDO, loop3205_redo
  loop3205_done:
    pop_eh 
  for_undef_2662:
  if_3199_end:
.annotate 'line', 2020
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2665
    new $P125, "Undef"
  vivify_2665:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1898
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3136"  :anon :subid("545_1312646121.678") :outer("544_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1914
    .const 'Sub' $P3182 = "549_1312646121.678" 
    capture_lex $P3182
    .const 'Sub' $P3148 = "546_1312646121.678" 
    capture_lex $P3148
.annotate 'line', 1915
    new $P125, "Undef"
    set $P3138, $P125
    .lex "$name", $P3138
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3139, "$/"
    unless_null $P3139, vivify_2551
    $P3139 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P3140, $P3139["sigil"]
    unless_null $P3140, vivify_2552
    $P3140 = root_new ['parrot';'ResizablePMCArray']
  vivify_2552:
    set $P128, $P3140[$I100]
    unless_null $P128, vivify_2553
    new $P128, "Undef"
  vivify_2553:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    new $P130, "Float"
    assign $P130, 0
    set $I101, $P130
    find_lex $P3141, "$/"
    unless_null $P3141, vivify_2554
    $P3141 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P3142, $P3141["deflongname"]
    unless_null $P3142, vivify_2555
    $P3142 = root_new ['parrot';'ResizablePMCArray']
  vivify_2555:
    set $P131, $P3142[$I101]
    unless_null $P131, vivify_2556
    new $P131, "Undef"
  vivify_2556:
    $S101 = $P131."ast"()
    concat $P132, $P129, $S101
    store_lex "$name", $P132
.annotate 'line', 1916
    find_lex $P127, "$past"
    unless_null $P127, vivify_2557
    new $P127, "Undef"
  vivify_2557:
    find_lex $P128, "$name"
    unless_null $P128, vivify_2558
    new $P128, "Undef"
  vivify_2558:
    $P127."name"($P128)
.annotate 'line', 1917
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2559
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2560
    die "Contextual $*SCOPE not found"
  vivify_2560:
  vivify_2559:
    set $S100, $P131
    iseq $I100, $S100, ""
    unless $I100, unless_3145
    new $P128, 'Integer'
    set $P128, $I100
    goto unless_3145_end
  unless_3145:
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2561
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2562
    die "Contextual $*SCOPE not found"
  vivify_2562:
  vivify_2561:
    set $S101, $P134
    iseq $I101, $S101, "my"
    new $P128, 'Integer'
    set $P128, $I101
  unless_3145_end:
    unless $P128, unless_3144
    set $P127, $P128
    goto unless_3144_end
  unless_3144:
    find_dynamic_lex $P137, "$*SCOPE"
    unless_null $P137, vivify_2563
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SCOPE"]
    unless_null $P137, vivify_2564
    die "Contextual $*SCOPE not found"
  vivify_2564:
  vivify_2563:
    set $S102, $P137
    iseq $I102, $S102, "our"
    new $P127, 'Integer'
    set $P127, $I102
  unless_3144_end:
    if $P127, if_3143
.annotate 'line', 2005
    find_lex $P138, "$/"
    unless_null $P138, vivify_2565
    new $P138, "Undef"
  vivify_2565:
    $P139 = $P138."CURSOR"()
    find_dynamic_lex $P142, "$*SCOPE"
    unless_null $P142, vivify_2566
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["$SCOPE"]
    unless_null $P142, vivify_2567
    die "Contextual $*SCOPE not found"
  vivify_2567:
  vivify_2566:
    concat $P143, $P142, " scoped routines are not supported yet"
    $P139."panic"($P143)
.annotate 'line', 2004
    goto if_3143_end
  if_3143:
.annotate 'line', 1918
    find_dynamic_lex $P140, "$*MULTINESS"
    unless_null $P140, vivify_2568
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MULTINESS"]
    unless_null $P140, vivify_2569
    die "Contextual $*MULTINESS not found"
  vivify_2569:
  vivify_2568:
    set $S103, $P140
    iseq $I103, $S103, "multi"
    if $I103, if_3146
.annotate 'line', 1969
    find_dynamic_lex $P145, "$*MULTINESS"
    unless_null $P145, vivify_2570
    get_hll_global $P142, "GLOBAL"
    get_who $P144, $P142
    set $P145, $P144["$MULTINESS"]
    unless_null $P145, vivify_2571
    die "Contextual $*MULTINESS not found"
  vivify_2571:
  vivify_2570:
    set $S104, $P145
    iseq $I104, $S104, "proto"
    if $I104, if_3180
.annotate 'line', 1988
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P149, "Float"
    assign $P149, 0
    set $I106, $P149
    find_lex $P151, "$?PACKAGE"
    get_who $P152, $P151
    set $P3190, $P152["@BLOCK"]
    unless_null $P3190, vivify_2572
    $P3190 = root_new ['parrot';'ResizablePMCArray']
  vivify_2572:
    set $P3191, $P3190[$I106]
    unless_null $P3191, vivify_2573
    $P3191 = root_new ['parrot';'ResizablePMCArray']
  vivify_2573:
    set $P153, $P3191[$I105]
    unless_null $P153, vivify_2574
    new $P153, "Undef"
  vivify_2574:
    get_hll_global $P154, "GLOBAL"
    nqp_get_package_through_who $P155, $P154, "PAST"
    get_who $P156, $P155
    set $P157, $P156["Var"]
    find_lex $P158, "$name"
    unless_null $P158, vivify_2575
    new $P158, "Undef"
  vivify_2575:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2576
    new $P159, "Undef"
  vivify_2576:
    $P160 = $P157."new"($P158 :named("name"), 1 :named("isdecl"), $P159 :named("viviself"), "lexical" :named("scope"))
    $P153."push"($P160)
.annotate 'line', 1990
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3192, $P151["@BLOCK"]
    unless_null $P3192, vivify_2577
    $P3192 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P152, $P3192[$I105]
    unless_null $P152, vivify_2578
    new $P152, "Undef"
  vivify_2578:
    find_lex $P153, "$name"
    unless_null $P153, vivify_2579
    new $P153, "Undef"
  vivify_2579:
    $P152."symbol"($P153, "lexical" :named("scope"))
.annotate 'line', 1991
    find_dynamic_lex $P151, "$*SCOPE"
    unless_null $P151, vivify_2580
    get_hll_global $P147, "GLOBAL"
    get_who $P149, $P147
    set $P151, $P149["$SCOPE"]
    unless_null $P151, vivify_2581
    die "Contextual $*SCOPE not found"
  vivify_2581:
  vivify_2580:
    set $S105, $P151
    iseq $I105, $S105, "our"
    unless $I105, if_3193_end
.annotate 'line', 1994
    find_dynamic_lex $P154, "$*SC"
    unless_null $P154, vivify_2582
    get_hll_global $P152, "GLOBAL"
    get_who $P153, $P152
    set $P154, $P153["$SC"]
    unless_null $P154, vivify_2583
    die "Contextual $*SC not found"
  vivify_2583:
  vivify_2582:
    find_dynamic_lex $P157, "$*PACKAGE"
    unless_null $P157, vivify_2584
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["$PACKAGE"]
    unless_null $P157, vivify_2585
    die "Contextual $*PACKAGE not found"
  vivify_2585:
  vivify_2584:
    find_lex $P158, "$name"
    unless_null $P158, vivify_2586
    new $P158, "Undef"
  vivify_2586:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2587
    new $P159, "Undef"
  vivify_2587:
    $P154."install_package_routine"($P157, $P158, $P159)
.annotate 'line', 1995
    new $P152, "Float"
    assign $P152, 0
    set $I106, $P152
    new $P153, "Float"
    assign $P153, 0
    set $I107, $P153
    find_lex $P154, "$?PACKAGE"
    get_who $P155, $P154
    set $P3194, $P155["@BLOCK"]
    unless_null $P3194, vivify_2588
    $P3194 = root_new ['parrot';'ResizablePMCArray']
  vivify_2588:
    set $P3195, $P3194[$I107]
    unless_null $P3195, vivify_2589
    $P3195 = root_new ['parrot';'ResizablePMCArray']
  vivify_2589:
    set $P156, $P3195[$I106]
    unless_null $P156, vivify_2590
    new $P156, "Undef"
  vivify_2590:
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 1997
    find_lex $P161, "$name"
    unless_null $P161, vivify_2591
    new $P161, "Undef"
  vivify_2591:
    new $P162, "ResizablePMCArray"
    push $P162, $P161
    find_lex $P163, "$/"
    unless_null $P163, vivify_2592
    new $P163, "Undef"
  vivify_2592:
    $P164 = "lexical_package_lookup"($P162, $P163)
.annotate 'line', 1998
    get_hll_global $P165, "GLOBAL"
    nqp_get_package_through_who $P166, $P165, "PAST"
    get_who $P167, $P166
    set $P168, $P167["Var"]
    find_lex $P169, "$name"
    unless_null $P169, vivify_2593
    new $P169, "Undef"
  vivify_2593:
    $P170 = $P168."new"($P169 :named("name"), "lexical" :named("scope"))
    $P171 = $P160."new"($P164, $P170, "bind_6model" :named("pasttype"))
.annotate 'line', 1995
    $P156."push"($P171)
  if_3193_end:
.annotate 'line', 1987
    goto if_3180_end
  if_3180:
.annotate 'line', 1969
    .const 'Sub' $P3182 = "549_1312646121.678" 
    capture_lex $P3182
    $P3182()
  if_3180_end:
    goto if_3146_end
  if_3146:
.annotate 'line', 1918
    .const 'Sub' $P3148 = "546_1312646121.678" 
    capture_lex $P3148
    $P3148()
  if_3146_end:
.annotate 'line', 2002
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    find_lex $P142, "$name"
    unless_null $P142, vivify_2651
    new $P142, "Undef"
  vivify_2651:
    $P143 = $P141."new"($P142 :named("name"))
    store_lex "$past", $P143
  if_3143_end:
.annotate 'line', 2009
    find_lex $P129, "$name"
    unless_null $P129, vivify_2652
    new $P129, "Undef"
  vivify_2652:
    set $S100, $P129
    iseq $I100, $S100, "MAIN"
    if $I100, if_3197
    new $P128, 'Integer'
    set $P128, $I100
    goto if_3197_end
  if_3197:
    find_dynamic_lex $P132, "$*MULTINESS"
    unless_null $P132, vivify_2653
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$MULTINESS"]
    unless_null $P132, vivify_2654
    die "Contextual $*MULTINESS not found"
  vivify_2654:
  vivify_2653:
    set $S101, $P132
    isne $I101, $S101, "multi"
    new $P128, 'Integer'
    set $P128, $I101
  if_3197_end:
    if $P128, if_3196
    set $P127, $P128
    goto if_3196_end
  if_3196:
.annotate 'line', 2010
    find_lex $P133, "$block"
    unless_null $P133, vivify_2655
    new $P133, "Undef"
  vivify_2655:
    store_dynamic_lex "$*MAIN_SUB", $P133
.annotate 'line', 2009
    set $P127, $P133
  if_3196_end:
.annotate 'line', 1914
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3181"  :anon :subid("549_1312646121.678") :outer("545_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1974
    new $P146, "Undef"
    set $P3183, $P146
    .lex "$cholder", $P3183
.annotate 'line', 1973
    find_dynamic_lex $P149, "$*SCOPE"
    unless_null $P149, vivify_2594
    get_hll_global $P147, "GLOBAL"
    get_who $P148, $P147
    set $P149, $P148["$SCOPE"]
    unless_null $P149, vivify_2595
    die "Contextual $*SCOPE not found"
  vivify_2595:
  vivify_2594:
    set $S105, $P149
    iseq $I105, $S105, "our"
    unless $I105, if_3184_end
    die "our-scoped protos not yet implemented"
  if_3184_end:
.annotate 'line', 1974
    get_hll_global $P147, "GLOBAL"
    nqp_get_package_through_who $P148, $P147, "PAST"
    get_who $P149, $P148
    set $P151, $P149["Op"]
    $P152 = $P151."new"("list" :named("pasttype"))
    store_lex "$cholder", $P152
.annotate 'line', 1975
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P148, "Float"
    assign $P148, 0
    set $I106, $P148
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3185, $P151["@BLOCK"]
    unless_null $P3185, vivify_2596
    $P3185 = root_new ['parrot';'ResizablePMCArray']
  vivify_2596:
    set $P3186, $P3185[$I106]
    unless_null $P3186, vivify_2597
    $P3186 = root_new ['parrot';'ResizablePMCArray']
  vivify_2597:
    set $P152, $P3186[$I105]
    unless_null $P152, vivify_2598
    new $P152, "Undef"
  vivify_2598:
    get_hll_global $P153, "GLOBAL"
    nqp_get_package_through_who $P154, $P153, "PAST"
    get_who $P155, $P154
    set $P156, $P155["Var"]
    find_lex $P157, "$name"
    unless_null $P157, vivify_2599
    new $P157, "Undef"
  vivify_2599:
    find_lex $P158, "$past"
    unless_null $P158, vivify_2600
    new $P158, "Undef"
  vivify_2600:
    $P159 = $P156."new"($P157 :named("name"), 1 :named("isdecl"), $P158 :named("viviself"), "lexical" :named("scope"))
    $P152."push"($P159)
.annotate 'line', 1977
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P148, "Float"
    assign $P148, 0
    set $I106, $P148
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3187, $P151["@BLOCK"]
    unless_null $P3187, vivify_2601
    $P3187 = root_new ['parrot';'ResizablePMCArray']
  vivify_2601:
    set $P3188, $P3187[$I106]
    unless_null $P3188, vivify_2602
    $P3188 = root_new ['parrot';'ResizablePMCArray']
  vivify_2602:
    set $P152, $P3188[$I105]
    unless_null $P152, vivify_2603
    new $P152, "Undef"
  vivify_2603:
    get_hll_global $P153, "GLOBAL"
    nqp_get_package_through_who $P154, $P153, "PAST"
    get_who $P155, $P154
    set $P156, $P155["Op"]
.annotate 'line', 1979
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Var"]
    find_lex $P161, "$name"
    unless_null $P161, vivify_2604
    new $P161, "Undef"
  vivify_2604:
    $P162 = $P160."new"($P161 :named("name"))
    find_lex $P163, "$cholder"
    unless_null $P163, vivify_2605
    new $P163, "Undef"
  vivify_2605:
    $P164 = $P156."new"($P162, $P163, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1977
    $P152."push"($P164)
.annotate 'line', 1982
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    find_lex $P148, "$?PACKAGE"
    get_who $P149, $P148
    set $P3189, $P149["@BLOCK"]
    unless_null $P3189, vivify_2606
    $P3189 = root_new ['parrot';'ResizablePMCArray']
  vivify_2606:
    set $P151, $P3189[$I105]
    unless_null $P151, vivify_2607
    new $P151, "Undef"
  vivify_2607:
    find_lex $P152, "$name"
    unless_null $P152, vivify_2608
    new $P152, "Undef"
  vivify_2608:
    find_lex $P153, "$cholder"
    unless_null $P153, vivify_2609
    new $P153, "Undef"
  vivify_2609:
    $P151."symbol"($P152, "lexical" :named("scope"), 1 :named("proto"), $P153 :named("cholder"))
.annotate 'line', 1985
    find_lex $P147, "$past"
    unless_null $P147, vivify_2610
    new $P147, "Undef"
  vivify_2610:
    $P148 = $P147."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1969
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3147"  :anon :subid("546_1312646121.678") :outer("545_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1918
    .const 'Sub' $P3158 = "547_1312646121.678" 
    capture_lex $P3158
.annotate 'line', 1921
    new $P141, "Undef"
    set $P3149, $P141
    .lex "$cholder", $P3149
.annotate 'line', 1922
    $P3151 = root_new ['parrot';'Hash']
    set $P3150, $P3151
    .lex "%sym", $P3150
.annotate 'line', 1920
    find_dynamic_lex $P144, "$*SCOPE"
    unless_null $P144, vivify_2611
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$SCOPE"]
    unless_null $P144, vivify_2612
    die "Contextual $*SCOPE not found"
  vivify_2612:
  vivify_2611:
    set $S104, $P144
    iseq $I104, $S104, "our"
    unless $I104, if_3152_end
    die "our-scoped multis not yet implemented"
  if_3152_end:
.annotate 'line', 1918
    find_lex $P142, "$cholder"
    unless_null $P142, vivify_2613
    new $P142, "Undef"
  vivify_2613:
.annotate 'line', 1922
    new $P142, "Float"
    assign $P142, 0
    set $I104, $P142
    find_lex $P143, "$?PACKAGE"
    get_who $P144, $P143
    set $P3153, $P144["@BLOCK"]
    unless_null $P3153, vivify_2614
    $P3153 = root_new ['parrot';'ResizablePMCArray']
  vivify_2614:
    set $P145, $P3153[$I104]
    unless_null $P145, vivify_2615
    new $P145, "Undef"
  vivify_2615:
    find_lex $P146, "$name"
    unless_null $P146, vivify_2616
    new $P146, "Undef"
  vivify_2616:
    $P147 = $P145."symbol"($P146)
    store_lex "%sym", $P147
.annotate 'line', 1923
    find_lex $P3155, "%sym"
    unless_null $P3155, vivify_2617
    $P3155 = root_new ['parrot';'Hash']
  vivify_2617:
    set $P142, $P3155["cholder"]
    unless_null $P142, vivify_2618
    new $P142, "Undef"
  vivify_2618:
    if $P142, if_3154
.annotate 'line', 1928
    .const 'Sub' $P3158 = "547_1312646121.678" 
    capture_lex $P3158
    $P3158()
    goto if_3154_end
  if_3154:
.annotate 'line', 1924
    find_lex $P3156, "%sym"
    unless_null $P3156, vivify_2646
    $P3156 = root_new ['parrot';'Hash']
  vivify_2646:
    set $P143, $P3156["cholder"]
    unless_null $P143, vivify_2647
    new $P143, "Undef"
  vivify_2647:
    store_lex "$cholder", $P143
  if_3154_end:
.annotate 'line', 1964
    find_lex $P142, "$cholder"
    unless_null $P142, vivify_2648
    new $P142, "Undef"
  vivify_2648:
    find_lex $P143, "$past"
    unless_null $P143, vivify_2649
    new $P143, "Undef"
  vivify_2649:
    $P142."push"($P143)
.annotate 'line', 1967
    find_lex $P142, "$past"
    unless_null $P142, vivify_2650
    new $P142, "Undef"
  vivify_2650:
    $P143 = "attach_multi_signature"($P142)
.annotate 'line', 1918
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3157"  :anon :subid("547_1312646121.678") :outer("546_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1928
    .const 'Sub' $P3165 = "548_1312646121.678" 
    capture_lex $P3165
.annotate 'line', 1935
    new $P143, "Undef"
    set $P3159, $P143
    .lex "$found_proto", $P3159
.annotate 'line', 1953
    new $P144, "Undef"
    set $P3160, $P144
    .lex "$dispatch_setup", $P3160
.annotate 'line', 1930
    find_lex $P3162, "%sym"
    unless_null $P3162, vivify_2619
    $P3162 = root_new ['parrot';'Hash']
  vivify_2619:
    set $P145, $P3162["proto"]
    unless_null $P145, vivify_2620
    new $P145, "Undef"
  vivify_2620:
    unless $P145, if_3161_end
.annotate 'line', 1933
    find_lex $P146, "$/"
    unless_null $P146, vivify_2621
    new $P146, "Undef"
  vivify_2621:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_3161_end:
.annotate 'line', 1928
    find_lex $P145, "$found_proto"
    unless_null $P145, vivify_2622
    new $P145, "Undef"
  vivify_2622:
.annotate 'line', 1936
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3163, $P147["@BLOCK"]
    unless_null $P3163, vivify_2623
    $P3163 = root_new ['parrot';'ResizablePMCArray']
  vivify_2623:
    defined $I104, $P3163
    unless $I104, for_undef_2624
    iter $P145, $P3163
    new $P151, 'ExceptionHandler'
    set_label $P151, loop3175_handler
    $P151."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P151
  loop3175_test:
    unless $P145, loop3175_done
    shift $P148, $P145
  loop3175_redo:
    .const 'Sub' $P3165 = "548_1312646121.678" 
    capture_lex $P3165
    $P3165($P148)
  loop3175_next:
    goto loop3175_test
  loop3175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P152, exception, 'type'
    eq $P152, .CONTROL_LOOP_NEXT, loop3175_next
    eq $P152, .CONTROL_LOOP_REDO, loop3175_redo
  loop3175_done:
    pop_eh 
  for_undef_2624:
.annotate 'line', 1947
    find_lex $P145, "$found_proto"
    unless_null $P145, vivify_2633
    new $P145, "Undef"
  vivify_2633:
    if $P145, unless_3176_end
.annotate 'line', 1948
    find_lex $P146, "$/"
    unless_null $P146, vivify_2634
    new $P146, "Undef"
  vivify_2634:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_3176_end:
.annotate 'line', 1952
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    $P149 = $P148."new"("list" :named("pasttype"))
    store_lex "$cholder", $P149
.annotate 'line', 1953
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
.annotate 'line', 1955
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Var"]
    find_lex $P154, "$name"
    unless_null $P154, vivify_2635
    new $P154, "Undef"
  vivify_2635:
    $P155 = $P153."new"($P154 :named("name"), "outer" :named("scope"))
    find_lex $P156, "$cholder"
    unless_null $P156, vivify_2636
    new $P156, "Undef"
  vivify_2636:
    $P157 = $P148."new"($P155, $P156, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1953
    store_lex "$dispatch_setup", $P157
.annotate 'line', 1958
    new $P145, "Float"
    assign $P145, 0
    set $I104, $P145
    new $P146, "Float"
    assign $P146, 0
    set $I105, $P146
    find_lex $P147, "$?PACKAGE"
    get_who $P148, $P147
    set $P3177, $P148["@BLOCK"]
    unless_null $P3177, vivify_2637
    $P3177 = root_new ['parrot';'ResizablePMCArray']
  vivify_2637:
    set $P3178, $P3177[$I105]
    unless_null $P3178, vivify_2638
    $P3178 = root_new ['parrot';'ResizablePMCArray']
  vivify_2638:
    set $P149, $P3178[$I104]
    unless_null $P149, vivify_2639
    new $P149, "Undef"
  vivify_2639:
    get_hll_global $P151, "GLOBAL"
    nqp_get_package_through_who $P152, $P151, "PAST"
    get_who $P153, $P152
    set $P154, $P153["Var"]
    find_lex $P155, "$name"
    unless_null $P155, vivify_2640
    new $P155, "Undef"
  vivify_2640:
    find_lex $P156, "$dispatch_setup"
    unless_null $P156, vivify_2641
    new $P156, "Undef"
  vivify_2641:
    $P157 = $P154."new"($P155 :named("name"), 1 :named("isdecl"), $P156 :named("viviself"), "lexical" :named("scope"))
    $P149."push"($P157)
.annotate 'line', 1960
    new $P145, "Float"
    assign $P145, 0
    set $I104, $P145
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3179, $P147["@BLOCK"]
    unless_null $P3179, vivify_2642
    $P3179 = root_new ['parrot';'ResizablePMCArray']
  vivify_2642:
    set $P148, $P3179[$I104]
    unless_null $P148, vivify_2643
    new $P148, "Undef"
  vivify_2643:
    find_lex $P149, "$name"
    unless_null $P149, vivify_2644
    new $P149, "Undef"
  vivify_2644:
    find_lex $P151, "$cholder"
    unless_null $P151, vivify_2645
    new $P151, "Undef"
  vivify_2645:
    $P152 = $P148."symbol"($P149, "lexical" :named("scope"), $P151 :named("cholder"))
.annotate 'line', 1928
    .return ($P152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3164"  :anon :subid("548_1312646121.678") :outer("547_1312646121.678")
    .param pmc param_3168
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1937
    $P3167 = root_new ['parrot';'Hash']
    set $P3166, $P3167
    .lex "%sym", $P3166
    .lex "$_", param_3168
    find_lex $P149, "$_"
    unless_null $P149, vivify_2625
    new $P149, "Undef"
  vivify_2625:
    find_lex $P151, "$name"
    unless_null $P151, vivify_2626
    new $P151, "Undef"
  vivify_2626:
    $P152 = $P149."symbol"($P151)
    store_lex "%sym", $P152
.annotate 'line', 1938
    find_lex $P3171, "%sym"
    unless_null $P3171, vivify_2627
    $P3171 = root_new ['parrot';'Hash']
  vivify_2627:
    set $P152, $P3171["proto"]
    unless_null $P152, vivify_2628
    new $P152, "Undef"
  vivify_2628:
    unless $P152, unless_3170
    set $P151, $P152
    goto unless_3170_end
  unless_3170:
    find_lex $P3172, "%sym"
    unless_null $P3172, vivify_2629
    $P3172 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P153, $P3172["cholder"]
    unless_null $P153, vivify_2630
    new $P153, "Undef"
  vivify_2630:
    set $P151, $P153
  unless_3170_end:
    if $P151, if_3169
.annotate 'line', 1941
    find_lex $P3174, "%sym"
    unless_null $P3174, vivify_2631
    $P3174 = root_new ['parrot';'Hash']
  vivify_2631:
    if $P3174, if_3173
    set $P155, $P3174
    goto if_3173_end
  if_3173:
.annotate 'line', 1942
    find_lex $P156, "$/"
    unless_null $P156, vivify_2632
    new $P156, "Undef"
  vivify_2632:
    $P157 = $P156."CURSOR"()
    $P158 = $P157."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1941
    set $P155, $P158
  if_3173_end:
    set $P149, $P155
.annotate 'line', 1938
    goto if_3169_end
  if_3169:
.annotate 'line', 1939
    new $P154, "Float"
    assign $P154, 1
    store_lex "$found_proto", $P154
.annotate 'line', 1938
    set $P149, $P154
  if_3169_end:
.annotate 'line', 1936
    .return ($P149)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3202"  :anon :subid("550_1312646121.678") :outer("544_1312646121.678")
    .param pmc param_3204
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2017
    .lex "$_", param_3204
    find_lex $P129, "$_"
    unless_null $P129, vivify_2663
    new $P129, "Undef"
  vivify_2663:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2664
    new $P131, "Undef"
  vivify_2664:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("551_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3207
    .param pmc param_3208
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2024
    .const 'Sub' $P3236 = "553_1312646121.678" 
    capture_lex $P3236
    .const 'Sub' $P3220 = "552_1312646121.678" 
    capture_lex $P3220
    .lex "self", param_3207
    .lex "$/", param_3208
.annotate 'line', 2027
    new $P122, "Undef"
    set $P3209, $P122
    .lex "$past", $P3209
.annotate 'line', 2024
    find_lex $P123, "$past"
    unless_null $P123, vivify_2666
    new $P123, "Undef"
  vivify_2666:
.annotate 'line', 2028
    find_lex $P3211, "$/"
    unless_null $P3211, vivify_2667
    $P3211 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P123, $P3211["onlystar"]
    unless_null $P123, vivify_2668
    new $P123, "Undef"
  vivify_2668:
    if $P123, if_3210
.annotate 'line', 2032
    find_lex $P3212, "$/"
    unless_null $P3212, vivify_2669
    $P3212 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P124, $P3212["blockoid"]
    unless_null $P124, vivify_2670
    new $P124, "Undef"
  vivify_2670:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 2033
    find_lex $P124, "$past"
    unless_null $P124, vivify_2671
    new $P124, "Undef"
  vivify_2671:
    $P124."blocktype"("declaration")
.annotate 'line', 2034
    find_dynamic_lex $P127, "$*RETURN_USED"
    unless_null $P127, vivify_2672
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$RETURN_USED"]
    unless_null $P127, vivify_2673
    die "Contextual $*RETURN_USED not found"
  vivify_2673:
  vivify_2672:
    unless $P127, if_3213_end
.annotate 'line', 2035
    find_lex $P128, "$past"
    unless_null $P128, vivify_2674
    new $P128, "Undef"
  vivify_2674:
    $P128."control"("return_pir")
  if_3213_end:
.annotate 'line', 2031
    goto if_3210_end
  if_3210:
.annotate 'line', 2029
    $P124 = "only_star_block"()
    store_lex "$past", $P124
  if_3210_end:
.annotate 'line', 2040
    find_lex $P3215, "$past"
    unless_null $P3215, vivify_2675
    $P3215 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P123, $P3215["signature_has_invocant"]
    unless_null $P123, vivify_2676
    new $P123, "Undef"
  vivify_2676:
    if $P123, unless_3214_end
.annotate 'line', 2041
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P3216, "$past"
    unless_null $P3216, vivify_2677
    $P3216 = root_new ['parrot';'ResizablePMCArray']
  vivify_2677:
    set $P125, $P3216[$I100]
    unless_null $P125, vivify_2678
    new $P125, "Undef"
  vivify_2678:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2043
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2679
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2680
    die "Contextual $*SC not found"
  vivify_2680:
  vivify_2679:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2681
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2682
    die "Contextual $*PACKAGE not found"
  vivify_2682:
  vivify_2681:
    $P137 = $P133."get_object_sc_ref_past"($P136)
.annotate 'line', 2041
    $P138 = $P130."new"("self" :named("name"), "parameter" :named("scope"), $P137 :named("multitype"))
    $P125."unshift"($P138)
  unless_3214_end:
.annotate 'line', 2046
    find_lex $P123, "$past"
    unless_null $P123, vivify_2683
    new $P123, "Undef"
  vivify_2683:
    $P123."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2049
    find_lex $P3218, "$/"
    unless_null $P3218, vivify_2684
    $P3218 = root_new ['parrot';'Hash']
  vivify_2684:
    set $P123, $P3218["deflongname"]
    unless_null $P123, vivify_2685
    new $P123, "Undef"
  vivify_2685:
    unless $P123, if_3217_end
    .const 'Sub' $P3220 = "552_1312646121.678" 
    capture_lex $P3220
    $P3220()
  if_3217_end:
.annotate 'line', 2076
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2720
    new $P124, "Undef"
  vivify_2720:
    $P123."!make"($P124)
.annotate 'line', 2077
    find_lex $P123, "$past"
    unless_null $P123, vivify_2721
    new $P123, "Undef"
  vivify_2721:
    find_lex $P3231, "$past"
    unless_null $P3231, vivify_2722
    $P3231 = root_new ['parrot';'Hash']
    store_lex "$past", $P3231
  vivify_2722:
    set $P3231["block_past"], $P123
.annotate 'line', 2078
    find_lex $P3233, "$/"
    unless_null $P3233, vivify_2723
    $P3233 = root_new ['parrot';'Hash']
  vivify_2723:
    set $P124, $P3233["trait"]
    unless_null $P124, vivify_2724
    new $P124, "Undef"
  vivify_2724:
    if $P124, if_3232
    set $P123, $P124
    goto if_3232_end
  if_3232:
.annotate 'line', 2079
    find_lex $P3234, "$/"
    unless_null $P3234, vivify_2725
    $P3234 = root_new ['parrot';'Hash']
  vivify_2725:
    set $P127, $P3234["trait"]
    unless_null $P127, vivify_2726
    new $P127, "Undef"
  vivify_2726:
    defined $I100, $P127
    unless $I100, for_undef_2727
    iter $P125, $P127
    new $P129, 'ExceptionHandler'
    set_label $P129, loop3238_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop3238_test:
    unless $P125, loop3238_done
    shift $P128, $P125
  loop3238_redo:
    .const 'Sub' $P3236 = "553_1312646121.678" 
    capture_lex $P3236
    $P3236($P128)
  loop3238_next:
    goto loop3238_test
  loop3238_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3238_next
    eq $P130, .CONTROL_LOOP_REDO, loop3238_redo
  loop3238_done:
    pop_eh 
  for_undef_2727:
.annotate 'line', 2078
    set $P123, $P125
  if_3232_end:
.annotate 'line', 2024
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3219"  :anon :subid("552_1312646121.678") :outer("551_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2051
    new $P124, "Undef"
    set $P3221, $P124
    .lex "$name", $P3221
.annotate 'line', 2059
    new $P125, "Undef"
    set $P3222, $P125
    .lex "$meta_meth", $P3222
.annotate 'line', 2060
    new $P127, "Undef"
    set $P3223, $P127
    .lex "$is_dispatcher", $P3223
.annotate 'line', 2051
    find_lex $P3224, "$/"
    unless_null $P3224, vivify_2686
    $P3224 = root_new ['parrot';'Hash']
  vivify_2686:
    set $P128, $P3224["private"]
    unless_null $P128, vivify_2687
    new $P128, "Undef"
  vivify_2687:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    new $P130, "Float"
    assign $P130, 0
    set $I100, $P130
    find_lex $P3225, "$/"
    unless_null $P3225, vivify_2688
    $P3225 = root_new ['parrot';'Hash']
  vivify_2688:
    set $P3226, $P3225["deflongname"]
    unless_null $P3226, vivify_2689
    $P3226 = root_new ['parrot';'ResizablePMCArray']
  vivify_2689:
    set $P131, $P3226[$I100]
    unless_null $P131, vivify_2690
    new $P131, "Undef"
  vivify_2690:
    $P132 = $P131."ast"()
    set $S101, $P132
    concat $P133, $P129, $S101
    store_lex "$name", $P133
.annotate 'line', 2052
    find_lex $P128, "$past"
    unless_null $P128, vivify_2691
    new $P128, "Undef"
  vivify_2691:
    find_lex $P129, "$name"
    unless_null $P129, vivify_2692
    new $P129, "Undef"
  vivify_2692:
    $P128."name"($P129)
.annotate 'line', 2056
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2693
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2694
    die "Contextual $*MULTINESS not found"
  vivify_2694:
  vivify_2693:
    set $S100, $P130
    iseq $I100, $S100, "multi"
    unless $I100, if_3227_end
    find_lex $P131, "$past"
    unless_null $P131, vivify_2695
    new $P131, "Undef"
  vivify_2695:
    "attach_multi_signature"($P131)
  if_3227_end:
.annotate 'line', 2059
    find_dynamic_lex $P131, "$*MULTINESS"
    unless_null $P131, vivify_2696
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$MULTINESS"]
    unless_null $P131, vivify_2697
    die "Contextual $*MULTINESS not found"
  vivify_2697:
  vivify_2696:
    set $S100, $P131
    iseq $I100, $S100, "multi"
    if $I100, if_3228
    new $P133, "String"
    assign $P133, "add_method"
    set $P128, $P133
    goto if_3228_end
  if_3228:
    new $P132, "String"
    assign $P132, "add_multi_method"
    set $P128, $P132
  if_3228_end:
    store_lex "$meta_meth", $P128
.annotate 'line', 2060
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2698
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2699
    die "Contextual $*MULTINESS not found"
  vivify_2699:
  vivify_2698:
    set $S100, $P130
    iseq $I100, $S100, "proto"
    new $P131, 'Integer'
    set $P131, $I100
    store_lex "$is_dispatcher", $P131
.annotate 'line', 2061
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_2700
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_2701
    die "Contextual $*SC not found"
  vivify_2701:
  vivify_2700:
    find_dynamic_lex $P133, "$*PACKAGE"
    unless_null $P133, vivify_2702
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PACKAGE"]
    unless_null $P133, vivify_2703
    die "Contextual $*PACKAGE not found"
  vivify_2703:
  vivify_2702:
    find_lex $P134, "$meta_meth"
    unless_null $P134, vivify_2704
    new $P134, "Undef"
  vivify_2704:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2705
    new $P135, "Undef"
  vivify_2705:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2706
    new $P136, "Undef"
  vivify_2706:
    find_lex $P137, "$is_dispatcher"
    unless_null $P137, vivify_2707
    new $P137, "Undef"
  vivify_2707:
    $P130."pkg_add_method"($P133, $P134, $P135, $P136, $P137)
.annotate 'line', 2064
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2708
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2709
    die "Contextual $*SCOPE not found"
  vivify_2709:
  vivify_2708:
    set $S100, $P131
    iseq $I100, $S100, "our"
    if $I100, if_3229
.annotate 'line', 2067
    find_lex $P133, "$past"
    unless_null $P133, vivify_2710
    new $P133, "Undef"
  vivify_2710:
    $P134 = $P133."pirflags"()
    if $P134, if_3230
.annotate 'line', 2070
    find_lex $P135, "$past"
    unless_null $P135, vivify_2711
    new $P135, "Undef"
  vivify_2711:
    $P136 = $P135."pirflags"(":anon")
.annotate 'line', 2069
    set $P132, $P136
.annotate 'line', 2067
    goto if_3230_end
  if_3230:
.annotate 'line', 2068
    find_lex $P135, "$past"
    unless_null $P135, vivify_2712
    new $P135, "Undef"
  vivify_2712:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2713
    new $P136, "Undef"
  vivify_2713:
    $P137 = $P136."pirflags"()
    set $S101, $P137
    new $P138, 'String'
    set $P138, $S101
    concat $P139, $P138, ":anon"
    $P141 = $P135."pirflags"($P139)
.annotate 'line', 2067
    set $P132, $P141
  if_3230_end:
.annotate 'line', 2066
    set $P128, $P132
.annotate 'line', 2064
    goto if_3229_end
  if_3229:
.annotate 'line', 2065
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2714
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2715
    die "Contextual $*SC not found"
  vivify_2715:
  vivify_2714:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2716
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2717
    die "Contextual $*PACKAGE not found"
  vivify_2717:
  vivify_2716:
    find_lex $P138, "$name"
    unless_null $P138, vivify_2718
    new $P138, "Undef"
  vivify_2718:
    find_lex $P139, "$past"
    unless_null $P139, vivify_2719
    new $P139, "Undef"
  vivify_2719:
    $P140 = $P134."install_package_routine"($P137, $P138, $P139)
.annotate 'line', 2064
    set $P128, $P140
  if_3229_end:
.annotate 'line', 2049
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3235"  :anon :subid("553_1312646121.678") :outer("551_1312646121.678")
    .param pmc param_3237
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2079
    .lex "$_", param_3237
    find_lex $P129, "$_"
    unless_null $P129, vivify_2728
    new $P129, "Undef"
  vivify_2728:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2729
    new $P131, "Undef"
  vivify_2729:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("554_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3240
    .param pmc param_3241
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2108
    .const 'Sub' $P3256 = "556_1312646121.678" 
    capture_lex $P3256
    .const 'Sub' $P3248 = "555_1312646121.678" 
    capture_lex $P3248
    .lex "self", param_3240
    .lex "$/", param_3241
.annotate 'line', 2109
    new $P122, "Undef"
    set $P3242, $P122
    .lex "$BLOCKINIT", $P3242
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P3243, $P127["@BLOCK"]
    unless_null $P3243, vivify_2730
    $P3243 = root_new ['parrot';'ResizablePMCArray']
  vivify_2730:
    set $P3244, $P3243[$I101]
    unless_null $P3244, vivify_2731
    $P3244 = root_new ['parrot';'ResizablePMCArray']
  vivify_2731:
    set $P128, $P3244[$I100]
    unless_null $P128, vivify_2732
    new $P128, "Undef"
  vivify_2732:
    store_lex "$BLOCKINIT", $P128
.annotate 'line', 2110
    find_lex $P3246, "$/"
    unless_null $P3246, vivify_2733
    $P3246 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P123, $P3246["invocant"]
    unless_null $P123, vivify_2734
    new $P123, "Undef"
  vivify_2734:
    unless $P123, if_3245_end
    .const 'Sub' $P3248 = "555_1312646121.678" 
    capture_lex $P3248
    $P3248()
  if_3245_end:
.annotate 'line', 2119
    find_lex $P3254, "$/"
    unless_null $P3254, vivify_2744
    $P3254 = root_new ['parrot';'Hash']
  vivify_2744:
    set $P124, $P3254["parameter"]
    unless_null $P124, vivify_2745
    new $P124, "Undef"
  vivify_2745:
    defined $I100, $P124
    unless $I100, for_undef_2746
    iter $P123, $P124
    new $P127, 'ExceptionHandler'
    set_label $P127, loop3258_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop3258_test:
    unless $P123, loop3258_done
    shift $P125, $P123
  loop3258_redo:
    .const 'Sub' $P3256 = "556_1312646121.678" 
    capture_lex $P3256
    $P3256($P125)
  loop3258_next:
    goto loop3258_test
  loop3258_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop3258_next
    eq $P128, .CONTROL_LOOP_REDO, loop3258_redo
  loop3258_done:
    pop_eh 
  for_undef_2746:
.annotate 'line', 2108
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3247"  :anon :subid("555_1312646121.678") :outer("554_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2111
    new $P124, "Undef"
    set $P3249, $P124
    .lex "$inv", $P3249
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3250, "$/"
    unless_null $P3250, vivify_2735
    $P3250 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P3251, $P3250["invocant"]
    unless_null $P3251, vivify_2736
    $P3251 = root_new ['parrot';'ResizablePMCArray']
  vivify_2736:
    set $P127, $P3251[$I100]
    unless_null $P127, vivify_2737
    new $P127, "Undef"
  vivify_2737:
    $P128 = $P127."ast"()
    store_lex "$inv", $P128
.annotate 'line', 2112
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2738
    new $P125, "Undef"
  vivify_2738:
    find_lex $P127, "$inv"
    unless_null $P127, vivify_2739
    new $P127, "Undef"
  vivify_2739:
    $P125."push"($P127)
.annotate 'line', 2113
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2740
    new $P125, "Undef"
  vivify_2740:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2115
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    find_lex $P135, "$inv"
    unless_null $P135, vivify_2741
    new $P135, "Undef"
  vivify_2741:
    $P136 = $P135."name"()
    $P137 = $P134."new"("lexical" :named("scope"), $P136 :named("name"))
.annotate 'line', 2113
    $P138 = $P130."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P137 :named("viviself"))
    $P125."push"($P138)
.annotate 'line', 2117
    new $P125, "Float"
    assign $P125, 1
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3252, $P129["@BLOCK"]
    unless_null $P3252, vivify_2742
    $P3252 = root_new ['parrot';'ResizablePMCArray']
    set $P129["@BLOCK"], $P3252
  vivify_2742:
    set $P3253, $P3252[$I100]
    unless_null $P3253, vivify_2743
    $P3253 = root_new ['parrot';'Hash']
    set $P3252[$I100], $P3253
  vivify_2743:
    set $P3253["signature_has_invocant"], $P125
.annotate 'line', 2110
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3255"  :anon :subid("556_1312646121.678") :outer("554_1312646121.678")
    .param pmc param_3257
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2119
    .lex "$_", param_3257
    find_lex $P127, "$BLOCKINIT"
    unless_null $P127, vivify_2747
    new $P127, "Undef"
  vivify_2747:
    find_lex $P128, "$_"
    unless_null $P128, vivify_2748
    new $P128, "Undef"
  vivify_2748:
    $P129 = $P128."ast"()
    $P130 = $P127."push"($P129)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("557_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3260
    .param pmc param_3261
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2122
    .lex "self", param_3260
    .lex "$/", param_3261
.annotate 'line', 2123
    new $P122, "Undef"
    set $P3262, $P122
    .lex "$quant", $P3262
.annotate 'line', 2124
    new $P123, "Undef"
    set $P3263, $P123
    .lex "$past", $P3263
.annotate 'line', 2123
    find_lex $P3264, "$/"
    unless_null $P3264, vivify_2749
    $P3264 = root_new ['parrot';'Hash']
  vivify_2749:
    set $P124, $P3264["quant"]
    unless_null $P124, vivify_2750
    new $P124, "Undef"
  vivify_2750:
    store_lex "$quant", $P124
.annotate 'line', 2122
    find_lex $P124, "$past"
    unless_null $P124, vivify_2751
    new $P124, "Undef"
  vivify_2751:
.annotate 'line', 2125
    find_lex $P3266, "$/"
    unless_null $P3266, vivify_2752
    $P3266 = root_new ['parrot';'Hash']
  vivify_2752:
    set $P124, $P3266["named_param"]
    unless_null $P124, vivify_2753
    new $P124, "Undef"
  vivify_2753:
    if $P124, if_3265
.annotate 'line', 2132
    find_lex $P3272, "$/"
    unless_null $P3272, vivify_2754
    $P3272 = root_new ['parrot';'Hash']
  vivify_2754:
    set $P125, $P3272["param_var"]
    unless_null $P125, vivify_2755
    new $P125, "Undef"
  vivify_2755:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2133
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2756
    new $P125, "Undef"
  vivify_2756:
    set $S100, $P125
    iseq $I100, $S100, "*"
    if $I100, if_3273
.annotate 'line', 2137
    find_lex $P127, "$quant"
    unless_null $P127, vivify_2757
    new $P127, "Undef"
  vivify_2757:
    set $S101, $P127
    iseq $I101, $S101, "?"
    unless $I101, if_3276_end
.annotate 'line', 2138
    find_lex $P128, "$past"
    unless_null $P128, vivify_2758
    new $P128, "Undef"
  vivify_2758:
    find_lex $P3277, "$/"
    unless_null $P3277, vivify_2759
    $P3277 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P3278, $P3277["param_var"]
    unless_null $P3278, vivify_2760
    $P3278 = root_new ['parrot';'Hash']
  vivify_2760:
    set $P129, $P3278["sigil"]
    unless_null $P129, vivify_2761
    new $P129, "Undef"
  vivify_2761:
    $P130 = "vivitype"($P129)
    $P128."viviself"($P130)
  if_3276_end:
.annotate 'line', 2137
    goto if_3273_end
  if_3273:
.annotate 'line', 2134
    find_lex $P127, "$past"
    unless_null $P127, vivify_2762
    new $P127, "Undef"
  vivify_2762:
    $P127."slurpy"(1)
.annotate 'line', 2135
    find_lex $P127, "$past"
    unless_null $P127, vivify_2763
    new $P127, "Undef"
  vivify_2763:
    find_lex $P3274, "$/"
    unless_null $P3274, vivify_2764
    $P3274 = root_new ['parrot';'Hash']
  vivify_2764:
    set $P3275, $P3274["param_var"]
    unless_null $P3275, vivify_2765
    $P3275 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P128, $P3275["sigil"]
    unless_null $P128, vivify_2766
    new $P128, "Undef"
  vivify_2766:
    set $S101, $P128
    iseq $I101, $S101, "%"
    $P127."named"($I101)
  if_3273_end:
.annotate 'line', 2131
    goto if_3265_end
  if_3265:
.annotate 'line', 2126
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_2767
    $P3267 = root_new ['parrot';'Hash']
  vivify_2767:
    set $P125, $P3267["named_param"]
    unless_null $P125, vivify_2768
    new $P125, "Undef"
  vivify_2768:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2127
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2769
    new $P125, "Undef"
  vivify_2769:
    set $S100, $P125
    isne $I100, $S100, "!"
    unless $I100, if_3268_end
.annotate 'line', 2128
    find_lex $P127, "$past"
    unless_null $P127, vivify_2770
    new $P127, "Undef"
  vivify_2770:
    find_lex $P3269, "$/"
    unless_null $P3269, vivify_2771
    $P3269 = root_new ['parrot';'Hash']
  vivify_2771:
    set $P3270, $P3269["named_param"]
    unless_null $P3270, vivify_2772
    $P3270 = root_new ['parrot';'Hash']
  vivify_2772:
    set $P3271, $P3270["param_var"]
    unless_null $P3271, vivify_2773
    $P3271 = root_new ['parrot';'Hash']
  vivify_2773:
    set $P128, $P3271["sigil"]
    unless_null $P128, vivify_2774
    new $P128, "Undef"
  vivify_2774:
    $P129 = "vivitype"($P128)
    $P127."viviself"($P129)
  if_3268_end:
  if_3265_end:
.annotate 'line', 2141
    find_lex $P3280, "$/"
    unless_null $P3280, vivify_2775
    $P3280 = root_new ['parrot';'Hash']
  vivify_2775:
    set $P124, $P3280["default_value"]
    unless_null $P124, vivify_2776
    new $P124, "Undef"
  vivify_2776:
    unless $P124, if_3279_end
.annotate 'line', 2142
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2777
    new $P125, "Undef"
  vivify_2777:
    set $S100, $P125
    iseq $I100, $S100, "*"
    unless $I100, if_3281_end
.annotate 'line', 2143
    find_lex $P127, "$/"
    unless_null $P127, vivify_2778
    new $P127, "Undef"
  vivify_2778:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on slurpy parameter")
  if_3281_end:
.annotate 'line', 2145
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2779
    new $P125, "Undef"
  vivify_2779:
    set $S100, $P125
    iseq $I100, $S100, "!"
    unless $I100, if_3282_end
.annotate 'line', 2146
    find_lex $P127, "$/"
    unless_null $P127, vivify_2780
    new $P127, "Undef"
  vivify_2780:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on required parameter")
  if_3282_end:
.annotate 'line', 2148
    find_lex $P125, "$past"
    unless_null $P125, vivify_2781
    new $P125, "Undef"
  vivify_2781:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3283, "$/"
    unless_null $P3283, vivify_2782
    $P3283 = root_new ['parrot';'Hash']
  vivify_2782:
    set $P3284, $P3283["default_value"]
    unless_null $P3284, vivify_2783
    $P3284 = root_new ['parrot';'ResizablePMCArray']
  vivify_2783:
    set $P3285, $P3284[$I100]
    unless_null $P3285, vivify_2784
    $P3285 = root_new ['parrot';'Hash']
  vivify_2784:
    set $P128, $P3285["EXPR"]
    unless_null $P128, vivify_2785
    new $P128, "Undef"
  vivify_2785:
    $P129 = $P128."ast"()
    $P125."viviself"($P129)
  if_3279_end:
.annotate 'line', 2150
    find_lex $P124, "$past"
    unless_null $P124, vivify_2786
    new $P124, "Undef"
  vivify_2786:
    $P125 = $P124."viviself"()
    if $P125, unless_3286_end
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3287, $P129["@BLOCK"]
    unless_null $P3287, vivify_2787
    $P3287 = root_new ['parrot';'ResizablePMCArray']
  vivify_2787:
    set $P130, $P3287[$I100]
    unless_null $P130, vivify_2788
    new $P130, "Undef"
  vivify_2788:
    new $P131, "Float"
    assign $P131, 0
    set $I101, $P131
    find_lex $P132, "$?PACKAGE"
    get_who $P133, $P132
    set $P3288, $P133["@BLOCK"]
    unless_null $P3288, vivify_2789
    $P3288 = root_new ['parrot';'ResizablePMCArray']
  vivify_2789:
    set $P134, $P3288[$I101]
    unless_null $P134, vivify_2790
    new $P134, "Undef"
  vivify_2790:
    $P135 = $P134."arity"()
    set $N100, $P135
    new $P136, 'Float'
    set $P136, $N100
    add $P137, $P136, 1
    $P130."arity"($P137)
  unless_3286_end:
.annotate 'line', 2154
    find_lex $P3290, "$/"
    unless_null $P3290, vivify_2791
    $P3290 = root_new ['parrot';'Hash']
  vivify_2791:
    set $P124, $P3290["typename"]
    unless_null $P124, vivify_2792
    new $P124, "Undef"
  vivify_2792:
    unless $P124, if_3289_end
.annotate 'line', 2155
    find_lex $P125, "$past"
    unless_null $P125, vivify_2793
    new $P125, "Undef"
  vivify_2793:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3291, "$/"
    unless_null $P3291, vivify_2794
    $P3291 = root_new ['parrot';'Hash']
  vivify_2794:
    set $P3292, $P3291["typename"]
    unless_null $P3292, vivify_2795
    $P3292 = root_new ['parrot';'ResizablePMCArray']
  vivify_2795:
    set $P128, $P3292[$I100]
    unless_null $P128, vivify_2796
    new $P128, "Undef"
  vivify_2796:
    $P129 = $P128."ast"()
    $P125."multitype"($P129)
  if_3289_end:
.annotate 'line', 2159
    find_lex $P3294, "$/"
    unless_null $P3294, vivify_2797
    $P3294 = root_new ['parrot';'Hash']
  vivify_2797:
    set $P124, $P3294["definedness"]
    unless_null $P124, vivify_2798
    new $P124, "Undef"
  vivify_2798:
    unless $P124, if_3293_end
.annotate 'line', 2160
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3295, "$/"
    unless_null $P3295, vivify_2799
    $P3295 = root_new ['parrot';'Hash']
  vivify_2799:
    set $P3296, $P3295["definedness"]
    unless_null $P3296, vivify_2800
    $P3296 = root_new ['parrot';'ResizablePMCArray']
  vivify_2800:
    set $P127, $P3296[$I100]
    unless_null $P127, vivify_2801
    new $P127, "Undef"
  vivify_2801:
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    find_lex $P3297, "$past"
    unless_null $P3297, vivify_2802
    $P3297 = root_new ['parrot';'Hash']
    store_lex "$past", $P3297
  vivify_2802:
    set $P3297["definedness"], $P128
  if_3293_end:
.annotate 'line', 2163
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2803
    new $P125, "Undef"
  vivify_2803:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2122
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("558_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3299
    .param pmc param_3300
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2166
    .lex "self", param_3299
    .lex "$/", param_3300
.annotate 'line', 2167
    new $P122, "Undef"
    set $P3301, $P122
    .lex "$name", $P3301
.annotate 'line', 2168
    new $P123, "Undef"
    set $P3302, $P123
    .lex "$past", $P3302
.annotate 'line', 2167
    find_lex $P124, "$/"
    unless_null $P124, vivify_2804
    new $P124, "Undef"
  vivify_2804:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    store_lex "$name", $P125
.annotate 'line', 2168
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    find_lex $P129, "$name"
    unless_null $P129, vivify_2805
    new $P129, "Undef"
  vivify_2805:
    find_lex $P130, "$/"
    unless_null $P130, vivify_2806
    new $P130, "Undef"
  vivify_2806:
    $P131 = $P128."new"($P129 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P130 :named("node"))
    store_lex "$past", $P131
.annotate 'line', 2170
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P3303, $P127["@BLOCK"]
    unless_null $P3303, vivify_2807
    $P3303 = root_new ['parrot';'ResizablePMCArray']
  vivify_2807:
    set $P128, $P3303[$I100]
    unless_null $P128, vivify_2808
    new $P128, "Undef"
  vivify_2808:
    find_lex $P129, "$name"
    unless_null $P129, vivify_2809
    new $P129, "Undef"
  vivify_2809:
    $P128."symbol"($P129, "lexical" :named("scope"))
.annotate 'line', 2171
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2810
    new $P125, "Undef"
  vivify_2810:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2166
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("559_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3305
    .param pmc param_3306
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2174
    .lex "self", param_3305
    .lex "$/", param_3306
.annotate 'line', 2175
    new $P122, "Undef"
    set $P3307, $P122
    .lex "$past", $P3307
    find_lex $P3308, "$/"
    unless_null $P3308, vivify_2811
    $P3308 = root_new ['parrot';'Hash']
  vivify_2811:
    set $P123, $P3308["param_var"]
    unless_null $P123, vivify_2812
    new $P123, "Undef"
  vivify_2812:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 2176
    find_lex $P123, "$past"
    unless_null $P123, vivify_2813
    new $P123, "Undef"
  vivify_2813:
    find_lex $P3309, "$/"
    unless_null $P3309, vivify_2814
    $P3309 = root_new ['parrot';'Hash']
  vivify_2814:
    set $P3310, $P3309["param_var"]
    unless_null $P3310, vivify_2815
    $P3310 = root_new ['parrot';'Hash']
  vivify_2815:
    set $P124, $P3310["name"]
    unless_null $P124, vivify_2816
    new $P124, "Undef"
  vivify_2816:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 2177
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2817
    new $P124, "Undef"
  vivify_2817:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2174
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("560_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3312
    .param pmc param_3313
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2180
    .const 'Sub' $P3318 = "561_1312646121.678" 
    capture_lex $P3318
    .lex "self", param_3312
    .lex "$/", param_3313
.annotate 'line', 2184
    $P3315 = root_new ['parrot';'ResizablePMCArray']
    set $P3314, $P3315
    .lex "@name", $P3314
.annotate 'line', 2185
    new $P122, "Undef"
    set $P3316, $P122
    .lex "$found", $P3316
.annotate 'line', 2184
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "HLL"
    get_who $P125, $P124
    set $P127, $P125["Compiler"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_2818
    new $P128, "Undef"
  vivify_2818:
    set $S100, $P128
    $P129 = $P127."parse_name"($S100)
    store_lex "@name", $P129
.annotate 'line', 2185
    new $P123, "Float"
    assign $P123, 0
    store_lex "$found", $P123
.annotate 'line', 2186
    .const 'Sub' $P3318 = "561_1312646121.678" 
    capture_lex $P3318
    $P3318()
.annotate 'line', 2191
    find_lex $P124, "$found"
    unless_null $P124, vivify_2824
    new $P124, "Undef"
  vivify_2824:
    unless $P124, unless_3328
    set $P123, $P124
    goto unless_3328_end
  unless_3328:
.annotate 'line', 2192
    find_lex $P125, "$/"
    unless_null $P125, vivify_2825
    new $P125, "Undef"
  vivify_2825:
    $P127 = $P125."CURSOR"()
    new $P128, "String"
    assign $P128, "Use of undeclared type '"
    find_lex $P129, "$/"
    unless_null $P129, vivify_2826
    new $P129, "Undef"
  vivify_2826:
    set $S100, $P129
    concat $P130, $P128, $S100
    concat $P131, $P130, "'"
    $P132 = $P127."panic"($P131)
.annotate 'line', 2191
    set $P123, $P132
  unless_3328_end:
.annotate 'line', 2180
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3317"  :anon :subid("561_1312646121.678") :outer("560_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2186
    new $P3323, 'ExceptionHandler'
    set_label $P3323, control_3322
    $P3323."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3323
.annotate 'line', 2187
    new $P123, "Undef"
    set $P3319, $P123
    .lex "$sym", $P3319
    find_lex $P3320, "@name"
    unless_null $P3320, vivify_2819
    $P3320 = root_new ['parrot';'ResizablePMCArray']
  vivify_2819:
    find_lex $P124, "$/"
    unless_null $P124, vivify_2820
    new $P124, "Undef"
  vivify_2820:
    $P125 = "find_sym"($P3320, $P124)
    store_lex "$sym", $P125
.annotate 'line', 2188
    find_dynamic_lex $P124, "$/"
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_2821
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_2822
    die "Contextual $*SC not found"
  vivify_2822:
  vivify_2821:
    find_lex $P129, "$sym"
    unless_null $P129, vivify_2823
    new $P129, "Undef"
  vivify_2823:
    $P130 = $P128."get_object_sc_ref_past"($P129)
    $P124."!make"($P130)
.annotate 'line', 2189
    new $P124, "Float"
    assign $P124, 1
    store_lex "$found", $P124
.annotate 'line', 2186
    pop_eh 
    goto skip_handler_3321
  control_3322:
    .local pmc exception 
    .get_results (exception) 
    new $P3326, 'Integer'
    set $P3326, 1
    set exception["handled"], $P3326
    set $I3327, exception["handled"]
    ne $I3327, 1, nothandled_3325
  handled_3324:
    .return (exception)
  nothandled_3325:
    rethrow exception
  skip_handler_3321:
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("562_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3330
    .param pmc param_3331
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2196
    .lex "self", param_3330
    .lex "$/", param_3331
.annotate 'line', 2197
    find_lex $P122, "$/"
    find_lex $P3332, "$/"
    unless_null $P3332, vivify_2827
    $P3332 = root_new ['parrot';'Hash']
  vivify_2827:
    set $P123, $P3332["trait_mod"]
    unless_null $P123, vivify_2828
    new $P123, "Undef"
  vivify_2828:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2196
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("563_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3334
    .param pmc param_3335
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2200
    .const 'Sub' $P3354 = "566_1312646121.678" 
    capture_lex $P3354
    .const 'Sub' $P3339 = "564_1312646121.678" 
    capture_lex $P3339
    .lex "self", param_3334
    .lex "$/", param_3335
.annotate 'line', 2201
    find_lex $P3337, "$/"
    unless_null $P3337, vivify_2829
    $P3337 = root_new ['parrot';'Hash']
  vivify_2829:
    set $P123, $P3337["longname"]
    unless_null $P123, vivify_2830
    new $P123, "Undef"
  vivify_2830:
    set $S100, $P123
    iseq $I100, $S100, "parrot_vtable"
    if $I100, if_3336
.annotate 'line', 2214
    find_lex $P3352, "$/"
    unless_null $P3352, vivify_2831
    $P3352 = root_new ['parrot';'Hash']
  vivify_2831:
    set $P132, $P3352["longname"]
    unless_null $P132, vivify_2832
    new $P132, "Undef"
  vivify_2832:
    set $S101, $P132
    iseq $I101, $S101, "parrot_vtable_handler"
    if $I101, if_3351
.annotate 'line', 2225
    find_lex $P3367, "$/"
    unless_null $P3367, vivify_2833
    $P3367 = root_new ['parrot';'Hash']
  vivify_2833:
    set $P139, $P3367["longname"]
    unless_null $P139, vivify_2834
    new $P139, "Undef"
  vivify_2834:
    set $S102, $P139
    iseq $I102, $S102, "pirflags"
    if $I102, if_3366
.annotate 'line', 2229
    find_lex $P140, "$/"
    unless_null $P140, vivify_2835
    new $P140, "Undef"
  vivify_2835:
    $P141 = $P140."CURSOR"()
    new $P143, 'String'
    set $P143, "Trait '"
    find_lex $P3368, "$/"
    unless_null $P3368, vivify_2836
    $P3368 = root_new ['parrot';'Hash']
  vivify_2836:
    set $P144, $P3368["longname"]
    unless_null $P144, vivify_2837
    new $P144, "Undef"
  vivify_2837:
    concat $P145, $P143, $P144
    concat $P146, $P145, "' not implemented"
    $P147 = $P141."panic"($P146)
.annotate 'line', 2228
    set $P138, $P147
.annotate 'line', 2225
    goto if_3366_end
  if_3366:
.annotate 'line', 2226
    find_lex $P140, "$/"
    unless_null $P140, vivify_2838
    new $P140, "Undef"
  vivify_2838:
    $P141 = $P140."CURSOR"()
    $P142 = $P141."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2225
    set $P138, $P142
  if_3366_end:
    set $P131, $P138
.annotate 'line', 2214
    goto if_3351_end
  if_3351:
    .const 'Sub' $P3354 = "566_1312646121.678" 
    capture_lex $P3354
    $P136 = $P3354()
    set $P131, $P136
  if_3351_end:
    set $P122, $P131
.annotate 'line', 2201
    goto if_3336_end
  if_3336:
    .const 'Sub' $P3339 = "564_1312646121.678" 
    capture_lex $P3339
    $P129 = $P3339()
    set $P122, $P129
  if_3336_end:
.annotate 'line', 2200
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3353"  :anon :subid("566_1312646121.678") :outer("563_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2214
    .const 'Sub' $P3362 = "567_1312646121.678" 
    capture_lex $P3362
.annotate 'line', 2216
    new $P133, "Undef"
    set $P3355, $P133
    .lex "$cpast", $P3355
.annotate 'line', 2219
    new $P134, "Undef"
    set $P3356, $P134
    .lex "$name", $P3356
.annotate 'line', 2220
    new $P135, "Undef"
    set $P3357, $P135
    .lex "$package", $P3357
.annotate 'line', 2216
    new $P136, "Float"
    assign $P136, 0
    set $I102, $P136
    find_lex $P3358, "$/"
    unless_null $P3358, vivify_2839
    $P3358 = root_new ['parrot';'Hash']
  vivify_2839:
    set $P3359, $P3358["circumfix"]
    unless_null $P3359, vivify_2840
    $P3359 = root_new ['parrot';'ResizablePMCArray']
  vivify_2840:
    set $P137, $P3359[$I102]
    unless_null $P137, vivify_2841
    new $P137, "Undef"
  vivify_2841:
    $P138 = $P137."ast"()
    store_lex "$cpast", $P138
.annotate 'line', 2218
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Val"]
    find_lex $P140, "$cpast"
    unless_null $P140, vivify_2842
    new $P140, "Undef"
  vivify_2842:
    $P141 = $P139."ACCEPTS"($P140)
    if $P141, unless_3360_end
.annotate 'line', 2217
    find_lex $P142, "$/"
    unless_null $P142, vivify_2843
    new $P142, "Undef"
  vivify_2843:
    $P143 = $P142."CURSOR"()
    $P143."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_3360_end:
.annotate 'line', 2219
    find_lex $P136, "$cpast"
    unless_null $P136, vivify_2844
    new $P136, "Undef"
  vivify_2844:
    $P137 = $P136."value"()
    store_lex "$name", $P137
.annotate 'line', 2220
    find_dynamic_lex $P138, "$*PACKAGE"
    unless_null $P138, vivify_2845
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PACKAGE"]
    unless_null $P138, vivify_2846
    die "Contextual $*PACKAGE not found"
  vivify_2846:
  vivify_2845:
    store_lex "$package", $P138
.annotate 'line', 2221
    find_dynamic_lex $P136, "$/"
    .const 'Sub' $P3362 = "567_1312646121.678" 
    newclosure $P3365, $P3362
    $P137 = $P136."!make"($P3365)
.annotate 'line', 2214
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3361"  :anon :subid("567_1312646121.678") :outer("566_1312646121.678")
    .param pmc param_3363
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2221
    .lex "$match", param_3363
.annotate 'line', 2222
    find_dynamic_lex $P139, "$*SC"
    unless_null $P139, vivify_2847
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SC"]
    unless_null $P139, vivify_2848
    die "Contextual $*SC not found"
  vivify_2848:
  vivify_2847:
    find_lex $P140, "$package"
    unless_null $P140, vivify_2849
    new $P140, "Undef"
  vivify_2849:
    find_lex $P141, "$name"
    unless_null $P141, vivify_2850
    new $P141, "Undef"
  vivify_2850:
    find_lex $P3364, "$match"
    unless_null $P3364, vivify_2851
    $P3364 = root_new ['parrot';'Hash']
  vivify_2851:
    set $P142, $P3364["variable"]
    unless_null $P142, vivify_2852
    new $P142, "Undef"
  vivify_2852:
    set $S102, $P142
    $P143 = $P139."pkg_add_parrot_vtable_handler_mapping"($P140, $P141, $S102)
.annotate 'line', 2221
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3338"  :anon :subid("564_1312646121.678") :outer("563_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2201
    .const 'Sub' $P3348 = "565_1312646121.678" 
    capture_lex $P3348
.annotate 'line', 2203
    new $P124, "Undef"
    set $P3340, $P124
    .lex "$cpast", $P3340
.annotate 'line', 2206
    new $P125, "Undef"
    set $P3341, $P125
    .lex "$name", $P3341
.annotate 'line', 2207
    new $P127, "Undef"
    set $P3342, $P127
    .lex "$package", $P3342
.annotate 'line', 2208
    new $P128, "Undef"
    set $P3343, $P128
    .lex "$is_dispatcher", $P3343
.annotate 'line', 2203
    new $P129, "Float"
    assign $P129, 0
    set $I101, $P129
    find_lex $P3344, "$/"
    unless_null $P3344, vivify_2853
    $P3344 = root_new ['parrot';'Hash']
  vivify_2853:
    set $P3345, $P3344["circumfix"]
    unless_null $P3345, vivify_2854
    $P3345 = root_new ['parrot';'ResizablePMCArray']
  vivify_2854:
    set $P130, $P3345[$I101]
    unless_null $P130, vivify_2855
    new $P130, "Undef"
  vivify_2855:
    $P131 = $P130."ast"()
    store_lex "$cpast", $P131
.annotate 'line', 2205
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    find_lex $P133, "$cpast"
    unless_null $P133, vivify_2856
    new $P133, "Undef"
  vivify_2856:
    $P134 = $P132."ACCEPTS"($P133)
    if $P134, unless_3346_end
.annotate 'line', 2204
    find_lex $P135, "$/"
    unless_null $P135, vivify_2857
    new $P135, "Undef"
  vivify_2857:
    $P136 = $P135."CURSOR"()
    $P136."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_3346_end:
.annotate 'line', 2206
    find_lex $P129, "$cpast"
    unless_null $P129, vivify_2858
    new $P129, "Undef"
  vivify_2858:
    $P130 = $P129."value"()
    store_lex "$name", $P130
.annotate 'line', 2207
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2859
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2860
    die "Contextual $*PACKAGE not found"
  vivify_2860:
  vivify_2859:
    store_lex "$package", $P131
.annotate 'line', 2208
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2861
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2862
    die "Contextual $*SCOPE not found"
  vivify_2862:
  vivify_2861:
    set $S101, $P131
    iseq $I101, $S101, "proto"
    new $P132, 'Integer'
    set $P132, $I101
    store_lex "$is_dispatcher", $P132
.annotate 'line', 2209
    find_dynamic_lex $P129, "$/"
    .const 'Sub' $P3348 = "565_1312646121.678" 
    newclosure $P3350, $P3348
    $P130 = $P129."!make"($P3350)
.annotate 'line', 2201
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3347"  :anon :subid("565_1312646121.678") :outer("564_1312646121.678")
    .param pmc param_3349
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2209
    .lex "$match", param_3349
.annotate 'line', 2210
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2863
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2864
    die "Contextual $*SC not found"
  vivify_2864:
  vivify_2863:
    find_lex $P133, "$package"
    unless_null $P133, vivify_2865
    new $P133, "Undef"
  vivify_2865:
    find_lex $P134, "$name"
    unless_null $P134, vivify_2866
    new $P134, "Undef"
  vivify_2866:
.annotate 'line', 2211
    find_lex $P135, "$match"
    unless_null $P135, vivify_2867
    new $P135, "Undef"
  vivify_2867:
    $P136 = $P135."ast"()
    set $P137, $P136["block_past"]
    unless_null $P137, vivify_2868
    new $P137, "Undef"
  vivify_2868:
.annotate 'line', 2210
    find_lex $P138, "$is_dispatcher"
    unless_null $P138, vivify_2869
    new $P138, "Undef"
  vivify_2869:
    $P139 = $P132."pkg_add_method"($P133, "add_parrot_vtable_mapping", $P134, $P137, $P138)
.annotate 'line', 2209
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("568_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3372
    .param pmc param_3373
    .param pmc param_3374 :optional
    .param int has_param_3374 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2233
    .const 'Sub' $P3405 = "571_1312646121.678" 
    capture_lex $P3405
    .const 'Sub' $P3389 = "570_1312646121.678" 
    capture_lex $P3389
    .const 'Sub' $P3384 = "569_1312646121.678" 
    capture_lex $P3384
    new $P3371, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3371, control_3370
    push_eh $P3371
    .lex "self", param_3372
    .lex "$/", param_3373
    if has_param_3374, optparam_2870
    new $P122, "Undef"
    set param_3374, $P122
  optparam_2870:
    .lex "$key", param_3374
.annotate 'line', 2234
    $P3376 = root_new ['parrot';'ResizablePMCArray']
    set $P3375, $P3376
    .lex "@MODIFIERS", $P3375
.annotate 'line', 2235
    new $P123, "Undef"
    set $P3377, $P123
    .lex "$name", $P3377
.annotate 'line', 2236
    new $P124, "Undef"
    set $P3378, $P124
    .lex "$past", $P3378
.annotate 'line', 2234
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P3379, $P130["@MODIFIERS"]
    unless_null $P3379, vivify_2871
    $P3379 = root_new ['parrot';'ResizablePMCArray']
  vivify_2871:
    store_lex "@MODIFIERS", $P3379
.annotate 'line', 2235
    find_lex $P3380, "$/"
    unless_null $P3380, vivify_2872
    $P3380 = root_new ['parrot';'Hash']
  vivify_2872:
    set $P125, $P3380["deflongname"]
    unless_null $P125, vivify_2873
    new $P125, "Undef"
  vivify_2873:
    $P127 = $P125."ast"()
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    store_lex "$name", $P128
.annotate 'line', 2233
    find_lex $P125, "$past"
    unless_null $P125, vivify_2874
    new $P125, "Undef"
  vivify_2874:
.annotate 'line', 2237
    find_lex $P3382, "$/"
    unless_null $P3382, vivify_2875
    $P3382 = root_new ['parrot';'Hash']
  vivify_2875:
    set $P125, $P3382["proto"]
    unless_null $P125, vivify_2876
    new $P125, "Undef"
  vivify_2876:
    if $P125, if_3381
.annotate 'line', 2267
    find_lex $P127, "$key"
    unless_null $P127, vivify_2877
    new $P127, "Undef"
  vivify_2877:
    set $S100, $P127
    iseq $I100, $S100, "open"
    if $I100, if_3387
.annotate 'line', 2277
    .const 'Sub' $P3405 = "571_1312646121.678" 
    capture_lex $P3405
    $P3405()
    goto if_3387_end
  if_3387:
.annotate 'line', 2267
    .const 'Sub' $P3389 = "570_1312646121.678" 
    capture_lex $P3389
    $P3389()
  if_3387_end:
    goto if_3381_end
  if_3381:
.annotate 'line', 2239
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Stmts"]
.annotate 'line', 2240
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Block"]
    find_lex $P135, "$name"
    unless_null $P135, vivify_2927
    new $P135, "Undef"
  vivify_2927:
.annotate 'line', 2241
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
.annotate 'line', 2242
    get_hll_global $P140, "GLOBAL"
    nqp_get_package_through_who $P141, $P140, "PAST"
    get_who $P142, $P141
    set $P143, $P142["Var"]
    $P144 = $P143."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P145, "$name"
    unless_null $P145, vivify_2928
    new $P145, "Undef"
  vivify_2928:
    $P146 = $P139."new"($P144, $P145, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2241
    find_lex $P147, "$/"
    unless_null $P147, vivify_2929
    new $P147, "Undef"
  vivify_2929:
    $P148 = $P134."new"($P146, $P135 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P147 :named("node"))
.annotate 'line', 2251
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Block"]
    new $P154, "String"
    assign $P154, "!PREFIX__"
    find_lex $P155, "$name"
    unless_null $P155, vivify_2930
    new $P155, "Undef"
  vivify_2930:
    concat $P156, $P154, $P155
.annotate 'line', 2252
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 2253
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Var"]
    $P165 = $P164."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P166, "$name"
    unless_null $P166, vivify_2931
    new $P166, "Undef"
  vivify_2931:
    $P167 = $P160."new"($P165, $P166, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2252
    find_lex $P168, "$/"
    unless_null $P168, vivify_2932
    new $P168, "Undef"
  vivify_2932:
    $P169 = $P153."new"($P167, $P156 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P168 :named("node"))
.annotate 'line', 2251
    $P170 = $P130."new"($P148, $P169)
.annotate 'line', 2239
    store_lex "$past", $P170
.annotate 'line', 2263
    find_lex $P128, "$past"
    unless_null $P128, vivify_2933
    new $P128, "Undef"
  vivify_2933:
    $P129 = $P128."list"()
    defined $I100, $P129
    unless $I100, for_undef_2934
    iter $P127, $P129
    new $P131, 'ExceptionHandler'
    set_label $P131, loop3386_handler
    $P131."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P131
  loop3386_test:
    unless $P127, loop3386_done
    shift $P130, $P127
  loop3386_redo:
    .const 'Sub' $P3384 = "569_1312646121.678" 
    capture_lex $P3384
    $P3384($P130)
  loop3386_next:
    goto loop3386_test
  loop3386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P132, exception, 'type'
    eq $P132, .CONTROL_LOOP_NEXT, loop3386_next
    eq $P132, .CONTROL_LOOP_REDO, loop3386_redo
  loop3386_done:
    pop_eh 
  for_undef_2934:
  if_3381_end:
.annotate 'line', 2308
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_2941
    new $P127, "Undef"
  vivify_2941:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2233
    .return ($P128)
  control_3370:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3404"  :anon :subid("571_1312646121.678") :outer("568_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2277
    .const 'Sub' $P3413 = "572_1312646121.678" 
    capture_lex $P3413
.annotate 'line', 2278
    new $P128, "Undef"
    set $P3406, $P128
    .lex "$regex", $P3406
.annotate 'line', 2281
    new $P129, "Undef"
    set $P3407, $P129
    .lex "$prefix_meth", $P3407
.annotate 'line', 2279
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "Regex"
    nqp_get_package_through_who $P132, $P131, "P6Regex"
    nqp_get_package_through_who $P133, $P132, "Actions"
    get_who $P134, $P133
    set $P135, $P134["buildsub"]
    find_lex $P3408, "$/"
    unless_null $P3408, vivify_2878
    $P3408 = root_new ['parrot';'Hash']
  vivify_2878:
    set $P136, $P3408["p6regex"]
    unless_null $P136, vivify_2879
    new $P136, "Undef"
  vivify_2879:
    $P137 = $P136."ast"()
    find_lex $P138, "$?PACKAGE"
    get_who $P139, $P138
    set $P3409, $P139["@BLOCK"]
    unless_null $P3409, vivify_2880
    $P3409 = root_new ['parrot';'ResizablePMCArray']
  vivify_2880:
    $P140 = $P3409."shift"()
    $P141 = $P135($P137, $P140)
    store_lex "$regex", $P141
.annotate 'line', 2280
    find_lex $P130, "$regex"
    unless_null $P130, vivify_2881
    new $P130, "Undef"
  vivify_2881:
    find_lex $P131, "$name"
    unless_null $P131, vivify_2882
    new $P131, "Undef"
  vivify_2882:
    $P130."name"($P131)
.annotate 'line', 2277
    find_lex $P130, "$prefix_meth"
    unless_null $P130, vivify_2883
    new $P130, "Undef"
  vivify_2883:
.annotate 'line', 2283
    find_dynamic_lex $P133, "$*PKGDECL"
    unless_null $P133, vivify_2884
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PKGDECL"]
    unless_null $P133, vivify_2885
    die "Contextual $*PKGDECL not found"
  vivify_2885:
  vivify_2884:
    if $P133, if_3411
    set $P130, $P133
    goto if_3411_end
  if_3411:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2886
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2887
    die "Contextual $*PACKAGE not found"
  vivify_2887:
  vivify_2886:
    get_how $P137, $P136
    can $I101, $P137, "add_method"
    new $P130, 'Integer'
    set $P130, $I101
  if_3411_end:
    unless $P130, if_3410_end
    .const 'Sub' $P3413 = "572_1312646121.678" 
    capture_lex $P3413
    $P3413()
  if_3410_end:
.annotate 'line', 2298
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 2300
    new $P134, "ResizablePMCArray"
    push $P134, "Regex"
    push $P134, "Method"
    find_lex $P135, "$/"
    unless_null $P135, vivify_2904
    new $P135, "Undef"
  vivify_2904:
    $P136 = "lexical_package_lookup"($P134, $P135)
    find_lex $P137, "$regex"
    unless_null $P137, vivify_2905
    new $P137, "Undef"
  vivify_2905:
    $P138 = $P133."new"($P136, $P137, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2298
    store_lex "$past", $P138
.annotate 'line', 2303
    find_lex $P131, "$prefix_meth"
    unless_null $P131, vivify_2906
    new $P131, "Undef"
  vivify_2906:
    if $P131, if_3418
    find_lex $P139, "$regex"
    unless_null $P139, vivify_2907
    new $P139, "Undef"
  vivify_2907:
    set $P130, $P139
    goto if_3418_end
  if_3418:
.annotate 'line', 2304
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Stmts"]
    find_lex $P136, "$regex"
    unless_null $P136, vivify_2908
    new $P136, "Undef"
  vivify_2908:
    find_lex $P137, "$prefix_meth"
    unless_null $P137, vivify_2909
    new $P137, "Undef"
  vivify_2909:
    $P138 = $P135."new"($P136, $P137)
    set $P130, $P138
  if_3418_end:
.annotate 'line', 2303
    find_lex $P3419, "$past"
    unless_null $P3419, vivify_2910
    $P3419 = root_new ['parrot';'Hash']
    store_lex "$past", $P3419
  vivify_2910:
    set $P3419["sink"], $P130
.annotate 'line', 2306
    find_lex $P3420, "@MODIFIERS"
    unless_null $P3420, vivify_2911
    $P3420 = root_new ['parrot';'ResizablePMCArray']
  vivify_2911:
    $P130 = $P3420."shift"()
.annotate 'line', 2277
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3412"  :anon :subid("572_1312646121.678") :outer("571_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2288
    $P3415 = root_new ['parrot';'ResizablePMCArray']
    set $P3414, $P3415
    .lex "@prefixes", $P3414
.annotate 'line', 2285
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_2888
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_2889
    die "Contextual $*SC not found"
  vivify_2889:
  vivify_2888:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2890
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2891
    die "Contextual $*PACKAGE not found"
  vivify_2891:
  vivify_2890:
    find_lex $P144, "$name"
    unless_null $P144, vivify_2892
    new $P144, "Undef"
  vivify_2892:
    find_lex $P145, "$regex"
    unless_null $P145, vivify_2893
    new $P145, "Undef"
  vivify_2893:
    $P140."pkg_add_method"($P143, "add_method", $P144, $P145, 0)
.annotate 'line', 2288
    find_lex $P3416, "$/"
    unless_null $P3416, vivify_2894
    $P3416 = root_new ['parrot';'Hash']
  vivify_2894:
    set $P138, $P3416["p6regex"]
    unless_null $P138, vivify_2895
    new $P138, "Undef"
  vivify_2895:
    $P139 = $P138."ast"()
    $P140 = $P139."prefix_list"()
    store_lex "@prefixes", $P140
.annotate 'line', 2289
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Block"]
.annotate 'line', 2290
    new $P142, "String"
    assign $P142, "!PREFIX__"
    find_lex $P143, "$name"
    unless_null $P143, vivify_2896
    new $P143, "Undef"
  vivify_2896:
    concat $P144, $P142, $P143
.annotate 'line', 2291
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    find_lex $P3417, "@prefixes"
    unless_null $P3417, vivify_2897
    $P3417 = root_new ['parrot';'ResizablePMCArray']
  vivify_2897:
    $P149 = $P148."new"($P3417 :flat, "list" :named("pasttype"))
    $P151 = $P141."new"($P149, $P144 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2289
    store_lex "$prefix_meth", $P151
.annotate 'line', 2293
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_2898
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_2899
    die "Contextual $*SC not found"
  vivify_2899:
  vivify_2898:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2900
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2901
    die "Contextual $*PACKAGE not found"
  vivify_2901:
  vivify_2900:
    find_lex $P144, "$prefix_meth"
    unless_null $P144, vivify_2902
    new $P144, "Undef"
  vivify_2902:
    $P145 = $P144."name"()
    find_lex $P146, "$prefix_meth"
    unless_null $P146, vivify_2903
    new $P146, "Undef"
  vivify_2903:
    $P147 = $P140."pkg_add_method"($P143, "add_method", $P145, $P146, 0)
.annotate 'line', 2283
    .return ($P147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3388"  :anon :subid("570_1312646121.678") :outer("568_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2268
    $P3391 = root_new ['parrot';'Hash']
    set $P3390, $P3391
    .lex "%h", $P3390
.annotate 'line', 2267
    find_lex $P3392, "%h"
    unless_null $P3392, vivify_2912
    $P3392 = root_new ['parrot';'Hash']
  vivify_2912:
.annotate 'line', 2269
    find_lex $P3394, "$/"
    unless_null $P3394, vivify_2913
    $P3394 = root_new ['parrot';'Hash']
  vivify_2913:
    set $P128, $P3394["sym"]
    unless_null $P128, vivify_2914
    new $P128, "Undef"
  vivify_2914:
    set $S101, $P128
    iseq $I101, $S101, "token"
    unless $I101, if_3393_end
    new $P129, "Float"
    assign $P129, 1
    find_lex $P3395, "%h"
    unless_null $P3395, vivify_2915
    $P3395 = root_new ['parrot';'Hash']
    store_lex "%h", $P3395
  vivify_2915:
    set $P3395["r"], $P129
  if_3393_end:
.annotate 'line', 2270
    find_lex $P3397, "$/"
    unless_null $P3397, vivify_2916
    $P3397 = root_new ['parrot';'Hash']
  vivify_2916:
    set $P128, $P3397["sym"]
    unless_null $P128, vivify_2917
    new $P128, "Undef"
  vivify_2917:
    set $S101, $P128
    iseq $I101, $S101, "rule"
    unless $I101, if_3396_end
    new $P129, "Float"
    assign $P129, 1
    find_lex $P3398, "%h"
    unless_null $P3398, vivify_2918
    $P3398 = root_new ['parrot';'Hash']
    store_lex "%h", $P3398
  vivify_2918:
    set $P3398["r"], $P129
    new $P129, "Float"
    assign $P129, 1
    find_lex $P3399, "%h"
    unless_null $P3399, vivify_2919
    $P3399 = root_new ['parrot';'Hash']
    store_lex "%h", $P3399
  vivify_2919:
    set $P3399["s"], $P129
  if_3396_end:
.annotate 'line', 2271
    find_lex $P3400, "@MODIFIERS"
    unless_null $P3400, vivify_2920
    $P3400 = root_new ['parrot';'ResizablePMCArray']
  vivify_2920:
    find_lex $P3401, "%h"
    unless_null $P3401, vivify_2921
    $P3401 = root_new ['parrot';'Hash']
  vivify_2921:
    $P3400."unshift"($P3401)
.annotate 'line', 2272
    find_lex $P128, "$name"
    unless_null $P128, vivify_2922
    new $P128, "Undef"
  vivify_2922:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "Regex"
    nqp_get_package_through_who $P131, $P130, "P6Regex"
    nqp_get_package_through_who $P132, $P131, "Actions"
    get_who $P133, $P132
    set $P133["$REGEXNAME"], $P128
.annotate 'line', 2273
    new $P128, "Float"
    assign $P128, 0
    set $I101, $P128
    find_lex $P129, "$?PACKAGE"
    get_who $P130, $P129
    set $P3402, $P130["@BLOCK"]
    unless_null $P3402, vivify_2923
    $P3402 = root_new ['parrot';'ResizablePMCArray']
  vivify_2923:
    set $P131, $P3402[$I101]
    unless_null $P131, vivify_2924
    new $P131, "Undef"
  vivify_2924:
    $P131."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2274
    new $P128, "Float"
    assign $P128, 0
    set $I101, $P128
    find_lex $P129, "$?PACKAGE"
    get_who $P130, $P129
    set $P3403, $P130["@BLOCK"]
    unless_null $P3403, vivify_2925
    $P3403 = root_new ['parrot';'ResizablePMCArray']
  vivify_2925:
    set $P131, $P3403[$I101]
    unless_null $P131, vivify_2926
    new $P131, "Undef"
  vivify_2926:
    $P131."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2275
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    new $P129, "Float"
    assign $P129, 0
    setattribute $P128, 'payload', $P129
    throw $P128
.annotate 'line', 2267
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3383"  :anon :subid("569_1312646121.678") :outer("568_1312646121.678")
    .param pmc param_3385
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2263
    .lex "$_", param_3385
.annotate 'line', 2264
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2935
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2936
    die "Contextual $*SC not found"
  vivify_2936:
  vivify_2935:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2937
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2938
    die "Contextual $*PACKAGE not found"
  vivify_2938:
  vivify_2937:
    find_lex $P137, "$_"
    unless_null $P137, vivify_2939
    new $P137, "Undef"
  vivify_2939:
    $P138 = $P137."name"()
    find_lex $P139, "$_"
    unless_null $P139, vivify_2940
    new $P139, "Undef"
  vivify_2940:
    $P140 = $P133."pkg_add_method"($P136, "add_method", $P138, $P139, 0)
.annotate 'line', 2263
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("573_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3422
    .param pmc param_3423
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2312
    .lex "self", param_3422
    .lex "$/", param_3423
.annotate 'line', 2313
    new $P122, "Undef"
    set $P3424, $P122
    .lex "$past", $P3424
    find_lex $P3426, "$/"
    unless_null $P3426, vivify_2942
    $P3426 = root_new ['parrot';'Hash']
  vivify_2942:
    set $P124, $P3426["args"]
    unless_null $P124, vivify_2943
    new $P124, "Undef"
  vivify_2943:
    if $P124, if_3425
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P133, "$/"
    unless_null $P133, vivify_2944
    new $P133, "Undef"
  vivify_2944:
    $P134 = $P132."new"($P133 :named("node"))
    set $P123, $P134
    goto if_3425_end
  if_3425:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3427, "$/"
    unless_null $P3427, vivify_2945
    $P3427 = root_new ['parrot';'Hash']
  vivify_2945:
    set $P3428, $P3427["args"]
    unless_null $P3428, vivify_2946
    $P3428 = root_new ['parrot';'ResizablePMCArray']
  vivify_2946:
    set $P127, $P3428[$I100]
    unless_null $P127, vivify_2947
    new $P127, "Undef"
  vivify_2947:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_3425_end:
    store_lex "$past", $P123
.annotate 'line', 2314
    find_lex $P3430, "$/"
    unless_null $P3430, vivify_2948
    $P3430 = root_new ['parrot';'Hash']
  vivify_2948:
    set $P123, $P3430["quote"]
    unless_null $P123, vivify_2949
    new $P123, "Undef"
  vivify_2949:
    if $P123, if_3429
.annotate 'line', 2318
    find_lex $P3433, "$/"
    unless_null $P3433, vivify_2950
    $P3433 = root_new ['parrot';'Hash']
  vivify_2950:
    set $P124, $P3433["longname"]
    unless_null $P124, vivify_2951
    new $P124, "Undef"
  vivify_2951:
    set $S100, $P124
    iseq $I100, $S100, "HOW"
    if $I100, if_3432
.annotate 'line', 2321
    find_lex $P3435, "$/"
    unless_null $P3435, vivify_2952
    $P3435 = root_new ['parrot';'Hash']
  vivify_2952:
    set $P125, $P3435["longname"]
    unless_null $P125, vivify_2953
    new $P125, "Undef"
  vivify_2953:
    set $S101, $P125
    iseq $I101, $S101, "WHAT"
    if $I101, if_3434
.annotate 'line', 2324
    find_lex $P3437, "$/"
    unless_null $P3437, vivify_2954
    $P3437 = root_new ['parrot';'Hash']
  vivify_2954:
    set $P127, $P3437["longname"]
    unless_null $P127, vivify_2955
    new $P127, "Undef"
  vivify_2955:
    set $S102, $P127
    iseq $I102, $S102, "WHO"
    if $I102, if_3436
.annotate 'line', 2328
    find_lex $P128, "$past"
    unless_null $P128, vivify_2956
    new $P128, "Undef"
  vivify_2956:
    find_lex $P3438, "$/"
    unless_null $P3438, vivify_2957
    $P3438 = root_new ['parrot';'Hash']
  vivify_2957:
    set $P129, $P3438["longname"]
    unless_null $P129, vivify_2958
    new $P129, "Undef"
  vivify_2958:
    set $S103, $P129
    $P128."name"($S103)
.annotate 'line', 2329
    find_lex $P128, "$past"
    unless_null $P128, vivify_2959
    new $P128, "Undef"
  vivify_2959:
    $P128."pasttype"("callmethod")
.annotate 'line', 2327
    goto if_3436_end
  if_3436:
.annotate 'line', 2325
    find_lex $P128, "$past"
    unless_null $P128, vivify_2960
    new $P128, "Undef"
  vivify_2960:
    $P128."pirop"("get_who PP")
  if_3436_end:
.annotate 'line', 2324
    goto if_3434_end
  if_3434:
.annotate 'line', 2322
    find_lex $P127, "$past"
    unless_null $P127, vivify_2961
    new $P127, "Undef"
  vivify_2961:
    $P127."pirop"("get_what PP")
  if_3434_end:
.annotate 'line', 2321
    goto if_3432_end
  if_3432:
.annotate 'line', 2319
    find_lex $P125, "$past"
    unless_null $P125, vivify_2962
    new $P125, "Undef"
  vivify_2962:
    $P125."pirop"("get_how PP")
  if_3432_end:
.annotate 'line', 2318
    goto if_3429_end
  if_3429:
.annotate 'line', 2315
    find_lex $P124, "$past"
    unless_null $P124, vivify_2963
    new $P124, "Undef"
  vivify_2963:
    find_lex $P3431, "$/"
    unless_null $P3431, vivify_2964
    $P3431 = root_new ['parrot';'Hash']
  vivify_2964:
    set $P125, $P3431["quote"]
    unless_null $P125, vivify_2965
    new $P125, "Undef"
  vivify_2965:
    $P127 = $P125."ast"()
    $P124."name"($P127)
.annotate 'line', 2316
    find_lex $P124, "$past"
    unless_null $P124, vivify_2966
    new $P124, "Undef"
  vivify_2966:
    $P124."pasttype"("callmethod")
  if_3429_end:
.annotate 'line', 2331
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2967
    new $P124, "Undef"
  vivify_2967:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2312
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("574_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3440
    .param pmc param_3441
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2336
    .lex "self", param_3440
    .lex "$/", param_3441
.annotate 'line', 2337
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    $P128 = $P127."new"("self" :named("name"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2336
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("575_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3443
    .param pmc param_3444
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2340
    .lex "self", param_3443
    .lex "$/", param_3444
.annotate 'line', 2341
    new $P122, "Undef"
    set $P3445, $P122
    .lex "$past", $P3445
    find_lex $P3446, "$/"
    unless_null $P3446, vivify_2968
    $P3446 = root_new ['parrot';'Hash']
  vivify_2968:
    set $P123, $P3446["args"]
    unless_null $P123, vivify_2969
    new $P123, "Undef"
  vivify_2969:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 2342
    find_lex $P123, "$past"
    unless_null $P123, vivify_2970
    new $P123, "Undef"
  vivify_2970:
    find_lex $P3447, "$/"
    unless_null $P3447, vivify_2971
    $P3447 = root_new ['parrot';'Hash']
  vivify_2971:
    set $P124, $P3447["deflongname"]
    unless_null $P124, vivify_2972
    new $P124, "Undef"
  vivify_2972:
    set $S100, $P124
    $P123."name"($S100)
.annotate 'line', 2343
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2973
    new $P124, "Undef"
  vivify_2973:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2340
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("576_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3449
    .param pmc param_3450
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2346
    .const 'Sub' $P3457 = "577_1312646121.678" 
    capture_lex $P3457
    .lex "self", param_3449
    .lex "$/", param_3450
.annotate 'line', 2348
    new $P122, "Undef"
    set $P3451, $P122
    .lex "$var", $P3451
.annotate 'line', 2358
    new $P123, "Undef"
    set $P3452, $P123
    .lex "$past", $P3452
.annotate 'line', 2346
    find_lex $P124, "$var"
    unless_null $P124, vivify_2974
    new $P124, "Undef"
  vivify_2974:
.annotate 'line', 2349
    find_lex $P3454, "$/"
    unless_null $P3454, vivify_2975
    $P3454 = root_new ['parrot';'Hash']
  vivify_2975:
    set $P124, $P3454["name"]
    unless_null $P124, vivify_2976
    new $P124, "Undef"
  vivify_2976:
    set $S100, $P124
    $P125 = "is_lexical"($S100)
    if $P125, if_3453
.annotate 'line', 2352
    .const 'Sub' $P3457 = "577_1312646121.678" 
    capture_lex $P3457
    $P3457()
    goto if_3453_end
  if_3453:
.annotate 'line', 2350
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    find_lex $P3455, "$/"
    unless_null $P3455, vivify_2982
    $P3455 = root_new ['parrot';'Hash']
  vivify_2982:
    set $P131, $P3455["name"]
    unless_null $P131, vivify_2983
    new $P131, "Undef"
  vivify_2983:
    set $S101, $P131
    $P132 = $P130."new"($S101 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P132
  if_3453_end:
.annotate 'line', 2358
    find_lex $P124, "$var"
    unless_null $P124, vivify_2984
    new $P124, "Undef"
  vivify_2984:
    store_lex "$past", $P124
.annotate 'line', 2359
    find_lex $P3464, "$/"
    unless_null $P3464, vivify_2985
    $P3464 = root_new ['parrot';'Hash']
  vivify_2985:
    set $P124, $P3464["args"]
    unless_null $P124, vivify_2986
    new $P124, "Undef"
  vivify_2986:
    unless $P124, if_3463_end
.annotate 'line', 2360
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3465, "$/"
    unless_null $P3465, vivify_2987
    $P3465 = root_new ['parrot';'Hash']
  vivify_2987:
    set $P3466, $P3465["args"]
    unless_null $P3466, vivify_2988
    $P3466 = root_new ['parrot';'ResizablePMCArray']
  vivify_2988:
    set $P127, $P3466[$I100]
    unless_null $P127, vivify_2989
    new $P127, "Undef"
  vivify_2989:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 2361
    find_lex $P125, "$past"
    unless_null $P125, vivify_2990
    new $P125, "Undef"
  vivify_2990:
    find_lex $P127, "$var"
    unless_null $P127, vivify_2991
    new $P127, "Undef"
  vivify_2991:
    $P125."unshift"($P127)
  if_3463_end:
.annotate 'line', 2363
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2992
    new $P125, "Undef"
  vivify_2992:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2346
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3456"  :anon :subid("577_1312646121.678") :outer("576_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2353
    $P3459 = root_new ['parrot';'ResizablePMCArray']
    set $P3458, $P3459
    .lex "@ns", $P3458
    find_lex $P3460, "$/"
    unless_null $P3460, vivify_2977
    $P3460 = root_new ['parrot';'Hash']
  vivify_2977:
    set $P3461, $P3460["name"]
    unless_null $P3461, vivify_2978
    $P3461 = root_new ['parrot';'Hash']
  vivify_2978:
    set $P127, $P3461["identifier"]
    unless_null $P127, vivify_2979
    new $P127, "Undef"
  vivify_2979:
    clone $P128, $P127
    store_lex "@ns", $P128
.annotate 'line', 2354
    find_lex $P3462, "@ns"
    unless_null $P3462, vivify_2980
    $P3462 = root_new ['parrot';'ResizablePMCArray']
  vivify_2980:
    find_lex $P127, "$/"
    unless_null $P127, vivify_2981
    new $P127, "Undef"
  vivify_2981:
    $P128 = "lexical_package_lookup"($P3462, $P127)
    store_lex "$var", $P128
.annotate 'line', 2352
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("578_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3468
    .param pmc param_3469
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2366
    .lex "self", param_3468
    .lex "$/", param_3469
.annotate 'line', 2367
    new $P122, "Undef"
    set $P3470, $P122
    .lex "$past", $P3470
.annotate 'line', 2368
    new $P123, "Undef"
    set $P3471, $P123
    .lex "$pirop", $P3471
.annotate 'line', 2367
    find_lex $P3473, "$/"
    unless_null $P3473, vivify_2993
    $P3473 = root_new ['parrot';'Hash']
  vivify_2993:
    set $P125, $P3473["args"]
    unless_null $P125, vivify_2994
    new $P125, "Undef"
  vivify_2994:
    if $P125, if_3472
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    find_lex $P134, "$/"
    unless_null $P134, vivify_2995
    new $P134, "Undef"
  vivify_2995:
    $P135 = $P133."new"($P134 :named("node"))
    set $P124, $P135
    goto if_3472_end
  if_3472:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3474, "$/"
    unless_null $P3474, vivify_2996
    $P3474 = root_new ['parrot';'Hash']
  vivify_2996:
    set $P3475, $P3474["args"]
    unless_null $P3475, vivify_2997
    $P3475 = root_new ['parrot';'ResizablePMCArray']
  vivify_2997:
    set $P128, $P3475[$I100]
    unless_null $P128, vivify_2998
    new $P128, "Undef"
  vivify_2998:
    $P129 = $P128."ast"()
    set $P124, $P129
  if_3472_end:
    store_lex "$past", $P124
.annotate 'line', 2368
    find_lex $P3476, "$/"
    unless_null $P3476, vivify_2999
    $P3476 = root_new ['parrot';'Hash']
  vivify_2999:
    set $P124, $P3476["op"]
    unless_null $P124, vivify_3000
    new $P124, "Undef"
  vivify_3000:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    store_lex "$pirop", $P125
.annotate 'line', 2369
    find_lex $P124, "$pirop"
    unless_null $P124, vivify_3001
    new $P124, "Undef"
  vivify_3001:
    set $S100, $P124
    split $P125, "__", $S100
    join $S101, " ", $P125
    new $P127, 'String'
    set $P127, $S101
    store_lex "$pirop", $P127
.annotate 'line', 2370
    find_lex $P124, "$past"
    unless_null $P124, vivify_3002
    new $P124, "Undef"
  vivify_3002:
    find_lex $P125, "$pirop"
    unless_null $P125, vivify_3003
    new $P125, "Undef"
  vivify_3003:
    $P124."pirop"($P125)
.annotate 'line', 2371
    find_lex $P124, "$past"
    unless_null $P124, vivify_3004
    new $P124, "Undef"
  vivify_3004:
    $P124."pasttype"("pirop")
.annotate 'line', 2372
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_3005
    new $P125, "Undef"
  vivify_3005:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2366
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::const>" :anon :subid("579_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3478
    .param pmc param_3479
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2375
    .lex "self", param_3478
    .lex "$/", param_3479
.annotate 'line', 2376
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Val"]
    find_lex $P3480, "$/"
    unless_null $P3480, vivify_3006
    $P3480 = root_new ['parrot';'Hash']
  vivify_3006:
    set $P128, $P3480["const"]
    unless_null $P128, vivify_3007
    new $P128, "Undef"
  vivify_3007:
    set $S100, $P128
    find_lex $P129, "$/"
    unless_null $P129, vivify_3008
    new $P129, "Undef"
  vivify_3008:
    $P130 = $P127."new"($S100 :named("value"), "!macro_const" :named("returns"), $P129 :named("node"))
    $P131 = $P122."!make"($P130)
.annotate 'line', 2375
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<nqp::op>" :anon :subid("580_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3482
    .param pmc param_3483
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2379
    .lex "self", param_3482
    .lex "$/", param_3483
.annotate 'line', 2380
    new $P122, "Undef"
    set $P3484, $P122
    .lex "$op", $P3484
.annotate 'line', 2381
    new $P123, "Undef"
    set $P3485, $P123
    .lex "$args", $P3485
.annotate 'line', 2382
    new $P124, "Undef"
    set $P3486, $P124
    .lex "$past", $P3486
.annotate 'line', 2380
    find_lex $P3487, "$/"
    unless_null $P3487, vivify_3009
    $P3487 = root_new ['parrot';'Hash']
  vivify_3009:
    set $P125, $P3487["op"]
    unless_null $P125, vivify_3010
    new $P125, "Undef"
  vivify_3010:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    store_lex "$op", $P127
.annotate 'line', 2381
    find_lex $P3489, "$/"
    unless_null $P3489, vivify_3011
    $P3489 = root_new ['parrot';'Hash']
  vivify_3011:
    set $P127, $P3489["args"]
    unless_null $P127, vivify_3012
    new $P127, "Undef"
  vivify_3012:
    if $P127, if_3488
    new $P132, "ResizablePMCArray"
    set $P125, $P132
    goto if_3488_end
  if_3488:
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P3490, "$/"
    unless_null $P3490, vivify_3013
    $P3490 = root_new ['parrot';'Hash']
  vivify_3013:
    set $P3491, $P3490["args"]
    unless_null $P3491, vivify_3014
    $P3491 = root_new ['parrot';'ResizablePMCArray']
  vivify_3014:
    set $P129, $P3491[$I100]
    unless_null $P129, vivify_3015
    new $P129, "Undef"
  vivify_3015:
    $P130 = $P129."ast"()
    $P131 = $P130."list"()
    set $P125, $P131
  if_3488_end:
    store_lex "$args", $P125
.annotate 'line', 2382
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Node"]
    find_lex $P130, "$args"
    unless_null $P130, vivify_3016
    new $P130, "Undef"
  vivify_3016:
    find_lex $P131, "$op"
    unless_null $P131, vivify_3017
    new $P131, "Undef"
  vivify_3017:
    find_lex $P132, "$/"
    unless_null $P132, vivify_3018
    new $P132, "Undef"
  vivify_3018:
    $P133 = $P129."map_node"($P130 :flat, "nqp" :named("map"), $P131 :named("op"), $P132 :named("node"))
    store_lex "$past", $P133
.annotate 'line', 2385
    find_lex $P125, "$past"
    unless_null $P125, vivify_3019
    new $P125, "Undef"
  vivify_3019:
    defined $I100, $P125
    if $I100, unless_3492_end
.annotate 'line', 2386
    find_lex $P127, "$/"
    unless_null $P127, vivify_3020
    new $P127, "Undef"
  vivify_3020:
    $P128 = $P127."CURSOR"()
    new $P129, 'String'
    set $P129, "Unrecognized nqp:: opcode 'nqp::"
    find_lex $P130, "$op"
    unless_null $P130, vivify_3021
    new $P130, "Undef"
  vivify_3021:
    concat $P131, $P129, $P130
    concat $P132, $P131, "'"
    $P128."panic"($P132)
  unless_3492_end:
.annotate 'line', 2387
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3022
    new $P127, "Undef"
  vivify_3022:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2379
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("581_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3494
    .param pmc param_3495
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2390
    .lex "self", param_3494
    .lex "$/", param_3495
.annotate 'line', 2391
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    $P128 = $P127."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2390
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("582_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3497
    .param pmc param_3498
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2396
    .lex "self", param_3497
    .lex "$/", param_3498
    find_lex $P122, "$/"
    find_lex $P3499, "$/"
    unless_null $P3499, vivify_3023
    $P3499 = root_new ['parrot';'Hash']
  vivify_3023:
    set $P123, $P3499["arglist"]
    unless_null $P123, vivify_3024
    new $P123, "Undef"
  vivify_3024:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("583_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3501
    .param pmc param_3502
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2398
    .const 'Sub' $P3509 = "584_1312646121.678" 
    capture_lex $P3509
    .lex "self", param_3501
    .lex "$/", param_3502
.annotate 'line', 2399
    new $P122, "Undef"
    set $P3503, $P122
    .lex "$past", $P3503
.annotate 'line', 2407
    new $P123, "Undef"
    set $P3504, $P123
    .lex "$i", $P3504
.annotate 'line', 2408
    new $P124, "Undef"
    set $P3505, $P124
    .lex "$n", $P3505
.annotate 'line', 2399
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P130, "$/"
    unless_null $P130, vivify_3025
    new $P130, "Undef"
  vivify_3025:
    $P131 = $P129."new"("call" :named("pasttype"), $P130 :named("node"))
    store_lex "$past", $P131
.annotate 'line', 2400
    find_lex $P3507, "$/"
    unless_null $P3507, vivify_3026
    $P3507 = root_new ['parrot';'Hash']
  vivify_3026:
    set $P125, $P3507["EXPR"]
    unless_null $P125, vivify_3027
    new $P125, "Undef"
  vivify_3027:
    unless $P125, if_3506_end
    .const 'Sub' $P3509 = "584_1312646121.678" 
    capture_lex $P3509
    $P3509()
  if_3506_end:
.annotate 'line', 2407
    new $P125, "Float"
    assign $P125, 0
    store_lex "$i", $P125
.annotate 'line', 2408
    find_lex $P125, "$past"
    unless_null $P125, vivify_3038
    new $P125, "Undef"
  vivify_3038:
    $P127 = $P125."list"()
    set $N100, $P127
    new $P128, 'Float'
    set $P128, $N100
    store_lex "$n", $P128
.annotate 'line', 2409
    new $P128, 'ExceptionHandler'
    set_label $P128, loop3530_handler
    $P128."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P128
  loop3530_test:
    find_lex $P125, "$i"
    unless_null $P125, vivify_3039
    new $P125, "Undef"
  vivify_3039:
    set $N100, $P125
    find_lex $P127, "$n"
    unless_null $P127, vivify_3040
    new $P127, "Undef"
  vivify_3040:
    set $N101, $P127
    islt $I100, $N100, $N101
    unless $I100, loop3530_done
  loop3530_redo:
.annotate 'line', 2410
    find_lex $P128, "$i"
    unless_null $P128, vivify_3041
    new $P128, "Undef"
  vivify_3041:
    set $I101, $P128
    find_lex $P3519, "$past"
    unless_null $P3519, vivify_3042
    $P3519 = root_new ['parrot';'ResizablePMCArray']
  vivify_3042:
    set $P129, $P3519[$I101]
    unless_null $P129, vivify_3043
    new $P129, "Undef"
  vivify_3043:
    $S100 = $P129."name"()
    iseq $I102, $S100, "&prefix:<|>"
    unless $I102, if_3518_end
.annotate 'line', 2411
    new $P130, "Float"
    assign $P130, 0
    set $I103, $P130
    find_lex $P131, "$i"
    unless_null $P131, vivify_3044
    new $P131, "Undef"
  vivify_3044:
    set $I104, $P131
    find_lex $P3520, "$past"
    unless_null $P3520, vivify_3045
    $P3520 = root_new ['parrot';'ResizablePMCArray']
  vivify_3045:
    set $P3521, $P3520[$I104]
    unless_null $P3521, vivify_3046
    $P3521 = root_new ['parrot';'ResizablePMCArray']
  vivify_3046:
    set $P132, $P3521[$I103]
    unless_null $P132, vivify_3047
    new $P132, "Undef"
  vivify_3047:
    find_lex $P133, "$i"
    unless_null $P133, vivify_3048
    new $P133, "Undef"
  vivify_3048:
    set $I105, $P133
    find_lex $P3522, "$past"
    unless_null $P3522, vivify_3049
    $P3522 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P3522
  vivify_3049:
    set $P3522[$I105], $P132
.annotate 'line', 2412
    find_lex $P130, "$i"
    unless_null $P130, vivify_3050
    new $P130, "Undef"
  vivify_3050:
    set $I103, $P130
    find_lex $P3523, "$past"
    unless_null $P3523, vivify_3051
    $P3523 = root_new ['parrot';'ResizablePMCArray']
  vivify_3051:
    set $P131, $P3523[$I103]
    unless_null $P131, vivify_3052
    new $P131, "Undef"
  vivify_3052:
    $P131."flat"(1)
.annotate 'line', 2413
    find_lex $P131, "$i"
    unless_null $P131, vivify_3053
    new $P131, "Undef"
  vivify_3053:
    set $I103, $P131
    find_lex $P3526, "$past"
    unless_null $P3526, vivify_3054
    $P3526 = root_new ['parrot';'ResizablePMCArray']
  vivify_3054:
    set $P132, $P3526[$I103]
    unless_null $P132, vivify_3055
    new $P132, "Undef"
  vivify_3055:
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Val"]
    $P137 = $P132."isa"($P136)
    if $P137, if_3525
    set $P130, $P137
    goto if_3525_end
  if_3525:
.annotate 'line', 2414
    find_lex $P138, "$i"
    unless_null $P138, vivify_3056
    new $P138, "Undef"
  vivify_3056:
    set $I104, $P138
    find_lex $P3527, "$past"
    unless_null $P3527, vivify_3057
    $P3527 = root_new ['parrot';'ResizablePMCArray']
  vivify_3057:
    set $P139, $P3527[$I104]
    unless_null $P139, vivify_3058
    new $P139, "Undef"
  vivify_3058:
    $S101 = $P139."name"()
    new $P140, "Float"
    assign $P140, 0
    set $I105, $P140
    new $P141, "Float"
    assign $P141, 1
    set $I106, $P141
    substr $S102, $S101, $I105, $I106
    iseq $I107, $S102, "%"
    new $P130, 'Integer'
    set $P130, $I107
  if_3525_end:
    unless $P130, if_3524_end
.annotate 'line', 2415
    find_lex $P142, "$i"
    unless_null $P142, vivify_3059
    new $P142, "Undef"
  vivify_3059:
    set $I108, $P142
    find_lex $P3528, "$past"
    unless_null $P3528, vivify_3060
    $P3528 = root_new ['parrot';'ResizablePMCArray']
  vivify_3060:
    set $P143, $P3528[$I108]
    unless_null $P143, vivify_3061
    new $P143, "Undef"
  vivify_3061:
    $P143."named"(1)
  if_3524_end:
  if_3518_end:
.annotate 'line', 2409
    find_lex $P128, "$i"
    unless_null $P128, vivify_3062
    new $P128, "Undef"
  vivify_3062:
    clone $P3529, $P128
    inc $P128
  loop3530_next:
    goto loop3530_test
  loop3530_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P129, exception, 'type'
    eq $P129, .CONTROL_LOOP_NEXT, loop3530_next
    eq $P129, .CONTROL_LOOP_REDO, loop3530_redo
  loop3530_done:
    pop_eh 
.annotate 'line', 2420
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3063
    new $P127, "Undef"
  vivify_3063:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2398
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3508"  :anon :subid("584_1312646121.678") :outer("583_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2400
    .const 'Sub' $P3515 = "585_1312646121.678" 
    capture_lex $P3515
.annotate 'line', 2401
    new $P127, "Undef"
    set $P3510, $P127
    .lex "$expr", $P3510
    find_lex $P3511, "$/"
    unless_null $P3511, vivify_3028
    $P3511 = root_new ['parrot';'Hash']
  vivify_3028:
    set $P128, $P3511["EXPR"]
    unless_null $P128, vivify_3029
    new $P128, "Undef"
  vivify_3029:
    $P129 = $P128."ast"()
    store_lex "$expr", $P129
.annotate 'line', 2402
    find_lex $P130, "$expr"
    unless_null $P130, vivify_3030
    new $P130, "Undef"
  vivify_3030:
    $S100 = $P130."name"()
    iseq $I100, $S100, "&infix:<,>"
    if $I100, if_3513
    new $P129, 'Integer'
    set $P129, $I100
    goto if_3513_end
  if_3513:
    find_lex $P131, "$expr"
    unless_null $P131, vivify_3031
    new $P131, "Undef"
  vivify_3031:
    $P132 = $P131."named"()
    isfalse $I101, $P132
    new $P129, 'Integer'
    set $P129, $I101
  if_3513_end:
    if $P129, if_3512
.annotate 'line', 2405
    find_lex $P134, "$past"
    unless_null $P134, vivify_3032
    new $P134, "Undef"
  vivify_3032:
    find_lex $P135, "$expr"
    unless_null $P135, vivify_3033
    new $P135, "Undef"
  vivify_3033:
    $P136 = $P134."push"($P135)
    set $P128, $P136
.annotate 'line', 2402
    goto if_3512_end
  if_3512:
.annotate 'line', 2403
    find_lex $P134, "$expr"
    unless_null $P134, vivify_3034
    new $P134, "Undef"
  vivify_3034:
    $P135 = $P134."list"()
    defined $I102, $P135
    unless $I102, for_undef_3035
    iter $P133, $P135
    new $P137, 'ExceptionHandler'
    set_label $P137, loop3517_handler
    $P137."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P137
  loop3517_test:
    unless $P133, loop3517_done
    shift $P136, $P133
  loop3517_redo:
    .const 'Sub' $P3515 = "585_1312646121.678" 
    capture_lex $P3515
    $P3515($P136)
  loop3517_next:
    goto loop3517_test
  loop3517_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P138, exception, 'type'
    eq $P138, .CONTROL_LOOP_NEXT, loop3517_next
    eq $P138, .CONTROL_LOOP_REDO, loop3517_redo
  loop3517_done:
    pop_eh 
  for_undef_3035:
.annotate 'line', 2402
    set $P128, $P133
  if_3512_end:
.annotate 'line', 2400
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3514"  :anon :subid("585_1312646121.678") :outer("584_1312646121.678")
    .param pmc param_3516
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2403
    .lex "$_", param_3516
    find_lex $P137, "$past"
    unless_null $P137, vivify_3036
    new $P137, "Undef"
  vivify_3036:
    find_lex $P138, "$_"
    unless_null $P138, vivify_3037
    new $P138, "Undef"
  vivify_3037:
    $P139 = $P137."push"($P138)
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("586_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3532
    .param pmc param_3533
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2423
    .lex "self", param_3532
    .lex "$/", param_3533
    find_lex $P122, "$/"
    find_lex $P3534, "$/"
    unless_null $P3534, vivify_3064
    $P3534 = root_new ['parrot';'Hash']
  vivify_3064:
    set $P123, $P3534["multi_declarator"]
    unless_null $P123, vivify_3065
    new $P123, "Undef"
  vivify_3065:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("587_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3536
    .param pmc param_3537
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2425
    .lex "self", param_3536
    .lex "$/", param_3537
    find_lex $P122, "$/"
    find_lex $P3538, "$/"
    unless_null $P3538, vivify_3066
    $P3538 = root_new ['parrot';'Hash']
  vivify_3066:
    set $P123, $P3538["value"]
    unless_null $P123, vivify_3067
    new $P123, "Undef"
  vivify_3067:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("588_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3540
    .param pmc param_3541
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2427
    .lex "self", param_3540
    .lex "$/", param_3541
.annotate 'line', 2428
    find_lex $P122, "$/"
.annotate 'line', 2429
    find_lex $P3543, "$/"
    unless_null $P3543, vivify_3068
    $P3543 = root_new ['parrot';'Hash']
  vivify_3068:
    set $P124, $P3543["EXPR"]
    unless_null $P124, vivify_3069
    new $P124, "Undef"
  vivify_3069:
    if $P124, if_3542
.annotate 'line', 2430
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P133, "$/"
    unless_null $P133, vivify_3070
    new $P133, "Undef"
  vivify_3070:
    $P134 = $P132."new"("list" :named("pasttype"), $P133 :named("node"))
    set $P123, $P134
.annotate 'line', 2429
    goto if_3542_end
  if_3542:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3544, "$/"
    unless_null $P3544, vivify_3071
    $P3544 = root_new ['parrot';'Hash']
  vivify_3071:
    set $P3545, $P3544["EXPR"]
    unless_null $P3545, vivify_3072
    $P3545 = root_new ['parrot';'ResizablePMCArray']
  vivify_3072:
    set $P127, $P3545[$I100]
    unless_null $P127, vivify_3073
    new $P127, "Undef"
  vivify_3073:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_3542_end:
    $P135 = $P122."!make"($P123)
.annotate 'line', 2427
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("589_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3547
    .param pmc param_3548
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2433
    .lex "self", param_3547
    .lex "$/", param_3548
.annotate 'line', 2434
    new $P122, "Undef"
    set $P3549, $P122
    .lex "$past", $P3549
.annotate 'line', 2433
    find_lex $P123, "$past"
    unless_null $P123, vivify_3074
    new $P123, "Undef"
  vivify_3074:
.annotate 'line', 2435
    find_lex $P3551, "$/"
    unless_null $P3551, vivify_3075
    $P3551 = root_new ['parrot';'Hash']
  vivify_3075:
    set $P123, $P3551["EXPR"]
    unless_null $P123, vivify_3076
    new $P123, "Undef"
  vivify_3076:
    if $P123, if_3550
.annotate 'line', 2442
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    $P129 = $P128."new"("list" :named("pasttype"))
    store_lex "$past", $P129
.annotate 'line', 2441
    goto if_3550_end
  if_3550:
.annotate 'line', 2436
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P3552, "$/"
    unless_null $P3552, vivify_3077
    $P3552 = root_new ['parrot';'Hash']
  vivify_3077:
    set $P3553, $P3552["EXPR"]
    unless_null $P3553, vivify_3078
    $P3553 = root_new ['parrot';'ResizablePMCArray']
  vivify_3078:
    set $P125, $P3553[$I100]
    unless_null $P125, vivify_3079
    new $P125, "Undef"
  vivify_3079:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2437
    find_lex $P124, "$past"
    unless_null $P124, vivify_3080
    new $P124, "Undef"
  vivify_3080:
    $S100 = $P124."name"()
    isne $I100, $S100, "&infix:<,>"
    unless $I100, if_3554_end
.annotate 'line', 2438
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P130, "$past"
    unless_null $P130, vivify_3081
    new $P130, "Undef"
  vivify_3081:
    $P131 = $P129."new"($P130, "list" :named("pasttype"))
    store_lex "$past", $P131
  if_3554_end:
  if_3550_end:
.annotate 'line', 2444
    find_lex $P123, "$past"
    unless_null $P123, vivify_3082
    new $P123, "Undef"
  vivify_3082:
    $P123."name"("&circumfix:<[ ]>")
.annotate 'line', 2445
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_3083
    new $P124, "Undef"
  vivify_3083:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2433
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("590_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3556
    .param pmc param_3557
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2448
    .lex "self", param_3556
    .lex "$/", param_3557
    find_lex $P122, "$/"
    find_lex $P3558, "$/"
    unless_null $P3558, vivify_3084
    $P3558 = root_new ['parrot';'Hash']
  vivify_3084:
    set $P123, $P3558["quote_EXPR"]
    unless_null $P123, vivify_3085
    new $P123, "Undef"
  vivify_3085:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("591_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3560
    .param pmc param_3561
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2449
    .lex "self", param_3560
    .lex "$/", param_3561
    find_lex $P122, "$/"
    find_lex $P3562, "$/"
    unless_null $P3562, vivify_3086
    $P3562 = root_new ['parrot';'Hash']
  vivify_3086:
    set $P123, $P3562["quote_EXPR"]
    unless_null $P123, vivify_3087
    new $P123, "Undef"
  vivify_3087:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("592_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3564
    .param pmc param_3565
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2451
    .const 'Sub' $P3572 = "593_1312646121.678" 
    capture_lex $P3572
    .lex "self", param_3564
    .lex "$/", param_3565
.annotate 'line', 2452
    find_lex $P3567, "$/"
    unless_null $P3567, vivify_3088
    $P3567 = root_new ['parrot';'Hash']
  vivify_3088:
    set $P3568, $P3567["pblock"]
    unless_null $P3568, vivify_3089
    $P3568 = root_new ['parrot';'Hash']
  vivify_3089:
    set $P3569, $P3568["blockoid"]
    unless_null $P3569, vivify_3090
    $P3569 = root_new ['parrot';'Hash']
  vivify_3090:
    set $P3570, $P3569["statementlist"]
    unless_null $P3570, vivify_3091
    $P3570 = root_new ['parrot';'Hash']
  vivify_3091:
    set $P123, $P3570["statement"]
    unless_null $P123, vivify_3092
    new $P123, "Undef"
  vivify_3092:
    set $N100, $P123
    set $N101, 0
    isgt $I100, $N100, $N101
    if $I100, if_3566
.annotate 'line', 2457
    find_lex $P3577, "$/"
    unless_null $P3577, vivify_3093
    $P3577 = root_new ['parrot';'Hash']
  vivify_3093:
    set $P3578, $P3577["pblock"]
    unless_null $P3578, vivify_3094
    $P3578 = root_new ['parrot';'Hash']
  vivify_3094:
    set $P3579, $P3578["blockoid"]
    unless_null $P3579, vivify_3095
    $P3579 = root_new ['parrot';'Hash']
  vivify_3095:
    set $P129, $P3579["you_are_here"]
    unless_null $P129, vivify_3096
    new $P129, "Undef"
  vivify_3096:
    if $P129, if_3576
.annotate 'line', 2461
    find_lex $P130, "$/"
    $P131 = "vivitype"("%")
    $P132 = $P130."!make"($P131)
.annotate 'line', 2460
    set $P127, $P132
.annotate 'line', 2457
    goto if_3576_end
  if_3576:
.annotate 'line', 2458
    find_lex $P130, "$/"
    find_lex $P3580, "$/"
    unless_null $P3580, vivify_3097
    $P3580 = root_new ['parrot';'Hash']
  vivify_3097:
    set $P131, $P3580["pblock"]
    unless_null $P131, vivify_3098
    new $P131, "Undef"
  vivify_3098:
    $P132 = $P131."ast"()
    $P133 = $P130."!make"($P132)
.annotate 'line', 2457
    set $P127, $P133
  if_3576_end:
    set $P122, $P127
.annotate 'line', 2452
    goto if_3566_end
  if_3566:
    .const 'Sub' $P3572 = "593_1312646121.678" 
    capture_lex $P3572
    $P125 = $P3572()
    set $P122, $P125
  if_3566_end:
.annotate 'line', 2451
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3571"  :anon :subid("593_1312646121.678") :outer("592_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2453
    new $P124, "Undef"
    set $P3573, $P124
    .lex "$past", $P3573
    find_lex $P3574, "$/"
    unless_null $P3574, vivify_3099
    $P3574 = root_new ['parrot';'Hash']
  vivify_3099:
    set $P125, $P3574["pblock"]
    unless_null $P125, vivify_3100
    new $P125, "Undef"
  vivify_3100:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2454
    new $P125, "Float"
    assign $P125, 1
    find_lex $P3575, "$past"
    unless_null $P3575, vivify_3101
    $P3575 = root_new ['parrot';'Hash']
    store_lex "$past", $P3575
  vivify_3101:
    set $P3575["bareblock"], $P125
.annotate 'line', 2455
    find_dynamic_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3102
    new $P127, "Undef"
  vivify_3102:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2452
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("594_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3582
    .param pmc param_3583
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2465
    .lex "self", param_3582
    .lex "$/", param_3583
.annotate 'line', 2466
    new $P122, "Undef"
    set $P3584, $P122
    .lex "$name", $P3584
    find_lex $P3586, "$/"
    unless_null $P3586, vivify_3103
    $P3586 = root_new ['parrot';'Hash']
  vivify_3103:
    set $P124, $P3586["sigil"]
    unless_null $P124, vivify_3104
    new $P124, "Undef"
  vivify_3104:
    set $S100, $P124
    iseq $I100, $S100, "@"
    if $I100, if_3585
.annotate 'line', 2467
    find_lex $P3588, "$/"
    unless_null $P3588, vivify_3105
    $P3588 = root_new ['parrot';'Hash']
  vivify_3105:
    set $P128, $P3588["sigil"]
    unless_null $P128, vivify_3106
    new $P128, "Undef"
  vivify_3106:
    set $S101, $P128
    iseq $I101, $S101, "%"
    if $I101, if_3587
    new $P130, "String"
    assign $P130, "item"
    set $P127, $P130
    goto if_3587_end
  if_3587:
    new $P129, "String"
    assign $P129, "hash"
    set $P127, $P129
  if_3587_end:
    set $P123, $P127
.annotate 'line', 2466
    goto if_3585_end
  if_3585:
    new $P125, "String"
    assign $P125, "list"
    set $P123, $P125
  if_3585_end:
    store_lex "$name", $P123
.annotate 'line', 2469
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    find_lex $P129, "$name"
    unless_null $P129, vivify_3107
    new $P129, "Undef"
  vivify_3107:
    find_lex $P3589, "$/"
    unless_null $P3589, vivify_3108
    $P3589 = root_new ['parrot';'Hash']
  vivify_3108:
    set $P130, $P3589["semilist"]
    unless_null $P130, vivify_3109
    new $P130, "Undef"
  vivify_3109:
    $P131 = $P130."ast"()
    $P132 = $P128."new"($P131, "callmethod" :named("pasttype"), $P129 :named("name"))
    $P133 = $P123."!make"($P132)
.annotate 'line', 2465
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("595_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3591
    .param pmc param_3592
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2472
    .lex "self", param_3591
    .lex "$/", param_3592
    find_lex $P122, "$/"
    find_lex $P3593, "$/"
    unless_null $P3593, vivify_3110
    $P3593 = root_new ['parrot';'Hash']
  vivify_3110:
    set $P123, $P3593["statement"]
    unless_null $P123, vivify_3111
    new $P123, "Undef"
  vivify_3111:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("596_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3595
    .param pmc param_3596
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2474
    .lex "self", param_3595
    .lex "$/", param_3596
.annotate 'line', 2475
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3597, "$/"
    unless_null $P3597, vivify_3112
    $P3597 = root_new ['parrot';'Hash']
  vivify_3112:
    set $P128, $P3597["EXPR"]
    unless_null $P128, vivify_3113
    new $P128, "Undef"
  vivify_3113:
    $P129 = $P128."ast"()
.annotate 'line', 2477
    $P130 = "vivitype"("@")
.annotate 'line', 2475
    $P131 = $P127."new"($P129, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2474
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("597_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3599
    .param pmc param_3600
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2480
    .lex "self", param_3599
    .lex "$/", param_3600
.annotate 'line', 2481
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3601, "$/"
    unless_null $P3601, vivify_3114
    $P3601 = root_new ['parrot';'Hash']
  vivify_3114:
    set $P128, $P3601["EXPR"]
    unless_null $P128, vivify_3115
    new $P128, "Undef"
  vivify_3115:
    $P129 = $P128."ast"()
.annotate 'line', 2483
    $P130 = "vivitype"("%")
.annotate 'line', 2481
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2480
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("598_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3603
    .param pmc param_3604
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2486
    .lex "self", param_3603
    .lex "$/", param_3604
.annotate 'line', 2487
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3605, "$/"
    unless_null $P3605, vivify_3116
    $P3605 = root_new ['parrot';'Hash']
  vivify_3116:
    set $P128, $P3605["quote_EXPR"]
    unless_null $P128, vivify_3117
    new $P128, "Undef"
  vivify_3117:
    $P129 = $P128."ast"()
.annotate 'line', 2489
    $P130 = "vivitype"("%")
.annotate 'line', 2487
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2486
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("599_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3607
    .param pmc param_3608
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2492
    .lex "self", param_3607
    .lex "$/", param_3608
.annotate 'line', 2493
    find_lex $P122, "$/"
    find_lex $P3609, "$/"
    unless_null $P3609, vivify_3118
    $P3609 = root_new ['parrot';'Hash']
  vivify_3118:
    set $P123, $P3609["arglist"]
    unless_null $P123, vivify_3119
    new $P123, "Undef"
  vivify_3119:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2492
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("600_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3611
    .param pmc param_3612
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2496
    .lex "self", param_3611
    .lex "$/", param_3612
.annotate 'line', 2497
    find_lex $P122, "$/"
    find_lex $P3614, "$/"
    unless_null $P3614, vivify_3120
    $P3614 = root_new ['parrot';'Hash']
  vivify_3120:
    set $P124, $P3614["quote"]
    unless_null $P124, vivify_3121
    new $P124, "Undef"
  vivify_3121:
    if $P124, if_3613
    find_lex $P3616, "$/"
    unless_null $P3616, vivify_3122
    $P3616 = root_new ['parrot';'Hash']
  vivify_3122:
    set $P128, $P3616["number"]
    unless_null $P128, vivify_3123
    new $P128, "Undef"
  vivify_3123:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3613_end
  if_3613:
    find_lex $P3615, "$/"
    unless_null $P3615, vivify_3124
    $P3615 = root_new ['parrot';'Hash']
  vivify_3124:
    set $P125, $P3615["quote"]
    unless_null $P125, vivify_3125
    new $P125, "Undef"
  vivify_3125:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3613_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 2496
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("601_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3618
    .param pmc param_3619
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2500
    .lex "self", param_3618
    .lex "$/", param_3619
.annotate 'line', 2501
    new $P122, "Undef"
    set $P3620, $P122
    .lex "$value", $P3620
    find_lex $P3622, "$/"
    unless_null $P3622, vivify_3126
    $P3622 = root_new ['parrot';'Hash']
  vivify_3126:
    set $P124, $P3622["dec_number"]
    unless_null $P124, vivify_3127
    new $P124, "Undef"
  vivify_3127:
    if $P124, if_3621
    find_lex $P3624, "$/"
    unless_null $P3624, vivify_3128
    $P3624 = root_new ['parrot';'Hash']
  vivify_3128:
    set $P128, $P3624["integer"]
    unless_null $P128, vivify_3129
    new $P128, "Undef"
  vivify_3129:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3621_end
  if_3621:
    find_lex $P3623, "$/"
    unless_null $P3623, vivify_3130
    $P3623 = root_new ['parrot';'Hash']
  vivify_3130:
    set $P125, $P3623["dec_number"]
    unless_null $P125, vivify_3131
    new $P125, "Undef"
  vivify_3131:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3621_end:
    store_lex "$value", $P123
.annotate 'line', 2502
    find_lex $P3626, "$/"
    unless_null $P3626, vivify_3132
    $P3626 = root_new ['parrot';'Hash']
  vivify_3132:
    set $P123, $P3626["sign"]
    unless_null $P123, vivify_3133
    new $P123, "Undef"
  vivify_3133:
    set $S100, $P123
    iseq $I100, $S100, "-"
    unless $I100, if_3625_end
    find_lex $P124, "$value"
    unless_null $P124, vivify_3134
    new $P124, "Undef"
  vivify_3134:
    neg $P125, $P124
    store_lex "$value", $P125
  if_3625_end:
.annotate 'line', 2503
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Val"]
    find_lex $P129, "$value"
    unless_null $P129, vivify_3135
    new $P129, "Undef"
  vivify_3135:
    $P130 = $P128."new"($P129 :named("value"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 2500
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("602_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3628
    .param pmc param_3629
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2506
    .lex "self", param_3628
    .lex "$/", param_3629
    find_lex $P122, "$/"
    find_lex $P3630, "$/"
    unless_null $P3630, vivify_3136
    $P3630 = root_new ['parrot';'Hash']
  vivify_3136:
    set $P123, $P3630["quote_EXPR"]
    unless_null $P123, vivify_3137
    new $P123, "Undef"
  vivify_3137:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("603_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3632
    .param pmc param_3633
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2507
    .lex "self", param_3632
    .lex "$/", param_3633
    find_lex $P122, "$/"
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_3138
    $P3634 = root_new ['parrot';'Hash']
  vivify_3138:
    set $P123, $P3634["quote_EXPR"]
    unless_null $P123, vivify_3139
    new $P123, "Undef"
  vivify_3139:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("604_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3636
    .param pmc param_3637
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2508
    .lex "self", param_3636
    .lex "$/", param_3637
    find_lex $P122, "$/"
    find_lex $P3638, "$/"
    unless_null $P3638, vivify_3140
    $P3638 = root_new ['parrot';'Hash']
  vivify_3140:
    set $P123, $P3638["quote_EXPR"]
    unless_null $P123, vivify_3141
    new $P123, "Undef"
  vivify_3141:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("605_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3640
    .param pmc param_3641
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2509
    .lex "self", param_3640
    .lex "$/", param_3641
    find_lex $P122, "$/"
    find_lex $P3642, "$/"
    unless_null $P3642, vivify_3142
    $P3642 = root_new ['parrot';'Hash']
  vivify_3142:
    set $P123, $P3642["quote_EXPR"]
    unless_null $P123, vivify_3143
    new $P123, "Undef"
  vivify_3143:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("606_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3644
    .param pmc param_3645
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2510
    .lex "self", param_3644
    .lex "$/", param_3645
    find_lex $P122, "$/"
    find_lex $P3646, "$/"
    unless_null $P3646, vivify_3144
    $P3646 = root_new ['parrot';'Hash']
  vivify_3144:
    set $P123, $P3646["quote_EXPR"]
    unless_null $P123, vivify_3145
    new $P123, "Undef"
  vivify_3145:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("607_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3648
    .param pmc param_3649
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2511
    .lex "self", param_3648
    .lex "$/", param_3649
.annotate 'line', 2512
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P3650, "$/"
    unless_null $P3650, vivify_3146
    $P3650 = root_new ['parrot';'Hash']
  vivify_3146:
    set $P128, $P3650["quote_EXPR"]
    unless_null $P128, vivify_3147
    new $P128, "Undef"
  vivify_3147:
    $P129 = $P128."ast"()
    $P130 = $P129."value"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_3148
    new $P131, "Undef"
  vivify_3148:
    $P132 = $P127."new"($P130 :named("inline"), "inline" :named("pasttype"), $P131 :named("node"))
    $P133 = $P122."!make"($P132)
.annotate 'line', 2511
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("608_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3654
    .param pmc param_3655
    .param pmc param_3656 :optional
    .param int has_param_3656 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2517
    new $P3653, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3653, control_3652
    push_eh $P3653
    .lex "self", param_3654
    .lex "$/", param_3655
    if has_param_3656, optparam_3149
    new $P122, "Undef"
    set param_3656, $P122
  optparam_3149:
    .lex "$key", param_3656
.annotate 'line', 2524
    new $P123, "Undef"
    set $P3657, $P123
    .lex "$regex", $P3657
.annotate 'line', 2526
    new $P124, "Undef"
    set $P3658, $P124
    .lex "$past", $P3658
.annotate 'line', 2518
    find_lex $P125, "$key"
    unless_null $P125, vivify_3150
    new $P125, "Undef"
  vivify_3150:
    set $S100, $P125
    iseq $I100, $S100, "open"
    unless $I100, if_3659_end
.annotate 'line', 2519
    null $P127
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "Regex"
    nqp_get_package_through_who $P130, $P129, "P6Regex"
    nqp_get_package_through_who $P131, $P130, "Actions"
    get_who $P132, $P131
    set $P132["$REGEXNAME"], $P127
.annotate 'line', 2520
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3660, $P129["@BLOCK"]
    unless_null $P3660, vivify_3151
    $P3660 = root_new ['parrot';'ResizablePMCArray']
  vivify_3151:
    set $P130, $P3660[$I101]
    unless_null $P130, vivify_3152
    new $P130, "Undef"
  vivify_3152:
    $P130."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2521
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3661, $P129["@BLOCK"]
    unless_null $P3661, vivify_3153
    $P3661 = root_new ['parrot';'ResizablePMCArray']
  vivify_3153:
    set $P130, $P3661[$I101]
    unless_null $P130, vivify_3154
    new $P130, "Undef"
  vivify_3154:
    $P130."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2522
    new $P127, "Exception"
    set $P127['type'], .CONTROL_RETURN
    new $P128, "Float"
    assign $P128, 0
    setattribute $P127, 'payload', $P128
    throw $P127
  if_3659_end:
.annotate 'line', 2525
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P131, $P130["buildsub"]
    find_lex $P3662, "$/"
    unless_null $P3662, vivify_3155
    $P3662 = root_new ['parrot';'Hash']
  vivify_3155:
    set $P132, $P3662["p6regex"]
    unless_null $P132, vivify_3156
    new $P132, "Undef"
  vivify_3156:
    $P133 = $P132."ast"()
    find_lex $P134, "$?PACKAGE"
    get_who $P135, $P134
    set $P3663, $P135["@BLOCK"]
    unless_null $P3663, vivify_3157
    $P3663 = root_new ['parrot';'ResizablePMCArray']
  vivify_3157:
    $P136 = $P3663."shift"()
    $P137 = $P131($P133, $P136)
    store_lex "$regex", $P137
.annotate 'line', 2527
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
.annotate 'line', 2529
    new $P130, "ResizablePMCArray"
    push $P130, "Regex"
    push $P130, "Regex"
    find_lex $P131, "$/"
    unless_null $P131, vivify_3158
    new $P131, "Undef"
  vivify_3158:
    $P132 = "lexical_package_lookup"($P130, $P131)
    find_lex $P133, "$regex"
    unless_null $P133, vivify_3159
    new $P133, "Undef"
  vivify_3159:
    $P134 = $P129."new"($P132, $P133, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2527
    store_lex "$past", $P134
.annotate 'line', 2533
    find_lex $P125, "$regex"
    unless_null $P125, vivify_3160
    new $P125, "Undef"
  vivify_3160:
    find_lex $P3664, "$past"
    unless_null $P3664, vivify_3161
    $P3664 = root_new ['parrot';'Hash']
    store_lex "$past", $P3664
  vivify_3161:
    set $P3664["sink"], $P125
.annotate 'line', 2534
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3162
    new $P127, "Undef"
  vivify_3162:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2517
    .return ($P128)
  control_3652:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("609_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3666
    .param pmc param_3667
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2537
    .lex "self", param_3666
    .lex "$/", param_3667
    find_lex $P122, "$/"
    find_lex $P3668, "$/"
    unless_null $P3668, vivify_3163
    $P3668 = root_new ['parrot';'Hash']
  vivify_3163:
    set $P123, $P3668["variable"]
    unless_null $P123, vivify_3164
    new $P123, "Undef"
  vivify_3164:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("610_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3670
    .param pmc param_3671
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2538
    .lex "self", param_3670
    .lex "$/", param_3671
.annotate 'line', 2539
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2540
    find_lex $P3672, "$/"
    unless_null $P3672, vivify_3165
    $P3672 = root_new ['parrot';'Hash']
  vivify_3165:
    set $P128, $P3672["block"]
    unless_null $P128, vivify_3166
    new $P128, "Undef"
  vivify_3166:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    find_lex $P131, "$/"
    unless_null $P131, vivify_3167
    new $P131, "Undef"
  vivify_3167:
    $P132 = $P127."new"($P130, "set S*" :named("pirop"), $P131 :named("node"))
.annotate 'line', 2539
    $P133 = $P122."!make"($P132)
.annotate 'line', 2538
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("611_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3674
    .param pmc param_3675
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2543
    .lex "self", param_3674
    .lex "$/", param_3675
    find_lex $P122, "$/"
    $P123 = $P122."!make"("\e")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("612_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3677
    .param pmc param_3678
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2547
    .lex "self", param_3677
    .lex "$/", param_3678
    find_lex $P122, "$/"
    find_lex $P3679, "$/"
    unless_null $P3679, vivify_3168
    $P3679 = root_new ['parrot';'Hash']
  vivify_3168:
    set $P123, $P3679["dotty"]
    unless_null $P123, vivify_3169
    new $P123, "Undef"
  vivify_3169:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("613_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3681
    .param pmc param_3682
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2549
    .lex "self", param_3681
    .lex "$/", param_3682
.annotate 'line', 2550
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2551
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    inc %0"
.annotate 'line', 2550
    $P129 = $P127."new"("postfix:<++>" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2549
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("614_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3684
    .param pmc param_3685
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2555
    .lex "self", param_3684
    .lex "$/", param_3685
.annotate 'line', 2556
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2557
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    dec %0"
.annotate 'line', 2556
    $P129 = $P127."new"("postfix:<-->" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2555
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("615_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3687
    .param pmc param_3688
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2561
    .lex "self", param_3687
    .lex "$/", param_3688
.annotate 'line', 2562
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2563
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Var"]
    $P132 = $P131."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P133, "$/"
    unless_null $P133, vivify_3170
    new $P133, "Undef"
  vivify_3170:
    $P134 = $P127."new"($P132, "callmethod" :named("pasttype"), "!make" :named("name"), $P133 :named("node"))
.annotate 'line', 2562
    $P135 = $P122."!make"($P134)
.annotate 'line', 2561
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("616_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3690
    .param pmc param_3691
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2579
    .lex "self", param_3690
    .lex "$/", param_3691
    find_lex $P122, "$/"
    unless_null $P122, vivify_3171
    new $P122, "Undef"
  vivify_3171:
    $P123 = "control"($P122, "CONTROL_LOOP_NEXT")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("617_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3693
    .param pmc param_3694
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2580
    .lex "self", param_3693
    .lex "$/", param_3694
    find_lex $P122, "$/"
    unless_null $P122, vivify_3172
    new $P122, "Undef"
  vivify_3172:
    $P123 = "control"($P122, "CONTROL_LOOP_LAST")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("618_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3696
    .param pmc param_3697
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2581
    .lex "self", param_3696
    .lex "$/", param_3697
    find_lex $P122, "$/"
    unless_null $P122, vivify_3173
    new $P122, "Undef"
  vivify_3173:
    $P123 = "control"($P122, "CONTROL_LOOP_REDO")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("619_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3699
    .param pmc param_3700
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2583
    .lex "self", param_3699
    .lex "$/", param_3700
.annotate 'line', 2584
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_3174
    new $P128, "Undef"
  vivify_3174:
    $P129 = $P127."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P128 :named("node"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2583
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("620_1312646121.678") :outer("440_1312646121.678")
    .param pmc param_3702
    .param pmc param_3703
    .param pmc param_3704
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2661
    .const 'Sub' $P3707 = "621_1312646121.678" 
    capture_lex $P3707
    .lex "self", param_3702
    .lex "$/", param_3703
    .lex "@name", param_3704
.annotate 'line', 2662
    new $P122, "Undef"
    set $P3705, $P122
    .lex "$known", $P3705
    new $P123, "Float"
    assign $P123, 0
    store_lex "$known", $P123
.annotate 'line', 2663
    .const 'Sub' $P3707 = "621_1312646121.678" 
    capture_lex $P3707
    $P3707()
.annotate 'line', 2661
    find_lex $P123, "$known"
    unless_null $P123, vivify_3177
    new $P123, "Undef"
  vivify_3177:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3706"  :anon :subid("621_1312646121.678") :outer("620_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2663
    new $P3711, 'ExceptionHandler'
    set_label $P3711, control_3710
    $P3711."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3711
.annotate 'line', 2664
    find_lex $P3708, "@name"
    unless_null $P3708, vivify_3175
    $P3708 = root_new ['parrot';'ResizablePMCArray']
  vivify_3175:
    find_lex $P123, "$/"
    unless_null $P123, vivify_3176
    new $P123, "Undef"
  vivify_3176:
    "find_sym"($P3708, $P123)
.annotate 'line', 2665
    new $P123, "Float"
    assign $P123, 1
    store_lex "$known", $P123
.annotate 'line', 2663
    pop_eh 
    goto skip_handler_3709
  control_3710:
    .local pmc exception 
    .get_results (exception) 
    new $P3714, 'Integer'
    set $P3714, 1
    set exception["handled"], $P3714
    set $I3715, exception["handled"]
    ne $I3715, 1, nothandled_3713
  handled_3712:
    .return (exception)
  nothandled_3713:
    rethrow exception
  skip_handler_3709:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3716"  :subid("622_1312646121.678") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2730
    .const 'Sub' $P3746 = "629_1312646121.678" 
    capture_lex $P3746
    .const 'Sub' $P3742 = "628_1312646121.678" 
    capture_lex $P3742
    .const 'Sub' $P3737 = "627_1312646121.678" 
    capture_lex $P3737
    .const 'Sub' $P3733 = "626_1312646121.678" 
    capture_lex $P3733
    .const 'Sub' $P3729 = "625_1312646121.678" 
    capture_lex $P3729
    .const 'Sub' $P3725 = "624_1312646121.678" 
    capture_lex $P3725
    .const 'Sub' $P3720 = "623_1312646121.678" 
    capture_lex $P3720
    .lex "$?PACKAGE", $P3718
    .lex "$?CLASS", $P3719
.annotate 'line', 2764
    .const 'Sub' $P3746 = "629_1312646121.678" 
    newclosure $P3752, $P3746
.annotate 'line', 2730
    .return ($P3752)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("623_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3721
    .param pmc param_3722
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2732
    .lex "self", param_3721
    .lex "$/", param_3722
.annotate 'line', 2733
    new $P103, "Undef"
    set $P3723, $P103
    .lex "$past", $P3723
    find_lex $P3724, "$/"
    unless_null $P3724, vivify_3178
    $P3724 = root_new ['parrot';'Hash']
  vivify_3178:
    set $P104, $P3724["statement"]
    unless_null $P104, vivify_3179
    new $P104, "Undef"
  vivify_3179:
    $P105 = $P104."ast"()
    store_lex "$past", $P105
.annotate 'line', 2734
    find_lex $P104, "$/"
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Regex"]
    find_lex $P109, "$past"
    unless_null $P109, vivify_3180
    new $P109, "Undef"
  vivify_3180:
    find_lex $P110, "$/"
    unless_null $P110, vivify_3181
    new $P110, "Undef"
  vivify_3181:
    $P111 = $P108."new"($P109, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P110 :named("node"))
    $P112 = $P104."!make"($P111)
.annotate 'line', 2732
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("624_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3726
    .param pmc param_3727
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2738
    .lex "self", param_3726
    .lex "$/", param_3727
.annotate 'line', 2739
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3728, "$/"
    unless_null $P3728, vivify_3182
    $P3728 = root_new ['parrot';'Hash']
  vivify_3182:
    set $P108, $P3728["codeblock"]
    unless_null $P108, vivify_3183
    new $P108, "Undef"
  vivify_3183:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3184
    new $P110, "Undef"
  vivify_3184:
    $P111 = $P107."new"($P109, "pastnode" :named("pasttype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2738
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("625_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3730
    .param pmc param_3731
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2743
    .lex "self", param_3730
    .lex "$/", param_3731
.annotate 'line', 2744
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3732, "$/"
    unless_null $P3732, vivify_3185
    $P3732 = root_new ['parrot';'Hash']
  vivify_3185:
    set $P108, $P3732["var"]
    unless_null $P108, vivify_3186
    new $P108, "Undef"
  vivify_3186:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3187
    new $P110, "Undef"
  vivify_3187:
    $P111 = $P107."new"("!INTERPOLATE", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2743
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("626_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3734
    .param pmc param_3735
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2748
    .lex "self", param_3734
    .lex "$/", param_3735
.annotate 'line', 2749
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3736, "$/"
    unless_null $P3736, vivify_3188
    $P3736 = root_new ['parrot';'Hash']
  vivify_3188:
    set $P108, $P3736["codeblock"]
    unless_null $P108, vivify_3189
    new $P108, "Undef"
  vivify_3189:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3190
    new $P110, "Undef"
  vivify_3190:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2748
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("627_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3738
    .param pmc param_3739
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2753
    .lex "self", param_3738
    .lex "$/", param_3739
.annotate 'line', 2754
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3740, "$/"
    unless_null $P3740, vivify_3191
    $P3740 = root_new ['parrot';'Hash']
  vivify_3191:
    set $P108, $P3740["codeblock"]
    unless_null $P108, vivify_3192
    new $P108, "Undef"
  vivify_3192:
    $P109 = $P108."ast"()
.annotate 'line', 2755
    find_lex $P3741, "$/"
    unless_null $P3741, vivify_3193
    $P3741 = root_new ['parrot';'Hash']
  vivify_3193:
    set $P110, $P3741["zw"]
    unless_null $P110, vivify_3194
    new $P110, "Undef"
  vivify_3194:
    set $S100, $P110
    iseq $I100, $S100, "!"
.annotate 'line', 2754
    find_lex $P111, "$/"
    unless_null $P111, vivify_3195
    new $P111, "Undef"
  vivify_3195:
    $P112 = $P107."new"($P109, "zerowidth" :named("subtype"), $I100 :named("negate"), "pastnode" :named("pasttype"), $P111 :named("node"))
    $P113 = $P103."!make"($P112)
.annotate 'line', 2753
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("628_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3743
    .param pmc param_3744
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2759
    .lex "self", param_3743
    .lex "$/", param_3744
.annotate 'line', 2760
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3745, "$/"
    unless_null $P3745, vivify_3196
    $P3745 = root_new ['parrot';'Hash']
  vivify_3196:
    set $P108, $P3745["var"]
    unless_null $P108, vivify_3197
    new $P108, "Undef"
  vivify_3197:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3198
    new $P110, "Undef"
  vivify_3198:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2759
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("629_1312646121.678") :outer("622_1312646121.678")
    .param pmc param_3747
    .param pmc param_3748
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2764
    .lex "self", param_3747
    .lex "$/", param_3748
.annotate 'line', 2765
    new $P103, "Undef"
    set $P3749, $P103
    .lex "$block", $P3749
.annotate 'line', 2767
    new $P104, "Undef"
    set $P3750, $P104
    .lex "$past", $P3750
.annotate 'line', 2765
    find_lex $P3751, "$/"
    unless_null $P3751, vivify_3199
    $P3751 = root_new ['parrot';'Hash']
  vivify_3199:
    set $P105, $P3751["block"]
    unless_null $P105, vivify_3200
    new $P105, "Undef"
  vivify_3200:
    $P106 = $P105."ast"()
    store_lex "$block", $P106
.annotate 'line', 2766
    find_lex $P105, "$block"
    unless_null $P105, vivify_3201
    new $P105, "Undef"
  vivify_3201:
    $P105."blocktype"("immediate")
.annotate 'line', 2768
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 2769
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 2770
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Var"]
    $P117 = $P116."new"("$/" :named("name"))
.annotate 'line', 2771
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 2772
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Var"]
    $P126 = $P125."new"(unicode:"$\x{a2}" :named("name"))
    $P127 = $P121."new"($P126, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2771
    $P128 = $P112."new"($P117, $P127, "bind_6model" :named("pasttype"))
.annotate 'line', 2769
    find_lex $P129, "$block"
    unless_null $P129, vivify_3202
    new $P129, "Undef"
  vivify_3202:
    $P130 = $P108."new"($P128, $P129)
.annotate 'line', 2768
    store_lex "$past", $P130
.annotate 'line', 2780
    find_lex $P105, "$/"
    find_lex $P106, "$past"
    unless_null $P106, vivify_3203
    new $P106, "Undef"
  vivify_3203:
    $P107 = $P105."!make"($P106)
.annotate 'line', 2764
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block3753"  :subid("630_1312646121.678") :outer("10_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2785
    .lex "$?PACKAGE", $P3755
    .lex "$?CLASS", $P3756
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block3759" :load :anon :subid("631_1312646121.678")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1
    .const 'Sub' $P3761 = "10_1312646121.678" 
    $P110 = $P3761()
    .return ($P110)
.end

