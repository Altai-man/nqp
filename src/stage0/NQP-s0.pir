
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303430322.161")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6180 = "573_1303430322.161" 
    capture_lex $P6180
    .const 'Sub' $P6059 = "564_1303430322.161" 
    capture_lex $P6059
    .const 'Sub' $P2598 = "406_1303430322.161" 
    capture_lex $P2598
    .const 'Sub' $P2494 = "384_1303430322.161" 
    capture_lex $P2494
    .const 'Sub' $P37 = "12_1303430322.161" 
    capture_lex $P37
    .const 'Sub' $P16 = "11_1303430322.161" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2252
    .const 'Sub' $P16 = "11_1303430322.161" 
    newclosure $P35, $P16
    .lex "MAIN", $P35
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P37 = "12_1303430322.161" 
    capture_lex $P37
    $P37()
.annotate 'line', 727
    .const 'Sub' $P2494 = "384_1303430322.161" 
    capture_lex $P2494
    $P2494()
.annotate 'line', 770
    .const 'Sub' $P2598 = "406_1303430322.161" 
    capture_lex $P2598
    $P2598()
.annotate 'line', 2194
    .const 'Sub' $P6059 = "564_1303430322.161" 
    capture_lex $P6059
    $P6059()
.annotate 'line', 2249
    .const 'Sub' $P6180 = "573_1303430322.161" 
    capture_lex $P6180
    $P6180()
    find_lex $P6190, "MAIN"
    find_lex $P6193, "@ARGS"
    if $P6193, if_6192
    set $P6191, $P6193
    goto if_6192_end
  if_6192:
    .const 'Sub' $P6194 = "11_1303430322.161" 
    find_lex $P6195, "@ARGS"
    $P6196 = $P6194($P6195 :flat)
    set $P6191, $P6196
  if_6192_end:
.annotate 'line', 1
    .return ($P6191)
    .const 'Sub' $P6198 = "575_1303430322.161" 
    .return ($P6198)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post576") :outer("10_1303430322.161")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303430322.161" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6202, "1303430311.149"
    isnull $I6203, $P6202
    if $I6203, if_6201
    .const 'Sub' $P6308 = "10_1303430322.161" 
    $P6309 = $P6308."get_lexinfo"()
    nqp_get_sc_object $P6310, "1303430311.149", 0
    $P6309."set_static_lexpad_value"("GLOBALish", $P6310)
    .const 'Sub' $P6311 = "10_1303430322.161" 
    $P6312 = $P6311."get_lexinfo"()
    $P6312."finish_static_lexpad"()
    .const 'Sub' $P6313 = "10_1303430322.161" 
    $P6314 = $P6313."get_lexinfo"()
    nqp_get_sc_object $P6315, "1303430311.149", 0
    $P6314."set_static_lexpad_value"("$?PACKAGE", $P6315)
    .const 'Sub' $P6316 = "10_1303430322.161" 
    $P6317 = $P6316."get_lexinfo"()
    $P6317."finish_static_lexpad"()
    nqp_get_sc_object $P6318, "1303430311.149", 1
    set_hll_global ["NQP"], "Grammar", $P6318
    .const 'Sub' $P6319 = "12_1303430322.161" 
    $P6320 = $P6319."get_lexinfo"()
    nqp_get_sc_object $P6321, "1303430311.149", 1
    $P6320."set_static_lexpad_value"("$?PACKAGE", $P6321)
    .const 'Sub' $P6322 = "12_1303430322.161" 
    $P6323 = $P6322."get_lexinfo"()
    $P6323."finish_static_lexpad"()
    .const 'Sub' $P6324 = "12_1303430322.161" 
    $P6325 = $P6324."get_lexinfo"()
    nqp_get_sc_object $P6326, "1303430311.149", 1
    $P6325."set_static_lexpad_value"("$?CLASS", $P6326)
    .const 'Sub' $P6327 = "12_1303430322.161" 
    $P6328 = $P6327."get_lexinfo"()
    $P6328."finish_static_lexpad"()
    nqp_get_sc_object $P6329, "1303430311.149", 2
    set_hll_global ["NQP"], "Regex", $P6329
    .const 'Sub' $P6330 = "384_1303430322.161" 
    $P6331 = $P6330."get_lexinfo"()
    nqp_get_sc_object $P6332, "1303430311.149", 2
    $P6331."set_static_lexpad_value"("$?PACKAGE", $P6332)
    .const 'Sub' $P6333 = "384_1303430322.161" 
    $P6334 = $P6333."get_lexinfo"()
    $P6334."finish_static_lexpad"()
    .const 'Sub' $P6335 = "384_1303430322.161" 
    $P6336 = $P6335."get_lexinfo"()
    nqp_get_sc_object $P6337, "1303430311.149", 2
    $P6336."set_static_lexpad_value"("$?CLASS", $P6337)
    .const 'Sub' $P6338 = "384_1303430322.161" 
    $P6339 = $P6338."get_lexinfo"()
    $P6339."finish_static_lexpad"()
    nqp_get_sc_object $P6340, "1303430311.149", 3
    set_hll_global ["NQP"], "Actions", $P6340
    .const 'Sub' $P6341 = "406_1303430322.161" 
    $P6342 = $P6341."get_lexinfo"()
    nqp_get_sc_object $P6343, "1303430311.149", 3
    $P6342."set_static_lexpad_value"("$?PACKAGE", $P6343)
    .const 'Sub' $P6344 = "406_1303430322.161" 
    $P6345 = $P6344."get_lexinfo"()
    $P6345."finish_static_lexpad"()
    .const 'Sub' $P6346 = "406_1303430322.161" 
    $P6347 = $P6346."get_lexinfo"()
    nqp_get_sc_object $P6348, "1303430311.149", 3
    $P6347."set_static_lexpad_value"("$?CLASS", $P6348)
    .const 'Sub' $P6349 = "406_1303430322.161" 
    $P6350 = $P6349."get_lexinfo"()
    $P6350."finish_static_lexpad"()
    nqp_get_sc_object $P6351, "1303430311.149", 4
    set_hll_global ["NQP"], "RegexActions", $P6351
    .const 'Sub' $P6352 = "564_1303430322.161" 
    $P6353 = $P6352."get_lexinfo"()
    nqp_get_sc_object $P6354, "1303430311.149", 4
    $P6353."set_static_lexpad_value"("$?PACKAGE", $P6354)
    .const 'Sub' $P6355 = "564_1303430322.161" 
    $P6356 = $P6355."get_lexinfo"()
    $P6356."finish_static_lexpad"()
    .const 'Sub' $P6357 = "564_1303430322.161" 
    $P6358 = $P6357."get_lexinfo"()
    nqp_get_sc_object $P6359, "1303430311.149", 4
    $P6358."set_static_lexpad_value"("$?CLASS", $P6359)
    .const 'Sub' $P6360 = "564_1303430322.161" 
    $P6361 = $P6360."get_lexinfo"()
    $P6361."finish_static_lexpad"()
    nqp_get_sc_object $P6362, "1303430311.149", 5
    set_hll_global ["NQP"], "Compiler", $P6362
    .const 'Sub' $P6363 = "573_1303430322.161" 
    $P6364 = $P6363."get_lexinfo"()
    nqp_get_sc_object $P6365, "1303430311.149", 5
    $P6364."set_static_lexpad_value"("$?PACKAGE", $P6365)
    .const 'Sub' $P6366 = "573_1303430322.161" 
    $P6367 = $P6366."get_lexinfo"()
    $P6367."finish_static_lexpad"()
    .const 'Sub' $P6368 = "573_1303430322.161" 
    $P6369 = $P6368."get_lexinfo"()
    nqp_get_sc_object $P6370, "1303430311.149", 5
    $P6369."set_static_lexpad_value"("$?CLASS", $P6370)
    .const 'Sub' $P6371 = "573_1303430322.161" 
    $P6372 = $P6371."get_lexinfo"()
    $P6372."finish_static_lexpad"()
    goto if_6201_end
  if_6201:
    nqp_dynop_setup 
    getinterp $P6204
    get_class $P6205, "LexPad"
    get_class $P6206, "NQPLexPad"
    $P6204."hll_map"($P6205, $P6206)
    nqp_create_sc $P6207, "1303430311.149"
    .local pmc cur_sc
    set cur_sc, $P6207
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6208, "ModuleLoader"
    $P6209 = $P6208."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6209)
    get_hll_global $P6210, "KnowHOW"
    $P6211 = $P6210."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6211, cur_sc
    nqp_set_sc_object "1303430311.149", 0, $P6211
    .const 'Sub' $P6212 = "10_1303430322.161" 
    $P6213 = $P6212."get_lexinfo"()
    nqp_get_sc_object $P6214, "1303430311.149", 0
    $P6213."set_static_lexpad_value"("GLOBALish", $P6214)
    .const 'Sub' $P6215 = "10_1303430322.161" 
    $P6216 = $P6215."get_lexinfo"()
    $P6216."finish_static_lexpad"()
    .const 'Sub' $P6217 = "10_1303430322.161" 
    $P6218 = $P6217."get_lexinfo"()
    nqp_get_sc_object $P6219, "1303430311.149", 0
    $P6218."set_static_lexpad_value"("$?PACKAGE", $P6219)
    .const 'Sub' $P6220 = "10_1303430322.161" 
    $P6221 = $P6220."get_lexinfo"()
    $P6221."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6222, "ModuleLoader"
    $P6222."load_module"("P6Regex")
    get_hll_global $P6223, "NQPClassHOW"
    $P6224 = $P6223."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6224, cur_sc
    nqp_set_sc_object "1303430311.149", 1, $P6224
    nqp_get_sc_object $P6225, "1303430311.149", 1
    nqp_get_sc_object $P6226, "1303430311.149", 0
    nqp_get_package_through_who $P6227, $P6226, "NQP"
    get_who $P6228, $P6227
    set $P6228["Grammar"], $P6225
    nqp_get_sc_object $P6229, "1303430311.149", 1
    set_hll_global ["NQP"], "Grammar", $P6229
    .const 'Sub' $P6230 = "12_1303430322.161" 
    $P6231 = $P6230."get_lexinfo"()
    nqp_get_sc_object $P6232, "1303430311.149", 1
    $P6231."set_static_lexpad_value"("$?PACKAGE", $P6232)
    .const 'Sub' $P6233 = "12_1303430322.161" 
    $P6234 = $P6233."get_lexinfo"()
    $P6234."finish_static_lexpad"()
    .const 'Sub' $P6235 = "12_1303430322.161" 
    $P6236 = $P6235."get_lexinfo"()
    nqp_get_sc_object $P6237, "1303430311.149", 1
    $P6236."set_static_lexpad_value"("$?CLASS", $P6237)
    .const 'Sub' $P6238 = "12_1303430322.161" 
    $P6239 = $P6238."get_lexinfo"()
    $P6239."finish_static_lexpad"()
    get_hll_global $P6240, "NQPClassHOW"
    $P6241 = $P6240."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P6241, cur_sc
    nqp_set_sc_object "1303430311.149", 2, $P6241
    nqp_get_sc_object $P6242, "1303430311.149", 2
    nqp_get_sc_object $P6243, "1303430311.149", 0
    nqp_get_package_through_who $P6244, $P6243, "NQP"
    get_who $P6245, $P6244
    set $P6245["Regex"], $P6242
    nqp_get_sc_object $P6246, "1303430311.149", 2
    set_hll_global ["NQP"], "Regex", $P6246
    .const 'Sub' $P6247 = "384_1303430322.161" 
    $P6248 = $P6247."get_lexinfo"()
    nqp_get_sc_object $P6249, "1303430311.149", 2
    $P6248."set_static_lexpad_value"("$?PACKAGE", $P6249)
    .const 'Sub' $P6250 = "384_1303430322.161" 
    $P6251 = $P6250."get_lexinfo"()
    $P6251."finish_static_lexpad"()
    .const 'Sub' $P6252 = "384_1303430322.161" 
    $P6253 = $P6252."get_lexinfo"()
    nqp_get_sc_object $P6254, "1303430311.149", 2
    $P6253."set_static_lexpad_value"("$?CLASS", $P6254)
    .const 'Sub' $P6255 = "384_1303430322.161" 
    $P6256 = $P6255."get_lexinfo"()
    $P6256."finish_static_lexpad"()
    get_hll_global $P6257, "NQPClassHOW"
    $P6258 = $P6257."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P6258, cur_sc
    nqp_set_sc_object "1303430311.149", 3, $P6258
    nqp_get_sc_object $P6259, "1303430311.149", 3
    nqp_get_sc_object $P6260, "1303430311.149", 0
    nqp_get_package_through_who $P6261, $P6260, "NQP"
    get_who $P6262, $P6261
    set $P6262["Actions"], $P6259
    nqp_get_sc_object $P6263, "1303430311.149", 3
    set_hll_global ["NQP"], "Actions", $P6263
    .const 'Sub' $P6264 = "406_1303430322.161" 
    $P6265 = $P6264."get_lexinfo"()
    nqp_get_sc_object $P6266, "1303430311.149", 3
    $P6265."set_static_lexpad_value"("$?PACKAGE", $P6266)
    .const 'Sub' $P6267 = "406_1303430322.161" 
    $P6268 = $P6267."get_lexinfo"()
    $P6268."finish_static_lexpad"()
    .const 'Sub' $P6269 = "406_1303430322.161" 
    $P6270 = $P6269."get_lexinfo"()
    nqp_get_sc_object $P6271, "1303430311.149", 3
    $P6270."set_static_lexpad_value"("$?CLASS", $P6271)
    .const 'Sub' $P6272 = "406_1303430322.161" 
    $P6273 = $P6272."get_lexinfo"()
    $P6273."finish_static_lexpad"()
    get_hll_global $P6274, "NQPClassHOW"
    $P6275 = $P6274."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P6275, cur_sc
    nqp_set_sc_object "1303430311.149", 4, $P6275
    nqp_get_sc_object $P6276, "1303430311.149", 4
    nqp_get_sc_object $P6277, "1303430311.149", 0
    nqp_get_package_through_who $P6278, $P6277, "NQP"
    get_who $P6279, $P6278
    set $P6279["RegexActions"], $P6276
    nqp_get_sc_object $P6280, "1303430311.149", 4
    set_hll_global ["NQP"], "RegexActions", $P6280
    .const 'Sub' $P6281 = "564_1303430322.161" 
    $P6282 = $P6281."get_lexinfo"()
    nqp_get_sc_object $P6283, "1303430311.149", 4
    $P6282."set_static_lexpad_value"("$?PACKAGE", $P6283)
    .const 'Sub' $P6284 = "564_1303430322.161" 
    $P6285 = $P6284."get_lexinfo"()
    $P6285."finish_static_lexpad"()
    .const 'Sub' $P6286 = "564_1303430322.161" 
    $P6287 = $P6286."get_lexinfo"()
    nqp_get_sc_object $P6288, "1303430311.149", 4
    $P6287."set_static_lexpad_value"("$?CLASS", $P6288)
    .const 'Sub' $P6289 = "564_1303430322.161" 
    $P6290 = $P6289."get_lexinfo"()
    $P6290."finish_static_lexpad"()
    get_hll_global $P6291, "NQPClassHOW"
    $P6292 = $P6291."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P6292, cur_sc
    nqp_set_sc_object "1303430311.149", 5, $P6292
    nqp_get_sc_object $P6293, "1303430311.149", 5
    nqp_get_sc_object $P6294, "1303430311.149", 0
    nqp_get_package_through_who $P6295, $P6294, "NQP"
    get_who $P6296, $P6295
    set $P6296["Compiler"], $P6293
    nqp_get_sc_object $P6297, "1303430311.149", 5
    set_hll_global ["NQP"], "Compiler", $P6297
    .const 'Sub' $P6298 = "573_1303430322.161" 
    $P6299 = $P6298."get_lexinfo"()
    nqp_get_sc_object $P6300, "1303430311.149", 5
    $P6299."set_static_lexpad_value"("$?PACKAGE", $P6300)
    .const 'Sub' $P6301 = "573_1303430322.161" 
    $P6302 = $P6301."get_lexinfo"()
    $P6302."finish_static_lexpad"()
    .const 'Sub' $P6303 = "573_1303430322.161" 
    $P6304 = $P6303."get_lexinfo"()
    nqp_get_sc_object $P6305, "1303430311.149", 5
    $P6304."set_static_lexpad_value"("$?CLASS", $P6305)
    .const 'Sub' $P6306 = "573_1303430322.161" 
    $P6307 = $P6306."get_lexinfo"()
    $P6307."finish_static_lexpad"()
  if_6201_end:
    nqp_get_sc_object $P6373, "1303430311.149", 0
    set_hll_global "GLOBAL", $P6373
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303430322.161") :outer("10_1303430322.161")
    .param pmc param_17
.annotate 'line', 2252
    .lex "@ARGS", param_17
.annotate 'line', 2254
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2260
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2254
    get_hll_global $P20, ["NQP"], "Compiler"
    $P21 = $P20."new"()
    store_lex "$nqpcomp", $P21
.annotate 'line', 2255
    find_lex $P22, "$nqpcomp"
    unless_null $P22, vivify_577
    new $P22, "Undef"
  vivify_577:
    $P22."language"("nqp")
.annotate 'line', 2256
    find_lex $P23, "$nqpcomp"
    unless_null $P23, vivify_578
    new $P23, "Undef"
  vivify_578:
    get_hll_global $P24, ["NQP"], "Grammar"
    $P23."parsegrammar"($P24)
.annotate 'line', 2257
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_579
    new $P25, "Undef"
  vivify_579:
    get_hll_global $P26, ["NQP"], "Actions"
    $P25."parseactions"($P26)
.annotate 'line', 2260
    find_lex $P27, "$nqpcomp"
    unless_null $P27, vivify_580
    new $P27, "Undef"
  vivify_580:
    $P28 = $P27."commandline_options"()
    store_lex "@clo", $P28
.annotate 'line', 2261
    find_lex $P29, "@clo"
    unless_null $P29, vivify_581
    $P29 = root_new ['parrot';'ResizablePMCArray']
  vivify_581:
    $P29."push"("parsetrace")
.annotate 'line', 2262
    find_lex $P30, "@clo"
    unless_null $P30, vivify_582
    $P30 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    $P30."push"("setting=s")
.annotate 'line', 2263
    find_lex $P31, "@clo"
    unless_null $P31, vivify_583
    $P31 = root_new ['parrot';'ResizablePMCArray']
  vivify_583:
    $P31."push"("setting-path=s")
.annotate 'line', 2266
    find_lex $P32, "$nqpcomp"
    unless_null $P32, vivify_584
    new $P32, "Undef"
  vivify_584:
    find_lex $P33, "@ARGS"
    unless_null $P33, vivify_585
    $P33 = root_new ['parrot';'ResizablePMCArray']
  vivify_585:
    $P34 = $P32."command_line"($P33, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2252
    .return ($P34)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block36"  :subid("12_1303430322.161") :outer("10_1303430322.161")
.annotate 'line', 9
    .const 'Sub' $P1771 = "383_1303430322.161" 
    capture_lex $P1771
    .const 'Sub' $P1758 = "382_1303430322.161" 
    capture_lex $P1758
    .const 'Sub' $P1752 = "380_1303430322.161" 
    capture_lex $P1752
    .const 'Sub' $P1746 = "378_1303430322.161" 
    capture_lex $P1746
    .const 'Sub' $P1740 = "376_1303430322.161" 
    capture_lex $P1740
    .const 'Sub' $P1734 = "374_1303430322.161" 
    capture_lex $P1734
    .const 'Sub' $P1722 = "371_1303430322.161" 
    capture_lex $P1722
    .const 'Sub' $P1715 = "369_1303430322.161" 
    capture_lex $P1715
    .const 'Sub' $P1708 = "367_1303430322.161" 
    capture_lex $P1708
    .const 'Sub' $P1701 = "365_1303430322.161" 
    capture_lex $P1701
    .const 'Sub' $P1694 = "363_1303430322.161" 
    capture_lex $P1694
    .const 'Sub' $P1688 = "361_1303430322.161" 
    capture_lex $P1688
    .const 'Sub' $P1681 = "359_1303430322.161" 
    capture_lex $P1681
    .const 'Sub' $P1674 = "357_1303430322.161" 
    capture_lex $P1674
    .const 'Sub' $P1667 = "355_1303430322.161" 
    capture_lex $P1667
    .const 'Sub' $P1660 = "353_1303430322.161" 
    capture_lex $P1660
    .const 'Sub' $P1653 = "351_1303430322.161" 
    capture_lex $P1653
    .const 'Sub' $P1646 = "349_1303430322.161" 
    capture_lex $P1646
    .const 'Sub' $P1639 = "347_1303430322.161" 
    capture_lex $P1639
    .const 'Sub' $P1632 = "345_1303430322.161" 
    capture_lex $P1632
    .const 'Sub' $P1625 = "343_1303430322.161" 
    capture_lex $P1625
    .const 'Sub' $P1618 = "341_1303430322.161" 
    capture_lex $P1618
    .const 'Sub' $P1611 = "339_1303430322.161" 
    capture_lex $P1611
    .const 'Sub' $P1604 = "337_1303430322.161" 
    capture_lex $P1604
    .const 'Sub' $P1597 = "335_1303430322.161" 
    capture_lex $P1597
    .const 'Sub' $P1590 = "333_1303430322.161" 
    capture_lex $P1590
    .const 'Sub' $P1583 = "331_1303430322.161" 
    capture_lex $P1583
    .const 'Sub' $P1576 = "329_1303430322.161" 
    capture_lex $P1576
    .const 'Sub' $P1569 = "327_1303430322.161" 
    capture_lex $P1569
    .const 'Sub' $P1562 = "325_1303430322.161" 
    capture_lex $P1562
    .const 'Sub' $P1555 = "323_1303430322.161" 
    capture_lex $P1555
    .const 'Sub' $P1548 = "321_1303430322.161" 
    capture_lex $P1548
    .const 'Sub' $P1541 = "319_1303430322.161" 
    capture_lex $P1541
    .const 'Sub' $P1534 = "317_1303430322.161" 
    capture_lex $P1534
    .const 'Sub' $P1527 = "315_1303430322.161" 
    capture_lex $P1527
    .const 'Sub' $P1520 = "313_1303430322.161" 
    capture_lex $P1520
    .const 'Sub' $P1513 = "311_1303430322.161" 
    capture_lex $P1513
    .const 'Sub' $P1506 = "309_1303430322.161" 
    capture_lex $P1506
    .const 'Sub' $P1499 = "307_1303430322.161" 
    capture_lex $P1499
    .const 'Sub' $P1492 = "305_1303430322.161" 
    capture_lex $P1492
    .const 'Sub' $P1485 = "303_1303430322.161" 
    capture_lex $P1485
    .const 'Sub' $P1479 = "301_1303430322.161" 
    capture_lex $P1479
    .const 'Sub' $P1472 = "299_1303430322.161" 
    capture_lex $P1472
    .const 'Sub' $P1465 = "297_1303430322.161" 
    capture_lex $P1465
    .const 'Sub' $P1458 = "295_1303430322.161" 
    capture_lex $P1458
    .const 'Sub' $P1451 = "293_1303430322.161" 
    capture_lex $P1451
    .const 'Sub' $P1444 = "291_1303430322.161" 
    capture_lex $P1444
    .const 'Sub' $P1437 = "289_1303430322.161" 
    capture_lex $P1437
    .const 'Sub' $P1430 = "287_1303430322.161" 
    capture_lex $P1430
    .const 'Sub' $P1424 = "285_1303430322.161" 
    capture_lex $P1424
    .const 'Sub' $P1418 = "283_1303430322.161" 
    capture_lex $P1418
    .const 'Sub' $P1413 = "281_1303430322.161" 
    capture_lex $P1413
    .const 'Sub' $P1407 = "279_1303430322.161" 
    capture_lex $P1407
    .const 'Sub' $P1401 = "277_1303430322.161" 
    capture_lex $P1401
    .const 'Sub' $P1396 = "275_1303430322.161" 
    capture_lex $P1396
    .const 'Sub' $P1391 = "273_1303430322.161" 
    capture_lex $P1391
    .const 'Sub' $P1383 = "271_1303430322.161" 
    capture_lex $P1383
    .const 'Sub' $P1374 = "269_1303430322.161" 
    capture_lex $P1374
    .const 'Sub' $P1369 = "267_1303430322.161" 
    capture_lex $P1369
    .const 'Sub' $P1364 = "265_1303430322.161" 
    capture_lex $P1364
    .const 'Sub' $P1359 = "263_1303430322.161" 
    capture_lex $P1359
    .const 'Sub' $P1351 = "261_1303430322.161" 
    capture_lex $P1351
    .const 'Sub' $P1343 = "259_1303430322.161" 
    capture_lex $P1343
    .const 'Sub' $P1338 = "257_1303430322.161" 
    capture_lex $P1338
    .const 'Sub' $P1333 = "255_1303430322.161" 
    capture_lex $P1333
    .const 'Sub' $P1328 = "253_1303430322.161" 
    capture_lex $P1328
    .const 'Sub' $P1322 = "251_1303430322.161" 
    capture_lex $P1322
    .const 'Sub' $P1315 = "249_1303430322.161" 
    capture_lex $P1315
    .const 'Sub' $P1308 = "247_1303430322.161" 
    capture_lex $P1308
    .const 'Sub' $P1301 = "245_1303430322.161" 
    capture_lex $P1301
    .const 'Sub' $P1294 = "243_1303430322.161" 
    capture_lex $P1294
    .const 'Sub' $P1289 = "241_1303430322.161" 
    capture_lex $P1289
    .const 'Sub' $P1284 = "239_1303430322.161" 
    capture_lex $P1284
    .const 'Sub' $P1270 = "235_1303430322.161" 
    capture_lex $P1270
    .const 'Sub' $P1262 = "233_1303430322.161" 
    capture_lex $P1262
    .const 'Sub' $P1256 = "231_1303430322.161" 
    capture_lex $P1256
    .const 'Sub' $P1249 = "229_1303430322.161" 
    capture_lex $P1249
    .const 'Sub' $P1243 = "227_1303430322.161" 
    capture_lex $P1243
    .const 'Sub' $P1229 = "224_1303430322.161" 
    capture_lex $P1229
    .const 'Sub' $P1221 = "222_1303430322.161" 
    capture_lex $P1221
    .const 'Sub' $P1213 = "220_1303430322.161" 
    capture_lex $P1213
    .const 'Sub' $P1207 = "218_1303430322.161" 
    capture_lex $P1207
    .const 'Sub' $P1201 = "216_1303430322.161" 
    capture_lex $P1201
    .const 'Sub' $P1185 = "212_1303430322.161" 
    capture_lex $P1185
    .const 'Sub' $P1144 = "210_1303430322.161" 
    capture_lex $P1144
    .const 'Sub' $P1133 = "208_1303430322.161" 
    capture_lex $P1133
    .const 'Sub' $P1119 = "204_1303430322.161" 
    capture_lex $P1119
    .const 'Sub' $P1110 = "202_1303430322.161" 
    capture_lex $P1110
    .const 'Sub' $P1104 = "200_1303430322.161" 
    capture_lex $P1104
    .const 'Sub' $P1094 = "198_1303430322.161" 
    capture_lex $P1094
    .const 'Sub' $P1079 = "196_1303430322.161" 
    capture_lex $P1079
    .const 'Sub' $P1065 = "193_1303430322.161" 
    capture_lex $P1065
    .const 'Sub' $P1057 = "191_1303430322.161" 
    capture_lex $P1057
    .const 'Sub' $P1047 = "189_1303430322.161" 
    capture_lex $P1047
    .const 'Sub' $P1037 = "187_1303430322.161" 
    capture_lex $P1037
    .const 'Sub' $P1018 = "182_1303430322.161" 
    capture_lex $P1018
    .const 'Sub' $P974 = "179_1303430322.161" 
    capture_lex $P974
    .const 'Sub' $P940 = "177_1303430322.161" 
    capture_lex $P940
    .const 'Sub' $P933 = "175_1303430322.161" 
    capture_lex $P933
    .const 'Sub' $P926 = "173_1303430322.161" 
    capture_lex $P926
    .const 'Sub' $P909 = "169_1303430322.161" 
    capture_lex $P909
    .const 'Sub' $P901 = "167_1303430322.161" 
    capture_lex $P901
    .const 'Sub' $P895 = "165_1303430322.161" 
    capture_lex $P895
    .const 'Sub' $P879 = "163_1303430322.161" 
    capture_lex $P879
    .const 'Sub' $P872 = "161_1303430322.161" 
    capture_lex $P872
    .const 'Sub' $P865 = "159_1303430322.161" 
    capture_lex $P865
    .const 'Sub' $P858 = "157_1303430322.161" 
    capture_lex $P858
    .const 'Sub' $P716 = "152_1303430322.161" 
    capture_lex $P716
    .const 'Sub' $P702 = "150_1303430322.161" 
    capture_lex $P702
    .const 'Sub' $P688 = "148_1303430322.161" 
    capture_lex $P688
    .const 'Sub' $P674 = "146_1303430322.161" 
    capture_lex $P674
    .const 'Sub' $P660 = "144_1303430322.161" 
    capture_lex $P660
    .const 'Sub' $P646 = "142_1303430322.161" 
    capture_lex $P646
    .const 'Sub' $P632 = "140_1303430322.161" 
    capture_lex $P632
    .const 'Sub' $P621 = "136_1303430322.161" 
    capture_lex $P621
    .const 'Sub' $P616 = "134_1303430322.161" 
    capture_lex $P616
    .const 'Sub' $P604 = "132_1303430322.161" 
    capture_lex $P604
    .const 'Sub' $P592 = "130_1303430322.161" 
    capture_lex $P592
    .const 'Sub' $P585 = "128_1303430322.161" 
    capture_lex $P585
    .const 'Sub' $P580 = "126_1303430322.161" 
    capture_lex $P580
    .const 'Sub' $P574 = "124_1303430322.161" 
    capture_lex $P574
    .const 'Sub' $P568 = "122_1303430322.161" 
    capture_lex $P568
    .const 'Sub' $P553 = "118_1303430322.161" 
    capture_lex $P553
    .const 'Sub' $P547 = "116_1303430322.161" 
    capture_lex $P547
    .const 'Sub' $P541 = "114_1303430322.161" 
    capture_lex $P541
    .const 'Sub' $P535 = "112_1303430322.161" 
    capture_lex $P535
    .const 'Sub' $P529 = "110_1303430322.161" 
    capture_lex $P529
    .const 'Sub' $P523 = "108_1303430322.161" 
    capture_lex $P523
    .const 'Sub' $P517 = "106_1303430322.161" 
    capture_lex $P517
    .const 'Sub' $P508 = "104_1303430322.161" 
    capture_lex $P508
    .const 'Sub' $P499 = "102_1303430322.161" 
    capture_lex $P499
    .const 'Sub' $P490 = "100_1303430322.161" 
    capture_lex $P490
    .const 'Sub' $P475 = "96_1303430322.161" 
    capture_lex $P475
    .const 'Sub' $P466 = "94_1303430322.161" 
    capture_lex $P466
    .const 'Sub' $P454 = "90_1303430322.161" 
    capture_lex $P454
    .const 'Sub' $P447 = "88_1303430322.161" 
    capture_lex $P447
    .const 'Sub' $P440 = "86_1303430322.161" 
    capture_lex $P440
    .const 'Sub' $P426 = "82_1303430322.161" 
    capture_lex $P426
    .const 'Sub' $P418 = "80_1303430322.161" 
    capture_lex $P418
    .const 'Sub' $P410 = "78_1303430322.161" 
    capture_lex $P410
    .const 'Sub' $P390 = "76_1303430322.161" 
    capture_lex $P390
    .const 'Sub' $P381 = "74_1303430322.161" 
    capture_lex $P381
    .const 'Sub' $P363 = "71_1303430322.161" 
    capture_lex $P363
    .const 'Sub' $P345 = "69_1303430322.161" 
    capture_lex $P345
    .const 'Sub' $P337 = "67_1303430322.161" 
    capture_lex $P337
    .const 'Sub' $P326 = "63_1303430322.161" 
    capture_lex $P326
    .const 'Sub' $P321 = "61_1303430322.161" 
    capture_lex $P321
    .const 'Sub' $P310 = "57_1303430322.161" 
    capture_lex $P310
    .const 'Sub' $P305 = "55_1303430322.161" 
    capture_lex $P305
    .const 'Sub' $P300 = "53_1303430322.161" 
    capture_lex $P300
    .const 'Sub' $P295 = "51_1303430322.161" 
    capture_lex $P295
    .const 'Sub' $P290 = "49_1303430322.161" 
    capture_lex $P290
    .const 'Sub' $P280 = "47_1303430322.161" 
    capture_lex $P280
    .const 'Sub' $P273 = "45_1303430322.161" 
    capture_lex $P273
    .const 'Sub' $P267 = "43_1303430322.161" 
    capture_lex $P267
    .const 'Sub' $P259 = "41_1303430322.161" 
    capture_lex $P259
    .const 'Sub' $P253 = "39_1303430322.161" 
    capture_lex $P253
    .const 'Sub' $P247 = "37_1303430322.161" 
    capture_lex $P247
    .const 'Sub' $P232 = "34_1303430322.161" 
    capture_lex $P232
    .const 'Sub' $P218 = "32_1303430322.161" 
    capture_lex $P218
    .const 'Sub' $P203 = "30_1303430322.161" 
    capture_lex $P203
    .const 'Sub' $P164 = "27_1303430322.161" 
    capture_lex $P164
    .const 'Sub' $P149 = "24_1303430322.161" 
    capture_lex $P149
    .const 'Sub' $P138 = "22_1303430322.161" 
    capture_lex $P138
    .const 'Sub' $P126 = "20_1303430322.161" 
    capture_lex $P126
    .const 'Sub' $P118 = "18_1303430322.161" 
    capture_lex $P118
    .const 'Sub' $P111 = "16_1303430322.161" 
    capture_lex $P111
    .const 'Sub' $P104 = "14_1303430322.161" 
    capture_lex $P104
    .const 'Sub' $P55 = "13_1303430322.161" 
    capture_lex $P55
    .lex "$?PACKAGE", $P38
    .lex "$?CLASS", $P39
.annotate 'line', 608
    get_hll_global $P40, ["NQP"], "Grammar"
    $P40."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 609
    get_hll_global $P41, ["NQP"], "Grammar"
    $P41."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 610
    get_hll_global $P42, ["NQP"], "Grammar"
    $P42."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 611
    get_hll_global $P43, ["NQP"], "Grammar"
    $P43."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 612
    get_hll_global $P44, ["NQP"], "Grammar"
    $P44."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 613
    get_hll_global $P45, ["NQP"], "Grammar"
    $P45."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 614
    get_hll_global $P46, ["NQP"], "Grammar"
    $P46."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 615
    get_hll_global $P47, ["NQP"], "Grammar"
    $P47."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 616
    get_hll_global $P48, ["NQP"], "Grammar"
    $P48."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 617
    get_hll_global $P49, ["NQP"], "Grammar"
    $P49."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 618
    get_hll_global $P50, ["NQP"], "Grammar"
    $P50."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 619
    get_hll_global $P51, ["NQP"], "Grammar"
    $P51."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 620
    get_hll_global $P52, ["NQP"], "Grammar"
    $P52."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 621
    get_hll_global $P53, ["NQP"], "Grammar"
    $P53."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 622
    get_hll_global $P54, ["NQP"], "Grammar"
    $P54."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 721
    .const 'Sub' $P1758 = "382_1303430322.161" 
    newclosure $P1769, $P1758
.annotate 'line', 9
    .return ($P1769)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post586") :outer("12_1303430322.161")
.annotate 'line', 9
    .const 'Sub' $P37 = "12_1303430322.161" 
    .local pmc block
    set block, $P37
    .const 'Sub' $P1771 = "383_1303430322.161" 
    capture_lex $P1771
    $P1771()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1770"  :anon :subid("383_1303430322.161") :outer("12_1303430322.161")
.annotate 'line', 9
    nqp_get_sc_object $P1772, "1303430311.149", 1
    .local pmc type_obj
    set type_obj, $P1772
    get_how $P1773, type_obj
    .const 'Sub' $P1774 = "13_1303430322.161" 
    $P1773."add_method"(type_obj, "TOP", $P1774)
    get_how $P1775, type_obj
    .const 'Sub' $P1776 = "14_1303430322.161" 
    $P1775."add_method"(type_obj, "identifier", $P1776)
    get_how $P1777, type_obj
    get_global $P1778, "!PREFIX__identifier"
    $P1777."add_method"(type_obj, "!PREFIX__identifier", $P1778)
    get_how $P1779, type_obj
    .const 'Sub' $P1780 = "16_1303430322.161" 
    $P1779."add_method"(type_obj, "name", $P1780)
    get_how $P1781, type_obj
    get_global $P1782, "!PREFIX__name"
    $P1781."add_method"(type_obj, "!PREFIX__name", $P1782)
    get_how $P1783, type_obj
    .const 'Sub' $P1784 = "18_1303430322.161" 
    $P1783."add_method"(type_obj, "deflongname", $P1784)
    get_how $P1785, type_obj
    get_global $P1786, "!PREFIX__deflongname"
    $P1785."add_method"(type_obj, "!PREFIX__deflongname", $P1786)
    get_how $P1787, type_obj
    .const 'Sub' $P1788 = "20_1303430322.161" 
    $P1787."add_method"(type_obj, "ENDSTMT", $P1788)
    get_how $P1789, type_obj
    get_global $P1790, "!PREFIX__ENDSTMT"
    $P1789."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1790)
    get_how $P1791, type_obj
    .const 'Sub' $P1792 = "22_1303430322.161" 
    $P1791."add_method"(type_obj, "ws", $P1792)
    get_how $P1793, type_obj
    get_global $P1794, "!PREFIX__ws"
    $P1793."add_method"(type_obj, "!PREFIX__ws", $P1794)
    get_how $P1795, type_obj
    .const 'Sub' $P1796 = "24_1303430322.161" 
    $P1795."add_method"(type_obj, "unv", $P1796)
    get_how $P1797, type_obj
    get_global $P1798, "!PREFIX__unv"
    $P1797."add_method"(type_obj, "!PREFIX__unv", $P1798)
    get_how $P1799, type_obj
    .const 'Sub' $P1800 = "27_1303430322.161" 
    $P1799."add_method"(type_obj, "pod_comment", $P1800)
    get_how $P1801, type_obj
    get_global $P1802, "!PREFIX__pod_comment"
    $P1801."add_method"(type_obj, "!PREFIX__pod_comment", $P1802)
    get_how $P1803, type_obj
    .const 'Sub' $P1804 = "30_1303430322.161" 
    $P1803."add_method"(type_obj, "comp_unit", $P1804)
    get_how $P1805, type_obj
    get_global $P1806, "!PREFIX__comp_unit"
    $P1805."add_method"(type_obj, "!PREFIX__comp_unit", $P1806)
    get_how $P1807, type_obj
    .const 'Sub' $P1808 = "32_1303430322.161" 
    $P1807."add_method"(type_obj, "statementlist", $P1808)
    get_how $P1809, type_obj
    get_global $P1810, "!PREFIX__statementlist"
    $P1809."add_method"(type_obj, "!PREFIX__statementlist", $P1810)
    get_how $P1811, type_obj
    .const 'Sub' $P1812 = "34_1303430322.161" 
    $P1811."add_method"(type_obj, "statement", $P1812)
    get_how $P1813, type_obj
    get_global $P1814, "!PREFIX__statement"
    $P1813."add_method"(type_obj, "!PREFIX__statement", $P1814)
    get_how $P1815, type_obj
    .const 'Sub' $P1816 = "37_1303430322.161" 
    $P1815."add_method"(type_obj, "eat_terminator", $P1816)
    get_how $P1817, type_obj
    get_global $P1818, "!PREFIX__eat_terminator"
    $P1817."add_method"(type_obj, "!PREFIX__eat_terminator", $P1818)
    get_how $P1819, type_obj
    .const 'Sub' $P1820 = "39_1303430322.161" 
    $P1819."add_method"(type_obj, "xblock", $P1820)
    get_how $P1821, type_obj
    get_global $P1822, "!PREFIX__xblock"
    $P1821."add_method"(type_obj, "!PREFIX__xblock", $P1822)
    get_how $P1823, type_obj
    .const 'Sub' $P1824 = "41_1303430322.161" 
    $P1823."add_method"(type_obj, "pblock", $P1824)
    get_how $P1825, type_obj
    get_global $P1826, "!PREFIX__pblock"
    $P1825."add_method"(type_obj, "!PREFIX__pblock", $P1826)
    get_how $P1827, type_obj
    .const 'Sub' $P1828 = "43_1303430322.161" 
    $P1827."add_method"(type_obj, "lambda", $P1828)
    get_how $P1829, type_obj
    get_global $P1830, "!PREFIX__lambda"
    $P1829."add_method"(type_obj, "!PREFIX__lambda", $P1830)
    get_how $P1831, type_obj
    .const 'Sub' $P1832 = "45_1303430322.161" 
    $P1831."add_method"(type_obj, "block", $P1832)
    get_how $P1833, type_obj
    get_global $P1834, "!PREFIX__block"
    $P1833."add_method"(type_obj, "!PREFIX__block", $P1834)
    get_how $P1835, type_obj
    .const 'Sub' $P1836 = "47_1303430322.161" 
    $P1835."add_method"(type_obj, "blockoid", $P1836)
    get_how $P1837, type_obj
    get_global $P1838, "!PREFIX__blockoid"
    $P1837."add_method"(type_obj, "!PREFIX__blockoid", $P1838)
    get_how $P1839, type_obj
    .const 'Sub' $P1840 = "49_1303430322.161" 
    $P1839."add_method"(type_obj, "newpad", $P1840)
    get_how $P1841, type_obj
    get_global $P1842, "!PREFIX__newpad"
    $P1841."add_method"(type_obj, "!PREFIX__newpad", $P1842)
    get_how $P1843, type_obj
    .const 'Sub' $P1844 = "51_1303430322.161" 
    $P1843."add_method"(type_obj, "outerctx", $P1844)
    get_how $P1845, type_obj
    get_global $P1846, "!PREFIX__outerctx"
    $P1845."add_method"(type_obj, "!PREFIX__outerctx", $P1846)
    get_how $P1847, type_obj
    .const 'Sub' $P1848 = "53_1303430322.161" 
    $P1847."add_method"(type_obj, "GLOBALish", $P1848)
    get_how $P1849, type_obj
    get_global $P1850, "!PREFIX__GLOBALish"
    $P1849."add_method"(type_obj, "!PREFIX__GLOBALish", $P1850)
    get_how $P1851, type_obj
    .const 'Sub' $P1852 = "55_1303430322.161" 
    $P1851."add_method"(type_obj, "finishpad", $P1852)
    get_how $P1853, type_obj
    get_global $P1854, "!PREFIX__finishpad"
    $P1853."add_method"(type_obj, "!PREFIX__finishpad", $P1854)
    get_how $P1855, type_obj
    .const 'Sub' $P1856 = "57_1303430322.161" 
    $P1855."add_method"(type_obj, "you_are_here", $P1856)
    get_how $P1857, type_obj
    get_global $P1858, "!PREFIX__you_are_here"
    $P1857."add_method"(type_obj, "!PREFIX__you_are_here", $P1858)
    get_how $P1859, type_obj
    .const 'Sub' $P1860 = "59_1303430322.161" 
    $P1859."add_method"(type_obj, "terminator", $P1860)
    get_how $P1861, type_obj
    .const 'Sub' $P1862 = "60_1303430322.161" 
    $P1861."add_method"(type_obj, "!PREFIX__terminator", $P1862)
    get_how $P1863, type_obj
    .const 'Sub' $P1864 = "61_1303430322.161" 
    $P1863."add_method"(type_obj, "terminator:sym<;>", $P1864)
    get_how $P1865, type_obj
    get_global $P1866, "!PREFIX__terminator:sym<;>"
    $P1865."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1866)
    get_how $P1867, type_obj
    .const 'Sub' $P1868 = "63_1303430322.161" 
    $P1867."add_method"(type_obj, "terminator:sym<}>", $P1868)
    get_how $P1869, type_obj
    get_global $P1870, "!PREFIX__terminator:sym<}>"
    $P1869."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1870)
    get_how $P1871, type_obj
    .const 'Sub' $P1872 = "65_1303430322.161" 
    $P1871."add_method"(type_obj, "statement_control", $P1872)
    get_how $P1873, type_obj
    .const 'Sub' $P1874 = "66_1303430322.161" 
    $P1873."add_method"(type_obj, "!PREFIX__statement_control", $P1874)
    get_how $P1875, type_obj
    .const 'Sub' $P1876 = "67_1303430322.161" 
    $P1875."add_method"(type_obj, "statement_control:sym<use>", $P1876)
    get_how $P1877, type_obj
    get_global $P1878, "!PREFIX__statement_control:sym<use>"
    $P1877."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1878)
    get_how $P1879, type_obj
    .const 'Sub' $P1880 = "69_1303430322.161" 
    $P1879."add_method"(type_obj, "statement_control:sym<if>", $P1880)
    get_how $P1881, type_obj
    get_global $P1882, "!PREFIX__statement_control:sym<if>"
    $P1881."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1882)
    get_how $P1883, type_obj
    .const 'Sub' $P1884 = "71_1303430322.161" 
    $P1883."add_method"(type_obj, "statement_control:sym<unless>", $P1884)
    get_how $P1885, type_obj
    get_global $P1886, "!PREFIX__statement_control:sym<unless>"
    $P1885."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1886)
    get_how $P1887, type_obj
    .const 'Sub' $P1888 = "74_1303430322.161" 
    $P1887."add_method"(type_obj, "statement_control:sym<while>", $P1888)
    get_how $P1889, type_obj
    get_global $P1890, "!PREFIX__statement_control:sym<while>"
    $P1889."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1890)
    get_how $P1891, type_obj
    .const 'Sub' $P1892 = "76_1303430322.161" 
    $P1891."add_method"(type_obj, "statement_control:sym<repeat>", $P1892)
    get_how $P1893, type_obj
    get_global $P1894, "!PREFIX__statement_control:sym<repeat>"
    $P1893."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1894)
    get_how $P1895, type_obj
    .const 'Sub' $P1896 = "78_1303430322.161" 
    $P1895."add_method"(type_obj, "statement_control:sym<for>", $P1896)
    get_how $P1897, type_obj
    get_global $P1898, "!PREFIX__statement_control:sym<for>"
    $P1897."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1898)
    get_how $P1899, type_obj
    .const 'Sub' $P1900 = "80_1303430322.161" 
    $P1899."add_method"(type_obj, "statement_control:sym<CATCH>", $P1900)
    get_how $P1901, type_obj
    get_global $P1902, "!PREFIX__statement_control:sym<CATCH>"
    $P1901."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1902)
    get_how $P1903, type_obj
    .const 'Sub' $P1904 = "82_1303430322.161" 
    $P1903."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1904)
    get_how $P1905, type_obj
    get_global $P1906, "!PREFIX__statement_control:sym<CONTROL>"
    $P1905."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1906)
    get_how $P1907, type_obj
    .const 'Sub' $P1908 = "84_1303430322.161" 
    $P1907."add_method"(type_obj, "statement_prefix", $P1908)
    get_how $P1909, type_obj
    .const 'Sub' $P1910 = "85_1303430322.161" 
    $P1909."add_method"(type_obj, "!PREFIX__statement_prefix", $P1910)
    get_how $P1911, type_obj
    .const 'Sub' $P1912 = "86_1303430322.161" 
    $P1911."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1912)
    get_how $P1913, type_obj
    get_global $P1914, "!PREFIX__statement_prefix:sym<INIT>"
    $P1913."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1914)
    get_how $P1915, type_obj
    .const 'Sub' $P1916 = "88_1303430322.161" 
    $P1915."add_method"(type_obj, "statement_prefix:sym<try>", $P1916)
    get_how $P1917, type_obj
    get_global $P1918, "!PREFIX__statement_prefix:sym<try>"
    $P1917."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1918)
    get_how $P1919, type_obj
    .const 'Sub' $P1920 = "90_1303430322.161" 
    $P1919."add_method"(type_obj, "blorst", $P1920)
    get_how $P1921, type_obj
    get_global $P1922, "!PREFIX__blorst"
    $P1921."add_method"(type_obj, "!PREFIX__blorst", $P1922)
    get_how $P1923, type_obj
    .const 'Sub' $P1924 = "92_1303430322.161" 
    $P1923."add_method"(type_obj, "statement_mod_cond", $P1924)
    get_how $P1925, type_obj
    .const 'Sub' $P1926 = "93_1303430322.161" 
    $P1925."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1926)
    get_how $P1927, type_obj
    .const 'Sub' $P1928 = "94_1303430322.161" 
    $P1927."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1928)
    get_how $P1929, type_obj
    get_global $P1930, "!PREFIX__statement_mod_cond:sym<if>"
    $P1929."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "96_1303430322.161" 
    $P1931."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1932)
    get_how $P1933, type_obj
    get_global $P1934, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1933."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1934)
    get_how $P1935, type_obj
    .const 'Sub' $P1936 = "98_1303430322.161" 
    $P1935."add_method"(type_obj, "statement_mod_loop", $P1936)
    get_how $P1937, type_obj
    .const 'Sub' $P1938 = "99_1303430322.161" 
    $P1937."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1938)
    get_how $P1939, type_obj
    .const 'Sub' $P1940 = "100_1303430322.161" 
    $P1939."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1940)
    get_how $P1941, type_obj
    get_global $P1942, "!PREFIX__statement_mod_loop:sym<while>"
    $P1941."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1942)
    get_how $P1943, type_obj
    .const 'Sub' $P1944 = "102_1303430322.161" 
    $P1943."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1944)
    get_how $P1945, type_obj
    get_global $P1946, "!PREFIX__statement_mod_loop:sym<until>"
    $P1945."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1946)
    get_how $P1947, type_obj
    .const 'Sub' $P1948 = "104_1303430322.161" 
    $P1947."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1948)
    get_how $P1949, type_obj
    get_global $P1950, "!PREFIX__statement_mod_loop:sym<for>"
    $P1949."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1950)
    get_how $P1951, type_obj
    .const 'Sub' $P1952 = "106_1303430322.161" 
    $P1951."add_method"(type_obj, "term:sym<fatarrow>", $P1952)
    get_how $P1953, type_obj
    get_global $P1954, "!PREFIX__term:sym<fatarrow>"
    $P1953."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1954)
    get_how $P1955, type_obj
    .const 'Sub' $P1956 = "108_1303430322.161" 
    $P1955."add_method"(type_obj, "term:sym<colonpair>", $P1956)
    get_how $P1957, type_obj
    get_global $P1958, "!PREFIX__term:sym<colonpair>"
    $P1957."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1958)
    get_how $P1959, type_obj
    .const 'Sub' $P1960 = "110_1303430322.161" 
    $P1959."add_method"(type_obj, "term:sym<variable>", $P1960)
    get_how $P1961, type_obj
    get_global $P1962, "!PREFIX__term:sym<variable>"
    $P1961."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1962)
    get_how $P1963, type_obj
    .const 'Sub' $P1964 = "112_1303430322.161" 
    $P1963."add_method"(type_obj, "term:sym<package_declarator>", $P1964)
    get_how $P1965, type_obj
    get_global $P1966, "!PREFIX__term:sym<package_declarator>"
    $P1965."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1966)
    get_how $P1967, type_obj
    .const 'Sub' $P1968 = "114_1303430322.161" 
    $P1967."add_method"(type_obj, "term:sym<scope_declarator>", $P1968)
    get_how $P1969, type_obj
    get_global $P1970, "!PREFIX__term:sym<scope_declarator>"
    $P1969."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1970)
    get_how $P1971, type_obj
    .const 'Sub' $P1972 = "116_1303430322.161" 
    $P1971."add_method"(type_obj, "term:sym<routine_declarator>", $P1972)
    get_how $P1973, type_obj
    get_global $P1974, "!PREFIX__term:sym<routine_declarator>"
    $P1973."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1974)
    get_how $P1975, type_obj
    .const 'Sub' $P1976 = "118_1303430322.161" 
    $P1975."add_method"(type_obj, "term:sym<multi_declarator>", $P1976)
    get_how $P1977, type_obj
    get_global $P1978, "!PREFIX__term:sym<multi_declarator>"
    $P1977."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1978)
    get_how $P1979, type_obj
    .const 'Sub' $P1980 = "122_1303430322.161" 
    $P1979."add_method"(type_obj, "term:sym<regex_declarator>", $P1980)
    get_how $P1981, type_obj
    get_global $P1982, "!PREFIX__term:sym<regex_declarator>"
    $P1981."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1982)
    get_how $P1983, type_obj
    .const 'Sub' $P1984 = "124_1303430322.161" 
    $P1983."add_method"(type_obj, "term:sym<statement_prefix>", $P1984)
    get_how $P1985, type_obj
    get_global $P1986, "!PREFIX__term:sym<statement_prefix>"
    $P1985."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1986)
    get_how $P1987, type_obj
    .const 'Sub' $P1988 = "126_1303430322.161" 
    $P1987."add_method"(type_obj, "term:sym<lambda>", $P1988)
    get_how $P1989, type_obj
    get_global $P1990, "!PREFIX__term:sym<lambda>"
    $P1989."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1990)
    get_how $P1991, type_obj
    .const 'Sub' $P1992 = "128_1303430322.161" 
    $P1991."add_method"(type_obj, "fatarrow", $P1992)
    get_how $P1993, type_obj
    get_global $P1994, "!PREFIX__fatarrow"
    $P1993."add_method"(type_obj, "!PREFIX__fatarrow", $P1994)
    get_how $P1995, type_obj
    .const 'Sub' $P1996 = "130_1303430322.161" 
    $P1995."add_method"(type_obj, "colonpair", $P1996)
    get_how $P1997, type_obj
    get_global $P1998, "!PREFIX__colonpair"
    $P1997."add_method"(type_obj, "!PREFIX__colonpair", $P1998)
    get_how $P1999, type_obj
    .const 'Sub' $P2000 = "132_1303430322.161" 
    $P1999."add_method"(type_obj, "variable", $P2000)
    get_how $P2001, type_obj
    get_global $P2002, "!PREFIX__variable"
    $P2001."add_method"(type_obj, "!PREFIX__variable", $P2002)
    get_how $P2003, type_obj
    .const 'Sub' $P2004 = "134_1303430322.161" 
    $P2003."add_method"(type_obj, "sigil", $P2004)
    get_how $P2005, type_obj
    get_global $P2006, "!PREFIX__sigil"
    $P2005."add_method"(type_obj, "!PREFIX__sigil", $P2006)
    get_how $P2007, type_obj
    .const 'Sub' $P2008 = "136_1303430322.161" 
    $P2007."add_method"(type_obj, "twigil", $P2008)
    get_how $P2009, type_obj
    get_global $P2010, "!PREFIX__twigil"
    $P2009."add_method"(type_obj, "!PREFIX__twigil", $P2010)
    get_how $P2011, type_obj
    .const 'Sub' $P2012 = "138_1303430322.161" 
    $P2011."add_method"(type_obj, "package_declarator", $P2012)
    get_how $P2013, type_obj
    .const 'Sub' $P2014 = "139_1303430322.161" 
    $P2013."add_method"(type_obj, "!PREFIX__package_declarator", $P2014)
    get_how $P2015, type_obj
    .const 'Sub' $P2016 = "140_1303430322.161" 
    $P2015."add_method"(type_obj, "package_declarator:sym<module>", $P2016)
    get_how $P2017, type_obj
    get_global $P2018, "!PREFIX__package_declarator:sym<module>"
    $P2017."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2018)
    get_how $P2019, type_obj
    .const 'Sub' $P2020 = "142_1303430322.161" 
    $P2019."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2020)
    get_how $P2021, type_obj
    get_global $P2022, "!PREFIX__package_declarator:sym<knowhow>"
    $P2021."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2022)
    get_how $P2023, type_obj
    .const 'Sub' $P2024 = "144_1303430322.161" 
    $P2023."add_method"(type_obj, "package_declarator:sym<class>", $P2024)
    get_how $P2025, type_obj
    get_global $P2026, "!PREFIX__package_declarator:sym<class>"
    $P2025."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2026)
    get_how $P2027, type_obj
    .const 'Sub' $P2028 = "146_1303430322.161" 
    $P2027."add_method"(type_obj, "package_declarator:sym<grammar>", $P2028)
    get_how $P2029, type_obj
    get_global $P2030, "!PREFIX__package_declarator:sym<grammar>"
    $P2029."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2030)
    get_how $P2031, type_obj
    .const 'Sub' $P2032 = "148_1303430322.161" 
    $P2031."add_method"(type_obj, "package_declarator:sym<role>", $P2032)
    get_how $P2033, type_obj
    get_global $P2034, "!PREFIX__package_declarator:sym<role>"
    $P2033."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2034)
    get_how $P2035, type_obj
    .const 'Sub' $P2036 = "150_1303430322.161" 
    $P2035."add_method"(type_obj, "package_declarator:sym<native>", $P2036)
    get_how $P2037, type_obj
    get_global $P2038, "!PREFIX__package_declarator:sym<native>"
    $P2037."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2038)
    get_how $P2039, type_obj
    .const 'Sub' $P2040 = "152_1303430322.161" 
    $P2039."add_method"(type_obj, "package_def", $P2040)
    get_how $P2041, type_obj
    get_global $P2042, "!PREFIX__package_def"
    $P2041."add_method"(type_obj, "!PREFIX__package_def", $P2042)
    get_how $P2043, type_obj
    .const 'Sub' $P2044 = "155_1303430322.161" 
    $P2043."add_method"(type_obj, "scope_declarator", $P2044)
    get_how $P2045, type_obj
    .const 'Sub' $P2046 = "156_1303430322.161" 
    $P2045."add_method"(type_obj, "!PREFIX__scope_declarator", $P2046)
    get_how $P2047, type_obj
    .const 'Sub' $P2048 = "157_1303430322.161" 
    $P2047."add_method"(type_obj, "scope_declarator:sym<my>", $P2048)
    get_how $P2049, type_obj
    get_global $P2050, "!PREFIX__scope_declarator:sym<my>"
    $P2049."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2050)
    get_how $P2051, type_obj
    .const 'Sub' $P2052 = "159_1303430322.161" 
    $P2051."add_method"(type_obj, "scope_declarator:sym<our>", $P2052)
    get_how $P2053, type_obj
    get_global $P2054, "!PREFIX__scope_declarator:sym<our>"
    $P2053."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2054)
    get_how $P2055, type_obj
    .const 'Sub' $P2056 = "161_1303430322.161" 
    $P2055."add_method"(type_obj, "scope_declarator:sym<has>", $P2056)
    get_how $P2057, type_obj
    get_global $P2058, "!PREFIX__scope_declarator:sym<has>"
    $P2057."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2058)
    get_how $P2059, type_obj
    .const 'Sub' $P2060 = "163_1303430322.161" 
    $P2059."add_method"(type_obj, "scoped", $P2060)
    get_how $P2061, type_obj
    get_global $P2062, "!PREFIX__scoped"
    $P2061."add_method"(type_obj, "!PREFIX__scoped", $P2062)
    get_how $P2063, type_obj
    .const 'Sub' $P2064 = "165_1303430322.161" 
    $P2063."add_method"(type_obj, "typename", $P2064)
    get_how $P2065, type_obj
    get_global $P2066, "!PREFIX__typename"
    $P2065."add_method"(type_obj, "!PREFIX__typename", $P2066)
    get_how $P2067, type_obj
    .const 'Sub' $P2068 = "167_1303430322.161" 
    $P2067."add_method"(type_obj, "declarator", $P2068)
    get_how $P2069, type_obj
    get_global $P2070, "!PREFIX__declarator"
    $P2069."add_method"(type_obj, "!PREFIX__declarator", $P2070)
    get_how $P2071, type_obj
    .const 'Sub' $P2072 = "169_1303430322.161" 
    $P2071."add_method"(type_obj, "variable_declarator", $P2072)
    get_how $P2073, type_obj
    get_global $P2074, "!PREFIX__variable_declarator"
    $P2073."add_method"(type_obj, "!PREFIX__variable_declarator", $P2074)
    get_how $P2075, type_obj
    .const 'Sub' $P2076 = "171_1303430322.161" 
    $P2075."add_method"(type_obj, "routine_declarator", $P2076)
    get_how $P2077, type_obj
    .const 'Sub' $P2078 = "172_1303430322.161" 
    $P2077."add_method"(type_obj, "!PREFIX__routine_declarator", $P2078)
    get_how $P2079, type_obj
    .const 'Sub' $P2080 = "173_1303430322.161" 
    $P2079."add_method"(type_obj, "routine_declarator:sym<sub>", $P2080)
    get_how $P2081, type_obj
    get_global $P2082, "!PREFIX__routine_declarator:sym<sub>"
    $P2081."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2082)
    get_how $P2083, type_obj
    .const 'Sub' $P2084 = "175_1303430322.161" 
    $P2083."add_method"(type_obj, "routine_declarator:sym<method>", $P2084)
    get_how $P2085, type_obj
    get_global $P2086, "!PREFIX__routine_declarator:sym<method>"
    $P2085."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2086)
    get_how $P2087, type_obj
    .const 'Sub' $P2088 = "177_1303430322.161" 
    $P2087."add_method"(type_obj, "routine_def", $P2088)
    get_how $P2089, type_obj
    get_global $P2090, "!PREFIX__routine_def"
    $P2089."add_method"(type_obj, "!PREFIX__routine_def", $P2090)
    get_how $P2091, type_obj
    .const 'Sub' $P2092 = "179_1303430322.161" 
    $P2091."add_method"(type_obj, "method_def", $P2092)
    get_how $P2093, type_obj
    get_global $P2094, "!PREFIX__method_def"
    $P2093."add_method"(type_obj, "!PREFIX__method_def", $P2094)
    get_how $P2095, type_obj
    .const 'Sub' $P2096 = "182_1303430322.161" 
    $P2095."add_method"(type_obj, "onlystar", $P2096)
    get_how $P2097, type_obj
    get_global $P2098, "!PREFIX__onlystar"
    $P2097."add_method"(type_obj, "!PREFIX__onlystar", $P2098)
    get_how $P2099, type_obj
    .const 'Sub' $P2100 = "185_1303430322.161" 
    $P2099."add_method"(type_obj, "multi_declarator", $P2100)
    get_how $P2101, type_obj
    .const 'Sub' $P2102 = "186_1303430322.161" 
    $P2101."add_method"(type_obj, "!PREFIX__multi_declarator", $P2102)
    get_how $P2103, type_obj
    .const 'Sub' $P2104 = "187_1303430322.161" 
    $P2103."add_method"(type_obj, "multi_declarator:sym<multi>", $P2104)
    get_how $P2105, type_obj
    get_global $P2106, "!PREFIX__multi_declarator:sym<multi>"
    $P2105."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2106)
    get_how $P2107, type_obj
    .const 'Sub' $P2108 = "189_1303430322.161" 
    $P2107."add_method"(type_obj, "multi_declarator:sym<proto>", $P2108)
    get_how $P2109, type_obj
    get_global $P2110, "!PREFIX__multi_declarator:sym<proto>"
    $P2109."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2110)
    get_how $P2111, type_obj
    .const 'Sub' $P2112 = "191_1303430322.161" 
    $P2111."add_method"(type_obj, "multi_declarator:sym<null>", $P2112)
    get_how $P2113, type_obj
    get_global $P2114, "!PREFIX__multi_declarator:sym<null>"
    $P2113."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2114)
    get_how $P2115, type_obj
    .const 'Sub' $P2116 = "193_1303430322.161" 
    $P2115."add_method"(type_obj, "signature", $P2116)
    get_how $P2117, type_obj
    get_global $P2118, "!PREFIX__signature"
    $P2117."add_method"(type_obj, "!PREFIX__signature", $P2118)
    get_how $P2119, type_obj
    .const 'Sub' $P2120 = "196_1303430322.161" 
    $P2119."add_method"(type_obj, "parameter", $P2120)
    get_how $P2121, type_obj
    get_global $P2122, "!PREFIX__parameter"
    $P2121."add_method"(type_obj, "!PREFIX__parameter", $P2122)
    get_how $P2123, type_obj
    .const 'Sub' $P2124 = "198_1303430322.161" 
    $P2123."add_method"(type_obj, "param_var", $P2124)
    get_how $P2125, type_obj
    get_global $P2126, "!PREFIX__param_var"
    $P2125."add_method"(type_obj, "!PREFIX__param_var", $P2126)
    get_how $P2127, type_obj
    .const 'Sub' $P2128 = "200_1303430322.161" 
    $P2127."add_method"(type_obj, "named_param", $P2128)
    get_how $P2129, type_obj
    get_global $P2130, "!PREFIX__named_param"
    $P2129."add_method"(type_obj, "!PREFIX__named_param", $P2130)
    get_how $P2131, type_obj
    .const 'Sub' $P2132 = "202_1303430322.161" 
    $P2131."add_method"(type_obj, "default_value", $P2132)
    get_how $P2133, type_obj
    get_global $P2134, "!PREFIX__default_value"
    $P2133."add_method"(type_obj, "!PREFIX__default_value", $P2134)
    get_how $P2135, type_obj
    .const 'Sub' $P2136 = "204_1303430322.161" 
    $P2135."add_method"(type_obj, "trait", $P2136)
    get_how $P2137, type_obj
    get_global $P2138, "!PREFIX__trait"
    $P2137."add_method"(type_obj, "!PREFIX__trait", $P2138)
    get_how $P2139, type_obj
    .const 'Sub' $P2140 = "206_1303430322.161" 
    $P2139."add_method"(type_obj, "trait_mod", $P2140)
    get_how $P2141, type_obj
    .const 'Sub' $P2142 = "207_1303430322.161" 
    $P2141."add_method"(type_obj, "!PREFIX__trait_mod", $P2142)
    get_how $P2143, type_obj
    .const 'Sub' $P2144 = "208_1303430322.161" 
    $P2143."add_method"(type_obj, "trait_mod:sym<is>", $P2144)
    get_how $P2145, type_obj
    get_global $P2146, "!PREFIX__trait_mod:sym<is>"
    $P2145."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2146)
    get_how $P2147, type_obj
    .const 'Sub' $P2148 = "210_1303430322.161" 
    $P2147."add_method"(type_obj, "regex_declarator", $P2148)
    get_how $P2149, type_obj
    get_global $P2150, "!PREFIX__regex_declarator"
    $P2149."add_method"(type_obj, "!PREFIX__regex_declarator", $P2150)
    get_how $P2151, type_obj
    .const 'Sub' $P2152 = "212_1303430322.161" 
    $P2151."add_method"(type_obj, "dotty", $P2152)
    get_how $P2153, type_obj
    get_global $P2154, "!PREFIX__dotty"
    $P2153."add_method"(type_obj, "!PREFIX__dotty", $P2154)
    get_how $P2155, type_obj
    .const 'Sub' $P2156 = "214_1303430322.161" 
    $P2155."add_method"(type_obj, "term", $P2156)
    get_how $P2157, type_obj
    .const 'Sub' $P2158 = "215_1303430322.161" 
    $P2157."add_method"(type_obj, "!PREFIX__term", $P2158)
    get_how $P2159, type_obj
    .const 'Sub' $P2160 = "216_1303430322.161" 
    $P2159."add_method"(type_obj, "term:sym<self>", $P2160)
    get_how $P2161, type_obj
    get_global $P2162, "!PREFIX__term:sym<self>"
    $P2161."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2162)
    get_how $P2163, type_obj
    .const 'Sub' $P2164 = "218_1303430322.161" 
    $P2163."add_method"(type_obj, "term:sym<identifier>", $P2164)
    get_how $P2165, type_obj
    get_global $P2166, "!PREFIX__term:sym<identifier>"
    $P2165."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2166)
    get_how $P2167, type_obj
    .const 'Sub' $P2168 = "220_1303430322.161" 
    $P2167."add_method"(type_obj, "term:sym<name>", $P2168)
    get_how $P2169, type_obj
    get_global $P2170, "!PREFIX__term:sym<name>"
    $P2169."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2170)
    get_how $P2171, type_obj
    .const 'Sub' $P2172 = "222_1303430322.161" 
    $P2171."add_method"(type_obj, "term:sym<pir::op>", $P2172)
    get_how $P2173, type_obj
    get_global $P2174, "!PREFIX__term:sym<pir::op>"
    $P2173."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2174)
    get_how $P2175, type_obj
    .const 'Sub' $P2176 = "224_1303430322.161" 
    $P2175."add_method"(type_obj, "term:sym<onlystar>", $P2176)
    get_how $P2177, type_obj
    get_global $P2178, "!PREFIX__term:sym<onlystar>"
    $P2177."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2178)
    get_how $P2179, type_obj
    .const 'Sub' $P2180 = "227_1303430322.161" 
    $P2179."add_method"(type_obj, "args", $P2180)
    get_how $P2181, type_obj
    get_global $P2182, "!PREFIX__args"
    $P2181."add_method"(type_obj, "!PREFIX__args", $P2182)
    get_how $P2183, type_obj
    .const 'Sub' $P2184 = "229_1303430322.161" 
    $P2183."add_method"(type_obj, "arglist", $P2184)
    get_how $P2185, type_obj
    get_global $P2186, "!PREFIX__arglist"
    $P2185."add_method"(type_obj, "!PREFIX__arglist", $P2186)
    get_how $P2187, type_obj
    .const 'Sub' $P2188 = "231_1303430322.161" 
    $P2187."add_method"(type_obj, "term:sym<value>", $P2188)
    get_how $P2189, type_obj
    get_global $P2190, "!PREFIX__term:sym<value>"
    $P2189."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2190)
    get_how $P2191, type_obj
    .const 'Sub' $P2192 = "233_1303430322.161" 
    $P2191."add_method"(type_obj, "value", $P2192)
    get_how $P2193, type_obj
    get_global $P2194, "!PREFIX__value"
    $P2193."add_method"(type_obj, "!PREFIX__value", $P2194)
    get_how $P2195, type_obj
    .const 'Sub' $P2196 = "235_1303430322.161" 
    $P2195."add_method"(type_obj, "number", $P2196)
    get_how $P2197, type_obj
    get_global $P2198, "!PREFIX__number"
    $P2197."add_method"(type_obj, "!PREFIX__number", $P2198)
    get_how $P2199, type_obj
    .const 'Sub' $P2200 = "237_1303430322.161" 
    $P2199."add_method"(type_obj, "quote", $P2200)
    get_how $P2201, type_obj
    .const 'Sub' $P2202 = "238_1303430322.161" 
    $P2201."add_method"(type_obj, "!PREFIX__quote", $P2202)
    get_how $P2203, type_obj
    .const 'Sub' $P2204 = "239_1303430322.161" 
    $P2203."add_method"(type_obj, "quote:sym<apos>", $P2204)
    get_how $P2205, type_obj
    get_global $P2206, "!PREFIX__quote:sym<apos>"
    $P2205."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2206)
    get_how $P2207, type_obj
    .const 'Sub' $P2208 = "241_1303430322.161" 
    $P2207."add_method"(type_obj, "quote:sym<dblq>", $P2208)
    get_how $P2209, type_obj
    get_global $P2210, "!PREFIX__quote:sym<dblq>"
    $P2209."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2210)
    get_how $P2211, type_obj
    .const 'Sub' $P2212 = "243_1303430322.161" 
    $P2211."add_method"(type_obj, "quote:sym<q>", $P2212)
    get_how $P2213, type_obj
    get_global $P2214, "!PREFIX__quote:sym<q>"
    $P2213."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2214)
    get_how $P2215, type_obj
    .const 'Sub' $P2216 = "245_1303430322.161" 
    $P2215."add_method"(type_obj, "quote:sym<qq>", $P2216)
    get_how $P2217, type_obj
    get_global $P2218, "!PREFIX__quote:sym<qq>"
    $P2217."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2218)
    get_how $P2219, type_obj
    .const 'Sub' $P2220 = "247_1303430322.161" 
    $P2219."add_method"(type_obj, "quote:sym<Q>", $P2220)
    get_how $P2221, type_obj
    get_global $P2222, "!PREFIX__quote:sym<Q>"
    $P2221."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2222)
    get_how $P2223, type_obj
    .const 'Sub' $P2224 = "249_1303430322.161" 
    $P2223."add_method"(type_obj, "quote:sym<Q:PIR>", $P2224)
    get_how $P2225, type_obj
    get_global $P2226, "!PREFIX__quote:sym<Q:PIR>"
    $P2225."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2226)
    get_how $P2227, type_obj
    .const 'Sub' $P2228 = "251_1303430322.161" 
    $P2227."add_method"(type_obj, "quote:sym</ />", $P2228)
    get_how $P2229, type_obj
    get_global $P2230, "!PREFIX__quote:sym</ />"
    $P2229."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2230)
    get_how $P2231, type_obj
    .const 'Sub' $P2232 = "253_1303430322.161" 
    $P2231."add_method"(type_obj, "quote_escape:sym<$>", $P2232)
    get_how $P2233, type_obj
    get_global $P2234, "!PREFIX__quote_escape:sym<$>"
    $P2233."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2234)
    get_how $P2235, type_obj
    .const 'Sub' $P2236 = "255_1303430322.161" 
    $P2235."add_method"(type_obj, "quote_escape:sym<{ }>", $P2236)
    get_how $P2237, type_obj
    get_global $P2238, "!PREFIX__quote_escape:sym<{ }>"
    $P2237."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2238)
    get_how $P2239, type_obj
    .const 'Sub' $P2240 = "257_1303430322.161" 
    $P2239."add_method"(type_obj, "quote_escape:sym<esc>", $P2240)
    get_how $P2241, type_obj
    get_global $P2242, "!PREFIX__quote_escape:sym<esc>"
    $P2241."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2242)
    get_how $P2243, type_obj
    .const 'Sub' $P2244 = "259_1303430322.161" 
    $P2243."add_method"(type_obj, "circumfix:sym<( )>", $P2244)
    get_how $P2245, type_obj
    get_global $P2246, "!PREFIX__circumfix:sym<( )>"
    $P2245."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2246)
    get_how $P2247, type_obj
    .const 'Sub' $P2248 = "261_1303430322.161" 
    $P2247."add_method"(type_obj, "circumfix:sym<[ ]>", $P2248)
    get_how $P2249, type_obj
    get_global $P2250, "!PREFIX__circumfix:sym<[ ]>"
    $P2249."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2250)
    get_how $P2251, type_obj
    .const 'Sub' $P2252 = "263_1303430322.161" 
    $P2251."add_method"(type_obj, "circumfix:sym<ang>", $P2252)
    get_how $P2253, type_obj
    get_global $P2254, "!PREFIX__circumfix:sym<ang>"
    $P2253."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2254)
    get_how $P2255, type_obj
    .const 'Sub' $P2256 = "265_1303430322.161" 
    $P2255."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2256)
    get_how $P2257, type_obj
    get_global $P2258, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2257."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2258)
    get_how $P2259, type_obj
    .const 'Sub' $P2260 = "267_1303430322.161" 
    $P2259."add_method"(type_obj, "circumfix:sym<{ }>", $P2260)
    get_how $P2261, type_obj
    get_global $P2262, "!PREFIX__circumfix:sym<{ }>"
    $P2261."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2262)
    get_how $P2263, type_obj
    .const 'Sub' $P2264 = "269_1303430322.161" 
    $P2263."add_method"(type_obj, "circumfix:sym<sigil>", $P2264)
    get_how $P2265, type_obj
    get_global $P2266, "!PREFIX__circumfix:sym<sigil>"
    $P2265."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2266)
    get_how $P2267, type_obj
    .const 'Sub' $P2268 = "271_1303430322.161" 
    $P2267."add_method"(type_obj, "semilist", $P2268)
    get_how $P2269, type_obj
    get_global $P2270, "!PREFIX__semilist"
    $P2269."add_method"(type_obj, "!PREFIX__semilist", $P2270)
    get_how $P2271, type_obj
    .const 'Sub' $P2272 = "273_1303430322.161" 
    $P2271."add_method"(type_obj, "infixish", $P2272)
    get_how $P2273, type_obj
    get_global $P2274, "!PREFIX__infixish"
    $P2273."add_method"(type_obj, "!PREFIX__infixish", $P2274)
    get_how $P2275, type_obj
    .const 'Sub' $P2276 = "275_1303430322.161" 
    $P2275."add_method"(type_obj, "infixstopper", $P2276)
    get_how $P2277, type_obj
    get_global $P2278, "!PREFIX__infixstopper"
    $P2277."add_method"(type_obj, "!PREFIX__infixstopper", $P2278)
    get_how $P2279, type_obj
    .const 'Sub' $P2280 = "277_1303430322.161" 
    $P2279."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2280)
    get_how $P2281, type_obj
    get_global $P2282, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2281."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2282)
    get_how $P2283, type_obj
    .const 'Sub' $P2284 = "279_1303430322.161" 
    $P2283."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2284)
    get_how $P2285, type_obj
    get_global $P2286, "!PREFIX__postcircumfix:sym<{ }>"
    $P2285."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2286)
    get_how $P2287, type_obj
    .const 'Sub' $P2288 = "281_1303430322.161" 
    $P2287."add_method"(type_obj, "postcircumfix:sym<ang>", $P2288)
    get_how $P2289, type_obj
    get_global $P2290, "!PREFIX__postcircumfix:sym<ang>"
    $P2289."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2290)
    get_how $P2291, type_obj
    .const 'Sub' $P2292 = "283_1303430322.161" 
    $P2291."add_method"(type_obj, "postcircumfix:sym<( )>", $P2292)
    get_how $P2293, type_obj
    get_global $P2294, "!PREFIX__postcircumfix:sym<( )>"
    $P2293."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2294)
    get_how $P2295, type_obj
    .const 'Sub' $P2296 = "285_1303430322.161" 
    $P2295."add_method"(type_obj, "postfix:sym<.>", $P2296)
    get_how $P2297, type_obj
    get_global $P2298, "!PREFIX__postfix:sym<.>"
    $P2297."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2298)
    get_how $P2299, type_obj
    .const 'Sub' $P2300 = "287_1303430322.161" 
    $P2299."add_method"(type_obj, "prefix:sym<++>", $P2300)
    get_how $P2301, type_obj
    get_global $P2302, "!PREFIX__prefix:sym<++>"
    $P2301."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2302)
    get_how $P2303, type_obj
    .const 'Sub' $P2304 = "289_1303430322.161" 
    $P2303."add_method"(type_obj, "prefix:sym<-->", $P2304)
    get_how $P2305, type_obj
    get_global $P2306, "!PREFIX__prefix:sym<-->"
    $P2305."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2306)
    get_how $P2307, type_obj
    .const 'Sub' $P2308 = "291_1303430322.161" 
    $P2307."add_method"(type_obj, "postfix:sym<++>", $P2308)
    get_how $P2309, type_obj
    get_global $P2310, "!PREFIX__postfix:sym<++>"
    $P2309."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2310)
    get_how $P2311, type_obj
    .const 'Sub' $P2312 = "293_1303430322.161" 
    $P2311."add_method"(type_obj, "postfix:sym<-->", $P2312)
    get_how $P2313, type_obj
    get_global $P2314, "!PREFIX__postfix:sym<-->"
    $P2313."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2314)
    get_how $P2315, type_obj
    .const 'Sub' $P2316 = "295_1303430322.161" 
    $P2315."add_method"(type_obj, "infix:sym<**>", $P2316)
    get_how $P2317, type_obj
    get_global $P2318, "!PREFIX__infix:sym<**>"
    $P2317."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2318)
    get_how $P2319, type_obj
    .const 'Sub' $P2320 = "297_1303430322.161" 
    $P2319."add_method"(type_obj, "prefix:sym<+>", $P2320)
    get_how $P2321, type_obj
    get_global $P2322, "!PREFIX__prefix:sym<+>"
    $P2321."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2322)
    get_how $P2323, type_obj
    .const 'Sub' $P2324 = "299_1303430322.161" 
    $P2323."add_method"(type_obj, "prefix:sym<~>", $P2324)
    get_how $P2325, type_obj
    get_global $P2326, "!PREFIX__prefix:sym<~>"
    $P2325."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2326)
    get_how $P2327, type_obj
    .const 'Sub' $P2328 = "301_1303430322.161" 
    $P2327."add_method"(type_obj, "prefix:sym<->", $P2328)
    get_how $P2329, type_obj
    get_global $P2330, "!PREFIX__prefix:sym<->"
    $P2329."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2330)
    get_how $P2331, type_obj
    .const 'Sub' $P2332 = "303_1303430322.161" 
    $P2331."add_method"(type_obj, "prefix:sym<?>", $P2332)
    get_how $P2333, type_obj
    get_global $P2334, "!PREFIX__prefix:sym<?>"
    $P2333."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2334)
    get_how $P2335, type_obj
    .const 'Sub' $P2336 = "305_1303430322.161" 
    $P2335."add_method"(type_obj, "prefix:sym<!>", $P2336)
    get_how $P2337, type_obj
    get_global $P2338, "!PREFIX__prefix:sym<!>"
    $P2337."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2338)
    get_how $P2339, type_obj
    .const 'Sub' $P2340 = "307_1303430322.161" 
    $P2339."add_method"(type_obj, "prefix:sym<|>", $P2340)
    get_how $P2341, type_obj
    get_global $P2342, "!PREFIX__prefix:sym<|>"
    $P2341."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2342)
    get_how $P2343, type_obj
    .const 'Sub' $P2344 = "309_1303430322.161" 
    $P2343."add_method"(type_obj, "infix:sym<*>", $P2344)
    get_how $P2345, type_obj
    get_global $P2346, "!PREFIX__infix:sym<*>"
    $P2345."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2346)
    get_how $P2347, type_obj
    .const 'Sub' $P2348 = "311_1303430322.161" 
    $P2347."add_method"(type_obj, "infix:sym</>", $P2348)
    get_how $P2349, type_obj
    get_global $P2350, "!PREFIX__infix:sym</>"
    $P2349."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2350)
    get_how $P2351, type_obj
    .const 'Sub' $P2352 = "313_1303430322.161" 
    $P2351."add_method"(type_obj, "infix:sym<%>", $P2352)
    get_how $P2353, type_obj
    get_global $P2354, "!PREFIX__infix:sym<%>"
    $P2353."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2354)
    get_how $P2355, type_obj
    .const 'Sub' $P2356 = "315_1303430322.161" 
    $P2355."add_method"(type_obj, "infix:sym<+&>", $P2356)
    get_how $P2357, type_obj
    get_global $P2358, "!PREFIX__infix:sym<+&>"
    $P2357."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2358)
    get_how $P2359, type_obj
    .const 'Sub' $P2360 = "317_1303430322.161" 
    $P2359."add_method"(type_obj, "infix:sym<+>", $P2360)
    get_how $P2361, type_obj
    get_global $P2362, "!PREFIX__infix:sym<+>"
    $P2361."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2362)
    get_how $P2363, type_obj
    .const 'Sub' $P2364 = "319_1303430322.161" 
    $P2363."add_method"(type_obj, "infix:sym<->", $P2364)
    get_how $P2365, type_obj
    get_global $P2366, "!PREFIX__infix:sym<->"
    $P2365."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2366)
    get_how $P2367, type_obj
    .const 'Sub' $P2368 = "321_1303430322.161" 
    $P2367."add_method"(type_obj, "infix:sym<+|>", $P2368)
    get_how $P2369, type_obj
    get_global $P2370, "!PREFIX__infix:sym<+|>"
    $P2369."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2370)
    get_how $P2371, type_obj
    .const 'Sub' $P2372 = "323_1303430322.161" 
    $P2371."add_method"(type_obj, "infix:sym<+^>", $P2372)
    get_how $P2373, type_obj
    get_global $P2374, "!PREFIX__infix:sym<+^>"
    $P2373."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2374)
    get_how $P2375, type_obj
    .const 'Sub' $P2376 = "325_1303430322.161" 
    $P2375."add_method"(type_obj, "infix:sym<~>", $P2376)
    get_how $P2377, type_obj
    get_global $P2378, "!PREFIX__infix:sym<~>"
    $P2377."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2378)
    get_how $P2379, type_obj
    .const 'Sub' $P2380 = "327_1303430322.161" 
    $P2379."add_method"(type_obj, "infix:sym<==>", $P2380)
    get_how $P2381, type_obj
    get_global $P2382, "!PREFIX__infix:sym<==>"
    $P2381."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2382)
    get_how $P2383, type_obj
    .const 'Sub' $P2384 = "329_1303430322.161" 
    $P2383."add_method"(type_obj, "infix:sym<!=>", $P2384)
    get_how $P2385, type_obj
    get_global $P2386, "!PREFIX__infix:sym<!=>"
    $P2385."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2386)
    get_how $P2387, type_obj
    .const 'Sub' $P2388 = "331_1303430322.161" 
    $P2387."add_method"(type_obj, "infix:sym<<=>", $P2388)
    get_how $P2389, type_obj
    get_global $P2390, "!PREFIX__infix:sym<<=>"
    $P2389."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2390)
    get_how $P2391, type_obj
    .const 'Sub' $P2392 = "333_1303430322.161" 
    $P2391."add_method"(type_obj, "infix:sym<>=>", $P2392)
    get_how $P2393, type_obj
    get_global $P2394, "!PREFIX__infix:sym<>=>"
    $P2393."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2394)
    get_how $P2395, type_obj
    .const 'Sub' $P2396 = "335_1303430322.161" 
    $P2395."add_method"(type_obj, "infix:sym<<>", $P2396)
    get_how $P2397, type_obj
    get_global $P2398, "!PREFIX__infix:sym<<>"
    $P2397."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2398)
    get_how $P2399, type_obj
    .const 'Sub' $P2400 = "337_1303430322.161" 
    $P2399."add_method"(type_obj, "infix:sym<>>", $P2400)
    get_how $P2401, type_obj
    get_global $P2402, "!PREFIX__infix:sym<>>"
    $P2401."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2402)
    get_how $P2403, type_obj
    .const 'Sub' $P2404 = "339_1303430322.161" 
    $P2403."add_method"(type_obj, "infix:sym<eq>", $P2404)
    get_how $P2405, type_obj
    get_global $P2406, "!PREFIX__infix:sym<eq>"
    $P2405."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2406)
    get_how $P2407, type_obj
    .const 'Sub' $P2408 = "341_1303430322.161" 
    $P2407."add_method"(type_obj, "infix:sym<ne>", $P2408)
    get_how $P2409, type_obj
    get_global $P2410, "!PREFIX__infix:sym<ne>"
    $P2409."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2410)
    get_how $P2411, type_obj
    .const 'Sub' $P2412 = "343_1303430322.161" 
    $P2411."add_method"(type_obj, "infix:sym<le>", $P2412)
    get_how $P2413, type_obj
    get_global $P2414, "!PREFIX__infix:sym<le>"
    $P2413."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2414)
    get_how $P2415, type_obj
    .const 'Sub' $P2416 = "345_1303430322.161" 
    $P2415."add_method"(type_obj, "infix:sym<ge>", $P2416)
    get_how $P2417, type_obj
    get_global $P2418, "!PREFIX__infix:sym<ge>"
    $P2417."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2418)
    get_how $P2419, type_obj
    .const 'Sub' $P2420 = "347_1303430322.161" 
    $P2419."add_method"(type_obj, "infix:sym<lt>", $P2420)
    get_how $P2421, type_obj
    get_global $P2422, "!PREFIX__infix:sym<lt>"
    $P2421."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2422)
    get_how $P2423, type_obj
    .const 'Sub' $P2424 = "349_1303430322.161" 
    $P2423."add_method"(type_obj, "infix:sym<gt>", $P2424)
    get_how $P2425, type_obj
    get_global $P2426, "!PREFIX__infix:sym<gt>"
    $P2425."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2426)
    get_how $P2427, type_obj
    .const 'Sub' $P2428 = "351_1303430322.161" 
    $P2427."add_method"(type_obj, "infix:sym<=:=>", $P2428)
    get_how $P2429, type_obj
    get_global $P2430, "!PREFIX__infix:sym<=:=>"
    $P2429."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2430)
    get_how $P2431, type_obj
    .const 'Sub' $P2432 = "353_1303430322.161" 
    $P2431."add_method"(type_obj, "infix:sym<~~>", $P2432)
    get_how $P2433, type_obj
    get_global $P2434, "!PREFIX__infix:sym<~~>"
    $P2433."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2434)
    get_how $P2435, type_obj
    .const 'Sub' $P2436 = "355_1303430322.161" 
    $P2435."add_method"(type_obj, "infix:sym<&&>", $P2436)
    get_how $P2437, type_obj
    get_global $P2438, "!PREFIX__infix:sym<&&>"
    $P2437."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2438)
    get_how $P2439, type_obj
    .const 'Sub' $P2440 = "357_1303430322.161" 
    $P2439."add_method"(type_obj, "infix:sym<||>", $P2440)
    get_how $P2441, type_obj
    get_global $P2442, "!PREFIX__infix:sym<||>"
    $P2441."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2442)
    get_how $P2443, type_obj
    .const 'Sub' $P2444 = "359_1303430322.161" 
    $P2443."add_method"(type_obj, "infix:sym<//>", $P2444)
    get_how $P2445, type_obj
    get_global $P2446, "!PREFIX__infix:sym<//>"
    $P2445."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2446)
    get_how $P2447, type_obj
    .const 'Sub' $P2448 = "361_1303430322.161" 
    $P2447."add_method"(type_obj, "infix:sym<?? !!>", $P2448)
    get_how $P2449, type_obj
    get_global $P2450, "!PREFIX__infix:sym<?? !!>"
    $P2449."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2450)
    get_how $P2451, type_obj
    .const 'Sub' $P2452 = "363_1303430322.161" 
    $P2451."add_method"(type_obj, "infix:sym<=>", $P2452)
    get_how $P2453, type_obj
    get_global $P2454, "!PREFIX__infix:sym<=>"
    $P2453."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2454)
    get_how $P2455, type_obj
    .const 'Sub' $P2456 = "365_1303430322.161" 
    $P2455."add_method"(type_obj, "infix:sym<:=>", $P2456)
    get_how $P2457, type_obj
    get_global $P2458, "!PREFIX__infix:sym<:=>"
    $P2457."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2458)
    get_how $P2459, type_obj
    .const 'Sub' $P2460 = "367_1303430322.161" 
    $P2459."add_method"(type_obj, "infix:sym<::=>", $P2460)
    get_how $P2461, type_obj
    get_global $P2462, "!PREFIX__infix:sym<::=>"
    $P2461."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2462)
    get_how $P2463, type_obj
    .const 'Sub' $P2464 = "369_1303430322.161" 
    $P2463."add_method"(type_obj, "infix:sym<,>", $P2464)
    get_how $P2465, type_obj
    get_global $P2466, "!PREFIX__infix:sym<,>"
    $P2465."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2466)
    get_how $P2467, type_obj
    .const 'Sub' $P2468 = "371_1303430322.161" 
    $P2467."add_method"(type_obj, "prefix:sym<return>", $P2468)
    get_how $P2469, type_obj
    get_global $P2470, "!PREFIX__prefix:sym<return>"
    $P2469."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2470)
    get_how $P2471, type_obj
    .const 'Sub' $P2472 = "374_1303430322.161" 
    $P2471."add_method"(type_obj, "prefix:sym<make>", $P2472)
    get_how $P2473, type_obj
    get_global $P2474, "!PREFIX__prefix:sym<make>"
    $P2473."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2474)
    get_how $P2475, type_obj
    .const 'Sub' $P2476 = "376_1303430322.161" 
    $P2475."add_method"(type_obj, "term:sym<last>", $P2476)
    get_how $P2477, type_obj
    get_global $P2478, "!PREFIX__term:sym<last>"
    $P2477."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2478)
    get_how $P2479, type_obj
    .const 'Sub' $P2480 = "378_1303430322.161" 
    $P2479."add_method"(type_obj, "term:sym<next>", $P2480)
    get_how $P2481, type_obj
    get_global $P2482, "!PREFIX__term:sym<next>"
    $P2481."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2482)
    get_how $P2483, type_obj
    .const 'Sub' $P2484 = "380_1303430322.161" 
    $P2483."add_method"(type_obj, "term:sym<redo>", $P2484)
    get_how $P2485, type_obj
    get_global $P2486, "!PREFIX__term:sym<redo>"
    $P2485."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2486)
    get_how $P2487, type_obj
    .const 'Sub' $P2488 = "382_1303430322.161" 
    $P2487."add_method"(type_obj, "smartmatch", $P2488)
    get_how $P2489, type_obj
    get_hll_global $P2490, ["HLL"], "Grammar"
    $P2489."add_parent"(type_obj, $P2490)
    get_how $P2491, type_obj
    $P2492 = $P2491."compose"(type_obj)
    .return ($P2492)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303430322.161") :outer("12_1303430322.161")
    .param pmc param_56
.annotate 'line', 10
    .lex "self", param_56
.annotate 'line', 12
    $P57 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P57
.annotate 'line', 19
    $P58 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P58
.annotate 'line', 28
    new $P59, "Undef"
    .lex "$*DEFAULT-METAATTR", $P59
.annotate 'line', 29
    $P60 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P60
.annotate 'line', 35
    new $P61, "Undef"
    .lex "$*SC", $P61
.annotate 'line', 39
    new $P62, "Undef"
    .lex "$*SCOPE", $P62
.annotate 'line', 40
    new $P63, "Undef"
    .lex "$*MULTINESS", $P63
.annotate 'line', 41
    new $P64, "Undef"
    .lex "$*INVOCANT_OK", $P64
.annotate 'line', 42
    new $P65, "Undef"
    .lex "$*RETURN_USED", $P65
.annotate 'line', 43
    new $P66, "Undef"
    .lex "$*PACKAGE-SETUP", $P66
.annotate 'line', 10
    find_lex $P67, "%*LANG"
    unless_null $P67, vivify_587
    get_hll_global $P67, "%LANG"
    unless_null $P67, vivify_588
    die "Contextual %*LANG not found"
  vivify_588:
  vivify_587:
.annotate 'line', 13
    get_hll_global $P68, ["NQP"], "Regex"
    find_lex $P69, "%*LANG"
    unless_null $P69, vivify_589
    get_hll_global $P69, "%LANG"
    unless_null $P69, vivify_590
    die "Contextual %*LANG not found"
  vivify_590:
    store_lex "%*LANG", $P69
  vivify_589:
    set $P69["Regex"], $P68
.annotate 'line', 14
    get_hll_global $P70, ["NQP"], "RegexActions"
    find_lex $P71, "%*LANG"
    unless_null $P71, vivify_591
    get_hll_global $P71, "%LANG"
    unless_null $P71, vivify_592
    die "Contextual %*LANG not found"
  vivify_592:
    store_lex "%*LANG", $P71
  vivify_591:
    set $P71["Regex-actions"], $P70
.annotate 'line', 15
    get_hll_global $P72, ["NQP"], "Grammar"
    find_lex $P73, "%*LANG"
    unless_null $P73, vivify_593
    get_hll_global $P73, "%LANG"
    unless_null $P73, vivify_594
    die "Contextual %*LANG not found"
  vivify_594:
    store_lex "%*LANG", $P73
  vivify_593:
    set $P73["MAIN"], $P72
.annotate 'line', 16
    get_hll_global $P74, ["NQP"], "Actions"
    find_lex $P75, "%*LANG"
    unless_null $P75, vivify_595
    get_hll_global $P75, "%LANG"
    unless_null $P75, vivify_596
    die "Contextual %*LANG not found"
  vivify_596:
    store_lex "%*LANG", $P75
  vivify_595:
    set $P75["MAIN-actions"], $P74
    find_lex $P76, "%*HOW"
    unless_null $P76, vivify_597
    get_hll_global $P76, "%HOW"
    unless_null $P76, vivify_598
    die "Contextual %*HOW not found"
  vivify_598:
  vivify_597:
.annotate 'line', 20
    get_hll_global $P77, "KnowHOW"
    find_lex $P78, "%*HOW"
    unless_null $P78, vivify_599
    get_hll_global $P78, "%HOW"
    unless_null $P78, vivify_600
    die "Contextual %*HOW not found"
  vivify_600:
    store_lex "%*HOW", $P78
  vivify_599:
    set $P78["knowhow"], $P77
.annotate 'line', 21
    get_hll_global $P79, "NQPModuleHOW"
    find_lex $P80, "%*HOW"
    unless_null $P80, vivify_601
    get_hll_global $P80, "%HOW"
    unless_null $P80, vivify_602
    die "Contextual %*HOW not found"
  vivify_602:
    store_lex "%*HOW", $P80
  vivify_601:
    set $P80["module"], $P79
.annotate 'line', 22
    get_hll_global $P81, "NQPClassHOW"
    find_lex $P82, "%*HOW"
    unless_null $P82, vivify_603
    get_hll_global $P82, "%HOW"
    unless_null $P82, vivify_604
    die "Contextual %*HOW not found"
  vivify_604:
    store_lex "%*HOW", $P82
  vivify_603:
    set $P82["class"], $P81
.annotate 'line', 23
    get_hll_global $P83, "NQPClassHOW"
    find_lex $P84, "%*HOW"
    unless_null $P84, vivify_605
    get_hll_global $P84, "%HOW"
    unless_null $P84, vivify_606
    die "Contextual %*HOW not found"
  vivify_606:
    store_lex "%*HOW", $P84
  vivify_605:
    set $P84["grammar"], $P83
.annotate 'line', 24
    get_hll_global $P85, "NQPParametricRoleHOW"
    find_lex $P86, "%*HOW"
    unless_null $P86, vivify_607
    get_hll_global $P86, "%HOW"
    unless_null $P86, vivify_608
    die "Contextual %*HOW not found"
  vivify_608:
    store_lex "%*HOW", $P86
  vivify_607:
    set $P86["role"], $P85
.annotate 'line', 25
    get_hll_global $P87, "NQPNativeHOW"
    find_lex $P88, "%*HOW"
    unless_null $P88, vivify_609
    get_hll_global $P88, "%HOW"
    unless_null $P88, vivify_610
    die "Contextual %*HOW not found"
  vivify_610:
    store_lex "%*HOW", $P88
  vivify_609:
    set $P88["native"], $P87
.annotate 'line', 28
    new $P89, "String"
    assign $P89, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P89
    find_lex $P90, "%*HOW-METAATTR"
    unless_null $P90, vivify_611
    get_hll_global $P90, "%HOW-METAATTR"
    unless_null $P90, vivify_612
    die "Contextual %*HOW-METAATTR not found"
  vivify_612:
  vivify_611:
.annotate 'line', 30
    new $P91, "String"
    assign $P91, "KnowHOWAttribute"
    find_lex $P92, "%*HOW-METAATTR"
    unless_null $P92, vivify_613
    get_hll_global $P92, "%HOW-METAATTR"
    unless_null $P92, vivify_614
    die "Contextual %*HOW-METAATTR not found"
  vivify_614:
    store_lex "%*HOW-METAATTR", $P92
  vivify_613:
    set $P92["knowhow"], $P91
.annotate 'line', 35
    get_hll_global $P93, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N94
    set $S95, $N94
    $P96 = $P93."new"($S95 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P96
.annotate 'line', 39
    new $P97, "String"
    assign $P97, ""
    store_lex "$*SCOPE", $P97
.annotate 'line', 40
    new $P98, "String"
    assign $P98, ""
    store_lex "$*MULTINESS", $P98
.annotate 'line', 41
    new $P99, "Integer"
    assign $P99, 0
    store_lex "$*INVOCANT_OK", $P99
.annotate 'line', 42
    new $P100, "Integer"
    assign $P100, 0
    store_lex "$*RETURN_USED", $P100
    find_lex $P101, "$*PACKAGE-SETUP"
    unless_null $P101, vivify_615
    get_hll_global $P101, "$PACKAGE-SETUP"
    unless_null $P101, vivify_616
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_616:
  vivify_615:
.annotate 'line', 44
    find_lex $P102, "self"
    $P103 = $P102."comp_unit"()
.annotate 'line', 10
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx105_tgt
    .local int rx105_pos
    .local int rx105_off
    .local int rx105_eos
    .local int rx105_rep
    .local pmc rx105_cur
    .local pmc rx105_debug
    (rx105_cur, rx105_pos, rx105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx105_cur
    .local pmc match
    .lex "$/", match
    length rx105_eos, rx105_tgt
    gt rx105_pos, rx105_eos, rx105_done
    set rx105_off, 0
    lt rx105_pos, 2, rx105_start
    sub rx105_off, rx105_pos, 1
    substr rx105_tgt, rx105_tgt, rx105_off
  rx105_start:
    eq $I10, 1, rx105_restart
    if_null rx105_debug, debug_617
    rx105_cur."!cursor_debug"("START", "identifier")
  debug_617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan109_done
    goto rxscan109_scan
  rxscan109_loop:
    (rx105_pos) = rx105_cur."from"()
    inc rx105_pos
    rx105_cur."!cursor_from"(rx105_pos)
    ge rx105_pos, rx105_eos, rxscan109_done
  rxscan109_scan:
    set_addr $I10, rxscan109_loop
    rx105_cur."!mark_push"(0, rx105_pos, $I10)
  rxscan109_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx105_cur."!cursor_pos"(rx105_pos)
    $P10 = rx105_cur."ident"()
    unless $P10, rx105_fail
    rx105_pos = $P10."pos"()
  # rx rxquantr110 ** 0..*
    set_addr $I10, rxquantr110_done
    rx105_cur."!mark_push"(0, rx105_pos, $I10)
  rxquantr110_loop:
  # rx enumcharlist negate=0 
    ge rx105_pos, rx105_eos, rx105_fail
    sub $I10, rx105_pos, rx105_off
    substr $S10, rx105_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx105_fail
    inc rx105_pos
  # rx subrule "ident" subtype=method negate=
    rx105_cur."!cursor_pos"(rx105_pos)
    $P10 = rx105_cur."ident"()
    unless $P10, rx105_fail
    rx105_pos = $P10."pos"()
    set_addr $I10, rxquantr110_done
    (rx105_rep) = rx105_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr110_done
    rx105_cur."!mark_push"(rx105_rep, rx105_pos, $I10)
    goto rxquantr110_loop
  rxquantr110_done:
  # rx pass
    rx105_cur."!cursor_pass"(rx105_pos, "identifier")
    if_null rx105_debug, debug_618
    rx105_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx105_pos)
  debug_618:
    .return (rx105_cur)
  rx105_restart:
.annotate 'line', 10
    if_null rx105_debug, debug_619
    rx105_cur."!cursor_debug"("NEXT", "identifier")
  debug_619:
  rx105_fail:
    (rx105_rep, rx105_pos, $I10, $P10) = rx105_cur."!mark_fail"(0)
    lt rx105_pos, -1, rx105_done
    eq rx105_pos, -1, rx105_fail
    jump $I10
  rx105_done:
    rx105_cur."!cursor_fail"()
    if_null rx105_debug, debug_620
    rx105_cur."!cursor_debug"("FAIL", "identifier")
  debug_620:
    .return (rx105_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303430322.161") :method
.annotate 'line', 10
    $P107 = self."!PREFIX__!subrule"("ident", "")
    new $P108, "ResizablePMCArray"
    push $P108, $P107
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx112_tgt
    .local int rx112_pos
    .local int rx112_off
    .local int rx112_eos
    .local int rx112_rep
    .local pmc rx112_cur
    .local pmc rx112_debug
    (rx112_cur, rx112_pos, rx112_tgt, $I10) = self."!cursor_start"()
    rx112_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx112_cur
    .local pmc match
    .lex "$/", match
    length rx112_eos, rx112_tgt
    gt rx112_pos, rx112_eos, rx112_done
    set rx112_off, 0
    lt rx112_pos, 2, rx112_start
    sub rx112_off, rx112_pos, 1
    substr rx112_tgt, rx112_tgt, rx112_off
  rx112_start:
    eq $I10, 1, rx112_restart
    if_null rx112_debug, debug_621
    rx112_cur."!cursor_debug"("START", "name")
  debug_621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan115_done
    goto rxscan115_scan
  rxscan115_loop:
    (rx112_pos) = rx112_cur."from"()
    inc rx112_pos
    rx112_cur."!cursor_from"(rx112_pos)
    ge rx112_pos, rx112_eos, rxscan115_done
  rxscan115_scan:
    set_addr $I10, rxscan115_loop
    rx112_cur."!mark_push"(0, rx112_pos, $I10)
  rxscan115_done:
.annotate 'line', 51
  # rx rxquantr116 ** 1..*
    set_addr $I10, rxquantr116_done
    rx112_cur."!mark_push"(0, -1, $I10)
  rxquantr116_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx112_cur."!cursor_pos"(rx112_pos)
    $P10 = rx112_cur."identifier"()
    unless $P10, rx112_fail
    goto rxsubrule117_pass
  rxsubrule117_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx112_fail
  rxsubrule117_pass:
    set_addr $I10, rxsubrule117_back
    rx112_cur."!mark_push"(0, rx112_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx112_pos = $P10."pos"()
    set_addr $I10, rxquantr116_done
    (rx112_rep) = rx112_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr116_done
    rx112_cur."!mark_push"(rx112_rep, rx112_pos, $I10)
  # rx literal  "::"
    add $I11, rx112_pos, 2
    gt $I11, rx112_eos, rx112_fail
    sub $I11, rx112_pos, rx112_off
    substr $S10, rx112_tgt, $I11, 2
    ne $S10, "::", rx112_fail
    add rx112_pos, 2
    goto rxquantr116_loop
  rxquantr116_done:
  # rx pass
    rx112_cur."!cursor_pass"(rx112_pos, "name")
    if_null rx112_debug, debug_622
    rx112_cur."!cursor_debug"("PASS", "name", " at pos=", rx112_pos)
  debug_622:
    .return (rx112_cur)
  rx112_restart:
.annotate 'line', 10
    if_null rx112_debug, debug_623
    rx112_cur."!cursor_debug"("NEXT", "name")
  debug_623:
  rx112_fail:
    (rx112_rep, rx112_pos, $I10, $P10) = rx112_cur."!mark_fail"(0)
    lt rx112_pos, -1, rx112_done
    eq rx112_pos, -1, rx112_fail
    jump $I10
  rx112_done:
    rx112_cur."!cursor_fail"()
    if_null rx112_debug, debug_624
    rx112_cur."!cursor_debug"("FAIL", "name")
  debug_624:
    .return (rx112_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303430322.161") :method
.annotate 'line', 10
    new $P114, "ResizablePMCArray"
    push $P114, ""
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx119_tgt
    .local int rx119_pos
    .local int rx119_off
    .local int rx119_eos
    .local int rx119_rep
    .local pmc rx119_cur
    .local pmc rx119_debug
    (rx119_cur, rx119_pos, rx119_tgt, $I10) = self."!cursor_start"()
    rx119_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx119_cur
    .local pmc match
    .lex "$/", match
    length rx119_eos, rx119_tgt
    gt rx119_pos, rx119_eos, rx119_done
    set rx119_off, 0
    lt rx119_pos, 2, rx119_start
    sub rx119_off, rx119_pos, 1
    substr rx119_tgt, rx119_tgt, rx119_off
  rx119_start:
    eq $I10, 1, rx119_restart
    if_null rx119_debug, debug_625
    rx119_cur."!cursor_debug"("START", "deflongname")
  debug_625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan123_done
    goto rxscan123_scan
  rxscan123_loop:
    (rx119_pos) = rx119_cur."from"()
    inc rx119_pos
    rx119_cur."!cursor_from"(rx119_pos)
    ge rx119_pos, rx119_eos, rxscan123_done
  rxscan123_scan:
    set_addr $I10, rxscan123_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxscan123_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."identifier"()
    unless $P10, rx119_fail
    rx119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx119_pos = $P10."pos"()
  # rx rxquantr124 ** 0..1
    set_addr $I10, rxquantr124_done
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxquantr124_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."colonpair"()
    unless $P10, rx119_fail
    goto rxsubrule125_pass
  rxsubrule125_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx119_fail
  rxsubrule125_pass:
    set_addr $I10, rxsubrule125_back
    rx119_cur."!mark_push"(0, rx119_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx119_pos = $P10."pos"()
    set_addr $I10, rxquantr124_done
    (rx119_rep) = rx119_cur."!mark_commit"($I10)
  rxquantr124_done:
.annotate 'line', 53
  # rx pass
    rx119_cur."!cursor_pass"(rx119_pos, "deflongname")
    if_null rx119_debug, debug_626
    rx119_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx119_pos)
  debug_626:
    .return (rx119_cur)
  rx119_restart:
.annotate 'line', 10
    if_null rx119_debug, debug_627
    rx119_cur."!cursor_debug"("NEXT", "deflongname")
  debug_627:
  rx119_fail:
    (rx119_rep, rx119_pos, $I10, $P10) = rx119_cur."!mark_fail"(0)
    lt rx119_pos, -1, rx119_done
    eq rx119_pos, -1, rx119_fail
    jump $I10
  rx119_done:
    rx119_cur."!cursor_fail"()
    if_null rx119_debug, debug_628
    rx119_cur."!cursor_debug"("FAIL", "deflongname")
  debug_628:
    .return (rx119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303430322.161") :method
.annotate 'line', 10
    $P121 = self."!PREFIX__!subrule"("identifier", "")
    new $P122, "ResizablePMCArray"
    push $P122, $P121
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx127_tgt
    .local int rx127_pos
    .local int rx127_off
    .local int rx127_eos
    .local int rx127_rep
    .local pmc rx127_cur
    .local pmc rx127_debug
    (rx127_cur, rx127_pos, rx127_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx127_cur
    .local pmc match
    .lex "$/", match
    length rx127_eos, rx127_tgt
    gt rx127_pos, rx127_eos, rx127_done
    set rx127_off, 0
    lt rx127_pos, 2, rx127_start
    sub rx127_off, rx127_pos, 1
    substr rx127_tgt, rx127_tgt, rx127_off
  rx127_start:
    eq $I10, 1, rx127_restart
    if_null rx127_debug, debug_629
    rx127_cur."!cursor_debug"("START", "ENDSTMT")
  debug_629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan130_done
    goto rxscan130_scan
  rxscan130_loop:
    (rx127_pos) = rx127_cur."from"()
    inc rx127_pos
    rx127_cur."!cursor_from"(rx127_pos)
    ge rx127_pos, rx127_eos, rxscan130_done
  rxscan130_scan:
    set_addr $I10, rxscan130_loop
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxscan130_done:
.annotate 'line', 61
  # rx rxquantr131 ** 0..1
    set_addr $I10, rxquantr131_done
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxquantr131_loop:
  alt132_0:
.annotate 'line', 58
    set_addr $I10, alt132_1
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx127_pos, rx127_off
    set rx127_rep, 0
    sub $I12, rx127_eos, rx127_pos
  rxenumcharlistq133_loop:
    le $I12, 0, rxenumcharlistq133_done
    substr $S10, rx127_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq133_done
    inc rx127_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq133_loop
  rxenumcharlistq133_done:
    add rx127_pos, rx127_pos, rx127_rep
  # rxanchor eol
    sub $I10, rx127_pos, rx127_off
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rxanchor134_done
    ne rx127_pos, rx127_eos, rx127_fail
    eq rx127_pos, 0, rxanchor134_done
    dec $I10
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rx127_fail
  rxanchor134_done:
  # rx subrule "ws" subtype=method negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."ws"()
    unless $P10, rx127_fail
    rx127_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."MARKER"("endstmt")
    unless $P10, rx127_fail
    goto alt132_end
  alt132_1:
.annotate 'line', 60
  # rx rxquantr135 ** 0..1
    set_addr $I10, rxquantr135_done
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxquantr135_loop:
  # rx subrule "unv" subtype=method negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."unv"()
    unless $P10, rx127_fail
    goto rxsubrule136_pass
  rxsubrule136_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx127_fail
  rxsubrule136_pass:
    set_addr $I10, rxsubrule136_back
    rx127_cur."!mark_push"(0, rx127_pos, $I10, $P10)
    rx127_pos = $P10."pos"()
    set_addr $I10, rxquantr135_done
    (rx127_rep) = rx127_cur."!mark_commit"($I10)
  rxquantr135_done:
  # rxanchor eol
    sub $I10, rx127_pos, rx127_off
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rxanchor137_done
    ne rx127_pos, rx127_eos, rx127_fail
    eq rx127_pos, 0, rxanchor137_done
    dec $I10
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rx127_fail
  rxanchor137_done:
  # rx subrule "ws" subtype=method negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."ws"()
    unless $P10, rx127_fail
    rx127_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."MARKER"("endstmt")
    unless $P10, rx127_fail
  alt132_end:
.annotate 'line', 61
    set_addr $I10, rxquantr131_done
    (rx127_rep) = rx127_cur."!mark_commit"($I10)
  rxquantr131_done:
.annotate 'line', 57
  # rx pass
    rx127_cur."!cursor_pass"(rx127_pos, "ENDSTMT")
    if_null rx127_debug, debug_630
    rx127_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx127_pos)
  debug_630:
    .return (rx127_cur)
  rx127_restart:
.annotate 'line', 10
    if_null rx127_debug, debug_631
    rx127_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_631:
  rx127_fail:
    (rx127_rep, rx127_pos, $I10, $P10) = rx127_cur."!mark_fail"(0)
    lt rx127_pos, -1, rx127_done
    eq rx127_pos, -1, rx127_fail
    jump $I10
  rx127_done:
    rx127_cur."!cursor_fail"()
    if_null rx127_debug, debug_632
    rx127_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_632:
    .return (rx127_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303430322.161") :method
.annotate 'line', 10
    new $P129, "ResizablePMCArray"
    push $P129, ""
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx139_tgt
    .local int rx139_pos
    .local int rx139_off
    .local int rx139_eos
    .local int rx139_rep
    .local pmc rx139_cur
    .local pmc rx139_debug
    (rx139_cur, rx139_pos, rx139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx139_cur
    .local pmc match
    .lex "$/", match
    length rx139_eos, rx139_tgt
    gt rx139_pos, rx139_eos, rx139_done
    set rx139_off, 0
    lt rx139_pos, 2, rx139_start
    sub rx139_off, rx139_pos, 1
    substr rx139_tgt, rx139_tgt, rx139_off
  rx139_start:
    eq $I10, 1, rx139_restart
    if_null rx139_debug, debug_633
    rx139_cur."!cursor_debug"("START", "ws")
  debug_633:
    $I10 = self.'from'()
    ne $I10, -1, rxscan142_done
    goto rxscan142_scan
  rxscan142_loop:
    (rx139_pos) = rx139_cur."from"()
    inc rx139_pos
    rx139_cur."!cursor_from"(rx139_pos)
    ge rx139_pos, rx139_eos, rxscan142_done
  rxscan142_scan:
    set_addr $I10, rxscan142_loop
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxscan142_done:
  alt143_0:
.annotate 'line', 64
    set_addr $I10, alt143_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."MARKED"("ws")
    unless $P10, rx139_fail
    goto alt143_end
  alt143_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."ww"()
    if $P10, rx139_fail
.annotate 'line', 71
  # rx rxquantr144 ** 0..*
    set_addr $I10, rxquantr144_done
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxquantr144_loop:
  alt145_0:
.annotate 'line', 67
    set_addr $I10, alt145_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq146_loop:
    le $I12, 0, rxenumcharlistq146_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq146_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq146_loop
  rxenumcharlistq146_done:
    lt rx139_rep, 1, rx139_fail
    add rx139_pos, rx139_pos, rx139_rep
    goto alt145_end
  alt145_1:
    set_addr $I10, alt145_2
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 35, rx139_fail
    add rx139_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx139_pos, rx139_off
    find_cclass $I11, 4096, rx139_tgt, $I10, rx139_eos
    add rx139_pos, rx139_off, $I11
    goto alt145_end
  alt145_2:
    set_addr $I10, alt145_3
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx139_pos, 0, rxanchor147_done
    ge rx139_pos, rx139_eos, rx139_fail
    sub $I10, rx139_pos, rx139_off
    dec $I10
    is_cclass $I11, 4096, rx139_tgt, $I10
    unless $I11, rx139_fail
  rxanchor147_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."pod_comment"()
    unless $P10, rx139_fail
    rx139_pos = $P10."pos"()
    goto alt145_end
  alt145_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq148_loop:
    le $I12, 0, rxenumcharlistq148_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq148_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq148_loop
  rxenumcharlistq148_done:
    lt rx139_rep, 1, rx139_fail
    add rx139_pos, rx139_pos, rx139_rep
  alt145_end:
.annotate 'line', 71
    set_addr $I10, rxquantr144_done
    (rx139_rep) = rx139_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr144_done
    rx139_cur."!mark_push"(rx139_rep, rx139_pos, $I10)
    goto rxquantr144_loop
  rxquantr144_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."MARKER"("ws")
    unless $P10, rx139_fail
  alt143_end:
.annotate 'line', 64
  # rx pass
    rx139_cur."!cursor_pass"(rx139_pos, "ws")
    if_null rx139_debug, debug_634
    rx139_cur."!cursor_debug"("PASS", "ws", " at pos=", rx139_pos)
  debug_634:
    .return (rx139_cur)
  rx139_restart:
.annotate 'line', 10
    if_null rx139_debug, debug_635
    rx139_cur."!cursor_debug"("NEXT", "ws")
  debug_635:
  rx139_fail:
    (rx139_rep, rx139_pos, $I10, $P10) = rx139_cur."!mark_fail"(0)
    lt rx139_pos, -1, rx139_done
    eq rx139_pos, -1, rx139_fail
    jump $I10
  rx139_done:
    rx139_cur."!cursor_fail"()
    if_null rx139_debug, debug_636
    rx139_cur."!cursor_debug"("FAIL", "ws")
  debug_636:
    .return (rx139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303430322.161") :method
.annotate 'line', 10
    new $P141, "ResizablePMCArray"
    push $P141, ""
    push $P141, ""
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P157 = "26_1303430322.161" 
    capture_lex $P157
    .local string rx150_tgt
    .local int rx150_pos
    .local int rx150_off
    .local int rx150_eos
    .local int rx150_rep
    .local pmc rx150_cur
    .local pmc rx150_debug
    (rx150_cur, rx150_pos, rx150_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx150_cur
    .local pmc match
    .lex "$/", match
    length rx150_eos, rx150_tgt
    gt rx150_pos, rx150_eos, rx150_done
    set rx150_off, 0
    lt rx150_pos, 2, rx150_start
    sub rx150_off, rx150_pos, 1
    substr rx150_tgt, rx150_tgt, rx150_off
  rx150_start:
    eq $I10, 1, rx150_restart
    if_null rx150_debug, debug_637
    rx150_cur."!cursor_debug"("START", "unv")
  debug_637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan153_done
    goto rxscan153_scan
  rxscan153_loop:
    (rx150_pos) = rx150_cur."from"()
    inc rx150_pos
    rx150_cur."!cursor_from"(rx150_pos)
    ge rx150_pos, rx150_eos, rxscan153_done
  rxscan153_scan:
    set_addr $I10, rxscan153_loop
    rx150_cur."!mark_push"(0, rx150_pos, $I10)
  rxscan153_done:
  alt154_0:
.annotate 'line', 77
    set_addr $I10, alt154_1
    rx150_cur."!mark_push"(0, rx150_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx150_pos, 0, rxanchor155_done
    ge rx150_pos, rx150_eos, rx150_fail
    sub $I10, rx150_pos, rx150_off
    dec $I10
    is_cclass $I11, 4096, rx150_tgt, $I10
    unless $I11, rx150_fail
  rxanchor155_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx150_cur."!cursor_pos"(rx150_pos)
    .const 'Sub' $P157 = "26_1303430322.161" 
    capture_lex $P157
    $P10 = rx150_cur."before"($P157)
    unless $P10, rx150_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx150_cur."!cursor_pos"(rx150_pos)
    $P10 = rx150_cur."pod_comment"()
    unless $P10, rx150_fail
    rx150_pos = $P10."pos"()
    goto alt154_end
  alt154_1:
    set_addr $I10, alt154_2
    rx150_cur."!mark_push"(0, rx150_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx150_pos, rx150_off
    set rx150_rep, 0
    sub $I12, rx150_eos, rx150_pos
  rxenumcharlistq162_loop:
    le $I12, 0, rxenumcharlistq162_done
    substr $S10, rx150_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq162_done
    inc rx150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq162_loop
  rxenumcharlistq162_done:
    add rx150_pos, rx150_pos, rx150_rep
  # rx literal  "#"
    add $I11, rx150_pos, 1
    gt $I11, rx150_eos, rx150_fail
    sub $I11, rx150_pos, rx150_off
    ord $I11, rx150_tgt, $I11
    ne $I11, 35, rx150_fail
    add rx150_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx150_pos, rx150_off
    find_cclass $I11, 4096, rx150_tgt, $I10, rx150_eos
    add rx150_pos, rx150_off, $I11
    goto alt154_end
  alt154_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx150_pos, rx150_off
    set rx150_rep, 0
    sub $I12, rx150_eos, rx150_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx150_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    lt rx150_rep, 1, rx150_fail
    add rx150_pos, rx150_pos, rx150_rep
  alt154_end:
.annotate 'line', 75
  # rx pass
    rx150_cur."!cursor_pass"(rx150_pos, "unv")
    if_null rx150_debug, debug_642
    rx150_cur."!cursor_debug"("PASS", "unv", " at pos=", rx150_pos)
  debug_642:
    .return (rx150_cur)
  rx150_restart:
.annotate 'line', 10
    if_null rx150_debug, debug_643
    rx150_cur."!cursor_debug"("NEXT", "unv")
  debug_643:
  rx150_fail:
    (rx150_rep, rx150_pos, $I10, $P10) = rx150_cur."!mark_fail"(0)
    lt rx150_pos, -1, rx150_done
    eq rx150_pos, -1, rx150_fail
    jump $I10
  rx150_done:
    rx150_cur."!cursor_fail"()
    if_null rx150_debug, debug_644
    rx150_cur."!cursor_debug"("FAIL", "unv")
  debug_644:
    .return (rx150_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303430322.161") :method
.annotate 'line', 10
    new $P152, "ResizablePMCArray"
    push $P152, ""
    push $P152, ""
    push $P152, ""
    .return ($P152)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block156"  :anon :subid("26_1303430322.161") :method :outer("24_1303430322.161")
.annotate 'line', 78
    .local string rx158_tgt
    .local int rx158_pos
    .local int rx158_off
    .local int rx158_eos
    .local int rx158_rep
    .local pmc rx158_cur
    .local pmc rx158_debug
    (rx158_cur, rx158_pos, rx158_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx158_cur
    .local pmc match
    .lex "$/", match
    length rx158_eos, rx158_tgt
    gt rx158_pos, rx158_eos, rx158_done
    set rx158_off, 0
    lt rx158_pos, 2, rx158_start
    sub rx158_off, rx158_pos, 1
    substr rx158_tgt, rx158_tgt, rx158_off
  rx158_start:
    eq $I10, 1, rx158_restart
    if_null rx158_debug, debug_638
    rx158_cur."!cursor_debug"("START", "")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan159_done
    goto rxscan159_scan
  rxscan159_loop:
    (rx158_pos) = rx158_cur."from"()
    inc rx158_pos
    rx158_cur."!cursor_from"(rx158_pos)
    ge rx158_pos, rx158_eos, rxscan159_done
  rxscan159_scan:
    set_addr $I10, rxscan159_loop
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  rxscan159_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx158_pos, rx158_off
    set rx158_rep, 0
    sub $I12, rx158_eos, rx158_pos
  rxenumcharlistq160_loop:
    le $I12, 0, rxenumcharlistq160_done
    substr $S10, rx158_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq160_done
    inc rx158_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq160_loop
  rxenumcharlistq160_done:
    add rx158_pos, rx158_pos, rx158_rep
  # rx literal  "="
    add $I11, rx158_pos, 1
    gt $I11, rx158_eos, rx158_fail
    sub $I11, rx158_pos, rx158_off
    ord $I11, rx158_tgt, $I11
    ne $I11, 61, rx158_fail
    add rx158_pos, 1
  alt161_0:
    set_addr $I10, alt161_1
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  # rx charclass w
    ge rx158_pos, rx158_eos, rx158_fail
    sub $I10, rx158_pos, rx158_off
    is_cclass $I11, 8192, rx158_tgt, $I10
    unless $I11, rx158_fail
    inc rx158_pos
    goto alt161_end
  alt161_1:
  # rx literal  "\\"
    add $I11, rx158_pos, 1
    gt $I11, rx158_eos, rx158_fail
    sub $I11, rx158_pos, rx158_off
    ord $I11, rx158_tgt, $I11
    ne $I11, 92, rx158_fail
    add rx158_pos, 1
  alt161_end:
  # rx pass
    rx158_cur."!cursor_pass"(rx158_pos, "")
    if_null rx158_debug, debug_639
    rx158_cur."!cursor_debug"("PASS", "", " at pos=", rx158_pos)
  debug_639:
    .return (rx158_cur)
  rx158_restart:
    if_null rx158_debug, debug_640
    rx158_cur."!cursor_debug"("NEXT", "")
  debug_640:
  rx158_fail:
    (rx158_rep, rx158_pos, $I10, $P10) = rx158_cur."!mark_fail"(0)
    lt rx158_pos, -1, rx158_done
    eq rx158_pos, -1, rx158_fail
    jump $I10
  rx158_done:
    rx158_cur."!cursor_fail"()
    if_null rx158_debug, debug_641
    rx158_cur."!cursor_debug"("FAIL", "")
  debug_641:
    .return (rx158_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P196 = "29_1303430322.161" 
    capture_lex $P196
    .local string rx165_tgt
    .local int rx165_pos
    .local int rx165_off
    .local int rx165_eos
    .local int rx165_rep
    .local pmc rx165_cur
    .local pmc rx165_debug
    (rx165_cur, rx165_pos, rx165_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx165_cur
    .local pmc match
    .lex "$/", match
    length rx165_eos, rx165_tgt
    gt rx165_pos, rx165_eos, rx165_done
    set rx165_off, 0
    lt rx165_pos, 2, rx165_start
    sub rx165_off, rx165_pos, 1
    substr rx165_tgt, rx165_tgt, rx165_off
  rx165_start:
    eq $I10, 1, rx165_restart
    if_null rx165_debug, debug_645
    rx165_cur."!cursor_debug"("START", "pod_comment")
  debug_645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan168_done
    goto rxscan168_scan
  rxscan168_loop:
    (rx165_pos) = rx165_cur."from"()
    inc rx165_pos
    rx165_cur."!cursor_from"(rx165_pos)
    ge rx165_pos, rx165_eos, rxscan168_done
  rxscan168_scan:
    set_addr $I10, rxscan168_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  rxscan168_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx165_pos, 0, rxanchor169_done
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    dec $I10
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
  rxanchor169_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq170_loop:
    le $I12, 0, rxenumcharlistq170_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq170_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq170_loop
  rxenumcharlistq170_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "="
    add $I11, rx165_pos, 1
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    ord $I11, rx165_tgt, $I11
    ne $I11, 61, rx165_fail
    add rx165_pos, 1
  alt171_0:
.annotate 'line', 86
    set_addr $I10, alt171_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx165_pos, 5
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 5
    ne $S10, "begin", rx165_fail
    add rx165_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq172_loop:
    le $I12, 0, rxenumcharlistq172_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq172_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq172_loop
  rxenumcharlistq172_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "END"
    add $I11, rx165_pos, 3
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 3
    ne $S10, "END", rx165_fail
    add rx165_pos, 3
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  alt173_0:
.annotate 'line', 88
    set_addr $I10, alt173_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rx rxquantf174 ** 0..*
    set_addr $I10, rxquantf174_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf174_done
  rxquantf174_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf174_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf174_done:
  # rx charclass nl
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
    substr $S10, rx165_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx165_pos, $I11
    inc rx165_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq176_loop:
    le $I12, 0, rxenumcharlistq176_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq176_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq176_loop
  rxenumcharlistq176_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "=end"
    add $I11, rx165_pos, 4
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 4
    ne $S10, "=end", rx165_fail
    add rx165_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq177_loop:
    le $I12, 0, rxenumcharlistq177_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq177_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq177_loop
  rxenumcharlistq177_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "END"
    add $I11, rx165_pos, 3
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 3
    ne $S10, "END", rx165_fail
    add rx165_pos, 3
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
    goto alt173_end
  alt173_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_not_cclass $I11, 65535, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
  alt173_end:
.annotate 'line', 87
    goto alt171_end
  alt171_1:
    set_addr $I10, alt171_2
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx165_pos, 5
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 5
    ne $S10, "begin", rx165_fail
    add rx165_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq178_loop:
    le $I12, 0, rxenumcharlistq178_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq178_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq178_loop
  rxenumcharlistq178_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx subrule "identifier" subtype=capture negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."identifier"()
    unless $P10, rx165_fail
    rx165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx165_pos = $P10."pos"()
  alt179_0:
.annotate 'line', 90
    set_addr $I10, alt179_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 91
  # rx rxquantf180 ** 0..*
    set_addr $I10, rxquantf180_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf180_done
  rxquantf180_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf180_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf180_done:
  # rx charclass nl
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
    substr $S10, rx165_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx165_pos, $I11
    inc rx165_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq182_loop:
    le $I12, 0, rxenumcharlistq182_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq182_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq182_loop
  rxenumcharlistq182_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "=end"
    add $I11, rx165_pos, 4
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 4
    ne $S10, "=end", rx165_fail
    add rx165_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq183_loop:
    le $I12, 0, rxenumcharlistq183_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq183_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq183_loop
  rxenumcharlistq183_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."!BACKREF"("identifier")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
    goto alt179_end
  alt179_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("=begin without matching =end")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt179_end:
.annotate 'line', 89
    goto alt171_end
  alt171_2:
    set_addr $I10, alt171_3
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx165_pos, 5
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 5
    ne $S10, "begin", rx165_fail
    add rx165_pos, 5
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq185_loop:
    le $I12, 0, rxenumcharlistq185_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq185_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq185_loop
  rxenumcharlistq185_done:
    add rx165_pos, rx165_pos, rx165_rep
  alt186_0:
.annotate 'line', 95
    set_addr $I10, alt186_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rxanchor eol
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    if $I11, rxanchor187_done
    ne rx165_pos, rx165_eos, rx165_fail
    eq rx165_pos, 0, rxanchor187_done
    dec $I10
    is_cclass $I11, 4096, rx165_tgt, $I10
    if $I11, rx165_fail
  rxanchor187_done:
    goto alt186_end
  alt186_1:
    set_addr $I10, alt186_2
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rx literal  "#"
    add $I11, rx165_pos, 1
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    ord $I11, rx165_tgt, $I11
    ne $I11, 35, rx165_fail
    add rx165_pos, 1
    goto alt186_end
  alt186_2:
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt186_end:
  alt188_0:
.annotate 'line', 96
    set_addr $I10, alt188_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 97
  # rx rxquantf189 ** 0..*
    set_addr $I10, rxquantf189_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf189_done
  rxquantf189_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf189_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf189_done:
  # rx charclass nl
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
    substr $S10, rx165_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx165_pos, $I11
    inc rx165_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq191_loop:
    le $I12, 0, rxenumcharlistq191_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq191_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq191_loop
  rxenumcharlistq191_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "=end"
    add $I11, rx165_pos, 4
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 4
    ne $S10, "=end", rx165_fail
    add rx165_pos, 4
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
    goto alt188_end
  alt188_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("=begin without matching =end")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt188_end:
.annotate 'line', 94
    goto alt171_end
  alt171_3:
    set_addr $I10, alt171_4
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."identifier"()
    unless $P10, rx165_fail
    rx165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx165_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf192 ** 0..*
    set_addr $I10, rxquantf192_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf192_done
  rxquantf192_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf192_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf192_done:
  # rxanchor bol
    eq rx165_pos, 0, rxanchor194_done
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    dec $I10
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
  rxanchor194_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    .const 'Sub' $P196 = "29_1303430322.161" 
    capture_lex $P196
    $P10 = rx165_cur."before"($P196)
    unless $P10, rx165_fail
.annotate 'line', 100
    goto alt171_end
  alt171_4:
  alt202_0:
.annotate 'line', 107
    set_addr $I10, alt202_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rx charclass s
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 32, rx165_tgt, $I10
    unless $I11, rx165_fail
    inc rx165_pos
    goto alt202_end
  alt202_1:
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("Illegal pod directive")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt202_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
  alt171_end:
.annotate 'line', 84
  # rx pass
    rx165_cur."!cursor_pass"(rx165_pos, "pod_comment")
    if_null rx165_debug, debug_650
    rx165_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx165_pos)
  debug_650:
    .return (rx165_cur)
  rx165_restart:
.annotate 'line', 10
    if_null rx165_debug, debug_651
    rx165_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_651:
  rx165_fail:
    (rx165_rep, rx165_pos, $I10, $P10) = rx165_cur."!mark_fail"(0)
    lt rx165_pos, -1, rx165_done
    eq rx165_pos, -1, rx165_fail
    jump $I10
  rx165_done:
    rx165_cur."!cursor_fail"()
    if_null rx165_debug, debug_652
    rx165_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_652:
    .return (rx165_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303430322.161") :method
.annotate 'line', 10
    new $P167, "ResizablePMCArray"
    push $P167, ""
    .return ($P167)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block195"  :anon :subid("29_1303430322.161") :method :outer("27_1303430322.161")
.annotate 'line', 101
    .local string rx197_tgt
    .local int rx197_pos
    .local int rx197_off
    .local int rx197_eos
    .local int rx197_rep
    .local pmc rx197_cur
    .local pmc rx197_debug
    (rx197_cur, rx197_pos, rx197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx197_cur
    .local pmc match
    .lex "$/", match
    length rx197_eos, rx197_tgt
    gt rx197_pos, rx197_eos, rx197_done
    set rx197_off, 0
    lt rx197_pos, 2, rx197_start
    sub rx197_off, rx197_pos, 1
    substr rx197_tgt, rx197_tgt, rx197_off
  rx197_start:
    eq $I10, 1, rx197_restart
    if_null rx197_debug, debug_646
    rx197_cur."!cursor_debug"("START", "")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan198_done
    goto rxscan198_scan
  rxscan198_loop:
    (rx197_pos) = rx197_cur."from"()
    inc rx197_pos
    rx197_cur."!cursor_from"(rx197_pos)
    ge rx197_pos, rx197_eos, rxscan198_done
  rxscan198_scan:
    set_addr $I10, rxscan198_loop
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  rxscan198_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx197_pos, rx197_off
    set rx197_rep, 0
    sub $I12, rx197_eos, rx197_pos
  rxenumcharlistq199_loop:
    le $I12, 0, rxenumcharlistq199_done
    substr $S10, rx197_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq199_done
    inc rx197_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq199_loop
  rxenumcharlistq199_done:
    add rx197_pos, rx197_pos, rx197_rep
  alt200_0:
    set_addr $I10, alt200_1
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx197_pos, 1
    gt $I11, rx197_eos, rx197_fail
    sub $I11, rx197_pos, rx197_off
    ord $I11, rx197_tgt, $I11
    ne $I11, 61, rx197_fail
    add rx197_pos, 1
.annotate 'line', 104
  # rx rxquantr201 ** 0..1
    set_addr $I10, rxquantr201_done
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  rxquantr201_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx197_pos, 3
    gt $I11, rx197_eos, rx197_fail
    sub $I11, rx197_pos, rx197_off
    substr $S10, rx197_tgt, $I11, 3
    ne $S10, "cut", rx197_fail
    add rx197_pos, 3
  # rxanchor rwb
    le rx197_pos, 0, rx197_fail
    sub $I10, rx197_pos, rx197_off
    is_cclass $I11, 8192, rx197_tgt, $I10
    if $I11, rx197_fail
    dec $I10
    is_cclass $I11, 8192, rx197_tgt, $I10
    unless $I11, rx197_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx197_cur."!cursor_pos"(rx197_pos)
    $P10 = rx197_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx197_fail
    rx197_pos = $P10."pos"()
    set_addr $I10, rxquantr201_done
    (rx197_rep) = rx197_cur."!mark_commit"($I10)
  rxquantr201_done:
.annotate 'line', 101
    goto alt200_end
  alt200_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx197_pos, rx197_eos, rx197_fail
    sub $I10, rx197_pos, rx197_off
    is_cclass $I11, 4096, rx197_tgt, $I10
    unless $I11, rx197_fail
    substr $S10, rx197_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx197_pos, $I11
    inc rx197_pos
  alt200_end:
.annotate 'line', 101
  # rx pass
    rx197_cur."!cursor_pass"(rx197_pos, "")
    if_null rx197_debug, debug_647
    rx197_cur."!cursor_debug"("PASS", "", " at pos=", rx197_pos)
  debug_647:
    .return (rx197_cur)
  rx197_restart:
    if_null rx197_debug, debug_648
    rx197_cur."!cursor_debug"("NEXT", "")
  debug_648:
  rx197_fail:
    (rx197_rep, rx197_pos, $I10, $P10) = rx197_cur."!mark_fail"(0)
    lt rx197_pos, -1, rx197_done
    eq rx197_pos, -1, rx197_fail
    jump $I10
  rx197_done:
    rx197_cur."!cursor_fail"()
    if_null rx197_debug, debug_649
    rx197_cur."!cursor_debug"("FAIL", "")
  debug_649:
    .return (rx197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 116
    new $P204, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P204
.annotate 'line', 117
    new $P205, "Undef"
    .lex "$*MAIN_SUB", $P205
.annotate 'line', 121
    new $P206, "Undef"
    .lex "$*PACKAGE", $P206
.annotate 'line', 122
    new $P207, "Undef"
    .lex "$*GLOBALish", $P207
.annotate 'line', 10
    .local string rx208_tgt
    .local int rx208_pos
    .local int rx208_off
    .local int rx208_eos
    .local int rx208_rep
    .local pmc rx208_cur
    .local pmc rx208_debug
    (rx208_cur, rx208_pos, rx208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx208_cur
    .local pmc match
    .lex "$/", match
    length rx208_eos, rx208_tgt
    gt rx208_pos, rx208_eos, rx208_done
    set rx208_off, 0
    lt rx208_pos, 2, rx208_start
    sub rx208_off, rx208_pos, 1
    substr rx208_tgt, rx208_tgt, rx208_off
  rx208_start:
    eq $I10, 1, rx208_restart
    if_null rx208_debug, debug_653
    rx208_cur."!cursor_debug"("START", "comp_unit")
  debug_653:
    $I10 = self.'from'()
    ne $I10, -1, rxscan212_done
    goto rxscan212_scan
  rxscan212_loop:
    (rx208_pos) = rx208_cur."from"()
    inc rx208_pos
    rx208_cur."!cursor_from"(rx208_pos)
    ge rx208_pos, rx208_eos, rxscan212_done
  rxscan212_scan:
    set_addr $I10, rxscan212_loop
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxscan212_done:
.annotate 'line', 116
    rx208_cur."!cursor_pos"(rx208_pos)
    new $P213, "Integer"
    assign $P213, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P213
.annotate 'line', 117
    rx208_cur."!cursor_pos"(rx208_pos)
    find_lex $P214, "$*MAIN_SUB"
    unless_null $P214, vivify_654
    get_hll_global $P214, "$MAIN_SUB"
    unless_null $P214, vivify_655
    die "Contextual $*MAIN_SUB not found"
  vivify_655:
  vivify_654:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."newpad"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."outerctx"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 121
    rx208_cur."!cursor_pos"(rx208_pos)
    find_lex $P215, "$*PACKAGE"
    unless_null $P215, vivify_656
    get_hll_global $P215, "$PACKAGE"
    unless_null $P215, vivify_657
    die "Contextual $*PACKAGE not found"
  vivify_657:
  vivify_656:
.annotate 'line', 122
    rx208_cur."!cursor_pos"(rx208_pos)
    find_lex $P216, "$*GLOBALish"
    unless_null $P216, vivify_658
    get_hll_global $P216, "$GLOBALish"
    unless_null $P216, vivify_659
    die "Contextual $*GLOBALish not found"
  vivify_659:
  vivify_658:
.annotate 'line', 123
  # rx subrule "GLOBALish" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."GLOBALish"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 125
  # rx subrule "statementlist" subtype=capture negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."statementlist"()
    unless $P10, rx208_fail
    rx208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx208_pos = $P10."pos"()
  alt217_0:
.annotate 'line', 126
    set_addr $I10, alt217_1
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  # rxanchor eos
    ne rx208_pos, rx208_eos, rx208_fail
    goto alt217_end
  alt217_1:
  # rx subrule "panic" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."panic"("Confused")
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  alt217_end:
.annotate 'line', 115
  # rx pass
    rx208_cur."!cursor_pass"(rx208_pos, "comp_unit")
    if_null rx208_debug, debug_660
    rx208_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx208_pos)
  debug_660:
    .return (rx208_cur)
  rx208_restart:
.annotate 'line', 10
    if_null rx208_debug, debug_661
    rx208_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_661:
  rx208_fail:
    (rx208_rep, rx208_pos, $I10, $P10) = rx208_cur."!mark_fail"(0)
    lt rx208_pos, -1, rx208_done
    eq rx208_pos, -1, rx208_fail
    jump $I10
  rx208_done:
    rx208_cur."!cursor_fail"()
    if_null rx208_debug, debug_662
    rx208_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_662:
    .return (rx208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303430322.161") :method
.annotate 'line', 10
    $P210 = self."!PREFIX__!subrule"("newpad", "")
    new $P211, "ResizablePMCArray"
    push $P211, $P210
    .return ($P211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx219_tgt
    .local int rx219_pos
    .local int rx219_off
    .local int rx219_eos
    .local int rx219_rep
    .local pmc rx219_cur
    .local pmc rx219_debug
    (rx219_cur, rx219_pos, rx219_tgt, $I10) = self."!cursor_start"()
    rx219_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx219_cur
    .local pmc match
    .lex "$/", match
    length rx219_eos, rx219_tgt
    gt rx219_pos, rx219_eos, rx219_done
    set rx219_off, 0
    lt rx219_pos, 2, rx219_start
    sub rx219_off, rx219_pos, 1
    substr rx219_tgt, rx219_tgt, rx219_off
  rx219_start:
    eq $I10, 1, rx219_restart
    if_null rx219_debug, debug_663
    rx219_cur."!cursor_debug"("START", "statementlist")
  debug_663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan224_done
    goto rxscan224_scan
  rxscan224_loop:
    (rx219_pos) = rx219_cur."from"()
    inc rx219_pos
    rx219_cur."!cursor_from"(rx219_pos)
    ge rx219_pos, rx219_eos, rxscan224_done
  rxscan224_scan:
    set_addr $I10, rxscan224_loop
    rx219_cur."!mark_push"(0, rx219_pos, $I10)
  rxscan224_done:
  alt225_0:
.annotate 'line', 129
    set_addr $I10, alt225_1
    rx219_cur."!mark_push"(0, rx219_pos, $I10)
.annotate 'line', 130
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  # rxanchor eos
    ne rx219_pos, rx219_eos, rx219_fail
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
    goto alt225_end
  alt225_1:
.annotate 'line', 131
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  # rx rxquantr229 ** 0..*
    set_addr $I10, rxquantr229_done
    rx219_cur."!mark_push"(0, rx219_pos, $I10)
  rxquantr229_loop:
  # rx subrule "statement" subtype=capture negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."statement"()
    unless $P10, rx219_fail
    rx219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx219_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."eat_terminator"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
    set_addr $I10, rxquantr229_done
    (rx219_rep) = rx219_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr229_done
    rx219_cur."!mark_push"(rx219_rep, rx219_pos, $I10)
    goto rxquantr229_loop
  rxquantr229_done:
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  alt225_end:
.annotate 'line', 129
  # rx pass
    rx219_cur."!cursor_pass"(rx219_pos, "statementlist")
    if_null rx219_debug, debug_664
    rx219_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx219_pos)
  debug_664:
    .return (rx219_cur)
  rx219_restart:
.annotate 'line', 10
    if_null rx219_debug, debug_665
    rx219_cur."!cursor_debug"("NEXT", "statementlist")
  debug_665:
  rx219_fail:
    (rx219_rep, rx219_pos, $I10, $P10) = rx219_cur."!mark_fail"(0)
    lt rx219_pos, -1, rx219_done
    eq rx219_pos, -1, rx219_fail
    jump $I10
  rx219_done:
    rx219_cur."!cursor_fail"()
    if_null rx219_debug, debug_666
    rx219_cur."!cursor_debug"("FAIL", "statementlist")
  debug_666:
    .return (rx219_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303430322.161") :method
.annotate 'line', 10
    $P221 = self."!PREFIX__!subrule"("ws", "")
    $P222 = self."!PREFIX__!subrule"("ws", "")
    new $P223, "ResizablePMCArray"
    push $P223, $P221
    push $P223, $P222
    .return ($P223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P238 = "36_1303430322.161" 
    capture_lex $P238
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    rx233_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_667
    rx233_cur."!cursor_debug"("START", "statement")
  debug_667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan236_done
    goto rxscan236_scan
  rxscan236_loop:
    (rx233_pos) = rx233_cur."from"()
    inc rx233_pos
    rx233_cur."!cursor_from"(rx233_pos)
    ge rx233_pos, rx233_eos, rxscan236_done
  rxscan236_scan:
    set_addr $I10, rxscan236_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan236_done:
.annotate 'line', 135
  # rx subrule "before" subtype=zerowidth negate=1
    rx233_cur."!cursor_pos"(rx233_pos)
    .const 'Sub' $P238 = "36_1303430322.161" 
    capture_lex $P238
    $P10 = rx233_cur."before"($P238)
    if $P10, rx233_fail
  alt242_0:
.annotate 'line', 136
    set_addr $I10, alt242_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_control" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_control"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx233_pos = $P10."pos"()
    goto alt242_end
  alt242_1:
.annotate 'line', 138
  # rx subrule "EXPR" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."EXPR"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx233_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."ws"()
    unless $P10, rx233_fail
    rx233_pos = $P10."pos"()
.annotate 'line', 143
  # rx rxquantr243 ** 0..1
    set_addr $I10, rxquantr243_done
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxquantr243_loop:
  alt244_0:
.annotate 'line', 139
    set_addr $I10, alt244_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 140
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."MARKED"("endstmt")
    unless $P10, rx233_fail
    goto alt244_end
  alt244_1:
    set_addr $I10, alt244_2
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 141
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_mod_cond"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx233_pos = $P10."pos"()
  # rx rxquantr245 ** 0..1
    set_addr $I10, rxquantr245_done
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxquantr245_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_mod_loop"()
    unless $P10, rx233_fail
    goto rxsubrule246_pass
  rxsubrule246_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx233_fail
  rxsubrule246_pass:
    set_addr $I10, rxsubrule246_back
    rx233_cur."!mark_push"(0, rx233_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx233_pos = $P10."pos"()
    set_addr $I10, rxquantr245_done
    (rx233_rep) = rx233_cur."!mark_commit"($I10)
  rxquantr245_done:
    goto alt244_end
  alt244_2:
.annotate 'line', 142
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_mod_loop"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx233_pos = $P10."pos"()
  alt244_end:
.annotate 'line', 143
    set_addr $I10, rxquantr243_done
    (rx233_rep) = rx233_cur."!mark_commit"($I10)
  rxquantr243_done:
  alt242_end:
.annotate 'line', 134
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "statement")
    if_null rx233_debug, debug_672
    rx233_cur."!cursor_debug"("PASS", "statement", " at pos=", rx233_pos)
  debug_672:
    .return (rx233_cur)
  rx233_restart:
.annotate 'line', 10
    if_null rx233_debug, debug_673
    rx233_cur."!cursor_debug"("NEXT", "statement")
  debug_673:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_674
    rx233_cur."!cursor_debug"("FAIL", "statement")
  debug_674:
    .return (rx233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303430322.161") :method
.annotate 'line', 10
    new $P235, "ResizablePMCArray"
    push $P235, ""
    .return ($P235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block237"  :anon :subid("36_1303430322.161") :method :outer("34_1303430322.161")
.annotate 'line', 135
    .local string rx239_tgt
    .local int rx239_pos
    .local int rx239_off
    .local int rx239_eos
    .local int rx239_rep
    .local pmc rx239_cur
    .local pmc rx239_debug
    (rx239_cur, rx239_pos, rx239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx239_cur
    .local pmc match
    .lex "$/", match
    length rx239_eos, rx239_tgt
    gt rx239_pos, rx239_eos, rx239_done
    set rx239_off, 0
    lt rx239_pos, 2, rx239_start
    sub rx239_off, rx239_pos, 1
    substr rx239_tgt, rx239_tgt, rx239_off
  rx239_start:
    eq $I10, 1, rx239_restart
    if_null rx239_debug, debug_668
    rx239_cur."!cursor_debug"("START", "")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan240_done
    goto rxscan240_scan
  rxscan240_loop:
    (rx239_pos) = rx239_cur."from"()
    inc rx239_pos
    rx239_cur."!cursor_from"(rx239_pos)
    ge rx239_pos, rx239_eos, rxscan240_done
  rxscan240_scan:
    set_addr $I10, rxscan240_loop
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  rxscan240_done:
  alt241_0:
    set_addr $I10, alt241_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx239_pos, rx239_eos, rx239_fail
    sub $I10, rx239_pos, rx239_off
    substr $S10, rx239_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx239_fail
    inc rx239_pos
    goto alt241_end
  alt241_1:
  # rxanchor eos
    ne rx239_pos, rx239_eos, rx239_fail
  alt241_end:
  # rx pass
    rx239_cur."!cursor_pass"(rx239_pos, "")
    if_null rx239_debug, debug_669
    rx239_cur."!cursor_debug"("PASS", "", " at pos=", rx239_pos)
  debug_669:
    .return (rx239_cur)
  rx239_restart:
    if_null rx239_debug, debug_670
    rx239_cur."!cursor_debug"("NEXT", "")
  debug_670:
  rx239_fail:
    (rx239_rep, rx239_pos, $I10, $P10) = rx239_cur."!mark_fail"(0)
    lt rx239_pos, -1, rx239_done
    eq rx239_pos, -1, rx239_fail
    jump $I10
  rx239_done:
    rx239_cur."!cursor_fail"()
    if_null rx239_debug, debug_671
    rx239_cur."!cursor_debug"("FAIL", "")
  debug_671:
    .return (rx239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx248_tgt
    .local int rx248_pos
    .local int rx248_off
    .local int rx248_eos
    .local int rx248_rep
    .local pmc rx248_cur
    .local pmc rx248_debug
    (rx248_cur, rx248_pos, rx248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx248_cur
    .local pmc match
    .lex "$/", match
    length rx248_eos, rx248_tgt
    gt rx248_pos, rx248_eos, rx248_done
    set rx248_off, 0
    lt rx248_pos, 2, rx248_start
    sub rx248_off, rx248_pos, 1
    substr rx248_tgt, rx248_tgt, rx248_off
  rx248_start:
    eq $I10, 1, rx248_restart
    if_null rx248_debug, debug_675
    rx248_cur."!cursor_debug"("START", "eat_terminator")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan251_done
    goto rxscan251_scan
  rxscan251_loop:
    (rx248_pos) = rx248_cur."from"()
    inc rx248_pos
    rx248_cur."!cursor_from"(rx248_pos)
    ge rx248_pos, rx248_eos, rxscan251_done
  rxscan251_scan:
    set_addr $I10, rxscan251_loop
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
  rxscan251_done:
  alt252_0:
.annotate 'line', 147
    set_addr $I10, alt252_1
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
.annotate 'line', 148
  # rx literal  ";"
    add $I11, rx248_pos, 1
    gt $I11, rx248_eos, rx248_fail
    sub $I11, rx248_pos, rx248_off
    ord $I11, rx248_tgt, $I11
    ne $I11, 59, rx248_fail
    add rx248_pos, 1
    goto alt252_end
  alt252_1:
    set_addr $I10, alt252_2
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
.annotate 'line', 149
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx248_cur."!cursor_pos"(rx248_pos)
    $P10 = rx248_cur."MARKED"("endstmt")
    unless $P10, rx248_fail
    goto alt252_end
  alt252_2:
    set_addr $I10, alt252_3
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
.annotate 'line', 150
  # rx subrule "terminator" subtype=zerowidth negate=
    rx248_cur."!cursor_pos"(rx248_pos)
    $P10 = rx248_cur."terminator"()
    unless $P10, rx248_fail
    goto alt252_end
  alt252_3:
.annotate 'line', 151
  # rxanchor eos
    ne rx248_pos, rx248_eos, rx248_fail
  alt252_end:
.annotate 'line', 147
  # rx pass
    rx248_cur."!cursor_pass"(rx248_pos, "eat_terminator")
    if_null rx248_debug, debug_676
    rx248_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx248_pos)
  debug_676:
    .return (rx248_cur)
  rx248_restart:
.annotate 'line', 10
    if_null rx248_debug, debug_677
    rx248_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_677:
  rx248_fail:
    (rx248_rep, rx248_pos, $I10, $P10) = rx248_cur."!mark_fail"(0)
    lt rx248_pos, -1, rx248_done
    eq rx248_pos, -1, rx248_fail
    jump $I10
  rx248_done:
    rx248_cur."!cursor_fail"()
    if_null rx248_debug, debug_678
    rx248_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_678:
    .return (rx248_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303430322.161") :method
.annotate 'line', 10
    new $P250, "ResizablePMCArray"
    push $P250, ""
    push $P250, ""
    push $P250, ""
    push $P250, ";"
    .return ($P250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx254_tgt
    .local int rx254_pos
    .local int rx254_off
    .local int rx254_eos
    .local int rx254_rep
    .local pmc rx254_cur
    .local pmc rx254_debug
    (rx254_cur, rx254_pos, rx254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx254_cur
    .local pmc match
    .lex "$/", match
    length rx254_eos, rx254_tgt
    gt rx254_pos, rx254_eos, rx254_done
    set rx254_off, 0
    lt rx254_pos, 2, rx254_start
    sub rx254_off, rx254_pos, 1
    substr rx254_tgt, rx254_tgt, rx254_off
  rx254_start:
    eq $I10, 1, rx254_restart
    if_null rx254_debug, debug_679
    rx254_cur."!cursor_debug"("START", "xblock")
  debug_679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan258_done
    goto rxscan258_scan
  rxscan258_loop:
    (rx254_pos) = rx254_cur."from"()
    inc rx254_pos
    rx254_cur."!cursor_from"(rx254_pos)
    ge rx254_pos, rx254_eos, rxscan258_done
  rxscan258_scan:
    set_addr $I10, rxscan258_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  rxscan258_done:
.annotate 'line', 155
  # rx subrule "EXPR" subtype=capture negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."EXPR"()
    unless $P10, rx254_fail
    rx254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx254_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."ws"()
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."pblock"()
    unless $P10, rx254_fail
    rx254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx254_pos = $P10."pos"()
.annotate 'line', 154
  # rx pass
    rx254_cur."!cursor_pass"(rx254_pos, "xblock")
    if_null rx254_debug, debug_680
    rx254_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx254_pos)
  debug_680:
    .return (rx254_cur)
  rx254_restart:
.annotate 'line', 10
    if_null rx254_debug, debug_681
    rx254_cur."!cursor_debug"("NEXT", "xblock")
  debug_681:
  rx254_fail:
    (rx254_rep, rx254_pos, $I10, $P10) = rx254_cur."!mark_fail"(0)
    lt rx254_pos, -1, rx254_done
    eq rx254_pos, -1, rx254_fail
    jump $I10
  rx254_done:
    rx254_cur."!cursor_fail"()
    if_null rx254_debug, debug_682
    rx254_cur."!cursor_debug"("FAIL", "xblock")
  debug_682:
    .return (rx254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303430322.161") :method
.annotate 'line', 10
    $P256 = self."!PREFIX__!subrule"("EXPR", "")
    new $P257, "ResizablePMCArray"
    push $P257, $P256
    .return ($P257)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx260_tgt
    .local int rx260_pos
    .local int rx260_off
    .local int rx260_eos
    .local int rx260_rep
    .local pmc rx260_cur
    .local pmc rx260_debug
    (rx260_cur, rx260_pos, rx260_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx260_cur
    .local pmc match
    .lex "$/", match
    length rx260_eos, rx260_tgt
    gt rx260_pos, rx260_eos, rx260_done
    set rx260_off, 0
    lt rx260_pos, 2, rx260_start
    sub rx260_off, rx260_pos, 1
    substr rx260_tgt, rx260_tgt, rx260_off
  rx260_start:
    eq $I10, 1, rx260_restart
    if_null rx260_debug, debug_683
    rx260_cur."!cursor_debug"("START", "pblock")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan265_done
    goto rxscan265_scan
  rxscan265_loop:
    (rx260_pos) = rx260_cur."from"()
    inc rx260_pos
    rx260_cur."!cursor_from"(rx260_pos)
    ge rx260_pos, rx260_eos, rxscan265_done
  rxscan265_scan:
    set_addr $I10, rxscan265_loop
    rx260_cur."!mark_push"(0, rx260_pos, $I10)
  rxscan265_done:
  alt266_0:
.annotate 'line', 158
    set_addr $I10, alt266_1
    rx260_cur."!mark_push"(0, rx260_pos, $I10)
.annotate 'line', 159
  # rx subrule "lambda" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."lambda"()
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."newpad"()
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "signature" subtype=capture negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."signature"()
    unless $P10, rx260_fail
    rx260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx260_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."blockoid"()
    unless $P10, rx260_fail
    rx260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx260_pos = $P10."pos"()
.annotate 'line', 159
    goto alt266_end
  alt266_1:
    set_addr $I10, alt266_2
    rx260_cur."!mark_push"(0, rx260_pos, $I10)
.annotate 'line', 163
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx260_pos, rx260_off
    substr $S10, rx260_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx260_fail
.annotate 'line', 164
  # rx subrule "newpad" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."newpad"()
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
.annotate 'line', 165
  # rx subrule "blockoid" subtype=capture negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."blockoid"()
    unless $P10, rx260_fail
    rx260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx260_pos = $P10."pos"()
.annotate 'line', 163
    goto alt266_end
  alt266_2:
.annotate 'line', 166
  # rx subrule "panic" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."panic"("Missing block")
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
  alt266_end:
.annotate 'line', 158
  # rx pass
    rx260_cur."!cursor_pass"(rx260_pos, "pblock")
    if_null rx260_debug, debug_684
    rx260_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx260_pos)
  debug_684:
    .return (rx260_cur)
  rx260_restart:
.annotate 'line', 10
    if_null rx260_debug, debug_685
    rx260_cur."!cursor_debug"("NEXT", "pblock")
  debug_685:
  rx260_fail:
    (rx260_rep, rx260_pos, $I10, $P10) = rx260_cur."!mark_fail"(0)
    lt rx260_pos, -1, rx260_done
    eq rx260_pos, -1, rx260_fail
    jump $I10
  rx260_done:
    rx260_cur."!cursor_fail"()
    if_null rx260_debug, debug_686
    rx260_cur."!cursor_debug"("FAIL", "pblock")
  debug_686:
    .return (rx260_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303430322.161") :method
.annotate 'line', 10
    $P262 = self."!PREFIX__!subrule"("panic", "")
    $P263 = self."!PREFIX__!subrule"("lambda", "")
    new $P264, "ResizablePMCArray"
    push $P264, $P262
    push $P264, "{"
    push $P264, $P263
    .return ($P264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_687
    rx268_cur."!cursor_debug"("START", "lambda")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan271_done
    goto rxscan271_scan
  rxscan271_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan271_done
  rxscan271_scan:
    set_addr $I10, rxscan271_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan271_done:
  alt272_0:
.annotate 'line', 169
    set_addr $I10, alt272_1
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  # rx literal  "->"
    add $I11, rx268_pos, 2
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    substr $S10, rx268_tgt, $I11, 2
    ne $S10, "->", rx268_fail
    add rx268_pos, 2
    goto alt272_end
  alt272_1:
  # rx literal  "<->"
    add $I11, rx268_pos, 3
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    substr $S10, rx268_tgt, $I11, 3
    ne $S10, "<->", rx268_fail
    add rx268_pos, 3
  alt272_end:
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "lambda")
    if_null rx268_debug, debug_688
    rx268_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx268_pos)
  debug_688:
    .return (rx268_cur)
  rx268_restart:
.annotate 'line', 10
    if_null rx268_debug, debug_689
    rx268_cur."!cursor_debug"("NEXT", "lambda")
  debug_689:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_690
    rx268_cur."!cursor_debug"("FAIL", "lambda")
  debug_690:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303430322.161") :method
.annotate 'line', 10
    new $P270, "ResizablePMCArray"
    push $P270, "<->"
    push $P270, "->"
    .return ($P270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx274_tgt
    .local int rx274_pos
    .local int rx274_off
    .local int rx274_eos
    .local int rx274_rep
    .local pmc rx274_cur
    .local pmc rx274_debug
    (rx274_cur, rx274_pos, rx274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx274_cur
    .local pmc match
    .lex "$/", match
    length rx274_eos, rx274_tgt
    gt rx274_pos, rx274_eos, rx274_done
    set rx274_off, 0
    lt rx274_pos, 2, rx274_start
    sub rx274_off, rx274_pos, 1
    substr rx274_tgt, rx274_tgt, rx274_off
  rx274_start:
    eq $I10, 1, rx274_restart
    if_null rx274_debug, debug_691
    rx274_cur."!cursor_debug"("START", "block")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan278_done
    goto rxscan278_scan
  rxscan278_loop:
    (rx274_pos) = rx274_cur."from"()
    inc rx274_pos
    rx274_cur."!cursor_from"(rx274_pos)
    ge rx274_pos, rx274_eos, rxscan278_done
  rxscan278_scan:
    set_addr $I10, rxscan278_loop
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  rxscan278_done:
  alt279_0:
.annotate 'line', 172
    set_addr $I10, alt279_1
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx274_pos, rx274_off
    substr $S10, rx274_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx274_fail
    goto alt279_end
  alt279_1:
  # rx subrule "panic" subtype=method negate=
    rx274_cur."!cursor_pos"(rx274_pos)
    $P10 = rx274_cur."panic"("Missing block")
    unless $P10, rx274_fail
    rx274_pos = $P10."pos"()
  alt279_end:
.annotate 'line', 173
  # rx subrule "newpad" subtype=method negate=
    rx274_cur."!cursor_pos"(rx274_pos)
    $P10 = rx274_cur."newpad"()
    unless $P10, rx274_fail
    rx274_pos = $P10."pos"()
.annotate 'line', 174
  # rx subrule "blockoid" subtype=capture negate=
    rx274_cur."!cursor_pos"(rx274_pos)
    $P10 = rx274_cur."blockoid"()
    unless $P10, rx274_fail
    rx274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx274_pos = $P10."pos"()
.annotate 'line', 171
  # rx pass
    rx274_cur."!cursor_pass"(rx274_pos, "block")
    if_null rx274_debug, debug_692
    rx274_cur."!cursor_debug"("PASS", "block", " at pos=", rx274_pos)
  debug_692:
    .return (rx274_cur)
  rx274_restart:
.annotate 'line', 10
    if_null rx274_debug, debug_693
    rx274_cur."!cursor_debug"("NEXT", "block")
  debug_693:
  rx274_fail:
    (rx274_rep, rx274_pos, $I10, $P10) = rx274_cur."!mark_fail"(0)
    lt rx274_pos, -1, rx274_done
    eq rx274_pos, -1, rx274_fail
    jump $I10
  rx274_done:
    rx274_cur."!cursor_fail"()
    if_null rx274_debug, debug_694
    rx274_cur."!cursor_debug"("FAIL", "block")
  debug_694:
    .return (rx274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303430322.161") :method
.annotate 'line', 10
    $P276 = self."!PREFIX__!subrule"("panic", "")
    new $P277, "ResizablePMCArray"
    push $P277, $P276
    push $P277, "{"
    .return ($P277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx281_tgt
    .local int rx281_pos
    .local int rx281_off
    .local int rx281_eos
    .local int rx281_rep
    .local pmc rx281_cur
    .local pmc rx281_debug
    (rx281_cur, rx281_pos, rx281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx281_cur
    .local pmc match
    .lex "$/", match
    length rx281_eos, rx281_tgt
    gt rx281_pos, rx281_eos, rx281_done
    set rx281_off, 0
    lt rx281_pos, 2, rx281_start
    sub rx281_off, rx281_pos, 1
    substr rx281_tgt, rx281_tgt, rx281_off
  rx281_start:
    eq $I10, 1, rx281_restart
    if_null rx281_debug, debug_695
    rx281_cur."!cursor_debug"("START", "blockoid")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan285_done
    goto rxscan285_scan
  rxscan285_loop:
    (rx281_pos) = rx281_cur."from"()
    inc rx281_pos
    rx281_cur."!cursor_from"(rx281_pos)
    ge rx281_pos, rx281_eos, rxscan285_done
  rxscan285_scan:
    set_addr $I10, rxscan285_loop
    rx281_cur."!mark_push"(0, rx281_pos, $I10)
  rxscan285_done:
.annotate 'line', 178
  # rx subrule "finishpad" subtype=method negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."finishpad"()
    unless $P10, rx281_fail
    rx281_pos = $P10."pos"()
  alt286_0:
.annotate 'line', 179
    set_addr $I10, alt286_1
    rx281_cur."!mark_push"(0, rx281_pos, $I10)
.annotate 'line', 180
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx281_pos, 14
    gt $I11, rx281_eos, rx281_fail
    sub $I11, rx281_pos, rx281_off
    substr $S10, rx281_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx281_fail
    add rx281_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."you_are_here"()
    unless $P10, rx281_fail
    rx281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx281_pos = $P10."pos"()
    goto alt286_end
  alt286_1:
.annotate 'line', 181
  # rx literal  "{"
    add $I11, rx281_pos, 1
    gt $I11, rx281_eos, rx281_fail
    sub $I11, rx281_pos, rx281_off
    ord $I11, rx281_tgt, $I11
    ne $I11, 123, rx281_fail
    add rx281_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."statementlist"()
    unless $P10, rx281_fail
    rx281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx281_pos = $P10."pos"()
  alt287_0:
    set_addr $I10, alt287_1
    rx281_cur."!mark_push"(0, rx281_pos, $I10)
  # rx literal  "}"
    add $I11, rx281_pos, 1
    gt $I11, rx281_eos, rx281_fail
    sub $I11, rx281_pos, rx281_off
    ord $I11, rx281_tgt, $I11
    ne $I11, 125, rx281_fail
    add rx281_pos, 1
    goto alt287_end
  alt287_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."FAILGOAL"("'}'")
    unless $P10, rx281_fail
    goto rxsubrule289_pass
  rxsubrule289_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx281_fail
  rxsubrule289_pass:
    set_addr $I10, rxsubrule289_back
    rx281_cur."!mark_push"(0, rx281_pos, $I10, $P10)
    rx281_pos = $P10."pos"()
  alt287_end:
  alt286_end:
.annotate 'line', 183
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."ENDSTMT"()
    unless $P10, rx281_fail
.annotate 'line', 177
  # rx pass
    rx281_cur."!cursor_pass"(rx281_pos, "blockoid")
    if_null rx281_debug, debug_696
    rx281_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx281_pos)
  debug_696:
    .return (rx281_cur)
  rx281_restart:
.annotate 'line', 10
    if_null rx281_debug, debug_697
    rx281_cur."!cursor_debug"("NEXT", "blockoid")
  debug_697:
  rx281_fail:
    (rx281_rep, rx281_pos, $I10, $P10) = rx281_cur."!mark_fail"(0)
    lt rx281_pos, -1, rx281_done
    eq rx281_pos, -1, rx281_fail
    jump $I10
  rx281_done:
    rx281_cur."!cursor_fail"()
    if_null rx281_debug, debug_698
    rx281_cur."!cursor_debug"("FAIL", "blockoid")
  debug_698:
    .return (rx281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303430322.161") :method
.annotate 'line', 10
    $P283 = self."!PREFIX__!subrule"("finishpad", "")
    new $P284, "ResizablePMCArray"
    push $P284, $P283
    .return ($P284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx291_tgt
    .local int rx291_pos
    .local int rx291_off
    .local int rx291_eos
    .local int rx291_rep
    .local pmc rx291_cur
    .local pmc rx291_debug
    (rx291_cur, rx291_pos, rx291_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx291_cur
    .local pmc match
    .lex "$/", match
    length rx291_eos, rx291_tgt
    gt rx291_pos, rx291_eos, rx291_done
    set rx291_off, 0
    lt rx291_pos, 2, rx291_start
    sub rx291_off, rx291_pos, 1
    substr rx291_tgt, rx291_tgt, rx291_off
  rx291_start:
    eq $I10, 1, rx291_restart
    if_null rx291_debug, debug_699
    rx291_cur."!cursor_debug"("START", "newpad")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan294_done
    goto rxscan294_scan
  rxscan294_loop:
    (rx291_pos) = rx291_cur."from"()
    inc rx291_pos
    rx291_cur."!cursor_from"(rx291_pos)
    ge rx291_pos, rx291_eos, rxscan294_done
  rxscan294_scan:
    set_addr $I10, rxscan294_loop
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  rxscan294_done:
.annotate 'line', 186
  # rx pass
    rx291_cur."!cursor_pass"(rx291_pos, "newpad")
    if_null rx291_debug, debug_700
    rx291_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx291_pos)
  debug_700:
    .return (rx291_cur)
  rx291_restart:
.annotate 'line', 10
    if_null rx291_debug, debug_701
    rx291_cur."!cursor_debug"("NEXT", "newpad")
  debug_701:
  rx291_fail:
    (rx291_rep, rx291_pos, $I10, $P10) = rx291_cur."!mark_fail"(0)
    lt rx291_pos, -1, rx291_done
    eq rx291_pos, -1, rx291_fail
    jump $I10
  rx291_done:
    rx291_cur."!cursor_fail"()
    if_null rx291_debug, debug_702
    rx291_cur."!cursor_debug"("FAIL", "newpad")
  debug_702:
    .return (rx291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303430322.161") :method
.annotate 'line', 10
    new $P293, "ResizablePMCArray"
    push $P293, ""
    .return ($P293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx296_tgt
    .local int rx296_pos
    .local int rx296_off
    .local int rx296_eos
    .local int rx296_rep
    .local pmc rx296_cur
    .local pmc rx296_debug
    (rx296_cur, rx296_pos, rx296_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx296_cur
    .local pmc match
    .lex "$/", match
    length rx296_eos, rx296_tgt
    gt rx296_pos, rx296_eos, rx296_done
    set rx296_off, 0
    lt rx296_pos, 2, rx296_start
    sub rx296_off, rx296_pos, 1
    substr rx296_tgt, rx296_tgt, rx296_off
  rx296_start:
    eq $I10, 1, rx296_restart
    if_null rx296_debug, debug_703
    rx296_cur."!cursor_debug"("START", "outerctx")
  debug_703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan299_done
    goto rxscan299_scan
  rxscan299_loop:
    (rx296_pos) = rx296_cur."from"()
    inc rx296_pos
    rx296_cur."!cursor_from"(rx296_pos)
    ge rx296_pos, rx296_eos, rxscan299_done
  rxscan299_scan:
    set_addr $I10, rxscan299_loop
    rx296_cur."!mark_push"(0, rx296_pos, $I10)
  rxscan299_done:
.annotate 'line', 187
  # rx pass
    rx296_cur."!cursor_pass"(rx296_pos, "outerctx")
    if_null rx296_debug, debug_704
    rx296_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx296_pos)
  debug_704:
    .return (rx296_cur)
  rx296_restart:
.annotate 'line', 10
    if_null rx296_debug, debug_705
    rx296_cur."!cursor_debug"("NEXT", "outerctx")
  debug_705:
  rx296_fail:
    (rx296_rep, rx296_pos, $I10, $P10) = rx296_cur."!mark_fail"(0)
    lt rx296_pos, -1, rx296_done
    eq rx296_pos, -1, rx296_fail
    jump $I10
  rx296_done:
    rx296_cur."!cursor_fail"()
    if_null rx296_debug, debug_706
    rx296_cur."!cursor_debug"("FAIL", "outerctx")
  debug_706:
    .return (rx296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303430322.161") :method
.annotate 'line', 10
    new $P298, "ResizablePMCArray"
    push $P298, ""
    .return ($P298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx301_tgt
    .local int rx301_pos
    .local int rx301_off
    .local int rx301_eos
    .local int rx301_rep
    .local pmc rx301_cur
    .local pmc rx301_debug
    (rx301_cur, rx301_pos, rx301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx301_cur
    .local pmc match
    .lex "$/", match
    length rx301_eos, rx301_tgt
    gt rx301_pos, rx301_eos, rx301_done
    set rx301_off, 0
    lt rx301_pos, 2, rx301_start
    sub rx301_off, rx301_pos, 1
    substr rx301_tgt, rx301_tgt, rx301_off
  rx301_start:
    eq $I10, 1, rx301_restart
    if_null rx301_debug, debug_707
    rx301_cur."!cursor_debug"("START", "GLOBALish")
  debug_707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan304_done
    goto rxscan304_scan
  rxscan304_loop:
    (rx301_pos) = rx301_cur."from"()
    inc rx301_pos
    rx301_cur."!cursor_from"(rx301_pos)
    ge rx301_pos, rx301_eos, rxscan304_done
  rxscan304_scan:
    set_addr $I10, rxscan304_loop
    rx301_cur."!mark_push"(0, rx301_pos, $I10)
  rxscan304_done:
.annotate 'line', 188
  # rx pass
    rx301_cur."!cursor_pass"(rx301_pos, "GLOBALish")
    if_null rx301_debug, debug_708
    rx301_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx301_pos)
  debug_708:
    .return (rx301_cur)
  rx301_restart:
.annotate 'line', 10
    if_null rx301_debug, debug_709
    rx301_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_709:
  rx301_fail:
    (rx301_rep, rx301_pos, $I10, $P10) = rx301_cur."!mark_fail"(0)
    lt rx301_pos, -1, rx301_done
    eq rx301_pos, -1, rx301_fail
    jump $I10
  rx301_done:
    rx301_cur."!cursor_fail"()
    if_null rx301_debug, debug_710
    rx301_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_710:
    .return (rx301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303430322.161") :method
.annotate 'line', 10
    new $P303, "ResizablePMCArray"
    push $P303, ""
    .return ($P303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_711
    rx306_cur."!cursor_debug"("START", "finishpad")
  debug_711:
    $I10 = self.'from'()
    ne $I10, -1, rxscan309_done
    goto rxscan309_scan
  rxscan309_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan309_done
  rxscan309_scan:
    set_addr $I10, rxscan309_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan309_done:
.annotate 'line', 189
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "finishpad")
    if_null rx306_debug, debug_712
    rx306_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx306_pos)
  debug_712:
    .return (rx306_cur)
  rx306_restart:
.annotate 'line', 10
    if_null rx306_debug, debug_713
    rx306_cur."!cursor_debug"("NEXT", "finishpad")
  debug_713:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_714
    rx306_cur."!cursor_debug"("FAIL", "finishpad")
  debug_714:
    .return (rx306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303430322.161") :method
.annotate 'line', 10
    new $P308, "ResizablePMCArray"
    push $P308, ""
    .return ($P308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx311_tgt
    .local int rx311_pos
    .local int rx311_off
    .local int rx311_eos
    .local int rx311_rep
    .local pmc rx311_cur
    .local pmc rx311_debug
    (rx311_cur, rx311_pos, rx311_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx311_cur
    .local pmc match
    .lex "$/", match
    length rx311_eos, rx311_tgt
    gt rx311_pos, rx311_eos, rx311_done
    set rx311_off, 0
    lt rx311_pos, 2, rx311_start
    sub rx311_off, rx311_pos, 1
    substr rx311_tgt, rx311_tgt, rx311_off
  rx311_start:
    eq $I10, 1, rx311_restart
    if_null rx311_debug, debug_715
    rx311_cur."!cursor_debug"("START", "you_are_here")
  debug_715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan314_done
    goto rxscan314_scan
  rxscan314_loop:
    (rx311_pos) = rx311_cur."from"()
    inc rx311_pos
    rx311_cur."!cursor_from"(rx311_pos)
    ge rx311_pos, rx311_eos, rxscan314_done
  rxscan314_scan:
    set_addr $I10, rxscan314_loop
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  rxscan314_done:
.annotate 'line', 190
  # rx pass
    rx311_cur."!cursor_pass"(rx311_pos, "you_are_here")
    if_null rx311_debug, debug_716
    rx311_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx311_pos)
  debug_716:
    .return (rx311_cur)
  rx311_restart:
.annotate 'line', 10
    if_null rx311_debug, debug_717
    rx311_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_717:
  rx311_fail:
    (rx311_rep, rx311_pos, $I10, $P10) = rx311_cur."!mark_fail"(0)
    lt rx311_pos, -1, rx311_done
    eq rx311_pos, -1, rx311_fail
    jump $I10
  rx311_done:
    rx311_cur."!cursor_fail"()
    if_null rx311_debug, debug_718
    rx311_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_718:
    .return (rx311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303430322.161") :method
.annotate 'line', 10
    new $P313, "ResizablePMCArray"
    push $P313, ""
    .return ($P313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303430322.161")
    .param pmc param_316
.annotate 'line', 192
    .lex "self", param_316
    $P317 = param_316."!protoregex"("terminator")
    .return ($P317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303430322.161")
    .param pmc param_319
.annotate 'line', 192
    .lex "self", param_319
    $P320 = param_319."!PREFIX__!protoregex"("terminator")
    .return ($P320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx322_tgt
    .local int rx322_pos
    .local int rx322_off
    .local int rx322_eos
    .local int rx322_rep
    .local pmc rx322_cur
    .local pmc rx322_debug
    (rx322_cur, rx322_pos, rx322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx322_cur
    .local pmc match
    .lex "$/", match
    length rx322_eos, rx322_tgt
    gt rx322_pos, rx322_eos, rx322_done
    set rx322_off, 0
    lt rx322_pos, 2, rx322_start
    sub rx322_off, rx322_pos, 1
    substr rx322_tgt, rx322_tgt, rx322_off
  rx322_start:
    eq $I10, 1, rx322_restart
    if_null rx322_debug, debug_719
    rx322_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan325_done
    goto rxscan325_scan
  rxscan325_loop:
    (rx322_pos) = rx322_cur."from"()
    inc rx322_pos
    rx322_cur."!cursor_from"(rx322_pos)
    ge rx322_pos, rx322_eos, rxscan325_done
  rxscan325_scan:
    set_addr $I10, rxscan325_loop
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  rxscan325_done:
.annotate 'line', 194
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx322_fail
  # rx pass
    rx322_cur."!cursor_pass"(rx322_pos, "terminator:sym<;>")
    if_null rx322_debug, debug_720
    rx322_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx322_pos)
  debug_720:
    .return (rx322_cur)
  rx322_restart:
.annotate 'line', 10
    if_null rx322_debug, debug_721
    rx322_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_721:
  rx322_fail:
    (rx322_rep, rx322_pos, $I10, $P10) = rx322_cur."!mark_fail"(0)
    lt rx322_pos, -1, rx322_done
    eq rx322_pos, -1, rx322_fail
    jump $I10
  rx322_done:
    rx322_cur."!cursor_fail"()
    if_null rx322_debug, debug_722
    rx322_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_722:
    .return (rx322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303430322.161") :method
.annotate 'line', 10
    new $P324, "ResizablePMCArray"
    push $P324, ";"
    .return ($P324)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx327_tgt
    .local int rx327_pos
    .local int rx327_off
    .local int rx327_eos
    .local int rx327_rep
    .local pmc rx327_cur
    .local pmc rx327_debug
    (rx327_cur, rx327_pos, rx327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx327_cur
    .local pmc match
    .lex "$/", match
    length rx327_eos, rx327_tgt
    gt rx327_pos, rx327_eos, rx327_done
    set rx327_off, 0
    lt rx327_pos, 2, rx327_start
    sub rx327_off, rx327_pos, 1
    substr rx327_tgt, rx327_tgt, rx327_off
  rx327_start:
    eq $I10, 1, rx327_restart
    if_null rx327_debug, debug_723
    rx327_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan330_done
    goto rxscan330_scan
  rxscan330_loop:
    (rx327_pos) = rx327_cur."from"()
    inc rx327_pos
    rx327_cur."!cursor_from"(rx327_pos)
    ge rx327_pos, rx327_eos, rxscan330_done
  rxscan330_scan:
    set_addr $I10, rxscan330_loop
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxscan330_done:
.annotate 'line', 195
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx327_fail
  # rx pass
    rx327_cur."!cursor_pass"(rx327_pos, "terminator:sym<}>")
    if_null rx327_debug, debug_724
    rx327_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx327_pos)
  debug_724:
    .return (rx327_cur)
  rx327_restart:
.annotate 'line', 10
    if_null rx327_debug, debug_725
    rx327_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_725:
  rx327_fail:
    (rx327_rep, rx327_pos, $I10, $P10) = rx327_cur."!mark_fail"(0)
    lt rx327_pos, -1, rx327_done
    eq rx327_pos, -1, rx327_fail
    jump $I10
  rx327_done:
    rx327_cur."!cursor_fail"()
    if_null rx327_debug, debug_726
    rx327_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_726:
    .return (rx327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303430322.161") :method
.annotate 'line', 10
    new $P329, "ResizablePMCArray"
    push $P329, "}"
    .return ($P329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303430322.161")
    .param pmc param_332
.annotate 'line', 199
    .lex "self", param_332
    $P333 = param_332."!protoregex"("statement_control")
    .return ($P333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303430322.161")
    .param pmc param_335
.annotate 'line', 199
    .lex "self", param_335
    $P336 = param_335."!PREFIX__!protoregex"("statement_control")
    .return ($P336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx338_tgt
    .local int rx338_pos
    .local int rx338_off
    .local int rx338_eos
    .local int rx338_rep
    .local pmc rx338_cur
    .local pmc rx338_debug
    (rx338_cur, rx338_pos, rx338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx338_cur
    .local pmc match
    .lex "$/", match
    length rx338_eos, rx338_tgt
    gt rx338_pos, rx338_eos, rx338_done
    set rx338_off, 0
    lt rx338_pos, 2, rx338_start
    sub rx338_off, rx338_pos, 1
    substr rx338_tgt, rx338_tgt, rx338_off
  rx338_start:
    eq $I10, 1, rx338_restart
    if_null rx338_debug, debug_727
    rx338_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan341_done
    goto rxscan341_scan
  rxscan341_loop:
    (rx338_pos) = rx338_cur."from"()
    inc rx338_pos
    rx338_cur."!cursor_from"(rx338_pos)
    ge rx338_pos, rx338_eos, rxscan341_done
  rxscan341_scan:
    set_addr $I10, rxscan341_loop
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  rxscan341_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_342_fail
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  # rx literal  "use"
    add $I11, rx338_pos, 3
    gt $I11, rx338_eos, rx338_fail
    sub $I11, rx338_pos, rx338_off
    substr $S10, rx338_tgt, $I11, 3
    ne $S10, "use", rx338_fail
    add rx338_pos, 3
    set_addr $I10, rxcap_342_fail
    ($I12, $I11) = rx338_cur."!mark_peek"($I10)
    rx338_cur."!cursor_pos"($I11)
    ($P10) = rx338_cur."!cursor_start"()
    $P10."!cursor_pass"(rx338_pos, "")
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_342_done
  rxcap_342_fail:
    goto rx338_fail
  rxcap_342_done:
  # rx charclass s
    ge rx338_pos, rx338_eos, rx338_fail
    sub $I10, rx338_pos, rx338_off
    is_cclass $I11, 32, rx338_tgt, $I10
    unless $I11, rx338_fail
    inc rx338_pos
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."name"()
    unless $P10, rx338_fail
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx338_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx338_cur."!cursor_pass"(rx338_pos, "statement_control:sym<use>")
    if_null rx338_debug, debug_728
    rx338_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx338_pos)
  debug_728:
    .return (rx338_cur)
  rx338_restart:
.annotate 'line', 10
    if_null rx338_debug, debug_729
    rx338_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_729:
  rx338_fail:
    (rx338_rep, rx338_pos, $I10, $P10) = rx338_cur."!mark_fail"(0)
    lt rx338_pos, -1, rx338_done
    eq rx338_pos, -1, rx338_fail
    jump $I10
  rx338_done:
    rx338_cur."!cursor_fail"()
    if_null rx338_debug, debug_730
    rx338_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_730:
    .return (rx338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303430322.161") :method
.annotate 'line', 10
    new $P340, "ResizablePMCArray"
    push $P340, "use"
    .return ($P340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx346_tgt
    .local int rx346_pos
    .local int rx346_off
    .local int rx346_eos
    .local int rx346_rep
    .local pmc rx346_cur
    .local pmc rx346_debug
    (rx346_cur, rx346_pos, rx346_tgt, $I10) = self."!cursor_start"()
    rx346_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx346_cur
    .local pmc match
    .lex "$/", match
    length rx346_eos, rx346_tgt
    gt rx346_pos, rx346_eos, rx346_done
    set rx346_off, 0
    lt rx346_pos, 2, rx346_start
    sub rx346_off, rx346_pos, 1
    substr rx346_tgt, rx346_tgt, rx346_off
  rx346_start:
    eq $I10, 1, rx346_restart
    if_null rx346_debug, debug_731
    rx346_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_731:
    $I10 = self.'from'()
    ne $I10, -1, rxscan349_done
    goto rxscan349_scan
  rxscan349_loop:
    (rx346_pos) = rx346_cur."from"()
    inc rx346_pos
    rx346_cur."!cursor_from"(rx346_pos)
    ge rx346_pos, rx346_eos, rxscan349_done
  rxscan349_scan:
    set_addr $I10, rxscan349_loop
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxscan349_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_350_fail
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  # rx literal  "if"
    add $I11, rx346_pos, 2
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 2
    ne $S10, "if", rx346_fail
    add rx346_pos, 2
    set_addr $I10, rxcap_350_fail
    ($I12, $I11) = rx346_cur."!mark_peek"($I10)
    rx346_cur."!cursor_pos"($I11)
    ($P10) = rx346_cur."!cursor_start"()
    $P10."!cursor_pass"(rx346_pos, "")
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_350_done
  rxcap_350_fail:
    goto rx346_fail
  rxcap_350_done:
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."xblock"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 208
  # rx rxquantr353 ** 0..*
    set_addr $I10, rxquantr353_done
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxquantr353_loop:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx346_pos, 5
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 5
    ne $S10, "elsif", rx346_fail
    add rx346_pos, 5
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."xblock"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
    set_addr $I10, rxquantr353_done
    (rx346_rep) = rx346_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr353_done
    rx346_cur."!mark_push"(rx346_rep, rx346_pos, $I10)
    goto rxquantr353_loop
  rxquantr353_done:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 209
  # rx rxquantr358 ** 0..1
    set_addr $I10, rxquantr358_done
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxquantr358_loop:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx346_pos, 4
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 4
    ne $S10, "else", rx346_fail
    add rx346_pos, 4
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."pblock"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
    set_addr $I10, rxquantr358_done
    (rx346_rep) = rx346_cur."!mark_commit"($I10)
  rxquantr358_done:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx346_cur."!cursor_pass"(rx346_pos, "statement_control:sym<if>")
    if_null rx346_debug, debug_732
    rx346_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx346_pos)
  debug_732:
    .return (rx346_cur)
  rx346_restart:
.annotate 'line', 10
    if_null rx346_debug, debug_733
    rx346_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_733:
  rx346_fail:
    (rx346_rep, rx346_pos, $I10, $P10) = rx346_cur."!mark_fail"(0)
    lt rx346_pos, -1, rx346_done
    eq rx346_pos, -1, rx346_fail
    jump $I10
  rx346_done:
    rx346_cur."!cursor_fail"()
    if_null rx346_debug, debug_734
    rx346_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_734:
    .return (rx346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303430322.161") :method
.annotate 'line', 10
    new $P348, "ResizablePMCArray"
    push $P348, "if"
    .return ($P348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P374 = "73_1303430322.161" 
    capture_lex $P374
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_735
    rx364_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_735:
    $I10 = self.'from'()
    ne $I10, -1, rxscan367_done
    goto rxscan367_scan
  rxscan367_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan367_done
  rxscan367_scan:
    set_addr $I10, rxscan367_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan367_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_368_fail
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx literal  "unless"
    add $I11, rx364_pos, 6
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    substr $S10, rx364_tgt, $I11, 6
    ne $S10, "unless", rx364_fail
    add rx364_pos, 6
    set_addr $I10, rxcap_368_fail
    ($I12, $I11) = rx364_cur."!mark_peek"($I10)
    rx364_cur."!cursor_pos"($I11)
    ($P10) = rx364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx364_pos, "")
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_368_done
  rxcap_368_fail:
    goto rx364_fail
  rxcap_368_done:
  # rx charclass s
    ge rx364_pos, rx364_eos, rx364_fail
    sub $I10, rx364_pos, rx364_off
    is_cclass $I11, 32, rx364_tgt, $I10
    unless $I11, rx364_fail
    inc rx364_pos
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."xblock"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  alt371_0:
.annotate 'line', 215
    set_addr $I10, alt371_1
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx364_cur."!cursor_pos"(rx364_pos)
    .const 'Sub' $P374 = "73_1303430322.161" 
    capture_lex $P374
    $P10 = rx364_cur."before"($P374)
    if $P10, rx364_fail
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
    goto alt371_end
  alt371_1:
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  alt371_end:
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "statement_control:sym<unless>")
    if_null rx364_debug, debug_740
    rx364_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx364_pos)
  debug_740:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 10
    if_null rx364_debug, debug_741
    rx364_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_741:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_742
    rx364_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_742:
    .return (rx364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303430322.161") :method
.annotate 'line', 10
    new $P366, "ResizablePMCArray"
    push $P366, "unless"
    .return ($P366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block373"  :anon :subid("73_1303430322.161") :method :outer("71_1303430322.161")
.annotate 'line', 215
    .local string rx375_tgt
    .local int rx375_pos
    .local int rx375_off
    .local int rx375_eos
    .local int rx375_rep
    .local pmc rx375_cur
    .local pmc rx375_debug
    (rx375_cur, rx375_pos, rx375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx375_cur
    .local pmc match
    .lex "$/", match
    length rx375_eos, rx375_tgt
    gt rx375_pos, rx375_eos, rx375_done
    set rx375_off, 0
    lt rx375_pos, 2, rx375_start
    sub rx375_off, rx375_pos, 1
    substr rx375_tgt, rx375_tgt, rx375_off
  rx375_start:
    eq $I10, 1, rx375_restart
    if_null rx375_debug, debug_736
    rx375_cur."!cursor_debug"("START", "")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan376_done
    goto rxscan376_scan
  rxscan376_loop:
    (rx375_pos) = rx375_cur."from"()
    inc rx375_pos
    rx375_cur."!cursor_from"(rx375_pos)
    ge rx375_pos, rx375_eos, rxscan376_done
  rxscan376_scan:
    set_addr $I10, rxscan376_loop
    rx375_cur."!mark_push"(0, rx375_pos, $I10)
  rxscan376_done:
  # rx literal  "else"
    add $I11, rx375_pos, 4
    gt $I11, rx375_eos, rx375_fail
    sub $I11, rx375_pos, rx375_off
    substr $S10, rx375_tgt, $I11, 4
    ne $S10, "else", rx375_fail
    add rx375_pos, 4
  # rx pass
    rx375_cur."!cursor_pass"(rx375_pos, "")
    if_null rx375_debug, debug_737
    rx375_cur."!cursor_debug"("PASS", "", " at pos=", rx375_pos)
  debug_737:
    .return (rx375_cur)
  rx375_restart:
    if_null rx375_debug, debug_738
    rx375_cur."!cursor_debug"("NEXT", "")
  debug_738:
  rx375_fail:
    (rx375_rep, rx375_pos, $I10, $P10) = rx375_cur."!mark_fail"(0)
    lt rx375_pos, -1, rx375_done
    eq rx375_pos, -1, rx375_fail
    jump $I10
  rx375_done:
    rx375_cur."!cursor_fail"()
    if_null rx375_debug, debug_739
    rx375_cur."!cursor_debug"("FAIL", "")
  debug_739:
    .return (rx375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx382_tgt
    .local int rx382_pos
    .local int rx382_off
    .local int rx382_eos
    .local int rx382_rep
    .local pmc rx382_cur
    .local pmc rx382_debug
    (rx382_cur, rx382_pos, rx382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx382_cur
    .local pmc match
    .lex "$/", match
    length rx382_eos, rx382_tgt
    gt rx382_pos, rx382_eos, rx382_done
    set rx382_off, 0
    lt rx382_pos, 2, rx382_start
    sub rx382_off, rx382_pos, 1
    substr rx382_tgt, rx382_tgt, rx382_off
  rx382_start:
    eq $I10, 1, rx382_restart
    if_null rx382_debug, debug_743
    rx382_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan385_done
    goto rxscan385_scan
  rxscan385_loop:
    (rx382_pos) = rx382_cur."from"()
    inc rx382_pos
    rx382_cur."!cursor_from"(rx382_pos)
    ge rx382_pos, rx382_eos, rxscan385_done
  rxscan385_scan:
    set_addr $I10, rxscan385_loop
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  rxscan385_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_387_fail
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  alt386_0:
    set_addr $I10, alt386_1
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  # rx literal  "while"
    add $I11, rx382_pos, 5
    gt $I11, rx382_eos, rx382_fail
    sub $I11, rx382_pos, rx382_off
    substr $S10, rx382_tgt, $I11, 5
    ne $S10, "while", rx382_fail
    add rx382_pos, 5
    goto alt386_end
  alt386_1:
  # rx literal  "until"
    add $I11, rx382_pos, 5
    gt $I11, rx382_eos, rx382_fail
    sub $I11, rx382_pos, rx382_off
    substr $S10, rx382_tgt, $I11, 5
    ne $S10, "until", rx382_fail
    add rx382_pos, 5
  alt386_end:
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx382_cur."!mark_peek"($I10)
    rx382_cur."!cursor_pos"($I11)
    ($P10) = rx382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx382_pos, "")
    rx382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx382_fail
  rxcap_387_done:
  # rx charclass s
    ge rx382_pos, rx382_eos, rx382_fail
    sub $I10, rx382_pos, rx382_off
    is_cclass $I11, 32, rx382_tgt, $I10
    unless $I11, rx382_fail
    inc rx382_pos
  # rx subrule "ws" subtype=method negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."ws"()
    unless $P10, rx382_fail
    rx382_pos = $P10."pos"()
.annotate 'line', 220
  # rx subrule "xblock" subtype=capture negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."xblock"()
    unless $P10, rx382_fail
    rx382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx382_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."ws"()
    unless $P10, rx382_fail
    rx382_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx382_cur."!cursor_pass"(rx382_pos, "statement_control:sym<while>")
    if_null rx382_debug, debug_744
    rx382_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx382_pos)
  debug_744:
    .return (rx382_cur)
  rx382_restart:
.annotate 'line', 10
    if_null rx382_debug, debug_745
    rx382_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_745:
  rx382_fail:
    (rx382_rep, rx382_pos, $I10, $P10) = rx382_cur."!mark_fail"(0)
    lt rx382_pos, -1, rx382_done
    eq rx382_pos, -1, rx382_fail
    jump $I10
  rx382_done:
    rx382_cur."!cursor_fail"()
    if_null rx382_debug, debug_746
    rx382_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_746:
    .return (rx382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303430322.161") :method
.annotate 'line', 10
    new $P384, "ResizablePMCArray"
    push $P384, "until"
    push $P384, "while"
    .return ($P384)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx391_tgt
    .local int rx391_pos
    .local int rx391_off
    .local int rx391_eos
    .local int rx391_rep
    .local pmc rx391_cur
    .local pmc rx391_debug
    (rx391_cur, rx391_pos, rx391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx391_cur
    .local pmc match
    .lex "$/", match
    length rx391_eos, rx391_tgt
    gt rx391_pos, rx391_eos, rx391_done
    set rx391_off, 0
    lt rx391_pos, 2, rx391_start
    sub rx391_off, rx391_pos, 1
    substr rx391_tgt, rx391_tgt, rx391_off
  rx391_start:
    eq $I10, 1, rx391_restart
    if_null rx391_debug, debug_747
    rx391_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_747:
    $I10 = self.'from'()
    ne $I10, -1, rxscan394_done
    goto rxscan394_scan
  rxscan394_loop:
    (rx391_pos) = rx391_cur."from"()
    inc rx391_pos
    rx391_cur."!cursor_from"(rx391_pos)
    ge rx391_pos, rx391_eos, rxscan394_done
  rxscan394_scan:
    set_addr $I10, rxscan394_loop
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  rxscan394_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_395_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx391_pos, 6
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 6
    ne $S10, "repeat", rx391_fail
    add rx391_pos, 6
    set_addr $I10, rxcap_395_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_395_done
  rxcap_395_fail:
    goto rx391_fail
  rxcap_395_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  alt397_0:
.annotate 'line', 225
    set_addr $I10, alt397_1
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
.annotate 'line', 226
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_400_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  alt399_0:
    set_addr $I10, alt399_1
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "while"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "while", rx391_fail
    add rx391_pos, 5
    goto alt399_end
  alt399_1:
  # rx literal  "until"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "until", rx391_fail
    add rx391_pos, 5
  alt399_end:
    set_addr $I10, rxcap_400_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_400_done
  rxcap_400_fail:
    goto rx391_fail
  rxcap_400_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."xblock"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
    goto alt397_end
  alt397_1:
.annotate 'line', 227
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."pblock"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_406_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  alt405_0:
    set_addr $I10, alt405_1
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "while"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "while", rx391_fail
    add rx391_pos, 5
    goto alt405_end
  alt405_1:
  # rx literal  "until"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "until", rx391_fail
    add rx391_pos, 5
  alt405_end:
    set_addr $I10, rxcap_406_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_406_done
  rxcap_406_fail:
    goto rx391_fail
  rxcap_406_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."EXPR"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  alt397_end:
.annotate 'line', 228
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx391_cur."!cursor_pass"(rx391_pos, "statement_control:sym<repeat>")
    if_null rx391_debug, debug_748
    rx391_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx391_pos)
  debug_748:
    .return (rx391_cur)
  rx391_restart:
.annotate 'line', 10
    if_null rx391_debug, debug_749
    rx391_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_749:
  rx391_fail:
    (rx391_rep, rx391_pos, $I10, $P10) = rx391_cur."!mark_fail"(0)
    lt rx391_pos, -1, rx391_done
    eq rx391_pos, -1, rx391_fail
    jump $I10
  rx391_done:
    rx391_cur."!cursor_fail"()
    if_null rx391_debug, debug_750
    rx391_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_750:
    .return (rx391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303430322.161") :method
.annotate 'line', 10
    new $P393, "ResizablePMCArray"
    push $P393, "repeat"
    .return ($P393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx411_tgt
    .local int rx411_pos
    .local int rx411_off
    .local int rx411_eos
    .local int rx411_rep
    .local pmc rx411_cur
    .local pmc rx411_debug
    (rx411_cur, rx411_pos, rx411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx411_cur
    .local pmc match
    .lex "$/", match
    length rx411_eos, rx411_tgt
    gt rx411_pos, rx411_eos, rx411_done
    set rx411_off, 0
    lt rx411_pos, 2, rx411_start
    sub rx411_off, rx411_pos, 1
    substr rx411_tgt, rx411_tgt, rx411_off
  rx411_start:
    eq $I10, 1, rx411_restart
    if_null rx411_debug, debug_751
    rx411_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan414_done
    goto rxscan414_scan
  rxscan414_loop:
    (rx411_pos) = rx411_cur."from"()
    inc rx411_pos
    rx411_cur."!cursor_from"(rx411_pos)
    ge rx411_pos, rx411_eos, rxscan414_done
  rxscan414_scan:
    set_addr $I10, rxscan414_loop
    rx411_cur."!mark_push"(0, rx411_pos, $I10)
  rxscan414_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_415_fail
    rx411_cur."!mark_push"(0, rx411_pos, $I10)
  # rx literal  "for"
    add $I11, rx411_pos, 3
    gt $I11, rx411_eos, rx411_fail
    sub $I11, rx411_pos, rx411_off
    substr $S10, rx411_tgt, $I11, 3
    ne $S10, "for", rx411_fail
    add rx411_pos, 3
    set_addr $I10, rxcap_415_fail
    ($I12, $I11) = rx411_cur."!mark_peek"($I10)
    rx411_cur."!cursor_pos"($I11)
    ($P10) = rx411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx411_pos, "")
    rx411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_415_done
  rxcap_415_fail:
    goto rx411_fail
  rxcap_415_done:
  # rx charclass s
    ge rx411_pos, rx411_eos, rx411_fail
    sub $I10, rx411_pos, rx411_off
    is_cclass $I11, 32, rx411_tgt, $I10
    unless $I11, rx411_fail
    inc rx411_pos
  # rx subrule "ws" subtype=method negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."ws"()
    unless $P10, rx411_fail
    rx411_pos = $P10."pos"()
.annotate 'line', 233
  # rx subrule "xblock" subtype=capture negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."xblock"()
    unless $P10, rx411_fail
    rx411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx411_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."ws"()
    unless $P10, rx411_fail
    rx411_pos = $P10."pos"()
.annotate 'line', 231
  # rx pass
    rx411_cur."!cursor_pass"(rx411_pos, "statement_control:sym<for>")
    if_null rx411_debug, debug_752
    rx411_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx411_pos)
  debug_752:
    .return (rx411_cur)
  rx411_restart:
.annotate 'line', 10
    if_null rx411_debug, debug_753
    rx411_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_753:
  rx411_fail:
    (rx411_rep, rx411_pos, $I10, $P10) = rx411_cur."!mark_fail"(0)
    lt rx411_pos, -1, rx411_done
    eq rx411_pos, -1, rx411_fail
    jump $I10
  rx411_done:
    rx411_cur."!cursor_fail"()
    if_null rx411_debug, debug_754
    rx411_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_754:
    .return (rx411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303430322.161") :method
.annotate 'line', 10
    new $P413, "ResizablePMCArray"
    push $P413, "for"
    .return ($P413)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx419_tgt
    .local int rx419_pos
    .local int rx419_off
    .local int rx419_eos
    .local int rx419_rep
    .local pmc rx419_cur
    .local pmc rx419_debug
    (rx419_cur, rx419_pos, rx419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx419_cur
    .local pmc match
    .lex "$/", match
    length rx419_eos, rx419_tgt
    gt rx419_pos, rx419_eos, rx419_done
    set rx419_off, 0
    lt rx419_pos, 2, rx419_start
    sub rx419_off, rx419_pos, 1
    substr rx419_tgt, rx419_tgt, rx419_off
  rx419_start:
    eq $I10, 1, rx419_restart
    if_null rx419_debug, debug_755
    rx419_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan422_done
    goto rxscan422_scan
  rxscan422_loop:
    (rx419_pos) = rx419_cur."from"()
    inc rx419_pos
    rx419_cur."!cursor_from"(rx419_pos)
    ge rx419_pos, rx419_eos, rxscan422_done
  rxscan422_scan:
    set_addr $I10, rxscan422_loop
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  rxscan422_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_423_fail
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx419_pos, 5
    gt $I11, rx419_eos, rx419_fail
    sub $I11, rx419_pos, rx419_off
    substr $S10, rx419_tgt, $I11, 5
    ne $S10, "CATCH", rx419_fail
    add rx419_pos, 5
    set_addr $I10, rxcap_423_fail
    ($I12, $I11) = rx419_cur."!mark_peek"($I10)
    rx419_cur."!cursor_pos"($I11)
    ($P10) = rx419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx419_pos, "")
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_423_done
  rxcap_423_fail:
    goto rx419_fail
  rxcap_423_done:
  # rx charclass s
    ge rx419_pos, rx419_eos, rx419_fail
    sub $I10, rx419_pos, rx419_off
    is_cclass $I11, 32, rx419_tgt, $I10
    unless $I11, rx419_fail
    inc rx419_pos
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
.annotate 'line', 238
  # rx subrule "block" subtype=capture negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."block"()
    unless $P10, rx419_fail
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx419_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
.annotate 'line', 236
  # rx pass
    rx419_cur."!cursor_pass"(rx419_pos, "statement_control:sym<CATCH>")
    if_null rx419_debug, debug_756
    rx419_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx419_pos)
  debug_756:
    .return (rx419_cur)
  rx419_restart:
.annotate 'line', 10
    if_null rx419_debug, debug_757
    rx419_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_757:
  rx419_fail:
    (rx419_rep, rx419_pos, $I10, $P10) = rx419_cur."!mark_fail"(0)
    lt rx419_pos, -1, rx419_done
    eq rx419_pos, -1, rx419_fail
    jump $I10
  rx419_done:
    rx419_cur."!cursor_fail"()
    if_null rx419_debug, debug_758
    rx419_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_758:
    .return (rx419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303430322.161") :method
.annotate 'line', 10
    new $P421, "ResizablePMCArray"
    push $P421, "CATCH"
    .return ($P421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_759
    rx427_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan430_done
    goto rxscan430_scan
  rxscan430_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan430_done
  rxscan430_scan:
    set_addr $I10, rxscan430_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan430_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_431_fail
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx427_pos, 7
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 7
    ne $S10, "CONTROL", rx427_fail
    add rx427_pos, 7
    set_addr $I10, rxcap_431_fail
    ($I12, $I11) = rx427_cur."!mark_peek"($I10)
    rx427_cur."!cursor_pos"($I11)
    ($P10) = rx427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx427_pos, "")
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_431_done
  rxcap_431_fail:
    goto rx427_fail
  rxcap_431_done:
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 243
  # rx subrule "block" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."block"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 241
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "statement_control:sym<CONTROL>")
    if_null rx427_debug, debug_760
    rx427_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx427_pos)
  debug_760:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_761
    rx427_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_761:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_762
    rx427_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_762:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303430322.161") :method
.annotate 'line', 10
    new $P429, "ResizablePMCArray"
    push $P429, "CONTROL"
    .return ($P429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303430322.161")
    .param pmc param_435
.annotate 'line', 246
    .lex "self", param_435
    $P436 = param_435."!protoregex"("statement_prefix")
    .return ($P436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303430322.161")
    .param pmc param_438
.annotate 'line', 246
    .lex "self", param_438
    $P439 = param_438."!PREFIX__!protoregex"("statement_prefix")
    .return ($P439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx441_tgt
    .local int rx441_pos
    .local int rx441_off
    .local int rx441_eos
    .local int rx441_rep
    .local pmc rx441_cur
    .local pmc rx441_debug
    (rx441_cur, rx441_pos, rx441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx441_cur
    .local pmc match
    .lex "$/", match
    length rx441_eos, rx441_tgt
    gt rx441_pos, rx441_eos, rx441_done
    set rx441_off, 0
    lt rx441_pos, 2, rx441_start
    sub rx441_off, rx441_pos, 1
    substr rx441_tgt, rx441_tgt, rx441_off
  rx441_start:
    eq $I10, 1, rx441_restart
    if_null rx441_debug, debug_763
    rx441_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan445_done
    goto rxscan445_scan
  rxscan445_loop:
    (rx441_pos) = rx441_cur."from"()
    inc rx441_pos
    rx441_cur."!cursor_from"(rx441_pos)
    ge rx441_pos, rx441_eos, rxscan445_done
  rxscan445_scan:
    set_addr $I10, rxscan445_loop
    rx441_cur."!mark_push"(0, rx441_pos, $I10)
  rxscan445_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_446_fail
    rx441_cur."!mark_push"(0, rx441_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx441_pos, 4
    gt $I11, rx441_eos, rx441_fail
    sub $I11, rx441_pos, rx441_off
    substr $S10, rx441_tgt, $I11, 4
    ne $S10, "INIT", rx441_fail
    add rx441_pos, 4
    set_addr $I10, rxcap_446_fail
    ($I12, $I11) = rx441_cur."!mark_peek"($I10)
    rx441_cur."!cursor_pos"($I11)
    ($P10) = rx441_cur."!cursor_start"()
    $P10."!cursor_pass"(rx441_pos, "")
    rx441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_446_done
  rxcap_446_fail:
    goto rx441_fail
  rxcap_446_done:
  # rx subrule "blorst" subtype=capture negate=
    rx441_cur."!cursor_pos"(rx441_pos)
    $P10 = rx441_cur."blorst"()
    unless $P10, rx441_fail
    rx441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx441_pos = $P10."pos"()
  # rx pass
    rx441_cur."!cursor_pass"(rx441_pos, "statement_prefix:sym<INIT>")
    if_null rx441_debug, debug_764
    rx441_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx441_pos)
  debug_764:
    .return (rx441_cur)
  rx441_restart:
.annotate 'line', 10
    if_null rx441_debug, debug_765
    rx441_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_765:
  rx441_fail:
    (rx441_rep, rx441_pos, $I10, $P10) = rx441_cur."!mark_fail"(0)
    lt rx441_pos, -1, rx441_done
    eq rx441_pos, -1, rx441_fail
    jump $I10
  rx441_done:
    rx441_cur."!cursor_fail"()
    if_null rx441_debug, debug_766
    rx441_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_766:
    .return (rx441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303430322.161") :method
.annotate 'line', 10
    $P443 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P444, "ResizablePMCArray"
    push $P444, $P443
    .return ($P444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_767
    rx448_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_767:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "try"
    add $I11, rx448_pos, 3
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 3
    ne $S10, "try", rx448_fail
    add rx448_pos, 3
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
.annotate 'line', 251
  # rx subrule "blorst" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."blorst"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx448_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_prefix:sym<try>")
    if_null rx448_debug, debug_768
    rx448_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx448_pos)
  debug_768:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 10
    if_null rx448_debug, debug_769
    rx448_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_769:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_770
    rx448_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_770:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303430322.161") :method
.annotate 'line', 10
    $P450 = self."!PREFIX__!subrule"("blorst", "try")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx455_tgt
    .local int rx455_pos
    .local int rx455_off
    .local int rx455_eos
    .local int rx455_rep
    .local pmc rx455_cur
    .local pmc rx455_debug
    (rx455_cur, rx455_pos, rx455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx455_cur
    .local pmc match
    .lex "$/", match
    length rx455_eos, rx455_tgt
    gt rx455_pos, rx455_eos, rx455_done
    set rx455_off, 0
    lt rx455_pos, 2, rx455_start
    sub rx455_off, rx455_pos, 1
    substr rx455_tgt, rx455_tgt, rx455_off
  rx455_start:
    eq $I10, 1, rx455_restart
    if_null rx455_debug, debug_771
    rx455_cur."!cursor_debug"("START", "blorst")
  debug_771:
    $I10 = self.'from'()
    ne $I10, -1, rxscan458_done
    goto rxscan458_scan
  rxscan458_loop:
    (rx455_pos) = rx455_cur."from"()
    inc rx455_pos
    rx455_cur."!cursor_from"(rx455_pos)
    ge rx455_pos, rx455_eos, rxscan458_done
  rxscan458_scan:
    set_addr $I10, rxscan458_loop
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  rxscan458_done:
.annotate 'line', 255
  # rx charclass s
    ge rx455_pos, rx455_eos, rx455_fail
    sub $I10, rx455_pos, rx455_off
    is_cclass $I11, 32, rx455_tgt, $I10
    unless $I11, rx455_fail
    inc rx455_pos
  # rx subrule "ws" subtype=method negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."ws"()
    unless $P10, rx455_fail
    rx455_pos = $P10."pos"()
  alt459_0:
    set_addr $I10, alt459_1
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx455_pos, rx455_off
    substr $S10, rx455_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx455_fail
  # rx subrule "block" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."block"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx455_pos = $P10."pos"()
    goto alt459_end
  alt459_1:
  # rx subrule "statement" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."statement"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx455_pos = $P10."pos"()
  alt459_end:
.annotate 'line', 254
  # rx pass
    rx455_cur."!cursor_pass"(rx455_pos, "blorst")
    if_null rx455_debug, debug_772
    rx455_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx455_pos)
  debug_772:
    .return (rx455_cur)
  rx455_restart:
.annotate 'line', 10
    if_null rx455_debug, debug_773
    rx455_cur."!cursor_debug"("NEXT", "blorst")
  debug_773:
  rx455_fail:
    (rx455_rep, rx455_pos, $I10, $P10) = rx455_cur."!mark_fail"(0)
    lt rx455_pos, -1, rx455_done
    eq rx455_pos, -1, rx455_fail
    jump $I10
  rx455_done:
    rx455_cur."!cursor_fail"()
    if_null rx455_debug, debug_774
    rx455_cur."!cursor_debug"("FAIL", "blorst")
  debug_774:
    .return (rx455_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303430322.161") :method
.annotate 'line', 10
    new $P457, "ResizablePMCArray"
    push $P457, ""
    .return ($P457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303430322.161")
    .param pmc param_461
.annotate 'line', 260
    .lex "self", param_461
    $P462 = param_461."!protoregex"("statement_mod_cond")
    .return ($P462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303430322.161")
    .param pmc param_464
.annotate 'line', 260
    .lex "self", param_464
    $P465 = param_464."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P465)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx467_tgt
    .local int rx467_pos
    .local int rx467_off
    .local int rx467_eos
    .local int rx467_rep
    .local pmc rx467_cur
    .local pmc rx467_debug
    (rx467_cur, rx467_pos, rx467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx467_cur
    .local pmc match
    .lex "$/", match
    length rx467_eos, rx467_tgt
    gt rx467_pos, rx467_eos, rx467_done
    set rx467_off, 0
    lt rx467_pos, 2, rx467_start
    sub rx467_off, rx467_pos, 1
    substr rx467_tgt, rx467_tgt, rx467_off
  rx467_start:
    eq $I10, 1, rx467_restart
    if_null rx467_debug, debug_775
    rx467_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan471_done
    goto rxscan471_scan
  rxscan471_loop:
    (rx467_pos) = rx467_cur."from"()
    inc rx467_pos
    rx467_cur."!cursor_from"(rx467_pos)
    ge rx467_pos, rx467_eos, rxscan471_done
  rxscan471_scan:
    set_addr $I10, rxscan471_loop
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  rxscan471_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_472_fail
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  # rx literal  "if"
    add $I11, rx467_pos, 2
    gt $I11, rx467_eos, rx467_fail
    sub $I11, rx467_pos, rx467_off
    substr $S10, rx467_tgt, $I11, 2
    ne $S10, "if", rx467_fail
    add rx467_pos, 2
    set_addr $I10, rxcap_472_fail
    ($I12, $I11) = rx467_cur."!mark_peek"($I10)
    rx467_cur."!cursor_pos"($I11)
    ($P10) = rx467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx467_pos, "")
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_472_done
  rxcap_472_fail:
    goto rx467_fail
  rxcap_472_done:
  # rx subrule "ws" subtype=method negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."ws"()
    unless $P10, rx467_fail
    rx467_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."EXPR"()
    unless $P10, rx467_fail
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx467_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."ws"()
    unless $P10, rx467_fail
    rx467_pos = $P10."pos"()
  # rx pass
    rx467_cur."!cursor_pass"(rx467_pos, "statement_mod_cond:sym<if>")
    if_null rx467_debug, debug_776
    rx467_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx467_pos)
  debug_776:
    .return (rx467_cur)
  rx467_restart:
.annotate 'line', 10
    if_null rx467_debug, debug_777
    rx467_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_777:
  rx467_fail:
    (rx467_rep, rx467_pos, $I10, $P10) = rx467_cur."!mark_fail"(0)
    lt rx467_pos, -1, rx467_done
    eq rx467_pos, -1, rx467_fail
    jump $I10
  rx467_done:
    rx467_cur."!cursor_fail"()
    if_null rx467_debug, debug_778
    rx467_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_778:
    .return (rx467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303430322.161") :method
.annotate 'line', 10
    $P469 = self."!PREFIX__!subrule"("ws", "if")
    new $P470, "ResizablePMCArray"
    push $P470, $P469
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx476_tgt
    .local int rx476_pos
    .local int rx476_off
    .local int rx476_eos
    .local int rx476_rep
    .local pmc rx476_cur
    .local pmc rx476_debug
    (rx476_cur, rx476_pos, rx476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx476_cur
    .local pmc match
    .lex "$/", match
    length rx476_eos, rx476_tgt
    gt rx476_pos, rx476_eos, rx476_done
    set rx476_off, 0
    lt rx476_pos, 2, rx476_start
    sub rx476_off, rx476_pos, 1
    substr rx476_tgt, rx476_tgt, rx476_off
  rx476_start:
    eq $I10, 1, rx476_restart
    if_null rx476_debug, debug_779
    rx476_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan480_done
    goto rxscan480_scan
  rxscan480_loop:
    (rx476_pos) = rx476_cur."from"()
    inc rx476_pos
    rx476_cur."!cursor_from"(rx476_pos)
    ge rx476_pos, rx476_eos, rxscan480_done
  rxscan480_scan:
    set_addr $I10, rxscan480_loop
    rx476_cur."!mark_push"(0, rx476_pos, $I10)
  rxscan480_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_481_fail
    rx476_cur."!mark_push"(0, rx476_pos, $I10)
  # rx literal  "unless"
    add $I11, rx476_pos, 6
    gt $I11, rx476_eos, rx476_fail
    sub $I11, rx476_pos, rx476_off
    substr $S10, rx476_tgt, $I11, 6
    ne $S10, "unless", rx476_fail
    add rx476_pos, 6
    set_addr $I10, rxcap_481_fail
    ($I12, $I11) = rx476_cur."!mark_peek"($I10)
    rx476_cur."!cursor_pos"($I11)
    ($P10) = rx476_cur."!cursor_start"()
    $P10."!cursor_pass"(rx476_pos, "")
    rx476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_481_done
  rxcap_481_fail:
    goto rx476_fail
  rxcap_481_done:
  # rx subrule "ws" subtype=method negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."ws"()
    unless $P10, rx476_fail
    rx476_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."EXPR"()
    unless $P10, rx476_fail
    rx476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx476_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."ws"()
    unless $P10, rx476_fail
    rx476_pos = $P10."pos"()
  # rx pass
    rx476_cur."!cursor_pass"(rx476_pos, "statement_mod_cond:sym<unless>")
    if_null rx476_debug, debug_780
    rx476_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx476_pos)
  debug_780:
    .return (rx476_cur)
  rx476_restart:
.annotate 'line', 10
    if_null rx476_debug, debug_781
    rx476_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_781:
  rx476_fail:
    (rx476_rep, rx476_pos, $I10, $P10) = rx476_cur."!mark_fail"(0)
    lt rx476_pos, -1, rx476_done
    eq rx476_pos, -1, rx476_fail
    jump $I10
  rx476_done:
    rx476_cur."!cursor_fail"()
    if_null rx476_debug, debug_782
    rx476_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_782:
    .return (rx476_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303430322.161") :method
.annotate 'line', 10
    $P478 = self."!PREFIX__!subrule"("ws", "unless")
    new $P479, "ResizablePMCArray"
    push $P479, $P478
    .return ($P479)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303430322.161")
    .param pmc param_485
.annotate 'line', 265
    .lex "self", param_485
    $P486 = param_485."!protoregex"("statement_mod_loop")
    .return ($P486)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303430322.161")
    .param pmc param_488
.annotate 'line', 265
    .lex "self", param_488
    $P489 = param_488."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx491_tgt
    .local int rx491_pos
    .local int rx491_off
    .local int rx491_eos
    .local int rx491_rep
    .local pmc rx491_cur
    .local pmc rx491_debug
    (rx491_cur, rx491_pos, rx491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx491_cur
    .local pmc match
    .lex "$/", match
    length rx491_eos, rx491_tgt
    gt rx491_pos, rx491_eos, rx491_done
    set rx491_off, 0
    lt rx491_pos, 2, rx491_start
    sub rx491_off, rx491_pos, 1
    substr rx491_tgt, rx491_tgt, rx491_off
  rx491_start:
    eq $I10, 1, rx491_restart
    if_null rx491_debug, debug_783
    rx491_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan495_done
    goto rxscan495_scan
  rxscan495_loop:
    (rx491_pos) = rx491_cur."from"()
    inc rx491_pos
    rx491_cur."!cursor_from"(rx491_pos)
    ge rx491_pos, rx491_eos, rxscan495_done
  rxscan495_scan:
    set_addr $I10, rxscan495_loop
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  rxscan495_done:
.annotate 'line', 267
  # rx subcapture "sym"
    set_addr $I10, rxcap_496_fail
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  # rx literal  "while"
    add $I11, rx491_pos, 5
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 5
    ne $S10, "while", rx491_fail
    add rx491_pos, 5
    set_addr $I10, rxcap_496_fail
    ($I12, $I11) = rx491_cur."!mark_peek"($I10)
    rx491_cur."!cursor_pos"($I11)
    ($P10) = rx491_cur."!cursor_start"()
    $P10."!cursor_pass"(rx491_pos, "")
    rx491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_496_done
  rxcap_496_fail:
    goto rx491_fail
  rxcap_496_done:
  # rx subrule "ws" subtype=method negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."ws"()
    unless $P10, rx491_fail
    rx491_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."EXPR"()
    unless $P10, rx491_fail
    rx491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx491_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."ws"()
    unless $P10, rx491_fail
    rx491_pos = $P10."pos"()
  # rx pass
    rx491_cur."!cursor_pass"(rx491_pos, "statement_mod_loop:sym<while>")
    if_null rx491_debug, debug_784
    rx491_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx491_pos)
  debug_784:
    .return (rx491_cur)
  rx491_restart:
.annotate 'line', 10
    if_null rx491_debug, debug_785
    rx491_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_785:
  rx491_fail:
    (rx491_rep, rx491_pos, $I10, $P10) = rx491_cur."!mark_fail"(0)
    lt rx491_pos, -1, rx491_done
    eq rx491_pos, -1, rx491_fail
    jump $I10
  rx491_done:
    rx491_cur."!cursor_fail"()
    if_null rx491_debug, debug_786
    rx491_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_786:
    .return (rx491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303430322.161") :method
.annotate 'line', 10
    $P493 = self."!PREFIX__!subrule"("ws", "while")
    new $P494, "ResizablePMCArray"
    push $P494, $P493
    .return ($P494)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_787
    rx500_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan504_done
    goto rxscan504_scan
  rxscan504_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan504_done
  rxscan504_scan:
    set_addr $I10, rxscan504_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan504_done:
.annotate 'line', 268
  # rx subcapture "sym"
    set_addr $I10, rxcap_505_fail
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  # rx literal  "until"
    add $I11, rx500_pos, 5
    gt $I11, rx500_eos, rx500_fail
    sub $I11, rx500_pos, rx500_off
    substr $S10, rx500_tgt, $I11, 5
    ne $S10, "until", rx500_fail
    add rx500_pos, 5
    set_addr $I10, rxcap_505_fail
    ($I12, $I11) = rx500_cur."!mark_peek"($I10)
    rx500_cur."!cursor_pos"($I11)
    ($P10) = rx500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx500_pos, "")
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_505_done
  rxcap_505_fail:
    goto rx500_fail
  rxcap_505_done:
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."EXPR"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx500_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "statement_mod_loop:sym<until>")
    if_null rx500_debug, debug_788
    rx500_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx500_pos)
  debug_788:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 10
    if_null rx500_debug, debug_789
    rx500_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_789:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_790
    rx500_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_790:
    .return (rx500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303430322.161") :method
.annotate 'line', 10
    $P502 = self."!PREFIX__!subrule"("ws", "until")
    new $P503, "ResizablePMCArray"
    push $P503, $P502
    .return ($P503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx509_tgt
    .local int rx509_pos
    .local int rx509_off
    .local int rx509_eos
    .local int rx509_rep
    .local pmc rx509_cur
    .local pmc rx509_debug
    (rx509_cur, rx509_pos, rx509_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx509_cur
    .local pmc match
    .lex "$/", match
    length rx509_eos, rx509_tgt
    gt rx509_pos, rx509_eos, rx509_done
    set rx509_off, 0
    lt rx509_pos, 2, rx509_start
    sub rx509_off, rx509_pos, 1
    substr rx509_tgt, rx509_tgt, rx509_off
  rx509_start:
    eq $I10, 1, rx509_restart
    if_null rx509_debug, debug_791
    rx509_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx509_pos) = rx509_cur."from"()
    inc rx509_pos
    rx509_cur."!cursor_from"(rx509_pos)
    ge rx509_pos, rx509_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx509_cur."!mark_push"(0, rx509_pos, $I10)
  rxscan513_done:
.annotate 'line', 269
  # rx subcapture "sym"
    set_addr $I10, rxcap_514_fail
    rx509_cur."!mark_push"(0, rx509_pos, $I10)
  # rx literal  "for"
    add $I11, rx509_pos, 3
    gt $I11, rx509_eos, rx509_fail
    sub $I11, rx509_pos, rx509_off
    substr $S10, rx509_tgt, $I11, 3
    ne $S10, "for", rx509_fail
    add rx509_pos, 3
    set_addr $I10, rxcap_514_fail
    ($I12, $I11) = rx509_cur."!mark_peek"($I10)
    rx509_cur."!cursor_pos"($I11)
    ($P10) = rx509_cur."!cursor_start"()
    $P10."!cursor_pass"(rx509_pos, "")
    rx509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_514_done
  rxcap_514_fail:
    goto rx509_fail
  rxcap_514_done:
  # rx subrule "ws" subtype=method negate=
    rx509_cur."!cursor_pos"(rx509_pos)
    $P10 = rx509_cur."ws"()
    unless $P10, rx509_fail
    rx509_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx509_cur."!cursor_pos"(rx509_pos)
    $P10 = rx509_cur."EXPR"()
    unless $P10, rx509_fail
    rx509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx509_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx509_cur."!cursor_pos"(rx509_pos)
    $P10 = rx509_cur."ws"()
    unless $P10, rx509_fail
    rx509_pos = $P10."pos"()
  # rx pass
    rx509_cur."!cursor_pass"(rx509_pos, "statement_mod_loop:sym<for>")
    if_null rx509_debug, debug_792
    rx509_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx509_pos)
  debug_792:
    .return (rx509_cur)
  rx509_restart:
.annotate 'line', 10
    if_null rx509_debug, debug_793
    rx509_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_793:
  rx509_fail:
    (rx509_rep, rx509_pos, $I10, $P10) = rx509_cur."!mark_fail"(0)
    lt rx509_pos, -1, rx509_done
    eq rx509_pos, -1, rx509_fail
    jump $I10
  rx509_done:
    rx509_cur."!cursor_fail"()
    if_null rx509_debug, debug_794
    rx509_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_794:
    .return (rx509_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303430322.161") :method
.annotate 'line', 10
    $P511 = self."!PREFIX__!subrule"("ws", "for")
    new $P512, "ResizablePMCArray"
    push $P512, $P511
    .return ($P512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx518_tgt
    .local int rx518_pos
    .local int rx518_off
    .local int rx518_eos
    .local int rx518_rep
    .local pmc rx518_cur
    .local pmc rx518_debug
    (rx518_cur, rx518_pos, rx518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx518_cur
    .local pmc match
    .lex "$/", match
    length rx518_eos, rx518_tgt
    gt rx518_pos, rx518_eos, rx518_done
    set rx518_off, 0
    lt rx518_pos, 2, rx518_start
    sub rx518_off, rx518_pos, 1
    substr rx518_tgt, rx518_tgt, rx518_off
  rx518_start:
    eq $I10, 1, rx518_restart
    if_null rx518_debug, debug_795
    rx518_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_795:
    $I10 = self.'from'()
    ne $I10, -1, rxscan522_done
    goto rxscan522_scan
  rxscan522_loop:
    (rx518_pos) = rx518_cur."from"()
    inc rx518_pos
    rx518_cur."!cursor_from"(rx518_pos)
    ge rx518_pos, rx518_eos, rxscan522_done
  rxscan522_scan:
    set_addr $I10, rxscan522_loop
    rx518_cur."!mark_push"(0, rx518_pos, $I10)
  rxscan522_done:
.annotate 'line', 273
  # rx subrule "fatarrow" subtype=capture negate=
    rx518_cur."!cursor_pos"(rx518_pos)
    $P10 = rx518_cur."fatarrow"()
    unless $P10, rx518_fail
    rx518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx518_pos = $P10."pos"()
  # rx pass
    rx518_cur."!cursor_pass"(rx518_pos, "term:sym<fatarrow>")
    if_null rx518_debug, debug_796
    rx518_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx518_pos)
  debug_796:
    .return (rx518_cur)
  rx518_restart:
.annotate 'line', 10
    if_null rx518_debug, debug_797
    rx518_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_797:
  rx518_fail:
    (rx518_rep, rx518_pos, $I10, $P10) = rx518_cur."!mark_fail"(0)
    lt rx518_pos, -1, rx518_done
    eq rx518_pos, -1, rx518_fail
    jump $I10
  rx518_done:
    rx518_cur."!cursor_fail"()
    if_null rx518_debug, debug_798
    rx518_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_798:
    .return (rx518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303430322.161") :method
.annotate 'line', 10
    $P520 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P521, "ResizablePMCArray"
    push $P521, $P520
    .return ($P521)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx524_tgt
    .local int rx524_pos
    .local int rx524_off
    .local int rx524_eos
    .local int rx524_rep
    .local pmc rx524_cur
    .local pmc rx524_debug
    (rx524_cur, rx524_pos, rx524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx524_cur
    .local pmc match
    .lex "$/", match
    length rx524_eos, rx524_tgt
    gt rx524_pos, rx524_eos, rx524_done
    set rx524_off, 0
    lt rx524_pos, 2, rx524_start
    sub rx524_off, rx524_pos, 1
    substr rx524_tgt, rx524_tgt, rx524_off
  rx524_start:
    eq $I10, 1, rx524_restart
    if_null rx524_debug, debug_799
    rx524_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_799:
    $I10 = self.'from'()
    ne $I10, -1, rxscan528_done
    goto rxscan528_scan
  rxscan528_loop:
    (rx524_pos) = rx524_cur."from"()
    inc rx524_pos
    rx524_cur."!cursor_from"(rx524_pos)
    ge rx524_pos, rx524_eos, rxscan528_done
  rxscan528_scan:
    set_addr $I10, rxscan528_loop
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxscan528_done:
.annotate 'line', 274
  # rx subrule "colonpair" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."colonpair"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx524_pos = $P10."pos"()
  # rx pass
    rx524_cur."!cursor_pass"(rx524_pos, "term:sym<colonpair>")
    if_null rx524_debug, debug_800
    rx524_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx524_pos)
  debug_800:
    .return (rx524_cur)
  rx524_restart:
.annotate 'line', 10
    if_null rx524_debug, debug_801
    rx524_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_801:
  rx524_fail:
    (rx524_rep, rx524_pos, $I10, $P10) = rx524_cur."!mark_fail"(0)
    lt rx524_pos, -1, rx524_done
    eq rx524_pos, -1, rx524_fail
    jump $I10
  rx524_done:
    rx524_cur."!cursor_fail"()
    if_null rx524_debug, debug_802
    rx524_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_802:
    .return (rx524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303430322.161") :method
.annotate 'line', 10
    $P526 = self."!PREFIX__!subrule"("colonpair", "")
    new $P527, "ResizablePMCArray"
    push $P527, $P526
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx530_tgt
    .local int rx530_pos
    .local int rx530_off
    .local int rx530_eos
    .local int rx530_rep
    .local pmc rx530_cur
    .local pmc rx530_debug
    (rx530_cur, rx530_pos, rx530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx530_cur
    .local pmc match
    .lex "$/", match
    length rx530_eos, rx530_tgt
    gt rx530_pos, rx530_eos, rx530_done
    set rx530_off, 0
    lt rx530_pos, 2, rx530_start
    sub rx530_off, rx530_pos, 1
    substr rx530_tgt, rx530_tgt, rx530_off
  rx530_start:
    eq $I10, 1, rx530_restart
    if_null rx530_debug, debug_803
    rx530_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_803:
    $I10 = self.'from'()
    ne $I10, -1, rxscan534_done
    goto rxscan534_scan
  rxscan534_loop:
    (rx530_pos) = rx530_cur."from"()
    inc rx530_pos
    rx530_cur."!cursor_from"(rx530_pos)
    ge rx530_pos, rx530_eos, rxscan534_done
  rxscan534_scan:
    set_addr $I10, rxscan534_loop
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
  rxscan534_done:
.annotate 'line', 275
  # rx subrule "variable" subtype=capture negate=
    rx530_cur."!cursor_pos"(rx530_pos)
    $P10 = rx530_cur."variable"()
    unless $P10, rx530_fail
    rx530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx530_pos = $P10."pos"()
  # rx pass
    rx530_cur."!cursor_pass"(rx530_pos, "term:sym<variable>")
    if_null rx530_debug, debug_804
    rx530_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx530_pos)
  debug_804:
    .return (rx530_cur)
  rx530_restart:
.annotate 'line', 10
    if_null rx530_debug, debug_805
    rx530_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_805:
  rx530_fail:
    (rx530_rep, rx530_pos, $I10, $P10) = rx530_cur."!mark_fail"(0)
    lt rx530_pos, -1, rx530_done
    eq rx530_pos, -1, rx530_fail
    jump $I10
  rx530_done:
    rx530_cur."!cursor_fail"()
    if_null rx530_debug, debug_806
    rx530_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_806:
    .return (rx530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303430322.161") :method
.annotate 'line', 10
    $P532 = self."!PREFIX__!subrule"("variable", "")
    new $P533, "ResizablePMCArray"
    push $P533, $P532
    .return ($P533)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_807
    rx536_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_807:
    $I10 = self.'from'()
    ne $I10, -1, rxscan540_done
    goto rxscan540_scan
  rxscan540_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan540_done
  rxscan540_scan:
    set_addr $I10, rxscan540_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan540_done:
.annotate 'line', 276
  # rx subrule "package_declarator" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."package_declarator"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx536_pos = $P10."pos"()
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "term:sym<package_declarator>")
    if_null rx536_debug, debug_808
    rx536_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx536_pos)
  debug_808:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 10
    if_null rx536_debug, debug_809
    rx536_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_809:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_810
    rx536_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_810:
    .return (rx536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303430322.161") :method
.annotate 'line', 10
    $P538 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P539, "ResizablePMCArray"
    push $P539, $P538
    .return ($P539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_811
    rx542_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_811:
    $I10 = self.'from'()
    ne $I10, -1, rxscan546_done
    goto rxscan546_scan
  rxscan546_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan546_done
  rxscan546_scan:
    set_addr $I10, rxscan546_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan546_done:
.annotate 'line', 277
  # rx subrule "scope_declarator" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."scope_declarator"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx542_pos = $P10."pos"()
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "term:sym<scope_declarator>")
    if_null rx542_debug, debug_812
    rx542_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx542_pos)
  debug_812:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 10
    if_null rx542_debug, debug_813
    rx542_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_813:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_814
    rx542_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_814:
    .return (rx542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303430322.161") :method
.annotate 'line', 10
    $P544 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P545, "ResizablePMCArray"
    push $P545, $P544
    .return ($P545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx548_tgt
    .local int rx548_pos
    .local int rx548_off
    .local int rx548_eos
    .local int rx548_rep
    .local pmc rx548_cur
    .local pmc rx548_debug
    (rx548_cur, rx548_pos, rx548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx548_cur
    .local pmc match
    .lex "$/", match
    length rx548_eos, rx548_tgt
    gt rx548_pos, rx548_eos, rx548_done
    set rx548_off, 0
    lt rx548_pos, 2, rx548_start
    sub rx548_off, rx548_pos, 1
    substr rx548_tgt, rx548_tgt, rx548_off
  rx548_start:
    eq $I10, 1, rx548_restart
    if_null rx548_debug, debug_815
    rx548_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_815:
    $I10 = self.'from'()
    ne $I10, -1, rxscan552_done
    goto rxscan552_scan
  rxscan552_loop:
    (rx548_pos) = rx548_cur."from"()
    inc rx548_pos
    rx548_cur."!cursor_from"(rx548_pos)
    ge rx548_pos, rx548_eos, rxscan552_done
  rxscan552_scan:
    set_addr $I10, rxscan552_loop
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  rxscan552_done:
.annotate 'line', 278
  # rx subrule "routine_declarator" subtype=capture negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."routine_declarator"()
    unless $P10, rx548_fail
    rx548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx548_pos = $P10."pos"()
  # rx pass
    rx548_cur."!cursor_pass"(rx548_pos, "term:sym<routine_declarator>")
    if_null rx548_debug, debug_816
    rx548_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx548_pos)
  debug_816:
    .return (rx548_cur)
  rx548_restart:
.annotate 'line', 10
    if_null rx548_debug, debug_817
    rx548_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_817:
  rx548_fail:
    (rx548_rep, rx548_pos, $I10, $P10) = rx548_cur."!mark_fail"(0)
    lt rx548_pos, -1, rx548_done
    eq rx548_pos, -1, rx548_fail
    jump $I10
  rx548_done:
    rx548_cur."!cursor_fail"()
    if_null rx548_debug, debug_818
    rx548_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_818:
    .return (rx548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303430322.161") :method
.annotate 'line', 10
    $P550 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P551, "ResizablePMCArray"
    push $P551, $P550
    .return ($P551)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P564 = "121_1303430322.161" 
    capture_lex $P564
    .const 'Sub' $P559 = "120_1303430322.161" 
    capture_lex $P559
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_819
    rx554_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_819:
    $I10 = self.'from'()
    ne $I10, -1, rxscan557_done
    goto rxscan557_scan
  rxscan557_loop:
    (rx554_pos) = rx554_cur."from"()
    inc rx554_pos
    rx554_cur."!cursor_from"(rx554_pos)
    ge rx554_pos, rx554_eos, rxscan557_done
  rxscan557_scan:
    set_addr $I10, rxscan557_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan557_done:
.annotate 'line', 280
  # rx subrule "before" subtype=zerowidth negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    .const 'Sub' $P559 = "120_1303430322.161" 
    capture_lex $P559
    $P10 = rx554_cur."before"($P559)
    unless $P10, rx554_fail
.annotate 'line', 281
  # rx subrule "before" subtype=zerowidth negate=1
    rx554_cur."!cursor_pos"(rx554_pos)
    .const 'Sub' $P564 = "121_1303430322.161" 
    capture_lex $P564
    $P10 = rx554_cur."before"($P564)
    if $P10, rx554_fail
.annotate 'line', 282
  # rx subrule "multi_declarator" subtype=capture negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."multi_declarator"()
    unless $P10, rx554_fail
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx554_pos = $P10."pos"()
.annotate 'line', 279
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "term:sym<multi_declarator>")
    if_null rx554_debug, debug_828
    rx554_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx554_pos)
  debug_828:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 10
    if_null rx554_debug, debug_829
    rx554_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_829:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_830
    rx554_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_830:
    .return (rx554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303430322.161") :method
.annotate 'line', 10
    new $P556, "ResizablePMCArray"
    push $P556, ""
    .return ($P556)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block558"  :anon :subid("120_1303430322.161") :method :outer("118_1303430322.161")
.annotate 'line', 280
    .local string rx560_tgt
    .local int rx560_pos
    .local int rx560_off
    .local int rx560_eos
    .local int rx560_rep
    .local pmc rx560_cur
    .local pmc rx560_debug
    (rx560_cur, rx560_pos, rx560_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx560_cur
    .local pmc match
    .lex "$/", match
    length rx560_eos, rx560_tgt
    gt rx560_pos, rx560_eos, rx560_done
    set rx560_off, 0
    lt rx560_pos, 2, rx560_start
    sub rx560_off, rx560_pos, 1
    substr rx560_tgt, rx560_tgt, rx560_off
  rx560_start:
    eq $I10, 1, rx560_restart
    if_null rx560_debug, debug_820
    rx560_cur."!cursor_debug"("START", "")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan561_done
    goto rxscan561_scan
  rxscan561_loop:
    (rx560_pos) = rx560_cur."from"()
    inc rx560_pos
    rx560_cur."!cursor_from"(rx560_pos)
    ge rx560_pos, rx560_eos, rxscan561_done
  rxscan561_scan:
    set_addr $I10, rxscan561_loop
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  rxscan561_done:
  alt562_0:
    set_addr $I10, alt562_1
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  # rx literal  "multi"
    add $I11, rx560_pos, 5
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 5
    ne $S10, "multi", rx560_fail
    add rx560_pos, 5
    goto alt562_end
  alt562_1:
    set_addr $I10, alt562_2
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  # rx literal  "proto"
    add $I11, rx560_pos, 5
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 5
    ne $S10, "proto", rx560_fail
    add rx560_pos, 5
    goto alt562_end
  alt562_2:
  # rx literal  "only"
    add $I11, rx560_pos, 4
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 4
    ne $S10, "only", rx560_fail
    add rx560_pos, 4
  alt562_end:
  # rx pass
    rx560_cur."!cursor_pass"(rx560_pos, "")
    if_null rx560_debug, debug_821
    rx560_cur."!cursor_debug"("PASS", "", " at pos=", rx560_pos)
  debug_821:
    .return (rx560_cur)
  rx560_restart:
    if_null rx560_debug, debug_822
    rx560_cur."!cursor_debug"("NEXT", "")
  debug_822:
  rx560_fail:
    (rx560_rep, rx560_pos, $I10, $P10) = rx560_cur."!mark_fail"(0)
    lt rx560_pos, -1, rx560_done
    eq rx560_pos, -1, rx560_fail
    jump $I10
  rx560_done:
    rx560_cur."!cursor_fail"()
    if_null rx560_debug, debug_823
    rx560_cur."!cursor_debug"("FAIL", "")
  debug_823:
    .return (rx560_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block563"  :anon :subid("121_1303430322.161") :method :outer("118_1303430322.161")
.annotate 'line', 281
    .local string rx565_tgt
    .local int rx565_pos
    .local int rx565_off
    .local int rx565_eos
    .local int rx565_rep
    .local pmc rx565_cur
    .local pmc rx565_debug
    (rx565_cur, rx565_pos, rx565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx565_cur
    .local pmc match
    .lex "$/", match
    length rx565_eos, rx565_tgt
    gt rx565_pos, rx565_eos, rx565_done
    set rx565_off, 0
    lt rx565_pos, 2, rx565_start
    sub rx565_off, rx565_pos, 1
    substr rx565_tgt, rx565_tgt, rx565_off
  rx565_start:
    eq $I10, 1, rx565_restart
    if_null rx565_debug, debug_824
    rx565_cur."!cursor_debug"("START", "")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan566_done
    goto rxscan566_scan
  rxscan566_loop:
    (rx565_pos) = rx565_cur."from"()
    inc rx565_pos
    rx565_cur."!cursor_from"(rx565_pos)
    ge rx565_pos, rx565_eos, rxscan566_done
  rxscan566_scan:
    set_addr $I10, rxscan566_loop
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxscan566_done:
  # rx literal  "proto"
    add $I11, rx565_pos, 5
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 5
    ne $S10, "proto", rx565_fail
    add rx565_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."ws"()
    unless $P10, rx565_fail
    rx565_pos = $P10."pos"()
  alt567_0:
    set_addr $I10, alt567_1
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "regex"
    add $I11, rx565_pos, 5
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 5
    ne $S10, "regex", rx565_fail
    add rx565_pos, 5
    goto alt567_end
  alt567_1:
    set_addr $I10, alt567_2
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "token"
    add $I11, rx565_pos, 5
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 5
    ne $S10, "token", rx565_fail
    add rx565_pos, 5
    goto alt567_end
  alt567_2:
  # rx literal  "rule"
    add $I11, rx565_pos, 4
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 4
    ne $S10, "rule", rx565_fail
    add rx565_pos, 4
  alt567_end:
  # rx pass
    rx565_cur."!cursor_pass"(rx565_pos, "")
    if_null rx565_debug, debug_825
    rx565_cur."!cursor_debug"("PASS", "", " at pos=", rx565_pos)
  debug_825:
    .return (rx565_cur)
  rx565_restart:
    if_null rx565_debug, debug_826
    rx565_cur."!cursor_debug"("NEXT", "")
  debug_826:
  rx565_fail:
    (rx565_rep, rx565_pos, $I10, $P10) = rx565_cur."!mark_fail"(0)
    lt rx565_pos, -1, rx565_done
    eq rx565_pos, -1, rx565_fail
    jump $I10
  rx565_done:
    rx565_cur."!cursor_fail"()
    if_null rx565_debug, debug_827
    rx565_cur."!cursor_debug"("FAIL", "")
  debug_827:
    .return (rx565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx569_tgt
    .local int rx569_pos
    .local int rx569_off
    .local int rx569_eos
    .local int rx569_rep
    .local pmc rx569_cur
    .local pmc rx569_debug
    (rx569_cur, rx569_pos, rx569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx569_cur
    .local pmc match
    .lex "$/", match
    length rx569_eos, rx569_tgt
    gt rx569_pos, rx569_eos, rx569_done
    set rx569_off, 0
    lt rx569_pos, 2, rx569_start
    sub rx569_off, rx569_pos, 1
    substr rx569_tgt, rx569_tgt, rx569_off
  rx569_start:
    eq $I10, 1, rx569_restart
    if_null rx569_debug, debug_831
    rx569_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_831:
    $I10 = self.'from'()
    ne $I10, -1, rxscan573_done
    goto rxscan573_scan
  rxscan573_loop:
    (rx569_pos) = rx569_cur."from"()
    inc rx569_pos
    rx569_cur."!cursor_from"(rx569_pos)
    ge rx569_pos, rx569_eos, rxscan573_done
  rxscan573_scan:
    set_addr $I10, rxscan573_loop
    rx569_cur."!mark_push"(0, rx569_pos, $I10)
  rxscan573_done:
.annotate 'line', 284
  # rx subrule "regex_declarator" subtype=capture negate=
    rx569_cur."!cursor_pos"(rx569_pos)
    $P10 = rx569_cur."regex_declarator"()
    unless $P10, rx569_fail
    rx569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx569_pos = $P10."pos"()
  # rx pass
    rx569_cur."!cursor_pass"(rx569_pos, "term:sym<regex_declarator>")
    if_null rx569_debug, debug_832
    rx569_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx569_pos)
  debug_832:
    .return (rx569_cur)
  rx569_restart:
.annotate 'line', 10
    if_null rx569_debug, debug_833
    rx569_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_833:
  rx569_fail:
    (rx569_rep, rx569_pos, $I10, $P10) = rx569_cur."!mark_fail"(0)
    lt rx569_pos, -1, rx569_done
    eq rx569_pos, -1, rx569_fail
    jump $I10
  rx569_done:
    rx569_cur."!cursor_fail"()
    if_null rx569_debug, debug_834
    rx569_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_834:
    .return (rx569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303430322.161") :method
.annotate 'line', 10
    $P571 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P572, "ResizablePMCArray"
    push $P572, $P571
    .return ($P572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx575_tgt
    .local int rx575_pos
    .local int rx575_off
    .local int rx575_eos
    .local int rx575_rep
    .local pmc rx575_cur
    .local pmc rx575_debug
    (rx575_cur, rx575_pos, rx575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx575_cur
    .local pmc match
    .lex "$/", match
    length rx575_eos, rx575_tgt
    gt rx575_pos, rx575_eos, rx575_done
    set rx575_off, 0
    lt rx575_pos, 2, rx575_start
    sub rx575_off, rx575_pos, 1
    substr rx575_tgt, rx575_tgt, rx575_off
  rx575_start:
    eq $I10, 1, rx575_restart
    if_null rx575_debug, debug_835
    rx575_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_835:
    $I10 = self.'from'()
    ne $I10, -1, rxscan579_done
    goto rxscan579_scan
  rxscan579_loop:
    (rx575_pos) = rx575_cur."from"()
    inc rx575_pos
    rx575_cur."!cursor_from"(rx575_pos)
    ge rx575_pos, rx575_eos, rxscan579_done
  rxscan579_scan:
    set_addr $I10, rxscan579_loop
    rx575_cur."!mark_push"(0, rx575_pos, $I10)
  rxscan579_done:
.annotate 'line', 285
  # rx subrule "statement_prefix" subtype=capture negate=
    rx575_cur."!cursor_pos"(rx575_pos)
    $P10 = rx575_cur."statement_prefix"()
    unless $P10, rx575_fail
    rx575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx575_pos = $P10."pos"()
  # rx pass
    rx575_cur."!cursor_pass"(rx575_pos, "term:sym<statement_prefix>")
    if_null rx575_debug, debug_836
    rx575_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx575_pos)
  debug_836:
    .return (rx575_cur)
  rx575_restart:
.annotate 'line', 10
    if_null rx575_debug, debug_837
    rx575_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_837:
  rx575_fail:
    (rx575_rep, rx575_pos, $I10, $P10) = rx575_cur."!mark_fail"(0)
    lt rx575_pos, -1, rx575_done
    eq rx575_pos, -1, rx575_fail
    jump $I10
  rx575_done:
    rx575_cur."!cursor_fail"()
    if_null rx575_debug, debug_838
    rx575_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_838:
    .return (rx575_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303430322.161") :method
.annotate 'line', 10
    $P577 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P578, "ResizablePMCArray"
    push $P578, $P577
    .return ($P578)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx581_tgt
    .local int rx581_pos
    .local int rx581_off
    .local int rx581_eos
    .local int rx581_rep
    .local pmc rx581_cur
    .local pmc rx581_debug
    (rx581_cur, rx581_pos, rx581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx581_cur
    .local pmc match
    .lex "$/", match
    length rx581_eos, rx581_tgt
    gt rx581_pos, rx581_eos, rx581_done
    set rx581_off, 0
    lt rx581_pos, 2, rx581_start
    sub rx581_off, rx581_pos, 1
    substr rx581_tgt, rx581_tgt, rx581_off
  rx581_start:
    eq $I10, 1, rx581_restart
    if_null rx581_debug, debug_839
    rx581_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_839:
    $I10 = self.'from'()
    ne $I10, -1, rxscan584_done
    goto rxscan584_scan
  rxscan584_loop:
    (rx581_pos) = rx581_cur."from"()
    inc rx581_pos
    rx581_cur."!cursor_from"(rx581_pos)
    ge rx581_pos, rx581_eos, rxscan584_done
  rxscan584_scan:
    set_addr $I10, rxscan584_loop
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  rxscan584_done:
.annotate 'line', 286
  # rx subrule "lambda" subtype=zerowidth negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."lambda"()
    unless $P10, rx581_fail
  # rx subrule "pblock" subtype=capture negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."pblock"()
    unless $P10, rx581_fail
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx581_pos = $P10."pos"()
  # rx pass
    rx581_cur."!cursor_pass"(rx581_pos, "term:sym<lambda>")
    if_null rx581_debug, debug_840
    rx581_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx581_pos)
  debug_840:
    .return (rx581_cur)
  rx581_restart:
.annotate 'line', 10
    if_null rx581_debug, debug_841
    rx581_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_841:
  rx581_fail:
    (rx581_rep, rx581_pos, $I10, $P10) = rx581_cur."!mark_fail"(0)
    lt rx581_pos, -1, rx581_done
    eq rx581_pos, -1, rx581_fail
    jump $I10
  rx581_done:
    rx581_cur."!cursor_fail"()
    if_null rx581_debug, debug_842
    rx581_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_842:
    .return (rx581_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303430322.161") :method
.annotate 'line', 10
    new $P583, "ResizablePMCArray"
    push $P583, ""
    .return ($P583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx586_tgt
    .local int rx586_pos
    .local int rx586_off
    .local int rx586_eos
    .local int rx586_rep
    .local pmc rx586_cur
    .local pmc rx586_debug
    (rx586_cur, rx586_pos, rx586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx586_cur
    .local pmc match
    .lex "$/", match
    length rx586_eos, rx586_tgt
    gt rx586_pos, rx586_eos, rx586_done
    set rx586_off, 0
    lt rx586_pos, 2, rx586_start
    sub rx586_off, rx586_pos, 1
    substr rx586_tgt, rx586_tgt, rx586_off
  rx586_start:
    eq $I10, 1, rx586_restart
    if_null rx586_debug, debug_843
    rx586_cur."!cursor_debug"("START", "fatarrow")
  debug_843:
    $I10 = self.'from'()
    ne $I10, -1, rxscan590_done
    goto rxscan590_scan
  rxscan590_loop:
    (rx586_pos) = rx586_cur."from"()
    inc rx586_pos
    rx586_cur."!cursor_from"(rx586_pos)
    ge rx586_pos, rx586_eos, rxscan590_done
  rxscan590_scan:
    set_addr $I10, rxscan590_loop
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  rxscan590_done:
.annotate 'line', 289
  # rx subrule "identifier" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."identifier"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx586_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx586_pos, rx586_off
    set rx586_rep, 0
    sub $I12, rx586_eos, rx586_pos
  rxenumcharlistq591_loop:
    le $I12, 0, rxenumcharlistq591_done
    substr $S10, rx586_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq591_done
    inc rx586_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq591_loop
  rxenumcharlistq591_done:
    add rx586_pos, rx586_pos, rx586_rep
  # rx literal  "=>"
    add $I11, rx586_pos, 2
    gt $I11, rx586_eos, rx586_fail
    sub $I11, rx586_pos, rx586_off
    substr $S10, rx586_tgt, $I11, 2
    ne $S10, "=>", rx586_fail
    add rx586_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."ws"()
    unless $P10, rx586_fail
    rx586_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."EXPR"("i=")
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx586_pos = $P10."pos"()
.annotate 'line', 288
  # rx pass
    rx586_cur."!cursor_pass"(rx586_pos, "fatarrow")
    if_null rx586_debug, debug_844
    rx586_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx586_pos)
  debug_844:
    .return (rx586_cur)
  rx586_restart:
.annotate 'line', 10
    if_null rx586_debug, debug_845
    rx586_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_845:
  rx586_fail:
    (rx586_rep, rx586_pos, $I10, $P10) = rx586_cur."!mark_fail"(0)
    lt rx586_pos, -1, rx586_done
    eq rx586_pos, -1, rx586_fail
    jump $I10
  rx586_done:
    rx586_cur."!cursor_fail"()
    if_null rx586_debug, debug_846
    rx586_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_846:
    .return (rx586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303430322.161") :method
.annotate 'line', 10
    $P588 = self."!PREFIX__!subrule"("identifier", "")
    new $P589, "ResizablePMCArray"
    push $P589, $P588
    .return ($P589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx593_tgt
    .local int rx593_pos
    .local int rx593_off
    .local int rx593_eos
    .local int rx593_rep
    .local pmc rx593_cur
    .local pmc rx593_debug
    (rx593_cur, rx593_pos, rx593_tgt, $I10) = self."!cursor_start"()
    rx593_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx593_cur
    .local pmc match
    .lex "$/", match
    length rx593_eos, rx593_tgt
    gt rx593_pos, rx593_eos, rx593_done
    set rx593_off, 0
    lt rx593_pos, 2, rx593_start
    sub rx593_off, rx593_pos, 1
    substr rx593_tgt, rx593_tgt, rx593_off
  rx593_start:
    eq $I10, 1, rx593_restart
    if_null rx593_debug, debug_847
    rx593_cur."!cursor_debug"("START", "colonpair")
  debug_847:
    $I10 = self.'from'()
    ne $I10, -1, rxscan599_done
    goto rxscan599_scan
  rxscan599_loop:
    (rx593_pos) = rx593_cur."from"()
    inc rx593_pos
    rx593_cur."!cursor_from"(rx593_pos)
    ge rx593_pos, rx593_eos, rxscan599_done
  rxscan599_scan:
    set_addr $I10, rxscan599_loop
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  rxscan599_done:
.annotate 'line', 293
  # rx literal  ":"
    add $I11, rx593_pos, 1
    gt $I11, rx593_eos, rx593_fail
    sub $I11, rx593_pos, rx593_off
    ord $I11, rx593_tgt, $I11
    ne $I11, 58, rx593_fail
    add rx593_pos, 1
  alt600_0:
.annotate 'line', 294
    set_addr $I10, alt600_1
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
.annotate 'line', 295
  # rx subcapture "not"
    set_addr $I10, rxcap_601_fail
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  # rx literal  "!"
    add $I11, rx593_pos, 1
    gt $I11, rx593_eos, rx593_fail
    sub $I11, rx593_pos, rx593_off
    ord $I11, rx593_tgt, $I11
    ne $I11, 33, rx593_fail
    add rx593_pos, 1
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx593_cur."!mark_peek"($I10)
    rx593_cur."!cursor_pos"($I11)
    ($P10) = rx593_cur."!cursor_start"()
    $P10."!cursor_pass"(rx593_pos, "")
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx593_fail
  rxcap_601_done:
  # rx subrule "identifier" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."identifier"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx593_pos = $P10."pos"()
    goto alt600_end
  alt600_1:
    set_addr $I10, alt600_2
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
.annotate 'line', 296
  # rx subrule "identifier" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."identifier"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx593_pos = $P10."pos"()
  # rx rxquantr602 ** 0..1
    set_addr $I10, rxquantr602_done
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  rxquantr602_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."circumfix"()
    unless $P10, rx593_fail
    goto rxsubrule603_pass
  rxsubrule603_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx593_fail
  rxsubrule603_pass:
    set_addr $I10, rxsubrule603_back
    rx593_cur."!mark_push"(0, rx593_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx593_pos = $P10."pos"()
    set_addr $I10, rxquantr602_done
    (rx593_rep) = rx593_cur."!mark_commit"($I10)
  rxquantr602_done:
    goto alt600_end
  alt600_2:
.annotate 'line', 297
  # rx subrule "circumfix" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."circumfix"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx593_pos = $P10."pos"()
  alt600_end:
.annotate 'line', 292
  # rx pass
    rx593_cur."!cursor_pass"(rx593_pos, "colonpair")
    if_null rx593_debug, debug_848
    rx593_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx593_pos)
  debug_848:
    .return (rx593_cur)
  rx593_restart:
.annotate 'line', 10
    if_null rx593_debug, debug_849
    rx593_cur."!cursor_debug"("NEXT", "colonpair")
  debug_849:
  rx593_fail:
    (rx593_rep, rx593_pos, $I10, $P10) = rx593_cur."!mark_fail"(0)
    lt rx593_pos, -1, rx593_done
    eq rx593_pos, -1, rx593_fail
    jump $I10
  rx593_done:
    rx593_cur."!cursor_fail"()
    if_null rx593_debug, debug_850
    rx593_cur."!cursor_debug"("FAIL", "colonpair")
  debug_850:
    .return (rx593_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303430322.161") :method
.annotate 'line', 10
    $P595 = self."!PREFIX__!subrule"("circumfix", ":")
    $P596 = self."!PREFIX__!subrule"("identifier", ":")
    $P597 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P598, "ResizablePMCArray"
    push $P598, $P595
    push $P598, $P596
    push $P598, $P597
    .return ($P598)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    rx605_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_851
    rx605_cur."!cursor_debug"("START", "variable")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan610_done
    goto rxscan610_scan
  rxscan610_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan610_done
  rxscan610_scan:
    set_addr $I10, rxscan610_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan610_done:
  alt611_0:
.annotate 'line', 301
    set_addr $I10, alt611_1
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
.annotate 'line', 302
  # rx subrule "sigil" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."sigil"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx605_pos = $P10."pos"()
  # rx rxquantr612 ** 0..1
    set_addr $I10, rxquantr612_done
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxquantr612_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."twigil"()
    unless $P10, rx605_fail
    goto rxsubrule613_pass
  rxsubrule613_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx605_fail
  rxsubrule613_pass:
    set_addr $I10, rxsubrule613_back
    rx605_cur."!mark_push"(0, rx605_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx605_pos = $P10."pos"()
    set_addr $I10, rxquantr612_done
    (rx605_rep) = rx605_cur."!mark_commit"($I10)
  rxquantr612_done:
  # rx subrule "name" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."name"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx605_pos = $P10."pos"()
    goto alt611_end
  alt611_1:
    set_addr $I10, alt611_2
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
.annotate 'line', 303
  # rx subrule "sigil" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."sigil"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx605_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx605_pos, rx605_off
    substr $S10, rx605_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx605_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."postcircumfix"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx605_pos = $P10."pos"()
    goto alt611_end
  alt611_2:
.annotate 'line', 304
  # rx subcapture "sigil"
    set_addr $I10, rxcap_614_fail
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  # rx literal  "$"
    add $I11, rx605_pos, 1
    gt $I11, rx605_eos, rx605_fail
    sub $I11, rx605_pos, rx605_off
    ord $I11, rx605_tgt, $I11
    ne $I11, 36, rx605_fail
    add rx605_pos, 1
    set_addr $I10, rxcap_614_fail
    ($I12, $I11) = rx605_cur."!mark_peek"($I10)
    rx605_cur."!cursor_pos"($I11)
    ($P10) = rx605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx605_pos, "")
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_614_done
  rxcap_614_fail:
    goto rx605_fail
  rxcap_614_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_615_fail
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx605_pos, rx605_eos, rx605_fail
    sub $I10, rx605_pos, rx605_off
    substr $S10, rx605_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx605_fail
    inc rx605_pos
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx605_cur."!mark_peek"($I10)
    rx605_cur."!cursor_pos"($I11)
    ($P10) = rx605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx605_pos, "")
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx605_fail
  rxcap_615_done:
  alt611_end:
.annotate 'line', 301
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "variable")
    if_null rx605_debug, debug_852
    rx605_cur."!cursor_debug"("PASS", "variable", " at pos=", rx605_pos)
  debug_852:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_853
    rx605_cur."!cursor_debug"("NEXT", "variable")
  debug_853:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_854
    rx605_cur."!cursor_debug"("FAIL", "variable")
  debug_854:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303430322.161") :method
.annotate 'line', 10
    $P607 = self."!PREFIX__!subrule"("sigil", "")
    $P608 = self."!PREFIX__!subrule"("sigil", "")
    new $P609, "ResizablePMCArray"
    push $P609, "$!"
    push $P609, "$_"
    push $P609, "$/"
    push $P609, $P607
    push $P609, $P608
    .return ($P609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_855
    rx617_cur."!cursor_debug"("START", "sigil")
  debug_855:
    $I10 = self.'from'()
    ne $I10, -1, rxscan620_done
    goto rxscan620_scan
  rxscan620_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan620_done
  rxscan620_scan:
    set_addr $I10, rxscan620_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan620_done:
.annotate 'line', 307
  # rx enumcharlist negate=0 
    ge rx617_pos, rx617_eos, rx617_fail
    sub $I10, rx617_pos, rx617_off
    substr $S10, rx617_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx617_fail
    inc rx617_pos
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "sigil")
    if_null rx617_debug, debug_856
    rx617_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx617_pos)
  debug_856:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_857
    rx617_cur."!cursor_debug"("NEXT", "sigil")
  debug_857:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_858
    rx617_cur."!cursor_debug"("FAIL", "sigil")
  debug_858:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303430322.161") :method
.annotate 'line', 10
    new $P619, "ResizablePMCArray"
    push $P619, "&"
    push $P619, "%"
    push $P619, "@"
    push $P619, "$"
    .return ($P619)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx622_tgt
    .local int rx622_pos
    .local int rx622_off
    .local int rx622_eos
    .local int rx622_rep
    .local pmc rx622_cur
    .local pmc rx622_debug
    (rx622_cur, rx622_pos, rx622_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx622_cur
    .local pmc match
    .lex "$/", match
    length rx622_eos, rx622_tgt
    gt rx622_pos, rx622_eos, rx622_done
    set rx622_off, 0
    lt rx622_pos, 2, rx622_start
    sub rx622_off, rx622_pos, 1
    substr rx622_tgt, rx622_tgt, rx622_off
  rx622_start:
    eq $I10, 1, rx622_restart
    if_null rx622_debug, debug_859
    rx622_cur."!cursor_debug"("START", "twigil")
  debug_859:
    $I10 = self.'from'()
    ne $I10, -1, rxscan625_done
    goto rxscan625_scan
  rxscan625_loop:
    (rx622_pos) = rx622_cur."from"()
    inc rx622_pos
    rx622_cur."!cursor_from"(rx622_pos)
    ge rx622_pos, rx622_eos, rxscan625_done
  rxscan625_scan:
    set_addr $I10, rxscan625_loop
    rx622_cur."!mark_push"(0, rx622_pos, $I10)
  rxscan625_done:
.annotate 'line', 309
  # rx enumcharlist negate=0 
    ge rx622_pos, rx622_eos, rx622_fail
    sub $I10, rx622_pos, rx622_off
    substr $S10, rx622_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx622_fail
    inc rx622_pos
  # rx pass
    rx622_cur."!cursor_pass"(rx622_pos, "twigil")
    if_null rx622_debug, debug_860
    rx622_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx622_pos)
  debug_860:
    .return (rx622_cur)
  rx622_restart:
.annotate 'line', 10
    if_null rx622_debug, debug_861
    rx622_cur."!cursor_debug"("NEXT", "twigil")
  debug_861:
  rx622_fail:
    (rx622_rep, rx622_pos, $I10, $P10) = rx622_cur."!mark_fail"(0)
    lt rx622_pos, -1, rx622_done
    eq rx622_pos, -1, rx622_fail
    jump $I10
  rx622_done:
    rx622_cur."!cursor_fail"()
    if_null rx622_debug, debug_862
    rx622_cur."!cursor_debug"("FAIL", "twigil")
  debug_862:
    .return (rx622_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303430322.161") :method
.annotate 'line', 10
    new $P624, "ResizablePMCArray"
    push $P624, "?"
    push $P624, "!"
    push $P624, "*"
    .return ($P624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303430322.161")
    .param pmc param_627
.annotate 'line', 311
    .lex "self", param_627
    $P628 = param_627."!protoregex"("package_declarator")
    .return ($P628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303430322.161")
    .param pmc param_630
.annotate 'line', 311
    .lex "self", param_630
    $P631 = param_630."!PREFIX__!protoregex"("package_declarator")
    .return ($P631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 313
    new $P633, "Undef"
    .lex "$*OUTERPACKAGE", $P633
.annotate 'line', 314
    new $P634, "Undef"
    .lex "$*PACKAGE-SETUP", $P634
.annotate 'line', 315
    new $P635, "Undef"
    .lex "$*PKGDECL", $P635
.annotate 'line', 10
    .local string rx636_tgt
    .local int rx636_pos
    .local int rx636_off
    .local int rx636_eos
    .local int rx636_rep
    .local pmc rx636_cur
    .local pmc rx636_debug
    (rx636_cur, rx636_pos, rx636_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx636_cur
    .local pmc match
    .lex "$/", match
    length rx636_eos, rx636_tgt
    gt rx636_pos, rx636_eos, rx636_done
    set rx636_off, 0
    lt rx636_pos, 2, rx636_start
    sub rx636_off, rx636_pos, 1
    substr rx636_tgt, rx636_tgt, rx636_off
  rx636_start:
    eq $I10, 1, rx636_restart
    if_null rx636_debug, debug_863
    rx636_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_863:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx636_pos) = rx636_cur."from"()
    inc rx636_pos
    rx636_cur."!cursor_from"(rx636_pos)
    ge rx636_pos, rx636_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxscan640_done:
.annotate 'line', 313
    rx636_cur."!cursor_pos"(rx636_pos)
    find_dynamic_lex $P641, "$*PACKAGE"
    unless_null $P641, vivify_864
    get_hll_global $P641, "$PACKAGE"
    unless_null $P641, vivify_865
    die "Contextual $*PACKAGE not found"
  vivify_865:
  vivify_864:
    store_lex "$*OUTERPACKAGE", $P641
.annotate 'line', 314
    rx636_cur."!cursor_pos"(rx636_pos)
    get_hll_global $P642, ["PAST"], "Stmts"
    $P643 = $P642."new"()
    store_lex "$*PACKAGE-SETUP", $P643
.annotate 'line', 315
    rx636_cur."!cursor_pos"(rx636_pos)
    new $P644, "String"
    assign $P644, "module"
    store_lex "$*PKGDECL", $P644
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_645_fail
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  # rx literal  "module"
    add $I11, rx636_pos, 6
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 6
    ne $S10, "module", rx636_fail
    add rx636_pos, 6
    set_addr $I10, rxcap_645_fail
    ($I12, $I11) = rx636_cur."!mark_peek"($I10)
    rx636_cur."!cursor_pos"($I11)
    ($P10) = rx636_cur."!cursor_start"()
    $P10."!cursor_pass"(rx636_pos, "")
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_645_done
  rxcap_645_fail:
    goto rx636_fail
  rxcap_645_done:
  # rx subrule "package_def" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."package_def"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx636_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx636_cur."!cursor_pass"(rx636_pos, "package_declarator:sym<module>")
    if_null rx636_debug, debug_866
    rx636_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx636_pos)
  debug_866:
    .return (rx636_cur)
  rx636_restart:
.annotate 'line', 10
    if_null rx636_debug, debug_867
    rx636_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_867:
  rx636_fail:
    (rx636_rep, rx636_pos, $I10, $P10) = rx636_cur."!mark_fail"(0)
    lt rx636_pos, -1, rx636_done
    eq rx636_pos, -1, rx636_fail
    jump $I10
  rx636_done:
    rx636_cur."!cursor_fail"()
    if_null rx636_debug, debug_868
    rx636_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_868:
    .return (rx636_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303430322.161") :method
.annotate 'line', 10
    $P638 = self."!PREFIX__!subrule"("package_def", "module")
    new $P639, "ResizablePMCArray"
    push $P639, $P638
    .return ($P639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 319
    new $P647, "Undef"
    .lex "$*OUTERPACKAGE", $P647
.annotate 'line', 320
    new $P648, "Undef"
    .lex "$*PACKAGE-SETUP", $P648
.annotate 'line', 321
    new $P649, "Undef"
    .lex "$*PKGDECL", $P649
.annotate 'line', 10
    .local string rx650_tgt
    .local int rx650_pos
    .local int rx650_off
    .local int rx650_eos
    .local int rx650_rep
    .local pmc rx650_cur
    .local pmc rx650_debug
    (rx650_cur, rx650_pos, rx650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx650_cur
    .local pmc match
    .lex "$/", match
    length rx650_eos, rx650_tgt
    gt rx650_pos, rx650_eos, rx650_done
    set rx650_off, 0
    lt rx650_pos, 2, rx650_start
    sub rx650_off, rx650_pos, 1
    substr rx650_tgt, rx650_tgt, rx650_off
  rx650_start:
    eq $I10, 1, rx650_restart
    if_null rx650_debug, debug_869
    rx650_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan654_done
    goto rxscan654_scan
  rxscan654_loop:
    (rx650_pos) = rx650_cur."from"()
    inc rx650_pos
    rx650_cur."!cursor_from"(rx650_pos)
    ge rx650_pos, rx650_eos, rxscan654_done
  rxscan654_scan:
    set_addr $I10, rxscan654_loop
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxscan654_done:
.annotate 'line', 319
    rx650_cur."!cursor_pos"(rx650_pos)
    find_dynamic_lex $P655, "$*PACKAGE"
    unless_null $P655, vivify_870
    get_hll_global $P655, "$PACKAGE"
    unless_null $P655, vivify_871
    die "Contextual $*PACKAGE not found"
  vivify_871:
  vivify_870:
    store_lex "$*OUTERPACKAGE", $P655
.annotate 'line', 320
    rx650_cur."!cursor_pos"(rx650_pos)
    get_hll_global $P656, ["PAST"], "Stmts"
    $P657 = $P656."new"()
    store_lex "$*PACKAGE-SETUP", $P657
.annotate 'line', 321
    rx650_cur."!cursor_pos"(rx650_pos)
    new $P658, "String"
    assign $P658, "knowhow"
    store_lex "$*PKGDECL", $P658
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_659_fail
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx650_pos, 7
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I11, 7
    ne $S10, "knowhow", rx650_fail
    add rx650_pos, 7
    set_addr $I10, rxcap_659_fail
    ($I12, $I11) = rx650_cur."!mark_peek"($I10)
    rx650_cur."!cursor_pos"($I11)
    ($P10) = rx650_cur."!cursor_start"()
    $P10."!cursor_pass"(rx650_pos, "")
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_659_done
  rxcap_659_fail:
    goto rx650_fail
  rxcap_659_done:
  # rx subrule "package_def" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."package_def"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx650_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx650_cur."!cursor_pass"(rx650_pos, "package_declarator:sym<knowhow>")
    if_null rx650_debug, debug_872
    rx650_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx650_pos)
  debug_872:
    .return (rx650_cur)
  rx650_restart:
.annotate 'line', 10
    if_null rx650_debug, debug_873
    rx650_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_873:
  rx650_fail:
    (rx650_rep, rx650_pos, $I10, $P10) = rx650_cur."!mark_fail"(0)
    lt rx650_pos, -1, rx650_done
    eq rx650_pos, -1, rx650_fail
    jump $I10
  rx650_done:
    rx650_cur."!cursor_fail"()
    if_null rx650_debug, debug_874
    rx650_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_874:
    .return (rx650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303430322.161") :method
.annotate 'line', 10
    $P652 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P653, "ResizablePMCArray"
    push $P653, $P652
    .return ($P653)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 325
    new $P661, "Undef"
    .lex "$*OUTERPACKAGE", $P661
.annotate 'line', 326
    new $P662, "Undef"
    .lex "$*PACKAGE-SETUP", $P662
.annotate 'line', 327
    new $P663, "Undef"
    .lex "$*PKGDECL", $P663
.annotate 'line', 10
    .local string rx664_tgt
    .local int rx664_pos
    .local int rx664_off
    .local int rx664_eos
    .local int rx664_rep
    .local pmc rx664_cur
    .local pmc rx664_debug
    (rx664_cur, rx664_pos, rx664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx664_cur
    .local pmc match
    .lex "$/", match
    length rx664_eos, rx664_tgt
    gt rx664_pos, rx664_eos, rx664_done
    set rx664_off, 0
    lt rx664_pos, 2, rx664_start
    sub rx664_off, rx664_pos, 1
    substr rx664_tgt, rx664_tgt, rx664_off
  rx664_start:
    eq $I10, 1, rx664_restart
    if_null rx664_debug, debug_875
    rx664_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_875:
    $I10 = self.'from'()
    ne $I10, -1, rxscan668_done
    goto rxscan668_scan
  rxscan668_loop:
    (rx664_pos) = rx664_cur."from"()
    inc rx664_pos
    rx664_cur."!cursor_from"(rx664_pos)
    ge rx664_pos, rx664_eos, rxscan668_done
  rxscan668_scan:
    set_addr $I10, rxscan668_loop
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  rxscan668_done:
.annotate 'line', 325
    rx664_cur."!cursor_pos"(rx664_pos)
    find_dynamic_lex $P669, "$*PACKAGE"
    unless_null $P669, vivify_876
    get_hll_global $P669, "$PACKAGE"
    unless_null $P669, vivify_877
    die "Contextual $*PACKAGE not found"
  vivify_877:
  vivify_876:
    store_lex "$*OUTERPACKAGE", $P669
.annotate 'line', 326
    rx664_cur."!cursor_pos"(rx664_pos)
    get_hll_global $P670, ["PAST"], "Stmts"
    $P671 = $P670."new"()
    store_lex "$*PACKAGE-SETUP", $P671
.annotate 'line', 327
    rx664_cur."!cursor_pos"(rx664_pos)
    new $P672, "String"
    assign $P672, "class"
    store_lex "$*PKGDECL", $P672
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_673_fail
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  # rx literal  "class"
    add $I11, rx664_pos, 5
    gt $I11, rx664_eos, rx664_fail
    sub $I11, rx664_pos, rx664_off
    substr $S10, rx664_tgt, $I11, 5
    ne $S10, "class", rx664_fail
    add rx664_pos, 5
    set_addr $I10, rxcap_673_fail
    ($I12, $I11) = rx664_cur."!mark_peek"($I10)
    rx664_cur."!cursor_pos"($I11)
    ($P10) = rx664_cur."!cursor_start"()
    $P10."!cursor_pass"(rx664_pos, "")
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_673_done
  rxcap_673_fail:
    goto rx664_fail
  rxcap_673_done:
  # rx subrule "package_def" subtype=capture negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."package_def"()
    unless $P10, rx664_fail
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx664_pos = $P10."pos"()
.annotate 'line', 324
  # rx pass
    rx664_cur."!cursor_pass"(rx664_pos, "package_declarator:sym<class>")
    if_null rx664_debug, debug_878
    rx664_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx664_pos)
  debug_878:
    .return (rx664_cur)
  rx664_restart:
.annotate 'line', 10
    if_null rx664_debug, debug_879
    rx664_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_879:
  rx664_fail:
    (rx664_rep, rx664_pos, $I10, $P10) = rx664_cur."!mark_fail"(0)
    lt rx664_pos, -1, rx664_done
    eq rx664_pos, -1, rx664_fail
    jump $I10
  rx664_done:
    rx664_cur."!cursor_fail"()
    if_null rx664_debug, debug_880
    rx664_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_880:
    .return (rx664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303430322.161") :method
.annotate 'line', 10
    $P666 = self."!PREFIX__!subrule"("package_def", "class")
    new $P667, "ResizablePMCArray"
    push $P667, $P666
    .return ($P667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 331
    new $P675, "Undef"
    .lex "$*OUTERPACKAGE", $P675
.annotate 'line', 332
    new $P676, "Undef"
    .lex "$*PACKAGE-SETUP", $P676
.annotate 'line', 333
    new $P677, "Undef"
    .lex "$*PKGDECL", $P677
.annotate 'line', 10
    .local string rx678_tgt
    .local int rx678_pos
    .local int rx678_off
    .local int rx678_eos
    .local int rx678_rep
    .local pmc rx678_cur
    .local pmc rx678_debug
    (rx678_cur, rx678_pos, rx678_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx678_cur
    .local pmc match
    .lex "$/", match
    length rx678_eos, rx678_tgt
    gt rx678_pos, rx678_eos, rx678_done
    set rx678_off, 0
    lt rx678_pos, 2, rx678_start
    sub rx678_off, rx678_pos, 1
    substr rx678_tgt, rx678_tgt, rx678_off
  rx678_start:
    eq $I10, 1, rx678_restart
    if_null rx678_debug, debug_881
    rx678_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan682_done
    goto rxscan682_scan
  rxscan682_loop:
    (rx678_pos) = rx678_cur."from"()
    inc rx678_pos
    rx678_cur."!cursor_from"(rx678_pos)
    ge rx678_pos, rx678_eos, rxscan682_done
  rxscan682_scan:
    set_addr $I10, rxscan682_loop
    rx678_cur."!mark_push"(0, rx678_pos, $I10)
  rxscan682_done:
.annotate 'line', 331
    rx678_cur."!cursor_pos"(rx678_pos)
    find_dynamic_lex $P683, "$*PACKAGE"
    unless_null $P683, vivify_882
    get_hll_global $P683, "$PACKAGE"
    unless_null $P683, vivify_883
    die "Contextual $*PACKAGE not found"
  vivify_883:
  vivify_882:
    store_lex "$*OUTERPACKAGE", $P683
.annotate 'line', 332
    rx678_cur."!cursor_pos"(rx678_pos)
    get_hll_global $P684, ["PAST"], "Stmts"
    $P685 = $P684."new"()
    store_lex "$*PACKAGE-SETUP", $P685
.annotate 'line', 333
    rx678_cur."!cursor_pos"(rx678_pos)
    new $P686, "String"
    assign $P686, "grammar"
    store_lex "$*PKGDECL", $P686
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_687_fail
    rx678_cur."!mark_push"(0, rx678_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx678_pos, 7
    gt $I11, rx678_eos, rx678_fail
    sub $I11, rx678_pos, rx678_off
    substr $S10, rx678_tgt, $I11, 7
    ne $S10, "grammar", rx678_fail
    add rx678_pos, 7
    set_addr $I10, rxcap_687_fail
    ($I12, $I11) = rx678_cur."!mark_peek"($I10)
    rx678_cur."!cursor_pos"($I11)
    ($P10) = rx678_cur."!cursor_start"()
    $P10."!cursor_pass"(rx678_pos, "")
    rx678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_687_done
  rxcap_687_fail:
    goto rx678_fail
  rxcap_687_done:
  # rx subrule "package_def" subtype=capture negate=
    rx678_cur."!cursor_pos"(rx678_pos)
    $P10 = rx678_cur."package_def"()
    unless $P10, rx678_fail
    rx678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx678_pos = $P10."pos"()
.annotate 'line', 330
  # rx pass
    rx678_cur."!cursor_pass"(rx678_pos, "package_declarator:sym<grammar>")
    if_null rx678_debug, debug_884
    rx678_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx678_pos)
  debug_884:
    .return (rx678_cur)
  rx678_restart:
.annotate 'line', 10
    if_null rx678_debug, debug_885
    rx678_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_885:
  rx678_fail:
    (rx678_rep, rx678_pos, $I10, $P10) = rx678_cur."!mark_fail"(0)
    lt rx678_pos, -1, rx678_done
    eq rx678_pos, -1, rx678_fail
    jump $I10
  rx678_done:
    rx678_cur."!cursor_fail"()
    if_null rx678_debug, debug_886
    rx678_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_886:
    .return (rx678_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303430322.161") :method
.annotate 'line', 10
    $P680 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P681, "ResizablePMCArray"
    push $P681, $P680
    .return ($P681)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 337
    new $P689, "Undef"
    .lex "$*OUTERPACKAGE", $P689
.annotate 'line', 338
    new $P690, "Undef"
    .lex "$*PACKAGE-SETUP", $P690
.annotate 'line', 339
    new $P691, "Undef"
    .lex "$*PKGDECL", $P691
.annotate 'line', 10
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_887
    rx692_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_887:
    $I10 = self.'from'()
    ne $I10, -1, rxscan696_done
    goto rxscan696_scan
  rxscan696_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan696_done
  rxscan696_scan:
    set_addr $I10, rxscan696_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan696_done:
.annotate 'line', 337
    rx692_cur."!cursor_pos"(rx692_pos)
    find_dynamic_lex $P697, "$*PACKAGE"
    unless_null $P697, vivify_888
    get_hll_global $P697, "$PACKAGE"
    unless_null $P697, vivify_889
    die "Contextual $*PACKAGE not found"
  vivify_889:
  vivify_888:
    store_lex "$*OUTERPACKAGE", $P697
.annotate 'line', 338
    rx692_cur."!cursor_pos"(rx692_pos)
    get_hll_global $P698, ["PAST"], "Stmts"
    $P699 = $P698."new"()
    store_lex "$*PACKAGE-SETUP", $P699
.annotate 'line', 339
    rx692_cur."!cursor_pos"(rx692_pos)
    new $P700, "String"
    assign $P700, "role"
    store_lex "$*PKGDECL", $P700
.annotate 'line', 340
  # rx subcapture "sym"
    set_addr $I10, rxcap_701_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "role"
    add $I11, rx692_pos, 4
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I11, 4
    ne $S10, "role", rx692_fail
    add rx692_pos, 4
    set_addr $I10, rxcap_701_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_701_done
  rxcap_701_fail:
    goto rx692_fail
  rxcap_701_done:
  # rx subrule "package_def" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."package_def"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx692_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "package_declarator:sym<role>")
    if_null rx692_debug, debug_890
    rx692_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx692_pos)
  debug_890:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 10
    if_null rx692_debug, debug_891
    rx692_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_891:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_892
    rx692_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_892:
    .return (rx692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303430322.161") :method
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("package_def", "role")
    new $P695, "ResizablePMCArray"
    push $P695, $P694
    .return ($P695)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 343
    new $P703, "Undef"
    .lex "$*OUTERPACKAGE", $P703
.annotate 'line', 344
    new $P704, "Undef"
    .lex "$*PACKAGE-SETUP", $P704
.annotate 'line', 345
    new $P705, "Undef"
    .lex "$*PKGDECL", $P705
.annotate 'line', 10
    .local string rx706_tgt
    .local int rx706_pos
    .local int rx706_off
    .local int rx706_eos
    .local int rx706_rep
    .local pmc rx706_cur
    .local pmc rx706_debug
    (rx706_cur, rx706_pos, rx706_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx706_cur
    .local pmc match
    .lex "$/", match
    length rx706_eos, rx706_tgt
    gt rx706_pos, rx706_eos, rx706_done
    set rx706_off, 0
    lt rx706_pos, 2, rx706_start
    sub rx706_off, rx706_pos, 1
    substr rx706_tgt, rx706_tgt, rx706_off
  rx706_start:
    eq $I10, 1, rx706_restart
    if_null rx706_debug, debug_893
    rx706_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan710_done
    goto rxscan710_scan
  rxscan710_loop:
    (rx706_pos) = rx706_cur."from"()
    inc rx706_pos
    rx706_cur."!cursor_from"(rx706_pos)
    ge rx706_pos, rx706_eos, rxscan710_done
  rxscan710_scan:
    set_addr $I10, rxscan710_loop
    rx706_cur."!mark_push"(0, rx706_pos, $I10)
  rxscan710_done:
.annotate 'line', 343
    rx706_cur."!cursor_pos"(rx706_pos)
    find_dynamic_lex $P711, "$*PACKAGE"
    unless_null $P711, vivify_894
    get_hll_global $P711, "$PACKAGE"
    unless_null $P711, vivify_895
    die "Contextual $*PACKAGE not found"
  vivify_895:
  vivify_894:
    store_lex "$*OUTERPACKAGE", $P711
.annotate 'line', 344
    rx706_cur."!cursor_pos"(rx706_pos)
    get_hll_global $P712, ["PAST"], "Stmts"
    $P713 = $P712."new"()
    store_lex "$*PACKAGE-SETUP", $P713
.annotate 'line', 345
    rx706_cur."!cursor_pos"(rx706_pos)
    new $P714, "String"
    assign $P714, "native"
    store_lex "$*PKGDECL", $P714
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_715_fail
    rx706_cur."!mark_push"(0, rx706_pos, $I10)
  # rx literal  "native"
    add $I11, rx706_pos, 6
    gt $I11, rx706_eos, rx706_fail
    sub $I11, rx706_pos, rx706_off
    substr $S10, rx706_tgt, $I11, 6
    ne $S10, "native", rx706_fail
    add rx706_pos, 6
    set_addr $I10, rxcap_715_fail
    ($I12, $I11) = rx706_cur."!mark_peek"($I10)
    rx706_cur."!cursor_pos"($I11)
    ($P10) = rx706_cur."!cursor_start"()
    $P10."!cursor_pass"(rx706_pos, "")
    rx706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_715_done
  rxcap_715_fail:
    goto rx706_fail
  rxcap_715_done:
  # rx subrule "package_def" subtype=capture negate=
    rx706_cur."!cursor_pos"(rx706_pos)
    $P10 = rx706_cur."package_def"()
    unless $P10, rx706_fail
    rx706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx706_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx706_cur."!cursor_pass"(rx706_pos, "package_declarator:sym<native>")
    if_null rx706_debug, debug_896
    rx706_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx706_pos)
  debug_896:
    .return (rx706_cur)
  rx706_restart:
.annotate 'line', 10
    if_null rx706_debug, debug_897
    rx706_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_897:
  rx706_fail:
    (rx706_rep, rx706_pos, $I10, $P10) = rx706_cur."!mark_fail"(0)
    lt rx706_pos, -1, rx706_done
    eq rx706_pos, -1, rx706_fail
    jump $I10
  rx706_done:
    rx706_cur."!cursor_fail"()
    if_null rx706_debug, debug_898
    rx706_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_898:
    .return (rx706_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303430322.161") :method
.annotate 'line', 10
    $P708 = self."!PREFIX__!subrule"("package_def", "native")
    new $P709, "ResizablePMCArray"
    push $P709, $P708
    .return ($P709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P740 = "154_1303430322.161" 
    capture_lex $P740
.annotate 'line', 350
    new $P717, "Undef"
    .lex "$*PACKAGE", $P717
.annotate 'line', 351
    $P718 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P718
.annotate 'line', 10
    .local string rx719_tgt
    .local int rx719_pos
    .local int rx719_off
    .local int rx719_eos
    .local int rx719_rep
    .local pmc rx719_cur
    .local pmc rx719_debug
    (rx719_cur, rx719_pos, rx719_tgt, $I10) = self."!cursor_start"()
    rx719_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx719_cur
    .local pmc match
    .lex "$/", match
    length rx719_eos, rx719_tgt
    gt rx719_pos, rx719_eos, rx719_done
    set rx719_off, 0
    lt rx719_pos, 2, rx719_start
    sub rx719_off, rx719_pos, 1
    substr rx719_tgt, rx719_tgt, rx719_off
  rx719_start:
    eq $I10, 1, rx719_restart
    if_null rx719_debug, debug_899
    rx719_cur."!cursor_debug"("START", "package_def")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan723_done
    goto rxscan723_scan
  rxscan723_loop:
    (rx719_pos) = rx719_cur."from"()
    inc rx719_pos
    rx719_cur."!cursor_from"(rx719_pos)
    ge rx719_pos, rx719_eos, rxscan723_done
  rxscan723_scan:
    set_addr $I10, rxscan723_loop
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxscan723_done:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 350
    rx719_cur."!cursor_pos"(rx719_pos)
    find_lex $P725, "$*PACKAGE"
    unless_null $P725, vivify_900
    get_hll_global $P725, "$PACKAGE"
    unless_null $P725, vivify_901
    die "Contextual $*PACKAGE not found"
  vivify_901:
  vivify_900:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 351
    rx719_cur."!cursor_pos"(rx719_pos)
    find_lex $P727, "%*ATTR-CHECK"
    unless_null $P727, vivify_902
    get_hll_global $P727, "%ATTR-CHECK"
    unless_null $P727, vivify_903
    die "Contextual %*ATTR-CHECK not found"
  vivify_903:
  vivify_902:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 353
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr730 ** 0..1
    set_addr $I10, rxquantr730_done
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxquantr730_loop:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx719_pos, 2
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 2
    ne $S10, "is", rx719_fail
    add rx719_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx719_pos, 5
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 5
    ne $S10, "repr(", rx719_fail
    add rx719_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."quote_EXPR"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx719_pos, 1
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    ord $I11, rx719_tgt, $I11
    ne $I11, 41, rx719_fail
    add rx719_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    set_addr $I10, rxquantr730_done
    (rx719_rep) = rx719_cur."!mark_commit"($I10)
  rxquantr730_done:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 356
    rx719_cur."!cursor_pos"(rx719_pos)
    find_lex $P737, unicode:"$\x{a2}"
    $P738 = $P737."MATCH"()
    store_lex "$/", $P738
    .const 'Sub' $P740 = "154_1303430322.161" 
    capture_lex $P740
    $P830 = $P740()
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 384
  # rx rxquantr832 ** 0..1
    set_addr $I10, rxquantr832_done
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxquantr832_loop:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx719_pos, 2
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 2
    ne $S10, "is", rx719_fail
    add rx719_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    set_addr $I10, rxquantr832_done
    (rx719_rep) = rx719_cur."!mark_commit"($I10)
  rxquantr832_done:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 385
  # rx rxquantr837 ** 0..*
    set_addr $I10, rxquantr837_done
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxquantr837_loop:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx719_pos, 4
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 4
    ne $S10, "does", rx719_fail
    add rx719_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    set_addr $I10, rxquantr837_done
    (rx719_rep) = rx719_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr837_done
    rx719_cur."!mark_push"(rx719_rep, rx719_pos, $I10)
    goto rxquantr837_loop
  rxquantr837_done:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  alt842_0:
.annotate 'line', 386
    set_addr $I10, alt842_1
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx719_pos, 1
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    ord $I11, rx719_tgt, $I11
    ne $I11, 59, rx719_fail
    add rx719_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."comp_unit"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    goto alt842_end
  alt842_1:
    set_addr $I10, alt842_2
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx719_fail
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."block"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    goto alt842_end
  alt842_2:
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."panic"("Malformed package declaration")
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  alt842_end:
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 349
  # rx pass
    rx719_cur."!cursor_pass"(rx719_pos, "package_def")
    if_null rx719_debug, debug_971
    rx719_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx719_pos)
  debug_971:
    .return (rx719_cur)
  rx719_restart:
.annotate 'line', 10
    if_null rx719_debug, debug_972
    rx719_cur."!cursor_debug"("NEXT", "package_def")
  debug_972:
  rx719_fail:
    (rx719_rep, rx719_pos, $I10, $P10) = rx719_cur."!mark_fail"(0)
    lt rx719_pos, -1, rx719_done
    eq rx719_pos, -1, rx719_fail
    jump $I10
  rx719_done:
    rx719_cur."!cursor_fail"()
    if_null rx719_debug, debug_973
    rx719_cur."!cursor_debug"("FAIL", "package_def")
  debug_973:
    .return (rx719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303430322.161") :method
.annotate 'line', 10
    $P721 = self."!PREFIX__!subrule"("ws", "")
    new $P722, "ResizablePMCArray"
    push $P722, $P721
    .return ($P722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block739"  :anon :subid("154_1303430322.161") :outer("152_1303430322.161")
.annotate 'line', 359
    $P741 = root_new ['parrot';'Hash']
    .lex "%args", $P741
.annotate 'line', 356
    find_lex $P742, "%args"
    unless_null $P742, vivify_904
    $P742 = root_new ['parrot';'Hash']
  vivify_904:
.annotate 'line', 360
    find_lex $P743, "$/"
    unless_null $P743, vivify_905
    $P743 = root_new ['parrot';'Hash']
  vivify_905:
    set $P744, $P743["name"]
    unless_null $P744, vivify_906
    new $P744, "Undef"
  vivify_906:
    set $S745, $P744
    new $P746, 'String'
    set $P746, $S745
    find_lex $P747, "%args"
    unless_null $P747, vivify_907
    $P747 = root_new ['parrot';'Hash']
    store_lex "%args", $P747
  vivify_907:
    set $P747["name"], $P746
.annotate 'line', 361
    find_lex $P749, "$/"
    unless_null $P749, vivify_908
    $P749 = root_new ['parrot';'Hash']
  vivify_908:
    set $P750, $P749["repr"]
    unless_null $P750, vivify_909
    new $P750, "Undef"
  vivify_909:
    unless $P750, if_748_end
.annotate 'line', 362
    find_lex $P751, "$/"
    unless_null $P751, vivify_910
    $P751 = root_new ['parrot';'Hash']
  vivify_910:
    set $P752, $P751["repr"]
    unless_null $P752, vivify_911
    $P752 = root_new ['parrot';'ResizablePMCArray']
  vivify_911:
    set $P753, $P752[0]
    unless_null $P753, vivify_912
    $P753 = root_new ['parrot';'Hash']
  vivify_912:
    set $P754, $P753["quote_delimited"]
    unless_null $P754, vivify_913
    $P754 = root_new ['parrot';'Hash']
  vivify_913:
    set $P755, $P754["quote_atom"]
    unless_null $P755, vivify_914
    $P755 = root_new ['parrot';'ResizablePMCArray']
  vivify_914:
    set $P756, $P755[0]
    unless_null $P756, vivify_915
    new $P756, "Undef"
  vivify_915:
    set $S757, $P756
    new $P758, 'String'
    set $P758, $S757
    find_lex $P759, "%args"
    unless_null $P759, vivify_916
    $P759 = root_new ['parrot';'Hash']
    store_lex "%args", $P759
  vivify_916:
    set $P759["repr"], $P758
  if_748_end:
.annotate 'line', 364
    find_dynamic_lex $P760, "$*SC"
    unless_null $P760, vivify_917
    get_hll_global $P760, "$SC"
    unless_null $P760, vivify_918
    die "Contextual $*SC not found"
  vivify_918:
  vivify_917:
    find_dynamic_lex $P761, "$*PKGDECL"
    unless_null $P761, vivify_919
    get_hll_global $P761, "$PKGDECL"
    unless_null $P761, vivify_920
    die "Contextual $*PKGDECL not found"
  vivify_920:
  vivify_919:
    find_dynamic_lex $P762, "%*HOW"
    unless_null $P762, vivify_921
    get_hll_global $P762, "%HOW"
    unless_null $P762, vivify_922
    die "Contextual %*HOW not found"
  vivify_922:
  vivify_921:
    set $P763, $P762[$P761]
    unless_null $P763, vivify_923
    new $P763, "Undef"
  vivify_923:
    find_lex $P764, "%args"
    unless_null $P764, vivify_924
    $P764 = root_new ['parrot';'Hash']
  vivify_924:
    $P765 = $P760."pkg_create_mo"($P763, $P764 :flat)
    store_dynamic_lex "$*PACKAGE", $P765
.annotate 'line', 367
    find_dynamic_lex $P770, "$*SCOPE"
    unless_null $P770, vivify_925
    get_hll_global $P770, "$SCOPE"
    unless_null $P770, vivify_926
    die "Contextual $*SCOPE not found"
  vivify_926:
  vivify_925:
    set $S771, $P770
    iseq $I772, $S771, "our"
    unless $I772, unless_769
    new $P768, 'Integer'
    set $P768, $I772
    goto unless_769_end
  unless_769:
    find_dynamic_lex $P773, "$*SCOPE"
    unless_null $P773, vivify_927
    get_hll_global $P773, "$SCOPE"
    unless_null $P773, vivify_928
    die "Contextual $*SCOPE not found"
  vivify_928:
  vivify_927:
    set $S774, $P773
    iseq $I775, $S774, ""
    new $P768, 'Integer'
    set $P768, $I775
  unless_769_end:
    if $P768, if_767
.annotate 'line', 373
    find_dynamic_lex $P802, "$*SCOPE"
    unless_null $P802, vivify_929
    get_hll_global $P802, "$SCOPE"
    unless_null $P802, vivify_930
    die "Contextual $*SCOPE not found"
  vivify_930:
  vivify_929:
    set $S803, $P802
    iseq $I804, $S803, "my"
    if $I804, if_801
.annotate 'line', 380
    find_lex $P825, "$/"
    unless_null $P825, vivify_931
    new $P825, "Undef"
  vivify_931:
    $P826 = $P825."CURSOR"()
    find_dynamic_lex $P827, "$*SCOPE"
    unless_null $P827, vivify_932
    get_hll_global $P827, "$SCOPE"
    unless_null $P827, vivify_933
    die "Contextual $*SCOPE not found"
  vivify_933:
  vivify_932:
    concat $P828, $P827, " scoped packages are not supported"
    $P829 = $P826."panic"($P828)
.annotate 'line', 379
    set $P800, $P829
.annotate 'line', 373
    goto if_801_end
  if_801:
.annotate 'line', 374
    find_lex $P806, "$/"
    unless_null $P806, vivify_934
    $P806 = root_new ['parrot';'Hash']
  vivify_934:
    set $P807, $P806["name"]
    unless_null $P807, vivify_935
    $P807 = root_new ['parrot';'Hash']
  vivify_935:
    set $P808, $P807["identifier"]
    unless_null $P808, vivify_936
    new $P808, "Undef"
  vivify_936:
    set $N809, $P808
    isne $I810, $N809, 1.0
    unless $I810, if_805_end
.annotate 'line', 375
    find_lex $P811, "$/"
    unless_null $P811, vivify_937
    $P811 = root_new ['parrot';'Hash']
  vivify_937:
    set $P812, $P811["name"]
    unless_null $P812, vivify_938
    new $P812, "Undef"
  vivify_938:
    $P813 = $P812."CURSOR"()
    $P813."panic"("A my scoped package cannot have a multi-part name yet")
  if_805_end:
.annotate 'line', 377
    find_dynamic_lex $P814, "$*SC"
    unless_null $P814, vivify_939
    get_hll_global $P814, "$SC"
    unless_null $P814, vivify_940
    die "Contextual $*SC not found"
  vivify_940:
  vivify_939:
    get_hll_global $P815, ["NQP"], "Actions"
    get_who $P816, $P815
    set $P817, $P816["@BLOCK"]
    unless_null $P817, vivify_941
    $P817 = root_new ['parrot';'ResizablePMCArray']
  vivify_941:
    set $P818, $P817[0]
    unless_null $P818, vivify_942
    new $P818, "Undef"
  vivify_942:
    find_lex $P819, "$/"
    unless_null $P819, vivify_943
    $P819 = root_new ['parrot';'Hash']
  vivify_943:
    set $P820, $P819["name"]
    unless_null $P820, vivify_944
    $P820 = root_new ['parrot';'Hash']
  vivify_944:
    set $P821, $P820["identifier"]
    unless_null $P821, vivify_945
    $P821 = root_new ['parrot';'ResizablePMCArray']
  vivify_945:
    set $P822, $P821[0]
    unless_null $P822, vivify_946
    new $P822, "Undef"
  vivify_946:
    find_dynamic_lex $P823, "$*PACKAGE"
    unless_null $P823, vivify_947
    get_hll_global $P823, "$PACKAGE"
    unless_null $P823, vivify_948
    die "Contextual $*PACKAGE not found"
  vivify_948:
  vivify_947:
    $P824 = $P814."install_lexical_symbol"($P818, $P822, $P823)
.annotate 'line', 373
    set $P800, $P824
  if_801_end:
    set $P766, $P800
.annotate 'line', 367
    goto if_767_end
  if_767:
.annotate 'line', 368
    find_dynamic_lex $P776, "$*SC"
    unless_null $P776, vivify_949
    get_hll_global $P776, "$SC"
    unless_null $P776, vivify_950
    die "Contextual $*SC not found"
  vivify_950:
  vivify_949:
    find_dynamic_lex $P777, "$*OUTERPACKAGE"
    unless_null $P777, vivify_951
    get_hll_global $P777, "$OUTERPACKAGE"
    unless_null $P777, vivify_952
    die "Contextual $*OUTERPACKAGE not found"
  vivify_952:
  vivify_951:
    find_lex $P778, "$/"
    unless_null $P778, vivify_953
    $P778 = root_new ['parrot';'Hash']
  vivify_953:
    set $P779, $P778["name"]
    unless_null $P779, vivify_954
    $P779 = root_new ['parrot';'Hash']
  vivify_954:
    set $P780, $P779["identifier"]
    unless_null $P780, vivify_955
    new $P780, "Undef"
  vivify_955:
    find_dynamic_lex $P781, "$*PACKAGE"
    unless_null $P781, vivify_956
    get_hll_global $P781, "$PACKAGE"
    unless_null $P781, vivify_957
    die "Contextual $*PACKAGE not found"
  vivify_957:
  vivify_956:
    $P776."install_package_symbol"($P777, $P780, $P781)
.annotate 'line', 369
    find_lex $P784, "$/"
    unless_null $P784, vivify_958
    $P784 = root_new ['parrot';'Hash']
  vivify_958:
    set $P785, $P784["name"]
    unless_null $P785, vivify_959
    $P785 = root_new ['parrot';'Hash']
  vivify_959:
    set $P786, $P785["identifier"]
    unless_null $P786, vivify_960
    new $P786, "Undef"
  vivify_960:
    set $N787, $P786
    iseq $I788, $N787, 1.0
    if $I788, if_783
    new $P782, 'Integer'
    set $P782, $I788
    goto if_783_end
  if_783:
.annotate 'line', 370
    find_dynamic_lex $P789, "$*SC"
    unless_null $P789, vivify_961
    get_hll_global $P789, "$SC"
    unless_null $P789, vivify_962
    die "Contextual $*SC not found"
  vivify_962:
  vivify_961:
    get_hll_global $P790, ["NQP"], "Actions"
    get_who $P791, $P790
    set $P792, $P791["@BLOCK"]
    unless_null $P792, vivify_963
    $P792 = root_new ['parrot';'ResizablePMCArray']
  vivify_963:
    set $P793, $P792[0]
    unless_null $P793, vivify_964
    new $P793, "Undef"
  vivify_964:
    find_lex $P794, "$/"
    unless_null $P794, vivify_965
    $P794 = root_new ['parrot';'Hash']
  vivify_965:
    set $P795, $P794["name"]
    unless_null $P795, vivify_966
    $P795 = root_new ['parrot';'Hash']
  vivify_966:
    set $P796, $P795["identifier"]
    unless_null $P796, vivify_967
    $P796 = root_new ['parrot';'ResizablePMCArray']
  vivify_967:
    set $P797, $P796[0]
    unless_null $P797, vivify_968
    new $P797, "Undef"
  vivify_968:
    find_dynamic_lex $P798, "$*PACKAGE"
    unless_null $P798, vivify_969
    get_hll_global $P798, "$PACKAGE"
    unless_null $P798, vivify_970
    die "Contextual $*PACKAGE not found"
  vivify_970:
  vivify_969:
    $P799 = $P789."install_lexical_symbol"($P793, $P797, $P798)
.annotate 'line', 369
    set $P782, $P799
  if_783_end:
.annotate 'line', 367
    set $P766, $P782
  if_767_end:
.annotate 'line', 356
    .return ($P766)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303430322.161")
    .param pmc param_853
.annotate 'line', 393
    .lex "self", param_853
    $P854 = param_853."!protoregex"("scope_declarator")
    .return ($P854)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303430322.161")
    .param pmc param_856
.annotate 'line', 393
    .lex "self", param_856
    $P857 = param_856."!PREFIX__!protoregex"("scope_declarator")
    .return ($P857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx859_tgt
    .local int rx859_pos
    .local int rx859_off
    .local int rx859_eos
    .local int rx859_rep
    .local pmc rx859_cur
    .local pmc rx859_debug
    (rx859_cur, rx859_pos, rx859_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx859_cur
    .local pmc match
    .lex "$/", match
    length rx859_eos, rx859_tgt
    gt rx859_pos, rx859_eos, rx859_done
    set rx859_off, 0
    lt rx859_pos, 2, rx859_start
    sub rx859_off, rx859_pos, 1
    substr rx859_tgt, rx859_tgt, rx859_off
  rx859_start:
    eq $I10, 1, rx859_restart
    if_null rx859_debug, debug_974
    rx859_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan863_done
    goto rxscan863_scan
  rxscan863_loop:
    (rx859_pos) = rx859_cur."from"()
    inc rx859_pos
    rx859_cur."!cursor_from"(rx859_pos)
    ge rx859_pos, rx859_eos, rxscan863_done
  rxscan863_scan:
    set_addr $I10, rxscan863_loop
    rx859_cur."!mark_push"(0, rx859_pos, $I10)
  rxscan863_done:
.annotate 'line', 394
  # rx subcapture "sym"
    set_addr $I10, rxcap_864_fail
    rx859_cur."!mark_push"(0, rx859_pos, $I10)
  # rx literal  "my"
    add $I11, rx859_pos, 2
    gt $I11, rx859_eos, rx859_fail
    sub $I11, rx859_pos, rx859_off
    substr $S10, rx859_tgt, $I11, 2
    ne $S10, "my", rx859_fail
    add rx859_pos, 2
    set_addr $I10, rxcap_864_fail
    ($I12, $I11) = rx859_cur."!mark_peek"($I10)
    rx859_cur."!cursor_pos"($I11)
    ($P10) = rx859_cur."!cursor_start"()
    $P10."!cursor_pass"(rx859_pos, "")
    rx859_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_864_done
  rxcap_864_fail:
    goto rx859_fail
  rxcap_864_done:
  # rx subrule "scoped" subtype=capture negate=
    rx859_cur."!cursor_pos"(rx859_pos)
    $P10 = rx859_cur."scoped"("my")
    unless $P10, rx859_fail
    rx859_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx859_pos = $P10."pos"()
  # rx pass
    rx859_cur."!cursor_pass"(rx859_pos, "scope_declarator:sym<my>")
    if_null rx859_debug, debug_975
    rx859_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx859_pos)
  debug_975:
    .return (rx859_cur)
  rx859_restart:
.annotate 'line', 10
    if_null rx859_debug, debug_976
    rx859_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_976:
  rx859_fail:
    (rx859_rep, rx859_pos, $I10, $P10) = rx859_cur."!mark_fail"(0)
    lt rx859_pos, -1, rx859_done
    eq rx859_pos, -1, rx859_fail
    jump $I10
  rx859_done:
    rx859_cur."!cursor_fail"()
    if_null rx859_debug, debug_977
    rx859_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_977:
    .return (rx859_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303430322.161") :method
.annotate 'line', 10
    $P861 = self."!PREFIX__!subrule"("scoped", "my")
    new $P862, "ResizablePMCArray"
    push $P862, $P861
    .return ($P862)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx866_tgt
    .local int rx866_pos
    .local int rx866_off
    .local int rx866_eos
    .local int rx866_rep
    .local pmc rx866_cur
    .local pmc rx866_debug
    (rx866_cur, rx866_pos, rx866_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx866_cur
    .local pmc match
    .lex "$/", match
    length rx866_eos, rx866_tgt
    gt rx866_pos, rx866_eos, rx866_done
    set rx866_off, 0
    lt rx866_pos, 2, rx866_start
    sub rx866_off, rx866_pos, 1
    substr rx866_tgt, rx866_tgt, rx866_off
  rx866_start:
    eq $I10, 1, rx866_restart
    if_null rx866_debug, debug_978
    rx866_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan870_done
    goto rxscan870_scan
  rxscan870_loop:
    (rx866_pos) = rx866_cur."from"()
    inc rx866_pos
    rx866_cur."!cursor_from"(rx866_pos)
    ge rx866_pos, rx866_eos, rxscan870_done
  rxscan870_scan:
    set_addr $I10, rxscan870_loop
    rx866_cur."!mark_push"(0, rx866_pos, $I10)
  rxscan870_done:
.annotate 'line', 395
  # rx subcapture "sym"
    set_addr $I10, rxcap_871_fail
    rx866_cur."!mark_push"(0, rx866_pos, $I10)
  # rx literal  "our"
    add $I11, rx866_pos, 3
    gt $I11, rx866_eos, rx866_fail
    sub $I11, rx866_pos, rx866_off
    substr $S10, rx866_tgt, $I11, 3
    ne $S10, "our", rx866_fail
    add rx866_pos, 3
    set_addr $I10, rxcap_871_fail
    ($I12, $I11) = rx866_cur."!mark_peek"($I10)
    rx866_cur."!cursor_pos"($I11)
    ($P10) = rx866_cur."!cursor_start"()
    $P10."!cursor_pass"(rx866_pos, "")
    rx866_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_871_done
  rxcap_871_fail:
    goto rx866_fail
  rxcap_871_done:
  # rx subrule "scoped" subtype=capture negate=
    rx866_cur."!cursor_pos"(rx866_pos)
    $P10 = rx866_cur."scoped"("our")
    unless $P10, rx866_fail
    rx866_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx866_pos = $P10."pos"()
  # rx pass
    rx866_cur."!cursor_pass"(rx866_pos, "scope_declarator:sym<our>")
    if_null rx866_debug, debug_979
    rx866_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx866_pos)
  debug_979:
    .return (rx866_cur)
  rx866_restart:
.annotate 'line', 10
    if_null rx866_debug, debug_980
    rx866_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_980:
  rx866_fail:
    (rx866_rep, rx866_pos, $I10, $P10) = rx866_cur."!mark_fail"(0)
    lt rx866_pos, -1, rx866_done
    eq rx866_pos, -1, rx866_fail
    jump $I10
  rx866_done:
    rx866_cur."!cursor_fail"()
    if_null rx866_debug, debug_981
    rx866_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_981:
    .return (rx866_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303430322.161") :method
.annotate 'line', 10
    $P868 = self."!PREFIX__!subrule"("scoped", "our")
    new $P869, "ResizablePMCArray"
    push $P869, $P868
    .return ($P869)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx873_tgt
    .local int rx873_pos
    .local int rx873_off
    .local int rx873_eos
    .local int rx873_rep
    .local pmc rx873_cur
    .local pmc rx873_debug
    (rx873_cur, rx873_pos, rx873_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx873_cur
    .local pmc match
    .lex "$/", match
    length rx873_eos, rx873_tgt
    gt rx873_pos, rx873_eos, rx873_done
    set rx873_off, 0
    lt rx873_pos, 2, rx873_start
    sub rx873_off, rx873_pos, 1
    substr rx873_tgt, rx873_tgt, rx873_off
  rx873_start:
    eq $I10, 1, rx873_restart
    if_null rx873_debug, debug_982
    rx873_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan877_done
    goto rxscan877_scan
  rxscan877_loop:
    (rx873_pos) = rx873_cur."from"()
    inc rx873_pos
    rx873_cur."!cursor_from"(rx873_pos)
    ge rx873_pos, rx873_eos, rxscan877_done
  rxscan877_scan:
    set_addr $I10, rxscan877_loop
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxscan877_done:
.annotate 'line', 396
  # rx subcapture "sym"
    set_addr $I10, rxcap_878_fail
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx literal  "has"
    add $I11, rx873_pos, 3
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    substr $S10, rx873_tgt, $I11, 3
    ne $S10, "has", rx873_fail
    add rx873_pos, 3
    set_addr $I10, rxcap_878_fail
    ($I12, $I11) = rx873_cur."!mark_peek"($I10)
    rx873_cur."!cursor_pos"($I11)
    ($P10) = rx873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx873_pos, "")
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_878_done
  rxcap_878_fail:
    goto rx873_fail
  rxcap_878_done:
  # rx subrule "scoped" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."scoped"("has")
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx873_pos = $P10."pos"()
  # rx pass
    rx873_cur."!cursor_pass"(rx873_pos, "scope_declarator:sym<has>")
    if_null rx873_debug, debug_983
    rx873_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx873_pos)
  debug_983:
    .return (rx873_cur)
  rx873_restart:
.annotate 'line', 10
    if_null rx873_debug, debug_984
    rx873_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_984:
  rx873_fail:
    (rx873_rep, rx873_pos, $I10, $P10) = rx873_cur."!mark_fail"(0)
    lt rx873_pos, -1, rx873_done
    eq rx873_pos, -1, rx873_fail
    jump $I10
  rx873_done:
    rx873_cur."!cursor_fail"()
    if_null rx873_debug, debug_985
    rx873_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_985:
    .return (rx873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303430322.161") :method
.annotate 'line', 10
    $P875 = self."!PREFIX__!subrule"("scoped", "has")
    new $P876, "ResizablePMCArray"
    push $P876, $P875
    .return ($P876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303430322.161") :method :outer("12_1303430322.161")
    .param pmc param_880
.annotate 'line', 398
    .lex "$*SCOPE", param_880
.annotate 'line', 10
    .local string rx881_tgt
    .local int rx881_pos
    .local int rx881_off
    .local int rx881_eos
    .local int rx881_rep
    .local pmc rx881_cur
    .local pmc rx881_debug
    (rx881_cur, rx881_pos, rx881_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx881_cur
    .local pmc match
    .lex "$/", match
    length rx881_eos, rx881_tgt
    gt rx881_pos, rx881_eos, rx881_done
    set rx881_off, 0
    lt rx881_pos, 2, rx881_start
    sub rx881_off, rx881_pos, 1
    substr rx881_tgt, rx881_tgt, rx881_off
  rx881_start:
    eq $I10, 1, rx881_restart
    if_null rx881_debug, debug_986
    rx881_cur."!cursor_debug"("START", "scoped")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan887_done
    goto rxscan887_scan
  rxscan887_loop:
    (rx881_pos) = rx881_cur."from"()
    inc rx881_pos
    rx881_cur."!cursor_from"(rx881_pos)
    ge rx881_pos, rx881_eos, rxscan887_done
  rxscan887_scan:
    set_addr $I10, rxscan887_loop
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxscan887_done:
  alt888_0:
.annotate 'line', 398
    set_addr $I10, alt888_1
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
.annotate 'line', 399
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."declarator"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
    goto alt888_end
  alt888_1:
    set_addr $I10, alt888_2
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
.annotate 'line', 400
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."multi_declarator"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
    goto alt888_end
  alt888_2:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."package_declarator"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  alt888_end:
.annotate 'line', 398
  # rx pass
    rx881_cur."!cursor_pass"(rx881_pos, "scoped")
    if_null rx881_debug, debug_987
    rx881_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx881_pos)
  debug_987:
    .return (rx881_cur)
  rx881_restart:
.annotate 'line', 10
    if_null rx881_debug, debug_988
    rx881_cur."!cursor_debug"("NEXT", "scoped")
  debug_988:
  rx881_fail:
    (rx881_rep, rx881_pos, $I10, $P10) = rx881_cur."!mark_fail"(0)
    lt rx881_pos, -1, rx881_done
    eq rx881_pos, -1, rx881_fail
    jump $I10
  rx881_done:
    rx881_cur."!cursor_fail"()
    if_null rx881_debug, debug_989
    rx881_cur."!cursor_debug"("FAIL", "scoped")
  debug_989:
    .return (rx881_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303430322.161") :method
.annotate 'line', 10
    $P883 = self."!PREFIX__!subrule"("ws", "")
    $P884 = self."!PREFIX__!subrule"("ws", "")
    $P885 = self."!PREFIX__!subrule"("ws", "")
    new $P886, "ResizablePMCArray"
    push $P886, $P883
    push $P886, $P884
    push $P886, $P885
    .return ($P886)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx896_tgt
    .local int rx896_pos
    .local int rx896_off
    .local int rx896_eos
    .local int rx896_rep
    .local pmc rx896_cur
    .local pmc rx896_debug
    (rx896_cur, rx896_pos, rx896_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx896_cur
    .local pmc match
    .lex "$/", match
    length rx896_eos, rx896_tgt
    gt rx896_pos, rx896_eos, rx896_done
    set rx896_off, 0
    lt rx896_pos, 2, rx896_start
    sub rx896_off, rx896_pos, 1
    substr rx896_tgt, rx896_tgt, rx896_off
  rx896_start:
    eq $I10, 1, rx896_restart
    if_null rx896_debug, debug_990
    rx896_cur."!cursor_debug"("START", "typename")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan900_done
    goto rxscan900_scan
  rxscan900_loop:
    (rx896_pos) = rx896_cur."from"()
    inc rx896_pos
    rx896_cur."!cursor_from"(rx896_pos)
    ge rx896_pos, rx896_eos, rxscan900_done
  rxscan900_scan:
    set_addr $I10, rxscan900_loop
    rx896_cur."!mark_push"(0, rx896_pos, $I10)
  rxscan900_done:
.annotate 'line', 404
  # rx subrule "name" subtype=capture negate=
    rx896_cur."!cursor_pos"(rx896_pos)
    $P10 = rx896_cur."name"()
    unless $P10, rx896_fail
    rx896_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx896_pos = $P10."pos"()
  # rx pass
    rx896_cur."!cursor_pass"(rx896_pos, "typename")
    if_null rx896_debug, debug_991
    rx896_cur."!cursor_debug"("PASS", "typename", " at pos=", rx896_pos)
  debug_991:
    .return (rx896_cur)
  rx896_restart:
.annotate 'line', 10
    if_null rx896_debug, debug_992
    rx896_cur."!cursor_debug"("NEXT", "typename")
  debug_992:
  rx896_fail:
    (rx896_rep, rx896_pos, $I10, $P10) = rx896_cur."!mark_fail"(0)
    lt rx896_pos, -1, rx896_done
    eq rx896_pos, -1, rx896_fail
    jump $I10
  rx896_done:
    rx896_cur."!cursor_fail"()
    if_null rx896_debug, debug_993
    rx896_cur."!cursor_debug"("FAIL", "typename")
  debug_993:
    .return (rx896_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303430322.161") :method
.annotate 'line', 10
    $P898 = self."!PREFIX__!subrule"("name", "")
    new $P899, "ResizablePMCArray"
    push $P899, $P898
    .return ($P899)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx902_tgt
    .local int rx902_pos
    .local int rx902_off
    .local int rx902_eos
    .local int rx902_rep
    .local pmc rx902_cur
    .local pmc rx902_debug
    (rx902_cur, rx902_pos, rx902_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx902_cur
    .local pmc match
    .lex "$/", match
    length rx902_eos, rx902_tgt
    gt rx902_pos, rx902_eos, rx902_done
    set rx902_off, 0
    lt rx902_pos, 2, rx902_start
    sub rx902_off, rx902_pos, 1
    substr rx902_tgt, rx902_tgt, rx902_off
  rx902_start:
    eq $I10, 1, rx902_restart
    if_null rx902_debug, debug_994
    rx902_cur."!cursor_debug"("START", "declarator")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan907_done
    goto rxscan907_scan
  rxscan907_loop:
    (rx902_pos) = rx902_cur."from"()
    inc rx902_pos
    rx902_cur."!cursor_from"(rx902_pos)
    ge rx902_pos, rx902_eos, rxscan907_done
  rxscan907_scan:
    set_addr $I10, rxscan907_loop
    rx902_cur."!mark_push"(0, rx902_pos, $I10)
  rxscan907_done:
  alt908_0:
.annotate 'line', 406
    set_addr $I10, alt908_1
    rx902_cur."!mark_push"(0, rx902_pos, $I10)
.annotate 'line', 407
  # rx subrule "variable_declarator" subtype=capture negate=
    rx902_cur."!cursor_pos"(rx902_pos)
    $P10 = rx902_cur."variable_declarator"()
    unless $P10, rx902_fail
    rx902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx902_pos = $P10."pos"()
    goto alt908_end
  alt908_1:
.annotate 'line', 408
  # rx subrule "routine_declarator" subtype=capture negate=
    rx902_cur."!cursor_pos"(rx902_pos)
    $P10 = rx902_cur."routine_declarator"()
    unless $P10, rx902_fail
    rx902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx902_pos = $P10."pos"()
  alt908_end:
.annotate 'line', 406
  # rx pass
    rx902_cur."!cursor_pass"(rx902_pos, "declarator")
    if_null rx902_debug, debug_995
    rx902_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx902_pos)
  debug_995:
    .return (rx902_cur)
  rx902_restart:
.annotate 'line', 10
    if_null rx902_debug, debug_996
    rx902_cur."!cursor_debug"("NEXT", "declarator")
  debug_996:
  rx902_fail:
    (rx902_rep, rx902_pos, $I10, $P10) = rx902_cur."!mark_fail"(0)
    lt rx902_pos, -1, rx902_done
    eq rx902_pos, -1, rx902_fail
    jump $I10
  rx902_done:
    rx902_cur."!cursor_fail"()
    if_null rx902_debug, debug_997
    rx902_cur."!cursor_debug"("FAIL", "declarator")
  debug_997:
    .return (rx902_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303430322.161") :method
.annotate 'line', 10
    $P904 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P905 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P906, "ResizablePMCArray"
    push $P906, $P904
    push $P906, $P905
    .return ($P906)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx910_tgt
    .local int rx910_pos
    .local int rx910_off
    .local int rx910_eos
    .local int rx910_rep
    .local pmc rx910_cur
    .local pmc rx910_debug
    (rx910_cur, rx910_pos, rx910_tgt, $I10) = self."!cursor_start"()
    rx910_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx910_cur
    .local pmc match
    .lex "$/", match
    length rx910_eos, rx910_tgt
    gt rx910_pos, rx910_eos, rx910_done
    set rx910_off, 0
    lt rx910_pos, 2, rx910_start
    sub rx910_off, rx910_pos, 1
    substr rx910_tgt, rx910_tgt, rx910_off
  rx910_start:
    eq $I10, 1, rx910_restart
    if_null rx910_debug, debug_998
    rx910_cur."!cursor_debug"("START", "variable_declarator")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan914_done
    goto rxscan914_scan
  rxscan914_loop:
    (rx910_pos) = rx910_cur."from"()
    inc rx910_pos
    rx910_cur."!cursor_from"(rx910_pos)
    ge rx910_pos, rx910_eos, rxscan914_done
  rxscan914_scan:
    set_addr $I10, rxscan914_loop
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxscan914_done:
.annotate 'line', 411
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  # rx rxquantr916 ** 0..1
    set_addr $I10, rxquantr916_done
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxquantr916_loop:
  # rx subrule "typename" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."typename"()
    unless $P10, rx910_fail
    goto rxsubrule917_pass
  rxsubrule917_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx910_fail
  rxsubrule917_pass:
    set_addr $I10, rxsubrule917_back
    rx910_cur."!mark_push"(0, rx910_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx910_pos = $P10."pos"()
    set_addr $I10, rxquantr916_done
    (rx910_rep) = rx910_cur."!mark_commit"($I10)
  rxquantr916_done:
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."variable"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx910_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  # rx pass
    rx910_cur."!cursor_pass"(rx910_pos, "variable_declarator")
    if_null rx910_debug, debug_999
    rx910_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx910_pos)
  debug_999:
    .return (rx910_cur)
  rx910_restart:
.annotate 'line', 10
    if_null rx910_debug, debug_1000
    rx910_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1000:
  rx910_fail:
    (rx910_rep, rx910_pos, $I10, $P10) = rx910_cur."!mark_fail"(0)
    lt rx910_pos, -1, rx910_done
    eq rx910_pos, -1, rx910_fail
    jump $I10
  rx910_done:
    rx910_cur."!cursor_fail"()
    if_null rx910_debug, debug_1001
    rx910_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1001:
    .return (rx910_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303430322.161") :method
.annotate 'line', 10
    $P912 = self."!PREFIX__!subrule"("ws", "")
    new $P913, "ResizablePMCArray"
    push $P913, $P912
    .return ($P913)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303430322.161")
    .param pmc param_921
.annotate 'line', 413
    .lex "self", param_921
    $P922 = param_921."!protoregex"("routine_declarator")
    .return ($P922)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303430322.161")
    .param pmc param_924
.annotate 'line', 413
    .lex "self", param_924
    $P925 = param_924."!PREFIX__!protoregex"("routine_declarator")
    .return ($P925)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx927_tgt
    .local int rx927_pos
    .local int rx927_off
    .local int rx927_eos
    .local int rx927_rep
    .local pmc rx927_cur
    .local pmc rx927_debug
    (rx927_cur, rx927_pos, rx927_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx927_cur
    .local pmc match
    .lex "$/", match
    length rx927_eos, rx927_tgt
    gt rx927_pos, rx927_eos, rx927_done
    set rx927_off, 0
    lt rx927_pos, 2, rx927_start
    sub rx927_off, rx927_pos, 1
    substr rx927_tgt, rx927_tgt, rx927_off
  rx927_start:
    eq $I10, 1, rx927_restart
    if_null rx927_debug, debug_1002
    rx927_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan931_done
    goto rxscan931_scan
  rxscan931_loop:
    (rx927_pos) = rx927_cur."from"()
    inc rx927_pos
    rx927_cur."!cursor_from"(rx927_pos)
    ge rx927_pos, rx927_eos, rxscan931_done
  rxscan931_scan:
    set_addr $I10, rxscan931_loop
    rx927_cur."!mark_push"(0, rx927_pos, $I10)
  rxscan931_done:
.annotate 'line', 414
  # rx subcapture "sym"
    set_addr $I10, rxcap_932_fail
    rx927_cur."!mark_push"(0, rx927_pos, $I10)
  # rx literal  "sub"
    add $I11, rx927_pos, 3
    gt $I11, rx927_eos, rx927_fail
    sub $I11, rx927_pos, rx927_off
    substr $S10, rx927_tgt, $I11, 3
    ne $S10, "sub", rx927_fail
    add rx927_pos, 3
    set_addr $I10, rxcap_932_fail
    ($I12, $I11) = rx927_cur."!mark_peek"($I10)
    rx927_cur."!cursor_pos"($I11)
    ($P10) = rx927_cur."!cursor_start"()
    $P10."!cursor_pass"(rx927_pos, "")
    rx927_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_932_done
  rxcap_932_fail:
    goto rx927_fail
  rxcap_932_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx927_cur."!cursor_pos"(rx927_pos)
    $P10 = rx927_cur."routine_def"()
    unless $P10, rx927_fail
    rx927_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx927_pos = $P10."pos"()
  # rx pass
    rx927_cur."!cursor_pass"(rx927_pos, "routine_declarator:sym<sub>")
    if_null rx927_debug, debug_1003
    rx927_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx927_pos)
  debug_1003:
    .return (rx927_cur)
  rx927_restart:
.annotate 'line', 10
    if_null rx927_debug, debug_1004
    rx927_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1004:
  rx927_fail:
    (rx927_rep, rx927_pos, $I10, $P10) = rx927_cur."!mark_fail"(0)
    lt rx927_pos, -1, rx927_done
    eq rx927_pos, -1, rx927_fail
    jump $I10
  rx927_done:
    rx927_cur."!cursor_fail"()
    if_null rx927_debug, debug_1005
    rx927_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1005:
    .return (rx927_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303430322.161") :method
.annotate 'line', 10
    $P929 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P930, "ResizablePMCArray"
    push $P930, $P929
    .return ($P930)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx934_tgt
    .local int rx934_pos
    .local int rx934_off
    .local int rx934_eos
    .local int rx934_rep
    .local pmc rx934_cur
    .local pmc rx934_debug
    (rx934_cur, rx934_pos, rx934_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx934_cur
    .local pmc match
    .lex "$/", match
    length rx934_eos, rx934_tgt
    gt rx934_pos, rx934_eos, rx934_done
    set rx934_off, 0
    lt rx934_pos, 2, rx934_start
    sub rx934_off, rx934_pos, 1
    substr rx934_tgt, rx934_tgt, rx934_off
  rx934_start:
    eq $I10, 1, rx934_restart
    if_null rx934_debug, debug_1006
    rx934_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1006:
    $I10 = self.'from'()
    ne $I10, -1, rxscan938_done
    goto rxscan938_scan
  rxscan938_loop:
    (rx934_pos) = rx934_cur."from"()
    inc rx934_pos
    rx934_cur."!cursor_from"(rx934_pos)
    ge rx934_pos, rx934_eos, rxscan938_done
  rxscan938_scan:
    set_addr $I10, rxscan938_loop
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  rxscan938_done:
.annotate 'line', 415
  # rx subcapture "sym"
    set_addr $I10, rxcap_939_fail
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  # rx literal  "method"
    add $I11, rx934_pos, 6
    gt $I11, rx934_eos, rx934_fail
    sub $I11, rx934_pos, rx934_off
    substr $S10, rx934_tgt, $I11, 6
    ne $S10, "method", rx934_fail
    add rx934_pos, 6
    set_addr $I10, rxcap_939_fail
    ($I12, $I11) = rx934_cur."!mark_peek"($I10)
    rx934_cur."!cursor_pos"($I11)
    ($P10) = rx934_cur."!cursor_start"()
    $P10."!cursor_pass"(rx934_pos, "")
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_939_done
  rxcap_939_fail:
    goto rx934_fail
  rxcap_939_done:
  # rx subrule "method_def" subtype=capture negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."method_def"()
    unless $P10, rx934_fail
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx934_pos = $P10."pos"()
  # rx pass
    rx934_cur."!cursor_pass"(rx934_pos, "routine_declarator:sym<method>")
    if_null rx934_debug, debug_1007
    rx934_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx934_pos)
  debug_1007:
    .return (rx934_cur)
  rx934_restart:
.annotate 'line', 10
    if_null rx934_debug, debug_1008
    rx934_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1008:
  rx934_fail:
    (rx934_rep, rx934_pos, $I10, $P10) = rx934_cur."!mark_fail"(0)
    lt rx934_pos, -1, rx934_done
    eq rx934_pos, -1, rx934_fail
    jump $I10
  rx934_done:
    rx934_cur."!cursor_fail"()
    if_null rx934_debug, debug_1009
    rx934_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1009:
    .return (rx934_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303430322.161") :method
.annotate 'line', 10
    $P936 = self."!PREFIX__!subrule"("method_def", "method")
    new $P937, "ResizablePMCArray"
    push $P937, $P936
    .return ($P937)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 418
    new $P941, "Undef"
    .lex "$*RETURN_USED", $P941
.annotate 'line', 10
    .local string rx942_tgt
    .local int rx942_pos
    .local int rx942_off
    .local int rx942_eos
    .local int rx942_rep
    .local pmc rx942_cur
    .local pmc rx942_debug
    (rx942_cur, rx942_pos, rx942_tgt, $I10) = self."!cursor_start"()
    rx942_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx942_cur
    .local pmc match
    .lex "$/", match
    length rx942_eos, rx942_tgt
    gt rx942_pos, rx942_eos, rx942_done
    set rx942_off, 0
    lt rx942_pos, 2, rx942_start
    sub rx942_off, rx942_pos, 1
    substr rx942_tgt, rx942_tgt, rx942_off
  rx942_start:
    eq $I10, 1, rx942_restart
    if_null rx942_debug, debug_1010
    rx942_cur."!cursor_debug"("START", "routine_def")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan946_done
    goto rxscan946_scan
  rxscan946_loop:
    (rx942_pos) = rx942_cur."from"()
    inc rx942_pos
    rx942_cur."!cursor_from"(rx942_pos)
    ge rx942_pos, rx942_eos, rxscan946_done
  rxscan946_scan:
    set_addr $I10, rxscan946_loop
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxscan946_done:
.annotate 'line', 417
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 418
    rx942_cur."!cursor_pos"(rx942_pos)
    new $P948, "Integer"
    assign $P948, 0
    store_lex "$*RETURN_USED", $P948
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 419
  # rx rxquantr950 ** 0..1
    set_addr $I10, rxquantr950_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr950_loop:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_953_fail
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  # rx rxquantr952 ** 0..1
    set_addr $I10, rxquantr952_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr952_loop:
  # rx literal  "&"
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 38, rx942_fail
    add rx942_pos, 1
    set_addr $I10, rxquantr952_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
  rxquantr952_done:
    set_addr $I10, rxcap_953_fail
    ($I12, $I11) = rx942_cur."!mark_peek"($I10)
    rx942_cur."!cursor_pos"($I11)
    ($P10) = rx942_cur."!cursor_start"()
    $P10."!cursor_pass"(rx942_pos, "")
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_953_done
  rxcap_953_fail:
    goto rx942_fail
  rxcap_953_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."deflongname"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    set_addr $I10, rxquantr950_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
  rxquantr950_done:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 420
  # rx subrule "newpad" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."newpad"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt957_0:
.annotate 'line', 421
    set_addr $I10, alt957_1
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 40, rx942_fail
    add rx942_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."signature"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 41, rx942_fail
    add rx942_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    goto alt957_end
  alt957_1:
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt957_end:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 423
  # rx rxquantr965 ** 0..*
    set_addr $I10, rxquantr965_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr965_loop:
  # rx subrule "trait" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."trait"()
    unless $P10, rx942_fail
    goto rxsubrule966_pass
  rxsubrule966_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx942_fail
  rxsubrule966_pass:
    set_addr $I10, rxsubrule966_back
    rx942_cur."!mark_push"(0, rx942_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx942_pos = $P10."pos"()
    set_addr $I10, rxquantr965_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr965_done
    rx942_cur."!mark_push"(rx942_rep, rx942_pos, $I10)
    goto rxquantr965_loop
  rxquantr965_done:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt968_0:
.annotate 'line', 424
    set_addr $I10, alt968_1
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."onlystar"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    goto alt968_end
  alt968_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."blockoid"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt968_end:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx942_cur."!cursor_pass"(rx942_pos, "routine_def")
    if_null rx942_debug, debug_1011
    rx942_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx942_pos)
  debug_1011:
    .return (rx942_cur)
  rx942_restart:
.annotate 'line', 10
    if_null rx942_debug, debug_1012
    rx942_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1012:
  rx942_fail:
    (rx942_rep, rx942_pos, $I10, $P10) = rx942_cur."!mark_fail"(0)
    lt rx942_pos, -1, rx942_done
    eq rx942_pos, -1, rx942_fail
    jump $I10
  rx942_done:
    rx942_cur."!cursor_fail"()
    if_null rx942_debug, debug_1013
    rx942_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1013:
    .return (rx942_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303430322.161") :method
.annotate 'line', 10
    $P944 = self."!PREFIX__!subrule"("ws", "")
    new $P945, "ResizablePMCArray"
    push $P945, $P944
    .return ($P945)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P1005 = "181_1303430322.161" 
    capture_lex $P1005
.annotate 'line', 431
    new $P975, "Undef"
    .lex "$*RETURN_USED", $P975
.annotate 'line', 432
    new $P976, "Undef"
    .lex "$*INVOCANT_OK", $P976
.annotate 'line', 10
    .local string rx977_tgt
    .local int rx977_pos
    .local int rx977_off
    .local int rx977_eos
    .local int rx977_rep
    .local pmc rx977_cur
    .local pmc rx977_debug
    (rx977_cur, rx977_pos, rx977_tgt, $I10) = self."!cursor_start"()
    rx977_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx977_cur
    .local pmc match
    .lex "$/", match
    length rx977_eos, rx977_tgt
    gt rx977_pos, rx977_eos, rx977_done
    set rx977_off, 0
    lt rx977_pos, 2, rx977_start
    sub rx977_off, rx977_pos, 1
    substr rx977_tgt, rx977_tgt, rx977_off
  rx977_start:
    eq $I10, 1, rx977_restart
    if_null rx977_debug, debug_1014
    rx977_cur."!cursor_debug"("START", "method_def")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan981_done
    goto rxscan981_scan
  rxscan981_loop:
    (rx977_pos) = rx977_cur."from"()
    inc rx977_pos
    rx977_cur."!cursor_from"(rx977_pos)
    ge rx977_pos, rx977_eos, rxscan981_done
  rxscan981_scan:
    set_addr $I10, rxscan981_loop
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxscan981_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 431
    rx977_cur."!cursor_pos"(rx977_pos)
    new $P983, "Integer"
    assign $P983, 0
    store_lex "$*RETURN_USED", $P983
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 432
    rx977_cur."!cursor_pos"(rx977_pos)
    new $P985, "Integer"
    assign $P985, 1
    store_lex "$*INVOCANT_OK", $P985
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 433
  # rx subcapture "private"
    set_addr $I10, rxcap_988_fail
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  # rx rxquantr987 ** 0..1
    set_addr $I10, rxquantr987_done
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxquantr987_loop:
  # rx literal  "!"
    add $I11, rx977_pos, 1
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    ord $I11, rx977_tgt, $I11
    ne $I11, 33, rx977_fail
    add rx977_pos, 1
    set_addr $I10, rxquantr987_done
    (rx977_rep) = rx977_cur."!mark_commit"($I10)
  rxquantr987_done:
    set_addr $I10, rxcap_988_fail
    ($I12, $I11) = rx977_cur."!mark_peek"($I10)
    rx977_cur."!cursor_pos"($I11)
    ($P10) = rx977_cur."!cursor_start"()
    $P10."!cursor_pass"(rx977_pos, "")
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_988_done
  rxcap_988_fail:
    goto rx977_fail
  rxcap_988_done:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 434
  # rx rxquantr990 ** 0..1
    set_addr $I10, rxquantr990_done
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxquantr990_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."deflongname"()
    unless $P10, rx977_fail
    goto rxsubrule991_pass
  rxsubrule991_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx977_fail
  rxsubrule991_pass:
    set_addr $I10, rxsubrule991_back
    rx977_cur."!mark_push"(0, rx977_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx977_pos = $P10."pos"()
    set_addr $I10, rxquantr990_done
    (rx977_rep) = rx977_cur."!mark_commit"($I10)
  rxquantr990_done:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 435
  # rx subrule "newpad" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."newpad"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt994_0:
.annotate 'line', 436
    set_addr $I10, alt994_1
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx977_pos, 1
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    ord $I11, rx977_tgt, $I11
    ne $I11, 40, rx977_fail
    add rx977_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."signature"()
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx977_pos, 1
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    ord $I11, rx977_tgt, $I11
    ne $I11, 41, rx977_fail
    add rx977_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
    goto alt994_end
  alt994_1:
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt994_end:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 438
    rx977_cur."!cursor_pos"(rx977_pos)
    find_lex $P1002, unicode:"$\x{a2}"
    $P1003 = $P1002."MATCH"()
    store_lex "$/", $P1003
    .const 'Sub' $P1005 = "181_1303430322.161" 
    capture_lex $P1005
    $P1007 = $P1005()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 439
  # rx rxquantr1009 ** 0..*
    set_addr $I10, rxquantr1009_done
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxquantr1009_loop:
  # rx subrule "trait" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."trait"()
    unless $P10, rx977_fail
    goto rxsubrule1010_pass
  rxsubrule1010_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx977_fail
  rxsubrule1010_pass:
    set_addr $I10, rxsubrule1010_back
    rx977_cur."!mark_push"(0, rx977_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx977_pos = $P10."pos"()
    set_addr $I10, rxquantr1009_done
    (rx977_rep) = rx977_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1009_done
    rx977_cur."!mark_push"(rx977_rep, rx977_pos, $I10)
    goto rxquantr1009_loop
  rxquantr1009_done:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt1012_0:
.annotate 'line', 440
    set_addr $I10, alt1012_1
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."onlystar"()
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
    goto alt1012_end
  alt1012_1:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."blockoid"()
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt1012_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 430
  # rx pass
    rx977_cur."!cursor_pass"(rx977_pos, "method_def")
    if_null rx977_debug, debug_1015
    rx977_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx977_pos)
  debug_1015:
    .return (rx977_cur)
  rx977_restart:
.annotate 'line', 10
    if_null rx977_debug, debug_1016
    rx977_cur."!cursor_debug"("NEXT", "method_def")
  debug_1016:
  rx977_fail:
    (rx977_rep, rx977_pos, $I10, $P10) = rx977_cur."!mark_fail"(0)
    lt rx977_pos, -1, rx977_done
    eq rx977_pos, -1, rx977_fail
    jump $I10
  rx977_done:
    rx977_cur."!cursor_fail"()
    if_null rx977_debug, debug_1017
    rx977_cur."!cursor_debug"("FAIL", "method_def")
  debug_1017:
    .return (rx977_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303430322.161") :method
.annotate 'line', 10
    $P979 = self."!PREFIX__!subrule"("ws", "")
    new $P980, "ResizablePMCArray"
    push $P980, $P979
    .return ($P980)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1004"  :anon :subid("181_1303430322.161") :outer("179_1303430322.161")
.annotate 'line', 438
    new $P1006, "Integer"
    assign $P1006, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1006
    .return ($P1006)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P1026 = "184_1303430322.161" 
    capture_lex $P1026
    .local string rx1019_tgt
    .local int rx1019_pos
    .local int rx1019_off
    .local int rx1019_eos
    .local int rx1019_rep
    .local pmc rx1019_cur
    .local pmc rx1019_debug
    (rx1019_cur, rx1019_pos, rx1019_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1019_cur
    .local pmc match
    .lex "$/", match
    length rx1019_eos, rx1019_tgt
    gt rx1019_pos, rx1019_eos, rx1019_done
    set rx1019_off, 0
    lt rx1019_pos, 2, rx1019_start
    sub rx1019_off, rx1019_pos, 1
    substr rx1019_tgt, rx1019_tgt, rx1019_off
  rx1019_start:
    eq $I10, 1, rx1019_restart
    if_null rx1019_debug, debug_1018
    rx1019_cur."!cursor_debug"("START", "onlystar")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1022_done
    goto rxscan1022_scan
  rxscan1022_loop:
    (rx1019_pos) = rx1019_cur."from"()
    inc rx1019_pos
    rx1019_cur."!cursor_from"(rx1019_pos)
    ge rx1019_pos, rx1019_eos, rxscan1022_done
  rxscan1022_scan:
    set_addr $I10, rxscan1022_loop
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  rxscan1022_done:
.annotate 'line', 447
    rx1019_cur."!cursor_pos"(rx1019_pos)
    find_lex $P1023, unicode:"$\x{a2}"
    $P1024 = $P1023."MATCH"()
    store_lex "$/", $P1024
    .const 'Sub' $P1026 = "184_1303430322.161" 
    capture_lex $P1026
    $P1030 = $P1026()
    unless $P1030, rx1019_fail
.annotate 'line', 448
  # rx literal  "{"
    add $I11, rx1019_pos, 1
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    ord $I11, rx1019_tgt, $I11
    ne $I11, 123, rx1019_fail
    add rx1019_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."ws"()
    unless $P10, rx1019_fail
    rx1019_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1019_pos, 1
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    ord $I11, rx1019_tgt, $I11
    ne $I11, 42, rx1019_fail
    add rx1019_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."ws"()
    unless $P10, rx1019_fail
    rx1019_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1019_pos, 1
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    ord $I11, rx1019_tgt, $I11
    ne $I11, 125, rx1019_fail
    add rx1019_pos, 1
.annotate 'line', 449
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."ENDSTMT"()
    unless $P10, rx1019_fail
.annotate 'line', 450
  # rx subrule "finishpad" subtype=method negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."finishpad"()
    unless $P10, rx1019_fail
    rx1019_pos = $P10."pos"()
.annotate 'line', 446
  # rx pass
    rx1019_cur."!cursor_pass"(rx1019_pos, "onlystar")
    if_null rx1019_debug, debug_1021
    rx1019_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1019_pos)
  debug_1021:
    .return (rx1019_cur)
  rx1019_restart:
.annotate 'line', 10
    if_null rx1019_debug, debug_1022
    rx1019_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1022:
  rx1019_fail:
    (rx1019_rep, rx1019_pos, $I10, $P10) = rx1019_cur."!mark_fail"(0)
    lt rx1019_pos, -1, rx1019_done
    eq rx1019_pos, -1, rx1019_fail
    jump $I10
  rx1019_done:
    rx1019_cur."!cursor_fail"()
    if_null rx1019_debug, debug_1023
    rx1019_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1023:
    .return (rx1019_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303430322.161") :method
.annotate 'line', 10
    new $P1021, "ResizablePMCArray"
    push $P1021, ""
    .return ($P1021)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1025"  :anon :subid("184_1303430322.161") :outer("182_1303430322.161")
.annotate 'line', 447
    find_dynamic_lex $P1027, "$*MULTINESS"
    unless_null $P1027, vivify_1019
    get_hll_global $P1027, "$MULTINESS"
    unless_null $P1027, vivify_1020
    die "Contextual $*MULTINESS not found"
  vivify_1020:
  vivify_1019:
    set $S1028, $P1027
    iseq $I1029, $S1028, "proto"
    .return ($I1029)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303430322.161")
    .param pmc param_1032
.annotate 'line', 453
    .lex "self", param_1032
    $P1033 = param_1032."!protoregex"("multi_declarator")
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303430322.161")
    .param pmc param_1035
.annotate 'line', 453
    .lex "self", param_1035
    $P1036 = param_1035."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1036)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 455
    new $P1038, "Undef"
    .lex "$*MULTINESS", $P1038
.annotate 'line', 10
    .local string rx1039_tgt
    .local int rx1039_pos
    .local int rx1039_off
    .local int rx1039_eos
    .local int rx1039_rep
    .local pmc rx1039_cur
    .local pmc rx1039_debug
    (rx1039_cur, rx1039_pos, rx1039_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1039_cur
    .local pmc match
    .lex "$/", match
    length rx1039_eos, rx1039_tgt
    gt rx1039_pos, rx1039_eos, rx1039_done
    set rx1039_off, 0
    lt rx1039_pos, 2, rx1039_start
    sub rx1039_off, rx1039_pos, 1
    substr rx1039_tgt, rx1039_tgt, rx1039_off
  rx1039_start:
    eq $I10, 1, rx1039_restart
    if_null rx1039_debug, debug_1024
    rx1039_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1043_done
    goto rxscan1043_scan
  rxscan1043_loop:
    (rx1039_pos) = rx1039_cur."from"()
    inc rx1039_pos
    rx1039_cur."!cursor_from"(rx1039_pos)
    ge rx1039_pos, rx1039_eos, rxscan1043_done
  rxscan1043_scan:
    set_addr $I10, rxscan1043_loop
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  rxscan1043_done:
.annotate 'line', 455
    rx1039_cur."!cursor_pos"(rx1039_pos)
    new $P1044, "String"
    assign $P1044, "multi"
    store_lex "$*MULTINESS", $P1044
.annotate 'line', 456
  # rx subcapture "sym"
    set_addr $I10, rxcap_1045_fail
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1039_pos, 5
    gt $I11, rx1039_eos, rx1039_fail
    sub $I11, rx1039_pos, rx1039_off
    substr $S10, rx1039_tgt, $I11, 5
    ne $S10, "multi", rx1039_fail
    add rx1039_pos, 5
    set_addr $I10, rxcap_1045_fail
    ($I12, $I11) = rx1039_cur."!mark_peek"($I10)
    rx1039_cur."!cursor_pos"($I11)
    ($P10) = rx1039_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1039_pos, "")
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1045_done
  rxcap_1045_fail:
    goto rx1039_fail
  rxcap_1045_done:
.annotate 'line', 457
  # rx subrule "ws" subtype=method negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."ws"()
    unless $P10, rx1039_fail
    rx1039_pos = $P10."pos"()
  alt1046_0:
    set_addr $I10, alt1046_1
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."declarator"()
    unless $P10, rx1039_fail
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1039_pos = $P10."pos"()
    goto alt1046_end
  alt1046_1:
    set_addr $I10, alt1046_2
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."routine_def"()
    unless $P10, rx1039_fail
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1039_pos = $P10."pos"()
    goto alt1046_end
  alt1046_2:
  # rx subrule "panic" subtype=method negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."panic"("Malformed multi")
    unless $P10, rx1039_fail
    rx1039_pos = $P10."pos"()
  alt1046_end:
.annotate 'line', 454
  # rx pass
    rx1039_cur."!cursor_pass"(rx1039_pos, "multi_declarator:sym<multi>")
    if_null rx1039_debug, debug_1025
    rx1039_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1039_pos)
  debug_1025:
    .return (rx1039_cur)
  rx1039_restart:
.annotate 'line', 10
    if_null rx1039_debug, debug_1026
    rx1039_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1026:
  rx1039_fail:
    (rx1039_rep, rx1039_pos, $I10, $P10) = rx1039_cur."!mark_fail"(0)
    lt rx1039_pos, -1, rx1039_done
    eq rx1039_pos, -1, rx1039_fail
    jump $I10
  rx1039_done:
    rx1039_cur."!cursor_fail"()
    if_null rx1039_debug, debug_1027
    rx1039_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1027:
    .return (rx1039_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303430322.161") :method
.annotate 'line', 10
    $P1041 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1042, "ResizablePMCArray"
    push $P1042, $P1041
    .return ($P1042)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 460
    new $P1048, "Undef"
    .lex "$*MULTINESS", $P1048
.annotate 'line', 10
    .local string rx1049_tgt
    .local int rx1049_pos
    .local int rx1049_off
    .local int rx1049_eos
    .local int rx1049_rep
    .local pmc rx1049_cur
    .local pmc rx1049_debug
    (rx1049_cur, rx1049_pos, rx1049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1049_cur
    .local pmc match
    .lex "$/", match
    length rx1049_eos, rx1049_tgt
    gt rx1049_pos, rx1049_eos, rx1049_done
    set rx1049_off, 0
    lt rx1049_pos, 2, rx1049_start
    sub rx1049_off, rx1049_pos, 1
    substr rx1049_tgt, rx1049_tgt, rx1049_off
  rx1049_start:
    eq $I10, 1, rx1049_restart
    if_null rx1049_debug, debug_1028
    rx1049_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1053_done
    goto rxscan1053_scan
  rxscan1053_loop:
    (rx1049_pos) = rx1049_cur."from"()
    inc rx1049_pos
    rx1049_cur."!cursor_from"(rx1049_pos)
    ge rx1049_pos, rx1049_eos, rxscan1053_done
  rxscan1053_scan:
    set_addr $I10, rxscan1053_loop
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  rxscan1053_done:
.annotate 'line', 460
    rx1049_cur."!cursor_pos"(rx1049_pos)
    new $P1054, "String"
    assign $P1054, "proto"
    store_lex "$*MULTINESS", $P1054
.annotate 'line', 461
  # rx subcapture "sym"
    set_addr $I10, rxcap_1055_fail
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1049_pos, 5
    gt $I11, rx1049_eos, rx1049_fail
    sub $I11, rx1049_pos, rx1049_off
    substr $S10, rx1049_tgt, $I11, 5
    ne $S10, "proto", rx1049_fail
    add rx1049_pos, 5
    set_addr $I10, rxcap_1055_fail
    ($I12, $I11) = rx1049_cur."!mark_peek"($I10)
    rx1049_cur."!cursor_pos"($I11)
    ($P10) = rx1049_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1049_pos, "")
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1055_done
  rxcap_1055_fail:
    goto rx1049_fail
  rxcap_1055_done:
.annotate 'line', 462
  # rx subrule "ws" subtype=method negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."ws"()
    unless $P10, rx1049_fail
    rx1049_pos = $P10."pos"()
  alt1056_0:
    set_addr $I10, alt1056_1
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."declarator"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1049_pos = $P10."pos"()
    goto alt1056_end
  alt1056_1:
    set_addr $I10, alt1056_2
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."routine_def"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1049_pos = $P10."pos"()
    goto alt1056_end
  alt1056_2:
  # rx subrule "panic" subtype=method negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."panic"("Malformed proto")
    unless $P10, rx1049_fail
    rx1049_pos = $P10."pos"()
  alt1056_end:
.annotate 'line', 459
  # rx pass
    rx1049_cur."!cursor_pass"(rx1049_pos, "multi_declarator:sym<proto>")
    if_null rx1049_debug, debug_1029
    rx1049_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1049_pos)
  debug_1029:
    .return (rx1049_cur)
  rx1049_restart:
.annotate 'line', 10
    if_null rx1049_debug, debug_1030
    rx1049_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1030:
  rx1049_fail:
    (rx1049_rep, rx1049_pos, $I10, $P10) = rx1049_cur."!mark_fail"(0)
    lt rx1049_pos, -1, rx1049_done
    eq rx1049_pos, -1, rx1049_fail
    jump $I10
  rx1049_done:
    rx1049_cur."!cursor_fail"()
    if_null rx1049_debug, debug_1031
    rx1049_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1031:
    .return (rx1049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303430322.161") :method
.annotate 'line', 10
    $P1051 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1052, "ResizablePMCArray"
    push $P1052, $P1051
    .return ($P1052)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 465
    new $P1058, "Undef"
    .lex "$*MULTINESS", $P1058
.annotate 'line', 10
    .local string rx1059_tgt
    .local int rx1059_pos
    .local int rx1059_off
    .local int rx1059_eos
    .local int rx1059_rep
    .local pmc rx1059_cur
    .local pmc rx1059_debug
    (rx1059_cur, rx1059_pos, rx1059_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1059_cur
    .local pmc match
    .lex "$/", match
    length rx1059_eos, rx1059_tgt
    gt rx1059_pos, rx1059_eos, rx1059_done
    set rx1059_off, 0
    lt rx1059_pos, 2, rx1059_start
    sub rx1059_off, rx1059_pos, 1
    substr rx1059_tgt, rx1059_tgt, rx1059_off
  rx1059_start:
    eq $I10, 1, rx1059_restart
    if_null rx1059_debug, debug_1032
    rx1059_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1063_done
    goto rxscan1063_scan
  rxscan1063_loop:
    (rx1059_pos) = rx1059_cur."from"()
    inc rx1059_pos
    rx1059_cur."!cursor_from"(rx1059_pos)
    ge rx1059_pos, rx1059_eos, rxscan1063_done
  rxscan1063_scan:
    set_addr $I10, rxscan1063_loop
    rx1059_cur."!mark_push"(0, rx1059_pos, $I10)
  rxscan1063_done:
.annotate 'line', 465
    rx1059_cur."!cursor_pos"(rx1059_pos)
    new $P1064, "String"
    assign $P1064, ""
    store_lex "$*MULTINESS", $P1064
.annotate 'line', 466
  # rx subrule "declarator" subtype=capture negate=
    rx1059_cur."!cursor_pos"(rx1059_pos)
    $P10 = rx1059_cur."declarator"()
    unless $P10, rx1059_fail
    rx1059_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1059_pos = $P10."pos"()
.annotate 'line', 464
  # rx pass
    rx1059_cur."!cursor_pass"(rx1059_pos, "multi_declarator:sym<null>")
    if_null rx1059_debug, debug_1033
    rx1059_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1059_pos)
  debug_1033:
    .return (rx1059_cur)
  rx1059_restart:
.annotate 'line', 10
    if_null rx1059_debug, debug_1034
    rx1059_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1034:
  rx1059_fail:
    (rx1059_rep, rx1059_pos, $I10, $P10) = rx1059_cur."!mark_fail"(0)
    lt rx1059_pos, -1, rx1059_done
    eq rx1059_pos, -1, rx1059_fail
    jump $I10
  rx1059_done:
    rx1059_cur."!cursor_fail"()
    if_null rx1059_debug, debug_1035
    rx1059_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1035:
    .return (rx1059_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303430322.161") :method
.annotate 'line', 10
    $P1061 = self."!PREFIX__!subrule"("declarator", "")
    new $P1062, "ResizablePMCArray"
    push $P1062, $P1061
    .return ($P1062)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P1074 = "195_1303430322.161" 
    capture_lex $P1074
    .local string rx1066_tgt
    .local int rx1066_pos
    .local int rx1066_off
    .local int rx1066_eos
    .local int rx1066_rep
    .local pmc rx1066_cur
    .local pmc rx1066_debug
    (rx1066_cur, rx1066_pos, rx1066_tgt, $I10) = self."!cursor_start"()
    rx1066_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1066_cur
    .local pmc match
    .lex "$/", match
    length rx1066_eos, rx1066_tgt
    gt rx1066_pos, rx1066_eos, rx1066_done
    set rx1066_off, 0
    lt rx1066_pos, 2, rx1066_start
    sub rx1066_off, rx1066_pos, 1
    substr rx1066_tgt, rx1066_tgt, rx1066_off
  rx1066_start:
    eq $I10, 1, rx1066_restart
    if_null rx1066_debug, debug_1036
    rx1066_cur."!cursor_debug"("START", "signature")
  debug_1036:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1066_pos) = rx1066_cur."from"()
    inc rx1066_pos
    rx1066_cur."!cursor_from"(rx1066_pos)
    ge rx1066_pos, rx1066_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxscan1069_done:
.annotate 'line', 470
  # rx rxquantr1070 ** 0..1
    set_addr $I10, rxquantr1070_done
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxquantr1070_loop:
    rx1066_cur."!cursor_pos"(rx1066_pos)
    find_lex $P1071, unicode:"$\x{a2}"
    $P1072 = $P1071."MATCH"()
    store_lex "$/", $P1072
    .const 'Sub' $P1074 = "195_1303430322.161" 
    capture_lex $P1074
    $P1076 = $P1074()
    unless $P1076, rx1066_fail
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."parameter"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1066_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1066_pos, 1
    gt $I11, rx1066_eos, rx1066_fail
    sub $I11, rx1066_pos, rx1066_off
    ord $I11, rx1066_tgt, $I11
    ne $I11, 58, rx1066_fail
    add rx1066_pos, 1
    set_addr $I10, rxquantr1070_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
  rxquantr1070_done:
.annotate 'line', 471
  # rx rxquantr1077 ** 0..1
    set_addr $I10, rxquantr1077_done
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxquantr1077_loop:
  # rx rxquantr1078 ** 1..*
    set_addr $I10, rxquantr1078_done
    rx1066_cur."!mark_push"(0, -1, $I10)
  rxquantr1078_loop:
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."parameter"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1066_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
    set_addr $I10, rxquantr1078_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1078_done
    rx1066_cur."!mark_push"(rx1066_rep, rx1066_pos, $I10)
  # rx literal  ","
    add $I11, rx1066_pos, 1
    gt $I11, rx1066_eos, rx1066_fail
    sub $I11, rx1066_pos, rx1066_off
    ord $I11, rx1066_tgt, $I11
    ne $I11, 44, rx1066_fail
    add rx1066_pos, 1
    goto rxquantr1078_loop
  rxquantr1078_done:
    set_addr $I10, rxquantr1077_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
  rxquantr1077_done:
.annotate 'line', 469
  # rx pass
    rx1066_cur."!cursor_pass"(rx1066_pos, "signature")
    if_null rx1066_debug, debug_1039
    rx1066_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1066_pos)
  debug_1039:
    .return (rx1066_cur)
  rx1066_restart:
.annotate 'line', 10
    if_null rx1066_debug, debug_1040
    rx1066_cur."!cursor_debug"("NEXT", "signature")
  debug_1040:
  rx1066_fail:
    (rx1066_rep, rx1066_pos, $I10, $P10) = rx1066_cur."!mark_fail"(0)
    lt rx1066_pos, -1, rx1066_done
    eq rx1066_pos, -1, rx1066_fail
    jump $I10
  rx1066_done:
    rx1066_cur."!cursor_fail"()
    if_null rx1066_debug, debug_1041
    rx1066_cur."!cursor_debug"("FAIL", "signature")
  debug_1041:
    .return (rx1066_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303430322.161") :method
.annotate 'line', 10
    new $P1068, "ResizablePMCArray"
    push $P1068, ""
    .return ($P1068)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1073"  :anon :subid("195_1303430322.161") :outer("193_1303430322.161")
.annotate 'line', 470
    find_dynamic_lex $P1075, "$*INVOCANT_OK"
    unless_null $P1075, vivify_1037
    get_hll_global $P1075, "$INVOCANT_OK"
    unless_null $P1075, vivify_1038
    die "Contextual $*INVOCANT_OK not found"
  vivify_1038:
  vivify_1037:
    .return ($P1075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    rx1080_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_1042
    rx1080_cur."!cursor_debug"("START", "parameter")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1083_done
    goto rxscan1083_scan
  rxscan1083_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1083_done
  rxscan1083_scan:
    set_addr $I10, rxscan1083_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1083_done:
.annotate 'line', 475
  # rx rxquantr1084 ** 0..*
    set_addr $I10, rxquantr1084_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1084_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."typename"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1080_pos = $P10."pos"()
  # rx rxquantr1085 ** 0..1
    set_addr $I10, rxquantr1085_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1085_loop:
  # rx literal  ":"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 58, rx1080_fail
    add rx1080_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1086_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1080_pos, rx1080_eos, rx1080_fail
    sub $I10, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1080_fail
    inc rx1080_pos
    set_addr $I10, rxcap_1086_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1086_done
  rxcap_1086_fail:
    goto rx1080_fail
  rxcap_1086_done:
    set_addr $I10, rxquantr1085_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
  rxquantr1085_done:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
    set_addr $I10, rxquantr1084_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1084_done
    rx1080_cur."!mark_push"(rx1080_rep, rx1080_pos, $I10)
    goto rxquantr1084_loop
  rxquantr1084_done:
  alt1087_0:
.annotate 'line', 476
    set_addr $I10, alt1087_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
.annotate 'line', 477
  # rx subcapture "quant"
    set_addr $I10, rxcap_1088_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "*"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 42, rx1080_fail
    add rx1080_pos, 1
    set_addr $I10, rxcap_1088_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1088_done
  rxcap_1088_fail:
    goto rx1080_fail
  rxcap_1088_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."param_var"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1080_pos = $P10."pos"()
    goto alt1087_end
  alt1087_1:
  alt1089_0:
.annotate 'line', 478
    set_addr $I10, alt1089_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."param_var"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1080_pos = $P10."pos"()
    goto alt1089_end
  alt1089_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."named_param"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1080_pos = $P10."pos"()
  alt1089_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1091_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  alt1090_0:
    set_addr $I10, alt1090_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "?"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 63, rx1080_fail
    add rx1080_pos, 1
    goto alt1090_end
  alt1090_1:
    set_addr $I10, alt1090_2
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "!"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 33, rx1080_fail
    add rx1080_pos, 1
    goto alt1090_end
  alt1090_2:
  alt1090_end:
    set_addr $I10, rxcap_1091_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1091_done
  rxcap_1091_fail:
    goto rx1080_fail
  rxcap_1091_done:
  alt1087_end:
.annotate 'line', 480
  # rx rxquantr1092 ** 0..1
    set_addr $I10, rxquantr1092_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1092_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."default_value"()
    unless $P10, rx1080_fail
    goto rxsubrule1093_pass
  rxsubrule1093_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1080_fail
  rxsubrule1093_pass:
    set_addr $I10, rxsubrule1093_back
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1080_pos = $P10."pos"()
    set_addr $I10, rxquantr1092_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
  rxquantr1092_done:
.annotate 'line', 474
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "parameter")
    if_null rx1080_debug, debug_1043
    rx1080_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1080_pos)
  debug_1043:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 10
    if_null rx1080_debug, debug_1044
    rx1080_cur."!cursor_debug"("NEXT", "parameter")
  debug_1044:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_1045
    rx1080_cur."!cursor_debug"("FAIL", "parameter")
  debug_1045:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303430322.161") :method
.annotate 'line', 10
    new $P1082, "ResizablePMCArray"
    push $P1082, ""
    .return ($P1082)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1095_tgt
    .local int rx1095_pos
    .local int rx1095_off
    .local int rx1095_eos
    .local int rx1095_rep
    .local pmc rx1095_cur
    .local pmc rx1095_debug
    (rx1095_cur, rx1095_pos, rx1095_tgt, $I10) = self."!cursor_start"()
    rx1095_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1095_cur
    .local pmc match
    .lex "$/", match
    length rx1095_eos, rx1095_tgt
    gt rx1095_pos, rx1095_eos, rx1095_done
    set rx1095_off, 0
    lt rx1095_pos, 2, rx1095_start
    sub rx1095_off, rx1095_pos, 1
    substr rx1095_tgt, rx1095_tgt, rx1095_off
  rx1095_start:
    eq $I10, 1, rx1095_restart
    if_null rx1095_debug, debug_1046
    rx1095_cur."!cursor_debug"("START", "param_var")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1099_done
    goto rxscan1099_scan
  rxscan1099_loop:
    (rx1095_pos) = rx1095_cur."from"()
    inc rx1095_pos
    rx1095_cur."!cursor_from"(rx1095_pos)
    ge rx1095_pos, rx1095_eos, rxscan1099_done
  rxscan1099_scan:
    set_addr $I10, rxscan1099_loop
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxscan1099_done:
.annotate 'line', 484
  # rx subrule "sigil" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."sigil"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1095_pos = $P10."pos"()
  # rx rxquantr1100 ** 0..1
    set_addr $I10, rxquantr1100_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1100_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."twigil"()
    unless $P10, rx1095_fail
    goto rxsubrule1101_pass
  rxsubrule1101_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1095_fail
  rxsubrule1101_pass:
    set_addr $I10, rxsubrule1101_back
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1100_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1100_done:
  alt1102_0:
.annotate 'line', 485
    set_addr $I10, alt1102_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ident"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1095_pos = $P10."pos"()
    goto alt1102_end
  alt1102_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1103_fail
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1095_pos, rx1095_eos, rx1095_fail
    sub $I10, rx1095_pos, rx1095_off
    substr $S10, rx1095_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1095_fail
    inc rx1095_pos
    set_addr $I10, rxcap_1103_fail
    ($I12, $I11) = rx1095_cur."!mark_peek"($I10)
    rx1095_cur."!cursor_pos"($I11)
    ($P10) = rx1095_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1095_pos, "")
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1103_done
  rxcap_1103_fail:
    goto rx1095_fail
  rxcap_1103_done:
  alt1102_end:
.annotate 'line', 483
  # rx pass
    rx1095_cur."!cursor_pass"(rx1095_pos, "param_var")
    if_null rx1095_debug, debug_1047
    rx1095_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1095_pos)
  debug_1047:
    .return (rx1095_cur)
  rx1095_restart:
.annotate 'line', 10
    if_null rx1095_debug, debug_1048
    rx1095_cur."!cursor_debug"("NEXT", "param_var")
  debug_1048:
  rx1095_fail:
    (rx1095_rep, rx1095_pos, $I10, $P10) = rx1095_cur."!mark_fail"(0)
    lt rx1095_pos, -1, rx1095_done
    eq rx1095_pos, -1, rx1095_fail
    jump $I10
  rx1095_done:
    rx1095_cur."!cursor_fail"()
    if_null rx1095_debug, debug_1049
    rx1095_cur."!cursor_debug"("FAIL", "param_var")
  debug_1049:
    .return (rx1095_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303430322.161") :method
.annotate 'line', 10
    $P1097 = self."!PREFIX__!subrule"("sigil", "")
    new $P1098, "ResizablePMCArray"
    push $P1098, $P1097
    .return ($P1098)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1105_tgt
    .local int rx1105_pos
    .local int rx1105_off
    .local int rx1105_eos
    .local int rx1105_rep
    .local pmc rx1105_cur
    .local pmc rx1105_debug
    (rx1105_cur, rx1105_pos, rx1105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1105_cur
    .local pmc match
    .lex "$/", match
    length rx1105_eos, rx1105_tgt
    gt rx1105_pos, rx1105_eos, rx1105_done
    set rx1105_off, 0
    lt rx1105_pos, 2, rx1105_start
    sub rx1105_off, rx1105_pos, 1
    substr rx1105_tgt, rx1105_tgt, rx1105_off
  rx1105_start:
    eq $I10, 1, rx1105_restart
    if_null rx1105_debug, debug_1050
    rx1105_cur."!cursor_debug"("START", "named_param")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1109_done
    goto rxscan1109_scan
  rxscan1109_loop:
    (rx1105_pos) = rx1105_cur."from"()
    inc rx1105_pos
    rx1105_cur."!cursor_from"(rx1105_pos)
    ge rx1105_pos, rx1105_eos, rxscan1109_done
  rxscan1109_scan:
    set_addr $I10, rxscan1109_loop
    rx1105_cur."!mark_push"(0, rx1105_pos, $I10)
  rxscan1109_done:
.annotate 'line', 489
  # rx literal  ":"
    add $I11, rx1105_pos, 1
    gt $I11, rx1105_eos, rx1105_fail
    sub $I11, rx1105_pos, rx1105_off
    ord $I11, rx1105_tgt, $I11
    ne $I11, 58, rx1105_fail
    add rx1105_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1105_cur."!cursor_pos"(rx1105_pos)
    $P10 = rx1105_cur."param_var"()
    unless $P10, rx1105_fail
    rx1105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1105_pos = $P10."pos"()
.annotate 'line', 488
  # rx pass
    rx1105_cur."!cursor_pass"(rx1105_pos, "named_param")
    if_null rx1105_debug, debug_1051
    rx1105_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1105_pos)
  debug_1051:
    .return (rx1105_cur)
  rx1105_restart:
.annotate 'line', 10
    if_null rx1105_debug, debug_1052
    rx1105_cur."!cursor_debug"("NEXT", "named_param")
  debug_1052:
  rx1105_fail:
    (rx1105_rep, rx1105_pos, $I10, $P10) = rx1105_cur."!mark_fail"(0)
    lt rx1105_pos, -1, rx1105_done
    eq rx1105_pos, -1, rx1105_fail
    jump $I10
  rx1105_done:
    rx1105_cur."!cursor_fail"()
    if_null rx1105_debug, debug_1053
    rx1105_cur."!cursor_debug"("FAIL", "named_param")
  debug_1053:
    .return (rx1105_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303430322.161") :method
.annotate 'line', 10
    $P1107 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1108, "ResizablePMCArray"
    push $P1108, $P1107
    .return ($P1108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1111_tgt
    .local int rx1111_pos
    .local int rx1111_off
    .local int rx1111_eos
    .local int rx1111_rep
    .local pmc rx1111_cur
    .local pmc rx1111_debug
    (rx1111_cur, rx1111_pos, rx1111_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1111_cur
    .local pmc match
    .lex "$/", match
    length rx1111_eos, rx1111_tgt
    gt rx1111_pos, rx1111_eos, rx1111_done
    set rx1111_off, 0
    lt rx1111_pos, 2, rx1111_start
    sub rx1111_off, rx1111_pos, 1
    substr rx1111_tgt, rx1111_tgt, rx1111_off
  rx1111_start:
    eq $I10, 1, rx1111_restart
    if_null rx1111_debug, debug_1054
    rx1111_cur."!cursor_debug"("START", "default_value")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1115_done
    goto rxscan1115_scan
  rxscan1115_loop:
    (rx1111_pos) = rx1111_cur."from"()
    inc rx1111_pos
    rx1111_cur."!cursor_from"(rx1111_pos)
    ge rx1111_pos, rx1111_eos, rxscan1115_done
  rxscan1115_scan:
    set_addr $I10, rxscan1115_loop
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxscan1115_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 61, rx1111_fail
    add rx1111_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."EXPR"("i=")
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx pass
    rx1111_cur."!cursor_pass"(rx1111_pos, "default_value")
    if_null rx1111_debug, debug_1055
    rx1111_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1111_pos)
  debug_1055:
    .return (rx1111_cur)
  rx1111_restart:
.annotate 'line', 10
    if_null rx1111_debug, debug_1056
    rx1111_cur."!cursor_debug"("NEXT", "default_value")
  debug_1056:
  rx1111_fail:
    (rx1111_rep, rx1111_pos, $I10, $P10) = rx1111_cur."!mark_fail"(0)
    lt rx1111_pos, -1, rx1111_done
    eq rx1111_pos, -1, rx1111_fail
    jump $I10
  rx1111_done:
    rx1111_cur."!cursor_fail"()
    if_null rx1111_debug, debug_1057
    rx1111_cur."!cursor_debug"("FAIL", "default_value")
  debug_1057:
    .return (rx1111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303430322.161") :method
.annotate 'line', 10
    $P1113 = self."!PREFIX__!subrule"("ws", "")
    new $P1114, "ResizablePMCArray"
    push $P1114, $P1113
    .return ($P1114)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1120_tgt
    .local int rx1120_pos
    .local int rx1120_off
    .local int rx1120_eos
    .local int rx1120_rep
    .local pmc rx1120_cur
    .local pmc rx1120_debug
    (rx1120_cur, rx1120_pos, rx1120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1120_cur
    .local pmc match
    .lex "$/", match
    length rx1120_eos, rx1120_tgt
    gt rx1120_pos, rx1120_eos, rx1120_done
    set rx1120_off, 0
    lt rx1120_pos, 2, rx1120_start
    sub rx1120_off, rx1120_pos, 1
    substr rx1120_tgt, rx1120_tgt, rx1120_off
  rx1120_start:
    eq $I10, 1, rx1120_restart
    if_null rx1120_debug, debug_1058
    rx1120_cur."!cursor_debug"("START", "trait")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1124_done
    goto rxscan1124_scan
  rxscan1124_loop:
    (rx1120_pos) = rx1120_cur."from"()
    inc rx1120_pos
    rx1120_cur."!cursor_from"(rx1120_pos)
    ge rx1120_pos, rx1120_eos, rxscan1124_done
  rxscan1124_scan:
    set_addr $I10, rxscan1124_loop
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxscan1124_done:
.annotate 'line', 494
  # rx subrule "ws" subtype=method negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."ws"()
    unless $P10, rx1120_fail
    rx1120_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."trait_mod"()
    unless $P10, rx1120_fail
    rx1120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1120_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."ws"()
    unless $P10, rx1120_fail
    rx1120_pos = $P10."pos"()
  # rx pass
    rx1120_cur."!cursor_pass"(rx1120_pos, "trait")
    if_null rx1120_debug, debug_1059
    rx1120_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1120_pos)
  debug_1059:
    .return (rx1120_cur)
  rx1120_restart:
.annotate 'line', 10
    if_null rx1120_debug, debug_1060
    rx1120_cur."!cursor_debug"("NEXT", "trait")
  debug_1060:
  rx1120_fail:
    (rx1120_rep, rx1120_pos, $I10, $P10) = rx1120_cur."!mark_fail"(0)
    lt rx1120_pos, -1, rx1120_done
    eq rx1120_pos, -1, rx1120_fail
    jump $I10
  rx1120_done:
    rx1120_cur."!cursor_fail"()
    if_null rx1120_debug, debug_1061
    rx1120_cur."!cursor_debug"("FAIL", "trait")
  debug_1061:
    .return (rx1120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303430322.161") :method
.annotate 'line', 10
    $P1122 = self."!PREFIX__!subrule"("ws", "")
    new $P1123, "ResizablePMCArray"
    push $P1123, $P1122
    .return ($P1123)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303430322.161")
    .param pmc param_1128
.annotate 'line', 496
    .lex "self", param_1128
    $P1129 = param_1128."!protoregex"("trait_mod")
    .return ($P1129)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303430322.161")
    .param pmc param_1131
.annotate 'line', 496
    .lex "self", param_1131
    $P1132 = param_1131."!PREFIX__!protoregex"("trait_mod")
    .return ($P1132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    rx1134_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_1062
    rx1134_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1138_done
    goto rxscan1138_scan
  rxscan1138_loop:
    (rx1134_pos) = rx1134_cur."from"()
    inc rx1134_pos
    rx1134_cur."!cursor_from"(rx1134_pos)
    ge rx1134_pos, rx1134_eos, rxscan1138_done
  rxscan1138_scan:
    set_addr $I10, rxscan1138_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1138_done:
.annotate 'line', 497
  # rx subcapture "sym"
    set_addr $I10, rxcap_1139_fail
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  # rx literal  "is"
    add $I11, rx1134_pos, 2
    gt $I11, rx1134_eos, rx1134_fail
    sub $I11, rx1134_pos, rx1134_off
    substr $S10, rx1134_tgt, $I11, 2
    ne $S10, "is", rx1134_fail
    add rx1134_pos, 2
    set_addr $I10, rxcap_1139_fail
    ($I12, $I11) = rx1134_cur."!mark_peek"($I10)
    rx1134_cur."!cursor_pos"($I11)
    ($P10) = rx1134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1134_pos, "")
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1139_done
  rxcap_1139_fail:
    goto rx1134_fail
  rxcap_1139_done:
  # rx subrule "ws" subtype=method negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."ws"()
    unless $P10, rx1134_fail
    rx1134_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."deflongname"()
    unless $P10, rx1134_fail
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1134_pos = $P10."pos"()
  # rx rxquantr1141 ** 0..1
    set_addr $I10, rxquantr1141_done
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxquantr1141_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."circumfix"()
    unless $P10, rx1134_fail
    goto rxsubrule1142_pass
  rxsubrule1142_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1134_fail
  rxsubrule1142_pass:
    set_addr $I10, rxsubrule1142_back
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1134_pos = $P10."pos"()
    set_addr $I10, rxquantr1141_done
    (rx1134_rep) = rx1134_cur."!mark_commit"($I10)
  rxquantr1141_done:
  # rx subrule "ws" subtype=method negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."ws"()
    unless $P10, rx1134_fail
    rx1134_pos = $P10."pos"()
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "trait_mod:sym<is>")
    if_null rx1134_debug, debug_1063
    rx1134_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1134_pos)
  debug_1063:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 10
    if_null rx1134_debug, debug_1064
    rx1134_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1064:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_1065
    rx1134_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1065:
    .return (rx1134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303430322.161") :method
.annotate 'line', 10
    $P1136 = self."!PREFIX__!subrule"("ws", "is")
    new $P1137, "ResizablePMCArray"
    push $P1137, $P1136
    .return ($P1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1145_tgt
    .local int rx1145_pos
    .local int rx1145_off
    .local int rx1145_eos
    .local int rx1145_rep
    .local pmc rx1145_cur
    .local pmc rx1145_debug
    (rx1145_cur, rx1145_pos, rx1145_tgt, $I10) = self."!cursor_start"()
    rx1145_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1145_cur
    .local pmc match
    .lex "$/", match
    length rx1145_eos, rx1145_tgt
    gt rx1145_pos, rx1145_eos, rx1145_done
    set rx1145_off, 0
    lt rx1145_pos, 2, rx1145_start
    sub rx1145_off, rx1145_pos, 1
    substr rx1145_tgt, rx1145_tgt, rx1145_off
  rx1145_start:
    eq $I10, 1, rx1145_restart
    if_null rx1145_debug, debug_1066
    rx1145_cur."!cursor_debug"("START", "regex_declarator")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1149_done
    goto rxscan1149_scan
  rxscan1149_loop:
    (rx1145_pos) = rx1145_cur."from"()
    inc rx1145_pos
    rx1145_cur."!cursor_from"(rx1145_pos)
    ge rx1145_pos, rx1145_eos, rxscan1149_done
  rxscan1149_scan:
    set_addr $I10, rxscan1149_loop
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  rxscan1149_done:
.annotate 'line', 499
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1151_0:
.annotate 'line', 500
    set_addr $I10, alt1151_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1153_fail
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "proto", rx1145_fail
    add rx1145_pos, 5
    set_addr $I10, rxcap_1153_fail
    ($I12, $I11) = rx1145_cur."!mark_peek"($I10)
    rx1145_cur."!cursor_pos"($I11)
    ($P10) = rx1145_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1145_pos, "")
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1153_done
  rxcap_1153_fail:
    goto rx1145_fail
  rxcap_1153_done:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1155_0:
    set_addr $I10, alt1155_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "regex", rx1145_fail
    add rx1145_pos, 5
    goto alt1155_end
  alt1155_1:
    set_addr $I10, alt1155_2
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "token"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "token", rx1145_fail
    add rx1145_pos, 5
    goto alt1155_end
  alt1155_2:
  # rx literal  "rule"
    add $I11, rx1145_pos, 4
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 4
    ne $S10, "rule", rx1145_fail
    add rx1145_pos, 4
  alt1155_end:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 502
  # rx subrule "deflongname" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."deflongname"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1158_0:
.annotate 'line', 503
    set_addr $I10, alt1158_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "<...>", rx1145_fail
    add rx1145_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ENDSTMT"()
    unless $P10, rx1145_fail
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
    goto alt1158_end
  alt1158_1:
    set_addr $I10, alt1158_2
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1145_pos, 3
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 3
    ne $S10, "<*>", rx1145_fail
    add rx1145_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ENDSTMT"()
    unless $P10, rx1145_fail
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
    goto alt1158_end
  alt1158_2:
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1158_end:
.annotate 'line', 507
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 501
    goto alt1151_end
  alt1151_1:
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1172_fail
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  alt1171_0:
    set_addr $I10, alt1171_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "regex", rx1145_fail
    add rx1145_pos, 5
    goto alt1171_end
  alt1171_1:
    set_addr $I10, alt1171_2
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "token"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "token", rx1145_fail
    add rx1145_pos, 5
    goto alt1171_end
  alt1171_2:
  # rx literal  "rule"
    add $I11, rx1145_pos, 4
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 4
    ne $S10, "rule", rx1145_fail
    add rx1145_pos, 4
  alt1171_end:
    set_addr $I10, rxcap_1172_fail
    ($I12, $I11) = rx1145_cur."!mark_peek"($I10)
    rx1145_cur."!cursor_pos"($I11)
    ($P10) = rx1145_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1145_pos, "")
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1172_done
  rxcap_1172_fail:
    goto rx1145_fail
  rxcap_1172_done:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 509
  # rx subrule "deflongname" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."deflongname"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 510
  # rx subrule "newpad" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."newpad"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 511
  # rx rxquantr1176 ** 0..1
    set_addr $I10, rxquantr1176_done
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  rxquantr1176_loop:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 40, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."signature"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 41, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
    set_addr $I10, rxquantr1176_done
    (rx1145_rep) = rx1145_cur."!mark_commit"($I10)
  rxquantr1176_done:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 512
  # rx reduce name="regex_declarator" key="open"
    rx1145_cur."!cursor_pos"(rx1145_pos)
    rx1145_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 513
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ENDSTMT"()
    unless $P10, rx1145_fail
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1151_end:
.annotate 'line', 514
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 499
  # rx pass
    rx1145_cur."!cursor_pass"(rx1145_pos, "regex_declarator")
    if_null rx1145_debug, debug_1067
    rx1145_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1145_pos)
  debug_1067:
    .return (rx1145_cur)
  rx1145_restart:
.annotate 'line', 10
    if_null rx1145_debug, debug_1068
    rx1145_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1068:
  rx1145_fail:
    (rx1145_rep, rx1145_pos, $I10, $P10) = rx1145_cur."!mark_fail"(0)
    lt rx1145_pos, -1, rx1145_done
    eq rx1145_pos, -1, rx1145_fail
    jump $I10
  rx1145_done:
    rx1145_cur."!cursor_fail"()
    if_null rx1145_debug, debug_1069
    rx1145_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1069:
    .return (rx1145_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303430322.161") :method
.annotate 'line', 10
    $P1147 = self."!PREFIX__!subrule"("ws", "")
    new $P1148, "ResizablePMCArray"
    push $P1148, $P1147
    .return ($P1148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1186_tgt
    .local int rx1186_pos
    .local int rx1186_off
    .local int rx1186_eos
    .local int rx1186_rep
    .local pmc rx1186_cur
    .local pmc rx1186_debug
    (rx1186_cur, rx1186_pos, rx1186_tgt, $I10) = self."!cursor_start"()
    rx1186_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1186_cur
    .local pmc match
    .lex "$/", match
    length rx1186_eos, rx1186_tgt
    gt rx1186_pos, rx1186_eos, rx1186_done
    set rx1186_off, 0
    lt rx1186_pos, 2, rx1186_start
    sub rx1186_off, rx1186_pos, 1
    substr rx1186_tgt, rx1186_tgt, rx1186_off
  rx1186_start:
    eq $I10, 1, rx1186_restart
    if_null rx1186_debug, debug_1070
    rx1186_cur."!cursor_debug"("START", "dotty")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1190_done
    goto rxscan1190_scan
  rxscan1190_loop:
    (rx1186_pos) = rx1186_cur."from"()
    inc rx1186_pos
    rx1186_cur."!cursor_from"(rx1186_pos)
    ge rx1186_pos, rx1186_eos, rxscan1190_done
  rxscan1190_scan:
    set_addr $I10, rxscan1190_loop
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxscan1190_done:
.annotate 'line', 518
  # rx literal  "."
    add $I11, rx1186_pos, 1
    gt $I11, rx1186_eos, rx1186_fail
    sub $I11, rx1186_pos, rx1186_off
    ord $I11, rx1186_tgt, $I11
    ne $I11, 46, rx1186_fail
    add rx1186_pos, 1
  alt1191_0:
.annotate 'line', 519
    set_addr $I10, alt1191_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."deflongname"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1186_pos = $P10."pos"()
    goto alt1191_end
  alt1191_1:
.annotate 'line', 520
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "quote" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."quote"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1186_pos = $P10."pos"()
  alt1192_0:
.annotate 'line', 521
    set_addr $I10, alt1192_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1186_fail
    goto alt1192_end
  alt1192_1:
  # rx subrule "panic" subtype=method negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1186_fail
    rx1186_pos = $P10."pos"()
  alt1192_end:
  alt1191_end:
.annotate 'line', 527
  # rx rxquantr1193 ** 0..1
    set_addr $I10, rxquantr1193_done
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxquantr1193_loop:
  alt1194_0:
.annotate 'line', 524
    set_addr $I10, alt1194_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
.annotate 'line', 525
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "args" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."args"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1186_pos = $P10."pos"()
    goto alt1194_end
  alt1194_1:
.annotate 'line', 526
  # rx literal  ":"
    add $I11, rx1186_pos, 1
    gt $I11, rx1186_eos, rx1186_fail
    sub $I11, rx1186_pos, rx1186_off
    ord $I11, rx1186_tgt, $I11
    ne $I11, 58, rx1186_fail
    add rx1186_pos, 1
  # rx charclass s
    ge rx1186_pos, rx1186_eos, rx1186_fail
    sub $I10, rx1186_pos, rx1186_off
    is_cclass $I11, 32, rx1186_tgt, $I10
    unless $I11, rx1186_fail
    inc rx1186_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."arglist"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1186_pos = $P10."pos"()
  alt1194_end:
.annotate 'line', 527
    set_addr $I10, rxquantr1193_done
    (rx1186_rep) = rx1186_cur."!mark_commit"($I10)
  rxquantr1193_done:
.annotate 'line', 517
  # rx pass
    rx1186_cur."!cursor_pass"(rx1186_pos, "dotty")
    if_null rx1186_debug, debug_1071
    rx1186_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1186_pos)
  debug_1071:
    .return (rx1186_cur)
  rx1186_restart:
.annotate 'line', 10
    if_null rx1186_debug, debug_1072
    rx1186_cur."!cursor_debug"("NEXT", "dotty")
  debug_1072:
  rx1186_fail:
    (rx1186_rep, rx1186_pos, $I10, $P10) = rx1186_cur."!mark_fail"(0)
    lt rx1186_pos, -1, rx1186_done
    eq rx1186_pos, -1, rx1186_fail
    jump $I10
  rx1186_done:
    rx1186_cur."!cursor_fail"()
    if_null rx1186_debug, debug_1073
    rx1186_cur."!cursor_debug"("FAIL", "dotty")
  debug_1073:
    .return (rx1186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303430322.161") :method
.annotate 'line', 10
    $P1188 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1189, "ResizablePMCArray"
    push $P1189, "'"
    push $P1189, "\""
    push $P1189, $P1188
    .return ($P1189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303430322.161")
    .param pmc param_1196
.annotate 'line', 531
    .lex "self", param_1196
    $P1197 = param_1196."!protoregex"("term")
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303430322.161")
    .param pmc param_1199
.annotate 'line', 531
    .lex "self", param_1199
    $P1200 = param_1199."!PREFIX__!protoregex"("term")
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1202_tgt
    .local int rx1202_pos
    .local int rx1202_off
    .local int rx1202_eos
    .local int rx1202_rep
    .local pmc rx1202_cur
    .local pmc rx1202_debug
    (rx1202_cur, rx1202_pos, rx1202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1202_cur
    .local pmc match
    .lex "$/", match
    length rx1202_eos, rx1202_tgt
    gt rx1202_pos, rx1202_eos, rx1202_done
    set rx1202_off, 0
    lt rx1202_pos, 2, rx1202_start
    sub rx1202_off, rx1202_pos, 1
    substr rx1202_tgt, rx1202_tgt, rx1202_off
  rx1202_start:
    eq $I10, 1, rx1202_restart
    if_null rx1202_debug, debug_1074
    rx1202_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1205_done
    goto rxscan1205_scan
  rxscan1205_loop:
    (rx1202_pos) = rx1202_cur."from"()
    inc rx1202_pos
    rx1202_cur."!cursor_from"(rx1202_pos)
    ge rx1202_pos, rx1202_eos, rxscan1205_done
  rxscan1205_scan:
    set_addr $I10, rxscan1205_loop
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxscan1205_done:
.annotate 'line', 533
  # rx subcapture "sym"
    set_addr $I10, rxcap_1206_fail
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  # rx literal  "self"
    add $I11, rx1202_pos, 4
    gt $I11, rx1202_eos, rx1202_fail
    sub $I11, rx1202_pos, rx1202_off
    substr $S10, rx1202_tgt, $I11, 4
    ne $S10, "self", rx1202_fail
    add rx1202_pos, 4
    set_addr $I10, rxcap_1206_fail
    ($I12, $I11) = rx1202_cur."!mark_peek"($I10)
    rx1202_cur."!cursor_pos"($I11)
    ($P10) = rx1202_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1202_pos, "")
    rx1202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1206_done
  rxcap_1206_fail:
    goto rx1202_fail
  rxcap_1206_done:
  # rxanchor rwb
    le rx1202_pos, 0, rx1202_fail
    sub $I10, rx1202_pos, rx1202_off
    is_cclass $I11, 8192, rx1202_tgt, $I10
    if $I11, rx1202_fail
    dec $I10
    is_cclass $I11, 8192, rx1202_tgt, $I10
    unless $I11, rx1202_fail
  # rx pass
    rx1202_cur."!cursor_pass"(rx1202_pos, "term:sym<self>")
    if_null rx1202_debug, debug_1075
    rx1202_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1202_pos)
  debug_1075:
    .return (rx1202_cur)
  rx1202_restart:
.annotate 'line', 10
    if_null rx1202_debug, debug_1076
    rx1202_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1076:
  rx1202_fail:
    (rx1202_rep, rx1202_pos, $I10, $P10) = rx1202_cur."!mark_fail"(0)
    lt rx1202_pos, -1, rx1202_done
    eq rx1202_pos, -1, rx1202_fail
    jump $I10
  rx1202_done:
    rx1202_cur."!cursor_fail"()
    if_null rx1202_debug, debug_1077
    rx1202_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1077:
    .return (rx1202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303430322.161") :method
.annotate 'line', 10
    new $P1204, "ResizablePMCArray"
    push $P1204, "self"
    .return ($P1204)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1208_tgt
    .local int rx1208_pos
    .local int rx1208_off
    .local int rx1208_eos
    .local int rx1208_rep
    .local pmc rx1208_cur
    .local pmc rx1208_debug
    (rx1208_cur, rx1208_pos, rx1208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1208_cur
    .local pmc match
    .lex "$/", match
    length rx1208_eos, rx1208_tgt
    gt rx1208_pos, rx1208_eos, rx1208_done
    set rx1208_off, 0
    lt rx1208_pos, 2, rx1208_start
    sub rx1208_off, rx1208_pos, 1
    substr rx1208_tgt, rx1208_tgt, rx1208_off
  rx1208_start:
    eq $I10, 1, rx1208_restart
    if_null rx1208_debug, debug_1078
    rx1208_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1212_done
    goto rxscan1212_scan
  rxscan1212_loop:
    (rx1208_pos) = rx1208_cur."from"()
    inc rx1208_pos
    rx1208_cur."!cursor_from"(rx1208_pos)
    ge rx1208_pos, rx1208_eos, rxscan1212_done
  rxscan1212_scan:
    set_addr $I10, rxscan1212_loop
    rx1208_cur."!mark_push"(0, rx1208_pos, $I10)
  rxscan1212_done:
.annotate 'line', 536
  # rx subrule "deflongname" subtype=capture negate=
    rx1208_cur."!cursor_pos"(rx1208_pos)
    $P10 = rx1208_cur."deflongname"()
    unless $P10, rx1208_fail
    rx1208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1208_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1208_pos, rx1208_off
    substr $S10, rx1208_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1208_fail
  # rx subrule "args" subtype=capture negate=
    rx1208_cur."!cursor_pos"(rx1208_pos)
    $P10 = rx1208_cur."args"()
    unless $P10, rx1208_fail
    rx1208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1208_pos = $P10."pos"()
.annotate 'line', 535
  # rx pass
    rx1208_cur."!cursor_pass"(rx1208_pos, "term:sym<identifier>")
    if_null rx1208_debug, debug_1079
    rx1208_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1208_pos)
  debug_1079:
    .return (rx1208_cur)
  rx1208_restart:
.annotate 'line', 10
    if_null rx1208_debug, debug_1080
    rx1208_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1080:
  rx1208_fail:
    (rx1208_rep, rx1208_pos, $I10, $P10) = rx1208_cur."!mark_fail"(0)
    lt rx1208_pos, -1, rx1208_done
    eq rx1208_pos, -1, rx1208_fail
    jump $I10
  rx1208_done:
    rx1208_cur."!cursor_fail"()
    if_null rx1208_debug, debug_1081
    rx1208_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1081:
    .return (rx1208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303430322.161") :method
.annotate 'line', 10
    $P1210 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1211, "ResizablePMCArray"
    push $P1211, $P1210
    .return ($P1211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1214_tgt
    .local int rx1214_pos
    .local int rx1214_off
    .local int rx1214_eos
    .local int rx1214_rep
    .local pmc rx1214_cur
    .local pmc rx1214_debug
    (rx1214_cur, rx1214_pos, rx1214_tgt, $I10) = self."!cursor_start"()
    rx1214_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1214_cur
    .local pmc match
    .lex "$/", match
    length rx1214_eos, rx1214_tgt
    gt rx1214_pos, rx1214_eos, rx1214_done
    set rx1214_off, 0
    lt rx1214_pos, 2, rx1214_start
    sub rx1214_off, rx1214_pos, 1
    substr rx1214_tgt, rx1214_tgt, rx1214_off
  rx1214_start:
    eq $I10, 1, rx1214_restart
    if_null rx1214_debug, debug_1082
    rx1214_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1214_pos) = rx1214_cur."from"()
    inc rx1214_pos
    rx1214_cur."!cursor_from"(rx1214_pos)
    ge rx1214_pos, rx1214_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxscan1218_done:
.annotate 'line', 540
  # rx subrule "name" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."name"()
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1214_pos = $P10."pos"()
  # rx rxquantr1219 ** 0..1
    set_addr $I10, rxquantr1219_done
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxquantr1219_loop:
  # rx subrule "args" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."args"()
    unless $P10, rx1214_fail
    goto rxsubrule1220_pass
  rxsubrule1220_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1214_fail
  rxsubrule1220_pass:
    set_addr $I10, rxsubrule1220_back
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1214_pos = $P10."pos"()
    set_addr $I10, rxquantr1219_done
    (rx1214_rep) = rx1214_cur."!mark_commit"($I10)
  rxquantr1219_done:
.annotate 'line', 539
  # rx pass
    rx1214_cur."!cursor_pass"(rx1214_pos, "term:sym<name>")
    if_null rx1214_debug, debug_1083
    rx1214_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1214_pos)
  debug_1083:
    .return (rx1214_cur)
  rx1214_restart:
.annotate 'line', 10
    if_null rx1214_debug, debug_1084
    rx1214_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1084:
  rx1214_fail:
    (rx1214_rep, rx1214_pos, $I10, $P10) = rx1214_cur."!mark_fail"(0)
    lt rx1214_pos, -1, rx1214_done
    eq rx1214_pos, -1, rx1214_fail
    jump $I10
  rx1214_done:
    rx1214_cur."!cursor_fail"()
    if_null rx1214_debug, debug_1085
    rx1214_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1085:
    .return (rx1214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303430322.161") :method
.annotate 'line', 10
    $P1216 = self."!PREFIX__!subrule"("name", "")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1216
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1222_tgt
    .local int rx1222_pos
    .local int rx1222_off
    .local int rx1222_eos
    .local int rx1222_rep
    .local pmc rx1222_cur
    .local pmc rx1222_debug
    (rx1222_cur, rx1222_pos, rx1222_tgt, $I10) = self."!cursor_start"()
    rx1222_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1222_cur
    .local pmc match
    .lex "$/", match
    length rx1222_eos, rx1222_tgt
    gt rx1222_pos, rx1222_eos, rx1222_done
    set rx1222_off, 0
    lt rx1222_pos, 2, rx1222_start
    sub rx1222_off, rx1222_pos, 1
    substr rx1222_tgt, rx1222_tgt, rx1222_off
  rx1222_start:
    eq $I10, 1, rx1222_restart
    if_null rx1222_debug, debug_1086
    rx1222_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1225_done
    goto rxscan1225_scan
  rxscan1225_loop:
    (rx1222_pos) = rx1222_cur."from"()
    inc rx1222_pos
    rx1222_cur."!cursor_from"(rx1222_pos)
    ge rx1222_pos, rx1222_eos, rxscan1225_done
  rxscan1225_scan:
    set_addr $I10, rxscan1225_loop
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  rxscan1225_done:
.annotate 'line', 544
  # rx literal  "pir::"
    add $I11, rx1222_pos, 5
    gt $I11, rx1222_eos, rx1222_fail
    sub $I11, rx1222_pos, rx1222_off
    substr $S10, rx1222_tgt, $I11, 5
    ne $S10, "pir::", rx1222_fail
    add rx1222_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1226_fail
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1222_pos, rx1222_off
    find_not_cclass $I11, 8192, rx1222_tgt, $I10, rx1222_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1222_fail
    add rx1222_pos, rx1222_off, $I11
    set_addr $I10, rxcap_1226_fail
    ($I12, $I11) = rx1222_cur."!mark_peek"($I10)
    rx1222_cur."!cursor_pos"($I11)
    ($P10) = rx1222_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1222_pos, "")
    rx1222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1226_done
  rxcap_1226_fail:
    goto rx1222_fail
  rxcap_1226_done:
  # rx rxquantr1227 ** 0..1
    set_addr $I10, rxquantr1227_done
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  rxquantr1227_loop:
  # rx subrule "args" subtype=capture negate=
    rx1222_cur."!cursor_pos"(rx1222_pos)
    $P10 = rx1222_cur."args"()
    unless $P10, rx1222_fail
    goto rxsubrule1228_pass
  rxsubrule1228_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1222_fail
  rxsubrule1228_pass:
    set_addr $I10, rxsubrule1228_back
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1222_pos = $P10."pos"()
    set_addr $I10, rxquantr1227_done
    (rx1222_rep) = rx1222_cur."!mark_commit"($I10)
  rxquantr1227_done:
.annotate 'line', 543
  # rx pass
    rx1222_cur."!cursor_pass"(rx1222_pos, "term:sym<pir::op>")
    if_null rx1222_debug, debug_1087
    rx1222_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1222_pos)
  debug_1087:
    .return (rx1222_cur)
  rx1222_restart:
.annotate 'line', 10
    if_null rx1222_debug, debug_1088
    rx1222_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1088:
  rx1222_fail:
    (rx1222_rep, rx1222_pos, $I10, $P10) = rx1222_cur."!mark_fail"(0)
    lt rx1222_pos, -1, rx1222_done
    eq rx1222_pos, -1, rx1222_fail
    jump $I10
  rx1222_done:
    rx1222_cur."!cursor_fail"()
    if_null rx1222_debug, debug_1089
    rx1222_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1089:
    .return (rx1222_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303430322.161") :method
.annotate 'line', 10
    new $P1224, "ResizablePMCArray"
    push $P1224, "pir::"
    .return ($P1224)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P1238 = "226_1303430322.161" 
    capture_lex $P1238
    .local string rx1230_tgt
    .local int rx1230_pos
    .local int rx1230_off
    .local int rx1230_eos
    .local int rx1230_rep
    .local pmc rx1230_cur
    .local pmc rx1230_debug
    (rx1230_cur, rx1230_pos, rx1230_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1230_cur
    .local pmc match
    .lex "$/", match
    length rx1230_eos, rx1230_tgt
    gt rx1230_pos, rx1230_eos, rx1230_done
    set rx1230_off, 0
    lt rx1230_pos, 2, rx1230_start
    sub rx1230_off, rx1230_pos, 1
    substr rx1230_tgt, rx1230_tgt, rx1230_off
  rx1230_start:
    eq $I10, 1, rx1230_restart
    if_null rx1230_debug, debug_1090
    rx1230_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1090:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1233_done
    goto rxscan1233_scan
  rxscan1233_loop:
    (rx1230_pos) = rx1230_cur."from"()
    inc rx1230_pos
    rx1230_cur."!cursor_from"(rx1230_pos)
    ge rx1230_pos, rx1230_eos, rxscan1233_done
  rxscan1233_scan:
    set_addr $I10, rxscan1233_loop
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  rxscan1233_done:
.annotate 'line', 548
  # rx literal  "{*}"
    add $I11, rx1230_pos, 3
    gt $I11, rx1230_eos, rx1230_fail
    sub $I11, rx1230_pos, rx1230_off
    substr $S10, rx1230_tgt, $I11, 3
    ne $S10, "{*}", rx1230_fail
    add rx1230_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."ENDSTMT"()
    unless $P10, rx1230_fail
  alt1234_0:
.annotate 'line', 549
    set_addr $I10, alt1234_1
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
    rx1230_cur."!cursor_pos"(rx1230_pos)
    find_lex $P1235, unicode:"$\x{a2}"
    $P1236 = $P1235."MATCH"()
    store_lex "$/", $P1236
    .const 'Sub' $P1238 = "226_1303430322.161" 
    capture_lex $P1238
    $P1242 = $P1238()
    unless $P1242, rx1230_fail
    goto alt1234_end
  alt1234_1:
  # rx subrule "panic" subtype=method negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1230_fail
    rx1230_pos = $P10."pos"()
  alt1234_end:
.annotate 'line', 547
  # rx pass
    rx1230_cur."!cursor_pass"(rx1230_pos, "term:sym<onlystar>")
    if_null rx1230_debug, debug_1093
    rx1230_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1230_pos)
  debug_1093:
    .return (rx1230_cur)
  rx1230_restart:
.annotate 'line', 10
    if_null rx1230_debug, debug_1094
    rx1230_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1094:
  rx1230_fail:
    (rx1230_rep, rx1230_pos, $I10, $P10) = rx1230_cur."!mark_fail"(0)
    lt rx1230_pos, -1, rx1230_done
    eq rx1230_pos, -1, rx1230_fail
    jump $I10
  rx1230_done:
    rx1230_cur."!cursor_fail"()
    if_null rx1230_debug, debug_1095
    rx1230_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1095:
    .return (rx1230_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303430322.161") :method
.annotate 'line', 10
    new $P1232, "ResizablePMCArray"
    push $P1232, "{*}"
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1237"  :anon :subid("226_1303430322.161") :outer("224_1303430322.161")
.annotate 'line', 549
    find_dynamic_lex $P1239, "$*MULTINESS"
    unless_null $P1239, vivify_1091
    get_hll_global $P1239, "$MULTINESS"
    unless_null $P1239, vivify_1092
    die "Contextual $*MULTINESS not found"
  vivify_1092:
  vivify_1091:
    set $S1240, $P1239
    iseq $I1241, $S1240, "proto"
    .return ($I1241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_1096
    rx1244_cur."!cursor_debug"("START", "args")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 553
  # rx literal  "("
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 40, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."arglist"()
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1244_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 41, rx1244_fail
    add rx1244_pos, 1
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "args")
    if_null rx1244_debug, debug_1097
    rx1244_cur."!cursor_debug"("PASS", "args", " at pos=", rx1244_pos)
  debug_1097:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 10
    if_null rx1244_debug, debug_1098
    rx1244_cur."!cursor_debug"("NEXT", "args")
  debug_1098:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_1099
    rx1244_cur."!cursor_debug"("FAIL", "args")
  debug_1099:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303430322.161") :method
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1250_tgt
    .local int rx1250_pos
    .local int rx1250_off
    .local int rx1250_eos
    .local int rx1250_rep
    .local pmc rx1250_cur
    .local pmc rx1250_debug
    (rx1250_cur, rx1250_pos, rx1250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1250_cur
    .local pmc match
    .lex "$/", match
    length rx1250_eos, rx1250_tgt
    gt rx1250_pos, rx1250_eos, rx1250_done
    set rx1250_off, 0
    lt rx1250_pos, 2, rx1250_start
    sub rx1250_off, rx1250_pos, 1
    substr rx1250_tgt, rx1250_tgt, rx1250_off
  rx1250_start:
    eq $I10, 1, rx1250_restart
    if_null rx1250_debug, debug_1100
    rx1250_cur."!cursor_debug"("START", "arglist")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1254_done
    goto rxscan1254_scan
  rxscan1254_loop:
    (rx1250_pos) = rx1250_cur."from"()
    inc rx1250_pos
    rx1250_cur."!cursor_from"(rx1250_pos)
    ge rx1250_pos, rx1250_eos, rxscan1254_done
  rxscan1254_scan:
    set_addr $I10, rxscan1254_loop
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  rxscan1254_done:
.annotate 'line', 557
  # rx subrule "ws" subtype=method negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."ws"()
    unless $P10, rx1250_fail
    rx1250_pos = $P10."pos"()
  alt1255_0:
.annotate 'line', 558
    set_addr $I10, alt1255_1
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
.annotate 'line', 559
  # rx subrule "EXPR" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."EXPR"("f=")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1250_pos = $P10."pos"()
    goto alt1255_end
  alt1255_1:
  alt1255_end:
.annotate 'line', 556
  # rx pass
    rx1250_cur."!cursor_pass"(rx1250_pos, "arglist")
    if_null rx1250_debug, debug_1101
    rx1250_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1250_pos)
  debug_1101:
    .return (rx1250_cur)
  rx1250_restart:
.annotate 'line', 10
    if_null rx1250_debug, debug_1102
    rx1250_cur."!cursor_debug"("NEXT", "arglist")
  debug_1102:
  rx1250_fail:
    (rx1250_rep, rx1250_pos, $I10, $P10) = rx1250_cur."!mark_fail"(0)
    lt rx1250_pos, -1, rx1250_done
    eq rx1250_pos, -1, rx1250_fail
    jump $I10
  rx1250_done:
    rx1250_cur."!cursor_fail"()
    if_null rx1250_debug, debug_1103
    rx1250_cur."!cursor_debug"("FAIL", "arglist")
  debug_1103:
    .return (rx1250_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303430322.161") :method
.annotate 'line', 10
    $P1252 = self."!PREFIX__!subrule"("ws", "")
    new $P1253, "ResizablePMCArray"
    push $P1253, $P1252
    .return ($P1253)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_1104
    rx1257_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1261_done
    goto rxscan1261_scan
  rxscan1261_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1261_done
  rxscan1261_scan:
    set_addr $I10, rxscan1261_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1261_done:
.annotate 'line', 565
  # rx subrule "value" subtype=capture negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."value"()
    unless $P10, rx1257_fail
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1257_pos = $P10."pos"()
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, "term:sym<value>")
    if_null rx1257_debug, debug_1105
    rx1257_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1257_pos)
  debug_1105:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 10
    if_null rx1257_debug, debug_1106
    rx1257_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1106:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_1107
    rx1257_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1107:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303430322.161") :method
.annotate 'line', 10
    $P1259 = self."!PREFIX__!subrule"("value", "")
    new $P1260, "ResizablePMCArray"
    push $P1260, $P1259
    .return ($P1260)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1263_tgt
    .local int rx1263_pos
    .local int rx1263_off
    .local int rx1263_eos
    .local int rx1263_rep
    .local pmc rx1263_cur
    .local pmc rx1263_debug
    (rx1263_cur, rx1263_pos, rx1263_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1263_cur
    .local pmc match
    .lex "$/", match
    length rx1263_eos, rx1263_tgt
    gt rx1263_pos, rx1263_eos, rx1263_done
    set rx1263_off, 0
    lt rx1263_pos, 2, rx1263_start
    sub rx1263_off, rx1263_pos, 1
    substr rx1263_tgt, rx1263_tgt, rx1263_off
  rx1263_start:
    eq $I10, 1, rx1263_restart
    if_null rx1263_debug, debug_1108
    rx1263_cur."!cursor_debug"("START", "value")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1268_done
    goto rxscan1268_scan
  rxscan1268_loop:
    (rx1263_pos) = rx1263_cur."from"()
    inc rx1263_pos
    rx1263_cur."!cursor_from"(rx1263_pos)
    ge rx1263_pos, rx1263_eos, rxscan1268_done
  rxscan1268_scan:
    set_addr $I10, rxscan1268_loop
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  rxscan1268_done:
  alt1269_0:
.annotate 'line', 567
    set_addr $I10, alt1269_1
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
.annotate 'line', 568
  # rx subrule "quote" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."quote"()
    unless $P10, rx1263_fail
    rx1263_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1263_pos = $P10."pos"()
    goto alt1269_end
  alt1269_1:
.annotate 'line', 569
  # rx subrule "number" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."number"()
    unless $P10, rx1263_fail
    rx1263_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1263_pos = $P10."pos"()
  alt1269_end:
.annotate 'line', 567
  # rx pass
    rx1263_cur."!cursor_pass"(rx1263_pos, "value")
    if_null rx1263_debug, debug_1109
    rx1263_cur."!cursor_debug"("PASS", "value", " at pos=", rx1263_pos)
  debug_1109:
    .return (rx1263_cur)
  rx1263_restart:
.annotate 'line', 10
    if_null rx1263_debug, debug_1110
    rx1263_cur."!cursor_debug"("NEXT", "value")
  debug_1110:
  rx1263_fail:
    (rx1263_rep, rx1263_pos, $I10, $P10) = rx1263_cur."!mark_fail"(0)
    lt rx1263_pos, -1, rx1263_done
    eq rx1263_pos, -1, rx1263_fail
    jump $I10
  rx1263_done:
    rx1263_cur."!cursor_fail"()
    if_null rx1263_debug, debug_1111
    rx1263_cur."!cursor_debug"("FAIL", "value")
  debug_1111:
    .return (rx1263_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303430322.161") :method
.annotate 'line', 10
    $P1265 = self."!PREFIX__!subrule"("number", "")
    $P1266 = self."!PREFIX__!subrule"("quote", "")
    new $P1267, "ResizablePMCArray"
    push $P1267, $P1265
    push $P1267, $P1266
    .return ($P1267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1271_tgt
    .local int rx1271_pos
    .local int rx1271_off
    .local int rx1271_eos
    .local int rx1271_rep
    .local pmc rx1271_cur
    .local pmc rx1271_debug
    (rx1271_cur, rx1271_pos, rx1271_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1271_cur
    .local pmc match
    .lex "$/", match
    length rx1271_eos, rx1271_tgt
    gt rx1271_pos, rx1271_eos, rx1271_done
    set rx1271_off, 0
    lt rx1271_pos, 2, rx1271_start
    sub rx1271_off, rx1271_pos, 1
    substr rx1271_tgt, rx1271_tgt, rx1271_off
  rx1271_start:
    eq $I10, 1, rx1271_restart
    if_null rx1271_debug, debug_1112
    rx1271_cur."!cursor_debug"("START", "number")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1274_done
    goto rxscan1274_scan
  rxscan1274_loop:
    (rx1271_pos) = rx1271_cur."from"()
    inc rx1271_pos
    rx1271_cur."!cursor_from"(rx1271_pos)
    ge rx1271_pos, rx1271_eos, rxscan1274_done
  rxscan1274_scan:
    set_addr $I10, rxscan1274_loop
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  rxscan1274_done:
.annotate 'line', 573
  # rx subcapture "sign"
    set_addr $I10, rxcap_1276_fail
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1271_pos, rx1271_off
    set rx1271_rep, 0
    sub $I12, rx1271_eos, rx1271_pos
    le $I12, 1, rxenumcharlistq1275_loop
    set $I12, 1
  rxenumcharlistq1275_loop:
    le $I12, 0, rxenumcharlistq1275_done
    substr $S10, rx1271_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1275_done
    inc rx1271_rep
  rxenumcharlistq1275_done:
    add rx1271_pos, rx1271_pos, rx1271_rep
    set_addr $I10, rxcap_1276_fail
    ($I12, $I11) = rx1271_cur."!mark_peek"($I10)
    rx1271_cur."!cursor_pos"($I11)
    ($P10) = rx1271_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1271_pos, "")
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1276_done
  rxcap_1276_fail:
    goto rx1271_fail
  rxcap_1276_done:
  alt1277_0:
.annotate 'line', 574
    set_addr $I10, alt1277_1
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."dec_number"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1271_pos = $P10."pos"()
    goto alt1277_end
  alt1277_1:
  # rx subrule "integer" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."integer"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1271_pos = $P10."pos"()
  alt1277_end:
.annotate 'line', 572
  # rx pass
    rx1271_cur."!cursor_pass"(rx1271_pos, "number")
    if_null rx1271_debug, debug_1113
    rx1271_cur."!cursor_debug"("PASS", "number", " at pos=", rx1271_pos)
  debug_1113:
    .return (rx1271_cur)
  rx1271_restart:
.annotate 'line', 10
    if_null rx1271_debug, debug_1114
    rx1271_cur."!cursor_debug"("NEXT", "number")
  debug_1114:
  rx1271_fail:
    (rx1271_rep, rx1271_pos, $I10, $P10) = rx1271_cur."!mark_fail"(0)
    lt rx1271_pos, -1, rx1271_done
    eq rx1271_pos, -1, rx1271_fail
    jump $I10
  rx1271_done:
    rx1271_cur."!cursor_fail"()
    if_null rx1271_debug, debug_1115
    rx1271_cur."!cursor_debug"("FAIL", "number")
  debug_1115:
    .return (rx1271_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303430322.161") :method
.annotate 'line', 10
    new $P1273, "ResizablePMCArray"
    push $P1273, ""
    .return ($P1273)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303430322.161")
    .param pmc param_1279
.annotate 'line', 577
    .lex "self", param_1279
    $P1280 = param_1279."!protoregex"("quote")
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303430322.161")
    .param pmc param_1282
.annotate 'line', 577
    .lex "self", param_1282
    $P1283 = param_1282."!PREFIX__!protoregex"("quote")
    .return ($P1283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1285_tgt
    .local int rx1285_pos
    .local int rx1285_off
    .local int rx1285_eos
    .local int rx1285_rep
    .local pmc rx1285_cur
    .local pmc rx1285_debug
    (rx1285_cur, rx1285_pos, rx1285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1285_cur
    .local pmc match
    .lex "$/", match
    length rx1285_eos, rx1285_tgt
    gt rx1285_pos, rx1285_eos, rx1285_done
    set rx1285_off, 0
    lt rx1285_pos, 2, rx1285_start
    sub rx1285_off, rx1285_pos, 1
    substr rx1285_tgt, rx1285_tgt, rx1285_off
  rx1285_start:
    eq $I10, 1, rx1285_restart
    if_null rx1285_debug, debug_1116
    rx1285_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1116:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1288_done
    goto rxscan1288_scan
  rxscan1288_loop:
    (rx1285_pos) = rx1285_cur."from"()
    inc rx1285_pos
    rx1285_cur."!cursor_from"(rx1285_pos)
    ge rx1285_pos, rx1285_eos, rxscan1288_done
  rxscan1288_scan:
    set_addr $I10, rxscan1288_loop
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxscan1288_done:
.annotate 'line', 578
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1285_pos, rx1285_off
    substr $S10, rx1285_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1285_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."quote_EXPR"(":q")
    unless $P10, rx1285_fail
    rx1285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1285_pos = $P10."pos"()
  # rx pass
    rx1285_cur."!cursor_pass"(rx1285_pos, "quote:sym<apos>")
    if_null rx1285_debug, debug_1117
    rx1285_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1285_pos)
  debug_1117:
    .return (rx1285_cur)
  rx1285_restart:
.annotate 'line', 10
    if_null rx1285_debug, debug_1118
    rx1285_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1118:
  rx1285_fail:
    (rx1285_rep, rx1285_pos, $I10, $P10) = rx1285_cur."!mark_fail"(0)
    lt rx1285_pos, -1, rx1285_done
    eq rx1285_pos, -1, rx1285_fail
    jump $I10
  rx1285_done:
    rx1285_cur."!cursor_fail"()
    if_null rx1285_debug, debug_1119
    rx1285_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1119:
    .return (rx1285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303430322.161") :method
.annotate 'line', 10
    new $P1287, "ResizablePMCArray"
    push $P1287, "'"
    .return ($P1287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1290_tgt
    .local int rx1290_pos
    .local int rx1290_off
    .local int rx1290_eos
    .local int rx1290_rep
    .local pmc rx1290_cur
    .local pmc rx1290_debug
    (rx1290_cur, rx1290_pos, rx1290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1290_cur
    .local pmc match
    .lex "$/", match
    length rx1290_eos, rx1290_tgt
    gt rx1290_pos, rx1290_eos, rx1290_done
    set rx1290_off, 0
    lt rx1290_pos, 2, rx1290_start
    sub rx1290_off, rx1290_pos, 1
    substr rx1290_tgt, rx1290_tgt, rx1290_off
  rx1290_start:
    eq $I10, 1, rx1290_restart
    if_null rx1290_debug, debug_1120
    rx1290_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1293_done
    goto rxscan1293_scan
  rxscan1293_loop:
    (rx1290_pos) = rx1290_cur."from"()
    inc rx1290_pos
    rx1290_cur."!cursor_from"(rx1290_pos)
    ge rx1290_pos, rx1290_eos, rxscan1293_done
  rxscan1293_scan:
    set_addr $I10, rxscan1293_loop
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  rxscan1293_done:
.annotate 'line', 579
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1290_pos, rx1290_off
    substr $S10, rx1290_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1290_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."quote_EXPR"(":qq")
    unless $P10, rx1290_fail
    rx1290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1290_pos = $P10."pos"()
  # rx pass
    rx1290_cur."!cursor_pass"(rx1290_pos, "quote:sym<dblq>")
    if_null rx1290_debug, debug_1121
    rx1290_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1290_pos)
  debug_1121:
    .return (rx1290_cur)
  rx1290_restart:
.annotate 'line', 10
    if_null rx1290_debug, debug_1122
    rx1290_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1122:
  rx1290_fail:
    (rx1290_rep, rx1290_pos, $I10, $P10) = rx1290_cur."!mark_fail"(0)
    lt rx1290_pos, -1, rx1290_done
    eq rx1290_pos, -1, rx1290_fail
    jump $I10
  rx1290_done:
    rx1290_cur."!cursor_fail"()
    if_null rx1290_debug, debug_1123
    rx1290_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1123:
    .return (rx1290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303430322.161") :method
.annotate 'line', 10
    new $P1292, "ResizablePMCArray"
    push $P1292, "\""
    .return ($P1292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_1124
    rx1295_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1299_done
    goto rxscan1299_scan
  rxscan1299_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1299_done
  rxscan1299_scan:
    set_addr $I10, rxscan1299_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1299_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1300_fail
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  # rx literal  "q"
    add $I11, rx1295_pos, 1
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    ord $I11, rx1295_tgt, $I11
    ne $I11, 113, rx1295_fail
    add rx1295_pos, 1
    set_addr $I10, rxcap_1300_fail
    ($I12, $I11) = rx1295_cur."!mark_peek"($I10)
    rx1295_cur."!cursor_pos"($I11)
    ($P10) = rx1295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1295_pos, "")
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1300_done
  rxcap_1300_fail:
    goto rx1295_fail
  rxcap_1300_done:
  # rxanchor rwb
    le rx1295_pos, 0, rx1295_fail
    sub $I10, rx1295_pos, rx1295_off
    is_cclass $I11, 8192, rx1295_tgt, $I10
    if $I11, rx1295_fail
    dec $I10
    is_cclass $I11, 8192, rx1295_tgt, $I10
    unless $I11, rx1295_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1295_pos, rx1295_off
    substr $S10, rx1295_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1295_fail
  # rx subrule "ws" subtype=method negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."ws"()
    unless $P10, rx1295_fail
    rx1295_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."quote_EXPR"(":q")
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1295_pos = $P10."pos"()
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "quote:sym<q>")
    if_null rx1295_debug, debug_1125
    rx1295_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1295_pos)
  debug_1125:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 10
    if_null rx1295_debug, debug_1126
    rx1295_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1126:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_1127
    rx1295_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1127:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303430322.161") :method
.annotate 'line', 10
    $P1297 = self."!PREFIX__!subrule"("ws", "q")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_1128
    rx1302_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1307_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1302_pos, 2
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 2
    ne $S10, "qq", rx1302_fail
    add rx1302_pos, 2
    set_addr $I10, rxcap_1307_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1307_done
  rxcap_1307_fail:
    goto rx1302_fail
  rxcap_1307_done:
  # rxanchor rwb
    le rx1302_pos, 0, rx1302_fail
    sub $I10, rx1302_pos, rx1302_off
    is_cclass $I11, 8192, rx1302_tgt, $I10
    if $I11, rx1302_fail
    dec $I10
    is_cclass $I11, 8192, rx1302_tgt, $I10
    unless $I11, rx1302_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."quote_EXPR"(":qq")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1302_pos = $P10."pos"()
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "quote:sym<qq>")
    if_null rx1302_debug, debug_1129
    rx1302_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1302_pos)
  debug_1129:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 10
    if_null rx1302_debug, debug_1130
    rx1302_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1130:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_1131
    rx1302_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1131:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303430322.161") :method
.annotate 'line', 10
    $P1304 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1309_tgt
    .local int rx1309_pos
    .local int rx1309_off
    .local int rx1309_eos
    .local int rx1309_rep
    .local pmc rx1309_cur
    .local pmc rx1309_debug
    (rx1309_cur, rx1309_pos, rx1309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1309_cur
    .local pmc match
    .lex "$/", match
    length rx1309_eos, rx1309_tgt
    gt rx1309_pos, rx1309_eos, rx1309_done
    set rx1309_off, 0
    lt rx1309_pos, 2, rx1309_start
    sub rx1309_off, rx1309_pos, 1
    substr rx1309_tgt, rx1309_tgt, rx1309_off
  rx1309_start:
    eq $I10, 1, rx1309_restart
    if_null rx1309_debug, debug_1132
    rx1309_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1313_done
    goto rxscan1313_scan
  rxscan1313_loop:
    (rx1309_pos) = rx1309_cur."from"()
    inc rx1309_pos
    rx1309_cur."!cursor_from"(rx1309_pos)
    ge rx1309_pos, rx1309_eos, rxscan1313_done
  rxscan1313_scan:
    set_addr $I10, rxscan1313_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  rxscan1313_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1314_fail
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1309_pos, 1
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    ord $I11, rx1309_tgt, $I11
    ne $I11, 81, rx1309_fail
    add rx1309_pos, 1
    set_addr $I10, rxcap_1314_fail
    ($I12, $I11) = rx1309_cur."!mark_peek"($I10)
    rx1309_cur."!cursor_pos"($I11)
    ($P10) = rx1309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1309_pos, "")
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1314_done
  rxcap_1314_fail:
    goto rx1309_fail
  rxcap_1314_done:
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, 8192, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, 8192, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1309_fail
  # rx subrule "ws" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."ws"()
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."quote_EXPR"()
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1309_pos = $P10."pos"()
  # rx pass
    rx1309_cur."!cursor_pass"(rx1309_pos, "quote:sym<Q>")
    if_null rx1309_debug, debug_1133
    rx1309_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1309_pos)
  debug_1133:
    .return (rx1309_cur)
  rx1309_restart:
.annotate 'line', 10
    if_null rx1309_debug, debug_1134
    rx1309_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1134:
  rx1309_fail:
    (rx1309_rep, rx1309_pos, $I10, $P10) = rx1309_cur."!mark_fail"(0)
    lt rx1309_pos, -1, rx1309_done
    eq rx1309_pos, -1, rx1309_fail
    jump $I10
  rx1309_done:
    rx1309_cur."!cursor_fail"()
    if_null rx1309_debug, debug_1135
    rx1309_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1135:
    .return (rx1309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303430322.161") :method
.annotate 'line', 10
    $P1311 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1312, "ResizablePMCArray"
    push $P1312, $P1311
    .return ($P1312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1316_tgt
    .local int rx1316_pos
    .local int rx1316_off
    .local int rx1316_eos
    .local int rx1316_rep
    .local pmc rx1316_cur
    .local pmc rx1316_debug
    (rx1316_cur, rx1316_pos, rx1316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1316_cur
    .local pmc match
    .lex "$/", match
    length rx1316_eos, rx1316_tgt
    gt rx1316_pos, rx1316_eos, rx1316_done
    set rx1316_off, 0
    lt rx1316_pos, 2, rx1316_start
    sub rx1316_off, rx1316_pos, 1
    substr rx1316_tgt, rx1316_tgt, rx1316_off
  rx1316_start:
    eq $I10, 1, rx1316_restart
    if_null rx1316_debug, debug_1136
    rx1316_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1320_done
    goto rxscan1320_scan
  rxscan1320_loop:
    (rx1316_pos) = rx1316_cur."from"()
    inc rx1316_pos
    rx1316_cur."!cursor_from"(rx1316_pos)
    ge rx1316_pos, rx1316_eos, rxscan1320_done
  rxscan1320_scan:
    set_addr $I10, rxscan1320_loop
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  rxscan1320_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1321_fail
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1316_pos, 5
    gt $I11, rx1316_eos, rx1316_fail
    sub $I11, rx1316_pos, rx1316_off
    substr $S10, rx1316_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1316_fail
    add rx1316_pos, 5
    set_addr $I10, rxcap_1321_fail
    ($I12, $I11) = rx1316_cur."!mark_peek"($I10)
    rx1316_cur."!cursor_pos"($I11)
    ($P10) = rx1316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1316_pos, "")
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1321_done
  rxcap_1321_fail:
    goto rx1316_fail
  rxcap_1321_done:
  # rx subrule "ws" subtype=method negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."ws"()
    unless $P10, rx1316_fail
    rx1316_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."quote_EXPR"()
    unless $P10, rx1316_fail
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1316_pos = $P10."pos"()
  # rx pass
    rx1316_cur."!cursor_pass"(rx1316_pos, "quote:sym<Q:PIR>")
    if_null rx1316_debug, debug_1137
    rx1316_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1316_pos)
  debug_1137:
    .return (rx1316_cur)
  rx1316_restart:
.annotate 'line', 10
    if_null rx1316_debug, debug_1138
    rx1316_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1138:
  rx1316_fail:
    (rx1316_rep, rx1316_pos, $I10, $P10) = rx1316_cur."!mark_fail"(0)
    lt rx1316_pos, -1, rx1316_done
    eq rx1316_pos, -1, rx1316_fail
    jump $I10
  rx1316_done:
    rx1316_cur."!cursor_fail"()
    if_null rx1316_debug, debug_1139
    rx1316_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1139:
    .return (rx1316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303430322.161") :method
.annotate 'line', 10
    $P1318 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1319, "ResizablePMCArray"
    push $P1319, $P1318
    .return ($P1319)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1323_tgt
    .local int rx1323_pos
    .local int rx1323_off
    .local int rx1323_eos
    .local int rx1323_rep
    .local pmc rx1323_cur
    .local pmc rx1323_debug
    (rx1323_cur, rx1323_pos, rx1323_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1323_cur
    .local pmc match
    .lex "$/", match
    length rx1323_eos, rx1323_tgt
    gt rx1323_pos, rx1323_eos, rx1323_done
    set rx1323_off, 0
    lt rx1323_pos, 2, rx1323_start
    sub rx1323_off, rx1323_pos, 1
    substr rx1323_tgt, rx1323_tgt, rx1323_off
  rx1323_start:
    eq $I10, 1, rx1323_restart
    if_null rx1323_debug, debug_1140
    rx1323_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1327_done
    goto rxscan1327_scan
  rxscan1327_loop:
    (rx1323_pos) = rx1323_cur."from"()
    inc rx1323_pos
    rx1323_cur."!cursor_from"(rx1323_pos)
    ge rx1323_pos, rx1323_eos, rxscan1327_done
  rxscan1327_scan:
    set_addr $I10, rxscan1327_loop
    rx1323_cur."!mark_push"(0, rx1323_pos, $I10)
  rxscan1327_done:
.annotate 'line', 585
  # rx literal  "/"
    add $I11, rx1323_pos, 1
    gt $I11, rx1323_eos, rx1323_fail
    sub $I11, rx1323_pos, rx1323_off
    ord $I11, rx1323_tgt, $I11
    ne $I11, 47, rx1323_fail
    add rx1323_pos, 1
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."newpad"()
    unless $P10, rx1323_fail
    rx1323_pos = $P10."pos"()
.annotate 'line', 587
  # rx reduce name="quote:sym</ />" key="open"
    rx1323_cur."!cursor_pos"(rx1323_pos)
    rx1323_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 588
  # rx subrule "LANG" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1323_pos = $P10."pos"()
.annotate 'line', 589
  # rx literal  "/"
    add $I11, rx1323_pos, 1
    gt $I11, rx1323_eos, rx1323_fail
    sub $I11, rx1323_pos, rx1323_off
    ord $I11, rx1323_tgt, $I11
    ne $I11, 47, rx1323_fail
    add rx1323_pos, 1
.annotate 'line', 584
  # rx pass
    rx1323_cur."!cursor_pass"(rx1323_pos, "quote:sym</ />")
    if_null rx1323_debug, debug_1141
    rx1323_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1323_pos)
  debug_1141:
    .return (rx1323_cur)
  rx1323_restart:
.annotate 'line', 10
    if_null rx1323_debug, debug_1142
    rx1323_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1142:
  rx1323_fail:
    (rx1323_rep, rx1323_pos, $I10, $P10) = rx1323_cur."!mark_fail"(0)
    lt rx1323_pos, -1, rx1323_done
    eq rx1323_pos, -1, rx1323_fail
    jump $I10
  rx1323_done:
    rx1323_cur."!cursor_fail"()
    if_null rx1323_debug, debug_1143
    rx1323_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1143:
    .return (rx1323_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303430322.161") :method
.annotate 'line', 10
    $P1325 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1326, "ResizablePMCArray"
    push $P1326, $P1325
    .return ($P1326)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1329_tgt
    .local int rx1329_pos
    .local int rx1329_off
    .local int rx1329_eos
    .local int rx1329_rep
    .local pmc rx1329_cur
    .local pmc rx1329_debug
    (rx1329_cur, rx1329_pos, rx1329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1329_cur
    .local pmc match
    .lex "$/", match
    length rx1329_eos, rx1329_tgt
    gt rx1329_pos, rx1329_eos, rx1329_done
    set rx1329_off, 0
    lt rx1329_pos, 2, rx1329_start
    sub rx1329_off, rx1329_pos, 1
    substr rx1329_tgt, rx1329_tgt, rx1329_off
  rx1329_start:
    eq $I10, 1, rx1329_restart
    if_null rx1329_debug, debug_1144
    rx1329_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1144:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1329_pos) = rx1329_cur."from"()
    inc rx1329_pos
    rx1329_cur."!cursor_from"(rx1329_pos)
    ge rx1329_pos, rx1329_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  rxscan1332_done:
.annotate 'line', 592
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1329_pos, rx1329_off
    substr $S10, rx1329_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1329_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."quotemod_check"("s")
    unless $P10, rx1329_fail
  # rx subrule "variable" subtype=capture negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."variable"()
    unless $P10, rx1329_fail
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1329_pos = $P10."pos"()
  # rx pass
    rx1329_cur."!cursor_pass"(rx1329_pos, "quote_escape:sym<$>")
    if_null rx1329_debug, debug_1145
    rx1329_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1329_pos)
  debug_1145:
    .return (rx1329_cur)
  rx1329_restart:
.annotate 'line', 10
    if_null rx1329_debug, debug_1146
    rx1329_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1146:
  rx1329_fail:
    (rx1329_rep, rx1329_pos, $I10, $P10) = rx1329_cur."!mark_fail"(0)
    lt rx1329_pos, -1, rx1329_done
    eq rx1329_pos, -1, rx1329_fail
    jump $I10
  rx1329_done:
    rx1329_cur."!cursor_fail"()
    if_null rx1329_debug, debug_1147
    rx1329_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1147:
    .return (rx1329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303430322.161") :method
.annotate 'line', 10
    new $P1331, "ResizablePMCArray"
    push $P1331, "$"
    .return ($P1331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_1148
    rx1334_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1337_done
    goto rxscan1337_scan
  rxscan1337_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1337_done
  rxscan1337_scan:
    set_addr $I10, rxscan1337_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1337_done:
.annotate 'line', 593
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1334_pos, rx1334_off
    substr $S10, rx1334_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1334_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."quotemod_check"("c")
    unless $P10, rx1334_fail
  # rx subrule "block" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."block"()
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "quote_escape:sym<{ }>")
    if_null rx1334_debug, debug_1149
    rx1334_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1334_pos)
  debug_1149:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 10
    if_null rx1334_debug, debug_1150
    rx1334_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1150:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_1151
    rx1334_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1151:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303430322.161") :method
.annotate 'line', 10
    new $P1336, "ResizablePMCArray"
    push $P1336, "{"
    .return ($P1336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1339_tgt
    .local int rx1339_pos
    .local int rx1339_off
    .local int rx1339_eos
    .local int rx1339_rep
    .local pmc rx1339_cur
    .local pmc rx1339_debug
    (rx1339_cur, rx1339_pos, rx1339_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1339_cur
    .local pmc match
    .lex "$/", match
    length rx1339_eos, rx1339_tgt
    gt rx1339_pos, rx1339_eos, rx1339_done
    set rx1339_off, 0
    lt rx1339_pos, 2, rx1339_start
    sub rx1339_off, rx1339_pos, 1
    substr rx1339_tgt, rx1339_tgt, rx1339_off
  rx1339_start:
    eq $I10, 1, rx1339_restart
    if_null rx1339_debug, debug_1152
    rx1339_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1339_pos) = rx1339_cur."from"()
    inc rx1339_pos
    rx1339_cur."!cursor_from"(rx1339_pos)
    ge rx1339_pos, rx1339_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1339_cur."!mark_push"(0, rx1339_pos, $I10)
  rxscan1342_done:
.annotate 'line', 594
  # rx literal  "\\e"
    add $I11, rx1339_pos, 2
    gt $I11, rx1339_eos, rx1339_fail
    sub $I11, rx1339_pos, rx1339_off
    substr $S10, rx1339_tgt, $I11, 2
    ne $S10, "\\e", rx1339_fail
    add rx1339_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1339_cur."!cursor_pos"(rx1339_pos)
    $P10 = rx1339_cur."quotemod_check"("b")
    unless $P10, rx1339_fail
  # rx pass
    rx1339_cur."!cursor_pass"(rx1339_pos, "quote_escape:sym<esc>")
    if_null rx1339_debug, debug_1153
    rx1339_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1339_pos)
  debug_1153:
    .return (rx1339_cur)
  rx1339_restart:
.annotate 'line', 10
    if_null rx1339_debug, debug_1154
    rx1339_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1154:
  rx1339_fail:
    (rx1339_rep, rx1339_pos, $I10, $P10) = rx1339_cur."!mark_fail"(0)
    lt rx1339_pos, -1, rx1339_done
    eq rx1339_pos, -1, rx1339_fail
    jump $I10
  rx1339_done:
    rx1339_cur."!cursor_fail"()
    if_null rx1339_debug, debug_1155
    rx1339_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1155:
    .return (rx1339_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303430322.161") :method
.annotate 'line', 10
    new $P1341, "ResizablePMCArray"
    push $P1341, "\\e"
    .return ($P1341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1344_tgt
    .local int rx1344_pos
    .local int rx1344_off
    .local int rx1344_eos
    .local int rx1344_rep
    .local pmc rx1344_cur
    .local pmc rx1344_debug
    (rx1344_cur, rx1344_pos, rx1344_tgt, $I10) = self."!cursor_start"()
    rx1344_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1344_cur
    .local pmc match
    .lex "$/", match
    length rx1344_eos, rx1344_tgt
    gt rx1344_pos, rx1344_eos, rx1344_done
    set rx1344_off, 0
    lt rx1344_pos, 2, rx1344_start
    sub rx1344_off, rx1344_pos, 1
    substr rx1344_tgt, rx1344_tgt, rx1344_off
  rx1344_start:
    eq $I10, 1, rx1344_restart
    if_null rx1344_debug, debug_1156
    rx1344_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1156:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1348_done
    goto rxscan1348_scan
  rxscan1348_loop:
    (rx1344_pos) = rx1344_cur."from"()
    inc rx1344_pos
    rx1344_cur."!cursor_from"(rx1344_pos)
    ge rx1344_pos, rx1344_eos, rxscan1348_done
  rxscan1348_scan:
    set_addr $I10, rxscan1348_loop
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10)
  rxscan1348_done:
.annotate 'line', 596
  # rx literal  "("
    add $I11, rx1344_pos, 1
    gt $I11, rx1344_eos, rx1344_fail
    sub $I11, rx1344_pos, rx1344_off
    ord $I11, rx1344_tgt, $I11
    ne $I11, 40, rx1344_fail
    add rx1344_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1344_cur."!cursor_pos"(rx1344_pos)
    $P10 = rx1344_cur."ws"()
    unless $P10, rx1344_fail
    rx1344_pos = $P10."pos"()
  # rx rxquantr1349 ** 0..1
    set_addr $I10, rxquantr1349_done
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10)
  rxquantr1349_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1344_cur."!cursor_pos"(rx1344_pos)
    $P10 = rx1344_cur."EXPR"()
    unless $P10, rx1344_fail
    goto rxsubrule1350_pass
  rxsubrule1350_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1344_fail
  rxsubrule1350_pass:
    set_addr $I10, rxsubrule1350_back
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1344_pos = $P10."pos"()
    set_addr $I10, rxquantr1349_done
    (rx1344_rep) = rx1344_cur."!mark_commit"($I10)
  rxquantr1349_done:
  # rx literal  ")"
    add $I11, rx1344_pos, 1
    gt $I11, rx1344_eos, rx1344_fail
    sub $I11, rx1344_pos, rx1344_off
    ord $I11, rx1344_tgt, $I11
    ne $I11, 41, rx1344_fail
    add rx1344_pos, 1
  # rx pass
    rx1344_cur."!cursor_pass"(rx1344_pos, "circumfix:sym<( )>")
    if_null rx1344_debug, debug_1157
    rx1344_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1344_pos)
  debug_1157:
    .return (rx1344_cur)
  rx1344_restart:
.annotate 'line', 10
    if_null rx1344_debug, debug_1158
    rx1344_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1158:
  rx1344_fail:
    (rx1344_rep, rx1344_pos, $I10, $P10) = rx1344_cur."!mark_fail"(0)
    lt rx1344_pos, -1, rx1344_done
    eq rx1344_pos, -1, rx1344_fail
    jump $I10
  rx1344_done:
    rx1344_cur."!cursor_fail"()
    if_null rx1344_debug, debug_1159
    rx1344_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1159:
    .return (rx1344_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303430322.161") :method
.annotate 'line', 10
    $P1346 = self."!PREFIX__!subrule"("ws", "(")
    new $P1347, "ResizablePMCArray"
    push $P1347, $P1346
    .return ($P1347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    rx1352_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_1160
    rx1352_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1356_done
    goto rxscan1356_scan
  rxscan1356_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1356_done
  rxscan1356_scan:
    set_addr $I10, rxscan1356_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1356_done:
.annotate 'line', 597
  # rx literal  "["
    add $I11, rx1352_pos, 1
    gt $I11, rx1352_eos, rx1352_fail
    sub $I11, rx1352_pos, rx1352_off
    ord $I11, rx1352_tgt, $I11
    ne $I11, 91, rx1352_fail
    add rx1352_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."ws"()
    unless $P10, rx1352_fail
    rx1352_pos = $P10."pos"()
  # rx rxquantr1357 ** 0..1
    set_addr $I10, rxquantr1357_done
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxquantr1357_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."EXPR"()
    unless $P10, rx1352_fail
    goto rxsubrule1358_pass
  rxsubrule1358_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1352_fail
  rxsubrule1358_pass:
    set_addr $I10, rxsubrule1358_back
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1352_pos = $P10."pos"()
    set_addr $I10, rxquantr1357_done
    (rx1352_rep) = rx1352_cur."!mark_commit"($I10)
  rxquantr1357_done:
  # rx literal  "]"
    add $I11, rx1352_pos, 1
    gt $I11, rx1352_eos, rx1352_fail
    sub $I11, rx1352_pos, rx1352_off
    ord $I11, rx1352_tgt, $I11
    ne $I11, 93, rx1352_fail
    add rx1352_pos, 1
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "circumfix:sym<[ ]>")
    if_null rx1352_debug, debug_1161
    rx1352_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1352_pos)
  debug_1161:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 10
    if_null rx1352_debug, debug_1162
    rx1352_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1162:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_1163
    rx1352_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1163:
    .return (rx1352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303430322.161") :method
.annotate 'line', 10
    $P1354 = self."!PREFIX__!subrule"("ws", "[")
    new $P1355, "ResizablePMCArray"
    push $P1355, $P1354
    .return ($P1355)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1360_tgt
    .local int rx1360_pos
    .local int rx1360_off
    .local int rx1360_eos
    .local int rx1360_rep
    .local pmc rx1360_cur
    .local pmc rx1360_debug
    (rx1360_cur, rx1360_pos, rx1360_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1360_cur
    .local pmc match
    .lex "$/", match
    length rx1360_eos, rx1360_tgt
    gt rx1360_pos, rx1360_eos, rx1360_done
    set rx1360_off, 0
    lt rx1360_pos, 2, rx1360_start
    sub rx1360_off, rx1360_pos, 1
    substr rx1360_tgt, rx1360_tgt, rx1360_off
  rx1360_start:
    eq $I10, 1, rx1360_restart
    if_null rx1360_debug, debug_1164
    rx1360_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1164:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1363_done
    goto rxscan1363_scan
  rxscan1363_loop:
    (rx1360_pos) = rx1360_cur."from"()
    inc rx1360_pos
    rx1360_cur."!cursor_from"(rx1360_pos)
    ge rx1360_pos, rx1360_eos, rxscan1363_done
  rxscan1363_scan:
    set_addr $I10, rxscan1363_loop
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxscan1363_done:
.annotate 'line', 598
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1360_pos, rx1360_off
    substr $S10, rx1360_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1360_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1360_cur."!cursor_pos"(rx1360_pos)
    $P10 = rx1360_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1360_fail
    rx1360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1360_pos = $P10."pos"()
  # rx pass
    rx1360_cur."!cursor_pass"(rx1360_pos, "circumfix:sym<ang>")
    if_null rx1360_debug, debug_1165
    rx1360_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1360_pos)
  debug_1165:
    .return (rx1360_cur)
  rx1360_restart:
.annotate 'line', 10
    if_null rx1360_debug, debug_1166
    rx1360_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1166:
  rx1360_fail:
    (rx1360_rep, rx1360_pos, $I10, $P10) = rx1360_cur."!mark_fail"(0)
    lt rx1360_pos, -1, rx1360_done
    eq rx1360_pos, -1, rx1360_fail
    jump $I10
  rx1360_done:
    rx1360_cur."!cursor_fail"()
    if_null rx1360_debug, debug_1167
    rx1360_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1167:
    .return (rx1360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303430322.161") :method
.annotate 'line', 10
    new $P1362, "ResizablePMCArray"
    push $P1362, "<"
    .return ($P1362)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_1168
    rx1365_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1368_done
    goto rxscan1368_scan
  rxscan1368_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1368_done
  rxscan1368_scan:
    set_addr $I10, rxscan1368_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1368_done:
.annotate 'line', 599
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1365_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1365_pos = $P10."pos"()
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1365_debug, debug_1169
    rx1365_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1365_pos)
  debug_1169:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 10
    if_null rx1365_debug, debug_1170
    rx1365_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1170:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_1171
    rx1365_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1171:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303430322.161") :method
.annotate 'line', 10
    new $P1367, "ResizablePMCArray"
    push $P1367, unicode:"\x{ab}"
    .return ($P1367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_1172
    rx1370_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1373_done
    goto rxscan1373_scan
  rxscan1373_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1373_done
  rxscan1373_scan:
    set_addr $I10, rxscan1373_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1373_done:
.annotate 'line', 600
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1370_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."pblock"()
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "circumfix:sym<{ }>")
    if_null rx1370_debug, debug_1173
    rx1370_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1370_pos)
  debug_1173:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 10
    if_null rx1370_debug, debug_1174
    rx1370_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1174:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_1175
    rx1370_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1175:
    .return (rx1370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303430322.161") :method
.annotate 'line', 10
    new $P1372, "ResizablePMCArray"
    push $P1372, "{"
    .return ($P1372)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_1176
    rx1375_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1176:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 601
  # rx subrule "sigil" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."sigil"()
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1375_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 40, rx1375_fail
    add rx1375_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."semilist"()
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1375_pos = $P10."pos"()
  alt1380_0:
    set_addr $I10, alt1380_1
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  ")"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 41, rx1375_fail
    add rx1375_pos, 1
    goto alt1380_end
  alt1380_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."FAILGOAL"("')'")
    unless $P10, rx1375_fail
    goto rxsubrule1382_pass
  rxsubrule1382_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1375_fail
  rxsubrule1382_pass:
    set_addr $I10, rxsubrule1382_back
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10, $P10)
    rx1375_pos = $P10."pos"()
  alt1380_end:
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "circumfix:sym<sigil>")
    if_null rx1375_debug, debug_1177
    rx1375_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1375_pos)
  debug_1177:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 10
    if_null rx1375_debug, debug_1178
    rx1375_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1178:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1179
    rx1375_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1179:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303430322.161") :method
.annotate 'line', 10
    $P1377 = self."!PREFIX__!subrule"("sigil", "")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1180
    rx1384_cur."!cursor_debug"("START", "semilist")
  debug_1180:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 603
  # rx subrule "ws" subtype=method negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."ws"()
    unless $P10, rx1384_fail
    rx1384_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."statement"()
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1384_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."ws"()
    unless $P10, rx1384_fail
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "semilist")
    if_null rx1384_debug, debug_1181
    rx1384_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1384_pos)
  debug_1181:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 10
    if_null rx1384_debug, debug_1182
    rx1384_cur."!cursor_debug"("NEXT", "semilist")
  debug_1182:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1183
    rx1384_cur."!cursor_debug"("FAIL", "semilist")
  debug_1183:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303430322.161") :method
.annotate 'line', 10
    $P1386 = self."!PREFIX__!subrule"("ws", "")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1392_tgt
    .local int rx1392_pos
    .local int rx1392_off
    .local int rx1392_eos
    .local int rx1392_rep
    .local pmc rx1392_cur
    .local pmc rx1392_debug
    (rx1392_cur, rx1392_pos, rx1392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1392_cur
    .local pmc match
    .lex "$/", match
    length rx1392_eos, rx1392_tgt
    gt rx1392_pos, rx1392_eos, rx1392_done
    set rx1392_off, 0
    lt rx1392_pos, 2, rx1392_start
    sub rx1392_off, rx1392_pos, 1
    substr rx1392_tgt, rx1392_tgt, rx1392_off
  rx1392_start:
    eq $I10, 1, rx1392_restart
    if_null rx1392_debug, debug_1184
    rx1392_cur."!cursor_debug"("START", "infixish")
  debug_1184:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    (rx1392_pos) = rx1392_cur."from"()
    inc rx1392_pos
    rx1392_cur."!cursor_from"(rx1392_pos)
    ge rx1392_pos, rx1392_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  rxscan1395_done:
.annotate 'line', 626
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1392_cur."!cursor_pos"(rx1392_pos)
    $P10 = rx1392_cur."infixstopper"()
    if $P10, rx1392_fail
  # rx subrule "infix" subtype=capture negate=
    rx1392_cur."!cursor_pos"(rx1392_pos)
    $P10 = rx1392_cur."infix"()
    unless $P10, rx1392_fail
    rx1392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1392_pos = $P10."pos"()
  # rx pass
    rx1392_cur."!cursor_pass"(rx1392_pos, "infixish")
    if_null rx1392_debug, debug_1185
    rx1392_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1392_pos)
  debug_1185:
    .return (rx1392_cur)
  rx1392_restart:
.annotate 'line', 10
    if_null rx1392_debug, debug_1186
    rx1392_cur."!cursor_debug"("NEXT", "infixish")
  debug_1186:
  rx1392_fail:
    (rx1392_rep, rx1392_pos, $I10, $P10) = rx1392_cur."!mark_fail"(0)
    lt rx1392_pos, -1, rx1392_done
    eq rx1392_pos, -1, rx1392_fail
    jump $I10
  rx1392_done:
    rx1392_cur."!cursor_fail"()
    if_null rx1392_debug, debug_1187
    rx1392_cur."!cursor_debug"("FAIL", "infixish")
  debug_1187:
    .return (rx1392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303430322.161") :method
.annotate 'line', 10
    new $P1394, "ResizablePMCArray"
    push $P1394, ""
    .return ($P1394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1397_tgt
    .local int rx1397_pos
    .local int rx1397_off
    .local int rx1397_eos
    .local int rx1397_rep
    .local pmc rx1397_cur
    .local pmc rx1397_debug
    (rx1397_cur, rx1397_pos, rx1397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1397_cur
    .local pmc match
    .lex "$/", match
    length rx1397_eos, rx1397_tgt
    gt rx1397_pos, rx1397_eos, rx1397_done
    set rx1397_off, 0
    lt rx1397_pos, 2, rx1397_start
    sub rx1397_off, rx1397_pos, 1
    substr rx1397_tgt, rx1397_tgt, rx1397_off
  rx1397_start:
    eq $I10, 1, rx1397_restart
    if_null rx1397_debug, debug_1188
    rx1397_cur."!cursor_debug"("START", "infixstopper")
  debug_1188:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1400_done
    goto rxscan1400_scan
  rxscan1400_loop:
    (rx1397_pos) = rx1397_cur."from"()
    inc rx1397_pos
    rx1397_cur."!cursor_from"(rx1397_pos)
    ge rx1397_pos, rx1397_eos, rxscan1400_done
  rxscan1400_scan:
    set_addr $I10, rxscan1400_loop
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  rxscan1400_done:
.annotate 'line', 627
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1397_cur."!cursor_pos"(rx1397_pos)
    $P10 = rx1397_cur."lambda"()
    unless $P10, rx1397_fail
  # rx pass
    rx1397_cur."!cursor_pass"(rx1397_pos, "infixstopper")
    if_null rx1397_debug, debug_1189
    rx1397_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1397_pos)
  debug_1189:
    .return (rx1397_cur)
  rx1397_restart:
.annotate 'line', 10
    if_null rx1397_debug, debug_1190
    rx1397_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1190:
  rx1397_fail:
    (rx1397_rep, rx1397_pos, $I10, $P10) = rx1397_cur."!mark_fail"(0)
    lt rx1397_pos, -1, rx1397_done
    eq rx1397_pos, -1, rx1397_fail
    jump $I10
  rx1397_done:
    rx1397_cur."!cursor_fail"()
    if_null rx1397_debug, debug_1191
    rx1397_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1191:
    .return (rx1397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303430322.161") :method
.annotate 'line', 10
    new $P1399, "ResizablePMCArray"
    push $P1399, ""
    .return ($P1399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1402_tgt
    .local int rx1402_pos
    .local int rx1402_off
    .local int rx1402_eos
    .local int rx1402_rep
    .local pmc rx1402_cur
    .local pmc rx1402_debug
    (rx1402_cur, rx1402_pos, rx1402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1402_cur
    .local pmc match
    .lex "$/", match
    length rx1402_eos, rx1402_tgt
    gt rx1402_pos, rx1402_eos, rx1402_done
    set rx1402_off, 0
    lt rx1402_pos, 2, rx1402_start
    sub rx1402_off, rx1402_pos, 1
    substr rx1402_tgt, rx1402_tgt, rx1402_off
  rx1402_start:
    eq $I10, 1, rx1402_restart
    if_null rx1402_debug, debug_1192
    rx1402_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1192:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1406_done
    goto rxscan1406_scan
  rxscan1406_loop:
    (rx1402_pos) = rx1402_cur."from"()
    inc rx1402_pos
    rx1402_cur."!cursor_from"(rx1402_pos)
    ge rx1402_pos, rx1402_eos, rxscan1406_done
  rxscan1406_scan:
    set_addr $I10, rxscan1406_loop
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  rxscan1406_done:
.annotate 'line', 630
  # rx literal  "["
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 91, rx1402_fail
    add rx1402_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."ws"()
    unless $P10, rx1402_fail
    rx1402_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."EXPR"()
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1402_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 93, rx1402_fail
    add rx1402_pos, 1
.annotate 'line', 631
  # rx subrule "O" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."O"("%methodop")
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1402_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1402_cur."!cursor_pass"(rx1402_pos, "postcircumfix:sym<[ ]>")
    if_null rx1402_debug, debug_1193
    rx1402_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1402_pos)
  debug_1193:
    .return (rx1402_cur)
  rx1402_restart:
.annotate 'line', 10
    if_null rx1402_debug, debug_1194
    rx1402_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1194:
  rx1402_fail:
    (rx1402_rep, rx1402_pos, $I10, $P10) = rx1402_cur."!mark_fail"(0)
    lt rx1402_pos, -1, rx1402_done
    eq rx1402_pos, -1, rx1402_fail
    jump $I10
  rx1402_done:
    rx1402_cur."!cursor_fail"()
    if_null rx1402_debug, debug_1195
    rx1402_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1195:
    .return (rx1402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303430322.161") :method
.annotate 'line', 10
    $P1404 = self."!PREFIX__!subrule"("ws", "[")
    new $P1405, "ResizablePMCArray"
    push $P1405, $P1404
    .return ($P1405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1408_tgt
    .local int rx1408_pos
    .local int rx1408_off
    .local int rx1408_eos
    .local int rx1408_rep
    .local pmc rx1408_cur
    .local pmc rx1408_debug
    (rx1408_cur, rx1408_pos, rx1408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1408_cur
    .local pmc match
    .lex "$/", match
    length rx1408_eos, rx1408_tgt
    gt rx1408_pos, rx1408_eos, rx1408_done
    set rx1408_off, 0
    lt rx1408_pos, 2, rx1408_start
    sub rx1408_off, rx1408_pos, 1
    substr rx1408_tgt, rx1408_tgt, rx1408_off
  rx1408_start:
    eq $I10, 1, rx1408_restart
    if_null rx1408_debug, debug_1196
    rx1408_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1196:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1408_pos) = rx1408_cur."from"()
    inc rx1408_pos
    rx1408_cur."!cursor_from"(rx1408_pos)
    ge rx1408_pos, rx1408_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  rxscan1412_done:
.annotate 'line', 635
  # rx literal  "{"
    add $I11, rx1408_pos, 1
    gt $I11, rx1408_eos, rx1408_fail
    sub $I11, rx1408_pos, rx1408_off
    ord $I11, rx1408_tgt, $I11
    ne $I11, 123, rx1408_fail
    add rx1408_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."ws"()
    unless $P10, rx1408_fail
    rx1408_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."EXPR"()
    unless $P10, rx1408_fail
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1408_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1408_pos, 1
    gt $I11, rx1408_eos, rx1408_fail
    sub $I11, rx1408_pos, rx1408_off
    ord $I11, rx1408_tgt, $I11
    ne $I11, 125, rx1408_fail
    add rx1408_pos, 1
.annotate 'line', 636
  # rx subrule "O" subtype=capture negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."O"("%methodop")
    unless $P10, rx1408_fail
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1408_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1408_cur."!cursor_pass"(rx1408_pos, "postcircumfix:sym<{ }>")
    if_null rx1408_debug, debug_1197
    rx1408_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1408_pos)
  debug_1197:
    .return (rx1408_cur)
  rx1408_restart:
.annotate 'line', 10
    if_null rx1408_debug, debug_1198
    rx1408_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1198:
  rx1408_fail:
    (rx1408_rep, rx1408_pos, $I10, $P10) = rx1408_cur."!mark_fail"(0)
    lt rx1408_pos, -1, rx1408_done
    eq rx1408_pos, -1, rx1408_fail
    jump $I10
  rx1408_done:
    rx1408_cur."!cursor_fail"()
    if_null rx1408_debug, debug_1199
    rx1408_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1199:
    .return (rx1408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303430322.161") :method
.annotate 'line', 10
    $P1410 = self."!PREFIX__!subrule"("ws", "{")
    new $P1411, "ResizablePMCArray"
    push $P1411, $P1410
    .return ($P1411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1414_tgt
    .local int rx1414_pos
    .local int rx1414_off
    .local int rx1414_eos
    .local int rx1414_rep
    .local pmc rx1414_cur
    .local pmc rx1414_debug
    (rx1414_cur, rx1414_pos, rx1414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1414_cur
    .local pmc match
    .lex "$/", match
    length rx1414_eos, rx1414_tgt
    gt rx1414_pos, rx1414_eos, rx1414_done
    set rx1414_off, 0
    lt rx1414_pos, 2, rx1414_start
    sub rx1414_off, rx1414_pos, 1
    substr rx1414_tgt, rx1414_tgt, rx1414_off
  rx1414_start:
    eq $I10, 1, rx1414_restart
    if_null rx1414_debug, debug_1200
    rx1414_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1200:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1417_done
    goto rxscan1417_scan
  rxscan1417_loop:
    (rx1414_pos) = rx1414_cur."from"()
    inc rx1414_pos
    rx1414_cur."!cursor_from"(rx1414_pos)
    ge rx1414_pos, rx1414_eos, rxscan1417_done
  rxscan1417_scan:
    set_addr $I10, rxscan1417_loop
    rx1414_cur."!mark_push"(0, rx1414_pos, $I10)
  rxscan1417_done:
.annotate 'line', 640
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1414_pos, rx1414_off
    substr $S10, rx1414_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1414_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1414_cur."!cursor_pos"(rx1414_pos)
    $P10 = rx1414_cur."quote_EXPR"(":q")
    unless $P10, rx1414_fail
    rx1414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1414_pos = $P10."pos"()
.annotate 'line', 641
  # rx subrule "O" subtype=capture negate=
    rx1414_cur."!cursor_pos"(rx1414_pos)
    $P10 = rx1414_cur."O"("%methodop")
    unless $P10, rx1414_fail
    rx1414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1414_pos = $P10."pos"()
.annotate 'line', 639
  # rx pass
    rx1414_cur."!cursor_pass"(rx1414_pos, "postcircumfix:sym<ang>")
    if_null rx1414_debug, debug_1201
    rx1414_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1414_pos)
  debug_1201:
    .return (rx1414_cur)
  rx1414_restart:
.annotate 'line', 10
    if_null rx1414_debug, debug_1202
    rx1414_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1202:
  rx1414_fail:
    (rx1414_rep, rx1414_pos, $I10, $P10) = rx1414_cur."!mark_fail"(0)
    lt rx1414_pos, -1, rx1414_done
    eq rx1414_pos, -1, rx1414_fail
    jump $I10
  rx1414_done:
    rx1414_cur."!cursor_fail"()
    if_null rx1414_debug, debug_1203
    rx1414_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1203:
    .return (rx1414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303430322.161") :method
.annotate 'line', 10
    new $P1416, "ResizablePMCArray"
    push $P1416, "<"
    .return ($P1416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1204
    rx1419_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1204:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    (rx1419_pos) = rx1419_cur."from"()
    inc rx1419_pos
    rx1419_cur."!cursor_from"(rx1419_pos)
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 645
  # rx literal  "("
    add $I11, rx1419_pos, 1
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    ord $I11, rx1419_tgt, $I11
    ne $I11, 40, rx1419_fail
    add rx1419_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."ws"()
    unless $P10, rx1419_fail
    rx1419_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."arglist"()
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1419_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1419_pos, 1
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    ord $I11, rx1419_tgt, $I11
    ne $I11, 41, rx1419_fail
    add rx1419_pos, 1
.annotate 'line', 646
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%methodop")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
.annotate 'line', 644
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "postcircumfix:sym<( )>")
    if_null rx1419_debug, debug_1205
    rx1419_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1419_pos)
  debug_1205:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 10
    if_null rx1419_debug, debug_1206
    rx1419_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1206:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1207
    rx1419_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1207:
    .return (rx1419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303430322.161") :method
.annotate 'line', 10
    $P1421 = self."!PREFIX__!subrule"("ws", "(")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1425_tgt
    .local int rx1425_pos
    .local int rx1425_off
    .local int rx1425_eos
    .local int rx1425_rep
    .local pmc rx1425_cur
    .local pmc rx1425_debug
    (rx1425_cur, rx1425_pos, rx1425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1425_cur
    .local pmc match
    .lex "$/", match
    length rx1425_eos, rx1425_tgt
    gt rx1425_pos, rx1425_eos, rx1425_done
    set rx1425_off, 0
    lt rx1425_pos, 2, rx1425_start
    sub rx1425_off, rx1425_pos, 1
    substr rx1425_tgt, rx1425_tgt, rx1425_off
  rx1425_start:
    eq $I10, 1, rx1425_restart
    if_null rx1425_debug, debug_1208
    rx1425_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1208:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1429_done
    goto rxscan1429_scan
  rxscan1429_loop:
    (rx1425_pos) = rx1425_cur."from"()
    inc rx1425_pos
    rx1425_cur."!cursor_from"(rx1425_pos)
    ge rx1425_pos, rx1425_eos, rxscan1429_done
  rxscan1429_scan:
    set_addr $I10, rxscan1429_loop
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  rxscan1429_done:
.annotate 'line', 649
  # rx subrule "dotty" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."dotty"()
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1425_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."O"("%methodop")
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1425_pos = $P10."pos"()
  # rx pass
    rx1425_cur."!cursor_pass"(rx1425_pos, "postfix:sym<.>")
    if_null rx1425_debug, debug_1209
    rx1425_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1425_pos)
  debug_1209:
    .return (rx1425_cur)
  rx1425_restart:
.annotate 'line', 10
    if_null rx1425_debug, debug_1210
    rx1425_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1210:
  rx1425_fail:
    (rx1425_rep, rx1425_pos, $I10, $P10) = rx1425_cur."!mark_fail"(0)
    lt rx1425_pos, -1, rx1425_done
    eq rx1425_pos, -1, rx1425_fail
    jump $I10
  rx1425_done:
    rx1425_cur."!cursor_fail"()
    if_null rx1425_debug, debug_1211
    rx1425_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1211:
    .return (rx1425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303430322.161") :method
.annotate 'line', 10
    $P1427 = self."!PREFIX__!subrule"("dotty", "")
    new $P1428, "ResizablePMCArray"
    push $P1428, $P1427
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1431_tgt
    .local int rx1431_pos
    .local int rx1431_off
    .local int rx1431_eos
    .local int rx1431_rep
    .local pmc rx1431_cur
    .local pmc rx1431_debug
    (rx1431_cur, rx1431_pos, rx1431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1431_cur
    .local pmc match
    .lex "$/", match
    length rx1431_eos, rx1431_tgt
    gt rx1431_pos, rx1431_eos, rx1431_done
    set rx1431_off, 0
    lt rx1431_pos, 2, rx1431_start
    sub rx1431_off, rx1431_pos, 1
    substr rx1431_tgt, rx1431_tgt, rx1431_off
  rx1431_start:
    eq $I10, 1, rx1431_restart
    if_null rx1431_debug, debug_1212
    rx1431_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1212:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1435_done
    goto rxscan1435_scan
  rxscan1435_loop:
    (rx1431_pos) = rx1431_cur."from"()
    inc rx1431_pos
    rx1431_cur."!cursor_from"(rx1431_pos)
    ge rx1431_pos, rx1431_eos, rxscan1435_done
  rxscan1435_scan:
    set_addr $I10, rxscan1435_loop
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  rxscan1435_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1436_fail
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  # rx literal  "++"
    add $I11, rx1431_pos, 2
    gt $I11, rx1431_eos, rx1431_fail
    sub $I11, rx1431_pos, rx1431_off
    substr $S10, rx1431_tgt, $I11, 2
    ne $S10, "++", rx1431_fail
    add rx1431_pos, 2
    set_addr $I10, rxcap_1436_fail
    ($I12, $I11) = rx1431_cur."!mark_peek"($I10)
    rx1431_cur."!cursor_pos"($I11)
    ($P10) = rx1431_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1431_pos, "")
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1436_done
  rxcap_1436_fail:
    goto rx1431_fail
  rxcap_1436_done:
  # rx subrule "O" subtype=capture negate=
    rx1431_cur."!cursor_pos"(rx1431_pos)
    $P10 = rx1431_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1431_fail
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1431_pos = $P10."pos"()
  # rx pass
    rx1431_cur."!cursor_pass"(rx1431_pos, "prefix:sym<++>")
    if_null rx1431_debug, debug_1213
    rx1431_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1431_pos)
  debug_1213:
    .return (rx1431_cur)
  rx1431_restart:
.annotate 'line', 10
    if_null rx1431_debug, debug_1214
    rx1431_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1214:
  rx1431_fail:
    (rx1431_rep, rx1431_pos, $I10, $P10) = rx1431_cur."!mark_fail"(0)
    lt rx1431_pos, -1, rx1431_done
    eq rx1431_pos, -1, rx1431_fail
    jump $I10
  rx1431_done:
    rx1431_cur."!cursor_fail"()
    if_null rx1431_debug, debug_1215
    rx1431_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1215:
    .return (rx1431_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303430322.161") :method
.annotate 'line', 10
    $P1433 = self."!PREFIX__!subrule"("O", "++")
    new $P1434, "ResizablePMCArray"
    push $P1434, $P1433
    .return ($P1434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1438_tgt
    .local int rx1438_pos
    .local int rx1438_off
    .local int rx1438_eos
    .local int rx1438_rep
    .local pmc rx1438_cur
    .local pmc rx1438_debug
    (rx1438_cur, rx1438_pos, rx1438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1438_cur
    .local pmc match
    .lex "$/", match
    length rx1438_eos, rx1438_tgt
    gt rx1438_pos, rx1438_eos, rx1438_done
    set rx1438_off, 0
    lt rx1438_pos, 2, rx1438_start
    sub rx1438_off, rx1438_pos, 1
    substr rx1438_tgt, rx1438_tgt, rx1438_off
  rx1438_start:
    eq $I10, 1, rx1438_restart
    if_null rx1438_debug, debug_1216
    rx1438_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1216:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1442_done
    goto rxscan1442_scan
  rxscan1442_loop:
    (rx1438_pos) = rx1438_cur."from"()
    inc rx1438_pos
    rx1438_cur."!cursor_from"(rx1438_pos)
    ge rx1438_pos, rx1438_eos, rxscan1442_done
  rxscan1442_scan:
    set_addr $I10, rxscan1442_loop
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  rxscan1442_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1443_fail
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  # rx literal  "--"
    add $I11, rx1438_pos, 2
    gt $I11, rx1438_eos, rx1438_fail
    sub $I11, rx1438_pos, rx1438_off
    substr $S10, rx1438_tgt, $I11, 2
    ne $S10, "--", rx1438_fail
    add rx1438_pos, 2
    set_addr $I10, rxcap_1443_fail
    ($I12, $I11) = rx1438_cur."!mark_peek"($I10)
    rx1438_cur."!cursor_pos"($I11)
    ($P10) = rx1438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1438_pos, "")
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1443_done
  rxcap_1443_fail:
    goto rx1438_fail
  rxcap_1443_done:
  # rx subrule "O" subtype=capture negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1438_fail
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1438_pos = $P10."pos"()
  # rx pass
    rx1438_cur."!cursor_pass"(rx1438_pos, "prefix:sym<-->")
    if_null rx1438_debug, debug_1217
    rx1438_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1438_pos)
  debug_1217:
    .return (rx1438_cur)
  rx1438_restart:
.annotate 'line', 10
    if_null rx1438_debug, debug_1218
    rx1438_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1218:
  rx1438_fail:
    (rx1438_rep, rx1438_pos, $I10, $P10) = rx1438_cur."!mark_fail"(0)
    lt rx1438_pos, -1, rx1438_done
    eq rx1438_pos, -1, rx1438_fail
    jump $I10
  rx1438_done:
    rx1438_cur."!cursor_fail"()
    if_null rx1438_debug, debug_1219
    rx1438_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1219:
    .return (rx1438_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303430322.161") :method
.annotate 'line', 10
    $P1440 = self."!PREFIX__!subrule"("O", "--")
    new $P1441, "ResizablePMCArray"
    push $P1441, $P1440
    .return ($P1441)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1445_tgt
    .local int rx1445_pos
    .local int rx1445_off
    .local int rx1445_eos
    .local int rx1445_rep
    .local pmc rx1445_cur
    .local pmc rx1445_debug
    (rx1445_cur, rx1445_pos, rx1445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1445_cur
    .local pmc match
    .lex "$/", match
    length rx1445_eos, rx1445_tgt
    gt rx1445_pos, rx1445_eos, rx1445_done
    set rx1445_off, 0
    lt rx1445_pos, 2, rx1445_start
    sub rx1445_off, rx1445_pos, 1
    substr rx1445_tgt, rx1445_tgt, rx1445_off
  rx1445_start:
    eq $I10, 1, rx1445_restart
    if_null rx1445_debug, debug_1220
    rx1445_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1220:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1449_done
    goto rxscan1449_scan
  rxscan1449_loop:
    (rx1445_pos) = rx1445_cur."from"()
    inc rx1445_pos
    rx1445_cur."!cursor_from"(rx1445_pos)
    ge rx1445_pos, rx1445_eos, rxscan1449_done
  rxscan1449_scan:
    set_addr $I10, rxscan1449_loop
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  rxscan1449_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1450_fail
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  # rx literal  "++"
    add $I11, rx1445_pos, 2
    gt $I11, rx1445_eos, rx1445_fail
    sub $I11, rx1445_pos, rx1445_off
    substr $S10, rx1445_tgt, $I11, 2
    ne $S10, "++", rx1445_fail
    add rx1445_pos, 2
    set_addr $I10, rxcap_1450_fail
    ($I12, $I11) = rx1445_cur."!mark_peek"($I10)
    rx1445_cur."!cursor_pos"($I11)
    ($P10) = rx1445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1445_pos, "")
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1450_done
  rxcap_1450_fail:
    goto rx1445_fail
  rxcap_1450_done:
  # rx subrule "O" subtype=capture negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."O"("%autoincrement")
    unless $P10, rx1445_fail
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1445_pos = $P10."pos"()
  # rx pass
    rx1445_cur."!cursor_pass"(rx1445_pos, "postfix:sym<++>")
    if_null rx1445_debug, debug_1221
    rx1445_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1445_pos)
  debug_1221:
    .return (rx1445_cur)
  rx1445_restart:
.annotate 'line', 10
    if_null rx1445_debug, debug_1222
    rx1445_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1222:
  rx1445_fail:
    (rx1445_rep, rx1445_pos, $I10, $P10) = rx1445_cur."!mark_fail"(0)
    lt rx1445_pos, -1, rx1445_done
    eq rx1445_pos, -1, rx1445_fail
    jump $I10
  rx1445_done:
    rx1445_cur."!cursor_fail"()
    if_null rx1445_debug, debug_1223
    rx1445_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1223:
    .return (rx1445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303430322.161") :method
.annotate 'line', 10
    $P1447 = self."!PREFIX__!subrule"("O", "++")
    new $P1448, "ResizablePMCArray"
    push $P1448, $P1447
    .return ($P1448)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1452_tgt
    .local int rx1452_pos
    .local int rx1452_off
    .local int rx1452_eos
    .local int rx1452_rep
    .local pmc rx1452_cur
    .local pmc rx1452_debug
    (rx1452_cur, rx1452_pos, rx1452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1452_cur
    .local pmc match
    .lex "$/", match
    length rx1452_eos, rx1452_tgt
    gt rx1452_pos, rx1452_eos, rx1452_done
    set rx1452_off, 0
    lt rx1452_pos, 2, rx1452_start
    sub rx1452_off, rx1452_pos, 1
    substr rx1452_tgt, rx1452_tgt, rx1452_off
  rx1452_start:
    eq $I10, 1, rx1452_restart
    if_null rx1452_debug, debug_1224
    rx1452_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1224:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1456_done
    goto rxscan1456_scan
  rxscan1456_loop:
    (rx1452_pos) = rx1452_cur."from"()
    inc rx1452_pos
    rx1452_cur."!cursor_from"(rx1452_pos)
    ge rx1452_pos, rx1452_eos, rxscan1456_done
  rxscan1456_scan:
    set_addr $I10, rxscan1456_loop
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  rxscan1456_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1457_fail
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  # rx literal  "--"
    add $I11, rx1452_pos, 2
    gt $I11, rx1452_eos, rx1452_fail
    sub $I11, rx1452_pos, rx1452_off
    substr $S10, rx1452_tgt, $I11, 2
    ne $S10, "--", rx1452_fail
    add rx1452_pos, 2
    set_addr $I10, rxcap_1457_fail
    ($I12, $I11) = rx1452_cur."!mark_peek"($I10)
    rx1452_cur."!cursor_pos"($I11)
    ($P10) = rx1452_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1452_pos, "")
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1457_done
  rxcap_1457_fail:
    goto rx1452_fail
  rxcap_1457_done:
  # rx subrule "O" subtype=capture negate=
    rx1452_cur."!cursor_pos"(rx1452_pos)
    $P10 = rx1452_cur."O"("%autoincrement")
    unless $P10, rx1452_fail
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1452_pos = $P10."pos"()
  # rx pass
    rx1452_cur."!cursor_pass"(rx1452_pos, "postfix:sym<-->")
    if_null rx1452_debug, debug_1225
    rx1452_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1452_pos)
  debug_1225:
    .return (rx1452_cur)
  rx1452_restart:
.annotate 'line', 10
    if_null rx1452_debug, debug_1226
    rx1452_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1226:
  rx1452_fail:
    (rx1452_rep, rx1452_pos, $I10, $P10) = rx1452_cur."!mark_fail"(0)
    lt rx1452_pos, -1, rx1452_done
    eq rx1452_pos, -1, rx1452_fail
    jump $I10
  rx1452_done:
    rx1452_cur."!cursor_fail"()
    if_null rx1452_debug, debug_1227
    rx1452_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1227:
    .return (rx1452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303430322.161") :method
.annotate 'line', 10
    $P1454 = self."!PREFIX__!subrule"("O", "--")
    new $P1455, "ResizablePMCArray"
    push $P1455, $P1454
    .return ($P1455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1459_tgt
    .local int rx1459_pos
    .local int rx1459_off
    .local int rx1459_eos
    .local int rx1459_rep
    .local pmc rx1459_cur
    .local pmc rx1459_debug
    (rx1459_cur, rx1459_pos, rx1459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1459_cur
    .local pmc match
    .lex "$/", match
    length rx1459_eos, rx1459_tgt
    gt rx1459_pos, rx1459_eos, rx1459_done
    set rx1459_off, 0
    lt rx1459_pos, 2, rx1459_start
    sub rx1459_off, rx1459_pos, 1
    substr rx1459_tgt, rx1459_tgt, rx1459_off
  rx1459_start:
    eq $I10, 1, rx1459_restart
    if_null rx1459_debug, debug_1228
    rx1459_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1228:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1463_done
    goto rxscan1463_scan
  rxscan1463_loop:
    (rx1459_pos) = rx1459_cur."from"()
    inc rx1459_pos
    rx1459_cur."!cursor_from"(rx1459_pos)
    ge rx1459_pos, rx1459_eos, rxscan1463_done
  rxscan1463_scan:
    set_addr $I10, rxscan1463_loop
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  rxscan1463_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1464_fail
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  # rx literal  "**"
    add $I11, rx1459_pos, 2
    gt $I11, rx1459_eos, rx1459_fail
    sub $I11, rx1459_pos, rx1459_off
    substr $S10, rx1459_tgt, $I11, 2
    ne $S10, "**", rx1459_fail
    add rx1459_pos, 2
    set_addr $I10, rxcap_1464_fail
    ($I12, $I11) = rx1459_cur."!mark_peek"($I10)
    rx1459_cur."!cursor_pos"($I11)
    ($P10) = rx1459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1459_pos, "")
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1464_done
  rxcap_1464_fail:
    goto rx1459_fail
  rxcap_1464_done:
  # rx subrule "O" subtype=capture negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1459_fail
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1459_pos = $P10."pos"()
  # rx pass
    rx1459_cur."!cursor_pass"(rx1459_pos, "infix:sym<**>")
    if_null rx1459_debug, debug_1229
    rx1459_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1459_pos)
  debug_1229:
    .return (rx1459_cur)
  rx1459_restart:
.annotate 'line', 10
    if_null rx1459_debug, debug_1230
    rx1459_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1230:
  rx1459_fail:
    (rx1459_rep, rx1459_pos, $I10, $P10) = rx1459_cur."!mark_fail"(0)
    lt rx1459_pos, -1, rx1459_done
    eq rx1459_pos, -1, rx1459_fail
    jump $I10
  rx1459_done:
    rx1459_cur."!cursor_fail"()
    if_null rx1459_debug, debug_1231
    rx1459_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1231:
    .return (rx1459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303430322.161") :method
.annotate 'line', 10
    $P1461 = self."!PREFIX__!subrule"("O", "**")
    new $P1462, "ResizablePMCArray"
    push $P1462, $P1461
    .return ($P1462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1232
    rx1466_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1232:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1466_pos) = rx1466_cur."from"()
    inc rx1466_pos
    rx1466_cur."!cursor_from"(rx1466_pos)
    ge rx1466_pos, rx1466_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1470_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1471_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "+"
    add $I11, rx1466_pos, 1
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    ord $I11, rx1466_tgt, $I11
    ne $I11, 43, rx1466_fail
    add rx1466_pos, 1
    set_addr $I10, rxcap_1471_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1471_done
  rxcap_1471_fail:
    goto rx1466_fail
  rxcap_1471_done:
  # rx subrule "O" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1466_pos = $P10."pos"()
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "prefix:sym<+>")
    if_null rx1466_debug, debug_1233
    rx1466_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1466_pos)
  debug_1233:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 10
    if_null rx1466_debug, debug_1234
    rx1466_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1234:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1235
    rx1466_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1235:
    .return (rx1466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303430322.161") :method
.annotate 'line', 10
    $P1468 = self."!PREFIX__!subrule"("O", "+")
    new $P1469, "ResizablePMCArray"
    push $P1469, $P1468
    .return ($P1469)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1473_tgt
    .local int rx1473_pos
    .local int rx1473_off
    .local int rx1473_eos
    .local int rx1473_rep
    .local pmc rx1473_cur
    .local pmc rx1473_debug
    (rx1473_cur, rx1473_pos, rx1473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1473_cur
    .local pmc match
    .lex "$/", match
    length rx1473_eos, rx1473_tgt
    gt rx1473_pos, rx1473_eos, rx1473_done
    set rx1473_off, 0
    lt rx1473_pos, 2, rx1473_start
    sub rx1473_off, rx1473_pos, 1
    substr rx1473_tgt, rx1473_tgt, rx1473_off
  rx1473_start:
    eq $I10, 1, rx1473_restart
    if_null rx1473_debug, debug_1236
    rx1473_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1236:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1477_done
    goto rxscan1477_scan
  rxscan1477_loop:
    (rx1473_pos) = rx1473_cur."from"()
    inc rx1473_pos
    rx1473_cur."!cursor_from"(rx1473_pos)
    ge rx1473_pos, rx1473_eos, rxscan1477_done
  rxscan1477_scan:
    set_addr $I10, rxscan1477_loop
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  rxscan1477_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1478_fail
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  # rx literal  "~"
    add $I11, rx1473_pos, 1
    gt $I11, rx1473_eos, rx1473_fail
    sub $I11, rx1473_pos, rx1473_off
    ord $I11, rx1473_tgt, $I11
    ne $I11, 126, rx1473_fail
    add rx1473_pos, 1
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1473_cur."!mark_peek"($I10)
    rx1473_cur."!cursor_pos"($I11)
    ($P10) = rx1473_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1473_pos, "")
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1473_fail
  rxcap_1478_done:
  # rx subrule "O" subtype=capture negate=
    rx1473_cur."!cursor_pos"(rx1473_pos)
    $P10 = rx1473_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1473_fail
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1473_pos = $P10."pos"()
  # rx pass
    rx1473_cur."!cursor_pass"(rx1473_pos, "prefix:sym<~>")
    if_null rx1473_debug, debug_1237
    rx1473_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1473_pos)
  debug_1237:
    .return (rx1473_cur)
  rx1473_restart:
.annotate 'line', 10
    if_null rx1473_debug, debug_1238
    rx1473_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1238:
  rx1473_fail:
    (rx1473_rep, rx1473_pos, $I10, $P10) = rx1473_cur."!mark_fail"(0)
    lt rx1473_pos, -1, rx1473_done
    eq rx1473_pos, -1, rx1473_fail
    jump $I10
  rx1473_done:
    rx1473_cur."!cursor_fail"()
    if_null rx1473_debug, debug_1239
    rx1473_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1239:
    .return (rx1473_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303430322.161") :method
.annotate 'line', 10
    $P1475 = self."!PREFIX__!subrule"("O", "~")
    new $P1476, "ResizablePMCArray"
    push $P1476, $P1475
    .return ($P1476)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1480_tgt
    .local int rx1480_pos
    .local int rx1480_off
    .local int rx1480_eos
    .local int rx1480_rep
    .local pmc rx1480_cur
    .local pmc rx1480_debug
    (rx1480_cur, rx1480_pos, rx1480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1480_cur
    .local pmc match
    .lex "$/", match
    length rx1480_eos, rx1480_tgt
    gt rx1480_pos, rx1480_eos, rx1480_done
    set rx1480_off, 0
    lt rx1480_pos, 2, rx1480_start
    sub rx1480_off, rx1480_pos, 1
    substr rx1480_tgt, rx1480_tgt, rx1480_off
  rx1480_start:
    eq $I10, 1, rx1480_restart
    if_null rx1480_debug, debug_1240
    rx1480_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1240:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1483_done
    goto rxscan1483_scan
  rxscan1483_loop:
    (rx1480_pos) = rx1480_cur."from"()
    inc rx1480_pos
    rx1480_cur."!cursor_from"(rx1480_pos)
    ge rx1480_pos, rx1480_eos, rxscan1483_done
  rxscan1483_scan:
    set_addr $I10, rxscan1483_loop
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  rxscan1483_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1484_fail
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  # rx literal  "-"
    add $I11, rx1480_pos, 1
    gt $I11, rx1480_eos, rx1480_fail
    sub $I11, rx1480_pos, rx1480_off
    ord $I11, rx1480_tgt, $I11
    ne $I11, 45, rx1480_fail
    add rx1480_pos, 1
    set_addr $I10, rxcap_1484_fail
    ($I12, $I11) = rx1480_cur."!mark_peek"($I10)
    rx1480_cur."!cursor_pos"($I11)
    ($P10) = rx1480_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1480_pos, "")
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1484_done
  rxcap_1484_fail:
    goto rx1480_fail
  rxcap_1484_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1480_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."number"()
    if $P10, rx1480_fail
  # rx subrule "O" subtype=capture negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1480_fail
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1480_pos = $P10."pos"()
  # rx pass
    rx1480_cur."!cursor_pass"(rx1480_pos, "prefix:sym<->")
    if_null rx1480_debug, debug_1241
    rx1480_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1480_pos)
  debug_1241:
    .return (rx1480_cur)
  rx1480_restart:
.annotate 'line', 10
    if_null rx1480_debug, debug_1242
    rx1480_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1242:
  rx1480_fail:
    (rx1480_rep, rx1480_pos, $I10, $P10) = rx1480_cur."!mark_fail"(0)
    lt rx1480_pos, -1, rx1480_done
    eq rx1480_pos, -1, rx1480_fail
    jump $I10
  rx1480_done:
    rx1480_cur."!cursor_fail"()
    if_null rx1480_debug, debug_1243
    rx1480_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1243:
    .return (rx1480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303430322.161") :method
.annotate 'line', 10
    new $P1482, "ResizablePMCArray"
    push $P1482, "-"
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1244
    rx1486_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1244:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1490_done
    goto rxscan1490_scan
  rxscan1490_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1490_done
  rxscan1490_scan:
    set_addr $I10, rxscan1490_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1490_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1491_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "?"
    add $I11, rx1486_pos, 1
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    ord $I11, rx1486_tgt, $I11
    ne $I11, 63, rx1486_fail
    add rx1486_pos, 1
    set_addr $I10, rxcap_1491_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1491_done
  rxcap_1491_fail:
    goto rx1486_fail
  rxcap_1491_done:
  # rx subrule "O" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "prefix:sym<?>")
    if_null rx1486_debug, debug_1245
    rx1486_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1486_pos)
  debug_1245:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 10
    if_null rx1486_debug, debug_1246
    rx1486_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1246:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1247
    rx1486_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1247:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303430322.161") :method
.annotate 'line', 10
    $P1488 = self."!PREFIX__!subrule"("O", "?")
    new $P1489, "ResizablePMCArray"
    push $P1489, $P1488
    .return ($P1489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1248
    rx1493_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1248:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1497_done
    goto rxscan1497_scan
  rxscan1497_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1497_done
  rxscan1497_scan:
    set_addr $I10, rxscan1497_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1497_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1498_fail
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  # rx literal  "!"
    add $I11, rx1493_pos, 1
    gt $I11, rx1493_eos, rx1493_fail
    sub $I11, rx1493_pos, rx1493_off
    ord $I11, rx1493_tgt, $I11
    ne $I11, 33, rx1493_fail
    add rx1493_pos, 1
    set_addr $I10, rxcap_1498_fail
    ($I12, $I11) = rx1493_cur."!mark_peek"($I10)
    rx1493_cur."!cursor_pos"($I11)
    ($P10) = rx1493_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1493_pos, "")
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1498_done
  rxcap_1498_fail:
    goto rx1493_fail
  rxcap_1498_done:
  # rx subrule "O" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "prefix:sym<!>")
    if_null rx1493_debug, debug_1249
    rx1493_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1493_pos)
  debug_1249:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1250
    rx1493_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1250:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1251
    rx1493_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1251:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303430322.161") :method
.annotate 'line', 10
    $P1495 = self."!PREFIX__!subrule"("O", "!")
    new $P1496, "ResizablePMCArray"
    push $P1496, $P1495
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1252
    rx1500_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1252:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1504_done
    goto rxscan1504_scan
  rxscan1504_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1504_done
  rxscan1504_scan:
    set_addr $I10, rxscan1504_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1504_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1505_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  "|"
    add $I11, rx1500_pos, 1
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    ord $I11, rx1500_tgt, $I11
    ne $I11, 124, rx1500_fail
    add rx1500_pos, 1
    set_addr $I10, rxcap_1505_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1505_done
  rxcap_1505_fail:
    goto rx1500_fail
  rxcap_1505_done:
  # rx subrule "O" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."O"("%symbolic_unary")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "prefix:sym<|>")
    if_null rx1500_debug, debug_1253
    rx1500_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1500_pos)
  debug_1253:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1254
    rx1500_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1254:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1255
    rx1500_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1255:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303430322.161") :method
.annotate 'line', 10
    $P1502 = self."!PREFIX__!subrule"("O", "|")
    new $P1503, "ResizablePMCArray"
    push $P1503, $P1502
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1256
    rx1507_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1256:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1511_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  # rx literal  "*"
    add $I11, rx1507_pos, 1
    gt $I11, rx1507_eos, rx1507_fail
    sub $I11, rx1507_pos, rx1507_off
    ord $I11, rx1507_tgt, $I11
    ne $I11, 42, rx1507_fail
    add rx1507_pos, 1
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1507_cur."!mark_peek"($I10)
    rx1507_cur."!cursor_pos"($I11)
    ($P10) = rx1507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1507_pos, "")
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1507_fail
  rxcap_1512_done:
  # rx subrule "O" subtype=capture negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1507_fail
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1507_pos = $P10."pos"()
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "infix:sym<*>")
    if_null rx1507_debug, debug_1257
    rx1507_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1507_pos)
  debug_1257:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 10
    if_null rx1507_debug, debug_1258
    rx1507_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1258:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1259
    rx1507_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1259:
    .return (rx1507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303430322.161") :method
.annotate 'line', 10
    $P1509 = self."!PREFIX__!subrule"("O", "*")
    new $P1510, "ResizablePMCArray"
    push $P1510, $P1509
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1260
    rx1514_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1260:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1518_done
    goto rxscan1518_scan
  rxscan1518_loop:
    (rx1514_pos) = rx1514_cur."from"()
    inc rx1514_pos
    rx1514_cur."!cursor_from"(rx1514_pos)
    ge rx1514_pos, rx1514_eos, rxscan1518_done
  rxscan1518_scan:
    set_addr $I10, rxscan1518_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1518_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1519_fail
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  # rx literal  "/"
    add $I11, rx1514_pos, 1
    gt $I11, rx1514_eos, rx1514_fail
    sub $I11, rx1514_pos, rx1514_off
    ord $I11, rx1514_tgt, $I11
    ne $I11, 47, rx1514_fail
    add rx1514_pos, 1
    set_addr $I10, rxcap_1519_fail
    ($I12, $I11) = rx1514_cur."!mark_peek"($I10)
    rx1514_cur."!cursor_pos"($I11)
    ($P10) = rx1514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1514_pos, "")
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1519_done
  rxcap_1519_fail:
    goto rx1514_fail
  rxcap_1519_done:
  # rx subrule "O" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1514_pos = $P10."pos"()
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "infix:sym</>")
    if_null rx1514_debug, debug_1261
    rx1514_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1514_pos)
  debug_1261:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 10
    if_null rx1514_debug, debug_1262
    rx1514_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1262:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1263
    rx1514_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1263:
    .return (rx1514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303430322.161") :method
.annotate 'line', 10
    $P1516 = self."!PREFIX__!subrule"("O", "/")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1264
    rx1521_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1264:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1525_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "%"
    add $I11, rx1521_pos, 1
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    ord $I11, rx1521_tgt, $I11
    ne $I11, 37, rx1521_fail
    add rx1521_pos, 1
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1521_fail
  rxcap_1526_done:
  # rx subrule "O" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "infix:sym<%>")
    if_null rx1521_debug, debug_1265
    rx1521_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1521_pos)
  debug_1265:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 10
    if_null rx1521_debug, debug_1266
    rx1521_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1266:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1267
    rx1521_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1267:
    .return (rx1521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303430322.161") :method
.annotate 'line', 10
    $P1523 = self."!PREFIX__!subrule"("O", "%")
    new $P1524, "ResizablePMCArray"
    push $P1524, $P1523
    .return ($P1524)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1268
    rx1528_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1268:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1532_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1533_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1528_pos, 2
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 2
    ne $S10, "+&", rx1528_fail
    add rx1528_pos, 2
    set_addr $I10, rxcap_1533_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1533_done
  rxcap_1533_fail:
    goto rx1528_fail
  rxcap_1533_done:
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "infix:sym<+&>")
    if_null rx1528_debug, debug_1269
    rx1528_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1528_pos)
  debug_1269:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 10
    if_null rx1528_debug, debug_1270
    rx1528_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1270:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1271
    rx1528_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1271:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303430322.161") :method
.annotate 'line', 10
    $P1530 = self."!PREFIX__!subrule"("O", "+&")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1272
    rx1535_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1272:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1539_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1540_fail
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  # rx literal  "+"
    add $I11, rx1535_pos, 1
    gt $I11, rx1535_eos, rx1535_fail
    sub $I11, rx1535_pos, rx1535_off
    ord $I11, rx1535_tgt, $I11
    ne $I11, 43, rx1535_fail
    add rx1535_pos, 1
    set_addr $I10, rxcap_1540_fail
    ($I12, $I11) = rx1535_cur."!mark_peek"($I10)
    rx1535_cur."!cursor_pos"($I11)
    ($P10) = rx1535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1535_pos, "")
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1540_done
  rxcap_1540_fail:
    goto rx1535_fail
  rxcap_1540_done:
  # rx subrule "O" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1535_pos = $P10."pos"()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "infix:sym<+>")
    if_null rx1535_debug, debug_1273
    rx1535_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1535_pos)
  debug_1273:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 10
    if_null rx1535_debug, debug_1274
    rx1535_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1274:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1275
    rx1535_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1275:
    .return (rx1535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303430322.161") :method
.annotate 'line', 10
    $P1537 = self."!PREFIX__!subrule"("O", "+")
    new $P1538, "ResizablePMCArray"
    push $P1538, $P1537
    .return ($P1538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1276
    rx1542_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1276:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1546_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1547_fail
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  # rx literal  "-"
    add $I11, rx1542_pos, 1
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    ord $I11, rx1542_tgt, $I11
    ne $I11, 45, rx1542_fail
    add rx1542_pos, 1
    set_addr $I10, rxcap_1547_fail
    ($I12, $I11) = rx1542_cur."!mark_peek"($I10)
    rx1542_cur."!cursor_pos"($I11)
    ($P10) = rx1542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1542_pos, "")
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1547_done
  rxcap_1547_fail:
    goto rx1542_fail
  rxcap_1547_done:
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "infix:sym<->")
    if_null rx1542_debug, debug_1277
    rx1542_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1542_pos)
  debug_1277:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1278
    rx1542_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1278:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1279
    rx1542_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1279:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303430322.161") :method
.annotate 'line', 10
    $P1544 = self."!PREFIX__!subrule"("O", "-")
    new $P1545, "ResizablePMCArray"
    push $P1545, $P1544
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1280
    rx1549_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1280:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1553_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1554_fail
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1549_pos, 2
    gt $I11, rx1549_eos, rx1549_fail
    sub $I11, rx1549_pos, rx1549_off
    substr $S10, rx1549_tgt, $I11, 2
    ne $S10, "+|", rx1549_fail
    add rx1549_pos, 2
    set_addr $I10, rxcap_1554_fail
    ($I12, $I11) = rx1549_cur."!mark_peek"($I10)
    rx1549_cur."!cursor_pos"($I11)
    ($P10) = rx1549_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1549_pos, "")
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1554_done
  rxcap_1554_fail:
    goto rx1549_fail
  rxcap_1554_done:
  # rx subrule "O" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "infix:sym<+|>")
    if_null rx1549_debug, debug_1281
    rx1549_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1549_pos)
  debug_1281:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 10
    if_null rx1549_debug, debug_1282
    rx1549_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1282:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1283
    rx1549_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1283:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303430322.161") :method
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("O", "+|")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1284
    rx1556_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1284:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1560_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1561_fail
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1556_pos, 2
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 2
    ne $S10, "+^", rx1556_fail
    add rx1556_pos, 2
    set_addr $I10, rxcap_1561_fail
    ($I12, $I11) = rx1556_cur."!mark_peek"($I10)
    rx1556_cur."!cursor_pos"($I11)
    ($P10) = rx1556_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1556_pos, "")
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1561_done
  rxcap_1561_fail:
    goto rx1556_fail
  rxcap_1561_done:
  # rx subrule "O" subtype=capture negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1556_fail
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1556_pos = $P10."pos"()
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infix:sym<+^>")
    if_null rx1556_debug, debug_1285
    rx1556_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1556_pos)
  debug_1285:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1286
    rx1556_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1286:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1287
    rx1556_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1287:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303430322.161") :method
.annotate 'line', 10
    $P1558 = self."!PREFIX__!subrule"("O", "+^")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1288
    rx1563_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1288:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1567_done
    goto rxscan1567_scan
  rxscan1567_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1567_done
  rxscan1567_scan:
    set_addr $I10, rxscan1567_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1567_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1568_fail
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  # rx literal  "~"
    add $I11, rx1563_pos, 1
    gt $I11, rx1563_eos, rx1563_fail
    sub $I11, rx1563_pos, rx1563_off
    ord $I11, rx1563_tgt, $I11
    ne $I11, 126, rx1563_fail
    add rx1563_pos, 1
    set_addr $I10, rxcap_1568_fail
    ($I12, $I11) = rx1563_cur."!mark_peek"($I10)
    rx1563_cur."!cursor_pos"($I11)
    ($P10) = rx1563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1563_pos, "")
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1568_done
  rxcap_1568_fail:
    goto rx1563_fail
  rxcap_1568_done:
  # rx subrule "O" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1563_pos = $P10."pos"()
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "infix:sym<~>")
    if_null rx1563_debug, debug_1289
    rx1563_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1563_pos)
  debug_1289:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 10
    if_null rx1563_debug, debug_1290
    rx1563_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1290:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1291
    rx1563_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1291:
    .return (rx1563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303430322.161") :method
.annotate 'line', 10
    $P1565 = self."!PREFIX__!subrule"("O", "~")
    new $P1566, "ResizablePMCArray"
    push $P1566, $P1565
    .return ($P1566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1292
    rx1570_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1292:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1574_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  # rx literal  "=="
    add $I11, rx1570_pos, 2
    gt $I11, rx1570_eos, rx1570_fail
    sub $I11, rx1570_pos, rx1570_off
    substr $S10, rx1570_tgt, $I11, 2
    ne $S10, "==", rx1570_fail
    add rx1570_pos, 2
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1570_cur."!mark_peek"($I10)
    rx1570_cur."!cursor_pos"($I11)
    ($P10) = rx1570_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1570_pos, "")
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1570_fail
  rxcap_1575_done:
  # rx subrule "O" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "infix:sym<==>")
    if_null rx1570_debug, debug_1293
    rx1570_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1570_pos)
  debug_1293:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 10
    if_null rx1570_debug, debug_1294
    rx1570_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1294:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1295
    rx1570_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1295:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303430322.161") :method
.annotate 'line', 10
    $P1572 = self."!PREFIX__!subrule"("O", "==")
    new $P1573, "ResizablePMCArray"
    push $P1573, $P1572
    .return ($P1573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1296
    rx1577_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1296:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1581_done
    goto rxscan1581_scan
  rxscan1581_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1581_done
  rxscan1581_scan:
    set_addr $I10, rxscan1581_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1581_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1582_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "!="
    add $I11, rx1577_pos, 2
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 2
    ne $S10, "!=", rx1577_fail
    add rx1577_pos, 2
    set_addr $I10, rxcap_1582_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1582_done
  rxcap_1582_fail:
    goto rx1577_fail
  rxcap_1582_done:
  # rx subrule "O" subtype=capture negate=
    rx1577_cur."!cursor_pos"(rx1577_pos)
    $P10 = rx1577_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1577_fail
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1577_pos = $P10."pos"()
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "infix:sym<!=>")
    if_null rx1577_debug, debug_1297
    rx1577_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1577_pos)
  debug_1297:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 10
    if_null rx1577_debug, debug_1298
    rx1577_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1298:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1299
    rx1577_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1299:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303430322.161") :method
.annotate 'line', 10
    $P1579 = self."!PREFIX__!subrule"("O", "!=")
    new $P1580, "ResizablePMCArray"
    push $P1580, $P1579
    .return ($P1580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1300
    rx1584_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1300:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1589_fail
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  # rx literal  "<="
    add $I11, rx1584_pos, 2
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    substr $S10, rx1584_tgt, $I11, 2
    ne $S10, "<=", rx1584_fail
    add rx1584_pos, 2
    set_addr $I10, rxcap_1589_fail
    ($I12, $I11) = rx1584_cur."!mark_peek"($I10)
    rx1584_cur."!cursor_pos"($I11)
    ($P10) = rx1584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1584_pos, "")
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1589_done
  rxcap_1589_fail:
    goto rx1584_fail
  rxcap_1589_done:
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "infix:sym<<=>")
    if_null rx1584_debug, debug_1301
    rx1584_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1584_pos)
  debug_1301:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1302
    rx1584_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1302:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1303
    rx1584_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1303:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303430322.161") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("O", "<=")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1304
    rx1591_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1304:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  ">="
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, ">=", rx1591_fail
    add rx1591_pos, 2
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subrule "O" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "infix:sym<>=>")
    if_null rx1591_debug, debug_1305
    rx1591_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1591_pos)
  debug_1305:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 10
    if_null rx1591_debug, debug_1306
    rx1591_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1306:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1307
    rx1591_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1307:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303430322.161") :method
.annotate 'line', 10
    $P1593 = self."!PREFIX__!subrule"("O", ">=")
    new $P1594, "ResizablePMCArray"
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1308
    rx1598_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1308:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1602_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1603_fail
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  # rx literal  "<"
    add $I11, rx1598_pos, 1
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    ord $I11, rx1598_tgt, $I11
    ne $I11, 60, rx1598_fail
    add rx1598_pos, 1
    set_addr $I10, rxcap_1603_fail
    ($I12, $I11) = rx1598_cur."!mark_peek"($I10)
    rx1598_cur."!cursor_pos"($I11)
    ($P10) = rx1598_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1598_pos, "")
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1603_done
  rxcap_1603_fail:
    goto rx1598_fail
  rxcap_1603_done:
  # rx subrule "O" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1598_pos = $P10."pos"()
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "infix:sym<<>")
    if_null rx1598_debug, debug_1309
    rx1598_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1598_pos)
  debug_1309:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 10
    if_null rx1598_debug, debug_1310
    rx1598_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1310:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1311
    rx1598_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1311:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303430322.161") :method
.annotate 'line', 10
    $P1600 = self."!PREFIX__!subrule"("O", "<")
    new $P1601, "ResizablePMCArray"
    push $P1601, $P1600
    .return ($P1601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1605_tgt
    .local int rx1605_pos
    .local int rx1605_off
    .local int rx1605_eos
    .local int rx1605_rep
    .local pmc rx1605_cur
    .local pmc rx1605_debug
    (rx1605_cur, rx1605_pos, rx1605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1605_cur
    .local pmc match
    .lex "$/", match
    length rx1605_eos, rx1605_tgt
    gt rx1605_pos, rx1605_eos, rx1605_done
    set rx1605_off, 0
    lt rx1605_pos, 2, rx1605_start
    sub rx1605_off, rx1605_pos, 1
    substr rx1605_tgt, rx1605_tgt, rx1605_off
  rx1605_start:
    eq $I10, 1, rx1605_restart
    if_null rx1605_debug, debug_1312
    rx1605_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1312:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1609_done
    goto rxscan1609_scan
  rxscan1609_loop:
    (rx1605_pos) = rx1605_cur."from"()
    inc rx1605_pos
    rx1605_cur."!cursor_from"(rx1605_pos)
    ge rx1605_pos, rx1605_eos, rxscan1609_done
  rxscan1609_scan:
    set_addr $I10, rxscan1609_loop
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  rxscan1609_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1610_fail
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  # rx literal  ">"
    add $I11, rx1605_pos, 1
    gt $I11, rx1605_eos, rx1605_fail
    sub $I11, rx1605_pos, rx1605_off
    ord $I11, rx1605_tgt, $I11
    ne $I11, 62, rx1605_fail
    add rx1605_pos, 1
    set_addr $I10, rxcap_1610_fail
    ($I12, $I11) = rx1605_cur."!mark_peek"($I10)
    rx1605_cur."!cursor_pos"($I11)
    ($P10) = rx1605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1605_pos, "")
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1610_done
  rxcap_1610_fail:
    goto rx1605_fail
  rxcap_1610_done:
  # rx subrule "O" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1605_pos = $P10."pos"()
  # rx pass
    rx1605_cur."!cursor_pass"(rx1605_pos, "infix:sym<>>")
    if_null rx1605_debug, debug_1313
    rx1605_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1605_pos)
  debug_1313:
    .return (rx1605_cur)
  rx1605_restart:
.annotate 'line', 10
    if_null rx1605_debug, debug_1314
    rx1605_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1314:
  rx1605_fail:
    (rx1605_rep, rx1605_pos, $I10, $P10) = rx1605_cur."!mark_fail"(0)
    lt rx1605_pos, -1, rx1605_done
    eq rx1605_pos, -1, rx1605_fail
    jump $I10
  rx1605_done:
    rx1605_cur."!cursor_fail"()
    if_null rx1605_debug, debug_1315
    rx1605_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1315:
    .return (rx1605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303430322.161") :method
.annotate 'line', 10
    $P1607 = self."!PREFIX__!subrule"("O", ">")
    new $P1608, "ResizablePMCArray"
    push $P1608, $P1607
    .return ($P1608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1316
    rx1612_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1316:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1616_done
    goto rxscan1616_scan
  rxscan1616_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1616_done
  rxscan1616_scan:
    set_addr $I10, rxscan1616_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1616_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1617_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1612_pos, 2
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    substr $S10, rx1612_tgt, $I11, 2
    ne $S10, "eq", rx1612_fail
    add rx1612_pos, 2
    set_addr $I10, rxcap_1617_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1617_done
  rxcap_1617_fail:
    goto rx1612_fail
  rxcap_1617_done:
  # rx subrule "O" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1612_pos = $P10."pos"()
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "infix:sym<eq>")
    if_null rx1612_debug, debug_1317
    rx1612_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1612_pos)
  debug_1317:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 10
    if_null rx1612_debug, debug_1318
    rx1612_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1318:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1319
    rx1612_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1319:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303430322.161") :method
.annotate 'line', 10
    $P1614 = self."!PREFIX__!subrule"("O", "eq")
    new $P1615, "ResizablePMCArray"
    push $P1615, $P1614
    .return ($P1615)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1619_tgt
    .local int rx1619_pos
    .local int rx1619_off
    .local int rx1619_eos
    .local int rx1619_rep
    .local pmc rx1619_cur
    .local pmc rx1619_debug
    (rx1619_cur, rx1619_pos, rx1619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1619_cur
    .local pmc match
    .lex "$/", match
    length rx1619_eos, rx1619_tgt
    gt rx1619_pos, rx1619_eos, rx1619_done
    set rx1619_off, 0
    lt rx1619_pos, 2, rx1619_start
    sub rx1619_off, rx1619_pos, 1
    substr rx1619_tgt, rx1619_tgt, rx1619_off
  rx1619_start:
    eq $I10, 1, rx1619_restart
    if_null rx1619_debug, debug_1320
    rx1619_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1320:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1623_done
    goto rxscan1623_scan
  rxscan1623_loop:
    (rx1619_pos) = rx1619_cur."from"()
    inc rx1619_pos
    rx1619_cur."!cursor_from"(rx1619_pos)
    ge rx1619_pos, rx1619_eos, rxscan1623_done
  rxscan1623_scan:
    set_addr $I10, rxscan1623_loop
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  rxscan1623_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1624_fail
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1619_pos, 2
    gt $I11, rx1619_eos, rx1619_fail
    sub $I11, rx1619_pos, rx1619_off
    substr $S10, rx1619_tgt, $I11, 2
    ne $S10, "ne", rx1619_fail
    add rx1619_pos, 2
    set_addr $I10, rxcap_1624_fail
    ($I12, $I11) = rx1619_cur."!mark_peek"($I10)
    rx1619_cur."!cursor_pos"($I11)
    ($P10) = rx1619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1619_pos, "")
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1624_done
  rxcap_1624_fail:
    goto rx1619_fail
  rxcap_1624_done:
  # rx subrule "O" subtype=capture negate=
    rx1619_cur."!cursor_pos"(rx1619_pos)
    $P10 = rx1619_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1619_fail
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1619_pos = $P10."pos"()
  # rx pass
    rx1619_cur."!cursor_pass"(rx1619_pos, "infix:sym<ne>")
    if_null rx1619_debug, debug_1321
    rx1619_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1619_pos)
  debug_1321:
    .return (rx1619_cur)
  rx1619_restart:
.annotate 'line', 10
    if_null rx1619_debug, debug_1322
    rx1619_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1322:
  rx1619_fail:
    (rx1619_rep, rx1619_pos, $I10, $P10) = rx1619_cur."!mark_fail"(0)
    lt rx1619_pos, -1, rx1619_done
    eq rx1619_pos, -1, rx1619_fail
    jump $I10
  rx1619_done:
    rx1619_cur."!cursor_fail"()
    if_null rx1619_debug, debug_1323
    rx1619_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1323:
    .return (rx1619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303430322.161") :method
.annotate 'line', 10
    $P1621 = self."!PREFIX__!subrule"("O", "ne")
    new $P1622, "ResizablePMCArray"
    push $P1622, $P1621
    .return ($P1622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1626_tgt
    .local int rx1626_pos
    .local int rx1626_off
    .local int rx1626_eos
    .local int rx1626_rep
    .local pmc rx1626_cur
    .local pmc rx1626_debug
    (rx1626_cur, rx1626_pos, rx1626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1626_cur
    .local pmc match
    .lex "$/", match
    length rx1626_eos, rx1626_tgt
    gt rx1626_pos, rx1626_eos, rx1626_done
    set rx1626_off, 0
    lt rx1626_pos, 2, rx1626_start
    sub rx1626_off, rx1626_pos, 1
    substr rx1626_tgt, rx1626_tgt, rx1626_off
  rx1626_start:
    eq $I10, 1, rx1626_restart
    if_null rx1626_debug, debug_1324
    rx1626_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1324:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1630_done
    goto rxscan1630_scan
  rxscan1630_loop:
    (rx1626_pos) = rx1626_cur."from"()
    inc rx1626_pos
    rx1626_cur."!cursor_from"(rx1626_pos)
    ge rx1626_pos, rx1626_eos, rxscan1630_done
  rxscan1630_scan:
    set_addr $I10, rxscan1630_loop
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  rxscan1630_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1631_fail
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  # rx literal  "le"
    add $I11, rx1626_pos, 2
    gt $I11, rx1626_eos, rx1626_fail
    sub $I11, rx1626_pos, rx1626_off
    substr $S10, rx1626_tgt, $I11, 2
    ne $S10, "le", rx1626_fail
    add rx1626_pos, 2
    set_addr $I10, rxcap_1631_fail
    ($I12, $I11) = rx1626_cur."!mark_peek"($I10)
    rx1626_cur."!cursor_pos"($I11)
    ($P10) = rx1626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1626_pos, "")
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1631_done
  rxcap_1631_fail:
    goto rx1626_fail
  rxcap_1631_done:
  # rx subrule "O" subtype=capture negate=
    rx1626_cur."!cursor_pos"(rx1626_pos)
    $P10 = rx1626_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1626_fail
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1626_pos = $P10."pos"()
  # rx pass
    rx1626_cur."!cursor_pass"(rx1626_pos, "infix:sym<le>")
    if_null rx1626_debug, debug_1325
    rx1626_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1626_pos)
  debug_1325:
    .return (rx1626_cur)
  rx1626_restart:
.annotate 'line', 10
    if_null rx1626_debug, debug_1326
    rx1626_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1326:
  rx1626_fail:
    (rx1626_rep, rx1626_pos, $I10, $P10) = rx1626_cur."!mark_fail"(0)
    lt rx1626_pos, -1, rx1626_done
    eq rx1626_pos, -1, rx1626_fail
    jump $I10
  rx1626_done:
    rx1626_cur."!cursor_fail"()
    if_null rx1626_debug, debug_1327
    rx1626_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1327:
    .return (rx1626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303430322.161") :method
.annotate 'line', 10
    $P1628 = self."!PREFIX__!subrule"("O", "le")
    new $P1629, "ResizablePMCArray"
    push $P1629, $P1628
    .return ($P1629)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1633_tgt
    .local int rx1633_pos
    .local int rx1633_off
    .local int rx1633_eos
    .local int rx1633_rep
    .local pmc rx1633_cur
    .local pmc rx1633_debug
    (rx1633_cur, rx1633_pos, rx1633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1633_cur
    .local pmc match
    .lex "$/", match
    length rx1633_eos, rx1633_tgt
    gt rx1633_pos, rx1633_eos, rx1633_done
    set rx1633_off, 0
    lt rx1633_pos, 2, rx1633_start
    sub rx1633_off, rx1633_pos, 1
    substr rx1633_tgt, rx1633_tgt, rx1633_off
  rx1633_start:
    eq $I10, 1, rx1633_restart
    if_null rx1633_debug, debug_1328
    rx1633_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1328:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1637_done
    goto rxscan1637_scan
  rxscan1637_loop:
    (rx1633_pos) = rx1633_cur."from"()
    inc rx1633_pos
    rx1633_cur."!cursor_from"(rx1633_pos)
    ge rx1633_pos, rx1633_eos, rxscan1637_done
  rxscan1637_scan:
    set_addr $I10, rxscan1637_loop
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  rxscan1637_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1638_fail
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1633_pos, 2
    gt $I11, rx1633_eos, rx1633_fail
    sub $I11, rx1633_pos, rx1633_off
    substr $S10, rx1633_tgt, $I11, 2
    ne $S10, "ge", rx1633_fail
    add rx1633_pos, 2
    set_addr $I10, rxcap_1638_fail
    ($I12, $I11) = rx1633_cur."!mark_peek"($I10)
    rx1633_cur."!cursor_pos"($I11)
    ($P10) = rx1633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1633_pos, "")
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1638_done
  rxcap_1638_fail:
    goto rx1633_fail
  rxcap_1638_done:
  # rx subrule "O" subtype=capture negate=
    rx1633_cur."!cursor_pos"(rx1633_pos)
    $P10 = rx1633_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1633_fail
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1633_pos = $P10."pos"()
  # rx pass
    rx1633_cur."!cursor_pass"(rx1633_pos, "infix:sym<ge>")
    if_null rx1633_debug, debug_1329
    rx1633_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1633_pos)
  debug_1329:
    .return (rx1633_cur)
  rx1633_restart:
.annotate 'line', 10
    if_null rx1633_debug, debug_1330
    rx1633_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1330:
  rx1633_fail:
    (rx1633_rep, rx1633_pos, $I10, $P10) = rx1633_cur."!mark_fail"(0)
    lt rx1633_pos, -1, rx1633_done
    eq rx1633_pos, -1, rx1633_fail
    jump $I10
  rx1633_done:
    rx1633_cur."!cursor_fail"()
    if_null rx1633_debug, debug_1331
    rx1633_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1331:
    .return (rx1633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303430322.161") :method
.annotate 'line', 10
    $P1635 = self."!PREFIX__!subrule"("O", "ge")
    new $P1636, "ResizablePMCArray"
    push $P1636, $P1635
    .return ($P1636)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1332
    rx1640_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1332:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1644_done
    goto rxscan1644_scan
  rxscan1644_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1644_done
  rxscan1644_scan:
    set_addr $I10, rxscan1644_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1644_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1645_fail
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1640_pos, 2
    gt $I11, rx1640_eos, rx1640_fail
    sub $I11, rx1640_pos, rx1640_off
    substr $S10, rx1640_tgt, $I11, 2
    ne $S10, "lt", rx1640_fail
    add rx1640_pos, 2
    set_addr $I10, rxcap_1645_fail
    ($I12, $I11) = rx1640_cur."!mark_peek"($I10)
    rx1640_cur."!cursor_pos"($I11)
    ($P10) = rx1640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1640_pos, "")
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1645_done
  rxcap_1645_fail:
    goto rx1640_fail
  rxcap_1645_done:
  # rx subrule "O" subtype=capture negate=
    rx1640_cur."!cursor_pos"(rx1640_pos)
    $P10 = rx1640_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1640_fail
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1640_pos = $P10."pos"()
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "infix:sym<lt>")
    if_null rx1640_debug, debug_1333
    rx1640_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1640_pos)
  debug_1333:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 10
    if_null rx1640_debug, debug_1334
    rx1640_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1334:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1335
    rx1640_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1335:
    .return (rx1640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303430322.161") :method
.annotate 'line', 10
    $P1642 = self."!PREFIX__!subrule"("O", "lt")
    new $P1643, "ResizablePMCArray"
    push $P1643, $P1642
    .return ($P1643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1336
    rx1647_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1336:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1651_done
    goto rxscan1651_scan
  rxscan1651_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1651_done
  rxscan1651_scan:
    set_addr $I10, rxscan1651_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1651_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1652_fail
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1647_pos, 2
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    substr $S10, rx1647_tgt, $I11, 2
    ne $S10, "gt", rx1647_fail
    add rx1647_pos, 2
    set_addr $I10, rxcap_1652_fail
    ($I12, $I11) = rx1647_cur."!mark_peek"($I10)
    rx1647_cur."!cursor_pos"($I11)
    ($P10) = rx1647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1647_pos, "")
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1652_done
  rxcap_1652_fail:
    goto rx1647_fail
  rxcap_1652_done:
  # rx subrule "O" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1647_pos = $P10."pos"()
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "infix:sym<gt>")
    if_null rx1647_debug, debug_1337
    rx1647_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1647_pos)
  debug_1337:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 10
    if_null rx1647_debug, debug_1338
    rx1647_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1338:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1339
    rx1647_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1339:
    .return (rx1647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303430322.161") :method
.annotate 'line', 10
    $P1649 = self."!PREFIX__!subrule"("O", "gt")
    new $P1650, "ResizablePMCArray"
    push $P1650, $P1649
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1340
    rx1654_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1340:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1658_done
    goto rxscan1658_scan
  rxscan1658_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1658_done
  rxscan1658_scan:
    set_addr $I10, rxscan1658_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1658_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1659_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1654_pos, 3
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 3
    ne $S10, "=:=", rx1654_fail
    add rx1654_pos, 3
    set_addr $I10, rxcap_1659_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1659_done
  rxcap_1659_fail:
    goto rx1654_fail
  rxcap_1659_done:
  # rx subrule "O" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1654_pos = $P10."pos"()
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "infix:sym<=:=>")
    if_null rx1654_debug, debug_1341
    rx1654_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1654_pos)
  debug_1341:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 10
    if_null rx1654_debug, debug_1342
    rx1654_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1342:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1343
    rx1654_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1343:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303430322.161") :method
.annotate 'line', 10
    $P1656 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1657, "ResizablePMCArray"
    push $P1657, $P1656
    .return ($P1657)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1661_tgt
    .local int rx1661_pos
    .local int rx1661_off
    .local int rx1661_eos
    .local int rx1661_rep
    .local pmc rx1661_cur
    .local pmc rx1661_debug
    (rx1661_cur, rx1661_pos, rx1661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1661_cur
    .local pmc match
    .lex "$/", match
    length rx1661_eos, rx1661_tgt
    gt rx1661_pos, rx1661_eos, rx1661_done
    set rx1661_off, 0
    lt rx1661_pos, 2, rx1661_start
    sub rx1661_off, rx1661_pos, 1
    substr rx1661_tgt, rx1661_tgt, rx1661_off
  rx1661_start:
    eq $I10, 1, rx1661_restart
    if_null rx1661_debug, debug_1344
    rx1661_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1344:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1665_done
    goto rxscan1665_scan
  rxscan1665_loop:
    (rx1661_pos) = rx1661_cur."from"()
    inc rx1661_pos
    rx1661_cur."!cursor_from"(rx1661_pos)
    ge rx1661_pos, rx1661_eos, rxscan1665_done
  rxscan1665_scan:
    set_addr $I10, rxscan1665_loop
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  rxscan1665_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1666_fail
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1661_pos, 2
    gt $I11, rx1661_eos, rx1661_fail
    sub $I11, rx1661_pos, rx1661_off
    substr $S10, rx1661_tgt, $I11, 2
    ne $S10, "~~", rx1661_fail
    add rx1661_pos, 2
    set_addr $I10, rxcap_1666_fail
    ($I12, $I11) = rx1661_cur."!mark_peek"($I10)
    rx1661_cur."!cursor_pos"($I11)
    ($P10) = rx1661_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1661_pos, "")
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1666_done
  rxcap_1666_fail:
    goto rx1661_fail
  rxcap_1666_done:
  # rx subrule "O" subtype=capture negate=
    rx1661_cur."!cursor_pos"(rx1661_pos)
    $P10 = rx1661_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1661_fail
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1661_pos = $P10."pos"()
  # rx pass
    rx1661_cur."!cursor_pass"(rx1661_pos, "infix:sym<~~>")
    if_null rx1661_debug, debug_1345
    rx1661_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1661_pos)
  debug_1345:
    .return (rx1661_cur)
  rx1661_restart:
.annotate 'line', 10
    if_null rx1661_debug, debug_1346
    rx1661_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1346:
  rx1661_fail:
    (rx1661_rep, rx1661_pos, $I10, $P10) = rx1661_cur."!mark_fail"(0)
    lt rx1661_pos, -1, rx1661_done
    eq rx1661_pos, -1, rx1661_fail
    jump $I10
  rx1661_done:
    rx1661_cur."!cursor_fail"()
    if_null rx1661_debug, debug_1347
    rx1661_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1347:
    .return (rx1661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303430322.161") :method
.annotate 'line', 10
    $P1663 = self."!PREFIX__!subrule"("O", "~~")
    new $P1664, "ResizablePMCArray"
    push $P1664, $P1663
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1668_tgt
    .local int rx1668_pos
    .local int rx1668_off
    .local int rx1668_eos
    .local int rx1668_rep
    .local pmc rx1668_cur
    .local pmc rx1668_debug
    (rx1668_cur, rx1668_pos, rx1668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1668_cur
    .local pmc match
    .lex "$/", match
    length rx1668_eos, rx1668_tgt
    gt rx1668_pos, rx1668_eos, rx1668_done
    set rx1668_off, 0
    lt rx1668_pos, 2, rx1668_start
    sub rx1668_off, rx1668_pos, 1
    substr rx1668_tgt, rx1668_tgt, rx1668_off
  rx1668_start:
    eq $I10, 1, rx1668_restart
    if_null rx1668_debug, debug_1348
    rx1668_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1348:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1672_done
    goto rxscan1672_scan
  rxscan1672_loop:
    (rx1668_pos) = rx1668_cur."from"()
    inc rx1668_pos
    rx1668_cur."!cursor_from"(rx1668_pos)
    ge rx1668_pos, rx1668_eos, rxscan1672_done
  rxscan1672_scan:
    set_addr $I10, rxscan1672_loop
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  rxscan1672_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1673_fail
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1668_pos, 2
    gt $I11, rx1668_eos, rx1668_fail
    sub $I11, rx1668_pos, rx1668_off
    substr $S10, rx1668_tgt, $I11, 2
    ne $S10, "&&", rx1668_fail
    add rx1668_pos, 2
    set_addr $I10, rxcap_1673_fail
    ($I12, $I11) = rx1668_cur."!mark_peek"($I10)
    rx1668_cur."!cursor_pos"($I11)
    ($P10) = rx1668_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1668_pos, "")
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1673_done
  rxcap_1673_fail:
    goto rx1668_fail
  rxcap_1673_done:
  # rx subrule "O" subtype=capture negate=
    rx1668_cur."!cursor_pos"(rx1668_pos)
    $P10 = rx1668_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1668_fail
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1668_pos = $P10."pos"()
  # rx pass
    rx1668_cur."!cursor_pass"(rx1668_pos, "infix:sym<&&>")
    if_null rx1668_debug, debug_1349
    rx1668_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1668_pos)
  debug_1349:
    .return (rx1668_cur)
  rx1668_restart:
.annotate 'line', 10
    if_null rx1668_debug, debug_1350
    rx1668_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1350:
  rx1668_fail:
    (rx1668_rep, rx1668_pos, $I10, $P10) = rx1668_cur."!mark_fail"(0)
    lt rx1668_pos, -1, rx1668_done
    eq rx1668_pos, -1, rx1668_fail
    jump $I10
  rx1668_done:
    rx1668_cur."!cursor_fail"()
    if_null rx1668_debug, debug_1351
    rx1668_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1351:
    .return (rx1668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303430322.161") :method
.annotate 'line', 10
    $P1670 = self."!PREFIX__!subrule"("O", "&&")
    new $P1671, "ResizablePMCArray"
    push $P1671, $P1670
    .return ($P1671)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1675_tgt
    .local int rx1675_pos
    .local int rx1675_off
    .local int rx1675_eos
    .local int rx1675_rep
    .local pmc rx1675_cur
    .local pmc rx1675_debug
    (rx1675_cur, rx1675_pos, rx1675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1675_cur
    .local pmc match
    .lex "$/", match
    length rx1675_eos, rx1675_tgt
    gt rx1675_pos, rx1675_eos, rx1675_done
    set rx1675_off, 0
    lt rx1675_pos, 2, rx1675_start
    sub rx1675_off, rx1675_pos, 1
    substr rx1675_tgt, rx1675_tgt, rx1675_off
  rx1675_start:
    eq $I10, 1, rx1675_restart
    if_null rx1675_debug, debug_1352
    rx1675_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1352:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1679_done
    goto rxscan1679_scan
  rxscan1679_loop:
    (rx1675_pos) = rx1675_cur."from"()
    inc rx1675_pos
    rx1675_cur."!cursor_from"(rx1675_pos)
    ge rx1675_pos, rx1675_eos, rxscan1679_done
  rxscan1679_scan:
    set_addr $I10, rxscan1679_loop
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  rxscan1679_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1680_fail
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  # rx literal  "||"
    add $I11, rx1675_pos, 2
    gt $I11, rx1675_eos, rx1675_fail
    sub $I11, rx1675_pos, rx1675_off
    substr $S10, rx1675_tgt, $I11, 2
    ne $S10, "||", rx1675_fail
    add rx1675_pos, 2
    set_addr $I10, rxcap_1680_fail
    ($I12, $I11) = rx1675_cur."!mark_peek"($I10)
    rx1675_cur."!cursor_pos"($I11)
    ($P10) = rx1675_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1675_pos, "")
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1680_done
  rxcap_1680_fail:
    goto rx1675_fail
  rxcap_1680_done:
  # rx subrule "O" subtype=capture negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1675_fail
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1675_pos = $P10."pos"()
  # rx pass
    rx1675_cur."!cursor_pass"(rx1675_pos, "infix:sym<||>")
    if_null rx1675_debug, debug_1353
    rx1675_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1675_pos)
  debug_1353:
    .return (rx1675_cur)
  rx1675_restart:
.annotate 'line', 10
    if_null rx1675_debug, debug_1354
    rx1675_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1354:
  rx1675_fail:
    (rx1675_rep, rx1675_pos, $I10, $P10) = rx1675_cur."!mark_fail"(0)
    lt rx1675_pos, -1, rx1675_done
    eq rx1675_pos, -1, rx1675_fail
    jump $I10
  rx1675_done:
    rx1675_cur."!cursor_fail"()
    if_null rx1675_debug, debug_1355
    rx1675_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1355:
    .return (rx1675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303430322.161") :method
.annotate 'line', 10
    $P1677 = self."!PREFIX__!subrule"("O", "||")
    new $P1678, "ResizablePMCArray"
    push $P1678, $P1677
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1682_tgt
    .local int rx1682_pos
    .local int rx1682_off
    .local int rx1682_eos
    .local int rx1682_rep
    .local pmc rx1682_cur
    .local pmc rx1682_debug
    (rx1682_cur, rx1682_pos, rx1682_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1682_cur
    .local pmc match
    .lex "$/", match
    length rx1682_eos, rx1682_tgt
    gt rx1682_pos, rx1682_eos, rx1682_done
    set rx1682_off, 0
    lt rx1682_pos, 2, rx1682_start
    sub rx1682_off, rx1682_pos, 1
    substr rx1682_tgt, rx1682_tgt, rx1682_off
  rx1682_start:
    eq $I10, 1, rx1682_restart
    if_null rx1682_debug, debug_1356
    rx1682_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1356:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1686_done
    goto rxscan1686_scan
  rxscan1686_loop:
    (rx1682_pos) = rx1682_cur."from"()
    inc rx1682_pos
    rx1682_cur."!cursor_from"(rx1682_pos)
    ge rx1682_pos, rx1682_eos, rxscan1686_done
  rxscan1686_scan:
    set_addr $I10, rxscan1686_loop
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxscan1686_done:
.annotate 'line', 697
  # rx subcapture "sym"
    set_addr $I10, rxcap_1687_fail
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  # rx literal  "//"
    add $I11, rx1682_pos, 2
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 2
    ne $S10, "//", rx1682_fail
    add rx1682_pos, 2
    set_addr $I10, rxcap_1687_fail
    ($I12, $I11) = rx1682_cur."!mark_peek"($I10)
    rx1682_cur."!cursor_pos"($I11)
    ($P10) = rx1682_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1682_pos, "")
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1687_done
  rxcap_1687_fail:
    goto rx1682_fail
  rxcap_1687_done:
  # rx subrule "O" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1682_pos = $P10."pos"()
  # rx pass
    rx1682_cur."!cursor_pass"(rx1682_pos, "infix:sym<//>")
    if_null rx1682_debug, debug_1357
    rx1682_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1682_pos)
  debug_1357:
    .return (rx1682_cur)
  rx1682_restart:
.annotate 'line', 10
    if_null rx1682_debug, debug_1358
    rx1682_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1358:
  rx1682_fail:
    (rx1682_rep, rx1682_pos, $I10, $P10) = rx1682_cur."!mark_fail"(0)
    lt rx1682_pos, -1, rx1682_done
    eq rx1682_pos, -1, rx1682_fail
    jump $I10
  rx1682_done:
    rx1682_cur."!cursor_fail"()
    if_null rx1682_debug, debug_1359
    rx1682_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1359:
    .return (rx1682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303430322.161") :method
.annotate 'line', 10
    $P1684 = self."!PREFIX__!subrule"("O", "//")
    new $P1685, "ResizablePMCArray"
    push $P1685, $P1684
    .return ($P1685)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1689_tgt
    .local int rx1689_pos
    .local int rx1689_off
    .local int rx1689_eos
    .local int rx1689_rep
    .local pmc rx1689_cur
    .local pmc rx1689_debug
    (rx1689_cur, rx1689_pos, rx1689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1689_cur
    .local pmc match
    .lex "$/", match
    length rx1689_eos, rx1689_tgt
    gt rx1689_pos, rx1689_eos, rx1689_done
    set rx1689_off, 0
    lt rx1689_pos, 2, rx1689_start
    sub rx1689_off, rx1689_pos, 1
    substr rx1689_tgt, rx1689_tgt, rx1689_off
  rx1689_start:
    eq $I10, 1, rx1689_restart
    if_null rx1689_debug, debug_1360
    rx1689_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1360:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1693_done
    goto rxscan1693_scan
  rxscan1693_loop:
    (rx1689_pos) = rx1689_cur."from"()
    inc rx1689_pos
    rx1689_cur."!cursor_from"(rx1689_pos)
    ge rx1689_pos, rx1689_eos, rxscan1693_done
  rxscan1693_scan:
    set_addr $I10, rxscan1693_loop
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  rxscan1693_done:
.annotate 'line', 700
  # rx literal  "??"
    add $I11, rx1689_pos, 2
    gt $I11, rx1689_eos, rx1689_fail
    sub $I11, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I11, 2
    ne $S10, "??", rx1689_fail
    add rx1689_pos, 2
.annotate 'line', 701
  # rx subrule "ws" subtype=method negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."ws"()
    unless $P10, rx1689_fail
    rx1689_pos = $P10."pos"()
.annotate 'line', 702
  # rx subrule "EXPR" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."EXPR"("i=")
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1689_pos = $P10."pos"()
.annotate 'line', 703
  # rx literal  "!!"
    add $I11, rx1689_pos, 2
    gt $I11, rx1689_eos, rx1689_fail
    sub $I11, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I11, 2
    ne $S10, "!!", rx1689_fail
    add rx1689_pos, 2
.annotate 'line', 704
  # rx subrule "O" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1689_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1689_cur."!cursor_pass"(rx1689_pos, "infix:sym<?? !!>")
    if_null rx1689_debug, debug_1361
    rx1689_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1689_pos)
  debug_1361:
    .return (rx1689_cur)
  rx1689_restart:
.annotate 'line', 10
    if_null rx1689_debug, debug_1362
    rx1689_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1362:
  rx1689_fail:
    (rx1689_rep, rx1689_pos, $I10, $P10) = rx1689_cur."!mark_fail"(0)
    lt rx1689_pos, -1, rx1689_done
    eq rx1689_pos, -1, rx1689_fail
    jump $I10
  rx1689_done:
    rx1689_cur."!cursor_fail"()
    if_null rx1689_debug, debug_1363
    rx1689_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1363:
    .return (rx1689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303430322.161") :method
.annotate 'line', 10
    $P1691 = self."!PREFIX__!subrule"("ws", "??")
    new $P1692, "ResizablePMCArray"
    push $P1692, $P1691
    .return ($P1692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1695_tgt
    .local int rx1695_pos
    .local int rx1695_off
    .local int rx1695_eos
    .local int rx1695_rep
    .local pmc rx1695_cur
    .local pmc rx1695_debug
    (rx1695_cur, rx1695_pos, rx1695_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1695_cur
    .local pmc match
    .lex "$/", match
    length rx1695_eos, rx1695_tgt
    gt rx1695_pos, rx1695_eos, rx1695_done
    set rx1695_off, 0
    lt rx1695_pos, 2, rx1695_start
    sub rx1695_off, rx1695_pos, 1
    substr rx1695_tgt, rx1695_tgt, rx1695_off
  rx1695_start:
    eq $I10, 1, rx1695_restart
    if_null rx1695_debug, debug_1364
    rx1695_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1364:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1699_done
    goto rxscan1699_scan
  rxscan1699_loop:
    (rx1695_pos) = rx1695_cur."from"()
    inc rx1695_pos
    rx1695_cur."!cursor_from"(rx1695_pos)
    ge rx1695_pos, rx1695_eos, rxscan1699_done
  rxscan1699_scan:
    set_addr $I10, rxscan1699_loop
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
  rxscan1699_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1700_fail
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
  # rx literal  "="
    add $I11, rx1695_pos, 1
    gt $I11, rx1695_eos, rx1695_fail
    sub $I11, rx1695_pos, rx1695_off
    ord $I11, rx1695_tgt, $I11
    ne $I11, 61, rx1695_fail
    add rx1695_pos, 1
    set_addr $I10, rxcap_1700_fail
    ($I12, $I11) = rx1695_cur."!mark_peek"($I10)
    rx1695_cur."!cursor_pos"($I11)
    ($P10) = rx1695_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1695_pos, "")
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1700_done
  rxcap_1700_fail:
    goto rx1695_fail
  rxcap_1700_done:
  # rx subrule "panic" subtype=method negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1695_fail
    rx1695_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx1695_cur."!cursor_pass"(rx1695_pos, "infix:sym<=>")
    if_null rx1695_debug, debug_1365
    rx1695_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1695_pos)
  debug_1365:
    .return (rx1695_cur)
  rx1695_restart:
.annotate 'line', 10
    if_null rx1695_debug, debug_1366
    rx1695_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1366:
  rx1695_fail:
    (rx1695_rep, rx1695_pos, $I10, $P10) = rx1695_cur."!mark_fail"(0)
    lt rx1695_pos, -1, rx1695_done
    eq rx1695_pos, -1, rx1695_fail
    jump $I10
  rx1695_done:
    rx1695_cur."!cursor_fail"()
    if_null rx1695_debug, debug_1367
    rx1695_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1367:
    .return (rx1695_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303430322.161") :method
.annotate 'line', 10
    $P1697 = self."!PREFIX__!subrule"("panic", "=")
    new $P1698, "ResizablePMCArray"
    push $P1698, $P1697
    .return ($P1698)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1702_tgt
    .local int rx1702_pos
    .local int rx1702_off
    .local int rx1702_eos
    .local int rx1702_rep
    .local pmc rx1702_cur
    .local pmc rx1702_debug
    (rx1702_cur, rx1702_pos, rx1702_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1702_cur
    .local pmc match
    .lex "$/", match
    length rx1702_eos, rx1702_tgt
    gt rx1702_pos, rx1702_eos, rx1702_done
    set rx1702_off, 0
    lt rx1702_pos, 2, rx1702_start
    sub rx1702_off, rx1702_pos, 1
    substr rx1702_tgt, rx1702_tgt, rx1702_off
  rx1702_start:
    eq $I10, 1, rx1702_restart
    if_null rx1702_debug, debug_1368
    rx1702_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1368:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1706_done
    goto rxscan1706_scan
  rxscan1706_loop:
    (rx1702_pos) = rx1702_cur."from"()
    inc rx1702_pos
    rx1702_cur."!cursor_from"(rx1702_pos)
    ge rx1702_pos, rx1702_eos, rxscan1706_done
  rxscan1706_scan:
    set_addr $I10, rxscan1706_loop
    rx1702_cur."!mark_push"(0, rx1702_pos, $I10)
  rxscan1706_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1707_fail
    rx1702_cur."!mark_push"(0, rx1702_pos, $I10)
  # rx literal  ":="
    add $I11, rx1702_pos, 2
    gt $I11, rx1702_eos, rx1702_fail
    sub $I11, rx1702_pos, rx1702_off
    substr $S10, rx1702_tgt, $I11, 2
    ne $S10, ":=", rx1702_fail
    add rx1702_pos, 2
    set_addr $I10, rxcap_1707_fail
    ($I12, $I11) = rx1702_cur."!mark_peek"($I10)
    rx1702_cur."!cursor_pos"($I11)
    ($P10) = rx1702_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1702_pos, "")
    rx1702_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1707_done
  rxcap_1707_fail:
    goto rx1702_fail
  rxcap_1707_done:
  # rx subrule "O" subtype=capture negate=
    rx1702_cur."!cursor_pos"(rx1702_pos)
    $P10 = rx1702_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1702_fail
    rx1702_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1702_pos = $P10."pos"()
  # rx pass
    rx1702_cur."!cursor_pass"(rx1702_pos, "infix:sym<:=>")
    if_null rx1702_debug, debug_1369
    rx1702_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1702_pos)
  debug_1369:
    .return (rx1702_cur)
  rx1702_restart:
.annotate 'line', 10
    if_null rx1702_debug, debug_1370
    rx1702_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1370:
  rx1702_fail:
    (rx1702_rep, rx1702_pos, $I10, $P10) = rx1702_cur."!mark_fail"(0)
    lt rx1702_pos, -1, rx1702_done
    eq rx1702_pos, -1, rx1702_fail
    jump $I10
  rx1702_done:
    rx1702_cur."!cursor_fail"()
    if_null rx1702_debug, debug_1371
    rx1702_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1371:
    .return (rx1702_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303430322.161") :method
.annotate 'line', 10
    $P1704 = self."!PREFIX__!subrule"("O", ":=")
    new $P1705, "ResizablePMCArray"
    push $P1705, $P1704
    .return ($P1705)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1709_tgt
    .local int rx1709_pos
    .local int rx1709_off
    .local int rx1709_eos
    .local int rx1709_rep
    .local pmc rx1709_cur
    .local pmc rx1709_debug
    (rx1709_cur, rx1709_pos, rx1709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1709_cur
    .local pmc match
    .lex "$/", match
    length rx1709_eos, rx1709_tgt
    gt rx1709_pos, rx1709_eos, rx1709_done
    set rx1709_off, 0
    lt rx1709_pos, 2, rx1709_start
    sub rx1709_off, rx1709_pos, 1
    substr rx1709_tgt, rx1709_tgt, rx1709_off
  rx1709_start:
    eq $I10, 1, rx1709_restart
    if_null rx1709_debug, debug_1372
    rx1709_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1372:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1713_done
    goto rxscan1713_scan
  rxscan1713_loop:
    (rx1709_pos) = rx1709_cur."from"()
    inc rx1709_pos
    rx1709_cur."!cursor_from"(rx1709_pos)
    ge rx1709_pos, rx1709_eos, rxscan1713_done
  rxscan1713_scan:
    set_addr $I10, rxscan1713_loop
    rx1709_cur."!mark_push"(0, rx1709_pos, $I10)
  rxscan1713_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1714_fail
    rx1709_cur."!mark_push"(0, rx1709_pos, $I10)
  # rx literal  "::="
    add $I11, rx1709_pos, 3
    gt $I11, rx1709_eos, rx1709_fail
    sub $I11, rx1709_pos, rx1709_off
    substr $S10, rx1709_tgt, $I11, 3
    ne $S10, "::=", rx1709_fail
    add rx1709_pos, 3
    set_addr $I10, rxcap_1714_fail
    ($I12, $I11) = rx1709_cur."!mark_peek"($I10)
    rx1709_cur."!cursor_pos"($I11)
    ($P10) = rx1709_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1709_pos, "")
    rx1709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1714_done
  rxcap_1714_fail:
    goto rx1709_fail
  rxcap_1714_done:
  # rx subrule "O" subtype=capture negate=
    rx1709_cur."!cursor_pos"(rx1709_pos)
    $P10 = rx1709_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1709_fail
    rx1709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1709_pos = $P10."pos"()
  # rx pass
    rx1709_cur."!cursor_pass"(rx1709_pos, "infix:sym<::=>")
    if_null rx1709_debug, debug_1373
    rx1709_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1709_pos)
  debug_1373:
    .return (rx1709_cur)
  rx1709_restart:
.annotate 'line', 10
    if_null rx1709_debug, debug_1374
    rx1709_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1374:
  rx1709_fail:
    (rx1709_rep, rx1709_pos, $I10, $P10) = rx1709_cur."!mark_fail"(0)
    lt rx1709_pos, -1, rx1709_done
    eq rx1709_pos, -1, rx1709_fail
    jump $I10
  rx1709_done:
    rx1709_cur."!cursor_fail"()
    if_null rx1709_debug, debug_1375
    rx1709_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1375:
    .return (rx1709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303430322.161") :method
.annotate 'line', 10
    $P1711 = self."!PREFIX__!subrule"("O", "::=")
    new $P1712, "ResizablePMCArray"
    push $P1712, $P1711
    .return ($P1712)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1716_tgt
    .local int rx1716_pos
    .local int rx1716_off
    .local int rx1716_eos
    .local int rx1716_rep
    .local pmc rx1716_cur
    .local pmc rx1716_debug
    (rx1716_cur, rx1716_pos, rx1716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1716_cur
    .local pmc match
    .lex "$/", match
    length rx1716_eos, rx1716_tgt
    gt rx1716_pos, rx1716_eos, rx1716_done
    set rx1716_off, 0
    lt rx1716_pos, 2, rx1716_start
    sub rx1716_off, rx1716_pos, 1
    substr rx1716_tgt, rx1716_tgt, rx1716_off
  rx1716_start:
    eq $I10, 1, rx1716_restart
    if_null rx1716_debug, debug_1376
    rx1716_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1376:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1720_done
    goto rxscan1720_scan
  rxscan1720_loop:
    (rx1716_pos) = rx1716_cur."from"()
    inc rx1716_pos
    rx1716_cur."!cursor_from"(rx1716_pos)
    ge rx1716_pos, rx1716_eos, rxscan1720_done
  rxscan1720_scan:
    set_addr $I10, rxscan1720_loop
    rx1716_cur."!mark_push"(0, rx1716_pos, $I10)
  rxscan1720_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1721_fail
    rx1716_cur."!mark_push"(0, rx1716_pos, $I10)
  # rx literal  ","
    add $I11, rx1716_pos, 1
    gt $I11, rx1716_eos, rx1716_fail
    sub $I11, rx1716_pos, rx1716_off
    ord $I11, rx1716_tgt, $I11
    ne $I11, 44, rx1716_fail
    add rx1716_pos, 1
    set_addr $I10, rxcap_1721_fail
    ($I12, $I11) = rx1716_cur."!mark_peek"($I10)
    rx1716_cur."!cursor_pos"($I11)
    ($P10) = rx1716_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1716_pos, "")
    rx1716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1721_done
  rxcap_1721_fail:
    goto rx1716_fail
  rxcap_1721_done:
  # rx subrule "O" subtype=capture negate=
    rx1716_cur."!cursor_pos"(rx1716_pos)
    $P10 = rx1716_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1716_fail
    rx1716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1716_pos = $P10."pos"()
  # rx pass
    rx1716_cur."!cursor_pass"(rx1716_pos, "infix:sym<,>")
    if_null rx1716_debug, debug_1377
    rx1716_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1716_pos)
  debug_1377:
    .return (rx1716_cur)
  rx1716_restart:
.annotate 'line', 10
    if_null rx1716_debug, debug_1378
    rx1716_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1378:
  rx1716_fail:
    (rx1716_rep, rx1716_pos, $I10, $P10) = rx1716_cur."!mark_fail"(0)
    lt rx1716_pos, -1, rx1716_done
    eq rx1716_pos, -1, rx1716_fail
    jump $I10
  rx1716_done:
    rx1716_cur."!cursor_fail"()
    if_null rx1716_debug, debug_1379
    rx1716_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1379:
    .return (rx1716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303430322.161") :method
.annotate 'line', 10
    $P1718 = self."!PREFIX__!subrule"("O", ",")
    new $P1719, "ResizablePMCArray"
    push $P1719, $P1718
    .return ($P1719)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .const 'Sub' $P1731 = "373_1303430322.161" 
    capture_lex $P1731
    .local string rx1723_tgt
    .local int rx1723_pos
    .local int rx1723_off
    .local int rx1723_eos
    .local int rx1723_rep
    .local pmc rx1723_cur
    .local pmc rx1723_debug
    (rx1723_cur, rx1723_pos, rx1723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1723_cur
    .local pmc match
    .lex "$/", match
    length rx1723_eos, rx1723_tgt
    gt rx1723_pos, rx1723_eos, rx1723_done
    set rx1723_off, 0
    lt rx1723_pos, 2, rx1723_start
    sub rx1723_off, rx1723_pos, 1
    substr rx1723_tgt, rx1723_tgt, rx1723_off
  rx1723_start:
    eq $I10, 1, rx1723_restart
    if_null rx1723_debug, debug_1380
    rx1723_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1380:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1726_done
    goto rxscan1726_scan
  rxscan1726_loop:
    (rx1723_pos) = rx1723_cur."from"()
    inc rx1723_pos
    rx1723_cur."!cursor_from"(rx1723_pos)
    ge rx1723_pos, rx1723_eos, rxscan1726_done
  rxscan1726_scan:
    set_addr $I10, rxscan1726_loop
    rx1723_cur."!mark_push"(0, rx1723_pos, $I10)
  rxscan1726_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1727_fail
    rx1723_cur."!mark_push"(0, rx1723_pos, $I10)
  # rx literal  "return"
    add $I11, rx1723_pos, 6
    gt $I11, rx1723_eos, rx1723_fail
    sub $I11, rx1723_pos, rx1723_off
    substr $S10, rx1723_tgt, $I11, 6
    ne $S10, "return", rx1723_fail
    add rx1723_pos, 6
    set_addr $I10, rxcap_1727_fail
    ($I12, $I11) = rx1723_cur."!mark_peek"($I10)
    rx1723_cur."!cursor_pos"($I11)
    ($P10) = rx1723_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1723_pos, "")
    rx1723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1727_done
  rxcap_1727_fail:
    goto rx1723_fail
  rxcap_1727_done:
  # rx charclass s
    ge rx1723_pos, rx1723_eos, rx1723_fail
    sub $I10, rx1723_pos, rx1723_off
    is_cclass $I11, 32, rx1723_tgt, $I10
    unless $I11, rx1723_fail
    inc rx1723_pos
  # rx subrule "O" subtype=capture negate=
    rx1723_cur."!cursor_pos"(rx1723_pos)
    $P10 = rx1723_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1723_fail
    rx1723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1723_pos = $P10."pos"()
    rx1723_cur."!cursor_pos"(rx1723_pos)
    find_lex $P1728, unicode:"$\x{a2}"
    $P1729 = $P1728."MATCH"()
    store_lex "$/", $P1729
    .const 'Sub' $P1731 = "373_1303430322.161" 
    capture_lex $P1731
    $P1733 = $P1731()
  # rx pass
    rx1723_cur."!cursor_pass"(rx1723_pos, "prefix:sym<return>")
    if_null rx1723_debug, debug_1381
    rx1723_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1723_pos)
  debug_1381:
    .return (rx1723_cur)
  rx1723_restart:
.annotate 'line', 10
    if_null rx1723_debug, debug_1382
    rx1723_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1382:
  rx1723_fail:
    (rx1723_rep, rx1723_pos, $I10, $P10) = rx1723_cur."!mark_fail"(0)
    lt rx1723_pos, -1, rx1723_done
    eq rx1723_pos, -1, rx1723_fail
    jump $I10
  rx1723_done:
    rx1723_cur."!cursor_fail"()
    if_null rx1723_debug, debug_1383
    rx1723_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1383:
    .return (rx1723_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303430322.161") :method
.annotate 'line', 10
    new $P1725, "ResizablePMCArray"
    push $P1725, "return"
    .return ($P1725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1730"  :anon :subid("373_1303430322.161") :outer("371_1303430322.161")
.annotate 'line', 715
    new $P1732, "Integer"
    assign $P1732, 1
    store_dynamic_lex "$*RETURN_USED", $P1732
    .return ($P1732)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1735_tgt
    .local int rx1735_pos
    .local int rx1735_off
    .local int rx1735_eos
    .local int rx1735_rep
    .local pmc rx1735_cur
    .local pmc rx1735_debug
    (rx1735_cur, rx1735_pos, rx1735_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1735_cur
    .local pmc match
    .lex "$/", match
    length rx1735_eos, rx1735_tgt
    gt rx1735_pos, rx1735_eos, rx1735_done
    set rx1735_off, 0
    lt rx1735_pos, 2, rx1735_start
    sub rx1735_off, rx1735_pos, 1
    substr rx1735_tgt, rx1735_tgt, rx1735_off
  rx1735_start:
    eq $I10, 1, rx1735_restart
    if_null rx1735_debug, debug_1384
    rx1735_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1384:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1738_done
    goto rxscan1738_scan
  rxscan1738_loop:
    (rx1735_pos) = rx1735_cur."from"()
    inc rx1735_pos
    rx1735_cur."!cursor_from"(rx1735_pos)
    ge rx1735_pos, rx1735_eos, rxscan1738_done
  rxscan1738_scan:
    set_addr $I10, rxscan1738_loop
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  rxscan1738_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1739_fail
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  # rx literal  "make"
    add $I11, rx1735_pos, 4
    gt $I11, rx1735_eos, rx1735_fail
    sub $I11, rx1735_pos, rx1735_off
    substr $S10, rx1735_tgt, $I11, 4
    ne $S10, "make", rx1735_fail
    add rx1735_pos, 4
    set_addr $I10, rxcap_1739_fail
    ($I12, $I11) = rx1735_cur."!mark_peek"($I10)
    rx1735_cur."!cursor_pos"($I11)
    ($P10) = rx1735_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1735_pos, "")
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1739_done
  rxcap_1739_fail:
    goto rx1735_fail
  rxcap_1739_done:
  # rx charclass s
    ge rx1735_pos, rx1735_eos, rx1735_fail
    sub $I10, rx1735_pos, rx1735_off
    is_cclass $I11, 32, rx1735_tgt, $I10
    unless $I11, rx1735_fail
    inc rx1735_pos
  # rx subrule "O" subtype=capture negate=
    rx1735_cur."!cursor_pos"(rx1735_pos)
    $P10 = rx1735_cur."O"("%list_prefix")
    unless $P10, rx1735_fail
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1735_pos = $P10."pos"()
  # rx pass
    rx1735_cur."!cursor_pass"(rx1735_pos, "prefix:sym<make>")
    if_null rx1735_debug, debug_1385
    rx1735_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1735_pos)
  debug_1385:
    .return (rx1735_cur)
  rx1735_restart:
.annotate 'line', 10
    if_null rx1735_debug, debug_1386
    rx1735_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1386:
  rx1735_fail:
    (rx1735_rep, rx1735_pos, $I10, $P10) = rx1735_cur."!mark_fail"(0)
    lt rx1735_pos, -1, rx1735_done
    eq rx1735_pos, -1, rx1735_fail
    jump $I10
  rx1735_done:
    rx1735_cur."!cursor_fail"()
    if_null rx1735_debug, debug_1387
    rx1735_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1387:
    .return (rx1735_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303430322.161") :method
.annotate 'line', 10
    new $P1737, "ResizablePMCArray"
    push $P1737, "make"
    .return ($P1737)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1741_tgt
    .local int rx1741_pos
    .local int rx1741_off
    .local int rx1741_eos
    .local int rx1741_rep
    .local pmc rx1741_cur
    .local pmc rx1741_debug
    (rx1741_cur, rx1741_pos, rx1741_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1741_cur
    .local pmc match
    .lex "$/", match
    length rx1741_eos, rx1741_tgt
    gt rx1741_pos, rx1741_eos, rx1741_done
    set rx1741_off, 0
    lt rx1741_pos, 2, rx1741_start
    sub rx1741_off, rx1741_pos, 1
    substr rx1741_tgt, rx1741_tgt, rx1741_off
  rx1741_start:
    eq $I10, 1, rx1741_restart
    if_null rx1741_debug, debug_1388
    rx1741_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1388:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1744_done
    goto rxscan1744_scan
  rxscan1744_loop:
    (rx1741_pos) = rx1741_cur."from"()
    inc rx1741_pos
    rx1741_cur."!cursor_from"(rx1741_pos)
    ge rx1741_pos, rx1741_eos, rxscan1744_done
  rxscan1744_scan:
    set_addr $I10, rxscan1744_loop
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  rxscan1744_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1745_fail
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  # rx literal  "last"
    add $I11, rx1741_pos, 4
    gt $I11, rx1741_eos, rx1741_fail
    sub $I11, rx1741_pos, rx1741_off
    substr $S10, rx1741_tgt, $I11, 4
    ne $S10, "last", rx1741_fail
    add rx1741_pos, 4
    set_addr $I10, rxcap_1745_fail
    ($I12, $I11) = rx1741_cur."!mark_peek"($I10)
    rx1741_cur."!cursor_pos"($I11)
    ($P10) = rx1741_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1741_pos, "")
    rx1741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1745_done
  rxcap_1745_fail:
    goto rx1741_fail
  rxcap_1745_done:
  # rx pass
    rx1741_cur."!cursor_pass"(rx1741_pos, "term:sym<last>")
    if_null rx1741_debug, debug_1389
    rx1741_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1741_pos)
  debug_1389:
    .return (rx1741_cur)
  rx1741_restart:
.annotate 'line', 10
    if_null rx1741_debug, debug_1390
    rx1741_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1390:
  rx1741_fail:
    (rx1741_rep, rx1741_pos, $I10, $P10) = rx1741_cur."!mark_fail"(0)
    lt rx1741_pos, -1, rx1741_done
    eq rx1741_pos, -1, rx1741_fail
    jump $I10
  rx1741_done:
    rx1741_cur."!cursor_fail"()
    if_null rx1741_debug, debug_1391
    rx1741_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1391:
    .return (rx1741_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303430322.161") :method
.annotate 'line', 10
    new $P1743, "ResizablePMCArray"
    push $P1743, "last"
    .return ($P1743)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1747_tgt
    .local int rx1747_pos
    .local int rx1747_off
    .local int rx1747_eos
    .local int rx1747_rep
    .local pmc rx1747_cur
    .local pmc rx1747_debug
    (rx1747_cur, rx1747_pos, rx1747_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1747_cur
    .local pmc match
    .lex "$/", match
    length rx1747_eos, rx1747_tgt
    gt rx1747_pos, rx1747_eos, rx1747_done
    set rx1747_off, 0
    lt rx1747_pos, 2, rx1747_start
    sub rx1747_off, rx1747_pos, 1
    substr rx1747_tgt, rx1747_tgt, rx1747_off
  rx1747_start:
    eq $I10, 1, rx1747_restart
    if_null rx1747_debug, debug_1392
    rx1747_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1392:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1750_done
    goto rxscan1750_scan
  rxscan1750_loop:
    (rx1747_pos) = rx1747_cur."from"()
    inc rx1747_pos
    rx1747_cur."!cursor_from"(rx1747_pos)
    ge rx1747_pos, rx1747_eos, rxscan1750_done
  rxscan1750_scan:
    set_addr $I10, rxscan1750_loop
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
  rxscan1750_done:
.annotate 'line', 718
  # rx subcapture "sym"
    set_addr $I10, rxcap_1751_fail
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
  # rx literal  "next"
    add $I11, rx1747_pos, 4
    gt $I11, rx1747_eos, rx1747_fail
    sub $I11, rx1747_pos, rx1747_off
    substr $S10, rx1747_tgt, $I11, 4
    ne $S10, "next", rx1747_fail
    add rx1747_pos, 4
    set_addr $I10, rxcap_1751_fail
    ($I12, $I11) = rx1747_cur."!mark_peek"($I10)
    rx1747_cur."!cursor_pos"($I11)
    ($P10) = rx1747_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1747_pos, "")
    rx1747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1751_done
  rxcap_1751_fail:
    goto rx1747_fail
  rxcap_1751_done:
  # rx pass
    rx1747_cur."!cursor_pass"(rx1747_pos, "term:sym<next>")
    if_null rx1747_debug, debug_1393
    rx1747_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1747_pos)
  debug_1393:
    .return (rx1747_cur)
  rx1747_restart:
.annotate 'line', 10
    if_null rx1747_debug, debug_1394
    rx1747_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1394:
  rx1747_fail:
    (rx1747_rep, rx1747_pos, $I10, $P10) = rx1747_cur."!mark_fail"(0)
    lt rx1747_pos, -1, rx1747_done
    eq rx1747_pos, -1, rx1747_fail
    jump $I10
  rx1747_done:
    rx1747_cur."!cursor_fail"()
    if_null rx1747_debug, debug_1395
    rx1747_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1395:
    .return (rx1747_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303430322.161") :method
.annotate 'line', 10
    new $P1749, "ResizablePMCArray"
    push $P1749, "next"
    .return ($P1749)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303430322.161") :method :outer("12_1303430322.161")
.annotate 'line', 10
    .local string rx1753_tgt
    .local int rx1753_pos
    .local int rx1753_off
    .local int rx1753_eos
    .local int rx1753_rep
    .local pmc rx1753_cur
    .local pmc rx1753_debug
    (rx1753_cur, rx1753_pos, rx1753_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1753_cur
    .local pmc match
    .lex "$/", match
    length rx1753_eos, rx1753_tgt
    gt rx1753_pos, rx1753_eos, rx1753_done
    set rx1753_off, 0
    lt rx1753_pos, 2, rx1753_start
    sub rx1753_off, rx1753_pos, 1
    substr rx1753_tgt, rx1753_tgt, rx1753_off
  rx1753_start:
    eq $I10, 1, rx1753_restart
    if_null rx1753_debug, debug_1396
    rx1753_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1396:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1756_done
    goto rxscan1756_scan
  rxscan1756_loop:
    (rx1753_pos) = rx1753_cur."from"()
    inc rx1753_pos
    rx1753_cur."!cursor_from"(rx1753_pos)
    ge rx1753_pos, rx1753_eos, rxscan1756_done
  rxscan1756_scan:
    set_addr $I10, rxscan1756_loop
    rx1753_cur."!mark_push"(0, rx1753_pos, $I10)
  rxscan1756_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1757_fail
    rx1753_cur."!mark_push"(0, rx1753_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1753_pos, 4
    gt $I11, rx1753_eos, rx1753_fail
    sub $I11, rx1753_pos, rx1753_off
    substr $S10, rx1753_tgt, $I11, 4
    ne $S10, "redo", rx1753_fail
    add rx1753_pos, 4
    set_addr $I10, rxcap_1757_fail
    ($I12, $I11) = rx1753_cur."!mark_peek"($I10)
    rx1753_cur."!cursor_pos"($I11)
    ($P10) = rx1753_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1753_pos, "")
    rx1753_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1757_done
  rxcap_1757_fail:
    goto rx1753_fail
  rxcap_1757_done:
  # rx pass
    rx1753_cur."!cursor_pass"(rx1753_pos, "term:sym<redo>")
    if_null rx1753_debug, debug_1397
    rx1753_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1753_pos)
  debug_1397:
    .return (rx1753_cur)
  rx1753_restart:
.annotate 'line', 10
    if_null rx1753_debug, debug_1398
    rx1753_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1398:
  rx1753_fail:
    (rx1753_rep, rx1753_pos, $I10, $P10) = rx1753_cur."!mark_fail"(0)
    lt rx1753_pos, -1, rx1753_done
    eq rx1753_pos, -1, rx1753_fail
    jump $I10
  rx1753_done:
    rx1753_cur."!cursor_fail"()
    if_null rx1753_debug, debug_1399
    rx1753_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1399:
    .return (rx1753_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303430322.161") :method
.annotate 'line', 10
    new $P1755, "ResizablePMCArray"
    push $P1755, "redo"
    .return ($P1755)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303430322.161") :outer("12_1303430322.161")
    .param pmc param_1759
    .param pmc param_1760
.annotate 'line', 721
    .lex "self", param_1759
    .lex "$/", param_1760
.annotate 'line', 723
    new $P1761, "Undef"
    .lex "$t", $P1761
    find_lex $P1762, "$/"
    unless_null $P1762, vivify_1400
    $P1762 = root_new ['parrot';'ResizablePMCArray']
  vivify_1400:
    set $P1763, $P1762[0]
    unless_null $P1763, vivify_1401
    new $P1763, "Undef"
  vivify_1401:
    store_lex "$t", $P1763
    find_lex $P1764, "$/"
    unless_null $P1764, vivify_1402
    $P1764 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P1765, $P1764[1]
    unless_null $P1765, vivify_1403
    new $P1765, "Undef"
  vivify_1403:
    find_lex $P1766, "$/"
    unless_null $P1766, vivify_1404
    $P1766 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1766
  vivify_1404:
    set $P1766[0], $P1765
    find_lex $P1767, "$t"
    unless_null $P1767, vivify_1405
    new $P1767, "Undef"
  vivify_1405:
    find_lex $P1768, "$/"
    unless_null $P1768, vivify_1406
    $P1768 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1768
  vivify_1406:
    set $P1768[1], $P1767
.annotate 'line', 721
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2493"  :subid("384_1303430322.161") :outer("10_1303430322.161")
.annotate 'line', 727
    .const 'Sub' $P2559 = "405_1303430322.161" 
    capture_lex $P2559
    .const 'Sub' $P2552 = "403_1303430322.161" 
    capture_lex $P2552
    .const 'Sub' $P2547 = "401_1303430322.161" 
    capture_lex $P2547
    .const 'Sub' $P2535 = "398_1303430322.161" 
    capture_lex $P2535
    .const 'Sub' $P2525 = "395_1303430322.161" 
    capture_lex $P2525
    .const 'Sub' $P2520 = "393_1303430322.161" 
    capture_lex $P2520
    .const 'Sub' $P2511 = "390_1303430322.161" 
    capture_lex $P2511
    .const 'Sub' $P2506 = "388_1303430322.161" 
    capture_lex $P2506
    .const 'Sub' $P2497 = "385_1303430322.161" 
    capture_lex $P2497
    .lex "$?PACKAGE", $P2495
    .lex "$?CLASS", $P2496
    .const 'Sub' $P2552 = "403_1303430322.161" 
    capture_lex $P2552
    .return ($P2552)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1407") :outer("384_1303430322.161")
.annotate 'line', 727
    .const 'Sub' $P2494 = "384_1303430322.161" 
    .local pmc block
    set block, $P2494
    .const 'Sub' $P2559 = "405_1303430322.161" 
    capture_lex $P2559
    $P2559()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2558"  :anon :subid("405_1303430322.161") :outer("384_1303430322.161")
.annotate 'line', 727
    nqp_get_sc_object $P2560, "1303430311.149", 2
    .local pmc type_obj
    set type_obj, $P2560
    get_how $P2561, type_obj
    .const 'Sub' $P2562 = "385_1303430322.161" 
    $P2561."add_method"(type_obj, "metachar:sym<:my>", $P2562)
    get_how $P2563, type_obj
    get_global $P2564, "!PREFIX__metachar:sym<:my>"
    $P2563."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2564)
    get_how $P2565, type_obj
    .const 'Sub' $P2566 = "388_1303430322.161" 
    $P2565."add_method"(type_obj, "metachar:sym<{ }>", $P2566)
    get_how $P2567, type_obj
    get_global $P2568, "!PREFIX__metachar:sym<{ }>"
    $P2567."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2568)
    get_how $P2569, type_obj
    .const 'Sub' $P2570 = "390_1303430322.161" 
    $P2569."add_method"(type_obj, "metachar:sym<nqpvar>", $P2570)
    get_how $P2571, type_obj
    get_global $P2572, "!PREFIX__metachar:sym<nqpvar>"
    $P2571."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2572)
    get_how $P2573, type_obj
    .const 'Sub' $P2574 = "393_1303430322.161" 
    $P2573."add_method"(type_obj, "assertion:sym<{ }>", $P2574)
    get_how $P2575, type_obj
    get_global $P2576, "!PREFIX__assertion:sym<{ }>"
    $P2575."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2576)
    get_how $P2577, type_obj
    .const 'Sub' $P2578 = "395_1303430322.161" 
    $P2577."add_method"(type_obj, "assertion:sym<?{ }>", $P2578)
    get_how $P2579, type_obj
    get_global $P2580, "!PREFIX__assertion:sym<?{ }>"
    $P2579."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2580)
    get_how $P2581, type_obj
    .const 'Sub' $P2582 = "398_1303430322.161" 
    $P2581."add_method"(type_obj, "assertion:sym<name>", $P2582)
    get_how $P2583, type_obj
    get_global $P2584, "!PREFIX__assertion:sym<name>"
    $P2583."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2584)
    get_how $P2585, type_obj
    .const 'Sub' $P2586 = "401_1303430322.161" 
    $P2585."add_method"(type_obj, "assertion:sym<var>", $P2586)
    get_how $P2587, type_obj
    get_global $P2588, "!PREFIX__assertion:sym<var>"
    $P2587."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2588)
    get_how $P2589, type_obj
    .const 'Sub' $P2590 = "403_1303430322.161" 
    $P2589."add_method"(type_obj, "codeblock", $P2590)
    get_how $P2591, type_obj
    get_global $P2592, "!PREFIX__codeblock"
    $P2591."add_method"(type_obj, "!PREFIX__codeblock", $P2592)
    get_how $P2593, type_obj
    get_hll_global $P2594, ["Regex";"P6Regex"], "Grammar"
    $P2593."add_parent"(type_obj, $P2594)
    get_how $P2595, type_obj
    $P2596 = $P2595."compose"(type_obj)
    .return ($P2596)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .const 'Sub' $P2503 = "387_1303430322.161" 
    capture_lex $P2503
    .local string rx2498_tgt
    .local int rx2498_pos
    .local int rx2498_off
    .local int rx2498_eos
    .local int rx2498_rep
    .local pmc rx2498_cur
    .local pmc rx2498_debug
    (rx2498_cur, rx2498_pos, rx2498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2498_cur
    .local pmc match
    .lex "$/", match
    length rx2498_eos, rx2498_tgt
    gt rx2498_pos, rx2498_eos, rx2498_done
    set rx2498_off, 0
    lt rx2498_pos, 2, rx2498_start
    sub rx2498_off, rx2498_pos, 1
    substr rx2498_tgt, rx2498_tgt, rx2498_off
  rx2498_start:
    eq $I10, 1, rx2498_restart
    if_null rx2498_debug, debug_1408
    rx2498_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1408:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2501_done
    goto rxscan2501_scan
  rxscan2501_loop:
    (rx2498_pos) = rx2498_cur."from"()
    inc rx2498_pos
    rx2498_cur."!cursor_from"(rx2498_pos)
    ge rx2498_pos, rx2498_eos, rxscan2501_done
  rxscan2501_scan:
    set_addr $I10, rxscan2501_loop
    rx2498_cur."!mark_push"(0, rx2498_pos, $I10)
  rxscan2501_done:
.annotate 'line', 729
  # rx literal  ":"
    add $I11, rx2498_pos, 1
    gt $I11, rx2498_eos, rx2498_fail
    sub $I11, rx2498_pos, rx2498_off
    ord $I11, rx2498_tgt, $I11
    ne $I11, 58, rx2498_fail
    add rx2498_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2498_cur."!cursor_pos"(rx2498_pos)
    .const 'Sub' $P2503 = "387_1303430322.161" 
    capture_lex $P2503
    $P10 = rx2498_cur."before"($P2503)
    unless $P10, rx2498_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2498_cur."!cursor_pos"(rx2498_pos)
    $P10 = rx2498_cur."LANG"("MAIN", "statement")
    unless $P10, rx2498_fail
    rx2498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2498_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2498_cur."!cursor_pos"(rx2498_pos)
    $P10 = rx2498_cur."ws"()
    unless $P10, rx2498_fail
    rx2498_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2498_pos, 1
    gt $I11, rx2498_eos, rx2498_fail
    sub $I11, rx2498_pos, rx2498_off
    ord $I11, rx2498_tgt, $I11
    ne $I11, 59, rx2498_fail
    add rx2498_pos, 1
.annotate 'line', 728
  # rx pass
    rx2498_cur."!cursor_pass"(rx2498_pos, "metachar:sym<:my>")
    if_null rx2498_debug, debug_1413
    rx2498_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2498_pos)
  debug_1413:
    .return (rx2498_cur)
  rx2498_restart:
.annotate 'line', 727
    if_null rx2498_debug, debug_1414
    rx2498_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1414:
  rx2498_fail:
    (rx2498_rep, rx2498_pos, $I10, $P10) = rx2498_cur."!mark_fail"(0)
    lt rx2498_pos, -1, rx2498_done
    eq rx2498_pos, -1, rx2498_fail
    jump $I10
  rx2498_done:
    rx2498_cur."!cursor_fail"()
    if_null rx2498_debug, debug_1415
    rx2498_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1415:
    .return (rx2498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303430322.161") :method
.annotate 'line', 727
    new $P2500, "ResizablePMCArray"
    push $P2500, ":"
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2502"  :anon :subid("387_1303430322.161") :method :outer("385_1303430322.161")
.annotate 'line', 729
    .local string rx2504_tgt
    .local int rx2504_pos
    .local int rx2504_off
    .local int rx2504_eos
    .local int rx2504_rep
    .local pmc rx2504_cur
    .local pmc rx2504_debug
    (rx2504_cur, rx2504_pos, rx2504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2504_cur
    .local pmc match
    .lex "$/", match
    length rx2504_eos, rx2504_tgt
    gt rx2504_pos, rx2504_eos, rx2504_done
    set rx2504_off, 0
    lt rx2504_pos, 2, rx2504_start
    sub rx2504_off, rx2504_pos, 1
    substr rx2504_tgt, rx2504_tgt, rx2504_off
  rx2504_start:
    eq $I10, 1, rx2504_restart
    if_null rx2504_debug, debug_1409
    rx2504_cur."!cursor_debug"("START", "")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2505_done
    goto rxscan2505_scan
  rxscan2505_loop:
    (rx2504_pos) = rx2504_cur."from"()
    inc rx2504_pos
    rx2504_cur."!cursor_from"(rx2504_pos)
    ge rx2504_pos, rx2504_eos, rxscan2505_done
  rxscan2505_scan:
    set_addr $I10, rxscan2505_loop
    rx2504_cur."!mark_push"(0, rx2504_pos, $I10)
  rxscan2505_done:
  # rx literal  "my"
    add $I11, rx2504_pos, 2
    gt $I11, rx2504_eos, rx2504_fail
    sub $I11, rx2504_pos, rx2504_off
    substr $S10, rx2504_tgt, $I11, 2
    ne $S10, "my", rx2504_fail
    add rx2504_pos, 2
  # rx pass
    rx2504_cur."!cursor_pass"(rx2504_pos, "")
    if_null rx2504_debug, debug_1410
    rx2504_cur."!cursor_debug"("PASS", "", " at pos=", rx2504_pos)
  debug_1410:
    .return (rx2504_cur)
  rx2504_restart:
    if_null rx2504_debug, debug_1411
    rx2504_cur."!cursor_debug"("NEXT", "")
  debug_1411:
  rx2504_fail:
    (rx2504_rep, rx2504_pos, $I10, $P10) = rx2504_cur."!mark_fail"(0)
    lt rx2504_pos, -1, rx2504_done
    eq rx2504_pos, -1, rx2504_fail
    jump $I10
  rx2504_done:
    rx2504_cur."!cursor_fail"()
    if_null rx2504_debug, debug_1412
    rx2504_cur."!cursor_debug"("FAIL", "")
  debug_1412:
    .return (rx2504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .local string rx2507_tgt
    .local int rx2507_pos
    .local int rx2507_off
    .local int rx2507_eos
    .local int rx2507_rep
    .local pmc rx2507_cur
    .local pmc rx2507_debug
    (rx2507_cur, rx2507_pos, rx2507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2507_cur
    .local pmc match
    .lex "$/", match
    length rx2507_eos, rx2507_tgt
    gt rx2507_pos, rx2507_eos, rx2507_done
    set rx2507_off, 0
    lt rx2507_pos, 2, rx2507_start
    sub rx2507_off, rx2507_pos, 1
    substr rx2507_tgt, rx2507_tgt, rx2507_off
  rx2507_start:
    eq $I10, 1, rx2507_restart
    if_null rx2507_debug, debug_1416
    rx2507_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1416:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2510_done
    goto rxscan2510_scan
  rxscan2510_loop:
    (rx2507_pos) = rx2507_cur."from"()
    inc rx2507_pos
    rx2507_cur."!cursor_from"(rx2507_pos)
    ge rx2507_pos, rx2507_eos, rxscan2510_done
  rxscan2510_scan:
    set_addr $I10, rxscan2510_loop
    rx2507_cur."!mark_push"(0, rx2507_pos, $I10)
  rxscan2510_done:
.annotate 'line', 733
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2507_pos, rx2507_off
    substr $S10, rx2507_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2507_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."codeblock"()
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2507_pos = $P10."pos"()
.annotate 'line', 732
  # rx pass
    rx2507_cur."!cursor_pass"(rx2507_pos, "metachar:sym<{ }>")
    if_null rx2507_debug, debug_1417
    rx2507_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2507_pos)
  debug_1417:
    .return (rx2507_cur)
  rx2507_restart:
.annotate 'line', 727
    if_null rx2507_debug, debug_1418
    rx2507_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1418:
  rx2507_fail:
    (rx2507_rep, rx2507_pos, $I10, $P10) = rx2507_cur."!mark_fail"(0)
    lt rx2507_pos, -1, rx2507_done
    eq rx2507_pos, -1, rx2507_fail
    jump $I10
  rx2507_done:
    rx2507_cur."!cursor_fail"()
    if_null rx2507_debug, debug_1419
    rx2507_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1419:
    .return (rx2507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303430322.161") :method
.annotate 'line', 727
    new $P2509, "ResizablePMCArray"
    push $P2509, "{"
    .return ($P2509)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .const 'Sub' $P2517 = "392_1303430322.161" 
    capture_lex $P2517
    .local string rx2512_tgt
    .local int rx2512_pos
    .local int rx2512_off
    .local int rx2512_eos
    .local int rx2512_rep
    .local pmc rx2512_cur
    .local pmc rx2512_debug
    (rx2512_cur, rx2512_pos, rx2512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2512_cur
    .local pmc match
    .lex "$/", match
    length rx2512_eos, rx2512_tgt
    gt rx2512_pos, rx2512_eos, rx2512_done
    set rx2512_off, 0
    lt rx2512_pos, 2, rx2512_start
    sub rx2512_off, rx2512_pos, 1
    substr rx2512_tgt, rx2512_tgt, rx2512_off
  rx2512_start:
    eq $I10, 1, rx2512_restart
    if_null rx2512_debug, debug_1420
    rx2512_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1420:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2515_done
    goto rxscan2515_scan
  rxscan2515_loop:
    (rx2512_pos) = rx2512_cur."from"()
    inc rx2512_pos
    rx2512_cur."!cursor_from"(rx2512_pos)
    ge rx2512_pos, rx2512_eos, rxscan2515_done
  rxscan2515_scan:
    set_addr $I10, rxscan2515_loop
    rx2512_cur."!mark_push"(0, rx2512_pos, $I10)
  rxscan2515_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2512_pos, rx2512_off
    substr $S10, rx2512_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2512_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2512_cur."!cursor_pos"(rx2512_pos)
    .const 'Sub' $P2517 = "392_1303430322.161" 
    capture_lex $P2517
    $P10 = rx2512_cur."before"($P2517)
    unless $P10, rx2512_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2512_cur."!cursor_pos"(rx2512_pos)
    $P10 = rx2512_cur."LANG"("MAIN", "variable")
    unless $P10, rx2512_fail
    rx2512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2512_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx2512_cur."!cursor_pass"(rx2512_pos, "metachar:sym<nqpvar>")
    if_null rx2512_debug, debug_1425
    rx2512_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2512_pos)
  debug_1425:
    .return (rx2512_cur)
  rx2512_restart:
.annotate 'line', 727
    if_null rx2512_debug, debug_1426
    rx2512_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1426:
  rx2512_fail:
    (rx2512_rep, rx2512_pos, $I10, $P10) = rx2512_cur."!mark_fail"(0)
    lt rx2512_pos, -1, rx2512_done
    eq rx2512_pos, -1, rx2512_fail
    jump $I10
  rx2512_done:
    rx2512_cur."!cursor_fail"()
    if_null rx2512_debug, debug_1427
    rx2512_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1427:
    .return (rx2512_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303430322.161") :method
.annotate 'line', 727
    new $P2514, "ResizablePMCArray"
    push $P2514, "$"
    push $P2514, "@"
    .return ($P2514)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2516"  :anon :subid("392_1303430322.161") :method :outer("390_1303430322.161")
.annotate 'line', 737
    .local string rx2518_tgt
    .local int rx2518_pos
    .local int rx2518_off
    .local int rx2518_eos
    .local int rx2518_rep
    .local pmc rx2518_cur
    .local pmc rx2518_debug
    (rx2518_cur, rx2518_pos, rx2518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2518_cur
    .local pmc match
    .lex "$/", match
    length rx2518_eos, rx2518_tgt
    gt rx2518_pos, rx2518_eos, rx2518_done
    set rx2518_off, 0
    lt rx2518_pos, 2, rx2518_start
    sub rx2518_off, rx2518_pos, 1
    substr rx2518_tgt, rx2518_tgt, rx2518_off
  rx2518_start:
    eq $I10, 1, rx2518_restart
    if_null rx2518_debug, debug_1421
    rx2518_cur."!cursor_debug"("START", "")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2519_done
    goto rxscan2519_scan
  rxscan2519_loop:
    (rx2518_pos) = rx2518_cur."from"()
    inc rx2518_pos
    rx2518_cur."!cursor_from"(rx2518_pos)
    ge rx2518_pos, rx2518_eos, rxscan2519_done
  rxscan2519_scan:
    set_addr $I10, rxscan2519_loop
    rx2518_cur."!mark_push"(0, rx2518_pos, $I10)
  rxscan2519_done:
  # rx charclass .
    ge rx2518_pos, rx2518_eos, rx2518_fail
    inc rx2518_pos
  # rx charclass w
    ge rx2518_pos, rx2518_eos, rx2518_fail
    sub $I10, rx2518_pos, rx2518_off
    is_cclass $I11, 8192, rx2518_tgt, $I10
    unless $I11, rx2518_fail
    inc rx2518_pos
  # rx pass
    rx2518_cur."!cursor_pass"(rx2518_pos, "")
    if_null rx2518_debug, debug_1422
    rx2518_cur."!cursor_debug"("PASS", "", " at pos=", rx2518_pos)
  debug_1422:
    .return (rx2518_cur)
  rx2518_restart:
    if_null rx2518_debug, debug_1423
    rx2518_cur."!cursor_debug"("NEXT", "")
  debug_1423:
  rx2518_fail:
    (rx2518_rep, rx2518_pos, $I10, $P10) = rx2518_cur."!mark_fail"(0)
    lt rx2518_pos, -1, rx2518_done
    eq rx2518_pos, -1, rx2518_fail
    jump $I10
  rx2518_done:
    rx2518_cur."!cursor_fail"()
    if_null rx2518_debug, debug_1424
    rx2518_cur."!cursor_debug"("FAIL", "")
  debug_1424:
    .return (rx2518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .local string rx2521_tgt
    .local int rx2521_pos
    .local int rx2521_off
    .local int rx2521_eos
    .local int rx2521_rep
    .local pmc rx2521_cur
    .local pmc rx2521_debug
    (rx2521_cur, rx2521_pos, rx2521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2521_cur
    .local pmc match
    .lex "$/", match
    length rx2521_eos, rx2521_tgt
    gt rx2521_pos, rx2521_eos, rx2521_done
    set rx2521_off, 0
    lt rx2521_pos, 2, rx2521_start
    sub rx2521_off, rx2521_pos, 1
    substr rx2521_tgt, rx2521_tgt, rx2521_off
  rx2521_start:
    eq $I10, 1, rx2521_restart
    if_null rx2521_debug, debug_1428
    rx2521_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1428:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2524_done
    goto rxscan2524_scan
  rxscan2524_loop:
    (rx2521_pos) = rx2521_cur."from"()
    inc rx2521_pos
    rx2521_cur."!cursor_from"(rx2521_pos)
    ge rx2521_pos, rx2521_eos, rxscan2524_done
  rxscan2524_scan:
    set_addr $I10, rxscan2524_loop
    rx2521_cur."!mark_push"(0, rx2521_pos, $I10)
  rxscan2524_done:
.annotate 'line', 741
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2521_pos, rx2521_off
    substr $S10, rx2521_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2521_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2521_cur."!cursor_pos"(rx2521_pos)
    $P10 = rx2521_cur."codeblock"()
    unless $P10, rx2521_fail
    rx2521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2521_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx2521_cur."!cursor_pass"(rx2521_pos, "assertion:sym<{ }>")
    if_null rx2521_debug, debug_1429
    rx2521_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2521_pos)
  debug_1429:
    .return (rx2521_cur)
  rx2521_restart:
.annotate 'line', 727
    if_null rx2521_debug, debug_1430
    rx2521_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1430:
  rx2521_fail:
    (rx2521_rep, rx2521_pos, $I10, $P10) = rx2521_cur."!mark_fail"(0)
    lt rx2521_pos, -1, rx2521_done
    eq rx2521_pos, -1, rx2521_fail
    jump $I10
  rx2521_done:
    rx2521_cur."!cursor_fail"()
    if_null rx2521_debug, debug_1431
    rx2521_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1431:
    .return (rx2521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303430322.161") :method
.annotate 'line', 727
    new $P2523, "ResizablePMCArray"
    push $P2523, "{"
    .return ($P2523)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .const 'Sub' $P2531 = "397_1303430322.161" 
    capture_lex $P2531
    .local string rx2526_tgt
    .local int rx2526_pos
    .local int rx2526_off
    .local int rx2526_eos
    .local int rx2526_rep
    .local pmc rx2526_cur
    .local pmc rx2526_debug
    (rx2526_cur, rx2526_pos, rx2526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2526_cur
    .local pmc match
    .lex "$/", match
    length rx2526_eos, rx2526_tgt
    gt rx2526_pos, rx2526_eos, rx2526_done
    set rx2526_off, 0
    lt rx2526_pos, 2, rx2526_start
    sub rx2526_off, rx2526_pos, 1
    substr rx2526_tgt, rx2526_tgt, rx2526_off
  rx2526_start:
    eq $I10, 1, rx2526_restart
    if_null rx2526_debug, debug_1432
    rx2526_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2529_done
    goto rxscan2529_scan
  rxscan2529_loop:
    (rx2526_pos) = rx2526_cur."from"()
    inc rx2526_pos
    rx2526_cur."!cursor_from"(rx2526_pos)
    ge rx2526_pos, rx2526_eos, rxscan2529_done
  rxscan2529_scan:
    set_addr $I10, rxscan2529_loop
    rx2526_cur."!mark_push"(0, rx2526_pos, $I10)
  rxscan2529_done:
.annotate 'line', 745
  # rx subcapture "zw"
    set_addr $I10, rxcap_2534_fail
    rx2526_cur."!mark_push"(0, rx2526_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2526_pos, rx2526_eos, rx2526_fail
    sub $I10, rx2526_pos, rx2526_off
    substr $S10, rx2526_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2526_fail
    inc rx2526_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2526_cur."!cursor_pos"(rx2526_pos)
    .const 'Sub' $P2531 = "397_1303430322.161" 
    capture_lex $P2531
    $P10 = rx2526_cur."before"($P2531)
    unless $P10, rx2526_fail
    set_addr $I10, rxcap_2534_fail
    ($I12, $I11) = rx2526_cur."!mark_peek"($I10)
    rx2526_cur."!cursor_pos"($I11)
    ($P10) = rx2526_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2526_pos, "")
    rx2526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2534_done
  rxcap_2534_fail:
    goto rx2526_fail
  rxcap_2534_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2526_cur."!cursor_pos"(rx2526_pos)
    $P10 = rx2526_cur."codeblock"()
    unless $P10, rx2526_fail
    rx2526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2526_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx2526_cur."!cursor_pass"(rx2526_pos, "assertion:sym<?{ }>")
    if_null rx2526_debug, debug_1437
    rx2526_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2526_pos)
  debug_1437:
    .return (rx2526_cur)
  rx2526_restart:
.annotate 'line', 727
    if_null rx2526_debug, debug_1438
    rx2526_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1438:
  rx2526_fail:
    (rx2526_rep, rx2526_pos, $I10, $P10) = rx2526_cur."!mark_fail"(0)
    lt rx2526_pos, -1, rx2526_done
    eq rx2526_pos, -1, rx2526_fail
    jump $I10
  rx2526_done:
    rx2526_cur."!cursor_fail"()
    if_null rx2526_debug, debug_1439
    rx2526_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1439:
    .return (rx2526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303430322.161") :method
.annotate 'line', 727
    new $P2528, "ResizablePMCArray"
    push $P2528, "!"
    push $P2528, "?"
    .return ($P2528)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2530"  :anon :subid("397_1303430322.161") :method :outer("395_1303430322.161")
.annotate 'line', 745
    .local string rx2532_tgt
    .local int rx2532_pos
    .local int rx2532_off
    .local int rx2532_eos
    .local int rx2532_rep
    .local pmc rx2532_cur
    .local pmc rx2532_debug
    (rx2532_cur, rx2532_pos, rx2532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2532_cur
    .local pmc match
    .lex "$/", match
    length rx2532_eos, rx2532_tgt
    gt rx2532_pos, rx2532_eos, rx2532_done
    set rx2532_off, 0
    lt rx2532_pos, 2, rx2532_start
    sub rx2532_off, rx2532_pos, 1
    substr rx2532_tgt, rx2532_tgt, rx2532_off
  rx2532_start:
    eq $I10, 1, rx2532_restart
    if_null rx2532_debug, debug_1433
    rx2532_cur."!cursor_debug"("START", "")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2533_done
    goto rxscan2533_scan
  rxscan2533_loop:
    (rx2532_pos) = rx2532_cur."from"()
    inc rx2532_pos
    rx2532_cur."!cursor_from"(rx2532_pos)
    ge rx2532_pos, rx2532_eos, rxscan2533_done
  rxscan2533_scan:
    set_addr $I10, rxscan2533_loop
    rx2532_cur."!mark_push"(0, rx2532_pos, $I10)
  rxscan2533_done:
  # rx literal  "{"
    add $I11, rx2532_pos, 1
    gt $I11, rx2532_eos, rx2532_fail
    sub $I11, rx2532_pos, rx2532_off
    ord $I11, rx2532_tgt, $I11
    ne $I11, 123, rx2532_fail
    add rx2532_pos, 1
  # rx pass
    rx2532_cur."!cursor_pass"(rx2532_pos, "")
    if_null rx2532_debug, debug_1434
    rx2532_cur."!cursor_debug"("PASS", "", " at pos=", rx2532_pos)
  debug_1434:
    .return (rx2532_cur)
  rx2532_restart:
    if_null rx2532_debug, debug_1435
    rx2532_cur."!cursor_debug"("NEXT", "")
  debug_1435:
  rx2532_fail:
    (rx2532_rep, rx2532_pos, $I10, $P10) = rx2532_cur."!mark_fail"(0)
    lt rx2532_pos, -1, rx2532_done
    eq rx2532_pos, -1, rx2532_fail
    jump $I10
  rx2532_done:
    rx2532_cur."!cursor_fail"()
    if_null rx2532_debug, debug_1436
    rx2532_cur."!cursor_debug"("FAIL", "")
  debug_1436:
    .return (rx2532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .const 'Sub' $P2544 = "400_1303430322.161" 
    capture_lex $P2544
    .local string rx2536_tgt
    .local int rx2536_pos
    .local int rx2536_off
    .local int rx2536_eos
    .local int rx2536_rep
    .local pmc rx2536_cur
    .local pmc rx2536_debug
    (rx2536_cur, rx2536_pos, rx2536_tgt, $I10) = self."!cursor_start"()
    rx2536_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2536_cur
    .local pmc match
    .lex "$/", match
    length rx2536_eos, rx2536_tgt
    gt rx2536_pos, rx2536_eos, rx2536_done
    set rx2536_off, 0
    lt rx2536_pos, 2, rx2536_start
    sub rx2536_off, rx2536_pos, 1
    substr rx2536_tgt, rx2536_tgt, rx2536_off
  rx2536_start:
    eq $I10, 1, rx2536_restart
    if_null rx2536_debug, debug_1440
    rx2536_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2540_done
    goto rxscan2540_scan
  rxscan2540_loop:
    (rx2536_pos) = rx2536_cur."from"()
    inc rx2536_pos
    rx2536_cur."!cursor_from"(rx2536_pos)
    ge rx2536_pos, rx2536_eos, rxscan2540_done
  rxscan2540_scan:
    set_addr $I10, rxscan2540_loop
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
  rxscan2540_done:
.annotate 'line', 749
  # rx subrule "identifier" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."identifier"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2536_pos = $P10."pos"()
.annotate 'line', 756
  # rx rxquantr2541 ** 0..1
    set_addr $I10, rxquantr2541_done
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
  rxquantr2541_loop:
  alt2542_0:
.annotate 'line', 750
    set_addr $I10, alt2542_1
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 751
  # rx subrule "before" subtype=zerowidth negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    .const 'Sub' $P2544 = "400_1303430322.161" 
    capture_lex $P2544
    $P10 = rx2536_cur."before"($P2544)
    unless $P10, rx2536_fail
    goto alt2542_end
  alt2542_1:
    set_addr $I10, alt2542_2
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 752
  # rx literal  "="
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 61, rx2536_fail
    add rx2536_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."assertion"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2536_pos = $P10."pos"()
    goto alt2542_end
  alt2542_2:
    set_addr $I10, alt2542_3
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 753
  # rx literal  ":"
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 58, rx2536_fail
    add rx2536_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."arglist"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2536_pos = $P10."pos"()
    goto alt2542_end
  alt2542_3:
    set_addr $I10, alt2542_4
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 754
  # rx literal  "("
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 40, rx2536_fail
    add rx2536_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2536_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 41, rx2536_fail
    add rx2536_pos, 1
    goto alt2542_end
  alt2542_4:
.annotate 'line', 755
  # rx subrule "normspace" subtype=method negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."normspace"()
    unless $P10, rx2536_fail
    rx2536_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."nibbler"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2536_pos = $P10."pos"()
  alt2542_end:
.annotate 'line', 756
    set_addr $I10, rxquantr2541_done
    (rx2536_rep) = rx2536_cur."!mark_commit"($I10)
  rxquantr2541_done:
.annotate 'line', 748
  # rx pass
    rx2536_cur."!cursor_pass"(rx2536_pos, "assertion:sym<name>")
    if_null rx2536_debug, debug_1445
    rx2536_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2536_pos)
  debug_1445:
    .return (rx2536_cur)
  rx2536_restart:
.annotate 'line', 727
    if_null rx2536_debug, debug_1446
    rx2536_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1446:
  rx2536_fail:
    (rx2536_rep, rx2536_pos, $I10, $P10) = rx2536_cur."!mark_fail"(0)
    lt rx2536_pos, -1, rx2536_done
    eq rx2536_pos, -1, rx2536_fail
    jump $I10
  rx2536_done:
    rx2536_cur."!cursor_fail"()
    if_null rx2536_debug, debug_1447
    rx2536_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1447:
    .return (rx2536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303430322.161") :method
.annotate 'line', 727
    $P2538 = self."!PREFIX__!subrule"("identifier", "")
    new $P2539, "ResizablePMCArray"
    push $P2539, $P2538
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2543"  :anon :subid("400_1303430322.161") :method :outer("398_1303430322.161")
.annotate 'line', 751
    .local string rx2545_tgt
    .local int rx2545_pos
    .local int rx2545_off
    .local int rx2545_eos
    .local int rx2545_rep
    .local pmc rx2545_cur
    .local pmc rx2545_debug
    (rx2545_cur, rx2545_pos, rx2545_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2545_cur
    .local pmc match
    .lex "$/", match
    length rx2545_eos, rx2545_tgt
    gt rx2545_pos, rx2545_eos, rx2545_done
    set rx2545_off, 0
    lt rx2545_pos, 2, rx2545_start
    sub rx2545_off, rx2545_pos, 1
    substr rx2545_tgt, rx2545_tgt, rx2545_off
  rx2545_start:
    eq $I10, 1, rx2545_restart
    if_null rx2545_debug, debug_1441
    rx2545_cur."!cursor_debug"("START", "")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2546_done
    goto rxscan2546_scan
  rxscan2546_loop:
    (rx2545_pos) = rx2545_cur."from"()
    inc rx2545_pos
    rx2545_cur."!cursor_from"(rx2545_pos)
    ge rx2545_pos, rx2545_eos, rxscan2546_done
  rxscan2546_scan:
    set_addr $I10, rxscan2546_loop
    rx2545_cur."!mark_push"(0, rx2545_pos, $I10)
  rxscan2546_done:
  # rx literal  ">"
    add $I11, rx2545_pos, 1
    gt $I11, rx2545_eos, rx2545_fail
    sub $I11, rx2545_pos, rx2545_off
    ord $I11, rx2545_tgt, $I11
    ne $I11, 62, rx2545_fail
    add rx2545_pos, 1
  # rx pass
    rx2545_cur."!cursor_pass"(rx2545_pos, "")
    if_null rx2545_debug, debug_1442
    rx2545_cur."!cursor_debug"("PASS", "", " at pos=", rx2545_pos)
  debug_1442:
    .return (rx2545_cur)
  rx2545_restart:
    if_null rx2545_debug, debug_1443
    rx2545_cur."!cursor_debug"("NEXT", "")
  debug_1443:
  rx2545_fail:
    (rx2545_rep, rx2545_pos, $I10, $P10) = rx2545_cur."!mark_fail"(0)
    lt rx2545_pos, -1, rx2545_done
    eq rx2545_pos, -1, rx2545_fail
    jump $I10
  rx2545_done:
    rx2545_cur."!cursor_fail"()
    if_null rx2545_debug, debug_1444
    rx2545_cur."!cursor_debug"("FAIL", "")
  debug_1444:
    .return (rx2545_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .local string rx2548_tgt
    .local int rx2548_pos
    .local int rx2548_off
    .local int rx2548_eos
    .local int rx2548_rep
    .local pmc rx2548_cur
    .local pmc rx2548_debug
    (rx2548_cur, rx2548_pos, rx2548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2548_cur
    .local pmc match
    .lex "$/", match
    length rx2548_eos, rx2548_tgt
    gt rx2548_pos, rx2548_eos, rx2548_done
    set rx2548_off, 0
    lt rx2548_pos, 2, rx2548_start
    sub rx2548_off, rx2548_pos, 1
    substr rx2548_tgt, rx2548_tgt, rx2548_off
  rx2548_start:
    eq $I10, 1, rx2548_restart
    if_null rx2548_debug, debug_1448
    rx2548_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2551_done
    goto rxscan2551_scan
  rxscan2551_loop:
    (rx2548_pos) = rx2548_cur."from"()
    inc rx2548_pos
    rx2548_cur."!cursor_from"(rx2548_pos)
    ge rx2548_pos, rx2548_eos, rxscan2551_done
  rxscan2551_scan:
    set_addr $I10, rxscan2551_loop
    rx2548_cur."!mark_push"(0, rx2548_pos, $I10)
  rxscan2551_done:
.annotate 'line', 760
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2548_pos, rx2548_off
    substr $S10, rx2548_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2548_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2548_cur."!cursor_pos"(rx2548_pos)
    $P10 = rx2548_cur."LANG"("MAIN", "variable")
    unless $P10, rx2548_fail
    rx2548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2548_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx2548_cur."!cursor_pass"(rx2548_pos, "assertion:sym<var>")
    if_null rx2548_debug, debug_1449
    rx2548_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2548_pos)
  debug_1449:
    .return (rx2548_cur)
  rx2548_restart:
.annotate 'line', 727
    if_null rx2548_debug, debug_1450
    rx2548_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1450:
  rx2548_fail:
    (rx2548_rep, rx2548_pos, $I10, $P10) = rx2548_cur."!mark_fail"(0)
    lt rx2548_pos, -1, rx2548_done
    eq rx2548_pos, -1, rx2548_fail
    jump $I10
  rx2548_done:
    rx2548_cur."!cursor_fail"()
    if_null rx2548_debug, debug_1451
    rx2548_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1451:
    .return (rx2548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303430322.161") :method
.annotate 'line', 727
    new $P2550, "ResizablePMCArray"
    push $P2550, "$"
    push $P2550, "@"
    .return ($P2550)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303430322.161") :method :outer("384_1303430322.161")
.annotate 'line', 727
    .local string rx2553_tgt
    .local int rx2553_pos
    .local int rx2553_off
    .local int rx2553_eos
    .local int rx2553_rep
    .local pmc rx2553_cur
    .local pmc rx2553_debug
    (rx2553_cur, rx2553_pos, rx2553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2553_cur
    .local pmc match
    .lex "$/", match
    length rx2553_eos, rx2553_tgt
    gt rx2553_pos, rx2553_eos, rx2553_done
    set rx2553_off, 0
    lt rx2553_pos, 2, rx2553_start
    sub rx2553_off, rx2553_pos, 1
    substr rx2553_tgt, rx2553_tgt, rx2553_off
  rx2553_start:
    eq $I10, 1, rx2553_restart
    if_null rx2553_debug, debug_1452
    rx2553_cur."!cursor_debug"("START", "codeblock")
  debug_1452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2557_done
    goto rxscan2557_scan
  rxscan2557_loop:
    (rx2553_pos) = rx2553_cur."from"()
    inc rx2553_pos
    rx2553_cur."!cursor_from"(rx2553_pos)
    ge rx2553_pos, rx2553_eos, rxscan2557_done
  rxscan2557_scan:
    set_addr $I10, rxscan2557_loop
    rx2553_cur."!mark_push"(0, rx2553_pos, $I10)
  rxscan2557_done:
.annotate 'line', 764
  # rx subrule "LANG" subtype=capture negate=
    rx2553_cur."!cursor_pos"(rx2553_pos)
    $P10 = rx2553_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2553_fail
    rx2553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2553_pos = $P10."pos"()
.annotate 'line', 763
  # rx pass
    rx2553_cur."!cursor_pass"(rx2553_pos, "codeblock")
    if_null rx2553_debug, debug_1453
    rx2553_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2553_pos)
  debug_1453:
    .return (rx2553_cur)
  rx2553_restart:
.annotate 'line', 727
    if_null rx2553_debug, debug_1454
    rx2553_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1454:
  rx2553_fail:
    (rx2553_rep, rx2553_pos, $I10, $P10) = rx2553_cur."!mark_fail"(0)
    lt rx2553_pos, -1, rx2553_done
    eq rx2553_pos, -1, rx2553_fail
    jump $I10
  rx2553_done:
    rx2553_cur."!cursor_fail"()
    if_null rx2553_debug, debug_1455
    rx2553_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1455:
    .return (rx2553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303430322.161") :method
.annotate 'line', 727
    $P2555 = self."!PREFIX__!subrule"("LANG", "")
    new $P2556, "ResizablePMCArray"
    push $P2556, $P2555
    .return ($P2556)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2597"  :subid("406_1303430322.161") :outer("10_1303430322.161")
.annotate 'line', 770
    .const 'Sub' $P5834 = "563_1303430322.161" 
    capture_lex $P5834
    .const 'Sub' $P5820 = "562_1303430322.161" 
    capture_lex $P5820
    .const 'Sub' $P5815 = "561_1303430322.161" 
    capture_lex $P5815
    .const 'Sub' $P5810 = "560_1303430322.161" 
    capture_lex $P5810
    .const 'Sub' $P5805 = "559_1303430322.161" 
    capture_lex $P5805
    .const 'Sub' $P5794 = "558_1303430322.161" 
    capture_lex $P5794
    .const 'Sub' $P5786 = "557_1303430322.161" 
    capture_lex $P5786
    .const 'Sub' $P5778 = "556_1303430322.161" 
    capture_lex $P5778
    .const 'Sub' $P5770 = "555_1303430322.161" 
    capture_lex $P5770
    .const 'Sub' $P5765 = "554_1303430322.161" 
    capture_lex $P5765
    .const 'Sub' $P5753 = "553_1303430322.161" 
    capture_lex $P5753
    .const 'Sub' $P5745 = "552_1303430322.161" 
    capture_lex $P5745
    .const 'Sub' $P5698 = "551_1303430322.161" 
    capture_lex $P5698
    .const 'Sub' $P5686 = "550_1303430322.161" 
    capture_lex $P5686
    .const 'Sub' $P5678 = "549_1303430322.161" 
    capture_lex $P5678
    .const 'Sub' $P5670 = "548_1303430322.161" 
    capture_lex $P5670
    .const 'Sub' $P5662 = "547_1303430322.161" 
    capture_lex $P5662
    .const 'Sub' $P5654 = "546_1303430322.161" 
    capture_lex $P5654
    .const 'Sub' $P5646 = "545_1303430322.161" 
    capture_lex $P5646
    .const 'Sub' $P5620 = "544_1303430322.161" 
    capture_lex $P5620
    .const 'Sub' $P5605 = "543_1303430322.161" 
    capture_lex $P5605
    .const 'Sub' $P5597 = "542_1303430322.161" 
    capture_lex $P5597
    .const 'Sub' $P5586 = "541_1303430322.161" 
    capture_lex $P5586
    .const 'Sub' $P5575 = "540_1303430322.161" 
    capture_lex $P5575
    .const 'Sub' $P5564 = "539_1303430322.161" 
    capture_lex $P5564
    .const 'Sub' $P5556 = "538_1303430322.161" 
    capture_lex $P5556
    .const 'Sub' $P5529 = "537_1303430322.161" 
    capture_lex $P5529
    .const 'Sub' $P5491 = "535_1303430322.161" 
    capture_lex $P5491
    .const 'Sub' $P5483 = "534_1303430322.161" 
    capture_lex $P5483
    .const 'Sub' $P5475 = "533_1303430322.161" 
    capture_lex $P5475
    .const 'Sub' $P5450 = "532_1303430322.161" 
    capture_lex $P5450
    .const 'Sub' $P5434 = "531_1303430322.161" 
    capture_lex $P5434
    .const 'Sub' $P5426 = "530_1303430322.161" 
    capture_lex $P5426
    .const 'Sub' $P5418 = "529_1303430322.161" 
    capture_lex $P5418
    .const 'Sub' $P5316 = "526_1303430322.161" 
    capture_lex $P5316
    .const 'Sub' $P5308 = "525_1303430322.161" 
    capture_lex $P5308
    .const 'Sub' $P5301 = "524_1303430322.161" 
    capture_lex $P5301
    .const 'Sub' $P5270 = "523_1303430322.161" 
    capture_lex $P5270
    .const 'Sub' $P5217 = "521_1303430322.161" 
    capture_lex $P5217
    .const 'Sub' $P5203 = "520_1303430322.161" 
    capture_lex $P5203
    .const 'Sub' $P5196 = "519_1303430322.161" 
    capture_lex $P5196
    .const 'Sub' $P5147 = "518_1303430322.161" 
    capture_lex $P5147
    .const 'Sub' $P4971 = "514_1303430322.161" 
    capture_lex $P4971
    .const 'Sub' $P4908 = "512_1303430322.161" 
    capture_lex $P4908
    .const 'Sub' $P4900 = "511_1303430322.161" 
    capture_lex $P4900
    .const 'Sub' $P4885 = "510_1303430322.161" 
    capture_lex $P4885
    .const 'Sub' $P4870 = "509_1303430322.161" 
    capture_lex $P4870
    .const 'Sub' $P4850 = "508_1303430322.161" 
    capture_lex $P4850
    .const 'Sub' $P4747 = "507_1303430322.161" 
    capture_lex $P4747
    .const 'Sub' $P4699 = "504_1303430322.161" 
    capture_lex $P4699
    .const 'Sub' $P4574 = "501_1303430322.161" 
    capture_lex $P4574
    .const 'Sub' $P4301 = "494_1303430322.161" 
    capture_lex $P4301
    .const 'Sub' $P4293 = "493_1303430322.161" 
    capture_lex $P4293
    .const 'Sub' $P4285 = "492_1303430322.161" 
    capture_lex $P4285
    .const 'Sub' $P4177 = "489_1303430322.161" 
    capture_lex $P4177
    .const 'Sub' $P4169 = "488_1303430322.161" 
    capture_lex $P4169
    .const 'Sub' $P4154 = "487_1303430322.161" 
    capture_lex $P4154
    .const 'Sub' $P4139 = "486_1303430322.161" 
    capture_lex $P4139
    .const 'Sub' $P4124 = "485_1303430322.161" 
    capture_lex $P4124
    .const 'Sub' $P4102 = "484_1303430322.161" 
    capture_lex $P4102
    .const 'Sub' $P4094 = "483_1303430322.161" 
    capture_lex $P4094
    .const 'Sub' $P4086 = "482_1303430322.161" 
    capture_lex $P4086
    .const 'Sub' $P4078 = "481_1303430322.161" 
    capture_lex $P4078
    .const 'Sub' $P3881 = "478_1303430322.161" 
    capture_lex $P3881
    .const 'Sub' $P3873 = "477_1303430322.161" 
    capture_lex $P3873
    .const 'Sub' $P3865 = "476_1303430322.161" 
    capture_lex $P3865
    .const 'Sub' $P3857 = "475_1303430322.161" 
    capture_lex $P3857
    .const 'Sub' $P3849 = "474_1303430322.161" 
    capture_lex $P3849
    .const 'Sub' $P3841 = "473_1303430322.161" 
    capture_lex $P3841
    .const 'Sub' $P3833 = "472_1303430322.161" 
    capture_lex $P3833
    .const 'Sub' $P3722 = "470_1303430322.161" 
    capture_lex $P3722
    .const 'Sub' $P3698 = "469_1303430322.161" 
    capture_lex $P3698
    .const 'Sub' $P3684 = "468_1303430322.161" 
    capture_lex $P3684
    .const 'Sub' $P3676 = "467_1303430322.161" 
    capture_lex $P3676
    .const 'Sub' $P3668 = "466_1303430322.161" 
    capture_lex $P3668
    .const 'Sub' $P3660 = "465_1303430322.161" 
    capture_lex $P3660
    .const 'Sub' $P3652 = "464_1303430322.161" 
    capture_lex $P3652
    .const 'Sub' $P3644 = "463_1303430322.161" 
    capture_lex $P3644
    .const 'Sub' $P3636 = "462_1303430322.161" 
    capture_lex $P3636
    .const 'Sub' $P3628 = "461_1303430322.161" 
    capture_lex $P3628
    .const 'Sub' $P3620 = "460_1303430322.161" 
    capture_lex $P3620
    .const 'Sub' $P3612 = "459_1303430322.161" 
    capture_lex $P3612
    .const 'Sub' $P3604 = "458_1303430322.161" 
    capture_lex $P3604
    .const 'Sub' $P3596 = "457_1303430322.161" 
    capture_lex $P3596
    .const 'Sub' $P3588 = "456_1303430322.161" 
    capture_lex $P3588
    .const 'Sub' $P3580 = "455_1303430322.161" 
    capture_lex $P3580
    .const 'Sub' $P3564 = "454_1303430322.161" 
    capture_lex $P3564
    .const 'Sub' $P3531 = "453_1303430322.161" 
    capture_lex $P3531
    .const 'Sub' $P3517 = "452_1303430322.161" 
    capture_lex $P3517
    .const 'Sub' $P3496 = "451_1303430322.161" 
    capture_lex $P3496
    .const 'Sub' $P3476 = "450_1303430322.161" 
    capture_lex $P3476
    .const 'Sub' $P3452 = "449_1303430322.161" 
    capture_lex $P3452
    .const 'Sub' $P3418 = "448_1303430322.161" 
    capture_lex $P3418
    .const 'Sub' $P3403 = "447_1303430322.161" 
    capture_lex $P3403
    .const 'Sub' $P3391 = "446_1303430322.161" 
    capture_lex $P3391
    .const 'Sub' $P3340 = "444_1303430322.161" 
    capture_lex $P3340
    .const 'Sub' $P3329 = "443_1303430322.161" 
    capture_lex $P3329
    .const 'Sub' $P3322 = "442_1303430322.161" 
    capture_lex $P3322
    .const 'Sub' $P3299 = "441_1303430322.161" 
    capture_lex $P3299
    .const 'Sub' $P3277 = "440_1303430322.161" 
    capture_lex $P3277
    .const 'Sub' $P3266 = "439_1303430322.161" 
    capture_lex $P3266
    .const 'Sub' $P3229 = "437_1303430322.161" 
    capture_lex $P3229
    .const 'Sub' $P3221 = "436_1303430322.161" 
    capture_lex $P3221
    .const 'Sub' $P3213 = "435_1303430322.161" 
    capture_lex $P3213
    .const 'Sub' $P3199 = "434_1303430322.161" 
    capture_lex $P3199
    .const 'Sub' $P3118 = "432_1303430322.161" 
    capture_lex $P3118
    .const 'Sub' $P3077 = "430_1303430322.161" 
    capture_lex $P3077
    .const 'Sub' $P3010 = "429_1303430322.161" 
    capture_lex $P3010
    .const 'Sub' $P2979 = "428_1303430322.161" 
    capture_lex $P2979
    .const 'Sub' $P2971 = "427_1303430322.161" 
    capture_lex $P2971
    .const 'Sub' $P2930 = "425_1303430322.161" 
    capture_lex $P2930
    .const 'Sub' $P2895 = "423_1303430322.161" 
    capture_lex $P2895
    .const 'Sub' $P2890 = "422_1303430322.161" 
    capture_lex $P2890
    .const 'Sub' $P2885 = "421_1303430322.161" 
    capture_lex $P2885
    .const 'Sub' $P2814 = "418_1303430322.161" 
    capture_lex $P2814
    .const 'Sub' $P2802 = "417_1303430322.161" 
    capture_lex $P2802
    .const 'Sub' $P2737 = "415_1303430322.161" 
    capture_lex $P2737
    .const 'Sub' $P2725 = "414_1303430322.161" 
    capture_lex $P2725
    .const 'Sub' $P2671 = "413_1303430322.161" 
    capture_lex $P2671
    .const 'Sub' $P2658 = "412_1303430322.161" 
    capture_lex $P2658
    .const 'Sub' $P2640 = "411_1303430322.161" 
    capture_lex $P2640
    .const 'Sub' $P2607 = "408_1303430322.161" 
    capture_lex $P2607
    .const 'Sub' $P2599 = "407_1303430322.161" 
    capture_lex $P2599
.annotate 'line', 774
    .const 'Sub' $P2599 = "407_1303430322.161" 
    newclosure $P2606, $P2599
    .lex "xblock_immediate", $P2606
.annotate 'line', 779
    .const 'Sub' $P2607 = "408_1303430322.161" 
    newclosure $P2639, $P2607
    .lex "block_immediate", $P2639
.annotate 'line', 789
    .const 'Sub' $P2640 = "411_1303430322.161" 
    newclosure $P2657, $P2640
    .lex "vivitype", $P2657
.annotate 'line', 808
    .const 'Sub' $P2658 = "412_1303430322.161" 
    newclosure $P2670, $P2658
    .lex "colonpair_str", $P2670
.annotate 'line', 1056
    .const 'Sub' $P2671 = "413_1303430322.161" 
    newclosure $P2724, $P2671
    .lex "push_block_handler", $P2724
.annotate 'line', 1613
    .const 'Sub' $P2725 = "414_1303430322.161" 
    newclosure $P2736, $P2725
    .lex "only_star_block", $P2736
.annotate 'line', 1622
    .const 'Sub' $P2737 = "415_1303430322.161" 
    newclosure $P2801, $P2737
    .lex "attach_multi_signature", $P2801
.annotate 'line', 2096
    .const 'Sub' $P2802 = "417_1303430322.161" 
    newclosure $P2813, $P2802
    .lex "control", $P2813
.annotate 'line', 2115
    .const 'Sub' $P2814 = "418_1303430322.161" 
    newclosure $P2884, $P2814
    .lex "lexical_package_lookup", $P2884
.annotate 'line', 2160
    .const 'Sub' $P2885 = "421_1303430322.161" 
    newclosure $P2889, $P2885
    .lex "is_lexical", $P2889
.annotate 'line', 2166
    .const 'Sub' $P2890 = "422_1303430322.161" 
    newclosure $P2894, $P2890
    .lex "is_package", $P2894
.annotate 'line', 2172
    .const 'Sub' $P2895 = "423_1303430322.161" 
    newclosure $P2929, $P2895
    .lex "is_scope", $P2929
.annotate 'line', 2183
    .const 'Sub' $P2930 = "425_1303430322.161" 
    newclosure $P2962, $P2930
    .lex "find_lex", $P2962
.annotate 'line', 770
    .lex "$?PACKAGE", $P2963
    .lex "$?CLASS", $P2964
.annotate 'line', 772
    new $P2965, "ResizablePMCArray"
    find_lex $P2966, "$?PACKAGE"
    get_who $P2967, $P2966
    set $P2967["@BLOCK"], $P2965
    find_lex $P2968, "xblock_immediate"
    find_lex $P2969, "block_immediate"
    find_lex $P2970, "vivitype"
.annotate 'line', 800
    find_lex $P3009, "colonpair_str"
.annotate 'line', 1049
    find_lex $P3516, "push_block_handler"
.annotate 'line', 1541
    find_lex $P4697, "only_star_block"
    find_lex $P4698, "attach_multi_signature"
.annotate 'line', 2087
    find_lex $P5804, "control"
.annotate 'line', 2109
    find_lex $P5828, "lexical_package_lookup"
    find_lex $P5829, "is_lexical"
    find_lex $P5830, "is_package"
    find_lex $P5831, "is_scope"
    find_lex $P5832, "find_lex"
.annotate 'line', 770
    .return ($P5832)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1456") :outer("406_1303430322.161")
.annotate 'line', 770
    .const 'Sub' $P2598 = "406_1303430322.161" 
    .local pmc block
    set block, $P2598
    .const 'Sub' $P5834 = "563_1303430322.161" 
    capture_lex $P5834
    $P5834()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5833"  :anon :subid("563_1303430322.161") :outer("406_1303430322.161")
.annotate 'line', 770
    nqp_get_sc_object $P5835, "1303430311.149", 3
    .local pmc type_obj
    set type_obj, $P5835
    get_how $P5836, type_obj
    .const 'Sub' $P5837 = "427_1303430322.161" 
    $P5836."add_method"(type_obj, "TOP", $P5837)
    get_how $P5838, type_obj
    .const 'Sub' $P5839 = "428_1303430322.161" 
    $P5838."add_method"(type_obj, "deflongname", $P5839)
    get_how $P5840, type_obj
    .const 'Sub' $P5841 = "429_1303430322.161" 
    $P5840."add_method"(type_obj, "comp_unit", $P5841)
    get_how $P5842, type_obj
    .const 'Sub' $P5843 = "430_1303430322.161" 
    $P5842."add_method"(type_obj, "statementlist", $P5843)
    get_how $P5844, type_obj
    .const 'Sub' $P5845 = "432_1303430322.161" 
    $P5844."add_method"(type_obj, "statement", $P5845)
    get_how $P5846, type_obj
    .const 'Sub' $P5847 = "434_1303430322.161" 
    $P5846."add_method"(type_obj, "xblock", $P5847)
    get_how $P5848, type_obj
    .const 'Sub' $P5849 = "435_1303430322.161" 
    $P5848."add_method"(type_obj, "pblock", $P5849)
    get_how $P5850, type_obj
    .const 'Sub' $P5851 = "436_1303430322.161" 
    $P5850."add_method"(type_obj, "block", $P5851)
    get_how $P5852, type_obj
    .const 'Sub' $P5853 = "437_1303430322.161" 
    $P5852."add_method"(type_obj, "blockoid", $P5853)
    get_how $P5854, type_obj
    .const 'Sub' $P5855 = "439_1303430322.161" 
    $P5854."add_method"(type_obj, "newpad", $P5855)
    get_how $P5856, type_obj
    .const 'Sub' $P5857 = "440_1303430322.161" 
    $P5856."add_method"(type_obj, "outerctx", $P5857)
    get_how $P5858, type_obj
    .const 'Sub' $P5859 = "441_1303430322.161" 
    $P5858."add_method"(type_obj, "GLOBALish", $P5859)
    get_how $P5860, type_obj
    .const 'Sub' $P5861 = "442_1303430322.161" 
    $P5860."add_method"(type_obj, "you_are_here", $P5861)
    get_how $P5862, type_obj
    .const 'Sub' $P5863 = "443_1303430322.161" 
    $P5862."add_method"(type_obj, "statement_control:sym<use>", $P5863)
    get_how $P5864, type_obj
    .const 'Sub' $P5865 = "444_1303430322.161" 
    $P5864."add_method"(type_obj, "statement_control:sym<if>", $P5865)
    get_how $P5866, type_obj
    .const 'Sub' $P5867 = "446_1303430322.161" 
    $P5866."add_method"(type_obj, "statement_control:sym<unless>", $P5867)
    get_how $P5868, type_obj
    .const 'Sub' $P5869 = "447_1303430322.161" 
    $P5868."add_method"(type_obj, "statement_control:sym<while>", $P5869)
    get_how $P5870, type_obj
    .const 'Sub' $P5871 = "448_1303430322.161" 
    $P5870."add_method"(type_obj, "statement_control:sym<repeat>", $P5871)
    get_how $P5872, type_obj
    .const 'Sub' $P5873 = "449_1303430322.161" 
    $P5872."add_method"(type_obj, "statement_control:sym<for>", $P5873)
    get_how $P5874, type_obj
    .const 'Sub' $P5875 = "450_1303430322.161" 
    $P5874."add_method"(type_obj, "statement_control:sym<CATCH>", $P5875)
    get_how $P5876, type_obj
    .const 'Sub' $P5877 = "451_1303430322.161" 
    $P5876."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5877)
    get_how $P5878, type_obj
    .const 'Sub' $P5879 = "452_1303430322.161" 
    $P5878."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5879)
    get_how $P5880, type_obj
    .const 'Sub' $P5881 = "453_1303430322.161" 
    $P5880."add_method"(type_obj, "statement_prefix:sym<try>", $P5881)
    get_how $P5882, type_obj
    .const 'Sub' $P5883 = "454_1303430322.161" 
    $P5882."add_method"(type_obj, "blorst", $P5883)
    get_how $P5884, type_obj
    .const 'Sub' $P5885 = "455_1303430322.161" 
    $P5884."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5885)
    get_how $P5886, type_obj
    .const 'Sub' $P5887 = "456_1303430322.161" 
    $P5886."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5887)
    get_how $P5888, type_obj
    .const 'Sub' $P5889 = "457_1303430322.161" 
    $P5888."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5889)
    get_how $P5890, type_obj
    .const 'Sub' $P5891 = "458_1303430322.161" 
    $P5890."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5891)
    get_how $P5892, type_obj
    .const 'Sub' $P5893 = "459_1303430322.161" 
    $P5892."add_method"(type_obj, "term:sym<fatarrow>", $P5893)
    get_how $P5894, type_obj
    .const 'Sub' $P5895 = "460_1303430322.161" 
    $P5894."add_method"(type_obj, "term:sym<colonpair>", $P5895)
    get_how $P5896, type_obj
    .const 'Sub' $P5897 = "461_1303430322.161" 
    $P5896."add_method"(type_obj, "term:sym<variable>", $P5897)
    get_how $P5898, type_obj
    .const 'Sub' $P5899 = "462_1303430322.161" 
    $P5898."add_method"(type_obj, "term:sym<package_declarator>", $P5899)
    get_how $P5900, type_obj
    .const 'Sub' $P5901 = "463_1303430322.161" 
    $P5900."add_method"(type_obj, "term:sym<scope_declarator>", $P5901)
    get_how $P5902, type_obj
    .const 'Sub' $P5903 = "464_1303430322.161" 
    $P5902."add_method"(type_obj, "term:sym<routine_declarator>", $P5903)
    get_how $P5904, type_obj
    .const 'Sub' $P5905 = "465_1303430322.161" 
    $P5904."add_method"(type_obj, "term:sym<regex_declarator>", $P5905)
    get_how $P5906, type_obj
    .const 'Sub' $P5907 = "466_1303430322.161" 
    $P5906."add_method"(type_obj, "term:sym<statement_prefix>", $P5907)
    get_how $P5908, type_obj
    .const 'Sub' $P5909 = "467_1303430322.161" 
    $P5908."add_method"(type_obj, "term:sym<lambda>", $P5909)
    get_how $P5910, type_obj
    .const 'Sub' $P5911 = "468_1303430322.161" 
    $P5910."add_method"(type_obj, "fatarrow", $P5911)
    get_how $P5912, type_obj
    .const 'Sub' $P5913 = "469_1303430322.161" 
    $P5912."add_method"(type_obj, "colonpair", $P5913)
    get_how $P5914, type_obj
    .const 'Sub' $P5915 = "470_1303430322.161" 
    $P5914."add_method"(type_obj, "variable", $P5915)
    get_how $P5916, type_obj
    .const 'Sub' $P5917 = "472_1303430322.161" 
    $P5916."add_method"(type_obj, "package_declarator:sym<module>", $P5917)
    get_how $P5918, type_obj
    .const 'Sub' $P5919 = "473_1303430322.161" 
    $P5918."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5919)
    get_how $P5920, type_obj
    .const 'Sub' $P5921 = "474_1303430322.161" 
    $P5920."add_method"(type_obj, "package_declarator:sym<class>", $P5921)
    get_how $P5922, type_obj
    .const 'Sub' $P5923 = "475_1303430322.161" 
    $P5922."add_method"(type_obj, "package_declarator:sym<grammar>", $P5923)
    get_how $P5924, type_obj
    .const 'Sub' $P5925 = "476_1303430322.161" 
    $P5924."add_method"(type_obj, "package_declarator:sym<role>", $P5925)
    get_how $P5926, type_obj
    .const 'Sub' $P5927 = "477_1303430322.161" 
    $P5926."add_method"(type_obj, "package_declarator:sym<native>", $P5927)
    get_how $P5928, type_obj
    .const 'Sub' $P5929 = "478_1303430322.161" 
    $P5928."add_method"(type_obj, "package_def", $P5929)
    get_how $P5930, type_obj
    .const 'Sub' $P5931 = "481_1303430322.161" 
    $P5930."add_method"(type_obj, "scope_declarator:sym<my>", $P5931)
    get_how $P5932, type_obj
    .const 'Sub' $P5933 = "482_1303430322.161" 
    $P5932."add_method"(type_obj, "scope_declarator:sym<our>", $P5933)
    get_how $P5934, type_obj
    .const 'Sub' $P5935 = "483_1303430322.161" 
    $P5934."add_method"(type_obj, "scope_declarator:sym<has>", $P5935)
    get_how $P5936, type_obj
    .const 'Sub' $P5937 = "484_1303430322.161" 
    $P5936."add_method"(type_obj, "scoped", $P5937)
    get_how $P5938, type_obj
    .const 'Sub' $P5939 = "485_1303430322.161" 
    $P5938."add_method"(type_obj, "declarator", $P5939)
    get_how $P5940, type_obj
    .const 'Sub' $P5941 = "486_1303430322.161" 
    $P5940."add_method"(type_obj, "multi_declarator:sym<multi>", $P5941)
    get_how $P5942, type_obj
    .const 'Sub' $P5943 = "487_1303430322.161" 
    $P5942."add_method"(type_obj, "multi_declarator:sym<proto>", $P5943)
    get_how $P5944, type_obj
    .const 'Sub' $P5945 = "488_1303430322.161" 
    $P5944."add_method"(type_obj, "multi_declarator:sym<null>", $P5945)
    get_how $P5946, type_obj
    .const 'Sub' $P5947 = "489_1303430322.161" 
    $P5946."add_method"(type_obj, "variable_declarator", $P5947)
    get_how $P5948, type_obj
    .const 'Sub' $P5949 = "492_1303430322.161" 
    $P5948."add_method"(type_obj, "routine_declarator:sym<sub>", $P5949)
    get_how $P5950, type_obj
    .const 'Sub' $P5951 = "493_1303430322.161" 
    $P5950."add_method"(type_obj, "routine_declarator:sym<method>", $P5951)
    get_how $P5952, type_obj
    .const 'Sub' $P5953 = "494_1303430322.161" 
    $P5952."add_method"(type_obj, "routine_def", $P5953)
    get_how $P5954, type_obj
    .const 'Sub' $P5955 = "501_1303430322.161" 
    $P5954."add_method"(type_obj, "method_def", $P5955)
    get_how $P5956, type_obj
    .const 'Sub' $P5957 = "504_1303430322.161" 
    $P5956."add_method"(type_obj, "signature", $P5957)
    get_how $P5958, type_obj
    .const 'Sub' $P5959 = "507_1303430322.161" 
    $P5958."add_method"(type_obj, "parameter", $P5959)
    get_how $P5960, type_obj
    .const 'Sub' $P5961 = "508_1303430322.161" 
    $P5960."add_method"(type_obj, "param_var", $P5961)
    get_how $P5962, type_obj
    .const 'Sub' $P5963 = "509_1303430322.161" 
    $P5962."add_method"(type_obj, "named_param", $P5963)
    get_how $P5964, type_obj
    .const 'Sub' $P5965 = "510_1303430322.161" 
    $P5964."add_method"(type_obj, "typename", $P5965)
    get_how $P5966, type_obj
    .const 'Sub' $P5967 = "511_1303430322.161" 
    $P5966."add_method"(type_obj, "trait", $P5967)
    get_how $P5968, type_obj
    .const 'Sub' $P5969 = "512_1303430322.161" 
    $P5968."add_method"(type_obj, "trait_mod:sym<is>", $P5969)
    get_how $P5970, type_obj
    .const 'Sub' $P5971 = "514_1303430322.161" 
    $P5970."add_method"(type_obj, "regex_declarator", $P5971)
    get_how $P5972, type_obj
    .const 'Sub' $P5973 = "518_1303430322.161" 
    $P5972."add_method"(type_obj, "dotty", $P5973)
    get_how $P5974, type_obj
    .const 'Sub' $P5975 = "519_1303430322.161" 
    $P5974."add_method"(type_obj, "term:sym<self>", $P5975)
    get_how $P5976, type_obj
    .const 'Sub' $P5977 = "520_1303430322.161" 
    $P5976."add_method"(type_obj, "term:sym<identifier>", $P5977)
    get_how $P5978, type_obj
    .const 'Sub' $P5979 = "521_1303430322.161" 
    $P5978."add_method"(type_obj, "term:sym<name>", $P5979)
    get_how $P5980, type_obj
    .const 'Sub' $P5981 = "523_1303430322.161" 
    $P5980."add_method"(type_obj, "term:sym<pir::op>", $P5981)
    get_how $P5982, type_obj
    .const 'Sub' $P5983 = "524_1303430322.161" 
    $P5982."add_method"(type_obj, "term:sym<onlystar>", $P5983)
    get_how $P5984, type_obj
    .const 'Sub' $P5985 = "525_1303430322.161" 
    $P5984."add_method"(type_obj, "args", $P5985)
    get_how $P5986, type_obj
    .const 'Sub' $P5987 = "526_1303430322.161" 
    $P5986."add_method"(type_obj, "arglist", $P5987)
    get_how $P5988, type_obj
    .const 'Sub' $P5989 = "529_1303430322.161" 
    $P5988."add_method"(type_obj, "term:sym<multi_declarator>", $P5989)
    get_how $P5990, type_obj
    .const 'Sub' $P5991 = "530_1303430322.161" 
    $P5990."add_method"(type_obj, "term:sym<value>", $P5991)
    get_how $P5992, type_obj
    .const 'Sub' $P5993 = "531_1303430322.161" 
    $P5992."add_method"(type_obj, "circumfix:sym<( )>", $P5993)
    get_how $P5994, type_obj
    .const 'Sub' $P5995 = "532_1303430322.161" 
    $P5994."add_method"(type_obj, "circumfix:sym<[ ]>", $P5995)
    get_how $P5996, type_obj
    .const 'Sub' $P5997 = "533_1303430322.161" 
    $P5996."add_method"(type_obj, "circumfix:sym<ang>", $P5997)
    get_how $P5998, type_obj
    .const 'Sub' $P5999 = "534_1303430322.161" 
    $P5998."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5999)
    get_how $P6000, type_obj
    .const 'Sub' $P6001 = "535_1303430322.161" 
    $P6000."add_method"(type_obj, "circumfix:sym<{ }>", $P6001)
    get_how $P6002, type_obj
    .const 'Sub' $P6003 = "537_1303430322.161" 
    $P6002."add_method"(type_obj, "circumfix:sym<sigil>", $P6003)
    get_how $P6004, type_obj
    .const 'Sub' $P6005 = "538_1303430322.161" 
    $P6004."add_method"(type_obj, "semilist", $P6005)
    get_how $P6006, type_obj
    .const 'Sub' $P6007 = "539_1303430322.161" 
    $P6006."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P6007)
    get_how $P6008, type_obj
    .const 'Sub' $P6009 = "540_1303430322.161" 
    $P6008."add_method"(type_obj, "postcircumfix:sym<{ }>", $P6009)
    get_how $P6010, type_obj
    .const 'Sub' $P6011 = "541_1303430322.161" 
    $P6010."add_method"(type_obj, "postcircumfix:sym<ang>", $P6011)
    get_how $P6012, type_obj
    .const 'Sub' $P6013 = "542_1303430322.161" 
    $P6012."add_method"(type_obj, "postcircumfix:sym<( )>", $P6013)
    get_how $P6014, type_obj
    .const 'Sub' $P6015 = "543_1303430322.161" 
    $P6014."add_method"(type_obj, "value", $P6015)
    get_how $P6016, type_obj
    .const 'Sub' $P6017 = "544_1303430322.161" 
    $P6016."add_method"(type_obj, "number", $P6017)
    get_how $P6018, type_obj
    .const 'Sub' $P6019 = "545_1303430322.161" 
    $P6018."add_method"(type_obj, "quote:sym<apos>", $P6019)
    get_how $P6020, type_obj
    .const 'Sub' $P6021 = "546_1303430322.161" 
    $P6020."add_method"(type_obj, "quote:sym<dblq>", $P6021)
    get_how $P6022, type_obj
    .const 'Sub' $P6023 = "547_1303430322.161" 
    $P6022."add_method"(type_obj, "quote:sym<qq>", $P6023)
    get_how $P6024, type_obj
    .const 'Sub' $P6025 = "548_1303430322.161" 
    $P6024."add_method"(type_obj, "quote:sym<q>", $P6025)
    get_how $P6026, type_obj
    .const 'Sub' $P6027 = "549_1303430322.161" 
    $P6026."add_method"(type_obj, "quote:sym<Q>", $P6027)
    get_how $P6028, type_obj
    .const 'Sub' $P6029 = "550_1303430322.161" 
    $P6028."add_method"(type_obj, "quote:sym<Q:PIR>", $P6029)
    get_how $P6030, type_obj
    .const 'Sub' $P6031 = "551_1303430322.161" 
    $P6030."add_method"(type_obj, "quote:sym</ />", $P6031)
    get_how $P6032, type_obj
    .const 'Sub' $P6033 = "552_1303430322.161" 
    $P6032."add_method"(type_obj, "quote_escape:sym<$>", $P6033)
    get_how $P6034, type_obj
    .const 'Sub' $P6035 = "553_1303430322.161" 
    $P6034."add_method"(type_obj, "quote_escape:sym<{ }>", $P6035)
    get_how $P6036, type_obj
    .const 'Sub' $P6037 = "554_1303430322.161" 
    $P6036."add_method"(type_obj, "quote_escape:sym<esc>", $P6037)
    get_how $P6038, type_obj
    .const 'Sub' $P6039 = "555_1303430322.161" 
    $P6038."add_method"(type_obj, "postfix:sym<.>", $P6039)
    get_how $P6040, type_obj
    .const 'Sub' $P6041 = "556_1303430322.161" 
    $P6040."add_method"(type_obj, "postfix:sym<++>", $P6041)
    get_how $P6042, type_obj
    .const 'Sub' $P6043 = "557_1303430322.161" 
    $P6042."add_method"(type_obj, "postfix:sym<-->", $P6043)
    get_how $P6044, type_obj
    .const 'Sub' $P6045 = "558_1303430322.161" 
    $P6044."add_method"(type_obj, "prefix:sym<make>", $P6045)
    get_how $P6046, type_obj
    .const 'Sub' $P6047 = "559_1303430322.161" 
    $P6046."add_method"(type_obj, "term:sym<next>", $P6047)
    get_how $P6048, type_obj
    .const 'Sub' $P6049 = "560_1303430322.161" 
    $P6048."add_method"(type_obj, "term:sym<last>", $P6049)
    get_how $P6050, type_obj
    .const 'Sub' $P6051 = "561_1303430322.161" 
    $P6050."add_method"(type_obj, "term:sym<redo>", $P6051)
    get_how $P6052, type_obj
    .const 'Sub' $P6053 = "562_1303430322.161" 
    $P6052."add_method"(type_obj, "infix:sym<~~>", $P6053)
    get_how $P6054, type_obj
    get_hll_global $P6055, ["HLL"], "Actions"
    $P6054."add_parent"(type_obj, $P6055)
    get_how $P6056, type_obj
    $P6057 = $P6056."compose"(type_obj)
    .return ($P6057)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2600
.annotate 'line', 774
    .lex "$xblock", param_2600
.annotate 'line', 775
    find_lex $P2601, "$xblock"
    unless_null $P2601, vivify_1457
    $P2601 = root_new ['parrot';'ResizablePMCArray']
  vivify_1457:
    set $P2602, $P2601[1]
    unless_null $P2602, vivify_1458
    new $P2602, "Undef"
  vivify_1458:
    $P2603 = "block_immediate"($P2602)
    find_lex $P2604, "$xblock"
    unless_null $P2604, vivify_1459
    $P2604 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2604
  vivify_1459:
    set $P2604[1], $P2603
    find_lex $P2605, "$xblock"
    unless_null $P2605, vivify_1460
    new $P2605, "Undef"
  vivify_1460:
.annotate 'line', 774
    .return ($P2605)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2608
.annotate 'line', 779
    .const 'Sub' $P2618 = "409_1303430322.161" 
    capture_lex $P2618
    .lex "$block", param_2608
.annotate 'line', 780
    find_lex $P2609, "$block"
    unless_null $P2609, vivify_1461
    new $P2609, "Undef"
  vivify_1461:
    $P2609."blocktype"("immediate")
.annotate 'line', 781
    find_lex $P2613, "$block"
    unless_null $P2613, vivify_1462
    new $P2613, "Undef"
  vivify_1462:
    $P2614 = $P2613."symtable"()
    unless $P2614, unless_2612
    set $P2611, $P2614
    goto unless_2612_end
  unless_2612:
    find_lex $P2615, "$block"
    unless_null $P2615, vivify_1463
    new $P2615, "Undef"
  vivify_1463:
    $P2616 = $P2615."handlers"()
    set $P2611, $P2616
  unless_2612_end:
    if $P2611, unless_2610_end
    .const 'Sub' $P2618 = "409_1303430322.161" 
    capture_lex $P2618
    $P2618()
  unless_2610_end:
    find_lex $P2638, "$block"
    unless_null $P2638, vivify_1470
    new $P2638, "Undef"
  vivify_1470:
.annotate 'line', 779
    .return ($P2638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2617"  :anon :subid("409_1303430322.161") :outer("408_1303430322.161")
.annotate 'line', 781
    .const 'Sub' $P2629 = "410_1303430322.161" 
    capture_lex $P2629
.annotate 'line', 782
    new $P2619, "Undef"
    .lex "$stmts", $P2619
    get_hll_global $P2620, ["PAST"], "Stmts"
    find_lex $P2621, "$block"
    unless_null $P2621, vivify_1464
    new $P2621, "Undef"
  vivify_1464:
    $P2622 = $P2620."new"($P2621 :named("node"))
    store_lex "$stmts", $P2622
.annotate 'line', 783
    find_lex $P2624, "$block"
    unless_null $P2624, vivify_1465
    new $P2624, "Undef"
  vivify_1465:
    $P2625 = $P2624."list"()
    defined $I2626, $P2625
    unless $I2626, for_undef_1466
    iter $P2623, $P2625
    new $P2635, 'ExceptionHandler'
    set_label $P2635, loop2634_handler
    $P2635."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2635
  loop2634_test:
    unless $P2623, loop2634_done
    shift $P2627, $P2623
  loop2634_redo:
    .const 'Sub' $P2629 = "410_1303430322.161" 
    capture_lex $P2629
    $P2629($P2627)
  loop2634_next:
    goto loop2634_test
  loop2634_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2636, exception, 'type'
    eq $P2636, .CONTROL_LOOP_NEXT, loop2634_next
    eq $P2636, .CONTROL_LOOP_REDO, loop2634_redo
  loop2634_done:
    pop_eh 
  for_undef_1466:
.annotate 'line', 784
    find_lex $P2637, "$stmts"
    unless_null $P2637, vivify_1469
    new $P2637, "Undef"
  vivify_1469:
    store_lex "$block", $P2637
.annotate 'line', 781
    .return ($P2637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2628"  :anon :subid("410_1303430322.161") :outer("409_1303430322.161")
    .param pmc param_2630
.annotate 'line', 783
    .lex "$_", param_2630
    find_lex $P2631, "$stmts"
    unless_null $P2631, vivify_1467
    new $P2631, "Undef"
  vivify_1467:
    find_lex $P2632, "$_"
    unless_null $P2632, vivify_1468
    new $P2632, "Undef"
  vivify_1468:
    $P2633 = $P2631."push"($P2632)
    .return ($P2633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2641
.annotate 'line', 789
    .lex "$sigil", param_2641
.annotate 'line', 790
    find_lex $P2644, "$sigil"
    unless_null $P2644, vivify_1471
    new $P2644, "Undef"
  vivify_1471:
    set $S2645, $P2644
    iseq $I2646, $S2645, "%"
    if $I2646, if_2643
.annotate 'line', 792
    find_lex $P2651, "$sigil"
    unless_null $P2651, vivify_1472
    new $P2651, "Undef"
  vivify_1472:
    set $S2652, $P2651
    iseq $I2653, $S2652, "@"
    if $I2653, if_2650
    new $P2656, "String"
    assign $P2656, "Undef"
    set $P2649, $P2656
    goto if_2650_end
  if_2650:
.annotate 'line', 793
    get_hll_global $P2654, ["PAST"], "Op"
    $P2655 = $P2654."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2649, $P2655
  if_2650_end:
    set $P2642, $P2649
.annotate 'line', 790
    goto if_2643_end
  if_2643:
.annotate 'line', 791
    get_hll_global $P2647, ["PAST"], "Op"
    $P2648 = $P2647."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2642, $P2648
  if_2643_end:
.annotate 'line', 789
    .return ($P2642)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2659
.annotate 'line', 808
    .lex "$ast", param_2659
.annotate 'line', 809
    get_hll_global $P2662, ["PAST"], "Op"
    find_lex $P2663, "$ast"
    unless_null $P2663, vivify_1473
    new $P2663, "Undef"
  vivify_1473:
    $P2664 = $P2662."ACCEPTS"($P2663)
    if $P2664, if_2661
.annotate 'line', 811
    find_lex $P2668, "$ast"
    unless_null $P2668, vivify_1474
    new $P2668, "Undef"
  vivify_1474:
    $P2669 = $P2668."value"()
    set $P2660, $P2669
.annotate 'line', 809
    goto if_2661_end
  if_2661:
.annotate 'line', 810
    find_lex $P2665, "$ast"
    unless_null $P2665, vivify_1475
    new $P2665, "Undef"
  vivify_1475:
    $P2666 = $P2665."list"()
    join $S2667, " ", $P2666
    new $P2660, 'String'
    set $P2660, $S2667
  if_2661_end:
.annotate 'line', 808
    .return ($P2660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("413_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2672
    .param pmc param_2673
.annotate 'line', 1056
    .lex "$/", param_2672
    .lex "$block", param_2673
.annotate 'line', 1057
    find_lex $P2675, "$?PACKAGE"
    get_who $P2676, $P2675
    set $P2677, $P2676["@BLOCK"]
    unless_null $P2677, vivify_1476
    $P2677 = root_new ['parrot';'ResizablePMCArray']
  vivify_1476:
    set $P2678, $P2677[0]
    unless_null $P2678, vivify_1477
    new $P2678, "Undef"
  vivify_1477:
    $P2679 = $P2678."handlers"()
    if $P2679, unless_2674_end
.annotate 'line', 1058
    find_lex $P2680, "$?PACKAGE"
    get_who $P2681, $P2680
    set $P2682, $P2681["@BLOCK"]
    unless_null $P2682, vivify_1478
    $P2682 = root_new ['parrot';'ResizablePMCArray']
  vivify_1478:
    set $P2683, $P2682[0]
    unless_null $P2683, vivify_1479
    new $P2683, "Undef"
  vivify_1479:
    new $P2684, "ResizablePMCArray"
    $P2683."handlers"($P2684)
  unless_2674_end:
.annotate 'line', 1060
    find_lex $P2686, "$block"
    unless_null $P2686, vivify_1480
    new $P2686, "Undef"
  vivify_1480:
    $P2687 = $P2686."arity"()
    if $P2687, unless_2685_end
.annotate 'line', 1061
    find_lex $P2688, "$block"
    unless_null $P2688, vivify_1481
    new $P2688, "Undef"
  vivify_1481:
.annotate 'line', 1062
    get_hll_global $P2689, ["PAST"], "Op"
.annotate 'line', 1063
    get_hll_global $P2690, ["PAST"], "Var"
    $P2691 = $P2690."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1064
    get_hll_global $P2692, ["PAST"], "Var"
    $P2693 = $P2692."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2694 = $P2689."new"($P2691, $P2693, "bind" :named("pasttype"))
.annotate 'line', 1062
    $P2688."unshift"($P2694)
.annotate 'line', 1067
    find_lex $P2695, "$block"
    unless_null $P2695, vivify_1482
    new $P2695, "Undef"
  vivify_1482:
    get_hll_global $P2696, ["PAST"], "Var"
    $P2697 = $P2696."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2695."unshift"($P2697)
.annotate 'line', 1068
    find_lex $P2698, "$block"
    unless_null $P2698, vivify_1483
    new $P2698, "Undef"
  vivify_1483:
    $P2698."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1069
    find_lex $P2699, "$block"
    unless_null $P2699, vivify_1484
    new $P2699, "Undef"
  vivify_1484:
    $P2699."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1070
    find_lex $P2700, "$block"
    unless_null $P2700, vivify_1485
    new $P2700, "Undef"
  vivify_1485:
    $P2700."arity"(1)
  unless_2685_end:
.annotate 'line', 1072
    find_lex $P2701, "$block"
    unless_null $P2701, vivify_1486
    new $P2701, "Undef"
  vivify_1486:
    $P2701."blocktype"("declaration")
.annotate 'line', 1073
    find_lex $P2702, "$?PACKAGE"
    get_who $P2703, $P2702
    set $P2704, $P2703["@BLOCK"]
    unless_null $P2704, vivify_1487
    $P2704 = root_new ['parrot';'ResizablePMCArray']
  vivify_1487:
    set $P2705, $P2704[0]
    unless_null $P2705, vivify_1488
    new $P2705, "Undef"
  vivify_1488:
    $P2706 = $P2705."handlers"()
.annotate 'line', 1074
    get_hll_global $P2707, ["PAST"], "Control"
    find_lex $P2708, "$/"
    unless_null $P2708, vivify_1489
    new $P2708, "Undef"
  vivify_1489:
.annotate 'line', 1076
    get_hll_global $P2709, ["PAST"], "Stmts"
.annotate 'line', 1077
    get_hll_global $P2710, ["PAST"], "Op"
    find_lex $P2711, "$block"
    unless_null $P2711, vivify_1490
    new $P2711, "Undef"
  vivify_1490:
.annotate 'line', 1079
    get_hll_global $P2712, ["PAST"], "Var"
    $P2713 = $P2712."new"("register" :named("scope"), "exception" :named("name"))
    $P2714 = $P2710."new"($P2711, $P2713, "call" :named("pasttype"))
.annotate 'line', 1081
    get_hll_global $P2715, ["PAST"], "Op"
.annotate 'line', 1082
    get_hll_global $P2716, ["PAST"], "Var"
.annotate 'line', 1083
    get_hll_global $P2717, ["PAST"], "Var"
    $P2718 = $P2717."new"("register" :named("scope"), "exception" :named("name"))
    $P2719 = $P2716."new"($P2718, "handled", "keyed" :named("scope"))
.annotate 'line', 1082
    $P2720 = $P2715."new"($P2719, 1, "bind" :named("pasttype"))
.annotate 'line', 1081
    $P2721 = $P2709."new"($P2714, $P2720)
.annotate 'line', 1076
    $P2722 = $P2707."new"($P2721, $P2708 :named("node"))
.annotate 'line', 1074
    $P2723 = $P2706."unshift"($P2722)
.annotate 'line', 1056
    .return ($P2723)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("414_1303430322.161") :outer("406_1303430322.161")
.annotate 'line', 1614
    new $P2726, "Undef"
    .lex "$past", $P2726
    find_lex $P2727, "$?PACKAGE"
    get_who $P2728, $P2727
    set $P2729, $P2728["@BLOCK"]
    unless_null $P2729, vivify_1491
    $P2729 = root_new ['parrot';'ResizablePMCArray']
  vivify_1491:
    $P2730 = $P2729."shift"()
    store_lex "$past", $P2730
.annotate 'line', 1615
    find_lex $P2731, "$past"
    unless_null $P2731, vivify_1492
    new $P2731, "Undef"
  vivify_1492:
    $P2731."closure"(1)
.annotate 'line', 1616
    find_lex $P2732, "$past"
    unless_null $P2732, vivify_1493
    new $P2732, "Undef"
  vivify_1493:
    get_hll_global $P2733, ["PAST"], "Op"
    $P2734 = $P2733."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2732."push"($P2734)
    find_lex $P2735, "$past"
    unless_null $P2735, vivify_1494
    new $P2735, "Undef"
  vivify_1494:
.annotate 'line', 1613
    .return ($P2735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("415_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2738
.annotate 'line', 1622
    .const 'Sub' $P2752 = "416_1303430322.161" 
    capture_lex $P2752
    .lex "$routine", param_2738
.annotate 'line', 1626
    new $P2739, "Undef"
    .lex "$types", $P2739
.annotate 'line', 1627
    new $P2740, "Undef"
    .lex "$definednesses", $P2740
.annotate 'line', 1626
    get_hll_global $P2741, ["PAST"], "Op"
    $P2742 = $P2741."new"("list" :named("pasttype"))
    store_lex "$types", $P2742
.annotate 'line', 1627
    get_hll_global $P2743, ["PAST"], "Op"
    $P2744 = $P2743."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2744
.annotate 'line', 1628
    find_lex $P2746, "$routine"
    unless_null $P2746, vivify_1495
    $P2746 = root_new ['parrot';'ResizablePMCArray']
  vivify_1495:
    set $P2747, $P2746[0]
    unless_null $P2747, vivify_1496
    new $P2747, "Undef"
  vivify_1496:
    $P2748 = $P2747."list"()
    defined $I2749, $P2748
    unless $I2749, for_undef_1497
    iter $P2745, $P2748
    new $P2790, 'ExceptionHandler'
    set_label $P2790, loop2789_handler
    $P2790."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2790
  loop2789_test:
    unless $P2745, loop2789_done
    shift $P2750, $P2745
  loop2789_redo:
    .const 'Sub' $P2752 = "416_1303430322.161" 
    capture_lex $P2752
    $P2752($P2750)
  loop2789_next:
    goto loop2789_test
  loop2789_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2791, exception, 'type'
    eq $P2791, .CONTROL_LOOP_NEXT, loop2789_next
    eq $P2791, .CONTROL_LOOP_REDO, loop2789_redo
  loop2789_done:
    pop_eh 
  for_undef_1497:
.annotate 'line', 1635
    find_lex $P2792, "$routine"
    unless_null $P2792, vivify_1507
    new $P2792, "Undef"
  vivify_1507:
    $P2793 = $P2792."loadinit"()
    get_hll_global $P2794, ["PAST"], "Op"
.annotate 'line', 1636
    get_hll_global $P2795, ["PAST"], "Var"
    $P2796 = $P2795."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2797, "$types"
    unless_null $P2797, vivify_1508
    new $P2797, "Undef"
  vivify_1508:
    find_lex $P2798, "$definednesses"
    unless_null $P2798, vivify_1509
    new $P2798, "Undef"
  vivify_1509:
    $P2799 = $P2794."new"($P2796, $P2797, $P2798, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1635
    $P2800 = $P2793."push"($P2799)
.annotate 'line', 1622
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2751"  :anon :subid("416_1303430322.161") :outer("415_1303430322.161")
    .param pmc param_2753
.annotate 'line', 1628
    .lex "$_", param_2753
.annotate 'line', 1629
    get_hll_global $P2758, ["PAST"], "Var"
    find_lex $P2759, "$_"
    unless_null $P2759, vivify_1498
    new $P2759, "Undef"
  vivify_1498:
    $P2760 = $P2758."ACCEPTS"($P2759)
    if $P2760, if_2757
    set $P2756, $P2760
    goto if_2757_end
  if_2757:
    find_lex $P2761, "$_"
    unless_null $P2761, vivify_1499
    new $P2761, "Undef"
  vivify_1499:
    $S2762 = $P2761."scope"()
    iseq $I2763, $S2762, "parameter"
    new $P2756, 'Integer'
    set $P2756, $I2763
  if_2757_end:
    if $P2756, if_2755
    set $P2754, $P2756
    goto if_2755_end
  if_2755:
.annotate 'line', 1630
    find_lex $P2764, "$types"
    unless_null $P2764, vivify_1500
    new $P2764, "Undef"
  vivify_1500:
    find_lex $P2766, "$_"
    unless_null $P2766, vivify_1501
    new $P2766, "Undef"
  vivify_1501:
    $P2767 = $P2766."multitype"()
    set $P2765, $P2767
    defined $I2769, $P2765
    if $I2769, default_2768
    get_hll_global $P2770, ["PAST"], "Op"
    $P2771 = $P2770."new"("null P" :named("pirop"))
    set $P2765, $P2771
  default_2768:
    $P2764."push"($P2765)
.annotate 'line', 1631
    find_lex $P2772, "$definednesses"
    unless_null $P2772, vivify_1502
    new $P2772, "Undef"
  vivify_1502:
    find_lex $P2775, "$_"
    unless_null $P2775, vivify_1503
    $P2775 = root_new ['parrot';'Hash']
  vivify_1503:
    set $P2776, $P2775["definedness"]
    unless_null $P2776, vivify_1504
    new $P2776, "Undef"
  vivify_1504:
    set $S2777, $P2776
    iseq $I2778, $S2777, "D"
    if $I2778, if_2774
.annotate 'line', 1632
    find_lex $P2782, "$_"
    unless_null $P2782, vivify_1505
    $P2782 = root_new ['parrot';'Hash']
  vivify_1505:
    set $P2783, $P2782["definedness"]
    unless_null $P2783, vivify_1506
    new $P2783, "Undef"
  vivify_1506:
    set $S2784, $P2783
    iseq $I2785, $S2784, "U"
    if $I2785, if_2781
    new $P2787, "Integer"
    assign $P2787, 0
    set $P2780, $P2787
    goto if_2781_end
  if_2781:
    new $P2786, "Integer"
    assign $P2786, 2
    set $P2780, $P2786
  if_2781_end:
    set $P2773, $P2780
.annotate 'line', 1631
    goto if_2774_end
  if_2774:
    new $P2779, "Integer"
    assign $P2779, 1
    set $P2773, $P2779
  if_2774_end:
    $P2788 = $P2772."push"($P2773)
.annotate 'line', 1629
    set $P2754, $P2788
  if_2755_end:
.annotate 'line', 1628
    .return ($P2754)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("417_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2803
    .param pmc param_2804
.annotate 'line', 2096
    .lex "$/", param_2803
    .lex "$type", param_2804
.annotate 'line', 2097
    find_lex $P2805, "$/"
    get_hll_global $P2806, ["PAST"], "Op"
    find_lex $P2807, "$/"
    unless_null $P2807, vivify_1510
    new $P2807, "Undef"
  vivify_1510:
.annotate 'line', 2101
    get_hll_global $P2808, ["PAST"], "Val"
    find_lex $P2809, "$type"
    unless_null $P2809, vivify_1511
    new $P2809, "Undef"
  vivify_1511:
    $P2810 = $P2808."new"($P2809 :named("value"), "!except_types" :named("returns"))
    $P2811 = $P2806."new"(0, $P2810, $P2807 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2097
    $P2812 = $P2805."!make"($P2811)
.annotate 'line', 2096
    .return ($P2812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("418_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'line', 2115
    .const 'Sub' $P2847 = "419_1303430322.161" 
    capture_lex $P2847
    new $P2816, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2816, control_2815
    push_eh $P2816
    .lex "@name", param_2817
    .lex "$/", param_2818
.annotate 'line', 2121
    new $P2819, "Undef"
    .lex "$final_name", $P2819
.annotate 'line', 2122
    new $P2820, "Undef"
    .lex "$lookup", $P2820
.annotate 'line', 2117
    find_lex $P2822, "@name"
    unless_null $P2822, vivify_1512
    $P2822 = root_new ['parrot';'ResizablePMCArray']
  vivify_1512:
    set $N2823, $P2822
    iseq $I2824, $N2823, 0.0
    unless $I2824, if_2821_end
    find_lex $P2825, "$/"
    unless_null $P2825, vivify_1513
    new $P2825, "Undef"
  vivify_1513:
    $P2826 = $P2825."CURSOR"()
    $P2826."panic"("Cannot compile empty name")
  if_2821_end:
.annotate 'line', 2121
    find_lex $P2827, "@name"
    unless_null $P2827, vivify_1514
    $P2827 = root_new ['parrot';'ResizablePMCArray']
  vivify_1514:
    $P2828 = $P2827."pop"()
    store_lex "$final_name", $P2828
.annotate 'line', 2122
    get_hll_global $P2829, ["PAST"], "Var"
    find_lex $P2830, "$final_name"
    unless_null $P2830, vivify_1515
    new $P2830, "Undef"
  vivify_1515:
    set $S2831, $P2830
    $P2832 = $P2829."new"($S2831, "keyed" :named("scope"))
    store_lex "$lookup", $P2832
.annotate 'line', 2126
    find_lex $P2834, "@name"
    unless_null $P2834, vivify_1516
    $P2834 = root_new ['parrot';'ResizablePMCArray']
  vivify_1516:
    set $N2835, $P2834
    iseq $I2836, $N2835, 0.0
    if $I2836, if_2833
.annotate 'line', 2135
    find_lex $P2843, "@name"
    unless_null $P2843, vivify_1517
    $P2843 = root_new ['parrot';'ResizablePMCArray']
  vivify_1517:
    set $P2844, $P2843[0]
    unless_null $P2844, vivify_1518
    new $P2844, "Undef"
  vivify_1518:
    $P2845 = "is_lexical"($P2844)
    if $P2845, if_2842
.annotate 'line', 2149
    find_lex $P2873, "$lookup"
    unless_null $P2873, vivify_1519
    new $P2873, "Undef"
  vivify_1519:
    get_hll_global $P2874, ["PAST"], "Op"
.annotate 'line', 2151
    get_hll_global $P2875, ["PAST"], "Var"
    find_lex $P2876, "@name"
    unless_null $P2876, vivify_1520
    $P2876 = root_new ['parrot';'ResizablePMCArray']
  vivify_1520:
    $P2877 = $P2876."pop"()
    find_lex $P2878, "@name"
    unless_null $P2878, vivify_1521
    $P2878 = root_new ['parrot';'ResizablePMCArray']
  vivify_1521:
    $P2879 = $P2875."new"($P2877 :named("name"), $P2878 :named("namespace"), "package" :named("scope"))
    $P2880 = $P2874."new"($P2879, "get_who PP" :named("pirop"))
.annotate 'line', 2149
    $P2873."unshift"($P2880)
.annotate 'line', 2144
    goto if_2842_end
  if_2842:
.annotate 'line', 2135
    .const 'Sub' $P2847 = "419_1303430322.161" 
    capture_lex $P2847
    $P2847()
  if_2842_end:
    goto if_2833_end
  if_2833:
.annotate 'line', 2127
    find_lex $P2837, "$lookup"
    unless_null $P2837, vivify_1529
    new $P2837, "Undef"
  vivify_1529:
    get_hll_global $P2838, ["PAST"], "Op"
.annotate 'line', 2129
    get_hll_global $P2839, ["PAST"], "Var"
    $P2840 = $P2839."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2841 = $P2838."new"($P2840, "get_who PP" :named("pirop"))
.annotate 'line', 2127
    $P2837."unshift"($P2841)
  if_2833_end:
.annotate 'line', 2155
    new $P2881, "Exception"
    set $P2881['type'], .CONTROL_RETURN
    find_lex $P2882, "$lookup"
    unless_null $P2882, vivify_1530
    new $P2882, "Undef"
  vivify_1530:
    setattribute $P2881, 'payload', $P2882
    throw $P2881
.annotate 'line', 2115
    .return ()
  control_2815:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2883, exception, "payload"
    .return ($P2883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2846"  :anon :subid("419_1303430322.161") :outer("418_1303430322.161")
.annotate 'line', 2135
    .const 'Sub' $P2858 = "420_1303430322.161" 
    capture_lex $P2858
.annotate 'line', 2136
    new $P2848, "Undef"
    .lex "$path", $P2848
    get_hll_global $P2849, ["PAST"], "Var"
    find_lex $P2850, "@name"
    unless_null $P2850, vivify_1522
    $P2850 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    $P2851 = $P2850."shift"()
    $P2852 = $P2849."new"($P2851 :named("name"), "lexical" :named("scope"))
    store_lex "$path", $P2852
.annotate 'line', 2137
    find_lex $P2854, "@name"
    unless_null $P2854, vivify_1523
    $P2854 = root_new ['parrot';'ResizablePMCArray']
  vivify_1523:
    defined $I2855, $P2854
    unless $I2855, for_undef_1524
    iter $P2853, $P2854
    new $P2866, 'ExceptionHandler'
    set_label $P2866, loop2865_handler
    $P2866."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2866
  loop2865_test:
    unless $P2853, loop2865_done
    shift $P2856, $P2853
  loop2865_redo:
    .const 'Sub' $P2858 = "420_1303430322.161" 
    capture_lex $P2858
    $P2858($P2856)
  loop2865_next:
    goto loop2865_test
  loop2865_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2867, exception, 'type'
    eq $P2867, .CONTROL_LOOP_NEXT, loop2865_next
    eq $P2867, .CONTROL_LOOP_REDO, loop2865_redo
  loop2865_done:
    pop_eh 
  for_undef_1524:
.annotate 'line', 2142
    find_lex $P2868, "$lookup"
    unless_null $P2868, vivify_1527
    new $P2868, "Undef"
  vivify_1527:
    get_hll_global $P2869, ["PAST"], "Op"
    find_lex $P2870, "$path"
    unless_null $P2870, vivify_1528
    new $P2870, "Undef"
  vivify_1528:
    $P2871 = $P2869."new"($P2870, "get_who PP" :named("pirop"))
    $P2872 = $P2868."unshift"($P2871)
.annotate 'line', 2135
    .return ($P2872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2857"  :anon :subid("420_1303430322.161") :outer("419_1303430322.161")
    .param pmc param_2859
.annotate 'line', 2137
    .lex "$_", param_2859
.annotate 'line', 2138
    get_hll_global $P2860, ["PAST"], "Op"
    find_lex $P2861, "$path"
    unless_null $P2861, vivify_1525
    new $P2861, "Undef"
  vivify_1525:
.annotate 'line', 2140
    find_lex $P2862, "$_"
    unless_null $P2862, vivify_1526
    new $P2862, "Undef"
  vivify_1526:
    set $S2863, $P2862
    $P2864 = $P2860."new"($P2861, $S2863, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2138
    store_lex "$path", $P2864
.annotate 'line', 2137
    .return ($P2864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("421_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2886
.annotate 'line', 2160
    .lex "$name", param_2886
.annotate 'line', 2161
    find_lex $P2887, "$name"
    unless_null $P2887, vivify_1531
    new $P2887, "Undef"
  vivify_1531:
    $P2888 = "is_scope"($P2887, "lexical")
.annotate 'line', 2160
    .return ($P2888)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("422_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2891
.annotate 'line', 2166
    .lex "$name", param_2891
.annotate 'line', 2167
    find_lex $P2892, "$name"
    unless_null $P2892, vivify_1532
    new $P2892, "Undef"
  vivify_1532:
    $P2893 = "is_scope"($P2892, "package")
.annotate 'line', 2166
    .return ($P2893)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("423_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2898
    .param pmc param_2899
.annotate 'line', 2172
    .const 'Sub' $P2907 = "424_1303430322.161" 
    capture_lex $P2907
    new $P2897, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2897, control_2896
    push_eh $P2897
    .lex "$name", param_2898
    .lex "$wanted_scope", param_2899
.annotate 'line', 2173
    find_lex $P2901, "$?PACKAGE"
    get_who $P2902, $P2901
    set $P2903, $P2902["@BLOCK"]
    unless_null $P2903, vivify_1533
    $P2903 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    defined $I2904, $P2903
    unless $I2904, for_undef_1534
    iter $P2900, $P2903
    new $P2926, 'ExceptionHandler'
    set_label $P2926, loop2925_handler
    $P2926."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2926
  loop2925_test:
    unless $P2900, loop2925_done
    shift $P2905, $P2900
  loop2925_redo:
    .const 'Sub' $P2907 = "424_1303430322.161" 
    capture_lex $P2907
    $P2907($P2905)
  loop2925_next:
    goto loop2925_test
  loop2925_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2927, exception, 'type'
    eq $P2927, .CONTROL_LOOP_NEXT, loop2925_next
    eq $P2927, .CONTROL_LOOP_REDO, loop2925_redo
  loop2925_done:
    pop_eh 
  for_undef_1534:
.annotate 'line', 2172
    .return (0)
  control_2896:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2928, exception, "payload"
    .return ($P2928)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2906"  :anon :subid("424_1303430322.161") :outer("423_1303430322.161")
    .param pmc param_2909
.annotate 'line', 2174
    $P2908 = root_new ['parrot';'Hash']
    .lex "%sym", $P2908
    .lex "$_", param_2909
    find_lex $P2910, "$_"
    unless_null $P2910, vivify_1535
    new $P2910, "Undef"
  vivify_1535:
    find_lex $P2911, "$name"
    unless_null $P2911, vivify_1536
    new $P2911, "Undef"
  vivify_1536:
    $P2912 = $P2910."symbol"($P2911)
    store_lex "%sym", $P2912
.annotate 'line', 2175
    find_lex $P2915, "%sym"
    unless_null $P2915, vivify_1537
    $P2915 = root_new ['parrot';'Hash']
  vivify_1537:
    set $N2916, $P2915
    if $N2916, if_2914
    new $P2913, 'Float'
    set $P2913, $N2916
    goto if_2914_end
  if_2914:
.annotate 'line', 2176
    new $P2917, "Exception"
    set $P2917['type'], .CONTROL_RETURN
    find_lex $P2918, "%sym"
    unless_null $P2918, vivify_1538
    $P2918 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P2919, $P2918["scope"]
    unless_null $P2919, vivify_1539
    new $P2919, "Undef"
  vivify_1539:
    set $S2920, $P2919
    find_lex $P2921, "$wanted_scope"
    unless_null $P2921, vivify_1540
    new $P2921, "Undef"
  vivify_1540:
    set $S2922, $P2921
    iseq $I2923, $S2920, $S2922
    new $P2924, 'Integer'
    set $P2924, $I2923
    setattribute $P2917, 'payload', $P2924
    throw $P2917
  if_2914_end:
.annotate 'line', 2173
    .return ($P2913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_lex"  :subid("425_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2933
.annotate 'line', 2183
    .const 'Sub' $P2941 = "426_1303430322.161" 
    capture_lex $P2941
    new $P2932, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2932, control_2931
    push_eh $P2932
    .lex "$name", param_2933
.annotate 'line', 2184
    find_lex $P2935, "$?PACKAGE"
    get_who $P2936, $P2935
    set $P2937, $P2936["@BLOCK"]
    unless_null $P2937, vivify_1541
    $P2937 = root_new ['parrot';'ResizablePMCArray']
  vivify_1541:
    defined $I2938, $P2937
    unless $I2938, for_undef_1542
    iter $P2934, $P2937
    new $P2955, 'ExceptionHandler'
    set_label $P2955, loop2954_handler
    $P2955."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2955
  loop2954_test:
    unless $P2934, loop2954_done
    shift $P2939, $P2934
  loop2954_redo:
    .const 'Sub' $P2941 = "426_1303430322.161" 
    capture_lex $P2941
    $P2941($P2939)
  loop2954_next:
    goto loop2954_test
  loop2954_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2956, exception, 'type'
    eq $P2956, .CONTROL_LOOP_NEXT, loop2954_next
    eq $P2956, .CONTROL_LOOP_REDO, loop2954_redo
  loop2954_done:
    pop_eh 
  for_undef_1542:
.annotate 'line', 2190
    new $P2957, 'String'
    set $P2957, "Could not find lexical '"
    find_lex $P2958, "$name"
    unless_null $P2958, vivify_1548
    new $P2958, "Undef"
  vivify_1548:
    concat $P2959, $P2957, $P2958
    concat $P2960, $P2959, "'"
    die $P2960
.annotate 'line', 2183
    .return ()
  control_2931:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2961, exception, "payload"
    .return ($P2961)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2940"  :anon :subid("426_1303430322.161") :outer("425_1303430322.161")
    .param pmc param_2943
.annotate 'line', 2185
    $P2942 = root_new ['parrot';'Hash']
    .lex "%sym", $P2942
    .lex "$_", param_2943
    find_lex $P2944, "$_"
    unless_null $P2944, vivify_1543
    new $P2944, "Undef"
  vivify_1543:
    find_lex $P2945, "$name"
    unless_null $P2945, vivify_1544
    new $P2945, "Undef"
  vivify_1544:
    $P2946 = $P2944."symbol"($P2945)
    store_lex "%sym", $P2946
.annotate 'line', 2186
    find_lex $P2949, "%sym"
    unless_null $P2949, vivify_1545
    $P2949 = root_new ['parrot';'Hash']
  vivify_1545:
    set $N2950, $P2949
    if $N2950, if_2948
    new $P2947, 'Float'
    set $P2947, $N2950
    goto if_2948_end
  if_2948:
.annotate 'line', 2187
    new $P2951, "Exception"
    set $P2951['type'], .CONTROL_RETURN
    find_lex $P2952, "%sym"
    unless_null $P2952, vivify_1546
    $P2952 = root_new ['parrot';'Hash']
  vivify_1546:
    set $P2953, $P2952["value"]
    unless_null $P2953, vivify_1547
    new $P2953, "Undef"
  vivify_1547:
    setattribute $P2951, 'payload', $P2953
    throw $P2951
  if_2948_end:
.annotate 'line', 2184
    .return ($P2947)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("427_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2972
    .param pmc param_2973
.annotate 'line', 798
    .lex "self", param_2972
    .lex "$/", param_2973
    find_lex $P2974, "$/"
    find_lex $P2975, "$/"
    unless_null $P2975, vivify_1549
    $P2975 = root_new ['parrot';'Hash']
  vivify_1549:
    set $P2976, $P2975["comp_unit"]
    unless_null $P2976, vivify_1550
    new $P2976, "Undef"
  vivify_1550:
    $P2977 = $P2976."ast"()
    $P2978 = $P2974."!make"($P2977)
    .return ($P2978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("428_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_2980
    .param pmc param_2981
.annotate 'line', 800
    .lex "self", param_2980
    .lex "$/", param_2981
.annotate 'line', 801
    find_lex $P2982, "$/"
.annotate 'line', 802
    find_lex $P2985, "$/"
    unless_null $P2985, vivify_1551
    $P2985 = root_new ['parrot';'Hash']
  vivify_1551:
    set $P2986, $P2985["colonpair"]
    unless_null $P2986, vivify_1552
    new $P2986, "Undef"
  vivify_1552:
    if $P2986, if_2984
.annotate 'line', 804
    find_lex $P3006, "$/"
    unless_null $P3006, vivify_1553
    new $P3006, "Undef"
  vivify_1553:
    set $S3007, $P3006
    new $P2983, 'String'
    set $P2983, $S3007
.annotate 'line', 802
    goto if_2984_end
  if_2984:
    find_lex $P2987, "$/"
    unless_null $P2987, vivify_1554
    $P2987 = root_new ['parrot';'Hash']
  vivify_1554:
    set $P2988, $P2987["identifier"]
    unless_null $P2988, vivify_1555
    new $P2988, "Undef"
  vivify_1555:
    set $S2989, $P2988
    new $P2990, 'String'
    set $P2990, $S2989
    concat $P2991, $P2990, ":"
    find_lex $P2992, "$/"
    unless_null $P2992, vivify_1556
    $P2992 = root_new ['parrot';'Hash']
  vivify_1556:
    set $P2993, $P2992["colonpair"]
    unless_null $P2993, vivify_1557
    $P2993 = root_new ['parrot';'ResizablePMCArray']
  vivify_1557:
    set $P2994, $P2993[0]
    unless_null $P2994, vivify_1558
    new $P2994, "Undef"
  vivify_1558:
    $P2995 = $P2994."ast"()
    $S2996 = $P2995."named"()
    concat $P2997, $P2991, $S2996
    concat $P2998, $P2997, "<"
.annotate 'line', 803
    find_lex $P2999, "$/"
    unless_null $P2999, vivify_1559
    $P2999 = root_new ['parrot';'Hash']
  vivify_1559:
    set $P3000, $P2999["colonpair"]
    unless_null $P3000, vivify_1560
    $P3000 = root_new ['parrot';'ResizablePMCArray']
  vivify_1560:
    set $P3001, $P3000[0]
    unless_null $P3001, vivify_1561
    new $P3001, "Undef"
  vivify_1561:
    $P3002 = $P3001."ast"()
    $S3003 = "colonpair_str"($P3002)
    concat $P3004, $P2998, $S3003
    concat $P3005, $P3004, ">"
    set $P2983, $P3005
  if_2984_end:
.annotate 'line', 802
    $P3008 = $P2982."!make"($P2983)
.annotate 'line', 800
    .return ($P3008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("429_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3011
    .param pmc param_3012
.annotate 'line', 814
    .lex "self", param_3011
    .lex "$/", param_3012
.annotate 'line', 815
    new $P3013, "Undef"
    .lex "$mainline", $P3013
.annotate 'line', 816
    new $P3014, "Undef"
    .lex "$unit", $P3014
.annotate 'line', 815
    find_lex $P3015, "$/"
    unless_null $P3015, vivify_1562
    $P3015 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3016, $P3015["statementlist"]
    unless_null $P3016, vivify_1563
    new $P3016, "Undef"
  vivify_1563:
    $P3017 = $P3016."ast"()
    store_lex "$mainline", $P3017
.annotate 'line', 816
    find_lex $P3018, "$?PACKAGE"
    get_who $P3019, $P3018
    set $P3020, $P3019["@BLOCK"]
    unless_null $P3020, vivify_1564
    $P3020 = root_new ['parrot';'ResizablePMCArray']
  vivify_1564:
    $P3021 = $P3020."shift"()
    store_lex "$unit", $P3021
.annotate 'line', 820
    find_lex $P3022, "$unit"
    unless_null $P3022, vivify_1565
    new $P3022, "Undef"
  vivify_1565:
    $P3023 = $P3022."loadinit"()
    find_dynamic_lex $P3024, "$*SC"
    unless_null $P3024, vivify_1566
    get_hll_global $P3024, "$SC"
    unless_null $P3024, vivify_1567
    die "Contextual $*SC not found"
  vivify_1567:
  vivify_1566:
    $P3025 = $P3024."to_past"()
    $P3023."push"($P3025)
.annotate 'line', 826
    find_lex $P3026, "$unit"
    unless_null $P3026, vivify_1568
    new $P3026, "Undef"
  vivify_1568:
    $P3027 = $P3026."loadinit"()
    get_hll_global $P3028, ["PAST"], "Op"
.annotate 'line', 828
    get_hll_global $P3029, ["PAST"], "Var"
    new $P3030, "ResizablePMCArray"
    $P3031 = $P3029."new"("GLOBAL" :named("name"), $P3030 :named("namespace"), "package" :named("scope"))
.annotate 'line', 829
    find_dynamic_lex $P3032, "$*SC"
    unless_null $P3032, vivify_1569
    get_hll_global $P3032, "$SC"
    unless_null $P3032, vivify_1570
    die "Contextual $*SC not found"
  vivify_1570:
  vivify_1569:
    find_dynamic_lex $P3033, "$*PACKAGE"
    unless_null $P3033, vivify_1571
    get_hll_global $P3033, "$PACKAGE"
    unless_null $P3033, vivify_1572
    die "Contextual $*PACKAGE not found"
  vivify_1572:
  vivify_1571:
    $P3034 = $P3032."get_slot_past_for_object"($P3033)
    $P3035 = $P3028."new"($P3031, $P3034, "bind" :named("pasttype"))
.annotate 'line', 826
    $P3027."push"($P3035)
.annotate 'line', 835
    find_dynamic_lex $P3037, "$*HAS_YOU_ARE_HERE"
    unless_null $P3037, vivify_1573
    get_hll_global $P3037, "$HAS_YOU_ARE_HERE"
    unless_null $P3037, vivify_1574
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1574:
  vivify_1573:
    if $P3037, unless_3036_end
.annotate 'line', 836
    find_lex $P3038, "$unit"
    unless_null $P3038, vivify_1575
    new $P3038, "Undef"
  vivify_1575:
    find_lex $P3039, "self"
    $P3040 = $P3039."CTXSAVE"()
    $P3038."push"($P3040)
  unless_3036_end:
.annotate 'line', 840
    find_lex $P3041, "$unit"
    unless_null $P3041, vivify_1576
    new $P3041, "Undef"
  vivify_1576:
    $P3041."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 844
    find_dynamic_lex $P3043, "$*MAIN_SUB"
    unless_null $P3043, vivify_1577
    get_hll_global $P3043, "$MAIN_SUB"
    unless_null $P3043, vivify_1578
    die "Contextual $*MAIN_SUB not found"
  vivify_1578:
  vivify_1577:
    unless $P3043, if_3042_end
.annotate 'line', 845
    find_lex $P3044, "$unit"
    unless_null $P3044, vivify_1579
    new $P3044, "Undef"
  vivify_1579:
    get_hll_global $P3045, ["PAST"], "Var"
    $P3046 = $P3045."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3044."unshift"($P3046)
.annotate 'line', 846
    find_lex $P3047, "$mainline"
    unless_null $P3047, vivify_1580
    new $P3047, "Undef"
  vivify_1580:
    get_hll_global $P3048, ["PAST"], "Op"
.annotate 'line', 848
    get_hll_global $P3049, ["PAST"], "Var"
    $P3050 = $P3049."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 849
    get_hll_global $P3051, ["PAST"], "Op"
.annotate 'line', 850
    get_hll_global $P3052, ["PAST"], "Val"
    find_dynamic_lex $P3053, "$*MAIN_SUB"
    unless_null $P3053, vivify_1581
    get_hll_global $P3053, "$MAIN_SUB"
    unless_null $P3053, vivify_1582
    die "Contextual $*MAIN_SUB not found"
  vivify_1582:
  vivify_1581:
    $P3054 = $P3052."new"($P3053 :named("value"))
.annotate 'line', 851
    get_hll_global $P3055, ["PAST"], "Var"
    $P3056 = $P3055."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3057 = $P3051."new"($P3054, $P3056, "call" :named("pasttype"))
.annotate 'line', 849
    $P3058 = $P3048."new"($P3050, $P3057, "if" :named("pasttype"))
.annotate 'line', 846
    $P3047."push"($P3058)
  if_3042_end:
.annotate 'line', 859
    find_lex $P3059, "$unit"
    unless_null $P3059, vivify_1583
    new $P3059, "Undef"
  vivify_1583:
.annotate 'line', 860
    get_hll_global $P3060, ["PAST"], "Op"
    find_lex $P3061, "$mainline"
    unless_null $P3061, vivify_1584
    new $P3061, "Undef"
  vivify_1584:
    $P3062 = $P3060."new"($P3061, "return" :named("pirop"))
    $P3059."push"($P3062)
.annotate 'line', 865
    find_lex $P3063, "$unit"
    unless_null $P3063, vivify_1585
    new $P3063, "Undef"
  vivify_1585:
.annotate 'line', 866
    get_hll_global $P3064, ["PAST"], "Block"
.annotate 'line', 868
    get_hll_global $P3065, ["PAST"], "Op"
    get_hll_global $P3066, ["PAST"], "Val"
    find_lex $P3067, "$unit"
    unless_null $P3067, vivify_1586
    new $P3067, "Undef"
  vivify_1586:
    $P3068 = $P3066."new"($P3067 :named("value"))
    $P3069 = $P3065."new"($P3068, "call" :named("pasttype"))
    $P3070 = $P3064."new"($P3069, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 866
    $P3063."push"($P3070)
.annotate 'line', 871
    find_lex $P3071, "$unit"
    unless_null $P3071, vivify_1587
    new $P3071, "Undef"
  vivify_1587:
    find_lex $P3072, "$/"
    unless_null $P3072, vivify_1588
    new $P3072, "Undef"
  vivify_1588:
    $P3071."node"($P3072)
.annotate 'line', 874
    find_lex $P3073, "$unit"
    unless_null $P3073, vivify_1589
    new $P3073, "Undef"
  vivify_1589:
    $P3073."hll"("nqp")
.annotate 'line', 876
    find_lex $P3074, "$/"
    find_lex $P3075, "$unit"
    unless_null $P3075, vivify_1590
    new $P3075, "Undef"
  vivify_1590:
    $P3076 = $P3074."!make"($P3075)
.annotate 'line', 814
    .return ($P3076)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("430_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3078
    .param pmc param_3079
.annotate 'line', 879
    .const 'Sub' $P3093 = "431_1303430322.161" 
    capture_lex $P3093
    .lex "self", param_3078
    .lex "$/", param_3079
.annotate 'line', 880
    new $P3080, "Undef"
    .lex "$past", $P3080
    get_hll_global $P3081, ["PAST"], "Stmts"
    find_lex $P3082, "$/"
    unless_null $P3082, vivify_1591
    new $P3082, "Undef"
  vivify_1591:
    $P3083 = $P3081."new"($P3082 :named("node"))
    store_lex "$past", $P3083
.annotate 'line', 881
    find_lex $P3085, "$/"
    unless_null $P3085, vivify_1592
    $P3085 = root_new ['parrot';'Hash']
  vivify_1592:
    set $P3086, $P3085["statement"]
    unless_null $P3086, vivify_1593
    new $P3086, "Undef"
  vivify_1593:
    unless $P3086, if_3084_end
.annotate 'line', 882
    find_lex $P3088, "$/"
    unless_null $P3088, vivify_1594
    $P3088 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3089, $P3088["statement"]
    unless_null $P3089, vivify_1595
    new $P3089, "Undef"
  vivify_1595:
    defined $I3090, $P3089
    unless $I3090, for_undef_1596
    iter $P3087, $P3089
    new $P3113, 'ExceptionHandler'
    set_label $P3113, loop3112_handler
    $P3113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3113
  loop3112_test:
    unless $P3087, loop3112_done
    shift $P3091, $P3087
  loop3112_redo:
    .const 'Sub' $P3093 = "431_1303430322.161" 
    capture_lex $P3093
    $P3093($P3091)
  loop3112_next:
    goto loop3112_test
  loop3112_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3114, exception, 'type'
    eq $P3114, .CONTROL_LOOP_NEXT, loop3112_next
    eq $P3114, .CONTROL_LOOP_REDO, loop3112_redo
  loop3112_done:
    pop_eh 
  for_undef_1596:
  if_3084_end:
.annotate 'line', 889
    find_lex $P3115, "$/"
    find_lex $P3116, "$past"
    unless_null $P3116, vivify_1607
    new $P3116, "Undef"
  vivify_1607:
    $P3117 = $P3115."!make"($P3116)
.annotate 'line', 879
    .return ($P3117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3092"  :anon :subid("431_1303430322.161") :outer("430_1303430322.161")
    .param pmc param_3095
.annotate 'line', 883
    new $P3094, "Undef"
    .lex "$ast", $P3094
    .lex "$_", param_3095
    find_lex $P3096, "$_"
    unless_null $P3096, vivify_1597
    new $P3096, "Undef"
  vivify_1597:
    $P3097 = $P3096."ast"()
    store_lex "$ast", $P3097
.annotate 'line', 884
    find_lex $P3099, "$ast"
    unless_null $P3099, vivify_1598
    $P3099 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P3100, $P3099["sink"]
    unless_null $P3100, vivify_1599
    new $P3100, "Undef"
  vivify_1599:
    defined $I3101, $P3100
    unless $I3101, if_3098_end
    find_lex $P3102, "$ast"
    unless_null $P3102, vivify_1600
    $P3102 = root_new ['parrot';'Hash']
  vivify_1600:
    set $P3103, $P3102["sink"]
    unless_null $P3103, vivify_1601
    new $P3103, "Undef"
  vivify_1601:
    store_lex "$ast", $P3103
  if_3098_end:
.annotate 'line', 885
    find_lex $P3105, "$ast"
    unless_null $P3105, vivify_1602
    $P3105 = root_new ['parrot';'Hash']
  vivify_1602:
    set $P3106, $P3105["bareblock"]
    unless_null $P3106, vivify_1603
    new $P3106, "Undef"
  vivify_1603:
    unless $P3106, if_3104_end
    find_lex $P3107, "$ast"
    unless_null $P3107, vivify_1604
    new $P3107, "Undef"
  vivify_1604:
    $P3108 = "block_immediate"($P3107)
    store_lex "$ast", $P3108
  if_3104_end:
.annotate 'line', 886
    find_lex $P3109, "$past"
    unless_null $P3109, vivify_1605
    new $P3109, "Undef"
  vivify_1605:
    find_lex $P3110, "$ast"
    unless_null $P3110, vivify_1606
    new $P3110, "Undef"
  vivify_1606:
    $P3111 = $P3109."push"($P3110)
.annotate 'line', 882
    .return ($P3111)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("432_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3119
    .param pmc param_3120
    .param pmc param_3121 :optional
    .param int has_param_3121 :opt_flag
.annotate 'line', 892
    .const 'Sub' $P3129 = "433_1303430322.161" 
    capture_lex $P3129
    .lex "self", param_3119
    .lex "$/", param_3120
    if has_param_3121, optparam_1608
    new $P3122, "Undef"
    set param_3121, $P3122
  optparam_1608:
    .lex "$key", param_3121
.annotate 'line', 893
    new $P3123, "Undef"
    .lex "$past", $P3123
.annotate 'line', 892
    find_lex $P3124, "$past"
    unless_null $P3124, vivify_1609
    new $P3124, "Undef"
  vivify_1609:
.annotate 'line', 894
    find_lex $P3126, "$/"
    unless_null $P3126, vivify_1610
    $P3126 = root_new ['parrot';'Hash']
  vivify_1610:
    set $P3127, $P3126["EXPR"]
    unless_null $P3127, vivify_1611
    new $P3127, "Undef"
  vivify_1611:
    if $P3127, if_3125
.annotate 'line', 915
    find_lex $P3190, "$/"
    unless_null $P3190, vivify_1612
    $P3190 = root_new ['parrot';'Hash']
  vivify_1612:
    set $P3191, $P3190["statement_control"]
    unless_null $P3191, vivify_1613
    new $P3191, "Undef"
  vivify_1613:
    if $P3191, if_3189
.annotate 'line', 916
    new $P3195, "Integer"
    assign $P3195, 0
    store_lex "$past", $P3195
    goto if_3189_end
  if_3189:
.annotate 'line', 915
    find_lex $P3192, "$/"
    unless_null $P3192, vivify_1614
    $P3192 = root_new ['parrot';'Hash']
  vivify_1614:
    set $P3193, $P3192["statement_control"]
    unless_null $P3193, vivify_1615
    new $P3193, "Undef"
  vivify_1615:
    $P3194 = $P3193."ast"()
    store_lex "$past", $P3194
  if_3189_end:
    goto if_3125_end
  if_3125:
.annotate 'line', 894
    .const 'Sub' $P3129 = "433_1303430322.161" 
    capture_lex $P3129
    $P3129()
  if_3125_end:
.annotate 'line', 917
    find_lex $P3196, "$/"
    find_lex $P3197, "$past"
    unless_null $P3197, vivify_1649
    new $P3197, "Undef"
  vivify_1649:
    $P3198 = $P3196."!make"($P3197)
.annotate 'line', 892
    .return ($P3198)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3128"  :anon :subid("433_1303430322.161") :outer("432_1303430322.161")
.annotate 'line', 895
    new $P3130, "Undef"
    .lex "$mc", $P3130
.annotate 'line', 896
    new $P3131, "Undef"
    .lex "$ml", $P3131
.annotate 'line', 895
    find_lex $P3132, "$/"
    unless_null $P3132, vivify_1616
    $P3132 = root_new ['parrot';'Hash']
  vivify_1616:
    set $P3133, $P3132["statement_mod_cond"]
    unless_null $P3133, vivify_1617
    $P3133 = root_new ['parrot';'ResizablePMCArray']
  vivify_1617:
    set $P3134, $P3133[0]
    unless_null $P3134, vivify_1618
    new $P3134, "Undef"
  vivify_1618:
    store_lex "$mc", $P3134
.annotate 'line', 896
    find_lex $P3135, "$/"
    unless_null $P3135, vivify_1619
    $P3135 = root_new ['parrot';'Hash']
  vivify_1619:
    set $P3136, $P3135["statement_mod_loop"]
    unless_null $P3136, vivify_1620
    $P3136 = root_new ['parrot';'ResizablePMCArray']
  vivify_1620:
    set $P3137, $P3136[0]
    unless_null $P3137, vivify_1621
    new $P3137, "Undef"
  vivify_1621:
    store_lex "$ml", $P3137
.annotate 'line', 897
    find_lex $P3138, "$/"
    unless_null $P3138, vivify_1622
    $P3138 = root_new ['parrot';'Hash']
  vivify_1622:
    set $P3139, $P3138["EXPR"]
    unless_null $P3139, vivify_1623
    new $P3139, "Undef"
  vivify_1623:
    $P3140 = $P3139."ast"()
    store_lex "$past", $P3140
.annotate 'line', 898
    find_lex $P3142, "$mc"
    unless_null $P3142, vivify_1624
    new $P3142, "Undef"
  vivify_1624:
    unless $P3142, if_3141_end
.annotate 'line', 899
    get_hll_global $P3143, ["PAST"], "Op"
    find_lex $P3144, "$mc"
    unless_null $P3144, vivify_1625
    $P3144 = root_new ['parrot';'Hash']
  vivify_1625:
    set $P3145, $P3144["cond"]
    unless_null $P3145, vivify_1626
    new $P3145, "Undef"
  vivify_1626:
    $P3146 = $P3145."ast"()
    find_lex $P3147, "$past"
    unless_null $P3147, vivify_1627
    new $P3147, "Undef"
  vivify_1627:
    find_lex $P3148, "$mc"
    unless_null $P3148, vivify_1628
    $P3148 = root_new ['parrot';'Hash']
  vivify_1628:
    set $P3149, $P3148["sym"]
    unless_null $P3149, vivify_1629
    new $P3149, "Undef"
  vivify_1629:
    set $S3150, $P3149
    find_lex $P3151, "$/"
    unless_null $P3151, vivify_1630
    new $P3151, "Undef"
  vivify_1630:
    $P3152 = $P3143."new"($P3146, $P3147, $S3150 :named("pasttype"), $P3151 :named("node"))
    store_lex "$past", $P3152
  if_3141_end:
.annotate 'line', 901
    find_lex $P3155, "$ml"
    unless_null $P3155, vivify_1631
    new $P3155, "Undef"
  vivify_1631:
    if $P3155, if_3154
    set $P3153, $P3155
    goto if_3154_end
  if_3154:
.annotate 'line', 902
    find_lex $P3158, "$ml"
    unless_null $P3158, vivify_1632
    $P3158 = root_new ['parrot';'Hash']
  vivify_1632:
    set $P3159, $P3158["sym"]
    unless_null $P3159, vivify_1633
    new $P3159, "Undef"
  vivify_1633:
    set $S3160, $P3159
    iseq $I3161, $S3160, "for"
    if $I3161, if_3157
.annotate 'line', 911
    get_hll_global $P3179, ["PAST"], "Op"
    find_lex $P3180, "$ml"
    unless_null $P3180, vivify_1634
    $P3180 = root_new ['parrot';'Hash']
  vivify_1634:
    set $P3181, $P3180["cond"]
    unless_null $P3181, vivify_1635
    new $P3181, "Undef"
  vivify_1635:
    $P3182 = $P3181."ast"()
    find_lex $P3183, "$past"
    unless_null $P3183, vivify_1636
    new $P3183, "Undef"
  vivify_1636:
    find_lex $P3184, "$ml"
    unless_null $P3184, vivify_1637
    $P3184 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3185, $P3184["sym"]
    unless_null $P3185, vivify_1638
    new $P3185, "Undef"
  vivify_1638:
    set $S3186, $P3185
    find_lex $P3187, "$/"
    unless_null $P3187, vivify_1639
    new $P3187, "Undef"
  vivify_1639:
    $P3188 = $P3179."new"($P3182, $P3183, $S3186 :named("pasttype"), $P3187 :named("node"))
    store_lex "$past", $P3188
.annotate 'line', 910
    set $P3156, $P3188
.annotate 'line', 902
    goto if_3157_end
  if_3157:
.annotate 'line', 903
    get_hll_global $P3162, ["PAST"], "Block"
.annotate 'line', 904
    get_hll_global $P3163, ["PAST"], "Var"
    $P3164 = $P3163."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3165, "$past"
    unless_null $P3165, vivify_1640
    new $P3165, "Undef"
  vivify_1640:
    $P3166 = $P3162."new"($P3164, $P3165, "immediate" :named("blocktype"))
.annotate 'line', 903
    store_lex "$past", $P3166
.annotate 'line', 906
    find_lex $P3167, "$past"
    unless_null $P3167, vivify_1641
    new $P3167, "Undef"
  vivify_1641:
    $P3167."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 907
    find_lex $P3168, "$past"
    unless_null $P3168, vivify_1642
    new $P3168, "Undef"
  vivify_1642:
    $P3168."arity"(1)
.annotate 'line', 908
    get_hll_global $P3169, ["PAST"], "Op"
    find_lex $P3170, "$ml"
    unless_null $P3170, vivify_1643
    $P3170 = root_new ['parrot';'Hash']
  vivify_1643:
    set $P3171, $P3170["cond"]
    unless_null $P3171, vivify_1644
    new $P3171, "Undef"
  vivify_1644:
    $P3172 = $P3171."ast"()
    find_lex $P3173, "$past"
    unless_null $P3173, vivify_1645
    new $P3173, "Undef"
  vivify_1645:
    find_lex $P3174, "$ml"
    unless_null $P3174, vivify_1646
    $P3174 = root_new ['parrot';'Hash']
  vivify_1646:
    set $P3175, $P3174["sym"]
    unless_null $P3175, vivify_1647
    new $P3175, "Undef"
  vivify_1647:
    set $S3176, $P3175
    find_lex $P3177, "$/"
    unless_null $P3177, vivify_1648
    new $P3177, "Undef"
  vivify_1648:
    $P3178 = $P3169."new"($P3172, $P3173, $S3176 :named("pasttype"), $P3177 :named("node"))
    store_lex "$past", $P3178
.annotate 'line', 902
    set $P3156, $P3178
  if_3157_end:
.annotate 'line', 901
    set $P3153, $P3156
  if_3154_end:
.annotate 'line', 894
    .return ($P3153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("434_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3200
    .param pmc param_3201
.annotate 'line', 920
    .lex "self", param_3200
    .lex "$/", param_3201
.annotate 'line', 921
    find_lex $P3202, "$/"
    get_hll_global $P3203, ["PAST"], "Op"
    find_lex $P3204, "$/"
    unless_null $P3204, vivify_1650
    $P3204 = root_new ['parrot';'Hash']
  vivify_1650:
    set $P3205, $P3204["EXPR"]
    unless_null $P3205, vivify_1651
    new $P3205, "Undef"
  vivify_1651:
    $P3206 = $P3205."ast"()
    find_lex $P3207, "$/"
    unless_null $P3207, vivify_1652
    $P3207 = root_new ['parrot';'Hash']
  vivify_1652:
    set $P3208, $P3207["pblock"]
    unless_null $P3208, vivify_1653
    new $P3208, "Undef"
  vivify_1653:
    $P3209 = $P3208."ast"()
    find_lex $P3210, "$/"
    unless_null $P3210, vivify_1654
    new $P3210, "Undef"
  vivify_1654:
    $P3211 = $P3203."new"($P3206, $P3209, "if" :named("pasttype"), $P3210 :named("node"))
    $P3212 = $P3202."!make"($P3211)
.annotate 'line', 920
    .return ($P3212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("435_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3214
    .param pmc param_3215
.annotate 'line', 924
    .lex "self", param_3214
    .lex "$/", param_3215
.annotate 'line', 925
    find_lex $P3216, "$/"
    find_lex $P3217, "$/"
    unless_null $P3217, vivify_1655
    $P3217 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3218, $P3217["blockoid"]
    unless_null $P3218, vivify_1656
    new $P3218, "Undef"
  vivify_1656:
    $P3219 = $P3218."ast"()
    $P3220 = $P3216."!make"($P3219)
.annotate 'line', 924
    .return ($P3220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("436_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3222
    .param pmc param_3223
.annotate 'line', 928
    .lex "self", param_3222
    .lex "$/", param_3223
.annotate 'line', 929
    find_lex $P3224, "$/"
    find_lex $P3225, "$/"
    unless_null $P3225, vivify_1657
    $P3225 = root_new ['parrot';'Hash']
  vivify_1657:
    set $P3226, $P3225["blockoid"]
    unless_null $P3226, vivify_1658
    new $P3226, "Undef"
  vivify_1658:
    $P3227 = $P3226."ast"()
    $P3228 = $P3224."!make"($P3227)
.annotate 'line', 928
    .return ($P3228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("437_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3230
    .param pmc param_3231
.annotate 'line', 932
    .const 'Sub' $P3242 = "438_1303430322.161" 
    capture_lex $P3242
    .lex "self", param_3230
    .lex "$/", param_3231
.annotate 'line', 933
    new $P3232, "Undef"
    .lex "$BLOCK", $P3232
    find_lex $P3233, "$?PACKAGE"
    get_who $P3234, $P3233
    set $P3235, $P3234["@BLOCK"]
    unless_null $P3235, vivify_1659
    $P3235 = root_new ['parrot';'ResizablePMCArray']
  vivify_1659:
    $P3236 = $P3235."shift"()
    store_lex "$BLOCK", $P3236
.annotate 'line', 934
    find_lex $P3239, "$/"
    unless_null $P3239, vivify_1660
    $P3239 = root_new ['parrot';'Hash']
  vivify_1660:
    set $P3240, $P3239["statementlist"]
    unless_null $P3240, vivify_1661
    new $P3240, "Undef"
  vivify_1661:
    if $P3240, if_3238
.annotate 'line', 942
    find_dynamic_lex $P3257, "$*HAS_YOU_ARE_HERE"
    unless_null $P3257, vivify_1662
    get_hll_global $P3257, "$HAS_YOU_ARE_HERE"
    unless_null $P3257, vivify_1663
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1663:
  vivify_1662:
    unless $P3257, if_3256_end
.annotate 'line', 943
    find_lex $P3258, "$/"
    unless_null $P3258, vivify_1664
    new $P3258, "Undef"
  vivify_1664:
    $P3259 = $P3258."CURSOR"()
    $P3259."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3256_end:
.annotate 'line', 945
    new $P3260, "Integer"
    assign $P3260, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3260
.annotate 'line', 946
    find_lex $P3261, "$/"
    find_lex $P3262, "$/"
    unless_null $P3262, vivify_1665
    $P3262 = root_new ['parrot';'Hash']
  vivify_1665:
    set $P3263, $P3262["you_are_here"]
    unless_null $P3263, vivify_1666
    new $P3263, "Undef"
  vivify_1666:
    $P3264 = $P3263."ast"()
    $P3265 = $P3261."!make"($P3264)
.annotate 'line', 941
    set $P3237, $P3265
.annotate 'line', 934
    goto if_3238_end
  if_3238:
    .const 'Sub' $P3242 = "438_1303430322.161" 
    capture_lex $P3242
    $P3255 = $P3242()
    set $P3237, $P3255
  if_3238_end:
.annotate 'line', 932
    .return ($P3237)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3241"  :anon :subid("438_1303430322.161") :outer("437_1303430322.161")
.annotate 'line', 935
    new $P3243, "Undef"
    .lex "$past", $P3243
    find_lex $P3244, "$/"
    unless_null $P3244, vivify_1667
    $P3244 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3245, $P3244["statementlist"]
    unless_null $P3245, vivify_1668
    new $P3245, "Undef"
  vivify_1668:
    $P3246 = $P3245."ast"()
    store_lex "$past", $P3246
.annotate 'line', 936
    find_lex $P3247, "$BLOCK"
    unless_null $P3247, vivify_1669
    new $P3247, "Undef"
  vivify_1669:
    find_lex $P3248, "$past"
    unless_null $P3248, vivify_1670
    new $P3248, "Undef"
  vivify_1670:
    $P3247."push"($P3248)
.annotate 'line', 937
    find_lex $P3249, "$BLOCK"
    unless_null $P3249, vivify_1671
    new $P3249, "Undef"
  vivify_1671:
    find_lex $P3250, "$/"
    unless_null $P3250, vivify_1672
    new $P3250, "Undef"
  vivify_1672:
    $P3249."node"($P3250)
.annotate 'line', 938
    find_lex $P3251, "$BLOCK"
    unless_null $P3251, vivify_1673
    new $P3251, "Undef"
  vivify_1673:
    $P3251."closure"(1)
.annotate 'line', 939
    find_dynamic_lex $P3252, "$/"
    find_lex $P3253, "$BLOCK"
    unless_null $P3253, vivify_1674
    new $P3253, "Undef"
  vivify_1674:
    $P3254 = $P3252."!make"($P3253)
.annotate 'line', 934
    .return ($P3254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("439_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3267
    .param pmc param_3268
.annotate 'line', 950
    .lex "self", param_3267
    .lex "$/", param_3268
.annotate 'line', 951
    find_lex $P3269, "$?PACKAGE"
    get_who $P3270, $P3269
    set $P3271, $P3270["@BLOCK"]
    unless_null $P3271, vivify_1675
    $P3271 = root_new ['parrot';'ResizablePMCArray']
  vivify_1675:
    get_hll_global $P3272, ["PAST"], "Block"
    get_hll_global $P3273, ["PAST"], "Stmts"
    $P3274 = $P3273."new"()
    $P3275 = $P3272."new"($P3274)
    $P3276 = $P3271."unshift"($P3275)
.annotate 'line', 950
    .return ($P3276)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("440_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3278
    .param pmc param_3279
.annotate 'line', 954
    .lex "self", param_3278
    .lex "$/", param_3279
.annotate 'line', 955
    find_dynamic_lex $P3281, "%*COMPILING"
    unless_null $P3281, vivify_1676
    get_hll_global $P3281, "%COMPILING"
    unless_null $P3281, vivify_1677
    die "Contextual %*COMPILING not found"
  vivify_1677:
  vivify_1676:
    set $P3282, $P3281["%?OPTIONS"]
    unless_null $P3282, vivify_1678
    $P3282 = root_new ['parrot';'Hash']
  vivify_1678:
    set $P3283, $P3282["outer_ctx"]
    unless_null $P3283, vivify_1679
    new $P3283, "Undef"
  vivify_1679:
    defined $I3284, $P3283
    if $I3284, unless_3280_end
.annotate 'line', 958
    find_dynamic_lex $P3285, "$*SC"
    unless_null $P3285, vivify_1680
    get_hll_global $P3285, "$SC"
    unless_null $P3285, vivify_1681
    die "Contextual $*SC not found"
  vivify_1681:
  vivify_1680:
    find_dynamic_lex $P3287, "%*COMPILING"
    unless_null $P3287, vivify_1682
    get_hll_global $P3287, "%COMPILING"
    unless_null $P3287, vivify_1683
    die "Contextual %*COMPILING not found"
  vivify_1683:
  vivify_1682:
    set $P3288, $P3287["%?OPTIONS"]
    unless_null $P3288, vivify_1684
    $P3288 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3289, $P3288["setting"]
    unless_null $P3289, vivify_1685
    new $P3289, "Undef"
  vivify_1685:
    set $P3286, $P3289
    defined $I3291, $P3286
    if $I3291, default_3290
    new $P3292, "String"
    assign $P3292, "NQPCORE"
    set $P3286, $P3292
  default_3290:
    $P3285."load_setting"($P3286)
  unless_3280_end:
.annotate 'line', 960
    find_lex $P3293, "self"
    find_lex $P3294, "$?PACKAGE"
    get_who $P3295, $P3294
    set $P3296, $P3295["@BLOCK"]
    unless_null $P3296, vivify_1686
    $P3296 = root_new ['parrot';'ResizablePMCArray']
  vivify_1686:
    set $P3297, $P3296[0]
    unless_null $P3297, vivify_1687
    new $P3297, "Undef"
  vivify_1687:
    $P3298 = $P3293."SET_BLOCK_OUTER_CTX"($P3297)
.annotate 'line', 954
    .return ($P3298)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("441_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3300
    .param pmc param_3301
.annotate 'line', 963
    .lex "self", param_3300
    .lex "$/", param_3301
.annotate 'line', 967
    find_dynamic_lex $P3302, "$*SC"
    unless_null $P3302, vivify_1688
    get_hll_global $P3302, "$SC"
    unless_null $P3302, vivify_1689
    die "Contextual $*SC not found"
  vivify_1689:
  vivify_1688:
    get_hll_global $P3303, "KnowHOW"
    $P3304 = $P3302."pkg_create_mo"($P3303, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3304
.annotate 'line', 968
    find_dynamic_lex $P3305, "$*GLOBALish"
    unless_null $P3305, vivify_1690
    get_hll_global $P3305, "$GLOBALish"
    unless_null $P3305, vivify_1691
    die "Contextual $*GLOBALish not found"
  vivify_1691:
  vivify_1690:
    get_how $P3306, $P3305
    find_dynamic_lex $P3307, "$*GLOBALish"
    unless_null $P3307, vivify_1692
    get_hll_global $P3307, "$GLOBALish"
    unless_null $P3307, vivify_1693
    die "Contextual $*GLOBALish not found"
  vivify_1693:
  vivify_1692:
    $P3306."compose"($P3307)
.annotate 'line', 969
    find_dynamic_lex $P3308, "$*SC"
    unless_null $P3308, vivify_1694
    get_hll_global $P3308, "$SC"
    unless_null $P3308, vivify_1695
    die "Contextual $*SC not found"
  vivify_1695:
  vivify_1694:
    find_lex $P3309, "$?PACKAGE"
    get_who $P3310, $P3309
    set $P3311, $P3310["@BLOCK"]
    unless_null $P3311, vivify_1696
    $P3311 = root_new ['parrot';'ResizablePMCArray']
  vivify_1696:
    set $P3312, $P3311[0]
    unless_null $P3312, vivify_1697
    new $P3312, "Undef"
  vivify_1697:
    find_dynamic_lex $P3313, "$*GLOBALish"
    unless_null $P3313, vivify_1698
    get_hll_global $P3313, "$GLOBALish"
    unless_null $P3313, vivify_1699
    die "Contextual $*GLOBALish not found"
  vivify_1699:
  vivify_1698:
    $P3308."install_lexical_symbol"($P3312, "GLOBALish", $P3313)
.annotate 'line', 972
    find_dynamic_lex $P3314, "$*GLOBALish"
    unless_null $P3314, vivify_1700
    get_hll_global $P3314, "$GLOBALish"
    unless_null $P3314, vivify_1701
    die "Contextual $*GLOBALish not found"
  vivify_1701:
  vivify_1700:
    store_dynamic_lex "$*PACKAGE", $P3314
.annotate 'line', 973
    find_dynamic_lex $P3315, "$*SC"
    unless_null $P3315, vivify_1702
    get_hll_global $P3315, "$SC"
    unless_null $P3315, vivify_1703
    die "Contextual $*SC not found"
  vivify_1703:
  vivify_1702:
    find_lex $P3316, "$?PACKAGE"
    get_who $P3317, $P3316
    set $P3318, $P3317["@BLOCK"]
    unless_null $P3318, vivify_1704
    $P3318 = root_new ['parrot';'ResizablePMCArray']
  vivify_1704:
    set $P3319, $P3318[0]
    unless_null $P3319, vivify_1705
    new $P3319, "Undef"
  vivify_1705:
    find_dynamic_lex $P3320, "$*PACKAGE"
    unless_null $P3320, vivify_1706
    get_hll_global $P3320, "$PACKAGE"
    unless_null $P3320, vivify_1707
    die "Contextual $*PACKAGE not found"
  vivify_1707:
  vivify_1706:
    $P3321 = $P3315."install_lexical_symbol"($P3319, "$?PACKAGE", $P3320)
.annotate 'line', 963
    .return ($P3321)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("442_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3323
    .param pmc param_3324
.annotate 'line', 976
    .lex "self", param_3323
    .lex "$/", param_3324
.annotate 'line', 977
    find_lex $P3325, "$/"
    find_lex $P3326, "self"
    $P3327 = $P3326."CTXSAVE"()
    $P3328 = $P3325."!make"($P3327)
.annotate 'line', 976
    .return ($P3328)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("443_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3330
    .param pmc param_3331
.annotate 'line', 982
    .lex "self", param_3330
    .lex "$/", param_3331
.annotate 'line', 983
    find_dynamic_lex $P3332, "$*SC"
    unless_null $P3332, vivify_1708
    get_hll_global $P3332, "$SC"
    unless_null $P3332, vivify_1709
    die "Contextual $*SC not found"
  vivify_1709:
  vivify_1708:
    find_lex $P3333, "$/"
    unless_null $P3333, vivify_1710
    $P3333 = root_new ['parrot';'Hash']
  vivify_1710:
    set $P3334, $P3333["name"]
    unless_null $P3334, vivify_1711
    new $P3334, "Undef"
  vivify_1711:
    set $S3335, $P3334
    $P3332."load_module"($S3335)
.annotate 'line', 984
    find_lex $P3336, "$/"
    get_hll_global $P3337, ["PAST"], "Stmts"
    $P3338 = $P3337."new"()
    $P3339 = $P3336."!make"($P3338)
.annotate 'line', 982
    .return ($P3339)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("444_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3341
    .param pmc param_3342
.annotate 'line', 987
    .const 'Sub' $P3370 = "445_1303430322.161" 
    capture_lex $P3370
    .lex "self", param_3341
    .lex "$/", param_3342
.annotate 'line', 988
    new $P3343, "Undef"
    .lex "$count", $P3343
.annotate 'line', 989
    new $P3344, "Undef"
    .lex "$past", $P3344
.annotate 'line', 988
    find_lex $P3345, "$/"
    unless_null $P3345, vivify_1712
    $P3345 = root_new ['parrot';'Hash']
  vivify_1712:
    set $P3346, $P3345["xblock"]
    unless_null $P3346, vivify_1713
    new $P3346, "Undef"
  vivify_1713:
    set $N3347, $P3346
    new $P3348, 'Float'
    set $P3348, $N3347
    sub $P3349, $P3348, 1
    store_lex "$count", $P3349
.annotate 'line', 989
    find_lex $P3350, "$count"
    unless_null $P3350, vivify_1714
    new $P3350, "Undef"
  vivify_1714:
    set $I3351, $P3350
    find_lex $P3352, "$/"
    unless_null $P3352, vivify_1715
    $P3352 = root_new ['parrot';'Hash']
  vivify_1715:
    set $P3353, $P3352["xblock"]
    unless_null $P3353, vivify_1716
    $P3353 = root_new ['parrot';'ResizablePMCArray']
  vivify_1716:
    set $P3354, $P3353[$I3351]
    unless_null $P3354, vivify_1717
    new $P3354, "Undef"
  vivify_1717:
    $P3355 = $P3354."ast"()
    $P3356 = "xblock_immediate"($P3355)
    store_lex "$past", $P3356
.annotate 'line', 990
    find_lex $P3358, "$/"
    unless_null $P3358, vivify_1718
    $P3358 = root_new ['parrot';'Hash']
  vivify_1718:
    set $P3359, $P3358["else"]
    unless_null $P3359, vivify_1719
    new $P3359, "Undef"
  vivify_1719:
    unless $P3359, if_3357_end
.annotate 'line', 991
    find_lex $P3360, "$past"
    unless_null $P3360, vivify_1720
    new $P3360, "Undef"
  vivify_1720:
    find_lex $P3361, "$/"
    unless_null $P3361, vivify_1721
    $P3361 = root_new ['parrot';'Hash']
  vivify_1721:
    set $P3362, $P3361["else"]
    unless_null $P3362, vivify_1722
    $P3362 = root_new ['parrot';'ResizablePMCArray']
  vivify_1722:
    set $P3363, $P3362[0]
    unless_null $P3363, vivify_1723
    new $P3363, "Undef"
  vivify_1723:
    $P3364 = $P3363."ast"()
    $P3365 = "block_immediate"($P3364)
    $P3360."push"($P3365)
  if_3357_end:
.annotate 'line', 994
    new $P3386, 'ExceptionHandler'
    set_label $P3386, loop3385_handler
    $P3386."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3386
  loop3385_test:
    find_lex $P3366, "$count"
    unless_null $P3366, vivify_1724
    new $P3366, "Undef"
  vivify_1724:
    set $N3367, $P3366
    isgt $I3368, $N3367, 0.0
    unless $I3368, loop3385_done
  loop3385_redo:
    .const 'Sub' $P3370 = "445_1303430322.161" 
    capture_lex $P3370
    $P3370()
  loop3385_next:
    goto loop3385_test
  loop3385_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3387, exception, 'type'
    eq $P3387, .CONTROL_LOOP_NEXT, loop3385_next
    eq $P3387, .CONTROL_LOOP_REDO, loop3385_redo
  loop3385_done:
    pop_eh 
.annotate 'line', 1000
    find_lex $P3388, "$/"
    find_lex $P3389, "$past"
    unless_null $P3389, vivify_1733
    new $P3389, "Undef"
  vivify_1733:
    $P3390 = $P3388."!make"($P3389)
.annotate 'line', 987
    .return ($P3390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3369"  :anon :subid("445_1303430322.161") :outer("444_1303430322.161")
.annotate 'line', 996
    new $P3371, "Undef"
    .lex "$else", $P3371
.annotate 'line', 994
    find_lex $P3372, "$count"
    unless_null $P3372, vivify_1725
    new $P3372, "Undef"
  vivify_1725:
    clone $P3373, $P3372
    dec $P3372
.annotate 'line', 996
    find_lex $P3374, "$past"
    unless_null $P3374, vivify_1726
    new $P3374, "Undef"
  vivify_1726:
    store_lex "$else", $P3374
.annotate 'line', 997
    find_lex $P3375, "$count"
    unless_null $P3375, vivify_1727
    new $P3375, "Undef"
  vivify_1727:
    set $I3376, $P3375
    find_lex $P3377, "$/"
    unless_null $P3377, vivify_1728
    $P3377 = root_new ['parrot';'Hash']
  vivify_1728:
    set $P3378, $P3377["xblock"]
    unless_null $P3378, vivify_1729
    $P3378 = root_new ['parrot';'ResizablePMCArray']
  vivify_1729:
    set $P3379, $P3378[$I3376]
    unless_null $P3379, vivify_1730
    new $P3379, "Undef"
  vivify_1730:
    $P3380 = $P3379."ast"()
    $P3381 = "xblock_immediate"($P3380)
    store_lex "$past", $P3381
.annotate 'line', 998
    find_lex $P3382, "$past"
    unless_null $P3382, vivify_1731
    new $P3382, "Undef"
  vivify_1731:
    find_lex $P3383, "$else"
    unless_null $P3383, vivify_1732
    new $P3383, "Undef"
  vivify_1732:
    $P3384 = $P3382."push"($P3383)
.annotate 'line', 994
    .return ($P3384)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("446_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3392
    .param pmc param_3393
.annotate 'line', 1003
    .lex "self", param_3392
    .lex "$/", param_3393
.annotate 'line', 1004
    new $P3394, "Undef"
    .lex "$past", $P3394
    find_lex $P3395, "$/"
    unless_null $P3395, vivify_1734
    $P3395 = root_new ['parrot';'Hash']
  vivify_1734:
    set $P3396, $P3395["xblock"]
    unless_null $P3396, vivify_1735
    new $P3396, "Undef"
  vivify_1735:
    $P3397 = $P3396."ast"()
    $P3398 = "xblock_immediate"($P3397)
    store_lex "$past", $P3398
.annotate 'line', 1005
    find_lex $P3399, "$past"
    unless_null $P3399, vivify_1736
    new $P3399, "Undef"
  vivify_1736:
    $P3399."pasttype"("unless")
.annotate 'line', 1006
    find_lex $P3400, "$/"
    find_lex $P3401, "$past"
    unless_null $P3401, vivify_1737
    new $P3401, "Undef"
  vivify_1737:
    $P3402 = $P3400."!make"($P3401)
.annotate 'line', 1003
    .return ($P3402)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("447_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3404
    .param pmc param_3405
.annotate 'line', 1009
    .lex "self", param_3404
    .lex "$/", param_3405
.annotate 'line', 1010
    new $P3406, "Undef"
    .lex "$past", $P3406
    find_lex $P3407, "$/"
    unless_null $P3407, vivify_1738
    $P3407 = root_new ['parrot';'Hash']
  vivify_1738:
    set $P3408, $P3407["xblock"]
    unless_null $P3408, vivify_1739
    new $P3408, "Undef"
  vivify_1739:
    $P3409 = $P3408."ast"()
    $P3410 = "xblock_immediate"($P3409)
    store_lex "$past", $P3410
.annotate 'line', 1011
    find_lex $P3411, "$past"
    unless_null $P3411, vivify_1740
    new $P3411, "Undef"
  vivify_1740:
    find_lex $P3412, "$/"
    unless_null $P3412, vivify_1741
    $P3412 = root_new ['parrot';'Hash']
  vivify_1741:
    set $P3413, $P3412["sym"]
    unless_null $P3413, vivify_1742
    new $P3413, "Undef"
  vivify_1742:
    set $S3414, $P3413
    $P3411."pasttype"($S3414)
.annotate 'line', 1012
    find_lex $P3415, "$/"
    find_lex $P3416, "$past"
    unless_null $P3416, vivify_1743
    new $P3416, "Undef"
  vivify_1743:
    $P3417 = $P3415."!make"($P3416)
.annotate 'line', 1009
    .return ($P3417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("448_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3419
    .param pmc param_3420
.annotate 'line', 1015
    .lex "self", param_3419
    .lex "$/", param_3420
.annotate 'line', 1016
    new $P3421, "Undef"
    .lex "$pasttype", $P3421
.annotate 'line', 1017
    new $P3422, "Undef"
    .lex "$past", $P3422
.annotate 'line', 1016
    new $P3423, "String"
    assign $P3423, "repeat_"
    find_lex $P3424, "$/"
    unless_null $P3424, vivify_1744
    $P3424 = root_new ['parrot';'Hash']
  vivify_1744:
    set $P3425, $P3424["wu"]
    unless_null $P3425, vivify_1745
    new $P3425, "Undef"
  vivify_1745:
    set $S3426, $P3425
    concat $P3427, $P3423, $S3426
    store_lex "$pasttype", $P3427
    find_lex $P3428, "$past"
    unless_null $P3428, vivify_1746
    new $P3428, "Undef"
  vivify_1746:
.annotate 'line', 1018
    find_lex $P3430, "$/"
    unless_null $P3430, vivify_1747
    $P3430 = root_new ['parrot';'Hash']
  vivify_1747:
    set $P3431, $P3430["xblock"]
    unless_null $P3431, vivify_1748
    new $P3431, "Undef"
  vivify_1748:
    if $P3431, if_3429
.annotate 'line', 1023
    get_hll_global $P3438, ["PAST"], "Op"
    find_lex $P3439, "$/"
    unless_null $P3439, vivify_1749
    $P3439 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P3440, $P3439["EXPR"]
    unless_null $P3440, vivify_1750
    new $P3440, "Undef"
  vivify_1750:
    $P3441 = $P3440."ast"()
    find_lex $P3442, "$/"
    unless_null $P3442, vivify_1751
    $P3442 = root_new ['parrot';'Hash']
  vivify_1751:
    set $P3443, $P3442["pblock"]
    unless_null $P3443, vivify_1752
    new $P3443, "Undef"
  vivify_1752:
    $P3444 = $P3443."ast"()
    $P3445 = "block_immediate"($P3444)
    find_lex $P3446, "$pasttype"
    unless_null $P3446, vivify_1753
    new $P3446, "Undef"
  vivify_1753:
    find_lex $P3447, "$/"
    unless_null $P3447, vivify_1754
    new $P3447, "Undef"
  vivify_1754:
    $P3448 = $P3438."new"($P3441, $P3445, $P3446 :named("pasttype"), $P3447 :named("node"))
    store_lex "$past", $P3448
.annotate 'line', 1022
    goto if_3429_end
  if_3429:
.annotate 'line', 1019
    find_lex $P3432, "$/"
    unless_null $P3432, vivify_1755
    $P3432 = root_new ['parrot';'Hash']
  vivify_1755:
    set $P3433, $P3432["xblock"]
    unless_null $P3433, vivify_1756
    new $P3433, "Undef"
  vivify_1756:
    $P3434 = $P3433."ast"()
    $P3435 = "xblock_immediate"($P3434)
    store_lex "$past", $P3435
.annotate 'line', 1020
    find_lex $P3436, "$past"
    unless_null $P3436, vivify_1757
    new $P3436, "Undef"
  vivify_1757:
    find_lex $P3437, "$pasttype"
    unless_null $P3437, vivify_1758
    new $P3437, "Undef"
  vivify_1758:
    $P3436."pasttype"($P3437)
  if_3429_end:
.annotate 'line', 1026
    find_lex $P3449, "$/"
    find_lex $P3450, "$past"
    unless_null $P3450, vivify_1759
    new $P3450, "Undef"
  vivify_1759:
    $P3451 = $P3449."!make"($P3450)
.annotate 'line', 1015
    .return ($P3451)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("449_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3453
    .param pmc param_3454
.annotate 'line', 1029
    .lex "self", param_3453
    .lex "$/", param_3454
.annotate 'line', 1030
    new $P3455, "Undef"
    .lex "$past", $P3455
.annotate 'line', 1032
    new $P3456, "Undef"
    .lex "$block", $P3456
.annotate 'line', 1030
    find_lex $P3457, "$/"
    unless_null $P3457, vivify_1760
    $P3457 = root_new ['parrot';'Hash']
  vivify_1760:
    set $P3458, $P3457["xblock"]
    unless_null $P3458, vivify_1761
    new $P3458, "Undef"
  vivify_1761:
    $P3459 = $P3458."ast"()
    store_lex "$past", $P3459
.annotate 'line', 1031
    find_lex $P3460, "$past"
    unless_null $P3460, vivify_1762
    new $P3460, "Undef"
  vivify_1762:
    $P3460."pasttype"("for")
.annotate 'line', 1032
    find_lex $P3461, "$past"
    unless_null $P3461, vivify_1763
    $P3461 = root_new ['parrot';'ResizablePMCArray']
  vivify_1763:
    set $P3462, $P3461[1]
    unless_null $P3462, vivify_1764
    new $P3462, "Undef"
  vivify_1764:
    store_lex "$block", $P3462
.annotate 'line', 1033
    find_lex $P3464, "$block"
    unless_null $P3464, vivify_1765
    new $P3464, "Undef"
  vivify_1765:
    $P3465 = $P3464."arity"()
    if $P3465, unless_3463_end
.annotate 'line', 1034
    find_lex $P3466, "$block"
    unless_null $P3466, vivify_1766
    $P3466 = root_new ['parrot';'ResizablePMCArray']
  vivify_1766:
    set $P3467, $P3466[0]
    unless_null $P3467, vivify_1767
    new $P3467, "Undef"
  vivify_1767:
    get_hll_global $P3468, ["PAST"], "Var"
    $P3469 = $P3468."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3467."push"($P3469)
.annotate 'line', 1035
    find_lex $P3470, "$block"
    unless_null $P3470, vivify_1768
    new $P3470, "Undef"
  vivify_1768:
    $P3470."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1036
    find_lex $P3471, "$block"
    unless_null $P3471, vivify_1769
    new $P3471, "Undef"
  vivify_1769:
    $P3471."arity"(1)
  unless_3463_end:
.annotate 'line', 1038
    find_lex $P3472, "$block"
    unless_null $P3472, vivify_1770
    new $P3472, "Undef"
  vivify_1770:
    $P3472."blocktype"("immediate")
.annotate 'line', 1039
    find_lex $P3473, "$/"
    find_lex $P3474, "$past"
    unless_null $P3474, vivify_1771
    new $P3474, "Undef"
  vivify_1771:
    $P3475 = $P3473."!make"($P3474)
.annotate 'line', 1029
    .return ($P3475)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("450_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3477
    .param pmc param_3478
.annotate 'line', 1042
    .lex "self", param_3477
    .lex "$/", param_3478
.annotate 'line', 1043
    new $P3479, "Undef"
    .lex "$block", $P3479
    find_lex $P3480, "$/"
    unless_null $P3480, vivify_1772
    $P3480 = root_new ['parrot';'Hash']
  vivify_1772:
    set $P3481, $P3480["block"]
    unless_null $P3481, vivify_1773
    new $P3481, "Undef"
  vivify_1773:
    $P3482 = $P3481."ast"()
    store_lex "$block", $P3482
.annotate 'line', 1044
    find_lex $P3483, "$/"
    unless_null $P3483, vivify_1774
    new $P3483, "Undef"
  vivify_1774:
    find_lex $P3484, "$block"
    unless_null $P3484, vivify_1775
    new $P3484, "Undef"
  vivify_1775:
    "push_block_handler"($P3483, $P3484)
.annotate 'line', 1045
    find_lex $P3485, "$?PACKAGE"
    get_who $P3486, $P3485
    set $P3487, $P3486["@BLOCK"]
    unless_null $P3487, vivify_1776
    $P3487 = root_new ['parrot';'ResizablePMCArray']
  vivify_1776:
    set $P3488, $P3487[0]
    unless_null $P3488, vivify_1777
    new $P3488, "Undef"
  vivify_1777:
    $P3489 = $P3488."handlers"()
    set $P3490, $P3489[0]
    unless_null $P3490, vivify_1778
    new $P3490, "Undef"
  vivify_1778:
    $P3490."handle_types_except"("CONTROL")
.annotate 'line', 1046
    find_lex $P3491, "$/"
    get_hll_global $P3492, ["PAST"], "Stmts"
    find_lex $P3493, "$/"
    unless_null $P3493, vivify_1779
    new $P3493, "Undef"
  vivify_1779:
    $P3494 = $P3492."new"($P3493 :named("node"))
    $P3495 = $P3491."!make"($P3494)
.annotate 'line', 1042
    .return ($P3495)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("451_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3497
    .param pmc param_3498
.annotate 'line', 1049
    .lex "self", param_3497
    .lex "$/", param_3498
.annotate 'line', 1050
    new $P3499, "Undef"
    .lex "$block", $P3499
    find_lex $P3500, "$/"
    unless_null $P3500, vivify_1780
    $P3500 = root_new ['parrot';'Hash']
  vivify_1780:
    set $P3501, $P3500["block"]
    unless_null $P3501, vivify_1781
    new $P3501, "Undef"
  vivify_1781:
    $P3502 = $P3501."ast"()
    store_lex "$block", $P3502
.annotate 'line', 1051
    find_lex $P3503, "$/"
    unless_null $P3503, vivify_1782
    new $P3503, "Undef"
  vivify_1782:
    find_lex $P3504, "$block"
    unless_null $P3504, vivify_1783
    new $P3504, "Undef"
  vivify_1783:
    "push_block_handler"($P3503, $P3504)
.annotate 'line', 1052
    find_lex $P3505, "$?PACKAGE"
    get_who $P3506, $P3505
    set $P3507, $P3506["@BLOCK"]
    unless_null $P3507, vivify_1784
    $P3507 = root_new ['parrot';'ResizablePMCArray']
  vivify_1784:
    set $P3508, $P3507[0]
    unless_null $P3508, vivify_1785
    new $P3508, "Undef"
  vivify_1785:
    $P3509 = $P3508."handlers"()
    set $P3510, $P3509[0]
    unless_null $P3510, vivify_1786
    new $P3510, "Undef"
  vivify_1786:
    $P3510."handle_types"("CONTROL")
.annotate 'line', 1053
    find_lex $P3511, "$/"
    get_hll_global $P3512, ["PAST"], "Stmts"
    find_lex $P3513, "$/"
    unless_null $P3513, vivify_1787
    new $P3513, "Undef"
  vivify_1787:
    $P3514 = $P3512."new"($P3513 :named("node"))
    $P3515 = $P3511."!make"($P3514)
.annotate 'line', 1049
    .return ($P3515)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("452_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3518
    .param pmc param_3519
.annotate 'line', 1093
    .lex "self", param_3518
    .lex "$/", param_3519
.annotate 'line', 1094
    find_lex $P3520, "$?PACKAGE"
    get_who $P3521, $P3520
    set $P3522, $P3521["@BLOCK"]
    unless_null $P3522, vivify_1788
    $P3522 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    set $P3523, $P3522[0]
    unless_null $P3523, vivify_1789
    new $P3523, "Undef"
  vivify_1789:
    find_lex $P3524, "$/"
    unless_null $P3524, vivify_1790
    $P3524 = root_new ['parrot';'Hash']
  vivify_1790:
    set $P3525, $P3524["blorst"]
    unless_null $P3525, vivify_1791
    new $P3525, "Undef"
  vivify_1791:
    $P3526 = $P3525."ast"()
    $P3523."push"($P3526)
.annotate 'line', 1095
    find_lex $P3527, "$/"
    get_hll_global $P3528, ["PAST"], "Stmts"
    $P3529 = $P3528."new"()
    $P3530 = $P3527."!make"($P3529)
.annotate 'line', 1093
    .return ($P3530)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("453_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3532
    .param pmc param_3533
.annotate 'line', 1098
    .lex "self", param_3532
    .lex "$/", param_3533
.annotate 'line', 1099
    new $P3534, "Undef"
    .lex "$past", $P3534
    find_lex $P3535, "$/"
    unless_null $P3535, vivify_1792
    $P3535 = root_new ['parrot';'Hash']
  vivify_1792:
    set $P3536, $P3535["blorst"]
    unless_null $P3536, vivify_1793
    new $P3536, "Undef"
  vivify_1793:
    $P3537 = $P3536."ast"()
    store_lex "$past", $P3537
.annotate 'line', 1100
    get_hll_global $P3539, ["PAST"], "Block"
    find_lex $P3540, "$past"
    unless_null $P3540, vivify_1794
    new $P3540, "Undef"
  vivify_1794:
    $P3541 = $P3539."ACCEPTS"($P3540)
    if $P3541, unless_3538_end
.annotate 'line', 1101
    get_hll_global $P3542, ["PAST"], "Block"
    find_lex $P3543, "$past"
    unless_null $P3543, vivify_1795
    new $P3543, "Undef"
  vivify_1795:
    find_lex $P3544, "$/"
    unless_null $P3544, vivify_1796
    new $P3544, "Undef"
  vivify_1796:
    $P3545 = $P3542."new"($P3543, "immediate" :named("blocktype"), $P3544 :named("node"))
    store_lex "$past", $P3545
  unless_3538_end:
.annotate 'line', 1103
    find_lex $P3547, "$past"
    unless_null $P3547, vivify_1797
    new $P3547, "Undef"
  vivify_1797:
    $P3548 = $P3547."handlers"()
    if $P3548, unless_3546_end
.annotate 'line', 1104
    find_lex $P3549, "$past"
    unless_null $P3549, vivify_1798
    new $P3549, "Undef"
  vivify_1798:
    get_hll_global $P3550, ["PAST"], "Control"
.annotate 'line', 1106
    get_hll_global $P3551, ["PAST"], "Stmts"
.annotate 'line', 1107
    get_hll_global $P3552, ["PAST"], "Op"
.annotate 'line', 1108
    get_hll_global $P3553, ["PAST"], "Var"
.annotate 'line', 1109
    get_hll_global $P3554, ["PAST"], "Var"
    $P3555 = $P3554."new"("register" :named("scope"), "exception" :named("name"))
    $P3556 = $P3553."new"($P3555, "handled", "keyed" :named("scope"))
.annotate 'line', 1108
    $P3557 = $P3552."new"($P3556, 1, "bind" :named("pasttype"))
.annotate 'line', 1107
    $P3558 = $P3551."new"($P3557)
.annotate 'line', 1106
    $P3559 = $P3550."new"($P3558, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1104
    new $P3560, "ResizablePMCArray"
    push $P3560, $P3559
    $P3549."handlers"($P3560)
  unless_3546_end:
.annotate 'line', 1118
    find_lex $P3561, "$/"
    find_lex $P3562, "$past"
    unless_null $P3562, vivify_1799
    new $P3562, "Undef"
  vivify_1799:
    $P3563 = $P3561."!make"($P3562)
.annotate 'line', 1098
    .return ($P3563)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("454_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3565
    .param pmc param_3566
.annotate 'line', 1121
    .lex "self", param_3565
    .lex "$/", param_3566
.annotate 'line', 1122
    find_lex $P3567, "$/"
.annotate 'line', 1123
    find_lex $P3570, "$/"
    unless_null $P3570, vivify_1800
    $P3570 = root_new ['parrot';'Hash']
  vivify_1800:
    set $P3571, $P3570["block"]
    unless_null $P3571, vivify_1801
    new $P3571, "Undef"
  vivify_1801:
    if $P3571, if_3569
.annotate 'line', 1124
    find_lex $P3576, "$/"
    unless_null $P3576, vivify_1802
    $P3576 = root_new ['parrot';'Hash']
  vivify_1802:
    set $P3577, $P3576["statement"]
    unless_null $P3577, vivify_1803
    new $P3577, "Undef"
  vivify_1803:
    $P3578 = $P3577."ast"()
    set $P3568, $P3578
.annotate 'line', 1123
    goto if_3569_end
  if_3569:
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_1804
    $P3572 = root_new ['parrot';'Hash']
  vivify_1804:
    set $P3573, $P3572["block"]
    unless_null $P3573, vivify_1805
    new $P3573, "Undef"
  vivify_1805:
    $P3574 = $P3573."ast"()
    $P3575 = "block_immediate"($P3574)
    set $P3568, $P3575
  if_3569_end:
    $P3579 = $P3567."!make"($P3568)
.annotate 'line', 1121
    .return ($P3579)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("455_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3581
    .param pmc param_3582
.annotate 'line', 1129
    .lex "self", param_3581
    .lex "$/", param_3582
    find_lex $P3583, "$/"
    find_lex $P3584, "$/"
    unless_null $P3584, vivify_1806
    $P3584 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3585, $P3584["cond"]
    unless_null $P3585, vivify_1807
    new $P3585, "Undef"
  vivify_1807:
    $P3586 = $P3585."ast"()
    $P3587 = $P3583."!make"($P3586)
    .return ($P3587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("456_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3589
    .param pmc param_3590
.annotate 'line', 1130
    .lex "self", param_3589
    .lex "$/", param_3590
    find_lex $P3591, "$/"
    find_lex $P3592, "$/"
    unless_null $P3592, vivify_1808
    $P3592 = root_new ['parrot';'Hash']
  vivify_1808:
    set $P3593, $P3592["cond"]
    unless_null $P3593, vivify_1809
    new $P3593, "Undef"
  vivify_1809:
    $P3594 = $P3593."ast"()
    $P3595 = $P3591."!make"($P3594)
    .return ($P3595)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("457_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3597
    .param pmc param_3598
.annotate 'line', 1132
    .lex "self", param_3597
    .lex "$/", param_3598
    find_lex $P3599, "$/"
    find_lex $P3600, "$/"
    unless_null $P3600, vivify_1810
    $P3600 = root_new ['parrot';'Hash']
  vivify_1810:
    set $P3601, $P3600["cond"]
    unless_null $P3601, vivify_1811
    new $P3601, "Undef"
  vivify_1811:
    $P3602 = $P3601."ast"()
    $P3603 = $P3599."!make"($P3602)
    .return ($P3603)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("458_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3605
    .param pmc param_3606
.annotate 'line', 1133
    .lex "self", param_3605
    .lex "$/", param_3606
    find_lex $P3607, "$/"
    find_lex $P3608, "$/"
    unless_null $P3608, vivify_1812
    $P3608 = root_new ['parrot';'Hash']
  vivify_1812:
    set $P3609, $P3608["cond"]
    unless_null $P3609, vivify_1813
    new $P3609, "Undef"
  vivify_1813:
    $P3610 = $P3609."ast"()
    $P3611 = $P3607."!make"($P3610)
    .return ($P3611)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("459_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3613
    .param pmc param_3614
.annotate 'line', 1137
    .lex "self", param_3613
    .lex "$/", param_3614
    find_lex $P3615, "$/"
    find_lex $P3616, "$/"
    unless_null $P3616, vivify_1814
    $P3616 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3617, $P3616["fatarrow"]
    unless_null $P3617, vivify_1815
    new $P3617, "Undef"
  vivify_1815:
    $P3618 = $P3617."ast"()
    $P3619 = $P3615."!make"($P3618)
    .return ($P3619)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("460_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3621
    .param pmc param_3622
.annotate 'line', 1138
    .lex "self", param_3621
    .lex "$/", param_3622
    find_lex $P3623, "$/"
    find_lex $P3624, "$/"
    unless_null $P3624, vivify_1816
    $P3624 = root_new ['parrot';'Hash']
  vivify_1816:
    set $P3625, $P3624["colonpair"]
    unless_null $P3625, vivify_1817
    new $P3625, "Undef"
  vivify_1817:
    $P3626 = $P3625."ast"()
    $P3627 = $P3623."!make"($P3626)
    .return ($P3627)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("461_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3629
    .param pmc param_3630
.annotate 'line', 1139
    .lex "self", param_3629
    .lex "$/", param_3630
    find_lex $P3631, "$/"
    find_lex $P3632, "$/"
    unless_null $P3632, vivify_1818
    $P3632 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P3633, $P3632["variable"]
    unless_null $P3633, vivify_1819
    new $P3633, "Undef"
  vivify_1819:
    $P3634 = $P3633."ast"()
    $P3635 = $P3631."!make"($P3634)
    .return ($P3635)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("462_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3637
    .param pmc param_3638
.annotate 'line', 1140
    .lex "self", param_3637
    .lex "$/", param_3638
    find_lex $P3639, "$/"
    find_lex $P3640, "$/"
    unless_null $P3640, vivify_1820
    $P3640 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P3641, $P3640["package_declarator"]
    unless_null $P3641, vivify_1821
    new $P3641, "Undef"
  vivify_1821:
    $P3642 = $P3641."ast"()
    $P3643 = $P3639."!make"($P3642)
    .return ($P3643)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("463_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3645
    .param pmc param_3646
.annotate 'line', 1141
    .lex "self", param_3645
    .lex "$/", param_3646
    find_lex $P3647, "$/"
    find_lex $P3648, "$/"
    unless_null $P3648, vivify_1822
    $P3648 = root_new ['parrot';'Hash']
  vivify_1822:
    set $P3649, $P3648["scope_declarator"]
    unless_null $P3649, vivify_1823
    new $P3649, "Undef"
  vivify_1823:
    $P3650 = $P3649."ast"()
    $P3651 = $P3647."!make"($P3650)
    .return ($P3651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("464_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3653
    .param pmc param_3654
.annotate 'line', 1142
    .lex "self", param_3653
    .lex "$/", param_3654
    find_lex $P3655, "$/"
    find_lex $P3656, "$/"
    unless_null $P3656, vivify_1824
    $P3656 = root_new ['parrot';'Hash']
  vivify_1824:
    set $P3657, $P3656["routine_declarator"]
    unless_null $P3657, vivify_1825
    new $P3657, "Undef"
  vivify_1825:
    $P3658 = $P3657."ast"()
    $P3659 = $P3655."!make"($P3658)
    .return ($P3659)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("465_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3661
    .param pmc param_3662
.annotate 'line', 1143
    .lex "self", param_3661
    .lex "$/", param_3662
    find_lex $P3663, "$/"
    find_lex $P3664, "$/"
    unless_null $P3664, vivify_1826
    $P3664 = root_new ['parrot';'Hash']
  vivify_1826:
    set $P3665, $P3664["regex_declarator"]
    unless_null $P3665, vivify_1827
    new $P3665, "Undef"
  vivify_1827:
    $P3666 = $P3665."ast"()
    $P3667 = $P3663."!make"($P3666)
    .return ($P3667)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("466_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3669
    .param pmc param_3670
.annotate 'line', 1144
    .lex "self", param_3669
    .lex "$/", param_3670
    find_lex $P3671, "$/"
    find_lex $P3672, "$/"
    unless_null $P3672, vivify_1828
    $P3672 = root_new ['parrot';'Hash']
  vivify_1828:
    set $P3673, $P3672["statement_prefix"]
    unless_null $P3673, vivify_1829
    new $P3673, "Undef"
  vivify_1829:
    $P3674 = $P3673."ast"()
    $P3675 = $P3671."!make"($P3674)
    .return ($P3675)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("467_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3677
    .param pmc param_3678
.annotate 'line', 1145
    .lex "self", param_3677
    .lex "$/", param_3678
    find_lex $P3679, "$/"
    find_lex $P3680, "$/"
    unless_null $P3680, vivify_1830
    $P3680 = root_new ['parrot';'Hash']
  vivify_1830:
    set $P3681, $P3680["pblock"]
    unless_null $P3681, vivify_1831
    new $P3681, "Undef"
  vivify_1831:
    $P3682 = $P3681."ast"()
    $P3683 = $P3679."!make"($P3682)
    .return ($P3683)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("468_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3685
    .param pmc param_3686
.annotate 'line', 1147
    .lex "self", param_3685
    .lex "$/", param_3686
.annotate 'line', 1148
    new $P3687, "Undef"
    .lex "$past", $P3687
    find_lex $P3688, "$/"
    unless_null $P3688, vivify_1832
    $P3688 = root_new ['parrot';'Hash']
  vivify_1832:
    set $P3689, $P3688["val"]
    unless_null $P3689, vivify_1833
    new $P3689, "Undef"
  vivify_1833:
    $P3690 = $P3689."ast"()
    store_lex "$past", $P3690
.annotate 'line', 1149
    find_lex $P3691, "$past"
    unless_null $P3691, vivify_1834
    new $P3691, "Undef"
  vivify_1834:
    find_lex $P3692, "$/"
    unless_null $P3692, vivify_1835
    $P3692 = root_new ['parrot';'Hash']
  vivify_1835:
    set $P3693, $P3692["key"]
    unless_null $P3693, vivify_1836
    new $P3693, "Undef"
  vivify_1836:
    $P3694 = $P3693."Str"()
    $P3691."named"($P3694)
.annotate 'line', 1150
    find_lex $P3695, "$/"
    find_lex $P3696, "$past"
    unless_null $P3696, vivify_1837
    new $P3696, "Undef"
  vivify_1837:
    $P3697 = $P3695."!make"($P3696)
.annotate 'line', 1147
    .return ($P3697)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("469_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3699
    .param pmc param_3700
.annotate 'line', 1153
    .lex "self", param_3699
    .lex "$/", param_3700
.annotate 'line', 1154
    new $P3701, "Undef"
    .lex "$past", $P3701
.annotate 'line', 1155
    find_lex $P3704, "$/"
    unless_null $P3704, vivify_1838
    $P3704 = root_new ['parrot';'Hash']
  vivify_1838:
    set $P3705, $P3704["circumfix"]
    unless_null $P3705, vivify_1839
    new $P3705, "Undef"
  vivify_1839:
    if $P3705, if_3703
.annotate 'line', 1156
    get_hll_global $P3710, ["PAST"], "Val"
    find_lex $P3711, "$/"
    unless_null $P3711, vivify_1840
    $P3711 = root_new ['parrot';'Hash']
  vivify_1840:
    set $P3712, $P3711["not"]
    unless_null $P3712, vivify_1841
    new $P3712, "Undef"
  vivify_1841:
    isfalse $I3713, $P3712
    $P3714 = $P3710."new"($I3713 :named("value"))
    set $P3702, $P3714
.annotate 'line', 1155
    goto if_3703_end
  if_3703:
    find_lex $P3706, "$/"
    unless_null $P3706, vivify_1842
    $P3706 = root_new ['parrot';'Hash']
  vivify_1842:
    set $P3707, $P3706["circumfix"]
    unless_null $P3707, vivify_1843
    $P3707 = root_new ['parrot';'ResizablePMCArray']
  vivify_1843:
    set $P3708, $P3707[0]
    unless_null $P3708, vivify_1844
    new $P3708, "Undef"
  vivify_1844:
    $P3709 = $P3708."ast"()
    set $P3702, $P3709
  if_3703_end:
    store_lex "$past", $P3702
.annotate 'line', 1157
    find_lex $P3715, "$past"
    unless_null $P3715, vivify_1845
    new $P3715, "Undef"
  vivify_1845:
    find_lex $P3716, "$/"
    unless_null $P3716, vivify_1846
    $P3716 = root_new ['parrot';'Hash']
  vivify_1846:
    set $P3717, $P3716["identifier"]
    unless_null $P3717, vivify_1847
    new $P3717, "Undef"
  vivify_1847:
    set $S3718, $P3717
    $P3715."named"($S3718)
.annotate 'line', 1158
    find_lex $P3719, "$/"
    find_lex $P3720, "$past"
    unless_null $P3720, vivify_1848
    new $P3720, "Undef"
  vivify_1848:
    $P3721 = $P3719."!make"($P3720)
.annotate 'line', 1153
    .return ($P3721)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("470_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3723
    .param pmc param_3724
.annotate 'line', 1161
    .const 'Sub' $P3737 = "471_1303430322.161" 
    capture_lex $P3737
    .lex "self", param_3723
    .lex "$/", param_3724
.annotate 'line', 1162
    new $P3725, "Undef"
    .lex "$past", $P3725
.annotate 'line', 1161
    find_lex $P3726, "$past"
    unless_null $P3726, vivify_1849
    new $P3726, "Undef"
  vivify_1849:
.annotate 'line', 1163
    find_lex $P3728, "$/"
    unless_null $P3728, vivify_1850
    $P3728 = root_new ['parrot';'Hash']
  vivify_1850:
    set $P3729, $P3728["postcircumfix"]
    unless_null $P3729, vivify_1851
    new $P3729, "Undef"
  vivify_1851:
    if $P3729, if_3727
.annotate 'line', 1167
    .const 'Sub' $P3737 = "471_1303430322.161" 
    capture_lex $P3737
    $P3737()
    goto if_3727_end
  if_3727:
.annotate 'line', 1164
    find_lex $P3730, "$/"
    unless_null $P3730, vivify_1887
    $P3730 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3731, $P3730["postcircumfix"]
    unless_null $P3731, vivify_1888
    new $P3731, "Undef"
  vivify_1888:
    $P3732 = $P3731."ast"()
    store_lex "$past", $P3732
.annotate 'line', 1165
    find_lex $P3733, "$past"
    unless_null $P3733, vivify_1889
    new $P3733, "Undef"
  vivify_1889:
    get_hll_global $P3734, ["PAST"], "Var"
    $P3735 = $P3734."new"("$/" :named("name"))
    $P3733."unshift"($P3735)
  if_3727_end:
.annotate 'line', 1209
    find_lex $P3830, "$/"
    find_lex $P3831, "$past"
    unless_null $P3831, vivify_1890
    new $P3831, "Undef"
  vivify_1890:
    $P3832 = $P3830."!make"($P3831)
.annotate 'line', 1161
    .return ($P3832)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3736"  :anon :subid("471_1303430322.161") :outer("470_1303430322.161")
.annotate 'line', 1168
    $P3738 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3738
    get_hll_global $P3739, ["NQP"], "Compiler"
    find_lex $P3740, "$/"
    unless_null $P3740, vivify_1852
    new $P3740, "Undef"
  vivify_1852:
    set $S3741, $P3740
    $P3742 = $P3739."parse_name"($S3741)
    store_lex "@name", $P3742
.annotate 'line', 1169
    find_lex $P3745, "@name"
    unless_null $P3745, vivify_1853
    $P3745 = root_new ['parrot';'ResizablePMCArray']
  vivify_1853:
    set $N3746, $P3745
    isgt $I3747, $N3746, 1.0
    if $I3747, if_3744
.annotate 'line', 1176
    find_lex $P3763, "$/"
    unless_null $P3763, vivify_1854
    $P3763 = root_new ['parrot';'Hash']
  vivify_1854:
    set $P3764, $P3763["twigil"]
    unless_null $P3764, vivify_1855
    $P3764 = root_new ['parrot';'ResizablePMCArray']
  vivify_1855:
    set $P3765, $P3764[0]
    unless_null $P3765, vivify_1856
    new $P3765, "Undef"
  vivify_1856:
    set $S3766, $P3765
    iseq $I3767, $S3766, "*"
    if $I3767, if_3762
.annotate 'line', 1191
    find_lex $P3791, "$/"
    unless_null $P3791, vivify_1857
    $P3791 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3792, $P3791["twigil"]
    unless_null $P3792, vivify_1858
    $P3792 = root_new ['parrot';'ResizablePMCArray']
  vivify_1858:
    set $P3793, $P3792[0]
    unless_null $P3793, vivify_1859
    new $P3793, "Undef"
  vivify_1859:
    set $S3794, $P3793
    iseq $I3795, $S3794, "!"
    if $I3795, if_3790
.annotate 'line', 1199
    find_lex $P3810, "@name"
    unless_null $P3810, vivify_1860
    $P3810 = root_new ['parrot';'ResizablePMCArray']
  vivify_1860:
    set $P3811, $P3810[0]
    unless_null $P3811, vivify_1861
    new $P3811, "Undef"
  vivify_1861:
    set $S3812, $P3811
    $P3813 = "is_package"($S3812)
    if $P3813, if_3809
.annotate 'line', 1204
    get_hll_global $P3822, ["PAST"], "Var"
.annotate 'line', 1205
    find_lex $P3823, "@name"
    unless_null $P3823, vivify_1862
    $P3823 = root_new ['parrot';'ResizablePMCArray']
  vivify_1862:
    $P3824 = $P3823."pop"()
    set $S3825, $P3824
    find_lex $P3826, "$/"
    unless_null $P3826, vivify_1863
    $P3826 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3827, $P3826["sigil"]
    unless_null $P3827, vivify_1864
    new $P3827, "Undef"
  vivify_1864:
    $P3828 = "vivitype"($P3827)
    $P3829 = $P3822."new"($S3825 :named("name"), $P3828 :named("viviself"))
.annotate 'line', 1204
    store_lex "$past", $P3829
.annotate 'line', 1203
    set $P3808, $P3829
.annotate 'line', 1199
    goto if_3809_end
  if_3809:
.annotate 'line', 1200
    find_lex $P3814, "@name"
    unless_null $P3814, vivify_1865
    $P3814 = root_new ['parrot';'ResizablePMCArray']
  vivify_1865:
    find_lex $P3815, "$/"
    unless_null $P3815, vivify_1866
    new $P3815, "Undef"
  vivify_1866:
    $P3816 = "lexical_package_lookup"($P3814, $P3815)
    store_lex "$past", $P3816
.annotate 'line', 1201
    find_lex $P3817, "$past"
    unless_null $P3817, vivify_1867
    new $P3817, "Undef"
  vivify_1867:
    find_lex $P3818, "$/"
    unless_null $P3818, vivify_1868
    $P3818 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P3819, $P3818["sigil"]
    unless_null $P3819, vivify_1869
    new $P3819, "Undef"
  vivify_1869:
    $P3820 = "vivitype"($P3819)
    $P3821 = $P3817."viviself"($P3820)
.annotate 'line', 1199
    set $P3808, $P3821
  if_3809_end:
    set $P3789, $P3808
.annotate 'line', 1191
    goto if_3790_end
  if_3790:
.annotate 'line', 1192
    get_hll_global $P3796, ["PAST"], "Var"
.annotate 'line', 1193
    find_lex $P3797, "@name"
    unless_null $P3797, vivify_1870
    $P3797 = root_new ['parrot';'ResizablePMCArray']
  vivify_1870:
    $P3798 = $P3797."pop"()
    set $S3799, $P3798
.annotate 'line', 1194
    find_lex $P3800, "$/"
    unless_null $P3800, vivify_1871
    $P3800 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P3801, $P3800["sigil"]
    unless_null $P3801, vivify_1872
    new $P3801, "Undef"
  vivify_1872:
    $P3802 = "vivitype"($P3801)
.annotate 'line', 1195
    get_hll_global $P3803, ["PAST"], "Var"
    $P3804 = $P3803."new"("self" :named("name"))
.annotate 'line', 1196
    get_hll_global $P3805, ["PAST"], "Var"
    $P3806 = $P3805."new"("$?CLASS" :named("name"))
    $P3807 = $P3796."new"($P3804, $P3806, $S3799 :named("name"), "attribute" :named("scope"), $P3802 :named("viviself"))
.annotate 'line', 1192
    store_lex "$past", $P3807
.annotate 'line', 1191
    set $P3789, $P3807
  if_3790_end:
    set $P3761, $P3789
.annotate 'line', 1176
    goto if_3762_end
  if_3762:
.annotate 'line', 1177
    get_hll_global $P3768, ["PAST"], "Var"
.annotate 'line', 1178
    find_lex $P3769, "@name"
    unless_null $P3769, vivify_1873
    $P3769 = root_new ['parrot';'ResizablePMCArray']
  vivify_1873:
    $P3770 = $P3769."pop"()
    set $S3771, $P3770
.annotate 'line', 1180
    get_hll_global $P3772, ["PAST"], "Var"
.annotate 'line', 1182
    find_lex $P3773, "$/"
    unless_null $P3773, vivify_1874
    $P3773 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P3774, $P3773["sigil"]
    unless_null $P3774, vivify_1875
    new $P3774, "Undef"
  vivify_1875:
    set $S3775, $P3774
    new $P3776, 'String'
    set $P3776, $S3775
    find_lex $P3777, "$/"
    unless_null $P3777, vivify_1876
    $P3777 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P3778, $P3777["desigilname"]
    unless_null $P3778, vivify_1877
    new $P3778, "Undef"
  vivify_1877:
    concat $P3779, $P3776, $P3778
.annotate 'line', 1184
    get_hll_global $P3780, ["PAST"], "Op"
    new $P3781, "String"
    assign $P3781, "Contextual "
    find_lex $P3782, "$/"
    unless_null $P3782, vivify_1878
    new $P3782, "Undef"
  vivify_1878:
    set $S3783, $P3782
    concat $P3784, $P3781, $S3783
    concat $P3785, $P3784, " not found"
    $P3786 = $P3780."new"($P3785, "die" :named("pirop"))
    $P3787 = $P3772."new"("package" :named("scope"), "" :named("namespace"), $P3779 :named("name"), $P3786 :named("viviself"))
.annotate 'line', 1180
    $P3788 = $P3768."new"($S3771 :named("name"), "contextual" :named("scope"), $P3787 :named("viviself"))
.annotate 'line', 1177
    store_lex "$past", $P3788
.annotate 'line', 1176
    set $P3761, $P3788
  if_3762_end:
    set $P3743, $P3761
.annotate 'line', 1169
    goto if_3744_end
  if_3744:
.annotate 'line', 1170
    find_lex $P3749, "$/"
    unless_null $P3749, vivify_1879
    $P3749 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P3750, $P3749["twigil"]
    unless_null $P3750, vivify_1880
    new $P3750, "Undef"
  vivify_1880:
    unless $P3750, if_3748_end
.annotate 'line', 1171
    find_lex $P3751, "$/"
    unless_null $P3751, vivify_1881
    new $P3751, "Undef"
  vivify_1881:
    $P3752 = $P3751."CURSOR"()
    $P3752."panic"("Twigil not allowed on multi-part name")
  if_3748_end:
.annotate 'line', 1173
    find_lex $P3753, "@name"
    unless_null $P3753, vivify_1882
    $P3753 = root_new ['parrot';'ResizablePMCArray']
  vivify_1882:
    find_lex $P3754, "$/"
    unless_null $P3754, vivify_1883
    new $P3754, "Undef"
  vivify_1883:
    $P3755 = "lexical_package_lookup"($P3753, $P3754)
    store_lex "$past", $P3755
.annotate 'line', 1174
    find_lex $P3756, "$past"
    unless_null $P3756, vivify_1884
    new $P3756, "Undef"
  vivify_1884:
    find_lex $P3757, "$/"
    unless_null $P3757, vivify_1885
    $P3757 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P3758, $P3757["sigil"]
    unless_null $P3758, vivify_1886
    new $P3758, "Undef"
  vivify_1886:
    $P3759 = "vivitype"($P3758)
    $P3760 = $P3756."viviself"($P3759)
.annotate 'line', 1169
    set $P3743, $P3760
  if_3744_end:
.annotate 'line', 1167
    .return ($P3743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("472_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3834
    .param pmc param_3835
.annotate 'line', 1212
    .lex "self", param_3834
    .lex "$/", param_3835
    find_lex $P3836, "$/"
    find_lex $P3837, "$/"
    unless_null $P3837, vivify_1891
    $P3837 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P3838, $P3837["package_def"]
    unless_null $P3838, vivify_1892
    new $P3838, "Undef"
  vivify_1892:
    $P3839 = $P3838."ast"()
    $P3840 = $P3836."!make"($P3839)
    .return ($P3840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("473_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3842
    .param pmc param_3843
.annotate 'line', 1213
    .lex "self", param_3842
    .lex "$/", param_3843
    find_lex $P3844, "$/"
    find_lex $P3845, "$/"
    unless_null $P3845, vivify_1893
    $P3845 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3846, $P3845["package_def"]
    unless_null $P3846, vivify_1894
    new $P3846, "Undef"
  vivify_1894:
    $P3847 = $P3846."ast"()
    $P3848 = $P3844."!make"($P3847)
    .return ($P3848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("474_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3850
    .param pmc param_3851
.annotate 'line', 1214
    .lex "self", param_3850
    .lex "$/", param_3851
    find_lex $P3852, "$/"
    find_lex $P3853, "$/"
    unless_null $P3853, vivify_1895
    $P3853 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P3854, $P3853["package_def"]
    unless_null $P3854, vivify_1896
    new $P3854, "Undef"
  vivify_1896:
    $P3855 = $P3854."ast"()
    $P3856 = $P3852."!make"($P3855)
    .return ($P3856)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("475_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3858
    .param pmc param_3859
.annotate 'line', 1215
    .lex "self", param_3858
    .lex "$/", param_3859
    find_lex $P3860, "$/"
    find_lex $P3861, "$/"
    unless_null $P3861, vivify_1897
    $P3861 = root_new ['parrot';'Hash']
  vivify_1897:
    set $P3862, $P3861["package_def"]
    unless_null $P3862, vivify_1898
    new $P3862, "Undef"
  vivify_1898:
    $P3863 = $P3862."ast"()
    $P3864 = $P3860."!make"($P3863)
    .return ($P3864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("476_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3866
    .param pmc param_3867
.annotate 'line', 1216
    .lex "self", param_3866
    .lex "$/", param_3867
    find_lex $P3868, "$/"
    find_lex $P3869, "$/"
    unless_null $P3869, vivify_1899
    $P3869 = root_new ['parrot';'Hash']
  vivify_1899:
    set $P3870, $P3869["package_def"]
    unless_null $P3870, vivify_1900
    new $P3870, "Undef"
  vivify_1900:
    $P3871 = $P3870."ast"()
    $P3872 = $P3868."!make"($P3871)
    .return ($P3872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("477_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3874
    .param pmc param_3875
.annotate 'line', 1217
    .lex "self", param_3874
    .lex "$/", param_3875
    find_lex $P3876, "$/"
    find_lex $P3877, "$/"
    unless_null $P3877, vivify_1901
    $P3877 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P3878, $P3877["package_def"]
    unless_null $P3878, vivify_1902
    new $P3878, "Undef"
  vivify_1902:
    $P3879 = $P3878."ast"()
    $P3880 = $P3876."!make"($P3879)
    .return ($P3880)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("478_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_3882
    .param pmc param_3883
.annotate 'line', 1219
    .const 'Sub' $P4032 = "480_1303430322.161" 
    capture_lex $P4032
    .const 'Sub' $P3974 = "479_1303430322.161" 
    capture_lex $P3974
    .lex "self", param_3882
    .lex "$/", param_3883
.annotate 'line', 1221
    $P3884 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3884
.annotate 'line', 1222
    new $P3885, "Undef"
    .lex "$name", $P3885
.annotate 'line', 1223
    new $P3886, "Undef"
    .lex "$how", $P3886
.annotate 'line', 1226
    new $P3887, "Undef"
    .lex "$past", $P3887
.annotate 'line', 1221
    find_lex $P3888, "$/"
    unless_null $P3888, vivify_1903
    $P3888 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P3889, $P3888["name"]
    unless_null $P3889, vivify_1904
    $P3889 = root_new ['parrot';'Hash']
  vivify_1904:
    set $P3890, $P3889["identifier"]
    unless_null $P3890, vivify_1905
    new $P3890, "Undef"
  vivify_1905:
    clone $P3891, $P3890
    store_lex "@ns", $P3891
.annotate 'line', 1222
    find_lex $P3892, "@ns"
    unless_null $P3892, vivify_1906
    $P3892 = root_new ['parrot';'ResizablePMCArray']
  vivify_1906:
    $P3893 = $P3892."pop"()
    set $S3894, $P3893
    new $P3895, 'String'
    set $P3895, $S3894
    store_lex "$name", $P3895
.annotate 'line', 1223
    find_dynamic_lex $P3896, "$*PKGDECL"
    unless_null $P3896, vivify_1907
    get_hll_global $P3896, "$PKGDECL"
    unless_null $P3896, vivify_1908
    die "Contextual $*PKGDECL not found"
  vivify_1908:
  vivify_1907:
    find_dynamic_lex $P3897, "%*HOW"
    unless_null $P3897, vivify_1909
    get_hll_global $P3897, "%HOW"
    unless_null $P3897, vivify_1910
    die "Contextual %*HOW not found"
  vivify_1910:
  vivify_1909:
    set $P3898, $P3897[$P3896]
    unless_null $P3898, vivify_1911
    new $P3898, "Undef"
  vivify_1911:
    store_lex "$how", $P3898
.annotate 'line', 1226
    find_lex $P3901, "$/"
    unless_null $P3901, vivify_1912
    $P3901 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P3902, $P3901["block"]
    unless_null $P3902, vivify_1913
    new $P3902, "Undef"
  vivify_1913:
    if $P3902, if_3900
    find_lex $P3906, "$/"
    unless_null $P3906, vivify_1914
    $P3906 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P3907, $P3906["comp_unit"]
    unless_null $P3907, vivify_1915
    new $P3907, "Undef"
  vivify_1915:
    $P3908 = $P3907."ast"()
    set $P3899, $P3908
    goto if_3900_end
  if_3900:
    find_lex $P3903, "$/"
    unless_null $P3903, vivify_1916
    $P3903 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P3904, $P3903["block"]
    unless_null $P3904, vivify_1917
    new $P3904, "Undef"
  vivify_1917:
    $P3905 = $P3904."ast"()
    set $P3899, $P3905
  if_3900_end:
    store_lex "$past", $P3899
.annotate 'line', 1227
    find_dynamic_lex $P3912, "$*SCOPE"
    unless_null $P3912, vivify_1918
    get_hll_global $P3912, "$SCOPE"
    unless_null $P3912, vivify_1919
    die "Contextual $*SCOPE not found"
  vivify_1919:
  vivify_1918:
    set $S3913, $P3912
    iseq $I3914, $S3913, "our"
    unless $I3914, unless_3911
    new $P3910, 'Integer'
    set $P3910, $I3914
    goto unless_3911_end
  unless_3911:
    find_dynamic_lex $P3915, "$*SCOPE"
    unless_null $P3915, vivify_1920
    get_hll_global $P3915, "$SCOPE"
    unless_null $P3915, vivify_1921
    die "Contextual $*SCOPE not found"
  vivify_1921:
  vivify_1920:
    set $S3916, $P3915
    iseq $I3917, $S3916, ""
    new $P3910, 'Integer'
    set $P3910, $I3917
  unless_3911_end:
    unless $P3910, if_3909_end
.annotate 'line', 1228
    find_lex $P3918, "$past"
    unless_null $P3918, vivify_1922
    new $P3918, "Undef"
  vivify_1922:
    find_lex $P3919, "$/"
    unless_null $P3919, vivify_1923
    $P3919 = root_new ['parrot';'Hash']
  vivify_1923:
    set $P3920, $P3919["name"]
    unless_null $P3920, vivify_1924
    $P3920 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P3921, $P3920["identifier"]
    unless_null $P3921, vivify_1925
    new $P3921, "Undef"
  vivify_1925:
    $P3918."namespace"($P3921)
  if_3909_end:
.annotate 'line', 1232
    find_dynamic_lex $P3922, "$*PACKAGE-SETUP"
    unless_null $P3922, vivify_1926
    get_hll_global $P3922, "$PACKAGE-SETUP"
    unless_null $P3922, vivify_1927
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1927:
  vivify_1926:
    get_hll_global $P3923, ["PAST"], "Stmts"
.annotate 'line', 1233
    get_hll_global $P3924, ["PAST"], "Op"
.annotate 'line', 1234
    get_hll_global $P3925, ["PAST"], "Var"
    $P3926 = $P3925."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1235
    find_dynamic_lex $P3927, "$*SC"
    unless_null $P3927, vivify_1928
    get_hll_global $P3927, "$SC"
    unless_null $P3927, vivify_1929
    die "Contextual $*SC not found"
  vivify_1929:
  vivify_1928:
    find_dynamic_lex $P3928, "$*PACKAGE"
    unless_null $P3928, vivify_1930
    get_hll_global $P3928, "$PACKAGE"
    unless_null $P3928, vivify_1931
    die "Contextual $*PACKAGE not found"
  vivify_1931:
  vivify_1930:
    $P3929 = $P3927."get_slot_past_for_object"($P3928)
    $P3930 = $P3924."new"($P3926, $P3929, "bind" :named("pasttype"))
.annotate 'line', 1233
    $P3931 = $P3923."new"($P3930)
.annotate 'line', 1232
    $P3922."unshift"($P3931)
.annotate 'line', 1244
    find_lex $P3935, "$how"
    unless_null $P3935, vivify_1932
    new $P3935, "Undef"
  vivify_1932:
    can $I3936, $P3935, "parametric"
    if $I3936, if_3934
    new $P3933, 'Integer'
    set $P3933, $I3936
    goto if_3934_end
  if_3934:
    find_lex $P3937, "$how"
    unless_null $P3937, vivify_1933
    new $P3937, "Undef"
  vivify_1933:
    find_lex $P3938, "$how"
    unless_null $P3938, vivify_1934
    new $P3938, "Undef"
  vivify_1934:
    $P3939 = $P3937."parametric"($P3938)
    set $P3933, $P3939
  if_3934_end:
    if $P3933, if_3932
.annotate 'line', 1262
    find_lex $P3963, "$past"
    unless_null $P3963, vivify_1935
    new $P3963, "Undef"
  vivify_1935:
    $P3963."blocktype"("immediate")
.annotate 'line', 1263
    find_dynamic_lex $P3964, "$*SC"
    unless_null $P3964, vivify_1936
    get_hll_global $P3964, "$SC"
    unless_null $P3964, vivify_1937
    die "Contextual $*SC not found"
  vivify_1937:
  vivify_1936:
    find_lex $P3965, "$past"
    unless_null $P3965, vivify_1938
    new $P3965, "Undef"
  vivify_1938:
    find_dynamic_lex $P3966, "$*PACKAGE"
    unless_null $P3966, vivify_1939
    get_hll_global $P3966, "$PACKAGE"
    unless_null $P3966, vivify_1940
    die "Contextual $*PACKAGE not found"
  vivify_1940:
  vivify_1939:
    $P3964."install_lexical_symbol"($P3965, "$?PACKAGE", $P3966)
.annotate 'line', 1264
    find_dynamic_lex $P3967, "$*SC"
    unless_null $P3967, vivify_1941
    get_hll_global $P3967, "$SC"
    unless_null $P3967, vivify_1942
    die "Contextual $*SC not found"
  vivify_1942:
  vivify_1941:
    find_lex $P3968, "$past"
    unless_null $P3968, vivify_1943
    new $P3968, "Undef"
  vivify_1943:
    find_dynamic_lex $P3969, "$*PACKAGE"
    unless_null $P3969, vivify_1944
    get_hll_global $P3969, "$PACKAGE"
    unless_null $P3969, vivify_1945
    die "Contextual $*PACKAGE not found"
  vivify_1945:
  vivify_1944:
    $P3967."install_lexical_symbol"($P3968, "$?CLASS", $P3969)
.annotate 'line', 1261
    goto if_3932_end
  if_3932:
.annotate 'line', 1245
    find_lex $P3940, "$past"
    unless_null $P3940, vivify_1946
    new $P3940, "Undef"
  vivify_1946:
    $P3940."blocktype"("declaration")
.annotate 'line', 1246
    find_lex $P3941, "$past"
    unless_null $P3941, vivify_1947
    new $P3941, "Undef"
  vivify_1947:
    get_hll_global $P3942, ["PAST"], "Var"
    $P3943 = $P3942."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3941."unshift"($P3943)
.annotate 'line', 1247
    find_lex $P3944, "$past"
    unless_null $P3944, vivify_1948
    new $P3944, "Undef"
  vivify_1948:
    $P3944."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1248
    find_dynamic_lex $P3945, "$*PACKAGE-SETUP"
    unless_null $P3945, vivify_1949
    get_hll_global $P3945, "$PACKAGE-SETUP"
    unless_null $P3945, vivify_1950
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1950:
  vivify_1949:
    get_hll_global $P3946, ["PAST"], "Op"
.annotate 'line', 1250
    get_hll_global $P3947, ["PAST"], "Op"
.annotate 'line', 1253
    get_hll_global $P3948, ["PAST"], "Var"
    $P3949 = $P3948."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3950 = $P3947."new"($P3949, "get_how PP" :named("pirop"))
.annotate 'line', 1255
    get_hll_global $P3951, ["PAST"], "Var"
    $P3952 = $P3951."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1256
    get_hll_global $P3953, ["PAST"], "Val"
    find_lex $P3954, "$past"
    unless_null $P3954, vivify_1951
    new $P3954, "Undef"
  vivify_1951:
    $P3955 = $P3953."new"($P3954 :named("value"))
    $P3956 = $P3946."new"($P3950, $P3952, $P3955, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1248
    $P3945."push"($P3956)
.annotate 'line', 1258
    find_dynamic_lex $P3957, "$*SC"
    unless_null $P3957, vivify_1952
    get_hll_global $P3957, "$SC"
    unless_null $P3957, vivify_1953
    die "Contextual $*SC not found"
  vivify_1953:
  vivify_1952:
    find_lex $P3958, "$past"
    unless_null $P3958, vivify_1954
    new $P3958, "Undef"
  vivify_1954:
    find_dynamic_lex $P3959, "$*PACKAGE"
    unless_null $P3959, vivify_1955
    get_hll_global $P3959, "$PACKAGE"
    unless_null $P3959, vivify_1956
    die "Contextual $*PACKAGE not found"
  vivify_1956:
  vivify_1955:
    $P3957."install_lexical_symbol"($P3958, "$?PACKAGE", $P3959)
.annotate 'line', 1259
    find_dynamic_lex $P3960, "$*SC"
    unless_null $P3960, vivify_1957
    get_hll_global $P3960, "$SC"
    unless_null $P3960, vivify_1958
    die "Contextual $*SC not found"
  vivify_1958:
  vivify_1957:
    find_lex $P3961, "$past"
    unless_null $P3961, vivify_1959
    new $P3961, "Undef"
  vivify_1959:
    find_dynamic_lex $P3962, "$*PACKAGE"
    unless_null $P3962, vivify_1960
    get_hll_global $P3962, "$PACKAGE"
    unless_null $P3962, vivify_1961
    die "Contextual $*PACKAGE not found"
  vivify_1961:
  vivify_1960:
    $P3960."install_lexical_symbol"($P3961, "$?ROLE", $P3962)
  if_3932_end:
.annotate 'line', 1269
    find_lex $P3971, "$/"
    unless_null $P3971, vivify_1962
    $P3971 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P3972, $P3971["parent"]
    unless_null $P3972, vivify_1963
    new $P3972, "Undef"
  vivify_1963:
    if $P3972, if_3970
.annotate 'line', 1283
    find_lex $P4002, "$how"
    unless_null $P4002, vivify_1964
    new $P4002, "Undef"
  vivify_1964:
    can $I4003, $P4002, "set_default_parent"
    unless $I4003, if_4001_end
.annotate 'line', 1285
    find_dynamic_lex $P4004, "$*PACKAGE-SETUP"
    unless_null $P4004, vivify_1965
    get_hll_global $P4004, "$PACKAGE-SETUP"
    unless_null $P4004, vivify_1966
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1966:
  vivify_1965:
    get_hll_global $P4005, ["PAST"], "Op"
.annotate 'line', 1287
    get_hll_global $P4006, ["PAST"], "Op"
.annotate 'line', 1290
    get_hll_global $P4007, ["PAST"], "Var"
    $P4008 = $P4007."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4009 = $P4006."new"($P4008, "get_how PP" :named("pirop"))
.annotate 'line', 1292
    get_hll_global $P4010, ["PAST"], "Var"
    $P4011 = $P4010."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1293
    find_dynamic_lex $P4014, "$*PKGDECL"
    unless_null $P4014, vivify_1967
    get_hll_global $P4014, "$PKGDECL"
    unless_null $P4014, vivify_1968
    die "Contextual $*PKGDECL not found"
  vivify_1968:
  vivify_1967:
    set $S4015, $P4014
    iseq $I4016, $S4015, "grammar"
    if $I4016, if_4013
.annotate 'line', 1295
    find_dynamic_lex $P4019, "$*SC"
    unless_null $P4019, vivify_1969
    get_hll_global $P4019, "$SC"
    unless_null $P4019, vivify_1970
    die "Contextual $*SC not found"
  vivify_1970:
  vivify_1969:
    $P4020 = "find_lex"("NQPMu")
    $P4021 = $P4019."get_object_sc_ref_past"($P4020)
    set $P4012, $P4021
.annotate 'line', 1293
    goto if_4013_end
  if_4013:
.annotate 'line', 1294
    get_hll_global $P4017, ["PAST"], "Var"
    $P4018 = $P4017."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    set $P4012, $P4018
  if_4013_end:
.annotate 'line', 1293
    $P4022 = $P4005."new"($P4009, $P4011, $P4012, "callmethod" :named("pasttype"), "set_default_parent" :named("name"))
.annotate 'line', 1285
    $P4004."push"($P4022)
  if_4001_end:
.annotate 'line', 1283
    goto if_3970_end
  if_3970:
.annotate 'line', 1269
    .const 'Sub' $P3974 = "479_1303430322.161" 
    capture_lex $P3974
    $P3974()
  if_3970_end:
.annotate 'line', 1300
    find_lex $P4024, "$/"
    unless_null $P4024, vivify_1980
    $P4024 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P4025, $P4024["role"]
    unless_null $P4025, vivify_1981
    new $P4025, "Undef"
  vivify_1981:
    unless $P4025, if_4023_end
.annotate 'line', 1301
    find_lex $P4027, "$/"
    unless_null $P4027, vivify_1982
    $P4027 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P4028, $P4027["role"]
    unless_null $P4028, vivify_1983
    new $P4028, "Undef"
  vivify_1983:
    defined $I4029, $P4028
    unless $I4029, for_undef_1984
    iter $P4026, $P4028
    new $P4059, 'ExceptionHandler'
    set_label $P4059, loop4058_handler
    $P4059."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4059
  loop4058_test:
    unless $P4026, loop4058_done
    shift $P4030, $P4026
  loop4058_redo:
    .const 'Sub' $P4032 = "480_1303430322.161" 
    capture_lex $P4032
    $P4032($P4030)
  loop4058_next:
    goto loop4058_test
  loop4058_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4060, exception, 'type'
    eq $P4060, .CONTROL_LOOP_NEXT, loop4058_next
    eq $P4060, .CONTROL_LOOP_REDO, loop4058_redo
  loop4058_done:
    pop_eh 
  for_undef_1984:
  if_4023_end:
.annotate 'line', 1318
    find_dynamic_lex $P4061, "$*PACKAGE-SETUP"
    unless_null $P4061, vivify_1992
    get_hll_global $P4061, "$PACKAGE-SETUP"
    unless_null $P4061, vivify_1993
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1993:
  vivify_1992:
    get_hll_global $P4062, ["PAST"], "Op"
.annotate 'line', 1320
    get_hll_global $P4063, ["PAST"], "Op"
.annotate 'line', 1323
    get_hll_global $P4064, ["PAST"], "Var"
    $P4065 = $P4064."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4066 = $P4063."new"($P4065, "get_how PP" :named("pirop"))
.annotate 'line', 1325
    get_hll_global $P4067, ["PAST"], "Var"
    $P4068 = $P4067."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4069 = $P4062."new"($P4066, $P4068, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1318
    $P4061."push"($P4069)
.annotate 'line', 1329
    find_lex $P4070, "$past"
    unless_null $P4070, vivify_1994
    new $P4070, "Undef"
  vivify_1994:
    $P4071 = $P4070."loadinit"()
    get_hll_global $P4072, ["PAST"], "Block"
    find_dynamic_lex $P4073, "$*PACKAGE-SETUP"
    unless_null $P4073, vivify_1995
    get_hll_global $P4073, "$PACKAGE-SETUP"
    unless_null $P4073, vivify_1996
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1996:
  vivify_1995:
    $P4074 = $P4072."new"($P4073, "immediate" :named("blocktype"))
    $P4071."push"($P4074)
.annotate 'line', 1331
    find_lex $P4075, "$/"
    find_lex $P4076, "$past"
    unless_null $P4076, vivify_1997
    new $P4076, "Undef"
  vivify_1997:
    $P4077 = $P4075."!make"($P4076)
.annotate 'line', 1219
    .return ($P4077)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3973"  :anon :subid("479_1303430322.161") :outer("478_1303430322.161")
.annotate 'line', 1270
    $P3975 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3975
.annotate 'line', 1271
    new $P3976, "Undef"
    .lex "$name", $P3976
.annotate 'line', 1270
    find_lex $P3977, "$/"
    unless_null $P3977, vivify_1971
    $P3977 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P3978, $P3977["parent"]
    unless_null $P3978, vivify_1972
    $P3978 = root_new ['parrot';'ResizablePMCArray']
  vivify_1972:
    set $P3979, $P3978[0]
    unless_null $P3979, vivify_1973
    $P3979 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P3980, $P3979["identifier"]
    unless_null $P3980, vivify_1974
    new $P3980, "Undef"
  vivify_1974:
    clone $P3981, $P3980
    store_lex "@ns", $P3981
.annotate 'line', 1271
    find_lex $P3982, "@ns"
    unless_null $P3982, vivify_1975
    $P3982 = root_new ['parrot';'ResizablePMCArray']
  vivify_1975:
    $P3983 = $P3982."pop"()
    set $S3984, $P3983
    new $P3985, 'String'
    set $P3985, $S3984
    store_lex "$name", $P3985
.annotate 'line', 1272
    find_dynamic_lex $P3986, "$*PACKAGE-SETUP"
    unless_null $P3986, vivify_1976
    get_hll_global $P3986, "$PACKAGE-SETUP"
    unless_null $P3986, vivify_1977
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1977:
  vivify_1976:
    get_hll_global $P3987, ["PAST"], "Op"
.annotate 'line', 1274
    get_hll_global $P3988, ["PAST"], "Op"
.annotate 'line', 1277
    get_hll_global $P3989, ["PAST"], "Var"
    $P3990 = $P3989."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3991 = $P3988."new"($P3990, "get_how PP" :named("pirop"))
.annotate 'line', 1279
    get_hll_global $P3992, ["PAST"], "Var"
    $P3993 = $P3992."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1280
    get_hll_global $P3994, ["PAST"], "Var"
    find_lex $P3995, "$name"
    unless_null $P3995, vivify_1978
    new $P3995, "Undef"
  vivify_1978:
    set $S3996, $P3995
    find_lex $P3997, "@ns"
    unless_null $P3997, vivify_1979
    $P3997 = root_new ['parrot';'ResizablePMCArray']
  vivify_1979:
    $P3998 = $P3994."new"($S3996 :named("name"), $P3997 :named("namespace"), "package" :named("scope"))
    $P3999 = $P3987."new"($P3991, $P3993, $P3998, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1272
    $P4000 = $P3986."push"($P3999)
.annotate 'line', 1269
    .return ($P4000)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4031"  :anon :subid("480_1303430322.161") :outer("478_1303430322.161")
    .param pmc param_4035
.annotate 'line', 1302
    $P4033 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4033
.annotate 'line', 1303
    new $P4034, "Undef"
    .lex "$name", $P4034
    .lex "$_", param_4035
.annotate 'line', 1302
    find_lex $P4036, "$_"
    unless_null $P4036, vivify_1985
    $P4036 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P4037, $P4036["identifier"]
    unless_null $P4037, vivify_1986
    new $P4037, "Undef"
  vivify_1986:
    clone $P4038, $P4037
    store_lex "@ns", $P4038
.annotate 'line', 1303
    find_lex $P4039, "@ns"
    unless_null $P4039, vivify_1987
    $P4039 = root_new ['parrot';'ResizablePMCArray']
  vivify_1987:
    $P4040 = $P4039."pop"()
    set $S4041, $P4040
    new $P4042, 'String'
    set $P4042, $S4041
    store_lex "$name", $P4042
.annotate 'line', 1304
    find_dynamic_lex $P4043, "$*PACKAGE-SETUP"
    unless_null $P4043, vivify_1988
    get_hll_global $P4043, "$PACKAGE-SETUP"
    unless_null $P4043, vivify_1989
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1989:
  vivify_1988:
    get_hll_global $P4044, ["PAST"], "Op"
.annotate 'line', 1306
    get_hll_global $P4045, ["PAST"], "Op"
.annotate 'line', 1309
    get_hll_global $P4046, ["PAST"], "Var"
    $P4047 = $P4046."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4048 = $P4045."new"($P4047, "get_how PP" :named("pirop"))
.annotate 'line', 1311
    get_hll_global $P4049, ["PAST"], "Var"
    $P4050 = $P4049."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1312
    get_hll_global $P4051, ["PAST"], "Var"
    find_lex $P4052, "$name"
    unless_null $P4052, vivify_1990
    new $P4052, "Undef"
  vivify_1990:
    set $S4053, $P4052
    find_lex $P4054, "@ns"
    unless_null $P4054, vivify_1991
    $P4054 = root_new ['parrot';'ResizablePMCArray']
  vivify_1991:
    $P4055 = $P4051."new"($S4053 :named("name"), $P4054 :named("namespace"), "package" :named("scope"))
    $P4056 = $P4044."new"($P4048, $P4050, $P4055, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1304
    $P4057 = $P4043."push"($P4056)
.annotate 'line', 1301
    .return ($P4057)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("481_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4079
    .param pmc param_4080
.annotate 'line', 1334
    .lex "self", param_4079
    .lex "$/", param_4080
    find_lex $P4081, "$/"
    find_lex $P4082, "$/"
    unless_null $P4082, vivify_1998
    $P4082 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P4083, $P4082["scoped"]
    unless_null $P4083, vivify_1999
    new $P4083, "Undef"
  vivify_1999:
    $P4084 = $P4083."ast"()
    $P4085 = $P4081."!make"($P4084)
    .return ($P4085)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("482_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4087
    .param pmc param_4088
.annotate 'line', 1335
    .lex "self", param_4087
    .lex "$/", param_4088
    find_lex $P4089, "$/"
    find_lex $P4090, "$/"
    unless_null $P4090, vivify_2000
    $P4090 = root_new ['parrot';'Hash']
  vivify_2000:
    set $P4091, $P4090["scoped"]
    unless_null $P4091, vivify_2001
    new $P4091, "Undef"
  vivify_2001:
    $P4092 = $P4091."ast"()
    $P4093 = $P4089."!make"($P4092)
    .return ($P4093)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("483_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4095
    .param pmc param_4096
.annotate 'line', 1336
    .lex "self", param_4095
    .lex "$/", param_4096
    find_lex $P4097, "$/"
    find_lex $P4098, "$/"
    unless_null $P4098, vivify_2002
    $P4098 = root_new ['parrot';'Hash']
  vivify_2002:
    set $P4099, $P4098["scoped"]
    unless_null $P4099, vivify_2003
    new $P4099, "Undef"
  vivify_2003:
    $P4100 = $P4099."ast"()
    $P4101 = $P4097."!make"($P4100)
    .return ($P4101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("484_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4103
    .param pmc param_4104
.annotate 'line', 1338
    .lex "self", param_4103
    .lex "$/", param_4104
.annotate 'line', 1339
    find_lex $P4105, "$/"
    find_lex $P4108, "$/"
    unless_null $P4108, vivify_2004
    $P4108 = root_new ['parrot';'Hash']
  vivify_2004:
    set $P4109, $P4108["declarator"]
    unless_null $P4109, vivify_2005
    new $P4109, "Undef"
  vivify_2005:
    if $P4109, if_4107
.annotate 'line', 1340
    find_lex $P4115, "$/"
    unless_null $P4115, vivify_2006
    $P4115 = root_new ['parrot';'Hash']
  vivify_2006:
    set $P4116, $P4115["multi_declarator"]
    unless_null $P4116, vivify_2007
    new $P4116, "Undef"
  vivify_2007:
    if $P4116, if_4114
.annotate 'line', 1341
    find_lex $P4120, "$/"
    unless_null $P4120, vivify_2008
    $P4120 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P4121, $P4120["package_declarator"]
    unless_null $P4121, vivify_2009
    new $P4121, "Undef"
  vivify_2009:
    $P4122 = $P4121."ast"()
    set $P4113, $P4122
.annotate 'line', 1340
    goto if_4114_end
  if_4114:
    find_lex $P4117, "$/"
    unless_null $P4117, vivify_2010
    $P4117 = root_new ['parrot';'Hash']
  vivify_2010:
    set $P4118, $P4117["multi_declarator"]
    unless_null $P4118, vivify_2011
    new $P4118, "Undef"
  vivify_2011:
    $P4119 = $P4118."ast"()
    set $P4113, $P4119
  if_4114_end:
    set $P4106, $P4113
.annotate 'line', 1339
    goto if_4107_end
  if_4107:
    find_lex $P4110, "$/"
    unless_null $P4110, vivify_2012
    $P4110 = root_new ['parrot';'Hash']
  vivify_2012:
    set $P4111, $P4110["declarator"]
    unless_null $P4111, vivify_2013
    new $P4111, "Undef"
  vivify_2013:
    $P4112 = $P4111."ast"()
    set $P4106, $P4112
  if_4107_end:
    $P4123 = $P4105."!make"($P4106)
.annotate 'line', 1338
    .return ($P4123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("485_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4125
    .param pmc param_4126
.annotate 'line', 1344
    .lex "self", param_4125
    .lex "$/", param_4126
.annotate 'line', 1345
    find_lex $P4127, "$/"
.annotate 'line', 1346
    find_lex $P4130, "$/"
    unless_null $P4130, vivify_2014
    $P4130 = root_new ['parrot';'Hash']
  vivify_2014:
    set $P4131, $P4130["routine_declarator"]
    unless_null $P4131, vivify_2015
    new $P4131, "Undef"
  vivify_2015:
    if $P4131, if_4129
.annotate 'line', 1347
    find_lex $P4135, "$/"
    unless_null $P4135, vivify_2016
    $P4135 = root_new ['parrot';'Hash']
  vivify_2016:
    set $P4136, $P4135["variable_declarator"]
    unless_null $P4136, vivify_2017
    new $P4136, "Undef"
  vivify_2017:
    $P4137 = $P4136."ast"()
    set $P4128, $P4137
.annotate 'line', 1346
    goto if_4129_end
  if_4129:
    find_lex $P4132, "$/"
    unless_null $P4132, vivify_2018
    $P4132 = root_new ['parrot';'Hash']
  vivify_2018:
    set $P4133, $P4132["routine_declarator"]
    unless_null $P4133, vivify_2019
    new $P4133, "Undef"
  vivify_2019:
    $P4134 = $P4133."ast"()
    set $P4128, $P4134
  if_4129_end:
    $P4138 = $P4127."!make"($P4128)
.annotate 'line', 1344
    .return ($P4138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("486_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4140
    .param pmc param_4141
.annotate 'line', 1350
    .lex "self", param_4140
    .lex "$/", param_4141
    find_lex $P4142, "$/"
    find_lex $P4145, "$/"
    unless_null $P4145, vivify_2020
    $P4145 = root_new ['parrot';'Hash']
  vivify_2020:
    set $P4146, $P4145["declarator"]
    unless_null $P4146, vivify_2021
    new $P4146, "Undef"
  vivify_2021:
    if $P4146, if_4144
    find_lex $P4150, "$/"
    unless_null $P4150, vivify_2022
    $P4150 = root_new ['parrot';'Hash']
  vivify_2022:
    set $P4151, $P4150["routine_def"]
    unless_null $P4151, vivify_2023
    new $P4151, "Undef"
  vivify_2023:
    $P4152 = $P4151."ast"()
    set $P4143, $P4152
    goto if_4144_end
  if_4144:
    find_lex $P4147, "$/"
    unless_null $P4147, vivify_2024
    $P4147 = root_new ['parrot';'Hash']
  vivify_2024:
    set $P4148, $P4147["declarator"]
    unless_null $P4148, vivify_2025
    new $P4148, "Undef"
  vivify_2025:
    $P4149 = $P4148."ast"()
    set $P4143, $P4149
  if_4144_end:
    $P4153 = $P4142."!make"($P4143)
    .return ($P4153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("487_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4155
    .param pmc param_4156
.annotate 'line', 1351
    .lex "self", param_4155
    .lex "$/", param_4156
    find_lex $P4157, "$/"
    find_lex $P4160, "$/"
    unless_null $P4160, vivify_2026
    $P4160 = root_new ['parrot';'Hash']
  vivify_2026:
    set $P4161, $P4160["declarator"]
    unless_null $P4161, vivify_2027
    new $P4161, "Undef"
  vivify_2027:
    if $P4161, if_4159
    find_lex $P4165, "$/"
    unless_null $P4165, vivify_2028
    $P4165 = root_new ['parrot';'Hash']
  vivify_2028:
    set $P4166, $P4165["routine_def"]
    unless_null $P4166, vivify_2029
    new $P4166, "Undef"
  vivify_2029:
    $P4167 = $P4166."ast"()
    set $P4158, $P4167
    goto if_4159_end
  if_4159:
    find_lex $P4162, "$/"
    unless_null $P4162, vivify_2030
    $P4162 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P4163, $P4162["declarator"]
    unless_null $P4163, vivify_2031
    new $P4163, "Undef"
  vivify_2031:
    $P4164 = $P4163."ast"()
    set $P4158, $P4164
  if_4159_end:
    $P4168 = $P4157."!make"($P4158)
    .return ($P4168)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("488_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4170
    .param pmc param_4171
.annotate 'line', 1352
    .lex "self", param_4170
    .lex "$/", param_4171
    find_lex $P4172, "$/"
    find_lex $P4173, "$/"
    unless_null $P4173, vivify_2032
    $P4173 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P4174, $P4173["declarator"]
    unless_null $P4174, vivify_2033
    new $P4174, "Undef"
  vivify_2033:
    $P4175 = $P4174."ast"()
    $P4176 = $P4172."!make"($P4175)
    .return ($P4176)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("489_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4178
    .param pmc param_4179
.annotate 'line', 1355
    .const 'Sub' $P4211 = "490_1303430322.161" 
    capture_lex $P4211
    .lex "self", param_4178
    .lex "$/", param_4179
.annotate 'line', 1356
    new $P4180, "Undef"
    .lex "$past", $P4180
.annotate 'line', 1357
    new $P4181, "Undef"
    .lex "$sigil", $P4181
.annotate 'line', 1358
    new $P4182, "Undef"
    .lex "$name", $P4182
.annotate 'line', 1359
    new $P4183, "Undef"
    .lex "$BLOCK", $P4183
.annotate 'line', 1356
    find_lex $P4184, "$/"
    unless_null $P4184, vivify_2034
    $P4184 = root_new ['parrot';'Hash']
  vivify_2034:
    set $P4185, $P4184["variable"]
    unless_null $P4185, vivify_2035
    new $P4185, "Undef"
  vivify_2035:
    $P4186 = $P4185."ast"()
    store_lex "$past", $P4186
.annotate 'line', 1357
    find_lex $P4187, "$/"
    unless_null $P4187, vivify_2036
    $P4187 = root_new ['parrot';'Hash']
  vivify_2036:
    set $P4188, $P4187["variable"]
    unless_null $P4188, vivify_2037
    $P4188 = root_new ['parrot';'Hash']
  vivify_2037:
    set $P4189, $P4188["sigil"]
    unless_null $P4189, vivify_2038
    new $P4189, "Undef"
  vivify_2038:
    store_lex "$sigil", $P4189
.annotate 'line', 1358
    find_lex $P4190, "$past"
    unless_null $P4190, vivify_2039
    new $P4190, "Undef"
  vivify_2039:
    $P4191 = $P4190."name"()
    store_lex "$name", $P4191
.annotate 'line', 1359
    find_lex $P4192, "$?PACKAGE"
    get_who $P4193, $P4192
    set $P4194, $P4193["@BLOCK"]
    unless_null $P4194, vivify_2040
    $P4194 = root_new ['parrot';'ResizablePMCArray']
  vivify_2040:
    set $P4195, $P4194[0]
    unless_null $P4195, vivify_2041
    new $P4195, "Undef"
  vivify_2041:
    store_lex "$BLOCK", $P4195
.annotate 'line', 1360
    find_lex $P4199, "$name"
    unless_null $P4199, vivify_2042
    new $P4199, "Undef"
  vivify_2042:
    if $P4199, if_4198
    set $P4197, $P4199
    goto if_4198_end
  if_4198:
    find_lex $P4200, "$BLOCK"
    unless_null $P4200, vivify_2043
    new $P4200, "Undef"
  vivify_2043:
    find_lex $P4201, "$name"
    unless_null $P4201, vivify_2044
    new $P4201, "Undef"
  vivify_2044:
    $P4202 = $P4200."symbol"($P4201)
    set $P4197, $P4202
  if_4198_end:
    unless $P4197, if_4196_end
.annotate 'line', 1361
    find_lex $P4203, "$/"
    unless_null $P4203, vivify_2045
    new $P4203, "Undef"
  vivify_2045:
    $P4204 = $P4203."CURSOR"()
    find_lex $P4205, "$name"
    unless_null $P4205, vivify_2046
    new $P4205, "Undef"
  vivify_2046:
    $P4204."panic"("Redeclaration of symbol ", $P4205)
  if_4196_end:
.annotate 'line', 1363
    find_dynamic_lex $P4207, "$*SCOPE"
    unless_null $P4207, vivify_2047
    get_hll_global $P4207, "$SCOPE"
    unless_null $P4207, vivify_2048
    die "Contextual $*SCOPE not found"
  vivify_2048:
  vivify_2047:
    set $S4208, $P4207
    iseq $I4209, $S4208, "has"
    if $I4209, if_4206
.annotate 'line', 1388
    find_dynamic_lex $P4256, "$*SCOPE"
    unless_null $P4256, vivify_2049
    get_hll_global $P4256, "$SCOPE"
    unless_null $P4256, vivify_2050
    die "Contextual $*SCOPE not found"
  vivify_2050:
  vivify_2049:
    set $S4257, $P4256
    iseq $I4258, $S4257, "our"
    if $I4258, if_4255
.annotate 'line', 1398
    find_lex $P4272, "$BLOCK"
    unless_null $P4272, vivify_2051
    $P4272 = root_new ['parrot';'ResizablePMCArray']
  vivify_2051:
    set $P4273, $P4272[0]
    unless_null $P4273, vivify_2052
    new $P4273, "Undef"
  vivify_2052:
    get_hll_global $P4274, ["PAST"], "Var"
    find_lex $P4275, "$name"
    unless_null $P4275, vivify_2053
    new $P4275, "Undef"
  vivify_2053:
.annotate 'line', 1400
    find_lex $P4276, "$sigil"
    unless_null $P4276, vivify_2054
    new $P4276, "Undef"
  vivify_2054:
    $P4277 = "vivitype"($P4276)
    find_lex $P4278, "$/"
    unless_null $P4278, vivify_2055
    new $P4278, "Undef"
  vivify_2055:
    $P4279 = $P4274."new"($P4275 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4277 :named("viviself"), $P4278 :named("node"))
.annotate 'line', 1398
    $P4273."push"($P4279)
.annotate 'line', 1403
    find_lex $P4280, "$BLOCK"
    unless_null $P4280, vivify_2056
    new $P4280, "Undef"
  vivify_2056:
    find_lex $P4281, "$name"
    unless_null $P4281, vivify_2057
    new $P4281, "Undef"
  vivify_2057:
    $P4280."symbol"($P4281, "lexical" :named("scope"))
.annotate 'line', 1397
    goto if_4255_end
  if_4255:
.annotate 'line', 1392
    find_lex $P4259, "$/"
    unless_null $P4259, vivify_2058
    $P4259 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P4260, $P4259["variable"]
    unless_null $P4260, vivify_2059
    new $P4260, "Undef"
  vivify_2059:
    set $S4261, $P4260
    new $P4262, 'String'
    set $P4262, $S4261
    store_lex "$name", $P4262
.annotate 'line', 1393
    find_lex $P4263, "$name"
    unless_null $P4263, vivify_2060
    new $P4263, "Undef"
  vivify_2060:
    new $P4264, "ResizablePMCArray"
    push $P4264, $P4263
    find_lex $P4265, "$/"
    unless_null $P4265, vivify_2061
    new $P4265, "Undef"
  vivify_2061:
    $P4266 = "lexical_package_lookup"($P4264, $P4265)
    store_lex "$past", $P4266
.annotate 'line', 1394
    find_lex $P4267, "$past"
    unless_null $P4267, vivify_2062
    new $P4267, "Undef"
  vivify_2062:
    find_lex $P4268, "$sigil"
    unless_null $P4268, vivify_2063
    new $P4268, "Undef"
  vivify_2063:
    $P4269 = "vivitype"($P4268)
    $P4267."viviself"($P4269)
.annotate 'line', 1395
    find_lex $P4270, "$BLOCK"
    unless_null $P4270, vivify_2064
    new $P4270, "Undef"
  vivify_2064:
    find_lex $P4271, "$name"
    unless_null $P4271, vivify_2065
    new $P4271, "Undef"
  vivify_2065:
    $P4270."symbol"($P4271, "package" :named("scope"))
  if_4255_end:
.annotate 'line', 1388
    goto if_4206_end
  if_4206:
.annotate 'line', 1363
    .const 'Sub' $P4211 = "490_1303430322.161" 
    capture_lex $P4211
    $P4211()
  if_4206_end:
.annotate 'line', 1405
    find_lex $P4282, "$/"
    find_lex $P4283, "$past"
    unless_null $P4283, vivify_2087
    new $P4283, "Undef"
  vivify_2087:
    $P4284 = $P4282."!make"($P4283)
.annotate 'line', 1355
    .return ($P4284)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4210"  :anon :subid("490_1303430322.161") :outer("489_1303430322.161")
.annotate 'line', 1363
    .const 'Sub' $P4241 = "491_1303430322.161" 
    capture_lex $P4241
.annotate 'line', 1365
    new $P4212, "Undef"
    .lex "$meta-attr-type", $P4212
.annotate 'line', 1373
    new $P4213, "Undef"
    .lex "$meta_args", $P4213
.annotate 'line', 1365
    find_dynamic_lex $P4216, "$*PKGDECL"
    unless_null $P4216, vivify_2066
    get_hll_global $P4216, "$PKGDECL"
    unless_null $P4216, vivify_2067
    die "Contextual $*PKGDECL not found"
  vivify_2067:
  vivify_2066:
    find_dynamic_lex $P4217, "%*HOW-METAATTR"
    unless_null $P4217, vivify_2068
    get_hll_global $P4217, "%HOW-METAATTR"
    unless_null $P4217, vivify_2069
    die "Contextual %*HOW-METAATTR not found"
  vivify_2069:
  vivify_2068:
    set $P4218, $P4217[$P4216]
    unless_null $P4218, vivify_2070
    new $P4218, "Undef"
  vivify_2070:
    unless $P4218, unless_4215
    set $P4214, $P4218
    goto unless_4215_end
  unless_4215:
    find_dynamic_lex $P4219, "$*DEFAULT-METAATTR"
    unless_null $P4219, vivify_2071
    get_hll_global $P4219, "$DEFAULT-METAATTR"
    unless_null $P4219, vivify_2072
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2072:
  vivify_2071:
    set $P4214, $P4219
  unless_4215_end:
    store_lex "$meta-attr-type", $P4214
.annotate 'line', 1366
    find_dynamic_lex $P4220, "$*PACKAGE-SETUP"
    unless_null $P4220, vivify_2073
    get_hll_global $P4220, "$PACKAGE-SETUP"
    unless_null $P4220, vivify_2074
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2074:
  vivify_2073:
    get_hll_global $P4221, ["PAST"], "Op"
.annotate 'line', 1368
    get_hll_global $P4222, ["PAST"], "Op"
.annotate 'line', 1370
    get_hll_global $P4223, ["PAST"], "Var"
    $P4224 = $P4223."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4225 = $P4222."new"($P4224, "get_how PP" :named("pirop"))
.annotate 'line', 1372
    get_hll_global $P4226, ["PAST"], "Var"
    $P4227 = $P4226."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1373
    get_hll_global $P4228, ["PAST"], "Op"
.annotate 'line', 1375
    get_hll_global $P4229, ["PAST"], "Var"
    find_lex $P4230, "$meta-attr-type"
    unless_null $P4230, vivify_2075
    new $P4230, "Undef"
  vivify_2075:
    $P4231 = $P4229."new"($P4230 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1376
    get_hll_global $P4232, ["PAST"], "Val"
    find_lex $P4233, "$name"
    unless_null $P4233, vivify_2076
    new $P4233, "Undef"
  vivify_2076:
    $P4234 = $P4232."new"($P4233 :named("value"), "name" :named("named"))
    $P4235 = $P4228."new"($P4231, $P4234, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1373
    store_lex "$meta_args", $P4235
    $P4236 = $P4221."new"($P4225, $P4227, $P4235, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1366
    $P4220."push"($P4236)
.annotate 'line', 1379
    find_lex $P4238, "$/"
    unless_null $P4238, vivify_2077
    $P4238 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4239, $P4238["typename"]
    unless_null $P4239, vivify_2078
    new $P4239, "Undef"
  vivify_2078:
    unless $P4239, if_4237_end
    .const 'Sub' $P4241 = "491_1303430322.161" 
    capture_lex $P4241
    $P4241()
  if_4237_end:
.annotate 'line', 1385
    find_lex $P4251, "$BLOCK"
    unless_null $P4251, vivify_2085
    new $P4251, "Undef"
  vivify_2085:
    find_lex $P4252, "$name"
    unless_null $P4252, vivify_2086
    new $P4252, "Undef"
  vivify_2086:
    $P4251."symbol"($P4252, "attribute" :named("scope"))
.annotate 'line', 1386
    get_hll_global $P4253, ["PAST"], "Stmts"
    $P4254 = $P4253."new"()
    store_lex "$past", $P4254
.annotate 'line', 1363
    .return ($P4254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4240"  :anon :subid("491_1303430322.161") :outer("490_1303430322.161")
.annotate 'line', 1380
    new $P4242, "Undef"
    .lex "$type", $P4242
    find_lex $P4243, "$/"
    unless_null $P4243, vivify_2079
    $P4243 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P4244, $P4243["typename"]
    unless_null $P4244, vivify_2080
    $P4244 = root_new ['parrot';'ResizablePMCArray']
  vivify_2080:
    set $P4245, $P4244[0]
    unless_null $P4245, vivify_2081
    new $P4245, "Undef"
  vivify_2081:
    $P4246 = $P4245."ast"()
    store_lex "$type", $P4246
.annotate 'line', 1381
    find_lex $P4247, "$type"
    unless_null $P4247, vivify_2082
    new $P4247, "Undef"
  vivify_2082:
    $P4247."named"("type")
.annotate 'line', 1382
    find_lex $P4248, "$meta_args"
    unless_null $P4248, vivify_2083
    new $P4248, "Undef"
  vivify_2083:
    find_lex $P4249, "$type"
    unless_null $P4249, vivify_2084
    new $P4249, "Undef"
  vivify_2084:
    $P4250 = $P4248."push"($P4249)
.annotate 'line', 1379
    .return ($P4250)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("492_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4286
    .param pmc param_4287
.annotate 'line', 1408
    .lex "self", param_4286
    .lex "$/", param_4287
    find_lex $P4288, "$/"
    find_lex $P4289, "$/"
    unless_null $P4289, vivify_2088
    $P4289 = root_new ['parrot';'Hash']
  vivify_2088:
    set $P4290, $P4289["routine_def"]
    unless_null $P4290, vivify_2089
    new $P4290, "Undef"
  vivify_2089:
    $P4291 = $P4290."ast"()
    $P4292 = $P4288."!make"($P4291)
    .return ($P4292)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("493_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4294
    .param pmc param_4295
.annotate 'line', 1409
    .lex "self", param_4294
    .lex "$/", param_4295
    find_lex $P4296, "$/"
    find_lex $P4297, "$/"
    unless_null $P4297, vivify_2090
    $P4297 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P4298, $P4297["method_def"]
    unless_null $P4298, vivify_2091
    new $P4298, "Undef"
  vivify_2091:
    $P4299 = $P4298."ast"()
    $P4300 = $P4296."!make"($P4299)
    .return ($P4300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("494_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4302
    .param pmc param_4303
.annotate 'line', 1411
    .const 'Sub' $P4562 = "500_1303430322.161" 
    capture_lex $P4562
    .const 'Sub' $P4323 = "495_1303430322.161" 
    capture_lex $P4323
    .lex "self", param_4302
    .lex "$/", param_4303
.annotate 'line', 1414
    new $P4304, "Undef"
    .lex "$past", $P4304
.annotate 'line', 1425
    new $P4305, "Undef"
    .lex "$block", $P4305
.annotate 'line', 1411
    find_lex $P4306, "$past"
    unless_null $P4306, vivify_2092
    new $P4306, "Undef"
  vivify_2092:
.annotate 'line', 1415
    find_lex $P4308, "$/"
    unless_null $P4308, vivify_2093
    $P4308 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P4309, $P4308["onlystar"]
    unless_null $P4309, vivify_2094
    new $P4309, "Undef"
  vivify_2094:
    if $P4309, if_4307
.annotate 'line', 1419
    find_lex $P4311, "$/"
    unless_null $P4311, vivify_2095
    $P4311 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P4312, $P4311["blockoid"]
    unless_null $P4312, vivify_2096
    new $P4312, "Undef"
  vivify_2096:
    $P4313 = $P4312."ast"()
    store_lex "$past", $P4313
.annotate 'line', 1420
    find_lex $P4314, "$past"
    unless_null $P4314, vivify_2097
    new $P4314, "Undef"
  vivify_2097:
    $P4314."blocktype"("declaration")
.annotate 'line', 1421
    find_dynamic_lex $P4316, "$*RETURN_USED"
    unless_null $P4316, vivify_2098
    get_hll_global $P4316, "$RETURN_USED"
    unless_null $P4316, vivify_2099
    die "Contextual $*RETURN_USED not found"
  vivify_2099:
  vivify_2098:
    unless $P4316, if_4315_end
.annotate 'line', 1422
    find_lex $P4317, "$past"
    unless_null $P4317, vivify_2100
    new $P4317, "Undef"
  vivify_2100:
    $P4317."control"("return_pir")
  if_4315_end:
.annotate 'line', 1418
    goto if_4307_end
  if_4307:
.annotate 'line', 1416
    $P4310 = "only_star_block"()
    store_lex "$past", $P4310
  if_4307_end:
.annotate 'line', 1425
    find_lex $P4318, "$past"
    unless_null $P4318, vivify_2101
    new $P4318, "Undef"
  vivify_2101:
    store_lex "$block", $P4318
.annotate 'line', 1427
    find_lex $P4320, "$/"
    unless_null $P4320, vivify_2102
    $P4320 = root_new ['parrot';'Hash']
  vivify_2102:
    set $P4321, $P4320["deflongname"]
    unless_null $P4321, vivify_2103
    new $P4321, "Undef"
  vivify_2103:
    unless $P4321, if_4319_end
    .const 'Sub' $P4323 = "495_1303430322.161" 
    capture_lex $P4323
    $P4323()
  if_4319_end:
.annotate 'line', 1532
    find_lex $P4551, "$block"
    unless_null $P4551, vivify_2206
    new $P4551, "Undef"
  vivify_2206:
    find_lex $P4552, "$past"
    unless_null $P4552, vivify_2207
    $P4552 = root_new ['parrot';'Hash']
    store_lex "$past", $P4552
  vivify_2207:
    set $P4552["block_past"], $P4551
.annotate 'line', 1533
    find_lex $P4554, "$/"
    unless_null $P4554, vivify_2208
    $P4554 = root_new ['parrot';'Hash']
  vivify_2208:
    set $P4555, $P4554["trait"]
    unless_null $P4555, vivify_2209
    new $P4555, "Undef"
  vivify_2209:
    unless $P4555, if_4553_end
.annotate 'line', 1534
    find_lex $P4557, "$/"
    unless_null $P4557, vivify_2210
    $P4557 = root_new ['parrot';'Hash']
  vivify_2210:
    set $P4558, $P4557["trait"]
    unless_null $P4558, vivify_2211
    new $P4558, "Undef"
  vivify_2211:
    defined $I4559, $P4558
    unless $I4559, for_undef_2212
    iter $P4556, $P4558
    new $P4569, 'ExceptionHandler'
    set_label $P4569, loop4568_handler
    $P4569."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4569
  loop4568_test:
    unless $P4556, loop4568_done
    shift $P4560, $P4556
  loop4568_redo:
    .const 'Sub' $P4562 = "500_1303430322.161" 
    capture_lex $P4562
    $P4562($P4560)
  loop4568_next:
    goto loop4568_test
  loop4568_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4570, exception, 'type'
    eq $P4570, .CONTROL_LOOP_NEXT, loop4568_next
    eq $P4570, .CONTROL_LOOP_REDO, loop4568_redo
  loop4568_done:
    pop_eh 
  for_undef_2212:
  if_4553_end:
.annotate 'line', 1537
    find_lex $P4571, "$/"
    find_lex $P4572, "$past"
    unless_null $P4572, vivify_2215
    new $P4572, "Undef"
  vivify_2215:
    $P4573 = $P4571."!make"($P4572)
.annotate 'line', 1411
    .return ($P4573)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4322"  :anon :subid("495_1303430322.161") :outer("494_1303430322.161")
.annotate 'line', 1427
    .const 'Sub' $P4453 = "499_1303430322.161" 
    capture_lex $P4453
    .const 'Sub' $P4356 = "496_1303430322.161" 
    capture_lex $P4356
.annotate 'line', 1428
    new $P4324, "Undef"
    .lex "$name", $P4324
    find_lex $P4325, "$/"
    unless_null $P4325, vivify_2104
    $P4325 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P4326, $P4325["sigil"]
    unless_null $P4326, vivify_2105
    $P4326 = root_new ['parrot';'ResizablePMCArray']
  vivify_2105:
    set $P4327, $P4326[0]
    unless_null $P4327, vivify_2106
    new $P4327, "Undef"
  vivify_2106:
    set $S4328, $P4327
    new $P4329, 'String'
    set $P4329, $S4328
    find_lex $P4330, "$/"
    unless_null $P4330, vivify_2107
    $P4330 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P4331, $P4330["deflongname"]
    unless_null $P4331, vivify_2108
    $P4331 = root_new ['parrot';'ResizablePMCArray']
  vivify_2108:
    set $P4332, $P4331[0]
    unless_null $P4332, vivify_2109
    new $P4332, "Undef"
  vivify_2109:
    $S4333 = $P4332."ast"()
    concat $P4334, $P4329, $S4333
    store_lex "$name", $P4334
.annotate 'line', 1429
    find_lex $P4335, "$past"
    unless_null $P4335, vivify_2110
    new $P4335, "Undef"
  vivify_2110:
    find_lex $P4336, "$name"
    unless_null $P4336, vivify_2111
    new $P4336, "Undef"
  vivify_2111:
    $P4335."name"($P4336)
.annotate 'line', 1430
    find_dynamic_lex $P4342, "$*SCOPE"
    unless_null $P4342, vivify_2112
    get_hll_global $P4342, "$SCOPE"
    unless_null $P4342, vivify_2113
    die "Contextual $*SCOPE not found"
  vivify_2113:
  vivify_2112:
    set $S4343, $P4342
    iseq $I4344, $S4343, ""
    unless $I4344, unless_4341
    new $P4340, 'Integer'
    set $P4340, $I4344
    goto unless_4341_end
  unless_4341:
    find_dynamic_lex $P4345, "$*SCOPE"
    unless_null $P4345, vivify_2114
    get_hll_global $P4345, "$SCOPE"
    unless_null $P4345, vivify_2115
    die "Contextual $*SCOPE not found"
  vivify_2115:
  vivify_2114:
    set $S4346, $P4345
    iseq $I4347, $S4346, "my"
    new $P4340, 'Integer'
    set $P4340, $I4347
  unless_4341_end:
    unless $P4340, unless_4339
    set $P4338, $P4340
    goto unless_4339_end
  unless_4339:
    find_dynamic_lex $P4348, "$*SCOPE"
    unless_null $P4348, vivify_2116
    get_hll_global $P4348, "$SCOPE"
    unless_null $P4348, vivify_2117
    die "Contextual $*SCOPE not found"
  vivify_2117:
  vivify_2116:
    set $S4349, $P4348
    iseq $I4350, $S4349, "our"
    new $P4338, 'Integer'
    set $P4338, $I4350
  unless_4339_end:
    if $P4338, if_4337
.annotate 'line', 1522
    find_lex $P4536, "$/"
    unless_null $P4536, vivify_2118
    new $P4536, "Undef"
  vivify_2118:
    $P4537 = $P4536."CURSOR"()
    find_dynamic_lex $P4538, "$*SCOPE"
    unless_null $P4538, vivify_2119
    get_hll_global $P4538, "$SCOPE"
    unless_null $P4538, vivify_2120
    die "Contextual $*SCOPE not found"
  vivify_2120:
  vivify_2119:
    concat $P4539, $P4538, " scoped routines are not supported yet"
    $P4537."panic"($P4539)
.annotate 'line', 1521
    goto if_4337_end
  if_4337:
.annotate 'line', 1431
    find_dynamic_lex $P4352, "$*MULTINESS"
    unless_null $P4352, vivify_2121
    get_hll_global $P4352, "$MULTINESS"
    unless_null $P4352, vivify_2122
    die "Contextual $*MULTINESS not found"
  vivify_2122:
  vivify_2121:
    set $S4353, $P4352
    iseq $I4354, $S4353, "multi"
    if $I4354, if_4351
.annotate 'line', 1482
    find_dynamic_lex $P4449, "$*MULTINESS"
    unless_null $P4449, vivify_2123
    get_hll_global $P4449, "$MULTINESS"
    unless_null $P4449, vivify_2124
    die "Contextual $*MULTINESS not found"
  vivify_2124:
  vivify_2123:
    set $S4450, $P4449
    iseq $I4451, $S4450, "proto"
    if $I4451, if_4448
.annotate 'line', 1501
    find_lex $P4489, "$?PACKAGE"
    get_who $P4490, $P4489
    set $P4491, $P4490["@BLOCK"]
    unless_null $P4491, vivify_2125
    $P4491 = root_new ['parrot';'ResizablePMCArray']
  vivify_2125:
    set $P4492, $P4491[0]
    unless_null $P4492, vivify_2126
    $P4492 = root_new ['parrot';'ResizablePMCArray']
  vivify_2126:
    set $P4493, $P4492[0]
    unless_null $P4493, vivify_2127
    new $P4493, "Undef"
  vivify_2127:
    get_hll_global $P4494, ["PAST"], "Var"
    find_lex $P4495, "$name"
    unless_null $P4495, vivify_2128
    new $P4495, "Undef"
  vivify_2128:
    find_lex $P4496, "$past"
    unless_null $P4496, vivify_2129
    new $P4496, "Undef"
  vivify_2129:
    $P4497 = $P4494."new"($P4495 :named("name"), 1 :named("isdecl"), $P4496 :named("viviself"), "lexical" :named("scope"))
    $P4493."push"($P4497)
.annotate 'line', 1503
    find_lex $P4498, "$?PACKAGE"
    get_who $P4499, $P4498
    set $P4500, $P4499["@BLOCK"]
    unless_null $P4500, vivify_2130
    $P4500 = root_new ['parrot';'ResizablePMCArray']
  vivify_2130:
    set $P4501, $P4500[0]
    unless_null $P4501, vivify_2131
    new $P4501, "Undef"
  vivify_2131:
    find_lex $P4502, "$name"
    unless_null $P4502, vivify_2132
    new $P4502, "Undef"
  vivify_2132:
    $P4501."symbol"($P4502, "lexical" :named("scope"))
.annotate 'line', 1504
    find_dynamic_lex $P4504, "$*SCOPE"
    unless_null $P4504, vivify_2133
    get_hll_global $P4504, "$SCOPE"
    unless_null $P4504, vivify_2134
    die "Contextual $*SCOPE not found"
  vivify_2134:
  vivify_2133:
    set $S4505, $P4504
    iseq $I4506, $S4505, "our"
    unless $I4506, if_4503_end
.annotate 'line', 1507
    find_lex $P4507, "$?PACKAGE"
    get_who $P4508, $P4507
    set $P4509, $P4508["@BLOCK"]
    unless_null $P4509, vivify_2135
    $P4509 = root_new ['parrot';'ResizablePMCArray']
  vivify_2135:
    set $P4510, $P4509[0]
    unless_null $P4510, vivify_2136
    $P4510 = root_new ['parrot';'ResizablePMCArray']
  vivify_2136:
    set $P4511, $P4510[0]
    unless_null $P4511, vivify_2137
    new $P4511, "Undef"
  vivify_2137:
    get_hll_global $P4512, ["PAST"], "Op"
.annotate 'line', 1509
    get_hll_global $P4513, ["PAST"], "Var"
    find_lex $P4514, "$name"
    unless_null $P4514, vivify_2138
    new $P4514, "Undef"
  vivify_2138:
    $P4515 = $P4513."new"($P4514 :named("name"), "package" :named("scope"))
.annotate 'line', 1510
    get_hll_global $P4516, ["PAST"], "Var"
    find_lex $P4517, "$name"
    unless_null $P4517, vivify_2139
    new $P4517, "Undef"
  vivify_2139:
    $P4518 = $P4516."new"($P4517 :named("name"), "lexical" :named("scope"))
    $P4519 = $P4512."new"($P4515, $P4518, "bind" :named("pasttype"))
.annotate 'line', 1507
    $P4511."push"($P4519)
.annotate 'line', 1512
    find_lex $P4520, "$?PACKAGE"
    get_who $P4521, $P4520
    set $P4522, $P4521["@BLOCK"]
    unless_null $P4522, vivify_2140
    $P4522 = root_new ['parrot';'ResizablePMCArray']
  vivify_2140:
    set $P4523, $P4522[0]
    unless_null $P4523, vivify_2141
    new $P4523, "Undef"
  vivify_2141:
    $P4524 = $P4523."loadinit"()
    get_hll_global $P4525, ["PAST"], "Op"
.annotate 'line', 1514
    get_hll_global $P4526, ["PAST"], "Var"
    find_lex $P4527, "$name"
    unless_null $P4527, vivify_2142
    new $P4527, "Undef"
  vivify_2142:
    $P4528 = $P4526."new"($P4527 :named("name"), "package" :named("scope"))
.annotate 'line', 1515
    get_hll_global $P4529, ["PAST"], "Val"
    find_lex $P4530, "$past"
    unless_null $P4530, vivify_2143
    new $P4530, "Undef"
  vivify_2143:
    $P4531 = $P4529."new"($P4530 :named("value"))
    $P4532 = $P4525."new"($P4528, $P4531, "bind" :named("pasttype"))
.annotate 'line', 1512
    $P4524."push"($P4532)
  if_4503_end:
.annotate 'line', 1500
    goto if_4448_end
  if_4448:
.annotate 'line', 1482
    .const 'Sub' $P4453 = "499_1303430322.161" 
    capture_lex $P4453
    $P4453()
  if_4448_end:
    goto if_4351_end
  if_4351:
.annotate 'line', 1431
    .const 'Sub' $P4356 = "496_1303430322.161" 
    capture_lex $P4356
    $P4356()
  if_4351_end:
.annotate 'line', 1519
    get_hll_global $P4533, ["PAST"], "Var"
    find_lex $P4534, "$name"
    unless_null $P4534, vivify_2201
    new $P4534, "Undef"
  vivify_2201:
    $P4535 = $P4533."new"($P4534 :named("name"))
    store_lex "$past", $P4535
  if_4337_end:
.annotate 'line', 1526
    find_lex $P4544, "$name"
    unless_null $P4544, vivify_2202
    new $P4544, "Undef"
  vivify_2202:
    set $S4545, $P4544
    iseq $I4546, $S4545, "MAIN"
    if $I4546, if_4543
    new $P4542, 'Integer'
    set $P4542, $I4546
    goto if_4543_end
  if_4543:
    find_dynamic_lex $P4547, "$*MULTINESS"
    unless_null $P4547, vivify_2203
    get_hll_global $P4547, "$MULTINESS"
    unless_null $P4547, vivify_2204
    die "Contextual $*MULTINESS not found"
  vivify_2204:
  vivify_2203:
    set $S4548, $P4547
    isne $I4549, $S4548, "multi"
    new $P4542, 'Integer'
    set $P4542, $I4549
  if_4543_end:
    if $P4542, if_4541
    set $P4540, $P4542
    goto if_4541_end
  if_4541:
.annotate 'line', 1527
    find_lex $P4550, "$block"
    unless_null $P4550, vivify_2205
    new $P4550, "Undef"
  vivify_2205:
    store_dynamic_lex "$*MAIN_SUB", $P4550
.annotate 'line', 1526
    set $P4540, $P4550
  if_4541_end:
.annotate 'line', 1427
    .return ($P4540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4452"  :anon :subid("499_1303430322.161") :outer("495_1303430322.161")
.annotate 'line', 1487
    new $P4454, "Undef"
    .lex "$cholder", $P4454
.annotate 'line', 1486
    find_dynamic_lex $P4456, "$*SCOPE"
    unless_null $P4456, vivify_2144
    get_hll_global $P4456, "$SCOPE"
    unless_null $P4456, vivify_2145
    die "Contextual $*SCOPE not found"
  vivify_2145:
  vivify_2144:
    set $S4457, $P4456
    iseq $I4458, $S4457, "our"
    unless $I4458, if_4455_end
    die "our-scoped protos not yet implemented"
  if_4455_end:
.annotate 'line', 1487
    get_hll_global $P4459, ["PAST"], "Op"
    $P4460 = $P4459."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4460
.annotate 'line', 1488
    find_lex $P4461, "$?PACKAGE"
    get_who $P4462, $P4461
    set $P4463, $P4462["@BLOCK"]
    unless_null $P4463, vivify_2146
    $P4463 = root_new ['parrot';'ResizablePMCArray']
  vivify_2146:
    set $P4464, $P4463[0]
    unless_null $P4464, vivify_2147
    $P4464 = root_new ['parrot';'ResizablePMCArray']
  vivify_2147:
    set $P4465, $P4464[0]
    unless_null $P4465, vivify_2148
    new $P4465, "Undef"
  vivify_2148:
    get_hll_global $P4466, ["PAST"], "Var"
    find_lex $P4467, "$name"
    unless_null $P4467, vivify_2149
    new $P4467, "Undef"
  vivify_2149:
    find_lex $P4468, "$past"
    unless_null $P4468, vivify_2150
    new $P4468, "Undef"
  vivify_2150:
    $P4469 = $P4466."new"($P4467 :named("name"), 1 :named("isdecl"), $P4468 :named("viviself"), "lexical" :named("scope"))
    $P4465."push"($P4469)
.annotate 'line', 1490
    find_lex $P4470, "$?PACKAGE"
    get_who $P4471, $P4470
    set $P4472, $P4471["@BLOCK"]
    unless_null $P4472, vivify_2151
    $P4472 = root_new ['parrot';'ResizablePMCArray']
  vivify_2151:
    set $P4473, $P4472[0]
    unless_null $P4473, vivify_2152
    $P4473 = root_new ['parrot';'ResizablePMCArray']
  vivify_2152:
    set $P4474, $P4473[0]
    unless_null $P4474, vivify_2153
    new $P4474, "Undef"
  vivify_2153:
    get_hll_global $P4475, ["PAST"], "Op"
.annotate 'line', 1492
    get_hll_global $P4476, ["PAST"], "Var"
    find_lex $P4477, "$name"
    unless_null $P4477, vivify_2154
    new $P4477, "Undef"
  vivify_2154:
    $P4478 = $P4476."new"($P4477 :named("name"))
    find_lex $P4479, "$cholder"
    unless_null $P4479, vivify_2155
    new $P4479, "Undef"
  vivify_2155:
    $P4480 = $P4475."new"($P4478, $P4479, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1490
    $P4474."push"($P4480)
.annotate 'line', 1495
    find_lex $P4481, "$?PACKAGE"
    get_who $P4482, $P4481
    set $P4483, $P4482["@BLOCK"]
    unless_null $P4483, vivify_2156
    $P4483 = root_new ['parrot';'ResizablePMCArray']
  vivify_2156:
    set $P4484, $P4483[0]
    unless_null $P4484, vivify_2157
    new $P4484, "Undef"
  vivify_2157:
    find_lex $P4485, "$name"
    unless_null $P4485, vivify_2158
    new $P4485, "Undef"
  vivify_2158:
    find_lex $P4486, "$cholder"
    unless_null $P4486, vivify_2159
    new $P4486, "Undef"
  vivify_2159:
    $P4484."symbol"($P4485, "lexical" :named("scope"), 1 :named("proto"), $P4486 :named("cholder"))
.annotate 'line', 1498
    find_lex $P4487, "$past"
    unless_null $P4487, vivify_2160
    new $P4487, "Undef"
  vivify_2160:
    $P4488 = $P4487."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1482
    .return ($P4488)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4355"  :anon :subid("496_1303430322.161") :outer("495_1303430322.161")
.annotate 'line', 1431
    .const 'Sub' $P4376 = "497_1303430322.161" 
    capture_lex $P4376
.annotate 'line', 1434
    new $P4357, "Undef"
    .lex "$cholder", $P4357
.annotate 'line', 1435
    $P4358 = root_new ['parrot';'Hash']
    .lex "%sym", $P4358
.annotate 'line', 1433
    find_dynamic_lex $P4360, "$*SCOPE"
    unless_null $P4360, vivify_2161
    get_hll_global $P4360, "$SCOPE"
    unless_null $P4360, vivify_2162
    die "Contextual $*SCOPE not found"
  vivify_2162:
  vivify_2161:
    set $S4361, $P4360
    iseq $I4362, $S4361, "our"
    unless $I4362, if_4359_end
    die "our-scoped multis not yet implemented"
  if_4359_end:
    find_lex $P4363, "$cholder"
    unless_null $P4363, vivify_2163
    new $P4363, "Undef"
  vivify_2163:
.annotate 'line', 1435
    find_lex $P4364, "$?PACKAGE"
    get_who $P4365, $P4364
    set $P4366, $P4365["@BLOCK"]
    unless_null $P4366, vivify_2164
    $P4366 = root_new ['parrot';'ResizablePMCArray']
  vivify_2164:
    set $P4367, $P4366[0]
    unless_null $P4367, vivify_2165
    new $P4367, "Undef"
  vivify_2165:
    find_lex $P4368, "$name"
    unless_null $P4368, vivify_2166
    new $P4368, "Undef"
  vivify_2166:
    $P4369 = $P4367."symbol"($P4368)
    store_lex "%sym", $P4369
.annotate 'line', 1436
    find_lex $P4371, "%sym"
    unless_null $P4371, vivify_2167
    $P4371 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P4372, $P4371["cholder"]
    unless_null $P4372, vivify_2168
    new $P4372, "Undef"
  vivify_2168:
    if $P4372, if_4370
.annotate 'line', 1441
    .const 'Sub' $P4376 = "497_1303430322.161" 
    capture_lex $P4376
    $P4376()
    goto if_4370_end
  if_4370:
.annotate 'line', 1437
    find_lex $P4373, "%sym"
    unless_null $P4373, vivify_2196
    $P4373 = root_new ['parrot';'Hash']
  vivify_2196:
    set $P4374, $P4373["cholder"]
    unless_null $P4374, vivify_2197
    new $P4374, "Undef"
  vivify_2197:
    store_lex "$cholder", $P4374
  if_4370_end:
.annotate 'line', 1477
    find_lex $P4444, "$cholder"
    unless_null $P4444, vivify_2198
    new $P4444, "Undef"
  vivify_2198:
    find_lex $P4445, "$past"
    unless_null $P4445, vivify_2199
    new $P4445, "Undef"
  vivify_2199:
    $P4444."push"($P4445)
.annotate 'line', 1480
    find_lex $P4446, "$past"
    unless_null $P4446, vivify_2200
    new $P4446, "Undef"
  vivify_2200:
    $P4447 = "attach_multi_signature"($P4446)
.annotate 'line', 1431
    .return ($P4447)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4375"  :anon :subid("497_1303430322.161") :outer("496_1303430322.161")
.annotate 'line', 1441
    .const 'Sub' $P4392 = "498_1303430322.161" 
    capture_lex $P4392
.annotate 'line', 1448
    new $P4377, "Undef"
    .lex "$found_proto", $P4377
.annotate 'line', 1466
    new $P4378, "Undef"
    .lex "$dispatch_setup", $P4378
.annotate 'line', 1443
    find_lex $P4380, "%sym"
    unless_null $P4380, vivify_2169
    $P4380 = root_new ['parrot';'Hash']
  vivify_2169:
    set $P4381, $P4380["proto"]
    unless_null $P4381, vivify_2170
    new $P4381, "Undef"
  vivify_2170:
    unless $P4381, if_4379_end
.annotate 'line', 1446
    find_lex $P4382, "$/"
    unless_null $P4382, vivify_2171
    new $P4382, "Undef"
  vivify_2171:
    $P4383 = $P4382."CURSOR"()
    $P4383."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4379_end:
.annotate 'line', 1443
    find_lex $P4384, "$found_proto"
    unless_null $P4384, vivify_2172
    new $P4384, "Undef"
  vivify_2172:
.annotate 'line', 1449
    find_lex $P4386, "$?PACKAGE"
    get_who $P4387, $P4386
    set $P4388, $P4387["@BLOCK"]
    unless_null $P4388, vivify_2173
    $P4388 = root_new ['parrot';'ResizablePMCArray']
  vivify_2173:
    defined $I4389, $P4388
    unless $I4389, for_undef_2174
    iter $P4385, $P4388
    new $P4414, 'ExceptionHandler'
    set_label $P4414, loop4413_handler
    $P4414."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4414
  loop4413_test:
    unless $P4385, loop4413_done
    shift $P4390, $P4385
  loop4413_redo:
    .const 'Sub' $P4392 = "498_1303430322.161" 
    capture_lex $P4392
    $P4392($P4390)
  loop4413_next:
    goto loop4413_test
  loop4413_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4415, exception, 'type'
    eq $P4415, .CONTROL_LOOP_NEXT, loop4413_next
    eq $P4415, .CONTROL_LOOP_REDO, loop4413_redo
  loop4413_done:
    pop_eh 
  for_undef_2174:
.annotate 'line', 1460
    find_lex $P4417, "$found_proto"
    unless_null $P4417, vivify_2183
    new $P4417, "Undef"
  vivify_2183:
    if $P4417, unless_4416_end
.annotate 'line', 1461
    find_lex $P4418, "$/"
    unless_null $P4418, vivify_2184
    new $P4418, "Undef"
  vivify_2184:
    $P4419 = $P4418."CURSOR"()
    $P4419."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4416_end:
.annotate 'line', 1465
    get_hll_global $P4420, ["PAST"], "Op"
    $P4421 = $P4420."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4421
.annotate 'line', 1466
    get_hll_global $P4422, ["PAST"], "Op"
.annotate 'line', 1468
    get_hll_global $P4423, ["PAST"], "Var"
    find_lex $P4424, "$name"
    unless_null $P4424, vivify_2185
    new $P4424, "Undef"
  vivify_2185:
    $P4425 = $P4423."new"($P4424 :named("name"), "outer" :named("scope"))
    find_lex $P4426, "$cholder"
    unless_null $P4426, vivify_2186
    new $P4426, "Undef"
  vivify_2186:
    $P4427 = $P4422."new"($P4425, $P4426, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1466
    store_lex "$dispatch_setup", $P4427
.annotate 'line', 1471
    find_lex $P4428, "$?PACKAGE"
    get_who $P4429, $P4428
    set $P4430, $P4429["@BLOCK"]
    unless_null $P4430, vivify_2187
    $P4430 = root_new ['parrot';'ResizablePMCArray']
  vivify_2187:
    set $P4431, $P4430[0]
    unless_null $P4431, vivify_2188
    $P4431 = root_new ['parrot';'ResizablePMCArray']
  vivify_2188:
    set $P4432, $P4431[0]
    unless_null $P4432, vivify_2189
    new $P4432, "Undef"
  vivify_2189:
    get_hll_global $P4433, ["PAST"], "Var"
    find_lex $P4434, "$name"
    unless_null $P4434, vivify_2190
    new $P4434, "Undef"
  vivify_2190:
    find_lex $P4435, "$dispatch_setup"
    unless_null $P4435, vivify_2191
    new $P4435, "Undef"
  vivify_2191:
    $P4436 = $P4433."new"($P4434 :named("name"), 1 :named("isdecl"), $P4435 :named("viviself"), "lexical" :named("scope"))
    $P4432."push"($P4436)
.annotate 'line', 1473
    find_lex $P4437, "$?PACKAGE"
    get_who $P4438, $P4437
    set $P4439, $P4438["@BLOCK"]
    unless_null $P4439, vivify_2192
    $P4439 = root_new ['parrot';'ResizablePMCArray']
  vivify_2192:
    set $P4440, $P4439[0]
    unless_null $P4440, vivify_2193
    new $P4440, "Undef"
  vivify_2193:
    find_lex $P4441, "$name"
    unless_null $P4441, vivify_2194
    new $P4441, "Undef"
  vivify_2194:
    find_lex $P4442, "$cholder"
    unless_null $P4442, vivify_2195
    new $P4442, "Undef"
  vivify_2195:
    $P4443 = $P4440."symbol"($P4441, "lexical" :named("scope"), $P4442 :named("cholder"))
.annotate 'line', 1441
    .return ($P4443)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4391"  :anon :subid("498_1303430322.161") :outer("497_1303430322.161")
    .param pmc param_4394
.annotate 'line', 1450
    $P4393 = root_new ['parrot';'Hash']
    .lex "%sym", $P4393
    .lex "$_", param_4394
    find_lex $P4395, "$_"
    unless_null $P4395, vivify_2175
    new $P4395, "Undef"
  vivify_2175:
    find_lex $P4396, "$name"
    unless_null $P4396, vivify_2176
    new $P4396, "Undef"
  vivify_2176:
    $P4397 = $P4395."symbol"($P4396)
    store_lex "%sym", $P4397
.annotate 'line', 1451
    find_lex $P4402, "%sym"
    unless_null $P4402, vivify_2177
    $P4402 = root_new ['parrot';'Hash']
  vivify_2177:
    set $P4403, $P4402["proto"]
    unless_null $P4403, vivify_2178
    new $P4403, "Undef"
  vivify_2178:
    unless $P4403, unless_4401
    set $P4400, $P4403
    goto unless_4401_end
  unless_4401:
    find_lex $P4404, "%sym"
    unless_null $P4404, vivify_2179
    $P4404 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P4405, $P4404["cholder"]
    unless_null $P4405, vivify_2180
    new $P4405, "Undef"
  vivify_2180:
    set $P4400, $P4405
  unless_4401_end:
    if $P4400, if_4399
.annotate 'line', 1454
    find_lex $P4409, "%sym"
    unless_null $P4409, vivify_2181
    $P4409 = root_new ['parrot';'Hash']
  vivify_2181:
    if $P4409, if_4408
    set $P4407, $P4409
    goto if_4408_end
  if_4408:
.annotate 'line', 1455
    find_lex $P4410, "$/"
    unless_null $P4410, vivify_2182
    new $P4410, "Undef"
  vivify_2182:
    $P4411 = $P4410."CURSOR"()
    $P4412 = $P4411."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1454
    set $P4407, $P4412
  if_4408_end:
    set $P4398, $P4407
.annotate 'line', 1451
    goto if_4399_end
  if_4399:
.annotate 'line', 1452
    new $P4406, "Integer"
    assign $P4406, 1
    store_lex "$found_proto", $P4406
.annotate 'line', 1451
    set $P4398, $P4406
  if_4399_end:
.annotate 'line', 1449
    .return ($P4398)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4561"  :anon :subid("500_1303430322.161") :outer("494_1303430322.161")
    .param pmc param_4563
.annotate 'line', 1534
    .lex "$_", param_4563
    find_lex $P4564, "$_"
    unless_null $P4564, vivify_2213
    new $P4564, "Undef"
  vivify_2213:
    $P4565 = $P4564."ast"()
    find_lex $P4566, "$/"
    unless_null $P4566, vivify_2214
    new $P4566, "Undef"
  vivify_2214:
    $P4567 = $P4565($P4566)
    .return ($P4567)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("501_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4575
    .param pmc param_4576
.annotate 'line', 1541
    .const 'Sub' $P4688 = "503_1303430322.161" 
    capture_lex $P4688
    .const 'Sub' $P4604 = "502_1303430322.161" 
    capture_lex $P4604
    .lex "self", param_4575
    .lex "$/", param_4576
.annotate 'line', 1544
    new $P4577, "Undef"
    .lex "$past", $P4577
.annotate 'line', 1541
    find_lex $P4578, "$past"
    unless_null $P4578, vivify_2216
    new $P4578, "Undef"
  vivify_2216:
.annotate 'line', 1545
    find_lex $P4580, "$/"
    unless_null $P4580, vivify_2217
    $P4580 = root_new ['parrot';'Hash']
  vivify_2217:
    set $P4581, $P4580["onlystar"]
    unless_null $P4581, vivify_2218
    new $P4581, "Undef"
  vivify_2218:
    if $P4581, if_4579
.annotate 'line', 1549
    find_lex $P4583, "$/"
    unless_null $P4583, vivify_2219
    $P4583 = root_new ['parrot';'Hash']
  vivify_2219:
    set $P4584, $P4583["blockoid"]
    unless_null $P4584, vivify_2220
    new $P4584, "Undef"
  vivify_2220:
    $P4585 = $P4584."ast"()
    store_lex "$past", $P4585
.annotate 'line', 1550
    find_lex $P4586, "$past"
    unless_null $P4586, vivify_2221
    new $P4586, "Undef"
  vivify_2221:
    $P4586."blocktype"("declaration")
.annotate 'line', 1551
    find_dynamic_lex $P4588, "$*RETURN_USED"
    unless_null $P4588, vivify_2222
    get_hll_global $P4588, "$RETURN_USED"
    unless_null $P4588, vivify_2223
    die "Contextual $*RETURN_USED not found"
  vivify_2223:
  vivify_2222:
    unless $P4588, if_4587_end
.annotate 'line', 1552
    find_lex $P4589, "$past"
    unless_null $P4589, vivify_2224
    new $P4589, "Undef"
  vivify_2224:
    $P4589."control"("return_pir")
  if_4587_end:
.annotate 'line', 1548
    goto if_4579_end
  if_4579:
.annotate 'line', 1546
    $P4582 = "only_star_block"()
    store_lex "$past", $P4582
  if_4579_end:
.annotate 'line', 1557
    find_lex $P4591, "$past"
    unless_null $P4591, vivify_2225
    $P4591 = root_new ['parrot';'Hash']
  vivify_2225:
    set $P4592, $P4591["signature_has_invocant"]
    unless_null $P4592, vivify_2226
    new $P4592, "Undef"
  vivify_2226:
    if $P4592, unless_4590_end
.annotate 'line', 1558
    find_lex $P4593, "$past"
    unless_null $P4593, vivify_2227
    $P4593 = root_new ['parrot';'ResizablePMCArray']
  vivify_2227:
    set $P4594, $P4593[0]
    unless_null $P4594, vivify_2228
    new $P4594, "Undef"
  vivify_2228:
    get_hll_global $P4595, ["PAST"], "Var"
.annotate 'line', 1560
    get_hll_global $P4596, ["PAST"], "Var"
    $P4597 = $P4596."new"("$?CLASS" :named("name"))
    $P4598 = $P4595."new"("self" :named("name"), "parameter" :named("scope"), $P4597 :named("multitype"))
.annotate 'line', 1558
    $P4594."unshift"($P4598)
  unless_4590_end:
.annotate 'line', 1563
    find_lex $P4599, "$past"
    unless_null $P4599, vivify_2229
    new $P4599, "Undef"
  vivify_2229:
    $P4599."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1566
    find_lex $P4601, "$/"
    unless_null $P4601, vivify_2230
    $P4601 = root_new ['parrot';'Hash']
  vivify_2230:
    set $P4602, $P4601["deflongname"]
    unless_null $P4602, vivify_2231
    new $P4602, "Undef"
  vivify_2231:
    unless $P4602, if_4600_end
    .const 'Sub' $P4604 = "502_1303430322.161" 
    capture_lex $P4604
    $P4604()
  if_4600_end:
.annotate 'line', 1601
    find_dynamic_lex $P4670, "$*SCOPE"
    unless_null $P4670, vivify_2257
    get_hll_global $P4670, "$SCOPE"
    unless_null $P4670, vivify_2258
    die "Contextual $*SCOPE not found"
  vivify_2258:
  vivify_2257:
    set $S4671, $P4670
    iseq $I4672, $S4671, "our"
    unless $I4672, if_4669_end
.annotate 'line', 1602
    find_lex $P4673, "$past"
    unless_null $P4673, vivify_2259
    new $P4673, "Undef"
  vivify_2259:
    $P4673."pirflags"(":nsentry")
  if_4669_end:
.annotate 'line', 1606
    find_lex $P4674, "$/"
    find_lex $P4675, "$past"
    unless_null $P4675, vivify_2260
    new $P4675, "Undef"
  vivify_2260:
    $P4674."!make"($P4675)
.annotate 'line', 1607
    find_lex $P4676, "$past"
    unless_null $P4676, vivify_2261
    new $P4676, "Undef"
  vivify_2261:
    find_lex $P4677, "$past"
    unless_null $P4677, vivify_2262
    $P4677 = root_new ['parrot';'Hash']
    store_lex "$past", $P4677
  vivify_2262:
    set $P4677["block_past"], $P4676
.annotate 'line', 1608
    find_lex $P4680, "$/"
    unless_null $P4680, vivify_2263
    $P4680 = root_new ['parrot';'Hash']
  vivify_2263:
    set $P4681, $P4680["trait"]
    unless_null $P4681, vivify_2264
    new $P4681, "Undef"
  vivify_2264:
    if $P4681, if_4679
    set $P4678, $P4681
    goto if_4679_end
  if_4679:
.annotate 'line', 1609
    find_lex $P4683, "$/"
    unless_null $P4683, vivify_2265
    $P4683 = root_new ['parrot';'Hash']
  vivify_2265:
    set $P4684, $P4683["trait"]
    unless_null $P4684, vivify_2266
    new $P4684, "Undef"
  vivify_2266:
    defined $I4685, $P4684
    unless $I4685, for_undef_2267
    iter $P4682, $P4684
    new $P4695, 'ExceptionHandler'
    set_label $P4695, loop4694_handler
    $P4695."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4695
  loop4694_test:
    unless $P4682, loop4694_done
    shift $P4686, $P4682
  loop4694_redo:
    .const 'Sub' $P4688 = "503_1303430322.161" 
    capture_lex $P4688
    $P4688($P4686)
  loop4694_next:
    goto loop4694_test
  loop4694_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4696, exception, 'type'
    eq $P4696, .CONTROL_LOOP_NEXT, loop4694_next
    eq $P4696, .CONTROL_LOOP_REDO, loop4694_redo
  loop4694_done:
    pop_eh 
  for_undef_2267:
.annotate 'line', 1608
    set $P4678, $P4682
  if_4679_end:
.annotate 'line', 1541
    .return ($P4678)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4603"  :anon :subid("502_1303430322.161") :outer("501_1303430322.161")
.annotate 'line', 1568
    new $P4605, "Undef"
    .lex "$name", $P4605
.annotate 'line', 1573
    new $P4606, "Undef"
    .lex "$to_add", $P4606
.annotate 'line', 1568
    find_lex $P4607, "$/"
    unless_null $P4607, vivify_2232
    $P4607 = root_new ['parrot';'Hash']
  vivify_2232:
    set $P4608, $P4607["private"]
    unless_null $P4608, vivify_2233
    new $P4608, "Undef"
  vivify_2233:
    set $S4609, $P4608
    new $P4610, 'String'
    set $P4610, $S4609
    find_lex $P4611, "$/"
    unless_null $P4611, vivify_2234
    $P4611 = root_new ['parrot';'Hash']
  vivify_2234:
    set $P4612, $P4611["deflongname"]
    unless_null $P4612, vivify_2235
    $P4612 = root_new ['parrot';'ResizablePMCArray']
  vivify_2235:
    set $P4613, $P4612[0]
    unless_null $P4613, vivify_2236
    new $P4613, "Undef"
  vivify_2236:
    $P4614 = $P4613."ast"()
    set $S4615, $P4614
    concat $P4616, $P4610, $S4615
    store_lex "$name", $P4616
.annotate 'line', 1569
    find_lex $P4617, "$past"
    unless_null $P4617, vivify_2237
    new $P4617, "Undef"
  vivify_2237:
    find_lex $P4618, "$name"
    unless_null $P4618, vivify_2238
    new $P4618, "Undef"
  vivify_2238:
    $P4617."name"($P4618)
.annotate 'line', 1573
    find_dynamic_lex $P4621, "$*MULTINESS"
    unless_null $P4621, vivify_2239
    get_hll_global $P4621, "$MULTINESS"
    unless_null $P4621, vivify_2240
    die "Contextual $*MULTINESS not found"
  vivify_2240:
  vivify_2239:
    set $S4622, $P4621
    isne $I4623, $S4622, "proto"
    if $I4623, if_4620
.annotate 'line', 1575
    get_hll_global $P4627, ["PAST"], "Op"
.annotate 'line', 1577
    get_hll_global $P4628, ["PAST"], "Val"
    find_lex $P4629, "$past"
    unless_null $P4629, vivify_2241
    new $P4629, "Undef"
  vivify_2241:
    $P4630 = $P4628."new"($P4629 :named("value"))
.annotate 'line', 1578
    get_hll_global $P4631, ["PAST"], "Op"
    $P4632 = $P4631."new"("list" :named("pasttype"))
    $P4633 = $P4627."new"($P4630, $P4632, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1575
    set $P4619, $P4633
.annotate 'line', 1573
    goto if_4620_end
  if_4620:
.annotate 'line', 1574
    get_hll_global $P4624, ["PAST"], "Val"
    find_lex $P4625, "$past"
    unless_null $P4625, vivify_2242
    new $P4625, "Undef"
  vivify_2242:
    $P4626 = $P4624."new"($P4625 :named("value"))
    set $P4619, $P4626
  if_4620_end:
.annotate 'line', 1573
    store_lex "$to_add", $P4619
.annotate 'line', 1580
    find_dynamic_lex $P4635, "$*MULTINESS"
    unless_null $P4635, vivify_2243
    get_hll_global $P4635, "$MULTINESS"
    unless_null $P4635, vivify_2244
    die "Contextual $*MULTINESS not found"
  vivify_2244:
  vivify_2243:
    set $S4636, $P4635
    iseq $I4637, $S4636, "proto"
    unless $I4637, if_4634_end
    find_lex $P4638, "$past"
    unless_null $P4638, vivify_2245
    new $P4638, "Undef"
  vivify_2245:
    $P4638."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4634_end:
.annotate 'line', 1584
    find_dynamic_lex $P4640, "$*MULTINESS"
    unless_null $P4640, vivify_2246
    get_hll_global $P4640, "$MULTINESS"
    unless_null $P4640, vivify_2247
    die "Contextual $*MULTINESS not found"
  vivify_2247:
  vivify_2246:
    set $S4641, $P4640
    iseq $I4642, $S4641, "multi"
    unless $I4642, if_4639_end
    find_lex $P4643, "$past"
    unless_null $P4643, vivify_2248
    new $P4643, "Undef"
  vivify_2248:
    "attach_multi_signature"($P4643)
  if_4639_end:
.annotate 'line', 1587
    find_dynamic_lex $P4646, "$*PACKAGE-SETUP"
    unless_null $P4646, vivify_2249
    get_hll_global $P4646, "$PACKAGE-SETUP"
    unless_null $P4646, vivify_2250
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2250:
  vivify_2249:
    defined $I4647, $P4646
    if $I4647, if_4645
    new $P4644, 'Integer'
    set $P4644, $I4647
    goto if_4645_end
  if_4645:
.annotate 'line', 1588
    find_dynamic_lex $P4648, "$*PACKAGE-SETUP"
    unless_null $P4648, vivify_2251
    get_hll_global $P4648, "$PACKAGE-SETUP"
    unless_null $P4648, vivify_2252
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2252:
  vivify_2251:
    get_hll_global $P4649, ["PAST"], "Op"
.annotate 'line', 1589
    find_dynamic_lex $P4652, "$*MULTINESS"
    unless_null $P4652, vivify_2253
    get_hll_global $P4652, "$MULTINESS"
    unless_null $P4652, vivify_2254
    die "Contextual $*MULTINESS not found"
  vivify_2254:
  vivify_2253:
    set $S4653, $P4652
    iseq $I4654, $S4653, "multi"
    if $I4654, if_4651
    new $P4656, "String"
    assign $P4656, "add_method"
    set $P4650, $P4656
    goto if_4651_end
  if_4651:
    new $P4655, "String"
    assign $P4655, "add_multi_method"
    set $P4650, $P4655
  if_4651_end:
.annotate 'line', 1590
    get_hll_global $P4657, ["PAST"], "Op"
.annotate 'line', 1593
    get_hll_global $P4658, ["PAST"], "Var"
    $P4659 = $P4658."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4660 = $P4657."new"($P4659, "get_how PP" :named("pirop"))
.annotate 'line', 1595
    get_hll_global $P4661, ["PAST"], "Var"
    $P4662 = $P4661."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1596
    get_hll_global $P4663, ["PAST"], "Val"
    find_lex $P4664, "$name"
    unless_null $P4664, vivify_2255
    new $P4664, "Undef"
  vivify_2255:
    $P4665 = $P4663."new"($P4664 :named("value"))
    find_lex $P4666, "$to_add"
    unless_null $P4666, vivify_2256
    new $P4666, "Undef"
  vivify_2256:
    $P4667 = $P4649."new"($P4660, $P4662, $P4665, $P4666, "callmethod" :named("pasttype"), $P4650 :named("name"))
.annotate 'line', 1588
    $P4668 = $P4648."push"($P4667)
.annotate 'line', 1587
    set $P4644, $P4668
  if_4645_end:
.annotate 'line', 1566
    .return ($P4644)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4687"  :anon :subid("503_1303430322.161") :outer("501_1303430322.161")
    .param pmc param_4689
.annotate 'line', 1609
    .lex "$_", param_4689
    find_lex $P4690, "$_"
    unless_null $P4690, vivify_2268
    new $P4690, "Undef"
  vivify_2268:
    $P4691 = $P4690."ast"()
    find_lex $P4692, "$/"
    unless_null $P4692, vivify_2269
    new $P4692, "Undef"
  vivify_2269:
    $P4693 = $P4691($P4692)
    .return ($P4693)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("504_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4700
    .param pmc param_4701
.annotate 'line', 1641
    .const 'Sub' $P4738 = "506_1303430322.161" 
    capture_lex $P4738
    .const 'Sub' $P4712 = "505_1303430322.161" 
    capture_lex $P4712
    .lex "self", param_4700
    .lex "$/", param_4701
.annotate 'line', 1642
    new $P4702, "Undef"
    .lex "$BLOCKINIT", $P4702
    find_lex $P4703, "$?PACKAGE"
    get_who $P4704, $P4703
    set $P4705, $P4704["@BLOCK"]
    unless_null $P4705, vivify_2270
    $P4705 = root_new ['parrot';'ResizablePMCArray']
  vivify_2270:
    set $P4706, $P4705[0]
    unless_null $P4706, vivify_2271
    $P4706 = root_new ['parrot';'ResizablePMCArray']
  vivify_2271:
    set $P4707, $P4706[0]
    unless_null $P4707, vivify_2272
    new $P4707, "Undef"
  vivify_2272:
    store_lex "$BLOCKINIT", $P4707
.annotate 'line', 1643
    find_lex $P4709, "$/"
    unless_null $P4709, vivify_2273
    $P4709 = root_new ['parrot';'Hash']
  vivify_2273:
    set $P4710, $P4709["invocant"]
    unless_null $P4710, vivify_2274
    new $P4710, "Undef"
  vivify_2274:
    unless $P4710, if_4708_end
    .const 'Sub' $P4712 = "505_1303430322.161" 
    capture_lex $P4712
    $P4712()
  if_4708_end:
.annotate 'line', 1652
    find_lex $P4733, "$/"
    unless_null $P4733, vivify_2284
    $P4733 = root_new ['parrot';'Hash']
  vivify_2284:
    set $P4734, $P4733["parameter"]
    unless_null $P4734, vivify_2285
    new $P4734, "Undef"
  vivify_2285:
    defined $I4735, $P4734
    unless $I4735, for_undef_2286
    iter $P4732, $P4734
    new $P4745, 'ExceptionHandler'
    set_label $P4745, loop4744_handler
    $P4745."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4745
  loop4744_test:
    unless $P4732, loop4744_done
    shift $P4736, $P4732
  loop4744_redo:
    .const 'Sub' $P4738 = "506_1303430322.161" 
    capture_lex $P4738
    $P4738($P4736)
  loop4744_next:
    goto loop4744_test
  loop4744_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4746, exception, 'type'
    eq $P4746, .CONTROL_LOOP_NEXT, loop4744_next
    eq $P4746, .CONTROL_LOOP_REDO, loop4744_redo
  loop4744_done:
    pop_eh 
  for_undef_2286:
.annotate 'line', 1641
    .return ($P4732)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4711"  :anon :subid("505_1303430322.161") :outer("504_1303430322.161")
.annotate 'line', 1644
    new $P4713, "Undef"
    .lex "$inv", $P4713
    find_lex $P4714, "$/"
    unless_null $P4714, vivify_2275
    $P4714 = root_new ['parrot';'Hash']
  vivify_2275:
    set $P4715, $P4714["invocant"]
    unless_null $P4715, vivify_2276
    $P4715 = root_new ['parrot';'ResizablePMCArray']
  vivify_2276:
    set $P4716, $P4715[0]
    unless_null $P4716, vivify_2277
    new $P4716, "Undef"
  vivify_2277:
    $P4717 = $P4716."ast"()
    store_lex "$inv", $P4717
.annotate 'line', 1645
    find_lex $P4718, "$BLOCKINIT"
    unless_null $P4718, vivify_2278
    new $P4718, "Undef"
  vivify_2278:
    find_lex $P4719, "$inv"
    unless_null $P4719, vivify_2279
    new $P4719, "Undef"
  vivify_2279:
    $P4718."push"($P4719)
.annotate 'line', 1646
    find_lex $P4720, "$BLOCKINIT"
    unless_null $P4720, vivify_2280
    new $P4720, "Undef"
  vivify_2280:
    get_hll_global $P4721, ["PAST"], "Var"
.annotate 'line', 1648
    get_hll_global $P4722, ["PAST"], "Var"
    find_lex $P4723, "$inv"
    unless_null $P4723, vivify_2281
    new $P4723, "Undef"
  vivify_2281:
    $P4724 = $P4723."name"()
    $P4725 = $P4722."new"("lexical" :named("scope"), $P4724 :named("name"))
    $P4726 = $P4721."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4725 :named("viviself"))
.annotate 'line', 1646
    $P4720."push"($P4726)
.annotate 'line', 1650
    new $P4727, "Integer"
    assign $P4727, 1
    find_lex $P4728, "$?PACKAGE"
    get_who $P4729, $P4728
    set $P4730, $P4729["@BLOCK"]
    unless_null $P4730, vivify_2282
    $P4730 = root_new ['parrot';'ResizablePMCArray']
    set $P4729["@BLOCK"], $P4730
  vivify_2282:
    set $P4731, $P4730[0]
    unless_null $P4731, vivify_2283
    $P4731 = root_new ['parrot';'Hash']
    set $P4730[0], $P4731
  vivify_2283:
    set $P4731["signature_has_invocant"], $P4727
.annotate 'line', 1643
    .return ($P4727)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4737"  :anon :subid("506_1303430322.161") :outer("504_1303430322.161")
    .param pmc param_4739
.annotate 'line', 1652
    .lex "$_", param_4739
    find_lex $P4740, "$BLOCKINIT"
    unless_null $P4740, vivify_2287
    new $P4740, "Undef"
  vivify_2287:
    find_lex $P4741, "$_"
    unless_null $P4741, vivify_2288
    new $P4741, "Undef"
  vivify_2288:
    $P4742 = $P4741."ast"()
    $P4743 = $P4740."push"($P4742)
    .return ($P4743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("507_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4748
    .param pmc param_4749
.annotate 'line', 1655
    .lex "self", param_4748
    .lex "$/", param_4749
.annotate 'line', 1656
    new $P4750, "Undef"
    .lex "$quant", $P4750
.annotate 'line', 1657
    new $P4751, "Undef"
    .lex "$past", $P4751
.annotate 'line', 1656
    find_lex $P4752, "$/"
    unless_null $P4752, vivify_2289
    $P4752 = root_new ['parrot';'Hash']
  vivify_2289:
    set $P4753, $P4752["quant"]
    unless_null $P4753, vivify_2290
    new $P4753, "Undef"
  vivify_2290:
    store_lex "$quant", $P4753
    find_lex $P4754, "$past"
    unless_null $P4754, vivify_2291
    new $P4754, "Undef"
  vivify_2291:
.annotate 'line', 1658
    find_lex $P4756, "$/"
    unless_null $P4756, vivify_2292
    $P4756 = root_new ['parrot';'Hash']
  vivify_2292:
    set $P4757, $P4756["named_param"]
    unless_null $P4757, vivify_2293
    new $P4757, "Undef"
  vivify_2293:
    if $P4757, if_4755
.annotate 'line', 1665
    find_lex $P4771, "$/"
    unless_null $P4771, vivify_2294
    $P4771 = root_new ['parrot';'Hash']
  vivify_2294:
    set $P4772, $P4771["param_var"]
    unless_null $P4772, vivify_2295
    new $P4772, "Undef"
  vivify_2295:
    $P4773 = $P4772."ast"()
    store_lex "$past", $P4773
.annotate 'line', 1666
    find_lex $P4775, "$quant"
    unless_null $P4775, vivify_2296
    new $P4775, "Undef"
  vivify_2296:
    set $S4776, $P4775
    iseq $I4777, $S4776, "*"
    if $I4777, if_4774
.annotate 'line', 1670
    find_lex $P4786, "$quant"
    unless_null $P4786, vivify_2297
    new $P4786, "Undef"
  vivify_2297:
    set $S4787, $P4786
    iseq $I4788, $S4787, "?"
    unless $I4788, if_4785_end
.annotate 'line', 1671
    find_lex $P4789, "$past"
    unless_null $P4789, vivify_2298
    new $P4789, "Undef"
  vivify_2298:
    find_lex $P4790, "$/"
    unless_null $P4790, vivify_2299
    $P4790 = root_new ['parrot';'Hash']
  vivify_2299:
    set $P4791, $P4790["param_var"]
    unless_null $P4791, vivify_2300
    $P4791 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4792, $P4791["sigil"]
    unless_null $P4792, vivify_2301
    new $P4792, "Undef"
  vivify_2301:
    $P4793 = "vivitype"($P4792)
    $P4789."viviself"($P4793)
  if_4785_end:
.annotate 'line', 1670
    goto if_4774_end
  if_4774:
.annotate 'line', 1667
    find_lex $P4778, "$past"
    unless_null $P4778, vivify_2302
    new $P4778, "Undef"
  vivify_2302:
    $P4778."slurpy"(1)
.annotate 'line', 1668
    find_lex $P4779, "$past"
    unless_null $P4779, vivify_2303
    new $P4779, "Undef"
  vivify_2303:
    find_lex $P4780, "$/"
    unless_null $P4780, vivify_2304
    $P4780 = root_new ['parrot';'Hash']
  vivify_2304:
    set $P4781, $P4780["param_var"]
    unless_null $P4781, vivify_2305
    $P4781 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P4782, $P4781["sigil"]
    unless_null $P4782, vivify_2306
    new $P4782, "Undef"
  vivify_2306:
    set $S4783, $P4782
    iseq $I4784, $S4783, "%"
    $P4779."named"($I4784)
  if_4774_end:
.annotate 'line', 1664
    goto if_4755_end
  if_4755:
.annotate 'line', 1659
    find_lex $P4758, "$/"
    unless_null $P4758, vivify_2307
    $P4758 = root_new ['parrot';'Hash']
  vivify_2307:
    set $P4759, $P4758["named_param"]
    unless_null $P4759, vivify_2308
    new $P4759, "Undef"
  vivify_2308:
    $P4760 = $P4759."ast"()
    store_lex "$past", $P4760
.annotate 'line', 1660
    find_lex $P4762, "$quant"
    unless_null $P4762, vivify_2309
    new $P4762, "Undef"
  vivify_2309:
    set $S4763, $P4762
    isne $I4764, $S4763, "!"
    unless $I4764, if_4761_end
.annotate 'line', 1661
    find_lex $P4765, "$past"
    unless_null $P4765, vivify_2310
    new $P4765, "Undef"
  vivify_2310:
    find_lex $P4766, "$/"
    unless_null $P4766, vivify_2311
    $P4766 = root_new ['parrot';'Hash']
  vivify_2311:
    set $P4767, $P4766["named_param"]
    unless_null $P4767, vivify_2312
    $P4767 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P4768, $P4767["param_var"]
    unless_null $P4768, vivify_2313
    $P4768 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P4769, $P4768["sigil"]
    unless_null $P4769, vivify_2314
    new $P4769, "Undef"
  vivify_2314:
    $P4770 = "vivitype"($P4769)
    $P4765."viviself"($P4770)
  if_4761_end:
  if_4755_end:
.annotate 'line', 1674
    find_lex $P4795, "$/"
    unless_null $P4795, vivify_2315
    $P4795 = root_new ['parrot';'Hash']
  vivify_2315:
    set $P4796, $P4795["default_value"]
    unless_null $P4796, vivify_2316
    new $P4796, "Undef"
  vivify_2316:
    unless $P4796, if_4794_end
.annotate 'line', 1675
    find_lex $P4798, "$quant"
    unless_null $P4798, vivify_2317
    new $P4798, "Undef"
  vivify_2317:
    set $S4799, $P4798
    iseq $I4800, $S4799, "*"
    unless $I4800, if_4797_end
.annotate 'line', 1676
    find_lex $P4801, "$/"
    unless_null $P4801, vivify_2318
    new $P4801, "Undef"
  vivify_2318:
    $P4802 = $P4801."CURSOR"()
    $P4802."panic"("Can't put default on slurpy parameter")
  if_4797_end:
.annotate 'line', 1678
    find_lex $P4804, "$quant"
    unless_null $P4804, vivify_2319
    new $P4804, "Undef"
  vivify_2319:
    set $S4805, $P4804
    iseq $I4806, $S4805, "!"
    unless $I4806, if_4803_end
.annotate 'line', 1679
    find_lex $P4807, "$/"
    unless_null $P4807, vivify_2320
    new $P4807, "Undef"
  vivify_2320:
    $P4808 = $P4807."CURSOR"()
    $P4808."panic"("Can't put default on required parameter")
  if_4803_end:
.annotate 'line', 1681
    find_lex $P4809, "$past"
    unless_null $P4809, vivify_2321
    new $P4809, "Undef"
  vivify_2321:
    find_lex $P4810, "$/"
    unless_null $P4810, vivify_2322
    $P4810 = root_new ['parrot';'Hash']
  vivify_2322:
    set $P4811, $P4810["default_value"]
    unless_null $P4811, vivify_2323
    $P4811 = root_new ['parrot';'ResizablePMCArray']
  vivify_2323:
    set $P4812, $P4811[0]
    unless_null $P4812, vivify_2324
    $P4812 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P4813, $P4812["EXPR"]
    unless_null $P4813, vivify_2325
    new $P4813, "Undef"
  vivify_2325:
    $P4814 = $P4813."ast"()
    $P4809."viviself"($P4814)
  if_4794_end:
.annotate 'line', 1683
    find_lex $P4816, "$past"
    unless_null $P4816, vivify_2326
    new $P4816, "Undef"
  vivify_2326:
    $P4817 = $P4816."viviself"()
    if $P4817, unless_4815_end
    find_lex $P4818, "$?PACKAGE"
    get_who $P4819, $P4818
    set $P4820, $P4819["@BLOCK"]
    unless_null $P4820, vivify_2327
    $P4820 = root_new ['parrot';'ResizablePMCArray']
  vivify_2327:
    set $P4821, $P4820[0]
    unless_null $P4821, vivify_2328
    new $P4821, "Undef"
  vivify_2328:
    find_lex $P4822, "$?PACKAGE"
    get_who $P4823, $P4822
    set $P4824, $P4823["@BLOCK"]
    unless_null $P4824, vivify_2329
    $P4824 = root_new ['parrot';'ResizablePMCArray']
  vivify_2329:
    set $P4825, $P4824[0]
    unless_null $P4825, vivify_2330
    new $P4825, "Undef"
  vivify_2330:
    $P4826 = $P4825."arity"()
    set $N4827, $P4826
    new $P4828, 'Float'
    set $P4828, $N4827
    add $P4829, $P4828, 1
    $P4821."arity"($P4829)
  unless_4815_end:
.annotate 'line', 1687
    find_lex $P4831, "$/"
    unless_null $P4831, vivify_2331
    $P4831 = root_new ['parrot';'Hash']
  vivify_2331:
    set $P4832, $P4831["typename"]
    unless_null $P4832, vivify_2332
    new $P4832, "Undef"
  vivify_2332:
    unless $P4832, if_4830_end
.annotate 'line', 1688
    find_lex $P4833, "$past"
    unless_null $P4833, vivify_2333
    new $P4833, "Undef"
  vivify_2333:
    find_lex $P4834, "$/"
    unless_null $P4834, vivify_2334
    $P4834 = root_new ['parrot';'Hash']
  vivify_2334:
    set $P4835, $P4834["typename"]
    unless_null $P4835, vivify_2335
    $P4835 = root_new ['parrot';'ResizablePMCArray']
  vivify_2335:
    set $P4836, $P4835[0]
    unless_null $P4836, vivify_2336
    new $P4836, "Undef"
  vivify_2336:
    $P4837 = $P4836."ast"()
    $P4833."multitype"($P4837)
  if_4830_end:
.annotate 'line', 1692
    find_lex $P4839, "$/"
    unless_null $P4839, vivify_2337
    $P4839 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P4840, $P4839["definedness"]
    unless_null $P4840, vivify_2338
    new $P4840, "Undef"
  vivify_2338:
    unless $P4840, if_4838_end
.annotate 'line', 1693
    find_lex $P4841, "$/"
    unless_null $P4841, vivify_2339
    $P4841 = root_new ['parrot';'Hash']
  vivify_2339:
    set $P4842, $P4841["definedness"]
    unless_null $P4842, vivify_2340
    $P4842 = root_new ['parrot';'ResizablePMCArray']
  vivify_2340:
    set $P4843, $P4842[0]
    unless_null $P4843, vivify_2341
    new $P4843, "Undef"
  vivify_2341:
    set $S4844, $P4843
    new $P4845, 'String'
    set $P4845, $S4844
    find_lex $P4846, "$past"
    unless_null $P4846, vivify_2342
    $P4846 = root_new ['parrot';'Hash']
    store_lex "$past", $P4846
  vivify_2342:
    set $P4846["definedness"], $P4845
  if_4838_end:
.annotate 'line', 1696
    find_lex $P4847, "$/"
    find_lex $P4848, "$past"
    unless_null $P4848, vivify_2343
    new $P4848, "Undef"
  vivify_2343:
    $P4849 = $P4847."!make"($P4848)
.annotate 'line', 1655
    .return ($P4849)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("508_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4851
    .param pmc param_4852
.annotate 'line', 1699
    .lex "self", param_4851
    .lex "$/", param_4852
.annotate 'line', 1700
    new $P4853, "Undef"
    .lex "$name", $P4853
.annotate 'line', 1701
    new $P4854, "Undef"
    .lex "$past", $P4854
.annotate 'line', 1700
    find_lex $P4855, "$/"
    unless_null $P4855, vivify_2344
    new $P4855, "Undef"
  vivify_2344:
    set $S4856, $P4855
    new $P4857, 'String'
    set $P4857, $S4856
    store_lex "$name", $P4857
.annotate 'line', 1701
    get_hll_global $P4858, ["PAST"], "Var"
    find_lex $P4859, "$name"
    unless_null $P4859, vivify_2345
    new $P4859, "Undef"
  vivify_2345:
    find_lex $P4860, "$/"
    unless_null $P4860, vivify_2346
    new $P4860, "Undef"
  vivify_2346:
    $P4861 = $P4858."new"($P4859 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4860 :named("node"))
    store_lex "$past", $P4861
.annotate 'line', 1703
    find_lex $P4862, "$?PACKAGE"
    get_who $P4863, $P4862
    set $P4864, $P4863["@BLOCK"]
    unless_null $P4864, vivify_2347
    $P4864 = root_new ['parrot';'ResizablePMCArray']
  vivify_2347:
    set $P4865, $P4864[0]
    unless_null $P4865, vivify_2348
    new $P4865, "Undef"
  vivify_2348:
    find_lex $P4866, "$name"
    unless_null $P4866, vivify_2349
    new $P4866, "Undef"
  vivify_2349:
    $P4865."symbol"($P4866, "lexical" :named("scope"))
.annotate 'line', 1704
    find_lex $P4867, "$/"
    find_lex $P4868, "$past"
    unless_null $P4868, vivify_2350
    new $P4868, "Undef"
  vivify_2350:
    $P4869 = $P4867."!make"($P4868)
.annotate 'line', 1699
    .return ($P4869)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("509_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4871
    .param pmc param_4872
.annotate 'line', 1707
    .lex "self", param_4871
    .lex "$/", param_4872
.annotate 'line', 1708
    new $P4873, "Undef"
    .lex "$past", $P4873
    find_lex $P4874, "$/"
    unless_null $P4874, vivify_2351
    $P4874 = root_new ['parrot';'Hash']
  vivify_2351:
    set $P4875, $P4874["param_var"]
    unless_null $P4875, vivify_2352
    new $P4875, "Undef"
  vivify_2352:
    $P4876 = $P4875."ast"()
    store_lex "$past", $P4876
.annotate 'line', 1709
    find_lex $P4877, "$past"
    unless_null $P4877, vivify_2353
    new $P4877, "Undef"
  vivify_2353:
    find_lex $P4878, "$/"
    unless_null $P4878, vivify_2354
    $P4878 = root_new ['parrot';'Hash']
  vivify_2354:
    set $P4879, $P4878["param_var"]
    unless_null $P4879, vivify_2355
    $P4879 = root_new ['parrot';'Hash']
  vivify_2355:
    set $P4880, $P4879["name"]
    unless_null $P4880, vivify_2356
    new $P4880, "Undef"
  vivify_2356:
    set $S4881, $P4880
    $P4877."named"($S4881)
.annotate 'line', 1710
    find_lex $P4882, "$/"
    find_lex $P4883, "$past"
    unless_null $P4883, vivify_2357
    new $P4883, "Undef"
  vivify_2357:
    $P4884 = $P4882."!make"($P4883)
.annotate 'line', 1707
    .return ($P4884)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("510_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4886
    .param pmc param_4887
.annotate 'line', 1713
    .lex "self", param_4886
    .lex "$/", param_4887
.annotate 'line', 1714
    $P4888 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4888
    get_hll_global $P4889, ["HLL"], "Compiler"
    find_lex $P4890, "$/"
    unless_null $P4890, vivify_2358
    new $P4890, "Undef"
  vivify_2358:
    set $S4891, $P4890
    $P4892 = $P4889."parse_name"($S4891)
    store_lex "@name", $P4892
.annotate 'line', 1715
    find_lex $P4893, "$/"
    get_hll_global $P4894, ["PAST"], "Var"
.annotate 'line', 1716
    find_lex $P4895, "@name"
    unless_null $P4895, vivify_2359
    $P4895 = root_new ['parrot';'ResizablePMCArray']
  vivify_2359:
    $P4896 = $P4895."pop"()
    find_lex $P4897, "@name"
    unless_null $P4897, vivify_2360
    $P4897 = root_new ['parrot';'ResizablePMCArray']
  vivify_2360:
    $P4898 = $P4894."new"($P4896 :named("name"), $P4897 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1715
    $P4899 = $P4893."!make"($P4898)
.annotate 'line', 1713
    .return ($P4899)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("511_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4901
    .param pmc param_4902
.annotate 'line', 1722
    .lex "self", param_4901
    .lex "$/", param_4902
.annotate 'line', 1723
    find_lex $P4903, "$/"
    find_lex $P4904, "$/"
    unless_null $P4904, vivify_2361
    $P4904 = root_new ['parrot';'Hash']
  vivify_2361:
    set $P4905, $P4904["trait_mod"]
    unless_null $P4905, vivify_2362
    new $P4905, "Undef"
  vivify_2362:
    $P4906 = $P4905."ast"()
    $P4907 = $P4903."!make"($P4906)
.annotate 'line', 1722
    .return ($P4907)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("512_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4909
    .param pmc param_4910
.annotate 'line', 1726
    .const 'Sub' $P4930 = "513_1303430322.161" 
    capture_lex $P4930
    .lex "self", param_4909
    .lex "$/", param_4910
.annotate 'line', 1727
    new $P4911, "Undef"
    .lex "$cpast", $P4911
    find_lex $P4912, "$/"
    unless_null $P4912, vivify_2363
    $P4912 = root_new ['parrot';'Hash']
  vivify_2363:
    set $P4913, $P4912["circumfix"]
    unless_null $P4913, vivify_2364
    $P4913 = root_new ['parrot';'ResizablePMCArray']
  vivify_2364:
    set $P4914, $P4913[0]
    unless_null $P4914, vivify_2365
    new $P4914, "Undef"
  vivify_2365:
    $P4915 = $P4914."ast"()
    store_lex "$cpast", $P4915
.annotate 'line', 1728
    find_lex $P4918, "$/"
    unless_null $P4918, vivify_2366
    $P4918 = root_new ['parrot';'Hash']
  vivify_2366:
    set $P4919, $P4918["longname"]
    unless_null $P4919, vivify_2367
    new $P4919, "Undef"
  vivify_2367:
    set $S4920, $P4919
    iseq $I4921, $S4920, "parrot_vtable"
    if $I4921, if_4917
.annotate 'line', 1748
    find_lex $P4956, "$/"
    unless_null $P4956, vivify_2368
    $P4956 = root_new ['parrot';'Hash']
  vivify_2368:
    set $P4957, $P4956["longname"]
    unless_null $P4957, vivify_2369
    new $P4957, "Undef"
  vivify_2369:
    set $S4958, $P4957
    iseq $I4959, $S4958, "pirflags"
    if $I4959, if_4955
.annotate 'line', 1752
    find_lex $P4963, "$/"
    unless_null $P4963, vivify_2370
    new $P4963, "Undef"
  vivify_2370:
    $P4964 = $P4963."CURSOR"()
    new $P4965, 'String'
    set $P4965, "Trait '"
    find_lex $P4966, "$/"
    unless_null $P4966, vivify_2371
    $P4966 = root_new ['parrot';'Hash']
  vivify_2371:
    set $P4967, $P4966["longname"]
    unless_null $P4967, vivify_2372
    new $P4967, "Undef"
  vivify_2372:
    concat $P4968, $P4965, $P4967
    concat $P4969, $P4968, "' not implemented"
    $P4970 = $P4964."panic"($P4969)
.annotate 'line', 1751
    set $P4954, $P4970
.annotate 'line', 1748
    goto if_4955_end
  if_4955:
.annotate 'line', 1749
    find_lex $P4960, "$/"
    unless_null $P4960, vivify_2373
    new $P4960, "Undef"
  vivify_2373:
    $P4961 = $P4960."CURSOR"()
    $P4962 = $P4961."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1748
    set $P4954, $P4962
  if_4955_end:
    set $P4916, $P4954
.annotate 'line', 1728
    goto if_4917_end
  if_4917:
.annotate 'line', 1731
    get_hll_global $P4923, ["PAST"], "Val"
    find_lex $P4924, "$cpast"
    unless_null $P4924, vivify_2374
    new $P4924, "Undef"
  vivify_2374:
    $P4925 = $P4923."ACCEPTS"($P4924)
    if $P4925, unless_4922_end
.annotate 'line', 1730
    find_lex $P4926, "$/"
    unless_null $P4926, vivify_2375
    new $P4926, "Undef"
  vivify_2375:
    $P4927 = $P4926."CURSOR"()
    $P4927."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4922_end:
.annotate 'line', 1732
    find_lex $P4928, "$/"
    .const 'Sub' $P4930 = "513_1303430322.161" 
    newclosure $P4952, $P4930
    $P4953 = $P4928."!make"($P4952)
.annotate 'line', 1728
    set $P4916, $P4953
  if_4917_end:
.annotate 'line', 1726
    .return ($P4916)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4929"  :anon :subid("513_1303430322.161") :outer("512_1303430322.161")
    .param pmc param_4931
.annotate 'line', 1732
    .lex "$match", param_4931
.annotate 'line', 1733
    new $P4932, "Undef"
    .lex "$meth", $P4932
    find_lex $P4933, "$match"
    unless_null $P4933, vivify_2376
    new $P4933, "Undef"
  vivify_2376:
    $P4934 = $P4933."ast"()
    set $P4935, $P4934["block_past"]
    unless_null $P4935, vivify_2377
    new $P4935, "Undef"
  vivify_2377:
    store_lex "$meth", $P4935
.annotate 'line', 1734
    find_dynamic_lex $P4938, "$*PACKAGE-SETUP"
    unless_null $P4938, vivify_2378
    get_hll_global $P4938, "$PACKAGE-SETUP"
    unless_null $P4938, vivify_2379
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2379:
  vivify_2378:
    defined $I4939, $P4938
    if $I4939, if_4937
    new $P4936, 'Integer'
    set $P4936, $I4939
    goto if_4937_end
  if_4937:
.annotate 'line', 1735
    find_dynamic_lex $P4940, "$*PACKAGE-SETUP"
    unless_null $P4940, vivify_2380
    get_hll_global $P4940, "$PACKAGE-SETUP"
    unless_null $P4940, vivify_2381
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2381:
  vivify_2380:
    get_hll_global $P4941, ["PAST"], "Op"
.annotate 'line', 1737
    get_hll_global $P4942, ["PAST"], "Op"
.annotate 'line', 1740
    get_hll_global $P4943, ["PAST"], "Var"
    $P4944 = $P4943."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4945 = $P4942."new"($P4944, "get_how PP" :named("pirop"))
.annotate 'line', 1742
    get_hll_global $P4946, ["PAST"], "Var"
    $P4947 = $P4946."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4948, "$cpast"
    unless_null $P4948, vivify_2382
    new $P4948, "Undef"
  vivify_2382:
    find_lex $P4949, "$meth"
    unless_null $P4949, vivify_2383
    new $P4949, "Undef"
  vivify_2383:
    $P4950 = $P4941."new"($P4945, $P4947, $P4948, $P4949, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1735
    $P4951 = $P4940."push"($P4950)
.annotate 'line', 1734
    set $P4936, $P4951
  if_4937_end:
.annotate 'line', 1732
    .return ($P4936)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("514_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_4974
    .param pmc param_4975
    .param pmc param_4976 :optional
    .param int has_param_4976 :opt_flag
.annotate 'line', 1756
    .const 'Sub' $P5083 = "517_1303430322.161" 
    capture_lex $P5083
    .const 'Sub' $P5048 = "516_1303430322.161" 
    capture_lex $P5048
    .const 'Sub' $P5021 = "515_1303430322.161" 
    capture_lex $P5021
    new $P4973, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4973, control_4972
    push_eh $P4973
    .lex "self", param_4974
    .lex "$/", param_4975
    if has_param_4976, optparam_2384
    new $P4977, "Undef"
    set param_4976, $P4977
  optparam_2384:
    .lex "$key", param_4976
.annotate 'line', 1757
    $P4978 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4978
.annotate 'line', 1758
    new $P4979, "Undef"
    .lex "$name", $P4979
.annotate 'line', 1759
    new $P4980, "Undef"
    .lex "$past", $P4980
.annotate 'line', 1757
    get_hll_global $P4981, ["Regex";"P6Regex"], "Actions"
    get_who $P4982, $P4981
    set $P4983, $P4982["@MODIFIERS"]
    unless_null $P4983, vivify_2385
    $P4983 = root_new ['parrot';'ResizablePMCArray']
  vivify_2385:
    store_lex "@MODIFIERS", $P4983
.annotate 'line', 1758
    find_lex $P4984, "$/"
    unless_null $P4984, vivify_2386
    $P4984 = root_new ['parrot';'Hash']
  vivify_2386:
    set $P4985, $P4984["deflongname"]
    unless_null $P4985, vivify_2387
    new $P4985, "Undef"
  vivify_2387:
    $P4986 = $P4985."ast"()
    set $S4987, $P4986
    new $P4988, 'String'
    set $P4988, $S4987
    store_lex "$name", $P4988
    find_lex $P4989, "$past"
    unless_null $P4989, vivify_2388
    new $P4989, "Undef"
  vivify_2388:
.annotate 'line', 1760
    find_lex $P4991, "$/"
    unless_null $P4991, vivify_2389
    $P4991 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P4992, $P4991["proto"]
    unless_null $P4992, vivify_2390
    new $P4992, "Undef"
  vivify_2390:
    if $P4992, if_4990
.annotate 'line', 1799
    find_lex $P5044, "$key"
    unless_null $P5044, vivify_2391
    new $P5044, "Undef"
  vivify_2391:
    set $S5045, $P5044
    iseq $I5046, $S5045, "open"
    if $I5046, if_5043
.annotate 'line', 1809
    .const 'Sub' $P5083 = "517_1303430322.161" 
    capture_lex $P5083
    $P5083()
    goto if_5043_end
  if_5043:
.annotate 'line', 1799
    .const 'Sub' $P5048 = "516_1303430322.161" 
    capture_lex $P5048
    $P5048()
  if_5043_end:
    goto if_4990_end
  if_4990:
.annotate 'line', 1762
    get_hll_global $P4993, ["PAST"], "Stmts"
.annotate 'line', 1763
    get_hll_global $P4994, ["PAST"], "Block"
    find_lex $P4995, "$name"
    unless_null $P4995, vivify_2426
    new $P4995, "Undef"
  vivify_2426:
.annotate 'line', 1764
    get_hll_global $P4996, ["PAST"], "Op"
.annotate 'line', 1765
    get_hll_global $P4997, ["PAST"], "Var"
    $P4998 = $P4997."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4999, "$name"
    unless_null $P4999, vivify_2427
    new $P4999, "Undef"
  vivify_2427:
    $P5000 = $P4996."new"($P4998, $P4999, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1764
    find_lex $P5001, "$/"
    unless_null $P5001, vivify_2428
    new $P5001, "Undef"
  vivify_2428:
    $P5002 = $P4994."new"($P5000, $P4995 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5001 :named("node"))
.annotate 'line', 1774
    get_hll_global $P5003, ["PAST"], "Block"
    new $P5004, "String"
    assign $P5004, "!PREFIX__"
    find_lex $P5005, "$name"
    unless_null $P5005, vivify_2429
    new $P5005, "Undef"
  vivify_2429:
    concat $P5006, $P5004, $P5005
.annotate 'line', 1775
    get_hll_global $P5007, ["PAST"], "Op"
.annotate 'line', 1776
    get_hll_global $P5008, ["PAST"], "Var"
    $P5009 = $P5008."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5010, "$name"
    unless_null $P5010, vivify_2430
    new $P5010, "Undef"
  vivify_2430:
    $P5011 = $P5007."new"($P5009, $P5010, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1775
    find_lex $P5012, "$/"
    unless_null $P5012, vivify_2431
    new $P5012, "Undef"
  vivify_2431:
    $P5013 = $P5003."new"($P5011, $P5006 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5012 :named("node"))
.annotate 'line', 1774
    $P5014 = $P4993."new"($P5002, $P5013)
.annotate 'line', 1762
    store_lex "$past", $P5014
.annotate 'line', 1786
    find_lex $P5016, "$past"
    unless_null $P5016, vivify_2432
    new $P5016, "Undef"
  vivify_2432:
    $P5017 = $P5016."list"()
    defined $I5018, $P5017
    unless $I5018, for_undef_2433
    iter $P5015, $P5017
    new $P5041, 'ExceptionHandler'
    set_label $P5041, loop5040_handler
    $P5041."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5041
  loop5040_test:
    unless $P5015, loop5040_done
    shift $P5019, $P5015
  loop5040_redo:
    .const 'Sub' $P5021 = "515_1303430322.161" 
    capture_lex $P5021
    $P5021($P5019)
  loop5040_next:
    goto loop5040_test
  loop5040_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5042, exception, 'type'
    eq $P5042, .CONTROL_LOOP_NEXT, loop5040_next
    eq $P5042, .CONTROL_LOOP_REDO, loop5040_redo
  loop5040_done:
    pop_eh 
  for_undef_2433:
  if_4990_end:
.annotate 'line', 1845
    find_lex $P5143, "$/"
    find_lex $P5144, "$past"
    unless_null $P5144, vivify_2438
    new $P5144, "Undef"
  vivify_2438:
    $P5145 = $P5143."!make"($P5144)
.annotate 'line', 1756
    .return ($P5145)
  control_4972:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5146, exception, "payload"
    .return ($P5146)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5082"  :anon :subid("517_1303430322.161") :outer("514_1303430322.161")
.annotate 'line', 1810
    new $P5084, "Undef"
    .lex "$regex", $P5084
.annotate 'line', 1811
    get_hll_global $P5085, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5086, "$/"
    unless_null $P5086, vivify_2392
    $P5086 = root_new ['parrot';'Hash']
  vivify_2392:
    set $P5087, $P5086["p6regex"]
    unless_null $P5087, vivify_2393
    new $P5087, "Undef"
  vivify_2393:
    $P5088 = $P5087."ast"()
    find_lex $P5089, "$?PACKAGE"
    get_who $P5090, $P5089
    set $P5091, $P5090["@BLOCK"]
    unless_null $P5091, vivify_2394
    $P5091 = root_new ['parrot';'ResizablePMCArray']
  vivify_2394:
    $P5092 = $P5091."shift"()
    $P5093 = $P5085($P5088, $P5092)
    store_lex "$regex", $P5093
.annotate 'line', 1812
    find_lex $P5094, "$regex"
    unless_null $P5094, vivify_2395
    new $P5094, "Undef"
  vivify_2395:
    find_lex $P5095, "$name"
    unless_null $P5095, vivify_2396
    new $P5095, "Undef"
  vivify_2396:
    $P5094."name"($P5095)
.annotate 'line', 1814
    get_hll_global $P5096, ["PAST"], "Op"
.annotate 'line', 1816
    get_hll_global $P5097, ["PAST"], "Var"
    new $P5098, "ResizablePMCArray"
    push $P5098, "Regex"
    $P5099 = $P5097."new"("Method" :named("name"), $P5098 :named("namespace"), "package" :named("scope"))
    find_lex $P5100, "$regex"
    unless_null $P5100, vivify_2397
    new $P5100, "Undef"
  vivify_2397:
    $P5101 = $P5096."new"($P5099, $P5100, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1814
    store_lex "$past", $P5101
.annotate 'line', 1819
    find_dynamic_lex $P5103, "$*PACKAGE-SETUP"
    unless_null $P5103, vivify_2398
    get_hll_global $P5103, "$PACKAGE-SETUP"
    unless_null $P5103, vivify_2399
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2399:
  vivify_2398:
    defined $I5104, $P5103
    unless $I5104, if_5102_end
.annotate 'line', 1820
    find_dynamic_lex $P5105, "$*PACKAGE-SETUP"
    unless_null $P5105, vivify_2400
    get_hll_global $P5105, "$PACKAGE-SETUP"
    unless_null $P5105, vivify_2401
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2401:
  vivify_2400:
    get_hll_global $P5106, ["PAST"], "Op"
.annotate 'line', 1822
    get_hll_global $P5107, ["PAST"], "Op"
.annotate 'line', 1824
    get_hll_global $P5108, ["PAST"], "Var"
    $P5109 = $P5108."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5110 = $P5107."new"($P5109, "get_how PP" :named("pirop"))
.annotate 'line', 1826
    get_hll_global $P5111, ["PAST"], "Var"
    $P5112 = $P5111."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1827
    get_hll_global $P5113, ["PAST"], "Val"
    find_lex $P5114, "$name"
    unless_null $P5114, vivify_2402
    new $P5114, "Undef"
  vivify_2402:
    $P5115 = $P5113."new"($P5114 :named("value"))
.annotate 'line', 1828
    get_hll_global $P5116, ["PAST"], "Val"
    find_lex $P5117, "$regex"
    unless_null $P5117, vivify_2403
    new $P5117, "Undef"
  vivify_2403:
    $P5118 = $P5116."new"($P5117 :named("value"))
    $P5119 = $P5106."new"($P5110, $P5112, $P5115, $P5118, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1820
    $P5105."push"($P5119)
.annotate 'line', 1830
    find_dynamic_lex $P5120, "$*PACKAGE-SETUP"
    unless_null $P5120, vivify_2404
    get_hll_global $P5120, "$PACKAGE-SETUP"
    unless_null $P5120, vivify_2405
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2405:
  vivify_2404:
    get_hll_global $P5121, ["PAST"], "Op"
.annotate 'line', 1832
    get_hll_global $P5122, ["PAST"], "Op"
.annotate 'line', 1834
    get_hll_global $P5123, ["PAST"], "Var"
    $P5124 = $P5123."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5125 = $P5122."new"($P5124, "get_how PP" :named("pirop"))
.annotate 'line', 1836
    get_hll_global $P5126, ["PAST"], "Var"
    $P5127 = $P5126."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1837
    get_hll_global $P5128, ["PAST"], "Val"
    new $P5129, "String"
    assign $P5129, "!PREFIX__"
    find_lex $P5130, "$name"
    unless_null $P5130, vivify_2406
    new $P5130, "Undef"
  vivify_2406:
    concat $P5131, $P5129, $P5130
    $P5132 = $P5128."new"($P5131 :named("value"))
.annotate 'line', 1838
    get_hll_global $P5133, ["PAST"], "Var"
    new $P5134, "String"
    assign $P5134, "!PREFIX__"
    find_lex $P5135, "$name"
    unless_null $P5135, vivify_2407
    new $P5135, "Undef"
  vivify_2407:
    concat $P5136, $P5134, $P5135
    $P5137 = $P5133."new"($P5136 :named("name"), "package" :named("scope"))
    $P5138 = $P5121."new"($P5125, $P5127, $P5132, $P5137, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1830
    $P5120."push"($P5138)
  if_5102_end:
.annotate 'line', 1842
    find_lex $P5139, "$regex"
    unless_null $P5139, vivify_2408
    new $P5139, "Undef"
  vivify_2408:
    find_lex $P5140, "$past"
    unless_null $P5140, vivify_2409
    $P5140 = root_new ['parrot';'Hash']
    store_lex "$past", $P5140
  vivify_2409:
    set $P5140["sink"], $P5139
.annotate 'line', 1843
    find_lex $P5141, "@MODIFIERS"
    unless_null $P5141, vivify_2410
    $P5141 = root_new ['parrot';'ResizablePMCArray']
  vivify_2410:
    $P5142 = $P5141."shift"()
.annotate 'line', 1809
    .return ($P5142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5047"  :anon :subid("516_1303430322.161") :outer("514_1303430322.161")
.annotate 'line', 1800
    $P5049 = root_new ['parrot';'Hash']
    .lex "%h", $P5049
.annotate 'line', 1799
    find_lex $P5050, "%h"
    unless_null $P5050, vivify_2411
    $P5050 = root_new ['parrot';'Hash']
  vivify_2411:
.annotate 'line', 1801
    find_lex $P5052, "$/"
    unless_null $P5052, vivify_2412
    $P5052 = root_new ['parrot';'Hash']
  vivify_2412:
    set $P5053, $P5052["sym"]
    unless_null $P5053, vivify_2413
    new $P5053, "Undef"
  vivify_2413:
    set $S5054, $P5053
    iseq $I5055, $S5054, "token"
    unless $I5055, if_5051_end
    new $P5056, "Integer"
    assign $P5056, 1
    find_lex $P5057, "%h"
    unless_null $P5057, vivify_2414
    $P5057 = root_new ['parrot';'Hash']
    store_lex "%h", $P5057
  vivify_2414:
    set $P5057["r"], $P5056
  if_5051_end:
.annotate 'line', 1802
    find_lex $P5059, "$/"
    unless_null $P5059, vivify_2415
    $P5059 = root_new ['parrot';'Hash']
  vivify_2415:
    set $P5060, $P5059["sym"]
    unless_null $P5060, vivify_2416
    new $P5060, "Undef"
  vivify_2416:
    set $S5061, $P5060
    iseq $I5062, $S5061, "rule"
    unless $I5062, if_5058_end
    new $P5063, "Integer"
    assign $P5063, 1
    find_lex $P5064, "%h"
    unless_null $P5064, vivify_2417
    $P5064 = root_new ['parrot';'Hash']
    store_lex "%h", $P5064
  vivify_2417:
    set $P5064["r"], $P5063
    new $P5065, "Integer"
    assign $P5065, 1
    find_lex $P5066, "%h"
    unless_null $P5066, vivify_2418
    $P5066 = root_new ['parrot';'Hash']
    store_lex "%h", $P5066
  vivify_2418:
    set $P5066["s"], $P5065
  if_5058_end:
.annotate 'line', 1803
    find_lex $P5067, "@MODIFIERS"
    unless_null $P5067, vivify_2419
    $P5067 = root_new ['parrot';'ResizablePMCArray']
  vivify_2419:
    find_lex $P5068, "%h"
    unless_null $P5068, vivify_2420
    $P5068 = root_new ['parrot';'Hash']
  vivify_2420:
    $P5067."unshift"($P5068)
.annotate 'line', 1804
    find_lex $P5069, "$name"
    unless_null $P5069, vivify_2421
    new $P5069, "Undef"
  vivify_2421:
    get_hll_global $P5070, ["Regex";"P6Regex"], "Actions"
    get_who $P5071, $P5070
    set $P5071["$REGEXNAME"], $P5069
.annotate 'line', 1805
    find_lex $P5072, "$?PACKAGE"
    get_who $P5073, $P5072
    set $P5074, $P5073["@BLOCK"]
    unless_null $P5074, vivify_2422
    $P5074 = root_new ['parrot';'ResizablePMCArray']
  vivify_2422:
    set $P5075, $P5074[0]
    unless_null $P5075, vivify_2423
    new $P5075, "Undef"
  vivify_2423:
    $P5075."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1806
    find_lex $P5076, "$?PACKAGE"
    get_who $P5077, $P5076
    set $P5078, $P5077["@BLOCK"]
    unless_null $P5078, vivify_2424
    $P5078 = root_new ['parrot';'ResizablePMCArray']
  vivify_2424:
    set $P5079, $P5078[0]
    unless_null $P5079, vivify_2425
    new $P5079, "Undef"
  vivify_2425:
    $P5079."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1807
    new $P5080, "Exception"
    set $P5080['type'], .CONTROL_RETURN
    new $P5081, "Integer"
    assign $P5081, 0
    setattribute $P5080, 'payload', $P5081
    throw $P5080
.annotate 'line', 1799
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5020"  :anon :subid("515_1303430322.161") :outer("514_1303430322.161")
    .param pmc param_5022
.annotate 'line', 1786
    .lex "$_", param_5022
.annotate 'line', 1787
    find_dynamic_lex $P5023, "$*PACKAGE-SETUP"
    unless_null $P5023, vivify_2434
    get_hll_global $P5023, "$PACKAGE-SETUP"
    unless_null $P5023, vivify_2435
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2435:
  vivify_2434:
    get_hll_global $P5024, ["PAST"], "Op"
.annotate 'line', 1789
    get_hll_global $P5025, ["PAST"], "Op"
.annotate 'line', 1791
    get_hll_global $P5026, ["PAST"], "Var"
    $P5027 = $P5026."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5028 = $P5025."new"($P5027, "get_how PP" :named("pirop"))
.annotate 'line', 1793
    get_hll_global $P5029, ["PAST"], "Var"
    $P5030 = $P5029."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1794
    get_hll_global $P5031, ["PAST"], "Val"
    find_lex $P5032, "$_"
    unless_null $P5032, vivify_2436
    new $P5032, "Undef"
  vivify_2436:
    $P5033 = $P5032."name"()
    $P5034 = $P5031."new"($P5033 :named("value"))
.annotate 'line', 1795
    get_hll_global $P5035, ["PAST"], "Val"
    find_lex $P5036, "$_"
    unless_null $P5036, vivify_2437
    new $P5036, "Undef"
  vivify_2437:
    $P5037 = $P5035."new"($P5036 :named("value"))
    $P5038 = $P5024."new"($P5028, $P5030, $P5034, $P5037, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1787
    $P5039 = $P5023."push"($P5038)
.annotate 'line', 1786
    .return ($P5039)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("518_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5148
    .param pmc param_5149
.annotate 'line', 1849
    .lex "self", param_5148
    .lex "$/", param_5149
.annotate 'line', 1850
    new $P5150, "Undef"
    .lex "$past", $P5150
    find_lex $P5153, "$/"
    unless_null $P5153, vivify_2439
    $P5153 = root_new ['parrot';'Hash']
  vivify_2439:
    set $P5154, $P5153["args"]
    unless_null $P5154, vivify_2440
    new $P5154, "Undef"
  vivify_2440:
    if $P5154, if_5152
    get_hll_global $P5159, ["PAST"], "Op"
    find_lex $P5160, "$/"
    unless_null $P5160, vivify_2441
    new $P5160, "Undef"
  vivify_2441:
    $P5161 = $P5159."new"($P5160 :named("node"))
    set $P5151, $P5161
    goto if_5152_end
  if_5152:
    find_lex $P5155, "$/"
    unless_null $P5155, vivify_2442
    $P5155 = root_new ['parrot';'Hash']
  vivify_2442:
    set $P5156, $P5155["args"]
    unless_null $P5156, vivify_2443
    $P5156 = root_new ['parrot';'ResizablePMCArray']
  vivify_2443:
    set $P5157, $P5156[0]
    unless_null $P5157, vivify_2444
    new $P5157, "Undef"
  vivify_2444:
    $P5158 = $P5157."ast"()
    set $P5151, $P5158
  if_5152_end:
    store_lex "$past", $P5151
.annotate 'line', 1851
    find_lex $P5163, "$/"
    unless_null $P5163, vivify_2445
    $P5163 = root_new ['parrot';'Hash']
  vivify_2445:
    set $P5164, $P5163["quote"]
    unless_null $P5164, vivify_2446
    new $P5164, "Undef"
  vivify_2446:
    if $P5164, if_5162
.annotate 'line', 1855
    find_lex $P5171, "$/"
    unless_null $P5171, vivify_2447
    $P5171 = root_new ['parrot';'Hash']
  vivify_2447:
    set $P5172, $P5171["longname"]
    unless_null $P5172, vivify_2448
    new $P5172, "Undef"
  vivify_2448:
    set $S5173, $P5172
    iseq $I5174, $S5173, "HOW"
    if $I5174, if_5170
.annotate 'line', 1858
    find_lex $P5177, "$/"
    unless_null $P5177, vivify_2449
    $P5177 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P5178, $P5177["longname"]
    unless_null $P5178, vivify_2450
    new $P5178, "Undef"
  vivify_2450:
    set $S5179, $P5178
    iseq $I5180, $S5179, "WHAT"
    if $I5180, if_5176
.annotate 'line', 1861
    find_lex $P5183, "$/"
    unless_null $P5183, vivify_2451
    $P5183 = root_new ['parrot';'Hash']
  vivify_2451:
    set $P5184, $P5183["longname"]
    unless_null $P5184, vivify_2452
    new $P5184, "Undef"
  vivify_2452:
    set $S5185, $P5184
    iseq $I5186, $S5185, "WHO"
    if $I5186, if_5182
.annotate 'line', 1865
    find_lex $P5188, "$past"
    unless_null $P5188, vivify_2453
    new $P5188, "Undef"
  vivify_2453:
    find_lex $P5189, "$/"
    unless_null $P5189, vivify_2454
    $P5189 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P5190, $P5189["longname"]
    unless_null $P5190, vivify_2455
    new $P5190, "Undef"
  vivify_2455:
    set $S5191, $P5190
    $P5188."name"($S5191)
.annotate 'line', 1866
    find_lex $P5192, "$past"
    unless_null $P5192, vivify_2456
    new $P5192, "Undef"
  vivify_2456:
    $P5192."pasttype"("callmethod")
.annotate 'line', 1864
    goto if_5182_end
  if_5182:
.annotate 'line', 1862
    find_lex $P5187, "$past"
    unless_null $P5187, vivify_2457
    new $P5187, "Undef"
  vivify_2457:
    $P5187."pirop"("get_who PP")
  if_5182_end:
.annotate 'line', 1861
    goto if_5176_end
  if_5176:
.annotate 'line', 1859
    find_lex $P5181, "$past"
    unless_null $P5181, vivify_2458
    new $P5181, "Undef"
  vivify_2458:
    $P5181."pirop"("get_what PP")
  if_5176_end:
.annotate 'line', 1858
    goto if_5170_end
  if_5170:
.annotate 'line', 1856
    find_lex $P5175, "$past"
    unless_null $P5175, vivify_2459
    new $P5175, "Undef"
  vivify_2459:
    $P5175."pirop"("get_how PP")
  if_5170_end:
.annotate 'line', 1855
    goto if_5162_end
  if_5162:
.annotate 'line', 1852
    find_lex $P5165, "$past"
    unless_null $P5165, vivify_2460
    new $P5165, "Undef"
  vivify_2460:
    find_lex $P5166, "$/"
    unless_null $P5166, vivify_2461
    $P5166 = root_new ['parrot';'Hash']
  vivify_2461:
    set $P5167, $P5166["quote"]
    unless_null $P5167, vivify_2462
    new $P5167, "Undef"
  vivify_2462:
    $P5168 = $P5167."ast"()
    $P5165."name"($P5168)
.annotate 'line', 1853
    find_lex $P5169, "$past"
    unless_null $P5169, vivify_2463
    new $P5169, "Undef"
  vivify_2463:
    $P5169."pasttype"("callmethod")
  if_5162_end:
.annotate 'line', 1868
    find_lex $P5193, "$/"
    find_lex $P5194, "$past"
    unless_null $P5194, vivify_2464
    new $P5194, "Undef"
  vivify_2464:
    $P5195 = $P5193."!make"($P5194)
.annotate 'line', 1849
    .return ($P5195)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("519_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5197
    .param pmc param_5198
.annotate 'line', 1873
    .lex "self", param_5197
    .lex "$/", param_5198
.annotate 'line', 1874
    find_lex $P5199, "$/"
    get_hll_global $P5200, ["PAST"], "Var"
    $P5201 = $P5200."new"("self" :named("name"))
    $P5202 = $P5199."!make"($P5201)
.annotate 'line', 1873
    .return ($P5202)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("520_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5204
    .param pmc param_5205
.annotate 'line', 1877
    .lex "self", param_5204
    .lex "$/", param_5205
.annotate 'line', 1878
    new $P5206, "Undef"
    .lex "$past", $P5206
    find_lex $P5207, "$/"
    unless_null $P5207, vivify_2465
    $P5207 = root_new ['parrot';'Hash']
  vivify_2465:
    set $P5208, $P5207["args"]
    unless_null $P5208, vivify_2466
    new $P5208, "Undef"
  vivify_2466:
    $P5209 = $P5208."ast"()
    store_lex "$past", $P5209
.annotate 'line', 1879
    find_lex $P5210, "$past"
    unless_null $P5210, vivify_2467
    new $P5210, "Undef"
  vivify_2467:
    find_lex $P5211, "$/"
    unless_null $P5211, vivify_2468
    $P5211 = root_new ['parrot';'Hash']
  vivify_2468:
    set $P5212, $P5211["deflongname"]
    unless_null $P5212, vivify_2469
    new $P5212, "Undef"
  vivify_2469:
    set $S5213, $P5212
    $P5210."name"($S5213)
.annotate 'line', 1880
    find_lex $P5214, "$/"
    find_lex $P5215, "$past"
    unless_null $P5215, vivify_2470
    new $P5215, "Undef"
  vivify_2470:
    $P5216 = $P5214."!make"($P5215)
.annotate 'line', 1877
    .return ($P5216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("521_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5218
    .param pmc param_5219
.annotate 'line', 1883
    .const 'Sub' $P5234 = "522_1303430322.161" 
    capture_lex $P5234
    .lex "self", param_5218
    .lex "$/", param_5219
.annotate 'line', 1885
    new $P5220, "Undef"
    .lex "$var", $P5220
.annotate 'line', 1899
    new $P5221, "Undef"
    .lex "$past", $P5221
.annotate 'line', 1883
    find_lex $P5222, "$var"
    unless_null $P5222, vivify_2471
    new $P5222, "Undef"
  vivify_2471:
.annotate 'line', 1886
    find_lex $P5224, "$/"
    unless_null $P5224, vivify_2472
    $P5224 = root_new ['parrot';'Hash']
  vivify_2472:
    set $P5225, $P5224["name"]
    unless_null $P5225, vivify_2473
    new $P5225, "Undef"
  vivify_2473:
    set $S5226, $P5225
    $P5227 = "is_lexical"($S5226)
    if $P5227, if_5223
.annotate 'line', 1889
    .const 'Sub' $P5234 = "522_1303430322.161" 
    capture_lex $P5234
    $P5234()
    goto if_5223_end
  if_5223:
.annotate 'line', 1887
    get_hll_global $P5228, ["PAST"], "Var"
    find_lex $P5229, "$/"
    unless_null $P5229, vivify_2484
    $P5229 = root_new ['parrot';'Hash']
  vivify_2484:
    set $P5230, $P5229["name"]
    unless_null $P5230, vivify_2485
    new $P5230, "Undef"
  vivify_2485:
    set $S5231, $P5230
    $P5232 = $P5228."new"($S5231 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5232
  if_5223_end:
.annotate 'line', 1899
    find_lex $P5257, "$var"
    unless_null $P5257, vivify_2486
    new $P5257, "Undef"
  vivify_2486:
    store_lex "$past", $P5257
.annotate 'line', 1900
    find_lex $P5259, "$/"
    unless_null $P5259, vivify_2487
    $P5259 = root_new ['parrot';'Hash']
  vivify_2487:
    set $P5260, $P5259["args"]
    unless_null $P5260, vivify_2488
    new $P5260, "Undef"
  vivify_2488:
    unless $P5260, if_5258_end
.annotate 'line', 1901
    find_lex $P5261, "$/"
    unless_null $P5261, vivify_2489
    $P5261 = root_new ['parrot';'Hash']
  vivify_2489:
    set $P5262, $P5261["args"]
    unless_null $P5262, vivify_2490
    $P5262 = root_new ['parrot';'ResizablePMCArray']
  vivify_2490:
    set $P5263, $P5262[0]
    unless_null $P5263, vivify_2491
    new $P5263, "Undef"
  vivify_2491:
    $P5264 = $P5263."ast"()
    store_lex "$past", $P5264
.annotate 'line', 1902
    find_lex $P5265, "$past"
    unless_null $P5265, vivify_2492
    new $P5265, "Undef"
  vivify_2492:
    find_lex $P5266, "$var"
    unless_null $P5266, vivify_2493
    new $P5266, "Undef"
  vivify_2493:
    $P5265."unshift"($P5266)
  if_5258_end:
.annotate 'line', 1904
    find_lex $P5267, "$/"
    find_lex $P5268, "$past"
    unless_null $P5268, vivify_2494
    new $P5268, "Undef"
  vivify_2494:
    $P5269 = $P5267."!make"($P5268)
.annotate 'line', 1883
    .return ($P5269)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5233"  :anon :subid("522_1303430322.161") :outer("521_1303430322.161")
.annotate 'line', 1890
    $P5235 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5235
.annotate 'line', 1891
    new $P5236, "Undef"
    .lex "$name", $P5236
.annotate 'line', 1890
    find_lex $P5237, "$/"
    unless_null $P5237, vivify_2474
    $P5237 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P5238, $P5237["name"]
    unless_null $P5238, vivify_2475
    $P5238 = root_new ['parrot';'Hash']
  vivify_2475:
    set $P5239, $P5238["identifier"]
    unless_null $P5239, vivify_2476
    new $P5239, "Undef"
  vivify_2476:
    clone $P5240, $P5239
    store_lex "@ns", $P5240
.annotate 'line', 1891
    find_lex $P5241, "@ns"
    unless_null $P5241, vivify_2477
    $P5241 = root_new ['parrot';'ResizablePMCArray']
  vivify_2477:
    $P5242 = $P5241."pop"()
    store_lex "$name", $P5242
.annotate 'line', 1892
    find_lex $P5246, "@ns"
    unless_null $P5246, vivify_2478
    $P5246 = root_new ['parrot';'ResizablePMCArray']
  vivify_2478:
    if $P5246, if_5245
    set $P5244, $P5246
    goto if_5245_end
  if_5245:
    find_lex $P5247, "@ns"
    unless_null $P5247, vivify_2479
    $P5247 = root_new ['parrot';'ResizablePMCArray']
  vivify_2479:
    set $P5248, $P5247[0]
    unless_null $P5248, vivify_2480
    new $P5248, "Undef"
  vivify_2480:
    set $S5249, $P5248
    iseq $I5250, $S5249, "GLOBAL"
    new $P5244, 'Integer'
    set $P5244, $I5250
  if_5245_end:
    unless $P5244, if_5243_end
    find_lex $P5251, "@ns"
    unless_null $P5251, vivify_2481
    $P5251 = root_new ['parrot';'ResizablePMCArray']
  vivify_2481:
    $P5251."shift"()
  if_5243_end:
.annotate 'line', 1893
    get_hll_global $P5252, ["PAST"], "Var"
    find_lex $P5253, "$name"
    unless_null $P5253, vivify_2482
    new $P5253, "Undef"
  vivify_2482:
    set $S5254, $P5253
    find_lex $P5255, "@ns"
    unless_null $P5255, vivify_2483
    $P5255 = root_new ['parrot';'ResizablePMCArray']
  vivify_2483:
    $P5256 = $P5252."new"($S5254 :named("name"), $P5255 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P5256
.annotate 'line', 1889
    .return ($P5256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("523_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5271
    .param pmc param_5272
.annotate 'line', 1907
    .lex "self", param_5271
    .lex "$/", param_5272
.annotate 'line', 1908
    new $P5273, "Undef"
    .lex "$past", $P5273
.annotate 'line', 1909
    new $P5274, "Undef"
    .lex "$pirop", $P5274
.annotate 'line', 1908
    find_lex $P5277, "$/"
    unless_null $P5277, vivify_2495
    $P5277 = root_new ['parrot';'Hash']
  vivify_2495:
    set $P5278, $P5277["args"]
    unless_null $P5278, vivify_2496
    new $P5278, "Undef"
  vivify_2496:
    if $P5278, if_5276
    get_hll_global $P5283, ["PAST"], "Op"
    find_lex $P5284, "$/"
    unless_null $P5284, vivify_2497
    new $P5284, "Undef"
  vivify_2497:
    $P5285 = $P5283."new"($P5284 :named("node"))
    set $P5275, $P5285
    goto if_5276_end
  if_5276:
    find_lex $P5279, "$/"
    unless_null $P5279, vivify_2498
    $P5279 = root_new ['parrot';'Hash']
  vivify_2498:
    set $P5280, $P5279["args"]
    unless_null $P5280, vivify_2499
    $P5280 = root_new ['parrot';'ResizablePMCArray']
  vivify_2499:
    set $P5281, $P5280[0]
    unless_null $P5281, vivify_2500
    new $P5281, "Undef"
  vivify_2500:
    $P5282 = $P5281."ast"()
    set $P5275, $P5282
  if_5276_end:
    store_lex "$past", $P5275
.annotate 'line', 1909
    find_lex $P5286, "$/"
    unless_null $P5286, vivify_2501
    $P5286 = root_new ['parrot';'Hash']
  vivify_2501:
    set $P5287, $P5286["op"]
    unless_null $P5287, vivify_2502
    new $P5287, "Undef"
  vivify_2502:
    set $S5288, $P5287
    new $P5289, 'String'
    set $P5289, $S5288
    store_lex "$pirop", $P5289
.annotate 'line', 1910
    find_lex $P5290, "$pirop"
    unless_null $P5290, vivify_2503
    new $P5290, "Undef"
  vivify_2503:
    set $S5291, $P5290
    split $P5292, "__", $S5291
    join $S5293, " ", $P5292
    new $P5294, 'String'
    set $P5294, $S5293
    store_lex "$pirop", $P5294
.annotate 'line', 1911
    find_lex $P5295, "$past"
    unless_null $P5295, vivify_2504
    new $P5295, "Undef"
  vivify_2504:
    find_lex $P5296, "$pirop"
    unless_null $P5296, vivify_2505
    new $P5296, "Undef"
  vivify_2505:
    $P5295."pirop"($P5296)
.annotate 'line', 1912
    find_lex $P5297, "$past"
    unless_null $P5297, vivify_2506
    new $P5297, "Undef"
  vivify_2506:
    $P5297."pasttype"("pirop")
.annotate 'line', 1913
    find_lex $P5298, "$/"
    find_lex $P5299, "$past"
    unless_null $P5299, vivify_2507
    new $P5299, "Undef"
  vivify_2507:
    $P5300 = $P5298."!make"($P5299)
.annotate 'line', 1907
    .return ($P5300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("524_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5302
    .param pmc param_5303
.annotate 'line', 1916
    .lex "self", param_5302
    .lex "$/", param_5303
.annotate 'line', 1917
    find_lex $P5304, "$/"
    get_hll_global $P5305, ["PAST"], "Op"
    $P5306 = $P5305."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5307 = $P5304."!make"($P5306)
.annotate 'line', 1916
    .return ($P5307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("525_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5309
    .param pmc param_5310
.annotate 'line', 1922
    .lex "self", param_5309
    .lex "$/", param_5310
    find_lex $P5311, "$/"
    find_lex $P5312, "$/"
    unless_null $P5312, vivify_2508
    $P5312 = root_new ['parrot';'Hash']
  vivify_2508:
    set $P5313, $P5312["arglist"]
    unless_null $P5313, vivify_2509
    new $P5313, "Undef"
  vivify_2509:
    $P5314 = $P5313."ast"()
    $P5315 = $P5311."!make"($P5314)
    .return ($P5315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("526_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5317
    .param pmc param_5318
.annotate 'line', 1924
    .const 'Sub' $P5329 = "527_1303430322.161" 
    capture_lex $P5329
    .lex "self", param_5317
    .lex "$/", param_5318
.annotate 'line', 1925
    new $P5319, "Undef"
    .lex "$past", $P5319
.annotate 'line', 1933
    new $P5320, "Undef"
    .lex "$i", $P5320
.annotate 'line', 1934
    new $P5321, "Undef"
    .lex "$n", $P5321
.annotate 'line', 1925
    get_hll_global $P5322, ["PAST"], "Op"
    find_lex $P5323, "$/"
    unless_null $P5323, vivify_2510
    new $P5323, "Undef"
  vivify_2510:
    $P5324 = $P5322."new"("call" :named("pasttype"), $P5323 :named("node"))
    store_lex "$past", $P5324
.annotate 'line', 1926
    find_lex $P5326, "$/"
    unless_null $P5326, vivify_2511
    $P5326 = root_new ['parrot';'Hash']
  vivify_2511:
    set $P5327, $P5326["EXPR"]
    unless_null $P5327, vivify_2512
    new $P5327, "Undef"
  vivify_2512:
    unless $P5327, if_5325_end
    .const 'Sub' $P5329 = "527_1303430322.161" 
    capture_lex $P5329
    $P5329()
  if_5325_end:
.annotate 'line', 1933
    new $P5361, "Integer"
    assign $P5361, 0
    store_lex "$i", $P5361
.annotate 'line', 1934
    find_lex $P5362, "$past"
    unless_null $P5362, vivify_2523
    new $P5362, "Undef"
  vivify_2523:
    $P5363 = $P5362."list"()
    set $N5364, $P5363
    new $P5365, 'Float'
    set $P5365, $N5364
    store_lex "$n", $P5365
.annotate 'line', 1935
    new $P5413, 'ExceptionHandler'
    set_label $P5413, loop5412_handler
    $P5413."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5413
  loop5412_test:
    find_lex $P5366, "$i"
    unless_null $P5366, vivify_2524
    new $P5366, "Undef"
  vivify_2524:
    set $N5367, $P5366
    find_lex $P5368, "$n"
    unless_null $P5368, vivify_2525
    new $P5368, "Undef"
  vivify_2525:
    set $N5369, $P5368
    islt $I5370, $N5367, $N5369
    unless $I5370, loop5412_done
  loop5412_redo:
.annotate 'line', 1936
    find_lex $P5372, "$i"
    unless_null $P5372, vivify_2526
    new $P5372, "Undef"
  vivify_2526:
    set $I5373, $P5372
    find_lex $P5374, "$past"
    unless_null $P5374, vivify_2527
    $P5374 = root_new ['parrot';'ResizablePMCArray']
  vivify_2527:
    set $P5375, $P5374[$I5373]
    unless_null $P5375, vivify_2528
    new $P5375, "Undef"
  vivify_2528:
    $S5376 = $P5375."name"()
    iseq $I5377, $S5376, "&prefix:<|>"
    unless $I5377, if_5371_end
.annotate 'line', 1937
    find_lex $P5378, "$i"
    unless_null $P5378, vivify_2529
    new $P5378, "Undef"
  vivify_2529:
    set $I5379, $P5378
    find_lex $P5380, "$past"
    unless_null $P5380, vivify_2530
    $P5380 = root_new ['parrot';'ResizablePMCArray']
  vivify_2530:
    set $P5381, $P5380[$I5379]
    unless_null $P5381, vivify_2531
    $P5381 = root_new ['parrot';'ResizablePMCArray']
  vivify_2531:
    set $P5382, $P5381[0]
    unless_null $P5382, vivify_2532
    new $P5382, "Undef"
  vivify_2532:
    find_lex $P5383, "$i"
    unless_null $P5383, vivify_2533
    new $P5383, "Undef"
  vivify_2533:
    set $I5384, $P5383
    find_lex $P5385, "$past"
    unless_null $P5385, vivify_2534
    $P5385 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5385
  vivify_2534:
    set $P5385[$I5384], $P5382
.annotate 'line', 1938
    find_lex $P5386, "$i"
    unless_null $P5386, vivify_2535
    new $P5386, "Undef"
  vivify_2535:
    set $I5387, $P5386
    find_lex $P5388, "$past"
    unless_null $P5388, vivify_2536
    $P5388 = root_new ['parrot';'ResizablePMCArray']
  vivify_2536:
    set $P5389, $P5388[$I5387]
    unless_null $P5389, vivify_2537
    new $P5389, "Undef"
  vivify_2537:
    $P5389."flat"(1)
.annotate 'line', 1939
    find_lex $P5393, "$i"
    unless_null $P5393, vivify_2538
    new $P5393, "Undef"
  vivify_2538:
    set $I5394, $P5393
    find_lex $P5395, "$past"
    unless_null $P5395, vivify_2539
    $P5395 = root_new ['parrot';'ResizablePMCArray']
  vivify_2539:
    set $P5396, $P5395[$I5394]
    unless_null $P5396, vivify_2540
    new $P5396, "Undef"
  vivify_2540:
    get_hll_global $P5397, ["PAST"], "Val"
    $P5398 = $P5396."isa"($P5397)
    if $P5398, if_5392
    set $P5391, $P5398
    goto if_5392_end
  if_5392:
.annotate 'line', 1940
    find_lex $P5399, "$i"
    unless_null $P5399, vivify_2541
    new $P5399, "Undef"
  vivify_2541:
    set $I5400, $P5399
    find_lex $P5401, "$past"
    unless_null $P5401, vivify_2542
    $P5401 = root_new ['parrot';'ResizablePMCArray']
  vivify_2542:
    set $P5402, $P5401[$I5400]
    unless_null $P5402, vivify_2543
    new $P5402, "Undef"
  vivify_2543:
    $S5403 = $P5402."name"()
    substr $S5404, $S5403, 0, 1
    iseq $I5405, $S5404, "%"
    new $P5391, 'Integer'
    set $P5391, $I5405
  if_5392_end:
    unless $P5391, if_5390_end
.annotate 'line', 1941
    find_lex $P5406, "$i"
    unless_null $P5406, vivify_2544
    new $P5406, "Undef"
  vivify_2544:
    set $I5407, $P5406
    find_lex $P5408, "$past"
    unless_null $P5408, vivify_2545
    $P5408 = root_new ['parrot';'ResizablePMCArray']
  vivify_2545:
    set $P5409, $P5408[$I5407]
    unless_null $P5409, vivify_2546
    new $P5409, "Undef"
  vivify_2546:
    $P5409."named"(1)
  if_5390_end:
  if_5371_end:
.annotate 'line', 1936
    find_lex $P5410, "$i"
    unless_null $P5410, vivify_2547
    new $P5410, "Undef"
  vivify_2547:
    clone $P5411, $P5410
    inc $P5410
  loop5412_next:
.annotate 'line', 1935
    goto loop5412_test
  loop5412_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5414, exception, 'type'
    eq $P5414, .CONTROL_LOOP_NEXT, loop5412_next
    eq $P5414, .CONTROL_LOOP_REDO, loop5412_redo
  loop5412_done:
    pop_eh 
.annotate 'line', 1946
    find_lex $P5415, "$/"
    find_lex $P5416, "$past"
    unless_null $P5416, vivify_2548
    new $P5416, "Undef"
  vivify_2548:
    $P5417 = $P5415."!make"($P5416)
.annotate 'line', 1924
    .return ($P5417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5328"  :anon :subid("527_1303430322.161") :outer("526_1303430322.161")
.annotate 'line', 1926
    .const 'Sub' $P5350 = "528_1303430322.161" 
    capture_lex $P5350
.annotate 'line', 1927
    new $P5330, "Undef"
    .lex "$expr", $P5330
    find_lex $P5331, "$/"
    unless_null $P5331, vivify_2513
    $P5331 = root_new ['parrot';'Hash']
  vivify_2513:
    set $P5332, $P5331["EXPR"]
    unless_null $P5332, vivify_2514
    new $P5332, "Undef"
  vivify_2514:
    $P5333 = $P5332."ast"()
    store_lex "$expr", $P5333
.annotate 'line', 1928
    find_lex $P5338, "$expr"
    unless_null $P5338, vivify_2515
    new $P5338, "Undef"
  vivify_2515:
    $S5339 = $P5338."name"()
    iseq $I5340, $S5339, "&infix:<,>"
    if $I5340, if_5337
    new $P5336, 'Integer'
    set $P5336, $I5340
    goto if_5337_end
  if_5337:
    find_lex $P5341, "$expr"
    unless_null $P5341, vivify_2516
    new $P5341, "Undef"
  vivify_2516:
    $P5342 = $P5341."named"()
    isfalse $I5343, $P5342
    new $P5336, 'Integer'
    set $P5336, $I5343
  if_5337_end:
    if $P5336, if_5335
.annotate 'line', 1931
    find_lex $P5358, "$past"
    unless_null $P5358, vivify_2517
    new $P5358, "Undef"
  vivify_2517:
    find_lex $P5359, "$expr"
    unless_null $P5359, vivify_2518
    new $P5359, "Undef"
  vivify_2518:
    $P5360 = $P5358."push"($P5359)
    set $P5334, $P5360
.annotate 'line', 1928
    goto if_5335_end
  if_5335:
.annotate 'line', 1929
    find_lex $P5345, "$expr"
    unless_null $P5345, vivify_2519
    new $P5345, "Undef"
  vivify_2519:
    $P5346 = $P5345."list"()
    defined $I5347, $P5346
    unless $I5347, for_undef_2520
    iter $P5344, $P5346
    new $P5356, 'ExceptionHandler'
    set_label $P5356, loop5355_handler
    $P5356."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5356
  loop5355_test:
    unless $P5344, loop5355_done
    shift $P5348, $P5344
  loop5355_redo:
    .const 'Sub' $P5350 = "528_1303430322.161" 
    capture_lex $P5350
    $P5350($P5348)
  loop5355_next:
    goto loop5355_test
  loop5355_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5357, exception, 'type'
    eq $P5357, .CONTROL_LOOP_NEXT, loop5355_next
    eq $P5357, .CONTROL_LOOP_REDO, loop5355_redo
  loop5355_done:
    pop_eh 
  for_undef_2520:
.annotate 'line', 1928
    set $P5334, $P5344
  if_5335_end:
.annotate 'line', 1926
    .return ($P5334)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5349"  :anon :subid("528_1303430322.161") :outer("527_1303430322.161")
    .param pmc param_5351
.annotate 'line', 1929
    .lex "$_", param_5351
    find_lex $P5352, "$past"
    unless_null $P5352, vivify_2521
    new $P5352, "Undef"
  vivify_2521:
    find_lex $P5353, "$_"
    unless_null $P5353, vivify_2522
    new $P5353, "Undef"
  vivify_2522:
    $P5354 = $P5352."push"($P5353)
    .return ($P5354)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("529_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5419
    .param pmc param_5420
.annotate 'line', 1949
    .lex "self", param_5419
    .lex "$/", param_5420
    find_lex $P5421, "$/"
    find_lex $P5422, "$/"
    unless_null $P5422, vivify_2549
    $P5422 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P5423, $P5422["multi_declarator"]
    unless_null $P5423, vivify_2550
    new $P5423, "Undef"
  vivify_2550:
    $P5424 = $P5423."ast"()
    $P5425 = $P5421."!make"($P5424)
    .return ($P5425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("530_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5427
    .param pmc param_5428
.annotate 'line', 1951
    .lex "self", param_5427
    .lex "$/", param_5428
    find_lex $P5429, "$/"
    find_lex $P5430, "$/"
    unless_null $P5430, vivify_2551
    $P5430 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P5431, $P5430["value"]
    unless_null $P5431, vivify_2552
    new $P5431, "Undef"
  vivify_2552:
    $P5432 = $P5431."ast"()
    $P5433 = $P5429."!make"($P5432)
    .return ($P5433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("531_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5435
    .param pmc param_5436
.annotate 'line', 1953
    .lex "self", param_5435
    .lex "$/", param_5436
.annotate 'line', 1954
    find_lex $P5437, "$/"
.annotate 'line', 1955
    find_lex $P5440, "$/"
    unless_null $P5440, vivify_2553
    $P5440 = root_new ['parrot';'Hash']
  vivify_2553:
    set $P5441, $P5440["EXPR"]
    unless_null $P5441, vivify_2554
    new $P5441, "Undef"
  vivify_2554:
    if $P5441, if_5439
.annotate 'line', 1956
    get_hll_global $P5446, ["PAST"], "Op"
    find_lex $P5447, "$/"
    unless_null $P5447, vivify_2555
    new $P5447, "Undef"
  vivify_2555:
    $P5448 = $P5446."new"("list" :named("pasttype"), $P5447 :named("node"))
    set $P5438, $P5448
.annotate 'line', 1955
    goto if_5439_end
  if_5439:
    find_lex $P5442, "$/"
    unless_null $P5442, vivify_2556
    $P5442 = root_new ['parrot';'Hash']
  vivify_2556:
    set $P5443, $P5442["EXPR"]
    unless_null $P5443, vivify_2557
    $P5443 = root_new ['parrot';'ResizablePMCArray']
  vivify_2557:
    set $P5444, $P5443[0]
    unless_null $P5444, vivify_2558
    new $P5444, "Undef"
  vivify_2558:
    $P5445 = $P5444."ast"()
    set $P5438, $P5445
  if_5439_end:
    $P5449 = $P5437."!make"($P5438)
.annotate 'line', 1953
    .return ($P5449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("532_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5451
    .param pmc param_5452
.annotate 'line', 1959
    .lex "self", param_5451
    .lex "$/", param_5452
.annotate 'line', 1960
    new $P5453, "Undef"
    .lex "$past", $P5453
.annotate 'line', 1959
    find_lex $P5454, "$past"
    unless_null $P5454, vivify_2559
    new $P5454, "Undef"
  vivify_2559:
.annotate 'line', 1961
    find_lex $P5456, "$/"
    unless_null $P5456, vivify_2560
    $P5456 = root_new ['parrot';'Hash']
  vivify_2560:
    set $P5457, $P5456["EXPR"]
    unless_null $P5457, vivify_2561
    new $P5457, "Undef"
  vivify_2561:
    if $P5457, if_5455
.annotate 'line', 1968
    get_hll_global $P5469, ["PAST"], "Op"
    $P5470 = $P5469."new"("list" :named("pasttype"))
    store_lex "$past", $P5470
.annotate 'line', 1967
    goto if_5455_end
  if_5455:
.annotate 'line', 1962
    find_lex $P5458, "$/"
    unless_null $P5458, vivify_2562
    $P5458 = root_new ['parrot';'Hash']
  vivify_2562:
    set $P5459, $P5458["EXPR"]
    unless_null $P5459, vivify_2563
    $P5459 = root_new ['parrot';'ResizablePMCArray']
  vivify_2563:
    set $P5460, $P5459[0]
    unless_null $P5460, vivify_2564
    new $P5460, "Undef"
  vivify_2564:
    $P5461 = $P5460."ast"()
    store_lex "$past", $P5461
.annotate 'line', 1963
    find_lex $P5463, "$past"
    unless_null $P5463, vivify_2565
    new $P5463, "Undef"
  vivify_2565:
    $S5464 = $P5463."name"()
    isne $I5465, $S5464, "&infix:<,>"
    unless $I5465, if_5462_end
.annotate 'line', 1964
    get_hll_global $P5466, ["PAST"], "Op"
    find_lex $P5467, "$past"
    unless_null $P5467, vivify_2566
    new $P5467, "Undef"
  vivify_2566:
    $P5468 = $P5466."new"($P5467, "list" :named("pasttype"))
    store_lex "$past", $P5468
  if_5462_end:
  if_5455_end:
.annotate 'line', 1970
    find_lex $P5471, "$past"
    unless_null $P5471, vivify_2567
    new $P5471, "Undef"
  vivify_2567:
    $P5471."name"("&circumfix:<[ ]>")
.annotate 'line', 1971
    find_lex $P5472, "$/"
    find_lex $P5473, "$past"
    unless_null $P5473, vivify_2568
    new $P5473, "Undef"
  vivify_2568:
    $P5474 = $P5472."!make"($P5473)
.annotate 'line', 1959
    .return ($P5474)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("533_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5476
    .param pmc param_5477
.annotate 'line', 1974
    .lex "self", param_5476
    .lex "$/", param_5477
    find_lex $P5478, "$/"
    find_lex $P5479, "$/"
    unless_null $P5479, vivify_2569
    $P5479 = root_new ['parrot';'Hash']
  vivify_2569:
    set $P5480, $P5479["quote_EXPR"]
    unless_null $P5480, vivify_2570
    new $P5480, "Undef"
  vivify_2570:
    $P5481 = $P5480."ast"()
    $P5482 = $P5478."!make"($P5481)
    .return ($P5482)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("534_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5484
    .param pmc param_5485
.annotate 'line', 1975
    .lex "self", param_5484
    .lex "$/", param_5485
    find_lex $P5486, "$/"
    find_lex $P5487, "$/"
    unless_null $P5487, vivify_2571
    $P5487 = root_new ['parrot';'Hash']
  vivify_2571:
    set $P5488, $P5487["quote_EXPR"]
    unless_null $P5488, vivify_2572
    new $P5488, "Undef"
  vivify_2572:
    $P5489 = $P5488."ast"()
    $P5490 = $P5486."!make"($P5489)
    .return ($P5490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("535_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5492
    .param pmc param_5493
.annotate 'line', 1977
    .const 'Sub' $P5504 = "536_1303430322.161" 
    capture_lex $P5504
    .lex "self", param_5492
    .lex "$/", param_5493
.annotate 'line', 1978
    find_lex $P5496, "$/"
    unless_null $P5496, vivify_2573
    $P5496 = root_new ['parrot';'Hash']
  vivify_2573:
    set $P5497, $P5496["pblock"]
    unless_null $P5497, vivify_2574
    $P5497 = root_new ['parrot';'Hash']
  vivify_2574:
    set $P5498, $P5497["blockoid"]
    unless_null $P5498, vivify_2575
    $P5498 = root_new ['parrot';'Hash']
  vivify_2575:
    set $P5499, $P5498["statementlist"]
    unless_null $P5499, vivify_2576
    $P5499 = root_new ['parrot';'Hash']
  vivify_2576:
    set $P5500, $P5499["statement"]
    unless_null $P5500, vivify_2577
    new $P5500, "Undef"
  vivify_2577:
    set $N5501, $P5500
    isgt $I5502, $N5501, 0.0
    if $I5502, if_5495
.annotate 'line', 1983
    find_lex $P5517, "$/"
    unless_null $P5517, vivify_2578
    $P5517 = root_new ['parrot';'Hash']
  vivify_2578:
    set $P5518, $P5517["pblock"]
    unless_null $P5518, vivify_2579
    $P5518 = root_new ['parrot';'Hash']
  vivify_2579:
    set $P5519, $P5518["blockoid"]
    unless_null $P5519, vivify_2580
    $P5519 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5520, $P5519["you_are_here"]
    unless_null $P5520, vivify_2581
    new $P5520, "Undef"
  vivify_2581:
    if $P5520, if_5516
.annotate 'line', 1987
    find_lex $P5526, "$/"
    $P5527 = "vivitype"("%")
    $P5528 = $P5526."!make"($P5527)
.annotate 'line', 1986
    set $P5515, $P5528
.annotate 'line', 1983
    goto if_5516_end
  if_5516:
.annotate 'line', 1984
    find_lex $P5521, "$/"
    find_lex $P5522, "$/"
    unless_null $P5522, vivify_2582
    $P5522 = root_new ['parrot';'Hash']
  vivify_2582:
    set $P5523, $P5522["pblock"]
    unless_null $P5523, vivify_2583
    new $P5523, "Undef"
  vivify_2583:
    $P5524 = $P5523."ast"()
    $P5525 = $P5521."!make"($P5524)
.annotate 'line', 1983
    set $P5515, $P5525
  if_5516_end:
    set $P5494, $P5515
.annotate 'line', 1978
    goto if_5495_end
  if_5495:
    .const 'Sub' $P5504 = "536_1303430322.161" 
    capture_lex $P5504
    $P5514 = $P5504()
    set $P5494, $P5514
  if_5495_end:
.annotate 'line', 1977
    .return ($P5494)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5503"  :anon :subid("536_1303430322.161") :outer("535_1303430322.161")
.annotate 'line', 1979
    new $P5505, "Undef"
    .lex "$past", $P5505
    find_lex $P5506, "$/"
    unless_null $P5506, vivify_2584
    $P5506 = root_new ['parrot';'Hash']
  vivify_2584:
    set $P5507, $P5506["pblock"]
    unless_null $P5507, vivify_2585
    new $P5507, "Undef"
  vivify_2585:
    $P5508 = $P5507."ast"()
    store_lex "$past", $P5508
.annotate 'line', 1980
    new $P5509, "Integer"
    assign $P5509, 1
    find_lex $P5510, "$past"
    unless_null $P5510, vivify_2586
    $P5510 = root_new ['parrot';'Hash']
    store_lex "$past", $P5510
  vivify_2586:
    set $P5510["bareblock"], $P5509
.annotate 'line', 1981
    find_dynamic_lex $P5511, "$/"
    find_lex $P5512, "$past"
    unless_null $P5512, vivify_2587
    new $P5512, "Undef"
  vivify_2587:
    $P5513 = $P5511."!make"($P5512)
.annotate 'line', 1978
    .return ($P5513)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("537_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5530
    .param pmc param_5531
.annotate 'line', 1991
    .lex "self", param_5530
    .lex "$/", param_5531
.annotate 'line', 1992
    new $P5532, "Undef"
    .lex "$name", $P5532
    find_lex $P5535, "$/"
    unless_null $P5535, vivify_2588
    $P5535 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P5536, $P5535["sigil"]
    unless_null $P5536, vivify_2589
    new $P5536, "Undef"
  vivify_2589:
    set $S5537, $P5536
    iseq $I5538, $S5537, "@"
    if $I5538, if_5534
.annotate 'line', 1993
    find_lex $P5542, "$/"
    unless_null $P5542, vivify_2590
    $P5542 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5543, $P5542["sigil"]
    unless_null $P5543, vivify_2591
    new $P5543, "Undef"
  vivify_2591:
    set $S5544, $P5543
    iseq $I5545, $S5544, "%"
    if $I5545, if_5541
    new $P5547, "String"
    assign $P5547, "item"
    set $P5540, $P5547
    goto if_5541_end
  if_5541:
    new $P5546, "String"
    assign $P5546, "hash"
    set $P5540, $P5546
  if_5541_end:
    set $P5533, $P5540
.annotate 'line', 1992
    goto if_5534_end
  if_5534:
    new $P5539, "String"
    assign $P5539, "list"
    set $P5533, $P5539
  if_5534_end:
    store_lex "$name", $P5533
.annotate 'line', 1995
    find_lex $P5548, "$/"
    get_hll_global $P5549, ["PAST"], "Op"
    find_lex $P5550, "$name"
    unless_null $P5550, vivify_2592
    new $P5550, "Undef"
  vivify_2592:
    find_lex $P5551, "$/"
    unless_null $P5551, vivify_2593
    $P5551 = root_new ['parrot';'Hash']
  vivify_2593:
    set $P5552, $P5551["semilist"]
    unless_null $P5552, vivify_2594
    new $P5552, "Undef"
  vivify_2594:
    $P5553 = $P5552."ast"()
    $P5554 = $P5549."new"($P5553, "callmethod" :named("pasttype"), $P5550 :named("name"))
    $P5555 = $P5548."!make"($P5554)
.annotate 'line', 1991
    .return ($P5555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("538_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5557
    .param pmc param_5558
.annotate 'line', 1998
    .lex "self", param_5557
    .lex "$/", param_5558
    find_lex $P5559, "$/"
    find_lex $P5560, "$/"
    unless_null $P5560, vivify_2595
    $P5560 = root_new ['parrot';'Hash']
  vivify_2595:
    set $P5561, $P5560["statement"]
    unless_null $P5561, vivify_2596
    new $P5561, "Undef"
  vivify_2596:
    $P5562 = $P5561."ast"()
    $P5563 = $P5559."!make"($P5562)
    .return ($P5563)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("539_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5565
    .param pmc param_5566
.annotate 'line', 2000
    .lex "self", param_5565
    .lex "$/", param_5566
.annotate 'line', 2001
    find_lex $P5567, "$/"
    get_hll_global $P5568, ["PAST"], "Var"
    find_lex $P5569, "$/"
    unless_null $P5569, vivify_2597
    $P5569 = root_new ['parrot';'Hash']
  vivify_2597:
    set $P5570, $P5569["EXPR"]
    unless_null $P5570, vivify_2598
    new $P5570, "Undef"
  vivify_2598:
    $P5571 = $P5570."ast"()
.annotate 'line', 2003
    $P5572 = "vivitype"("@")
    $P5573 = $P5568."new"($P5571, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5572 :named("vivibase"))
.annotate 'line', 2001
    $P5574 = $P5567."!make"($P5573)
.annotate 'line', 2000
    .return ($P5574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("540_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5576
    .param pmc param_5577
.annotate 'line', 2006
    .lex "self", param_5576
    .lex "$/", param_5577
.annotate 'line', 2007
    find_lex $P5578, "$/"
    get_hll_global $P5579, ["PAST"], "Var"
    find_lex $P5580, "$/"
    unless_null $P5580, vivify_2599
    $P5580 = root_new ['parrot';'Hash']
  vivify_2599:
    set $P5581, $P5580["EXPR"]
    unless_null $P5581, vivify_2600
    new $P5581, "Undef"
  vivify_2600:
    $P5582 = $P5581."ast"()
.annotate 'line', 2009
    $P5583 = "vivitype"("%")
    $P5584 = $P5579."new"($P5582, "keyed" :named("scope"), "Undef" :named("viviself"), $P5583 :named("vivibase"))
.annotate 'line', 2007
    $P5585 = $P5578."!make"($P5584)
.annotate 'line', 2006
    .return ($P5585)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("541_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5587
    .param pmc param_5588
.annotate 'line', 2012
    .lex "self", param_5587
    .lex "$/", param_5588
.annotate 'line', 2013
    find_lex $P5589, "$/"
    get_hll_global $P5590, ["PAST"], "Var"
    find_lex $P5591, "$/"
    unless_null $P5591, vivify_2601
    $P5591 = root_new ['parrot';'Hash']
  vivify_2601:
    set $P5592, $P5591["quote_EXPR"]
    unless_null $P5592, vivify_2602
    new $P5592, "Undef"
  vivify_2602:
    $P5593 = $P5592."ast"()
.annotate 'line', 2015
    $P5594 = "vivitype"("%")
    $P5595 = $P5590."new"($P5593, "keyed" :named("scope"), "Undef" :named("viviself"), $P5594 :named("vivibase"))
.annotate 'line', 2013
    $P5596 = $P5589."!make"($P5595)
.annotate 'line', 2012
    .return ($P5596)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("542_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5598
    .param pmc param_5599
.annotate 'line', 2018
    .lex "self", param_5598
    .lex "$/", param_5599
.annotate 'line', 2019
    find_lex $P5600, "$/"
    find_lex $P5601, "$/"
    unless_null $P5601, vivify_2603
    $P5601 = root_new ['parrot';'Hash']
  vivify_2603:
    set $P5602, $P5601["arglist"]
    unless_null $P5602, vivify_2604
    new $P5602, "Undef"
  vivify_2604:
    $P5603 = $P5602."ast"()
    $P5604 = $P5600."!make"($P5603)
.annotate 'line', 2018
    .return ($P5604)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("543_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5606
    .param pmc param_5607
.annotate 'line', 2022
    .lex "self", param_5606
    .lex "$/", param_5607
.annotate 'line', 2023
    find_lex $P5608, "$/"
    find_lex $P5611, "$/"
    unless_null $P5611, vivify_2605
    $P5611 = root_new ['parrot';'Hash']
  vivify_2605:
    set $P5612, $P5611["quote"]
    unless_null $P5612, vivify_2606
    new $P5612, "Undef"
  vivify_2606:
    if $P5612, if_5610
    find_lex $P5616, "$/"
    unless_null $P5616, vivify_2607
    $P5616 = root_new ['parrot';'Hash']
  vivify_2607:
    set $P5617, $P5616["number"]
    unless_null $P5617, vivify_2608
    new $P5617, "Undef"
  vivify_2608:
    $P5618 = $P5617."ast"()
    set $P5609, $P5618
    goto if_5610_end
  if_5610:
    find_lex $P5613, "$/"
    unless_null $P5613, vivify_2609
    $P5613 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5614, $P5613["quote"]
    unless_null $P5614, vivify_2610
    new $P5614, "Undef"
  vivify_2610:
    $P5615 = $P5614."ast"()
    set $P5609, $P5615
  if_5610_end:
    $P5619 = $P5608."!make"($P5609)
.annotate 'line', 2022
    .return ($P5619)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("544_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5621
    .param pmc param_5622
.annotate 'line', 2026
    .lex "self", param_5621
    .lex "$/", param_5622
.annotate 'line', 2027
    new $P5623, "Undef"
    .lex "$value", $P5623
    find_lex $P5626, "$/"
    unless_null $P5626, vivify_2611
    $P5626 = root_new ['parrot';'Hash']
  vivify_2611:
    set $P5627, $P5626["dec_number"]
    unless_null $P5627, vivify_2612
    new $P5627, "Undef"
  vivify_2612:
    if $P5627, if_5625
    find_lex $P5631, "$/"
    unless_null $P5631, vivify_2613
    $P5631 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5632, $P5631["integer"]
    unless_null $P5632, vivify_2614
    new $P5632, "Undef"
  vivify_2614:
    $P5633 = $P5632."ast"()
    set $P5624, $P5633
    goto if_5625_end
  if_5625:
    find_lex $P5628, "$/"
    unless_null $P5628, vivify_2615
    $P5628 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P5629, $P5628["dec_number"]
    unless_null $P5629, vivify_2616
    new $P5629, "Undef"
  vivify_2616:
    $P5630 = $P5629."ast"()
    set $P5624, $P5630
  if_5625_end:
    store_lex "$value", $P5624
.annotate 'line', 2028
    find_lex $P5635, "$/"
    unless_null $P5635, vivify_2617
    $P5635 = root_new ['parrot';'Hash']
  vivify_2617:
    set $P5636, $P5635["sign"]
    unless_null $P5636, vivify_2618
    new $P5636, "Undef"
  vivify_2618:
    set $S5637, $P5636
    iseq $I5638, $S5637, "-"
    unless $I5638, if_5634_end
    find_lex $P5639, "$value"
    unless_null $P5639, vivify_2619
    new $P5639, "Undef"
  vivify_2619:
    neg $P5640, $P5639
    store_lex "$value", $P5640
  if_5634_end:
.annotate 'line', 2029
    find_lex $P5641, "$/"
    get_hll_global $P5642, ["PAST"], "Val"
    find_lex $P5643, "$value"
    unless_null $P5643, vivify_2620
    new $P5643, "Undef"
  vivify_2620:
    $P5644 = $P5642."new"($P5643 :named("value"))
    $P5645 = $P5641."!make"($P5644)
.annotate 'line', 2026
    .return ($P5645)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("545_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5647
    .param pmc param_5648
.annotate 'line', 2032
    .lex "self", param_5647
    .lex "$/", param_5648
    find_lex $P5649, "$/"
    find_lex $P5650, "$/"
    unless_null $P5650, vivify_2621
    $P5650 = root_new ['parrot';'Hash']
  vivify_2621:
    set $P5651, $P5650["quote_EXPR"]
    unless_null $P5651, vivify_2622
    new $P5651, "Undef"
  vivify_2622:
    $P5652 = $P5651."ast"()
    $P5653 = $P5649."!make"($P5652)
    .return ($P5653)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("546_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5655
    .param pmc param_5656
.annotate 'line', 2033
    .lex "self", param_5655
    .lex "$/", param_5656
    find_lex $P5657, "$/"
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2623
    $P5658 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5659, $P5658["quote_EXPR"]
    unless_null $P5659, vivify_2624
    new $P5659, "Undef"
  vivify_2624:
    $P5660 = $P5659."ast"()
    $P5661 = $P5657."!make"($P5660)
    .return ($P5661)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("547_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5663
    .param pmc param_5664
.annotate 'line', 2034
    .lex "self", param_5663
    .lex "$/", param_5664
    find_lex $P5665, "$/"
    find_lex $P5666, "$/"
    unless_null $P5666, vivify_2625
    $P5666 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P5667, $P5666["quote_EXPR"]
    unless_null $P5667, vivify_2626
    new $P5667, "Undef"
  vivify_2626:
    $P5668 = $P5667."ast"()
    $P5669 = $P5665."!make"($P5668)
    .return ($P5669)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("548_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5671
    .param pmc param_5672
.annotate 'line', 2035
    .lex "self", param_5671
    .lex "$/", param_5672
    find_lex $P5673, "$/"
    find_lex $P5674, "$/"
    unless_null $P5674, vivify_2627
    $P5674 = root_new ['parrot';'Hash']
  vivify_2627:
    set $P5675, $P5674["quote_EXPR"]
    unless_null $P5675, vivify_2628
    new $P5675, "Undef"
  vivify_2628:
    $P5676 = $P5675."ast"()
    $P5677 = $P5673."!make"($P5676)
    .return ($P5677)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("549_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5679
    .param pmc param_5680
.annotate 'line', 2036
    .lex "self", param_5679
    .lex "$/", param_5680
    find_lex $P5681, "$/"
    find_lex $P5682, "$/"
    unless_null $P5682, vivify_2629
    $P5682 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P5683, $P5682["quote_EXPR"]
    unless_null $P5683, vivify_2630
    new $P5683, "Undef"
  vivify_2630:
    $P5684 = $P5683."ast"()
    $P5685 = $P5681."!make"($P5684)
    .return ($P5685)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("550_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5687
    .param pmc param_5688
.annotate 'line', 2037
    .lex "self", param_5687
    .lex "$/", param_5688
.annotate 'line', 2038
    find_lex $P5689, "$/"
    get_hll_global $P5690, ["PAST"], "Op"
    find_lex $P5691, "$/"
    unless_null $P5691, vivify_2631
    $P5691 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P5692, $P5691["quote_EXPR"]
    unless_null $P5692, vivify_2632
    new $P5692, "Undef"
  vivify_2632:
    $P5693 = $P5692."ast"()
    $P5694 = $P5693."value"()
    find_lex $P5695, "$/"
    unless_null $P5695, vivify_2633
    new $P5695, "Undef"
  vivify_2633:
    $P5696 = $P5690."new"($P5694 :named("inline"), "inline" :named("pasttype"), $P5695 :named("node"))
    $P5697 = $P5689."!make"($P5696)
.annotate 'line', 2037
    .return ($P5697)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("551_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5701
    .param pmc param_5702
    .param pmc param_5703 :optional
    .param int has_param_5703 :opt_flag
.annotate 'line', 2043
    new $P5700, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5700, control_5699
    push_eh $P5700
    .lex "self", param_5701
    .lex "$/", param_5702
    if has_param_5703, optparam_2634
    new $P5704, "Undef"
    set param_5703, $P5704
  optparam_2634:
    .lex "$key", param_5703
.annotate 'line', 2050
    new $P5705, "Undef"
    .lex "$regex", $P5705
.annotate 'line', 2052
    new $P5706, "Undef"
    .lex "$past", $P5706
.annotate 'line', 2044
    find_lex $P5708, "$key"
    unless_null $P5708, vivify_2635
    new $P5708, "Undef"
  vivify_2635:
    set $S5709, $P5708
    iseq $I5710, $S5709, "open"
    unless $I5710, if_5707_end
.annotate 'line', 2045
    null $P5711
    get_hll_global $P5712, ["Regex";"P6Regex"], "Actions"
    get_who $P5713, $P5712
    set $P5713["$REGEXNAME"], $P5711
.annotate 'line', 2046
    find_lex $P5714, "$?PACKAGE"
    get_who $P5715, $P5714
    set $P5716, $P5715["@BLOCK"]
    unless_null $P5716, vivify_2636
    $P5716 = root_new ['parrot';'ResizablePMCArray']
  vivify_2636:
    set $P5717, $P5716[0]
    unless_null $P5717, vivify_2637
    new $P5717, "Undef"
  vivify_2637:
    $P5717."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2047
    find_lex $P5718, "$?PACKAGE"
    get_who $P5719, $P5718
    set $P5720, $P5719["@BLOCK"]
    unless_null $P5720, vivify_2638
    $P5720 = root_new ['parrot';'ResizablePMCArray']
  vivify_2638:
    set $P5721, $P5720[0]
    unless_null $P5721, vivify_2639
    new $P5721, "Undef"
  vivify_2639:
    $P5721."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2048
    new $P5722, "Exception"
    set $P5722['type'], .CONTROL_RETURN
    new $P5723, "Integer"
    assign $P5723, 0
    setattribute $P5722, 'payload', $P5723
    throw $P5722
  if_5707_end:
.annotate 'line', 2051
    get_hll_global $P5724, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5725, "$/"
    unless_null $P5725, vivify_2640
    $P5725 = root_new ['parrot';'Hash']
  vivify_2640:
    set $P5726, $P5725["p6regex"]
    unless_null $P5726, vivify_2641
    new $P5726, "Undef"
  vivify_2641:
    $P5727 = $P5726."ast"()
    find_lex $P5728, "$?PACKAGE"
    get_who $P5729, $P5728
    set $P5730, $P5729["@BLOCK"]
    unless_null $P5730, vivify_2642
    $P5730 = root_new ['parrot';'ResizablePMCArray']
  vivify_2642:
    $P5731 = $P5730."shift"()
    $P5732 = $P5724($P5727, $P5731)
    store_lex "$regex", $P5732
.annotate 'line', 2053
    get_hll_global $P5733, ["PAST"], "Op"
.annotate 'line', 2055
    get_hll_global $P5734, ["PAST"], "Var"
    new $P5735, "ResizablePMCArray"
    push $P5735, "Regex"
    $P5736 = $P5734."new"("Regex" :named("name"), $P5735 :named("namespace"), "package" :named("scope"))
    find_lex $P5737, "$regex"
    unless_null $P5737, vivify_2643
    new $P5737, "Undef"
  vivify_2643:
    $P5738 = $P5733."new"($P5736, $P5737, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2053
    store_lex "$past", $P5738
.annotate 'line', 2059
    find_lex $P5739, "$regex"
    unless_null $P5739, vivify_2644
    new $P5739, "Undef"
  vivify_2644:
    find_lex $P5740, "$past"
    unless_null $P5740, vivify_2645
    $P5740 = root_new ['parrot';'Hash']
    store_lex "$past", $P5740
  vivify_2645:
    set $P5740["sink"], $P5739
.annotate 'line', 2060
    find_lex $P5741, "$/"
    find_lex $P5742, "$past"
    unless_null $P5742, vivify_2646
    new $P5742, "Undef"
  vivify_2646:
    $P5743 = $P5741."!make"($P5742)
.annotate 'line', 2043
    .return ($P5743)
  control_5699:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5744, exception, "payload"
    .return ($P5744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("552_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5746
    .param pmc param_5747
.annotate 'line', 2063
    .lex "self", param_5746
    .lex "$/", param_5747
    find_lex $P5748, "$/"
    find_lex $P5749, "$/"
    unless_null $P5749, vivify_2647
    $P5749 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5750, $P5749["variable"]
    unless_null $P5750, vivify_2648
    new $P5750, "Undef"
  vivify_2648:
    $P5751 = $P5750."ast"()
    $P5752 = $P5748."!make"($P5751)
    .return ($P5752)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("553_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5754
    .param pmc param_5755
.annotate 'line', 2064
    .lex "self", param_5754
    .lex "$/", param_5755
.annotate 'line', 2065
    find_lex $P5756, "$/"
    get_hll_global $P5757, ["PAST"], "Op"
.annotate 'line', 2066
    find_lex $P5758, "$/"
    unless_null $P5758, vivify_2649
    $P5758 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5759, $P5758["block"]
    unless_null $P5759, vivify_2650
    new $P5759, "Undef"
  vivify_2650:
    $P5760 = $P5759."ast"()
    $P5761 = "block_immediate"($P5760)
    find_lex $P5762, "$/"
    unless_null $P5762, vivify_2651
    new $P5762, "Undef"
  vivify_2651:
    $P5763 = $P5757."new"($P5761, "set S*" :named("pirop"), $P5762 :named("node"))
.annotate 'line', 2065
    $P5764 = $P5756."!make"($P5763)
.annotate 'line', 2064
    .return ($P5764)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("554_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5766
    .param pmc param_5767
.annotate 'line', 2069
    .lex "self", param_5766
    .lex "$/", param_5767
    find_lex $P5768, "$/"
    $P5769 = $P5768."!make"("\e")
    .return ($P5769)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("555_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5771
    .param pmc param_5772
.annotate 'line', 2073
    .lex "self", param_5771
    .lex "$/", param_5772
    find_lex $P5773, "$/"
    find_lex $P5774, "$/"
    unless_null $P5774, vivify_2652
    $P5774 = root_new ['parrot';'Hash']
  vivify_2652:
    set $P5775, $P5774["dotty"]
    unless_null $P5775, vivify_2653
    new $P5775, "Undef"
  vivify_2653:
    $P5776 = $P5775."ast"()
    $P5777 = $P5773."!make"($P5776)
    .return ($P5777)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("556_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5779
    .param pmc param_5780
.annotate 'line', 2075
    .lex "self", param_5779
    .lex "$/", param_5780
.annotate 'line', 2076
    find_lex $P5781, "$/"
    get_hll_global $P5782, ["PAST"], "Op"
.annotate 'line', 2077
    new $P5783, "ResizablePMCArray"
    push $P5783, "    clone %r, %0"
    push $P5783, "    inc %0"
    $P5784 = $P5782."new"("postfix:<++>" :named("name"), $P5783 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2076
    $P5785 = $P5781."!make"($P5784)
.annotate 'line', 2075
    .return ($P5785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("557_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5787
    .param pmc param_5788
.annotate 'line', 2081
    .lex "self", param_5787
    .lex "$/", param_5788
.annotate 'line', 2082
    find_lex $P5789, "$/"
    get_hll_global $P5790, ["PAST"], "Op"
.annotate 'line', 2083
    new $P5791, "ResizablePMCArray"
    push $P5791, "    clone %r, %0"
    push $P5791, "    dec %0"
    $P5792 = $P5790."new"("postfix:<-->" :named("name"), $P5791 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2082
    $P5793 = $P5789."!make"($P5792)
.annotate 'line', 2081
    .return ($P5793)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("558_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5795
    .param pmc param_5796
.annotate 'line', 2087
    .lex "self", param_5795
    .lex "$/", param_5796
.annotate 'line', 2088
    find_lex $P5797, "$/"
    get_hll_global $P5798, ["PAST"], "Op"
.annotate 'line', 2089
    get_hll_global $P5799, ["PAST"], "Var"
    $P5800 = $P5799."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5801, "$/"
    unless_null $P5801, vivify_2654
    new $P5801, "Undef"
  vivify_2654:
    $P5802 = $P5798."new"($P5800, "callmethod" :named("pasttype"), "!make" :named("name"), $P5801 :named("node"))
.annotate 'line', 2088
    $P5803 = $P5797."!make"($P5802)
.annotate 'line', 2087
    .return ($P5803)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("559_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5806
    .param pmc param_5807
.annotate 'line', 2105
    .lex "self", param_5806
    .lex "$/", param_5807
    find_lex $P5808, "$/"
    unless_null $P5808, vivify_2655
    new $P5808, "Undef"
  vivify_2655:
    $P5809 = "control"($P5808, "CONTROL_LOOP_NEXT")
    .return ($P5809)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("560_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5811
    .param pmc param_5812
.annotate 'line', 2106
    .lex "self", param_5811
    .lex "$/", param_5812
    find_lex $P5813, "$/"
    unless_null $P5813, vivify_2656
    new $P5813, "Undef"
  vivify_2656:
    $P5814 = "control"($P5813, "CONTROL_LOOP_LAST")
    .return ($P5814)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("561_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5816
    .param pmc param_5817
.annotate 'line', 2107
    .lex "self", param_5816
    .lex "$/", param_5817
    find_lex $P5818, "$/"
    unless_null $P5818, vivify_2657
    new $P5818, "Undef"
  vivify_2657:
    $P5819 = "control"($P5818, "CONTROL_LOOP_REDO")
    .return ($P5819)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("562_1303430322.161") :outer("406_1303430322.161")
    .param pmc param_5821
    .param pmc param_5822
.annotate 'line', 2109
    .lex "self", param_5821
    .lex "$/", param_5822
.annotate 'line', 2110
    find_lex $P5823, "$/"
    get_hll_global $P5824, ["PAST"], "Op"
    find_lex $P5825, "$/"
    unless_null $P5825, vivify_2658
    new $P5825, "Undef"
  vivify_2658:
    $P5826 = $P5824."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5825 :named("node"))
    $P5827 = $P5823."!make"($P5826)
.annotate 'line', 2109
    .return ($P5827)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6058"  :subid("564_1303430322.161") :outer("10_1303430322.161")
.annotate 'line', 2194
    .const 'Sub' $P6159 = "572_1303430322.161" 
    capture_lex $P6159
    .const 'Sub' $P6134 = "571_1303430322.161" 
    capture_lex $P6134
    .const 'Sub' $P6123 = "570_1303430322.161" 
    capture_lex $P6123
    .const 'Sub' $P6108 = "569_1303430322.161" 
    capture_lex $P6108
    .const 'Sub' $P6097 = "568_1303430322.161" 
    capture_lex $P6097
    .const 'Sub' $P6086 = "567_1303430322.161" 
    capture_lex $P6086
    .const 'Sub' $P6075 = "566_1303430322.161" 
    capture_lex $P6075
    .const 'Sub' $P6062 = "565_1303430322.161" 
    capture_lex $P6062
    .lex "$?PACKAGE", $P6060
    .lex "$?CLASS", $P6061
.annotate 'line', 2228
    .const 'Sub' $P6134 = "571_1303430322.161" 
    newclosure $P6157, $P6134
.annotate 'line', 2194
    .return ($P6157)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2659") :outer("564_1303430322.161")
.annotate 'line', 2194
    .const 'Sub' $P6059 = "564_1303430322.161" 
    .local pmc block
    set block, $P6059
    .const 'Sub' $P6159 = "572_1303430322.161" 
    capture_lex $P6159
    $P6159()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6158"  :anon :subid("572_1303430322.161") :outer("564_1303430322.161")
.annotate 'line', 2194
    nqp_get_sc_object $P6160, "1303430311.149", 4
    .local pmc type_obj
    set type_obj, $P6160
    get_how $P6161, type_obj
    .const 'Sub' $P6162 = "565_1303430322.161" 
    $P6161."add_method"(type_obj, "metachar:sym<:my>", $P6162)
    get_how $P6163, type_obj
    .const 'Sub' $P6164 = "566_1303430322.161" 
    $P6163."add_method"(type_obj, "metachar:sym<{ }>", $P6164)
    get_how $P6165, type_obj
    .const 'Sub' $P6166 = "567_1303430322.161" 
    $P6165."add_method"(type_obj, "metachar:sym<nqpvar>", $P6166)
    get_how $P6167, type_obj
    .const 'Sub' $P6168 = "568_1303430322.161" 
    $P6167."add_method"(type_obj, "assertion:sym<{ }>", $P6168)
    get_how $P6169, type_obj
    .const 'Sub' $P6170 = "569_1303430322.161" 
    $P6169."add_method"(type_obj, "assertion:sym<?{ }>", $P6170)
    get_how $P6171, type_obj
    .const 'Sub' $P6172 = "570_1303430322.161" 
    $P6171."add_method"(type_obj, "assertion:sym<var>", $P6172)
    get_how $P6173, type_obj
    .const 'Sub' $P6174 = "571_1303430322.161" 
    $P6173."add_method"(type_obj, "codeblock", $P6174)
    get_how $P6175, type_obj
    get_hll_global $P6176, ["Regex";"P6Regex"], "Actions"
    $P6175."add_parent"(type_obj, $P6176)
    get_how $P6177, type_obj
    $P6178 = $P6177."compose"(type_obj)
    .return ($P6178)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("565_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6063
    .param pmc param_6064
.annotate 'line', 2196
    .lex "self", param_6063
    .lex "$/", param_6064
.annotate 'line', 2197
    new $P6065, "Undef"
    .lex "$past", $P6065
    find_lex $P6066, "$/"
    unless_null $P6066, vivify_2660
    $P6066 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P6067, $P6066["statement"]
    unless_null $P6067, vivify_2661
    new $P6067, "Undef"
  vivify_2661:
    $P6068 = $P6067."ast"()
    store_lex "$past", $P6068
.annotate 'line', 2198
    find_lex $P6069, "$/"
    get_hll_global $P6070, ["PAST"], "Regex"
    find_lex $P6071, "$past"
    unless_null $P6071, vivify_2662
    new $P6071, "Undef"
  vivify_2662:
    find_lex $P6072, "$/"
    unless_null $P6072, vivify_2663
    new $P6072, "Undef"
  vivify_2663:
    $P6073 = $P6070."new"($P6071, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6072 :named("node"))
    $P6074 = $P6069."!make"($P6073)
.annotate 'line', 2196
    .return ($P6074)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("566_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6076
    .param pmc param_6077
.annotate 'line', 2202
    .lex "self", param_6076
    .lex "$/", param_6077
.annotate 'line', 2203
    find_lex $P6078, "$/"
    get_hll_global $P6079, ["PAST"], "Regex"
    find_lex $P6080, "$/"
    unless_null $P6080, vivify_2664
    $P6080 = root_new ['parrot';'Hash']
  vivify_2664:
    set $P6081, $P6080["codeblock"]
    unless_null $P6081, vivify_2665
    new $P6081, "Undef"
  vivify_2665:
    $P6082 = $P6081."ast"()
    find_lex $P6083, "$/"
    unless_null $P6083, vivify_2666
    new $P6083, "Undef"
  vivify_2666:
    $P6084 = $P6079."new"($P6082, "pastnode" :named("pasttype"), $P6083 :named("node"))
    $P6085 = $P6078."!make"($P6084)
.annotate 'line', 2202
    .return ($P6085)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("567_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6087
    .param pmc param_6088
.annotate 'line', 2207
    .lex "self", param_6087
    .lex "$/", param_6088
.annotate 'line', 2208
    find_lex $P6089, "$/"
    get_hll_global $P6090, ["PAST"], "Regex"
    find_lex $P6091, "$/"
    unless_null $P6091, vivify_2667
    $P6091 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P6092, $P6091["var"]
    unless_null $P6092, vivify_2668
    new $P6092, "Undef"
  vivify_2668:
    $P6093 = $P6092."ast"()
    find_lex $P6094, "$/"
    unless_null $P6094, vivify_2669
    new $P6094, "Undef"
  vivify_2669:
    $P6095 = $P6090."new"("!INTERPOLATE", $P6093, "subrule" :named("pasttype"), "method" :named("subtype"), $P6094 :named("node"))
    $P6096 = $P6089."!make"($P6095)
.annotate 'line', 2207
    .return ($P6096)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("568_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6098
    .param pmc param_6099
.annotate 'line', 2212
    .lex "self", param_6098
    .lex "$/", param_6099
.annotate 'line', 2213
    find_lex $P6100, "$/"
    get_hll_global $P6101, ["PAST"], "Regex"
    find_lex $P6102, "$/"
    unless_null $P6102, vivify_2670
    $P6102 = root_new ['parrot';'Hash']
  vivify_2670:
    set $P6103, $P6102["codeblock"]
    unless_null $P6103, vivify_2671
    new $P6103, "Undef"
  vivify_2671:
    $P6104 = $P6103."ast"()
    find_lex $P6105, "$/"
    unless_null $P6105, vivify_2672
    new $P6105, "Undef"
  vivify_2672:
    $P6106 = $P6101."new"("!INTERPOLATE_REGEX", $P6104, "subrule" :named("pasttype"), "method" :named("subtype"), $P6105 :named("node"))
    $P6107 = $P6100."!make"($P6106)
.annotate 'line', 2212
    .return ($P6107)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("569_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6109
    .param pmc param_6110
.annotate 'line', 2217
    .lex "self", param_6109
    .lex "$/", param_6110
.annotate 'line', 2218
    find_lex $P6111, "$/"
    get_hll_global $P6112, ["PAST"], "Regex"
    find_lex $P6113, "$/"
    unless_null $P6113, vivify_2673
    $P6113 = root_new ['parrot';'Hash']
  vivify_2673:
    set $P6114, $P6113["codeblock"]
    unless_null $P6114, vivify_2674
    new $P6114, "Undef"
  vivify_2674:
    $P6115 = $P6114."ast"()
.annotate 'line', 2219
    find_lex $P6116, "$/"
    unless_null $P6116, vivify_2675
    $P6116 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P6117, $P6116["zw"]
    unless_null $P6117, vivify_2676
    new $P6117, "Undef"
  vivify_2676:
    set $S6118, $P6117
    iseq $I6119, $S6118, "!"
    find_lex $P6120, "$/"
    unless_null $P6120, vivify_2677
    new $P6120, "Undef"
  vivify_2677:
    $P6121 = $P6112."new"($P6115, "zerowidth" :named("subtype"), $I6119 :named("negate"), "pastnode" :named("pasttype"), $P6120 :named("node"))
.annotate 'line', 2218
    $P6122 = $P6111."!make"($P6121)
.annotate 'line', 2217
    .return ($P6122)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("570_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6124
    .param pmc param_6125
.annotate 'line', 2223
    .lex "self", param_6124
    .lex "$/", param_6125
.annotate 'line', 2224
    find_lex $P6126, "$/"
    get_hll_global $P6127, ["PAST"], "Regex"
    find_lex $P6128, "$/"
    unless_null $P6128, vivify_2678
    $P6128 = root_new ['parrot';'Hash']
  vivify_2678:
    set $P6129, $P6128["var"]
    unless_null $P6129, vivify_2679
    new $P6129, "Undef"
  vivify_2679:
    $P6130 = $P6129."ast"()
    find_lex $P6131, "$/"
    unless_null $P6131, vivify_2680
    new $P6131, "Undef"
  vivify_2680:
    $P6132 = $P6127."new"("!INTERPOLATE_REGEX", $P6130, "subrule" :named("pasttype"), "method" :named("subtype"), $P6131 :named("node"))
    $P6133 = $P6126."!make"($P6132)
.annotate 'line', 2223
    .return ($P6133)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("571_1303430322.161") :outer("564_1303430322.161")
    .param pmc param_6135
    .param pmc param_6136
.annotate 'line', 2228
    .lex "self", param_6135
    .lex "$/", param_6136
.annotate 'line', 2229
    new $P6137, "Undef"
    .lex "$block", $P6137
.annotate 'line', 2231
    new $P6138, "Undef"
    .lex "$past", $P6138
.annotate 'line', 2229
    find_lex $P6139, "$/"
    unless_null $P6139, vivify_2681
    $P6139 = root_new ['parrot';'Hash']
  vivify_2681:
    set $P6140, $P6139["block"]
    unless_null $P6140, vivify_2682
    new $P6140, "Undef"
  vivify_2682:
    $P6141 = $P6140."ast"()
    store_lex "$block", $P6141
.annotate 'line', 2230
    find_lex $P6142, "$block"
    unless_null $P6142, vivify_2683
    new $P6142, "Undef"
  vivify_2683:
    $P6142."blocktype"("immediate")
.annotate 'line', 2232
    get_hll_global $P6143, ["PAST"], "Stmts"
.annotate 'line', 2233
    get_hll_global $P6144, ["PAST"], "Op"
.annotate 'line', 2234
    get_hll_global $P6145, ["PAST"], "Var"
    $P6146 = $P6145."new"("$/" :named("name"))
.annotate 'line', 2235
    get_hll_global $P6147, ["PAST"], "Op"
.annotate 'line', 2236
    get_hll_global $P6148, ["PAST"], "Var"
    $P6149 = $P6148."new"(unicode:"$\x{a2}" :named("name"))
    $P6150 = $P6147."new"($P6149, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2235
    $P6151 = $P6144."new"($P6146, $P6150, "bind" :named("pasttype"))
.annotate 'line', 2233
    find_lex $P6152, "$block"
    unless_null $P6152, vivify_2684
    new $P6152, "Undef"
  vivify_2684:
    $P6153 = $P6143."new"($P6151, $P6152)
.annotate 'line', 2232
    store_lex "$past", $P6153
.annotate 'line', 2244
    find_lex $P6154, "$/"
    find_lex $P6155, "$past"
    unless_null $P6155, vivify_2685
    new $P6155, "Undef"
  vivify_2685:
    $P6156 = $P6154."!make"($P6155)
.annotate 'line', 2228
    .return ($P6156)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6179"  :subid("573_1303430322.161") :outer("10_1303430322.161")
.annotate 'line', 2249
    .const 'Sub' $P6184 = "574_1303430322.161" 
    capture_lex $P6184
    .lex "$?PACKAGE", $P6181
    .lex "$?CLASS", $P6182
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2686") :outer("573_1303430322.161")
.annotate 'line', 2249
    .const 'Sub' $P6180 = "573_1303430322.161" 
    .local pmc block
    set block, $P6180
    .const 'Sub' $P6184 = "574_1303430322.161" 
    capture_lex $P6184
    $P6184()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6183"  :anon :subid("574_1303430322.161") :outer("573_1303430322.161")
.annotate 'line', 2249
    nqp_get_sc_object $P6185, "1303430311.149", 5
    .local pmc type_obj
    set type_obj, $P6185
    get_how $P6186, type_obj
    get_hll_global $P6187, ["HLL"], "Compiler"
    $P6186."add_parent"(type_obj, $P6187)
    get_how $P6188, type_obj
    $P6189 = $P6188."compose"(type_obj)
    .return ($P6189)
.end


.HLL "nqp"

.namespace []
.sub "_block6197" :load :anon :subid("575_1303430322.161")
.annotate 'line', 1
    .const 'Sub' $P6199 = "10_1303430322.161" 
    $P6200 = $P6199()
    .return ($P6200)
.end

