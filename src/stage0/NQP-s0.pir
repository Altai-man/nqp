
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1304282286.73")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6728 = "767_1304282286.73" 
    capture_lex $P6728
    .const 'Sub' $P6590 = "758_1304282286.73" 
    capture_lex $P6590
    .const 'Sub' $P2497 = "582_1304282286.73" 
    capture_lex $P2497
    .const 'Sub' $P2409 = "552_1304282286.73" 
    capture_lex $P2409
    .const 'Sub' $P47 = "12_1304282286.73" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1304282286.73" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2292
    .const 'Sub' $P16 = "11_1304282286.73" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1304282286.73" 
    capture_lex $P47
    $P47()
.annotate 'line', 731
    .const 'Sub' $P2409 = "552_1304282286.73" 
    capture_lex $P2409
    $P2409()
.annotate 'line', 774
    .const 'Sub' $P2497 = "582_1304282286.73" 
    capture_lex $P2497
    $P2497()
.annotate 'line', 2234
    .const 'Sub' $P6590 = "758_1304282286.73" 
    capture_lex $P6590
    $P6590()
.annotate 'line', 2289
    .const 'Sub' $P6728 = "767_1304282286.73" 
    capture_lex $P6728
    $P6728()
    find_lex $P6736, "MAIN"
    find_lex $P6739, "@ARGS"
    if $P6739, if_6738
    set $P6737, $P6739
    goto if_6738_end
  if_6738:
    .const 'Sub' $P6740 = "11_1304282286.73" 
    find_lex $P6741, "@ARGS"
    $P6742 = $P6740($P6741 :flat)
    set $P6737, $P6742
  if_6738_end:
.annotate 'line', 1
    .return ($P6737)
    .const 'Sub' $P6744 = "769_1304282286.73" 
    .return ($P6744)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post770") :outer("10_1304282286.73")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1304282286.73" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6748, "1304282274.421"
    isnull $I6749, $P6748
    if $I6749, if_6747
    .const 'Sub' $P8836 = "10_1304282286.73" 
    $P8837 = $P8836."get_lexinfo"()
    nqp_get_sc_object $P8838, "1304282274.421", 0
    $P8837."set_static_lexpad_value"("GLOBALish", $P8838)
    .const 'Sub' $P8839 = "10_1304282286.73" 
    $P8840 = $P8839."get_lexinfo"()
    $P8840."finish_static_lexpad"()
    .const 'Sub' $P8841 = "10_1304282286.73" 
    $P8842 = $P8841."get_lexinfo"()
    nqp_get_sc_object $P8843, "1304282274.421", 0
    $P8842."set_static_lexpad_value"("$?PACKAGE", $P8843)
    .const 'Sub' $P8844 = "10_1304282286.73" 
    $P8845 = $P8844."get_lexinfo"()
    $P8845."finish_static_lexpad"()
    nqp_get_sc_object $P8846, "1304282274.421", 2
    .const 'Sub' $P8847 = "13_1304282286.73" 
    copy $P8846, $P8847
    nqp_get_sc_object $P8848, "1304282274.421", 3
    .const 'Sub' $P8849 = "14_1304282286.73" 
    copy $P8848, $P8849
    nqp_get_sc_object $P8850, "1304282274.421", 4
    .const 'Sub' $P8851 = "16_1304282286.73" 
    copy $P8850, $P8851
    nqp_get_sc_object $P8852, "1304282274.421", 5
    .const 'Sub' $P8853 = "17_1304282286.73" 
    copy $P8852, $P8853
    nqp_get_sc_object $P8854, "1304282274.421", 6
    .const 'Sub' $P8855 = "19_1304282286.73" 
    copy $P8854, $P8855
    nqp_get_sc_object $P8856, "1304282274.421", 7
    .const 'Sub' $P8857 = "20_1304282286.73" 
    copy $P8856, $P8857
    nqp_get_sc_object $P8858, "1304282274.421", 8
    .const 'Sub' $P8859 = "22_1304282286.73" 
    copy $P8858, $P8859
    nqp_get_sc_object $P8860, "1304282274.421", 9
    .const 'Sub' $P8861 = "23_1304282286.73" 
    copy $P8860, $P8861
    nqp_get_sc_object $P8862, "1304282274.421", 10
    .const 'Sub' $P8863 = "25_1304282286.73" 
    copy $P8862, $P8863
    nqp_get_sc_object $P8864, "1304282274.421", 11
    .const 'Sub' $P8865 = "26_1304282286.73" 
    copy $P8864, $P8865
    nqp_get_sc_object $P8866, "1304282274.421", 12
    .const 'Sub' $P8867 = "28_1304282286.73" 
    copy $P8866, $P8867
    nqp_get_sc_object $P8868, "1304282274.421", 13
    .const 'Sub' $P8869 = "29_1304282286.73" 
    copy $P8868, $P8869
    nqp_get_sc_object $P8870, "1304282274.421", 14
    .const 'Sub' $P8871 = "32_1304282286.73" 
    copy $P8870, $P8871
    nqp_get_sc_object $P8872, "1304282274.421", 15
    .const 'Sub' $P8873 = "33_1304282286.73" 
    copy $P8872, $P8873
    nqp_get_sc_object $P8874, "1304282274.421", 16
    .const 'Sub' $P8875 = "36_1304282286.73" 
    copy $P8874, $P8875
    nqp_get_sc_object $P8876, "1304282274.421", 17
    .const 'Sub' $P8877 = "37_1304282286.73" 
    copy $P8876, $P8877
    nqp_get_sc_object $P8878, "1304282274.421", 18
    .const 'Sub' $P8879 = "39_1304282286.73" 
    copy $P8878, $P8879
    nqp_get_sc_object $P8880, "1304282274.421", 19
    .const 'Sub' $P8881 = "40_1304282286.73" 
    copy $P8880, $P8881
    nqp_get_sc_object $P8882, "1304282274.421", 20
    .const 'Sub' $P8883 = "42_1304282286.73" 
    copy $P8882, $P8883
    nqp_get_sc_object $P8884, "1304282274.421", 21
    .const 'Sub' $P8885 = "43_1304282286.73" 
    copy $P8884, $P8885
    nqp_get_sc_object $P8886, "1304282274.421", 22
    .const 'Sub' $P8887 = "46_1304282286.73" 
    copy $P8886, $P8887
    nqp_get_sc_object $P8888, "1304282274.421", 23
    .const 'Sub' $P8889 = "47_1304282286.73" 
    copy $P8888, $P8889
    nqp_get_sc_object $P8890, "1304282274.421", 24
    .const 'Sub' $P8891 = "49_1304282286.73" 
    copy $P8890, $P8891
    nqp_get_sc_object $P8892, "1304282274.421", 25
    .const 'Sub' $P8893 = "50_1304282286.73" 
    copy $P8892, $P8893
    nqp_get_sc_object $P8894, "1304282274.421", 26
    .const 'Sub' $P8895 = "52_1304282286.73" 
    copy $P8894, $P8895
    nqp_get_sc_object $P8896, "1304282274.421", 27
    .const 'Sub' $P8897 = "53_1304282286.73" 
    copy $P8896, $P8897
    nqp_get_sc_object $P8898, "1304282274.421", 28
    .const 'Sub' $P8899 = "55_1304282286.73" 
    copy $P8898, $P8899
    nqp_get_sc_object $P8900, "1304282274.421", 29
    .const 'Sub' $P8901 = "56_1304282286.73" 
    copy $P8900, $P8901
    nqp_get_sc_object $P8902, "1304282274.421", 30
    .const 'Sub' $P8903 = "58_1304282286.73" 
    copy $P8902, $P8903
    nqp_get_sc_object $P8904, "1304282274.421", 31
    .const 'Sub' $P8905 = "59_1304282286.73" 
    copy $P8904, $P8905
    nqp_get_sc_object $P8906, "1304282274.421", 32
    .const 'Sub' $P8907 = "61_1304282286.73" 
    copy $P8906, $P8907
    nqp_get_sc_object $P8908, "1304282274.421", 33
    .const 'Sub' $P8909 = "62_1304282286.73" 
    copy $P8908, $P8909
    nqp_get_sc_object $P8910, "1304282274.421", 34
    .const 'Sub' $P8911 = "64_1304282286.73" 
    copy $P8910, $P8911
    nqp_get_sc_object $P8912, "1304282274.421", 35
    .const 'Sub' $P8913 = "65_1304282286.73" 
    copy $P8912, $P8913
    nqp_get_sc_object $P8914, "1304282274.421", 36
    .const 'Sub' $P8915 = "67_1304282286.73" 
    copy $P8914, $P8915
    nqp_get_sc_object $P8916, "1304282274.421", 37
    .const 'Sub' $P8917 = "68_1304282286.73" 
    copy $P8916, $P8917
    nqp_get_sc_object $P8918, "1304282274.421", 38
    .const 'Sub' $P8919 = "70_1304282286.73" 
    copy $P8918, $P8919
    nqp_get_sc_object $P8920, "1304282274.421", 39
    .const 'Sub' $P8921 = "71_1304282286.73" 
    copy $P8920, $P8921
    nqp_get_sc_object $P8922, "1304282274.421", 40
    .const 'Sub' $P8923 = "73_1304282286.73" 
    copy $P8922, $P8923
    nqp_get_sc_object $P8924, "1304282274.421", 41
    .const 'Sub' $P8925 = "74_1304282286.73" 
    copy $P8924, $P8925
    nqp_get_sc_object $P8926, "1304282274.421", 42
    .const 'Sub' $P8927 = "76_1304282286.73" 
    copy $P8926, $P8927
    nqp_get_sc_object $P8928, "1304282274.421", 43
    .const 'Sub' $P8929 = "77_1304282286.73" 
    copy $P8928, $P8929
    nqp_get_sc_object $P8930, "1304282274.421", 44
    .const 'Sub' $P8931 = "79_1304282286.73" 
    copy $P8930, $P8931
    nqp_get_sc_object $P8932, "1304282274.421", 45
    .const 'Sub' $P8933 = "80_1304282286.73" 
    copy $P8932, $P8933
    nqp_get_sc_object $P8934, "1304282274.421", 46
    .const 'Sub' $P8935 = "81_1304282286.73" 
    copy $P8934, $P8935
    nqp_get_sc_object $P8936, "1304282274.421", 47
    .const 'Sub' $P8937 = "82_1304282286.73" 
    copy $P8936, $P8937
    nqp_get_sc_object $P8938, "1304282274.421", 48
    .const 'Sub' $P8939 = "84_1304282286.73" 
    copy $P8938, $P8939
    nqp_get_sc_object $P8940, "1304282274.421", 49
    .const 'Sub' $P8941 = "85_1304282286.73" 
    copy $P8940, $P8941
    nqp_get_sc_object $P8942, "1304282274.421", 50
    .const 'Sub' $P8943 = "87_1304282286.73" 
    copy $P8942, $P8943
    nqp_get_sc_object $P8944, "1304282274.421", 51
    .const 'Sub' $P8945 = "88_1304282286.73" 
    copy $P8944, $P8945
    nqp_get_sc_object $P8946, "1304282274.421", 52
    .const 'Sub' $P8947 = "89_1304282286.73" 
    copy $P8946, $P8947
    nqp_get_sc_object $P8948, "1304282274.421", 53
    .const 'Sub' $P8949 = "90_1304282286.73" 
    copy $P8948, $P8949
    nqp_get_sc_object $P8950, "1304282274.421", 54
    .const 'Sub' $P8951 = "92_1304282286.73" 
    copy $P8950, $P8951
    nqp_get_sc_object $P8952, "1304282274.421", 55
    .const 'Sub' $P8953 = "93_1304282286.73" 
    copy $P8952, $P8953
    nqp_get_sc_object $P8954, "1304282274.421", 56
    .const 'Sub' $P8955 = "95_1304282286.73" 
    copy $P8954, $P8955
    nqp_get_sc_object $P8956, "1304282274.421", 57
    .const 'Sub' $P8957 = "96_1304282286.73" 
    copy $P8956, $P8957
    nqp_get_sc_object $P8958, "1304282274.421", 58
    .const 'Sub' $P8959 = "99_1304282286.73" 
    copy $P8958, $P8959
    nqp_get_sc_object $P8960, "1304282274.421", 59
    .const 'Sub' $P8961 = "100_1304282286.73" 
    copy $P8960, $P8961
    nqp_get_sc_object $P8962, "1304282274.421", 60
    .const 'Sub' $P8963 = "102_1304282286.73" 
    copy $P8962, $P8963
    nqp_get_sc_object $P8964, "1304282274.421", 61
    .const 'Sub' $P8965 = "103_1304282286.73" 
    copy $P8964, $P8965
    nqp_get_sc_object $P8966, "1304282274.421", 62
    .const 'Sub' $P8967 = "105_1304282286.73" 
    copy $P8966, $P8967
    nqp_get_sc_object $P8968, "1304282274.421", 63
    .const 'Sub' $P8969 = "106_1304282286.73" 
    copy $P8968, $P8969
    nqp_get_sc_object $P8970, "1304282274.421", 64
    .const 'Sub' $P8971 = "108_1304282286.73" 
    copy $P8970, $P8971
    nqp_get_sc_object $P8972, "1304282274.421", 65
    .const 'Sub' $P8973 = "109_1304282286.73" 
    copy $P8972, $P8973
    nqp_get_sc_object $P8974, "1304282274.421", 66
    .const 'Sub' $P8975 = "111_1304282286.73" 
    copy $P8974, $P8975
    nqp_get_sc_object $P8976, "1304282274.421", 67
    .const 'Sub' $P8977 = "112_1304282286.73" 
    copy $P8976, $P8977
    nqp_get_sc_object $P8978, "1304282274.421", 68
    .const 'Sub' $P8979 = "114_1304282286.73" 
    copy $P8978, $P8979
    nqp_get_sc_object $P8980, "1304282274.421", 69
    .const 'Sub' $P8981 = "115_1304282286.73" 
    copy $P8980, $P8981
    nqp_get_sc_object $P8982, "1304282274.421", 70
    .const 'Sub' $P8983 = "116_1304282286.73" 
    copy $P8982, $P8983
    nqp_get_sc_object $P8984, "1304282274.421", 71
    .const 'Sub' $P8985 = "117_1304282286.73" 
    copy $P8984, $P8985
    nqp_get_sc_object $P8986, "1304282274.421", 72
    .const 'Sub' $P8987 = "119_1304282286.73" 
    copy $P8986, $P8987
    nqp_get_sc_object $P8988, "1304282274.421", 73
    .const 'Sub' $P8989 = "120_1304282286.73" 
    copy $P8988, $P8989
    nqp_get_sc_object $P8990, "1304282274.421", 74
    .const 'Sub' $P8991 = "122_1304282286.73" 
    copy $P8990, $P8991
    nqp_get_sc_object $P8992, "1304282274.421", 75
    .const 'Sub' $P8993 = "123_1304282286.73" 
    copy $P8992, $P8993
    nqp_get_sc_object $P8994, "1304282274.421", 76
    .const 'Sub' $P8995 = "125_1304282286.73" 
    copy $P8994, $P8995
    nqp_get_sc_object $P8996, "1304282274.421", 77
    .const 'Sub' $P8997 = "126_1304282286.73" 
    copy $P8996, $P8997
    nqp_get_sc_object $P8998, "1304282274.421", 78
    .const 'Sub' $P8999 = "127_1304282286.73" 
    copy $P8998, $P8999
    nqp_get_sc_object $P9000, "1304282274.421", 79
    .const 'Sub' $P9001 = "128_1304282286.73" 
    copy $P9000, $P9001
    nqp_get_sc_object $P9002, "1304282274.421", 80
    .const 'Sub' $P9003 = "130_1304282286.73" 
    copy $P9002, $P9003
    nqp_get_sc_object $P9004, "1304282274.421", 81
    .const 'Sub' $P9005 = "131_1304282286.73" 
    copy $P9004, $P9005
    nqp_get_sc_object $P9006, "1304282274.421", 82
    .const 'Sub' $P9007 = "133_1304282286.73" 
    copy $P9006, $P9007
    nqp_get_sc_object $P9008, "1304282274.421", 83
    .const 'Sub' $P9009 = "134_1304282286.73" 
    copy $P9008, $P9009
    nqp_get_sc_object $P9010, "1304282274.421", 84
    .const 'Sub' $P9011 = "135_1304282286.73" 
    copy $P9010, $P9011
    nqp_get_sc_object $P9012, "1304282274.421", 85
    .const 'Sub' $P9013 = "136_1304282286.73" 
    copy $P9012, $P9013
    nqp_get_sc_object $P9014, "1304282274.421", 86
    .const 'Sub' $P9015 = "138_1304282286.73" 
    copy $P9014, $P9015
    nqp_get_sc_object $P9016, "1304282274.421", 87
    .const 'Sub' $P9017 = "139_1304282286.73" 
    copy $P9016, $P9017
    nqp_get_sc_object $P9018, "1304282274.421", 88
    .const 'Sub' $P9019 = "141_1304282286.73" 
    copy $P9018, $P9019
    nqp_get_sc_object $P9020, "1304282274.421", 89
    .const 'Sub' $P9021 = "142_1304282286.73" 
    copy $P9020, $P9021
    nqp_get_sc_object $P9022, "1304282274.421", 90
    .const 'Sub' $P9023 = "144_1304282286.73" 
    copy $P9022, $P9023
    nqp_get_sc_object $P9024, "1304282274.421", 91
    .const 'Sub' $P9025 = "145_1304282286.73" 
    copy $P9024, $P9025
    nqp_get_sc_object $P9026, "1304282274.421", 92
    .const 'Sub' $P9027 = "147_1304282286.73" 
    copy $P9026, $P9027
    nqp_get_sc_object $P9028, "1304282274.421", 93
    .const 'Sub' $P9029 = "148_1304282286.73" 
    copy $P9028, $P9029
    nqp_get_sc_object $P9030, "1304282274.421", 94
    .const 'Sub' $P9031 = "150_1304282286.73" 
    copy $P9030, $P9031
    nqp_get_sc_object $P9032, "1304282274.421", 95
    .const 'Sub' $P9033 = "151_1304282286.73" 
    copy $P9032, $P9033
    nqp_get_sc_object $P9034, "1304282274.421", 96
    .const 'Sub' $P9035 = "153_1304282286.73" 
    copy $P9034, $P9035
    nqp_get_sc_object $P9036, "1304282274.421", 97
    .const 'Sub' $P9037 = "154_1304282286.73" 
    copy $P9036, $P9037
    nqp_get_sc_object $P9038, "1304282274.421", 98
    .const 'Sub' $P9039 = "156_1304282286.73" 
    copy $P9038, $P9039
    nqp_get_sc_object $P9040, "1304282274.421", 99
    .const 'Sub' $P9041 = "157_1304282286.73" 
    copy $P9040, $P9041
    nqp_get_sc_object $P9042, "1304282274.421", 100
    .const 'Sub' $P9043 = "159_1304282286.73" 
    copy $P9042, $P9043
    nqp_get_sc_object $P9044, "1304282274.421", 101
    .const 'Sub' $P9045 = "160_1304282286.73" 
    copy $P9044, $P9045
    nqp_get_sc_object $P9046, "1304282274.421", 102
    .const 'Sub' $P9047 = "162_1304282286.73" 
    copy $P9046, $P9047
    nqp_get_sc_object $P9048, "1304282274.421", 103
    .const 'Sub' $P9049 = "163_1304282286.73" 
    copy $P9048, $P9049
    nqp_get_sc_object $P9050, "1304282274.421", 104
    .const 'Sub' $P9051 = "167_1304282286.73" 
    copy $P9050, $P9051
    nqp_get_sc_object $P9052, "1304282274.421", 105
    .const 'Sub' $P9053 = "168_1304282286.73" 
    copy $P9052, $P9053
    nqp_get_sc_object $P9054, "1304282274.421", 106
    .const 'Sub' $P9055 = "170_1304282286.73" 
    copy $P9054, $P9055
    nqp_get_sc_object $P9056, "1304282274.421", 107
    .const 'Sub' $P9057 = "171_1304282286.73" 
    copy $P9056, $P9057
    nqp_get_sc_object $P9058, "1304282274.421", 108
    .const 'Sub' $P9059 = "173_1304282286.73" 
    copy $P9058, $P9059
    nqp_get_sc_object $P9060, "1304282274.421", 109
    .const 'Sub' $P9061 = "174_1304282286.73" 
    copy $P9060, $P9061
    nqp_get_sc_object $P9062, "1304282274.421", 110
    .const 'Sub' $P9063 = "176_1304282286.73" 
    copy $P9062, $P9063
    nqp_get_sc_object $P9064, "1304282274.421", 111
    .const 'Sub' $P9065 = "177_1304282286.73" 
    copy $P9064, $P9065
    nqp_get_sc_object $P9066, "1304282274.421", 112
    .const 'Sub' $P9067 = "179_1304282286.73" 
    copy $P9066, $P9067
    nqp_get_sc_object $P9068, "1304282274.421", 113
    .const 'Sub' $P9069 = "180_1304282286.73" 
    copy $P9068, $P9069
    nqp_get_sc_object $P9070, "1304282274.421", 114
    .const 'Sub' $P9071 = "182_1304282286.73" 
    copy $P9070, $P9071
    nqp_get_sc_object $P9072, "1304282274.421", 115
    .const 'Sub' $P9073 = "183_1304282286.73" 
    copy $P9072, $P9073
    nqp_get_sc_object $P9074, "1304282274.421", 116
    .const 'Sub' $P9075 = "185_1304282286.73" 
    copy $P9074, $P9075
    nqp_get_sc_object $P9076, "1304282274.421", 117
    .const 'Sub' $P9077 = "186_1304282286.73" 
    copy $P9076, $P9077
    nqp_get_sc_object $P9078, "1304282274.421", 118
    .const 'Sub' $P9079 = "188_1304282286.73" 
    copy $P9078, $P9079
    nqp_get_sc_object $P9080, "1304282274.421", 119
    .const 'Sub' $P9081 = "189_1304282286.73" 
    copy $P9080, $P9081
    nqp_get_sc_object $P9082, "1304282274.421", 120
    .const 'Sub' $P9083 = "191_1304282286.73" 
    copy $P9082, $P9083
    nqp_get_sc_object $P9084, "1304282274.421", 121
    .const 'Sub' $P9085 = "192_1304282286.73" 
    copy $P9084, $P9085
    nqp_get_sc_object $P9086, "1304282274.421", 122
    .const 'Sub' $P9087 = "193_1304282286.73" 
    copy $P9086, $P9087
    nqp_get_sc_object $P9088, "1304282274.421", 123
    .const 'Sub' $P9089 = "194_1304282286.73" 
    copy $P9088, $P9089
    nqp_get_sc_object $P9090, "1304282274.421", 124
    .const 'Sub' $P9091 = "196_1304282286.73" 
    copy $P9090, $P9091
    nqp_get_sc_object $P9092, "1304282274.421", 125
    .const 'Sub' $P9093 = "197_1304282286.73" 
    copy $P9092, $P9093
    nqp_get_sc_object $P9094, "1304282274.421", 126
    .const 'Sub' $P9095 = "199_1304282286.73" 
    copy $P9094, $P9095
    nqp_get_sc_object $P9096, "1304282274.421", 127
    .const 'Sub' $P9097 = "200_1304282286.73" 
    copy $P9096, $P9097
    nqp_get_sc_object $P9098, "1304282274.421", 128
    .const 'Sub' $P9099 = "202_1304282286.73" 
    copy $P9098, $P9099
    nqp_get_sc_object $P9100, "1304282274.421", 129
    .const 'Sub' $P9101 = "203_1304282286.73" 
    copy $P9100, $P9101
    nqp_get_sc_object $P9102, "1304282274.421", 130
    .const 'Sub' $P9103 = "205_1304282286.73" 
    copy $P9102, $P9103
    nqp_get_sc_object $P9104, "1304282274.421", 131
    .const 'Sub' $P9105 = "206_1304282286.73" 
    copy $P9104, $P9105
    nqp_get_sc_object $P9106, "1304282274.421", 132
    .const 'Sub' $P9107 = "208_1304282286.73" 
    copy $P9106, $P9107
    nqp_get_sc_object $P9108, "1304282274.421", 133
    .const 'Sub' $P9109 = "209_1304282286.73" 
    copy $P9108, $P9109
    nqp_get_sc_object $P9110, "1304282274.421", 134
    .const 'Sub' $P9111 = "211_1304282286.73" 
    copy $P9110, $P9111
    nqp_get_sc_object $P9112, "1304282274.421", 135
    .const 'Sub' $P9113 = "212_1304282286.73" 
    copy $P9112, $P9113
    nqp_get_sc_object $P9114, "1304282274.421", 136
    .const 'Sub' $P9115 = "215_1304282286.73" 
    copy $P9114, $P9115
    nqp_get_sc_object $P9116, "1304282274.421", 137
    .const 'Sub' $P9117 = "216_1304282286.73" 
    copy $P9116, $P9117
    nqp_get_sc_object $P9118, "1304282274.421", 138
    .const 'Sub' $P9119 = "217_1304282286.73" 
    copy $P9118, $P9119
    nqp_get_sc_object $P9120, "1304282274.421", 139
    .const 'Sub' $P9121 = "218_1304282286.73" 
    copy $P9120, $P9121
    nqp_get_sc_object $P9122, "1304282274.421", 140
    .const 'Sub' $P9123 = "220_1304282286.73" 
    copy $P9122, $P9123
    nqp_get_sc_object $P9124, "1304282274.421", 141
    .const 'Sub' $P9125 = "221_1304282286.73" 
    copy $P9124, $P9125
    nqp_get_sc_object $P9126, "1304282274.421", 142
    .const 'Sub' $P9127 = "223_1304282286.73" 
    copy $P9126, $P9127
    nqp_get_sc_object $P9128, "1304282274.421", 143
    .const 'Sub' $P9129 = "224_1304282286.73" 
    copy $P9128, $P9129
    nqp_get_sc_object $P9130, "1304282274.421", 144
    .const 'Sub' $P9131 = "226_1304282286.73" 
    copy $P9130, $P9131
    nqp_get_sc_object $P9132, "1304282274.421", 145
    .const 'Sub' $P9133 = "227_1304282286.73" 
    copy $P9132, $P9133
    nqp_get_sc_object $P9134, "1304282274.421", 146
    .const 'Sub' $P9135 = "229_1304282286.73" 
    copy $P9134, $P9135
    nqp_get_sc_object $P9136, "1304282274.421", 147
    .const 'Sub' $P9137 = "230_1304282286.73" 
    copy $P9136, $P9137
    nqp_get_sc_object $P9138, "1304282274.421", 148
    .const 'Sub' $P9139 = "233_1304282286.73" 
    copy $P9138, $P9139
    nqp_get_sc_object $P9140, "1304282274.421", 149
    .const 'Sub' $P9141 = "234_1304282286.73" 
    copy $P9140, $P9141
    nqp_get_sc_object $P9142, "1304282274.421", 150
    .const 'Sub' $P9143 = "236_1304282286.73" 
    copy $P9142, $P9143
    nqp_get_sc_object $P9144, "1304282274.421", 151
    .const 'Sub' $P9145 = "237_1304282286.73" 
    copy $P9144, $P9145
    nqp_get_sc_object $P9146, "1304282274.421", 152
    .const 'Sub' $P9147 = "240_1304282286.73" 
    copy $P9146, $P9147
    nqp_get_sc_object $P9148, "1304282274.421", 153
    .const 'Sub' $P9149 = "241_1304282286.73" 
    copy $P9148, $P9149
    nqp_get_sc_object $P9150, "1304282274.421", 154
    .const 'Sub' $P9151 = "242_1304282286.73" 
    copy $P9150, $P9151
    nqp_get_sc_object $P9152, "1304282274.421", 155
    .const 'Sub' $P9153 = "243_1304282286.73" 
    copy $P9152, $P9153
    nqp_get_sc_object $P9154, "1304282274.421", 156
    .const 'Sub' $P9155 = "245_1304282286.73" 
    copy $P9154, $P9155
    nqp_get_sc_object $P9156, "1304282274.421", 157
    .const 'Sub' $P9157 = "246_1304282286.73" 
    copy $P9156, $P9157
    nqp_get_sc_object $P9158, "1304282274.421", 158
    .const 'Sub' $P9159 = "248_1304282286.73" 
    copy $P9158, $P9159
    nqp_get_sc_object $P9160, "1304282274.421", 159
    .const 'Sub' $P9161 = "249_1304282286.73" 
    copy $P9160, $P9161
    nqp_get_sc_object $P9162, "1304282274.421", 160
    .const 'Sub' $P9163 = "251_1304282286.73" 
    copy $P9162, $P9163
    nqp_get_sc_object $P9164, "1304282274.421", 161
    .const 'Sub' $P9165 = "252_1304282286.73" 
    copy $P9164, $P9165
    nqp_get_sc_object $P9166, "1304282274.421", 162
    .const 'Sub' $P9167 = "255_1304282286.73" 
    copy $P9166, $P9167
    nqp_get_sc_object $P9168, "1304282274.421", 163
    .const 'Sub' $P9169 = "256_1304282286.73" 
    copy $P9168, $P9169
    nqp_get_sc_object $P9170, "1304282274.421", 164
    .const 'Sub' $P9171 = "259_1304282286.73" 
    copy $P9170, $P9171
    nqp_get_sc_object $P9172, "1304282274.421", 165
    .const 'Sub' $P9173 = "260_1304282286.73" 
    copy $P9172, $P9173
    nqp_get_sc_object $P9174, "1304282274.421", 166
    .const 'Sub' $P9175 = "261_1304282286.73" 
    copy $P9174, $P9175
    nqp_get_sc_object $P9176, "1304282274.421", 167
    .const 'Sub' $P9177 = "262_1304282286.73" 
    copy $P9176, $P9177
    nqp_get_sc_object $P9178, "1304282274.421", 168
    .const 'Sub' $P9179 = "264_1304282286.73" 
    copy $P9178, $P9179
    nqp_get_sc_object $P9180, "1304282274.421", 169
    .const 'Sub' $P9181 = "265_1304282286.73" 
    copy $P9180, $P9181
    nqp_get_sc_object $P9182, "1304282274.421", 170
    .const 'Sub' $P9183 = "267_1304282286.73" 
    copy $P9182, $P9183
    nqp_get_sc_object $P9184, "1304282274.421", 171
    .const 'Sub' $P9185 = "268_1304282286.73" 
    copy $P9184, $P9185
    nqp_get_sc_object $P9186, "1304282274.421", 172
    .const 'Sub' $P9187 = "270_1304282286.73" 
    copy $P9186, $P9187
    nqp_get_sc_object $P9188, "1304282274.421", 173
    .const 'Sub' $P9189 = "271_1304282286.73" 
    copy $P9188, $P9189
    nqp_get_sc_object $P9190, "1304282274.421", 174
    .const 'Sub' $P9191 = "274_1304282286.73" 
    copy $P9190, $P9191
    nqp_get_sc_object $P9192, "1304282274.421", 175
    .const 'Sub' $P9193 = "275_1304282286.73" 
    copy $P9192, $P9193
    nqp_get_sc_object $P9194, "1304282274.421", 176
    .const 'Sub' $P9195 = "277_1304282286.73" 
    copy $P9194, $P9195
    nqp_get_sc_object $P9196, "1304282274.421", 177
    .const 'Sub' $P9197 = "278_1304282286.73" 
    copy $P9196, $P9197
    nqp_get_sc_object $P9198, "1304282274.421", 178
    .const 'Sub' $P9199 = "280_1304282286.73" 
    copy $P9198, $P9199
    nqp_get_sc_object $P9200, "1304282274.421", 179
    .const 'Sub' $P9201 = "281_1304282286.73" 
    copy $P9200, $P9201
    nqp_get_sc_object $P9202, "1304282274.421", 180
    .const 'Sub' $P9203 = "283_1304282286.73" 
    copy $P9202, $P9203
    nqp_get_sc_object $P9204, "1304282274.421", 181
    .const 'Sub' $P9205 = "284_1304282286.73" 
    copy $P9204, $P9205
    nqp_get_sc_object $P9206, "1304282274.421", 182
    .const 'Sub' $P9207 = "286_1304282286.73" 
    copy $P9206, $P9207
    nqp_get_sc_object $P9208, "1304282274.421", 183
    .const 'Sub' $P9209 = "287_1304282286.73" 
    copy $P9208, $P9209
    nqp_get_sc_object $P9210, "1304282274.421", 184
    .const 'Sub' $P9211 = "289_1304282286.73" 
    copy $P9210, $P9211
    nqp_get_sc_object $P9212, "1304282274.421", 185
    .const 'Sub' $P9213 = "290_1304282286.73" 
    copy $P9212, $P9213
    nqp_get_sc_object $P9214, "1304282274.421", 186
    .const 'Sub' $P9215 = "291_1304282286.73" 
    copy $P9214, $P9215
    nqp_get_sc_object $P9216, "1304282274.421", 187
    .const 'Sub' $P9217 = "292_1304282286.73" 
    copy $P9216, $P9217
    nqp_get_sc_object $P9218, "1304282274.421", 188
    .const 'Sub' $P9219 = "294_1304282286.73" 
    copy $P9218, $P9219
    nqp_get_sc_object $P9220, "1304282274.421", 189
    .const 'Sub' $P9221 = "295_1304282286.73" 
    copy $P9220, $P9221
    nqp_get_sc_object $P9222, "1304282274.421", 190
    .const 'Sub' $P9223 = "297_1304282286.73" 
    copy $P9222, $P9223
    nqp_get_sc_object $P9224, "1304282274.421", 191
    .const 'Sub' $P9225 = "298_1304282286.73" 
    copy $P9224, $P9225
    nqp_get_sc_object $P9226, "1304282274.421", 192
    .const 'Sub' $P9227 = "300_1304282286.73" 
    copy $P9226, $P9227
    nqp_get_sc_object $P9228, "1304282274.421", 193
    .const 'Sub' $P9229 = "301_1304282286.73" 
    copy $P9228, $P9229
    nqp_get_sc_object $P9230, "1304282274.421", 194
    .const 'Sub' $P9231 = "302_1304282286.73" 
    copy $P9230, $P9231
    nqp_get_sc_object $P9232, "1304282274.421", 195
    .const 'Sub' $P9233 = "303_1304282286.73" 
    copy $P9232, $P9233
    nqp_get_sc_object $P9234, "1304282274.421", 196
    .const 'Sub' $P9235 = "305_1304282286.73" 
    copy $P9234, $P9235
    nqp_get_sc_object $P9236, "1304282274.421", 197
    .const 'Sub' $P9237 = "306_1304282286.73" 
    copy $P9236, $P9237
    nqp_get_sc_object $P9238, "1304282274.421", 198
    .const 'Sub' $P9239 = "308_1304282286.73" 
    copy $P9238, $P9239
    nqp_get_sc_object $P9240, "1304282274.421", 199
    .const 'Sub' $P9241 = "309_1304282286.73" 
    copy $P9240, $P9241
    nqp_get_sc_object $P9242, "1304282274.421", 200
    .const 'Sub' $P9243 = "311_1304282286.73" 
    copy $P9242, $P9243
    nqp_get_sc_object $P9244, "1304282274.421", 201
    .const 'Sub' $P9245 = "312_1304282286.73" 
    copy $P9244, $P9245
    nqp_get_sc_object $P9246, "1304282274.421", 202
    .const 'Sub' $P9247 = "314_1304282286.73" 
    copy $P9246, $P9247
    nqp_get_sc_object $P9248, "1304282274.421", 203
    .const 'Sub' $P9249 = "315_1304282286.73" 
    copy $P9248, $P9249
    nqp_get_sc_object $P9250, "1304282274.421", 204
    .const 'Sub' $P9251 = "318_1304282286.73" 
    copy $P9250, $P9251
    nqp_get_sc_object $P9252, "1304282274.421", 205
    .const 'Sub' $P9253 = "319_1304282286.73" 
    copy $P9252, $P9253
    nqp_get_sc_object $P9254, "1304282274.421", 206
    .const 'Sub' $P9255 = "321_1304282286.73" 
    copy $P9254, $P9255
    nqp_get_sc_object $P9256, "1304282274.421", 207
    .const 'Sub' $P9257 = "322_1304282286.73" 
    copy $P9256, $P9257
    nqp_get_sc_object $P9258, "1304282274.421", 208
    .const 'Sub' $P9259 = "324_1304282286.73" 
    copy $P9258, $P9259
    nqp_get_sc_object $P9260, "1304282274.421", 209
    .const 'Sub' $P9261 = "325_1304282286.73" 
    copy $P9260, $P9261
    nqp_get_sc_object $P9262, "1304282274.421", 210
    .const 'Sub' $P9263 = "327_1304282286.73" 
    copy $P9262, $P9263
    nqp_get_sc_object $P9264, "1304282274.421", 211
    .const 'Sub' $P9265 = "328_1304282286.73" 
    copy $P9264, $P9265
    nqp_get_sc_object $P9266, "1304282274.421", 212
    .const 'Sub' $P9267 = "330_1304282286.73" 
    copy $P9266, $P9267
    nqp_get_sc_object $P9268, "1304282274.421", 213
    .const 'Sub' $P9269 = "331_1304282286.73" 
    copy $P9268, $P9269
    nqp_get_sc_object $P9270, "1304282274.421", 214
    .const 'Sub' $P9271 = "333_1304282286.73" 
    copy $P9270, $P9271
    nqp_get_sc_object $P9272, "1304282274.421", 215
    .const 'Sub' $P9273 = "334_1304282286.73" 
    copy $P9272, $P9273
    nqp_get_sc_object $P9274, "1304282274.421", 216
    .const 'Sub' $P9275 = "335_1304282286.73" 
    copy $P9274, $P9275
    nqp_get_sc_object $P9276, "1304282274.421", 217
    .const 'Sub' $P9277 = "336_1304282286.73" 
    copy $P9276, $P9277
    nqp_get_sc_object $P9278, "1304282274.421", 218
    .const 'Sub' $P9279 = "338_1304282286.73" 
    copy $P9278, $P9279
    nqp_get_sc_object $P9280, "1304282274.421", 219
    .const 'Sub' $P9281 = "339_1304282286.73" 
    copy $P9280, $P9281
    nqp_get_sc_object $P9282, "1304282274.421", 220
    .const 'Sub' $P9283 = "341_1304282286.73" 
    copy $P9282, $P9283
    nqp_get_sc_object $P9284, "1304282274.421", 221
    .const 'Sub' $P9285 = "342_1304282286.73" 
    copy $P9284, $P9285
    nqp_get_sc_object $P9286, "1304282274.421", 222
    .const 'Sub' $P9287 = "344_1304282286.73" 
    copy $P9286, $P9287
    nqp_get_sc_object $P9288, "1304282274.421", 223
    .const 'Sub' $P9289 = "345_1304282286.73" 
    copy $P9288, $P9289
    nqp_get_sc_object $P9290, "1304282274.421", 224
    .const 'Sub' $P9291 = "347_1304282286.73" 
    copy $P9290, $P9291
    nqp_get_sc_object $P9292, "1304282274.421", 225
    .const 'Sub' $P9293 = "348_1304282286.73" 
    copy $P9292, $P9293
    nqp_get_sc_object $P9294, "1304282274.421", 226
    .const 'Sub' $P9295 = "350_1304282286.73" 
    copy $P9294, $P9295
    nqp_get_sc_object $P9296, "1304282274.421", 227
    .const 'Sub' $P9297 = "351_1304282286.73" 
    copy $P9296, $P9297
    nqp_get_sc_object $P9298, "1304282274.421", 228
    .const 'Sub' $P9299 = "353_1304282286.73" 
    copy $P9298, $P9299
    nqp_get_sc_object $P9300, "1304282274.421", 229
    .const 'Sub' $P9301 = "354_1304282286.73" 
    copy $P9300, $P9301
    nqp_get_sc_object $P9302, "1304282274.421", 230
    .const 'Sub' $P9303 = "356_1304282286.73" 
    copy $P9302, $P9303
    nqp_get_sc_object $P9304, "1304282274.421", 231
    .const 'Sub' $P9305 = "357_1304282286.73" 
    copy $P9304, $P9305
    nqp_get_sc_object $P9306, "1304282274.421", 232
    .const 'Sub' $P9307 = "359_1304282286.73" 
    copy $P9306, $P9307
    nqp_get_sc_object $P9308, "1304282274.421", 233
    .const 'Sub' $P9309 = "360_1304282286.73" 
    copy $P9308, $P9309
    nqp_get_sc_object $P9310, "1304282274.421", 234
    .const 'Sub' $P9311 = "362_1304282286.73" 
    copy $P9310, $P9311
    nqp_get_sc_object $P9312, "1304282274.421", 235
    .const 'Sub' $P9313 = "363_1304282286.73" 
    copy $P9312, $P9313
    nqp_get_sc_object $P9314, "1304282274.421", 236
    .const 'Sub' $P9315 = "365_1304282286.73" 
    copy $P9314, $P9315
    nqp_get_sc_object $P9316, "1304282274.421", 237
    .const 'Sub' $P9317 = "366_1304282286.73" 
    copy $P9316, $P9317
    nqp_get_sc_object $P9318, "1304282274.421", 238
    .const 'Sub' $P9319 = "368_1304282286.73" 
    copy $P9318, $P9319
    nqp_get_sc_object $P9320, "1304282274.421", 239
    .const 'Sub' $P9321 = "369_1304282286.73" 
    copy $P9320, $P9321
    nqp_get_sc_object $P9322, "1304282274.421", 240
    .const 'Sub' $P9323 = "371_1304282286.73" 
    copy $P9322, $P9323
    nqp_get_sc_object $P9324, "1304282274.421", 241
    .const 'Sub' $P9325 = "372_1304282286.73" 
    copy $P9324, $P9325
    nqp_get_sc_object $P9326, "1304282274.421", 242
    .const 'Sub' $P9327 = "374_1304282286.73" 
    copy $P9326, $P9327
    nqp_get_sc_object $P9328, "1304282274.421", 243
    .const 'Sub' $P9329 = "375_1304282286.73" 
    copy $P9328, $P9329
    nqp_get_sc_object $P9330, "1304282274.421", 244
    .const 'Sub' $P9331 = "377_1304282286.73" 
    copy $P9330, $P9331
    nqp_get_sc_object $P9332, "1304282274.421", 245
    .const 'Sub' $P9333 = "378_1304282286.73" 
    copy $P9332, $P9333
    nqp_get_sc_object $P9334, "1304282274.421", 246
    .const 'Sub' $P9335 = "380_1304282286.73" 
    copy $P9334, $P9335
    nqp_get_sc_object $P9336, "1304282274.421", 247
    .const 'Sub' $P9337 = "381_1304282286.73" 
    copy $P9336, $P9337
    nqp_get_sc_object $P9338, "1304282274.421", 248
    .const 'Sub' $P9339 = "383_1304282286.73" 
    copy $P9338, $P9339
    nqp_get_sc_object $P9340, "1304282274.421", 249
    .const 'Sub' $P9341 = "384_1304282286.73" 
    copy $P9340, $P9341
    nqp_get_sc_object $P9342, "1304282274.421", 250
    .const 'Sub' $P9343 = "386_1304282286.73" 
    copy $P9342, $P9343
    nqp_get_sc_object $P9344, "1304282274.421", 251
    .const 'Sub' $P9345 = "387_1304282286.73" 
    copy $P9344, $P9345
    nqp_get_sc_object $P9346, "1304282274.421", 252
    .const 'Sub' $P9347 = "389_1304282286.73" 
    copy $P9346, $P9347
    nqp_get_sc_object $P9348, "1304282274.421", 253
    .const 'Sub' $P9349 = "390_1304282286.73" 
    copy $P9348, $P9349
    nqp_get_sc_object $P9350, "1304282274.421", 254
    .const 'Sub' $P9351 = "392_1304282286.73" 
    copy $P9350, $P9351
    nqp_get_sc_object $P9352, "1304282274.421", 255
    .const 'Sub' $P9353 = "393_1304282286.73" 
    copy $P9352, $P9353
    nqp_get_sc_object $P9354, "1304282274.421", 256
    .const 'Sub' $P9355 = "395_1304282286.73" 
    copy $P9354, $P9355
    nqp_get_sc_object $P9356, "1304282274.421", 257
    .const 'Sub' $P9357 = "396_1304282286.73" 
    copy $P9356, $P9357
    nqp_get_sc_object $P9358, "1304282274.421", 258
    .const 'Sub' $P9359 = "398_1304282286.73" 
    copy $P9358, $P9359
    nqp_get_sc_object $P9360, "1304282274.421", 259
    .const 'Sub' $P9361 = "399_1304282286.73" 
    copy $P9360, $P9361
    nqp_get_sc_object $P9362, "1304282274.421", 260
    .const 'Sub' $P9363 = "401_1304282286.73" 
    copy $P9362, $P9363
    nqp_get_sc_object $P9364, "1304282274.421", 261
    .const 'Sub' $P9365 = "402_1304282286.73" 
    copy $P9364, $P9365
    nqp_get_sc_object $P9366, "1304282274.421", 262
    .const 'Sub' $P9367 = "404_1304282286.73" 
    copy $P9366, $P9367
    nqp_get_sc_object $P9368, "1304282274.421", 263
    .const 'Sub' $P9369 = "405_1304282286.73" 
    copy $P9368, $P9369
    nqp_get_sc_object $P9370, "1304282274.421", 264
    .const 'Sub' $P9371 = "407_1304282286.73" 
    copy $P9370, $P9371
    nqp_get_sc_object $P9372, "1304282274.421", 265
    .const 'Sub' $P9373 = "408_1304282286.73" 
    copy $P9372, $P9373
    nqp_get_sc_object $P9374, "1304282274.421", 266
    .const 'Sub' $P9375 = "410_1304282286.73" 
    copy $P9374, $P9375
    nqp_get_sc_object $P9376, "1304282274.421", 267
    .const 'Sub' $P9377 = "411_1304282286.73" 
    copy $P9376, $P9377
    nqp_get_sc_object $P9378, "1304282274.421", 268
    .const 'Sub' $P9379 = "413_1304282286.73" 
    copy $P9378, $P9379
    nqp_get_sc_object $P9380, "1304282274.421", 269
    .const 'Sub' $P9381 = "414_1304282286.73" 
    copy $P9380, $P9381
    nqp_get_sc_object $P9382, "1304282274.421", 270
    .const 'Sub' $P9383 = "416_1304282286.73" 
    copy $P9382, $P9383
    nqp_get_sc_object $P9384, "1304282274.421", 271
    .const 'Sub' $P9385 = "417_1304282286.73" 
    copy $P9384, $P9385
    nqp_get_sc_object $P9386, "1304282274.421", 272
    .const 'Sub' $P9387 = "419_1304282286.73" 
    copy $P9386, $P9387
    nqp_get_sc_object $P9388, "1304282274.421", 273
    .const 'Sub' $P9389 = "420_1304282286.73" 
    copy $P9388, $P9389
    nqp_get_sc_object $P9390, "1304282274.421", 274
    .const 'Sub' $P9391 = "422_1304282286.73" 
    copy $P9390, $P9391
    nqp_get_sc_object $P9392, "1304282274.421", 275
    .const 'Sub' $P9393 = "423_1304282286.73" 
    copy $P9392, $P9393
    nqp_get_sc_object $P9394, "1304282274.421", 276
    .const 'Sub' $P9395 = "425_1304282286.73" 
    copy $P9394, $P9395
    nqp_get_sc_object $P9396, "1304282274.421", 277
    .const 'Sub' $P9397 = "426_1304282286.73" 
    copy $P9396, $P9397
    nqp_get_sc_object $P9398, "1304282274.421", 278
    .const 'Sub' $P9399 = "428_1304282286.73" 
    copy $P9398, $P9399
    nqp_get_sc_object $P9400, "1304282274.421", 279
    .const 'Sub' $P9401 = "429_1304282286.73" 
    copy $P9400, $P9401
    nqp_get_sc_object $P9402, "1304282274.421", 280
    .const 'Sub' $P9403 = "431_1304282286.73" 
    copy $P9402, $P9403
    nqp_get_sc_object $P9404, "1304282274.421", 281
    .const 'Sub' $P9405 = "432_1304282286.73" 
    copy $P9404, $P9405
    nqp_get_sc_object $P9406, "1304282274.421", 282
    .const 'Sub' $P9407 = "434_1304282286.73" 
    copy $P9406, $P9407
    nqp_get_sc_object $P9408, "1304282274.421", 283
    .const 'Sub' $P9409 = "435_1304282286.73" 
    copy $P9408, $P9409
    nqp_get_sc_object $P9410, "1304282274.421", 284
    .const 'Sub' $P9411 = "437_1304282286.73" 
    copy $P9410, $P9411
    nqp_get_sc_object $P9412, "1304282274.421", 285
    .const 'Sub' $P9413 = "438_1304282286.73" 
    copy $P9412, $P9413
    nqp_get_sc_object $P9414, "1304282274.421", 286
    .const 'Sub' $P9415 = "440_1304282286.73" 
    copy $P9414, $P9415
    nqp_get_sc_object $P9416, "1304282274.421", 287
    .const 'Sub' $P9417 = "441_1304282286.73" 
    copy $P9416, $P9417
    nqp_get_sc_object $P9418, "1304282274.421", 288
    .const 'Sub' $P9419 = "443_1304282286.73" 
    copy $P9418, $P9419
    nqp_get_sc_object $P9420, "1304282274.421", 289
    .const 'Sub' $P9421 = "444_1304282286.73" 
    copy $P9420, $P9421
    nqp_get_sc_object $P9422, "1304282274.421", 290
    .const 'Sub' $P9423 = "446_1304282286.73" 
    copy $P9422, $P9423
    nqp_get_sc_object $P9424, "1304282274.421", 291
    .const 'Sub' $P9425 = "447_1304282286.73" 
    copy $P9424, $P9425
    nqp_get_sc_object $P9426, "1304282274.421", 292
    .const 'Sub' $P9427 = "449_1304282286.73" 
    copy $P9426, $P9427
    nqp_get_sc_object $P9428, "1304282274.421", 293
    .const 'Sub' $P9429 = "450_1304282286.73" 
    copy $P9428, $P9429
    nqp_get_sc_object $P9430, "1304282274.421", 294
    .const 'Sub' $P9431 = "452_1304282286.73" 
    copy $P9430, $P9431
    nqp_get_sc_object $P9432, "1304282274.421", 295
    .const 'Sub' $P9433 = "453_1304282286.73" 
    copy $P9432, $P9433
    nqp_get_sc_object $P9434, "1304282274.421", 296
    .const 'Sub' $P9435 = "455_1304282286.73" 
    copy $P9434, $P9435
    nqp_get_sc_object $P9436, "1304282274.421", 297
    .const 'Sub' $P9437 = "456_1304282286.73" 
    copy $P9436, $P9437
    nqp_get_sc_object $P9438, "1304282274.421", 298
    .const 'Sub' $P9439 = "458_1304282286.73" 
    copy $P9438, $P9439
    nqp_get_sc_object $P9440, "1304282274.421", 299
    .const 'Sub' $P9441 = "459_1304282286.73" 
    copy $P9440, $P9441
    nqp_get_sc_object $P9442, "1304282274.421", 300
    .const 'Sub' $P9443 = "461_1304282286.73" 
    copy $P9442, $P9443
    nqp_get_sc_object $P9444, "1304282274.421", 301
    .const 'Sub' $P9445 = "462_1304282286.73" 
    copy $P9444, $P9445
    nqp_get_sc_object $P9446, "1304282274.421", 302
    .const 'Sub' $P9447 = "464_1304282286.73" 
    copy $P9446, $P9447
    nqp_get_sc_object $P9448, "1304282274.421", 303
    .const 'Sub' $P9449 = "465_1304282286.73" 
    copy $P9448, $P9449
    nqp_get_sc_object $P9450, "1304282274.421", 304
    .const 'Sub' $P9451 = "467_1304282286.73" 
    copy $P9450, $P9451
    nqp_get_sc_object $P9452, "1304282274.421", 305
    .const 'Sub' $P9453 = "468_1304282286.73" 
    copy $P9452, $P9453
    nqp_get_sc_object $P9454, "1304282274.421", 306
    .const 'Sub' $P9455 = "470_1304282286.73" 
    copy $P9454, $P9455
    nqp_get_sc_object $P9456, "1304282274.421", 307
    .const 'Sub' $P9457 = "471_1304282286.73" 
    copy $P9456, $P9457
    nqp_get_sc_object $P9458, "1304282274.421", 308
    .const 'Sub' $P9459 = "473_1304282286.73" 
    copy $P9458, $P9459
    nqp_get_sc_object $P9460, "1304282274.421", 309
    .const 'Sub' $P9461 = "474_1304282286.73" 
    copy $P9460, $P9461
    nqp_get_sc_object $P9462, "1304282274.421", 310
    .const 'Sub' $P9463 = "476_1304282286.73" 
    copy $P9462, $P9463
    nqp_get_sc_object $P9464, "1304282274.421", 311
    .const 'Sub' $P9465 = "477_1304282286.73" 
    copy $P9464, $P9465
    nqp_get_sc_object $P9466, "1304282274.421", 312
    .const 'Sub' $P9467 = "479_1304282286.73" 
    copy $P9466, $P9467
    nqp_get_sc_object $P9468, "1304282274.421", 313
    .const 'Sub' $P9469 = "480_1304282286.73" 
    copy $P9468, $P9469
    nqp_get_sc_object $P9470, "1304282274.421", 314
    .const 'Sub' $P9471 = "482_1304282286.73" 
    copy $P9470, $P9471
    nqp_get_sc_object $P9472, "1304282274.421", 315
    .const 'Sub' $P9473 = "483_1304282286.73" 
    copy $P9472, $P9473
    nqp_get_sc_object $P9474, "1304282274.421", 316
    .const 'Sub' $P9475 = "485_1304282286.73" 
    copy $P9474, $P9475
    nqp_get_sc_object $P9476, "1304282274.421", 317
    .const 'Sub' $P9477 = "486_1304282286.73" 
    copy $P9476, $P9477
    nqp_get_sc_object $P9478, "1304282274.421", 318
    .const 'Sub' $P9479 = "488_1304282286.73" 
    copy $P9478, $P9479
    nqp_get_sc_object $P9480, "1304282274.421", 319
    .const 'Sub' $P9481 = "489_1304282286.73" 
    copy $P9480, $P9481
    nqp_get_sc_object $P9482, "1304282274.421", 320
    .const 'Sub' $P9483 = "491_1304282286.73" 
    copy $P9482, $P9483
    nqp_get_sc_object $P9484, "1304282274.421", 321
    .const 'Sub' $P9485 = "492_1304282286.73" 
    copy $P9484, $P9485
    nqp_get_sc_object $P9486, "1304282274.421", 322
    .const 'Sub' $P9487 = "494_1304282286.73" 
    copy $P9486, $P9487
    nqp_get_sc_object $P9488, "1304282274.421", 323
    .const 'Sub' $P9489 = "495_1304282286.73" 
    copy $P9488, $P9489
    nqp_get_sc_object $P9490, "1304282274.421", 324
    .const 'Sub' $P9491 = "497_1304282286.73" 
    copy $P9490, $P9491
    nqp_get_sc_object $P9492, "1304282274.421", 325
    .const 'Sub' $P9493 = "498_1304282286.73" 
    copy $P9492, $P9493
    nqp_get_sc_object $P9494, "1304282274.421", 326
    .const 'Sub' $P9495 = "500_1304282286.73" 
    copy $P9494, $P9495
    nqp_get_sc_object $P9496, "1304282274.421", 327
    .const 'Sub' $P9497 = "501_1304282286.73" 
    copy $P9496, $P9497
    nqp_get_sc_object $P9498, "1304282274.421", 328
    .const 'Sub' $P9499 = "503_1304282286.73" 
    copy $P9498, $P9499
    nqp_get_sc_object $P9500, "1304282274.421", 329
    .const 'Sub' $P9501 = "504_1304282286.73" 
    copy $P9500, $P9501
    nqp_get_sc_object $P9502, "1304282274.421", 330
    .const 'Sub' $P9503 = "506_1304282286.73" 
    copy $P9502, $P9503
    nqp_get_sc_object $P9504, "1304282274.421", 331
    .const 'Sub' $P9505 = "507_1304282286.73" 
    copy $P9504, $P9505
    nqp_get_sc_object $P9506, "1304282274.421", 332
    .const 'Sub' $P9507 = "509_1304282286.73" 
    copy $P9506, $P9507
    nqp_get_sc_object $P9508, "1304282274.421", 333
    .const 'Sub' $P9509 = "510_1304282286.73" 
    copy $P9508, $P9509
    nqp_get_sc_object $P9510, "1304282274.421", 334
    .const 'Sub' $P9511 = "512_1304282286.73" 
    copy $P9510, $P9511
    nqp_get_sc_object $P9512, "1304282274.421", 335
    .const 'Sub' $P9513 = "513_1304282286.73" 
    copy $P9512, $P9513
    nqp_get_sc_object $P9514, "1304282274.421", 336
    .const 'Sub' $P9515 = "515_1304282286.73" 
    copy $P9514, $P9515
    nqp_get_sc_object $P9516, "1304282274.421", 337
    .const 'Sub' $P9517 = "516_1304282286.73" 
    copy $P9516, $P9517
    nqp_get_sc_object $P9518, "1304282274.421", 338
    .const 'Sub' $P9519 = "518_1304282286.73" 
    copy $P9518, $P9519
    nqp_get_sc_object $P9520, "1304282274.421", 339
    .const 'Sub' $P9521 = "519_1304282286.73" 
    copy $P9520, $P9521
    nqp_get_sc_object $P9522, "1304282274.421", 340
    .const 'Sub' $P9523 = "521_1304282286.73" 
    copy $P9522, $P9523
    nqp_get_sc_object $P9524, "1304282274.421", 341
    .const 'Sub' $P9525 = "522_1304282286.73" 
    copy $P9524, $P9525
    nqp_get_sc_object $P9526, "1304282274.421", 342
    .const 'Sub' $P9527 = "524_1304282286.73" 
    copy $P9526, $P9527
    nqp_get_sc_object $P9528, "1304282274.421", 343
    .const 'Sub' $P9529 = "525_1304282286.73" 
    copy $P9528, $P9529
    nqp_get_sc_object $P9530, "1304282274.421", 344
    .const 'Sub' $P9531 = "527_1304282286.73" 
    copy $P9530, $P9531
    nqp_get_sc_object $P9532, "1304282274.421", 345
    .const 'Sub' $P9533 = "528_1304282286.73" 
    copy $P9532, $P9533
    nqp_get_sc_object $P9534, "1304282274.421", 346
    .const 'Sub' $P9535 = "530_1304282286.73" 
    copy $P9534, $P9535
    nqp_get_sc_object $P9536, "1304282274.421", 347
    .const 'Sub' $P9537 = "531_1304282286.73" 
    copy $P9536, $P9537
    nqp_get_sc_object $P9538, "1304282274.421", 348
    .const 'Sub' $P9539 = "533_1304282286.73" 
    copy $P9538, $P9539
    nqp_get_sc_object $P9540, "1304282274.421", 349
    .const 'Sub' $P9541 = "534_1304282286.73" 
    copy $P9540, $P9541
    nqp_get_sc_object $P9542, "1304282274.421", 350
    .const 'Sub' $P9543 = "537_1304282286.73" 
    copy $P9542, $P9543
    nqp_get_sc_object $P9544, "1304282274.421", 351
    .const 'Sub' $P9545 = "538_1304282286.73" 
    copy $P9544, $P9545
    nqp_get_sc_object $P9546, "1304282274.421", 352
    .const 'Sub' $P9547 = "540_1304282286.73" 
    copy $P9546, $P9547
    nqp_get_sc_object $P9548, "1304282274.421", 353
    .const 'Sub' $P9549 = "541_1304282286.73" 
    copy $P9548, $P9549
    nqp_get_sc_object $P9550, "1304282274.421", 354
    .const 'Sub' $P9551 = "543_1304282286.73" 
    copy $P9550, $P9551
    nqp_get_sc_object $P9552, "1304282274.421", 355
    .const 'Sub' $P9553 = "544_1304282286.73" 
    copy $P9552, $P9553
    nqp_get_sc_object $P9554, "1304282274.421", 356
    .const 'Sub' $P9555 = "546_1304282286.73" 
    copy $P9554, $P9555
    nqp_get_sc_object $P9556, "1304282274.421", 357
    .const 'Sub' $P9557 = "547_1304282286.73" 
    copy $P9556, $P9557
    nqp_get_sc_object $P9558, "1304282274.421", 358
    .const 'Sub' $P9559 = "549_1304282286.73" 
    copy $P9558, $P9559
    nqp_get_sc_object $P9560, "1304282274.421", 359
    .const 'Sub' $P9561 = "550_1304282286.73" 
    copy $P9560, $P9561
    .const 'Sub' $P9562 = "12_1304282286.73" 
    $P9563 = $P9562."get_lexinfo"()
    nqp_get_sc_object $P9564, "1304282274.421", 1
    $P9563."set_static_lexpad_value"("$?PACKAGE", $P9564)
    .const 'Sub' $P9565 = "12_1304282286.73" 
    $P9566 = $P9565."get_lexinfo"()
    $P9566."finish_static_lexpad"()
    .const 'Sub' $P9567 = "12_1304282286.73" 
    $P9568 = $P9567."get_lexinfo"()
    nqp_get_sc_object $P9569, "1304282274.421", 1
    $P9568."set_static_lexpad_value"("$?CLASS", $P9569)
    .const 'Sub' $P9570 = "12_1304282286.73" 
    $P9571 = $P9570."get_lexinfo"()
    $P9571."finish_static_lexpad"()
    nqp_get_sc_object $P9572, "1304282274.421", 361
    .const 'Sub' $P9573 = "553_1304282286.73" 
    copy $P9572, $P9573
    nqp_get_sc_object $P9574, "1304282274.421", 362
    .const 'Sub' $P9575 = "556_1304282286.73" 
    copy $P9574, $P9575
    nqp_get_sc_object $P9576, "1304282274.421", 363
    .const 'Sub' $P9577 = "557_1304282286.73" 
    copy $P9576, $P9577
    nqp_get_sc_object $P9578, "1304282274.421", 364
    .const 'Sub' $P9579 = "559_1304282286.73" 
    copy $P9578, $P9579
    nqp_get_sc_object $P9580, "1304282274.421", 365
    .const 'Sub' $P9581 = "560_1304282286.73" 
    copy $P9580, $P9581
    nqp_get_sc_object $P9582, "1304282274.421", 366
    .const 'Sub' $P9583 = "563_1304282286.73" 
    copy $P9582, $P9583
    nqp_get_sc_object $P9584, "1304282274.421", 367
    .const 'Sub' $P9585 = "564_1304282286.73" 
    copy $P9584, $P9585
    nqp_get_sc_object $P9586, "1304282274.421", 368
    .const 'Sub' $P9587 = "566_1304282286.73" 
    copy $P9586, $P9587
    nqp_get_sc_object $P9588, "1304282274.421", 369
    .const 'Sub' $P9589 = "567_1304282286.73" 
    copy $P9588, $P9589
    nqp_get_sc_object $P9590, "1304282274.421", 370
    .const 'Sub' $P9591 = "570_1304282286.73" 
    copy $P9590, $P9591
    nqp_get_sc_object $P9592, "1304282274.421", 371
    .const 'Sub' $P9593 = "571_1304282286.73" 
    copy $P9592, $P9593
    nqp_get_sc_object $P9594, "1304282274.421", 372
    .const 'Sub' $P9595 = "574_1304282286.73" 
    copy $P9594, $P9595
    nqp_get_sc_object $P9596, "1304282274.421", 373
    .const 'Sub' $P9597 = "575_1304282286.73" 
    copy $P9596, $P9597
    nqp_get_sc_object $P9598, "1304282274.421", 374
    .const 'Sub' $P9599 = "577_1304282286.73" 
    copy $P9598, $P9599
    nqp_get_sc_object $P9600, "1304282274.421", 375
    .const 'Sub' $P9601 = "578_1304282286.73" 
    copy $P9600, $P9601
    nqp_get_sc_object $P9602, "1304282274.421", 376
    .const 'Sub' $P9603 = "580_1304282286.73" 
    copy $P9602, $P9603
    .const 'Sub' $P9604 = "552_1304282286.73" 
    $P9605 = $P9604."get_lexinfo"()
    nqp_get_sc_object $P9606, "1304282274.421", 360
    $P9605."set_static_lexpad_value"("$?PACKAGE", $P9606)
    .const 'Sub' $P9607 = "552_1304282286.73" 
    $P9608 = $P9607."get_lexinfo"()
    $P9608."finish_static_lexpad"()
    .const 'Sub' $P9609 = "552_1304282286.73" 
    $P9610 = $P9609."get_lexinfo"()
    nqp_get_sc_object $P9611, "1304282274.421", 360
    $P9610."set_static_lexpad_value"("$?CLASS", $P9611)
    .const 'Sub' $P9612 = "552_1304282286.73" 
    $P9613 = $P9612."get_lexinfo"()
    $P9613."finish_static_lexpad"()
    nqp_get_sc_object $P9614, "1304282274.421", 378
    .const 'Sub' $P9615 = "609_1304282286.73" 
    copy $P9614, $P9615
    nqp_get_sc_object $P9616, "1304282274.421", 379
    .const 'Sub' $P9617 = "610_1304282286.73" 
    copy $P9616, $P9617
    nqp_get_sc_object $P9618, "1304282274.421", 380
    .const 'Sub' $P9619 = "611_1304282286.73" 
    copy $P9618, $P9619
    nqp_get_sc_object $P9620, "1304282274.421", 381
    .const 'Sub' $P9621 = "612_1304282286.73" 
    copy $P9620, $P9621
    nqp_get_sc_object $P9622, "1304282274.421", 382
    .const 'Sub' $P9623 = "614_1304282286.73" 
    copy $P9622, $P9623
    nqp_get_sc_object $P9624, "1304282274.421", 383
    .const 'Sub' $P9625 = "616_1304282286.73" 
    copy $P9624, $P9625
    nqp_get_sc_object $P9626, "1304282274.421", 384
    .const 'Sub' $P9627 = "617_1304282286.73" 
    copy $P9626, $P9627
    nqp_get_sc_object $P9628, "1304282274.421", 385
    .const 'Sub' $P9629 = "618_1304282286.73" 
    copy $P9628, $P9629
    nqp_get_sc_object $P9630, "1304282274.421", 386
    .const 'Sub' $P9631 = "619_1304282286.73" 
    copy $P9630, $P9631
    nqp_get_sc_object $P9632, "1304282274.421", 387
    .const 'Sub' $P9633 = "621_1304282286.73" 
    copy $P9632, $P9633
    nqp_get_sc_object $P9634, "1304282274.421", 388
    .const 'Sub' $P9635 = "622_1304282286.73" 
    copy $P9634, $P9635
    nqp_get_sc_object $P9636, "1304282274.421", 389
    .const 'Sub' $P9637 = "624_1304282286.73" 
    copy $P9636, $P9637
    nqp_get_sc_object $P9638, "1304282274.421", 390
    .const 'Sub' $P9639 = "625_1304282286.73" 
    copy $P9638, $P9639
    nqp_get_sc_object $P9640, "1304282274.421", 391
    .const 'Sub' $P9641 = "626_1304282286.73" 
    copy $P9640, $P9641
    nqp_get_sc_object $P9642, "1304282274.421", 392
    .const 'Sub' $P9643 = "627_1304282286.73" 
    copy $P9642, $P9643
    nqp_get_sc_object $P9644, "1304282274.421", 393
    .const 'Sub' $P9645 = "629_1304282286.73" 
    copy $P9644, $P9645
    nqp_get_sc_object $P9646, "1304282274.421", 394
    .const 'Sub' $P9647 = "630_1304282286.73" 
    copy $P9646, $P9647
    nqp_get_sc_object $P9648, "1304282274.421", 395
    .const 'Sub' $P9649 = "631_1304282286.73" 
    copy $P9648, $P9649
    nqp_get_sc_object $P9650, "1304282274.421", 396
    .const 'Sub' $P9651 = "632_1304282286.73" 
    copy $P9650, $P9651
    nqp_get_sc_object $P9652, "1304282274.421", 397
    .const 'Sub' $P9653 = "633_1304282286.73" 
    copy $P9652, $P9653
    nqp_get_sc_object $P9654, "1304282274.421", 398
    .const 'Sub' $P9655 = "634_1304282286.73" 
    copy $P9654, $P9655
    nqp_get_sc_object $P9656, "1304282274.421", 399
    .const 'Sub' $P9657 = "635_1304282286.73" 
    copy $P9656, $P9657
    nqp_get_sc_object $P9658, "1304282274.421", 400
    .const 'Sub' $P9659 = "636_1304282286.73" 
    copy $P9658, $P9659
    nqp_get_sc_object $P9660, "1304282274.421", 401
    .const 'Sub' $P9661 = "637_1304282286.73" 
    copy $P9660, $P9661
    nqp_get_sc_object $P9662, "1304282274.421", 402
    .const 'Sub' $P9663 = "638_1304282286.73" 
    copy $P9662, $P9663
    nqp_get_sc_object $P9664, "1304282274.421", 403
    .const 'Sub' $P9665 = "639_1304282286.73" 
    copy $P9664, $P9665
    nqp_get_sc_object $P9666, "1304282274.421", 404
    .const 'Sub' $P9667 = "640_1304282286.73" 
    copy $P9666, $P9667
    nqp_get_sc_object $P9668, "1304282274.421", 405
    .const 'Sub' $P9669 = "641_1304282286.73" 
    copy $P9668, $P9669
    nqp_get_sc_object $P9670, "1304282274.421", 406
    .const 'Sub' $P9671 = "642_1304282286.73" 
    copy $P9670, $P9671
    nqp_get_sc_object $P9672, "1304282274.421", 407
    .const 'Sub' $P9673 = "643_1304282286.73" 
    copy $P9672, $P9673
    nqp_get_sc_object $P9674, "1304282274.421", 408
    .const 'Sub' $P9675 = "644_1304282286.73" 
    copy $P9674, $P9675
    nqp_get_sc_object $P9676, "1304282274.421", 409
    .const 'Sub' $P9677 = "645_1304282286.73" 
    copy $P9676, $P9677
    nqp_get_sc_object $P9678, "1304282274.421", 410
    .const 'Sub' $P9679 = "646_1304282286.73" 
    copy $P9678, $P9679
    nqp_get_sc_object $P9680, "1304282274.421", 411
    .const 'Sub' $P9681 = "647_1304282286.73" 
    copy $P9680, $P9681
    nqp_get_sc_object $P9682, "1304282274.421", 412
    .const 'Sub' $P9683 = "648_1304282286.73" 
    copy $P9682, $P9683
    nqp_get_sc_object $P9684, "1304282274.421", 413
    .const 'Sub' $P9685 = "649_1304282286.73" 
    copy $P9684, $P9685
    nqp_get_sc_object $P9686, "1304282274.421", 414
    .const 'Sub' $P9687 = "650_1304282286.73" 
    copy $P9686, $P9687
    nqp_get_sc_object $P9688, "1304282274.421", 415
    .const 'Sub' $P9689 = "651_1304282286.73" 
    copy $P9688, $P9689
    nqp_get_sc_object $P9690, "1304282274.421", 416
    .const 'Sub' $P9691 = "652_1304282286.73" 
    copy $P9690, $P9691
    nqp_get_sc_object $P9692, "1304282274.421", 417
    .const 'Sub' $P9693 = "653_1304282286.73" 
    copy $P9692, $P9693
    nqp_get_sc_object $P9694, "1304282274.421", 418
    .const 'Sub' $P9695 = "659_1304282286.73" 
    copy $P9694, $P9695
    nqp_get_sc_object $P9696, "1304282274.421", 419
    .const 'Sub' $P9697 = "660_1304282286.73" 
    copy $P9696, $P9697
    nqp_get_sc_object $P9698, "1304282274.421", 420
    .const 'Sub' $P9699 = "661_1304282286.73" 
    copy $P9698, $P9699
    nqp_get_sc_object $P9700, "1304282274.421", 421
    .const 'Sub' $P9701 = "662_1304282286.73" 
    copy $P9700, $P9701
    nqp_get_sc_object $P9702, "1304282274.421", 422
    .const 'Sub' $P9703 = "663_1304282286.73" 
    copy $P9702, $P9703
    nqp_get_sc_object $P9704, "1304282274.421", 423
    .const 'Sub' $P9705 = "664_1304282286.73" 
    copy $P9704, $P9705
    nqp_get_sc_object $P9706, "1304282274.421", 424
    .const 'Sub' $P9707 = "665_1304282286.73" 
    copy $P9706, $P9707
    nqp_get_sc_object $P9708, "1304282274.421", 425
    .const 'Sub' $P9709 = "671_1304282286.73" 
    copy $P9708, $P9709
    nqp_get_sc_object $P9710, "1304282274.421", 426
    .const 'Sub' $P9711 = "672_1304282286.73" 
    copy $P9710, $P9711
    nqp_get_sc_object $P9712, "1304282274.421", 427
    .const 'Sub' $P9713 = "673_1304282286.73" 
    copy $P9712, $P9713
    nqp_get_sc_object $P9714, "1304282274.421", 428
    .const 'Sub' $P9715 = "674_1304282286.73" 
    copy $P9714, $P9715
    nqp_get_sc_object $P9716, "1304282274.421", 429
    .const 'Sub' $P9717 = "675_1304282286.73" 
    copy $P9716, $P9717
    nqp_get_sc_object $P9718, "1304282274.421", 430
    .const 'Sub' $P9719 = "676_1304282286.73" 
    copy $P9718, $P9719
    nqp_get_sc_object $P9720, "1304282274.421", 431
    .const 'Sub' $P9721 = "677_1304282286.73" 
    copy $P9720, $P9721
    nqp_get_sc_object $P9722, "1304282274.421", 432
    .const 'Sub' $P9723 = "678_1304282286.73" 
    copy $P9722, $P9723
    nqp_get_sc_object $P9724, "1304282274.421", 433
    .const 'Sub' $P9725 = "679_1304282286.73" 
    copy $P9724, $P9725
    nqp_get_sc_object $P9726, "1304282274.421", 434
    .const 'Sub' $P9727 = "681_1304282286.73" 
    copy $P9726, $P9727
    nqp_get_sc_object $P9728, "1304282274.421", 435
    .const 'Sub' $P9729 = "682_1304282286.73" 
    copy $P9728, $P9729
    nqp_get_sc_object $P9730, "1304282274.421", 436
    .const 'Sub' $P9731 = "683_1304282286.73" 
    copy $P9730, $P9731
    nqp_get_sc_object $P9732, "1304282274.421", 437
    .const 'Sub' $P9733 = "690_1304282286.73" 
    copy $P9732, $P9733
    nqp_get_sc_object $P9734, "1304282274.421", 438
    .const 'Sub' $P9735 = "693_1304282286.73" 
    copy $P9734, $P9735
    nqp_get_sc_object $P9736, "1304282274.421", 439
    .const 'Sub' $P9737 = "696_1304282286.73" 
    copy $P9736, $P9737
    nqp_get_sc_object $P9738, "1304282274.421", 440
    .const 'Sub' $P9739 = "697_1304282286.73" 
    copy $P9738, $P9739
    nqp_get_sc_object $P9740, "1304282274.421", 441
    .const 'Sub' $P9741 = "698_1304282286.73" 
    copy $P9740, $P9741
    nqp_get_sc_object $P9742, "1304282274.421", 442
    .const 'Sub' $P9743 = "699_1304282286.73" 
    copy $P9742, $P9743
    nqp_get_sc_object $P9744, "1304282274.421", 443
    .const 'Sub' $P9745 = "701_1304282286.73" 
    copy $P9744, $P9745
    nqp_get_sc_object $P9746, "1304282274.421", 444
    .const 'Sub' $P9747 = "702_1304282286.73" 
    copy $P9746, $P9747
    nqp_get_sc_object $P9748, "1304282274.421", 445
    .const 'Sub' $P9749 = "705_1304282286.73" 
    copy $P9748, $P9749
    nqp_get_sc_object $P9750, "1304282274.421", 446
    .const 'Sub' $P9751 = "710_1304282286.73" 
    copy $P9750, $P9751
    nqp_get_sc_object $P9752, "1304282274.421", 447
    .const 'Sub' $P9753 = "711_1304282286.73" 
    copy $P9752, $P9753
    nqp_get_sc_object $P9754, "1304282274.421", 448
    .const 'Sub' $P9755 = "712_1304282286.73" 
    copy $P9754, $P9755
    nqp_get_sc_object $P9756, "1304282274.421", 449
    .const 'Sub' $P9757 = "713_1304282286.73" 
    copy $P9756, $P9757
    nqp_get_sc_object $P9758, "1304282274.421", 450
    .const 'Sub' $P9759 = "715_1304282286.73" 
    copy $P9758, $P9759
    nqp_get_sc_object $P9760, "1304282274.421", 451
    .const 'Sub' $P9761 = "716_1304282286.73" 
    copy $P9760, $P9761
    nqp_get_sc_object $P9762, "1304282274.421", 452
    .const 'Sub' $P9763 = "717_1304282286.73" 
    copy $P9762, $P9763
    nqp_get_sc_object $P9764, "1304282274.421", 453
    .const 'Sub' $P9765 = "718_1304282286.73" 
    copy $P9764, $P9765
    nqp_get_sc_object $P9766, "1304282274.421", 454
    .const 'Sub' $P9767 = "721_1304282286.73" 
    copy $P9766, $P9767
    nqp_get_sc_object $P9768, "1304282274.421", 455
    .const 'Sub' $P9769 = "722_1304282286.73" 
    copy $P9768, $P9769
    nqp_get_sc_object $P9770, "1304282274.421", 456
    .const 'Sub' $P9771 = "723_1304282286.73" 
    copy $P9770, $P9771
    nqp_get_sc_object $P9772, "1304282274.421", 457
    .const 'Sub' $P9773 = "724_1304282286.73" 
    copy $P9772, $P9773
    nqp_get_sc_object $P9774, "1304282274.421", 458
    .const 'Sub' $P9775 = "725_1304282286.73" 
    copy $P9774, $P9775
    nqp_get_sc_object $P9776, "1304282274.421", 459
    .const 'Sub' $P9777 = "726_1304282286.73" 
    copy $P9776, $P9777
    nqp_get_sc_object $P9778, "1304282274.421", 460
    .const 'Sub' $P9779 = "727_1304282286.73" 
    copy $P9778, $P9779
    nqp_get_sc_object $P9780, "1304282274.421", 461
    .const 'Sub' $P9781 = "729_1304282286.73" 
    copy $P9780, $P9781
    nqp_get_sc_object $P9782, "1304282274.421", 462
    .const 'Sub' $P9783 = "730_1304282286.73" 
    copy $P9782, $P9783
    nqp_get_sc_object $P9784, "1304282274.421", 463
    .const 'Sub' $P9785 = "731_1304282286.73" 
    copy $P9784, $P9785
    nqp_get_sc_object $P9786, "1304282274.421", 464
    .const 'Sub' $P9787 = "732_1304282286.73" 
    copy $P9786, $P9787
    nqp_get_sc_object $P9788, "1304282274.421", 465
    .const 'Sub' $P9789 = "733_1304282286.73" 
    copy $P9788, $P9789
    nqp_get_sc_object $P9790, "1304282274.421", 466
    .const 'Sub' $P9791 = "734_1304282286.73" 
    copy $P9790, $P9791
    nqp_get_sc_object $P9792, "1304282274.421", 467
    .const 'Sub' $P9793 = "735_1304282286.73" 
    copy $P9792, $P9793
    nqp_get_sc_object $P9794, "1304282274.421", 468
    .const 'Sub' $P9795 = "736_1304282286.73" 
    copy $P9794, $P9795
    nqp_get_sc_object $P9796, "1304282274.421", 469
    .const 'Sub' $P9797 = "737_1304282286.73" 
    copy $P9796, $P9797
    nqp_get_sc_object $P9798, "1304282274.421", 470
    .const 'Sub' $P9799 = "738_1304282286.73" 
    copy $P9798, $P9799
    nqp_get_sc_object $P9800, "1304282274.421", 471
    .const 'Sub' $P9801 = "739_1304282286.73" 
    copy $P9800, $P9801
    nqp_get_sc_object $P9802, "1304282274.421", 472
    .const 'Sub' $P9803 = "740_1304282286.73" 
    copy $P9802, $P9803
    nqp_get_sc_object $P9804, "1304282274.421", 473
    .const 'Sub' $P9805 = "741_1304282286.73" 
    copy $P9804, $P9805
    nqp_get_sc_object $P9806, "1304282274.421", 474
    .const 'Sub' $P9807 = "742_1304282286.73" 
    copy $P9806, $P9807
    nqp_get_sc_object $P9808, "1304282274.421", 475
    .const 'Sub' $P9809 = "743_1304282286.73" 
    copy $P9808, $P9809
    nqp_get_sc_object $P9810, "1304282274.421", 476
    .const 'Sub' $P9811 = "744_1304282286.73" 
    copy $P9810, $P9811
    nqp_get_sc_object $P9812, "1304282274.421", 477
    .const 'Sub' $P9813 = "745_1304282286.73" 
    copy $P9812, $P9813
    nqp_get_sc_object $P9814, "1304282274.421", 478
    .const 'Sub' $P9815 = "746_1304282286.73" 
    copy $P9814, $P9815
    nqp_get_sc_object $P9816, "1304282274.421", 479
    .const 'Sub' $P9817 = "747_1304282286.73" 
    copy $P9816, $P9817
    nqp_get_sc_object $P9818, "1304282274.421", 480
    .const 'Sub' $P9819 = "748_1304282286.73" 
    copy $P9818, $P9819
    nqp_get_sc_object $P9820, "1304282274.421", 481
    .const 'Sub' $P9821 = "749_1304282286.73" 
    copy $P9820, $P9821
    nqp_get_sc_object $P9822, "1304282274.421", 482
    .const 'Sub' $P9823 = "750_1304282286.73" 
    copy $P9822, $P9823
    nqp_get_sc_object $P9824, "1304282274.421", 483
    .const 'Sub' $P9825 = "751_1304282286.73" 
    copy $P9824, $P9825
    nqp_get_sc_object $P9826, "1304282274.421", 484
    .const 'Sub' $P9827 = "752_1304282286.73" 
    copy $P9826, $P9827
    nqp_get_sc_object $P9828, "1304282274.421", 485
    .const 'Sub' $P9829 = "753_1304282286.73" 
    copy $P9828, $P9829
    nqp_get_sc_object $P9830, "1304282274.421", 486
    .const 'Sub' $P9831 = "754_1304282286.73" 
    copy $P9830, $P9831
    nqp_get_sc_object $P9832, "1304282274.421", 487
    .const 'Sub' $P9833 = "755_1304282286.73" 
    copy $P9832, $P9833
    .const 'Sub' $P9834 = "582_1304282286.73" 
    $P9835 = $P9834."get_lexinfo"()
    nqp_get_sc_object $P9836, "1304282274.421", 377
    $P9835."set_static_lexpad_value"("$?PACKAGE", $P9836)
    .const 'Sub' $P9837 = "582_1304282286.73" 
    $P9838 = $P9837."get_lexinfo"()
    $P9838."finish_static_lexpad"()
    .const 'Sub' $P9839 = "582_1304282286.73" 
    $P9840 = $P9839."get_lexinfo"()
    nqp_get_sc_object $P9841, "1304282274.421", 377
    $P9840."set_static_lexpad_value"("$?CLASS", $P9841)
    .const 'Sub' $P9842 = "582_1304282286.73" 
    $P9843 = $P9842."get_lexinfo"()
    $P9843."finish_static_lexpad"()
    nqp_get_sc_object $P9844, "1304282274.421", 489
    .const 'Sub' $P9845 = "759_1304282286.73" 
    copy $P9844, $P9845
    nqp_get_sc_object $P9846, "1304282274.421", 490
    .const 'Sub' $P9847 = "760_1304282286.73" 
    copy $P9846, $P9847
    nqp_get_sc_object $P9848, "1304282274.421", 491
    .const 'Sub' $P9849 = "761_1304282286.73" 
    copy $P9848, $P9849
    nqp_get_sc_object $P9850, "1304282274.421", 492
    .const 'Sub' $P9851 = "762_1304282286.73" 
    copy $P9850, $P9851
    nqp_get_sc_object $P9852, "1304282274.421", 493
    .const 'Sub' $P9853 = "763_1304282286.73" 
    copy $P9852, $P9853
    nqp_get_sc_object $P9854, "1304282274.421", 494
    .const 'Sub' $P9855 = "764_1304282286.73" 
    copy $P9854, $P9855
    nqp_get_sc_object $P9856, "1304282274.421", 495
    .const 'Sub' $P9857 = "765_1304282286.73" 
    copy $P9856, $P9857
    .const 'Sub' $P9858 = "758_1304282286.73" 
    $P9859 = $P9858."get_lexinfo"()
    nqp_get_sc_object $P9860, "1304282274.421", 488
    $P9859."set_static_lexpad_value"("$?PACKAGE", $P9860)
    .const 'Sub' $P9861 = "758_1304282286.73" 
    $P9862 = $P9861."get_lexinfo"()
    $P9862."finish_static_lexpad"()
    .const 'Sub' $P9863 = "758_1304282286.73" 
    $P9864 = $P9863."get_lexinfo"()
    nqp_get_sc_object $P9865, "1304282274.421", 488
    $P9864."set_static_lexpad_value"("$?CLASS", $P9865)
    .const 'Sub' $P9866 = "758_1304282286.73" 
    $P9867 = $P9866."get_lexinfo"()
    $P9867."finish_static_lexpad"()
    .const 'Sub' $P9868 = "767_1304282286.73" 
    $P9869 = $P9868."get_lexinfo"()
    nqp_get_sc_object $P9870, "1304282274.421", 496
    $P9869."set_static_lexpad_value"("$?PACKAGE", $P9870)
    .const 'Sub' $P9871 = "767_1304282286.73" 
    $P9872 = $P9871."get_lexinfo"()
    $P9872."finish_static_lexpad"()
    .const 'Sub' $P9873 = "767_1304282286.73" 
    $P9874 = $P9873."get_lexinfo"()
    nqp_get_sc_object $P9875, "1304282274.421", 496
    $P9874."set_static_lexpad_value"("$?CLASS", $P9875)
    .const 'Sub' $P9876 = "767_1304282286.73" 
    $P9877 = $P9876."get_lexinfo"()
    $P9877."finish_static_lexpad"()
    goto if_6747_end
  if_6747:
    nqp_dynop_setup 
    getinterp $P6750
    get_class $P6751, "LexPad"
    get_class $P6752, "NQPLexPad"
    $P6750."hll_map"($P6751, $P6752)
    nqp_create_sc $P6753, "1304282274.421"
    .local pmc cur_sc
    set cur_sc, $P6753
    nqp_get_sc_object $P6754, "__6MODEL_CORE__", 0
    $P6755 = $P6754."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6755, cur_sc
    nqp_set_sc_object "1304282274.421", 0, $P6755
    .const 'Sub' $P6756 = "10_1304282286.73" 
    $P6757 = $P6756."get_lexinfo"()
    nqp_get_sc_object $P6758, "1304282274.421", 0
    $P6757."set_static_lexpad_value"("GLOBALish", $P6758)
    .const 'Sub' $P6759 = "10_1304282286.73" 
    $P6760 = $P6759."get_lexinfo"()
    $P6760."finish_static_lexpad"()
    .const 'Sub' $P6761 = "10_1304282286.73" 
    $P6762 = $P6761."get_lexinfo"()
    nqp_get_sc_object $P6763, "1304282274.421", 0
    $P6762."set_static_lexpad_value"("$?PACKAGE", $P6763)
    .const 'Sub' $P6764 = "10_1304282286.73" 
    $P6765 = $P6764."get_lexinfo"()
    $P6765."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6766, "ModuleLoader"
    $P6767 = $P6766."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6767)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6768, "ModuleLoader"
    nqp_get_sc_object $P6769, "1304282274.421", 0
    $P6768."load_module"("Regex", $P6769)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6770, "ModuleLoader"
    nqp_get_sc_object $P6771, "1304282274.421", 0
    $P6770."load_module"("P6Regex", $P6771)
    nqp_get_sc_object $P6772, "1304282248.255", 41
    $P6773 = $P6772."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6773, cur_sc
    nqp_set_sc_object "1304282274.421", 1, $P6773
    nqp_get_sc_object $P6774, "1304282274.421", 1
    nqp_get_sc_object $P6775, "1304282274.421", 0
    nqp_get_package_through_who $P6776, $P6775, "NQP"
    get_who $P6777, $P6776
    set $P6777["Grammar"], $P6774
    nqp_get_sc_object $P6778, "1304282274.421", 1
    get_how $P6779, $P6778
    nqp_get_sc_object $P6780, "1304282274.421", 1
    .const 'Sub' $P6781 = "13_1304282286.73" 
    $P6779."add_method"($P6780, "TOP", $P6781)
    nqp_get_sc_object $P6782, "1304282274.421", 1
    get_how $P6783, $P6782
    nqp_get_sc_object $P6784, "1304282274.421", 1
    .const 'Sub' $P6785 = "14_1304282286.73" 
    $P6783."add_method"($P6784, "identifier", $P6785)
    nqp_get_sc_object $P6786, "1304282274.421", 1
    get_how $P6787, $P6786
    nqp_get_sc_object $P6788, "1304282274.421", 1
    .const 'Sub' $P6789 = "16_1304282286.73" 
    $P6787."add_method"($P6788, "!PREFIX__identifier", $P6789)
    nqp_get_sc_object $P6790, "1304282274.421", 1
    get_how $P6791, $P6790
    nqp_get_sc_object $P6792, "1304282274.421", 1
    .const 'Sub' $P6793 = "17_1304282286.73" 
    $P6791."add_method"($P6792, "name", $P6793)
    nqp_get_sc_object $P6794, "1304282274.421", 1
    get_how $P6795, $P6794
    nqp_get_sc_object $P6796, "1304282274.421", 1
    .const 'Sub' $P6797 = "19_1304282286.73" 
    $P6795."add_method"($P6796, "!PREFIX__name", $P6797)
    nqp_get_sc_object $P6798, "1304282274.421", 1
    get_how $P6799, $P6798
    nqp_get_sc_object $P6800, "1304282274.421", 1
    .const 'Sub' $P6801 = "20_1304282286.73" 
    $P6799."add_method"($P6800, "deflongname", $P6801)
    nqp_get_sc_object $P6802, "1304282274.421", 1
    get_how $P6803, $P6802
    nqp_get_sc_object $P6804, "1304282274.421", 1
    .const 'Sub' $P6805 = "22_1304282286.73" 
    $P6803."add_method"($P6804, "!PREFIX__deflongname", $P6805)
    nqp_get_sc_object $P6806, "1304282274.421", 1
    get_how $P6807, $P6806
    nqp_get_sc_object $P6808, "1304282274.421", 1
    .const 'Sub' $P6809 = "23_1304282286.73" 
    $P6807."add_method"($P6808, "ENDSTMT", $P6809)
    nqp_get_sc_object $P6810, "1304282274.421", 1
    get_how $P6811, $P6810
    nqp_get_sc_object $P6812, "1304282274.421", 1
    .const 'Sub' $P6813 = "25_1304282286.73" 
    $P6811."add_method"($P6812, "!PREFIX__ENDSTMT", $P6813)
    nqp_get_sc_object $P6814, "1304282274.421", 1
    get_how $P6815, $P6814
    nqp_get_sc_object $P6816, "1304282274.421", 1
    .const 'Sub' $P6817 = "26_1304282286.73" 
    $P6815."add_method"($P6816, "ws", $P6817)
    nqp_get_sc_object $P6818, "1304282274.421", 1
    get_how $P6819, $P6818
    nqp_get_sc_object $P6820, "1304282274.421", 1
    .const 'Sub' $P6821 = "28_1304282286.73" 
    $P6819."add_method"($P6820, "!PREFIX__ws", $P6821)
    nqp_get_sc_object $P6822, "1304282274.421", 1
    get_how $P6823, $P6822
    nqp_get_sc_object $P6824, "1304282274.421", 1
    .const 'Sub' $P6825 = "29_1304282286.73" 
    $P6823."add_method"($P6824, "unv", $P6825)
    nqp_get_sc_object $P6826, "1304282274.421", 1
    get_how $P6827, $P6826
    nqp_get_sc_object $P6828, "1304282274.421", 1
    .const 'Sub' $P6829 = "32_1304282286.73" 
    $P6827."add_method"($P6828, "!PREFIX__unv", $P6829)
    nqp_get_sc_object $P6830, "1304282274.421", 1
    get_how $P6831, $P6830
    nqp_get_sc_object $P6832, "1304282274.421", 1
    .const 'Sub' $P6833 = "33_1304282286.73" 
    $P6831."add_method"($P6832, "pod_comment", $P6833)
    nqp_get_sc_object $P6834, "1304282274.421", 1
    get_how $P6835, $P6834
    nqp_get_sc_object $P6836, "1304282274.421", 1
    .const 'Sub' $P6837 = "36_1304282286.73" 
    $P6835."add_method"($P6836, "!PREFIX__pod_comment", $P6837)
    nqp_get_sc_object $P6838, "1304282274.421", 1
    get_how $P6839, $P6838
    nqp_get_sc_object $P6840, "1304282274.421", 1
    .const 'Sub' $P6841 = "37_1304282286.73" 
    $P6839."add_method"($P6840, "comp_unit", $P6841)
    nqp_get_sc_object $P6842, "1304282274.421", 1
    get_how $P6843, $P6842
    nqp_get_sc_object $P6844, "1304282274.421", 1
    .const 'Sub' $P6845 = "39_1304282286.73" 
    $P6843."add_method"($P6844, "!PREFIX__comp_unit", $P6845)
    nqp_get_sc_object $P6846, "1304282274.421", 1
    get_how $P6847, $P6846
    nqp_get_sc_object $P6848, "1304282274.421", 1
    .const 'Sub' $P6849 = "40_1304282286.73" 
    $P6847."add_method"($P6848, "statementlist", $P6849)
    nqp_get_sc_object $P6850, "1304282274.421", 1
    get_how $P6851, $P6850
    nqp_get_sc_object $P6852, "1304282274.421", 1
    .const 'Sub' $P6853 = "42_1304282286.73" 
    $P6851."add_method"($P6852, "!PREFIX__statementlist", $P6853)
    nqp_get_sc_object $P6854, "1304282274.421", 1
    get_how $P6855, $P6854
    nqp_get_sc_object $P6856, "1304282274.421", 1
    .const 'Sub' $P6857 = "43_1304282286.73" 
    $P6855."add_method"($P6856, "statement", $P6857)
    nqp_get_sc_object $P6858, "1304282274.421", 1
    get_how $P6859, $P6858
    nqp_get_sc_object $P6860, "1304282274.421", 1
    .const 'Sub' $P6861 = "46_1304282286.73" 
    $P6859."add_method"($P6860, "!PREFIX__statement", $P6861)
    nqp_get_sc_object $P6862, "1304282274.421", 1
    get_how $P6863, $P6862
    nqp_get_sc_object $P6864, "1304282274.421", 1
    .const 'Sub' $P6865 = "47_1304282286.73" 
    $P6863."add_method"($P6864, "eat_terminator", $P6865)
    nqp_get_sc_object $P6866, "1304282274.421", 1
    get_how $P6867, $P6866
    nqp_get_sc_object $P6868, "1304282274.421", 1
    .const 'Sub' $P6869 = "49_1304282286.73" 
    $P6867."add_method"($P6868, "!PREFIX__eat_terminator", $P6869)
    nqp_get_sc_object $P6870, "1304282274.421", 1
    get_how $P6871, $P6870
    nqp_get_sc_object $P6872, "1304282274.421", 1
    .const 'Sub' $P6873 = "50_1304282286.73" 
    $P6871."add_method"($P6872, "xblock", $P6873)
    nqp_get_sc_object $P6874, "1304282274.421", 1
    get_how $P6875, $P6874
    nqp_get_sc_object $P6876, "1304282274.421", 1
    .const 'Sub' $P6877 = "52_1304282286.73" 
    $P6875."add_method"($P6876, "!PREFIX__xblock", $P6877)
    nqp_get_sc_object $P6878, "1304282274.421", 1
    get_how $P6879, $P6878
    nqp_get_sc_object $P6880, "1304282274.421", 1
    .const 'Sub' $P6881 = "53_1304282286.73" 
    $P6879."add_method"($P6880, "pblock", $P6881)
    nqp_get_sc_object $P6882, "1304282274.421", 1
    get_how $P6883, $P6882
    nqp_get_sc_object $P6884, "1304282274.421", 1
    .const 'Sub' $P6885 = "55_1304282286.73" 
    $P6883."add_method"($P6884, "!PREFIX__pblock", $P6885)
    nqp_get_sc_object $P6886, "1304282274.421", 1
    get_how $P6887, $P6886
    nqp_get_sc_object $P6888, "1304282274.421", 1
    .const 'Sub' $P6889 = "56_1304282286.73" 
    $P6887."add_method"($P6888, "lambda", $P6889)
    nqp_get_sc_object $P6890, "1304282274.421", 1
    get_how $P6891, $P6890
    nqp_get_sc_object $P6892, "1304282274.421", 1
    .const 'Sub' $P6893 = "58_1304282286.73" 
    $P6891."add_method"($P6892, "!PREFIX__lambda", $P6893)
    nqp_get_sc_object $P6894, "1304282274.421", 1
    get_how $P6895, $P6894
    nqp_get_sc_object $P6896, "1304282274.421", 1
    .const 'Sub' $P6897 = "59_1304282286.73" 
    $P6895."add_method"($P6896, "block", $P6897)
    nqp_get_sc_object $P6898, "1304282274.421", 1
    get_how $P6899, $P6898
    nqp_get_sc_object $P6900, "1304282274.421", 1
    .const 'Sub' $P6901 = "61_1304282286.73" 
    $P6899."add_method"($P6900, "!PREFIX__block", $P6901)
    nqp_get_sc_object $P6902, "1304282274.421", 1
    get_how $P6903, $P6902
    nqp_get_sc_object $P6904, "1304282274.421", 1
    .const 'Sub' $P6905 = "62_1304282286.73" 
    $P6903."add_method"($P6904, "blockoid", $P6905)
    nqp_get_sc_object $P6906, "1304282274.421", 1
    get_how $P6907, $P6906
    nqp_get_sc_object $P6908, "1304282274.421", 1
    .const 'Sub' $P6909 = "64_1304282286.73" 
    $P6907."add_method"($P6908, "!PREFIX__blockoid", $P6909)
    nqp_get_sc_object $P6910, "1304282274.421", 1
    get_how $P6911, $P6910
    nqp_get_sc_object $P6912, "1304282274.421", 1
    .const 'Sub' $P6913 = "65_1304282286.73" 
    $P6911."add_method"($P6912, "newpad", $P6913)
    nqp_get_sc_object $P6914, "1304282274.421", 1
    get_how $P6915, $P6914
    nqp_get_sc_object $P6916, "1304282274.421", 1
    .const 'Sub' $P6917 = "67_1304282286.73" 
    $P6915."add_method"($P6916, "!PREFIX__newpad", $P6917)
    nqp_get_sc_object $P6918, "1304282274.421", 1
    get_how $P6919, $P6918
    nqp_get_sc_object $P6920, "1304282274.421", 1
    .const 'Sub' $P6921 = "68_1304282286.73" 
    $P6919."add_method"($P6920, "outerctx", $P6921)
    nqp_get_sc_object $P6922, "1304282274.421", 1
    get_how $P6923, $P6922
    nqp_get_sc_object $P6924, "1304282274.421", 1
    .const 'Sub' $P6925 = "70_1304282286.73" 
    $P6923."add_method"($P6924, "!PREFIX__outerctx", $P6925)
    nqp_get_sc_object $P6926, "1304282274.421", 1
    get_how $P6927, $P6926
    nqp_get_sc_object $P6928, "1304282274.421", 1
    .const 'Sub' $P6929 = "71_1304282286.73" 
    $P6927."add_method"($P6928, "GLOBALish", $P6929)
    nqp_get_sc_object $P6930, "1304282274.421", 1
    get_how $P6931, $P6930
    nqp_get_sc_object $P6932, "1304282274.421", 1
    .const 'Sub' $P6933 = "73_1304282286.73" 
    $P6931."add_method"($P6932, "!PREFIX__GLOBALish", $P6933)
    nqp_get_sc_object $P6934, "1304282274.421", 1
    get_how $P6935, $P6934
    nqp_get_sc_object $P6936, "1304282274.421", 1
    .const 'Sub' $P6937 = "74_1304282286.73" 
    $P6935."add_method"($P6936, "finishpad", $P6937)
    nqp_get_sc_object $P6938, "1304282274.421", 1
    get_how $P6939, $P6938
    nqp_get_sc_object $P6940, "1304282274.421", 1
    .const 'Sub' $P6941 = "76_1304282286.73" 
    $P6939."add_method"($P6940, "!PREFIX__finishpad", $P6941)
    nqp_get_sc_object $P6942, "1304282274.421", 1
    get_how $P6943, $P6942
    nqp_get_sc_object $P6944, "1304282274.421", 1
    .const 'Sub' $P6945 = "77_1304282286.73" 
    $P6943."add_method"($P6944, "you_are_here", $P6945)
    nqp_get_sc_object $P6946, "1304282274.421", 1
    get_how $P6947, $P6946
    nqp_get_sc_object $P6948, "1304282274.421", 1
    .const 'Sub' $P6949 = "79_1304282286.73" 
    $P6947."add_method"($P6948, "!PREFIX__you_are_here", $P6949)
    nqp_get_sc_object $P6950, "1304282274.421", 1
    get_how $P6951, $P6950
    nqp_get_sc_object $P6952, "1304282274.421", 1
    .const 'Sub' $P6953 = "80_1304282286.73" 
    $P6951."add_method"($P6952, "terminator", $P6953)
    nqp_get_sc_object $P6954, "1304282274.421", 1
    get_how $P6955, $P6954
    nqp_get_sc_object $P6956, "1304282274.421", 1
    .const 'Sub' $P6957 = "81_1304282286.73" 
    $P6955."add_method"($P6956, "!PREFIX__terminator", $P6957)
    nqp_get_sc_object $P6958, "1304282274.421", 1
    get_how $P6959, $P6958
    nqp_get_sc_object $P6960, "1304282274.421", 1
    .const 'Sub' $P6961 = "82_1304282286.73" 
    $P6959."add_method"($P6960, "terminator:sym<;>", $P6961)
    nqp_get_sc_object $P6962, "1304282274.421", 1
    get_how $P6963, $P6962
    nqp_get_sc_object $P6964, "1304282274.421", 1
    .const 'Sub' $P6965 = "84_1304282286.73" 
    $P6963."add_method"($P6964, "!PREFIX__terminator:sym<;>", $P6965)
    nqp_get_sc_object $P6966, "1304282274.421", 1
    get_how $P6967, $P6966
    nqp_get_sc_object $P6968, "1304282274.421", 1
    .const 'Sub' $P6969 = "85_1304282286.73" 
    $P6967."add_method"($P6968, "terminator:sym<}>", $P6969)
    nqp_get_sc_object $P6970, "1304282274.421", 1
    get_how $P6971, $P6970
    nqp_get_sc_object $P6972, "1304282274.421", 1
    .const 'Sub' $P6973 = "87_1304282286.73" 
    $P6971."add_method"($P6972, "!PREFIX__terminator:sym<}>", $P6973)
    nqp_get_sc_object $P6974, "1304282274.421", 1
    get_how $P6975, $P6974
    nqp_get_sc_object $P6976, "1304282274.421", 1
    .const 'Sub' $P6977 = "88_1304282286.73" 
    $P6975."add_method"($P6976, "statement_control", $P6977)
    nqp_get_sc_object $P6978, "1304282274.421", 1
    get_how $P6979, $P6978
    nqp_get_sc_object $P6980, "1304282274.421", 1
    .const 'Sub' $P6981 = "89_1304282286.73" 
    $P6979."add_method"($P6980, "!PREFIX__statement_control", $P6981)
    nqp_get_sc_object $P6982, "1304282274.421", 1
    get_how $P6983, $P6982
    nqp_get_sc_object $P6984, "1304282274.421", 1
    .const 'Sub' $P6985 = "90_1304282286.73" 
    $P6983."add_method"($P6984, "statement_control:sym<use>", $P6985)
    nqp_get_sc_object $P6986, "1304282274.421", 1
    get_how $P6987, $P6986
    nqp_get_sc_object $P6988, "1304282274.421", 1
    .const 'Sub' $P6989 = "92_1304282286.73" 
    $P6987."add_method"($P6988, "!PREFIX__statement_control:sym<use>", $P6989)
    nqp_get_sc_object $P6990, "1304282274.421", 1
    get_how $P6991, $P6990
    nqp_get_sc_object $P6992, "1304282274.421", 1
    .const 'Sub' $P6993 = "93_1304282286.73" 
    $P6991."add_method"($P6992, "statement_control:sym<if>", $P6993)
    nqp_get_sc_object $P6994, "1304282274.421", 1
    get_how $P6995, $P6994
    nqp_get_sc_object $P6996, "1304282274.421", 1
    .const 'Sub' $P6997 = "95_1304282286.73" 
    $P6995."add_method"($P6996, "!PREFIX__statement_control:sym<if>", $P6997)
    nqp_get_sc_object $P6998, "1304282274.421", 1
    get_how $P6999, $P6998
    nqp_get_sc_object $P7000, "1304282274.421", 1
    .const 'Sub' $P7001 = "96_1304282286.73" 
    $P6999."add_method"($P7000, "statement_control:sym<unless>", $P7001)
    nqp_get_sc_object $P7002, "1304282274.421", 1
    get_how $P7003, $P7002
    nqp_get_sc_object $P7004, "1304282274.421", 1
    .const 'Sub' $P7005 = "99_1304282286.73" 
    $P7003."add_method"($P7004, "!PREFIX__statement_control:sym<unless>", $P7005)
    nqp_get_sc_object $P7006, "1304282274.421", 1
    get_how $P7007, $P7006
    nqp_get_sc_object $P7008, "1304282274.421", 1
    .const 'Sub' $P7009 = "100_1304282286.73" 
    $P7007."add_method"($P7008, "statement_control:sym<while>", $P7009)
    nqp_get_sc_object $P7010, "1304282274.421", 1
    get_how $P7011, $P7010
    nqp_get_sc_object $P7012, "1304282274.421", 1
    .const 'Sub' $P7013 = "102_1304282286.73" 
    $P7011."add_method"($P7012, "!PREFIX__statement_control:sym<while>", $P7013)
    nqp_get_sc_object $P7014, "1304282274.421", 1
    get_how $P7015, $P7014
    nqp_get_sc_object $P7016, "1304282274.421", 1
    .const 'Sub' $P7017 = "103_1304282286.73" 
    $P7015."add_method"($P7016, "statement_control:sym<repeat>", $P7017)
    nqp_get_sc_object $P7018, "1304282274.421", 1
    get_how $P7019, $P7018
    nqp_get_sc_object $P7020, "1304282274.421", 1
    .const 'Sub' $P7021 = "105_1304282286.73" 
    $P7019."add_method"($P7020, "!PREFIX__statement_control:sym<repeat>", $P7021)
    nqp_get_sc_object $P7022, "1304282274.421", 1
    get_how $P7023, $P7022
    nqp_get_sc_object $P7024, "1304282274.421", 1
    .const 'Sub' $P7025 = "106_1304282286.73" 
    $P7023."add_method"($P7024, "statement_control:sym<for>", $P7025)
    nqp_get_sc_object $P7026, "1304282274.421", 1
    get_how $P7027, $P7026
    nqp_get_sc_object $P7028, "1304282274.421", 1
    .const 'Sub' $P7029 = "108_1304282286.73" 
    $P7027."add_method"($P7028, "!PREFIX__statement_control:sym<for>", $P7029)
    nqp_get_sc_object $P7030, "1304282274.421", 1
    get_how $P7031, $P7030
    nqp_get_sc_object $P7032, "1304282274.421", 1
    .const 'Sub' $P7033 = "109_1304282286.73" 
    $P7031."add_method"($P7032, "statement_control:sym<CATCH>", $P7033)
    nqp_get_sc_object $P7034, "1304282274.421", 1
    get_how $P7035, $P7034
    nqp_get_sc_object $P7036, "1304282274.421", 1
    .const 'Sub' $P7037 = "111_1304282286.73" 
    $P7035."add_method"($P7036, "!PREFIX__statement_control:sym<CATCH>", $P7037)
    nqp_get_sc_object $P7038, "1304282274.421", 1
    get_how $P7039, $P7038
    nqp_get_sc_object $P7040, "1304282274.421", 1
    .const 'Sub' $P7041 = "112_1304282286.73" 
    $P7039."add_method"($P7040, "statement_control:sym<CONTROL>", $P7041)
    nqp_get_sc_object $P7042, "1304282274.421", 1
    get_how $P7043, $P7042
    nqp_get_sc_object $P7044, "1304282274.421", 1
    .const 'Sub' $P7045 = "114_1304282286.73" 
    $P7043."add_method"($P7044, "!PREFIX__statement_control:sym<CONTROL>", $P7045)
    nqp_get_sc_object $P7046, "1304282274.421", 1
    get_how $P7047, $P7046
    nqp_get_sc_object $P7048, "1304282274.421", 1
    .const 'Sub' $P7049 = "115_1304282286.73" 
    $P7047."add_method"($P7048, "statement_prefix", $P7049)
    nqp_get_sc_object $P7050, "1304282274.421", 1
    get_how $P7051, $P7050
    nqp_get_sc_object $P7052, "1304282274.421", 1
    .const 'Sub' $P7053 = "116_1304282286.73" 
    $P7051."add_method"($P7052, "!PREFIX__statement_prefix", $P7053)
    nqp_get_sc_object $P7054, "1304282274.421", 1
    get_how $P7055, $P7054
    nqp_get_sc_object $P7056, "1304282274.421", 1
    .const 'Sub' $P7057 = "117_1304282286.73" 
    $P7055."add_method"($P7056, "statement_prefix:sym<INIT>", $P7057)
    nqp_get_sc_object $P7058, "1304282274.421", 1
    get_how $P7059, $P7058
    nqp_get_sc_object $P7060, "1304282274.421", 1
    .const 'Sub' $P7061 = "119_1304282286.73" 
    $P7059."add_method"($P7060, "!PREFIX__statement_prefix:sym<INIT>", $P7061)
    nqp_get_sc_object $P7062, "1304282274.421", 1
    get_how $P7063, $P7062
    nqp_get_sc_object $P7064, "1304282274.421", 1
    .const 'Sub' $P7065 = "120_1304282286.73" 
    $P7063."add_method"($P7064, "statement_prefix:sym<try>", $P7065)
    nqp_get_sc_object $P7066, "1304282274.421", 1
    get_how $P7067, $P7066
    nqp_get_sc_object $P7068, "1304282274.421", 1
    .const 'Sub' $P7069 = "122_1304282286.73" 
    $P7067."add_method"($P7068, "!PREFIX__statement_prefix:sym<try>", $P7069)
    nqp_get_sc_object $P7070, "1304282274.421", 1
    get_how $P7071, $P7070
    nqp_get_sc_object $P7072, "1304282274.421", 1
    .const 'Sub' $P7073 = "123_1304282286.73" 
    $P7071."add_method"($P7072, "blorst", $P7073)
    nqp_get_sc_object $P7074, "1304282274.421", 1
    get_how $P7075, $P7074
    nqp_get_sc_object $P7076, "1304282274.421", 1
    .const 'Sub' $P7077 = "125_1304282286.73" 
    $P7075."add_method"($P7076, "!PREFIX__blorst", $P7077)
    nqp_get_sc_object $P7078, "1304282274.421", 1
    get_how $P7079, $P7078
    nqp_get_sc_object $P7080, "1304282274.421", 1
    .const 'Sub' $P7081 = "126_1304282286.73" 
    $P7079."add_method"($P7080, "statement_mod_cond", $P7081)
    nqp_get_sc_object $P7082, "1304282274.421", 1
    get_how $P7083, $P7082
    nqp_get_sc_object $P7084, "1304282274.421", 1
    .const 'Sub' $P7085 = "127_1304282286.73" 
    $P7083."add_method"($P7084, "!PREFIX__statement_mod_cond", $P7085)
    nqp_get_sc_object $P7086, "1304282274.421", 1
    get_how $P7087, $P7086
    nqp_get_sc_object $P7088, "1304282274.421", 1
    .const 'Sub' $P7089 = "128_1304282286.73" 
    $P7087."add_method"($P7088, "statement_mod_cond:sym<if>", $P7089)
    nqp_get_sc_object $P7090, "1304282274.421", 1
    get_how $P7091, $P7090
    nqp_get_sc_object $P7092, "1304282274.421", 1
    .const 'Sub' $P7093 = "130_1304282286.73" 
    $P7091."add_method"($P7092, "!PREFIX__statement_mod_cond:sym<if>", $P7093)
    nqp_get_sc_object $P7094, "1304282274.421", 1
    get_how $P7095, $P7094
    nqp_get_sc_object $P7096, "1304282274.421", 1
    .const 'Sub' $P7097 = "131_1304282286.73" 
    $P7095."add_method"($P7096, "statement_mod_cond:sym<unless>", $P7097)
    nqp_get_sc_object $P7098, "1304282274.421", 1
    get_how $P7099, $P7098
    nqp_get_sc_object $P7100, "1304282274.421", 1
    .const 'Sub' $P7101 = "133_1304282286.73" 
    $P7099."add_method"($P7100, "!PREFIX__statement_mod_cond:sym<unless>", $P7101)
    nqp_get_sc_object $P7102, "1304282274.421", 1
    get_how $P7103, $P7102
    nqp_get_sc_object $P7104, "1304282274.421", 1
    .const 'Sub' $P7105 = "134_1304282286.73" 
    $P7103."add_method"($P7104, "statement_mod_loop", $P7105)
    nqp_get_sc_object $P7106, "1304282274.421", 1
    get_how $P7107, $P7106
    nqp_get_sc_object $P7108, "1304282274.421", 1
    .const 'Sub' $P7109 = "135_1304282286.73" 
    $P7107."add_method"($P7108, "!PREFIX__statement_mod_loop", $P7109)
    nqp_get_sc_object $P7110, "1304282274.421", 1
    get_how $P7111, $P7110
    nqp_get_sc_object $P7112, "1304282274.421", 1
    .const 'Sub' $P7113 = "136_1304282286.73" 
    $P7111."add_method"($P7112, "statement_mod_loop:sym<while>", $P7113)
    nqp_get_sc_object $P7114, "1304282274.421", 1
    get_how $P7115, $P7114
    nqp_get_sc_object $P7116, "1304282274.421", 1
    .const 'Sub' $P7117 = "138_1304282286.73" 
    $P7115."add_method"($P7116, "!PREFIX__statement_mod_loop:sym<while>", $P7117)
    nqp_get_sc_object $P7118, "1304282274.421", 1
    get_how $P7119, $P7118
    nqp_get_sc_object $P7120, "1304282274.421", 1
    .const 'Sub' $P7121 = "139_1304282286.73" 
    $P7119."add_method"($P7120, "statement_mod_loop:sym<until>", $P7121)
    nqp_get_sc_object $P7122, "1304282274.421", 1
    get_how $P7123, $P7122
    nqp_get_sc_object $P7124, "1304282274.421", 1
    .const 'Sub' $P7125 = "141_1304282286.73" 
    $P7123."add_method"($P7124, "!PREFIX__statement_mod_loop:sym<until>", $P7125)
    nqp_get_sc_object $P7126, "1304282274.421", 1
    get_how $P7127, $P7126
    nqp_get_sc_object $P7128, "1304282274.421", 1
    .const 'Sub' $P7129 = "142_1304282286.73" 
    $P7127."add_method"($P7128, "statement_mod_loop:sym<for>", $P7129)
    nqp_get_sc_object $P7130, "1304282274.421", 1
    get_how $P7131, $P7130
    nqp_get_sc_object $P7132, "1304282274.421", 1
    .const 'Sub' $P7133 = "144_1304282286.73" 
    $P7131."add_method"($P7132, "!PREFIX__statement_mod_loop:sym<for>", $P7133)
    nqp_get_sc_object $P7134, "1304282274.421", 1
    get_how $P7135, $P7134
    nqp_get_sc_object $P7136, "1304282274.421", 1
    .const 'Sub' $P7137 = "145_1304282286.73" 
    $P7135."add_method"($P7136, "term:sym<fatarrow>", $P7137)
    nqp_get_sc_object $P7138, "1304282274.421", 1
    get_how $P7139, $P7138
    nqp_get_sc_object $P7140, "1304282274.421", 1
    .const 'Sub' $P7141 = "147_1304282286.73" 
    $P7139."add_method"($P7140, "!PREFIX__term:sym<fatarrow>", $P7141)
    nqp_get_sc_object $P7142, "1304282274.421", 1
    get_how $P7143, $P7142
    nqp_get_sc_object $P7144, "1304282274.421", 1
    .const 'Sub' $P7145 = "148_1304282286.73" 
    $P7143."add_method"($P7144, "term:sym<colonpair>", $P7145)
    nqp_get_sc_object $P7146, "1304282274.421", 1
    get_how $P7147, $P7146
    nqp_get_sc_object $P7148, "1304282274.421", 1
    .const 'Sub' $P7149 = "150_1304282286.73" 
    $P7147."add_method"($P7148, "!PREFIX__term:sym<colonpair>", $P7149)
    nqp_get_sc_object $P7150, "1304282274.421", 1
    get_how $P7151, $P7150
    nqp_get_sc_object $P7152, "1304282274.421", 1
    .const 'Sub' $P7153 = "151_1304282286.73" 
    $P7151."add_method"($P7152, "term:sym<variable>", $P7153)
    nqp_get_sc_object $P7154, "1304282274.421", 1
    get_how $P7155, $P7154
    nqp_get_sc_object $P7156, "1304282274.421", 1
    .const 'Sub' $P7157 = "153_1304282286.73" 
    $P7155."add_method"($P7156, "!PREFIX__term:sym<variable>", $P7157)
    nqp_get_sc_object $P7158, "1304282274.421", 1
    get_how $P7159, $P7158
    nqp_get_sc_object $P7160, "1304282274.421", 1
    .const 'Sub' $P7161 = "154_1304282286.73" 
    $P7159."add_method"($P7160, "term:sym<package_declarator>", $P7161)
    nqp_get_sc_object $P7162, "1304282274.421", 1
    get_how $P7163, $P7162
    nqp_get_sc_object $P7164, "1304282274.421", 1
    .const 'Sub' $P7165 = "156_1304282286.73" 
    $P7163."add_method"($P7164, "!PREFIX__term:sym<package_declarator>", $P7165)
    nqp_get_sc_object $P7166, "1304282274.421", 1
    get_how $P7167, $P7166
    nqp_get_sc_object $P7168, "1304282274.421", 1
    .const 'Sub' $P7169 = "157_1304282286.73" 
    $P7167."add_method"($P7168, "term:sym<scope_declarator>", $P7169)
    nqp_get_sc_object $P7170, "1304282274.421", 1
    get_how $P7171, $P7170
    nqp_get_sc_object $P7172, "1304282274.421", 1
    .const 'Sub' $P7173 = "159_1304282286.73" 
    $P7171."add_method"($P7172, "!PREFIX__term:sym<scope_declarator>", $P7173)
    nqp_get_sc_object $P7174, "1304282274.421", 1
    get_how $P7175, $P7174
    nqp_get_sc_object $P7176, "1304282274.421", 1
    .const 'Sub' $P7177 = "160_1304282286.73" 
    $P7175."add_method"($P7176, "term:sym<routine_declarator>", $P7177)
    nqp_get_sc_object $P7178, "1304282274.421", 1
    get_how $P7179, $P7178
    nqp_get_sc_object $P7180, "1304282274.421", 1
    .const 'Sub' $P7181 = "162_1304282286.73" 
    $P7179."add_method"($P7180, "!PREFIX__term:sym<routine_declarator>", $P7181)
    nqp_get_sc_object $P7182, "1304282274.421", 1
    get_how $P7183, $P7182
    nqp_get_sc_object $P7184, "1304282274.421", 1
    .const 'Sub' $P7185 = "163_1304282286.73" 
    $P7183."add_method"($P7184, "term:sym<multi_declarator>", $P7185)
    nqp_get_sc_object $P7186, "1304282274.421", 1
    get_how $P7187, $P7186
    nqp_get_sc_object $P7188, "1304282274.421", 1
    .const 'Sub' $P7189 = "167_1304282286.73" 
    $P7187."add_method"($P7188, "!PREFIX__term:sym<multi_declarator>", $P7189)
    nqp_get_sc_object $P7190, "1304282274.421", 1
    get_how $P7191, $P7190
    nqp_get_sc_object $P7192, "1304282274.421", 1
    .const 'Sub' $P7193 = "168_1304282286.73" 
    $P7191."add_method"($P7192, "term:sym<regex_declarator>", $P7193)
    nqp_get_sc_object $P7194, "1304282274.421", 1
    get_how $P7195, $P7194
    nqp_get_sc_object $P7196, "1304282274.421", 1
    .const 'Sub' $P7197 = "170_1304282286.73" 
    $P7195."add_method"($P7196, "!PREFIX__term:sym<regex_declarator>", $P7197)
    nqp_get_sc_object $P7198, "1304282274.421", 1
    get_how $P7199, $P7198
    nqp_get_sc_object $P7200, "1304282274.421", 1
    .const 'Sub' $P7201 = "171_1304282286.73" 
    $P7199."add_method"($P7200, "term:sym<statement_prefix>", $P7201)
    nqp_get_sc_object $P7202, "1304282274.421", 1
    get_how $P7203, $P7202
    nqp_get_sc_object $P7204, "1304282274.421", 1
    .const 'Sub' $P7205 = "173_1304282286.73" 
    $P7203."add_method"($P7204, "!PREFIX__term:sym<statement_prefix>", $P7205)
    nqp_get_sc_object $P7206, "1304282274.421", 1
    get_how $P7207, $P7206
    nqp_get_sc_object $P7208, "1304282274.421", 1
    .const 'Sub' $P7209 = "174_1304282286.73" 
    $P7207."add_method"($P7208, "term:sym<lambda>", $P7209)
    nqp_get_sc_object $P7210, "1304282274.421", 1
    get_how $P7211, $P7210
    nqp_get_sc_object $P7212, "1304282274.421", 1
    .const 'Sub' $P7213 = "176_1304282286.73" 
    $P7211."add_method"($P7212, "!PREFIX__term:sym<lambda>", $P7213)
    nqp_get_sc_object $P7214, "1304282274.421", 1
    get_how $P7215, $P7214
    nqp_get_sc_object $P7216, "1304282274.421", 1
    .const 'Sub' $P7217 = "177_1304282286.73" 
    $P7215."add_method"($P7216, "fatarrow", $P7217)
    nqp_get_sc_object $P7218, "1304282274.421", 1
    get_how $P7219, $P7218
    nqp_get_sc_object $P7220, "1304282274.421", 1
    .const 'Sub' $P7221 = "179_1304282286.73" 
    $P7219."add_method"($P7220, "!PREFIX__fatarrow", $P7221)
    nqp_get_sc_object $P7222, "1304282274.421", 1
    get_how $P7223, $P7222
    nqp_get_sc_object $P7224, "1304282274.421", 1
    .const 'Sub' $P7225 = "180_1304282286.73" 
    $P7223."add_method"($P7224, "colonpair", $P7225)
    nqp_get_sc_object $P7226, "1304282274.421", 1
    get_how $P7227, $P7226
    nqp_get_sc_object $P7228, "1304282274.421", 1
    .const 'Sub' $P7229 = "182_1304282286.73" 
    $P7227."add_method"($P7228, "!PREFIX__colonpair", $P7229)
    nqp_get_sc_object $P7230, "1304282274.421", 1
    get_how $P7231, $P7230
    nqp_get_sc_object $P7232, "1304282274.421", 1
    .const 'Sub' $P7233 = "183_1304282286.73" 
    $P7231."add_method"($P7232, "variable", $P7233)
    nqp_get_sc_object $P7234, "1304282274.421", 1
    get_how $P7235, $P7234
    nqp_get_sc_object $P7236, "1304282274.421", 1
    .const 'Sub' $P7237 = "185_1304282286.73" 
    $P7235."add_method"($P7236, "!PREFIX__variable", $P7237)
    nqp_get_sc_object $P7238, "1304282274.421", 1
    get_how $P7239, $P7238
    nqp_get_sc_object $P7240, "1304282274.421", 1
    .const 'Sub' $P7241 = "186_1304282286.73" 
    $P7239."add_method"($P7240, "sigil", $P7241)
    nqp_get_sc_object $P7242, "1304282274.421", 1
    get_how $P7243, $P7242
    nqp_get_sc_object $P7244, "1304282274.421", 1
    .const 'Sub' $P7245 = "188_1304282286.73" 
    $P7243."add_method"($P7244, "!PREFIX__sigil", $P7245)
    nqp_get_sc_object $P7246, "1304282274.421", 1
    get_how $P7247, $P7246
    nqp_get_sc_object $P7248, "1304282274.421", 1
    .const 'Sub' $P7249 = "189_1304282286.73" 
    $P7247."add_method"($P7248, "twigil", $P7249)
    nqp_get_sc_object $P7250, "1304282274.421", 1
    get_how $P7251, $P7250
    nqp_get_sc_object $P7252, "1304282274.421", 1
    .const 'Sub' $P7253 = "191_1304282286.73" 
    $P7251."add_method"($P7252, "!PREFIX__twigil", $P7253)
    nqp_get_sc_object $P7254, "1304282274.421", 1
    get_how $P7255, $P7254
    nqp_get_sc_object $P7256, "1304282274.421", 1
    .const 'Sub' $P7257 = "192_1304282286.73" 
    $P7255."add_method"($P7256, "package_declarator", $P7257)
    nqp_get_sc_object $P7258, "1304282274.421", 1
    get_how $P7259, $P7258
    nqp_get_sc_object $P7260, "1304282274.421", 1
    .const 'Sub' $P7261 = "193_1304282286.73" 
    $P7259."add_method"($P7260, "!PREFIX__package_declarator", $P7261)
    nqp_get_sc_object $P7262, "1304282274.421", 1
    get_how $P7263, $P7262
    nqp_get_sc_object $P7264, "1304282274.421", 1
    .const 'Sub' $P7265 = "194_1304282286.73" 
    $P7263."add_method"($P7264, "package_declarator:sym<module>", $P7265)
    nqp_get_sc_object $P7266, "1304282274.421", 1
    get_how $P7267, $P7266
    nqp_get_sc_object $P7268, "1304282274.421", 1
    .const 'Sub' $P7269 = "196_1304282286.73" 
    $P7267."add_method"($P7268, "!PREFIX__package_declarator:sym<module>", $P7269)
    nqp_get_sc_object $P7270, "1304282274.421", 1
    get_how $P7271, $P7270
    nqp_get_sc_object $P7272, "1304282274.421", 1
    .const 'Sub' $P7273 = "197_1304282286.73" 
    $P7271."add_method"($P7272, "package_declarator:sym<knowhow>", $P7273)
    nqp_get_sc_object $P7274, "1304282274.421", 1
    get_how $P7275, $P7274
    nqp_get_sc_object $P7276, "1304282274.421", 1
    .const 'Sub' $P7277 = "199_1304282286.73" 
    $P7275."add_method"($P7276, "!PREFIX__package_declarator:sym<knowhow>", $P7277)
    nqp_get_sc_object $P7278, "1304282274.421", 1
    get_how $P7279, $P7278
    nqp_get_sc_object $P7280, "1304282274.421", 1
    .const 'Sub' $P7281 = "200_1304282286.73" 
    $P7279."add_method"($P7280, "package_declarator:sym<class>", $P7281)
    nqp_get_sc_object $P7282, "1304282274.421", 1
    get_how $P7283, $P7282
    nqp_get_sc_object $P7284, "1304282274.421", 1
    .const 'Sub' $P7285 = "202_1304282286.73" 
    $P7283."add_method"($P7284, "!PREFIX__package_declarator:sym<class>", $P7285)
    nqp_get_sc_object $P7286, "1304282274.421", 1
    get_how $P7287, $P7286
    nqp_get_sc_object $P7288, "1304282274.421", 1
    .const 'Sub' $P7289 = "203_1304282286.73" 
    $P7287."add_method"($P7288, "package_declarator:sym<grammar>", $P7289)
    nqp_get_sc_object $P7290, "1304282274.421", 1
    get_how $P7291, $P7290
    nqp_get_sc_object $P7292, "1304282274.421", 1
    .const 'Sub' $P7293 = "205_1304282286.73" 
    $P7291."add_method"($P7292, "!PREFIX__package_declarator:sym<grammar>", $P7293)
    nqp_get_sc_object $P7294, "1304282274.421", 1
    get_how $P7295, $P7294
    nqp_get_sc_object $P7296, "1304282274.421", 1
    .const 'Sub' $P7297 = "206_1304282286.73" 
    $P7295."add_method"($P7296, "package_declarator:sym<role>", $P7297)
    nqp_get_sc_object $P7298, "1304282274.421", 1
    get_how $P7299, $P7298
    nqp_get_sc_object $P7300, "1304282274.421", 1
    .const 'Sub' $P7301 = "208_1304282286.73" 
    $P7299."add_method"($P7300, "!PREFIX__package_declarator:sym<role>", $P7301)
    nqp_get_sc_object $P7302, "1304282274.421", 1
    get_how $P7303, $P7302
    nqp_get_sc_object $P7304, "1304282274.421", 1
    .const 'Sub' $P7305 = "209_1304282286.73" 
    $P7303."add_method"($P7304, "package_declarator:sym<native>", $P7305)
    nqp_get_sc_object $P7306, "1304282274.421", 1
    get_how $P7307, $P7306
    nqp_get_sc_object $P7308, "1304282274.421", 1
    .const 'Sub' $P7309 = "211_1304282286.73" 
    $P7307."add_method"($P7308, "!PREFIX__package_declarator:sym<native>", $P7309)
    nqp_get_sc_object $P7310, "1304282274.421", 1
    get_how $P7311, $P7310
    nqp_get_sc_object $P7312, "1304282274.421", 1
    .const 'Sub' $P7313 = "212_1304282286.73" 
    $P7311."add_method"($P7312, "package_def", $P7313)
    nqp_get_sc_object $P7314, "1304282274.421", 1
    get_how $P7315, $P7314
    nqp_get_sc_object $P7316, "1304282274.421", 1
    .const 'Sub' $P7317 = "215_1304282286.73" 
    $P7315."add_method"($P7316, "!PREFIX__package_def", $P7317)
    nqp_get_sc_object $P7318, "1304282274.421", 1
    get_how $P7319, $P7318
    nqp_get_sc_object $P7320, "1304282274.421", 1
    .const 'Sub' $P7321 = "216_1304282286.73" 
    $P7319."add_method"($P7320, "scope_declarator", $P7321)
    nqp_get_sc_object $P7322, "1304282274.421", 1
    get_how $P7323, $P7322
    nqp_get_sc_object $P7324, "1304282274.421", 1
    .const 'Sub' $P7325 = "217_1304282286.73" 
    $P7323."add_method"($P7324, "!PREFIX__scope_declarator", $P7325)
    nqp_get_sc_object $P7326, "1304282274.421", 1
    get_how $P7327, $P7326
    nqp_get_sc_object $P7328, "1304282274.421", 1
    .const 'Sub' $P7329 = "218_1304282286.73" 
    $P7327."add_method"($P7328, "scope_declarator:sym<my>", $P7329)
    nqp_get_sc_object $P7330, "1304282274.421", 1
    get_how $P7331, $P7330
    nqp_get_sc_object $P7332, "1304282274.421", 1
    .const 'Sub' $P7333 = "220_1304282286.73" 
    $P7331."add_method"($P7332, "!PREFIX__scope_declarator:sym<my>", $P7333)
    nqp_get_sc_object $P7334, "1304282274.421", 1
    get_how $P7335, $P7334
    nqp_get_sc_object $P7336, "1304282274.421", 1
    .const 'Sub' $P7337 = "221_1304282286.73" 
    $P7335."add_method"($P7336, "scope_declarator:sym<our>", $P7337)
    nqp_get_sc_object $P7338, "1304282274.421", 1
    get_how $P7339, $P7338
    nqp_get_sc_object $P7340, "1304282274.421", 1
    .const 'Sub' $P7341 = "223_1304282286.73" 
    $P7339."add_method"($P7340, "!PREFIX__scope_declarator:sym<our>", $P7341)
    nqp_get_sc_object $P7342, "1304282274.421", 1
    get_how $P7343, $P7342
    nqp_get_sc_object $P7344, "1304282274.421", 1
    .const 'Sub' $P7345 = "224_1304282286.73" 
    $P7343."add_method"($P7344, "scope_declarator:sym<has>", $P7345)
    nqp_get_sc_object $P7346, "1304282274.421", 1
    get_how $P7347, $P7346
    nqp_get_sc_object $P7348, "1304282274.421", 1
    .const 'Sub' $P7349 = "226_1304282286.73" 
    $P7347."add_method"($P7348, "!PREFIX__scope_declarator:sym<has>", $P7349)
    nqp_get_sc_object $P7350, "1304282274.421", 1
    get_how $P7351, $P7350
    nqp_get_sc_object $P7352, "1304282274.421", 1
    .const 'Sub' $P7353 = "227_1304282286.73" 
    $P7351."add_method"($P7352, "scoped", $P7353)
    nqp_get_sc_object $P7354, "1304282274.421", 1
    get_how $P7355, $P7354
    nqp_get_sc_object $P7356, "1304282274.421", 1
    .const 'Sub' $P7357 = "229_1304282286.73" 
    $P7355."add_method"($P7356, "!PREFIX__scoped", $P7357)
    nqp_get_sc_object $P7358, "1304282274.421", 1
    get_how $P7359, $P7358
    nqp_get_sc_object $P7360, "1304282274.421", 1
    .const 'Sub' $P7361 = "230_1304282286.73" 
    $P7359."add_method"($P7360, "typename", $P7361)
    nqp_get_sc_object $P7362, "1304282274.421", 1
    get_how $P7363, $P7362
    nqp_get_sc_object $P7364, "1304282274.421", 1
    .const 'Sub' $P7365 = "233_1304282286.73" 
    $P7363."add_method"($P7364, "!PREFIX__typename", $P7365)
    nqp_get_sc_object $P7366, "1304282274.421", 1
    get_how $P7367, $P7366
    nqp_get_sc_object $P7368, "1304282274.421", 1
    .const 'Sub' $P7369 = "234_1304282286.73" 
    $P7367."add_method"($P7368, "declarator", $P7369)
    nqp_get_sc_object $P7370, "1304282274.421", 1
    get_how $P7371, $P7370
    nqp_get_sc_object $P7372, "1304282274.421", 1
    .const 'Sub' $P7373 = "236_1304282286.73" 
    $P7371."add_method"($P7372, "!PREFIX__declarator", $P7373)
    nqp_get_sc_object $P7374, "1304282274.421", 1
    get_how $P7375, $P7374
    nqp_get_sc_object $P7376, "1304282274.421", 1
    .const 'Sub' $P7377 = "237_1304282286.73" 
    $P7375."add_method"($P7376, "variable_declarator", $P7377)
    nqp_get_sc_object $P7378, "1304282274.421", 1
    get_how $P7379, $P7378
    nqp_get_sc_object $P7380, "1304282274.421", 1
    .const 'Sub' $P7381 = "240_1304282286.73" 
    $P7379."add_method"($P7380, "!PREFIX__variable_declarator", $P7381)
    nqp_get_sc_object $P7382, "1304282274.421", 1
    get_how $P7383, $P7382
    nqp_get_sc_object $P7384, "1304282274.421", 1
    .const 'Sub' $P7385 = "241_1304282286.73" 
    $P7383."add_method"($P7384, "routine_declarator", $P7385)
    nqp_get_sc_object $P7386, "1304282274.421", 1
    get_how $P7387, $P7386
    nqp_get_sc_object $P7388, "1304282274.421", 1
    .const 'Sub' $P7389 = "242_1304282286.73" 
    $P7387."add_method"($P7388, "!PREFIX__routine_declarator", $P7389)
    nqp_get_sc_object $P7390, "1304282274.421", 1
    get_how $P7391, $P7390
    nqp_get_sc_object $P7392, "1304282274.421", 1
    .const 'Sub' $P7393 = "243_1304282286.73" 
    $P7391."add_method"($P7392, "routine_declarator:sym<sub>", $P7393)
    nqp_get_sc_object $P7394, "1304282274.421", 1
    get_how $P7395, $P7394
    nqp_get_sc_object $P7396, "1304282274.421", 1
    .const 'Sub' $P7397 = "245_1304282286.73" 
    $P7395."add_method"($P7396, "!PREFIX__routine_declarator:sym<sub>", $P7397)
    nqp_get_sc_object $P7398, "1304282274.421", 1
    get_how $P7399, $P7398
    nqp_get_sc_object $P7400, "1304282274.421", 1
    .const 'Sub' $P7401 = "246_1304282286.73" 
    $P7399."add_method"($P7400, "routine_declarator:sym<method>", $P7401)
    nqp_get_sc_object $P7402, "1304282274.421", 1
    get_how $P7403, $P7402
    nqp_get_sc_object $P7404, "1304282274.421", 1
    .const 'Sub' $P7405 = "248_1304282286.73" 
    $P7403."add_method"($P7404, "!PREFIX__routine_declarator:sym<method>", $P7405)
    nqp_get_sc_object $P7406, "1304282274.421", 1
    get_how $P7407, $P7406
    nqp_get_sc_object $P7408, "1304282274.421", 1
    .const 'Sub' $P7409 = "249_1304282286.73" 
    $P7407."add_method"($P7408, "routine_def", $P7409)
    nqp_get_sc_object $P7410, "1304282274.421", 1
    get_how $P7411, $P7410
    nqp_get_sc_object $P7412, "1304282274.421", 1
    .const 'Sub' $P7413 = "251_1304282286.73" 
    $P7411."add_method"($P7412, "!PREFIX__routine_def", $P7413)
    nqp_get_sc_object $P7414, "1304282274.421", 1
    get_how $P7415, $P7414
    nqp_get_sc_object $P7416, "1304282274.421", 1
    .const 'Sub' $P7417 = "252_1304282286.73" 
    $P7415."add_method"($P7416, "method_def", $P7417)
    nqp_get_sc_object $P7418, "1304282274.421", 1
    get_how $P7419, $P7418
    nqp_get_sc_object $P7420, "1304282274.421", 1
    .const 'Sub' $P7421 = "255_1304282286.73" 
    $P7419."add_method"($P7420, "!PREFIX__method_def", $P7421)
    nqp_get_sc_object $P7422, "1304282274.421", 1
    get_how $P7423, $P7422
    nqp_get_sc_object $P7424, "1304282274.421", 1
    .const 'Sub' $P7425 = "256_1304282286.73" 
    $P7423."add_method"($P7424, "onlystar", $P7425)
    nqp_get_sc_object $P7426, "1304282274.421", 1
    get_how $P7427, $P7426
    nqp_get_sc_object $P7428, "1304282274.421", 1
    .const 'Sub' $P7429 = "259_1304282286.73" 
    $P7427."add_method"($P7428, "!PREFIX__onlystar", $P7429)
    nqp_get_sc_object $P7430, "1304282274.421", 1
    get_how $P7431, $P7430
    nqp_get_sc_object $P7432, "1304282274.421", 1
    .const 'Sub' $P7433 = "260_1304282286.73" 
    $P7431."add_method"($P7432, "multi_declarator", $P7433)
    nqp_get_sc_object $P7434, "1304282274.421", 1
    get_how $P7435, $P7434
    nqp_get_sc_object $P7436, "1304282274.421", 1
    .const 'Sub' $P7437 = "261_1304282286.73" 
    $P7435."add_method"($P7436, "!PREFIX__multi_declarator", $P7437)
    nqp_get_sc_object $P7438, "1304282274.421", 1
    get_how $P7439, $P7438
    nqp_get_sc_object $P7440, "1304282274.421", 1
    .const 'Sub' $P7441 = "262_1304282286.73" 
    $P7439."add_method"($P7440, "multi_declarator:sym<multi>", $P7441)
    nqp_get_sc_object $P7442, "1304282274.421", 1
    get_how $P7443, $P7442
    nqp_get_sc_object $P7444, "1304282274.421", 1
    .const 'Sub' $P7445 = "264_1304282286.73" 
    $P7443."add_method"($P7444, "!PREFIX__multi_declarator:sym<multi>", $P7445)
    nqp_get_sc_object $P7446, "1304282274.421", 1
    get_how $P7447, $P7446
    nqp_get_sc_object $P7448, "1304282274.421", 1
    .const 'Sub' $P7449 = "265_1304282286.73" 
    $P7447."add_method"($P7448, "multi_declarator:sym<proto>", $P7449)
    nqp_get_sc_object $P7450, "1304282274.421", 1
    get_how $P7451, $P7450
    nqp_get_sc_object $P7452, "1304282274.421", 1
    .const 'Sub' $P7453 = "267_1304282286.73" 
    $P7451."add_method"($P7452, "!PREFIX__multi_declarator:sym<proto>", $P7453)
    nqp_get_sc_object $P7454, "1304282274.421", 1
    get_how $P7455, $P7454
    nqp_get_sc_object $P7456, "1304282274.421", 1
    .const 'Sub' $P7457 = "268_1304282286.73" 
    $P7455."add_method"($P7456, "multi_declarator:sym<null>", $P7457)
    nqp_get_sc_object $P7458, "1304282274.421", 1
    get_how $P7459, $P7458
    nqp_get_sc_object $P7460, "1304282274.421", 1
    .const 'Sub' $P7461 = "270_1304282286.73" 
    $P7459."add_method"($P7460, "!PREFIX__multi_declarator:sym<null>", $P7461)
    nqp_get_sc_object $P7462, "1304282274.421", 1
    get_how $P7463, $P7462
    nqp_get_sc_object $P7464, "1304282274.421", 1
    .const 'Sub' $P7465 = "271_1304282286.73" 
    $P7463."add_method"($P7464, "signature", $P7465)
    nqp_get_sc_object $P7466, "1304282274.421", 1
    get_how $P7467, $P7466
    nqp_get_sc_object $P7468, "1304282274.421", 1
    .const 'Sub' $P7469 = "274_1304282286.73" 
    $P7467."add_method"($P7468, "!PREFIX__signature", $P7469)
    nqp_get_sc_object $P7470, "1304282274.421", 1
    get_how $P7471, $P7470
    nqp_get_sc_object $P7472, "1304282274.421", 1
    .const 'Sub' $P7473 = "275_1304282286.73" 
    $P7471."add_method"($P7472, "parameter", $P7473)
    nqp_get_sc_object $P7474, "1304282274.421", 1
    get_how $P7475, $P7474
    nqp_get_sc_object $P7476, "1304282274.421", 1
    .const 'Sub' $P7477 = "277_1304282286.73" 
    $P7475."add_method"($P7476, "!PREFIX__parameter", $P7477)
    nqp_get_sc_object $P7478, "1304282274.421", 1
    get_how $P7479, $P7478
    nqp_get_sc_object $P7480, "1304282274.421", 1
    .const 'Sub' $P7481 = "278_1304282286.73" 
    $P7479."add_method"($P7480, "param_var", $P7481)
    nqp_get_sc_object $P7482, "1304282274.421", 1
    get_how $P7483, $P7482
    nqp_get_sc_object $P7484, "1304282274.421", 1
    .const 'Sub' $P7485 = "280_1304282286.73" 
    $P7483."add_method"($P7484, "!PREFIX__param_var", $P7485)
    nqp_get_sc_object $P7486, "1304282274.421", 1
    get_how $P7487, $P7486
    nqp_get_sc_object $P7488, "1304282274.421", 1
    .const 'Sub' $P7489 = "281_1304282286.73" 
    $P7487."add_method"($P7488, "named_param", $P7489)
    nqp_get_sc_object $P7490, "1304282274.421", 1
    get_how $P7491, $P7490
    nqp_get_sc_object $P7492, "1304282274.421", 1
    .const 'Sub' $P7493 = "283_1304282286.73" 
    $P7491."add_method"($P7492, "!PREFIX__named_param", $P7493)
    nqp_get_sc_object $P7494, "1304282274.421", 1
    get_how $P7495, $P7494
    nqp_get_sc_object $P7496, "1304282274.421", 1
    .const 'Sub' $P7497 = "284_1304282286.73" 
    $P7495."add_method"($P7496, "default_value", $P7497)
    nqp_get_sc_object $P7498, "1304282274.421", 1
    get_how $P7499, $P7498
    nqp_get_sc_object $P7500, "1304282274.421", 1
    .const 'Sub' $P7501 = "286_1304282286.73" 
    $P7499."add_method"($P7500, "!PREFIX__default_value", $P7501)
    nqp_get_sc_object $P7502, "1304282274.421", 1
    get_how $P7503, $P7502
    nqp_get_sc_object $P7504, "1304282274.421", 1
    .const 'Sub' $P7505 = "287_1304282286.73" 
    $P7503."add_method"($P7504, "trait", $P7505)
    nqp_get_sc_object $P7506, "1304282274.421", 1
    get_how $P7507, $P7506
    nqp_get_sc_object $P7508, "1304282274.421", 1
    .const 'Sub' $P7509 = "289_1304282286.73" 
    $P7507."add_method"($P7508, "!PREFIX__trait", $P7509)
    nqp_get_sc_object $P7510, "1304282274.421", 1
    get_how $P7511, $P7510
    nqp_get_sc_object $P7512, "1304282274.421", 1
    .const 'Sub' $P7513 = "290_1304282286.73" 
    $P7511."add_method"($P7512, "trait_mod", $P7513)
    nqp_get_sc_object $P7514, "1304282274.421", 1
    get_how $P7515, $P7514
    nqp_get_sc_object $P7516, "1304282274.421", 1
    .const 'Sub' $P7517 = "291_1304282286.73" 
    $P7515."add_method"($P7516, "!PREFIX__trait_mod", $P7517)
    nqp_get_sc_object $P7518, "1304282274.421", 1
    get_how $P7519, $P7518
    nqp_get_sc_object $P7520, "1304282274.421", 1
    .const 'Sub' $P7521 = "292_1304282286.73" 
    $P7519."add_method"($P7520, "trait_mod:sym<is>", $P7521)
    nqp_get_sc_object $P7522, "1304282274.421", 1
    get_how $P7523, $P7522
    nqp_get_sc_object $P7524, "1304282274.421", 1
    .const 'Sub' $P7525 = "294_1304282286.73" 
    $P7523."add_method"($P7524, "!PREFIX__trait_mod:sym<is>", $P7525)
    nqp_get_sc_object $P7526, "1304282274.421", 1
    get_how $P7527, $P7526
    nqp_get_sc_object $P7528, "1304282274.421", 1
    .const 'Sub' $P7529 = "295_1304282286.73" 
    $P7527."add_method"($P7528, "regex_declarator", $P7529)
    nqp_get_sc_object $P7530, "1304282274.421", 1
    get_how $P7531, $P7530
    nqp_get_sc_object $P7532, "1304282274.421", 1
    .const 'Sub' $P7533 = "297_1304282286.73" 
    $P7531."add_method"($P7532, "!PREFIX__regex_declarator", $P7533)
    nqp_get_sc_object $P7534, "1304282274.421", 1
    get_how $P7535, $P7534
    nqp_get_sc_object $P7536, "1304282274.421", 1
    .const 'Sub' $P7537 = "298_1304282286.73" 
    $P7535."add_method"($P7536, "dotty", $P7537)
    nqp_get_sc_object $P7538, "1304282274.421", 1
    get_how $P7539, $P7538
    nqp_get_sc_object $P7540, "1304282274.421", 1
    .const 'Sub' $P7541 = "300_1304282286.73" 
    $P7539."add_method"($P7540, "!PREFIX__dotty", $P7541)
    nqp_get_sc_object $P7542, "1304282274.421", 1
    get_how $P7543, $P7542
    nqp_get_sc_object $P7544, "1304282274.421", 1
    .const 'Sub' $P7545 = "301_1304282286.73" 
    $P7543."add_method"($P7544, "term", $P7545)
    nqp_get_sc_object $P7546, "1304282274.421", 1
    get_how $P7547, $P7546
    nqp_get_sc_object $P7548, "1304282274.421", 1
    .const 'Sub' $P7549 = "302_1304282286.73" 
    $P7547."add_method"($P7548, "!PREFIX__term", $P7549)
    nqp_get_sc_object $P7550, "1304282274.421", 1
    get_how $P7551, $P7550
    nqp_get_sc_object $P7552, "1304282274.421", 1
    .const 'Sub' $P7553 = "303_1304282286.73" 
    $P7551."add_method"($P7552, "term:sym<self>", $P7553)
    nqp_get_sc_object $P7554, "1304282274.421", 1
    get_how $P7555, $P7554
    nqp_get_sc_object $P7556, "1304282274.421", 1
    .const 'Sub' $P7557 = "305_1304282286.73" 
    $P7555."add_method"($P7556, "!PREFIX__term:sym<self>", $P7557)
    nqp_get_sc_object $P7558, "1304282274.421", 1
    get_how $P7559, $P7558
    nqp_get_sc_object $P7560, "1304282274.421", 1
    .const 'Sub' $P7561 = "306_1304282286.73" 
    $P7559."add_method"($P7560, "term:sym<identifier>", $P7561)
    nqp_get_sc_object $P7562, "1304282274.421", 1
    get_how $P7563, $P7562
    nqp_get_sc_object $P7564, "1304282274.421", 1
    .const 'Sub' $P7565 = "308_1304282286.73" 
    $P7563."add_method"($P7564, "!PREFIX__term:sym<identifier>", $P7565)
    nqp_get_sc_object $P7566, "1304282274.421", 1
    get_how $P7567, $P7566
    nqp_get_sc_object $P7568, "1304282274.421", 1
    .const 'Sub' $P7569 = "309_1304282286.73" 
    $P7567."add_method"($P7568, "term:sym<name>", $P7569)
    nqp_get_sc_object $P7570, "1304282274.421", 1
    get_how $P7571, $P7570
    nqp_get_sc_object $P7572, "1304282274.421", 1
    .const 'Sub' $P7573 = "311_1304282286.73" 
    $P7571."add_method"($P7572, "!PREFIX__term:sym<name>", $P7573)
    nqp_get_sc_object $P7574, "1304282274.421", 1
    get_how $P7575, $P7574
    nqp_get_sc_object $P7576, "1304282274.421", 1
    .const 'Sub' $P7577 = "312_1304282286.73" 
    $P7575."add_method"($P7576, "term:sym<pir::op>", $P7577)
    nqp_get_sc_object $P7578, "1304282274.421", 1
    get_how $P7579, $P7578
    nqp_get_sc_object $P7580, "1304282274.421", 1
    .const 'Sub' $P7581 = "314_1304282286.73" 
    $P7579."add_method"($P7580, "!PREFIX__term:sym<pir::op>", $P7581)
    nqp_get_sc_object $P7582, "1304282274.421", 1
    get_how $P7583, $P7582
    nqp_get_sc_object $P7584, "1304282274.421", 1
    .const 'Sub' $P7585 = "315_1304282286.73" 
    $P7583."add_method"($P7584, "term:sym<onlystar>", $P7585)
    nqp_get_sc_object $P7586, "1304282274.421", 1
    get_how $P7587, $P7586
    nqp_get_sc_object $P7588, "1304282274.421", 1
    .const 'Sub' $P7589 = "318_1304282286.73" 
    $P7587."add_method"($P7588, "!PREFIX__term:sym<onlystar>", $P7589)
    nqp_get_sc_object $P7590, "1304282274.421", 1
    get_how $P7591, $P7590
    nqp_get_sc_object $P7592, "1304282274.421", 1
    .const 'Sub' $P7593 = "319_1304282286.73" 
    $P7591."add_method"($P7592, "args", $P7593)
    nqp_get_sc_object $P7594, "1304282274.421", 1
    get_how $P7595, $P7594
    nqp_get_sc_object $P7596, "1304282274.421", 1
    .const 'Sub' $P7597 = "321_1304282286.73" 
    $P7595."add_method"($P7596, "!PREFIX__args", $P7597)
    nqp_get_sc_object $P7598, "1304282274.421", 1
    get_how $P7599, $P7598
    nqp_get_sc_object $P7600, "1304282274.421", 1
    .const 'Sub' $P7601 = "322_1304282286.73" 
    $P7599."add_method"($P7600, "arglist", $P7601)
    nqp_get_sc_object $P7602, "1304282274.421", 1
    get_how $P7603, $P7602
    nqp_get_sc_object $P7604, "1304282274.421", 1
    .const 'Sub' $P7605 = "324_1304282286.73" 
    $P7603."add_method"($P7604, "!PREFIX__arglist", $P7605)
    nqp_get_sc_object $P7606, "1304282274.421", 1
    get_how $P7607, $P7606
    nqp_get_sc_object $P7608, "1304282274.421", 1
    .const 'Sub' $P7609 = "325_1304282286.73" 
    $P7607."add_method"($P7608, "term:sym<value>", $P7609)
    nqp_get_sc_object $P7610, "1304282274.421", 1
    get_how $P7611, $P7610
    nqp_get_sc_object $P7612, "1304282274.421", 1
    .const 'Sub' $P7613 = "327_1304282286.73" 
    $P7611."add_method"($P7612, "!PREFIX__term:sym<value>", $P7613)
    nqp_get_sc_object $P7614, "1304282274.421", 1
    get_how $P7615, $P7614
    nqp_get_sc_object $P7616, "1304282274.421", 1
    .const 'Sub' $P7617 = "328_1304282286.73" 
    $P7615."add_method"($P7616, "value", $P7617)
    nqp_get_sc_object $P7618, "1304282274.421", 1
    get_how $P7619, $P7618
    nqp_get_sc_object $P7620, "1304282274.421", 1
    .const 'Sub' $P7621 = "330_1304282286.73" 
    $P7619."add_method"($P7620, "!PREFIX__value", $P7621)
    nqp_get_sc_object $P7622, "1304282274.421", 1
    get_how $P7623, $P7622
    nqp_get_sc_object $P7624, "1304282274.421", 1
    .const 'Sub' $P7625 = "331_1304282286.73" 
    $P7623."add_method"($P7624, "number", $P7625)
    nqp_get_sc_object $P7626, "1304282274.421", 1
    get_how $P7627, $P7626
    nqp_get_sc_object $P7628, "1304282274.421", 1
    .const 'Sub' $P7629 = "333_1304282286.73" 
    $P7627."add_method"($P7628, "!PREFIX__number", $P7629)
    nqp_get_sc_object $P7630, "1304282274.421", 1
    get_how $P7631, $P7630
    nqp_get_sc_object $P7632, "1304282274.421", 1
    .const 'Sub' $P7633 = "334_1304282286.73" 
    $P7631."add_method"($P7632, "quote", $P7633)
    nqp_get_sc_object $P7634, "1304282274.421", 1
    get_how $P7635, $P7634
    nqp_get_sc_object $P7636, "1304282274.421", 1
    .const 'Sub' $P7637 = "335_1304282286.73" 
    $P7635."add_method"($P7636, "!PREFIX__quote", $P7637)
    nqp_get_sc_object $P7638, "1304282274.421", 1
    get_how $P7639, $P7638
    nqp_get_sc_object $P7640, "1304282274.421", 1
    .const 'Sub' $P7641 = "336_1304282286.73" 
    $P7639."add_method"($P7640, "quote:sym<apos>", $P7641)
    nqp_get_sc_object $P7642, "1304282274.421", 1
    get_how $P7643, $P7642
    nqp_get_sc_object $P7644, "1304282274.421", 1
    .const 'Sub' $P7645 = "338_1304282286.73" 
    $P7643."add_method"($P7644, "!PREFIX__quote:sym<apos>", $P7645)
    nqp_get_sc_object $P7646, "1304282274.421", 1
    get_how $P7647, $P7646
    nqp_get_sc_object $P7648, "1304282274.421", 1
    .const 'Sub' $P7649 = "339_1304282286.73" 
    $P7647."add_method"($P7648, "quote:sym<dblq>", $P7649)
    nqp_get_sc_object $P7650, "1304282274.421", 1
    get_how $P7651, $P7650
    nqp_get_sc_object $P7652, "1304282274.421", 1
    .const 'Sub' $P7653 = "341_1304282286.73" 
    $P7651."add_method"($P7652, "!PREFIX__quote:sym<dblq>", $P7653)
    nqp_get_sc_object $P7654, "1304282274.421", 1
    get_how $P7655, $P7654
    nqp_get_sc_object $P7656, "1304282274.421", 1
    .const 'Sub' $P7657 = "342_1304282286.73" 
    $P7655."add_method"($P7656, "quote:sym<q>", $P7657)
    nqp_get_sc_object $P7658, "1304282274.421", 1
    get_how $P7659, $P7658
    nqp_get_sc_object $P7660, "1304282274.421", 1
    .const 'Sub' $P7661 = "344_1304282286.73" 
    $P7659."add_method"($P7660, "!PREFIX__quote:sym<q>", $P7661)
    nqp_get_sc_object $P7662, "1304282274.421", 1
    get_how $P7663, $P7662
    nqp_get_sc_object $P7664, "1304282274.421", 1
    .const 'Sub' $P7665 = "345_1304282286.73" 
    $P7663."add_method"($P7664, "quote:sym<qq>", $P7665)
    nqp_get_sc_object $P7666, "1304282274.421", 1
    get_how $P7667, $P7666
    nqp_get_sc_object $P7668, "1304282274.421", 1
    .const 'Sub' $P7669 = "347_1304282286.73" 
    $P7667."add_method"($P7668, "!PREFIX__quote:sym<qq>", $P7669)
    nqp_get_sc_object $P7670, "1304282274.421", 1
    get_how $P7671, $P7670
    nqp_get_sc_object $P7672, "1304282274.421", 1
    .const 'Sub' $P7673 = "348_1304282286.73" 
    $P7671."add_method"($P7672, "quote:sym<Q>", $P7673)
    nqp_get_sc_object $P7674, "1304282274.421", 1
    get_how $P7675, $P7674
    nqp_get_sc_object $P7676, "1304282274.421", 1
    .const 'Sub' $P7677 = "350_1304282286.73" 
    $P7675."add_method"($P7676, "!PREFIX__quote:sym<Q>", $P7677)
    nqp_get_sc_object $P7678, "1304282274.421", 1
    get_how $P7679, $P7678
    nqp_get_sc_object $P7680, "1304282274.421", 1
    .const 'Sub' $P7681 = "351_1304282286.73" 
    $P7679."add_method"($P7680, "quote:sym<Q:PIR>", $P7681)
    nqp_get_sc_object $P7682, "1304282274.421", 1
    get_how $P7683, $P7682
    nqp_get_sc_object $P7684, "1304282274.421", 1
    .const 'Sub' $P7685 = "353_1304282286.73" 
    $P7683."add_method"($P7684, "!PREFIX__quote:sym<Q:PIR>", $P7685)
    nqp_get_sc_object $P7686, "1304282274.421", 1
    get_how $P7687, $P7686
    nqp_get_sc_object $P7688, "1304282274.421", 1
    .const 'Sub' $P7689 = "354_1304282286.73" 
    $P7687."add_method"($P7688, "quote:sym</ />", $P7689)
    nqp_get_sc_object $P7690, "1304282274.421", 1
    get_how $P7691, $P7690
    nqp_get_sc_object $P7692, "1304282274.421", 1
    .const 'Sub' $P7693 = "356_1304282286.73" 
    $P7691."add_method"($P7692, "!PREFIX__quote:sym</ />", $P7693)
    nqp_get_sc_object $P7694, "1304282274.421", 1
    get_how $P7695, $P7694
    nqp_get_sc_object $P7696, "1304282274.421", 1
    .const 'Sub' $P7697 = "357_1304282286.73" 
    $P7695."add_method"($P7696, "quote_escape:sym<$>", $P7697)
    nqp_get_sc_object $P7698, "1304282274.421", 1
    get_how $P7699, $P7698
    nqp_get_sc_object $P7700, "1304282274.421", 1
    .const 'Sub' $P7701 = "359_1304282286.73" 
    $P7699."add_method"($P7700, "!PREFIX__quote_escape:sym<$>", $P7701)
    nqp_get_sc_object $P7702, "1304282274.421", 1
    get_how $P7703, $P7702
    nqp_get_sc_object $P7704, "1304282274.421", 1
    .const 'Sub' $P7705 = "360_1304282286.73" 
    $P7703."add_method"($P7704, "quote_escape:sym<{ }>", $P7705)
    nqp_get_sc_object $P7706, "1304282274.421", 1
    get_how $P7707, $P7706
    nqp_get_sc_object $P7708, "1304282274.421", 1
    .const 'Sub' $P7709 = "362_1304282286.73" 
    $P7707."add_method"($P7708, "!PREFIX__quote_escape:sym<{ }>", $P7709)
    nqp_get_sc_object $P7710, "1304282274.421", 1
    get_how $P7711, $P7710
    nqp_get_sc_object $P7712, "1304282274.421", 1
    .const 'Sub' $P7713 = "363_1304282286.73" 
    $P7711."add_method"($P7712, "quote_escape:sym<esc>", $P7713)
    nqp_get_sc_object $P7714, "1304282274.421", 1
    get_how $P7715, $P7714
    nqp_get_sc_object $P7716, "1304282274.421", 1
    .const 'Sub' $P7717 = "365_1304282286.73" 
    $P7715."add_method"($P7716, "!PREFIX__quote_escape:sym<esc>", $P7717)
    nqp_get_sc_object $P7718, "1304282274.421", 1
    get_how $P7719, $P7718
    nqp_get_sc_object $P7720, "1304282274.421", 1
    .const 'Sub' $P7721 = "366_1304282286.73" 
    $P7719."add_method"($P7720, "circumfix:sym<( )>", $P7721)
    nqp_get_sc_object $P7722, "1304282274.421", 1
    get_how $P7723, $P7722
    nqp_get_sc_object $P7724, "1304282274.421", 1
    .const 'Sub' $P7725 = "368_1304282286.73" 
    $P7723."add_method"($P7724, "!PREFIX__circumfix:sym<( )>", $P7725)
    nqp_get_sc_object $P7726, "1304282274.421", 1
    get_how $P7727, $P7726
    nqp_get_sc_object $P7728, "1304282274.421", 1
    .const 'Sub' $P7729 = "369_1304282286.73" 
    $P7727."add_method"($P7728, "circumfix:sym<[ ]>", $P7729)
    nqp_get_sc_object $P7730, "1304282274.421", 1
    get_how $P7731, $P7730
    nqp_get_sc_object $P7732, "1304282274.421", 1
    .const 'Sub' $P7733 = "371_1304282286.73" 
    $P7731."add_method"($P7732, "!PREFIX__circumfix:sym<[ ]>", $P7733)
    nqp_get_sc_object $P7734, "1304282274.421", 1
    get_how $P7735, $P7734
    nqp_get_sc_object $P7736, "1304282274.421", 1
    .const 'Sub' $P7737 = "372_1304282286.73" 
    $P7735."add_method"($P7736, "circumfix:sym<ang>", $P7737)
    nqp_get_sc_object $P7738, "1304282274.421", 1
    get_how $P7739, $P7738
    nqp_get_sc_object $P7740, "1304282274.421", 1
    .const 'Sub' $P7741 = "374_1304282286.73" 
    $P7739."add_method"($P7740, "!PREFIX__circumfix:sym<ang>", $P7741)
    nqp_get_sc_object $P7742, "1304282274.421", 1
    get_how $P7743, $P7742
    nqp_get_sc_object $P7744, "1304282274.421", 1
    .const 'Sub' $P7745 = "375_1304282286.73" 
    $P7743."add_method"($P7744, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7745)
    nqp_get_sc_object $P7746, "1304282274.421", 1
    get_how $P7747, $P7746
    nqp_get_sc_object $P7748, "1304282274.421", 1
    .const 'Sub' $P7749 = "377_1304282286.73" 
    $P7747."add_method"($P7748, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P7749)
    nqp_get_sc_object $P7750, "1304282274.421", 1
    get_how $P7751, $P7750
    nqp_get_sc_object $P7752, "1304282274.421", 1
    .const 'Sub' $P7753 = "378_1304282286.73" 
    $P7751."add_method"($P7752, "circumfix:sym<{ }>", $P7753)
    nqp_get_sc_object $P7754, "1304282274.421", 1
    get_how $P7755, $P7754
    nqp_get_sc_object $P7756, "1304282274.421", 1
    .const 'Sub' $P7757 = "380_1304282286.73" 
    $P7755."add_method"($P7756, "!PREFIX__circumfix:sym<{ }>", $P7757)
    nqp_get_sc_object $P7758, "1304282274.421", 1
    get_how $P7759, $P7758
    nqp_get_sc_object $P7760, "1304282274.421", 1
    .const 'Sub' $P7761 = "381_1304282286.73" 
    $P7759."add_method"($P7760, "circumfix:sym<sigil>", $P7761)
    nqp_get_sc_object $P7762, "1304282274.421", 1
    get_how $P7763, $P7762
    nqp_get_sc_object $P7764, "1304282274.421", 1
    .const 'Sub' $P7765 = "383_1304282286.73" 
    $P7763."add_method"($P7764, "!PREFIX__circumfix:sym<sigil>", $P7765)
    nqp_get_sc_object $P7766, "1304282274.421", 1
    get_how $P7767, $P7766
    nqp_get_sc_object $P7768, "1304282274.421", 1
    .const 'Sub' $P7769 = "384_1304282286.73" 
    $P7767."add_method"($P7768, "semilist", $P7769)
    nqp_get_sc_object $P7770, "1304282274.421", 1
    get_how $P7771, $P7770
    nqp_get_sc_object $P7772, "1304282274.421", 1
    .const 'Sub' $P7773 = "386_1304282286.73" 
    $P7771."add_method"($P7772, "!PREFIX__semilist", $P7773)
    nqp_get_sc_object $P7774, "1304282274.421", 1
    get_how $P7775, $P7774
    nqp_get_sc_object $P7776, "1304282274.421", 1
    .const 'Sub' $P7777 = "387_1304282286.73" 
    $P7775."add_method"($P7776, "infixish", $P7777)
    nqp_get_sc_object $P7778, "1304282274.421", 1
    get_how $P7779, $P7778
    nqp_get_sc_object $P7780, "1304282274.421", 1
    .const 'Sub' $P7781 = "389_1304282286.73" 
    $P7779."add_method"($P7780, "!PREFIX__infixish", $P7781)
    nqp_get_sc_object $P7782, "1304282274.421", 1
    get_how $P7783, $P7782
    nqp_get_sc_object $P7784, "1304282274.421", 1
    .const 'Sub' $P7785 = "390_1304282286.73" 
    $P7783."add_method"($P7784, "infixstopper", $P7785)
    nqp_get_sc_object $P7786, "1304282274.421", 1
    get_how $P7787, $P7786
    nqp_get_sc_object $P7788, "1304282274.421", 1
    .const 'Sub' $P7789 = "392_1304282286.73" 
    $P7787."add_method"($P7788, "!PREFIX__infixstopper", $P7789)
    nqp_get_sc_object $P7790, "1304282274.421", 1
    get_how $P7791, $P7790
    nqp_get_sc_object $P7792, "1304282274.421", 1
    .const 'Sub' $P7793 = "393_1304282286.73" 
    $P7791."add_method"($P7792, "postcircumfix:sym<[ ]>", $P7793)
    nqp_get_sc_object $P7794, "1304282274.421", 1
    get_how $P7795, $P7794
    nqp_get_sc_object $P7796, "1304282274.421", 1
    .const 'Sub' $P7797 = "395_1304282286.73" 
    $P7795."add_method"($P7796, "!PREFIX__postcircumfix:sym<[ ]>", $P7797)
    nqp_get_sc_object $P7798, "1304282274.421", 1
    get_how $P7799, $P7798
    nqp_get_sc_object $P7800, "1304282274.421", 1
    .const 'Sub' $P7801 = "396_1304282286.73" 
    $P7799."add_method"($P7800, "postcircumfix:sym<{ }>", $P7801)
    nqp_get_sc_object $P7802, "1304282274.421", 1
    get_how $P7803, $P7802
    nqp_get_sc_object $P7804, "1304282274.421", 1
    .const 'Sub' $P7805 = "398_1304282286.73" 
    $P7803."add_method"($P7804, "!PREFIX__postcircumfix:sym<{ }>", $P7805)
    nqp_get_sc_object $P7806, "1304282274.421", 1
    get_how $P7807, $P7806
    nqp_get_sc_object $P7808, "1304282274.421", 1
    .const 'Sub' $P7809 = "399_1304282286.73" 
    $P7807."add_method"($P7808, "postcircumfix:sym<ang>", $P7809)
    nqp_get_sc_object $P7810, "1304282274.421", 1
    get_how $P7811, $P7810
    nqp_get_sc_object $P7812, "1304282274.421", 1
    .const 'Sub' $P7813 = "401_1304282286.73" 
    $P7811."add_method"($P7812, "!PREFIX__postcircumfix:sym<ang>", $P7813)
    nqp_get_sc_object $P7814, "1304282274.421", 1
    get_how $P7815, $P7814
    nqp_get_sc_object $P7816, "1304282274.421", 1
    .const 'Sub' $P7817 = "402_1304282286.73" 
    $P7815."add_method"($P7816, "postcircumfix:sym<( )>", $P7817)
    nqp_get_sc_object $P7818, "1304282274.421", 1
    get_how $P7819, $P7818
    nqp_get_sc_object $P7820, "1304282274.421", 1
    .const 'Sub' $P7821 = "404_1304282286.73" 
    $P7819."add_method"($P7820, "!PREFIX__postcircumfix:sym<( )>", $P7821)
    nqp_get_sc_object $P7822, "1304282274.421", 1
    get_how $P7823, $P7822
    nqp_get_sc_object $P7824, "1304282274.421", 1
    .const 'Sub' $P7825 = "405_1304282286.73" 
    $P7823."add_method"($P7824, "postfix:sym<.>", $P7825)
    nqp_get_sc_object $P7826, "1304282274.421", 1
    get_how $P7827, $P7826
    nqp_get_sc_object $P7828, "1304282274.421", 1
    .const 'Sub' $P7829 = "407_1304282286.73" 
    $P7827."add_method"($P7828, "!PREFIX__postfix:sym<.>", $P7829)
    nqp_get_sc_object $P7830, "1304282274.421", 1
    get_how $P7831, $P7830
    nqp_get_sc_object $P7832, "1304282274.421", 1
    .const 'Sub' $P7833 = "408_1304282286.73" 
    $P7831."add_method"($P7832, "prefix:sym<++>", $P7833)
    nqp_get_sc_object $P7834, "1304282274.421", 1
    get_how $P7835, $P7834
    nqp_get_sc_object $P7836, "1304282274.421", 1
    .const 'Sub' $P7837 = "410_1304282286.73" 
    $P7835."add_method"($P7836, "!PREFIX__prefix:sym<++>", $P7837)
    nqp_get_sc_object $P7838, "1304282274.421", 1
    get_how $P7839, $P7838
    nqp_get_sc_object $P7840, "1304282274.421", 1
    .const 'Sub' $P7841 = "411_1304282286.73" 
    $P7839."add_method"($P7840, "prefix:sym<-->", $P7841)
    nqp_get_sc_object $P7842, "1304282274.421", 1
    get_how $P7843, $P7842
    nqp_get_sc_object $P7844, "1304282274.421", 1
    .const 'Sub' $P7845 = "413_1304282286.73" 
    $P7843."add_method"($P7844, "!PREFIX__prefix:sym<-->", $P7845)
    nqp_get_sc_object $P7846, "1304282274.421", 1
    get_how $P7847, $P7846
    nqp_get_sc_object $P7848, "1304282274.421", 1
    .const 'Sub' $P7849 = "414_1304282286.73" 
    $P7847."add_method"($P7848, "postfix:sym<++>", $P7849)
    nqp_get_sc_object $P7850, "1304282274.421", 1
    get_how $P7851, $P7850
    nqp_get_sc_object $P7852, "1304282274.421", 1
    .const 'Sub' $P7853 = "416_1304282286.73" 
    $P7851."add_method"($P7852, "!PREFIX__postfix:sym<++>", $P7853)
    nqp_get_sc_object $P7854, "1304282274.421", 1
    get_how $P7855, $P7854
    nqp_get_sc_object $P7856, "1304282274.421", 1
    .const 'Sub' $P7857 = "417_1304282286.73" 
    $P7855."add_method"($P7856, "postfix:sym<-->", $P7857)
    nqp_get_sc_object $P7858, "1304282274.421", 1
    get_how $P7859, $P7858
    nqp_get_sc_object $P7860, "1304282274.421", 1
    .const 'Sub' $P7861 = "419_1304282286.73" 
    $P7859."add_method"($P7860, "!PREFIX__postfix:sym<-->", $P7861)
    nqp_get_sc_object $P7862, "1304282274.421", 1
    get_how $P7863, $P7862
    nqp_get_sc_object $P7864, "1304282274.421", 1
    .const 'Sub' $P7865 = "420_1304282286.73" 
    $P7863."add_method"($P7864, "infix:sym<**>", $P7865)
    nqp_get_sc_object $P7866, "1304282274.421", 1
    get_how $P7867, $P7866
    nqp_get_sc_object $P7868, "1304282274.421", 1
    .const 'Sub' $P7869 = "422_1304282286.73" 
    $P7867."add_method"($P7868, "!PREFIX__infix:sym<**>", $P7869)
    nqp_get_sc_object $P7870, "1304282274.421", 1
    get_how $P7871, $P7870
    nqp_get_sc_object $P7872, "1304282274.421", 1
    .const 'Sub' $P7873 = "423_1304282286.73" 
    $P7871."add_method"($P7872, "prefix:sym<+>", $P7873)
    nqp_get_sc_object $P7874, "1304282274.421", 1
    get_how $P7875, $P7874
    nqp_get_sc_object $P7876, "1304282274.421", 1
    .const 'Sub' $P7877 = "425_1304282286.73" 
    $P7875."add_method"($P7876, "!PREFIX__prefix:sym<+>", $P7877)
    nqp_get_sc_object $P7878, "1304282274.421", 1
    get_how $P7879, $P7878
    nqp_get_sc_object $P7880, "1304282274.421", 1
    .const 'Sub' $P7881 = "426_1304282286.73" 
    $P7879."add_method"($P7880, "prefix:sym<~>", $P7881)
    nqp_get_sc_object $P7882, "1304282274.421", 1
    get_how $P7883, $P7882
    nqp_get_sc_object $P7884, "1304282274.421", 1
    .const 'Sub' $P7885 = "428_1304282286.73" 
    $P7883."add_method"($P7884, "!PREFIX__prefix:sym<~>", $P7885)
    nqp_get_sc_object $P7886, "1304282274.421", 1
    get_how $P7887, $P7886
    nqp_get_sc_object $P7888, "1304282274.421", 1
    .const 'Sub' $P7889 = "429_1304282286.73" 
    $P7887."add_method"($P7888, "prefix:sym<->", $P7889)
    nqp_get_sc_object $P7890, "1304282274.421", 1
    get_how $P7891, $P7890
    nqp_get_sc_object $P7892, "1304282274.421", 1
    .const 'Sub' $P7893 = "431_1304282286.73" 
    $P7891."add_method"($P7892, "!PREFIX__prefix:sym<->", $P7893)
    nqp_get_sc_object $P7894, "1304282274.421", 1
    get_how $P7895, $P7894
    nqp_get_sc_object $P7896, "1304282274.421", 1
    .const 'Sub' $P7897 = "432_1304282286.73" 
    $P7895."add_method"($P7896, "prefix:sym<?>", $P7897)
    nqp_get_sc_object $P7898, "1304282274.421", 1
    get_how $P7899, $P7898
    nqp_get_sc_object $P7900, "1304282274.421", 1
    .const 'Sub' $P7901 = "434_1304282286.73" 
    $P7899."add_method"($P7900, "!PREFIX__prefix:sym<?>", $P7901)
    nqp_get_sc_object $P7902, "1304282274.421", 1
    get_how $P7903, $P7902
    nqp_get_sc_object $P7904, "1304282274.421", 1
    .const 'Sub' $P7905 = "435_1304282286.73" 
    $P7903."add_method"($P7904, "prefix:sym<!>", $P7905)
    nqp_get_sc_object $P7906, "1304282274.421", 1
    get_how $P7907, $P7906
    nqp_get_sc_object $P7908, "1304282274.421", 1
    .const 'Sub' $P7909 = "437_1304282286.73" 
    $P7907."add_method"($P7908, "!PREFIX__prefix:sym<!>", $P7909)
    nqp_get_sc_object $P7910, "1304282274.421", 1
    get_how $P7911, $P7910
    nqp_get_sc_object $P7912, "1304282274.421", 1
    .const 'Sub' $P7913 = "438_1304282286.73" 
    $P7911."add_method"($P7912, "prefix:sym<|>", $P7913)
    nqp_get_sc_object $P7914, "1304282274.421", 1
    get_how $P7915, $P7914
    nqp_get_sc_object $P7916, "1304282274.421", 1
    .const 'Sub' $P7917 = "440_1304282286.73" 
    $P7915."add_method"($P7916, "!PREFIX__prefix:sym<|>", $P7917)
    nqp_get_sc_object $P7918, "1304282274.421", 1
    get_how $P7919, $P7918
    nqp_get_sc_object $P7920, "1304282274.421", 1
    .const 'Sub' $P7921 = "441_1304282286.73" 
    $P7919."add_method"($P7920, "infix:sym<*>", $P7921)
    nqp_get_sc_object $P7922, "1304282274.421", 1
    get_how $P7923, $P7922
    nqp_get_sc_object $P7924, "1304282274.421", 1
    .const 'Sub' $P7925 = "443_1304282286.73" 
    $P7923."add_method"($P7924, "!PREFIX__infix:sym<*>", $P7925)
    nqp_get_sc_object $P7926, "1304282274.421", 1
    get_how $P7927, $P7926
    nqp_get_sc_object $P7928, "1304282274.421", 1
    .const 'Sub' $P7929 = "444_1304282286.73" 
    $P7927."add_method"($P7928, "infix:sym</>", $P7929)
    nqp_get_sc_object $P7930, "1304282274.421", 1
    get_how $P7931, $P7930
    nqp_get_sc_object $P7932, "1304282274.421", 1
    .const 'Sub' $P7933 = "446_1304282286.73" 
    $P7931."add_method"($P7932, "!PREFIX__infix:sym</>", $P7933)
    nqp_get_sc_object $P7934, "1304282274.421", 1
    get_how $P7935, $P7934
    nqp_get_sc_object $P7936, "1304282274.421", 1
    .const 'Sub' $P7937 = "447_1304282286.73" 
    $P7935."add_method"($P7936, "infix:sym<%>", $P7937)
    nqp_get_sc_object $P7938, "1304282274.421", 1
    get_how $P7939, $P7938
    nqp_get_sc_object $P7940, "1304282274.421", 1
    .const 'Sub' $P7941 = "449_1304282286.73" 
    $P7939."add_method"($P7940, "!PREFIX__infix:sym<%>", $P7941)
    nqp_get_sc_object $P7942, "1304282274.421", 1
    get_how $P7943, $P7942
    nqp_get_sc_object $P7944, "1304282274.421", 1
    .const 'Sub' $P7945 = "450_1304282286.73" 
    $P7943."add_method"($P7944, "infix:sym<+&>", $P7945)
    nqp_get_sc_object $P7946, "1304282274.421", 1
    get_how $P7947, $P7946
    nqp_get_sc_object $P7948, "1304282274.421", 1
    .const 'Sub' $P7949 = "452_1304282286.73" 
    $P7947."add_method"($P7948, "!PREFIX__infix:sym<+&>", $P7949)
    nqp_get_sc_object $P7950, "1304282274.421", 1
    get_how $P7951, $P7950
    nqp_get_sc_object $P7952, "1304282274.421", 1
    .const 'Sub' $P7953 = "453_1304282286.73" 
    $P7951."add_method"($P7952, "infix:sym<+>", $P7953)
    nqp_get_sc_object $P7954, "1304282274.421", 1
    get_how $P7955, $P7954
    nqp_get_sc_object $P7956, "1304282274.421", 1
    .const 'Sub' $P7957 = "455_1304282286.73" 
    $P7955."add_method"($P7956, "!PREFIX__infix:sym<+>", $P7957)
    nqp_get_sc_object $P7958, "1304282274.421", 1
    get_how $P7959, $P7958
    nqp_get_sc_object $P7960, "1304282274.421", 1
    .const 'Sub' $P7961 = "456_1304282286.73" 
    $P7959."add_method"($P7960, "infix:sym<->", $P7961)
    nqp_get_sc_object $P7962, "1304282274.421", 1
    get_how $P7963, $P7962
    nqp_get_sc_object $P7964, "1304282274.421", 1
    .const 'Sub' $P7965 = "458_1304282286.73" 
    $P7963."add_method"($P7964, "!PREFIX__infix:sym<->", $P7965)
    nqp_get_sc_object $P7966, "1304282274.421", 1
    get_how $P7967, $P7966
    nqp_get_sc_object $P7968, "1304282274.421", 1
    .const 'Sub' $P7969 = "459_1304282286.73" 
    $P7967."add_method"($P7968, "infix:sym<+|>", $P7969)
    nqp_get_sc_object $P7970, "1304282274.421", 1
    get_how $P7971, $P7970
    nqp_get_sc_object $P7972, "1304282274.421", 1
    .const 'Sub' $P7973 = "461_1304282286.73" 
    $P7971."add_method"($P7972, "!PREFIX__infix:sym<+|>", $P7973)
    nqp_get_sc_object $P7974, "1304282274.421", 1
    get_how $P7975, $P7974
    nqp_get_sc_object $P7976, "1304282274.421", 1
    .const 'Sub' $P7977 = "462_1304282286.73" 
    $P7975."add_method"($P7976, "infix:sym<+^>", $P7977)
    nqp_get_sc_object $P7978, "1304282274.421", 1
    get_how $P7979, $P7978
    nqp_get_sc_object $P7980, "1304282274.421", 1
    .const 'Sub' $P7981 = "464_1304282286.73" 
    $P7979."add_method"($P7980, "!PREFIX__infix:sym<+^>", $P7981)
    nqp_get_sc_object $P7982, "1304282274.421", 1
    get_how $P7983, $P7982
    nqp_get_sc_object $P7984, "1304282274.421", 1
    .const 'Sub' $P7985 = "465_1304282286.73" 
    $P7983."add_method"($P7984, "infix:sym<~>", $P7985)
    nqp_get_sc_object $P7986, "1304282274.421", 1
    get_how $P7987, $P7986
    nqp_get_sc_object $P7988, "1304282274.421", 1
    .const 'Sub' $P7989 = "467_1304282286.73" 
    $P7987."add_method"($P7988, "!PREFIX__infix:sym<~>", $P7989)
    nqp_get_sc_object $P7990, "1304282274.421", 1
    get_how $P7991, $P7990
    nqp_get_sc_object $P7992, "1304282274.421", 1
    .const 'Sub' $P7993 = "468_1304282286.73" 
    $P7991."add_method"($P7992, "infix:sym<==>", $P7993)
    nqp_get_sc_object $P7994, "1304282274.421", 1
    get_how $P7995, $P7994
    nqp_get_sc_object $P7996, "1304282274.421", 1
    .const 'Sub' $P7997 = "470_1304282286.73" 
    $P7995."add_method"($P7996, "!PREFIX__infix:sym<==>", $P7997)
    nqp_get_sc_object $P7998, "1304282274.421", 1
    get_how $P7999, $P7998
    nqp_get_sc_object $P8000, "1304282274.421", 1
    .const 'Sub' $P8001 = "471_1304282286.73" 
    $P7999."add_method"($P8000, "infix:sym<!=>", $P8001)
    nqp_get_sc_object $P8002, "1304282274.421", 1
    get_how $P8003, $P8002
    nqp_get_sc_object $P8004, "1304282274.421", 1
    .const 'Sub' $P8005 = "473_1304282286.73" 
    $P8003."add_method"($P8004, "!PREFIX__infix:sym<!=>", $P8005)
    nqp_get_sc_object $P8006, "1304282274.421", 1
    get_how $P8007, $P8006
    nqp_get_sc_object $P8008, "1304282274.421", 1
    .const 'Sub' $P8009 = "474_1304282286.73" 
    $P8007."add_method"($P8008, "infix:sym<<=>", $P8009)
    nqp_get_sc_object $P8010, "1304282274.421", 1
    get_how $P8011, $P8010
    nqp_get_sc_object $P8012, "1304282274.421", 1
    .const 'Sub' $P8013 = "476_1304282286.73" 
    $P8011."add_method"($P8012, "!PREFIX__infix:sym<<=>", $P8013)
    nqp_get_sc_object $P8014, "1304282274.421", 1
    get_how $P8015, $P8014
    nqp_get_sc_object $P8016, "1304282274.421", 1
    .const 'Sub' $P8017 = "477_1304282286.73" 
    $P8015."add_method"($P8016, "infix:sym<>=>", $P8017)
    nqp_get_sc_object $P8018, "1304282274.421", 1
    get_how $P8019, $P8018
    nqp_get_sc_object $P8020, "1304282274.421", 1
    .const 'Sub' $P8021 = "479_1304282286.73" 
    $P8019."add_method"($P8020, "!PREFIX__infix:sym<>=>", $P8021)
    nqp_get_sc_object $P8022, "1304282274.421", 1
    get_how $P8023, $P8022
    nqp_get_sc_object $P8024, "1304282274.421", 1
    .const 'Sub' $P8025 = "480_1304282286.73" 
    $P8023."add_method"($P8024, "infix:sym<<>", $P8025)
    nqp_get_sc_object $P8026, "1304282274.421", 1
    get_how $P8027, $P8026
    nqp_get_sc_object $P8028, "1304282274.421", 1
    .const 'Sub' $P8029 = "482_1304282286.73" 
    $P8027."add_method"($P8028, "!PREFIX__infix:sym<<>", $P8029)
    nqp_get_sc_object $P8030, "1304282274.421", 1
    get_how $P8031, $P8030
    nqp_get_sc_object $P8032, "1304282274.421", 1
    .const 'Sub' $P8033 = "483_1304282286.73" 
    $P8031."add_method"($P8032, "infix:sym<>>", $P8033)
    nqp_get_sc_object $P8034, "1304282274.421", 1
    get_how $P8035, $P8034
    nqp_get_sc_object $P8036, "1304282274.421", 1
    .const 'Sub' $P8037 = "485_1304282286.73" 
    $P8035."add_method"($P8036, "!PREFIX__infix:sym<>>", $P8037)
    nqp_get_sc_object $P8038, "1304282274.421", 1
    get_how $P8039, $P8038
    nqp_get_sc_object $P8040, "1304282274.421", 1
    .const 'Sub' $P8041 = "486_1304282286.73" 
    $P8039."add_method"($P8040, "infix:sym<eq>", $P8041)
    nqp_get_sc_object $P8042, "1304282274.421", 1
    get_how $P8043, $P8042
    nqp_get_sc_object $P8044, "1304282274.421", 1
    .const 'Sub' $P8045 = "488_1304282286.73" 
    $P8043."add_method"($P8044, "!PREFIX__infix:sym<eq>", $P8045)
    nqp_get_sc_object $P8046, "1304282274.421", 1
    get_how $P8047, $P8046
    nqp_get_sc_object $P8048, "1304282274.421", 1
    .const 'Sub' $P8049 = "489_1304282286.73" 
    $P8047."add_method"($P8048, "infix:sym<ne>", $P8049)
    nqp_get_sc_object $P8050, "1304282274.421", 1
    get_how $P8051, $P8050
    nqp_get_sc_object $P8052, "1304282274.421", 1
    .const 'Sub' $P8053 = "491_1304282286.73" 
    $P8051."add_method"($P8052, "!PREFIX__infix:sym<ne>", $P8053)
    nqp_get_sc_object $P8054, "1304282274.421", 1
    get_how $P8055, $P8054
    nqp_get_sc_object $P8056, "1304282274.421", 1
    .const 'Sub' $P8057 = "492_1304282286.73" 
    $P8055."add_method"($P8056, "infix:sym<le>", $P8057)
    nqp_get_sc_object $P8058, "1304282274.421", 1
    get_how $P8059, $P8058
    nqp_get_sc_object $P8060, "1304282274.421", 1
    .const 'Sub' $P8061 = "494_1304282286.73" 
    $P8059."add_method"($P8060, "!PREFIX__infix:sym<le>", $P8061)
    nqp_get_sc_object $P8062, "1304282274.421", 1
    get_how $P8063, $P8062
    nqp_get_sc_object $P8064, "1304282274.421", 1
    .const 'Sub' $P8065 = "495_1304282286.73" 
    $P8063."add_method"($P8064, "infix:sym<ge>", $P8065)
    nqp_get_sc_object $P8066, "1304282274.421", 1
    get_how $P8067, $P8066
    nqp_get_sc_object $P8068, "1304282274.421", 1
    .const 'Sub' $P8069 = "497_1304282286.73" 
    $P8067."add_method"($P8068, "!PREFIX__infix:sym<ge>", $P8069)
    nqp_get_sc_object $P8070, "1304282274.421", 1
    get_how $P8071, $P8070
    nqp_get_sc_object $P8072, "1304282274.421", 1
    .const 'Sub' $P8073 = "498_1304282286.73" 
    $P8071."add_method"($P8072, "infix:sym<lt>", $P8073)
    nqp_get_sc_object $P8074, "1304282274.421", 1
    get_how $P8075, $P8074
    nqp_get_sc_object $P8076, "1304282274.421", 1
    .const 'Sub' $P8077 = "500_1304282286.73" 
    $P8075."add_method"($P8076, "!PREFIX__infix:sym<lt>", $P8077)
    nqp_get_sc_object $P8078, "1304282274.421", 1
    get_how $P8079, $P8078
    nqp_get_sc_object $P8080, "1304282274.421", 1
    .const 'Sub' $P8081 = "501_1304282286.73" 
    $P8079."add_method"($P8080, "infix:sym<gt>", $P8081)
    nqp_get_sc_object $P8082, "1304282274.421", 1
    get_how $P8083, $P8082
    nqp_get_sc_object $P8084, "1304282274.421", 1
    .const 'Sub' $P8085 = "503_1304282286.73" 
    $P8083."add_method"($P8084, "!PREFIX__infix:sym<gt>", $P8085)
    nqp_get_sc_object $P8086, "1304282274.421", 1
    get_how $P8087, $P8086
    nqp_get_sc_object $P8088, "1304282274.421", 1
    .const 'Sub' $P8089 = "504_1304282286.73" 
    $P8087."add_method"($P8088, "infix:sym<=:=>", $P8089)
    nqp_get_sc_object $P8090, "1304282274.421", 1
    get_how $P8091, $P8090
    nqp_get_sc_object $P8092, "1304282274.421", 1
    .const 'Sub' $P8093 = "506_1304282286.73" 
    $P8091."add_method"($P8092, "!PREFIX__infix:sym<=:=>", $P8093)
    nqp_get_sc_object $P8094, "1304282274.421", 1
    get_how $P8095, $P8094
    nqp_get_sc_object $P8096, "1304282274.421", 1
    .const 'Sub' $P8097 = "507_1304282286.73" 
    $P8095."add_method"($P8096, "infix:sym<~~>", $P8097)
    nqp_get_sc_object $P8098, "1304282274.421", 1
    get_how $P8099, $P8098
    nqp_get_sc_object $P8100, "1304282274.421", 1
    .const 'Sub' $P8101 = "509_1304282286.73" 
    $P8099."add_method"($P8100, "!PREFIX__infix:sym<~~>", $P8101)
    nqp_get_sc_object $P8102, "1304282274.421", 1
    get_how $P8103, $P8102
    nqp_get_sc_object $P8104, "1304282274.421", 1
    .const 'Sub' $P8105 = "510_1304282286.73" 
    $P8103."add_method"($P8104, "infix:sym<&&>", $P8105)
    nqp_get_sc_object $P8106, "1304282274.421", 1
    get_how $P8107, $P8106
    nqp_get_sc_object $P8108, "1304282274.421", 1
    .const 'Sub' $P8109 = "512_1304282286.73" 
    $P8107."add_method"($P8108, "!PREFIX__infix:sym<&&>", $P8109)
    nqp_get_sc_object $P8110, "1304282274.421", 1
    get_how $P8111, $P8110
    nqp_get_sc_object $P8112, "1304282274.421", 1
    .const 'Sub' $P8113 = "513_1304282286.73" 
    $P8111."add_method"($P8112, "infix:sym<||>", $P8113)
    nqp_get_sc_object $P8114, "1304282274.421", 1
    get_how $P8115, $P8114
    nqp_get_sc_object $P8116, "1304282274.421", 1
    .const 'Sub' $P8117 = "515_1304282286.73" 
    $P8115."add_method"($P8116, "!PREFIX__infix:sym<||>", $P8117)
    nqp_get_sc_object $P8118, "1304282274.421", 1
    get_how $P8119, $P8118
    nqp_get_sc_object $P8120, "1304282274.421", 1
    .const 'Sub' $P8121 = "516_1304282286.73" 
    $P8119."add_method"($P8120, "infix:sym<//>", $P8121)
    nqp_get_sc_object $P8122, "1304282274.421", 1
    get_how $P8123, $P8122
    nqp_get_sc_object $P8124, "1304282274.421", 1
    .const 'Sub' $P8125 = "518_1304282286.73" 
    $P8123."add_method"($P8124, "!PREFIX__infix:sym<//>", $P8125)
    nqp_get_sc_object $P8126, "1304282274.421", 1
    get_how $P8127, $P8126
    nqp_get_sc_object $P8128, "1304282274.421", 1
    .const 'Sub' $P8129 = "519_1304282286.73" 
    $P8127."add_method"($P8128, "infix:sym<?? !!>", $P8129)
    nqp_get_sc_object $P8130, "1304282274.421", 1
    get_how $P8131, $P8130
    nqp_get_sc_object $P8132, "1304282274.421", 1
    .const 'Sub' $P8133 = "521_1304282286.73" 
    $P8131."add_method"($P8132, "!PREFIX__infix:sym<?? !!>", $P8133)
    nqp_get_sc_object $P8134, "1304282274.421", 1
    get_how $P8135, $P8134
    nqp_get_sc_object $P8136, "1304282274.421", 1
    .const 'Sub' $P8137 = "522_1304282286.73" 
    $P8135."add_method"($P8136, "infix:sym<=>", $P8137)
    nqp_get_sc_object $P8138, "1304282274.421", 1
    get_how $P8139, $P8138
    nqp_get_sc_object $P8140, "1304282274.421", 1
    .const 'Sub' $P8141 = "524_1304282286.73" 
    $P8139."add_method"($P8140, "!PREFIX__infix:sym<=>", $P8141)
    nqp_get_sc_object $P8142, "1304282274.421", 1
    get_how $P8143, $P8142
    nqp_get_sc_object $P8144, "1304282274.421", 1
    .const 'Sub' $P8145 = "525_1304282286.73" 
    $P8143."add_method"($P8144, "infix:sym<:=>", $P8145)
    nqp_get_sc_object $P8146, "1304282274.421", 1
    get_how $P8147, $P8146
    nqp_get_sc_object $P8148, "1304282274.421", 1
    .const 'Sub' $P8149 = "527_1304282286.73" 
    $P8147."add_method"($P8148, "!PREFIX__infix:sym<:=>", $P8149)
    nqp_get_sc_object $P8150, "1304282274.421", 1
    get_how $P8151, $P8150
    nqp_get_sc_object $P8152, "1304282274.421", 1
    .const 'Sub' $P8153 = "528_1304282286.73" 
    $P8151."add_method"($P8152, "infix:sym<::=>", $P8153)
    nqp_get_sc_object $P8154, "1304282274.421", 1
    get_how $P8155, $P8154
    nqp_get_sc_object $P8156, "1304282274.421", 1
    .const 'Sub' $P8157 = "530_1304282286.73" 
    $P8155."add_method"($P8156, "!PREFIX__infix:sym<::=>", $P8157)
    nqp_get_sc_object $P8158, "1304282274.421", 1
    get_how $P8159, $P8158
    nqp_get_sc_object $P8160, "1304282274.421", 1
    .const 'Sub' $P8161 = "531_1304282286.73" 
    $P8159."add_method"($P8160, "infix:sym<,>", $P8161)
    nqp_get_sc_object $P8162, "1304282274.421", 1
    get_how $P8163, $P8162
    nqp_get_sc_object $P8164, "1304282274.421", 1
    .const 'Sub' $P8165 = "533_1304282286.73" 
    $P8163."add_method"($P8164, "!PREFIX__infix:sym<,>", $P8165)
    nqp_get_sc_object $P8166, "1304282274.421", 1
    get_how $P8167, $P8166
    nqp_get_sc_object $P8168, "1304282274.421", 1
    .const 'Sub' $P8169 = "534_1304282286.73" 
    $P8167."add_method"($P8168, "prefix:sym<return>", $P8169)
    nqp_get_sc_object $P8170, "1304282274.421", 1
    get_how $P8171, $P8170
    nqp_get_sc_object $P8172, "1304282274.421", 1
    .const 'Sub' $P8173 = "537_1304282286.73" 
    $P8171."add_method"($P8172, "!PREFIX__prefix:sym<return>", $P8173)
    nqp_get_sc_object $P8174, "1304282274.421", 1
    get_how $P8175, $P8174
    nqp_get_sc_object $P8176, "1304282274.421", 1
    .const 'Sub' $P8177 = "538_1304282286.73" 
    $P8175."add_method"($P8176, "prefix:sym<make>", $P8177)
    nqp_get_sc_object $P8178, "1304282274.421", 1
    get_how $P8179, $P8178
    nqp_get_sc_object $P8180, "1304282274.421", 1
    .const 'Sub' $P8181 = "540_1304282286.73" 
    $P8179."add_method"($P8180, "!PREFIX__prefix:sym<make>", $P8181)
    nqp_get_sc_object $P8182, "1304282274.421", 1
    get_how $P8183, $P8182
    nqp_get_sc_object $P8184, "1304282274.421", 1
    .const 'Sub' $P8185 = "541_1304282286.73" 
    $P8183."add_method"($P8184, "term:sym<last>", $P8185)
    nqp_get_sc_object $P8186, "1304282274.421", 1
    get_how $P8187, $P8186
    nqp_get_sc_object $P8188, "1304282274.421", 1
    .const 'Sub' $P8189 = "543_1304282286.73" 
    $P8187."add_method"($P8188, "!PREFIX__term:sym<last>", $P8189)
    nqp_get_sc_object $P8190, "1304282274.421", 1
    get_how $P8191, $P8190
    nqp_get_sc_object $P8192, "1304282274.421", 1
    .const 'Sub' $P8193 = "544_1304282286.73" 
    $P8191."add_method"($P8192, "term:sym<next>", $P8193)
    nqp_get_sc_object $P8194, "1304282274.421", 1
    get_how $P8195, $P8194
    nqp_get_sc_object $P8196, "1304282274.421", 1
    .const 'Sub' $P8197 = "546_1304282286.73" 
    $P8195."add_method"($P8196, "!PREFIX__term:sym<next>", $P8197)
    nqp_get_sc_object $P8198, "1304282274.421", 1
    get_how $P8199, $P8198
    nqp_get_sc_object $P8200, "1304282274.421", 1
    .const 'Sub' $P8201 = "547_1304282286.73" 
    $P8199."add_method"($P8200, "term:sym<redo>", $P8201)
    nqp_get_sc_object $P8202, "1304282274.421", 1
    get_how $P8203, $P8202
    nqp_get_sc_object $P8204, "1304282274.421", 1
    .const 'Sub' $P8205 = "549_1304282286.73" 
    $P8203."add_method"($P8204, "!PREFIX__term:sym<redo>", $P8205)
    nqp_get_sc_object $P8206, "1304282274.421", 1
    get_how $P8207, $P8206
    nqp_get_sc_object $P8208, "1304282274.421", 1
    .const 'Sub' $P8209 = "550_1304282286.73" 
    $P8207."add_method"($P8208, "smartmatch", $P8209)
    .const 'Sub' $P8210 = "12_1304282286.73" 
    $P8211 = $P8210."get_lexinfo"()
    nqp_get_sc_object $P8212, "1304282274.421", 1
    $P8211."set_static_lexpad_value"("$?PACKAGE", $P8212)
    .const 'Sub' $P8213 = "12_1304282286.73" 
    $P8214 = $P8213."get_lexinfo"()
    $P8214."finish_static_lexpad"()
    .const 'Sub' $P8215 = "12_1304282286.73" 
    $P8216 = $P8215."get_lexinfo"()
    nqp_get_sc_object $P8217, "1304282274.421", 1
    $P8216."set_static_lexpad_value"("$?CLASS", $P8217)
    .const 'Sub' $P8218 = "12_1304282286.73" 
    $P8219 = $P8218."get_lexinfo"()
    $P8219."finish_static_lexpad"()
    nqp_get_sc_object $P8220, "1304282274.421", 1
    get_how $P8221, $P8220
    nqp_get_sc_object $P8222, "1304282274.421", 1
    nqp_get_sc_object $P8223, "1304282255.673", 1
    $P8221."add_parent"($P8222, $P8223)
    nqp_get_sc_object $P8224, "1304282248.255", 41
    $P8225 = $P8224."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P8225, cur_sc
    nqp_set_sc_object "1304282274.421", 360, $P8225
    nqp_get_sc_object $P8226, "1304282274.421", 360
    nqp_get_sc_object $P8227, "1304282274.421", 0
    nqp_get_package_through_who $P8228, $P8227, "NQP"
    get_who $P8229, $P8228
    set $P8229["Regex"], $P8226
    nqp_get_sc_object $P8230, "1304282274.421", 360
    get_how $P8231, $P8230
    nqp_get_sc_object $P8232, "1304282274.421", 360
    .const 'Sub' $P8233 = "553_1304282286.73" 
    $P8231."add_method"($P8232, "metachar:sym<:my>", $P8233)
    nqp_get_sc_object $P8234, "1304282274.421", 360
    get_how $P8235, $P8234
    nqp_get_sc_object $P8236, "1304282274.421", 360
    .const 'Sub' $P8237 = "556_1304282286.73" 
    $P8235."add_method"($P8236, "!PREFIX__metachar:sym<:my>", $P8237)
    nqp_get_sc_object $P8238, "1304282274.421", 360
    get_how $P8239, $P8238
    nqp_get_sc_object $P8240, "1304282274.421", 360
    .const 'Sub' $P8241 = "557_1304282286.73" 
    $P8239."add_method"($P8240, "metachar:sym<{ }>", $P8241)
    nqp_get_sc_object $P8242, "1304282274.421", 360
    get_how $P8243, $P8242
    nqp_get_sc_object $P8244, "1304282274.421", 360
    .const 'Sub' $P8245 = "559_1304282286.73" 
    $P8243."add_method"($P8244, "!PREFIX__metachar:sym<{ }>", $P8245)
    nqp_get_sc_object $P8246, "1304282274.421", 360
    get_how $P8247, $P8246
    nqp_get_sc_object $P8248, "1304282274.421", 360
    .const 'Sub' $P8249 = "560_1304282286.73" 
    $P8247."add_method"($P8248, "metachar:sym<nqpvar>", $P8249)
    nqp_get_sc_object $P8250, "1304282274.421", 360
    get_how $P8251, $P8250
    nqp_get_sc_object $P8252, "1304282274.421", 360
    .const 'Sub' $P8253 = "563_1304282286.73" 
    $P8251."add_method"($P8252, "!PREFIX__metachar:sym<nqpvar>", $P8253)
    nqp_get_sc_object $P8254, "1304282274.421", 360
    get_how $P8255, $P8254
    nqp_get_sc_object $P8256, "1304282274.421", 360
    .const 'Sub' $P8257 = "564_1304282286.73" 
    $P8255."add_method"($P8256, "assertion:sym<{ }>", $P8257)
    nqp_get_sc_object $P8258, "1304282274.421", 360
    get_how $P8259, $P8258
    nqp_get_sc_object $P8260, "1304282274.421", 360
    .const 'Sub' $P8261 = "566_1304282286.73" 
    $P8259."add_method"($P8260, "!PREFIX__assertion:sym<{ }>", $P8261)
    nqp_get_sc_object $P8262, "1304282274.421", 360
    get_how $P8263, $P8262
    nqp_get_sc_object $P8264, "1304282274.421", 360
    .const 'Sub' $P8265 = "567_1304282286.73" 
    $P8263."add_method"($P8264, "assertion:sym<?{ }>", $P8265)
    nqp_get_sc_object $P8266, "1304282274.421", 360
    get_how $P8267, $P8266
    nqp_get_sc_object $P8268, "1304282274.421", 360
    .const 'Sub' $P8269 = "570_1304282286.73" 
    $P8267."add_method"($P8268, "!PREFIX__assertion:sym<?{ }>", $P8269)
    nqp_get_sc_object $P8270, "1304282274.421", 360
    get_how $P8271, $P8270
    nqp_get_sc_object $P8272, "1304282274.421", 360
    .const 'Sub' $P8273 = "571_1304282286.73" 
    $P8271."add_method"($P8272, "assertion:sym<name>", $P8273)
    nqp_get_sc_object $P8274, "1304282274.421", 360
    get_how $P8275, $P8274
    nqp_get_sc_object $P8276, "1304282274.421", 360
    .const 'Sub' $P8277 = "574_1304282286.73" 
    $P8275."add_method"($P8276, "!PREFIX__assertion:sym<name>", $P8277)
    nqp_get_sc_object $P8278, "1304282274.421", 360
    get_how $P8279, $P8278
    nqp_get_sc_object $P8280, "1304282274.421", 360
    .const 'Sub' $P8281 = "575_1304282286.73" 
    $P8279."add_method"($P8280, "assertion:sym<var>", $P8281)
    nqp_get_sc_object $P8282, "1304282274.421", 360
    get_how $P8283, $P8282
    nqp_get_sc_object $P8284, "1304282274.421", 360
    .const 'Sub' $P8285 = "577_1304282286.73" 
    $P8283."add_method"($P8284, "!PREFIX__assertion:sym<var>", $P8285)
    nqp_get_sc_object $P8286, "1304282274.421", 360
    get_how $P8287, $P8286
    nqp_get_sc_object $P8288, "1304282274.421", 360
    .const 'Sub' $P8289 = "578_1304282286.73" 
    $P8287."add_method"($P8288, "codeblock", $P8289)
    nqp_get_sc_object $P8290, "1304282274.421", 360
    get_how $P8291, $P8290
    nqp_get_sc_object $P8292, "1304282274.421", 360
    .const 'Sub' $P8293 = "580_1304282286.73" 
    $P8291."add_method"($P8292, "!PREFIX__codeblock", $P8293)
    .const 'Sub' $P8294 = "552_1304282286.73" 
    $P8295 = $P8294."get_lexinfo"()
    nqp_get_sc_object $P8296, "1304282274.421", 360
    $P8295."set_static_lexpad_value"("$?PACKAGE", $P8296)
    .const 'Sub' $P8297 = "552_1304282286.73" 
    $P8298 = $P8297."get_lexinfo"()
    $P8298."finish_static_lexpad"()
    .const 'Sub' $P8299 = "552_1304282286.73" 
    $P8300 = $P8299."get_lexinfo"()
    nqp_get_sc_object $P8301, "1304282274.421", 360
    $P8300."set_static_lexpad_value"("$?CLASS", $P8301)
    .const 'Sub' $P8302 = "552_1304282286.73" 
    $P8303 = $P8302."get_lexinfo"()
    $P8303."finish_static_lexpad"()
    nqp_get_sc_object $P8304, "1304282274.421", 360
    get_how $P8305, $P8304
    nqp_get_sc_object $P8306, "1304282274.421", 360
    nqp_get_sc_object $P8307, "1304282267.413", 1
    $P8305."add_parent"($P8306, $P8307)
    nqp_get_sc_object $P8308, "1304282248.255", 41
    $P8309 = $P8308."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P8309, cur_sc
    nqp_set_sc_object "1304282274.421", 377, $P8309
    nqp_get_sc_object $P8310, "1304282274.421", 377
    nqp_get_sc_object $P8311, "1304282274.421", 0
    nqp_get_package_through_who $P8312, $P8311, "NQP"
    get_who $P8313, $P8312
    set $P8313["Actions"], $P8310
    nqp_get_sc_object $P8314, "1304282274.421", 377
    get_how $P8315, $P8314
    nqp_get_sc_object $P8316, "1304282274.421", 377
    .const 'Sub' $P8317 = "609_1304282286.73" 
    $P8315."add_method"($P8316, "TOP", $P8317)
    nqp_get_sc_object $P8318, "1304282274.421", 377
    get_how $P8319, $P8318
    nqp_get_sc_object $P8320, "1304282274.421", 377
    .const 'Sub' $P8321 = "610_1304282286.73" 
    $P8319."add_method"($P8320, "deflongname", $P8321)
    nqp_get_sc_object $P8322, "1304282274.421", 377
    get_how $P8323, $P8322
    nqp_get_sc_object $P8324, "1304282274.421", 377
    .const 'Sub' $P8325 = "611_1304282286.73" 
    $P8323."add_method"($P8324, "comp_unit", $P8325)
    nqp_get_sc_object $P8326, "1304282274.421", 377
    get_how $P8327, $P8326
    nqp_get_sc_object $P8328, "1304282274.421", 377
    .const 'Sub' $P8329 = "612_1304282286.73" 
    $P8327."add_method"($P8328, "statementlist", $P8329)
    nqp_get_sc_object $P8330, "1304282274.421", 377
    get_how $P8331, $P8330
    nqp_get_sc_object $P8332, "1304282274.421", 377
    .const 'Sub' $P8333 = "614_1304282286.73" 
    $P8331."add_method"($P8332, "statement", $P8333)
    nqp_get_sc_object $P8334, "1304282274.421", 377
    get_how $P8335, $P8334
    nqp_get_sc_object $P8336, "1304282274.421", 377
    .const 'Sub' $P8337 = "616_1304282286.73" 
    $P8335."add_method"($P8336, "xblock", $P8337)
    nqp_get_sc_object $P8338, "1304282274.421", 377
    get_how $P8339, $P8338
    nqp_get_sc_object $P8340, "1304282274.421", 377
    .const 'Sub' $P8341 = "617_1304282286.73" 
    $P8339."add_method"($P8340, "pblock", $P8341)
    nqp_get_sc_object $P8342, "1304282274.421", 377
    get_how $P8343, $P8342
    nqp_get_sc_object $P8344, "1304282274.421", 377
    .const 'Sub' $P8345 = "618_1304282286.73" 
    $P8343."add_method"($P8344, "block", $P8345)
    nqp_get_sc_object $P8346, "1304282274.421", 377
    get_how $P8347, $P8346
    nqp_get_sc_object $P8348, "1304282274.421", 377
    .const 'Sub' $P8349 = "619_1304282286.73" 
    $P8347."add_method"($P8348, "blockoid", $P8349)
    nqp_get_sc_object $P8350, "1304282274.421", 377
    get_how $P8351, $P8350
    nqp_get_sc_object $P8352, "1304282274.421", 377
    .const 'Sub' $P8353 = "621_1304282286.73" 
    $P8351."add_method"($P8352, "newpad", $P8353)
    nqp_get_sc_object $P8354, "1304282274.421", 377
    get_how $P8355, $P8354
    nqp_get_sc_object $P8356, "1304282274.421", 377
    .const 'Sub' $P8357 = "622_1304282286.73" 
    $P8355."add_method"($P8356, "outerctx", $P8357)
    nqp_get_sc_object $P8358, "1304282274.421", 377
    get_how $P8359, $P8358
    nqp_get_sc_object $P8360, "1304282274.421", 377
    .const 'Sub' $P8361 = "624_1304282286.73" 
    $P8359."add_method"($P8360, "GLOBALish", $P8361)
    nqp_get_sc_object $P8362, "1304282274.421", 377
    get_how $P8363, $P8362
    nqp_get_sc_object $P8364, "1304282274.421", 377
    .const 'Sub' $P8365 = "625_1304282286.73" 
    $P8363."add_method"($P8364, "you_are_here", $P8365)
    nqp_get_sc_object $P8366, "1304282274.421", 377
    get_how $P8367, $P8366
    nqp_get_sc_object $P8368, "1304282274.421", 377
    .const 'Sub' $P8369 = "626_1304282286.73" 
    $P8367."add_method"($P8368, "statement_control:sym<use>", $P8369)
    nqp_get_sc_object $P8370, "1304282274.421", 377
    get_how $P8371, $P8370
    nqp_get_sc_object $P8372, "1304282274.421", 377
    .const 'Sub' $P8373 = "627_1304282286.73" 
    $P8371."add_method"($P8372, "statement_control:sym<if>", $P8373)
    nqp_get_sc_object $P8374, "1304282274.421", 377
    get_how $P8375, $P8374
    nqp_get_sc_object $P8376, "1304282274.421", 377
    .const 'Sub' $P8377 = "629_1304282286.73" 
    $P8375."add_method"($P8376, "statement_control:sym<unless>", $P8377)
    nqp_get_sc_object $P8378, "1304282274.421", 377
    get_how $P8379, $P8378
    nqp_get_sc_object $P8380, "1304282274.421", 377
    .const 'Sub' $P8381 = "630_1304282286.73" 
    $P8379."add_method"($P8380, "statement_control:sym<while>", $P8381)
    nqp_get_sc_object $P8382, "1304282274.421", 377
    get_how $P8383, $P8382
    nqp_get_sc_object $P8384, "1304282274.421", 377
    .const 'Sub' $P8385 = "631_1304282286.73" 
    $P8383."add_method"($P8384, "statement_control:sym<repeat>", $P8385)
    nqp_get_sc_object $P8386, "1304282274.421", 377
    get_how $P8387, $P8386
    nqp_get_sc_object $P8388, "1304282274.421", 377
    .const 'Sub' $P8389 = "632_1304282286.73" 
    $P8387."add_method"($P8388, "statement_control:sym<for>", $P8389)
    nqp_get_sc_object $P8390, "1304282274.421", 377
    get_how $P8391, $P8390
    nqp_get_sc_object $P8392, "1304282274.421", 377
    .const 'Sub' $P8393 = "633_1304282286.73" 
    $P8391."add_method"($P8392, "statement_control:sym<CATCH>", $P8393)
    nqp_get_sc_object $P8394, "1304282274.421", 377
    get_how $P8395, $P8394
    nqp_get_sc_object $P8396, "1304282274.421", 377
    .const 'Sub' $P8397 = "634_1304282286.73" 
    $P8395."add_method"($P8396, "statement_control:sym<CONTROL>", $P8397)
    nqp_get_sc_object $P8398, "1304282274.421", 377
    get_how $P8399, $P8398
    nqp_get_sc_object $P8400, "1304282274.421", 377
    .const 'Sub' $P8401 = "635_1304282286.73" 
    $P8399."add_method"($P8400, "statement_prefix:sym<INIT>", $P8401)
    nqp_get_sc_object $P8402, "1304282274.421", 377
    get_how $P8403, $P8402
    nqp_get_sc_object $P8404, "1304282274.421", 377
    .const 'Sub' $P8405 = "636_1304282286.73" 
    $P8403."add_method"($P8404, "statement_prefix:sym<try>", $P8405)
    nqp_get_sc_object $P8406, "1304282274.421", 377
    get_how $P8407, $P8406
    nqp_get_sc_object $P8408, "1304282274.421", 377
    .const 'Sub' $P8409 = "637_1304282286.73" 
    $P8407."add_method"($P8408, "blorst", $P8409)
    nqp_get_sc_object $P8410, "1304282274.421", 377
    get_how $P8411, $P8410
    nqp_get_sc_object $P8412, "1304282274.421", 377
    .const 'Sub' $P8413 = "638_1304282286.73" 
    $P8411."add_method"($P8412, "statement_mod_cond:sym<if>", $P8413)
    nqp_get_sc_object $P8414, "1304282274.421", 377
    get_how $P8415, $P8414
    nqp_get_sc_object $P8416, "1304282274.421", 377
    .const 'Sub' $P8417 = "639_1304282286.73" 
    $P8415."add_method"($P8416, "statement_mod_cond:sym<unless>", $P8417)
    nqp_get_sc_object $P8418, "1304282274.421", 377
    get_how $P8419, $P8418
    nqp_get_sc_object $P8420, "1304282274.421", 377
    .const 'Sub' $P8421 = "640_1304282286.73" 
    $P8419."add_method"($P8420, "statement_mod_loop:sym<while>", $P8421)
    nqp_get_sc_object $P8422, "1304282274.421", 377
    get_how $P8423, $P8422
    nqp_get_sc_object $P8424, "1304282274.421", 377
    .const 'Sub' $P8425 = "641_1304282286.73" 
    $P8423."add_method"($P8424, "statement_mod_loop:sym<until>", $P8425)
    nqp_get_sc_object $P8426, "1304282274.421", 377
    get_how $P8427, $P8426
    nqp_get_sc_object $P8428, "1304282274.421", 377
    .const 'Sub' $P8429 = "642_1304282286.73" 
    $P8427."add_method"($P8428, "term:sym<fatarrow>", $P8429)
    nqp_get_sc_object $P8430, "1304282274.421", 377
    get_how $P8431, $P8430
    nqp_get_sc_object $P8432, "1304282274.421", 377
    .const 'Sub' $P8433 = "643_1304282286.73" 
    $P8431."add_method"($P8432, "term:sym<colonpair>", $P8433)
    nqp_get_sc_object $P8434, "1304282274.421", 377
    get_how $P8435, $P8434
    nqp_get_sc_object $P8436, "1304282274.421", 377
    .const 'Sub' $P8437 = "644_1304282286.73" 
    $P8435."add_method"($P8436, "term:sym<variable>", $P8437)
    nqp_get_sc_object $P8438, "1304282274.421", 377
    get_how $P8439, $P8438
    nqp_get_sc_object $P8440, "1304282274.421", 377
    .const 'Sub' $P8441 = "645_1304282286.73" 
    $P8439."add_method"($P8440, "term:sym<package_declarator>", $P8441)
    nqp_get_sc_object $P8442, "1304282274.421", 377
    get_how $P8443, $P8442
    nqp_get_sc_object $P8444, "1304282274.421", 377
    .const 'Sub' $P8445 = "646_1304282286.73" 
    $P8443."add_method"($P8444, "term:sym<scope_declarator>", $P8445)
    nqp_get_sc_object $P8446, "1304282274.421", 377
    get_how $P8447, $P8446
    nqp_get_sc_object $P8448, "1304282274.421", 377
    .const 'Sub' $P8449 = "647_1304282286.73" 
    $P8447."add_method"($P8448, "term:sym<routine_declarator>", $P8449)
    nqp_get_sc_object $P8450, "1304282274.421", 377
    get_how $P8451, $P8450
    nqp_get_sc_object $P8452, "1304282274.421", 377
    .const 'Sub' $P8453 = "648_1304282286.73" 
    $P8451."add_method"($P8452, "term:sym<regex_declarator>", $P8453)
    nqp_get_sc_object $P8454, "1304282274.421", 377
    get_how $P8455, $P8454
    nqp_get_sc_object $P8456, "1304282274.421", 377
    .const 'Sub' $P8457 = "649_1304282286.73" 
    $P8455."add_method"($P8456, "term:sym<statement_prefix>", $P8457)
    nqp_get_sc_object $P8458, "1304282274.421", 377
    get_how $P8459, $P8458
    nqp_get_sc_object $P8460, "1304282274.421", 377
    .const 'Sub' $P8461 = "650_1304282286.73" 
    $P8459."add_method"($P8460, "term:sym<lambda>", $P8461)
    nqp_get_sc_object $P8462, "1304282274.421", 377
    get_how $P8463, $P8462
    nqp_get_sc_object $P8464, "1304282274.421", 377
    .const 'Sub' $P8465 = "651_1304282286.73" 
    $P8463."add_method"($P8464, "fatarrow", $P8465)
    nqp_get_sc_object $P8466, "1304282274.421", 377
    get_how $P8467, $P8466
    nqp_get_sc_object $P8468, "1304282274.421", 377
    .const 'Sub' $P8469 = "652_1304282286.73" 
    $P8467."add_method"($P8468, "colonpair", $P8469)
    nqp_get_sc_object $P8470, "1304282274.421", 377
    get_how $P8471, $P8470
    nqp_get_sc_object $P8472, "1304282274.421", 377
    .const 'Sub' $P8473 = "653_1304282286.73" 
    $P8471."add_method"($P8472, "variable", $P8473)
    nqp_get_sc_object $P8474, "1304282274.421", 377
    get_how $P8475, $P8474
    nqp_get_sc_object $P8476, "1304282274.421", 377
    .const 'Sub' $P8477 = "659_1304282286.73" 
    $P8475."add_method"($P8476, "package_declarator:sym<module>", $P8477)
    nqp_get_sc_object $P8478, "1304282274.421", 377
    get_how $P8479, $P8478
    nqp_get_sc_object $P8480, "1304282274.421", 377
    .const 'Sub' $P8481 = "660_1304282286.73" 
    $P8479."add_method"($P8480, "package_declarator:sym<knowhow>", $P8481)
    nqp_get_sc_object $P8482, "1304282274.421", 377
    get_how $P8483, $P8482
    nqp_get_sc_object $P8484, "1304282274.421", 377
    .const 'Sub' $P8485 = "661_1304282286.73" 
    $P8483."add_method"($P8484, "package_declarator:sym<class>", $P8485)
    nqp_get_sc_object $P8486, "1304282274.421", 377
    get_how $P8487, $P8486
    nqp_get_sc_object $P8488, "1304282274.421", 377
    .const 'Sub' $P8489 = "662_1304282286.73" 
    $P8487."add_method"($P8488, "package_declarator:sym<grammar>", $P8489)
    nqp_get_sc_object $P8490, "1304282274.421", 377
    get_how $P8491, $P8490
    nqp_get_sc_object $P8492, "1304282274.421", 377
    .const 'Sub' $P8493 = "663_1304282286.73" 
    $P8491."add_method"($P8492, "package_declarator:sym<role>", $P8493)
    nqp_get_sc_object $P8494, "1304282274.421", 377
    get_how $P8495, $P8494
    nqp_get_sc_object $P8496, "1304282274.421", 377
    .const 'Sub' $P8497 = "664_1304282286.73" 
    $P8495."add_method"($P8496, "package_declarator:sym<native>", $P8497)
    nqp_get_sc_object $P8498, "1304282274.421", 377
    get_how $P8499, $P8498
    nqp_get_sc_object $P8500, "1304282274.421", 377
    .const 'Sub' $P8501 = "665_1304282286.73" 
    $P8499."add_method"($P8500, "package_def", $P8501)
    nqp_get_sc_object $P8502, "1304282274.421", 377
    get_how $P8503, $P8502
    nqp_get_sc_object $P8504, "1304282274.421", 377
    .const 'Sub' $P8505 = "671_1304282286.73" 
    $P8503."add_method"($P8504, "scope_declarator:sym<my>", $P8505)
    nqp_get_sc_object $P8506, "1304282274.421", 377
    get_how $P8507, $P8506
    nqp_get_sc_object $P8508, "1304282274.421", 377
    .const 'Sub' $P8509 = "672_1304282286.73" 
    $P8507."add_method"($P8508, "scope_declarator:sym<our>", $P8509)
    nqp_get_sc_object $P8510, "1304282274.421", 377
    get_how $P8511, $P8510
    nqp_get_sc_object $P8512, "1304282274.421", 377
    .const 'Sub' $P8513 = "673_1304282286.73" 
    $P8511."add_method"($P8512, "scope_declarator:sym<has>", $P8513)
    nqp_get_sc_object $P8514, "1304282274.421", 377
    get_how $P8515, $P8514
    nqp_get_sc_object $P8516, "1304282274.421", 377
    .const 'Sub' $P8517 = "674_1304282286.73" 
    $P8515."add_method"($P8516, "scoped", $P8517)
    nqp_get_sc_object $P8518, "1304282274.421", 377
    get_how $P8519, $P8518
    nqp_get_sc_object $P8520, "1304282274.421", 377
    .const 'Sub' $P8521 = "675_1304282286.73" 
    $P8519."add_method"($P8520, "declarator", $P8521)
    nqp_get_sc_object $P8522, "1304282274.421", 377
    get_how $P8523, $P8522
    nqp_get_sc_object $P8524, "1304282274.421", 377
    .const 'Sub' $P8525 = "676_1304282286.73" 
    $P8523."add_method"($P8524, "multi_declarator:sym<multi>", $P8525)
    nqp_get_sc_object $P8526, "1304282274.421", 377
    get_how $P8527, $P8526
    nqp_get_sc_object $P8528, "1304282274.421", 377
    .const 'Sub' $P8529 = "677_1304282286.73" 
    $P8527."add_method"($P8528, "multi_declarator:sym<proto>", $P8529)
    nqp_get_sc_object $P8530, "1304282274.421", 377
    get_how $P8531, $P8530
    nqp_get_sc_object $P8532, "1304282274.421", 377
    .const 'Sub' $P8533 = "678_1304282286.73" 
    $P8531."add_method"($P8532, "multi_declarator:sym<null>", $P8533)
    nqp_get_sc_object $P8534, "1304282274.421", 377
    get_how $P8535, $P8534
    nqp_get_sc_object $P8536, "1304282274.421", 377
    .const 'Sub' $P8537 = "679_1304282286.73" 
    $P8535."add_method"($P8536, "variable_declarator", $P8537)
    nqp_get_sc_object $P8538, "1304282274.421", 377
    get_how $P8539, $P8538
    nqp_get_sc_object $P8540, "1304282274.421", 377
    .const 'Sub' $P8541 = "681_1304282286.73" 
    $P8539."add_method"($P8540, "routine_declarator:sym<sub>", $P8541)
    nqp_get_sc_object $P8542, "1304282274.421", 377
    get_how $P8543, $P8542
    nqp_get_sc_object $P8544, "1304282274.421", 377
    .const 'Sub' $P8545 = "682_1304282286.73" 
    $P8543."add_method"($P8544, "routine_declarator:sym<method>", $P8545)
    nqp_get_sc_object $P8546, "1304282274.421", 377
    get_how $P8547, $P8546
    nqp_get_sc_object $P8548, "1304282274.421", 377
    .const 'Sub' $P8549 = "683_1304282286.73" 
    $P8547."add_method"($P8548, "routine_def", $P8549)
    nqp_get_sc_object $P8550, "1304282274.421", 377
    get_how $P8551, $P8550
    nqp_get_sc_object $P8552, "1304282274.421", 377
    .const 'Sub' $P8553 = "690_1304282286.73" 
    $P8551."add_method"($P8552, "method_def", $P8553)
    nqp_get_sc_object $P8554, "1304282274.421", 377
    get_how $P8555, $P8554
    nqp_get_sc_object $P8556, "1304282274.421", 377
    .const 'Sub' $P8557 = "693_1304282286.73" 
    $P8555."add_method"($P8556, "signature", $P8557)
    nqp_get_sc_object $P8558, "1304282274.421", 377
    get_how $P8559, $P8558
    nqp_get_sc_object $P8560, "1304282274.421", 377
    .const 'Sub' $P8561 = "696_1304282286.73" 
    $P8559."add_method"($P8560, "parameter", $P8561)
    nqp_get_sc_object $P8562, "1304282274.421", 377
    get_how $P8563, $P8562
    nqp_get_sc_object $P8564, "1304282274.421", 377
    .const 'Sub' $P8565 = "697_1304282286.73" 
    $P8563."add_method"($P8564, "param_var", $P8565)
    nqp_get_sc_object $P8566, "1304282274.421", 377
    get_how $P8567, $P8566
    nqp_get_sc_object $P8568, "1304282274.421", 377
    .const 'Sub' $P8569 = "698_1304282286.73" 
    $P8567."add_method"($P8568, "named_param", $P8569)
    nqp_get_sc_object $P8570, "1304282274.421", 377
    get_how $P8571, $P8570
    nqp_get_sc_object $P8572, "1304282274.421", 377
    .const 'Sub' $P8573 = "699_1304282286.73" 
    $P8571."add_method"($P8572, "typename", $P8573)
    nqp_get_sc_object $P8574, "1304282274.421", 377
    get_how $P8575, $P8574
    nqp_get_sc_object $P8576, "1304282274.421", 377
    .const 'Sub' $P8577 = "701_1304282286.73" 
    $P8575."add_method"($P8576, "trait", $P8577)
    nqp_get_sc_object $P8578, "1304282274.421", 377
    get_how $P8579, $P8578
    nqp_get_sc_object $P8580, "1304282274.421", 377
    .const 'Sub' $P8581 = "702_1304282286.73" 
    $P8579."add_method"($P8580, "trait_mod:sym<is>", $P8581)
    nqp_get_sc_object $P8582, "1304282274.421", 377
    get_how $P8583, $P8582
    nqp_get_sc_object $P8584, "1304282274.421", 377
    .const 'Sub' $P8585 = "705_1304282286.73" 
    $P8583."add_method"($P8584, "regex_declarator", $P8585)
    nqp_get_sc_object $P8586, "1304282274.421", 377
    get_how $P8587, $P8586
    nqp_get_sc_object $P8588, "1304282274.421", 377
    .const 'Sub' $P8589 = "710_1304282286.73" 
    $P8587."add_method"($P8588, "dotty", $P8589)
    nqp_get_sc_object $P8590, "1304282274.421", 377
    get_how $P8591, $P8590
    nqp_get_sc_object $P8592, "1304282274.421", 377
    .const 'Sub' $P8593 = "711_1304282286.73" 
    $P8591."add_method"($P8592, "term:sym<self>", $P8593)
    nqp_get_sc_object $P8594, "1304282274.421", 377
    get_how $P8595, $P8594
    nqp_get_sc_object $P8596, "1304282274.421", 377
    .const 'Sub' $P8597 = "712_1304282286.73" 
    $P8595."add_method"($P8596, "term:sym<identifier>", $P8597)
    nqp_get_sc_object $P8598, "1304282274.421", 377
    get_how $P8599, $P8598
    nqp_get_sc_object $P8600, "1304282274.421", 377
    .const 'Sub' $P8601 = "713_1304282286.73" 
    $P8599."add_method"($P8600, "term:sym<name>", $P8601)
    nqp_get_sc_object $P8602, "1304282274.421", 377
    get_how $P8603, $P8602
    nqp_get_sc_object $P8604, "1304282274.421", 377
    .const 'Sub' $P8605 = "715_1304282286.73" 
    $P8603."add_method"($P8604, "term:sym<pir::op>", $P8605)
    nqp_get_sc_object $P8606, "1304282274.421", 377
    get_how $P8607, $P8606
    nqp_get_sc_object $P8608, "1304282274.421", 377
    .const 'Sub' $P8609 = "716_1304282286.73" 
    $P8607."add_method"($P8608, "term:sym<onlystar>", $P8609)
    nqp_get_sc_object $P8610, "1304282274.421", 377
    get_how $P8611, $P8610
    nqp_get_sc_object $P8612, "1304282274.421", 377
    .const 'Sub' $P8613 = "717_1304282286.73" 
    $P8611."add_method"($P8612, "args", $P8613)
    nqp_get_sc_object $P8614, "1304282274.421", 377
    get_how $P8615, $P8614
    nqp_get_sc_object $P8616, "1304282274.421", 377
    .const 'Sub' $P8617 = "718_1304282286.73" 
    $P8615."add_method"($P8616, "arglist", $P8617)
    nqp_get_sc_object $P8618, "1304282274.421", 377
    get_how $P8619, $P8618
    nqp_get_sc_object $P8620, "1304282274.421", 377
    .const 'Sub' $P8621 = "721_1304282286.73" 
    $P8619."add_method"($P8620, "term:sym<multi_declarator>", $P8621)
    nqp_get_sc_object $P8622, "1304282274.421", 377
    get_how $P8623, $P8622
    nqp_get_sc_object $P8624, "1304282274.421", 377
    .const 'Sub' $P8625 = "722_1304282286.73" 
    $P8623."add_method"($P8624, "term:sym<value>", $P8625)
    nqp_get_sc_object $P8626, "1304282274.421", 377
    get_how $P8627, $P8626
    nqp_get_sc_object $P8628, "1304282274.421", 377
    .const 'Sub' $P8629 = "723_1304282286.73" 
    $P8627."add_method"($P8628, "circumfix:sym<( )>", $P8629)
    nqp_get_sc_object $P8630, "1304282274.421", 377
    get_how $P8631, $P8630
    nqp_get_sc_object $P8632, "1304282274.421", 377
    .const 'Sub' $P8633 = "724_1304282286.73" 
    $P8631."add_method"($P8632, "circumfix:sym<[ ]>", $P8633)
    nqp_get_sc_object $P8634, "1304282274.421", 377
    get_how $P8635, $P8634
    nqp_get_sc_object $P8636, "1304282274.421", 377
    .const 'Sub' $P8637 = "725_1304282286.73" 
    $P8635."add_method"($P8636, "circumfix:sym<ang>", $P8637)
    nqp_get_sc_object $P8638, "1304282274.421", 377
    get_how $P8639, $P8638
    nqp_get_sc_object $P8640, "1304282274.421", 377
    .const 'Sub' $P8641 = "726_1304282286.73" 
    $P8639."add_method"($P8640, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8641)
    nqp_get_sc_object $P8642, "1304282274.421", 377
    get_how $P8643, $P8642
    nqp_get_sc_object $P8644, "1304282274.421", 377
    .const 'Sub' $P8645 = "727_1304282286.73" 
    $P8643."add_method"($P8644, "circumfix:sym<{ }>", $P8645)
    nqp_get_sc_object $P8646, "1304282274.421", 377
    get_how $P8647, $P8646
    nqp_get_sc_object $P8648, "1304282274.421", 377
    .const 'Sub' $P8649 = "729_1304282286.73" 
    $P8647."add_method"($P8648, "circumfix:sym<sigil>", $P8649)
    nqp_get_sc_object $P8650, "1304282274.421", 377
    get_how $P8651, $P8650
    nqp_get_sc_object $P8652, "1304282274.421", 377
    .const 'Sub' $P8653 = "730_1304282286.73" 
    $P8651."add_method"($P8652, "semilist", $P8653)
    nqp_get_sc_object $P8654, "1304282274.421", 377
    get_how $P8655, $P8654
    nqp_get_sc_object $P8656, "1304282274.421", 377
    .const 'Sub' $P8657 = "731_1304282286.73" 
    $P8655."add_method"($P8656, "postcircumfix:sym<[ ]>", $P8657)
    nqp_get_sc_object $P8658, "1304282274.421", 377
    get_how $P8659, $P8658
    nqp_get_sc_object $P8660, "1304282274.421", 377
    .const 'Sub' $P8661 = "732_1304282286.73" 
    $P8659."add_method"($P8660, "postcircumfix:sym<{ }>", $P8661)
    nqp_get_sc_object $P8662, "1304282274.421", 377
    get_how $P8663, $P8662
    nqp_get_sc_object $P8664, "1304282274.421", 377
    .const 'Sub' $P8665 = "733_1304282286.73" 
    $P8663."add_method"($P8664, "postcircumfix:sym<ang>", $P8665)
    nqp_get_sc_object $P8666, "1304282274.421", 377
    get_how $P8667, $P8666
    nqp_get_sc_object $P8668, "1304282274.421", 377
    .const 'Sub' $P8669 = "734_1304282286.73" 
    $P8667."add_method"($P8668, "postcircumfix:sym<( )>", $P8669)
    nqp_get_sc_object $P8670, "1304282274.421", 377
    get_how $P8671, $P8670
    nqp_get_sc_object $P8672, "1304282274.421", 377
    .const 'Sub' $P8673 = "735_1304282286.73" 
    $P8671."add_method"($P8672, "value", $P8673)
    nqp_get_sc_object $P8674, "1304282274.421", 377
    get_how $P8675, $P8674
    nqp_get_sc_object $P8676, "1304282274.421", 377
    .const 'Sub' $P8677 = "736_1304282286.73" 
    $P8675."add_method"($P8676, "number", $P8677)
    nqp_get_sc_object $P8678, "1304282274.421", 377
    get_how $P8679, $P8678
    nqp_get_sc_object $P8680, "1304282274.421", 377
    .const 'Sub' $P8681 = "737_1304282286.73" 
    $P8679."add_method"($P8680, "quote:sym<apos>", $P8681)
    nqp_get_sc_object $P8682, "1304282274.421", 377
    get_how $P8683, $P8682
    nqp_get_sc_object $P8684, "1304282274.421", 377
    .const 'Sub' $P8685 = "738_1304282286.73" 
    $P8683."add_method"($P8684, "quote:sym<dblq>", $P8685)
    nqp_get_sc_object $P8686, "1304282274.421", 377
    get_how $P8687, $P8686
    nqp_get_sc_object $P8688, "1304282274.421", 377
    .const 'Sub' $P8689 = "739_1304282286.73" 
    $P8687."add_method"($P8688, "quote:sym<qq>", $P8689)
    nqp_get_sc_object $P8690, "1304282274.421", 377
    get_how $P8691, $P8690
    nqp_get_sc_object $P8692, "1304282274.421", 377
    .const 'Sub' $P8693 = "740_1304282286.73" 
    $P8691."add_method"($P8692, "quote:sym<q>", $P8693)
    nqp_get_sc_object $P8694, "1304282274.421", 377
    get_how $P8695, $P8694
    nqp_get_sc_object $P8696, "1304282274.421", 377
    .const 'Sub' $P8697 = "741_1304282286.73" 
    $P8695."add_method"($P8696, "quote:sym<Q>", $P8697)
    nqp_get_sc_object $P8698, "1304282274.421", 377
    get_how $P8699, $P8698
    nqp_get_sc_object $P8700, "1304282274.421", 377
    .const 'Sub' $P8701 = "742_1304282286.73" 
    $P8699."add_method"($P8700, "quote:sym<Q:PIR>", $P8701)
    nqp_get_sc_object $P8702, "1304282274.421", 377
    get_how $P8703, $P8702
    nqp_get_sc_object $P8704, "1304282274.421", 377
    .const 'Sub' $P8705 = "743_1304282286.73" 
    $P8703."add_method"($P8704, "quote:sym</ />", $P8705)
    nqp_get_sc_object $P8706, "1304282274.421", 377
    get_how $P8707, $P8706
    nqp_get_sc_object $P8708, "1304282274.421", 377
    .const 'Sub' $P8709 = "744_1304282286.73" 
    $P8707."add_method"($P8708, "quote_escape:sym<$>", $P8709)
    nqp_get_sc_object $P8710, "1304282274.421", 377
    get_how $P8711, $P8710
    nqp_get_sc_object $P8712, "1304282274.421", 377
    .const 'Sub' $P8713 = "745_1304282286.73" 
    $P8711."add_method"($P8712, "quote_escape:sym<{ }>", $P8713)
    nqp_get_sc_object $P8714, "1304282274.421", 377
    get_how $P8715, $P8714
    nqp_get_sc_object $P8716, "1304282274.421", 377
    .const 'Sub' $P8717 = "746_1304282286.73" 
    $P8715."add_method"($P8716, "quote_escape:sym<esc>", $P8717)
    nqp_get_sc_object $P8718, "1304282274.421", 377
    get_how $P8719, $P8718
    nqp_get_sc_object $P8720, "1304282274.421", 377
    .const 'Sub' $P8721 = "747_1304282286.73" 
    $P8719."add_method"($P8720, "postfix:sym<.>", $P8721)
    nqp_get_sc_object $P8722, "1304282274.421", 377
    get_how $P8723, $P8722
    nqp_get_sc_object $P8724, "1304282274.421", 377
    .const 'Sub' $P8725 = "748_1304282286.73" 
    $P8723."add_method"($P8724, "postfix:sym<++>", $P8725)
    nqp_get_sc_object $P8726, "1304282274.421", 377
    get_how $P8727, $P8726
    nqp_get_sc_object $P8728, "1304282274.421", 377
    .const 'Sub' $P8729 = "749_1304282286.73" 
    $P8727."add_method"($P8728, "postfix:sym<-->", $P8729)
    nqp_get_sc_object $P8730, "1304282274.421", 377
    get_how $P8731, $P8730
    nqp_get_sc_object $P8732, "1304282274.421", 377
    .const 'Sub' $P8733 = "750_1304282286.73" 
    $P8731."add_method"($P8732, "prefix:sym<make>", $P8733)
    nqp_get_sc_object $P8734, "1304282274.421", 377
    get_how $P8735, $P8734
    nqp_get_sc_object $P8736, "1304282274.421", 377
    .const 'Sub' $P8737 = "751_1304282286.73" 
    $P8735."add_method"($P8736, "term:sym<next>", $P8737)
    nqp_get_sc_object $P8738, "1304282274.421", 377
    get_how $P8739, $P8738
    nqp_get_sc_object $P8740, "1304282274.421", 377
    .const 'Sub' $P8741 = "752_1304282286.73" 
    $P8739."add_method"($P8740, "term:sym<last>", $P8741)
    nqp_get_sc_object $P8742, "1304282274.421", 377
    get_how $P8743, $P8742
    nqp_get_sc_object $P8744, "1304282274.421", 377
    .const 'Sub' $P8745 = "753_1304282286.73" 
    $P8743."add_method"($P8744, "term:sym<redo>", $P8745)
    nqp_get_sc_object $P8746, "1304282274.421", 377
    get_how $P8747, $P8746
    nqp_get_sc_object $P8748, "1304282274.421", 377
    .const 'Sub' $P8749 = "754_1304282286.73" 
    $P8747."add_method"($P8748, "infix:sym<~~>", $P8749)
    nqp_get_sc_object $P8750, "1304282274.421", 377
    get_how $P8751, $P8750
    nqp_get_sc_object $P8752, "1304282274.421", 377
    .const 'Sub' $P8753 = "755_1304282286.73" 
    $P8751."add_method"($P8752, "known_sym", $P8753)
    .const 'Sub' $P8754 = "582_1304282286.73" 
    $P8755 = $P8754."get_lexinfo"()
    nqp_get_sc_object $P8756, "1304282274.421", 377
    $P8755."set_static_lexpad_value"("$?PACKAGE", $P8756)
    .const 'Sub' $P8757 = "582_1304282286.73" 
    $P8758 = $P8757."get_lexinfo"()
    $P8758."finish_static_lexpad"()
    .const 'Sub' $P8759 = "582_1304282286.73" 
    $P8760 = $P8759."get_lexinfo"()
    nqp_get_sc_object $P8761, "1304282274.421", 377
    $P8760."set_static_lexpad_value"("$?CLASS", $P8761)
    .const 'Sub' $P8762 = "582_1304282286.73" 
    $P8763 = $P8762."get_lexinfo"()
    $P8763."finish_static_lexpad"()
    nqp_get_sc_object $P8764, "1304282274.421", 377
    get_how $P8765, $P8764
    nqp_get_sc_object $P8766, "1304282274.421", 377
    nqp_get_sc_object $P8767, "1304282255.673", 105
    $P8765."add_parent"($P8766, $P8767)
    nqp_get_sc_object $P8768, "1304282248.255", 41
    $P8769 = $P8768."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P8769, cur_sc
    nqp_set_sc_object "1304282274.421", 488, $P8769
    nqp_get_sc_object $P8770, "1304282274.421", 488
    nqp_get_sc_object $P8771, "1304282274.421", 0
    nqp_get_package_through_who $P8772, $P8771, "NQP"
    get_who $P8773, $P8772
    set $P8773["RegexActions"], $P8770
    nqp_get_sc_object $P8774, "1304282274.421", 488
    get_how $P8775, $P8774
    nqp_get_sc_object $P8776, "1304282274.421", 488
    .const 'Sub' $P8777 = "759_1304282286.73" 
    $P8775."add_method"($P8776, "metachar:sym<:my>", $P8777)
    nqp_get_sc_object $P8778, "1304282274.421", 488
    get_how $P8779, $P8778
    nqp_get_sc_object $P8780, "1304282274.421", 488
    .const 'Sub' $P8781 = "760_1304282286.73" 
    $P8779."add_method"($P8780, "metachar:sym<{ }>", $P8781)
    nqp_get_sc_object $P8782, "1304282274.421", 488
    get_how $P8783, $P8782
    nqp_get_sc_object $P8784, "1304282274.421", 488
    .const 'Sub' $P8785 = "761_1304282286.73" 
    $P8783."add_method"($P8784, "metachar:sym<nqpvar>", $P8785)
    nqp_get_sc_object $P8786, "1304282274.421", 488
    get_how $P8787, $P8786
    nqp_get_sc_object $P8788, "1304282274.421", 488
    .const 'Sub' $P8789 = "762_1304282286.73" 
    $P8787."add_method"($P8788, "assertion:sym<{ }>", $P8789)
    nqp_get_sc_object $P8790, "1304282274.421", 488
    get_how $P8791, $P8790
    nqp_get_sc_object $P8792, "1304282274.421", 488
    .const 'Sub' $P8793 = "763_1304282286.73" 
    $P8791."add_method"($P8792, "assertion:sym<?{ }>", $P8793)
    nqp_get_sc_object $P8794, "1304282274.421", 488
    get_how $P8795, $P8794
    nqp_get_sc_object $P8796, "1304282274.421", 488
    .const 'Sub' $P8797 = "764_1304282286.73" 
    $P8795."add_method"($P8796, "assertion:sym<var>", $P8797)
    nqp_get_sc_object $P8798, "1304282274.421", 488
    get_how $P8799, $P8798
    nqp_get_sc_object $P8800, "1304282274.421", 488
    .const 'Sub' $P8801 = "765_1304282286.73" 
    $P8799."add_method"($P8800, "codeblock", $P8801)
    .const 'Sub' $P8802 = "758_1304282286.73" 
    $P8803 = $P8802."get_lexinfo"()
    nqp_get_sc_object $P8804, "1304282274.421", 488
    $P8803."set_static_lexpad_value"("$?PACKAGE", $P8804)
    .const 'Sub' $P8805 = "758_1304282286.73" 
    $P8806 = $P8805."get_lexinfo"()
    $P8806."finish_static_lexpad"()
    .const 'Sub' $P8807 = "758_1304282286.73" 
    $P8808 = $P8807."get_lexinfo"()
    nqp_get_sc_object $P8809, "1304282274.421", 488
    $P8808."set_static_lexpad_value"("$?CLASS", $P8809)
    .const 'Sub' $P8810 = "758_1304282286.73" 
    $P8811 = $P8810."get_lexinfo"()
    $P8811."finish_static_lexpad"()
    nqp_get_sc_object $P8812, "1304282274.421", 488
    get_how $P8813, $P8812
    nqp_get_sc_object $P8814, "1304282274.421", 488
    nqp_get_sc_object $P8815, "1304282267.413", 145
    $P8813."add_parent"($P8814, $P8815)
    nqp_get_sc_object $P8816, "1304282248.255", 41
    $P8817 = $P8816."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P8817, cur_sc
    nqp_set_sc_object "1304282274.421", 496, $P8817
    nqp_get_sc_object $P8818, "1304282274.421", 496
    nqp_get_sc_object $P8819, "1304282274.421", 0
    nqp_get_package_through_who $P8820, $P8819, "NQP"
    get_who $P8821, $P8820
    set $P8821["Compiler"], $P8818
    .const 'Sub' $P8822 = "767_1304282286.73" 
    $P8823 = $P8822."get_lexinfo"()
    nqp_get_sc_object $P8824, "1304282274.421", 496
    $P8823."set_static_lexpad_value"("$?PACKAGE", $P8824)
    .const 'Sub' $P8825 = "767_1304282286.73" 
    $P8826 = $P8825."get_lexinfo"()
    $P8826."finish_static_lexpad"()
    .const 'Sub' $P8827 = "767_1304282286.73" 
    $P8828 = $P8827."get_lexinfo"()
    nqp_get_sc_object $P8829, "1304282274.421", 496
    $P8828."set_static_lexpad_value"("$?CLASS", $P8829)
    .const 'Sub' $P8830 = "767_1304282286.73" 
    $P8831 = $P8830."get_lexinfo"()
    $P8831."finish_static_lexpad"()
    nqp_get_sc_object $P8832, "1304282274.421", 496
    get_how $P8833, $P8832
    nqp_get_sc_object $P8834, "1304282274.421", 496
    nqp_get_sc_object $P8835, "1304282255.673", 138
    $P8833."add_parent"($P8834, $P8835)
  if_6747_end:
    nqp_get_sc_object $P9878, "1304282274.421", 0
    set_hll_global "GLOBAL", $P9878
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1304282286.73") :outer("10_1304282286.73")
    .param pmc param_17
.annotate 'line', 2292
    .lex "@ARGS", param_17
.annotate 'line', 2294
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2300
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2294
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2295
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_771
    new $P25, "Undef"
  vivify_771:
    $P25."language"("nqp")
.annotate 'line', 2296
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_772
    new $P26, "Undef"
  vivify_772:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2297
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_773
    new $P31, "Undef"
  vivify_773:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2300
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_774
    new $P36, "Undef"
  vivify_774:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2301
    find_lex $P38, "@clo"
    unless_null $P38, vivify_775
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_775:
    $P38."push"("parsetrace")
.annotate 'line', 2302
    find_lex $P39, "@clo"
    unless_null $P39, vivify_776
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_776:
    $P39."push"("setting=s")
.annotate 'line', 2303
    find_lex $P40, "@clo"
    unless_null $P40, vivify_777
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_777:
    $P40."push"("setting-path=s")
.annotate 'line', 2304
    find_lex $P41, "@clo"
    unless_null $P41, vivify_778
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_778:
    $P41."push"("module-path=s")
.annotate 'line', 2307
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_779
    new $P42, "Undef"
  vivify_779:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_780
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_780:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2292
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1304282286.73") :outer("10_1304282286.73")
.annotate 'line', 9
    .const 'Sub' $P2404 = "551_1304282286.73" 
    capture_lex $P2404
    .const 'Sub' $P2391 = "550_1304282286.73" 
    capture_lex $P2391
    .const 'Sub' $P2389 = "549_1304282286.73" 
    capture_lex $P2389
    .const 'Sub' $P2383 = "547_1304282286.73" 
    capture_lex $P2383
    .const 'Sub' $P2381 = "546_1304282286.73" 
    capture_lex $P2381
    .const 'Sub' $P2375 = "544_1304282286.73" 
    capture_lex $P2375
    .const 'Sub' $P2373 = "543_1304282286.73" 
    capture_lex $P2373
    .const 'Sub' $P2367 = "541_1304282286.73" 
    capture_lex $P2367
    .const 'Sub' $P2365 = "540_1304282286.73" 
    capture_lex $P2365
    .const 'Sub' $P2359 = "538_1304282286.73" 
    capture_lex $P2359
    .const 'Sub' $P2357 = "537_1304282286.73" 
    capture_lex $P2357
    .const 'Sub' $P2345 = "534_1304282286.73" 
    capture_lex $P2345
    .const 'Sub' $P2342 = "533_1304282286.73" 
    capture_lex $P2342
    .const 'Sub' $P2335 = "531_1304282286.73" 
    capture_lex $P2335
    .const 'Sub' $P2332 = "530_1304282286.73" 
    capture_lex $P2332
    .const 'Sub' $P2325 = "528_1304282286.73" 
    capture_lex $P2325
    .const 'Sub' $P2322 = "527_1304282286.73" 
    capture_lex $P2322
    .const 'Sub' $P2315 = "525_1304282286.73" 
    capture_lex $P2315
    .const 'Sub' $P2312 = "524_1304282286.73" 
    capture_lex $P2312
    .const 'Sub' $P2305 = "522_1304282286.73" 
    capture_lex $P2305
    .const 'Sub' $P2302 = "521_1304282286.73" 
    capture_lex $P2302
    .const 'Sub' $P2296 = "519_1304282286.73" 
    capture_lex $P2296
    .const 'Sub' $P2293 = "518_1304282286.73" 
    capture_lex $P2293
    .const 'Sub' $P2286 = "516_1304282286.73" 
    capture_lex $P2286
    .const 'Sub' $P2283 = "515_1304282286.73" 
    capture_lex $P2283
    .const 'Sub' $P2276 = "513_1304282286.73" 
    capture_lex $P2276
    .const 'Sub' $P2273 = "512_1304282286.73" 
    capture_lex $P2273
    .const 'Sub' $P2266 = "510_1304282286.73" 
    capture_lex $P2266
    .const 'Sub' $P2263 = "509_1304282286.73" 
    capture_lex $P2263
    .const 'Sub' $P2256 = "507_1304282286.73" 
    capture_lex $P2256
    .const 'Sub' $P2253 = "506_1304282286.73" 
    capture_lex $P2253
    .const 'Sub' $P2246 = "504_1304282286.73" 
    capture_lex $P2246
    .const 'Sub' $P2243 = "503_1304282286.73" 
    capture_lex $P2243
    .const 'Sub' $P2236 = "501_1304282286.73" 
    capture_lex $P2236
    .const 'Sub' $P2233 = "500_1304282286.73" 
    capture_lex $P2233
    .const 'Sub' $P2226 = "498_1304282286.73" 
    capture_lex $P2226
    .const 'Sub' $P2223 = "497_1304282286.73" 
    capture_lex $P2223
    .const 'Sub' $P2216 = "495_1304282286.73" 
    capture_lex $P2216
    .const 'Sub' $P2213 = "494_1304282286.73" 
    capture_lex $P2213
    .const 'Sub' $P2206 = "492_1304282286.73" 
    capture_lex $P2206
    .const 'Sub' $P2203 = "491_1304282286.73" 
    capture_lex $P2203
    .const 'Sub' $P2196 = "489_1304282286.73" 
    capture_lex $P2196
    .const 'Sub' $P2193 = "488_1304282286.73" 
    capture_lex $P2193
    .const 'Sub' $P2186 = "486_1304282286.73" 
    capture_lex $P2186
    .const 'Sub' $P2183 = "485_1304282286.73" 
    capture_lex $P2183
    .const 'Sub' $P2176 = "483_1304282286.73" 
    capture_lex $P2176
    .const 'Sub' $P2173 = "482_1304282286.73" 
    capture_lex $P2173
    .const 'Sub' $P2166 = "480_1304282286.73" 
    capture_lex $P2166
    .const 'Sub' $P2163 = "479_1304282286.73" 
    capture_lex $P2163
    .const 'Sub' $P2156 = "477_1304282286.73" 
    capture_lex $P2156
    .const 'Sub' $P2153 = "476_1304282286.73" 
    capture_lex $P2153
    .const 'Sub' $P2146 = "474_1304282286.73" 
    capture_lex $P2146
    .const 'Sub' $P2143 = "473_1304282286.73" 
    capture_lex $P2143
    .const 'Sub' $P2136 = "471_1304282286.73" 
    capture_lex $P2136
    .const 'Sub' $P2133 = "470_1304282286.73" 
    capture_lex $P2133
    .const 'Sub' $P2126 = "468_1304282286.73" 
    capture_lex $P2126
    .const 'Sub' $P2123 = "467_1304282286.73" 
    capture_lex $P2123
    .const 'Sub' $P2116 = "465_1304282286.73" 
    capture_lex $P2116
    .const 'Sub' $P2113 = "464_1304282286.73" 
    capture_lex $P2113
    .const 'Sub' $P2106 = "462_1304282286.73" 
    capture_lex $P2106
    .const 'Sub' $P2103 = "461_1304282286.73" 
    capture_lex $P2103
    .const 'Sub' $P2096 = "459_1304282286.73" 
    capture_lex $P2096
    .const 'Sub' $P2093 = "458_1304282286.73" 
    capture_lex $P2093
    .const 'Sub' $P2086 = "456_1304282286.73" 
    capture_lex $P2086
    .const 'Sub' $P2083 = "455_1304282286.73" 
    capture_lex $P2083
    .const 'Sub' $P2076 = "453_1304282286.73" 
    capture_lex $P2076
    .const 'Sub' $P2073 = "452_1304282286.73" 
    capture_lex $P2073
    .const 'Sub' $P2066 = "450_1304282286.73" 
    capture_lex $P2066
    .const 'Sub' $P2063 = "449_1304282286.73" 
    capture_lex $P2063
    .const 'Sub' $P2056 = "447_1304282286.73" 
    capture_lex $P2056
    .const 'Sub' $P2053 = "446_1304282286.73" 
    capture_lex $P2053
    .const 'Sub' $P2046 = "444_1304282286.73" 
    capture_lex $P2046
    .const 'Sub' $P2043 = "443_1304282286.73" 
    capture_lex $P2043
    .const 'Sub' $P2036 = "441_1304282286.73" 
    capture_lex $P2036
    .const 'Sub' $P2033 = "440_1304282286.73" 
    capture_lex $P2033
    .const 'Sub' $P2026 = "438_1304282286.73" 
    capture_lex $P2026
    .const 'Sub' $P2023 = "437_1304282286.73" 
    capture_lex $P2023
    .const 'Sub' $P2016 = "435_1304282286.73" 
    capture_lex $P2016
    .const 'Sub' $P2013 = "434_1304282286.73" 
    capture_lex $P2013
    .const 'Sub' $P2006 = "432_1304282286.73" 
    capture_lex $P2006
    .const 'Sub' $P2004 = "431_1304282286.73" 
    capture_lex $P2004
    .const 'Sub' $P1998 = "429_1304282286.73" 
    capture_lex $P1998
    .const 'Sub' $P1995 = "428_1304282286.73" 
    capture_lex $P1995
    .const 'Sub' $P1988 = "426_1304282286.73" 
    capture_lex $P1988
    .const 'Sub' $P1985 = "425_1304282286.73" 
    capture_lex $P1985
    .const 'Sub' $P1978 = "423_1304282286.73" 
    capture_lex $P1978
    .const 'Sub' $P1975 = "422_1304282286.73" 
    capture_lex $P1975
    .const 'Sub' $P1968 = "420_1304282286.73" 
    capture_lex $P1968
    .const 'Sub' $P1965 = "419_1304282286.73" 
    capture_lex $P1965
    .const 'Sub' $P1958 = "417_1304282286.73" 
    capture_lex $P1958
    .const 'Sub' $P1955 = "416_1304282286.73" 
    capture_lex $P1955
    .const 'Sub' $P1948 = "414_1304282286.73" 
    capture_lex $P1948
    .const 'Sub' $P1945 = "413_1304282286.73" 
    capture_lex $P1945
    .const 'Sub' $P1938 = "411_1304282286.73" 
    capture_lex $P1938
    .const 'Sub' $P1935 = "410_1304282286.73" 
    capture_lex $P1935
    .const 'Sub' $P1928 = "408_1304282286.73" 
    capture_lex $P1928
    .const 'Sub' $P1925 = "407_1304282286.73" 
    capture_lex $P1925
    .const 'Sub' $P1919 = "405_1304282286.73" 
    capture_lex $P1919
    .const 'Sub' $P1916 = "404_1304282286.73" 
    capture_lex $P1916
    .const 'Sub' $P1910 = "402_1304282286.73" 
    capture_lex $P1910
    .const 'Sub' $P1908 = "401_1304282286.73" 
    capture_lex $P1908
    .const 'Sub' $P1903 = "399_1304282286.73" 
    capture_lex $P1903
    .const 'Sub' $P1900 = "398_1304282286.73" 
    capture_lex $P1900
    .const 'Sub' $P1894 = "396_1304282286.73" 
    capture_lex $P1894
    .const 'Sub' $P1891 = "395_1304282286.73" 
    capture_lex $P1891
    .const 'Sub' $P1885 = "393_1304282286.73" 
    capture_lex $P1885
    .const 'Sub' $P1883 = "392_1304282286.73" 
    capture_lex $P1883
    .const 'Sub' $P1878 = "390_1304282286.73" 
    capture_lex $P1878
    .const 'Sub' $P1876 = "389_1304282286.73" 
    capture_lex $P1876
    .const 'Sub' $P1871 = "387_1304282286.73" 
    capture_lex $P1871
    .const 'Sub' $P1868 = "386_1304282286.73" 
    capture_lex $P1868
    .const 'Sub' $P1860 = "384_1304282286.73" 
    capture_lex $P1860
    .const 'Sub' $P1857 = "383_1304282286.73" 
    capture_lex $P1857
    .const 'Sub' $P1848 = "381_1304282286.73" 
    capture_lex $P1848
    .const 'Sub' $P1846 = "380_1304282286.73" 
    capture_lex $P1846
    .const 'Sub' $P1841 = "378_1304282286.73" 
    capture_lex $P1841
    .const 'Sub' $P1839 = "377_1304282286.73" 
    capture_lex $P1839
    .const 'Sub' $P1834 = "375_1304282286.73" 
    capture_lex $P1834
    .const 'Sub' $P1832 = "374_1304282286.73" 
    capture_lex $P1832
    .const 'Sub' $P1827 = "372_1304282286.73" 
    capture_lex $P1827
    .const 'Sub' $P1824 = "371_1304282286.73" 
    capture_lex $P1824
    .const 'Sub' $P1816 = "369_1304282286.73" 
    capture_lex $P1816
    .const 'Sub' $P1813 = "368_1304282286.73" 
    capture_lex $P1813
    .const 'Sub' $P1805 = "366_1304282286.73" 
    capture_lex $P1805
    .const 'Sub' $P1803 = "365_1304282286.73" 
    capture_lex $P1803
    .const 'Sub' $P1798 = "363_1304282286.73" 
    capture_lex $P1798
    .const 'Sub' $P1796 = "362_1304282286.73" 
    capture_lex $P1796
    .const 'Sub' $P1791 = "360_1304282286.73" 
    capture_lex $P1791
    .const 'Sub' $P1789 = "359_1304282286.73" 
    capture_lex $P1789
    .const 'Sub' $P1784 = "357_1304282286.73" 
    capture_lex $P1784
    .const 'Sub' $P1781 = "356_1304282286.73" 
    capture_lex $P1781
    .const 'Sub' $P1775 = "354_1304282286.73" 
    capture_lex $P1775
    .const 'Sub' $P1772 = "353_1304282286.73" 
    capture_lex $P1772
    .const 'Sub' $P1765 = "351_1304282286.73" 
    capture_lex $P1765
    .const 'Sub' $P1762 = "350_1304282286.73" 
    capture_lex $P1762
    .const 'Sub' $P1755 = "348_1304282286.73" 
    capture_lex $P1755
    .const 'Sub' $P1752 = "347_1304282286.73" 
    capture_lex $P1752
    .const 'Sub' $P1745 = "345_1304282286.73" 
    capture_lex $P1745
    .const 'Sub' $P1742 = "344_1304282286.73" 
    capture_lex $P1742
    .const 'Sub' $P1735 = "342_1304282286.73" 
    capture_lex $P1735
    .const 'Sub' $P1733 = "341_1304282286.73" 
    capture_lex $P1733
    .const 'Sub' $P1728 = "339_1304282286.73" 
    capture_lex $P1728
    .const 'Sub' $P1726 = "338_1304282286.73" 
    capture_lex $P1726
    .const 'Sub' $P1721 = "336_1304282286.73" 
    capture_lex $P1721
    .const 'Sub' $P1713 = "333_1304282286.73" 
    capture_lex $P1713
    .const 'Sub' $P1705 = "331_1304282286.73" 
    capture_lex $P1705
    .const 'Sub' $P1701 = "330_1304282286.73" 
    capture_lex $P1701
    .const 'Sub' $P1693 = "328_1304282286.73" 
    capture_lex $P1693
    .const 'Sub' $P1690 = "327_1304282286.73" 
    capture_lex $P1690
    .const 'Sub' $P1684 = "325_1304282286.73" 
    capture_lex $P1684
    .const 'Sub' $P1681 = "324_1304282286.73" 
    capture_lex $P1681
    .const 'Sub' $P1674 = "322_1304282286.73" 
    capture_lex $P1674
    .const 'Sub' $P1671 = "321_1304282286.73" 
    capture_lex $P1671
    .const 'Sub' $P1665 = "319_1304282286.73" 
    capture_lex $P1665
    .const 'Sub' $P1663 = "318_1304282286.73" 
    capture_lex $P1663
    .const 'Sub' $P1647 = "315_1304282286.73" 
    capture_lex $P1647
    .const 'Sub' $P1645 = "314_1304282286.73" 
    capture_lex $P1645
    .const 'Sub' $P1637 = "312_1304282286.73" 
    capture_lex $P1637
    .const 'Sub' $P1634 = "311_1304282286.73" 
    capture_lex $P1634
    .const 'Sub' $P1626 = "309_1304282286.73" 
    capture_lex $P1626
    .const 'Sub' $P1623 = "308_1304282286.73" 
    capture_lex $P1623
    .const 'Sub' $P1617 = "306_1304282286.73" 
    capture_lex $P1617
    .const 'Sub' $P1615 = "305_1304282286.73" 
    capture_lex $P1615
    .const 'Sub' $P1609 = "303_1304282286.73" 
    capture_lex $P1609
    .const 'Sub' $P1600 = "300_1304282286.73" 
    capture_lex $P1600
    .const 'Sub' $P1590 = "298_1304282286.73" 
    capture_lex $P1590
    .const 'Sub' $P1587 = "297_1304282286.73" 
    capture_lex $P1587
    .const 'Sub' $P1546 = "295_1304282286.73" 
    capture_lex $P1546
    .const 'Sub' $P1543 = "294_1304282286.73" 
    capture_lex $P1543
    .const 'Sub' $P1532 = "292_1304282286.73" 
    capture_lex $P1532
    .const 'Sub' $P1523 = "289_1304282286.73" 
    capture_lex $P1523
    .const 'Sub' $P1515 = "287_1304282286.73" 
    capture_lex $P1515
    .const 'Sub' $P1512 = "286_1304282286.73" 
    capture_lex $P1512
    .const 'Sub' $P1503 = "284_1304282286.73" 
    capture_lex $P1503
    .const 'Sub' $P1500 = "283_1304282286.73" 
    capture_lex $P1500
    .const 'Sub' $P1494 = "281_1304282286.73" 
    capture_lex $P1494
    .const 'Sub' $P1491 = "280_1304282286.73" 
    capture_lex $P1491
    .const 'Sub' $P1481 = "278_1304282286.73" 
    capture_lex $P1481
    .const 'Sub' $P1479 = "277_1304282286.73" 
    capture_lex $P1479
    .const 'Sub' $P1464 = "275_1304282286.73" 
    capture_lex $P1464
    .const 'Sub' $P1462 = "274_1304282286.73" 
    capture_lex $P1462
    .const 'Sub' $P1446 = "271_1304282286.73" 
    capture_lex $P1446
    .const 'Sub' $P1443 = "270_1304282286.73" 
    capture_lex $P1443
    .const 'Sub' $P1435 = "268_1304282286.73" 
    capture_lex $P1435
    .const 'Sub' $P1432 = "267_1304282286.73" 
    capture_lex $P1432
    .const 'Sub' $P1422 = "265_1304282286.73" 
    capture_lex $P1422
    .const 'Sub' $P1419 = "264_1304282286.73" 
    capture_lex $P1419
    .const 'Sub' $P1409 = "262_1304282286.73" 
    capture_lex $P1409
    .const 'Sub' $P1401 = "259_1304282286.73" 
    capture_lex $P1401
    .const 'Sub' $P1386 = "256_1304282286.73" 
    capture_lex $P1386
    .const 'Sub' $P1383 = "255_1304282286.73" 
    capture_lex $P1383
    .const 'Sub' $P1339 = "252_1304282286.73" 
    capture_lex $P1339
    .const 'Sub' $P1336 = "251_1304282286.73" 
    capture_lex $P1336
    .const 'Sub' $P1302 = "249_1304282286.73" 
    capture_lex $P1302
    .const 'Sub' $P1299 = "248_1304282286.73" 
    capture_lex $P1299
    .const 'Sub' $P1292 = "246_1304282286.73" 
    capture_lex $P1292
    .const 'Sub' $P1289 = "245_1304282286.73" 
    capture_lex $P1289
    .const 'Sub' $P1282 = "243_1304282286.73" 
    capture_lex $P1282
    .const 'Sub' $P1273 = "240_1304282286.73" 
    capture_lex $P1273
    .const 'Sub' $P1252 = "237_1304282286.73" 
    capture_lex $P1252
    .const 'Sub' $P1248 = "236_1304282286.73" 
    capture_lex $P1248
    .const 'Sub' $P1240 = "234_1304282286.73" 
    capture_lex $P1240
    .const 'Sub' $P1237 = "233_1304282286.73" 
    capture_lex $P1237
    .const 'Sub' $P1218 = "230_1304282286.73" 
    capture_lex $P1218
    .const 'Sub' $P1213 = "229_1304282286.73" 
    capture_lex $P1213
    .const 'Sub' $P1197 = "227_1304282286.73" 
    capture_lex $P1197
    .const 'Sub' $P1194 = "226_1304282286.73" 
    capture_lex $P1194
    .const 'Sub' $P1187 = "224_1304282286.73" 
    capture_lex $P1187
    .const 'Sub' $P1184 = "223_1304282286.73" 
    capture_lex $P1184
    .const 'Sub' $P1177 = "221_1304282286.73" 
    capture_lex $P1177
    .const 'Sub' $P1174 = "220_1304282286.73" 
    capture_lex $P1174
    .const 'Sub' $P1167 = "218_1304282286.73" 
    capture_lex $P1167
    .const 'Sub' $P1158 = "215_1304282286.73" 
    capture_lex $P1158
    .const 'Sub' $P986 = "212_1304282286.73" 
    capture_lex $P986
    .const 'Sub' $P983 = "211_1304282286.73" 
    capture_lex $P983
    .const 'Sub' $P964 = "209_1304282286.73" 
    capture_lex $P964
    .const 'Sub' $P961 = "208_1304282286.73" 
    capture_lex $P961
    .const 'Sub' $P942 = "206_1304282286.73" 
    capture_lex $P942
    .const 'Sub' $P939 = "205_1304282286.73" 
    capture_lex $P939
    .const 'Sub' $P920 = "203_1304282286.73" 
    capture_lex $P920
    .const 'Sub' $P917 = "202_1304282286.73" 
    capture_lex $P917
    .const 'Sub' $P898 = "200_1304282286.73" 
    capture_lex $P898
    .const 'Sub' $P895 = "199_1304282286.73" 
    capture_lex $P895
    .const 'Sub' $P876 = "197_1304282286.73" 
    capture_lex $P876
    .const 'Sub' $P873 = "196_1304282286.73" 
    capture_lex $P873
    .const 'Sub' $P854 = "194_1304282286.73" 
    capture_lex $P854
    .const 'Sub' $P846 = "191_1304282286.73" 
    capture_lex $P846
    .const 'Sub' $P841 = "189_1304282286.73" 
    capture_lex $P841
    .const 'Sub' $P839 = "188_1304282286.73" 
    capture_lex $P839
    .const 'Sub' $P834 = "186_1304282286.73" 
    capture_lex $P834
    .const 'Sub' $P830 = "185_1304282286.73" 
    capture_lex $P830
    .const 'Sub' $P818 = "183_1304282286.73" 
    capture_lex $P818
    .const 'Sub' $P813 = "182_1304282286.73" 
    capture_lex $P813
    .const 'Sub' $P801 = "180_1304282286.73" 
    capture_lex $P801
    .const 'Sub' $P798 = "179_1304282286.73" 
    capture_lex $P798
    .const 'Sub' $P791 = "177_1304282286.73" 
    capture_lex $P791
    .const 'Sub' $P789 = "176_1304282286.73" 
    capture_lex $P789
    .const 'Sub' $P784 = "174_1304282286.73" 
    capture_lex $P784
    .const 'Sub' $P781 = "173_1304282286.73" 
    capture_lex $P781
    .const 'Sub' $P775 = "171_1304282286.73" 
    capture_lex $P775
    .const 'Sub' $P772 = "170_1304282286.73" 
    capture_lex $P772
    .const 'Sub' $P766 = "168_1304282286.73" 
    capture_lex $P766
    .const 'Sub' $P764 = "167_1304282286.73" 
    capture_lex $P764
    .const 'Sub' $P749 = "163_1304282286.73" 
    capture_lex $P749
    .const 'Sub' $P746 = "162_1304282286.73" 
    capture_lex $P746
    .const 'Sub' $P740 = "160_1304282286.73" 
    capture_lex $P740
    .const 'Sub' $P737 = "159_1304282286.73" 
    capture_lex $P737
    .const 'Sub' $P731 = "157_1304282286.73" 
    capture_lex $P731
    .const 'Sub' $P728 = "156_1304282286.73" 
    capture_lex $P728
    .const 'Sub' $P722 = "154_1304282286.73" 
    capture_lex $P722
    .const 'Sub' $P719 = "153_1304282286.73" 
    capture_lex $P719
    .const 'Sub' $P713 = "151_1304282286.73" 
    capture_lex $P713
    .const 'Sub' $P710 = "150_1304282286.73" 
    capture_lex $P710
    .const 'Sub' $P704 = "148_1304282286.73" 
    capture_lex $P704
    .const 'Sub' $P701 = "147_1304282286.73" 
    capture_lex $P701
    .const 'Sub' $P695 = "145_1304282286.73" 
    capture_lex $P695
    .const 'Sub' $P692 = "144_1304282286.73" 
    capture_lex $P692
    .const 'Sub' $P683 = "142_1304282286.73" 
    capture_lex $P683
    .const 'Sub' $P680 = "141_1304282286.73" 
    capture_lex $P680
    .const 'Sub' $P671 = "139_1304282286.73" 
    capture_lex $P671
    .const 'Sub' $P668 = "138_1304282286.73" 
    capture_lex $P668
    .const 'Sub' $P659 = "136_1304282286.73" 
    capture_lex $P659
    .const 'Sub' $P650 = "133_1304282286.73" 
    capture_lex $P650
    .const 'Sub' $P641 = "131_1304282286.73" 
    capture_lex $P641
    .const 'Sub' $P638 = "130_1304282286.73" 
    capture_lex $P638
    .const 'Sub' $P629 = "128_1304282286.73" 
    capture_lex $P629
    .const 'Sub' $P621 = "125_1304282286.73" 
    capture_lex $P621
    .const 'Sub' $P615 = "123_1304282286.73" 
    capture_lex $P615
    .const 'Sub' $P612 = "122_1304282286.73" 
    capture_lex $P612
    .const 'Sub' $P605 = "120_1304282286.73" 
    capture_lex $P605
    .const 'Sub' $P602 = "119_1304282286.73" 
    capture_lex $P602
    .const 'Sub' $P595 = "117_1304282286.73" 
    capture_lex $P595
    .const 'Sub' $P587 = "114_1304282286.73" 
    capture_lex $P587
    .const 'Sub' $P579 = "112_1304282286.73" 
    capture_lex $P579
    .const 'Sub' $P577 = "111_1304282286.73" 
    capture_lex $P577
    .const 'Sub' $P569 = "109_1304282286.73" 
    capture_lex $P569
    .const 'Sub' $P567 = "108_1304282286.73" 
    capture_lex $P567
    .const 'Sub' $P559 = "106_1304282286.73" 
    capture_lex $P559
    .const 'Sub' $P557 = "105_1304282286.73" 
    capture_lex $P557
    .const 'Sub' $P537 = "103_1304282286.73" 
    capture_lex $P537
    .const 'Sub' $P535 = "102_1304282286.73" 
    capture_lex $P535
    .const 'Sub' $P526 = "100_1304282286.73" 
    capture_lex $P526
    .const 'Sub' $P524 = "99_1304282286.73" 
    capture_lex $P524
    .const 'Sub' $P506 = "96_1304282286.73" 
    capture_lex $P506
    .const 'Sub' $P504 = "95_1304282286.73" 
    capture_lex $P504
    .const 'Sub' $P486 = "93_1304282286.73" 
    capture_lex $P486
    .const 'Sub' $P484 = "92_1304282286.73" 
    capture_lex $P484
    .const 'Sub' $P476 = "90_1304282286.73" 
    capture_lex $P476
    .const 'Sub' $P468 = "87_1304282286.73" 
    capture_lex $P468
    .const 'Sub' $P463 = "85_1304282286.73" 
    capture_lex $P463
    .const 'Sub' $P461 = "84_1304282286.73" 
    capture_lex $P461
    .const 'Sub' $P456 = "82_1304282286.73" 
    capture_lex $P456
    .const 'Sub' $P448 = "79_1304282286.73" 
    capture_lex $P448
    .const 'Sub' $P443 = "77_1304282286.73" 
    capture_lex $P443
    .const 'Sub' $P441 = "76_1304282286.73" 
    capture_lex $P441
    .const 'Sub' $P436 = "74_1304282286.73" 
    capture_lex $P436
    .const 'Sub' $P434 = "73_1304282286.73" 
    capture_lex $P434
    .const 'Sub' $P429 = "71_1304282286.73" 
    capture_lex $P429
    .const 'Sub' $P427 = "70_1304282286.73" 
    capture_lex $P427
    .const 'Sub' $P422 = "68_1304282286.73" 
    capture_lex $P422
    .const 'Sub' $P420 = "67_1304282286.73" 
    capture_lex $P420
    .const 'Sub' $P415 = "65_1304282286.73" 
    capture_lex $P415
    .const 'Sub' $P412 = "64_1304282286.73" 
    capture_lex $P412
    .const 'Sub' $P402 = "62_1304282286.73" 
    capture_lex $P402
    .const 'Sub' $P399 = "61_1304282286.73" 
    capture_lex $P399
    .const 'Sub' $P392 = "59_1304282286.73" 
    capture_lex $P392
    .const 'Sub' $P390 = "58_1304282286.73" 
    capture_lex $P390
    .const 'Sub' $P384 = "56_1304282286.73" 
    capture_lex $P384
    .const 'Sub' $P380 = "55_1304282286.73" 
    capture_lex $P380
    .const 'Sub' $P372 = "53_1304282286.73" 
    capture_lex $P372
    .const 'Sub' $P369 = "52_1304282286.73" 
    capture_lex $P369
    .const 'Sub' $P363 = "50_1304282286.73" 
    capture_lex $P363
    .const 'Sub' $P361 = "49_1304282286.73" 
    capture_lex $P361
    .const 'Sub' $P355 = "47_1304282286.73" 
    capture_lex $P355
    .const 'Sub' $P353 = "46_1304282286.73" 
    capture_lex $P353
    .const 'Sub' $P338 = "43_1304282286.73" 
    capture_lex $P338
    .const 'Sub' $P334 = "42_1304282286.73" 
    capture_lex $P334
    .const 'Sub' $P320 = "40_1304282286.73" 
    capture_lex $P320
    .const 'Sub' $P317 = "39_1304282286.73" 
    capture_lex $P317
    .const 'Sub' $P294 = "37_1304282286.73" 
    capture_lex $P294
    .const 'Sub' $P292 = "36_1304282286.73" 
    capture_lex $P292
    .const 'Sub' $P253 = "33_1304282286.73" 
    capture_lex $P253
    .const 'Sub' $P251 = "32_1304282286.73" 
    capture_lex $P251
    .const 'Sub' $P236 = "29_1304282286.73" 
    capture_lex $P236
    .const 'Sub' $P234 = "28_1304282286.73" 
    capture_lex $P234
    .const 'Sub' $P223 = "26_1304282286.73" 
    capture_lex $P223
    .const 'Sub' $P221 = "25_1304282286.73" 
    capture_lex $P221
    .const 'Sub' $P209 = "23_1304282286.73" 
    capture_lex $P209
    .const 'Sub' $P206 = "22_1304282286.73" 
    capture_lex $P206
    .const 'Sub' $P198 = "20_1304282286.73" 
    capture_lex $P198
    .const 'Sub' $P196 = "19_1304282286.73" 
    capture_lex $P196
    .const 'Sub' $P189 = "17_1304282286.73" 
    capture_lex $P189
    .const 'Sub' $P186 = "16_1304282286.73" 
    capture_lex $P186
    .const 'Sub' $P179 = "14_1304282286.73" 
    capture_lex $P179
    .const 'Sub' $P110 = "13_1304282286.73" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 612
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 613
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 614
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 615
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 616
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 617
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 618
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 619
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 620
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 621
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 622
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 623
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 624
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 625
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 626
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 725
    .const 'Sub' $P2391 = "550_1304282286.73" 
    newclosure $P2402, $P2391
.annotate 'line', 9
    .return ($P2402)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post781") :outer("12_1304282286.73")
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1304282286.73" 
    .local pmc block
    set block, $P47
    .const 'Sub' $P2404 = "551_1304282286.73" 
    capture_lex $P2404
    $P2404()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2403"  :anon :subid("551_1304282286.73") :outer("12_1304282286.73")
.annotate 'line', 9
    nqp_get_sc_object $P2405, "1304282274.421", 1
    .local pmc type_obj
    set type_obj, $P2405
    get_how $P2406, type_obj
    $P2407 = $P2406."compose"(type_obj)
    .return ($P2407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1304282286.73") :outer("12_1304282286.73")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 21
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 28
    new $P114, "Undef"
    .lex "$*SC", $P114
.annotate 'line', 32
    new $P115, "Undef"
    .lex "$*SCOPE", $P115
.annotate 'line', 33
    new $P116, "Undef"
    .lex "$*MULTINESS", $P116
.annotate 'line', 34
    new $P117, "Undef"
    .lex "$*INVOCANT_OK", $P117
.annotate 'line', 35
    new $P118, "Undef"
    .lex "$*RETURN_USED", $P118
.annotate 'line', 36
    new $P119, "Undef"
    .lex "$*PACKAGE-SETUP", $P119
.annotate 'line', 10
    find_lex $P122, "%*LANG"
    unless_null $P122, vivify_782
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["%LANG"]
    unless_null $P122, vivify_783
    die "Contextual %*LANG not found"
  vivify_783:
  vivify_782:
.annotate 'line', 13
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "NQP"
    get_who $P125, $P124
    set $P126, $P125["Regex"]
    find_lex $P129, "%*LANG"
    unless_null $P129, vivify_784
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["%LANG"]
    unless_null $P129, vivify_785
    die "Contextual %*LANG not found"
  vivify_785:
    store_lex "%*LANG", $P129
  vivify_784:
    set $P129["Regex"], $P126
.annotate 'line', 14
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "NQP"
    get_who $P132, $P131
    set $P133, $P132["RegexActions"]
    find_lex $P136, "%*LANG"
    unless_null $P136, vivify_786
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["%LANG"]
    unless_null $P136, vivify_787
    die "Contextual %*LANG not found"
  vivify_787:
    store_lex "%*LANG", $P136
  vivify_786:
    set $P136["Regex-actions"], $P133
.annotate 'line', 15
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "NQP"
    get_who $P139, $P138
    set $P140, $P139["Grammar"]
    find_lex $P143, "%*LANG"
    unless_null $P143, vivify_788
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["%LANG"]
    unless_null $P143, vivify_789
    die "Contextual %*LANG not found"
  vivify_789:
    store_lex "%*LANG", $P143
  vivify_788:
    set $P143["MAIN"], $P140
.annotate 'line', 16
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "NQP"
    get_who $P146, $P145
    set $P147, $P146["Actions"]
    find_lex $P150, "%*LANG"
    unless_null $P150, vivify_790
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P150, $P149["%LANG"]
    unless_null $P150, vivify_791
    die "Contextual %*LANG not found"
  vivify_791:
    store_lex "%*LANG", $P150
  vivify_790:
    set $P150["MAIN-actions"], $P147
    find_lex $P153, "%*HOW"
    unless_null $P153, vivify_792
    get_hll_global $P151, "GLOBAL"
    get_who $P152, $P151
    set $P153, $P152["%HOW"]
    unless_null $P153, vivify_793
    die "Contextual %*HOW not found"
  vivify_793:
  vivify_792:
.annotate 'line', 22
    get_knowhow $P154
    find_lex $P157, "%*HOW"
    unless_null $P157, vivify_794
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["%HOW"]
    unless_null $P157, vivify_795
    die "Contextual %*HOW not found"
  vivify_795:
    store_lex "%*HOW", $P157
  vivify_794:
    set $P157["knowhow"], $P154
.annotate 'line', 23
    get_knowhow_attribute $P158
    find_lex $P161, "%*HOW"
    unless_null $P161, vivify_796
    get_hll_global $P159, "GLOBAL"
    get_who $P160, $P159
    set $P161, $P160["%HOW"]
    unless_null $P161, vivify_797
    die "Contextual %*HOW not found"
  vivify_797:
    store_lex "%*HOW", $P161
  vivify_796:
    set $P161["knowhow-attr"], $P158
.annotate 'line', 28
    get_hll_global $P162, "GLOBAL"
    nqp_get_package_through_who $P163, $P162, "HLL"
    nqp_get_package_through_who $P164, $P163, "Compiler"
    get_who $P165, $P164
    set $P166, $P165["SerializationContextBuilder"]
.annotate 'line', 30
    time $N167
    set $S168, $N167
    $P169 = $P166."new"($S168 :named("handle"))
.annotate 'line', 28
    store_lex "$*SC", $P169
.annotate 'line', 32
    new $P170, "String"
    assign $P170, ""
    store_lex "$*SCOPE", $P170
.annotate 'line', 33
    new $P171, "String"
    assign $P171, ""
    store_lex "$*MULTINESS", $P171
.annotate 'line', 34
    new $P172, "Integer"
    assign $P172, 0
    store_lex "$*INVOCANT_OK", $P172
.annotate 'line', 35
    new $P173, "Integer"
    assign $P173, 0
    store_lex "$*RETURN_USED", $P173
    find_lex $P176, "$*PACKAGE-SETUP"
    unless_null $P176, vivify_798
    get_hll_global $P174, "GLOBAL"
    get_who $P175, $P174
    set $P176, $P175["$PACKAGE-SETUP"]
    unless_null $P176, vivify_799
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_799:
  vivify_798:
.annotate 'line', 37
    find_lex $P177, "self"
    $P178 = $P177."comp_unit"()
.annotate 'line', 10
    .return ($P178)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx180_tgt
    .local int rx180_pos
    .local int rx180_off
    .local int rx180_eos
    .local int rx180_rep
    .local pmc rx180_cur
    .local pmc rx180_debug
    (rx180_cur, rx180_pos, rx180_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx180_cur
    .local pmc match
    .lex "$/", match
    length rx180_eos, rx180_tgt
    gt rx180_pos, rx180_eos, rx180_done
    set rx180_off, 0
    lt rx180_pos, 2, rx180_start
    sub rx180_off, rx180_pos, 1
    substr rx180_tgt, rx180_tgt, rx180_off
  rx180_start:
    eq $I10, 1, rx180_restart
    if_null rx180_debug, debug_800
    rx180_cur."!cursor_debug"("START", "identifier")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan184_done
    goto rxscan184_scan
  rxscan184_loop:
    (rx180_pos) = rx180_cur."from"()
    inc rx180_pos
    rx180_cur."!cursor_from"(rx180_pos)
    ge rx180_pos, rx180_eos, rxscan184_done
  rxscan184_scan:
    set_addr $I10, rxscan184_loop
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxscan184_done:
.annotate 'line', 42
  # rx subrule "ident" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ident"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  # rx rxquantr185 ** 0..*
    set_addr $I10, rxquantr185_done
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxquantr185_loop:
  # rx enumcharlist negate=0 
    ge rx180_pos, rx180_eos, rx180_fail
    sub $I10, rx180_pos, rx180_off
    substr $S10, rx180_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx180_fail
    inc rx180_pos
  # rx subrule "ident" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ident"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
    set_addr $I10, rxquantr185_done
    (rx180_rep) = rx180_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr185_done
    rx180_cur."!mark_push"(rx180_rep, rx180_pos, $I10)
    goto rxquantr185_loop
  rxquantr185_done:
  # rx pass
    rx180_cur."!cursor_pass"(rx180_pos, "identifier")
    if_null rx180_debug, debug_801
    rx180_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx180_pos)
  debug_801:
    .return (rx180_cur)
  rx180_restart:
.annotate 'line', 10
    if_null rx180_debug, debug_802
    rx180_cur."!cursor_debug"("NEXT", "identifier")
  debug_802:
  rx180_fail:
    (rx180_rep, rx180_pos, $I10, $P10) = rx180_cur."!mark_fail"(0)
    lt rx180_pos, -1, rx180_done
    eq rx180_pos, -1, rx180_fail
    jump $I10
  rx180_done:
    rx180_cur."!cursor_fail"()
    if_null rx180_debug, debug_803
    rx180_cur."!cursor_debug"("FAIL", "identifier")
  debug_803:
    .return (rx180_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1304282286.73") :method
.annotate 'line', 10
    $P182 = self."!PREFIX__!subrule"("ident", "")
    new $P183, "ResizablePMCArray"
    push $P183, $P182
    .return ($P183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("16_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P187 = self."!PREFIX__!subrule"("ident", "")
    new $P188, "ResizablePMCArray"
    push $P188, $P187
    .return ($P188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("17_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx190_tgt
    .local int rx190_pos
    .local int rx190_off
    .local int rx190_eos
    .local int rx190_rep
    .local pmc rx190_cur
    .local pmc rx190_debug
    (rx190_cur, rx190_pos, rx190_tgt, $I10) = self."!cursor_start"()
    rx190_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx190_cur
    .local pmc match
    .lex "$/", match
    length rx190_eos, rx190_tgt
    gt rx190_pos, rx190_eos, rx190_done
    set rx190_off, 0
    lt rx190_pos, 2, rx190_start
    sub rx190_off, rx190_pos, 1
    substr rx190_tgt, rx190_tgt, rx190_off
  rx190_start:
    eq $I10, 1, rx190_restart
    if_null rx190_debug, debug_804
    rx190_cur."!cursor_debug"("START", "name")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan193_done
    goto rxscan193_scan
  rxscan193_loop:
    (rx190_pos) = rx190_cur."from"()
    inc rx190_pos
    rx190_cur."!cursor_from"(rx190_pos)
    ge rx190_pos, rx190_eos, rxscan193_done
  rxscan193_scan:
    set_addr $I10, rxscan193_loop
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
  rxscan193_done:
.annotate 'line', 44
  # rx rxquantr194 ** 1..*
    set_addr $I10, rxquantr194_done
    rx190_cur."!mark_push"(0, -1, $I10)
  rxquantr194_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."identifier"()
    unless $P10, rx190_fail
    goto rxsubrule195_pass
  rxsubrule195_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx190_fail
  rxsubrule195_pass:
    set_addr $I10, rxsubrule195_back
    rx190_cur."!mark_push"(0, rx190_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx190_pos = $P10."pos"()
    set_addr $I10, rxquantr194_done
    (rx190_rep) = rx190_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr194_done
    rx190_cur."!mark_push"(rx190_rep, rx190_pos, $I10)
  # rx literal  "::"
    add $I11, rx190_pos, 2
    gt $I11, rx190_eos, rx190_fail
    sub $I11, rx190_pos, rx190_off
    substr $S10, rx190_tgt, $I11, 2
    ne $S10, "::", rx190_fail
    add rx190_pos, 2
    goto rxquantr194_loop
  rxquantr194_done:
  # rx pass
    rx190_cur."!cursor_pass"(rx190_pos, "name")
    if_null rx190_debug, debug_805
    rx190_cur."!cursor_debug"("PASS", "name", " at pos=", rx190_pos)
  debug_805:
    .return (rx190_cur)
  rx190_restart:
.annotate 'line', 10
    if_null rx190_debug, debug_806
    rx190_cur."!cursor_debug"("NEXT", "name")
  debug_806:
  rx190_fail:
    (rx190_rep, rx190_pos, $I10, $P10) = rx190_cur."!mark_fail"(0)
    lt rx190_pos, -1, rx190_done
    eq rx190_pos, -1, rx190_fail
    jump $I10
  rx190_done:
    rx190_cur."!cursor_fail"()
    if_null rx190_debug, debug_807
    rx190_cur."!cursor_debug"("FAIL", "name")
  debug_807:
    .return (rx190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("18_1304282286.73") :method
.annotate 'line', 10
    new $P192, "ResizablePMCArray"
    push $P192, ""
    .return ($P192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("19_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P197, "ResizablePMCArray"
    push $P197, ""
    .return ($P197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("20_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx199_tgt
    .local int rx199_pos
    .local int rx199_off
    .local int rx199_eos
    .local int rx199_rep
    .local pmc rx199_cur
    .local pmc rx199_debug
    (rx199_cur, rx199_pos, rx199_tgt, $I10) = self."!cursor_start"()
    rx199_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx199_cur
    .local pmc match
    .lex "$/", match
    length rx199_eos, rx199_tgt
    gt rx199_pos, rx199_eos, rx199_done
    set rx199_off, 0
    lt rx199_pos, 2, rx199_start
    sub rx199_off, rx199_pos, 1
    substr rx199_tgt, rx199_tgt, rx199_off
  rx199_start:
    eq $I10, 1, rx199_restart
    if_null rx199_debug, debug_808
    rx199_cur."!cursor_debug"("START", "deflongname")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan203_done
    goto rxscan203_scan
  rxscan203_loop:
    (rx199_pos) = rx199_cur."from"()
    inc rx199_pos
    rx199_cur."!cursor_from"(rx199_pos)
    ge rx199_pos, rx199_eos, rxscan203_done
  rxscan203_scan:
    set_addr $I10, rxscan203_loop
    rx199_cur."!mark_push"(0, rx199_pos, $I10)
  rxscan203_done:
.annotate 'line', 47
  # rx subrule "identifier" subtype=capture negate=
    rx199_cur."!cursor_pos"(rx199_pos)
    $P10 = rx199_cur."identifier"()
    unless $P10, rx199_fail
    rx199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx199_pos = $P10."pos"()
  # rx rxquantr204 ** 0..1
    set_addr $I10, rxquantr204_done
    rx199_cur."!mark_push"(0, rx199_pos, $I10)
  rxquantr204_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx199_cur."!cursor_pos"(rx199_pos)
    $P10 = rx199_cur."colonpair"()
    unless $P10, rx199_fail
    goto rxsubrule205_pass
  rxsubrule205_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx199_fail
  rxsubrule205_pass:
    set_addr $I10, rxsubrule205_back
    rx199_cur."!mark_push"(0, rx199_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx199_pos = $P10."pos"()
    set_addr $I10, rxquantr204_done
    (rx199_rep) = rx199_cur."!mark_commit"($I10)
  rxquantr204_done:
.annotate 'line', 46
  # rx pass
    rx199_cur."!cursor_pass"(rx199_pos, "deflongname")
    if_null rx199_debug, debug_809
    rx199_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx199_pos)
  debug_809:
    .return (rx199_cur)
  rx199_restart:
.annotate 'line', 10
    if_null rx199_debug, debug_810
    rx199_cur."!cursor_debug"("NEXT", "deflongname")
  debug_810:
  rx199_fail:
    (rx199_rep, rx199_pos, $I10, $P10) = rx199_cur."!mark_fail"(0)
    lt rx199_pos, -1, rx199_done
    eq rx199_pos, -1, rx199_fail
    jump $I10
  rx199_done:
    rx199_cur."!cursor_fail"()
    if_null rx199_debug, debug_811
    rx199_cur."!cursor_debug"("FAIL", "deflongname")
  debug_811:
    .return (rx199_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("21_1304282286.73") :method
.annotate 'line', 10
    $P201 = self."!PREFIX__!subrule"("identifier", "")
    new $P202, "ResizablePMCArray"
    push $P202, $P201
    .return ($P202)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("22_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P207 = self."!PREFIX__!subrule"("identifier", "")
    new $P208, "ResizablePMCArray"
    push $P208, $P207
    .return ($P208)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("23_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_812
    rx210_cur."!cursor_debug"("START", "ENDSTMT")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan213_done:
.annotate 'line', 54
  # rx rxquantr214 ** 0..1
    set_addr $I10, rxquantr214_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr214_loop:
  alt215_0:
.annotate 'line', 51
    set_addr $I10, alt215_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 52
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx210_pos, rx210_off
    set rx210_rep, 0
    sub $I12, rx210_eos, rx210_pos
  rxenumcharlistq216_loop:
    le $I12, 0, rxenumcharlistq216_done
    substr $S10, rx210_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq216_done
    inc rx210_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq216_loop
  rxenumcharlistq216_done:
    add rx210_pos, rx210_pos, rx210_rep
  # rxanchor eol
    sub $I10, rx210_pos, rx210_off
    is_cclass $I11, 4096, rx210_tgt, $I10
    if $I11, rxanchor217_done
    ne rx210_pos, rx210_eos, rx210_fail
    eq rx210_pos, 0, rxanchor217_done
    dec $I10
    is_cclass $I11, 4096, rx210_tgt, $I10
    if $I11, rx210_fail
  rxanchor217_done:
  # rx subrule "ws" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."ws"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."MARKER"("endstmt")
    unless $P10, rx210_fail
    goto alt215_end
  alt215_1:
.annotate 'line', 53
  # rx rxquantr218 ** 0..1
    set_addr $I10, rxquantr218_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr218_loop:
  # rx subrule "unv" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."unv"()
    unless $P10, rx210_fail
    goto rxsubrule219_pass
  rxsubrule219_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx210_fail
  rxsubrule219_pass:
    set_addr $I10, rxsubrule219_back
    rx210_cur."!mark_push"(0, rx210_pos, $I10, $P10)
    rx210_pos = $P10."pos"()
    set_addr $I10, rxquantr218_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr218_done:
  # rxanchor eol
    sub $I10, rx210_pos, rx210_off
    is_cclass $I11, 4096, rx210_tgt, $I10
    if $I11, rxanchor220_done
    ne rx210_pos, rx210_eos, rx210_fail
    eq rx210_pos, 0, rxanchor220_done
    dec $I10
    is_cclass $I11, 4096, rx210_tgt, $I10
    if $I11, rx210_fail
  rxanchor220_done:
  # rx subrule "ws" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."ws"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."MARKER"("endstmt")
    unless $P10, rx210_fail
  alt215_end:
.annotate 'line', 54
    set_addr $I10, rxquantr214_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr214_done:
.annotate 'line', 50
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "ENDSTMT")
    if_null rx210_debug, debug_813
    rx210_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx210_pos)
  debug_813:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 10
    if_null rx210_debug, debug_814
    rx210_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_814:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_815
    rx210_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_815:
    .return (rx210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("24_1304282286.73") :method
.annotate 'line', 10
    new $P212, "ResizablePMCArray"
    push $P212, ""
    .return ($P212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("25_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P222, "ResizablePMCArray"
    push $P222, ""
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("26_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx224_tgt
    .local int rx224_pos
    .local int rx224_off
    .local int rx224_eos
    .local int rx224_rep
    .local pmc rx224_cur
    .local pmc rx224_debug
    (rx224_cur, rx224_pos, rx224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx224_cur
    .local pmc match
    .lex "$/", match
    length rx224_eos, rx224_tgt
    gt rx224_pos, rx224_eos, rx224_done
    set rx224_off, 0
    lt rx224_pos, 2, rx224_start
    sub rx224_off, rx224_pos, 1
    substr rx224_tgt, rx224_tgt, rx224_off
  rx224_start:
    eq $I10, 1, rx224_restart
    if_null rx224_debug, debug_816
    rx224_cur."!cursor_debug"("START", "ws")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan227_done
    goto rxscan227_scan
  rxscan227_loop:
    (rx224_pos) = rx224_cur."from"()
    inc rx224_pos
    rx224_cur."!cursor_from"(rx224_pos)
    ge rx224_pos, rx224_eos, rxscan227_done
  rxscan227_scan:
    set_addr $I10, rxscan227_loop
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  rxscan227_done:
  alt228_0:
.annotate 'line', 57
    set_addr $I10, alt228_1
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
.annotate 'line', 58
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."MARKED"("ws")
    unless $P10, rx224_fail
    goto alt228_end
  alt228_1:
.annotate 'line', 59
  # rx subrule "ww" subtype=zerowidth negate=1
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."ww"()
    if $P10, rx224_fail
.annotate 'line', 64
  # rx rxquantr229 ** 0..*
    set_addr $I10, rxquantr229_done
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  rxquantr229_loop:
  alt230_0:
.annotate 'line', 60
    set_addr $I10, alt230_1
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx224_pos, rx224_off
    set rx224_rep, 0
    sub $I12, rx224_eos, rx224_pos
  rxenumcharlistq231_loop:
    le $I12, 0, rxenumcharlistq231_done
    substr $S10, rx224_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq231_done
    inc rx224_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq231_loop
  rxenumcharlistq231_done:
    lt rx224_rep, 1, rx224_fail
    add rx224_pos, rx224_pos, rx224_rep
    goto alt230_end
  alt230_1:
    set_addr $I10, alt230_2
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
.annotate 'line', 61
  # rx literal  "#"
    add $I11, rx224_pos, 1
    gt $I11, rx224_eos, rx224_fail
    sub $I11, rx224_pos, rx224_off
    ord $I11, rx224_tgt, $I11
    ne $I11, 35, rx224_fail
    add rx224_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx224_pos, rx224_off
    find_cclass $I11, 4096, rx224_tgt, $I10, rx224_eos
    add rx224_pos, rx224_off, $I11
    goto alt230_end
  alt230_2:
    set_addr $I10, alt230_3
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
.annotate 'line', 62
  # rxanchor bol
    eq rx224_pos, 0, rxanchor232_done
    ge rx224_pos, rx224_eos, rx224_fail
    sub $I10, rx224_pos, rx224_off
    dec $I10
    is_cclass $I11, 4096, rx224_tgt, $I10
    unless $I11, rx224_fail
  rxanchor232_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."pod_comment"()
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
    goto alt230_end
  alt230_3:
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx224_pos, rx224_off
    set rx224_rep, 0
    sub $I12, rx224_eos, rx224_pos
  rxenumcharlistq233_loop:
    le $I12, 0, rxenumcharlistq233_done
    substr $S10, rx224_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq233_done
    inc rx224_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq233_loop
  rxenumcharlistq233_done:
    lt rx224_rep, 1, rx224_fail
    add rx224_pos, rx224_pos, rx224_rep
  alt230_end:
.annotate 'line', 64
    set_addr $I10, rxquantr229_done
    (rx224_rep) = rx224_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr229_done
    rx224_cur."!mark_push"(rx224_rep, rx224_pos, $I10)
    goto rxquantr229_loop
  rxquantr229_done:
.annotate 'line', 65
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."MARKER"("ws")
    unless $P10, rx224_fail
  alt228_end:
.annotate 'line', 57
  # rx pass
    rx224_cur."!cursor_pass"(rx224_pos, "ws")
    if_null rx224_debug, debug_817
    rx224_cur."!cursor_debug"("PASS", "ws", " at pos=", rx224_pos)
  debug_817:
    .return (rx224_cur)
  rx224_restart:
.annotate 'line', 10
    if_null rx224_debug, debug_818
    rx224_cur."!cursor_debug"("NEXT", "ws")
  debug_818:
  rx224_fail:
    (rx224_rep, rx224_pos, $I10, $P10) = rx224_cur."!mark_fail"(0)
    lt rx224_pos, -1, rx224_done
    eq rx224_pos, -1, rx224_fail
    jump $I10
  rx224_done:
    rx224_cur."!cursor_fail"()
    if_null rx224_debug, debug_819
    rx224_cur."!cursor_debug"("FAIL", "ws")
  debug_819:
    .return (rx224_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("27_1304282286.73") :method
.annotate 'line', 10
    new $P226, "ResizablePMCArray"
    push $P226, ""
    push $P226, ""
    .return ($P226)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("28_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P235, "ResizablePMCArray"
    push $P235, ""
    push $P235, ""
    .return ($P235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("29_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P244 = "31_1304282286.73" 
    capture_lex $P244
    .local string rx237_tgt
    .local int rx237_pos
    .local int rx237_off
    .local int rx237_eos
    .local int rx237_rep
    .local pmc rx237_cur
    .local pmc rx237_debug
    (rx237_cur, rx237_pos, rx237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx237_cur
    .local pmc match
    .lex "$/", match
    length rx237_eos, rx237_tgt
    gt rx237_pos, rx237_eos, rx237_done
    set rx237_off, 0
    lt rx237_pos, 2, rx237_start
    sub rx237_off, rx237_pos, 1
    substr rx237_tgt, rx237_tgt, rx237_off
  rx237_start:
    eq $I10, 1, rx237_restart
    if_null rx237_debug, debug_820
    rx237_cur."!cursor_debug"("START", "unv")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan240_done
    goto rxscan240_scan
  rxscan240_loop:
    (rx237_pos) = rx237_cur."from"()
    inc rx237_pos
    rx237_cur."!cursor_from"(rx237_pos)
    ge rx237_pos, rx237_eos, rxscan240_done
  rxscan240_scan:
    set_addr $I10, rxscan240_loop
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
  rxscan240_done:
  alt241_0:
.annotate 'line', 70
    set_addr $I10, alt241_1
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 71
  # rxanchor bol
    eq rx237_pos, 0, rxanchor242_done
    ge rx237_pos, rx237_eos, rx237_fail
    sub $I10, rx237_pos, rx237_off
    dec $I10
    is_cclass $I11, 4096, rx237_tgt, $I10
    unless $I11, rx237_fail
  rxanchor242_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    .const 'Sub' $P244 = "31_1304282286.73" 
    capture_lex $P244
    $P10 = rx237_cur."before"($P244)
    unless $P10, rx237_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."pod_comment"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
    goto alt241_end
  alt241_1:
    set_addr $I10, alt241_2
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 72
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx237_pos, rx237_off
    set rx237_rep, 0
    sub $I12, rx237_eos, rx237_pos
  rxenumcharlistq249_loop:
    le $I12, 0, rxenumcharlistq249_done
    substr $S10, rx237_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq249_done
    inc rx237_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq249_loop
  rxenumcharlistq249_done:
    add rx237_pos, rx237_pos, rx237_rep
  # rx literal  "#"
    add $I11, rx237_pos, 1
    gt $I11, rx237_eos, rx237_fail
    sub $I11, rx237_pos, rx237_off
    ord $I11, rx237_tgt, $I11
    ne $I11, 35, rx237_fail
    add rx237_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx237_pos, rx237_off
    find_cclass $I11, 4096, rx237_tgt, $I10, rx237_eos
    add rx237_pos, rx237_off, $I11
    goto alt241_end
  alt241_2:
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx237_pos, rx237_off
    set rx237_rep, 0
    sub $I12, rx237_eos, rx237_pos
  rxenumcharlistq250_loop:
    le $I12, 0, rxenumcharlistq250_done
    substr $S10, rx237_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq250_done
    inc rx237_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq250_loop
  rxenumcharlistq250_done:
    lt rx237_rep, 1, rx237_fail
    add rx237_pos, rx237_pos, rx237_rep
  alt241_end:
.annotate 'line', 68
  # rx pass
    rx237_cur."!cursor_pass"(rx237_pos, "unv")
    if_null rx237_debug, debug_825
    rx237_cur."!cursor_debug"("PASS", "unv", " at pos=", rx237_pos)
  debug_825:
    .return (rx237_cur)
  rx237_restart:
.annotate 'line', 10
    if_null rx237_debug, debug_826
    rx237_cur."!cursor_debug"("NEXT", "unv")
  debug_826:
  rx237_fail:
    (rx237_rep, rx237_pos, $I10, $P10) = rx237_cur."!mark_fail"(0)
    lt rx237_pos, -1, rx237_done
    eq rx237_pos, -1, rx237_fail
    jump $I10
  rx237_done:
    rx237_cur."!cursor_fail"()
    if_null rx237_debug, debug_827
    rx237_cur."!cursor_debug"("FAIL", "unv")
  debug_827:
    .return (rx237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("30_1304282286.73") :method
.annotate 'line', 10
    new $P239, "ResizablePMCArray"
    push $P239, ""
    push $P239, ""
    push $P239, ""
    .return ($P239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block243"  :anon :subid("31_1304282286.73") :method :outer("29_1304282286.73")
.annotate 'line', 71
    .local string rx245_tgt
    .local int rx245_pos
    .local int rx245_off
    .local int rx245_eos
    .local int rx245_rep
    .local pmc rx245_cur
    .local pmc rx245_debug
    (rx245_cur, rx245_pos, rx245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx245_cur
    .local pmc match
    .lex "$/", match
    length rx245_eos, rx245_tgt
    gt rx245_pos, rx245_eos, rx245_done
    set rx245_off, 0
    lt rx245_pos, 2, rx245_start
    sub rx245_off, rx245_pos, 1
    substr rx245_tgt, rx245_tgt, rx245_off
  rx245_start:
    eq $I10, 1, rx245_restart
    if_null rx245_debug, debug_821
    rx245_cur."!cursor_debug"("START", "")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    (rx245_pos) = rx245_cur."from"()
    inc rx245_pos
    rx245_cur."!cursor_from"(rx245_pos)
    ge rx245_pos, rx245_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  rxscan246_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx245_pos, rx245_off
    set rx245_rep, 0
    sub $I12, rx245_eos, rx245_pos
  rxenumcharlistq247_loop:
    le $I12, 0, rxenumcharlistq247_done
    substr $S10, rx245_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq247_done
    inc rx245_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq247_loop
  rxenumcharlistq247_done:
    add rx245_pos, rx245_pos, rx245_rep
  # rx literal  "="
    add $I11, rx245_pos, 1
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    ord $I11, rx245_tgt, $I11
    ne $I11, 61, rx245_fail
    add rx245_pos, 1
  alt248_0:
    set_addr $I10, alt248_1
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  # rx charclass w
    ge rx245_pos, rx245_eos, rx245_fail
    sub $I10, rx245_pos, rx245_off
    is_cclass $I11, 8192, rx245_tgt, $I10
    unless $I11, rx245_fail
    inc rx245_pos
    goto alt248_end
  alt248_1:
  # rx literal  "\\"
    add $I11, rx245_pos, 1
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    ord $I11, rx245_tgt, $I11
    ne $I11, 92, rx245_fail
    add rx245_pos, 1
  alt248_end:
  # rx pass
    rx245_cur."!cursor_pass"(rx245_pos, "")
    if_null rx245_debug, debug_822
    rx245_cur."!cursor_debug"("PASS", "", " at pos=", rx245_pos)
  debug_822:
    .return (rx245_cur)
  rx245_restart:
    if_null rx245_debug, debug_823
    rx245_cur."!cursor_debug"("NEXT", "")
  debug_823:
  rx245_fail:
    (rx245_rep, rx245_pos, $I10, $P10) = rx245_cur."!mark_fail"(0)
    lt rx245_pos, -1, rx245_done
    eq rx245_pos, -1, rx245_fail
    jump $I10
  rx245_done:
    rx245_cur."!cursor_fail"()
    if_null rx245_debug, debug_824
    rx245_cur."!cursor_debug"("FAIL", "")
  debug_824:
    .return (rx245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("32_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P252, "ResizablePMCArray"
    push $P252, ""
    push $P252, ""
    push $P252, ""
    .return ($P252)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("33_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P285 = "35_1304282286.73" 
    capture_lex $P285
    .local string rx254_tgt
    .local int rx254_pos
    .local int rx254_off
    .local int rx254_eos
    .local int rx254_rep
    .local pmc rx254_cur
    .local pmc rx254_debug
    (rx254_cur, rx254_pos, rx254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx254_cur
    .local pmc match
    .lex "$/", match
    length rx254_eos, rx254_tgt
    gt rx254_pos, rx254_eos, rx254_done
    set rx254_off, 0
    lt rx254_pos, 2, rx254_start
    sub rx254_off, rx254_pos, 1
    substr rx254_tgt, rx254_tgt, rx254_off
  rx254_start:
    eq $I10, 1, rx254_restart
    if_null rx254_debug, debug_828
    rx254_cur."!cursor_debug"("START", "pod_comment")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan257_done
    goto rxscan257_scan
  rxscan257_loop:
    (rx254_pos) = rx254_cur."from"()
    inc rx254_pos
    rx254_cur."!cursor_from"(rx254_pos)
    ge rx254_pos, rx254_eos, rxscan257_done
  rxscan257_scan:
    set_addr $I10, rxscan257_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  rxscan257_done:
.annotate 'line', 78
  # rxanchor bol
    eq rx254_pos, 0, rxanchor258_done
    ge rx254_pos, rx254_eos, rx254_fail
    sub $I10, rx254_pos, rx254_off
    dec $I10
    is_cclass $I11, 4096, rx254_tgt, $I10
    unless $I11, rx254_fail
  rxanchor258_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq259_loop:
    le $I12, 0, rxenumcharlistq259_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq259_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq259_loop
  rxenumcharlistq259_done:
    add rx254_pos, rx254_pos, rx254_rep
  # rx literal  "="
    add $I11, rx254_pos, 1
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    ord $I11, rx254_tgt, $I11
    ne $I11, 61, rx254_fail
    add rx254_pos, 1
  alt260_0:
.annotate 'line', 79
    set_addr $I10, alt260_1
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx254_pos, 5
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 5
    ne $S10, "begin", rx254_fail
    add rx254_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq261_loop:
    le $I12, 0, rxenumcharlistq261_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq261_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq261_loop
  rxenumcharlistq261_done:
    lt rx254_rep, 1, rx254_fail
    add rx254_pos, rx254_pos, rx254_rep
  # rx literal  "END"
    add $I11, rx254_pos, 3
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 3
    ne $S10, "END", rx254_fail
    add rx254_pos, 3
  # rxanchor rwb
    le rx254_pos, 0, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 8192, rx254_tgt, $I10
    if $I11, rx254_fail
    dec $I10
    is_cclass $I11, 8192, rx254_tgt, $I10
    unless $I11, rx254_fail
  alt262_0:
.annotate 'line', 81
    set_addr $I10, alt262_1
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  # rx rxquantf263 ** 0..*
    set_addr $I10, rxquantf263_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
    goto rxquantf263_done
  rxquantf263_loop:
  # rx charclass .
    ge rx254_pos, rx254_eos, rx254_fail
    inc rx254_pos
    set_addr $I10, rxquantf263_loop
    rx254_cur."!mark_push"(rx254_rep, rx254_pos, $I10)
  rxquantf263_done:
  # rx charclass nl
    ge rx254_pos, rx254_eos, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 4096, rx254_tgt, $I10
    unless $I11, rx254_fail
    substr $S10, rx254_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx254_pos, $I11
    inc rx254_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq265_loop:
    le $I12, 0, rxenumcharlistq265_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq265_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq265_loop
  rxenumcharlistq265_done:
    add rx254_pos, rx254_pos, rx254_rep
  # rx literal  "=end"
    add $I11, rx254_pos, 4
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 4
    ne $S10, "=end", rx254_fail
    add rx254_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq266_loop:
    le $I12, 0, rxenumcharlistq266_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq266_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq266_loop
  rxenumcharlistq266_done:
    lt rx254_rep, 1, rx254_fail
    add rx254_pos, rx254_pos, rx254_rep
  # rx literal  "END"
    add $I11, rx254_pos, 3
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 3
    ne $S10, "END", rx254_fail
    add rx254_pos, 3
  # rxanchor rwb
    le rx254_pos, 0, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 8192, rx254_tgt, $I10
    if $I11, rx254_fail
    dec $I10
    is_cclass $I11, 8192, rx254_tgt, $I10
    unless $I11, rx254_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx254_pos, rx254_off
    find_cclass $I11, 4096, rx254_tgt, $I10, rx254_eos
    add rx254_pos, rx254_off, $I11
    goto alt262_end
  alt262_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx254_pos, rx254_off
    find_not_cclass $I11, 65535, rx254_tgt, $I10, rx254_eos
    add rx254_pos, rx254_off, $I11
  alt262_end:
.annotate 'line', 80
    goto alt260_end
  alt260_1:
    set_addr $I10, alt260_2
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
.annotate 'line', 82
  # rx literal  "begin"
    add $I11, rx254_pos, 5
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 5
    ne $S10, "begin", rx254_fail
    add rx254_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq267_loop:
    le $I12, 0, rxenumcharlistq267_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq267_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq267_loop
  rxenumcharlistq267_done:
    lt rx254_rep, 1, rx254_fail
    add rx254_pos, rx254_pos, rx254_rep
  # rx subrule "identifier" subtype=capture negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."identifier"()
    unless $P10, rx254_fail
    rx254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx254_pos = $P10."pos"()
  alt268_0:
.annotate 'line', 83
    set_addr $I10, alt268_1
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
.annotate 'line', 84
  # rx rxquantf269 ** 0..*
    set_addr $I10, rxquantf269_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
    goto rxquantf269_done
  rxquantf269_loop:
  # rx charclass .
    ge rx254_pos, rx254_eos, rx254_fail
    inc rx254_pos
    set_addr $I10, rxquantf269_loop
    rx254_cur."!mark_push"(rx254_rep, rx254_pos, $I10)
  rxquantf269_done:
  # rx charclass nl
    ge rx254_pos, rx254_eos, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 4096, rx254_tgt, $I10
    unless $I11, rx254_fail
    substr $S10, rx254_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx254_pos, $I11
    inc rx254_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq271_loop:
    le $I12, 0, rxenumcharlistq271_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq271_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq271_loop
  rxenumcharlistq271_done:
    add rx254_pos, rx254_pos, rx254_rep
  # rx literal  "=end"
    add $I11, rx254_pos, 4
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 4
    ne $S10, "=end", rx254_fail
    add rx254_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq272_loop:
    le $I12, 0, rxenumcharlistq272_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq272_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq272_loop
  rxenumcharlistq272_done:
    lt rx254_rep, 1, rx254_fail
    add rx254_pos, rx254_pos, rx254_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."!BACKREF"("identifier")
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  # rxanchor rwb
    le rx254_pos, 0, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 8192, rx254_tgt, $I10
    if $I11, rx254_fail
    dec $I10
    is_cclass $I11, 8192, rx254_tgt, $I10
    unless $I11, rx254_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx254_pos, rx254_off
    find_cclass $I11, 4096, rx254_tgt, $I10, rx254_eos
    add rx254_pos, rx254_off, $I11
    goto alt268_end
  alt268_1:
.annotate 'line', 85
  # rx subrule "panic" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."panic"("=begin without matching =end")
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  alt268_end:
.annotate 'line', 82
    goto alt260_end
  alt260_2:
    set_addr $I10, alt260_3
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx254_pos, 5
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 5
    ne $S10, "begin", rx254_fail
    add rx254_pos, 5
  # rxanchor rwb
    le rx254_pos, 0, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 8192, rx254_tgt, $I10
    if $I11, rx254_fail
    dec $I10
    is_cclass $I11, 8192, rx254_tgt, $I10
    unless $I11, rx254_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq274_loop:
    le $I12, 0, rxenumcharlistq274_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq274_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq274_loop
  rxenumcharlistq274_done:
    add rx254_pos, rx254_pos, rx254_rep
  alt275_0:
.annotate 'line', 88
    set_addr $I10, alt275_1
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  # rxanchor eol
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 4096, rx254_tgt, $I10
    if $I11, rxanchor276_done
    ne rx254_pos, rx254_eos, rx254_fail
    eq rx254_pos, 0, rxanchor276_done
    dec $I10
    is_cclass $I11, 4096, rx254_tgt, $I10
    if $I11, rx254_fail
  rxanchor276_done:
    goto alt275_end
  alt275_1:
    set_addr $I10, alt275_2
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  # rx literal  "#"
    add $I11, rx254_pos, 1
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    ord $I11, rx254_tgt, $I11
    ne $I11, 35, rx254_fail
    add rx254_pos, 1
    goto alt275_end
  alt275_2:
  # rx subrule "panic" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  alt275_end:
  alt277_0:
.annotate 'line', 89
    set_addr $I10, alt277_1
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
.annotate 'line', 90
  # rx rxquantf278 ** 0..*
    set_addr $I10, rxquantf278_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
    goto rxquantf278_done
  rxquantf278_loop:
  # rx charclass .
    ge rx254_pos, rx254_eos, rx254_fail
    inc rx254_pos
    set_addr $I10, rxquantf278_loop
    rx254_cur."!mark_push"(rx254_rep, rx254_pos, $I10)
  rxquantf278_done:
  # rx charclass nl
    ge rx254_pos, rx254_eos, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 4096, rx254_tgt, $I10
    unless $I11, rx254_fail
    substr $S10, rx254_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx254_pos, $I11
    inc rx254_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx254_pos, rx254_off
    set rx254_rep, 0
    sub $I12, rx254_eos, rx254_pos
  rxenumcharlistq280_loop:
    le $I12, 0, rxenumcharlistq280_done
    substr $S10, rx254_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq280_done
    inc rx254_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq280_loop
  rxenumcharlistq280_done:
    add rx254_pos, rx254_pos, rx254_rep
  # rx literal  "=end"
    add $I11, rx254_pos, 4
    gt $I11, rx254_eos, rx254_fail
    sub $I11, rx254_pos, rx254_off
    substr $S10, rx254_tgt, $I11, 4
    ne $S10, "=end", rx254_fail
    add rx254_pos, 4
  # rxanchor rwb
    le rx254_pos, 0, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 8192, rx254_tgt, $I10
    if $I11, rx254_fail
    dec $I10
    is_cclass $I11, 8192, rx254_tgt, $I10
    unless $I11, rx254_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx254_pos, rx254_off
    find_cclass $I11, 4096, rx254_tgt, $I10, rx254_eos
    add rx254_pos, rx254_off, $I11
    goto alt277_end
  alt277_1:
.annotate 'line', 91
  # rx subrule "panic" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."panic"("=begin without matching =end")
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  alt277_end:
.annotate 'line', 87
    goto alt260_end
  alt260_3:
    set_addr $I10, alt260_4
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
.annotate 'line', 93
  # rx subrule "identifier" subtype=capture negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."identifier"()
    unless $P10, rx254_fail
    rx254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx254_pos = $P10."pos"()
.annotate 'line', 94
  # rx rxquantf281 ** 0..*
    set_addr $I10, rxquantf281_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
    goto rxquantf281_done
  rxquantf281_loop:
  # rx charclass .
    ge rx254_pos, rx254_eos, rx254_fail
    inc rx254_pos
    set_addr $I10, rxquantf281_loop
    rx254_cur."!mark_push"(rx254_rep, rx254_pos, $I10)
  rxquantf281_done:
  # rxanchor bol
    eq rx254_pos, 0, rxanchor283_done
    ge rx254_pos, rx254_eos, rx254_fail
    sub $I10, rx254_pos, rx254_off
    dec $I10
    is_cclass $I11, 4096, rx254_tgt, $I10
    unless $I11, rx254_fail
  rxanchor283_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    .const 'Sub' $P285 = "35_1304282286.73" 
    capture_lex $P285
    $P10 = rx254_cur."before"($P285)
    unless $P10, rx254_fail
.annotate 'line', 93
    goto alt260_end
  alt260_4:
  alt291_0:
.annotate 'line', 100
    set_addr $I10, alt291_1
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  # rx charclass s
    ge rx254_pos, rx254_eos, rx254_fail
    sub $I10, rx254_pos, rx254_off
    is_cclass $I11, 32, rx254_tgt, $I10
    unless $I11, rx254_fail
    inc rx254_pos
    goto alt291_end
  alt291_1:
  # rx subrule "panic" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."panic"("Illegal pod directive")
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  alt291_end:
.annotate 'line', 101
  # rx charclass_q N r 0..-1
    sub $I10, rx254_pos, rx254_off
    find_cclass $I11, 4096, rx254_tgt, $I10, rx254_eos
    add rx254_pos, rx254_off, $I11
  alt260_end:
.annotate 'line', 77
  # rx pass
    rx254_cur."!cursor_pass"(rx254_pos, "pod_comment")
    if_null rx254_debug, debug_833
    rx254_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx254_pos)
  debug_833:
    .return (rx254_cur)
  rx254_restart:
.annotate 'line', 10
    if_null rx254_debug, debug_834
    rx254_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_834:
  rx254_fail:
    (rx254_rep, rx254_pos, $I10, $P10) = rx254_cur."!mark_fail"(0)
    lt rx254_pos, -1, rx254_done
    eq rx254_pos, -1, rx254_fail
    jump $I10
  rx254_done:
    rx254_cur."!cursor_fail"()
    if_null rx254_debug, debug_835
    rx254_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_835:
    .return (rx254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("34_1304282286.73") :method
.annotate 'line', 10
    new $P256, "ResizablePMCArray"
    push $P256, ""
    .return ($P256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block284"  :anon :subid("35_1304282286.73") :method :outer("33_1304282286.73")
.annotate 'line', 94
    .local string rx286_tgt
    .local int rx286_pos
    .local int rx286_off
    .local int rx286_eos
    .local int rx286_rep
    .local pmc rx286_cur
    .local pmc rx286_debug
    (rx286_cur, rx286_pos, rx286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx286_cur
    .local pmc match
    .lex "$/", match
    length rx286_eos, rx286_tgt
    gt rx286_pos, rx286_eos, rx286_done
    set rx286_off, 0
    lt rx286_pos, 2, rx286_start
    sub rx286_off, rx286_pos, 1
    substr rx286_tgt, rx286_tgt, rx286_off
  rx286_start:
    eq $I10, 1, rx286_restart
    if_null rx286_debug, debug_829
    rx286_cur."!cursor_debug"("START", "")
  debug_829:
    $I10 = self.'from'()
    ne $I10, -1, rxscan287_done
    goto rxscan287_scan
  rxscan287_loop:
    (rx286_pos) = rx286_cur."from"()
    inc rx286_pos
    rx286_cur."!cursor_from"(rx286_pos)
    ge rx286_pos, rx286_eos, rxscan287_done
  rxscan287_scan:
    set_addr $I10, rxscan287_loop
    rx286_cur."!mark_push"(0, rx286_pos, $I10)
  rxscan287_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx286_pos, rx286_off
    set rx286_rep, 0
    sub $I12, rx286_eos, rx286_pos
  rxenumcharlistq288_loop:
    le $I12, 0, rxenumcharlistq288_done
    substr $S10, rx286_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq288_done
    inc rx286_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq288_loop
  rxenumcharlistq288_done:
    add rx286_pos, rx286_pos, rx286_rep
  alt289_0:
    set_addr $I10, alt289_1
    rx286_cur."!mark_push"(0, rx286_pos, $I10)
.annotate 'line', 95
  # rx literal  "="
    add $I11, rx286_pos, 1
    gt $I11, rx286_eos, rx286_fail
    sub $I11, rx286_pos, rx286_off
    ord $I11, rx286_tgt, $I11
    ne $I11, 61, rx286_fail
    add rx286_pos, 1
.annotate 'line', 97
  # rx rxquantr290 ** 0..1
    set_addr $I10, rxquantr290_done
    rx286_cur."!mark_push"(0, rx286_pos, $I10)
  rxquantr290_loop:
.annotate 'line', 96
  # rx literal  "cut"
    add $I11, rx286_pos, 3
    gt $I11, rx286_eos, rx286_fail
    sub $I11, rx286_pos, rx286_off
    substr $S10, rx286_tgt, $I11, 3
    ne $S10, "cut", rx286_fail
    add rx286_pos, 3
  # rxanchor rwb
    le rx286_pos, 0, rx286_fail
    sub $I10, rx286_pos, rx286_off
    is_cclass $I11, 8192, rx286_tgt, $I10
    if $I11, rx286_fail
    dec $I10
    is_cclass $I11, 8192, rx286_tgt, $I10
    unless $I11, rx286_fail
.annotate 'line', 97
  # rx subrule "panic" subtype=method negate=
    rx286_cur."!cursor_pos"(rx286_pos)
    $P10 = rx286_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx286_fail
    rx286_pos = $P10."pos"()
    set_addr $I10, rxquantr290_done
    (rx286_rep) = rx286_cur."!mark_commit"($I10)
  rxquantr290_done:
.annotate 'line', 94
    goto alt289_end
  alt289_1:
.annotate 'line', 98
  # rx charclass nl
    ge rx286_pos, rx286_eos, rx286_fail
    sub $I10, rx286_pos, rx286_off
    is_cclass $I11, 4096, rx286_tgt, $I10
    unless $I11, rx286_fail
    substr $S10, rx286_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx286_pos, $I11
    inc rx286_pos
  alt289_end:
.annotate 'line', 94
  # rx pass
    rx286_cur."!cursor_pass"(rx286_pos, "")
    if_null rx286_debug, debug_830
    rx286_cur."!cursor_debug"("PASS", "", " at pos=", rx286_pos)
  debug_830:
    .return (rx286_cur)
  rx286_restart:
    if_null rx286_debug, debug_831
    rx286_cur."!cursor_debug"("NEXT", "")
  debug_831:
  rx286_fail:
    (rx286_rep, rx286_pos, $I10, $P10) = rx286_cur."!mark_fail"(0)
    lt rx286_pos, -1, rx286_done
    eq rx286_pos, -1, rx286_fail
    jump $I10
  rx286_done:
    rx286_cur."!cursor_fail"()
    if_null rx286_debug, debug_832
    rx286_cur."!cursor_debug"("FAIL", "")
  debug_832:
    .return (rx286_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("36_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P293, "ResizablePMCArray"
    push $P293, ""
    .return ($P293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("37_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 109
    new $P295, "Undef"
    .lex "$*IN_DECL", $P295
.annotate 'line', 111
    new $P296, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P296
.annotate 'line', 112
    new $P297, "Undef"
    .lex "$*MAIN_SUB", $P297
.annotate 'line', 115
    new $P298, "Undef"
    .lex "$*PACKAGE", $P298
.annotate 'line', 116
    new $P299, "Undef"
    .lex "$*GLOBALish", $P299
.annotate 'line', 10
    .local string rx300_tgt
    .local int rx300_pos
    .local int rx300_off
    .local int rx300_eos
    .local int rx300_rep
    .local pmc rx300_cur
    .local pmc rx300_debug
    (rx300_cur, rx300_pos, rx300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx300_cur
    .local pmc match
    .lex "$/", match
    length rx300_eos, rx300_tgt
    gt rx300_pos, rx300_eos, rx300_done
    set rx300_off, 0
    lt rx300_pos, 2, rx300_start
    sub rx300_off, rx300_pos, 1
    substr rx300_tgt, rx300_tgt, rx300_off
  rx300_start:
    eq $I10, 1, rx300_restart
    if_null rx300_debug, debug_836
    rx300_cur."!cursor_debug"("START", "comp_unit")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan304_done
    goto rxscan304_scan
  rxscan304_loop:
    (rx300_pos) = rx300_cur."from"()
    inc rx300_pos
    rx300_cur."!cursor_from"(rx300_pos)
    ge rx300_pos, rx300_eos, rxscan304_done
  rxscan304_scan:
    set_addr $I10, rxscan304_loop
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxscan304_done:
.annotate 'line', 109
    rx300_cur."!cursor_pos"(rx300_pos)
    new $P305, "String"
    assign $P305, ""
    store_lex "$*IN_DECL", $P305
.annotate 'line', 111
    rx300_cur."!cursor_pos"(rx300_pos)
    new $P306, "Integer"
    assign $P306, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P306
.annotate 'line', 112
    rx300_cur."!cursor_pos"(rx300_pos)
    find_lex $P309, "$*MAIN_SUB"
    unless_null $P309, vivify_837
    get_hll_global $P307, "GLOBAL"
    get_who $P308, $P307
    set $P309, $P308["$MAIN_SUB"]
    unless_null $P309, vivify_838
    die "Contextual $*MAIN_SUB not found"
  vivify_838:
  vivify_837:
.annotate 'line', 113
  # rx subrule "newpad" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."newpad"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
.annotate 'line', 115
    rx300_cur."!cursor_pos"(rx300_pos)
    find_lex $P312, "$*PACKAGE"
    unless_null $P312, vivify_839
    get_hll_global $P310, "GLOBAL"
    get_who $P311, $P310
    set $P312, $P311["$PACKAGE"]
    unless_null $P312, vivify_840
    die "Contextual $*PACKAGE not found"
  vivify_840:
  vivify_839:
.annotate 'line', 116
    rx300_cur."!cursor_pos"(rx300_pos)
    find_lex $P315, "$*GLOBALish"
    unless_null $P315, vivify_841
    get_hll_global $P313, "GLOBAL"
    get_who $P314, $P313
    set $P315, $P314["$GLOBALish"]
    unless_null $P315, vivify_842
    die "Contextual $*GLOBALish not found"
  vivify_842:
  vivify_841:
.annotate 'line', 117
  # rx subrule "GLOBALish" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."GLOBALish"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."outerctx"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
.annotate 'line', 121
  # rx subrule "statementlist" subtype=capture negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."statementlist"()
    unless $P10, rx300_fail
    rx300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx300_pos = $P10."pos"()
  alt316_0:
.annotate 'line', 122
    set_addr $I10, alt316_1
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  # rxanchor eos
    ne rx300_pos, rx300_eos, rx300_fail
    goto alt316_end
  alt316_1:
  # rx subrule "panic" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."panic"("Confused")
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  alt316_end:
.annotate 'line', 108
  # rx pass
    rx300_cur."!cursor_pass"(rx300_pos, "comp_unit")
    if_null rx300_debug, debug_843
    rx300_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx300_pos)
  debug_843:
    .return (rx300_cur)
  rx300_restart:
.annotate 'line', 10
    if_null rx300_debug, debug_844
    rx300_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_844:
  rx300_fail:
    (rx300_rep, rx300_pos, $I10, $P10) = rx300_cur."!mark_fail"(0)
    lt rx300_pos, -1, rx300_done
    eq rx300_pos, -1, rx300_fail
    jump $I10
  rx300_done:
    rx300_cur."!cursor_fail"()
    if_null rx300_debug, debug_845
    rx300_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_845:
    .return (rx300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("38_1304282286.73") :method
.annotate 'line', 10
    $P302 = self."!PREFIX__!subrule"("newpad", "")
    new $P303, "ResizablePMCArray"
    push $P303, $P302
    .return ($P303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("39_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P318 = self."!PREFIX__!subrule"("newpad", "")
    new $P319, "ResizablePMCArray"
    push $P319, $P318
    .return ($P319)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("40_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx321_tgt
    .local int rx321_pos
    .local int rx321_off
    .local int rx321_eos
    .local int rx321_rep
    .local pmc rx321_cur
    .local pmc rx321_debug
    (rx321_cur, rx321_pos, rx321_tgt, $I10) = self."!cursor_start"()
    rx321_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx321_cur
    .local pmc match
    .lex "$/", match
    length rx321_eos, rx321_tgt
    gt rx321_pos, rx321_eos, rx321_done
    set rx321_off, 0
    lt rx321_pos, 2, rx321_start
    sub rx321_off, rx321_pos, 1
    substr rx321_tgt, rx321_tgt, rx321_off
  rx321_start:
    eq $I10, 1, rx321_restart
    if_null rx321_debug, debug_846
    rx321_cur."!cursor_debug"("START", "statementlist")
  debug_846:
    $I10 = self.'from'()
    ne $I10, -1, rxscan326_done
    goto rxscan326_scan
  rxscan326_loop:
    (rx321_pos) = rx321_cur."from"()
    inc rx321_pos
    rx321_cur."!cursor_from"(rx321_pos)
    ge rx321_pos, rx321_eos, rxscan326_done
  rxscan326_scan:
    set_addr $I10, rxscan326_loop
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  rxscan326_done:
  alt327_0:
.annotate 'line', 125
    set_addr $I10, alt327_1
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
  # rxanchor eos
    ne rx321_pos, rx321_eos, rx321_fail
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
    goto alt327_end
  alt327_1:
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
  # rx rxquantr331 ** 0..*
    set_addr $I10, rxquantr331_done
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  rxquantr331_loop:
  # rx subrule "statement" subtype=capture negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."statement"()
    unless $P10, rx321_fail
    rx321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx321_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."eat_terminator"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
    set_addr $I10, rxquantr331_done
    (rx321_rep) = rx321_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr331_done
    rx321_cur."!mark_push"(rx321_rep, rx321_pos, $I10)
    goto rxquantr331_loop
  rxquantr331_done:
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
  alt327_end:
.annotate 'line', 125
  # rx pass
    rx321_cur."!cursor_pass"(rx321_pos, "statementlist")
    if_null rx321_debug, debug_847
    rx321_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx321_pos)
  debug_847:
    .return (rx321_cur)
  rx321_restart:
.annotate 'line', 10
    if_null rx321_debug, debug_848
    rx321_cur."!cursor_debug"("NEXT", "statementlist")
  debug_848:
  rx321_fail:
    (rx321_rep, rx321_pos, $I10, $P10) = rx321_cur."!mark_fail"(0)
    lt rx321_pos, -1, rx321_done
    eq rx321_pos, -1, rx321_fail
    jump $I10
  rx321_done:
    rx321_cur."!cursor_fail"()
    if_null rx321_debug, debug_849
    rx321_cur."!cursor_debug"("FAIL", "statementlist")
  debug_849:
    .return (rx321_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("41_1304282286.73") :method
.annotate 'line', 10
    $P323 = self."!PREFIX__!subrule"("ws", "")
    $P324 = self."!PREFIX__!subrule"("ws", "")
    new $P325, "ResizablePMCArray"
    push $P325, $P323
    push $P325, $P324
    .return ($P325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("42_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P335 = self."!PREFIX__!subrule"("ws", "")
    $P336 = self."!PREFIX__!subrule"("ws", "")
    new $P337, "ResizablePMCArray"
    push $P337, $P335
    push $P337, $P336
    .return ($P337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("43_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P344 = "45_1304282286.73" 
    capture_lex $P344
    .local string rx339_tgt
    .local int rx339_pos
    .local int rx339_off
    .local int rx339_eos
    .local int rx339_rep
    .local pmc rx339_cur
    .local pmc rx339_debug
    (rx339_cur, rx339_pos, rx339_tgt, $I10) = self."!cursor_start"()
    rx339_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx339_cur
    .local pmc match
    .lex "$/", match
    length rx339_eos, rx339_tgt
    gt rx339_pos, rx339_eos, rx339_done
    set rx339_off, 0
    lt rx339_pos, 2, rx339_start
    sub rx339_off, rx339_pos, 1
    substr rx339_tgt, rx339_tgt, rx339_off
  rx339_start:
    eq $I10, 1, rx339_restart
    if_null rx339_debug, debug_850
    rx339_cur."!cursor_debug"("START", "statement")
  debug_850:
    $I10 = self.'from'()
    ne $I10, -1, rxscan342_done
    goto rxscan342_scan
  rxscan342_loop:
    (rx339_pos) = rx339_cur."from"()
    inc rx339_pos
    rx339_cur."!cursor_from"(rx339_pos)
    ge rx339_pos, rx339_eos, rxscan342_done
  rxscan342_scan:
    set_addr $I10, rxscan342_loop
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  rxscan342_done:
.annotate 'line', 131
  # rx subrule "before" subtype=zerowidth negate=1
    rx339_cur."!cursor_pos"(rx339_pos)
    .const 'Sub' $P344 = "45_1304282286.73" 
    capture_lex $P344
    $P10 = rx339_cur."before"($P344)
    if $P10, rx339_fail
  alt348_0:
.annotate 'line', 132
    set_addr $I10, alt348_1
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
.annotate 'line', 133
  # rx subrule "statement_control" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."statement_control"()
    unless $P10, rx339_fail
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx339_pos = $P10."pos"()
    goto alt348_end
  alt348_1:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."EXPR"()
    unless $P10, rx339_fail
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx339_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."ws"()
    unless $P10, rx339_fail
    rx339_pos = $P10."pos"()
.annotate 'line', 139
  # rx rxquantr349 ** 0..1
    set_addr $I10, rxquantr349_done
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  rxquantr349_loop:
  alt350_0:
.annotate 'line', 135
    set_addr $I10, alt350_1
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
.annotate 'line', 136
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."MARKED"("endstmt")
    unless $P10, rx339_fail
    goto alt350_end
  alt350_1:
    set_addr $I10, alt350_2
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."statement_mod_cond"()
    unless $P10, rx339_fail
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx339_pos = $P10."pos"()
  # rx rxquantr351 ** 0..1
    set_addr $I10, rxquantr351_done
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  rxquantr351_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."statement_mod_loop"()
    unless $P10, rx339_fail
    goto rxsubrule352_pass
  rxsubrule352_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx339_fail
  rxsubrule352_pass:
    set_addr $I10, rxsubrule352_back
    rx339_cur."!mark_push"(0, rx339_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx339_pos = $P10."pos"()
    set_addr $I10, rxquantr351_done
    (rx339_rep) = rx339_cur."!mark_commit"($I10)
  rxquantr351_done:
    goto alt350_end
  alt350_2:
.annotate 'line', 138
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."statement_mod_loop"()
    unless $P10, rx339_fail
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx339_pos = $P10."pos"()
  alt350_end:
.annotate 'line', 139
    set_addr $I10, rxquantr349_done
    (rx339_rep) = rx339_cur."!mark_commit"($I10)
  rxquantr349_done:
  alt348_end:
.annotate 'line', 130
  # rx pass
    rx339_cur."!cursor_pass"(rx339_pos, "statement")
    if_null rx339_debug, debug_855
    rx339_cur."!cursor_debug"("PASS", "statement", " at pos=", rx339_pos)
  debug_855:
    .return (rx339_cur)
  rx339_restart:
.annotate 'line', 10
    if_null rx339_debug, debug_856
    rx339_cur."!cursor_debug"("NEXT", "statement")
  debug_856:
  rx339_fail:
    (rx339_rep, rx339_pos, $I10, $P10) = rx339_cur."!mark_fail"(0)
    lt rx339_pos, -1, rx339_done
    eq rx339_pos, -1, rx339_fail
    jump $I10
  rx339_done:
    rx339_cur."!cursor_fail"()
    if_null rx339_debug, debug_857
    rx339_cur."!cursor_debug"("FAIL", "statement")
  debug_857:
    .return (rx339_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("44_1304282286.73") :method
.annotate 'line', 10
    new $P341, "ResizablePMCArray"
    push $P341, ""
    .return ($P341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block343"  :anon :subid("45_1304282286.73") :method :outer("43_1304282286.73")
.annotate 'line', 131
    .local string rx345_tgt
    .local int rx345_pos
    .local int rx345_off
    .local int rx345_eos
    .local int rx345_rep
    .local pmc rx345_cur
    .local pmc rx345_debug
    (rx345_cur, rx345_pos, rx345_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx345_cur
    .local pmc match
    .lex "$/", match
    length rx345_eos, rx345_tgt
    gt rx345_pos, rx345_eos, rx345_done
    set rx345_off, 0
    lt rx345_pos, 2, rx345_start
    sub rx345_off, rx345_pos, 1
    substr rx345_tgt, rx345_tgt, rx345_off
  rx345_start:
    eq $I10, 1, rx345_restart
    if_null rx345_debug, debug_851
    rx345_cur."!cursor_debug"("START", "")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan346_done
    goto rxscan346_scan
  rxscan346_loop:
    (rx345_pos) = rx345_cur."from"()
    inc rx345_pos
    rx345_cur."!cursor_from"(rx345_pos)
    ge rx345_pos, rx345_eos, rxscan346_done
  rxscan346_scan:
    set_addr $I10, rxscan346_loop
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxscan346_done:
  alt347_0:
    set_addr $I10, alt347_1
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx345_fail
    inc rx345_pos
    goto alt347_end
  alt347_1:
  # rxanchor eos
    ne rx345_pos, rx345_eos, rx345_fail
  alt347_end:
  # rx pass
    rx345_cur."!cursor_pass"(rx345_pos, "")
    if_null rx345_debug, debug_852
    rx345_cur."!cursor_debug"("PASS", "", " at pos=", rx345_pos)
  debug_852:
    .return (rx345_cur)
  rx345_restart:
    if_null rx345_debug, debug_853
    rx345_cur."!cursor_debug"("NEXT", "")
  debug_853:
  rx345_fail:
    (rx345_rep, rx345_pos, $I10, $P10) = rx345_cur."!mark_fail"(0)
    lt rx345_pos, -1, rx345_done
    eq rx345_pos, -1, rx345_fail
    jump $I10
  rx345_done:
    rx345_cur."!cursor_fail"()
    if_null rx345_debug, debug_854
    rx345_cur."!cursor_debug"("FAIL", "")
  debug_854:
    .return (rx345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("46_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P354, "ResizablePMCArray"
    push $P354, ""
    .return ($P354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("47_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx356_tgt
    .local int rx356_pos
    .local int rx356_off
    .local int rx356_eos
    .local int rx356_rep
    .local pmc rx356_cur
    .local pmc rx356_debug
    (rx356_cur, rx356_pos, rx356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx356_cur
    .local pmc match
    .lex "$/", match
    length rx356_eos, rx356_tgt
    gt rx356_pos, rx356_eos, rx356_done
    set rx356_off, 0
    lt rx356_pos, 2, rx356_start
    sub rx356_off, rx356_pos, 1
    substr rx356_tgt, rx356_tgt, rx356_off
  rx356_start:
    eq $I10, 1, rx356_restart
    if_null rx356_debug, debug_858
    rx356_cur."!cursor_debug"("START", "eat_terminator")
  debug_858:
    $I10 = self.'from'()
    ne $I10, -1, rxscan359_done
    goto rxscan359_scan
  rxscan359_loop:
    (rx356_pos) = rx356_cur."from"()
    inc rx356_pos
    rx356_cur."!cursor_from"(rx356_pos)
    ge rx356_pos, rx356_eos, rxscan359_done
  rxscan359_scan:
    set_addr $I10, rxscan359_loop
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  rxscan359_done:
  alt360_0:
.annotate 'line', 143
    set_addr $I10, alt360_1
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
.annotate 'line', 144
  # rx literal  ";"
    add $I11, rx356_pos, 1
    gt $I11, rx356_eos, rx356_fail
    sub $I11, rx356_pos, rx356_off
    ord $I11, rx356_tgt, $I11
    ne $I11, 59, rx356_fail
    add rx356_pos, 1
    goto alt360_end
  alt360_1:
    set_addr $I10, alt360_2
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
.annotate 'line', 145
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."MARKED"("endstmt")
    unless $P10, rx356_fail
    goto alt360_end
  alt360_2:
    set_addr $I10, alt360_3
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
.annotate 'line', 146
  # rx subrule "terminator" subtype=zerowidth negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."terminator"()
    unless $P10, rx356_fail
    goto alt360_end
  alt360_3:
.annotate 'line', 147
  # rxanchor eos
    ne rx356_pos, rx356_eos, rx356_fail
  alt360_end:
.annotate 'line', 143
  # rx pass
    rx356_cur."!cursor_pass"(rx356_pos, "eat_terminator")
    if_null rx356_debug, debug_859
    rx356_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx356_pos)
  debug_859:
    .return (rx356_cur)
  rx356_restart:
.annotate 'line', 10
    if_null rx356_debug, debug_860
    rx356_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_860:
  rx356_fail:
    (rx356_rep, rx356_pos, $I10, $P10) = rx356_cur."!mark_fail"(0)
    lt rx356_pos, -1, rx356_done
    eq rx356_pos, -1, rx356_fail
    jump $I10
  rx356_done:
    rx356_cur."!cursor_fail"()
    if_null rx356_debug, debug_861
    rx356_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_861:
    .return (rx356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("48_1304282286.73") :method
.annotate 'line', 10
    new $P358, "ResizablePMCArray"
    push $P358, ""
    push $P358, ""
    push $P358, ""
    push $P358, ";"
    .return ($P358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("49_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P362, "ResizablePMCArray"
    push $P362, ""
    push $P362, ""
    push $P362, ""
    push $P362, ";"
    .return ($P362)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("50_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_862
    rx364_cur."!cursor_debug"("START", "xblock")
  debug_862:
    $I10 = self.'from'()
    ne $I10, -1, rxscan368_done
    goto rxscan368_scan
  rxscan368_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan368_done
  rxscan368_scan:
    set_addr $I10, rxscan368_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan368_done:
.annotate 'line', 151
  # rx subrule "EXPR" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."EXPR"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."pblock"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx364_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "xblock")
    if_null rx364_debug, debug_863
    rx364_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx364_pos)
  debug_863:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 10
    if_null rx364_debug, debug_864
    rx364_cur."!cursor_debug"("NEXT", "xblock")
  debug_864:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_865
    rx364_cur."!cursor_debug"("FAIL", "xblock")
  debug_865:
    .return (rx364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("51_1304282286.73") :method
.annotate 'line', 10
    $P366 = self."!PREFIX__!subrule"("EXPR", "")
    new $P367, "ResizablePMCArray"
    push $P367, $P366
    .return ($P367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("52_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P370 = self."!PREFIX__!subrule"("EXPR", "")
    new $P371, "ResizablePMCArray"
    push $P371, $P370
    .return ($P371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("53_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx373_tgt
    .local int rx373_pos
    .local int rx373_off
    .local int rx373_eos
    .local int rx373_rep
    .local pmc rx373_cur
    .local pmc rx373_debug
    (rx373_cur, rx373_pos, rx373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx373_cur
    .local pmc match
    .lex "$/", match
    length rx373_eos, rx373_tgt
    gt rx373_pos, rx373_eos, rx373_done
    set rx373_off, 0
    lt rx373_pos, 2, rx373_start
    sub rx373_off, rx373_pos, 1
    substr rx373_tgt, rx373_tgt, rx373_off
  rx373_start:
    eq $I10, 1, rx373_restart
    if_null rx373_debug, debug_866
    rx373_cur."!cursor_debug"("START", "pblock")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan378_done
    goto rxscan378_scan
  rxscan378_loop:
    (rx373_pos) = rx373_cur."from"()
    inc rx373_pos
    rx373_cur."!cursor_from"(rx373_pos)
    ge rx373_pos, rx373_eos, rxscan378_done
  rxscan378_scan:
    set_addr $I10, rxscan378_loop
    rx373_cur."!mark_push"(0, rx373_pos, $I10)
  rxscan378_done:
  alt379_0:
.annotate 'line', 154
    set_addr $I10, alt379_1
    rx373_cur."!mark_push"(0, rx373_pos, $I10)
.annotate 'line', 155
  # rx subrule "lambda" subtype=method negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."lambda"()
    unless $P10, rx373_fail
    rx373_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "newpad" subtype=method negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."newpad"()
    unless $P10, rx373_fail
    rx373_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "signature" subtype=capture negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."signature"()
    unless $P10, rx373_fail
    rx373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx373_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "blockoid" subtype=capture negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."blockoid"()
    unless $P10, rx373_fail
    rx373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx373_pos = $P10."pos"()
.annotate 'line', 155
    goto alt379_end
  alt379_1:
    set_addr $I10, alt379_2
    rx373_cur."!mark_push"(0, rx373_pos, $I10)
.annotate 'line', 159
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx373_pos, rx373_off
    substr $S10, rx373_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx373_fail
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."newpad"()
    unless $P10, rx373_fail
    rx373_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "blockoid" subtype=capture negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."blockoid"()
    unless $P10, rx373_fail
    rx373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx373_pos = $P10."pos"()
.annotate 'line', 159
    goto alt379_end
  alt379_2:
.annotate 'line', 162
  # rx subrule "panic" subtype=method negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."panic"("Missing block")
    unless $P10, rx373_fail
    rx373_pos = $P10."pos"()
  alt379_end:
.annotate 'line', 154
  # rx pass
    rx373_cur."!cursor_pass"(rx373_pos, "pblock")
    if_null rx373_debug, debug_867
    rx373_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx373_pos)
  debug_867:
    .return (rx373_cur)
  rx373_restart:
.annotate 'line', 10
    if_null rx373_debug, debug_868
    rx373_cur."!cursor_debug"("NEXT", "pblock")
  debug_868:
  rx373_fail:
    (rx373_rep, rx373_pos, $I10, $P10) = rx373_cur."!mark_fail"(0)
    lt rx373_pos, -1, rx373_done
    eq rx373_pos, -1, rx373_fail
    jump $I10
  rx373_done:
    rx373_cur."!cursor_fail"()
    if_null rx373_debug, debug_869
    rx373_cur."!cursor_debug"("FAIL", "pblock")
  debug_869:
    .return (rx373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("54_1304282286.73") :method
.annotate 'line', 10
    $P375 = self."!PREFIX__!subrule"("panic", "")
    $P376 = self."!PREFIX__!subrule"("lambda", "")
    new $P377, "ResizablePMCArray"
    push $P377, $P375
    push $P377, "{"
    push $P377, $P376
    .return ($P377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("55_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P381 = self."!PREFIX__!subrule"("panic", "")
    $P382 = self."!PREFIX__!subrule"("lambda", "")
    new $P383, "ResizablePMCArray"
    push $P383, $P381
    push $P383, "{"
    push $P383, $P382
    .return ($P383)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("56_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx385_tgt
    .local int rx385_pos
    .local int rx385_off
    .local int rx385_eos
    .local int rx385_rep
    .local pmc rx385_cur
    .local pmc rx385_debug
    (rx385_cur, rx385_pos, rx385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx385_cur
    .local pmc match
    .lex "$/", match
    length rx385_eos, rx385_tgt
    gt rx385_pos, rx385_eos, rx385_done
    set rx385_off, 0
    lt rx385_pos, 2, rx385_start
    sub rx385_off, rx385_pos, 1
    substr rx385_tgt, rx385_tgt, rx385_off
  rx385_start:
    eq $I10, 1, rx385_restart
    if_null rx385_debug, debug_870
    rx385_cur."!cursor_debug"("START", "lambda")
  debug_870:
    $I10 = self.'from'()
    ne $I10, -1, rxscan388_done
    goto rxscan388_scan
  rxscan388_loop:
    (rx385_pos) = rx385_cur."from"()
    inc rx385_pos
    rx385_cur."!cursor_from"(rx385_pos)
    ge rx385_pos, rx385_eos, rxscan388_done
  rxscan388_scan:
    set_addr $I10, rxscan388_loop
    rx385_cur."!mark_push"(0, rx385_pos, $I10)
  rxscan388_done:
  alt389_0:
.annotate 'line', 165
    set_addr $I10, alt389_1
    rx385_cur."!mark_push"(0, rx385_pos, $I10)
  # rx literal  "->"
    add $I11, rx385_pos, 2
    gt $I11, rx385_eos, rx385_fail
    sub $I11, rx385_pos, rx385_off
    substr $S10, rx385_tgt, $I11, 2
    ne $S10, "->", rx385_fail
    add rx385_pos, 2
    goto alt389_end
  alt389_1:
  # rx literal  "<->"
    add $I11, rx385_pos, 3
    gt $I11, rx385_eos, rx385_fail
    sub $I11, rx385_pos, rx385_off
    substr $S10, rx385_tgt, $I11, 3
    ne $S10, "<->", rx385_fail
    add rx385_pos, 3
  alt389_end:
  # rx pass
    rx385_cur."!cursor_pass"(rx385_pos, "lambda")
    if_null rx385_debug, debug_871
    rx385_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx385_pos)
  debug_871:
    .return (rx385_cur)
  rx385_restart:
.annotate 'line', 10
    if_null rx385_debug, debug_872
    rx385_cur."!cursor_debug"("NEXT", "lambda")
  debug_872:
  rx385_fail:
    (rx385_rep, rx385_pos, $I10, $P10) = rx385_cur."!mark_fail"(0)
    lt rx385_pos, -1, rx385_done
    eq rx385_pos, -1, rx385_fail
    jump $I10
  rx385_done:
    rx385_cur."!cursor_fail"()
    if_null rx385_debug, debug_873
    rx385_cur."!cursor_debug"("FAIL", "lambda")
  debug_873:
    .return (rx385_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("57_1304282286.73") :method
.annotate 'line', 10
    new $P387, "ResizablePMCArray"
    push $P387, "<->"
    push $P387, "->"
    .return ($P387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("58_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P391, "ResizablePMCArray"
    push $P391, "<->"
    push $P391, "->"
    .return ($P391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("59_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx393_tgt
    .local int rx393_pos
    .local int rx393_off
    .local int rx393_eos
    .local int rx393_rep
    .local pmc rx393_cur
    .local pmc rx393_debug
    (rx393_cur, rx393_pos, rx393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx393_cur
    .local pmc match
    .lex "$/", match
    length rx393_eos, rx393_tgt
    gt rx393_pos, rx393_eos, rx393_done
    set rx393_off, 0
    lt rx393_pos, 2, rx393_start
    sub rx393_off, rx393_pos, 1
    substr rx393_tgt, rx393_tgt, rx393_off
  rx393_start:
    eq $I10, 1, rx393_restart
    if_null rx393_debug, debug_874
    rx393_cur."!cursor_debug"("START", "block")
  debug_874:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx393_pos) = rx393_cur."from"()
    inc rx393_pos
    rx393_cur."!cursor_from"(rx393_pos)
    ge rx393_pos, rx393_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  rxscan397_done:
  alt398_0:
.annotate 'line', 168
    set_addr $I10, alt398_1
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx393_pos, rx393_off
    substr $S10, rx393_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx393_fail
    goto alt398_end
  alt398_1:
  # rx subrule "panic" subtype=method negate=
    rx393_cur."!cursor_pos"(rx393_pos)
    $P10 = rx393_cur."panic"("Missing block")
    unless $P10, rx393_fail
    rx393_pos = $P10."pos"()
  alt398_end:
.annotate 'line', 169
  # rx subrule "newpad" subtype=method negate=
    rx393_cur."!cursor_pos"(rx393_pos)
    $P10 = rx393_cur."newpad"()
    unless $P10, rx393_fail
    rx393_pos = $P10."pos"()
.annotate 'line', 170
  # rx subrule "blockoid" subtype=capture negate=
    rx393_cur."!cursor_pos"(rx393_pos)
    $P10 = rx393_cur."blockoid"()
    unless $P10, rx393_fail
    rx393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx393_pos = $P10."pos"()
.annotate 'line', 167
  # rx pass
    rx393_cur."!cursor_pass"(rx393_pos, "block")
    if_null rx393_debug, debug_875
    rx393_cur."!cursor_debug"("PASS", "block", " at pos=", rx393_pos)
  debug_875:
    .return (rx393_cur)
  rx393_restart:
.annotate 'line', 10
    if_null rx393_debug, debug_876
    rx393_cur."!cursor_debug"("NEXT", "block")
  debug_876:
  rx393_fail:
    (rx393_rep, rx393_pos, $I10, $P10) = rx393_cur."!mark_fail"(0)
    lt rx393_pos, -1, rx393_done
    eq rx393_pos, -1, rx393_fail
    jump $I10
  rx393_done:
    rx393_cur."!cursor_fail"()
    if_null rx393_debug, debug_877
    rx393_cur."!cursor_debug"("FAIL", "block")
  debug_877:
    .return (rx393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("60_1304282286.73") :method
.annotate 'line', 10
    $P395 = self."!PREFIX__!subrule"("panic", "")
    new $P396, "ResizablePMCArray"
    push $P396, $P395
    push $P396, "{"
    .return ($P396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("61_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P400 = self."!PREFIX__!subrule"("panic", "")
    new $P401, "ResizablePMCArray"
    push $P401, $P400
    push $P401, "{"
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("62_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx403_tgt
    .local int rx403_pos
    .local int rx403_off
    .local int rx403_eos
    .local int rx403_rep
    .local pmc rx403_cur
    .local pmc rx403_debug
    (rx403_cur, rx403_pos, rx403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx403_cur
    .local pmc match
    .lex "$/", match
    length rx403_eos, rx403_tgt
    gt rx403_pos, rx403_eos, rx403_done
    set rx403_off, 0
    lt rx403_pos, 2, rx403_start
    sub rx403_off, rx403_pos, 1
    substr rx403_tgt, rx403_tgt, rx403_off
  rx403_start:
    eq $I10, 1, rx403_restart
    if_null rx403_debug, debug_878
    rx403_cur."!cursor_debug"("START", "blockoid")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan407_done
    goto rxscan407_scan
  rxscan407_loop:
    (rx403_pos) = rx403_cur."from"()
    inc rx403_pos
    rx403_cur."!cursor_from"(rx403_pos)
    ge rx403_pos, rx403_eos, rxscan407_done
  rxscan407_scan:
    set_addr $I10, rxscan407_loop
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
  rxscan407_done:
.annotate 'line', 174
  # rx subrule "finishpad" subtype=method negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."finishpad"()
    unless $P10, rx403_fail
    rx403_pos = $P10."pos"()
  alt408_0:
.annotate 'line', 175
    set_addr $I10, alt408_1
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
.annotate 'line', 176
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx403_pos, 14
    gt $I11, rx403_eos, rx403_fail
    sub $I11, rx403_pos, rx403_off
    substr $S10, rx403_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx403_fail
    add rx403_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."you_are_here"()
    unless $P10, rx403_fail
    rx403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx403_pos = $P10."pos"()
    goto alt408_end
  alt408_1:
.annotate 'line', 177
  # rx literal  "{"
    add $I11, rx403_pos, 1
    gt $I11, rx403_eos, rx403_fail
    sub $I11, rx403_pos, rx403_off
    ord $I11, rx403_tgt, $I11
    ne $I11, 123, rx403_fail
    add rx403_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."statementlist"()
    unless $P10, rx403_fail
    rx403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx403_pos = $P10."pos"()
  alt409_0:
    set_addr $I10, alt409_1
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
  # rx literal  "}"
    add $I11, rx403_pos, 1
    gt $I11, rx403_eos, rx403_fail
    sub $I11, rx403_pos, rx403_off
    ord $I11, rx403_tgt, $I11
    ne $I11, 125, rx403_fail
    add rx403_pos, 1
    goto alt409_end
  alt409_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."FAILGOAL"("'}'")
    unless $P10, rx403_fail
    goto rxsubrule411_pass
  rxsubrule411_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx403_fail
  rxsubrule411_pass:
    set_addr $I10, rxsubrule411_back
    rx403_cur."!mark_push"(0, rx403_pos, $I10, $P10)
    rx403_pos = $P10."pos"()
  alt409_end:
  alt408_end:
.annotate 'line', 179
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."ENDSTMT"()
    unless $P10, rx403_fail
.annotate 'line', 173
  # rx pass
    rx403_cur."!cursor_pass"(rx403_pos, "blockoid")
    if_null rx403_debug, debug_879
    rx403_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx403_pos)
  debug_879:
    .return (rx403_cur)
  rx403_restart:
.annotate 'line', 10
    if_null rx403_debug, debug_880
    rx403_cur."!cursor_debug"("NEXT", "blockoid")
  debug_880:
  rx403_fail:
    (rx403_rep, rx403_pos, $I10, $P10) = rx403_cur."!mark_fail"(0)
    lt rx403_pos, -1, rx403_done
    eq rx403_pos, -1, rx403_fail
    jump $I10
  rx403_done:
    rx403_cur."!cursor_fail"()
    if_null rx403_debug, debug_881
    rx403_cur."!cursor_debug"("FAIL", "blockoid")
  debug_881:
    .return (rx403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("63_1304282286.73") :method
.annotate 'line', 10
    $P405 = self."!PREFIX__!subrule"("finishpad", "")
    new $P406, "ResizablePMCArray"
    push $P406, $P405
    .return ($P406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("64_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P413 = self."!PREFIX__!subrule"("finishpad", "")
    new $P414, "ResizablePMCArray"
    push $P414, $P413
    .return ($P414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("65_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx416_tgt
    .local int rx416_pos
    .local int rx416_off
    .local int rx416_eos
    .local int rx416_rep
    .local pmc rx416_cur
    .local pmc rx416_debug
    (rx416_cur, rx416_pos, rx416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx416_cur
    .local pmc match
    .lex "$/", match
    length rx416_eos, rx416_tgt
    gt rx416_pos, rx416_eos, rx416_done
    set rx416_off, 0
    lt rx416_pos, 2, rx416_start
    sub rx416_off, rx416_pos, 1
    substr rx416_tgt, rx416_tgt, rx416_off
  rx416_start:
    eq $I10, 1, rx416_restart
    if_null rx416_debug, debug_882
    rx416_cur."!cursor_debug"("START", "newpad")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan419_done
    goto rxscan419_scan
  rxscan419_loop:
    (rx416_pos) = rx416_cur."from"()
    inc rx416_pos
    rx416_cur."!cursor_from"(rx416_pos)
    ge rx416_pos, rx416_eos, rxscan419_done
  rxscan419_scan:
    set_addr $I10, rxscan419_loop
    rx416_cur."!mark_push"(0, rx416_pos, $I10)
  rxscan419_done:
.annotate 'line', 182
  # rx pass
    rx416_cur."!cursor_pass"(rx416_pos, "newpad")
    if_null rx416_debug, debug_883
    rx416_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx416_pos)
  debug_883:
    .return (rx416_cur)
  rx416_restart:
.annotate 'line', 10
    if_null rx416_debug, debug_884
    rx416_cur."!cursor_debug"("NEXT", "newpad")
  debug_884:
  rx416_fail:
    (rx416_rep, rx416_pos, $I10, $P10) = rx416_cur."!mark_fail"(0)
    lt rx416_pos, -1, rx416_done
    eq rx416_pos, -1, rx416_fail
    jump $I10
  rx416_done:
    rx416_cur."!cursor_fail"()
    if_null rx416_debug, debug_885
    rx416_cur."!cursor_debug"("FAIL", "newpad")
  debug_885:
    .return (rx416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("66_1304282286.73") :method
.annotate 'line', 10
    new $P418, "ResizablePMCArray"
    push $P418, ""
    .return ($P418)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("67_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P421, "ResizablePMCArray"
    push $P421, ""
    .return ($P421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("68_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx423_tgt
    .local int rx423_pos
    .local int rx423_off
    .local int rx423_eos
    .local int rx423_rep
    .local pmc rx423_cur
    .local pmc rx423_debug
    (rx423_cur, rx423_pos, rx423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx423_cur
    .local pmc match
    .lex "$/", match
    length rx423_eos, rx423_tgt
    gt rx423_pos, rx423_eos, rx423_done
    set rx423_off, 0
    lt rx423_pos, 2, rx423_start
    sub rx423_off, rx423_pos, 1
    substr rx423_tgt, rx423_tgt, rx423_off
  rx423_start:
    eq $I10, 1, rx423_restart
    if_null rx423_debug, debug_886
    rx423_cur."!cursor_debug"("START", "outerctx")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan426_done
    goto rxscan426_scan
  rxscan426_loop:
    (rx423_pos) = rx423_cur."from"()
    inc rx423_pos
    rx423_cur."!cursor_from"(rx423_pos)
    ge rx423_pos, rx423_eos, rxscan426_done
  rxscan426_scan:
    set_addr $I10, rxscan426_loop
    rx423_cur."!mark_push"(0, rx423_pos, $I10)
  rxscan426_done:
.annotate 'line', 183
  # rx pass
    rx423_cur."!cursor_pass"(rx423_pos, "outerctx")
    if_null rx423_debug, debug_887
    rx423_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx423_pos)
  debug_887:
    .return (rx423_cur)
  rx423_restart:
.annotate 'line', 10
    if_null rx423_debug, debug_888
    rx423_cur."!cursor_debug"("NEXT", "outerctx")
  debug_888:
  rx423_fail:
    (rx423_rep, rx423_pos, $I10, $P10) = rx423_cur."!mark_fail"(0)
    lt rx423_pos, -1, rx423_done
    eq rx423_pos, -1, rx423_fail
    jump $I10
  rx423_done:
    rx423_cur."!cursor_fail"()
    if_null rx423_debug, debug_889
    rx423_cur."!cursor_debug"("FAIL", "outerctx")
  debug_889:
    .return (rx423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("69_1304282286.73") :method
.annotate 'line', 10
    new $P425, "ResizablePMCArray"
    push $P425, ""
    .return ($P425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("70_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P428, "ResizablePMCArray"
    push $P428, ""
    .return ($P428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("71_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx430_tgt
    .local int rx430_pos
    .local int rx430_off
    .local int rx430_eos
    .local int rx430_rep
    .local pmc rx430_cur
    .local pmc rx430_debug
    (rx430_cur, rx430_pos, rx430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx430_cur
    .local pmc match
    .lex "$/", match
    length rx430_eos, rx430_tgt
    gt rx430_pos, rx430_eos, rx430_done
    set rx430_off, 0
    lt rx430_pos, 2, rx430_start
    sub rx430_off, rx430_pos, 1
    substr rx430_tgt, rx430_tgt, rx430_off
  rx430_start:
    eq $I10, 1, rx430_restart
    if_null rx430_debug, debug_890
    rx430_cur."!cursor_debug"("START", "GLOBALish")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan433_done
    goto rxscan433_scan
  rxscan433_loop:
    (rx430_pos) = rx430_cur."from"()
    inc rx430_pos
    rx430_cur."!cursor_from"(rx430_pos)
    ge rx430_pos, rx430_eos, rxscan433_done
  rxscan433_scan:
    set_addr $I10, rxscan433_loop
    rx430_cur."!mark_push"(0, rx430_pos, $I10)
  rxscan433_done:
.annotate 'line', 184
  # rx pass
    rx430_cur."!cursor_pass"(rx430_pos, "GLOBALish")
    if_null rx430_debug, debug_891
    rx430_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx430_pos)
  debug_891:
    .return (rx430_cur)
  rx430_restart:
.annotate 'line', 10
    if_null rx430_debug, debug_892
    rx430_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_892:
  rx430_fail:
    (rx430_rep, rx430_pos, $I10, $P10) = rx430_cur."!mark_fail"(0)
    lt rx430_pos, -1, rx430_done
    eq rx430_pos, -1, rx430_fail
    jump $I10
  rx430_done:
    rx430_cur."!cursor_fail"()
    if_null rx430_debug, debug_893
    rx430_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_893:
    .return (rx430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("72_1304282286.73") :method
.annotate 'line', 10
    new $P432, "ResizablePMCArray"
    push $P432, ""
    .return ($P432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("73_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P435, "ResizablePMCArray"
    push $P435, ""
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("74_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx437_tgt
    .local int rx437_pos
    .local int rx437_off
    .local int rx437_eos
    .local int rx437_rep
    .local pmc rx437_cur
    .local pmc rx437_debug
    (rx437_cur, rx437_pos, rx437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx437_cur
    .local pmc match
    .lex "$/", match
    length rx437_eos, rx437_tgt
    gt rx437_pos, rx437_eos, rx437_done
    set rx437_off, 0
    lt rx437_pos, 2, rx437_start
    sub rx437_off, rx437_pos, 1
    substr rx437_tgt, rx437_tgt, rx437_off
  rx437_start:
    eq $I10, 1, rx437_restart
    if_null rx437_debug, debug_894
    rx437_cur."!cursor_debug"("START", "finishpad")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan440_done
    goto rxscan440_scan
  rxscan440_loop:
    (rx437_pos) = rx437_cur."from"()
    inc rx437_pos
    rx437_cur."!cursor_from"(rx437_pos)
    ge rx437_pos, rx437_eos, rxscan440_done
  rxscan440_scan:
    set_addr $I10, rxscan440_loop
    rx437_cur."!mark_push"(0, rx437_pos, $I10)
  rxscan440_done:
.annotate 'line', 185
  # rx pass
    rx437_cur."!cursor_pass"(rx437_pos, "finishpad")
    if_null rx437_debug, debug_895
    rx437_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx437_pos)
  debug_895:
    .return (rx437_cur)
  rx437_restart:
.annotate 'line', 10
    if_null rx437_debug, debug_896
    rx437_cur."!cursor_debug"("NEXT", "finishpad")
  debug_896:
  rx437_fail:
    (rx437_rep, rx437_pos, $I10, $P10) = rx437_cur."!mark_fail"(0)
    lt rx437_pos, -1, rx437_done
    eq rx437_pos, -1, rx437_fail
    jump $I10
  rx437_done:
    rx437_cur."!cursor_fail"()
    if_null rx437_debug, debug_897
    rx437_cur."!cursor_debug"("FAIL", "finishpad")
  debug_897:
    .return (rx437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("75_1304282286.73") :method
.annotate 'line', 10
    new $P439, "ResizablePMCArray"
    push $P439, ""
    .return ($P439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("76_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P442, "ResizablePMCArray"
    push $P442, ""
    .return ($P442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("77_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx444_tgt
    .local int rx444_pos
    .local int rx444_off
    .local int rx444_eos
    .local int rx444_rep
    .local pmc rx444_cur
    .local pmc rx444_debug
    (rx444_cur, rx444_pos, rx444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx444_cur
    .local pmc match
    .lex "$/", match
    length rx444_eos, rx444_tgt
    gt rx444_pos, rx444_eos, rx444_done
    set rx444_off, 0
    lt rx444_pos, 2, rx444_start
    sub rx444_off, rx444_pos, 1
    substr rx444_tgt, rx444_tgt, rx444_off
  rx444_start:
    eq $I10, 1, rx444_restart
    if_null rx444_debug, debug_898
    rx444_cur."!cursor_debug"("START", "you_are_here")
  debug_898:
    $I10 = self.'from'()
    ne $I10, -1, rxscan447_done
    goto rxscan447_scan
  rxscan447_loop:
    (rx444_pos) = rx444_cur."from"()
    inc rx444_pos
    rx444_cur."!cursor_from"(rx444_pos)
    ge rx444_pos, rx444_eos, rxscan447_done
  rxscan447_scan:
    set_addr $I10, rxscan447_loop
    rx444_cur."!mark_push"(0, rx444_pos, $I10)
  rxscan447_done:
.annotate 'line', 186
  # rx pass
    rx444_cur."!cursor_pass"(rx444_pos, "you_are_here")
    if_null rx444_debug, debug_899
    rx444_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx444_pos)
  debug_899:
    .return (rx444_cur)
  rx444_restart:
.annotate 'line', 10
    if_null rx444_debug, debug_900
    rx444_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_900:
  rx444_fail:
    (rx444_rep, rx444_pos, $I10, $P10) = rx444_cur."!mark_fail"(0)
    lt rx444_pos, -1, rx444_done
    eq rx444_pos, -1, rx444_fail
    jump $I10
  rx444_done:
    rx444_cur."!cursor_fail"()
    if_null rx444_debug, debug_901
    rx444_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_901:
    .return (rx444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("78_1304282286.73") :method
.annotate 'line', 10
    new $P446, "ResizablePMCArray"
    push $P446, ""
    .return ($P446)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("79_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P449, "ResizablePMCArray"
    push $P449, ""
    .return ($P449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("80_1304282286.73")
    .param pmc param_451
.annotate 'line', 188
    .lex "self", param_451
    $P452 = param_451."!protoregex"("terminator")
    .return ($P452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("81_1304282286.73")
    .param pmc param_454
.annotate 'line', 188
    .lex "self", param_454
    $P455 = param_454."!PREFIX__!protoregex"("terminator")
    .return ($P455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("82_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx457_tgt
    .local int rx457_pos
    .local int rx457_off
    .local int rx457_eos
    .local int rx457_rep
    .local pmc rx457_cur
    .local pmc rx457_debug
    (rx457_cur, rx457_pos, rx457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx457_cur
    .local pmc match
    .lex "$/", match
    length rx457_eos, rx457_tgt
    gt rx457_pos, rx457_eos, rx457_done
    set rx457_off, 0
    lt rx457_pos, 2, rx457_start
    sub rx457_off, rx457_pos, 1
    substr rx457_tgt, rx457_tgt, rx457_off
  rx457_start:
    eq $I10, 1, rx457_restart
    if_null rx457_debug, debug_902
    rx457_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_902:
    $I10 = self.'from'()
    ne $I10, -1, rxscan460_done
    goto rxscan460_scan
  rxscan460_loop:
    (rx457_pos) = rx457_cur."from"()
    inc rx457_pos
    rx457_cur."!cursor_from"(rx457_pos)
    ge rx457_pos, rx457_eos, rxscan460_done
  rxscan460_scan:
    set_addr $I10, rxscan460_loop
    rx457_cur."!mark_push"(0, rx457_pos, $I10)
  rxscan460_done:
.annotate 'line', 190
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx457_pos, rx457_off
    substr $S10, rx457_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx457_fail
  # rx pass
    rx457_cur."!cursor_pass"(rx457_pos, "terminator:sym<;>")
    if_null rx457_debug, debug_903
    rx457_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx457_pos)
  debug_903:
    .return (rx457_cur)
  rx457_restart:
.annotate 'line', 10
    if_null rx457_debug, debug_904
    rx457_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_904:
  rx457_fail:
    (rx457_rep, rx457_pos, $I10, $P10) = rx457_cur."!mark_fail"(0)
    lt rx457_pos, -1, rx457_done
    eq rx457_pos, -1, rx457_fail
    jump $I10
  rx457_done:
    rx457_cur."!cursor_fail"()
    if_null rx457_debug, debug_905
    rx457_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_905:
    .return (rx457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("83_1304282286.73") :method
.annotate 'line', 10
    new $P459, "ResizablePMCArray"
    push $P459, ";"
    .return ($P459)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("84_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P462, "ResizablePMCArray"
    push $P462, ";"
    .return ($P462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("85_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx464_tgt
    .local int rx464_pos
    .local int rx464_off
    .local int rx464_eos
    .local int rx464_rep
    .local pmc rx464_cur
    .local pmc rx464_debug
    (rx464_cur, rx464_pos, rx464_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx464_cur
    .local pmc match
    .lex "$/", match
    length rx464_eos, rx464_tgt
    gt rx464_pos, rx464_eos, rx464_done
    set rx464_off, 0
    lt rx464_pos, 2, rx464_start
    sub rx464_off, rx464_pos, 1
    substr rx464_tgt, rx464_tgt, rx464_off
  rx464_start:
    eq $I10, 1, rx464_restart
    if_null rx464_debug, debug_906
    rx464_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_906:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx464_pos) = rx464_cur."from"()
    inc rx464_pos
    rx464_cur."!cursor_from"(rx464_pos)
    ge rx464_pos, rx464_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx464_cur."!mark_push"(0, rx464_pos, $I10)
  rxscan467_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx464_pos, rx464_off
    substr $S10, rx464_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx464_fail
  # rx pass
    rx464_cur."!cursor_pass"(rx464_pos, "terminator:sym<}>")
    if_null rx464_debug, debug_907
    rx464_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx464_pos)
  debug_907:
    .return (rx464_cur)
  rx464_restart:
.annotate 'line', 10
    if_null rx464_debug, debug_908
    rx464_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_908:
  rx464_fail:
    (rx464_rep, rx464_pos, $I10, $P10) = rx464_cur."!mark_fail"(0)
    lt rx464_pos, -1, rx464_done
    eq rx464_pos, -1, rx464_fail
    jump $I10
  rx464_done:
    rx464_cur."!cursor_fail"()
    if_null rx464_debug, debug_909
    rx464_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_909:
    .return (rx464_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("86_1304282286.73") :method
.annotate 'line', 10
    new $P466, "ResizablePMCArray"
    push $P466, "}"
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("87_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P469, "ResizablePMCArray"
    push $P469, "}"
    .return ($P469)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("88_1304282286.73")
    .param pmc param_471
.annotate 'line', 195
    .lex "self", param_471
    $P472 = param_471."!protoregex"("statement_control")
    .return ($P472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("89_1304282286.73")
    .param pmc param_474
.annotate 'line', 195
    .lex "self", param_474
    $P475 = param_474."!PREFIX__!protoregex"("statement_control")
    .return ($P475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("90_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx477_tgt
    .local int rx477_pos
    .local int rx477_off
    .local int rx477_eos
    .local int rx477_rep
    .local pmc rx477_cur
    .local pmc rx477_debug
    (rx477_cur, rx477_pos, rx477_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx477_cur
    .local pmc match
    .lex "$/", match
    length rx477_eos, rx477_tgt
    gt rx477_pos, rx477_eos, rx477_done
    set rx477_off, 0
    lt rx477_pos, 2, rx477_start
    sub rx477_off, rx477_pos, 1
    substr rx477_tgt, rx477_tgt, rx477_off
  rx477_start:
    eq $I10, 1, rx477_restart
    if_null rx477_debug, debug_910
    rx477_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_910:
    $I10 = self.'from'()
    ne $I10, -1, rxscan480_done
    goto rxscan480_scan
  rxscan480_loop:
    (rx477_pos) = rx477_cur."from"()
    inc rx477_pos
    rx477_cur."!cursor_from"(rx477_pos)
    ge rx477_pos, rx477_eos, rxscan480_done
  rxscan480_scan:
    set_addr $I10, rxscan480_loop
    rx477_cur."!mark_push"(0, rx477_pos, $I10)
  rxscan480_done:
.annotate 'line', 198
  # rx subcapture "sym"
    set_addr $I10, rxcap_481_fail
    rx477_cur."!mark_push"(0, rx477_pos, $I10)
  # rx literal  "use"
    add $I11, rx477_pos, 3
    gt $I11, rx477_eos, rx477_fail
    sub $I11, rx477_pos, rx477_off
    substr $S10, rx477_tgt, $I11, 3
    ne $S10, "use", rx477_fail
    add rx477_pos, 3
    set_addr $I10, rxcap_481_fail
    ($I12, $I11) = rx477_cur."!mark_peek"($I10)
    rx477_cur."!cursor_pos"($I11)
    ($P10) = rx477_cur."!cursor_start"()
    $P10."!cursor_pass"(rx477_pos, "")
    rx477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_481_done
  rxcap_481_fail:
    goto rx477_fail
  rxcap_481_done:
  # rx charclass s
    ge rx477_pos, rx477_eos, rx477_fail
    sub $I10, rx477_pos, rx477_off
    is_cclass $I11, 32, rx477_tgt, $I10
    unless $I11, rx477_fail
    inc rx477_pos
  # rx subrule "ws" subtype=method negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."ws"()
    unless $P10, rx477_fail
    rx477_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."name"()
    unless $P10, rx477_fail
    rx477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx477_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."ws"()
    unless $P10, rx477_fail
    rx477_pos = $P10."pos"()
.annotate 'line', 197
  # rx pass
    rx477_cur."!cursor_pass"(rx477_pos, "statement_control:sym<use>")
    if_null rx477_debug, debug_911
    rx477_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx477_pos)
  debug_911:
    .return (rx477_cur)
  rx477_restart:
.annotate 'line', 10
    if_null rx477_debug, debug_912
    rx477_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_912:
  rx477_fail:
    (rx477_rep, rx477_pos, $I10, $P10) = rx477_cur."!mark_fail"(0)
    lt rx477_pos, -1, rx477_done
    eq rx477_pos, -1, rx477_fail
    jump $I10
  rx477_done:
    rx477_cur."!cursor_fail"()
    if_null rx477_debug, debug_913
    rx477_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_913:
    .return (rx477_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("91_1304282286.73") :method
.annotate 'line', 10
    new $P479, "ResizablePMCArray"
    push $P479, "use"
    .return ($P479)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("92_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P485, "ResizablePMCArray"
    push $P485, "use"
    .return ($P485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("93_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx487_tgt
    .local int rx487_pos
    .local int rx487_off
    .local int rx487_eos
    .local int rx487_rep
    .local pmc rx487_cur
    .local pmc rx487_debug
    (rx487_cur, rx487_pos, rx487_tgt, $I10) = self."!cursor_start"()
    rx487_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx487_cur
    .local pmc match
    .lex "$/", match
    length rx487_eos, rx487_tgt
    gt rx487_pos, rx487_eos, rx487_done
    set rx487_off, 0
    lt rx487_pos, 2, rx487_start
    sub rx487_off, rx487_pos, 1
    substr rx487_tgt, rx487_tgt, rx487_off
  rx487_start:
    eq $I10, 1, rx487_restart
    if_null rx487_debug, debug_914
    rx487_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_914:
    $I10 = self.'from'()
    ne $I10, -1, rxscan490_done
    goto rxscan490_scan
  rxscan490_loop:
    (rx487_pos) = rx487_cur."from"()
    inc rx487_pos
    rx487_cur."!cursor_from"(rx487_pos)
    ge rx487_pos, rx487_eos, rxscan490_done
  rxscan490_scan:
    set_addr $I10, rxscan490_loop
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxscan490_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_491_fail
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  # rx literal  "if"
    add $I11, rx487_pos, 2
    gt $I11, rx487_eos, rx487_fail
    sub $I11, rx487_pos, rx487_off
    substr $S10, rx487_tgt, $I11, 2
    ne $S10, "if", rx487_fail
    add rx487_pos, 2
    set_addr $I10, rxcap_491_fail
    ($I12, $I11) = rx487_cur."!mark_peek"($I10)
    rx487_cur."!cursor_pos"($I11)
    ($P10) = rx487_cur."!cursor_start"()
    $P10."!cursor_pass"(rx487_pos, "")
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_491_done
  rxcap_491_fail:
    goto rx487_fail
  rxcap_491_done:
  # rx charclass s
    ge rx487_pos, rx487_eos, rx487_fail
    sub $I10, rx487_pos, rx487_off
    is_cclass $I11, 32, rx487_tgt, $I10
    unless $I11, rx487_fail
    inc rx487_pos
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."xblock"()
    unless $P10, rx487_fail
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx487_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
.annotate 'line', 204
  # rx rxquantr494 ** 0..*
    set_addr $I10, rxquantr494_done
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxquantr494_loop:
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx487_pos, 5
    gt $I11, rx487_eos, rx487_fail
    sub $I11, rx487_pos, rx487_off
    substr $S10, rx487_tgt, $I11, 5
    ne $S10, "elsif", rx487_fail
    add rx487_pos, 5
  # rx charclass s
    ge rx487_pos, rx487_eos, rx487_fail
    sub $I10, rx487_pos, rx487_off
    is_cclass $I11, 32, rx487_tgt, $I10
    unless $I11, rx487_fail
    inc rx487_pos
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."xblock"()
    unless $P10, rx487_fail
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx487_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
    set_addr $I10, rxquantr494_done
    (rx487_rep) = rx487_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr494_done
    rx487_cur."!mark_push"(rx487_rep, rx487_pos, $I10)
    goto rxquantr494_loop
  rxquantr494_done:
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr499 ** 0..1
    set_addr $I10, rxquantr499_done
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxquantr499_loop:
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx487_pos, 4
    gt $I11, rx487_eos, rx487_fail
    sub $I11, rx487_pos, rx487_off
    substr $S10, rx487_tgt, $I11, 4
    ne $S10, "else", rx487_fail
    add rx487_pos, 4
  # rx charclass s
    ge rx487_pos, rx487_eos, rx487_fail
    sub $I10, rx487_pos, rx487_off
    is_cclass $I11, 32, rx487_tgt, $I10
    unless $I11, rx487_fail
    inc rx487_pos
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."pblock"()
    unless $P10, rx487_fail
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx487_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
    set_addr $I10, rxquantr499_done
    (rx487_rep) = rx487_cur."!mark_commit"($I10)
  rxquantr499_done:
  # rx subrule "ws" subtype=method negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."ws"()
    unless $P10, rx487_fail
    rx487_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx487_cur."!cursor_pass"(rx487_pos, "statement_control:sym<if>")
    if_null rx487_debug, debug_915
    rx487_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx487_pos)
  debug_915:
    .return (rx487_cur)
  rx487_restart:
.annotate 'line', 10
    if_null rx487_debug, debug_916
    rx487_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_916:
  rx487_fail:
    (rx487_rep, rx487_pos, $I10, $P10) = rx487_cur."!mark_fail"(0)
    lt rx487_pos, -1, rx487_done
    eq rx487_pos, -1, rx487_fail
    jump $I10
  rx487_done:
    rx487_cur."!cursor_fail"()
    if_null rx487_debug, debug_917
    rx487_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_917:
    .return (rx487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("94_1304282286.73") :method
.annotate 'line', 10
    new $P489, "ResizablePMCArray"
    push $P489, "if"
    .return ($P489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("95_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P505, "ResizablePMCArray"
    push $P505, "if"
    .return ($P505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("96_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P517 = "98_1304282286.73" 
    capture_lex $P517
    .local string rx507_tgt
    .local int rx507_pos
    .local int rx507_off
    .local int rx507_eos
    .local int rx507_rep
    .local pmc rx507_cur
    .local pmc rx507_debug
    (rx507_cur, rx507_pos, rx507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx507_cur
    .local pmc match
    .lex "$/", match
    length rx507_eos, rx507_tgt
    gt rx507_pos, rx507_eos, rx507_done
    set rx507_off, 0
    lt rx507_pos, 2, rx507_start
    sub rx507_off, rx507_pos, 1
    substr rx507_tgt, rx507_tgt, rx507_off
  rx507_start:
    eq $I10, 1, rx507_restart
    if_null rx507_debug, debug_918
    rx507_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_918:
    $I10 = self.'from'()
    ne $I10, -1, rxscan510_done
    goto rxscan510_scan
  rxscan510_loop:
    (rx507_pos) = rx507_cur."from"()
    inc rx507_pos
    rx507_cur."!cursor_from"(rx507_pos)
    ge rx507_pos, rx507_eos, rxscan510_done
  rxscan510_scan:
    set_addr $I10, rxscan510_loop
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
  rxscan510_done:
.annotate 'line', 209
  # rx subcapture "sym"
    set_addr $I10, rxcap_511_fail
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
  # rx literal  "unless"
    add $I11, rx507_pos, 6
    gt $I11, rx507_eos, rx507_fail
    sub $I11, rx507_pos, rx507_off
    substr $S10, rx507_tgt, $I11, 6
    ne $S10, "unless", rx507_fail
    add rx507_pos, 6
    set_addr $I10, rxcap_511_fail
    ($I12, $I11) = rx507_cur."!mark_peek"($I10)
    rx507_cur."!cursor_pos"($I11)
    ($P10) = rx507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx507_pos, "")
    rx507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_511_done
  rxcap_511_fail:
    goto rx507_fail
  rxcap_511_done:
  # rx charclass s
    ge rx507_pos, rx507_eos, rx507_fail
    sub $I10, rx507_pos, rx507_off
    is_cclass $I11, 32, rx507_tgt, $I10
    unless $I11, rx507_fail
    inc rx507_pos
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
.annotate 'line', 210
  # rx subrule "xblock" subtype=capture negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."xblock"()
    unless $P10, rx507_fail
    rx507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx507_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
  alt514_0:
.annotate 'line', 211
    set_addr $I10, alt514_1
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx507_cur."!cursor_pos"(rx507_pos)
    .const 'Sub' $P517 = "98_1304282286.73" 
    capture_lex $P517
    $P10 = rx507_cur."before"($P517)
    if $P10, rx507_fail
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
    goto alt514_end
  alt514_1:
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
  alt514_end:
  # rx subrule "ws" subtype=method negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."ws"()
    unless $P10, rx507_fail
    rx507_pos = $P10."pos"()
.annotate 'line', 208
  # rx pass
    rx507_cur."!cursor_pass"(rx507_pos, "statement_control:sym<unless>")
    if_null rx507_debug, debug_923
    rx507_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx507_pos)
  debug_923:
    .return (rx507_cur)
  rx507_restart:
.annotate 'line', 10
    if_null rx507_debug, debug_924
    rx507_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_924:
  rx507_fail:
    (rx507_rep, rx507_pos, $I10, $P10) = rx507_cur."!mark_fail"(0)
    lt rx507_pos, -1, rx507_done
    eq rx507_pos, -1, rx507_fail
    jump $I10
  rx507_done:
    rx507_cur."!cursor_fail"()
    if_null rx507_debug, debug_925
    rx507_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_925:
    .return (rx507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("97_1304282286.73") :method
.annotate 'line', 10
    new $P509, "ResizablePMCArray"
    push $P509, "unless"
    .return ($P509)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block516"  :anon :subid("98_1304282286.73") :method :outer("96_1304282286.73")
.annotate 'line', 211
    .local string rx518_tgt
    .local int rx518_pos
    .local int rx518_off
    .local int rx518_eos
    .local int rx518_rep
    .local pmc rx518_cur
    .local pmc rx518_debug
    (rx518_cur, rx518_pos, rx518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx518_cur
    .local pmc match
    .lex "$/", match
    length rx518_eos, rx518_tgt
    gt rx518_pos, rx518_eos, rx518_done
    set rx518_off, 0
    lt rx518_pos, 2, rx518_start
    sub rx518_off, rx518_pos, 1
    substr rx518_tgt, rx518_tgt, rx518_off
  rx518_start:
    eq $I10, 1, rx518_restart
    if_null rx518_debug, debug_919
    rx518_cur."!cursor_debug"("START", "")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan519_done
    goto rxscan519_scan
  rxscan519_loop:
    (rx518_pos) = rx518_cur."from"()
    inc rx518_pos
    rx518_cur."!cursor_from"(rx518_pos)
    ge rx518_pos, rx518_eos, rxscan519_done
  rxscan519_scan:
    set_addr $I10, rxscan519_loop
    rx518_cur."!mark_push"(0, rx518_pos, $I10)
  rxscan519_done:
  # rx literal  "else"
    add $I11, rx518_pos, 4
    gt $I11, rx518_eos, rx518_fail
    sub $I11, rx518_pos, rx518_off
    substr $S10, rx518_tgt, $I11, 4
    ne $S10, "else", rx518_fail
    add rx518_pos, 4
  # rx pass
    rx518_cur."!cursor_pass"(rx518_pos, "")
    if_null rx518_debug, debug_920
    rx518_cur."!cursor_debug"("PASS", "", " at pos=", rx518_pos)
  debug_920:
    .return (rx518_cur)
  rx518_restart:
    if_null rx518_debug, debug_921
    rx518_cur."!cursor_debug"("NEXT", "")
  debug_921:
  rx518_fail:
    (rx518_rep, rx518_pos, $I10, $P10) = rx518_cur."!mark_fail"(0)
    lt rx518_pos, -1, rx518_done
    eq rx518_pos, -1, rx518_fail
    jump $I10
  rx518_done:
    rx518_cur."!cursor_fail"()
    if_null rx518_debug, debug_922
    rx518_cur."!cursor_debug"("FAIL", "")
  debug_922:
    .return (rx518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("99_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P525, "ResizablePMCArray"
    push $P525, "unless"
    .return ($P525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("100_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx527_tgt
    .local int rx527_pos
    .local int rx527_off
    .local int rx527_eos
    .local int rx527_rep
    .local pmc rx527_cur
    .local pmc rx527_debug
    (rx527_cur, rx527_pos, rx527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx527_cur
    .local pmc match
    .lex "$/", match
    length rx527_eos, rx527_tgt
    gt rx527_pos, rx527_eos, rx527_done
    set rx527_off, 0
    lt rx527_pos, 2, rx527_start
    sub rx527_off, rx527_pos, 1
    substr rx527_tgt, rx527_tgt, rx527_off
  rx527_start:
    eq $I10, 1, rx527_restart
    if_null rx527_debug, debug_926
    rx527_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_926:
    $I10 = self.'from'()
    ne $I10, -1, rxscan530_done
    goto rxscan530_scan
  rxscan530_loop:
    (rx527_pos) = rx527_cur."from"()
    inc rx527_pos
    rx527_cur."!cursor_from"(rx527_pos)
    ge rx527_pos, rx527_eos, rxscan530_done
  rxscan530_scan:
    set_addr $I10, rxscan530_loop
    rx527_cur."!mark_push"(0, rx527_pos, $I10)
  rxscan530_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_532_fail
    rx527_cur."!mark_push"(0, rx527_pos, $I10)
  alt531_0:
    set_addr $I10, alt531_1
    rx527_cur."!mark_push"(0, rx527_pos, $I10)
  # rx literal  "while"
    add $I11, rx527_pos, 5
    gt $I11, rx527_eos, rx527_fail
    sub $I11, rx527_pos, rx527_off
    substr $S10, rx527_tgt, $I11, 5
    ne $S10, "while", rx527_fail
    add rx527_pos, 5
    goto alt531_end
  alt531_1:
  # rx literal  "until"
    add $I11, rx527_pos, 5
    gt $I11, rx527_eos, rx527_fail
    sub $I11, rx527_pos, rx527_off
    substr $S10, rx527_tgt, $I11, 5
    ne $S10, "until", rx527_fail
    add rx527_pos, 5
  alt531_end:
    set_addr $I10, rxcap_532_fail
    ($I12, $I11) = rx527_cur."!mark_peek"($I10)
    rx527_cur."!cursor_pos"($I11)
    ($P10) = rx527_cur."!cursor_start"()
    $P10."!cursor_pass"(rx527_pos, "")
    rx527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_532_done
  rxcap_532_fail:
    goto rx527_fail
  rxcap_532_done:
  # rx charclass s
    ge rx527_pos, rx527_eos, rx527_fail
    sub $I10, rx527_pos, rx527_off
    is_cclass $I11, 32, rx527_tgt, $I10
    unless $I11, rx527_fail
    inc rx527_pos
  # rx subrule "ws" subtype=method negate=
    rx527_cur."!cursor_pos"(rx527_pos)
    $P10 = rx527_cur."ws"()
    unless $P10, rx527_fail
    rx527_pos = $P10."pos"()
.annotate 'line', 216
  # rx subrule "xblock" subtype=capture negate=
    rx527_cur."!cursor_pos"(rx527_pos)
    $P10 = rx527_cur."xblock"()
    unless $P10, rx527_fail
    rx527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx527_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx527_cur."!cursor_pos"(rx527_pos)
    $P10 = rx527_cur."ws"()
    unless $P10, rx527_fail
    rx527_pos = $P10."pos"()
.annotate 'line', 214
  # rx pass
    rx527_cur."!cursor_pass"(rx527_pos, "statement_control:sym<while>")
    if_null rx527_debug, debug_927
    rx527_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx527_pos)
  debug_927:
    .return (rx527_cur)
  rx527_restart:
.annotate 'line', 10
    if_null rx527_debug, debug_928
    rx527_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_928:
  rx527_fail:
    (rx527_rep, rx527_pos, $I10, $P10) = rx527_cur."!mark_fail"(0)
    lt rx527_pos, -1, rx527_done
    eq rx527_pos, -1, rx527_fail
    jump $I10
  rx527_done:
    rx527_cur."!cursor_fail"()
    if_null rx527_debug, debug_929
    rx527_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_929:
    .return (rx527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("101_1304282286.73") :method
.annotate 'line', 10
    new $P529, "ResizablePMCArray"
    push $P529, "until"
    push $P529, "while"
    .return ($P529)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("102_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P536, "ResizablePMCArray"
    push $P536, "until"
    push $P536, "while"
    .return ($P536)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("103_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx538_tgt
    .local int rx538_pos
    .local int rx538_off
    .local int rx538_eos
    .local int rx538_rep
    .local pmc rx538_cur
    .local pmc rx538_debug
    (rx538_cur, rx538_pos, rx538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx538_cur
    .local pmc match
    .lex "$/", match
    length rx538_eos, rx538_tgt
    gt rx538_pos, rx538_eos, rx538_done
    set rx538_off, 0
    lt rx538_pos, 2, rx538_start
    sub rx538_off, rx538_pos, 1
    substr rx538_tgt, rx538_tgt, rx538_off
  rx538_start:
    eq $I10, 1, rx538_restart
    if_null rx538_debug, debug_930
    rx538_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_930:
    $I10 = self.'from'()
    ne $I10, -1, rxscan541_done
    goto rxscan541_scan
  rxscan541_loop:
    (rx538_pos) = rx538_cur."from"()
    inc rx538_pos
    rx538_cur."!cursor_from"(rx538_pos)
    ge rx538_pos, rx538_eos, rxscan541_done
  rxscan541_scan:
    set_addr $I10, rxscan541_loop
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  rxscan541_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_542_fail
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx538_pos, 6
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I11, 6
    ne $S10, "repeat", rx538_fail
    add rx538_pos, 6
    set_addr $I10, rxcap_542_fail
    ($I12, $I11) = rx538_cur."!mark_peek"($I10)
    rx538_cur."!cursor_pos"($I11)
    ($P10) = rx538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx538_pos, "")
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_542_done
  rxcap_542_fail:
    goto rx538_fail
  rxcap_542_done:
  # rx charclass s
    ge rx538_pos, rx538_eos, rx538_fail
    sub $I10, rx538_pos, rx538_off
    is_cclass $I11, 32, rx538_tgt, $I10
    unless $I11, rx538_fail
    inc rx538_pos
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  alt544_0:
.annotate 'line', 221
    set_addr $I10, alt544_1
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_547_fail
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  alt546_0:
    set_addr $I10, alt546_1
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  # rx literal  "while"
    add $I11, rx538_pos, 5
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I11, 5
    ne $S10, "while", rx538_fail
    add rx538_pos, 5
    goto alt546_end
  alt546_1:
  # rx literal  "until"
    add $I11, rx538_pos, 5
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I11, 5
    ne $S10, "until", rx538_fail
    add rx538_pos, 5
  alt546_end:
    set_addr $I10, rxcap_547_fail
    ($I12, $I11) = rx538_cur."!mark_peek"($I10)
    rx538_cur."!cursor_pos"($I11)
    ($P10) = rx538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx538_pos, "")
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_547_done
  rxcap_547_fail:
    goto rx538_fail
  rxcap_547_done:
  # rx charclass s
    ge rx538_pos, rx538_eos, rx538_fail
    sub $I10, rx538_pos, rx538_off
    is_cclass $I11, 32, rx538_tgt, $I10
    unless $I11, rx538_fail
    inc rx538_pos
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."xblock"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx538_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
    goto alt544_end
  alt544_1:
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."pblock"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx538_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_553_fail
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  alt552_0:
    set_addr $I10, alt552_1
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  # rx literal  "while"
    add $I11, rx538_pos, 5
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I11, 5
    ne $S10, "while", rx538_fail
    add rx538_pos, 5
    goto alt552_end
  alt552_1:
  # rx literal  "until"
    add $I11, rx538_pos, 5
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I11, 5
    ne $S10, "until", rx538_fail
    add rx538_pos, 5
  alt552_end:
    set_addr $I10, rxcap_553_fail
    ($I12, $I11) = rx538_cur."!mark_peek"($I10)
    rx538_cur."!cursor_pos"($I11)
    ($P10) = rx538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx538_pos, "")
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_553_done
  rxcap_553_fail:
    goto rx538_fail
  rxcap_553_done:
  # rx charclass s
    ge rx538_pos, rx538_eos, rx538_fail
    sub $I10, rx538_pos, rx538_off
    is_cclass $I11, 32, rx538_tgt, $I10
    unless $I11, rx538_fail
    inc rx538_pos
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."EXPR"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx538_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  alt544_end:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx538_cur."!cursor_pass"(rx538_pos, "statement_control:sym<repeat>")
    if_null rx538_debug, debug_931
    rx538_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx538_pos)
  debug_931:
    .return (rx538_cur)
  rx538_restart:
.annotate 'line', 10
    if_null rx538_debug, debug_932
    rx538_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_932:
  rx538_fail:
    (rx538_rep, rx538_pos, $I10, $P10) = rx538_cur."!mark_fail"(0)
    lt rx538_pos, -1, rx538_done
    eq rx538_pos, -1, rx538_fail
    jump $I10
  rx538_done:
    rx538_cur."!cursor_fail"()
    if_null rx538_debug, debug_933
    rx538_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_933:
    .return (rx538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("104_1304282286.73") :method
.annotate 'line', 10
    new $P540, "ResizablePMCArray"
    push $P540, "repeat"
    .return ($P540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("105_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P558, "ResizablePMCArray"
    push $P558, "repeat"
    .return ($P558)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("106_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx560_tgt
    .local int rx560_pos
    .local int rx560_off
    .local int rx560_eos
    .local int rx560_rep
    .local pmc rx560_cur
    .local pmc rx560_debug
    (rx560_cur, rx560_pos, rx560_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx560_cur
    .local pmc match
    .lex "$/", match
    length rx560_eos, rx560_tgt
    gt rx560_pos, rx560_eos, rx560_done
    set rx560_off, 0
    lt rx560_pos, 2, rx560_start
    sub rx560_off, rx560_pos, 1
    substr rx560_tgt, rx560_tgt, rx560_off
  rx560_start:
    eq $I10, 1, rx560_restart
    if_null rx560_debug, debug_934
    rx560_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_934:
    $I10 = self.'from'()
    ne $I10, -1, rxscan563_done
    goto rxscan563_scan
  rxscan563_loop:
    (rx560_pos) = rx560_cur."from"()
    inc rx560_pos
    rx560_cur."!cursor_from"(rx560_pos)
    ge rx560_pos, rx560_eos, rxscan563_done
  rxscan563_scan:
    set_addr $I10, rxscan563_loop
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  rxscan563_done:
.annotate 'line', 228
  # rx subcapture "sym"
    set_addr $I10, rxcap_564_fail
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  # rx literal  "for"
    add $I11, rx560_pos, 3
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 3
    ne $S10, "for", rx560_fail
    add rx560_pos, 3
    set_addr $I10, rxcap_564_fail
    ($I12, $I11) = rx560_cur."!mark_peek"($I10)
    rx560_cur."!cursor_pos"($I11)
    ($P10) = rx560_cur."!cursor_start"()
    $P10."!cursor_pass"(rx560_pos, "")
    rx560_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_564_done
  rxcap_564_fail:
    goto rx560_fail
  rxcap_564_done:
  # rx charclass s
    ge rx560_pos, rx560_eos, rx560_fail
    sub $I10, rx560_pos, rx560_off
    is_cclass $I11, 32, rx560_tgt, $I10
    unless $I11, rx560_fail
    inc rx560_pos
  # rx subrule "ws" subtype=method negate=
    rx560_cur."!cursor_pos"(rx560_pos)
    $P10 = rx560_cur."ws"()
    unless $P10, rx560_fail
    rx560_pos = $P10."pos"()
.annotate 'line', 229
  # rx subrule "xblock" subtype=capture negate=
    rx560_cur."!cursor_pos"(rx560_pos)
    $P10 = rx560_cur."xblock"()
    unless $P10, rx560_fail
    rx560_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx560_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx560_cur."!cursor_pos"(rx560_pos)
    $P10 = rx560_cur."ws"()
    unless $P10, rx560_fail
    rx560_pos = $P10."pos"()
.annotate 'line', 227
  # rx pass
    rx560_cur."!cursor_pass"(rx560_pos, "statement_control:sym<for>")
    if_null rx560_debug, debug_935
    rx560_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx560_pos)
  debug_935:
    .return (rx560_cur)
  rx560_restart:
.annotate 'line', 10
    if_null rx560_debug, debug_936
    rx560_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_936:
  rx560_fail:
    (rx560_rep, rx560_pos, $I10, $P10) = rx560_cur."!mark_fail"(0)
    lt rx560_pos, -1, rx560_done
    eq rx560_pos, -1, rx560_fail
    jump $I10
  rx560_done:
    rx560_cur."!cursor_fail"()
    if_null rx560_debug, debug_937
    rx560_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_937:
    .return (rx560_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("107_1304282286.73") :method
.annotate 'line', 10
    new $P562, "ResizablePMCArray"
    push $P562, "for"
    .return ($P562)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("108_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P568, "ResizablePMCArray"
    push $P568, "for"
    .return ($P568)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("109_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx570_tgt
    .local int rx570_pos
    .local int rx570_off
    .local int rx570_eos
    .local int rx570_rep
    .local pmc rx570_cur
    .local pmc rx570_debug
    (rx570_cur, rx570_pos, rx570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx570_cur
    .local pmc match
    .lex "$/", match
    length rx570_eos, rx570_tgt
    gt rx570_pos, rx570_eos, rx570_done
    set rx570_off, 0
    lt rx570_pos, 2, rx570_start
    sub rx570_off, rx570_pos, 1
    substr rx570_tgt, rx570_tgt, rx570_off
  rx570_start:
    eq $I10, 1, rx570_restart
    if_null rx570_debug, debug_938
    rx570_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_938:
    $I10 = self.'from'()
    ne $I10, -1, rxscan573_done
    goto rxscan573_scan
  rxscan573_loop:
    (rx570_pos) = rx570_cur."from"()
    inc rx570_pos
    rx570_cur."!cursor_from"(rx570_pos)
    ge rx570_pos, rx570_eos, rxscan573_done
  rxscan573_scan:
    set_addr $I10, rxscan573_loop
    rx570_cur."!mark_push"(0, rx570_pos, $I10)
  rxscan573_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_574_fail
    rx570_cur."!mark_push"(0, rx570_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx570_pos, 5
    gt $I11, rx570_eos, rx570_fail
    sub $I11, rx570_pos, rx570_off
    substr $S10, rx570_tgt, $I11, 5
    ne $S10, "CATCH", rx570_fail
    add rx570_pos, 5
    set_addr $I10, rxcap_574_fail
    ($I12, $I11) = rx570_cur."!mark_peek"($I10)
    rx570_cur."!cursor_pos"($I11)
    ($P10) = rx570_cur."!cursor_start"()
    $P10."!cursor_pass"(rx570_pos, "")
    rx570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_574_done
  rxcap_574_fail:
    goto rx570_fail
  rxcap_574_done:
  # rx charclass s
    ge rx570_pos, rx570_eos, rx570_fail
    sub $I10, rx570_pos, rx570_off
    is_cclass $I11, 32, rx570_tgt, $I10
    unless $I11, rx570_fail
    inc rx570_pos
  # rx subrule "ws" subtype=method negate=
    rx570_cur."!cursor_pos"(rx570_pos)
    $P10 = rx570_cur."ws"()
    unless $P10, rx570_fail
    rx570_pos = $P10."pos"()
.annotate 'line', 234
  # rx subrule "block" subtype=capture negate=
    rx570_cur."!cursor_pos"(rx570_pos)
    $P10 = rx570_cur."block"()
    unless $P10, rx570_fail
    rx570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx570_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx570_cur."!cursor_pos"(rx570_pos)
    $P10 = rx570_cur."ws"()
    unless $P10, rx570_fail
    rx570_pos = $P10."pos"()
.annotate 'line', 232
  # rx pass
    rx570_cur."!cursor_pass"(rx570_pos, "statement_control:sym<CATCH>")
    if_null rx570_debug, debug_939
    rx570_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx570_pos)
  debug_939:
    .return (rx570_cur)
  rx570_restart:
.annotate 'line', 10
    if_null rx570_debug, debug_940
    rx570_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_940:
  rx570_fail:
    (rx570_rep, rx570_pos, $I10, $P10) = rx570_cur."!mark_fail"(0)
    lt rx570_pos, -1, rx570_done
    eq rx570_pos, -1, rx570_fail
    jump $I10
  rx570_done:
    rx570_cur."!cursor_fail"()
    if_null rx570_debug, debug_941
    rx570_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_941:
    .return (rx570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("110_1304282286.73") :method
.annotate 'line', 10
    new $P572, "ResizablePMCArray"
    push $P572, "CATCH"
    .return ($P572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("111_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P578, "ResizablePMCArray"
    push $P578, "CATCH"
    .return ($P578)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("112_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx580_tgt
    .local int rx580_pos
    .local int rx580_off
    .local int rx580_eos
    .local int rx580_rep
    .local pmc rx580_cur
    .local pmc rx580_debug
    (rx580_cur, rx580_pos, rx580_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx580_cur
    .local pmc match
    .lex "$/", match
    length rx580_eos, rx580_tgt
    gt rx580_pos, rx580_eos, rx580_done
    set rx580_off, 0
    lt rx580_pos, 2, rx580_start
    sub rx580_off, rx580_pos, 1
    substr rx580_tgt, rx580_tgt, rx580_off
  rx580_start:
    eq $I10, 1, rx580_restart
    if_null rx580_debug, debug_942
    rx580_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_942:
    $I10 = self.'from'()
    ne $I10, -1, rxscan583_done
    goto rxscan583_scan
  rxscan583_loop:
    (rx580_pos) = rx580_cur."from"()
    inc rx580_pos
    rx580_cur."!cursor_from"(rx580_pos)
    ge rx580_pos, rx580_eos, rxscan583_done
  rxscan583_scan:
    set_addr $I10, rxscan583_loop
    rx580_cur."!mark_push"(0, rx580_pos, $I10)
  rxscan583_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_584_fail
    rx580_cur."!mark_push"(0, rx580_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx580_pos, 7
    gt $I11, rx580_eos, rx580_fail
    sub $I11, rx580_pos, rx580_off
    substr $S10, rx580_tgt, $I11, 7
    ne $S10, "CONTROL", rx580_fail
    add rx580_pos, 7
    set_addr $I10, rxcap_584_fail
    ($I12, $I11) = rx580_cur."!mark_peek"($I10)
    rx580_cur."!cursor_pos"($I11)
    ($P10) = rx580_cur."!cursor_start"()
    $P10."!cursor_pass"(rx580_pos, "")
    rx580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_584_done
  rxcap_584_fail:
    goto rx580_fail
  rxcap_584_done:
  # rx charclass s
    ge rx580_pos, rx580_eos, rx580_fail
    sub $I10, rx580_pos, rx580_off
    is_cclass $I11, 32, rx580_tgt, $I10
    unless $I11, rx580_fail
    inc rx580_pos
  # rx subrule "ws" subtype=method negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."ws"()
    unless $P10, rx580_fail
    rx580_pos = $P10."pos"()
.annotate 'line', 239
  # rx subrule "block" subtype=capture negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."block"()
    unless $P10, rx580_fail
    rx580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx580_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."ws"()
    unless $P10, rx580_fail
    rx580_pos = $P10."pos"()
.annotate 'line', 237
  # rx pass
    rx580_cur."!cursor_pass"(rx580_pos, "statement_control:sym<CONTROL>")
    if_null rx580_debug, debug_943
    rx580_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx580_pos)
  debug_943:
    .return (rx580_cur)
  rx580_restart:
.annotate 'line', 10
    if_null rx580_debug, debug_944
    rx580_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_944:
  rx580_fail:
    (rx580_rep, rx580_pos, $I10, $P10) = rx580_cur."!mark_fail"(0)
    lt rx580_pos, -1, rx580_done
    eq rx580_pos, -1, rx580_fail
    jump $I10
  rx580_done:
    rx580_cur."!cursor_fail"()
    if_null rx580_debug, debug_945
    rx580_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_945:
    .return (rx580_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("113_1304282286.73") :method
.annotate 'line', 10
    new $P582, "ResizablePMCArray"
    push $P582, "CONTROL"
    .return ($P582)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("114_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P588, "ResizablePMCArray"
    push $P588, "CONTROL"
    .return ($P588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("115_1304282286.73")
    .param pmc param_590
.annotate 'line', 242
    .lex "self", param_590
    $P591 = param_590."!protoregex"("statement_prefix")
    .return ($P591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("116_1304282286.73")
    .param pmc param_593
.annotate 'line', 242
    .lex "self", param_593
    $P594 = param_593."!PREFIX__!protoregex"("statement_prefix")
    .return ($P594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("117_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx596_tgt
    .local int rx596_pos
    .local int rx596_off
    .local int rx596_eos
    .local int rx596_rep
    .local pmc rx596_cur
    .local pmc rx596_debug
    (rx596_cur, rx596_pos, rx596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx596_cur
    .local pmc match
    .lex "$/", match
    length rx596_eos, rx596_tgt
    gt rx596_pos, rx596_eos, rx596_done
    set rx596_off, 0
    lt rx596_pos, 2, rx596_start
    sub rx596_off, rx596_pos, 1
    substr rx596_tgt, rx596_tgt, rx596_off
  rx596_start:
    eq $I10, 1, rx596_restart
    if_null rx596_debug, debug_946
    rx596_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_946:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx596_pos) = rx596_cur."from"()
    inc rx596_pos
    rx596_cur."!cursor_from"(rx596_pos)
    ge rx596_pos, rx596_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  rxscan600_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_601_fail
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx596_pos, 4
    gt $I11, rx596_eos, rx596_fail
    sub $I11, rx596_pos, rx596_off
    substr $S10, rx596_tgt, $I11, 4
    ne $S10, "INIT", rx596_fail
    add rx596_pos, 4
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx596_cur."!mark_peek"($I10)
    rx596_cur."!cursor_pos"($I11)
    ($P10) = rx596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx596_pos, "")
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx596_fail
  rxcap_601_done:
  # rx subrule "blorst" subtype=capture negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."blorst"()
    unless $P10, rx596_fail
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx596_pos = $P10."pos"()
  # rx pass
    rx596_cur."!cursor_pass"(rx596_pos, "statement_prefix:sym<INIT>")
    if_null rx596_debug, debug_947
    rx596_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx596_pos)
  debug_947:
    .return (rx596_cur)
  rx596_restart:
.annotate 'line', 10
    if_null rx596_debug, debug_948
    rx596_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_948:
  rx596_fail:
    (rx596_rep, rx596_pos, $I10, $P10) = rx596_cur."!mark_fail"(0)
    lt rx596_pos, -1, rx596_done
    eq rx596_pos, -1, rx596_fail
    jump $I10
  rx596_done:
    rx596_cur."!cursor_fail"()
    if_null rx596_debug, debug_949
    rx596_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_949:
    .return (rx596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("118_1304282286.73") :method
.annotate 'line', 10
    $P598 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P599, "ResizablePMCArray"
    push $P599, $P598
    .return ($P599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("119_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P603 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P604, "ResizablePMCArray"
    push $P604, $P603
    .return ($P604)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("120_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx606_tgt
    .local int rx606_pos
    .local int rx606_off
    .local int rx606_eos
    .local int rx606_rep
    .local pmc rx606_cur
    .local pmc rx606_debug
    (rx606_cur, rx606_pos, rx606_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx606_cur
    .local pmc match
    .lex "$/", match
    length rx606_eos, rx606_tgt
    gt rx606_pos, rx606_eos, rx606_done
    set rx606_off, 0
    lt rx606_pos, 2, rx606_start
    sub rx606_off, rx606_pos, 1
    substr rx606_tgt, rx606_tgt, rx606_off
  rx606_start:
    eq $I10, 1, rx606_restart
    if_null rx606_debug, debug_950
    rx606_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_950:
    $I10 = self.'from'()
    ne $I10, -1, rxscan610_done
    goto rxscan610_scan
  rxscan610_loop:
    (rx606_pos) = rx606_cur."from"()
    inc rx606_pos
    rx606_cur."!cursor_from"(rx606_pos)
    ge rx606_pos, rx606_eos, rxscan610_done
  rxscan610_scan:
    set_addr $I10, rxscan610_loop
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
  rxscan610_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_611_fail
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
  # rx literal  "try"
    add $I11, rx606_pos, 3
    gt $I11, rx606_eos, rx606_fail
    sub $I11, rx606_pos, rx606_off
    substr $S10, rx606_tgt, $I11, 3
    ne $S10, "try", rx606_fail
    add rx606_pos, 3
    set_addr $I10, rxcap_611_fail
    ($I12, $I11) = rx606_cur."!mark_peek"($I10)
    rx606_cur."!cursor_pos"($I11)
    ($P10) = rx606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx606_pos, "")
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_611_done
  rxcap_611_fail:
    goto rx606_fail
  rxcap_611_done:
.annotate 'line', 247
  # rx subrule "blorst" subtype=capture negate=
    rx606_cur."!cursor_pos"(rx606_pos)
    $P10 = rx606_cur."blorst"()
    unless $P10, rx606_fail
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx606_pos = $P10."pos"()
.annotate 'line', 245
  # rx pass
    rx606_cur."!cursor_pass"(rx606_pos, "statement_prefix:sym<try>")
    if_null rx606_debug, debug_951
    rx606_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx606_pos)
  debug_951:
    .return (rx606_cur)
  rx606_restart:
.annotate 'line', 10
    if_null rx606_debug, debug_952
    rx606_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_952:
  rx606_fail:
    (rx606_rep, rx606_pos, $I10, $P10) = rx606_cur."!mark_fail"(0)
    lt rx606_pos, -1, rx606_done
    eq rx606_pos, -1, rx606_fail
    jump $I10
  rx606_done:
    rx606_cur."!cursor_fail"()
    if_null rx606_debug, debug_953
    rx606_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_953:
    .return (rx606_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("121_1304282286.73") :method
.annotate 'line', 10
    $P608 = self."!PREFIX__!subrule"("blorst", "try")
    new $P609, "ResizablePMCArray"
    push $P609, $P608
    .return ($P609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("122_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P613 = self."!PREFIX__!subrule"("blorst", "try")
    new $P614, "ResizablePMCArray"
    push $P614, $P613
    .return ($P614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("123_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx616_tgt
    .local int rx616_pos
    .local int rx616_off
    .local int rx616_eos
    .local int rx616_rep
    .local pmc rx616_cur
    .local pmc rx616_debug
    (rx616_cur, rx616_pos, rx616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx616_cur
    .local pmc match
    .lex "$/", match
    length rx616_eos, rx616_tgt
    gt rx616_pos, rx616_eos, rx616_done
    set rx616_off, 0
    lt rx616_pos, 2, rx616_start
    sub rx616_off, rx616_pos, 1
    substr rx616_tgt, rx616_tgt, rx616_off
  rx616_start:
    eq $I10, 1, rx616_restart
    if_null rx616_debug, debug_954
    rx616_cur."!cursor_debug"("START", "blorst")
  debug_954:
    $I10 = self.'from'()
    ne $I10, -1, rxscan619_done
    goto rxscan619_scan
  rxscan619_loop:
    (rx616_pos) = rx616_cur."from"()
    inc rx616_pos
    rx616_cur."!cursor_from"(rx616_pos)
    ge rx616_pos, rx616_eos, rxscan619_done
  rxscan619_scan:
    set_addr $I10, rxscan619_loop
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  rxscan619_done:
.annotate 'line', 251
  # rx charclass s
    ge rx616_pos, rx616_eos, rx616_fail
    sub $I10, rx616_pos, rx616_off
    is_cclass $I11, 32, rx616_tgt, $I10
    unless $I11, rx616_fail
    inc rx616_pos
  # rx subrule "ws" subtype=method negate=
    rx616_cur."!cursor_pos"(rx616_pos)
    $P10 = rx616_cur."ws"()
    unless $P10, rx616_fail
    rx616_pos = $P10."pos"()
  alt620_0:
    set_addr $I10, alt620_1
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx616_pos, rx616_off
    substr $S10, rx616_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx616_fail
  # rx subrule "block" subtype=capture negate=
    rx616_cur."!cursor_pos"(rx616_pos)
    $P10 = rx616_cur."block"()
    unless $P10, rx616_fail
    rx616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx616_pos = $P10."pos"()
    goto alt620_end
  alt620_1:
  # rx subrule "statement" subtype=capture negate=
    rx616_cur."!cursor_pos"(rx616_pos)
    $P10 = rx616_cur."statement"()
    unless $P10, rx616_fail
    rx616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx616_pos = $P10."pos"()
  alt620_end:
.annotate 'line', 250
  # rx pass
    rx616_cur."!cursor_pass"(rx616_pos, "blorst")
    if_null rx616_debug, debug_955
    rx616_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx616_pos)
  debug_955:
    .return (rx616_cur)
  rx616_restart:
.annotate 'line', 10
    if_null rx616_debug, debug_956
    rx616_cur."!cursor_debug"("NEXT", "blorst")
  debug_956:
  rx616_fail:
    (rx616_rep, rx616_pos, $I10, $P10) = rx616_cur."!mark_fail"(0)
    lt rx616_pos, -1, rx616_done
    eq rx616_pos, -1, rx616_fail
    jump $I10
  rx616_done:
    rx616_cur."!cursor_fail"()
    if_null rx616_debug, debug_957
    rx616_cur."!cursor_debug"("FAIL", "blorst")
  debug_957:
    .return (rx616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("124_1304282286.73") :method
.annotate 'line', 10
    new $P618, "ResizablePMCArray"
    push $P618, ""
    .return ($P618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("125_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P622, "ResizablePMCArray"
    push $P622, ""
    .return ($P622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("126_1304282286.73")
    .param pmc param_624
.annotate 'line', 256
    .lex "self", param_624
    $P625 = param_624."!protoregex"("statement_mod_cond")
    .return ($P625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("127_1304282286.73")
    .param pmc param_627
.annotate 'line', 256
    .lex "self", param_627
    $P628 = param_627."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("128_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx630_tgt
    .local int rx630_pos
    .local int rx630_off
    .local int rx630_eos
    .local int rx630_rep
    .local pmc rx630_cur
    .local pmc rx630_debug
    (rx630_cur, rx630_pos, rx630_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx630_cur
    .local pmc match
    .lex "$/", match
    length rx630_eos, rx630_tgt
    gt rx630_pos, rx630_eos, rx630_done
    set rx630_off, 0
    lt rx630_pos, 2, rx630_start
    sub rx630_off, rx630_pos, 1
    substr rx630_tgt, rx630_tgt, rx630_off
  rx630_start:
    eq $I10, 1, rx630_restart
    if_null rx630_debug, debug_958
    rx630_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_958:
    $I10 = self.'from'()
    ne $I10, -1, rxscan634_done
    goto rxscan634_scan
  rxscan634_loop:
    (rx630_pos) = rx630_cur."from"()
    inc rx630_pos
    rx630_cur."!cursor_from"(rx630_pos)
    ge rx630_pos, rx630_eos, rxscan634_done
  rxscan634_scan:
    set_addr $I10, rxscan634_loop
    rx630_cur."!mark_push"(0, rx630_pos, $I10)
  rxscan634_done:
.annotate 'line', 258
  # rx subcapture "sym"
    set_addr $I10, rxcap_635_fail
    rx630_cur."!mark_push"(0, rx630_pos, $I10)
  # rx literal  "if"
    add $I11, rx630_pos, 2
    gt $I11, rx630_eos, rx630_fail
    sub $I11, rx630_pos, rx630_off
    substr $S10, rx630_tgt, $I11, 2
    ne $S10, "if", rx630_fail
    add rx630_pos, 2
    set_addr $I10, rxcap_635_fail
    ($I12, $I11) = rx630_cur."!mark_peek"($I10)
    rx630_cur."!cursor_pos"($I11)
    ($P10) = rx630_cur."!cursor_start"()
    $P10."!cursor_pass"(rx630_pos, "")
    rx630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_635_done
  rxcap_635_fail:
    goto rx630_fail
  rxcap_635_done:
  # rx subrule "ws" subtype=method negate=
    rx630_cur."!cursor_pos"(rx630_pos)
    $P10 = rx630_cur."ws"()
    unless $P10, rx630_fail
    rx630_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx630_cur."!cursor_pos"(rx630_pos)
    $P10 = rx630_cur."EXPR"()
    unless $P10, rx630_fail
    rx630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx630_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx630_cur."!cursor_pos"(rx630_pos)
    $P10 = rx630_cur."ws"()
    unless $P10, rx630_fail
    rx630_pos = $P10."pos"()
  # rx pass
    rx630_cur."!cursor_pass"(rx630_pos, "statement_mod_cond:sym<if>")
    if_null rx630_debug, debug_959
    rx630_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx630_pos)
  debug_959:
    .return (rx630_cur)
  rx630_restart:
.annotate 'line', 10
    if_null rx630_debug, debug_960
    rx630_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_960:
  rx630_fail:
    (rx630_rep, rx630_pos, $I10, $P10) = rx630_cur."!mark_fail"(0)
    lt rx630_pos, -1, rx630_done
    eq rx630_pos, -1, rx630_fail
    jump $I10
  rx630_done:
    rx630_cur."!cursor_fail"()
    if_null rx630_debug, debug_961
    rx630_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_961:
    .return (rx630_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("129_1304282286.73") :method
.annotate 'line', 10
    $P632 = self."!PREFIX__!subrule"("ws", "if")
    new $P633, "ResizablePMCArray"
    push $P633, $P632
    .return ($P633)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("130_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P639 = self."!PREFIX__!subrule"("ws", "if")
    new $P640, "ResizablePMCArray"
    push $P640, $P639
    .return ($P640)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("131_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx642_tgt
    .local int rx642_pos
    .local int rx642_off
    .local int rx642_eos
    .local int rx642_rep
    .local pmc rx642_cur
    .local pmc rx642_debug
    (rx642_cur, rx642_pos, rx642_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx642_cur
    .local pmc match
    .lex "$/", match
    length rx642_eos, rx642_tgt
    gt rx642_pos, rx642_eos, rx642_done
    set rx642_off, 0
    lt rx642_pos, 2, rx642_start
    sub rx642_off, rx642_pos, 1
    substr rx642_tgt, rx642_tgt, rx642_off
  rx642_start:
    eq $I10, 1, rx642_restart
    if_null rx642_debug, debug_962
    rx642_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_962:
    $I10 = self.'from'()
    ne $I10, -1, rxscan646_done
    goto rxscan646_scan
  rxscan646_loop:
    (rx642_pos) = rx642_cur."from"()
    inc rx642_pos
    rx642_cur."!cursor_from"(rx642_pos)
    ge rx642_pos, rx642_eos, rxscan646_done
  rxscan646_scan:
    set_addr $I10, rxscan646_loop
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
  rxscan646_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_647_fail
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
  # rx literal  "unless"
    add $I11, rx642_pos, 6
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    substr $S10, rx642_tgt, $I11, 6
    ne $S10, "unless", rx642_fail
    add rx642_pos, 6
    set_addr $I10, rxcap_647_fail
    ($I12, $I11) = rx642_cur."!mark_peek"($I10)
    rx642_cur."!cursor_pos"($I11)
    ($P10) = rx642_cur."!cursor_start"()
    $P10."!cursor_pass"(rx642_pos, "")
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_647_done
  rxcap_647_fail:
    goto rx642_fail
  rxcap_647_done:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."EXPR"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx pass
    rx642_cur."!cursor_pass"(rx642_pos, "statement_mod_cond:sym<unless>")
    if_null rx642_debug, debug_963
    rx642_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx642_pos)
  debug_963:
    .return (rx642_cur)
  rx642_restart:
.annotate 'line', 10
    if_null rx642_debug, debug_964
    rx642_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_964:
  rx642_fail:
    (rx642_rep, rx642_pos, $I10, $P10) = rx642_cur."!mark_fail"(0)
    lt rx642_pos, -1, rx642_done
    eq rx642_pos, -1, rx642_fail
    jump $I10
  rx642_done:
    rx642_cur."!cursor_fail"()
    if_null rx642_debug, debug_965
    rx642_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_965:
    .return (rx642_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("132_1304282286.73") :method
.annotate 'line', 10
    $P644 = self."!PREFIX__!subrule"("ws", "unless")
    new $P645, "ResizablePMCArray"
    push $P645, $P644
    .return ($P645)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("133_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P651 = self."!PREFIX__!subrule"("ws", "unless")
    new $P652, "ResizablePMCArray"
    push $P652, $P651
    .return ($P652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("134_1304282286.73")
    .param pmc param_654
.annotate 'line', 261
    .lex "self", param_654
    $P655 = param_654."!protoregex"("statement_mod_loop")
    .return ($P655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("135_1304282286.73")
    .param pmc param_657
.annotate 'line', 261
    .lex "self", param_657
    $P658 = param_657."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("136_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx660_tgt
    .local int rx660_pos
    .local int rx660_off
    .local int rx660_eos
    .local int rx660_rep
    .local pmc rx660_cur
    .local pmc rx660_debug
    (rx660_cur, rx660_pos, rx660_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx660_cur
    .local pmc match
    .lex "$/", match
    length rx660_eos, rx660_tgt
    gt rx660_pos, rx660_eos, rx660_done
    set rx660_off, 0
    lt rx660_pos, 2, rx660_start
    sub rx660_off, rx660_pos, 1
    substr rx660_tgt, rx660_tgt, rx660_off
  rx660_start:
    eq $I10, 1, rx660_restart
    if_null rx660_debug, debug_966
    rx660_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_966:
    $I10 = self.'from'()
    ne $I10, -1, rxscan664_done
    goto rxscan664_scan
  rxscan664_loop:
    (rx660_pos) = rx660_cur."from"()
    inc rx660_pos
    rx660_cur."!cursor_from"(rx660_pos)
    ge rx660_pos, rx660_eos, rxscan664_done
  rxscan664_scan:
    set_addr $I10, rxscan664_loop
    rx660_cur."!mark_push"(0, rx660_pos, $I10)
  rxscan664_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_665_fail
    rx660_cur."!mark_push"(0, rx660_pos, $I10)
  # rx literal  "while"
    add $I11, rx660_pos, 5
    gt $I11, rx660_eos, rx660_fail
    sub $I11, rx660_pos, rx660_off
    substr $S10, rx660_tgt, $I11, 5
    ne $S10, "while", rx660_fail
    add rx660_pos, 5
    set_addr $I10, rxcap_665_fail
    ($I12, $I11) = rx660_cur."!mark_peek"($I10)
    rx660_cur."!cursor_pos"($I11)
    ($P10) = rx660_cur."!cursor_start"()
    $P10."!cursor_pass"(rx660_pos, "")
    rx660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_665_done
  rxcap_665_fail:
    goto rx660_fail
  rxcap_665_done:
  # rx subrule "ws" subtype=method negate=
    rx660_cur."!cursor_pos"(rx660_pos)
    $P10 = rx660_cur."ws"()
    unless $P10, rx660_fail
    rx660_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx660_cur."!cursor_pos"(rx660_pos)
    $P10 = rx660_cur."EXPR"()
    unless $P10, rx660_fail
    rx660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx660_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx660_cur."!cursor_pos"(rx660_pos)
    $P10 = rx660_cur."ws"()
    unless $P10, rx660_fail
    rx660_pos = $P10."pos"()
  # rx pass
    rx660_cur."!cursor_pass"(rx660_pos, "statement_mod_loop:sym<while>")
    if_null rx660_debug, debug_967
    rx660_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx660_pos)
  debug_967:
    .return (rx660_cur)
  rx660_restart:
.annotate 'line', 10
    if_null rx660_debug, debug_968
    rx660_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_968:
  rx660_fail:
    (rx660_rep, rx660_pos, $I10, $P10) = rx660_cur."!mark_fail"(0)
    lt rx660_pos, -1, rx660_done
    eq rx660_pos, -1, rx660_fail
    jump $I10
  rx660_done:
    rx660_cur."!cursor_fail"()
    if_null rx660_debug, debug_969
    rx660_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_969:
    .return (rx660_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("137_1304282286.73") :method
.annotate 'line', 10
    $P662 = self."!PREFIX__!subrule"("ws", "while")
    new $P663, "ResizablePMCArray"
    push $P663, $P662
    .return ($P663)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("138_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P669 = self."!PREFIX__!subrule"("ws", "while")
    new $P670, "ResizablePMCArray"
    push $P670, $P669
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("139_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx672_tgt
    .local int rx672_pos
    .local int rx672_off
    .local int rx672_eos
    .local int rx672_rep
    .local pmc rx672_cur
    .local pmc rx672_debug
    (rx672_cur, rx672_pos, rx672_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx672_cur
    .local pmc match
    .lex "$/", match
    length rx672_eos, rx672_tgt
    gt rx672_pos, rx672_eos, rx672_done
    set rx672_off, 0
    lt rx672_pos, 2, rx672_start
    sub rx672_off, rx672_pos, 1
    substr rx672_tgt, rx672_tgt, rx672_off
  rx672_start:
    eq $I10, 1, rx672_restart
    if_null rx672_debug, debug_970
    rx672_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_970:
    $I10 = self.'from'()
    ne $I10, -1, rxscan676_done
    goto rxscan676_scan
  rxscan676_loop:
    (rx672_pos) = rx672_cur."from"()
    inc rx672_pos
    rx672_cur."!cursor_from"(rx672_pos)
    ge rx672_pos, rx672_eos, rxscan676_done
  rxscan676_scan:
    set_addr $I10, rxscan676_loop
    rx672_cur."!mark_push"(0, rx672_pos, $I10)
  rxscan676_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_677_fail
    rx672_cur."!mark_push"(0, rx672_pos, $I10)
  # rx literal  "until"
    add $I11, rx672_pos, 5
    gt $I11, rx672_eos, rx672_fail
    sub $I11, rx672_pos, rx672_off
    substr $S10, rx672_tgt, $I11, 5
    ne $S10, "until", rx672_fail
    add rx672_pos, 5
    set_addr $I10, rxcap_677_fail
    ($I12, $I11) = rx672_cur."!mark_peek"($I10)
    rx672_cur."!cursor_pos"($I11)
    ($P10) = rx672_cur."!cursor_start"()
    $P10."!cursor_pass"(rx672_pos, "")
    rx672_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_677_done
  rxcap_677_fail:
    goto rx672_fail
  rxcap_677_done:
  # rx subrule "ws" subtype=method negate=
    rx672_cur."!cursor_pos"(rx672_pos)
    $P10 = rx672_cur."ws"()
    unless $P10, rx672_fail
    rx672_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx672_cur."!cursor_pos"(rx672_pos)
    $P10 = rx672_cur."EXPR"()
    unless $P10, rx672_fail
    rx672_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx672_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx672_cur."!cursor_pos"(rx672_pos)
    $P10 = rx672_cur."ws"()
    unless $P10, rx672_fail
    rx672_pos = $P10."pos"()
  # rx pass
    rx672_cur."!cursor_pass"(rx672_pos, "statement_mod_loop:sym<until>")
    if_null rx672_debug, debug_971
    rx672_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx672_pos)
  debug_971:
    .return (rx672_cur)
  rx672_restart:
.annotate 'line', 10
    if_null rx672_debug, debug_972
    rx672_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_972:
  rx672_fail:
    (rx672_rep, rx672_pos, $I10, $P10) = rx672_cur."!mark_fail"(0)
    lt rx672_pos, -1, rx672_done
    eq rx672_pos, -1, rx672_fail
    jump $I10
  rx672_done:
    rx672_cur."!cursor_fail"()
    if_null rx672_debug, debug_973
    rx672_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_973:
    .return (rx672_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("140_1304282286.73") :method
.annotate 'line', 10
    $P674 = self."!PREFIX__!subrule"("ws", "until")
    new $P675, "ResizablePMCArray"
    push $P675, $P674
    .return ($P675)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("141_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("ws", "until")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("142_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx684_tgt
    .local int rx684_pos
    .local int rx684_off
    .local int rx684_eos
    .local int rx684_rep
    .local pmc rx684_cur
    .local pmc rx684_debug
    (rx684_cur, rx684_pos, rx684_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx684_cur
    .local pmc match
    .lex "$/", match
    length rx684_eos, rx684_tgt
    gt rx684_pos, rx684_eos, rx684_done
    set rx684_off, 0
    lt rx684_pos, 2, rx684_start
    sub rx684_off, rx684_pos, 1
    substr rx684_tgt, rx684_tgt, rx684_off
  rx684_start:
    eq $I10, 1, rx684_restart
    if_null rx684_debug, debug_974
    rx684_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan688_done
    goto rxscan688_scan
  rxscan688_loop:
    (rx684_pos) = rx684_cur."from"()
    inc rx684_pos
    rx684_cur."!cursor_from"(rx684_pos)
    ge rx684_pos, rx684_eos, rxscan688_done
  rxscan688_scan:
    set_addr $I10, rxscan688_loop
    rx684_cur."!mark_push"(0, rx684_pos, $I10)
  rxscan688_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_689_fail
    rx684_cur."!mark_push"(0, rx684_pos, $I10)
  # rx literal  "for"
    add $I11, rx684_pos, 3
    gt $I11, rx684_eos, rx684_fail
    sub $I11, rx684_pos, rx684_off
    substr $S10, rx684_tgt, $I11, 3
    ne $S10, "for", rx684_fail
    add rx684_pos, 3
    set_addr $I10, rxcap_689_fail
    ($I12, $I11) = rx684_cur."!mark_peek"($I10)
    rx684_cur."!cursor_pos"($I11)
    ($P10) = rx684_cur."!cursor_start"()
    $P10."!cursor_pass"(rx684_pos, "")
    rx684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_689_done
  rxcap_689_fail:
    goto rx684_fail
  rxcap_689_done:
  # rx subrule "ws" subtype=method negate=
    rx684_cur."!cursor_pos"(rx684_pos)
    $P10 = rx684_cur."ws"()
    unless $P10, rx684_fail
    rx684_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx684_cur."!cursor_pos"(rx684_pos)
    $P10 = rx684_cur."EXPR"()
    unless $P10, rx684_fail
    rx684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx684_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx684_cur."!cursor_pos"(rx684_pos)
    $P10 = rx684_cur."ws"()
    unless $P10, rx684_fail
    rx684_pos = $P10."pos"()
  # rx pass
    rx684_cur."!cursor_pass"(rx684_pos, "statement_mod_loop:sym<for>")
    if_null rx684_debug, debug_975
    rx684_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx684_pos)
  debug_975:
    .return (rx684_cur)
  rx684_restart:
.annotate 'line', 10
    if_null rx684_debug, debug_976
    rx684_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_976:
  rx684_fail:
    (rx684_rep, rx684_pos, $I10, $P10) = rx684_cur."!mark_fail"(0)
    lt rx684_pos, -1, rx684_done
    eq rx684_pos, -1, rx684_fail
    jump $I10
  rx684_done:
    rx684_cur."!cursor_fail"()
    if_null rx684_debug, debug_977
    rx684_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_977:
    .return (rx684_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("143_1304282286.73") :method
.annotate 'line', 10
    $P686 = self."!PREFIX__!subrule"("ws", "for")
    new $P687, "ResizablePMCArray"
    push $P687, $P686
    .return ($P687)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("144_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P693 = self."!PREFIX__!subrule"("ws", "for")
    new $P694, "ResizablePMCArray"
    push $P694, $P693
    .return ($P694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("145_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx696_tgt
    .local int rx696_pos
    .local int rx696_off
    .local int rx696_eos
    .local int rx696_rep
    .local pmc rx696_cur
    .local pmc rx696_debug
    (rx696_cur, rx696_pos, rx696_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx696_cur
    .local pmc match
    .lex "$/", match
    length rx696_eos, rx696_tgt
    gt rx696_pos, rx696_eos, rx696_done
    set rx696_off, 0
    lt rx696_pos, 2, rx696_start
    sub rx696_off, rx696_pos, 1
    substr rx696_tgt, rx696_tgt, rx696_off
  rx696_start:
    eq $I10, 1, rx696_restart
    if_null rx696_debug, debug_978
    rx696_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan700_done
    goto rxscan700_scan
  rxscan700_loop:
    (rx696_pos) = rx696_cur."from"()
    inc rx696_pos
    rx696_cur."!cursor_from"(rx696_pos)
    ge rx696_pos, rx696_eos, rxscan700_done
  rxscan700_scan:
    set_addr $I10, rxscan700_loop
    rx696_cur."!mark_push"(0, rx696_pos, $I10)
  rxscan700_done:
.annotate 'line', 269
  # rx subrule "fatarrow" subtype=capture negate=
    rx696_cur."!cursor_pos"(rx696_pos)
    $P10 = rx696_cur."fatarrow"()
    unless $P10, rx696_fail
    rx696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx696_pos = $P10."pos"()
  # rx pass
    rx696_cur."!cursor_pass"(rx696_pos, "term:sym<fatarrow>")
    if_null rx696_debug, debug_979
    rx696_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx696_pos)
  debug_979:
    .return (rx696_cur)
  rx696_restart:
.annotate 'line', 10
    if_null rx696_debug, debug_980
    rx696_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_980:
  rx696_fail:
    (rx696_rep, rx696_pos, $I10, $P10) = rx696_cur."!mark_fail"(0)
    lt rx696_pos, -1, rx696_done
    eq rx696_pos, -1, rx696_fail
    jump $I10
  rx696_done:
    rx696_cur."!cursor_fail"()
    if_null rx696_debug, debug_981
    rx696_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_981:
    .return (rx696_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("146_1304282286.73") :method
.annotate 'line', 10
    $P698 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P699, "ResizablePMCArray"
    push $P699, $P698
    .return ($P699)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("147_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P702 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P703, "ResizablePMCArray"
    push $P703, $P702
    .return ($P703)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("148_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_982
    rx705_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan709_done
    goto rxscan709_scan
  rxscan709_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan709_done
  rxscan709_scan:
    set_addr $I10, rxscan709_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan709_done:
.annotate 'line', 270
  # rx subrule "colonpair" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."colonpair"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx705_pos = $P10."pos"()
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "term:sym<colonpair>")
    if_null rx705_debug, debug_983
    rx705_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx705_pos)
  debug_983:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 10
    if_null rx705_debug, debug_984
    rx705_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_984:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_985
    rx705_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_985:
    .return (rx705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("149_1304282286.73") :method
.annotate 'line', 10
    $P707 = self."!PREFIX__!subrule"("colonpair", "")
    new $P708, "ResizablePMCArray"
    push $P708, $P707
    .return ($P708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("150_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P711 = self."!PREFIX__!subrule"("colonpair", "")
    new $P712, "ResizablePMCArray"
    push $P712, $P711
    .return ($P712)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("151_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx714_tgt
    .local int rx714_pos
    .local int rx714_off
    .local int rx714_eos
    .local int rx714_rep
    .local pmc rx714_cur
    .local pmc rx714_debug
    (rx714_cur, rx714_pos, rx714_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx714_cur
    .local pmc match
    .lex "$/", match
    length rx714_eos, rx714_tgt
    gt rx714_pos, rx714_eos, rx714_done
    set rx714_off, 0
    lt rx714_pos, 2, rx714_start
    sub rx714_off, rx714_pos, 1
    substr rx714_tgt, rx714_tgt, rx714_off
  rx714_start:
    eq $I10, 1, rx714_restart
    if_null rx714_debug, debug_986
    rx714_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan718_done
    goto rxscan718_scan
  rxscan718_loop:
    (rx714_pos) = rx714_cur."from"()
    inc rx714_pos
    rx714_cur."!cursor_from"(rx714_pos)
    ge rx714_pos, rx714_eos, rxscan718_done
  rxscan718_scan:
    set_addr $I10, rxscan718_loop
    rx714_cur."!mark_push"(0, rx714_pos, $I10)
  rxscan718_done:
.annotate 'line', 271
  # rx subrule "variable" subtype=capture negate=
    rx714_cur."!cursor_pos"(rx714_pos)
    $P10 = rx714_cur."variable"()
    unless $P10, rx714_fail
    rx714_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx714_pos = $P10."pos"()
  # rx pass
    rx714_cur."!cursor_pass"(rx714_pos, "term:sym<variable>")
    if_null rx714_debug, debug_987
    rx714_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx714_pos)
  debug_987:
    .return (rx714_cur)
  rx714_restart:
.annotate 'line', 10
    if_null rx714_debug, debug_988
    rx714_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_988:
  rx714_fail:
    (rx714_rep, rx714_pos, $I10, $P10) = rx714_cur."!mark_fail"(0)
    lt rx714_pos, -1, rx714_done
    eq rx714_pos, -1, rx714_fail
    jump $I10
  rx714_done:
    rx714_cur."!cursor_fail"()
    if_null rx714_debug, debug_989
    rx714_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_989:
    .return (rx714_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("152_1304282286.73") :method
.annotate 'line', 10
    $P716 = self."!PREFIX__!subrule"("variable", "")
    new $P717, "ResizablePMCArray"
    push $P717, $P716
    .return ($P717)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("153_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P720 = self."!PREFIX__!subrule"("variable", "")
    new $P721, "ResizablePMCArray"
    push $P721, $P720
    .return ($P721)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("154_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx723_tgt
    .local int rx723_pos
    .local int rx723_off
    .local int rx723_eos
    .local int rx723_rep
    .local pmc rx723_cur
    .local pmc rx723_debug
    (rx723_cur, rx723_pos, rx723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx723_cur
    .local pmc match
    .lex "$/", match
    length rx723_eos, rx723_tgt
    gt rx723_pos, rx723_eos, rx723_done
    set rx723_off, 0
    lt rx723_pos, 2, rx723_start
    sub rx723_off, rx723_pos, 1
    substr rx723_tgt, rx723_tgt, rx723_off
  rx723_start:
    eq $I10, 1, rx723_restart
    if_null rx723_debug, debug_990
    rx723_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan727_done
    goto rxscan727_scan
  rxscan727_loop:
    (rx723_pos) = rx723_cur."from"()
    inc rx723_pos
    rx723_cur."!cursor_from"(rx723_pos)
    ge rx723_pos, rx723_eos, rxscan727_done
  rxscan727_scan:
    set_addr $I10, rxscan727_loop
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  rxscan727_done:
.annotate 'line', 272
  # rx subrule "package_declarator" subtype=capture negate=
    rx723_cur."!cursor_pos"(rx723_pos)
    $P10 = rx723_cur."package_declarator"()
    unless $P10, rx723_fail
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx723_pos = $P10."pos"()
  # rx pass
    rx723_cur."!cursor_pass"(rx723_pos, "term:sym<package_declarator>")
    if_null rx723_debug, debug_991
    rx723_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx723_pos)
  debug_991:
    .return (rx723_cur)
  rx723_restart:
.annotate 'line', 10
    if_null rx723_debug, debug_992
    rx723_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_992:
  rx723_fail:
    (rx723_rep, rx723_pos, $I10, $P10) = rx723_cur."!mark_fail"(0)
    lt rx723_pos, -1, rx723_done
    eq rx723_pos, -1, rx723_fail
    jump $I10
  rx723_done:
    rx723_cur."!cursor_fail"()
    if_null rx723_debug, debug_993
    rx723_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_993:
    .return (rx723_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("155_1304282286.73") :method
.annotate 'line', 10
    $P725 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P726, "ResizablePMCArray"
    push $P726, $P725
    .return ($P726)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("156_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P729 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P730, "ResizablePMCArray"
    push $P730, $P729
    .return ($P730)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("157_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx732_tgt
    .local int rx732_pos
    .local int rx732_off
    .local int rx732_eos
    .local int rx732_rep
    .local pmc rx732_cur
    .local pmc rx732_debug
    (rx732_cur, rx732_pos, rx732_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx732_cur
    .local pmc match
    .lex "$/", match
    length rx732_eos, rx732_tgt
    gt rx732_pos, rx732_eos, rx732_done
    set rx732_off, 0
    lt rx732_pos, 2, rx732_start
    sub rx732_off, rx732_pos, 1
    substr rx732_tgt, rx732_tgt, rx732_off
  rx732_start:
    eq $I10, 1, rx732_restart
    if_null rx732_debug, debug_994
    rx732_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan736_done
    goto rxscan736_scan
  rxscan736_loop:
    (rx732_pos) = rx732_cur."from"()
    inc rx732_pos
    rx732_cur."!cursor_from"(rx732_pos)
    ge rx732_pos, rx732_eos, rxscan736_done
  rxscan736_scan:
    set_addr $I10, rxscan736_loop
    rx732_cur."!mark_push"(0, rx732_pos, $I10)
  rxscan736_done:
.annotate 'line', 273
  # rx subrule "scope_declarator" subtype=capture negate=
    rx732_cur."!cursor_pos"(rx732_pos)
    $P10 = rx732_cur."scope_declarator"()
    unless $P10, rx732_fail
    rx732_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx732_pos = $P10."pos"()
  # rx pass
    rx732_cur."!cursor_pass"(rx732_pos, "term:sym<scope_declarator>")
    if_null rx732_debug, debug_995
    rx732_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx732_pos)
  debug_995:
    .return (rx732_cur)
  rx732_restart:
.annotate 'line', 10
    if_null rx732_debug, debug_996
    rx732_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_996:
  rx732_fail:
    (rx732_rep, rx732_pos, $I10, $P10) = rx732_cur."!mark_fail"(0)
    lt rx732_pos, -1, rx732_done
    eq rx732_pos, -1, rx732_fail
    jump $I10
  rx732_done:
    rx732_cur."!cursor_fail"()
    if_null rx732_debug, debug_997
    rx732_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_997:
    .return (rx732_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("158_1304282286.73") :method
.annotate 'line', 10
    $P734 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P735, "ResizablePMCArray"
    push $P735, $P734
    .return ($P735)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("159_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P738 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P739, "ResizablePMCArray"
    push $P739, $P738
    .return ($P739)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("160_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx741_tgt
    .local int rx741_pos
    .local int rx741_off
    .local int rx741_eos
    .local int rx741_rep
    .local pmc rx741_cur
    .local pmc rx741_debug
    (rx741_cur, rx741_pos, rx741_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx741_cur
    .local pmc match
    .lex "$/", match
    length rx741_eos, rx741_tgt
    gt rx741_pos, rx741_eos, rx741_done
    set rx741_off, 0
    lt rx741_pos, 2, rx741_start
    sub rx741_off, rx741_pos, 1
    substr rx741_tgt, rx741_tgt, rx741_off
  rx741_start:
    eq $I10, 1, rx741_restart
    if_null rx741_debug, debug_998
    rx741_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan745_done
    goto rxscan745_scan
  rxscan745_loop:
    (rx741_pos) = rx741_cur."from"()
    inc rx741_pos
    rx741_cur."!cursor_from"(rx741_pos)
    ge rx741_pos, rx741_eos, rxscan745_done
  rxscan745_scan:
    set_addr $I10, rxscan745_loop
    rx741_cur."!mark_push"(0, rx741_pos, $I10)
  rxscan745_done:
.annotate 'line', 274
  # rx subrule "routine_declarator" subtype=capture negate=
    rx741_cur."!cursor_pos"(rx741_pos)
    $P10 = rx741_cur."routine_declarator"()
    unless $P10, rx741_fail
    rx741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx741_pos = $P10."pos"()
  # rx pass
    rx741_cur."!cursor_pass"(rx741_pos, "term:sym<routine_declarator>")
    if_null rx741_debug, debug_999
    rx741_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx741_pos)
  debug_999:
    .return (rx741_cur)
  rx741_restart:
.annotate 'line', 10
    if_null rx741_debug, debug_1000
    rx741_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1000:
  rx741_fail:
    (rx741_rep, rx741_pos, $I10, $P10) = rx741_cur."!mark_fail"(0)
    lt rx741_pos, -1, rx741_done
    eq rx741_pos, -1, rx741_fail
    jump $I10
  rx741_done:
    rx741_cur."!cursor_fail"()
    if_null rx741_debug, debug_1001
    rx741_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1001:
    .return (rx741_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("161_1304282286.73") :method
.annotate 'line', 10
    $P743 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P744, "ResizablePMCArray"
    push $P744, $P743
    .return ($P744)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("162_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P747 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P748, "ResizablePMCArray"
    push $P748, $P747
    .return ($P748)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("163_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P760 = "166_1304282286.73" 
    capture_lex $P760
    .const 'Sub' $P755 = "165_1304282286.73" 
    capture_lex $P755
    .local string rx750_tgt
    .local int rx750_pos
    .local int rx750_off
    .local int rx750_eos
    .local int rx750_rep
    .local pmc rx750_cur
    .local pmc rx750_debug
    (rx750_cur, rx750_pos, rx750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx750_cur
    .local pmc match
    .lex "$/", match
    length rx750_eos, rx750_tgt
    gt rx750_pos, rx750_eos, rx750_done
    set rx750_off, 0
    lt rx750_pos, 2, rx750_start
    sub rx750_off, rx750_pos, 1
    substr rx750_tgt, rx750_tgt, rx750_off
  rx750_start:
    eq $I10, 1, rx750_restart
    if_null rx750_debug, debug_1002
    rx750_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan753_done
    goto rxscan753_scan
  rxscan753_loop:
    (rx750_pos) = rx750_cur."from"()
    inc rx750_pos
    rx750_cur."!cursor_from"(rx750_pos)
    ge rx750_pos, rx750_eos, rxscan753_done
  rxscan753_scan:
    set_addr $I10, rxscan753_loop
    rx750_cur."!mark_push"(0, rx750_pos, $I10)
  rxscan753_done:
.annotate 'line', 276
  # rx subrule "before" subtype=zerowidth negate=
    rx750_cur."!cursor_pos"(rx750_pos)
    .const 'Sub' $P755 = "165_1304282286.73" 
    capture_lex $P755
    $P10 = rx750_cur."before"($P755)
    unless $P10, rx750_fail
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=1
    rx750_cur."!cursor_pos"(rx750_pos)
    .const 'Sub' $P760 = "166_1304282286.73" 
    capture_lex $P760
    $P10 = rx750_cur."before"($P760)
    if $P10, rx750_fail
.annotate 'line', 278
  # rx subrule "multi_declarator" subtype=capture negate=
    rx750_cur."!cursor_pos"(rx750_pos)
    $P10 = rx750_cur."multi_declarator"()
    unless $P10, rx750_fail
    rx750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx750_pos = $P10."pos"()
.annotate 'line', 275
  # rx pass
    rx750_cur."!cursor_pass"(rx750_pos, "term:sym<multi_declarator>")
    if_null rx750_debug, debug_1011
    rx750_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx750_pos)
  debug_1011:
    .return (rx750_cur)
  rx750_restart:
.annotate 'line', 10
    if_null rx750_debug, debug_1012
    rx750_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1012:
  rx750_fail:
    (rx750_rep, rx750_pos, $I10, $P10) = rx750_cur."!mark_fail"(0)
    lt rx750_pos, -1, rx750_done
    eq rx750_pos, -1, rx750_fail
    jump $I10
  rx750_done:
    rx750_cur."!cursor_fail"()
    if_null rx750_debug, debug_1013
    rx750_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1013:
    .return (rx750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("164_1304282286.73") :method
.annotate 'line', 10
    new $P752, "ResizablePMCArray"
    push $P752, ""
    .return ($P752)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block754"  :anon :subid("165_1304282286.73") :method :outer("163_1304282286.73")
.annotate 'line', 276
    .local string rx756_tgt
    .local int rx756_pos
    .local int rx756_off
    .local int rx756_eos
    .local int rx756_rep
    .local pmc rx756_cur
    .local pmc rx756_debug
    (rx756_cur, rx756_pos, rx756_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx756_cur
    .local pmc match
    .lex "$/", match
    length rx756_eos, rx756_tgt
    gt rx756_pos, rx756_eos, rx756_done
    set rx756_off, 0
    lt rx756_pos, 2, rx756_start
    sub rx756_off, rx756_pos, 1
    substr rx756_tgt, rx756_tgt, rx756_off
  rx756_start:
    eq $I10, 1, rx756_restart
    if_null rx756_debug, debug_1003
    rx756_cur."!cursor_debug"("START", "")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan757_done
    goto rxscan757_scan
  rxscan757_loop:
    (rx756_pos) = rx756_cur."from"()
    inc rx756_pos
    rx756_cur."!cursor_from"(rx756_pos)
    ge rx756_pos, rx756_eos, rxscan757_done
  rxscan757_scan:
    set_addr $I10, rxscan757_loop
    rx756_cur."!mark_push"(0, rx756_pos, $I10)
  rxscan757_done:
  alt758_0:
    set_addr $I10, alt758_1
    rx756_cur."!mark_push"(0, rx756_pos, $I10)
  # rx literal  "multi"
    add $I11, rx756_pos, 5
    gt $I11, rx756_eos, rx756_fail
    sub $I11, rx756_pos, rx756_off
    substr $S10, rx756_tgt, $I11, 5
    ne $S10, "multi", rx756_fail
    add rx756_pos, 5
    goto alt758_end
  alt758_1:
    set_addr $I10, alt758_2
    rx756_cur."!mark_push"(0, rx756_pos, $I10)
  # rx literal  "proto"
    add $I11, rx756_pos, 5
    gt $I11, rx756_eos, rx756_fail
    sub $I11, rx756_pos, rx756_off
    substr $S10, rx756_tgt, $I11, 5
    ne $S10, "proto", rx756_fail
    add rx756_pos, 5
    goto alt758_end
  alt758_2:
  # rx literal  "only"
    add $I11, rx756_pos, 4
    gt $I11, rx756_eos, rx756_fail
    sub $I11, rx756_pos, rx756_off
    substr $S10, rx756_tgt, $I11, 4
    ne $S10, "only", rx756_fail
    add rx756_pos, 4
  alt758_end:
  # rx pass
    rx756_cur."!cursor_pass"(rx756_pos, "")
    if_null rx756_debug, debug_1004
    rx756_cur."!cursor_debug"("PASS", "", " at pos=", rx756_pos)
  debug_1004:
    .return (rx756_cur)
  rx756_restart:
    if_null rx756_debug, debug_1005
    rx756_cur."!cursor_debug"("NEXT", "")
  debug_1005:
  rx756_fail:
    (rx756_rep, rx756_pos, $I10, $P10) = rx756_cur."!mark_fail"(0)
    lt rx756_pos, -1, rx756_done
    eq rx756_pos, -1, rx756_fail
    jump $I10
  rx756_done:
    rx756_cur."!cursor_fail"()
    if_null rx756_debug, debug_1006
    rx756_cur."!cursor_debug"("FAIL", "")
  debug_1006:
    .return (rx756_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block759"  :anon :subid("166_1304282286.73") :method :outer("163_1304282286.73")
.annotate 'line', 277
    .local string rx761_tgt
    .local int rx761_pos
    .local int rx761_off
    .local int rx761_eos
    .local int rx761_rep
    .local pmc rx761_cur
    .local pmc rx761_debug
    (rx761_cur, rx761_pos, rx761_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx761_cur
    .local pmc match
    .lex "$/", match
    length rx761_eos, rx761_tgt
    gt rx761_pos, rx761_eos, rx761_done
    set rx761_off, 0
    lt rx761_pos, 2, rx761_start
    sub rx761_off, rx761_pos, 1
    substr rx761_tgt, rx761_tgt, rx761_off
  rx761_start:
    eq $I10, 1, rx761_restart
    if_null rx761_debug, debug_1007
    rx761_cur."!cursor_debug"("START", "")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan762_done
    goto rxscan762_scan
  rxscan762_loop:
    (rx761_pos) = rx761_cur."from"()
    inc rx761_pos
    rx761_cur."!cursor_from"(rx761_pos)
    ge rx761_pos, rx761_eos, rxscan762_done
  rxscan762_scan:
    set_addr $I10, rxscan762_loop
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxscan762_done:
  # rx literal  "proto"
    add $I11, rx761_pos, 5
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 5
    ne $S10, "proto", rx761_fail
    add rx761_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  alt763_0:
    set_addr $I10, alt763_1
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx literal  "regex"
    add $I11, rx761_pos, 5
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 5
    ne $S10, "regex", rx761_fail
    add rx761_pos, 5
    goto alt763_end
  alt763_1:
    set_addr $I10, alt763_2
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx literal  "token"
    add $I11, rx761_pos, 5
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 5
    ne $S10, "token", rx761_fail
    add rx761_pos, 5
    goto alt763_end
  alt763_2:
  # rx literal  "rule"
    add $I11, rx761_pos, 4
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 4
    ne $S10, "rule", rx761_fail
    add rx761_pos, 4
  alt763_end:
  # rx pass
    rx761_cur."!cursor_pass"(rx761_pos, "")
    if_null rx761_debug, debug_1008
    rx761_cur."!cursor_debug"("PASS", "", " at pos=", rx761_pos)
  debug_1008:
    .return (rx761_cur)
  rx761_restart:
    if_null rx761_debug, debug_1009
    rx761_cur."!cursor_debug"("NEXT", "")
  debug_1009:
  rx761_fail:
    (rx761_rep, rx761_pos, $I10, $P10) = rx761_cur."!mark_fail"(0)
    lt rx761_pos, -1, rx761_done
    eq rx761_pos, -1, rx761_fail
    jump $I10
  rx761_done:
    rx761_cur."!cursor_fail"()
    if_null rx761_debug, debug_1010
    rx761_cur."!cursor_debug"("FAIL", "")
  debug_1010:
    .return (rx761_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("167_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P765, "ResizablePMCArray"
    push $P765, ""
    .return ($P765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("168_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx767_tgt
    .local int rx767_pos
    .local int rx767_off
    .local int rx767_eos
    .local int rx767_rep
    .local pmc rx767_cur
    .local pmc rx767_debug
    (rx767_cur, rx767_pos, rx767_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx767_cur
    .local pmc match
    .lex "$/", match
    length rx767_eos, rx767_tgt
    gt rx767_pos, rx767_eos, rx767_done
    set rx767_off, 0
    lt rx767_pos, 2, rx767_start
    sub rx767_off, rx767_pos, 1
    substr rx767_tgt, rx767_tgt, rx767_off
  rx767_start:
    eq $I10, 1, rx767_restart
    if_null rx767_debug, debug_1014
    rx767_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan771_done
    goto rxscan771_scan
  rxscan771_loop:
    (rx767_pos) = rx767_cur."from"()
    inc rx767_pos
    rx767_cur."!cursor_from"(rx767_pos)
    ge rx767_pos, rx767_eos, rxscan771_done
  rxscan771_scan:
    set_addr $I10, rxscan771_loop
    rx767_cur."!mark_push"(0, rx767_pos, $I10)
  rxscan771_done:
.annotate 'line', 280
  # rx subrule "regex_declarator" subtype=capture negate=
    rx767_cur."!cursor_pos"(rx767_pos)
    $P10 = rx767_cur."regex_declarator"()
    unless $P10, rx767_fail
    rx767_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx767_pos = $P10."pos"()
  # rx pass
    rx767_cur."!cursor_pass"(rx767_pos, "term:sym<regex_declarator>")
    if_null rx767_debug, debug_1015
    rx767_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx767_pos)
  debug_1015:
    .return (rx767_cur)
  rx767_restart:
.annotate 'line', 10
    if_null rx767_debug, debug_1016
    rx767_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1016:
  rx767_fail:
    (rx767_rep, rx767_pos, $I10, $P10) = rx767_cur."!mark_fail"(0)
    lt rx767_pos, -1, rx767_done
    eq rx767_pos, -1, rx767_fail
    jump $I10
  rx767_done:
    rx767_cur."!cursor_fail"()
    if_null rx767_debug, debug_1017
    rx767_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1017:
    .return (rx767_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("169_1304282286.73") :method
.annotate 'line', 10
    $P769 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P770, "ResizablePMCArray"
    push $P770, $P769
    .return ($P770)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("170_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P773 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P774, "ResizablePMCArray"
    push $P774, $P773
    .return ($P774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("171_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx776_tgt
    .local int rx776_pos
    .local int rx776_off
    .local int rx776_eos
    .local int rx776_rep
    .local pmc rx776_cur
    .local pmc rx776_debug
    (rx776_cur, rx776_pos, rx776_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx776_cur
    .local pmc match
    .lex "$/", match
    length rx776_eos, rx776_tgt
    gt rx776_pos, rx776_eos, rx776_done
    set rx776_off, 0
    lt rx776_pos, 2, rx776_start
    sub rx776_off, rx776_pos, 1
    substr rx776_tgt, rx776_tgt, rx776_off
  rx776_start:
    eq $I10, 1, rx776_restart
    if_null rx776_debug, debug_1018
    rx776_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan780_done
    goto rxscan780_scan
  rxscan780_loop:
    (rx776_pos) = rx776_cur."from"()
    inc rx776_pos
    rx776_cur."!cursor_from"(rx776_pos)
    ge rx776_pos, rx776_eos, rxscan780_done
  rxscan780_scan:
    set_addr $I10, rxscan780_loop
    rx776_cur."!mark_push"(0, rx776_pos, $I10)
  rxscan780_done:
.annotate 'line', 281
  # rx subrule "statement_prefix" subtype=capture negate=
    rx776_cur."!cursor_pos"(rx776_pos)
    $P10 = rx776_cur."statement_prefix"()
    unless $P10, rx776_fail
    rx776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx776_pos = $P10."pos"()
  # rx pass
    rx776_cur."!cursor_pass"(rx776_pos, "term:sym<statement_prefix>")
    if_null rx776_debug, debug_1019
    rx776_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx776_pos)
  debug_1019:
    .return (rx776_cur)
  rx776_restart:
.annotate 'line', 10
    if_null rx776_debug, debug_1020
    rx776_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1020:
  rx776_fail:
    (rx776_rep, rx776_pos, $I10, $P10) = rx776_cur."!mark_fail"(0)
    lt rx776_pos, -1, rx776_done
    eq rx776_pos, -1, rx776_fail
    jump $I10
  rx776_done:
    rx776_cur."!cursor_fail"()
    if_null rx776_debug, debug_1021
    rx776_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1021:
    .return (rx776_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("172_1304282286.73") :method
.annotate 'line', 10
    $P778 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P779, "ResizablePMCArray"
    push $P779, $P778
    .return ($P779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("173_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P782 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P783, "ResizablePMCArray"
    push $P783, $P782
    .return ($P783)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("174_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx785_tgt
    .local int rx785_pos
    .local int rx785_off
    .local int rx785_eos
    .local int rx785_rep
    .local pmc rx785_cur
    .local pmc rx785_debug
    (rx785_cur, rx785_pos, rx785_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx785_cur
    .local pmc match
    .lex "$/", match
    length rx785_eos, rx785_tgt
    gt rx785_pos, rx785_eos, rx785_done
    set rx785_off, 0
    lt rx785_pos, 2, rx785_start
    sub rx785_off, rx785_pos, 1
    substr rx785_tgt, rx785_tgt, rx785_off
  rx785_start:
    eq $I10, 1, rx785_restart
    if_null rx785_debug, debug_1022
    rx785_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1022:
    $I10 = self.'from'()
    ne $I10, -1, rxscan788_done
    goto rxscan788_scan
  rxscan788_loop:
    (rx785_pos) = rx785_cur."from"()
    inc rx785_pos
    rx785_cur."!cursor_from"(rx785_pos)
    ge rx785_pos, rx785_eos, rxscan788_done
  rxscan788_scan:
    set_addr $I10, rxscan788_loop
    rx785_cur."!mark_push"(0, rx785_pos, $I10)
  rxscan788_done:
.annotate 'line', 282
  # rx subrule "lambda" subtype=zerowidth negate=
    rx785_cur."!cursor_pos"(rx785_pos)
    $P10 = rx785_cur."lambda"()
    unless $P10, rx785_fail
  # rx subrule "pblock" subtype=capture negate=
    rx785_cur."!cursor_pos"(rx785_pos)
    $P10 = rx785_cur."pblock"()
    unless $P10, rx785_fail
    rx785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx785_pos = $P10."pos"()
  # rx pass
    rx785_cur."!cursor_pass"(rx785_pos, "term:sym<lambda>")
    if_null rx785_debug, debug_1023
    rx785_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx785_pos)
  debug_1023:
    .return (rx785_cur)
  rx785_restart:
.annotate 'line', 10
    if_null rx785_debug, debug_1024
    rx785_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1024:
  rx785_fail:
    (rx785_rep, rx785_pos, $I10, $P10) = rx785_cur."!mark_fail"(0)
    lt rx785_pos, -1, rx785_done
    eq rx785_pos, -1, rx785_fail
    jump $I10
  rx785_done:
    rx785_cur."!cursor_fail"()
    if_null rx785_debug, debug_1025
    rx785_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1025:
    .return (rx785_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("175_1304282286.73") :method
.annotate 'line', 10
    new $P787, "ResizablePMCArray"
    push $P787, ""
    .return ($P787)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("176_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P790, "ResizablePMCArray"
    push $P790, ""
    .return ($P790)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("177_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx792_tgt
    .local int rx792_pos
    .local int rx792_off
    .local int rx792_eos
    .local int rx792_rep
    .local pmc rx792_cur
    .local pmc rx792_debug
    (rx792_cur, rx792_pos, rx792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx792_cur
    .local pmc match
    .lex "$/", match
    length rx792_eos, rx792_tgt
    gt rx792_pos, rx792_eos, rx792_done
    set rx792_off, 0
    lt rx792_pos, 2, rx792_start
    sub rx792_off, rx792_pos, 1
    substr rx792_tgt, rx792_tgt, rx792_off
  rx792_start:
    eq $I10, 1, rx792_restart
    if_null rx792_debug, debug_1026
    rx792_cur."!cursor_debug"("START", "fatarrow")
  debug_1026:
    $I10 = self.'from'()
    ne $I10, -1, rxscan796_done
    goto rxscan796_scan
  rxscan796_loop:
    (rx792_pos) = rx792_cur."from"()
    inc rx792_pos
    rx792_cur."!cursor_from"(rx792_pos)
    ge rx792_pos, rx792_eos, rxscan796_done
  rxscan796_scan:
    set_addr $I10, rxscan796_loop
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxscan796_done:
.annotate 'line', 285
  # rx subrule "identifier" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."identifier"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx792_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx792_pos, rx792_off
    set rx792_rep, 0
    sub $I12, rx792_eos, rx792_pos
  rxenumcharlistq797_loop:
    le $I12, 0, rxenumcharlistq797_done
    substr $S10, rx792_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq797_done
    inc rx792_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq797_loop
  rxenumcharlistq797_done:
    add rx792_pos, rx792_pos, rx792_rep
  # rx literal  "=>"
    add $I11, rx792_pos, 2
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    substr $S10, rx792_tgt, $I11, 2
    ne $S10, "=>", rx792_fail
    add rx792_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."EXPR"("i=")
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx792_pos = $P10."pos"()
.annotate 'line', 284
  # rx pass
    rx792_cur."!cursor_pass"(rx792_pos, "fatarrow")
    if_null rx792_debug, debug_1027
    rx792_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx792_pos)
  debug_1027:
    .return (rx792_cur)
  rx792_restart:
.annotate 'line', 10
    if_null rx792_debug, debug_1028
    rx792_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1028:
  rx792_fail:
    (rx792_rep, rx792_pos, $I10, $P10) = rx792_cur."!mark_fail"(0)
    lt rx792_pos, -1, rx792_done
    eq rx792_pos, -1, rx792_fail
    jump $I10
  rx792_done:
    rx792_cur."!cursor_fail"()
    if_null rx792_debug, debug_1029
    rx792_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1029:
    .return (rx792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("178_1304282286.73") :method
.annotate 'line', 10
    $P794 = self."!PREFIX__!subrule"("identifier", "")
    new $P795, "ResizablePMCArray"
    push $P795, $P794
    .return ($P795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("179_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P799 = self."!PREFIX__!subrule"("identifier", "")
    new $P800, "ResizablePMCArray"
    push $P800, $P799
    .return ($P800)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("180_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx802_tgt
    .local int rx802_pos
    .local int rx802_off
    .local int rx802_eos
    .local int rx802_rep
    .local pmc rx802_cur
    .local pmc rx802_debug
    (rx802_cur, rx802_pos, rx802_tgt, $I10) = self."!cursor_start"()
    rx802_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx802_cur
    .local pmc match
    .lex "$/", match
    length rx802_eos, rx802_tgt
    gt rx802_pos, rx802_eos, rx802_done
    set rx802_off, 0
    lt rx802_pos, 2, rx802_start
    sub rx802_off, rx802_pos, 1
    substr rx802_tgt, rx802_tgt, rx802_off
  rx802_start:
    eq $I10, 1, rx802_restart
    if_null rx802_debug, debug_1030
    rx802_cur."!cursor_debug"("START", "colonpair")
  debug_1030:
    $I10 = self.'from'()
    ne $I10, -1, rxscan808_done
    goto rxscan808_scan
  rxscan808_loop:
    (rx802_pos) = rx802_cur."from"()
    inc rx802_pos
    rx802_cur."!cursor_from"(rx802_pos)
    ge rx802_pos, rx802_eos, rxscan808_done
  rxscan808_scan:
    set_addr $I10, rxscan808_loop
    rx802_cur."!mark_push"(0, rx802_pos, $I10)
  rxscan808_done:
.annotate 'line', 289
  # rx literal  ":"
    add $I11, rx802_pos, 1
    gt $I11, rx802_eos, rx802_fail
    sub $I11, rx802_pos, rx802_off
    ord $I11, rx802_tgt, $I11
    ne $I11, 58, rx802_fail
    add rx802_pos, 1
  alt809_0:
.annotate 'line', 290
    set_addr $I10, alt809_1
    rx802_cur."!mark_push"(0, rx802_pos, $I10)
.annotate 'line', 291
  # rx subcapture "not"
    set_addr $I10, rxcap_810_fail
    rx802_cur."!mark_push"(0, rx802_pos, $I10)
  # rx literal  "!"
    add $I11, rx802_pos, 1
    gt $I11, rx802_eos, rx802_fail
    sub $I11, rx802_pos, rx802_off
    ord $I11, rx802_tgt, $I11
    ne $I11, 33, rx802_fail
    add rx802_pos, 1
    set_addr $I10, rxcap_810_fail
    ($I12, $I11) = rx802_cur."!mark_peek"($I10)
    rx802_cur."!cursor_pos"($I11)
    ($P10) = rx802_cur."!cursor_start"()
    $P10."!cursor_pass"(rx802_pos, "")
    rx802_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_810_done
  rxcap_810_fail:
    goto rx802_fail
  rxcap_810_done:
  # rx subrule "identifier" subtype=capture negate=
    rx802_cur."!cursor_pos"(rx802_pos)
    $P10 = rx802_cur."identifier"()
    unless $P10, rx802_fail
    rx802_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx802_pos = $P10."pos"()
    goto alt809_end
  alt809_1:
    set_addr $I10, alt809_2
    rx802_cur."!mark_push"(0, rx802_pos, $I10)
.annotate 'line', 292
  # rx subrule "identifier" subtype=capture negate=
    rx802_cur."!cursor_pos"(rx802_pos)
    $P10 = rx802_cur."identifier"()
    unless $P10, rx802_fail
    rx802_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx802_pos = $P10."pos"()
  # rx rxquantr811 ** 0..1
    set_addr $I10, rxquantr811_done
    rx802_cur."!mark_push"(0, rx802_pos, $I10)
  rxquantr811_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx802_cur."!cursor_pos"(rx802_pos)
    $P10 = rx802_cur."circumfix"()
    unless $P10, rx802_fail
    goto rxsubrule812_pass
  rxsubrule812_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx802_fail
  rxsubrule812_pass:
    set_addr $I10, rxsubrule812_back
    rx802_cur."!mark_push"(0, rx802_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx802_pos = $P10."pos"()
    set_addr $I10, rxquantr811_done
    (rx802_rep) = rx802_cur."!mark_commit"($I10)
  rxquantr811_done:
    goto alt809_end
  alt809_2:
.annotate 'line', 293
  # rx subrule "circumfix" subtype=capture negate=
    rx802_cur."!cursor_pos"(rx802_pos)
    $P10 = rx802_cur."circumfix"()
    unless $P10, rx802_fail
    rx802_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx802_pos = $P10."pos"()
  alt809_end:
.annotate 'line', 288
  # rx pass
    rx802_cur."!cursor_pass"(rx802_pos, "colonpair")
    if_null rx802_debug, debug_1031
    rx802_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx802_pos)
  debug_1031:
    .return (rx802_cur)
  rx802_restart:
.annotate 'line', 10
    if_null rx802_debug, debug_1032
    rx802_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1032:
  rx802_fail:
    (rx802_rep, rx802_pos, $I10, $P10) = rx802_cur."!mark_fail"(0)
    lt rx802_pos, -1, rx802_done
    eq rx802_pos, -1, rx802_fail
    jump $I10
  rx802_done:
    rx802_cur."!cursor_fail"()
    if_null rx802_debug, debug_1033
    rx802_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1033:
    .return (rx802_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("181_1304282286.73") :method
.annotate 'line', 10
    $P804 = self."!PREFIX__!subrule"("circumfix", ":")
    $P805 = self."!PREFIX__!subrule"("identifier", ":")
    $P806 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P807, "ResizablePMCArray"
    push $P807, $P804
    push $P807, $P805
    push $P807, $P806
    .return ($P807)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("182_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P814 = self."!PREFIX__!subrule"("circumfix", ":")
    $P815 = self."!PREFIX__!subrule"("identifier", ":")
    $P816 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P817, "ResizablePMCArray"
    push $P817, $P814
    push $P817, $P815
    push $P817, $P816
    .return ($P817)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("183_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx819_tgt
    .local int rx819_pos
    .local int rx819_off
    .local int rx819_eos
    .local int rx819_rep
    .local pmc rx819_cur
    .local pmc rx819_debug
    (rx819_cur, rx819_pos, rx819_tgt, $I10) = self."!cursor_start"()
    rx819_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx819_cur
    .local pmc match
    .lex "$/", match
    length rx819_eos, rx819_tgt
    gt rx819_pos, rx819_eos, rx819_done
    set rx819_off, 0
    lt rx819_pos, 2, rx819_start
    sub rx819_off, rx819_pos, 1
    substr rx819_tgt, rx819_tgt, rx819_off
  rx819_start:
    eq $I10, 1, rx819_restart
    if_null rx819_debug, debug_1034
    rx819_cur."!cursor_debug"("START", "variable")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan824_done
    goto rxscan824_scan
  rxscan824_loop:
    (rx819_pos) = rx819_cur."from"()
    inc rx819_pos
    rx819_cur."!cursor_from"(rx819_pos)
    ge rx819_pos, rx819_eos, rxscan824_done
  rxscan824_scan:
    set_addr $I10, rxscan824_loop
    rx819_cur."!mark_push"(0, rx819_pos, $I10)
  rxscan824_done:
  alt825_0:
.annotate 'line', 297
    set_addr $I10, alt825_1
    rx819_cur."!mark_push"(0, rx819_pos, $I10)
.annotate 'line', 298
  # rx subrule "sigil" subtype=capture negate=
    rx819_cur."!cursor_pos"(rx819_pos)
    $P10 = rx819_cur."sigil"()
    unless $P10, rx819_fail
    rx819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx819_pos = $P10."pos"()
  # rx rxquantr826 ** 0..1
    set_addr $I10, rxquantr826_done
    rx819_cur."!mark_push"(0, rx819_pos, $I10)
  rxquantr826_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx819_cur."!cursor_pos"(rx819_pos)
    $P10 = rx819_cur."twigil"()
    unless $P10, rx819_fail
    goto rxsubrule827_pass
  rxsubrule827_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx819_fail
  rxsubrule827_pass:
    set_addr $I10, rxsubrule827_back
    rx819_cur."!mark_push"(0, rx819_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx819_pos = $P10."pos"()
    set_addr $I10, rxquantr826_done
    (rx819_rep) = rx819_cur."!mark_commit"($I10)
  rxquantr826_done:
  # rx subrule "name" subtype=capture negate=
    rx819_cur."!cursor_pos"(rx819_pos)
    $P10 = rx819_cur."name"()
    unless $P10, rx819_fail
    rx819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx819_pos = $P10."pos"()
    goto alt825_end
  alt825_1:
    set_addr $I10, alt825_2
    rx819_cur."!mark_push"(0, rx819_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx819_cur."!cursor_pos"(rx819_pos)
    $P10 = rx819_cur."sigil"()
    unless $P10, rx819_fail
    rx819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx819_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx819_pos, rx819_off
    substr $S10, rx819_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx819_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx819_cur."!cursor_pos"(rx819_pos)
    $P10 = rx819_cur."postcircumfix"()
    unless $P10, rx819_fail
    rx819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx819_pos = $P10."pos"()
    goto alt825_end
  alt825_2:
.annotate 'line', 300
  # rx subcapture "sigil"
    set_addr $I10, rxcap_828_fail
    rx819_cur."!mark_push"(0, rx819_pos, $I10)
  # rx literal  "$"
    add $I11, rx819_pos, 1
    gt $I11, rx819_eos, rx819_fail
    sub $I11, rx819_pos, rx819_off
    ord $I11, rx819_tgt, $I11
    ne $I11, 36, rx819_fail
    add rx819_pos, 1
    set_addr $I10, rxcap_828_fail
    ($I12, $I11) = rx819_cur."!mark_peek"($I10)
    rx819_cur."!cursor_pos"($I11)
    ($P10) = rx819_cur."!cursor_start"()
    $P10."!cursor_pass"(rx819_pos, "")
    rx819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_828_done
  rxcap_828_fail:
    goto rx819_fail
  rxcap_828_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_829_fail
    rx819_cur."!mark_push"(0, rx819_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx819_pos, rx819_eos, rx819_fail
    sub $I10, rx819_pos, rx819_off
    substr $S10, rx819_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx819_fail
    inc rx819_pos
    set_addr $I10, rxcap_829_fail
    ($I12, $I11) = rx819_cur."!mark_peek"($I10)
    rx819_cur."!cursor_pos"($I11)
    ($P10) = rx819_cur."!cursor_start"()
    $P10."!cursor_pass"(rx819_pos, "")
    rx819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_829_done
  rxcap_829_fail:
    goto rx819_fail
  rxcap_829_done:
  alt825_end:
.annotate 'line', 297
  # rx pass
    rx819_cur."!cursor_pass"(rx819_pos, "variable")
    if_null rx819_debug, debug_1035
    rx819_cur."!cursor_debug"("PASS", "variable", " at pos=", rx819_pos)
  debug_1035:
    .return (rx819_cur)
  rx819_restart:
.annotate 'line', 10
    if_null rx819_debug, debug_1036
    rx819_cur."!cursor_debug"("NEXT", "variable")
  debug_1036:
  rx819_fail:
    (rx819_rep, rx819_pos, $I10, $P10) = rx819_cur."!mark_fail"(0)
    lt rx819_pos, -1, rx819_done
    eq rx819_pos, -1, rx819_fail
    jump $I10
  rx819_done:
    rx819_cur."!cursor_fail"()
    if_null rx819_debug, debug_1037
    rx819_cur."!cursor_debug"("FAIL", "variable")
  debug_1037:
    .return (rx819_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("184_1304282286.73") :method
.annotate 'line', 10
    $P821 = self."!PREFIX__!subrule"("sigil", "")
    $P822 = self."!PREFIX__!subrule"("sigil", "")
    new $P823, "ResizablePMCArray"
    push $P823, "$!"
    push $P823, "$_"
    push $P823, "$/"
    push $P823, $P821
    push $P823, $P822
    .return ($P823)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("185_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P831 = self."!PREFIX__!subrule"("sigil", "")
    $P832 = self."!PREFIX__!subrule"("sigil", "")
    new $P833, "ResizablePMCArray"
    push $P833, "/"
    push $P833, "_"
    push $P833, "!"
    push $P833, $P831
    push $P833, $P832
    .return ($P833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("186_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx835_tgt
    .local int rx835_pos
    .local int rx835_off
    .local int rx835_eos
    .local int rx835_rep
    .local pmc rx835_cur
    .local pmc rx835_debug
    (rx835_cur, rx835_pos, rx835_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx835_cur
    .local pmc match
    .lex "$/", match
    length rx835_eos, rx835_tgt
    gt rx835_pos, rx835_eos, rx835_done
    set rx835_off, 0
    lt rx835_pos, 2, rx835_start
    sub rx835_off, rx835_pos, 1
    substr rx835_tgt, rx835_tgt, rx835_off
  rx835_start:
    eq $I10, 1, rx835_restart
    if_null rx835_debug, debug_1038
    rx835_cur."!cursor_debug"("START", "sigil")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan838_done
    goto rxscan838_scan
  rxscan838_loop:
    (rx835_pos) = rx835_cur."from"()
    inc rx835_pos
    rx835_cur."!cursor_from"(rx835_pos)
    ge rx835_pos, rx835_eos, rxscan838_done
  rxscan838_scan:
    set_addr $I10, rxscan838_loop
    rx835_cur."!mark_push"(0, rx835_pos, $I10)
  rxscan838_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx835_pos, rx835_eos, rx835_fail
    sub $I10, rx835_pos, rx835_off
    substr $S10, rx835_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx835_fail
    inc rx835_pos
  # rx pass
    rx835_cur."!cursor_pass"(rx835_pos, "sigil")
    if_null rx835_debug, debug_1039
    rx835_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx835_pos)
  debug_1039:
    .return (rx835_cur)
  rx835_restart:
.annotate 'line', 10
    if_null rx835_debug, debug_1040
    rx835_cur."!cursor_debug"("NEXT", "sigil")
  debug_1040:
  rx835_fail:
    (rx835_rep, rx835_pos, $I10, $P10) = rx835_cur."!mark_fail"(0)
    lt rx835_pos, -1, rx835_done
    eq rx835_pos, -1, rx835_fail
    jump $I10
  rx835_done:
    rx835_cur."!cursor_fail"()
    if_null rx835_debug, debug_1041
    rx835_cur."!cursor_debug"("FAIL", "sigil")
  debug_1041:
    .return (rx835_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("187_1304282286.73") :method
.annotate 'line', 10
    new $P837, "ResizablePMCArray"
    push $P837, "&"
    push $P837, "%"
    push $P837, "@"
    push $P837, "$"
    .return ($P837)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("188_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P840, "ResizablePMCArray"
    push $P840, "$"
    push $P840, "@"
    push $P840, "%"
    push $P840, "&"
    .return ($P840)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("189_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx842_tgt
    .local int rx842_pos
    .local int rx842_off
    .local int rx842_eos
    .local int rx842_rep
    .local pmc rx842_cur
    .local pmc rx842_debug
    (rx842_cur, rx842_pos, rx842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx842_cur
    .local pmc match
    .lex "$/", match
    length rx842_eos, rx842_tgt
    gt rx842_pos, rx842_eos, rx842_done
    set rx842_off, 0
    lt rx842_pos, 2, rx842_start
    sub rx842_off, rx842_pos, 1
    substr rx842_tgt, rx842_tgt, rx842_off
  rx842_start:
    eq $I10, 1, rx842_restart
    if_null rx842_debug, debug_1042
    rx842_cur."!cursor_debug"("START", "twigil")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan845_done
    goto rxscan845_scan
  rxscan845_loop:
    (rx842_pos) = rx842_cur."from"()
    inc rx842_pos
    rx842_cur."!cursor_from"(rx842_pos)
    ge rx842_pos, rx842_eos, rxscan845_done
  rxscan845_scan:
    set_addr $I10, rxscan845_loop
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  rxscan845_done:
.annotate 'line', 305
  # rx enumcharlist negate=0 
    ge rx842_pos, rx842_eos, rx842_fail
    sub $I10, rx842_pos, rx842_off
    substr $S10, rx842_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx842_fail
    inc rx842_pos
  # rx pass
    rx842_cur."!cursor_pass"(rx842_pos, "twigil")
    if_null rx842_debug, debug_1043
    rx842_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx842_pos)
  debug_1043:
    .return (rx842_cur)
  rx842_restart:
.annotate 'line', 10
    if_null rx842_debug, debug_1044
    rx842_cur."!cursor_debug"("NEXT", "twigil")
  debug_1044:
  rx842_fail:
    (rx842_rep, rx842_pos, $I10, $P10) = rx842_cur."!mark_fail"(0)
    lt rx842_pos, -1, rx842_done
    eq rx842_pos, -1, rx842_fail
    jump $I10
  rx842_done:
    rx842_cur."!cursor_fail"()
    if_null rx842_debug, debug_1045
    rx842_cur."!cursor_debug"("FAIL", "twigil")
  debug_1045:
    .return (rx842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("190_1304282286.73") :method
.annotate 'line', 10
    new $P844, "ResizablePMCArray"
    push $P844, "?"
    push $P844, "!"
    push $P844, "*"
    .return ($P844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("191_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P847, "ResizablePMCArray"
    push $P847, "*"
    push $P847, "!"
    push $P847, "?"
    .return ($P847)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("192_1304282286.73")
    .param pmc param_849
.annotate 'line', 307
    .lex "self", param_849
    $P850 = param_849."!protoregex"("package_declarator")
    .return ($P850)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("193_1304282286.73")
    .param pmc param_852
.annotate 'line', 307
    .lex "self", param_852
    $P853 = param_852."!PREFIX__!protoregex"("package_declarator")
    .return ($P853)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("194_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 309
    new $P855, "Undef"
    .lex "$*OUTERPACKAGE", $P855
.annotate 'line', 310
    new $P856, "Undef"
    .lex "$*PACKAGE-SETUP", $P856
.annotate 'line', 311
    new $P857, "Undef"
    .lex "$*PKGDECL", $P857
.annotate 'line', 10
    .local string rx858_tgt
    .local int rx858_pos
    .local int rx858_off
    .local int rx858_eos
    .local int rx858_rep
    .local pmc rx858_cur
    .local pmc rx858_debug
    (rx858_cur, rx858_pos, rx858_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx858_cur
    .local pmc match
    .lex "$/", match
    length rx858_eos, rx858_tgt
    gt rx858_pos, rx858_eos, rx858_done
    set rx858_off, 0
    lt rx858_pos, 2, rx858_start
    sub rx858_off, rx858_pos, 1
    substr rx858_tgt, rx858_tgt, rx858_off
  rx858_start:
    eq $I10, 1, rx858_restart
    if_null rx858_debug, debug_1046
    rx858_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan862_done
    goto rxscan862_scan
  rxscan862_loop:
    (rx858_pos) = rx858_cur."from"()
    inc rx858_pos
    rx858_cur."!cursor_from"(rx858_pos)
    ge rx858_pos, rx858_eos, rxscan862_done
  rxscan862_scan:
    set_addr $I10, rxscan862_loop
    rx858_cur."!mark_push"(0, rx858_pos, $I10)
  rxscan862_done:
.annotate 'line', 309
    rx858_cur."!cursor_pos"(rx858_pos)
    find_dynamic_lex $P865, "$*PACKAGE"
    unless_null $P865, vivify_1047
    get_hll_global $P863, "GLOBAL"
    get_who $P864, $P863
    set $P865, $P864["$PACKAGE"]
    unless_null $P865, vivify_1048
    die "Contextual $*PACKAGE not found"
  vivify_1048:
  vivify_1047:
    store_lex "$*OUTERPACKAGE", $P865
.annotate 'line', 310
    rx858_cur."!cursor_pos"(rx858_pos)
    get_hll_global $P866, "GLOBAL"
    nqp_get_package_through_who $P867, $P866, "PAST"
    get_who $P868, $P867
    set $P869, $P868["Stmts"]
    $P870 = $P869."new"()
    store_lex "$*PACKAGE-SETUP", $P870
.annotate 'line', 311
    rx858_cur."!cursor_pos"(rx858_pos)
    new $P871, "String"
    assign $P871, "module"
    store_lex "$*PKGDECL", $P871
.annotate 'line', 312
  # rx subcapture "sym"
    set_addr $I10, rxcap_872_fail
    rx858_cur."!mark_push"(0, rx858_pos, $I10)
  # rx literal  "module"
    add $I11, rx858_pos, 6
    gt $I11, rx858_eos, rx858_fail
    sub $I11, rx858_pos, rx858_off
    substr $S10, rx858_tgt, $I11, 6
    ne $S10, "module", rx858_fail
    add rx858_pos, 6
    set_addr $I10, rxcap_872_fail
    ($I12, $I11) = rx858_cur."!mark_peek"($I10)
    rx858_cur."!cursor_pos"($I11)
    ($P10) = rx858_cur."!cursor_start"()
    $P10."!cursor_pass"(rx858_pos, "")
    rx858_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_872_done
  rxcap_872_fail:
    goto rx858_fail
  rxcap_872_done:
  # rx subrule "package_def" subtype=capture negate=
    rx858_cur."!cursor_pos"(rx858_pos)
    $P10 = rx858_cur."package_def"()
    unless $P10, rx858_fail
    rx858_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx858_pos = $P10."pos"()
.annotate 'line', 308
  # rx pass
    rx858_cur."!cursor_pass"(rx858_pos, "package_declarator:sym<module>")
    if_null rx858_debug, debug_1049
    rx858_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx858_pos)
  debug_1049:
    .return (rx858_cur)
  rx858_restart:
.annotate 'line', 10
    if_null rx858_debug, debug_1050
    rx858_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1050:
  rx858_fail:
    (rx858_rep, rx858_pos, $I10, $P10) = rx858_cur."!mark_fail"(0)
    lt rx858_pos, -1, rx858_done
    eq rx858_pos, -1, rx858_fail
    jump $I10
  rx858_done:
    rx858_cur."!cursor_fail"()
    if_null rx858_debug, debug_1051
    rx858_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1051:
    .return (rx858_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("195_1304282286.73") :method
.annotate 'line', 10
    $P860 = self."!PREFIX__!subrule"("package_def", "module")
    new $P861, "ResizablePMCArray"
    push $P861, $P860
    .return ($P861)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("196_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P874 = self."!PREFIX__!subrule"("package_def", "module")
    new $P875, "ResizablePMCArray"
    push $P875, $P874
    .return ($P875)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("197_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 315
    new $P877, "Undef"
    .lex "$*OUTERPACKAGE", $P877
.annotate 'line', 316
    new $P878, "Undef"
    .lex "$*PACKAGE-SETUP", $P878
.annotate 'line', 317
    new $P879, "Undef"
    .lex "$*PKGDECL", $P879
.annotate 'line', 10
    .local string rx880_tgt
    .local int rx880_pos
    .local int rx880_off
    .local int rx880_eos
    .local int rx880_rep
    .local pmc rx880_cur
    .local pmc rx880_debug
    (rx880_cur, rx880_pos, rx880_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx880_cur
    .local pmc match
    .lex "$/", match
    length rx880_eos, rx880_tgt
    gt rx880_pos, rx880_eos, rx880_done
    set rx880_off, 0
    lt rx880_pos, 2, rx880_start
    sub rx880_off, rx880_pos, 1
    substr rx880_tgt, rx880_tgt, rx880_off
  rx880_start:
    eq $I10, 1, rx880_restart
    if_null rx880_debug, debug_1052
    rx880_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1052:
    $I10 = self.'from'()
    ne $I10, -1, rxscan884_done
    goto rxscan884_scan
  rxscan884_loop:
    (rx880_pos) = rx880_cur."from"()
    inc rx880_pos
    rx880_cur."!cursor_from"(rx880_pos)
    ge rx880_pos, rx880_eos, rxscan884_done
  rxscan884_scan:
    set_addr $I10, rxscan884_loop
    rx880_cur."!mark_push"(0, rx880_pos, $I10)
  rxscan884_done:
.annotate 'line', 315
    rx880_cur."!cursor_pos"(rx880_pos)
    find_dynamic_lex $P887, "$*PACKAGE"
    unless_null $P887, vivify_1053
    get_hll_global $P885, "GLOBAL"
    get_who $P886, $P885
    set $P887, $P886["$PACKAGE"]
    unless_null $P887, vivify_1054
    die "Contextual $*PACKAGE not found"
  vivify_1054:
  vivify_1053:
    store_lex "$*OUTERPACKAGE", $P887
.annotate 'line', 316
    rx880_cur."!cursor_pos"(rx880_pos)
    get_hll_global $P888, "GLOBAL"
    nqp_get_package_through_who $P889, $P888, "PAST"
    get_who $P890, $P889
    set $P891, $P890["Stmts"]
    $P892 = $P891."new"()
    store_lex "$*PACKAGE-SETUP", $P892
.annotate 'line', 317
    rx880_cur."!cursor_pos"(rx880_pos)
    new $P893, "String"
    assign $P893, "knowhow"
    store_lex "$*PKGDECL", $P893
.annotate 'line', 318
  # rx subcapture "sym"
    set_addr $I10, rxcap_894_fail
    rx880_cur."!mark_push"(0, rx880_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx880_pos, 7
    gt $I11, rx880_eos, rx880_fail
    sub $I11, rx880_pos, rx880_off
    substr $S10, rx880_tgt, $I11, 7
    ne $S10, "knowhow", rx880_fail
    add rx880_pos, 7
    set_addr $I10, rxcap_894_fail
    ($I12, $I11) = rx880_cur."!mark_peek"($I10)
    rx880_cur."!cursor_pos"($I11)
    ($P10) = rx880_cur."!cursor_start"()
    $P10."!cursor_pass"(rx880_pos, "")
    rx880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_894_done
  rxcap_894_fail:
    goto rx880_fail
  rxcap_894_done:
  # rx subrule "package_def" subtype=capture negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."package_def"()
    unless $P10, rx880_fail
    rx880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx880_pos = $P10."pos"()
.annotate 'line', 314
  # rx pass
    rx880_cur."!cursor_pass"(rx880_pos, "package_declarator:sym<knowhow>")
    if_null rx880_debug, debug_1055
    rx880_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx880_pos)
  debug_1055:
    .return (rx880_cur)
  rx880_restart:
.annotate 'line', 10
    if_null rx880_debug, debug_1056
    rx880_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1056:
  rx880_fail:
    (rx880_rep, rx880_pos, $I10, $P10) = rx880_cur."!mark_fail"(0)
    lt rx880_pos, -1, rx880_done
    eq rx880_pos, -1, rx880_fail
    jump $I10
  rx880_done:
    rx880_cur."!cursor_fail"()
    if_null rx880_debug, debug_1057
    rx880_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1057:
    .return (rx880_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("198_1304282286.73") :method
.annotate 'line', 10
    $P882 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P883, "ResizablePMCArray"
    push $P883, $P882
    .return ($P883)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("199_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P896 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P897, "ResizablePMCArray"
    push $P897, $P896
    .return ($P897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("200_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 321
    new $P899, "Undef"
    .lex "$*OUTERPACKAGE", $P899
.annotate 'line', 322
    new $P900, "Undef"
    .lex "$*PACKAGE-SETUP", $P900
.annotate 'line', 323
    new $P901, "Undef"
    .lex "$*PKGDECL", $P901
.annotate 'line', 10
    .local string rx902_tgt
    .local int rx902_pos
    .local int rx902_off
    .local int rx902_eos
    .local int rx902_rep
    .local pmc rx902_cur
    .local pmc rx902_debug
    (rx902_cur, rx902_pos, rx902_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx902_cur
    .local pmc match
    .lex "$/", match
    length rx902_eos, rx902_tgt
    gt rx902_pos, rx902_eos, rx902_done
    set rx902_off, 0
    lt rx902_pos, 2, rx902_start
    sub rx902_off, rx902_pos, 1
    substr rx902_tgt, rx902_tgt, rx902_off
  rx902_start:
    eq $I10, 1, rx902_restart
    if_null rx902_debug, debug_1058
    rx902_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan906_done
    goto rxscan906_scan
  rxscan906_loop:
    (rx902_pos) = rx902_cur."from"()
    inc rx902_pos
    rx902_cur."!cursor_from"(rx902_pos)
    ge rx902_pos, rx902_eos, rxscan906_done
  rxscan906_scan:
    set_addr $I10, rxscan906_loop
    rx902_cur."!mark_push"(0, rx902_pos, $I10)
  rxscan906_done:
.annotate 'line', 321
    rx902_cur."!cursor_pos"(rx902_pos)
    find_dynamic_lex $P909, "$*PACKAGE"
    unless_null $P909, vivify_1059
    get_hll_global $P907, "GLOBAL"
    get_who $P908, $P907
    set $P909, $P908["$PACKAGE"]
    unless_null $P909, vivify_1060
    die "Contextual $*PACKAGE not found"
  vivify_1060:
  vivify_1059:
    store_lex "$*OUTERPACKAGE", $P909
.annotate 'line', 322
    rx902_cur."!cursor_pos"(rx902_pos)
    get_hll_global $P910, "GLOBAL"
    nqp_get_package_through_who $P911, $P910, "PAST"
    get_who $P912, $P911
    set $P913, $P912["Stmts"]
    $P914 = $P913."new"()
    store_lex "$*PACKAGE-SETUP", $P914
.annotate 'line', 323
    rx902_cur."!cursor_pos"(rx902_pos)
    new $P915, "String"
    assign $P915, "class"
    store_lex "$*PKGDECL", $P915
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_916_fail
    rx902_cur."!mark_push"(0, rx902_pos, $I10)
  # rx literal  "class"
    add $I11, rx902_pos, 5
    gt $I11, rx902_eos, rx902_fail
    sub $I11, rx902_pos, rx902_off
    substr $S10, rx902_tgt, $I11, 5
    ne $S10, "class", rx902_fail
    add rx902_pos, 5
    set_addr $I10, rxcap_916_fail
    ($I12, $I11) = rx902_cur."!mark_peek"($I10)
    rx902_cur."!cursor_pos"($I11)
    ($P10) = rx902_cur."!cursor_start"()
    $P10."!cursor_pass"(rx902_pos, "")
    rx902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_916_done
  rxcap_916_fail:
    goto rx902_fail
  rxcap_916_done:
  # rx subrule "package_def" subtype=capture negate=
    rx902_cur."!cursor_pos"(rx902_pos)
    $P10 = rx902_cur."package_def"()
    unless $P10, rx902_fail
    rx902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx902_pos = $P10."pos"()
.annotate 'line', 320
  # rx pass
    rx902_cur."!cursor_pass"(rx902_pos, "package_declarator:sym<class>")
    if_null rx902_debug, debug_1061
    rx902_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx902_pos)
  debug_1061:
    .return (rx902_cur)
  rx902_restart:
.annotate 'line', 10
    if_null rx902_debug, debug_1062
    rx902_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1062:
  rx902_fail:
    (rx902_rep, rx902_pos, $I10, $P10) = rx902_cur."!mark_fail"(0)
    lt rx902_pos, -1, rx902_done
    eq rx902_pos, -1, rx902_fail
    jump $I10
  rx902_done:
    rx902_cur."!cursor_fail"()
    if_null rx902_debug, debug_1063
    rx902_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1063:
    .return (rx902_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("201_1304282286.73") :method
.annotate 'line', 10
    $P904 = self."!PREFIX__!subrule"("package_def", "class")
    new $P905, "ResizablePMCArray"
    push $P905, $P904
    .return ($P905)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("202_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P918 = self."!PREFIX__!subrule"("package_def", "class")
    new $P919, "ResizablePMCArray"
    push $P919, $P918
    .return ($P919)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("203_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 327
    new $P921, "Undef"
    .lex "$*OUTERPACKAGE", $P921
.annotate 'line', 328
    new $P922, "Undef"
    .lex "$*PACKAGE-SETUP", $P922
.annotate 'line', 329
    new $P923, "Undef"
    .lex "$*PKGDECL", $P923
.annotate 'line', 10
    .local string rx924_tgt
    .local int rx924_pos
    .local int rx924_off
    .local int rx924_eos
    .local int rx924_rep
    .local pmc rx924_cur
    .local pmc rx924_debug
    (rx924_cur, rx924_pos, rx924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx924_cur
    .local pmc match
    .lex "$/", match
    length rx924_eos, rx924_tgt
    gt rx924_pos, rx924_eos, rx924_done
    set rx924_off, 0
    lt rx924_pos, 2, rx924_start
    sub rx924_off, rx924_pos, 1
    substr rx924_tgt, rx924_tgt, rx924_off
  rx924_start:
    eq $I10, 1, rx924_restart
    if_null rx924_debug, debug_1064
    rx924_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1064:
    $I10 = self.'from'()
    ne $I10, -1, rxscan928_done
    goto rxscan928_scan
  rxscan928_loop:
    (rx924_pos) = rx924_cur."from"()
    inc rx924_pos
    rx924_cur."!cursor_from"(rx924_pos)
    ge rx924_pos, rx924_eos, rxscan928_done
  rxscan928_scan:
    set_addr $I10, rxscan928_loop
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  rxscan928_done:
.annotate 'line', 327
    rx924_cur."!cursor_pos"(rx924_pos)
    find_dynamic_lex $P931, "$*PACKAGE"
    unless_null $P931, vivify_1065
    get_hll_global $P929, "GLOBAL"
    get_who $P930, $P929
    set $P931, $P930["$PACKAGE"]
    unless_null $P931, vivify_1066
    die "Contextual $*PACKAGE not found"
  vivify_1066:
  vivify_1065:
    store_lex "$*OUTERPACKAGE", $P931
.annotate 'line', 328
    rx924_cur."!cursor_pos"(rx924_pos)
    get_hll_global $P932, "GLOBAL"
    nqp_get_package_through_who $P933, $P932, "PAST"
    get_who $P934, $P933
    set $P935, $P934["Stmts"]
    $P936 = $P935."new"()
    store_lex "$*PACKAGE-SETUP", $P936
.annotate 'line', 329
    rx924_cur."!cursor_pos"(rx924_pos)
    new $P937, "String"
    assign $P937, "grammar"
    store_lex "$*PKGDECL", $P937
.annotate 'line', 330
  # rx subcapture "sym"
    set_addr $I10, rxcap_938_fail
    rx924_cur."!mark_push"(0, rx924_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx924_pos, 7
    gt $I11, rx924_eos, rx924_fail
    sub $I11, rx924_pos, rx924_off
    substr $S10, rx924_tgt, $I11, 7
    ne $S10, "grammar", rx924_fail
    add rx924_pos, 7
    set_addr $I10, rxcap_938_fail
    ($I12, $I11) = rx924_cur."!mark_peek"($I10)
    rx924_cur."!cursor_pos"($I11)
    ($P10) = rx924_cur."!cursor_start"()
    $P10."!cursor_pass"(rx924_pos, "")
    rx924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_938_done
  rxcap_938_fail:
    goto rx924_fail
  rxcap_938_done:
  # rx subrule "package_def" subtype=capture negate=
    rx924_cur."!cursor_pos"(rx924_pos)
    $P10 = rx924_cur."package_def"()
    unless $P10, rx924_fail
    rx924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx924_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx924_cur."!cursor_pass"(rx924_pos, "package_declarator:sym<grammar>")
    if_null rx924_debug, debug_1067
    rx924_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx924_pos)
  debug_1067:
    .return (rx924_cur)
  rx924_restart:
.annotate 'line', 10
    if_null rx924_debug, debug_1068
    rx924_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1068:
  rx924_fail:
    (rx924_rep, rx924_pos, $I10, $P10) = rx924_cur."!mark_fail"(0)
    lt rx924_pos, -1, rx924_done
    eq rx924_pos, -1, rx924_fail
    jump $I10
  rx924_done:
    rx924_cur."!cursor_fail"()
    if_null rx924_debug, debug_1069
    rx924_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1069:
    .return (rx924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("204_1304282286.73") :method
.annotate 'line', 10
    $P926 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P927, "ResizablePMCArray"
    push $P927, $P926
    .return ($P927)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("205_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P940 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P941, "ResizablePMCArray"
    push $P941, $P940
    .return ($P941)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("206_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 333
    new $P943, "Undef"
    .lex "$*OUTERPACKAGE", $P943
.annotate 'line', 334
    new $P944, "Undef"
    .lex "$*PACKAGE-SETUP", $P944
.annotate 'line', 335
    new $P945, "Undef"
    .lex "$*PKGDECL", $P945
.annotate 'line', 10
    .local string rx946_tgt
    .local int rx946_pos
    .local int rx946_off
    .local int rx946_eos
    .local int rx946_rep
    .local pmc rx946_cur
    .local pmc rx946_debug
    (rx946_cur, rx946_pos, rx946_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx946_cur
    .local pmc match
    .lex "$/", match
    length rx946_eos, rx946_tgt
    gt rx946_pos, rx946_eos, rx946_done
    set rx946_off, 0
    lt rx946_pos, 2, rx946_start
    sub rx946_off, rx946_pos, 1
    substr rx946_tgt, rx946_tgt, rx946_off
  rx946_start:
    eq $I10, 1, rx946_restart
    if_null rx946_debug, debug_1070
    rx946_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan950_done
    goto rxscan950_scan
  rxscan950_loop:
    (rx946_pos) = rx946_cur."from"()
    inc rx946_pos
    rx946_cur."!cursor_from"(rx946_pos)
    ge rx946_pos, rx946_eos, rxscan950_done
  rxscan950_scan:
    set_addr $I10, rxscan950_loop
    rx946_cur."!mark_push"(0, rx946_pos, $I10)
  rxscan950_done:
.annotate 'line', 333
    rx946_cur."!cursor_pos"(rx946_pos)
    find_dynamic_lex $P953, "$*PACKAGE"
    unless_null $P953, vivify_1071
    get_hll_global $P951, "GLOBAL"
    get_who $P952, $P951
    set $P953, $P952["$PACKAGE"]
    unless_null $P953, vivify_1072
    die "Contextual $*PACKAGE not found"
  vivify_1072:
  vivify_1071:
    store_lex "$*OUTERPACKAGE", $P953
.annotate 'line', 334
    rx946_cur."!cursor_pos"(rx946_pos)
    get_hll_global $P954, "GLOBAL"
    nqp_get_package_through_who $P955, $P954, "PAST"
    get_who $P956, $P955
    set $P957, $P956["Stmts"]
    $P958 = $P957."new"()
    store_lex "$*PACKAGE-SETUP", $P958
.annotate 'line', 335
    rx946_cur."!cursor_pos"(rx946_pos)
    new $P959, "String"
    assign $P959, "role"
    store_lex "$*PKGDECL", $P959
.annotate 'line', 336
  # rx subcapture "sym"
    set_addr $I10, rxcap_960_fail
    rx946_cur."!mark_push"(0, rx946_pos, $I10)
  # rx literal  "role"
    add $I11, rx946_pos, 4
    gt $I11, rx946_eos, rx946_fail
    sub $I11, rx946_pos, rx946_off
    substr $S10, rx946_tgt, $I11, 4
    ne $S10, "role", rx946_fail
    add rx946_pos, 4
    set_addr $I10, rxcap_960_fail
    ($I12, $I11) = rx946_cur."!mark_peek"($I10)
    rx946_cur."!cursor_pos"($I11)
    ($P10) = rx946_cur."!cursor_start"()
    $P10."!cursor_pass"(rx946_pos, "")
    rx946_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_960_done
  rxcap_960_fail:
    goto rx946_fail
  rxcap_960_done:
  # rx subrule "package_def" subtype=capture negate=
    rx946_cur."!cursor_pos"(rx946_pos)
    $P10 = rx946_cur."package_def"()
    unless $P10, rx946_fail
    rx946_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx946_pos = $P10."pos"()
.annotate 'line', 332
  # rx pass
    rx946_cur."!cursor_pass"(rx946_pos, "package_declarator:sym<role>")
    if_null rx946_debug, debug_1073
    rx946_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx946_pos)
  debug_1073:
    .return (rx946_cur)
  rx946_restart:
.annotate 'line', 10
    if_null rx946_debug, debug_1074
    rx946_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1074:
  rx946_fail:
    (rx946_rep, rx946_pos, $I10, $P10) = rx946_cur."!mark_fail"(0)
    lt rx946_pos, -1, rx946_done
    eq rx946_pos, -1, rx946_fail
    jump $I10
  rx946_done:
    rx946_cur."!cursor_fail"()
    if_null rx946_debug, debug_1075
    rx946_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1075:
    .return (rx946_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("207_1304282286.73") :method
.annotate 'line', 10
    $P948 = self."!PREFIX__!subrule"("package_def", "role")
    new $P949, "ResizablePMCArray"
    push $P949, $P948
    .return ($P949)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("208_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P962 = self."!PREFIX__!subrule"("package_def", "role")
    new $P963, "ResizablePMCArray"
    push $P963, $P962
    .return ($P963)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("209_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 339
    new $P965, "Undef"
    .lex "$*OUTERPACKAGE", $P965
.annotate 'line', 340
    new $P966, "Undef"
    .lex "$*PACKAGE-SETUP", $P966
.annotate 'line', 341
    new $P967, "Undef"
    .lex "$*PKGDECL", $P967
.annotate 'line', 10
    .local string rx968_tgt
    .local int rx968_pos
    .local int rx968_off
    .local int rx968_eos
    .local int rx968_rep
    .local pmc rx968_cur
    .local pmc rx968_debug
    (rx968_cur, rx968_pos, rx968_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx968_cur
    .local pmc match
    .lex "$/", match
    length rx968_eos, rx968_tgt
    gt rx968_pos, rx968_eos, rx968_done
    set rx968_off, 0
    lt rx968_pos, 2, rx968_start
    sub rx968_off, rx968_pos, 1
    substr rx968_tgt, rx968_tgt, rx968_off
  rx968_start:
    eq $I10, 1, rx968_restart
    if_null rx968_debug, debug_1076
    rx968_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan972_done
    goto rxscan972_scan
  rxscan972_loop:
    (rx968_pos) = rx968_cur."from"()
    inc rx968_pos
    rx968_cur."!cursor_from"(rx968_pos)
    ge rx968_pos, rx968_eos, rxscan972_done
  rxscan972_scan:
    set_addr $I10, rxscan972_loop
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  rxscan972_done:
.annotate 'line', 339
    rx968_cur."!cursor_pos"(rx968_pos)
    find_dynamic_lex $P975, "$*PACKAGE"
    unless_null $P975, vivify_1077
    get_hll_global $P973, "GLOBAL"
    get_who $P974, $P973
    set $P975, $P974["$PACKAGE"]
    unless_null $P975, vivify_1078
    die "Contextual $*PACKAGE not found"
  vivify_1078:
  vivify_1077:
    store_lex "$*OUTERPACKAGE", $P975
.annotate 'line', 340
    rx968_cur."!cursor_pos"(rx968_pos)
    get_hll_global $P976, "GLOBAL"
    nqp_get_package_through_who $P977, $P976, "PAST"
    get_who $P978, $P977
    set $P979, $P978["Stmts"]
    $P980 = $P979."new"()
    store_lex "$*PACKAGE-SETUP", $P980
.annotate 'line', 341
    rx968_cur."!cursor_pos"(rx968_pos)
    new $P981, "String"
    assign $P981, "native"
    store_lex "$*PKGDECL", $P981
.annotate 'line', 342
  # rx subcapture "sym"
    set_addr $I10, rxcap_982_fail
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "native"
    add $I11, rx968_pos, 6
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 6
    ne $S10, "native", rx968_fail
    add rx968_pos, 6
    set_addr $I10, rxcap_982_fail
    ($I12, $I11) = rx968_cur."!mark_peek"($I10)
    rx968_cur."!cursor_pos"($I11)
    ($P10) = rx968_cur."!cursor_start"()
    $P10."!cursor_pass"(rx968_pos, "")
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_982_done
  rxcap_982_fail:
    goto rx968_fail
  rxcap_982_done:
  # rx subrule "package_def" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."package_def"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx968_pos = $P10."pos"()
.annotate 'line', 338
  # rx pass
    rx968_cur."!cursor_pass"(rx968_pos, "package_declarator:sym<native>")
    if_null rx968_debug, debug_1079
    rx968_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx968_pos)
  debug_1079:
    .return (rx968_cur)
  rx968_restart:
.annotate 'line', 10
    if_null rx968_debug, debug_1080
    rx968_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1080:
  rx968_fail:
    (rx968_rep, rx968_pos, $I10, $P10) = rx968_cur."!mark_fail"(0)
    lt rx968_pos, -1, rx968_done
    eq rx968_pos, -1, rx968_fail
    jump $I10
  rx968_done:
    rx968_cur."!cursor_fail"()
    if_null rx968_debug, debug_1081
    rx968_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1081:
    .return (rx968_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("210_1304282286.73") :method
.annotate 'line', 10
    $P970 = self."!PREFIX__!subrule"("package_def", "native")
    new $P971, "ResizablePMCArray"
    push $P971, $P970
    .return ($P971)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("211_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P984 = self."!PREFIX__!subrule"("package_def", "native")
    new $P985, "ResizablePMCArray"
    push $P985, $P984
    .return ($P985)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("212_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1014 = "214_1304282286.73" 
    capture_lex $P1014
.annotate 'line', 346
    new $P987, "Undef"
    .lex "$*PACKAGE", $P987
.annotate 'line', 347
    $P988 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P988
.annotate 'line', 10
    .local string rx989_tgt
    .local int rx989_pos
    .local int rx989_off
    .local int rx989_eos
    .local int rx989_rep
    .local pmc rx989_cur
    .local pmc rx989_debug
    (rx989_cur, rx989_pos, rx989_tgt, $I10) = self."!cursor_start"()
    rx989_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx989_cur
    .local pmc match
    .lex "$/", match
    length rx989_eos, rx989_tgt
    gt rx989_pos, rx989_eos, rx989_done
    set rx989_off, 0
    lt rx989_pos, 2, rx989_start
    sub rx989_off, rx989_pos, 1
    substr rx989_tgt, rx989_tgt, rx989_off
  rx989_start:
    eq $I10, 1, rx989_restart
    if_null rx989_debug, debug_1082
    rx989_cur."!cursor_debug"("START", "package_def")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan993_done
    goto rxscan993_scan
  rxscan993_loop:
    (rx989_pos) = rx989_cur."from"()
    inc rx989_pos
    rx989_cur."!cursor_from"(rx989_pos)
    ge rx989_pos, rx989_eos, rxscan993_done
  rxscan993_scan:
    set_addr $I10, rxscan993_loop
    rx989_cur."!mark_push"(0, rx989_pos, $I10)
  rxscan993_done:
.annotate 'line', 345
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 346
    rx989_cur."!cursor_pos"(rx989_pos)
    find_lex $P997, "$*PACKAGE"
    unless_null $P997, vivify_1083
    get_hll_global $P995, "GLOBAL"
    get_who $P996, $P995
    set $P997, $P996["$PACKAGE"]
    unless_null $P997, vivify_1084
    die "Contextual $*PACKAGE not found"
  vivify_1084:
  vivify_1083:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 347
    rx989_cur."!cursor_pos"(rx989_pos)
    find_lex $P1001, "%*ATTR-CHECK"
    unless_null $P1001, vivify_1085
    get_hll_global $P999, "GLOBAL"
    get_who $P1000, $P999
    set $P1001, $P1000["%ATTR-CHECK"]
    unless_null $P1001, vivify_1086
    die "Contextual %*ATTR-CHECK not found"
  vivify_1086:
  vivify_1085:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 349
  # rx subrule "name" subtype=capture negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."name"()
    unless $P10, rx989_fail
    rx989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 350
  # rx rxquantr1004 ** 0..1
    set_addr $I10, rxquantr1004_done
    rx989_cur."!mark_push"(0, rx989_pos, $I10)
  rxquantr1004_loop:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx989_pos, 2
    gt $I11, rx989_eos, rx989_fail
    sub $I11, rx989_pos, rx989_off
    substr $S10, rx989_tgt, $I11, 2
    ne $S10, "is", rx989_fail
    add rx989_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx989_pos, 5
    gt $I11, rx989_eos, rx989_fail
    sub $I11, rx989_pos, rx989_off
    substr $S10, rx989_tgt, $I11, 5
    ne $S10, "repr(", rx989_fail
    add rx989_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."quote_EXPR"()
    unless $P10, rx989_fail
    rx989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx989_pos, 1
    gt $I11, rx989_eos, rx989_fail
    sub $I11, rx989_pos, rx989_off
    ord $I11, rx989_tgt, $I11
    ne $I11, 41, rx989_fail
    add rx989_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
    set_addr $I10, rxquantr1004_done
    (rx989_rep) = rx989_cur."!mark_commit"($I10)
  rxquantr1004_done:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 352
    rx989_cur."!cursor_pos"(rx989_pos)
    find_lex $P1011, unicode:"$\x{a2}"
    $P1012 = $P1011."MATCH"()
    store_lex "$/", $P1012
    .const 'Sub' $P1014 = "214_1304282286.73" 
    capture_lex $P1014
    $P1136 = $P1014()
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 380
  # rx rxquantr1138 ** 0..1
    set_addr $I10, rxquantr1138_done
    rx989_cur."!mark_push"(0, rx989_pos, $I10)
  rxquantr1138_loop:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx989_pos, 2
    gt $I11, rx989_eos, rx989_fail
    sub $I11, rx989_pos, rx989_off
    substr $S10, rx989_tgt, $I11, 2
    ne $S10, "is", rx989_fail
    add rx989_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."name"()
    unless $P10, rx989_fail
    rx989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
    set_addr $I10, rxquantr1138_done
    (rx989_rep) = rx989_cur."!mark_commit"($I10)
  rxquantr1138_done:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 381
  # rx rxquantr1143 ** 0..*
    set_addr $I10, rxquantr1143_done
    rx989_cur."!mark_push"(0, rx989_pos, $I10)
  rxquantr1143_loop:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx989_pos, 4
    gt $I11, rx989_eos, rx989_fail
    sub $I11, rx989_pos, rx989_off
    substr $S10, rx989_tgt, $I11, 4
    ne $S10, "does", rx989_fail
    add rx989_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."name"()
    unless $P10, rx989_fail
    rx989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
    set_addr $I10, rxquantr1143_done
    (rx989_rep) = rx989_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1143_done
    rx989_cur."!mark_push"(rx989_rep, rx989_pos, $I10)
    goto rxquantr1143_loop
  rxquantr1143_done:
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  alt1148_0:
.annotate 'line', 382
    set_addr $I10, alt1148_1
    rx989_cur."!mark_push"(0, rx989_pos, $I10)
.annotate 'line', 383
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx989_pos, 1
    gt $I11, rx989_eos, rx989_fail
    sub $I11, rx989_pos, rx989_off
    ord $I11, rx989_tgt, $I11
    ne $I11, 59, rx989_fail
    add rx989_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."comp_unit"()
    unless $P10, rx989_fail
    rx989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
    goto alt1148_end
  alt1148_1:
    set_addr $I10, alt1148_2
    rx989_cur."!mark_push"(0, rx989_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx989_pos, rx989_off
    substr $S10, rx989_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx989_fail
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."block"()
    unless $P10, rx989_fail
    rx989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
    goto alt1148_end
  alt1148_2:
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."panic"("Malformed package declaration")
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
  alt1148_end:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx989_cur."!cursor_pos"(rx989_pos)
    $P10 = rx989_cur."ws"()
    unless $P10, rx989_fail
    rx989_pos = $P10."pos"()
.annotate 'line', 345
  # rx pass
    rx989_cur."!cursor_pass"(rx989_pos, "package_def")
    if_null rx989_debug, debug_1154
    rx989_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx989_pos)
  debug_1154:
    .return (rx989_cur)
  rx989_restart:
.annotate 'line', 10
    if_null rx989_debug, debug_1155
    rx989_cur."!cursor_debug"("NEXT", "package_def")
  debug_1155:
  rx989_fail:
    (rx989_rep, rx989_pos, $I10, $P10) = rx989_cur."!mark_fail"(0)
    lt rx989_pos, -1, rx989_done
    eq rx989_pos, -1, rx989_fail
    jump $I10
  rx989_done:
    rx989_cur."!cursor_fail"()
    if_null rx989_debug, debug_1156
    rx989_cur."!cursor_debug"("FAIL", "package_def")
  debug_1156:
    .return (rx989_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("213_1304282286.73") :method
.annotate 'line', 10
    $P991 = self."!PREFIX__!subrule"("ws", "")
    new $P992, "ResizablePMCArray"
    push $P992, $P991
    .return ($P992)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1013"  :anon :subid("214_1304282286.73") :outer("212_1304282286.73")
.annotate 'line', 355
    $P1015 = root_new ['parrot';'Hash']
    .lex "%args", $P1015
.annotate 'line', 352
    find_lex $P1016, "%args"
    unless_null $P1016, vivify_1087
    $P1016 = root_new ['parrot';'Hash']
  vivify_1087:
.annotate 'line', 356
    find_lex $P1017, "$/"
    unless_null $P1017, vivify_1088
    $P1017 = root_new ['parrot';'Hash']
  vivify_1088:
    set $P1018, $P1017["name"]
    unless_null $P1018, vivify_1089
    new $P1018, "Undef"
  vivify_1089:
    set $S1019, $P1018
    new $P1020, 'String'
    set $P1020, $S1019
    find_lex $P1021, "%args"
    unless_null $P1021, vivify_1090
    $P1021 = root_new ['parrot';'Hash']
    store_lex "%args", $P1021
  vivify_1090:
    set $P1021["name"], $P1020
.annotate 'line', 357
    find_lex $P1023, "$/"
    unless_null $P1023, vivify_1091
    $P1023 = root_new ['parrot';'Hash']
  vivify_1091:
    set $P1024, $P1023["repr"]
    unless_null $P1024, vivify_1092
    new $P1024, "Undef"
  vivify_1092:
    unless $P1024, if_1022_end
.annotate 'line', 358
    find_lex $P1025, "$/"
    unless_null $P1025, vivify_1093
    $P1025 = root_new ['parrot';'Hash']
  vivify_1093:
    set $P1026, $P1025["repr"]
    unless_null $P1026, vivify_1094
    $P1026 = root_new ['parrot';'ResizablePMCArray']
  vivify_1094:
    set $P1027, $P1026[0]
    unless_null $P1027, vivify_1095
    $P1027 = root_new ['parrot';'Hash']
  vivify_1095:
    set $P1028, $P1027["quote_delimited"]
    unless_null $P1028, vivify_1096
    $P1028 = root_new ['parrot';'Hash']
  vivify_1096:
    set $P1029, $P1028["quote_atom"]
    unless_null $P1029, vivify_1097
    $P1029 = root_new ['parrot';'ResizablePMCArray']
  vivify_1097:
    set $P1030, $P1029[0]
    unless_null $P1030, vivify_1098
    new $P1030, "Undef"
  vivify_1098:
    set $S1031, $P1030
    new $P1032, 'String'
    set $P1032, $S1031
    find_lex $P1033, "%args"
    unless_null $P1033, vivify_1099
    $P1033 = root_new ['parrot';'Hash']
    store_lex "%args", $P1033
  vivify_1099:
    set $P1033["repr"], $P1032
  if_1022_end:
.annotate 'line', 360
    find_dynamic_lex $P1036, "$*SC"
    unless_null $P1036, vivify_1100
    get_hll_global $P1034, "GLOBAL"
    get_who $P1035, $P1034
    set $P1036, $P1035["$SC"]
    unless_null $P1036, vivify_1101
    die "Contextual $*SC not found"
  vivify_1101:
  vivify_1100:
    find_dynamic_lex $P1039, "$*PKGDECL"
    unless_null $P1039, vivify_1102
    get_hll_global $P1037, "GLOBAL"
    get_who $P1038, $P1037
    set $P1039, $P1038["$PKGDECL"]
    unless_null $P1039, vivify_1103
    die "Contextual $*PKGDECL not found"
  vivify_1103:
  vivify_1102:
    find_dynamic_lex $P1042, "%*HOW"
    unless_null $P1042, vivify_1104
    get_hll_global $P1040, "GLOBAL"
    get_who $P1041, $P1040
    set $P1042, $P1041["%HOW"]
    unless_null $P1042, vivify_1105
    die "Contextual %*HOW not found"
  vivify_1105:
  vivify_1104:
    set $P1043, $P1042[$P1039]
    unless_null $P1043, vivify_1106
    new $P1043, "Undef"
  vivify_1106:
    find_lex $P1044, "%args"
    unless_null $P1044, vivify_1107
    $P1044 = root_new ['parrot';'Hash']
  vivify_1107:
    $P1045 = $P1036."pkg_create_mo"($P1043, $P1044 :flat)
    store_dynamic_lex "$*PACKAGE", $P1045
.annotate 'line', 363
    find_dynamic_lex $P1052, "$*SCOPE"
    unless_null $P1052, vivify_1108
    get_hll_global $P1050, "GLOBAL"
    get_who $P1051, $P1050
    set $P1052, $P1051["$SCOPE"]
    unless_null $P1052, vivify_1109
    die "Contextual $*SCOPE not found"
  vivify_1109:
  vivify_1108:
    set $S1053, $P1052
    iseq $I1054, $S1053, "our"
    unless $I1054, unless_1049
    new $P1048, 'Integer'
    set $P1048, $I1054
    goto unless_1049_end
  unless_1049:
    find_dynamic_lex $P1057, "$*SCOPE"
    unless_null $P1057, vivify_1110
    get_hll_global $P1055, "GLOBAL"
    get_who $P1056, $P1055
    set $P1057, $P1056["$SCOPE"]
    unless_null $P1057, vivify_1111
    die "Contextual $*SCOPE not found"
  vivify_1111:
  vivify_1110:
    set $S1058, $P1057
    iseq $I1059, $S1058, ""
    new $P1048, 'Integer'
    set $P1048, $I1059
  unless_1049_end:
    if $P1048, if_1047
.annotate 'line', 369
    find_dynamic_lex $P1100, "$*SCOPE"
    unless_null $P1100, vivify_1112
    get_hll_global $P1098, "GLOBAL"
    get_who $P1099, $P1098
    set $P1100, $P1099["$SCOPE"]
    unless_null $P1100, vivify_1113
    die "Contextual $*SCOPE not found"
  vivify_1113:
  vivify_1112:
    set $S1101, $P1100
    iseq $I1102, $S1101, "my"
    if $I1102, if_1097
.annotate 'line', 376
    find_lex $P1129, "$/"
    unless_null $P1129, vivify_1114
    new $P1129, "Undef"
  vivify_1114:
    $P1130 = $P1129."CURSOR"()
    find_dynamic_lex $P1133, "$*SCOPE"
    unless_null $P1133, vivify_1115
    get_hll_global $P1131, "GLOBAL"
    get_who $P1132, $P1131
    set $P1133, $P1132["$SCOPE"]
    unless_null $P1133, vivify_1116
    die "Contextual $*SCOPE not found"
  vivify_1116:
  vivify_1115:
    concat $P1134, $P1133, " scoped packages are not supported"
    $P1135 = $P1130."panic"($P1134)
.annotate 'line', 375
    set $P1096, $P1135
.annotate 'line', 369
    goto if_1097_end
  if_1097:
.annotate 'line', 370
    find_lex $P1104, "$/"
    unless_null $P1104, vivify_1117
    $P1104 = root_new ['parrot';'Hash']
  vivify_1117:
    set $P1105, $P1104["name"]
    unless_null $P1105, vivify_1118
    $P1105 = root_new ['parrot';'Hash']
  vivify_1118:
    set $P1106, $P1105["identifier"]
    unless_null $P1106, vivify_1119
    new $P1106, "Undef"
  vivify_1119:
    set $N1107, $P1106
    isne $I1108, $N1107, 1.0
    unless $I1108, if_1103_end
.annotate 'line', 371
    find_lex $P1109, "$/"
    unless_null $P1109, vivify_1120
    $P1109 = root_new ['parrot';'Hash']
  vivify_1120:
    set $P1110, $P1109["name"]
    unless_null $P1110, vivify_1121
    new $P1110, "Undef"
  vivify_1121:
    $P1111 = $P1110."CURSOR"()
    $P1111."panic"("A my scoped package cannot have a multi-part name yet")
  if_1103_end:
.annotate 'line', 373
    find_dynamic_lex $P1114, "$*SC"
    unless_null $P1114, vivify_1122
    get_hll_global $P1112, "GLOBAL"
    get_who $P1113, $P1112
    set $P1114, $P1113["$SC"]
    unless_null $P1114, vivify_1123
    die "Contextual $*SC not found"
  vivify_1123:
  vivify_1122:
    get_hll_global $P1115, "GLOBAL"
    nqp_get_package_through_who $P1116, $P1115, "NQP"
    nqp_get_package_through_who $P1117, $P1116, "Actions"
    get_who $P1118, $P1117
    set $P1119, $P1118["@BLOCK"]
    unless_null $P1119, vivify_1124
    $P1119 = root_new ['parrot';'ResizablePMCArray']
  vivify_1124:
    set $P1120, $P1119[0]
    unless_null $P1120, vivify_1125
    new $P1120, "Undef"
  vivify_1125:
    find_lex $P1121, "$/"
    unless_null $P1121, vivify_1126
    $P1121 = root_new ['parrot';'Hash']
  vivify_1126:
    set $P1122, $P1121["name"]
    unless_null $P1122, vivify_1127
    $P1122 = root_new ['parrot';'Hash']
  vivify_1127:
    set $P1123, $P1122["identifier"]
    unless_null $P1123, vivify_1128
    $P1123 = root_new ['parrot';'ResizablePMCArray']
  vivify_1128:
    set $P1124, $P1123[0]
    unless_null $P1124, vivify_1129
    new $P1124, "Undef"
  vivify_1129:
    find_dynamic_lex $P1127, "$*PACKAGE"
    unless_null $P1127, vivify_1130
    get_hll_global $P1125, "GLOBAL"
    get_who $P1126, $P1125
    set $P1127, $P1126["$PACKAGE"]
    unless_null $P1127, vivify_1131
    die "Contextual $*PACKAGE not found"
  vivify_1131:
  vivify_1130:
    $P1128 = $P1114."install_lexical_symbol"($P1120, $P1124, $P1127)
.annotate 'line', 369
    set $P1096, $P1128
  if_1097_end:
    set $P1046, $P1096
.annotate 'line', 363
    goto if_1047_end
  if_1047:
.annotate 'line', 364
    find_dynamic_lex $P1062, "$*SC"
    unless_null $P1062, vivify_1132
    get_hll_global $P1060, "GLOBAL"
    get_who $P1061, $P1060
    set $P1062, $P1061["$SC"]
    unless_null $P1062, vivify_1133
    die "Contextual $*SC not found"
  vivify_1133:
  vivify_1132:
    find_dynamic_lex $P1065, "$*OUTERPACKAGE"
    unless_null $P1065, vivify_1134
    get_hll_global $P1063, "GLOBAL"
    get_who $P1064, $P1063
    set $P1065, $P1064["$OUTERPACKAGE"]
    unless_null $P1065, vivify_1135
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1135:
  vivify_1134:
    find_lex $P1066, "$/"
    unless_null $P1066, vivify_1136
    $P1066 = root_new ['parrot';'Hash']
  vivify_1136:
    set $P1067, $P1066["name"]
    unless_null $P1067, vivify_1137
    $P1067 = root_new ['parrot';'Hash']
  vivify_1137:
    set $P1068, $P1067["identifier"]
    unless_null $P1068, vivify_1138
    new $P1068, "Undef"
  vivify_1138:
    find_dynamic_lex $P1071, "$*PACKAGE"
    unless_null $P1071, vivify_1139
    get_hll_global $P1069, "GLOBAL"
    get_who $P1070, $P1069
    set $P1071, $P1070["$PACKAGE"]
    unless_null $P1071, vivify_1140
    die "Contextual $*PACKAGE not found"
  vivify_1140:
  vivify_1139:
    $P1062."install_package_symbol"($P1065, $P1068, $P1071)
.annotate 'line', 365
    find_lex $P1074, "$/"
    unless_null $P1074, vivify_1141
    $P1074 = root_new ['parrot';'Hash']
  vivify_1141:
    set $P1075, $P1074["name"]
    unless_null $P1075, vivify_1142
    $P1075 = root_new ['parrot';'Hash']
  vivify_1142:
    set $P1076, $P1075["identifier"]
    unless_null $P1076, vivify_1143
    new $P1076, "Undef"
  vivify_1143:
    set $N1077, $P1076
    iseq $I1078, $N1077, 1.0
    if $I1078, if_1073
    new $P1072, 'Integer'
    set $P1072, $I1078
    goto if_1073_end
  if_1073:
.annotate 'line', 366
    find_dynamic_lex $P1081, "$*SC"
    unless_null $P1081, vivify_1144
    get_hll_global $P1079, "GLOBAL"
    get_who $P1080, $P1079
    set $P1081, $P1080["$SC"]
    unless_null $P1081, vivify_1145
    die "Contextual $*SC not found"
  vivify_1145:
  vivify_1144:
    get_hll_global $P1082, "GLOBAL"
    nqp_get_package_through_who $P1083, $P1082, "NQP"
    nqp_get_package_through_who $P1084, $P1083, "Actions"
    get_who $P1085, $P1084
    set $P1086, $P1085["@BLOCK"]
    unless_null $P1086, vivify_1146
    $P1086 = root_new ['parrot';'ResizablePMCArray']
  vivify_1146:
    set $P1087, $P1086[0]
    unless_null $P1087, vivify_1147
    new $P1087, "Undef"
  vivify_1147:
    find_lex $P1088, "$/"
    unless_null $P1088, vivify_1148
    $P1088 = root_new ['parrot';'Hash']
  vivify_1148:
    set $P1089, $P1088["name"]
    unless_null $P1089, vivify_1149
    $P1089 = root_new ['parrot';'Hash']
  vivify_1149:
    set $P1090, $P1089["identifier"]
    unless_null $P1090, vivify_1150
    $P1090 = root_new ['parrot';'ResizablePMCArray']
  vivify_1150:
    set $P1091, $P1090[0]
    unless_null $P1091, vivify_1151
    new $P1091, "Undef"
  vivify_1151:
    find_dynamic_lex $P1094, "$*PACKAGE"
    unless_null $P1094, vivify_1152
    get_hll_global $P1092, "GLOBAL"
    get_who $P1093, $P1092
    set $P1094, $P1093["$PACKAGE"]
    unless_null $P1094, vivify_1153
    die "Contextual $*PACKAGE not found"
  vivify_1153:
  vivify_1152:
    $P1095 = $P1081."install_lexical_symbol"($P1087, $P1091, $P1094)
.annotate 'line', 365
    set $P1072, $P1095
  if_1073_end:
.annotate 'line', 363
    set $P1046, $P1072
  if_1047_end:
.annotate 'line', 352
    .return ($P1046)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("215_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1159 = self."!PREFIX__!subrule"("ws", "")
    new $P1160, "ResizablePMCArray"
    push $P1160, $P1159
    .return ($P1160)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("216_1304282286.73")
    .param pmc param_1162
.annotate 'line', 389
    .lex "self", param_1162
    $P1163 = param_1162."!protoregex"("scope_declarator")
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("217_1304282286.73")
    .param pmc param_1165
.annotate 'line', 389
    .lex "self", param_1165
    $P1166 = param_1165."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("218_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1168_tgt
    .local int rx1168_pos
    .local int rx1168_off
    .local int rx1168_eos
    .local int rx1168_rep
    .local pmc rx1168_cur
    .local pmc rx1168_debug
    (rx1168_cur, rx1168_pos, rx1168_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1168_cur
    .local pmc match
    .lex "$/", match
    length rx1168_eos, rx1168_tgt
    gt rx1168_pos, rx1168_eos, rx1168_done
    set rx1168_off, 0
    lt rx1168_pos, 2, rx1168_start
    sub rx1168_off, rx1168_pos, 1
    substr rx1168_tgt, rx1168_tgt, rx1168_off
  rx1168_start:
    eq $I10, 1, rx1168_restart
    if_null rx1168_debug, debug_1157
    rx1168_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1157:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1172_done
    goto rxscan1172_scan
  rxscan1172_loop:
    (rx1168_pos) = rx1168_cur."from"()
    inc rx1168_pos
    rx1168_cur."!cursor_from"(rx1168_pos)
    ge rx1168_pos, rx1168_eos, rxscan1172_done
  rxscan1172_scan:
    set_addr $I10, rxscan1172_loop
    rx1168_cur."!mark_push"(0, rx1168_pos, $I10)
  rxscan1172_done:
.annotate 'line', 390
  # rx subcapture "sym"
    set_addr $I10, rxcap_1173_fail
    rx1168_cur."!mark_push"(0, rx1168_pos, $I10)
  # rx literal  "my"
    add $I11, rx1168_pos, 2
    gt $I11, rx1168_eos, rx1168_fail
    sub $I11, rx1168_pos, rx1168_off
    substr $S10, rx1168_tgt, $I11, 2
    ne $S10, "my", rx1168_fail
    add rx1168_pos, 2
    set_addr $I10, rxcap_1173_fail
    ($I12, $I11) = rx1168_cur."!mark_peek"($I10)
    rx1168_cur."!cursor_pos"($I11)
    ($P10) = rx1168_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1168_pos, "")
    rx1168_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1173_done
  rxcap_1173_fail:
    goto rx1168_fail
  rxcap_1173_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1168_cur."!cursor_pos"(rx1168_pos)
    $P10 = rx1168_cur."scoped"("my")
    unless $P10, rx1168_fail
    rx1168_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1168_pos = $P10."pos"()
  # rx pass
    rx1168_cur."!cursor_pass"(rx1168_pos, "scope_declarator:sym<my>")
    if_null rx1168_debug, debug_1158
    rx1168_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1168_pos)
  debug_1158:
    .return (rx1168_cur)
  rx1168_restart:
.annotate 'line', 10
    if_null rx1168_debug, debug_1159
    rx1168_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1159:
  rx1168_fail:
    (rx1168_rep, rx1168_pos, $I10, $P10) = rx1168_cur."!mark_fail"(0)
    lt rx1168_pos, -1, rx1168_done
    eq rx1168_pos, -1, rx1168_fail
    jump $I10
  rx1168_done:
    rx1168_cur."!cursor_fail"()
    if_null rx1168_debug, debug_1160
    rx1168_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1160:
    .return (rx1168_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("219_1304282286.73") :method
.annotate 'line', 10
    $P1170 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1171, "ResizablePMCArray"
    push $P1171, $P1170
    .return ($P1171)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("220_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1175 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1176, "ResizablePMCArray"
    push $P1176, $P1175
    .return ($P1176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("221_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1178_tgt
    .local int rx1178_pos
    .local int rx1178_off
    .local int rx1178_eos
    .local int rx1178_rep
    .local pmc rx1178_cur
    .local pmc rx1178_debug
    (rx1178_cur, rx1178_pos, rx1178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1178_cur
    .local pmc match
    .lex "$/", match
    length rx1178_eos, rx1178_tgt
    gt rx1178_pos, rx1178_eos, rx1178_done
    set rx1178_off, 0
    lt rx1178_pos, 2, rx1178_start
    sub rx1178_off, rx1178_pos, 1
    substr rx1178_tgt, rx1178_tgt, rx1178_off
  rx1178_start:
    eq $I10, 1, rx1178_restart
    if_null rx1178_debug, debug_1161
    rx1178_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1182_done
    goto rxscan1182_scan
  rxscan1182_loop:
    (rx1178_pos) = rx1178_cur."from"()
    inc rx1178_pos
    rx1178_cur."!cursor_from"(rx1178_pos)
    ge rx1178_pos, rx1178_eos, rxscan1182_done
  rxscan1182_scan:
    set_addr $I10, rxscan1182_loop
    rx1178_cur."!mark_push"(0, rx1178_pos, $I10)
  rxscan1182_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_1183_fail
    rx1178_cur."!mark_push"(0, rx1178_pos, $I10)
  # rx literal  "our"
    add $I11, rx1178_pos, 3
    gt $I11, rx1178_eos, rx1178_fail
    sub $I11, rx1178_pos, rx1178_off
    substr $S10, rx1178_tgt, $I11, 3
    ne $S10, "our", rx1178_fail
    add rx1178_pos, 3
    set_addr $I10, rxcap_1183_fail
    ($I12, $I11) = rx1178_cur."!mark_peek"($I10)
    rx1178_cur."!cursor_pos"($I11)
    ($P10) = rx1178_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1178_pos, "")
    rx1178_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1183_done
  rxcap_1183_fail:
    goto rx1178_fail
  rxcap_1183_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."scoped"("our")
    unless $P10, rx1178_fail
    rx1178_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1178_pos = $P10."pos"()
  # rx pass
    rx1178_cur."!cursor_pass"(rx1178_pos, "scope_declarator:sym<our>")
    if_null rx1178_debug, debug_1162
    rx1178_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1178_pos)
  debug_1162:
    .return (rx1178_cur)
  rx1178_restart:
.annotate 'line', 10
    if_null rx1178_debug, debug_1163
    rx1178_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1163:
  rx1178_fail:
    (rx1178_rep, rx1178_pos, $I10, $P10) = rx1178_cur."!mark_fail"(0)
    lt rx1178_pos, -1, rx1178_done
    eq rx1178_pos, -1, rx1178_fail
    jump $I10
  rx1178_done:
    rx1178_cur."!cursor_fail"()
    if_null rx1178_debug, debug_1164
    rx1178_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1164:
    .return (rx1178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("222_1304282286.73") :method
.annotate 'line', 10
    $P1180 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1181, "ResizablePMCArray"
    push $P1181, $P1180
    .return ($P1181)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("223_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1185 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1186, "ResizablePMCArray"
    push $P1186, $P1185
    .return ($P1186)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("224_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1188_tgt
    .local int rx1188_pos
    .local int rx1188_off
    .local int rx1188_eos
    .local int rx1188_rep
    .local pmc rx1188_cur
    .local pmc rx1188_debug
    (rx1188_cur, rx1188_pos, rx1188_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1188_cur
    .local pmc match
    .lex "$/", match
    length rx1188_eos, rx1188_tgt
    gt rx1188_pos, rx1188_eos, rx1188_done
    set rx1188_off, 0
    lt rx1188_pos, 2, rx1188_start
    sub rx1188_off, rx1188_pos, 1
    substr rx1188_tgt, rx1188_tgt, rx1188_off
  rx1188_start:
    eq $I10, 1, rx1188_restart
    if_null rx1188_debug, debug_1165
    rx1188_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1165:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1192_done
    goto rxscan1192_scan
  rxscan1192_loop:
    (rx1188_pos) = rx1188_cur."from"()
    inc rx1188_pos
    rx1188_cur."!cursor_from"(rx1188_pos)
    ge rx1188_pos, rx1188_eos, rxscan1192_done
  rxscan1192_scan:
    set_addr $I10, rxscan1192_loop
    rx1188_cur."!mark_push"(0, rx1188_pos, $I10)
  rxscan1192_done:
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_1193_fail
    rx1188_cur."!mark_push"(0, rx1188_pos, $I10)
  # rx literal  "has"
    add $I11, rx1188_pos, 3
    gt $I11, rx1188_eos, rx1188_fail
    sub $I11, rx1188_pos, rx1188_off
    substr $S10, rx1188_tgt, $I11, 3
    ne $S10, "has", rx1188_fail
    add rx1188_pos, 3
    set_addr $I10, rxcap_1193_fail
    ($I12, $I11) = rx1188_cur."!mark_peek"($I10)
    rx1188_cur."!cursor_pos"($I11)
    ($P10) = rx1188_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1188_pos, "")
    rx1188_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1193_done
  rxcap_1193_fail:
    goto rx1188_fail
  rxcap_1193_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1188_cur."!cursor_pos"(rx1188_pos)
    $P10 = rx1188_cur."scoped"("has")
    unless $P10, rx1188_fail
    rx1188_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1188_pos = $P10."pos"()
  # rx pass
    rx1188_cur."!cursor_pass"(rx1188_pos, "scope_declarator:sym<has>")
    if_null rx1188_debug, debug_1166
    rx1188_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1188_pos)
  debug_1166:
    .return (rx1188_cur)
  rx1188_restart:
.annotate 'line', 10
    if_null rx1188_debug, debug_1167
    rx1188_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1167:
  rx1188_fail:
    (rx1188_rep, rx1188_pos, $I10, $P10) = rx1188_cur."!mark_fail"(0)
    lt rx1188_pos, -1, rx1188_done
    eq rx1188_pos, -1, rx1188_fail
    jump $I10
  rx1188_done:
    rx1188_cur."!cursor_fail"()
    if_null rx1188_debug, debug_1168
    rx1188_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1168:
    .return (rx1188_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("225_1304282286.73") :method
.annotate 'line', 10
    $P1190 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1191, "ResizablePMCArray"
    push $P1191, $P1190
    .return ($P1191)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("226_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1195 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1196, "ResizablePMCArray"
    push $P1196, $P1195
    .return ($P1196)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("227_1304282286.73") :method :outer("12_1304282286.73")
    .param pmc param_1198
.annotate 'line', 394
    .lex "$*SCOPE", param_1198
.annotate 'line', 10
    .local string rx1199_tgt
    .local int rx1199_pos
    .local int rx1199_off
    .local int rx1199_eos
    .local int rx1199_rep
    .local pmc rx1199_cur
    .local pmc rx1199_debug
    (rx1199_cur, rx1199_pos, rx1199_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1199_cur
    .local pmc match
    .lex "$/", match
    length rx1199_eos, rx1199_tgt
    gt rx1199_pos, rx1199_eos, rx1199_done
    set rx1199_off, 0
    lt rx1199_pos, 2, rx1199_start
    sub rx1199_off, rx1199_pos, 1
    substr rx1199_tgt, rx1199_tgt, rx1199_off
  rx1199_start:
    eq $I10, 1, rx1199_restart
    if_null rx1199_debug, debug_1169
    rx1199_cur."!cursor_debug"("START", "scoped")
  debug_1169:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1205_done
    goto rxscan1205_scan
  rxscan1205_loop:
    (rx1199_pos) = rx1199_cur."from"()
    inc rx1199_pos
    rx1199_cur."!cursor_from"(rx1199_pos)
    ge rx1199_pos, rx1199_eos, rxscan1205_done
  rxscan1205_scan:
    set_addr $I10, rxscan1205_loop
    rx1199_cur."!mark_push"(0, rx1199_pos, $I10)
  rxscan1205_done:
  alt1206_0:
.annotate 'line', 394
    set_addr $I10, alt1206_1
    rx1199_cur."!mark_push"(0, rx1199_pos, $I10)
.annotate 'line', 395
  # rx subrule "ws" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."ws"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."declarator"()
    unless $P10, rx1199_fail
    rx1199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1199_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."ws"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
    goto alt1206_end
  alt1206_1:
    set_addr $I10, alt1206_2
    rx1199_cur."!mark_push"(0, rx1199_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."ws"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."multi_declarator"()
    unless $P10, rx1199_fail
    rx1199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1199_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."ws"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
    goto alt1206_end
  alt1206_2:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."ws"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."package_declarator"()
    unless $P10, rx1199_fail
    rx1199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1199_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1199_cur."!cursor_pos"(rx1199_pos)
    $P10 = rx1199_cur."ws"()
    unless $P10, rx1199_fail
    rx1199_pos = $P10."pos"()
  alt1206_end:
.annotate 'line', 394
  # rx pass
    rx1199_cur."!cursor_pass"(rx1199_pos, "scoped")
    if_null rx1199_debug, debug_1170
    rx1199_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1199_pos)
  debug_1170:
    .return (rx1199_cur)
  rx1199_restart:
.annotate 'line', 10
    if_null rx1199_debug, debug_1171
    rx1199_cur."!cursor_debug"("NEXT", "scoped")
  debug_1171:
  rx1199_fail:
    (rx1199_rep, rx1199_pos, $I10, $P10) = rx1199_cur."!mark_fail"(0)
    lt rx1199_pos, -1, rx1199_done
    eq rx1199_pos, -1, rx1199_fail
    jump $I10
  rx1199_done:
    rx1199_cur."!cursor_fail"()
    if_null rx1199_debug, debug_1172
    rx1199_cur."!cursor_debug"("FAIL", "scoped")
  debug_1172:
    .return (rx1199_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("228_1304282286.73") :method
.annotate 'line', 10
    $P1201 = self."!PREFIX__!subrule"("ws", "")
    $P1202 = self."!PREFIX__!subrule"("ws", "")
    $P1203 = self."!PREFIX__!subrule"("ws", "")
    new $P1204, "ResizablePMCArray"
    push $P1204, $P1201
    push $P1204, $P1202
    push $P1204, $P1203
    .return ($P1204)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("229_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1214 = self."!PREFIX__!subrule"("ws", "")
    $P1215 = self."!PREFIX__!subrule"("ws", "")
    $P1216 = self."!PREFIX__!subrule"("ws", "")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1214
    push $P1217, $P1215
    push $P1217, $P1216
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("230_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1227 = "232_1304282286.73" 
    capture_lex $P1227
    .local string rx1219_tgt
    .local int rx1219_pos
    .local int rx1219_off
    .local int rx1219_eos
    .local int rx1219_rep
    .local pmc rx1219_cur
    .local pmc rx1219_debug
    (rx1219_cur, rx1219_pos, rx1219_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1219_cur
    .local pmc match
    .lex "$/", match
    length rx1219_eos, rx1219_tgt
    gt rx1219_pos, rx1219_eos, rx1219_done
    set rx1219_off, 0
    lt rx1219_pos, 2, rx1219_start
    sub rx1219_off, rx1219_pos, 1
    substr rx1219_tgt, rx1219_tgt, rx1219_off
  rx1219_start:
    eq $I10, 1, rx1219_restart
    if_null rx1219_debug, debug_1173
    rx1219_cur."!cursor_debug"("START", "typename")
  debug_1173:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1223_done
    goto rxscan1223_scan
  rxscan1223_loop:
    (rx1219_pos) = rx1219_cur."from"()
    inc rx1219_pos
    rx1219_cur."!cursor_from"(rx1219_pos)
    ge rx1219_pos, rx1219_eos, rxscan1223_done
  rxscan1223_scan:
    set_addr $I10, rxscan1223_loop
    rx1219_cur."!mark_push"(0, rx1219_pos, $I10)
  rxscan1223_done:
.annotate 'line', 401
  # rx subrule "name" subtype=capture negate=
    rx1219_cur."!cursor_pos"(rx1219_pos)
    $P10 = rx1219_cur."name"()
    unless $P10, rx1219_fail
    rx1219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1219_pos = $P10."pos"()
.annotate 'line', 402
    rx1219_cur."!cursor_pos"(rx1219_pos)
    find_lex $P1224, unicode:"$\x{a2}"
    $P1225 = $P1224."MATCH"()
    store_lex "$/", $P1225
    .const 'Sub' $P1227 = "232_1304282286.73" 
    capture_lex $P1227
    $P1236 = $P1227()
    unless $P1236, rx1219_fail
.annotate 'line', 400
  # rx pass
    rx1219_cur."!cursor_pass"(rx1219_pos, "typename")
    if_null rx1219_debug, debug_1180
    rx1219_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1219_pos)
  debug_1180:
    .return (rx1219_cur)
  rx1219_restart:
.annotate 'line', 10
    if_null rx1219_debug, debug_1181
    rx1219_cur."!cursor_debug"("NEXT", "typename")
  debug_1181:
  rx1219_fail:
    (rx1219_rep, rx1219_pos, $I10, $P10) = rx1219_cur."!mark_fail"(0)
    lt rx1219_pos, -1, rx1219_done
    eq rx1219_pos, -1, rx1219_fail
    jump $I10
  rx1219_done:
    rx1219_cur."!cursor_fail"()
    if_null rx1219_debug, debug_1182
    rx1219_cur."!cursor_debug"("FAIL", "typename")
  debug_1182:
    .return (rx1219_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("231_1304282286.73") :method
.annotate 'line', 10
    $P1221 = self."!PREFIX__!subrule"("name", "")
    new $P1222, "ResizablePMCArray"
    push $P1222, $P1221
    .return ($P1222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1226"  :anon :subid("232_1304282286.73") :outer("230_1304282286.73")
.annotate 'line', 402
    find_dynamic_lex $P1230, "$*ACTIONS"
    unless_null $P1230, vivify_1174
    get_hll_global $P1228, "GLOBAL"
    get_who $P1229, $P1228
    set $P1230, $P1229["$ACTIONS"]
    unless_null $P1230, vivify_1175
    die "Contextual $*ACTIONS not found"
  vivify_1175:
  vivify_1174:
    find_lex $P1231, "$/"
    unless_null $P1231, vivify_1176
    new $P1231, "Undef"
  vivify_1176:
    find_lex $P1232, "$/"
    unless_null $P1232, vivify_1177
    $P1232 = root_new ['parrot';'Hash']
  vivify_1177:
    set $P1233, $P1232["name"]
    unless_null $P1233, vivify_1178
    $P1233 = root_new ['parrot';'Hash']
  vivify_1178:
    set $P1234, $P1233["identifier"]
    unless_null $P1234, vivify_1179
    new $P1234, "Undef"
  vivify_1179:
    $P1235 = $P1230."known_sym"($P1231, $P1234)
    .return ($P1235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("233_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1238 = self."!PREFIX__!subrule"("name", "")
    new $P1239, "ResizablePMCArray"
    push $P1239, $P1238
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("234_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1241_tgt
    .local int rx1241_pos
    .local int rx1241_off
    .local int rx1241_eos
    .local int rx1241_rep
    .local pmc rx1241_cur
    .local pmc rx1241_debug
    (rx1241_cur, rx1241_pos, rx1241_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1241_cur
    .local pmc match
    .lex "$/", match
    length rx1241_eos, rx1241_tgt
    gt rx1241_pos, rx1241_eos, rx1241_done
    set rx1241_off, 0
    lt rx1241_pos, 2, rx1241_start
    sub rx1241_off, rx1241_pos, 1
    substr rx1241_tgt, rx1241_tgt, rx1241_off
  rx1241_start:
    eq $I10, 1, rx1241_restart
    if_null rx1241_debug, debug_1183
    rx1241_cur."!cursor_debug"("START", "declarator")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1246_done
    goto rxscan1246_scan
  rxscan1246_loop:
    (rx1241_pos) = rx1241_cur."from"()
    inc rx1241_pos
    rx1241_cur."!cursor_from"(rx1241_pos)
    ge rx1241_pos, rx1241_eos, rxscan1246_done
  rxscan1246_scan:
    set_addr $I10, rxscan1246_loop
    rx1241_cur."!mark_push"(0, rx1241_pos, $I10)
  rxscan1246_done:
  alt1247_0:
.annotate 'line', 405
    set_addr $I10, alt1247_1
    rx1241_cur."!mark_push"(0, rx1241_pos, $I10)
.annotate 'line', 406
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1241_cur."!cursor_pos"(rx1241_pos)
    $P10 = rx1241_cur."variable_declarator"()
    unless $P10, rx1241_fail
    rx1241_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1241_pos = $P10."pos"()
    goto alt1247_end
  alt1247_1:
.annotate 'line', 407
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1241_cur."!cursor_pos"(rx1241_pos)
    $P10 = rx1241_cur."routine_declarator"()
    unless $P10, rx1241_fail
    rx1241_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1241_pos = $P10."pos"()
  alt1247_end:
.annotate 'line', 405
  # rx pass
    rx1241_cur."!cursor_pass"(rx1241_pos, "declarator")
    if_null rx1241_debug, debug_1184
    rx1241_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1241_pos)
  debug_1184:
    .return (rx1241_cur)
  rx1241_restart:
.annotate 'line', 10
    if_null rx1241_debug, debug_1185
    rx1241_cur."!cursor_debug"("NEXT", "declarator")
  debug_1185:
  rx1241_fail:
    (rx1241_rep, rx1241_pos, $I10, $P10) = rx1241_cur."!mark_fail"(0)
    lt rx1241_pos, -1, rx1241_done
    eq rx1241_pos, -1, rx1241_fail
    jump $I10
  rx1241_done:
    rx1241_cur."!cursor_fail"()
    if_null rx1241_debug, debug_1186
    rx1241_cur."!cursor_debug"("FAIL", "declarator")
  debug_1186:
    .return (rx1241_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("235_1304282286.73") :method
.annotate 'line', 10
    $P1243 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1244 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1245, "ResizablePMCArray"
    push $P1245, $P1243
    push $P1245, $P1244
    .return ($P1245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("236_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1249 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1250 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1251, "ResizablePMCArray"
    push $P1251, $P1249
    push $P1251, $P1250
    .return ($P1251)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("237_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1269 = "239_1304282286.73" 
    capture_lex $P1269
.annotate 'line', 412
    new $P1253, "Undef"
    .lex "$*IN_DECL", $P1253
.annotate 'line', 10
    .local string rx1254_tgt
    .local int rx1254_pos
    .local int rx1254_off
    .local int rx1254_eos
    .local int rx1254_rep
    .local pmc rx1254_cur
    .local pmc rx1254_debug
    (rx1254_cur, rx1254_pos, rx1254_tgt, $I10) = self."!cursor_start"()
    rx1254_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1254_cur
    .local pmc match
    .lex "$/", match
    length rx1254_eos, rx1254_tgt
    gt rx1254_pos, rx1254_eos, rx1254_done
    set rx1254_off, 0
    lt rx1254_pos, 2, rx1254_start
    sub rx1254_off, rx1254_pos, 1
    substr rx1254_tgt, rx1254_tgt, rx1254_off
  rx1254_start:
    eq $I10, 1, rx1254_restart
    if_null rx1254_debug, debug_1187
    rx1254_cur."!cursor_debug"("START", "variable_declarator")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1258_done
    goto rxscan1258_scan
  rxscan1258_loop:
    (rx1254_pos) = rx1254_cur."from"()
    inc rx1254_pos
    rx1254_cur."!cursor_from"(rx1254_pos)
    ge rx1254_pos, rx1254_eos, rxscan1258_done
  rxscan1258_scan:
    set_addr $I10, rxscan1258_loop
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10)
  rxscan1258_done:
.annotate 'line', 410
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
.annotate 'line', 411
  # rx rxquantr1260 ** 0..1
    set_addr $I10, rxquantr1260_done
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10)
  rxquantr1260_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."typename"()
    unless $P10, rx1254_fail
    goto rxsubrule1261_pass
  rxsubrule1261_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1254_fail
  rxsubrule1261_pass:
    set_addr $I10, rxsubrule1261_back
    rx1254_cur."!mark_push"(0, rx1254_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1254_pos = $P10."pos"()
    set_addr $I10, rxquantr1260_done
    (rx1254_rep) = rx1254_cur."!mark_commit"($I10)
  rxquantr1260_done:
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
.annotate 'line', 412
    rx1254_cur."!cursor_pos"(rx1254_pos)
    new $P1263, "String"
    assign $P1263, "variable"
    store_lex "$*IN_DECL", $P1263
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
.annotate 'line', 413
  # rx subrule "variable" subtype=capture negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."variable"()
    unless $P10, rx1254_fail
    rx1254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1254_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
.annotate 'line', 414
    rx1254_cur."!cursor_pos"(rx1254_pos)
    find_lex $P1266, unicode:"$\x{a2}"
    $P1267 = $P1266."MATCH"()
    store_lex "$/", $P1267
    .const 'Sub' $P1269 = "239_1304282286.73" 
    capture_lex $P1269
    $P1271 = $P1269()
  # rx subrule "ws" subtype=method negate=
    rx1254_cur."!cursor_pos"(rx1254_pos)
    $P10 = rx1254_cur."ws"()
    unless $P10, rx1254_fail
    rx1254_pos = $P10."pos"()
.annotate 'line', 410
  # rx pass
    rx1254_cur."!cursor_pass"(rx1254_pos, "variable_declarator")
    if_null rx1254_debug, debug_1188
    rx1254_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1254_pos)
  debug_1188:
    .return (rx1254_cur)
  rx1254_restart:
.annotate 'line', 10
    if_null rx1254_debug, debug_1189
    rx1254_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1189:
  rx1254_fail:
    (rx1254_rep, rx1254_pos, $I10, $P10) = rx1254_cur."!mark_fail"(0)
    lt rx1254_pos, -1, rx1254_done
    eq rx1254_pos, -1, rx1254_fail
    jump $I10
  rx1254_done:
    rx1254_cur."!cursor_fail"()
    if_null rx1254_debug, debug_1190
    rx1254_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1190:
    .return (rx1254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("238_1304282286.73") :method
.annotate 'line', 10
    $P1256 = self."!PREFIX__!subrule"("ws", "")
    new $P1257, "ResizablePMCArray"
    push $P1257, $P1256
    .return ($P1257)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1268"  :anon :subid("239_1304282286.73") :outer("237_1304282286.73")
.annotate 'line', 414
    new $P1270, "Integer"
    assign $P1270, 0
    store_dynamic_lex "$*IN_DECL", $P1270
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("240_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1274 = self."!PREFIX__!subrule"("ws", "")
    new $P1275, "ResizablePMCArray"
    push $P1275, $P1274
    .return ($P1275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("241_1304282286.73")
    .param pmc param_1277
.annotate 'line', 417
    .lex "self", param_1277
    $P1278 = param_1277."!protoregex"("routine_declarator")
    .return ($P1278)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("242_1304282286.73")
    .param pmc param_1280
.annotate 'line', 417
    .lex "self", param_1280
    $P1281 = param_1280."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("243_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1283_tgt
    .local int rx1283_pos
    .local int rx1283_off
    .local int rx1283_eos
    .local int rx1283_rep
    .local pmc rx1283_cur
    .local pmc rx1283_debug
    (rx1283_cur, rx1283_pos, rx1283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1283_cur
    .local pmc match
    .lex "$/", match
    length rx1283_eos, rx1283_tgt
    gt rx1283_pos, rx1283_eos, rx1283_done
    set rx1283_off, 0
    lt rx1283_pos, 2, rx1283_start
    sub rx1283_off, rx1283_pos, 1
    substr rx1283_tgt, rx1283_tgt, rx1283_off
  rx1283_start:
    eq $I10, 1, rx1283_restart
    if_null rx1283_debug, debug_1191
    rx1283_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1287_done
    goto rxscan1287_scan
  rxscan1287_loop:
    (rx1283_pos) = rx1283_cur."from"()
    inc rx1283_pos
    rx1283_cur."!cursor_from"(rx1283_pos)
    ge rx1283_pos, rx1283_eos, rxscan1287_done
  rxscan1287_scan:
    set_addr $I10, rxscan1287_loop
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxscan1287_done:
.annotate 'line', 418
  # rx subcapture "sym"
    set_addr $I10, rxcap_1288_fail
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1283_pos, 3
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 3
    ne $S10, "sub", rx1283_fail
    add rx1283_pos, 3
    set_addr $I10, rxcap_1288_fail
    ($I12, $I11) = rx1283_cur."!mark_peek"($I10)
    rx1283_cur."!cursor_pos"($I11)
    ($P10) = rx1283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1283_pos, "")
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1288_done
  rxcap_1288_fail:
    goto rx1283_fail
  rxcap_1288_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."routine_def"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1283_pos = $P10."pos"()
  # rx pass
    rx1283_cur."!cursor_pass"(rx1283_pos, "routine_declarator:sym<sub>")
    if_null rx1283_debug, debug_1192
    rx1283_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1283_pos)
  debug_1192:
    .return (rx1283_cur)
  rx1283_restart:
.annotate 'line', 10
    if_null rx1283_debug, debug_1193
    rx1283_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1193:
  rx1283_fail:
    (rx1283_rep, rx1283_pos, $I10, $P10) = rx1283_cur."!mark_fail"(0)
    lt rx1283_pos, -1, rx1283_done
    eq rx1283_pos, -1, rx1283_fail
    jump $I10
  rx1283_done:
    rx1283_cur."!cursor_fail"()
    if_null rx1283_debug, debug_1194
    rx1283_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1194:
    .return (rx1283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("244_1304282286.73") :method
.annotate 'line', 10
    $P1285 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1286, "ResizablePMCArray"
    push $P1286, $P1285
    .return ($P1286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("245_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1290 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1291, "ResizablePMCArray"
    push $P1291, $P1290
    .return ($P1291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("246_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1293_tgt
    .local int rx1293_pos
    .local int rx1293_off
    .local int rx1293_eos
    .local int rx1293_rep
    .local pmc rx1293_cur
    .local pmc rx1293_debug
    (rx1293_cur, rx1293_pos, rx1293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1293_cur
    .local pmc match
    .lex "$/", match
    length rx1293_eos, rx1293_tgt
    gt rx1293_pos, rx1293_eos, rx1293_done
    set rx1293_off, 0
    lt rx1293_pos, 2, rx1293_start
    sub rx1293_off, rx1293_pos, 1
    substr rx1293_tgt, rx1293_tgt, rx1293_off
  rx1293_start:
    eq $I10, 1, rx1293_restart
    if_null rx1293_debug, debug_1195
    rx1293_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1297_done
    goto rxscan1297_scan
  rxscan1297_loop:
    (rx1293_pos) = rx1293_cur."from"()
    inc rx1293_pos
    rx1293_cur."!cursor_from"(rx1293_pos)
    ge rx1293_pos, rx1293_eos, rxscan1297_done
  rxscan1297_scan:
    set_addr $I10, rxscan1297_loop
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  rxscan1297_done:
.annotate 'line', 419
  # rx subcapture "sym"
    set_addr $I10, rxcap_1298_fail
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  # rx literal  "method"
    add $I11, rx1293_pos, 6
    gt $I11, rx1293_eos, rx1293_fail
    sub $I11, rx1293_pos, rx1293_off
    substr $S10, rx1293_tgt, $I11, 6
    ne $S10, "method", rx1293_fail
    add rx1293_pos, 6
    set_addr $I10, rxcap_1298_fail
    ($I12, $I11) = rx1293_cur."!mark_peek"($I10)
    rx1293_cur."!cursor_pos"($I11)
    ($P10) = rx1293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1293_pos, "")
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1298_done
  rxcap_1298_fail:
    goto rx1293_fail
  rxcap_1298_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."method_def"()
    unless $P10, rx1293_fail
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1293_pos = $P10."pos"()
  # rx pass
    rx1293_cur."!cursor_pass"(rx1293_pos, "routine_declarator:sym<method>")
    if_null rx1293_debug, debug_1196
    rx1293_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1293_pos)
  debug_1196:
    .return (rx1293_cur)
  rx1293_restart:
.annotate 'line', 10
    if_null rx1293_debug, debug_1197
    rx1293_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1197:
  rx1293_fail:
    (rx1293_rep, rx1293_pos, $I10, $P10) = rx1293_cur."!mark_fail"(0)
    lt rx1293_pos, -1, rx1293_done
    eq rx1293_pos, -1, rx1293_fail
    jump $I10
  rx1293_done:
    rx1293_cur."!cursor_fail"()
    if_null rx1293_debug, debug_1198
    rx1293_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1198:
    .return (rx1293_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("247_1304282286.73") :method
.annotate 'line', 10
    $P1295 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1296, "ResizablePMCArray"
    push $P1296, $P1295
    .return ($P1296)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("248_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1300 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1301, "ResizablePMCArray"
    push $P1301, $P1300
    .return ($P1301)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("249_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 422
    new $P1303, "Undef"
    .lex "$*RETURN_USED", $P1303
.annotate 'line', 10
    .local string rx1304_tgt
    .local int rx1304_pos
    .local int rx1304_off
    .local int rx1304_eos
    .local int rx1304_rep
    .local pmc rx1304_cur
    .local pmc rx1304_debug
    (rx1304_cur, rx1304_pos, rx1304_tgt, $I10) = self."!cursor_start"()
    rx1304_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1304_cur
    .local pmc match
    .lex "$/", match
    length rx1304_eos, rx1304_tgt
    gt rx1304_pos, rx1304_eos, rx1304_done
    set rx1304_off, 0
    lt rx1304_pos, 2, rx1304_start
    sub rx1304_off, rx1304_pos, 1
    substr rx1304_tgt, rx1304_tgt, rx1304_off
  rx1304_start:
    eq $I10, 1, rx1304_restart
    if_null rx1304_debug, debug_1199
    rx1304_cur."!cursor_debug"("START", "routine_def")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1308_done
    goto rxscan1308_scan
  rxscan1308_loop:
    (rx1304_pos) = rx1304_cur."from"()
    inc rx1304_pos
    rx1304_cur."!cursor_from"(rx1304_pos)
    ge rx1304_pos, rx1304_eos, rxscan1308_done
  rxscan1308_scan:
    set_addr $I10, rxscan1308_loop
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  rxscan1308_done:
.annotate 'line', 421
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
.annotate 'line', 422
    rx1304_cur."!cursor_pos"(rx1304_pos)
    new $P1310, "Integer"
    assign $P1310, 0
    store_lex "$*RETURN_USED", $P1310
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
.annotate 'line', 423
  # rx rxquantr1312 ** 0..1
    set_addr $I10, rxquantr1312_done
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  rxquantr1312_loop:
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1315_fail
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  # rx rxquantr1314 ** 0..1
    set_addr $I10, rxquantr1314_done
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  rxquantr1314_loop:
  # rx literal  "&"
    add $I11, rx1304_pos, 1
    gt $I11, rx1304_eos, rx1304_fail
    sub $I11, rx1304_pos, rx1304_off
    ord $I11, rx1304_tgt, $I11
    ne $I11, 38, rx1304_fail
    add rx1304_pos, 1
    set_addr $I10, rxquantr1314_done
    (rx1304_rep) = rx1304_cur."!mark_commit"($I10)
  rxquantr1314_done:
    set_addr $I10, rxcap_1315_fail
    ($I12, $I11) = rx1304_cur."!mark_peek"($I10)
    rx1304_cur."!cursor_pos"($I11)
    ($P10) = rx1304_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1304_pos, "")
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1315_done
  rxcap_1315_fail:
    goto rx1304_fail
  rxcap_1315_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."deflongname"()
    unless $P10, rx1304_fail
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1304_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
    set_addr $I10, rxquantr1312_done
    (rx1304_rep) = rx1304_cur."!mark_commit"($I10)
  rxquantr1312_done:
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
.annotate 'line', 424
  # rx subrule "newpad" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."newpad"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  alt1319_0:
.annotate 'line', 425
    set_addr $I10, alt1319_1
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1304_pos, 1
    gt $I11, rx1304_eos, rx1304_fail
    sub $I11, rx1304_pos, rx1304_off
    ord $I11, rx1304_tgt, $I11
    ne $I11, 40, rx1304_fail
    add rx1304_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."signature"()
    unless $P10, rx1304_fail
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1304_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1304_pos, 1
    gt $I11, rx1304_eos, rx1304_fail
    sub $I11, rx1304_pos, rx1304_off
    ord $I11, rx1304_tgt, $I11
    ne $I11, 41, rx1304_fail
    add rx1304_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
    goto alt1319_end
  alt1319_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  alt1319_end:
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
.annotate 'line', 427
  # rx rxquantr1327 ** 0..*
    set_addr $I10, rxquantr1327_done
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  rxquantr1327_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."trait"()
    unless $P10, rx1304_fail
    goto rxsubrule1328_pass
  rxsubrule1328_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1304_fail
  rxsubrule1328_pass:
    set_addr $I10, rxsubrule1328_back
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1304_pos = $P10."pos"()
    set_addr $I10, rxquantr1327_done
    (rx1304_rep) = rx1304_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1327_done
    rx1304_cur."!mark_push"(rx1304_rep, rx1304_pos, $I10)
    goto rxquantr1327_loop
  rxquantr1327_done:
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  alt1330_0:
.annotate 'line', 428
    set_addr $I10, alt1330_1
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
.annotate 'line', 429
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."onlystar"()
    unless $P10, rx1304_fail
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1304_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
    goto alt1330_end
  alt1330_1:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."blockoid"()
    unless $P10, rx1304_fail
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1304_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
  alt1330_end:
.annotate 'line', 431
  # rx subrule "ws" subtype=method negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."ws"()
    unless $P10, rx1304_fail
    rx1304_pos = $P10."pos"()
.annotate 'line', 421
  # rx pass
    rx1304_cur."!cursor_pass"(rx1304_pos, "routine_def")
    if_null rx1304_debug, debug_1200
    rx1304_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1304_pos)
  debug_1200:
    .return (rx1304_cur)
  rx1304_restart:
.annotate 'line', 10
    if_null rx1304_debug, debug_1201
    rx1304_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1201:
  rx1304_fail:
    (rx1304_rep, rx1304_pos, $I10, $P10) = rx1304_cur."!mark_fail"(0)
    lt rx1304_pos, -1, rx1304_done
    eq rx1304_pos, -1, rx1304_fail
    jump $I10
  rx1304_done:
    rx1304_cur."!cursor_fail"()
    if_null rx1304_debug, debug_1202
    rx1304_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1202:
    .return (rx1304_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("250_1304282286.73") :method
.annotate 'line', 10
    $P1306 = self."!PREFIX__!subrule"("ws", "")
    new $P1307, "ResizablePMCArray"
    push $P1307, $P1306
    .return ($P1307)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("251_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1337 = self."!PREFIX__!subrule"("ws", "")
    new $P1338, "ResizablePMCArray"
    push $P1338, $P1337
    .return ($P1338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("252_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1370 = "254_1304282286.73" 
    capture_lex $P1370
.annotate 'line', 435
    new $P1340, "Undef"
    .lex "$*RETURN_USED", $P1340
.annotate 'line', 436
    new $P1341, "Undef"
    .lex "$*INVOCANT_OK", $P1341
.annotate 'line', 10
    .local string rx1342_tgt
    .local int rx1342_pos
    .local int rx1342_off
    .local int rx1342_eos
    .local int rx1342_rep
    .local pmc rx1342_cur
    .local pmc rx1342_debug
    (rx1342_cur, rx1342_pos, rx1342_tgt, $I10) = self."!cursor_start"()
    rx1342_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1342_cur
    .local pmc match
    .lex "$/", match
    length rx1342_eos, rx1342_tgt
    gt rx1342_pos, rx1342_eos, rx1342_done
    set rx1342_off, 0
    lt rx1342_pos, 2, rx1342_start
    sub rx1342_off, rx1342_pos, 1
    substr rx1342_tgt, rx1342_tgt, rx1342_off
  rx1342_start:
    eq $I10, 1, rx1342_restart
    if_null rx1342_debug, debug_1203
    rx1342_cur."!cursor_debug"("START", "method_def")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1346_done
    goto rxscan1346_scan
  rxscan1346_loop:
    (rx1342_pos) = rx1342_cur."from"()
    inc rx1342_pos
    rx1342_cur."!cursor_from"(rx1342_pos)
    ge rx1342_pos, rx1342_eos, rxscan1346_done
  rxscan1346_scan:
    set_addr $I10, rxscan1346_loop
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxscan1346_done:
.annotate 'line', 434
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 435
    rx1342_cur."!cursor_pos"(rx1342_pos)
    new $P1348, "Integer"
    assign $P1348, 0
    store_lex "$*RETURN_USED", $P1348
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 436
    rx1342_cur."!cursor_pos"(rx1342_pos)
    new $P1350, "Integer"
    assign $P1350, 1
    store_lex "$*INVOCANT_OK", $P1350
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 437
  # rx subcapture "private"
    set_addr $I10, rxcap_1353_fail
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  # rx rxquantr1352 ** 0..1
    set_addr $I10, rxquantr1352_done
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxquantr1352_loop:
  # rx literal  "!"
    add $I11, rx1342_pos, 1
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    ord $I11, rx1342_tgt, $I11
    ne $I11, 33, rx1342_fail
    add rx1342_pos, 1
    set_addr $I10, rxquantr1352_done
    (rx1342_rep) = rx1342_cur."!mark_commit"($I10)
  rxquantr1352_done:
    set_addr $I10, rxcap_1353_fail
    ($I12, $I11) = rx1342_cur."!mark_peek"($I10)
    rx1342_cur."!cursor_pos"($I11)
    ($P10) = rx1342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1342_pos, "")
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1353_done
  rxcap_1353_fail:
    goto rx1342_fail
  rxcap_1353_done:
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 438
  # rx rxquantr1355 ** 0..1
    set_addr $I10, rxquantr1355_done
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxquantr1355_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."deflongname"()
    unless $P10, rx1342_fail
    goto rxsubrule1356_pass
  rxsubrule1356_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1342_fail
  rxsubrule1356_pass:
    set_addr $I10, rxsubrule1356_back
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1342_pos = $P10."pos"()
    set_addr $I10, rxquantr1355_done
    (rx1342_rep) = rx1342_cur."!mark_commit"($I10)
  rxquantr1355_done:
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 439
  # rx subrule "newpad" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."newpad"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  alt1359_0:
.annotate 'line', 440
    set_addr $I10, alt1359_1
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1342_pos, 1
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    ord $I11, rx1342_tgt, $I11
    ne $I11, 40, rx1342_fail
    add rx1342_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."signature"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1342_pos, 1
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    ord $I11, rx1342_tgt, $I11
    ne $I11, 41, rx1342_fail
    add rx1342_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
    goto alt1359_end
  alt1359_1:
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  alt1359_end:
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 442
    rx1342_cur."!cursor_pos"(rx1342_pos)
    find_lex $P1367, unicode:"$\x{a2}"
    $P1368 = $P1367."MATCH"()
    store_lex "$/", $P1368
    .const 'Sub' $P1370 = "254_1304282286.73" 
    capture_lex $P1370
    $P1372 = $P1370()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 443
  # rx rxquantr1374 ** 0..*
    set_addr $I10, rxquantr1374_done
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxquantr1374_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."trait"()
    unless $P10, rx1342_fail
    goto rxsubrule1375_pass
  rxsubrule1375_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1342_fail
  rxsubrule1375_pass:
    set_addr $I10, rxsubrule1375_back
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1342_pos = $P10."pos"()
    set_addr $I10, rxquantr1374_done
    (rx1342_rep) = rx1342_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1374_done
    rx1342_cur."!mark_push"(rx1342_rep, rx1342_pos, $I10)
    goto rxquantr1374_loop
  rxquantr1374_done:
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  alt1377_0:
.annotate 'line', 444
    set_addr $I10, alt1377_1
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
.annotate 'line', 445
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."onlystar"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
    goto alt1377_end
  alt1377_1:
.annotate 'line', 446
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."blockoid"()
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
  alt1377_end:
.annotate 'line', 447
  # rx subrule "ws" subtype=method negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."ws"()
    unless $P10, rx1342_fail
    rx1342_pos = $P10."pos"()
.annotate 'line', 434
  # rx pass
    rx1342_cur."!cursor_pass"(rx1342_pos, "method_def")
    if_null rx1342_debug, debug_1204
    rx1342_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1342_pos)
  debug_1204:
    .return (rx1342_cur)
  rx1342_restart:
.annotate 'line', 10
    if_null rx1342_debug, debug_1205
    rx1342_cur."!cursor_debug"("NEXT", "method_def")
  debug_1205:
  rx1342_fail:
    (rx1342_rep, rx1342_pos, $I10, $P10) = rx1342_cur."!mark_fail"(0)
    lt rx1342_pos, -1, rx1342_done
    eq rx1342_pos, -1, rx1342_fail
    jump $I10
  rx1342_done:
    rx1342_cur."!cursor_fail"()
    if_null rx1342_debug, debug_1206
    rx1342_cur."!cursor_debug"("FAIL", "method_def")
  debug_1206:
    .return (rx1342_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("253_1304282286.73") :method
.annotate 'line', 10
    $P1344 = self."!PREFIX__!subrule"("ws", "")
    new $P1345, "ResizablePMCArray"
    push $P1345, $P1344
    .return ($P1345)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1369"  :anon :subid("254_1304282286.73") :outer("252_1304282286.73")
.annotate 'line', 442
    new $P1371, "Integer"
    assign $P1371, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1371
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("255_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1384 = self."!PREFIX__!subrule"("ws", "")
    new $P1385, "ResizablePMCArray"
    push $P1385, $P1384
    .return ($P1385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("256_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1394 = "258_1304282286.73" 
    capture_lex $P1394
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_1207
    rx1387_cur."!cursor_debug"("START", "onlystar")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1390_done
    goto rxscan1390_scan
  rxscan1390_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1390_done
  rxscan1390_scan:
    set_addr $I10, rxscan1390_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1390_done:
.annotate 'line', 451
    rx1387_cur."!cursor_pos"(rx1387_pos)
    find_lex $P1391, unicode:"$\x{a2}"
    $P1392 = $P1391."MATCH"()
    store_lex "$/", $P1392
    .const 'Sub' $P1394 = "258_1304282286.73" 
    capture_lex $P1394
    $P1400 = $P1394()
    unless $P1400, rx1387_fail
.annotate 'line', 452
  # rx literal  "{"
    add $I11, rx1387_pos, 1
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    ord $I11, rx1387_tgt, $I11
    ne $I11, 123, rx1387_fail
    add rx1387_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ws"()
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1387_pos, 1
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    ord $I11, rx1387_tgt, $I11
    ne $I11, 42, rx1387_fail
    add rx1387_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ws"()
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1387_pos, 1
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    ord $I11, rx1387_tgt, $I11
    ne $I11, 125, rx1387_fail
    add rx1387_pos, 1
.annotate 'line', 453
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ENDSTMT"()
    unless $P10, rx1387_fail
.annotate 'line', 454
  # rx subrule "finishpad" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."finishpad"()
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
.annotate 'line', 450
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "onlystar")
    if_null rx1387_debug, debug_1210
    rx1387_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1387_pos)
  debug_1210:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 10
    if_null rx1387_debug, debug_1211
    rx1387_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1211:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_1212
    rx1387_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1212:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("257_1304282286.73") :method
.annotate 'line', 10
    new $P1389, "ResizablePMCArray"
    push $P1389, ""
    .return ($P1389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1393"  :anon :subid("258_1304282286.73") :outer("256_1304282286.73")
.annotate 'line', 451
    find_dynamic_lex $P1397, "$*MULTINESS"
    unless_null $P1397, vivify_1208
    get_hll_global $P1395, "GLOBAL"
    get_who $P1396, $P1395
    set $P1397, $P1396["$MULTINESS"]
    unless_null $P1397, vivify_1209
    die "Contextual $*MULTINESS not found"
  vivify_1209:
  vivify_1208:
    set $S1398, $P1397
    iseq $I1399, $S1398, "proto"
    .return ($I1399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("259_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1402, "ResizablePMCArray"
    push $P1402, ""
    .return ($P1402)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("260_1304282286.73")
    .param pmc param_1404
.annotate 'line', 457
    .lex "self", param_1404
    $P1405 = param_1404."!protoregex"("multi_declarator")
    .return ($P1405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("261_1304282286.73")
    .param pmc param_1407
.annotate 'line', 457
    .lex "self", param_1407
    $P1408 = param_1407."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("262_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 459
    new $P1410, "Undef"
    .lex "$*MULTINESS", $P1410
.annotate 'line', 10
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_1213
    rx1411_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1213:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1415_done
    goto rxscan1415_scan
  rxscan1415_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1415_done
  rxscan1415_scan:
    set_addr $I10, rxscan1415_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1415_done:
.annotate 'line', 459
    rx1411_cur."!cursor_pos"(rx1411_pos)
    new $P1416, "String"
    assign $P1416, "multi"
    store_lex "$*MULTINESS", $P1416
.annotate 'line', 460
  # rx subcapture "sym"
    set_addr $I10, rxcap_1417_fail
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1411_pos, 5
    gt $I11, rx1411_eos, rx1411_fail
    sub $I11, rx1411_pos, rx1411_off
    substr $S10, rx1411_tgt, $I11, 5
    ne $S10, "multi", rx1411_fail
    add rx1411_pos, 5
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1411_cur."!mark_peek"($I10)
    rx1411_cur."!cursor_pos"($I11)
    ($P10) = rx1411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1411_pos, "")
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1411_fail
  rxcap_1417_done:
.annotate 'line', 461
  # rx subrule "ws" subtype=method negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."ws"()
    unless $P10, rx1411_fail
    rx1411_pos = $P10."pos"()
  alt1418_0:
    set_addr $I10, alt1418_1
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."declarator"()
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1411_pos = $P10."pos"()
    goto alt1418_end
  alt1418_1:
    set_addr $I10, alt1418_2
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."routine_def"()
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1411_pos = $P10."pos"()
    goto alt1418_end
  alt1418_2:
  # rx subrule "panic" subtype=method negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."panic"("Malformed multi")
    unless $P10, rx1411_fail
    rx1411_pos = $P10."pos"()
  alt1418_end:
.annotate 'line', 458
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "multi_declarator:sym<multi>")
    if_null rx1411_debug, debug_1214
    rx1411_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1411_pos)
  debug_1214:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 10
    if_null rx1411_debug, debug_1215
    rx1411_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1215:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_1216
    rx1411_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1216:
    .return (rx1411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("263_1304282286.73") :method
.annotate 'line', 10
    $P1413 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1414, "ResizablePMCArray"
    push $P1414, $P1413
    .return ($P1414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("264_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1420 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1421, "ResizablePMCArray"
    push $P1421, $P1420
    .return ($P1421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("265_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 464
    new $P1423, "Undef"
    .lex "$*MULTINESS", $P1423
.annotate 'line', 10
    .local string rx1424_tgt
    .local int rx1424_pos
    .local int rx1424_off
    .local int rx1424_eos
    .local int rx1424_rep
    .local pmc rx1424_cur
    .local pmc rx1424_debug
    (rx1424_cur, rx1424_pos, rx1424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1424_cur
    .local pmc match
    .lex "$/", match
    length rx1424_eos, rx1424_tgt
    gt rx1424_pos, rx1424_eos, rx1424_done
    set rx1424_off, 0
    lt rx1424_pos, 2, rx1424_start
    sub rx1424_off, rx1424_pos, 1
    substr rx1424_tgt, rx1424_tgt, rx1424_off
  rx1424_start:
    eq $I10, 1, rx1424_restart
    if_null rx1424_debug, debug_1217
    rx1424_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1217:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1428_done
    goto rxscan1428_scan
  rxscan1428_loop:
    (rx1424_pos) = rx1424_cur."from"()
    inc rx1424_pos
    rx1424_cur."!cursor_from"(rx1424_pos)
    ge rx1424_pos, rx1424_eos, rxscan1428_done
  rxscan1428_scan:
    set_addr $I10, rxscan1428_loop
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  rxscan1428_done:
.annotate 'line', 464
    rx1424_cur."!cursor_pos"(rx1424_pos)
    new $P1429, "String"
    assign $P1429, "proto"
    store_lex "$*MULTINESS", $P1429
.annotate 'line', 465
  # rx subcapture "sym"
    set_addr $I10, rxcap_1430_fail
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1424_pos, 5
    gt $I11, rx1424_eos, rx1424_fail
    sub $I11, rx1424_pos, rx1424_off
    substr $S10, rx1424_tgt, $I11, 5
    ne $S10, "proto", rx1424_fail
    add rx1424_pos, 5
    set_addr $I10, rxcap_1430_fail
    ($I12, $I11) = rx1424_cur."!mark_peek"($I10)
    rx1424_cur."!cursor_pos"($I11)
    ($P10) = rx1424_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1424_pos, "")
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1430_done
  rxcap_1430_fail:
    goto rx1424_fail
  rxcap_1430_done:
.annotate 'line', 466
  # rx subrule "ws" subtype=method negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."ws"()
    unless $P10, rx1424_fail
    rx1424_pos = $P10."pos"()
  alt1431_0:
    set_addr $I10, alt1431_1
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."declarator"()
    unless $P10, rx1424_fail
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1424_pos = $P10."pos"()
    goto alt1431_end
  alt1431_1:
    set_addr $I10, alt1431_2
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."routine_def"()
    unless $P10, rx1424_fail
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1424_pos = $P10."pos"()
    goto alt1431_end
  alt1431_2:
  # rx subrule "panic" subtype=method negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."panic"("Malformed proto")
    unless $P10, rx1424_fail
    rx1424_pos = $P10."pos"()
  alt1431_end:
.annotate 'line', 463
  # rx pass
    rx1424_cur."!cursor_pass"(rx1424_pos, "multi_declarator:sym<proto>")
    if_null rx1424_debug, debug_1218
    rx1424_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1424_pos)
  debug_1218:
    .return (rx1424_cur)
  rx1424_restart:
.annotate 'line', 10
    if_null rx1424_debug, debug_1219
    rx1424_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1219:
  rx1424_fail:
    (rx1424_rep, rx1424_pos, $I10, $P10) = rx1424_cur."!mark_fail"(0)
    lt rx1424_pos, -1, rx1424_done
    eq rx1424_pos, -1, rx1424_fail
    jump $I10
  rx1424_done:
    rx1424_cur."!cursor_fail"()
    if_null rx1424_debug, debug_1220
    rx1424_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1220:
    .return (rx1424_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("266_1304282286.73") :method
.annotate 'line', 10
    $P1426 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1427, "ResizablePMCArray"
    push $P1427, $P1426
    .return ($P1427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("267_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1433 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1434, "ResizablePMCArray"
    push $P1434, $P1433
    .return ($P1434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("268_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 469
    new $P1436, "Undef"
    .lex "$*MULTINESS", $P1436
.annotate 'line', 10
    .local string rx1437_tgt
    .local int rx1437_pos
    .local int rx1437_off
    .local int rx1437_eos
    .local int rx1437_rep
    .local pmc rx1437_cur
    .local pmc rx1437_debug
    (rx1437_cur, rx1437_pos, rx1437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1437_cur
    .local pmc match
    .lex "$/", match
    length rx1437_eos, rx1437_tgt
    gt rx1437_pos, rx1437_eos, rx1437_done
    set rx1437_off, 0
    lt rx1437_pos, 2, rx1437_start
    sub rx1437_off, rx1437_pos, 1
    substr rx1437_tgt, rx1437_tgt, rx1437_off
  rx1437_start:
    eq $I10, 1, rx1437_restart
    if_null rx1437_debug, debug_1221
    rx1437_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1221:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1441_done
    goto rxscan1441_scan
  rxscan1441_loop:
    (rx1437_pos) = rx1437_cur."from"()
    inc rx1437_pos
    rx1437_cur."!cursor_from"(rx1437_pos)
    ge rx1437_pos, rx1437_eos, rxscan1441_done
  rxscan1441_scan:
    set_addr $I10, rxscan1441_loop
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  rxscan1441_done:
.annotate 'line', 469
    rx1437_cur."!cursor_pos"(rx1437_pos)
    new $P1442, "String"
    assign $P1442, ""
    store_lex "$*MULTINESS", $P1442
.annotate 'line', 470
  # rx subrule "declarator" subtype=capture negate=
    rx1437_cur."!cursor_pos"(rx1437_pos)
    $P10 = rx1437_cur."declarator"()
    unless $P10, rx1437_fail
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1437_pos = $P10."pos"()
.annotate 'line', 468
  # rx pass
    rx1437_cur."!cursor_pass"(rx1437_pos, "multi_declarator:sym<null>")
    if_null rx1437_debug, debug_1222
    rx1437_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1437_pos)
  debug_1222:
    .return (rx1437_cur)
  rx1437_restart:
.annotate 'line', 10
    if_null rx1437_debug, debug_1223
    rx1437_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1223:
  rx1437_fail:
    (rx1437_rep, rx1437_pos, $I10, $P10) = rx1437_cur."!mark_fail"(0)
    lt rx1437_pos, -1, rx1437_done
    eq rx1437_pos, -1, rx1437_fail
    jump $I10
  rx1437_done:
    rx1437_cur."!cursor_fail"()
    if_null rx1437_debug, debug_1224
    rx1437_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1224:
    .return (rx1437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("269_1304282286.73") :method
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("declarator", "")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("270_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1444 = self."!PREFIX__!subrule"("declarator", "")
    new $P1445, "ResizablePMCArray"
    push $P1445, $P1444
    .return ($P1445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("271_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1455 = "273_1304282286.73" 
    capture_lex $P1455
    .local string rx1447_tgt
    .local int rx1447_pos
    .local int rx1447_off
    .local int rx1447_eos
    .local int rx1447_rep
    .local pmc rx1447_cur
    .local pmc rx1447_debug
    (rx1447_cur, rx1447_pos, rx1447_tgt, $I10) = self."!cursor_start"()
    rx1447_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1447_cur
    .local pmc match
    .lex "$/", match
    length rx1447_eos, rx1447_tgt
    gt rx1447_pos, rx1447_eos, rx1447_done
    set rx1447_off, 0
    lt rx1447_pos, 2, rx1447_start
    sub rx1447_off, rx1447_pos, 1
    substr rx1447_tgt, rx1447_tgt, rx1447_off
  rx1447_start:
    eq $I10, 1, rx1447_restart
    if_null rx1447_debug, debug_1225
    rx1447_cur."!cursor_debug"("START", "signature")
  debug_1225:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1447_pos) = rx1447_cur."from"()
    inc rx1447_pos
    rx1447_cur."!cursor_from"(rx1447_pos)
    ge rx1447_pos, rx1447_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxscan1450_done:
.annotate 'line', 474
  # rx rxquantr1451 ** 0..1
    set_addr $I10, rxquantr1451_done
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxquantr1451_loop:
    rx1447_cur."!cursor_pos"(rx1447_pos)
    find_lex $P1452, unicode:"$\x{a2}"
    $P1453 = $P1452."MATCH"()
    store_lex "$/", $P1453
    .const 'Sub' $P1455 = "273_1304282286.73" 
    capture_lex $P1455
    $P1459 = $P1455()
    unless $P1459, rx1447_fail
  # rx subrule "ws" subtype=method negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."ws"()
    unless $P10, rx1447_fail
    rx1447_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."parameter"()
    unless $P10, rx1447_fail
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."ws"()
    unless $P10, rx1447_fail
    rx1447_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1447_pos, 1
    gt $I11, rx1447_eos, rx1447_fail
    sub $I11, rx1447_pos, rx1447_off
    ord $I11, rx1447_tgt, $I11
    ne $I11, 58, rx1447_fail
    add rx1447_pos, 1
    set_addr $I10, rxquantr1451_done
    (rx1447_rep) = rx1447_cur."!mark_commit"($I10)
  rxquantr1451_done:
.annotate 'line', 475
  # rx rxquantr1460 ** 0..1
    set_addr $I10, rxquantr1460_done
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxquantr1460_loop:
  # rx rxquantr1461 ** 1..*
    set_addr $I10, rxquantr1461_done
    rx1447_cur."!mark_push"(0, -1, $I10)
  rxquantr1461_loop:
  # rx subrule "ws" subtype=method negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."ws"()
    unless $P10, rx1447_fail
    rx1447_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."parameter"()
    unless $P10, rx1447_fail
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."ws"()
    unless $P10, rx1447_fail
    rx1447_pos = $P10."pos"()
    set_addr $I10, rxquantr1461_done
    (rx1447_rep) = rx1447_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1461_done
    rx1447_cur."!mark_push"(rx1447_rep, rx1447_pos, $I10)
  # rx literal  ","
    add $I11, rx1447_pos, 1
    gt $I11, rx1447_eos, rx1447_fail
    sub $I11, rx1447_pos, rx1447_off
    ord $I11, rx1447_tgt, $I11
    ne $I11, 44, rx1447_fail
    add rx1447_pos, 1
    goto rxquantr1461_loop
  rxquantr1461_done:
    set_addr $I10, rxquantr1460_done
    (rx1447_rep) = rx1447_cur."!mark_commit"($I10)
  rxquantr1460_done:
.annotate 'line', 473
  # rx pass
    rx1447_cur."!cursor_pass"(rx1447_pos, "signature")
    if_null rx1447_debug, debug_1228
    rx1447_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1447_pos)
  debug_1228:
    .return (rx1447_cur)
  rx1447_restart:
.annotate 'line', 10
    if_null rx1447_debug, debug_1229
    rx1447_cur."!cursor_debug"("NEXT", "signature")
  debug_1229:
  rx1447_fail:
    (rx1447_rep, rx1447_pos, $I10, $P10) = rx1447_cur."!mark_fail"(0)
    lt rx1447_pos, -1, rx1447_done
    eq rx1447_pos, -1, rx1447_fail
    jump $I10
  rx1447_done:
    rx1447_cur."!cursor_fail"()
    if_null rx1447_debug, debug_1230
    rx1447_cur."!cursor_debug"("FAIL", "signature")
  debug_1230:
    .return (rx1447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("272_1304282286.73") :method
.annotate 'line', 10
    new $P1449, "ResizablePMCArray"
    push $P1449, ""
    .return ($P1449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1454"  :anon :subid("273_1304282286.73") :outer("271_1304282286.73")
.annotate 'line', 474
    find_dynamic_lex $P1458, "$*INVOCANT_OK"
    unless_null $P1458, vivify_1226
    get_hll_global $P1456, "GLOBAL"
    get_who $P1457, $P1456
    set $P1458, $P1457["$INVOCANT_OK"]
    unless_null $P1458, vivify_1227
    die "Contextual $*INVOCANT_OK not found"
  vivify_1227:
  vivify_1226:
    .return ($P1458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("274_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1463, "ResizablePMCArray"
    push $P1463, ""
    .return ($P1463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("275_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1465_tgt
    .local int rx1465_pos
    .local int rx1465_off
    .local int rx1465_eos
    .local int rx1465_rep
    .local pmc rx1465_cur
    .local pmc rx1465_debug
    (rx1465_cur, rx1465_pos, rx1465_tgt, $I10) = self."!cursor_start"()
    rx1465_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1465_cur
    .local pmc match
    .lex "$/", match
    length rx1465_eos, rx1465_tgt
    gt rx1465_pos, rx1465_eos, rx1465_done
    set rx1465_off, 0
    lt rx1465_pos, 2, rx1465_start
    sub rx1465_off, rx1465_pos, 1
    substr rx1465_tgt, rx1465_tgt, rx1465_off
  rx1465_start:
    eq $I10, 1, rx1465_restart
    if_null rx1465_debug, debug_1231
    rx1465_cur."!cursor_debug"("START", "parameter")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1468_done
    goto rxscan1468_scan
  rxscan1468_loop:
    (rx1465_pos) = rx1465_cur."from"()
    inc rx1465_pos
    rx1465_cur."!cursor_from"(rx1465_pos)
    ge rx1465_pos, rx1465_eos, rxscan1468_done
  rxscan1468_scan:
    set_addr $I10, rxscan1468_loop
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxscan1468_done:
.annotate 'line', 479
  # rx rxquantr1469 ** 0..*
    set_addr $I10, rxquantr1469_done
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxquantr1469_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."typename"()
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1465_pos = $P10."pos"()
  # rx rxquantr1470 ** 0..1
    set_addr $I10, rxquantr1470_done
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxquantr1470_loop:
  # rx literal  ":"
    add $I11, rx1465_pos, 1
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    ord $I11, rx1465_tgt, $I11
    ne $I11, 58, rx1465_fail
    add rx1465_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1471_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1465_pos, rx1465_eos, rx1465_fail
    sub $I10, rx1465_pos, rx1465_off
    substr $S10, rx1465_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1465_fail
    inc rx1465_pos
    set_addr $I10, rxcap_1471_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1471_done
  rxcap_1471_fail:
    goto rx1465_fail
  rxcap_1471_done:
    set_addr $I10, rxquantr1470_done
    (rx1465_rep) = rx1465_cur."!mark_commit"($I10)
  rxquantr1470_done:
  # rx subrule "ws" subtype=method negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."ws"()
    unless $P10, rx1465_fail
    rx1465_pos = $P10."pos"()
    set_addr $I10, rxquantr1469_done
    (rx1465_rep) = rx1465_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1469_done
    rx1465_cur."!mark_push"(rx1465_rep, rx1465_pos, $I10)
    goto rxquantr1469_loop
  rxquantr1469_done:
  alt1472_0:
.annotate 'line', 480
    set_addr $I10, alt1472_1
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
.annotate 'line', 481
  # rx subcapture "quant"
    set_addr $I10, rxcap_1473_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "*"
    add $I11, rx1465_pos, 1
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    ord $I11, rx1465_tgt, $I11
    ne $I11, 42, rx1465_fail
    add rx1465_pos, 1
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1465_fail
  rxcap_1473_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."param_var"()
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1465_pos = $P10."pos"()
    goto alt1472_end
  alt1472_1:
  alt1474_0:
.annotate 'line', 482
    set_addr $I10, alt1474_1
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."param_var"()
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1465_pos = $P10."pos"()
    goto alt1474_end
  alt1474_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."named_param"()
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1465_pos = $P10."pos"()
  alt1474_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1476_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  alt1475_0:
    set_addr $I10, alt1475_1
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "?"
    add $I11, rx1465_pos, 1
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    ord $I11, rx1465_tgt, $I11
    ne $I11, 63, rx1465_fail
    add rx1465_pos, 1
    goto alt1475_end
  alt1475_1:
    set_addr $I10, alt1475_2
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "!"
    add $I11, rx1465_pos, 1
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    ord $I11, rx1465_tgt, $I11
    ne $I11, 33, rx1465_fail
    add rx1465_pos, 1
    goto alt1475_end
  alt1475_2:
  alt1475_end:
    set_addr $I10, rxcap_1476_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1476_done
  rxcap_1476_fail:
    goto rx1465_fail
  rxcap_1476_done:
  alt1472_end:
.annotate 'line', 484
  # rx rxquantr1477 ** 0..1
    set_addr $I10, rxquantr1477_done
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxquantr1477_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."default_value"()
    unless $P10, rx1465_fail
    goto rxsubrule1478_pass
  rxsubrule1478_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1465_fail
  rxsubrule1478_pass:
    set_addr $I10, rxsubrule1478_back
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1465_pos = $P10."pos"()
    set_addr $I10, rxquantr1477_done
    (rx1465_rep) = rx1465_cur."!mark_commit"($I10)
  rxquantr1477_done:
.annotate 'line', 478
  # rx pass
    rx1465_cur."!cursor_pass"(rx1465_pos, "parameter")
    if_null rx1465_debug, debug_1232
    rx1465_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1465_pos)
  debug_1232:
    .return (rx1465_cur)
  rx1465_restart:
.annotate 'line', 10
    if_null rx1465_debug, debug_1233
    rx1465_cur."!cursor_debug"("NEXT", "parameter")
  debug_1233:
  rx1465_fail:
    (rx1465_rep, rx1465_pos, $I10, $P10) = rx1465_cur."!mark_fail"(0)
    lt rx1465_pos, -1, rx1465_done
    eq rx1465_pos, -1, rx1465_fail
    jump $I10
  rx1465_done:
    rx1465_cur."!cursor_fail"()
    if_null rx1465_debug, debug_1234
    rx1465_cur."!cursor_debug"("FAIL", "parameter")
  debug_1234:
    .return (rx1465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("276_1304282286.73") :method
.annotate 'line', 10
    new $P1467, "ResizablePMCArray"
    push $P1467, ""
    .return ($P1467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("277_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1480, "ResizablePMCArray"
    push $P1480, ""
    .return ($P1480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("278_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    rx1482_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1235
    rx1482_cur."!cursor_debug"("START", "param_var")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 488
  # rx subrule "sigil" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."sigil"()
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1482_pos = $P10."pos"()
  # rx rxquantr1487 ** 0..1
    set_addr $I10, rxquantr1487_done
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxquantr1487_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."twigil"()
    unless $P10, rx1482_fail
    goto rxsubrule1488_pass
  rxsubrule1488_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1482_fail
  rxsubrule1488_pass:
    set_addr $I10, rxsubrule1488_back
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1482_pos = $P10."pos"()
    set_addr $I10, rxquantr1487_done
    (rx1482_rep) = rx1482_cur."!mark_commit"($I10)
  rxquantr1487_done:
  alt1489_0:
.annotate 'line', 489
    set_addr $I10, alt1489_1
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."ident"()
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1482_pos = $P10."pos"()
    goto alt1489_end
  alt1489_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1490_fail
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1482_pos, rx1482_eos, rx1482_fail
    sub $I10, rx1482_pos, rx1482_off
    substr $S10, rx1482_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1482_fail
    inc rx1482_pos
    set_addr $I10, rxcap_1490_fail
    ($I12, $I11) = rx1482_cur."!mark_peek"($I10)
    rx1482_cur."!cursor_pos"($I11)
    ($P10) = rx1482_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1482_pos, "")
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1490_done
  rxcap_1490_fail:
    goto rx1482_fail
  rxcap_1490_done:
  alt1489_end:
.annotate 'line', 487
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "param_var")
    if_null rx1482_debug, debug_1236
    rx1482_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1482_pos)
  debug_1236:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 10
    if_null rx1482_debug, debug_1237
    rx1482_cur."!cursor_debug"("NEXT", "param_var")
  debug_1237:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1238
    rx1482_cur."!cursor_debug"("FAIL", "param_var")
  debug_1238:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("279_1304282286.73") :method
.annotate 'line', 10
    $P1484 = self."!PREFIX__!subrule"("sigil", "")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("280_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1492 = self."!PREFIX__!subrule"("sigil", "")
    new $P1493, "ResizablePMCArray"
    push $P1493, $P1492
    .return ($P1493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("281_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1495_tgt
    .local int rx1495_pos
    .local int rx1495_off
    .local int rx1495_eos
    .local int rx1495_rep
    .local pmc rx1495_cur
    .local pmc rx1495_debug
    (rx1495_cur, rx1495_pos, rx1495_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1495_cur
    .local pmc match
    .lex "$/", match
    length rx1495_eos, rx1495_tgt
    gt rx1495_pos, rx1495_eos, rx1495_done
    set rx1495_off, 0
    lt rx1495_pos, 2, rx1495_start
    sub rx1495_off, rx1495_pos, 1
    substr rx1495_tgt, rx1495_tgt, rx1495_off
  rx1495_start:
    eq $I10, 1, rx1495_restart
    if_null rx1495_debug, debug_1239
    rx1495_cur."!cursor_debug"("START", "named_param")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1499_done
    goto rxscan1499_scan
  rxscan1499_loop:
    (rx1495_pos) = rx1495_cur."from"()
    inc rx1495_pos
    rx1495_cur."!cursor_from"(rx1495_pos)
    ge rx1495_pos, rx1495_eos, rxscan1499_done
  rxscan1499_scan:
    set_addr $I10, rxscan1499_loop
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  rxscan1499_done:
.annotate 'line', 493
  # rx literal  ":"
    add $I11, rx1495_pos, 1
    gt $I11, rx1495_eos, rx1495_fail
    sub $I11, rx1495_pos, rx1495_off
    ord $I11, rx1495_tgt, $I11
    ne $I11, 58, rx1495_fail
    add rx1495_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."param_var"()
    unless $P10, rx1495_fail
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1495_pos = $P10."pos"()
.annotate 'line', 492
  # rx pass
    rx1495_cur."!cursor_pass"(rx1495_pos, "named_param")
    if_null rx1495_debug, debug_1240
    rx1495_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1495_pos)
  debug_1240:
    .return (rx1495_cur)
  rx1495_restart:
.annotate 'line', 10
    if_null rx1495_debug, debug_1241
    rx1495_cur."!cursor_debug"("NEXT", "named_param")
  debug_1241:
  rx1495_fail:
    (rx1495_rep, rx1495_pos, $I10, $P10) = rx1495_cur."!mark_fail"(0)
    lt rx1495_pos, -1, rx1495_done
    eq rx1495_pos, -1, rx1495_fail
    jump $I10
  rx1495_done:
    rx1495_cur."!cursor_fail"()
    if_null rx1495_debug, debug_1242
    rx1495_cur."!cursor_debug"("FAIL", "named_param")
  debug_1242:
    .return (rx1495_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("282_1304282286.73") :method
.annotate 'line', 10
    $P1497 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1498, "ResizablePMCArray"
    push $P1498, $P1497
    .return ($P1498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("283_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1501 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1502, "ResizablePMCArray"
    push $P1502, $P1501
    .return ($P1502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("284_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1504_tgt
    .local int rx1504_pos
    .local int rx1504_off
    .local int rx1504_eos
    .local int rx1504_rep
    .local pmc rx1504_cur
    .local pmc rx1504_debug
    (rx1504_cur, rx1504_pos, rx1504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1504_cur
    .local pmc match
    .lex "$/", match
    length rx1504_eos, rx1504_tgt
    gt rx1504_pos, rx1504_eos, rx1504_done
    set rx1504_off, 0
    lt rx1504_pos, 2, rx1504_start
    sub rx1504_off, rx1504_pos, 1
    substr rx1504_tgt, rx1504_tgt, rx1504_off
  rx1504_start:
    eq $I10, 1, rx1504_restart
    if_null rx1504_debug, debug_1243
    rx1504_cur."!cursor_debug"("START", "default_value")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1508_done
    goto rxscan1508_scan
  rxscan1508_loop:
    (rx1504_pos) = rx1504_cur."from"()
    inc rx1504_pos
    rx1504_cur."!cursor_from"(rx1504_pos)
    ge rx1504_pos, rx1504_eos, rxscan1508_done
  rxscan1508_scan:
    set_addr $I10, rxscan1508_loop
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  rxscan1508_done:
.annotate 'line', 496
  # rx subrule "ws" subtype=method negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."ws"()
    unless $P10, rx1504_fail
    rx1504_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1504_pos, 1
    gt $I11, rx1504_eos, rx1504_fail
    sub $I11, rx1504_pos, rx1504_off
    ord $I11, rx1504_tgt, $I11
    ne $I11, 61, rx1504_fail
    add rx1504_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."ws"()
    unless $P10, rx1504_fail
    rx1504_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."EXPR"("i=")
    unless $P10, rx1504_fail
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1504_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."ws"()
    unless $P10, rx1504_fail
    rx1504_pos = $P10."pos"()
  # rx pass
    rx1504_cur."!cursor_pass"(rx1504_pos, "default_value")
    if_null rx1504_debug, debug_1244
    rx1504_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1504_pos)
  debug_1244:
    .return (rx1504_cur)
  rx1504_restart:
.annotate 'line', 10
    if_null rx1504_debug, debug_1245
    rx1504_cur."!cursor_debug"("NEXT", "default_value")
  debug_1245:
  rx1504_fail:
    (rx1504_rep, rx1504_pos, $I10, $P10) = rx1504_cur."!mark_fail"(0)
    lt rx1504_pos, -1, rx1504_done
    eq rx1504_pos, -1, rx1504_fail
    jump $I10
  rx1504_done:
    rx1504_cur."!cursor_fail"()
    if_null rx1504_debug, debug_1246
    rx1504_cur."!cursor_debug"("FAIL", "default_value")
  debug_1246:
    .return (rx1504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("285_1304282286.73") :method
.annotate 'line', 10
    $P1506 = self."!PREFIX__!subrule"("ws", "")
    new $P1507, "ResizablePMCArray"
    push $P1507, $P1506
    .return ($P1507)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("286_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1513 = self."!PREFIX__!subrule"("ws", "")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("287_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1516_tgt
    .local int rx1516_pos
    .local int rx1516_off
    .local int rx1516_eos
    .local int rx1516_rep
    .local pmc rx1516_cur
    .local pmc rx1516_debug
    (rx1516_cur, rx1516_pos, rx1516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1516_cur
    .local pmc match
    .lex "$/", match
    length rx1516_eos, rx1516_tgt
    gt rx1516_pos, rx1516_eos, rx1516_done
    set rx1516_off, 0
    lt rx1516_pos, 2, rx1516_start
    sub rx1516_off, rx1516_pos, 1
    substr rx1516_tgt, rx1516_tgt, rx1516_off
  rx1516_start:
    eq $I10, 1, rx1516_restart
    if_null rx1516_debug, debug_1247
    rx1516_cur."!cursor_debug"("START", "trait")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1516_pos) = rx1516_cur."from"()
    inc rx1516_pos
    rx1516_cur."!cursor_from"(rx1516_pos)
    ge rx1516_pos, rx1516_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  rxscan1520_done:
.annotate 'line', 498
  # rx subrule "ws" subtype=method negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."ws"()
    unless $P10, rx1516_fail
    rx1516_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."trait_mod"()
    unless $P10, rx1516_fail
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1516_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."ws"()
    unless $P10, rx1516_fail
    rx1516_pos = $P10."pos"()
  # rx pass
    rx1516_cur."!cursor_pass"(rx1516_pos, "trait")
    if_null rx1516_debug, debug_1248
    rx1516_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1516_pos)
  debug_1248:
    .return (rx1516_cur)
  rx1516_restart:
.annotate 'line', 10
    if_null rx1516_debug, debug_1249
    rx1516_cur."!cursor_debug"("NEXT", "trait")
  debug_1249:
  rx1516_fail:
    (rx1516_rep, rx1516_pos, $I10, $P10) = rx1516_cur."!mark_fail"(0)
    lt rx1516_pos, -1, rx1516_done
    eq rx1516_pos, -1, rx1516_fail
    jump $I10
  rx1516_done:
    rx1516_cur."!cursor_fail"()
    if_null rx1516_debug, debug_1250
    rx1516_cur."!cursor_debug"("FAIL", "trait")
  debug_1250:
    .return (rx1516_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("288_1304282286.73") :method
.annotate 'line', 10
    $P1518 = self."!PREFIX__!subrule"("ws", "")
    new $P1519, "ResizablePMCArray"
    push $P1519, $P1518
    .return ($P1519)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("289_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1524 = self."!PREFIX__!subrule"("ws", "")
    new $P1525, "ResizablePMCArray"
    push $P1525, $P1524
    .return ($P1525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("290_1304282286.73")
    .param pmc param_1527
.annotate 'line', 500
    .lex "self", param_1527
    $P1528 = param_1527."!protoregex"("trait_mod")
    .return ($P1528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("291_1304282286.73")
    .param pmc param_1530
.annotate 'line', 500
    .lex "self", param_1530
    $P1531 = param_1530."!PREFIX__!protoregex"("trait_mod")
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("292_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    rx1533_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1251
    rx1533_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1537_done
    goto rxscan1537_scan
  rxscan1537_loop:
    (rx1533_pos) = rx1533_cur."from"()
    inc rx1533_pos
    rx1533_cur."!cursor_from"(rx1533_pos)
    ge rx1533_pos, rx1533_eos, rxscan1537_done
  rxscan1537_scan:
    set_addr $I10, rxscan1537_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1537_done:
.annotate 'line', 501
  # rx subcapture "sym"
    set_addr $I10, rxcap_1538_fail
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  # rx literal  "is"
    add $I11, rx1533_pos, 2
    gt $I11, rx1533_eos, rx1533_fail
    sub $I11, rx1533_pos, rx1533_off
    substr $S10, rx1533_tgt, $I11, 2
    ne $S10, "is", rx1533_fail
    add rx1533_pos, 2
    set_addr $I10, rxcap_1538_fail
    ($I12, $I11) = rx1533_cur."!mark_peek"($I10)
    rx1533_cur."!cursor_pos"($I11)
    ($P10) = rx1533_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1533_pos, "")
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1538_done
  rxcap_1538_fail:
    goto rx1533_fail
  rxcap_1538_done:
  # rx subrule "ws" subtype=method negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."ws"()
    unless $P10, rx1533_fail
    rx1533_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."deflongname"()
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1533_pos = $P10."pos"()
  # rx rxquantr1540 ** 0..1
    set_addr $I10, rxquantr1540_done
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxquantr1540_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."circumfix"()
    unless $P10, rx1533_fail
    goto rxsubrule1541_pass
  rxsubrule1541_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1533_fail
  rxsubrule1541_pass:
    set_addr $I10, rxsubrule1541_back
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1533_pos = $P10."pos"()
    set_addr $I10, rxquantr1540_done
    (rx1533_rep) = rx1533_cur."!mark_commit"($I10)
  rxquantr1540_done:
  # rx subrule "ws" subtype=method negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."ws"()
    unless $P10, rx1533_fail
    rx1533_pos = $P10."pos"()
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "trait_mod:sym<is>")
    if_null rx1533_debug, debug_1252
    rx1533_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1533_pos)
  debug_1252:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 10
    if_null rx1533_debug, debug_1253
    rx1533_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1253:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1254
    rx1533_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1254:
    .return (rx1533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("293_1304282286.73") :method
.annotate 'line', 10
    $P1535 = self."!PREFIX__!subrule"("ws", "is")
    new $P1536, "ResizablePMCArray"
    push $P1536, $P1535
    .return ($P1536)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("294_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1544 = self."!PREFIX__!subrule"("ws", "is")
    new $P1545, "ResizablePMCArray"
    push $P1545, $P1544
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("295_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1547_tgt
    .local int rx1547_pos
    .local int rx1547_off
    .local int rx1547_eos
    .local int rx1547_rep
    .local pmc rx1547_cur
    .local pmc rx1547_debug
    (rx1547_cur, rx1547_pos, rx1547_tgt, $I10) = self."!cursor_start"()
    rx1547_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1547_cur
    .local pmc match
    .lex "$/", match
    length rx1547_eos, rx1547_tgt
    gt rx1547_pos, rx1547_eos, rx1547_done
    set rx1547_off, 0
    lt rx1547_pos, 2, rx1547_start
    sub rx1547_off, rx1547_pos, 1
    substr rx1547_tgt, rx1547_tgt, rx1547_off
  rx1547_start:
    eq $I10, 1, rx1547_restart
    if_null rx1547_debug, debug_1255
    rx1547_cur."!cursor_debug"("START", "regex_declarator")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1551_done
    goto rxscan1551_scan
  rxscan1551_loop:
    (rx1547_pos) = rx1547_cur."from"()
    inc rx1547_pos
    rx1547_cur."!cursor_from"(rx1547_pos)
    ge rx1547_pos, rx1547_eos, rxscan1551_done
  rxscan1551_scan:
    set_addr $I10, rxscan1551_loop
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  rxscan1551_done:
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  alt1553_0:
.annotate 'line', 504
    set_addr $I10, alt1553_1
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1555_fail
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1547_pos, 5
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 5
    ne $S10, "proto", rx1547_fail
    add rx1547_pos, 5
    set_addr $I10, rxcap_1555_fail
    ($I12, $I11) = rx1547_cur."!mark_peek"($I10)
    rx1547_cur."!cursor_pos"($I11)
    ($P10) = rx1547_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1547_pos, "")
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1555_done
  rxcap_1555_fail:
    goto rx1547_fail
  rxcap_1555_done:
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  alt1557_0:
    set_addr $I10, alt1557_1
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1547_pos, 5
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 5
    ne $S10, "regex", rx1547_fail
    add rx1547_pos, 5
    goto alt1557_end
  alt1557_1:
    set_addr $I10, alt1557_2
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "token"
    add $I11, rx1547_pos, 5
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 5
    ne $S10, "token", rx1547_fail
    add rx1547_pos, 5
    goto alt1557_end
  alt1557_2:
  # rx literal  "rule"
    add $I11, rx1547_pos, 4
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 4
    ne $S10, "rule", rx1547_fail
    add rx1547_pos, 4
  alt1557_end:
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 506
  # rx subrule "deflongname" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."deflongname"()
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1547_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  alt1560_0:
.annotate 'line', 507
    set_addr $I10, alt1560_1
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 123, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1547_pos, 5
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 5
    ne $S10, "<...>", rx1547_fail
    add rx1547_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 125, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ENDSTMT"()
    unless $P10, rx1547_fail
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
    goto alt1560_end
  alt1560_1:
    set_addr $I10, alt1560_2
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
.annotate 'line', 509
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 123, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1547_pos, 3
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 3
    ne $S10, "<*>", rx1547_fail
    add rx1547_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 125, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ENDSTMT"()
    unless $P10, rx1547_fail
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
    goto alt1560_end
  alt1560_2:
.annotate 'line', 510
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  alt1560_end:
.annotate 'line', 511
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 505
    goto alt1553_end
  alt1553_1:
.annotate 'line', 512
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1574_fail
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  alt1573_0:
    set_addr $I10, alt1573_1
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1547_pos, 5
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 5
    ne $S10, "regex", rx1547_fail
    add rx1547_pos, 5
    goto alt1573_end
  alt1573_1:
    set_addr $I10, alt1573_2
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "token"
    add $I11, rx1547_pos, 5
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 5
    ne $S10, "token", rx1547_fail
    add rx1547_pos, 5
    goto alt1573_end
  alt1573_2:
  # rx literal  "rule"
    add $I11, rx1547_pos, 4
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 4
    ne $S10, "rule", rx1547_fail
    add rx1547_pos, 4
  alt1573_end:
    set_addr $I10, rxcap_1574_fail
    ($I12, $I11) = rx1547_cur."!mark_peek"($I10)
    rx1547_cur."!cursor_pos"($I11)
    ($P10) = rx1547_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1547_pos, "")
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1574_done
  rxcap_1574_fail:
    goto rx1547_fail
  rxcap_1574_done:
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 513
  # rx subrule "deflongname" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."deflongname"()
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1547_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 514
  # rx subrule "newpad" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."newpad"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 515
  # rx rxquantr1578 ** 0..1
    set_addr $I10, rxquantr1578_done
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  rxquantr1578_loop:
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 40, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."signature"()
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1547_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 41, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
    set_addr $I10, rxquantr1578_done
    (rx1547_rep) = rx1547_cur."!mark_commit"($I10)
  rxquantr1578_done:
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 516
  # rx reduce name="regex_declarator" key="open"
    rx1547_cur."!cursor_pos"(rx1547_pos)
    rx1547_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 517
  # rx literal  "{"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 123, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1547_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1547_pos, 1
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    ord $I11, rx1547_tgt, $I11
    ne $I11, 125, rx1547_fail
    add rx1547_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ENDSTMT"()
    unless $P10, rx1547_fail
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
  alt1553_end:
.annotate 'line', 518
  # rx subrule "ws" subtype=method negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."ws"()
    unless $P10, rx1547_fail
    rx1547_pos = $P10."pos"()
.annotate 'line', 503
  # rx pass
    rx1547_cur."!cursor_pass"(rx1547_pos, "regex_declarator")
    if_null rx1547_debug, debug_1256
    rx1547_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1547_pos)
  debug_1256:
    .return (rx1547_cur)
  rx1547_restart:
.annotate 'line', 10
    if_null rx1547_debug, debug_1257
    rx1547_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1257:
  rx1547_fail:
    (rx1547_rep, rx1547_pos, $I10, $P10) = rx1547_cur."!mark_fail"(0)
    lt rx1547_pos, -1, rx1547_done
    eq rx1547_pos, -1, rx1547_fail
    jump $I10
  rx1547_done:
    rx1547_cur."!cursor_fail"()
    if_null rx1547_debug, debug_1258
    rx1547_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1258:
    .return (rx1547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("296_1304282286.73") :method
.annotate 'line', 10
    $P1549 = self."!PREFIX__!subrule"("ws", "")
    new $P1550, "ResizablePMCArray"
    push $P1550, $P1549
    .return ($P1550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("297_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1588 = self."!PREFIX__!subrule"("ws", "")
    new $P1589, "ResizablePMCArray"
    push $P1589, $P1588
    .return ($P1589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("298_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    rx1591_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1259
    rx1591_cur."!cursor_debug"("START", "dotty")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 522
  # rx literal  "."
    add $I11, rx1591_pos, 1
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    ord $I11, rx1591_tgt, $I11
    ne $I11, 46, rx1591_fail
    add rx1591_pos, 1
  alt1596_0:
.annotate 'line', 523
    set_addr $I10, alt1596_1
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."deflongname"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1591_pos = $P10."pos"()
    goto alt1596_end
  alt1596_1:
.annotate 'line', 524
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1591_fail
  # rx subrule "quote" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."quote"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1591_pos = $P10."pos"()
  alt1597_0:
.annotate 'line', 525
    set_addr $I10, alt1597_1
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1591_fail
    goto alt1597_end
  alt1597_1:
  # rx subrule "panic" subtype=method negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1591_fail
    rx1591_pos = $P10."pos"()
  alt1597_end:
  alt1596_end:
.annotate 'line', 531
  # rx rxquantr1598 ** 0..1
    set_addr $I10, rxquantr1598_done
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxquantr1598_loop:
  alt1599_0:
.annotate 'line', 528
    set_addr $I10, alt1599_1
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1591_fail
  # rx subrule "args" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."args"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1591_pos = $P10."pos"()
    goto alt1599_end
  alt1599_1:
.annotate 'line', 530
  # rx literal  ":"
    add $I11, rx1591_pos, 1
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    ord $I11, rx1591_tgt, $I11
    ne $I11, 58, rx1591_fail
    add rx1591_pos, 1
  # rx charclass s
    ge rx1591_pos, rx1591_eos, rx1591_fail
    sub $I10, rx1591_pos, rx1591_off
    is_cclass $I11, 32, rx1591_tgt, $I10
    unless $I11, rx1591_fail
    inc rx1591_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."arglist"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1591_pos = $P10."pos"()
  alt1599_end:
.annotate 'line', 531
    set_addr $I10, rxquantr1598_done
    (rx1591_rep) = rx1591_cur."!mark_commit"($I10)
  rxquantr1598_done:
.annotate 'line', 521
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "dotty")
    if_null rx1591_debug, debug_1260
    rx1591_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1591_pos)
  debug_1260:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 10
    if_null rx1591_debug, debug_1261
    rx1591_cur."!cursor_debug"("NEXT", "dotty")
  debug_1261:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1262
    rx1591_cur."!cursor_debug"("FAIL", "dotty")
  debug_1262:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("299_1304282286.73") :method
.annotate 'line', 10
    $P1593 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1594, "ResizablePMCArray"
    push $P1594, "'"
    push $P1594, "\""
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("300_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1601 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1602, "ResizablePMCArray"
    push $P1602, "'"
    push $P1602, "\""
    push $P1602, $P1601
    .return ($P1602)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("301_1304282286.73")
    .param pmc param_1604
.annotate 'line', 535
    .lex "self", param_1604
    $P1605 = param_1604."!protoregex"("term")
    .return ($P1605)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("302_1304282286.73")
    .param pmc param_1607
.annotate 'line', 535
    .lex "self", param_1607
    $P1608 = param_1607."!PREFIX__!protoregex"("term")
    .return ($P1608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("303_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1610_tgt
    .local int rx1610_pos
    .local int rx1610_off
    .local int rx1610_eos
    .local int rx1610_rep
    .local pmc rx1610_cur
    .local pmc rx1610_debug
    (rx1610_cur, rx1610_pos, rx1610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1610_cur
    .local pmc match
    .lex "$/", match
    length rx1610_eos, rx1610_tgt
    gt rx1610_pos, rx1610_eos, rx1610_done
    set rx1610_off, 0
    lt rx1610_pos, 2, rx1610_start
    sub rx1610_off, rx1610_pos, 1
    substr rx1610_tgt, rx1610_tgt, rx1610_off
  rx1610_start:
    eq $I10, 1, rx1610_restart
    if_null rx1610_debug, debug_1263
    rx1610_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1610_pos) = rx1610_cur."from"()
    inc rx1610_pos
    rx1610_cur."!cursor_from"(rx1610_pos)
    ge rx1610_pos, rx1610_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  rxscan1613_done:
.annotate 'line', 537
  # rx subcapture "sym"
    set_addr $I10, rxcap_1614_fail
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  # rx literal  "self"
    add $I11, rx1610_pos, 4
    gt $I11, rx1610_eos, rx1610_fail
    sub $I11, rx1610_pos, rx1610_off
    substr $S10, rx1610_tgt, $I11, 4
    ne $S10, "self", rx1610_fail
    add rx1610_pos, 4
    set_addr $I10, rxcap_1614_fail
    ($I12, $I11) = rx1610_cur."!mark_peek"($I10)
    rx1610_cur."!cursor_pos"($I11)
    ($P10) = rx1610_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1610_pos, "")
    rx1610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1614_done
  rxcap_1614_fail:
    goto rx1610_fail
  rxcap_1614_done:
  # rxanchor rwb
    le rx1610_pos, 0, rx1610_fail
    sub $I10, rx1610_pos, rx1610_off
    is_cclass $I11, 8192, rx1610_tgt, $I10
    if $I11, rx1610_fail
    dec $I10
    is_cclass $I11, 8192, rx1610_tgt, $I10
    unless $I11, rx1610_fail
  # rx pass
    rx1610_cur."!cursor_pass"(rx1610_pos, "term:sym<self>")
    if_null rx1610_debug, debug_1264
    rx1610_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1610_pos)
  debug_1264:
    .return (rx1610_cur)
  rx1610_restart:
.annotate 'line', 10
    if_null rx1610_debug, debug_1265
    rx1610_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1265:
  rx1610_fail:
    (rx1610_rep, rx1610_pos, $I10, $P10) = rx1610_cur."!mark_fail"(0)
    lt rx1610_pos, -1, rx1610_done
    eq rx1610_pos, -1, rx1610_fail
    jump $I10
  rx1610_done:
    rx1610_cur."!cursor_fail"()
    if_null rx1610_debug, debug_1266
    rx1610_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1266:
    .return (rx1610_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("304_1304282286.73") :method
.annotate 'line', 10
    new $P1612, "ResizablePMCArray"
    push $P1612, "self"
    .return ($P1612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("305_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1616, "ResizablePMCArray"
    push $P1616, "self"
    .return ($P1616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("306_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1267
    rx1618_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 540
  # rx subrule "deflongname" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."deflongname"()
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1618_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1618_fail
  # rx subrule "args" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."args"()
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1618_pos = $P10."pos"()
.annotate 'line', 539
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "term:sym<identifier>")
    if_null rx1618_debug, debug_1268
    rx1618_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1618_pos)
  debug_1268:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1269
    rx1618_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1269:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1270
    rx1618_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1270:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("307_1304282286.73") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("308_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1624 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1625, "ResizablePMCArray"
    push $P1625, $P1624
    .return ($P1625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("309_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1627_tgt
    .local int rx1627_pos
    .local int rx1627_off
    .local int rx1627_eos
    .local int rx1627_rep
    .local pmc rx1627_cur
    .local pmc rx1627_debug
    (rx1627_cur, rx1627_pos, rx1627_tgt, $I10) = self."!cursor_start"()
    rx1627_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1627_cur
    .local pmc match
    .lex "$/", match
    length rx1627_eos, rx1627_tgt
    gt rx1627_pos, rx1627_eos, rx1627_done
    set rx1627_off, 0
    lt rx1627_pos, 2, rx1627_start
    sub rx1627_off, rx1627_pos, 1
    substr rx1627_tgt, rx1627_tgt, rx1627_off
  rx1627_start:
    eq $I10, 1, rx1627_restart
    if_null rx1627_debug, debug_1271
    rx1627_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1631_done
    goto rxscan1631_scan
  rxscan1631_loop:
    (rx1627_pos) = rx1627_cur."from"()
    inc rx1627_pos
    rx1627_cur."!cursor_from"(rx1627_pos)
    ge rx1627_pos, rx1627_eos, rxscan1631_done
  rxscan1631_scan:
    set_addr $I10, rxscan1631_loop
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  rxscan1631_done:
.annotate 'line', 544
  # rx subrule "name" subtype=capture negate=
    rx1627_cur."!cursor_pos"(rx1627_pos)
    $P10 = rx1627_cur."name"()
    unless $P10, rx1627_fail
    rx1627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1627_pos = $P10."pos"()
  # rx rxquantr1632 ** 0..1
    set_addr $I10, rxquantr1632_done
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  rxquantr1632_loop:
  # rx subrule "args" subtype=capture negate=
    rx1627_cur."!cursor_pos"(rx1627_pos)
    $P10 = rx1627_cur."args"()
    unless $P10, rx1627_fail
    goto rxsubrule1633_pass
  rxsubrule1633_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1627_fail
  rxsubrule1633_pass:
    set_addr $I10, rxsubrule1633_back
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1627_pos = $P10."pos"()
    set_addr $I10, rxquantr1632_done
    (rx1627_rep) = rx1627_cur."!mark_commit"($I10)
  rxquantr1632_done:
.annotate 'line', 543
  # rx pass
    rx1627_cur."!cursor_pass"(rx1627_pos, "term:sym<name>")
    if_null rx1627_debug, debug_1272
    rx1627_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1627_pos)
  debug_1272:
    .return (rx1627_cur)
  rx1627_restart:
.annotate 'line', 10
    if_null rx1627_debug, debug_1273
    rx1627_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1273:
  rx1627_fail:
    (rx1627_rep, rx1627_pos, $I10, $P10) = rx1627_cur."!mark_fail"(0)
    lt rx1627_pos, -1, rx1627_done
    eq rx1627_pos, -1, rx1627_fail
    jump $I10
  rx1627_done:
    rx1627_cur."!cursor_fail"()
    if_null rx1627_debug, debug_1274
    rx1627_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1274:
    .return (rx1627_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("310_1304282286.73") :method
.annotate 'line', 10
    $P1629 = self."!PREFIX__!subrule"("name", "")
    new $P1630, "ResizablePMCArray"
    push $P1630, $P1629
    .return ($P1630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("311_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1635 = self."!PREFIX__!subrule"("name", "")
    new $P1636, "ResizablePMCArray"
    push $P1636, $P1635
    .return ($P1636)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("312_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1638_tgt
    .local int rx1638_pos
    .local int rx1638_off
    .local int rx1638_eos
    .local int rx1638_rep
    .local pmc rx1638_cur
    .local pmc rx1638_debug
    (rx1638_cur, rx1638_pos, rx1638_tgt, $I10) = self."!cursor_start"()
    rx1638_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1638_cur
    .local pmc match
    .lex "$/", match
    length rx1638_eos, rx1638_tgt
    gt rx1638_pos, rx1638_eos, rx1638_done
    set rx1638_off, 0
    lt rx1638_pos, 2, rx1638_start
    sub rx1638_off, rx1638_pos, 1
    substr rx1638_tgt, rx1638_tgt, rx1638_off
  rx1638_start:
    eq $I10, 1, rx1638_restart
    if_null rx1638_debug, debug_1275
    rx1638_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1638_pos) = rx1638_cur."from"()
    inc rx1638_pos
    rx1638_cur."!cursor_from"(rx1638_pos)
    ge rx1638_pos, rx1638_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10)
  rxscan1641_done:
.annotate 'line', 548
  # rx literal  "pir::"
    add $I11, rx1638_pos, 5
    gt $I11, rx1638_eos, rx1638_fail
    sub $I11, rx1638_pos, rx1638_off
    substr $S10, rx1638_tgt, $I11, 5
    ne $S10, "pir::", rx1638_fail
    add rx1638_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1642_fail
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1638_pos, rx1638_off
    find_not_cclass $I11, 8192, rx1638_tgt, $I10, rx1638_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1638_fail
    add rx1638_pos, rx1638_off, $I11
    set_addr $I10, rxcap_1642_fail
    ($I12, $I11) = rx1638_cur."!mark_peek"($I10)
    rx1638_cur."!cursor_pos"($I11)
    ($P10) = rx1638_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1638_pos, "")
    rx1638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1642_done
  rxcap_1642_fail:
    goto rx1638_fail
  rxcap_1642_done:
  # rx rxquantr1643 ** 0..1
    set_addr $I10, rxquantr1643_done
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10)
  rxquantr1643_loop:
  # rx subrule "args" subtype=capture negate=
    rx1638_cur."!cursor_pos"(rx1638_pos)
    $P10 = rx1638_cur."args"()
    unless $P10, rx1638_fail
    goto rxsubrule1644_pass
  rxsubrule1644_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1638_fail
  rxsubrule1644_pass:
    set_addr $I10, rxsubrule1644_back
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1638_pos = $P10."pos"()
    set_addr $I10, rxquantr1643_done
    (rx1638_rep) = rx1638_cur."!mark_commit"($I10)
  rxquantr1643_done:
.annotate 'line', 547
  # rx pass
    rx1638_cur."!cursor_pass"(rx1638_pos, "term:sym<pir::op>")
    if_null rx1638_debug, debug_1276
    rx1638_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1638_pos)
  debug_1276:
    .return (rx1638_cur)
  rx1638_restart:
.annotate 'line', 10
    if_null rx1638_debug, debug_1277
    rx1638_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1277:
  rx1638_fail:
    (rx1638_rep, rx1638_pos, $I10, $P10) = rx1638_cur."!mark_fail"(0)
    lt rx1638_pos, -1, rx1638_done
    eq rx1638_pos, -1, rx1638_fail
    jump $I10
  rx1638_done:
    rx1638_cur."!cursor_fail"()
    if_null rx1638_debug, debug_1278
    rx1638_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1278:
    .return (rx1638_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("313_1304282286.73") :method
.annotate 'line', 10
    new $P1640, "ResizablePMCArray"
    push $P1640, "pir::"
    .return ($P1640)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("314_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1646, "ResizablePMCArray"
    push $P1646, "pir::"
    .return ($P1646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("315_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P1656 = "317_1304282286.73" 
    capture_lex $P1656
    .local string rx1648_tgt
    .local int rx1648_pos
    .local int rx1648_off
    .local int rx1648_eos
    .local int rx1648_rep
    .local pmc rx1648_cur
    .local pmc rx1648_debug
    (rx1648_cur, rx1648_pos, rx1648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1648_cur
    .local pmc match
    .lex "$/", match
    length rx1648_eos, rx1648_tgt
    gt rx1648_pos, rx1648_eos, rx1648_done
    set rx1648_off, 0
    lt rx1648_pos, 2, rx1648_start
    sub rx1648_off, rx1648_pos, 1
    substr rx1648_tgt, rx1648_tgt, rx1648_off
  rx1648_start:
    eq $I10, 1, rx1648_restart
    if_null rx1648_debug, debug_1279
    rx1648_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1651_done
    goto rxscan1651_scan
  rxscan1651_loop:
    (rx1648_pos) = rx1648_cur."from"()
    inc rx1648_pos
    rx1648_cur."!cursor_from"(rx1648_pos)
    ge rx1648_pos, rx1648_eos, rxscan1651_done
  rxscan1651_scan:
    set_addr $I10, rxscan1651_loop
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
  rxscan1651_done:
.annotate 'line', 552
  # rx literal  "{*}"
    add $I11, rx1648_pos, 3
    gt $I11, rx1648_eos, rx1648_fail
    sub $I11, rx1648_pos, rx1648_off
    substr $S10, rx1648_tgt, $I11, 3
    ne $S10, "{*}", rx1648_fail
    add rx1648_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1648_cur."!cursor_pos"(rx1648_pos)
    $P10 = rx1648_cur."ENDSTMT"()
    unless $P10, rx1648_fail
  alt1652_0:
.annotate 'line', 553
    set_addr $I10, alt1652_1
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
    rx1648_cur."!cursor_pos"(rx1648_pos)
    find_lex $P1653, unicode:"$\x{a2}"
    $P1654 = $P1653."MATCH"()
    store_lex "$/", $P1654
    .const 'Sub' $P1656 = "317_1304282286.73" 
    capture_lex $P1656
    $P1662 = $P1656()
    unless $P1662, rx1648_fail
    goto alt1652_end
  alt1652_1:
  # rx subrule "panic" subtype=method negate=
    rx1648_cur."!cursor_pos"(rx1648_pos)
    $P10 = rx1648_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1648_fail
    rx1648_pos = $P10."pos"()
  alt1652_end:
.annotate 'line', 551
  # rx pass
    rx1648_cur."!cursor_pass"(rx1648_pos, "term:sym<onlystar>")
    if_null rx1648_debug, debug_1282
    rx1648_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1648_pos)
  debug_1282:
    .return (rx1648_cur)
  rx1648_restart:
.annotate 'line', 10
    if_null rx1648_debug, debug_1283
    rx1648_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1283:
  rx1648_fail:
    (rx1648_rep, rx1648_pos, $I10, $P10) = rx1648_cur."!mark_fail"(0)
    lt rx1648_pos, -1, rx1648_done
    eq rx1648_pos, -1, rx1648_fail
    jump $I10
  rx1648_done:
    rx1648_cur."!cursor_fail"()
    if_null rx1648_debug, debug_1284
    rx1648_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1284:
    .return (rx1648_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("316_1304282286.73") :method
.annotate 'line', 10
    new $P1650, "ResizablePMCArray"
    push $P1650, "{*}"
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1655"  :anon :subid("317_1304282286.73") :outer("315_1304282286.73")
.annotate 'line', 553
    find_dynamic_lex $P1659, "$*MULTINESS"
    unless_null $P1659, vivify_1280
    get_hll_global $P1657, "GLOBAL"
    get_who $P1658, $P1657
    set $P1659, $P1658["$MULTINESS"]
    unless_null $P1659, vivify_1281
    die "Contextual $*MULTINESS not found"
  vivify_1281:
  vivify_1280:
    set $S1660, $P1659
    iseq $I1661, $S1660, "proto"
    .return ($I1661)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("318_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1664, "ResizablePMCArray"
    push $P1664, "{*}"
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("319_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1666_tgt
    .local int rx1666_pos
    .local int rx1666_off
    .local int rx1666_eos
    .local int rx1666_rep
    .local pmc rx1666_cur
    .local pmc rx1666_debug
    (rx1666_cur, rx1666_pos, rx1666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1666_cur
    .local pmc match
    .lex "$/", match
    length rx1666_eos, rx1666_tgt
    gt rx1666_pos, rx1666_eos, rx1666_done
    set rx1666_off, 0
    lt rx1666_pos, 2, rx1666_start
    sub rx1666_off, rx1666_pos, 1
    substr rx1666_tgt, rx1666_tgt, rx1666_off
  rx1666_start:
    eq $I10, 1, rx1666_restart
    if_null rx1666_debug, debug_1285
    rx1666_cur."!cursor_debug"("START", "args")
  debug_1285:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1670_done
    goto rxscan1670_scan
  rxscan1670_loop:
    (rx1666_pos) = rx1666_cur."from"()
    inc rx1666_pos
    rx1666_cur."!cursor_from"(rx1666_pos)
    ge rx1666_pos, rx1666_eos, rxscan1670_done
  rxscan1670_scan:
    set_addr $I10, rxscan1670_loop
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  rxscan1670_done:
.annotate 'line', 557
  # rx literal  "("
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 40, rx1666_fail
    add rx1666_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."arglist"()
    unless $P10, rx1666_fail
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1666_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 41, rx1666_fail
    add rx1666_pos, 1
  # rx pass
    rx1666_cur."!cursor_pass"(rx1666_pos, "args")
    if_null rx1666_debug, debug_1286
    rx1666_cur."!cursor_debug"("PASS", "args", " at pos=", rx1666_pos)
  debug_1286:
    .return (rx1666_cur)
  rx1666_restart:
.annotate 'line', 10
    if_null rx1666_debug, debug_1287
    rx1666_cur."!cursor_debug"("NEXT", "args")
  debug_1287:
  rx1666_fail:
    (rx1666_rep, rx1666_pos, $I10, $P10) = rx1666_cur."!mark_fail"(0)
    lt rx1666_pos, -1, rx1666_done
    eq rx1666_pos, -1, rx1666_fail
    jump $I10
  rx1666_done:
    rx1666_cur."!cursor_fail"()
    if_null rx1666_debug, debug_1288
    rx1666_cur."!cursor_debug"("FAIL", "args")
  debug_1288:
    .return (rx1666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("320_1304282286.73") :method
.annotate 'line', 10
    $P1668 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1669, "ResizablePMCArray"
    push $P1669, $P1668
    .return ($P1669)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("321_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1672 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1673, "ResizablePMCArray"
    push $P1673, $P1672
    .return ($P1673)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("322_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1675_tgt
    .local int rx1675_pos
    .local int rx1675_off
    .local int rx1675_eos
    .local int rx1675_rep
    .local pmc rx1675_cur
    .local pmc rx1675_debug
    (rx1675_cur, rx1675_pos, rx1675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1675_cur
    .local pmc match
    .lex "$/", match
    length rx1675_eos, rx1675_tgt
    gt rx1675_pos, rx1675_eos, rx1675_done
    set rx1675_off, 0
    lt rx1675_pos, 2, rx1675_start
    sub rx1675_off, rx1675_pos, 1
    substr rx1675_tgt, rx1675_tgt, rx1675_off
  rx1675_start:
    eq $I10, 1, rx1675_restart
    if_null rx1675_debug, debug_1289
    rx1675_cur."!cursor_debug"("START", "arglist")
  debug_1289:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1679_done
    goto rxscan1679_scan
  rxscan1679_loop:
    (rx1675_pos) = rx1675_cur."from"()
    inc rx1675_pos
    rx1675_cur."!cursor_from"(rx1675_pos)
    ge rx1675_pos, rx1675_eos, rxscan1679_done
  rxscan1679_scan:
    set_addr $I10, rxscan1679_loop
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  rxscan1679_done:
.annotate 'line', 561
  # rx subrule "ws" subtype=method negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."ws"()
    unless $P10, rx1675_fail
    rx1675_pos = $P10."pos"()
  alt1680_0:
.annotate 'line', 562
    set_addr $I10, alt1680_1
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
.annotate 'line', 563
  # rx subrule "EXPR" subtype=capture negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."EXPR"("f=")
    unless $P10, rx1675_fail
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1675_pos = $P10."pos"()
    goto alt1680_end
  alt1680_1:
  alt1680_end:
.annotate 'line', 560
  # rx pass
    rx1675_cur."!cursor_pass"(rx1675_pos, "arglist")
    if_null rx1675_debug, debug_1290
    rx1675_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1675_pos)
  debug_1290:
    .return (rx1675_cur)
  rx1675_restart:
.annotate 'line', 10
    if_null rx1675_debug, debug_1291
    rx1675_cur."!cursor_debug"("NEXT", "arglist")
  debug_1291:
  rx1675_fail:
    (rx1675_rep, rx1675_pos, $I10, $P10) = rx1675_cur."!mark_fail"(0)
    lt rx1675_pos, -1, rx1675_done
    eq rx1675_pos, -1, rx1675_fail
    jump $I10
  rx1675_done:
    rx1675_cur."!cursor_fail"()
    if_null rx1675_debug, debug_1292
    rx1675_cur."!cursor_debug"("FAIL", "arglist")
  debug_1292:
    .return (rx1675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("323_1304282286.73") :method
.annotate 'line', 10
    $P1677 = self."!PREFIX__!subrule"("ws", "")
    new $P1678, "ResizablePMCArray"
    push $P1678, $P1677
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("324_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1682 = self."!PREFIX__!subrule"("ws", "")
    new $P1683, "ResizablePMCArray"
    push $P1683, $P1682
    .return ($P1683)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("325_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1685_tgt
    .local int rx1685_pos
    .local int rx1685_off
    .local int rx1685_eos
    .local int rx1685_rep
    .local pmc rx1685_cur
    .local pmc rx1685_debug
    (rx1685_cur, rx1685_pos, rx1685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1685_cur
    .local pmc match
    .lex "$/", match
    length rx1685_eos, rx1685_tgt
    gt rx1685_pos, rx1685_eos, rx1685_done
    set rx1685_off, 0
    lt rx1685_pos, 2, rx1685_start
    sub rx1685_off, rx1685_pos, 1
    substr rx1685_tgt, rx1685_tgt, rx1685_off
  rx1685_start:
    eq $I10, 1, rx1685_restart
    if_null rx1685_debug, debug_1293
    rx1685_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1293:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1689_done
    goto rxscan1689_scan
  rxscan1689_loop:
    (rx1685_pos) = rx1685_cur."from"()
    inc rx1685_pos
    rx1685_cur."!cursor_from"(rx1685_pos)
    ge rx1685_pos, rx1685_eos, rxscan1689_done
  rxscan1689_scan:
    set_addr $I10, rxscan1689_loop
    rx1685_cur."!mark_push"(0, rx1685_pos, $I10)
  rxscan1689_done:
.annotate 'line', 569
  # rx subrule "value" subtype=capture negate=
    rx1685_cur."!cursor_pos"(rx1685_pos)
    $P10 = rx1685_cur."value"()
    unless $P10, rx1685_fail
    rx1685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1685_pos = $P10."pos"()
  # rx pass
    rx1685_cur."!cursor_pass"(rx1685_pos, "term:sym<value>")
    if_null rx1685_debug, debug_1294
    rx1685_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1685_pos)
  debug_1294:
    .return (rx1685_cur)
  rx1685_restart:
.annotate 'line', 10
    if_null rx1685_debug, debug_1295
    rx1685_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1295:
  rx1685_fail:
    (rx1685_rep, rx1685_pos, $I10, $P10) = rx1685_cur."!mark_fail"(0)
    lt rx1685_pos, -1, rx1685_done
    eq rx1685_pos, -1, rx1685_fail
    jump $I10
  rx1685_done:
    rx1685_cur."!cursor_fail"()
    if_null rx1685_debug, debug_1296
    rx1685_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1296:
    .return (rx1685_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("326_1304282286.73") :method
.annotate 'line', 10
    $P1687 = self."!PREFIX__!subrule"("value", "")
    new $P1688, "ResizablePMCArray"
    push $P1688, $P1687
    .return ($P1688)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("327_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1691 = self."!PREFIX__!subrule"("value", "")
    new $P1692, "ResizablePMCArray"
    push $P1692, $P1691
    .return ($P1692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("328_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1694_tgt
    .local int rx1694_pos
    .local int rx1694_off
    .local int rx1694_eos
    .local int rx1694_rep
    .local pmc rx1694_cur
    .local pmc rx1694_debug
    (rx1694_cur, rx1694_pos, rx1694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1694_cur
    .local pmc match
    .lex "$/", match
    length rx1694_eos, rx1694_tgt
    gt rx1694_pos, rx1694_eos, rx1694_done
    set rx1694_off, 0
    lt rx1694_pos, 2, rx1694_start
    sub rx1694_off, rx1694_pos, 1
    substr rx1694_tgt, rx1694_tgt, rx1694_off
  rx1694_start:
    eq $I10, 1, rx1694_restart
    if_null rx1694_debug, debug_1297
    rx1694_cur."!cursor_debug"("START", "value")
  debug_1297:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1699_done
    goto rxscan1699_scan
  rxscan1699_loop:
    (rx1694_pos) = rx1694_cur."from"()
    inc rx1694_pos
    rx1694_cur."!cursor_from"(rx1694_pos)
    ge rx1694_pos, rx1694_eos, rxscan1699_done
  rxscan1699_scan:
    set_addr $I10, rxscan1699_loop
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  rxscan1699_done:
  alt1700_0:
.annotate 'line', 571
    set_addr $I10, alt1700_1
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
.annotate 'line', 572
  # rx subrule "quote" subtype=capture negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."quote"()
    unless $P10, rx1694_fail
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1694_pos = $P10."pos"()
    goto alt1700_end
  alt1700_1:
.annotate 'line', 573
  # rx subrule "number" subtype=capture negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."number"()
    unless $P10, rx1694_fail
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1694_pos = $P10."pos"()
  alt1700_end:
.annotate 'line', 571
  # rx pass
    rx1694_cur."!cursor_pass"(rx1694_pos, "value")
    if_null rx1694_debug, debug_1298
    rx1694_cur."!cursor_debug"("PASS", "value", " at pos=", rx1694_pos)
  debug_1298:
    .return (rx1694_cur)
  rx1694_restart:
.annotate 'line', 10
    if_null rx1694_debug, debug_1299
    rx1694_cur."!cursor_debug"("NEXT", "value")
  debug_1299:
  rx1694_fail:
    (rx1694_rep, rx1694_pos, $I10, $P10) = rx1694_cur."!mark_fail"(0)
    lt rx1694_pos, -1, rx1694_done
    eq rx1694_pos, -1, rx1694_fail
    jump $I10
  rx1694_done:
    rx1694_cur."!cursor_fail"()
    if_null rx1694_debug, debug_1300
    rx1694_cur."!cursor_debug"("FAIL", "value")
  debug_1300:
    .return (rx1694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("329_1304282286.73") :method
.annotate 'line', 10
    $P1696 = self."!PREFIX__!subrule"("number", "")
    $P1697 = self."!PREFIX__!subrule"("quote", "")
    new $P1698, "ResizablePMCArray"
    push $P1698, $P1696
    push $P1698, $P1697
    .return ($P1698)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("330_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1702 = self."!PREFIX__!subrule"("number", "")
    $P1703 = self."!PREFIX__!subrule"("quote", "")
    new $P1704, "ResizablePMCArray"
    push $P1704, $P1702
    push $P1704, $P1703
    .return ($P1704)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("331_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1706_tgt
    .local int rx1706_pos
    .local int rx1706_off
    .local int rx1706_eos
    .local int rx1706_rep
    .local pmc rx1706_cur
    .local pmc rx1706_debug
    (rx1706_cur, rx1706_pos, rx1706_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1706_cur
    .local pmc match
    .lex "$/", match
    length rx1706_eos, rx1706_tgt
    gt rx1706_pos, rx1706_eos, rx1706_done
    set rx1706_off, 0
    lt rx1706_pos, 2, rx1706_start
    sub rx1706_off, rx1706_pos, 1
    substr rx1706_tgt, rx1706_tgt, rx1706_off
  rx1706_start:
    eq $I10, 1, rx1706_restart
    if_null rx1706_debug, debug_1301
    rx1706_cur."!cursor_debug"("START", "number")
  debug_1301:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1709_done
    goto rxscan1709_scan
  rxscan1709_loop:
    (rx1706_pos) = rx1706_cur."from"()
    inc rx1706_pos
    rx1706_cur."!cursor_from"(rx1706_pos)
    ge rx1706_pos, rx1706_eos, rxscan1709_done
  rxscan1709_scan:
    set_addr $I10, rxscan1709_loop
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  rxscan1709_done:
.annotate 'line', 577
  # rx subcapture "sign"
    set_addr $I10, rxcap_1711_fail
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1706_pos, rx1706_off
    set rx1706_rep, 0
    sub $I12, rx1706_eos, rx1706_pos
    le $I12, 1, rxenumcharlistq1710_loop
    set $I12, 1
  rxenumcharlistq1710_loop:
    le $I12, 0, rxenumcharlistq1710_done
    substr $S10, rx1706_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1710_done
    inc rx1706_rep
  rxenumcharlistq1710_done:
    add rx1706_pos, rx1706_pos, rx1706_rep
    set_addr $I10, rxcap_1711_fail
    ($I12, $I11) = rx1706_cur."!mark_peek"($I10)
    rx1706_cur."!cursor_pos"($I11)
    ($P10) = rx1706_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1706_pos, "")
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1711_done
  rxcap_1711_fail:
    goto rx1706_fail
  rxcap_1711_done:
  alt1712_0:
.annotate 'line', 578
    set_addr $I10, alt1712_1
    rx1706_cur."!mark_push"(0, rx1706_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1706_cur."!cursor_pos"(rx1706_pos)
    $P10 = rx1706_cur."dec_number"()
    unless $P10, rx1706_fail
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1706_pos = $P10."pos"()
    goto alt1712_end
  alt1712_1:
  # rx subrule "integer" subtype=capture negate=
    rx1706_cur."!cursor_pos"(rx1706_pos)
    $P10 = rx1706_cur."integer"()
    unless $P10, rx1706_fail
    rx1706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1706_pos = $P10."pos"()
  alt1712_end:
.annotate 'line', 576
  # rx pass
    rx1706_cur."!cursor_pass"(rx1706_pos, "number")
    if_null rx1706_debug, debug_1302
    rx1706_cur."!cursor_debug"("PASS", "number", " at pos=", rx1706_pos)
  debug_1302:
    .return (rx1706_cur)
  rx1706_restart:
.annotate 'line', 10
    if_null rx1706_debug, debug_1303
    rx1706_cur."!cursor_debug"("NEXT", "number")
  debug_1303:
  rx1706_fail:
    (rx1706_rep, rx1706_pos, $I10, $P10) = rx1706_cur."!mark_fail"(0)
    lt rx1706_pos, -1, rx1706_done
    eq rx1706_pos, -1, rx1706_fail
    jump $I10
  rx1706_done:
    rx1706_cur."!cursor_fail"()
    if_null rx1706_debug, debug_1304
    rx1706_cur."!cursor_debug"("FAIL", "number")
  debug_1304:
    .return (rx1706_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("332_1304282286.73") :method
.annotate 'line', 10
    new $P1708, "ResizablePMCArray"
    push $P1708, ""
    .return ($P1708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("333_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1714, "ResizablePMCArray"
    push $P1714, ""
    .return ($P1714)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("334_1304282286.73")
    .param pmc param_1716
.annotate 'line', 581
    .lex "self", param_1716
    $P1717 = param_1716."!protoregex"("quote")
    .return ($P1717)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("335_1304282286.73")
    .param pmc param_1719
.annotate 'line', 581
    .lex "self", param_1719
    $P1720 = param_1719."!PREFIX__!protoregex"("quote")
    .return ($P1720)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("336_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1722_tgt
    .local int rx1722_pos
    .local int rx1722_off
    .local int rx1722_eos
    .local int rx1722_rep
    .local pmc rx1722_cur
    .local pmc rx1722_debug
    (rx1722_cur, rx1722_pos, rx1722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1722_cur
    .local pmc match
    .lex "$/", match
    length rx1722_eos, rx1722_tgt
    gt rx1722_pos, rx1722_eos, rx1722_done
    set rx1722_off, 0
    lt rx1722_pos, 2, rx1722_start
    sub rx1722_off, rx1722_pos, 1
    substr rx1722_tgt, rx1722_tgt, rx1722_off
  rx1722_start:
    eq $I10, 1, rx1722_restart
    if_null rx1722_debug, debug_1305
    rx1722_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1305:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1722_pos) = rx1722_cur."from"()
    inc rx1722_pos
    rx1722_cur."!cursor_from"(rx1722_pos)
    ge rx1722_pos, rx1722_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  rxscan1725_done:
.annotate 'line', 582
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1722_pos, rx1722_off
    substr $S10, rx1722_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1722_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."quote_EXPR"(":q")
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1722_pos = $P10."pos"()
  # rx pass
    rx1722_cur."!cursor_pass"(rx1722_pos, "quote:sym<apos>")
    if_null rx1722_debug, debug_1306
    rx1722_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1722_pos)
  debug_1306:
    .return (rx1722_cur)
  rx1722_restart:
.annotate 'line', 10
    if_null rx1722_debug, debug_1307
    rx1722_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1307:
  rx1722_fail:
    (rx1722_rep, rx1722_pos, $I10, $P10) = rx1722_cur."!mark_fail"(0)
    lt rx1722_pos, -1, rx1722_done
    eq rx1722_pos, -1, rx1722_fail
    jump $I10
  rx1722_done:
    rx1722_cur."!cursor_fail"()
    if_null rx1722_debug, debug_1308
    rx1722_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1308:
    .return (rx1722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("337_1304282286.73") :method
.annotate 'line', 10
    new $P1724, "ResizablePMCArray"
    push $P1724, "'"
    .return ($P1724)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("338_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1727, "ResizablePMCArray"
    push $P1727, "'"
    .return ($P1727)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("339_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1729_tgt
    .local int rx1729_pos
    .local int rx1729_off
    .local int rx1729_eos
    .local int rx1729_rep
    .local pmc rx1729_cur
    .local pmc rx1729_debug
    (rx1729_cur, rx1729_pos, rx1729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1729_cur
    .local pmc match
    .lex "$/", match
    length rx1729_eos, rx1729_tgt
    gt rx1729_pos, rx1729_eos, rx1729_done
    set rx1729_off, 0
    lt rx1729_pos, 2, rx1729_start
    sub rx1729_off, rx1729_pos, 1
    substr rx1729_tgt, rx1729_tgt, rx1729_off
  rx1729_start:
    eq $I10, 1, rx1729_restart
    if_null rx1729_debug, debug_1309
    rx1729_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1309:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1732_done
    goto rxscan1732_scan
  rxscan1732_loop:
    (rx1729_pos) = rx1729_cur."from"()
    inc rx1729_pos
    rx1729_cur."!cursor_from"(rx1729_pos)
    ge rx1729_pos, rx1729_eos, rxscan1732_done
  rxscan1732_scan:
    set_addr $I10, rxscan1732_loop
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  rxscan1732_done:
.annotate 'line', 583
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1729_pos, rx1729_off
    substr $S10, rx1729_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1729_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1729_cur."!cursor_pos"(rx1729_pos)
    $P10 = rx1729_cur."quote_EXPR"(":qq")
    unless $P10, rx1729_fail
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1729_pos = $P10."pos"()
  # rx pass
    rx1729_cur."!cursor_pass"(rx1729_pos, "quote:sym<dblq>")
    if_null rx1729_debug, debug_1310
    rx1729_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1729_pos)
  debug_1310:
    .return (rx1729_cur)
  rx1729_restart:
.annotate 'line', 10
    if_null rx1729_debug, debug_1311
    rx1729_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1311:
  rx1729_fail:
    (rx1729_rep, rx1729_pos, $I10, $P10) = rx1729_cur."!mark_fail"(0)
    lt rx1729_pos, -1, rx1729_done
    eq rx1729_pos, -1, rx1729_fail
    jump $I10
  rx1729_done:
    rx1729_cur."!cursor_fail"()
    if_null rx1729_debug, debug_1312
    rx1729_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1312:
    .return (rx1729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("340_1304282286.73") :method
.annotate 'line', 10
    new $P1731, "ResizablePMCArray"
    push $P1731, "\""
    .return ($P1731)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("341_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1734, "ResizablePMCArray"
    push $P1734, "\""
    .return ($P1734)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("342_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1736_tgt
    .local int rx1736_pos
    .local int rx1736_off
    .local int rx1736_eos
    .local int rx1736_rep
    .local pmc rx1736_cur
    .local pmc rx1736_debug
    (rx1736_cur, rx1736_pos, rx1736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1736_cur
    .local pmc match
    .lex "$/", match
    length rx1736_eos, rx1736_tgt
    gt rx1736_pos, rx1736_eos, rx1736_done
    set rx1736_off, 0
    lt rx1736_pos, 2, rx1736_start
    sub rx1736_off, rx1736_pos, 1
    substr rx1736_tgt, rx1736_tgt, rx1736_off
  rx1736_start:
    eq $I10, 1, rx1736_restart
    if_null rx1736_debug, debug_1313
    rx1736_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1313:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1740_done
    goto rxscan1740_scan
  rxscan1740_loop:
    (rx1736_pos) = rx1736_cur."from"()
    inc rx1736_pos
    rx1736_cur."!cursor_from"(rx1736_pos)
    ge rx1736_pos, rx1736_eos, rxscan1740_done
  rxscan1740_scan:
    set_addr $I10, rxscan1740_loop
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  rxscan1740_done:
.annotate 'line', 584
  # rx subcapture "sym"
    set_addr $I10, rxcap_1741_fail
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  # rx literal  "q"
    add $I11, rx1736_pos, 1
    gt $I11, rx1736_eos, rx1736_fail
    sub $I11, rx1736_pos, rx1736_off
    ord $I11, rx1736_tgt, $I11
    ne $I11, 113, rx1736_fail
    add rx1736_pos, 1
    set_addr $I10, rxcap_1741_fail
    ($I12, $I11) = rx1736_cur."!mark_peek"($I10)
    rx1736_cur."!cursor_pos"($I11)
    ($P10) = rx1736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1736_pos, "")
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1741_done
  rxcap_1741_fail:
    goto rx1736_fail
  rxcap_1741_done:
  # rxanchor rwb
    le rx1736_pos, 0, rx1736_fail
    sub $I10, rx1736_pos, rx1736_off
    is_cclass $I11, 8192, rx1736_tgt, $I10
    if $I11, rx1736_fail
    dec $I10
    is_cclass $I11, 8192, rx1736_tgt, $I10
    unless $I11, rx1736_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1736_pos, rx1736_off
    substr $S10, rx1736_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1736_fail
  # rx subrule "ws" subtype=method negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."ws"()
    unless $P10, rx1736_fail
    rx1736_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."quote_EXPR"(":q")
    unless $P10, rx1736_fail
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1736_pos = $P10."pos"()
  # rx pass
    rx1736_cur."!cursor_pass"(rx1736_pos, "quote:sym<q>")
    if_null rx1736_debug, debug_1314
    rx1736_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1736_pos)
  debug_1314:
    .return (rx1736_cur)
  rx1736_restart:
.annotate 'line', 10
    if_null rx1736_debug, debug_1315
    rx1736_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1315:
  rx1736_fail:
    (rx1736_rep, rx1736_pos, $I10, $P10) = rx1736_cur."!mark_fail"(0)
    lt rx1736_pos, -1, rx1736_done
    eq rx1736_pos, -1, rx1736_fail
    jump $I10
  rx1736_done:
    rx1736_cur."!cursor_fail"()
    if_null rx1736_debug, debug_1316
    rx1736_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1316:
    .return (rx1736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("343_1304282286.73") :method
.annotate 'line', 10
    $P1738 = self."!PREFIX__!subrule"("ws", "q")
    new $P1739, "ResizablePMCArray"
    push $P1739, $P1738
    .return ($P1739)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("344_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1743 = self."!PREFIX__!subrule"("ws", "q")
    new $P1744, "ResizablePMCArray"
    push $P1744, $P1743
    .return ($P1744)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("345_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1746_tgt
    .local int rx1746_pos
    .local int rx1746_off
    .local int rx1746_eos
    .local int rx1746_rep
    .local pmc rx1746_cur
    .local pmc rx1746_debug
    (rx1746_cur, rx1746_pos, rx1746_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1746_cur
    .local pmc match
    .lex "$/", match
    length rx1746_eos, rx1746_tgt
    gt rx1746_pos, rx1746_eos, rx1746_done
    set rx1746_off, 0
    lt rx1746_pos, 2, rx1746_start
    sub rx1746_off, rx1746_pos, 1
    substr rx1746_tgt, rx1746_tgt, rx1746_off
  rx1746_start:
    eq $I10, 1, rx1746_restart
    if_null rx1746_debug, debug_1317
    rx1746_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1317:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1750_done
    goto rxscan1750_scan
  rxscan1750_loop:
    (rx1746_pos) = rx1746_cur."from"()
    inc rx1746_pos
    rx1746_cur."!cursor_from"(rx1746_pos)
    ge rx1746_pos, rx1746_eos, rxscan1750_done
  rxscan1750_scan:
    set_addr $I10, rxscan1750_loop
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
  rxscan1750_done:
.annotate 'line', 585
  # rx subcapture "sym"
    set_addr $I10, rxcap_1751_fail
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1746_pos, 2
    gt $I11, rx1746_eos, rx1746_fail
    sub $I11, rx1746_pos, rx1746_off
    substr $S10, rx1746_tgt, $I11, 2
    ne $S10, "qq", rx1746_fail
    add rx1746_pos, 2
    set_addr $I10, rxcap_1751_fail
    ($I12, $I11) = rx1746_cur."!mark_peek"($I10)
    rx1746_cur."!cursor_pos"($I11)
    ($P10) = rx1746_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1746_pos, "")
    rx1746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1751_done
  rxcap_1751_fail:
    goto rx1746_fail
  rxcap_1751_done:
  # rxanchor rwb
    le rx1746_pos, 0, rx1746_fail
    sub $I10, rx1746_pos, rx1746_off
    is_cclass $I11, 8192, rx1746_tgt, $I10
    if $I11, rx1746_fail
    dec $I10
    is_cclass $I11, 8192, rx1746_tgt, $I10
    unless $I11, rx1746_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1746_pos, rx1746_off
    substr $S10, rx1746_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1746_fail
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."quote_EXPR"(":qq")
    unless $P10, rx1746_fail
    rx1746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1746_pos = $P10."pos"()
  # rx pass
    rx1746_cur."!cursor_pass"(rx1746_pos, "quote:sym<qq>")
    if_null rx1746_debug, debug_1318
    rx1746_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1746_pos)
  debug_1318:
    .return (rx1746_cur)
  rx1746_restart:
.annotate 'line', 10
    if_null rx1746_debug, debug_1319
    rx1746_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1319:
  rx1746_fail:
    (rx1746_rep, rx1746_pos, $I10, $P10) = rx1746_cur."!mark_fail"(0)
    lt rx1746_pos, -1, rx1746_done
    eq rx1746_pos, -1, rx1746_fail
    jump $I10
  rx1746_done:
    rx1746_cur."!cursor_fail"()
    if_null rx1746_debug, debug_1320
    rx1746_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1320:
    .return (rx1746_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("346_1304282286.73") :method
.annotate 'line', 10
    $P1748 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1749, "ResizablePMCArray"
    push $P1749, $P1748
    .return ($P1749)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("347_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1753 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1754, "ResizablePMCArray"
    push $P1754, $P1753
    .return ($P1754)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("348_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1756_tgt
    .local int rx1756_pos
    .local int rx1756_off
    .local int rx1756_eos
    .local int rx1756_rep
    .local pmc rx1756_cur
    .local pmc rx1756_debug
    (rx1756_cur, rx1756_pos, rx1756_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1756_cur
    .local pmc match
    .lex "$/", match
    length rx1756_eos, rx1756_tgt
    gt rx1756_pos, rx1756_eos, rx1756_done
    set rx1756_off, 0
    lt rx1756_pos, 2, rx1756_start
    sub rx1756_off, rx1756_pos, 1
    substr rx1756_tgt, rx1756_tgt, rx1756_off
  rx1756_start:
    eq $I10, 1, rx1756_restart
    if_null rx1756_debug, debug_1321
    rx1756_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1321:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1760_done
    goto rxscan1760_scan
  rxscan1760_loop:
    (rx1756_pos) = rx1756_cur."from"()
    inc rx1756_pos
    rx1756_cur."!cursor_from"(rx1756_pos)
    ge rx1756_pos, rx1756_eos, rxscan1760_done
  rxscan1760_scan:
    set_addr $I10, rxscan1760_loop
    rx1756_cur."!mark_push"(0, rx1756_pos, $I10)
  rxscan1760_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1761_fail
    rx1756_cur."!mark_push"(0, rx1756_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1756_pos, 1
    gt $I11, rx1756_eos, rx1756_fail
    sub $I11, rx1756_pos, rx1756_off
    ord $I11, rx1756_tgt, $I11
    ne $I11, 81, rx1756_fail
    add rx1756_pos, 1
    set_addr $I10, rxcap_1761_fail
    ($I12, $I11) = rx1756_cur."!mark_peek"($I10)
    rx1756_cur."!cursor_pos"($I11)
    ($P10) = rx1756_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1756_pos, "")
    rx1756_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1761_done
  rxcap_1761_fail:
    goto rx1756_fail
  rxcap_1761_done:
  # rxanchor rwb
    le rx1756_pos, 0, rx1756_fail
    sub $I10, rx1756_pos, rx1756_off
    is_cclass $I11, 8192, rx1756_tgt, $I10
    if $I11, rx1756_fail
    dec $I10
    is_cclass $I11, 8192, rx1756_tgt, $I10
    unless $I11, rx1756_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1756_pos, rx1756_off
    substr $S10, rx1756_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1756_fail
  # rx subrule "ws" subtype=method negate=
    rx1756_cur."!cursor_pos"(rx1756_pos)
    $P10 = rx1756_cur."ws"()
    unless $P10, rx1756_fail
    rx1756_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1756_cur."!cursor_pos"(rx1756_pos)
    $P10 = rx1756_cur."quote_EXPR"()
    unless $P10, rx1756_fail
    rx1756_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1756_pos = $P10."pos"()
  # rx pass
    rx1756_cur."!cursor_pass"(rx1756_pos, "quote:sym<Q>")
    if_null rx1756_debug, debug_1322
    rx1756_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1756_pos)
  debug_1322:
    .return (rx1756_cur)
  rx1756_restart:
.annotate 'line', 10
    if_null rx1756_debug, debug_1323
    rx1756_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1323:
  rx1756_fail:
    (rx1756_rep, rx1756_pos, $I10, $P10) = rx1756_cur."!mark_fail"(0)
    lt rx1756_pos, -1, rx1756_done
    eq rx1756_pos, -1, rx1756_fail
    jump $I10
  rx1756_done:
    rx1756_cur."!cursor_fail"()
    if_null rx1756_debug, debug_1324
    rx1756_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1324:
    .return (rx1756_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("349_1304282286.73") :method
.annotate 'line', 10
    $P1758 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1759, "ResizablePMCArray"
    push $P1759, $P1758
    .return ($P1759)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("350_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1763 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1764, "ResizablePMCArray"
    push $P1764, $P1763
    .return ($P1764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("351_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1766_tgt
    .local int rx1766_pos
    .local int rx1766_off
    .local int rx1766_eos
    .local int rx1766_rep
    .local pmc rx1766_cur
    .local pmc rx1766_debug
    (rx1766_cur, rx1766_pos, rx1766_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1766_cur
    .local pmc match
    .lex "$/", match
    length rx1766_eos, rx1766_tgt
    gt rx1766_pos, rx1766_eos, rx1766_done
    set rx1766_off, 0
    lt rx1766_pos, 2, rx1766_start
    sub rx1766_off, rx1766_pos, 1
    substr rx1766_tgt, rx1766_tgt, rx1766_off
  rx1766_start:
    eq $I10, 1, rx1766_restart
    if_null rx1766_debug, debug_1325
    rx1766_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1770_done
    goto rxscan1770_scan
  rxscan1770_loop:
    (rx1766_pos) = rx1766_cur."from"()
    inc rx1766_pos
    rx1766_cur."!cursor_from"(rx1766_pos)
    ge rx1766_pos, rx1766_eos, rxscan1770_done
  rxscan1770_scan:
    set_addr $I10, rxscan1770_loop
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  rxscan1770_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1771_fail
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1766_pos, 5
    gt $I11, rx1766_eos, rx1766_fail
    sub $I11, rx1766_pos, rx1766_off
    substr $S10, rx1766_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1766_fail
    add rx1766_pos, 5
    set_addr $I10, rxcap_1771_fail
    ($I12, $I11) = rx1766_cur."!mark_peek"($I10)
    rx1766_cur."!cursor_pos"($I11)
    ($P10) = rx1766_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1766_pos, "")
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1771_done
  rxcap_1771_fail:
    goto rx1766_fail
  rxcap_1771_done:
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."quote_EXPR"()
    unless $P10, rx1766_fail
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1766_pos = $P10."pos"()
  # rx pass
    rx1766_cur."!cursor_pass"(rx1766_pos, "quote:sym<Q:PIR>")
    if_null rx1766_debug, debug_1326
    rx1766_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1766_pos)
  debug_1326:
    .return (rx1766_cur)
  rx1766_restart:
.annotate 'line', 10
    if_null rx1766_debug, debug_1327
    rx1766_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1327:
  rx1766_fail:
    (rx1766_rep, rx1766_pos, $I10, $P10) = rx1766_cur."!mark_fail"(0)
    lt rx1766_pos, -1, rx1766_done
    eq rx1766_pos, -1, rx1766_fail
    jump $I10
  rx1766_done:
    rx1766_cur."!cursor_fail"()
    if_null rx1766_debug, debug_1328
    rx1766_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1328:
    .return (rx1766_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("352_1304282286.73") :method
.annotate 'line', 10
    $P1768 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1769, "ResizablePMCArray"
    push $P1769, $P1768
    .return ($P1769)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("353_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1773 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1774, "ResizablePMCArray"
    push $P1774, $P1773
    .return ($P1774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("354_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1776_tgt
    .local int rx1776_pos
    .local int rx1776_off
    .local int rx1776_eos
    .local int rx1776_rep
    .local pmc rx1776_cur
    .local pmc rx1776_debug
    (rx1776_cur, rx1776_pos, rx1776_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1776_cur
    .local pmc match
    .lex "$/", match
    length rx1776_eos, rx1776_tgt
    gt rx1776_pos, rx1776_eos, rx1776_done
    set rx1776_off, 0
    lt rx1776_pos, 2, rx1776_start
    sub rx1776_off, rx1776_pos, 1
    substr rx1776_tgt, rx1776_tgt, rx1776_off
  rx1776_start:
    eq $I10, 1, rx1776_restart
    if_null rx1776_debug, debug_1329
    rx1776_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1329:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1780_done
    goto rxscan1780_scan
  rxscan1780_loop:
    (rx1776_pos) = rx1776_cur."from"()
    inc rx1776_pos
    rx1776_cur."!cursor_from"(rx1776_pos)
    ge rx1776_pos, rx1776_eos, rxscan1780_done
  rxscan1780_scan:
    set_addr $I10, rxscan1780_loop
    rx1776_cur."!mark_push"(0, rx1776_pos, $I10)
  rxscan1780_done:
.annotate 'line', 589
  # rx literal  "/"
    add $I11, rx1776_pos, 1
    gt $I11, rx1776_eos, rx1776_fail
    sub $I11, rx1776_pos, rx1776_off
    ord $I11, rx1776_tgt, $I11
    ne $I11, 47, rx1776_fail
    add rx1776_pos, 1
.annotate 'line', 590
  # rx subrule "newpad" subtype=method negate=
    rx1776_cur."!cursor_pos"(rx1776_pos)
    $P10 = rx1776_cur."newpad"()
    unless $P10, rx1776_fail
    rx1776_pos = $P10."pos"()
.annotate 'line', 591
  # rx reduce name="quote:sym</ />" key="open"
    rx1776_cur."!cursor_pos"(rx1776_pos)
    rx1776_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 592
  # rx subrule "LANG" subtype=capture negate=
    rx1776_cur."!cursor_pos"(rx1776_pos)
    $P10 = rx1776_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1776_fail
    rx1776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1776_pos = $P10."pos"()
.annotate 'line', 593
  # rx literal  "/"
    add $I11, rx1776_pos, 1
    gt $I11, rx1776_eos, rx1776_fail
    sub $I11, rx1776_pos, rx1776_off
    ord $I11, rx1776_tgt, $I11
    ne $I11, 47, rx1776_fail
    add rx1776_pos, 1
.annotate 'line', 588
  # rx pass
    rx1776_cur."!cursor_pass"(rx1776_pos, "quote:sym</ />")
    if_null rx1776_debug, debug_1330
    rx1776_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1776_pos)
  debug_1330:
    .return (rx1776_cur)
  rx1776_restart:
.annotate 'line', 10
    if_null rx1776_debug, debug_1331
    rx1776_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1331:
  rx1776_fail:
    (rx1776_rep, rx1776_pos, $I10, $P10) = rx1776_cur."!mark_fail"(0)
    lt rx1776_pos, -1, rx1776_done
    eq rx1776_pos, -1, rx1776_fail
    jump $I10
  rx1776_done:
    rx1776_cur."!cursor_fail"()
    if_null rx1776_debug, debug_1332
    rx1776_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1332:
    .return (rx1776_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("355_1304282286.73") :method
.annotate 'line', 10
    $P1778 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1779, "ResizablePMCArray"
    push $P1779, $P1778
    .return ($P1779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("356_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1782 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1783, "ResizablePMCArray"
    push $P1783, $P1782
    .return ($P1783)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("357_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1785_tgt
    .local int rx1785_pos
    .local int rx1785_off
    .local int rx1785_eos
    .local int rx1785_rep
    .local pmc rx1785_cur
    .local pmc rx1785_debug
    (rx1785_cur, rx1785_pos, rx1785_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1785_cur
    .local pmc match
    .lex "$/", match
    length rx1785_eos, rx1785_tgt
    gt rx1785_pos, rx1785_eos, rx1785_done
    set rx1785_off, 0
    lt rx1785_pos, 2, rx1785_start
    sub rx1785_off, rx1785_pos, 1
    substr rx1785_tgt, rx1785_tgt, rx1785_off
  rx1785_start:
    eq $I10, 1, rx1785_restart
    if_null rx1785_debug, debug_1333
    rx1785_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1788_done
    goto rxscan1788_scan
  rxscan1788_loop:
    (rx1785_pos) = rx1785_cur."from"()
    inc rx1785_pos
    rx1785_cur."!cursor_from"(rx1785_pos)
    ge rx1785_pos, rx1785_eos, rxscan1788_done
  rxscan1788_scan:
    set_addr $I10, rxscan1788_loop
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  rxscan1788_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1785_pos, rx1785_off
    substr $S10, rx1785_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1785_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1785_cur."!cursor_pos"(rx1785_pos)
    $P10 = rx1785_cur."quotemod_check"("s")
    unless $P10, rx1785_fail
  # rx subrule "variable" subtype=capture negate=
    rx1785_cur."!cursor_pos"(rx1785_pos)
    $P10 = rx1785_cur."variable"()
    unless $P10, rx1785_fail
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1785_pos = $P10."pos"()
  # rx pass
    rx1785_cur."!cursor_pass"(rx1785_pos, "quote_escape:sym<$>")
    if_null rx1785_debug, debug_1334
    rx1785_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1785_pos)
  debug_1334:
    .return (rx1785_cur)
  rx1785_restart:
.annotate 'line', 10
    if_null rx1785_debug, debug_1335
    rx1785_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1335:
  rx1785_fail:
    (rx1785_rep, rx1785_pos, $I10, $P10) = rx1785_cur."!mark_fail"(0)
    lt rx1785_pos, -1, rx1785_done
    eq rx1785_pos, -1, rx1785_fail
    jump $I10
  rx1785_done:
    rx1785_cur."!cursor_fail"()
    if_null rx1785_debug, debug_1336
    rx1785_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1336:
    .return (rx1785_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("358_1304282286.73") :method
.annotate 'line', 10
    new $P1787, "ResizablePMCArray"
    push $P1787, "$"
    .return ($P1787)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("359_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1790, "ResizablePMCArray"
    push $P1790, "$"
    .return ($P1790)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("360_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1792_tgt
    .local int rx1792_pos
    .local int rx1792_off
    .local int rx1792_eos
    .local int rx1792_rep
    .local pmc rx1792_cur
    .local pmc rx1792_debug
    (rx1792_cur, rx1792_pos, rx1792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1792_cur
    .local pmc match
    .lex "$/", match
    length rx1792_eos, rx1792_tgt
    gt rx1792_pos, rx1792_eos, rx1792_done
    set rx1792_off, 0
    lt rx1792_pos, 2, rx1792_start
    sub rx1792_off, rx1792_pos, 1
    substr rx1792_tgt, rx1792_tgt, rx1792_off
  rx1792_start:
    eq $I10, 1, rx1792_restart
    if_null rx1792_debug, debug_1337
    rx1792_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1795_done
    goto rxscan1795_scan
  rxscan1795_loop:
    (rx1792_pos) = rx1792_cur."from"()
    inc rx1792_pos
    rx1792_cur."!cursor_from"(rx1792_pos)
    ge rx1792_pos, rx1792_eos, rxscan1795_done
  rxscan1795_scan:
    set_addr $I10, rxscan1795_loop
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  rxscan1795_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1792_pos, rx1792_off
    substr $S10, rx1792_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1792_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1792_cur."!cursor_pos"(rx1792_pos)
    $P10 = rx1792_cur."quotemod_check"("c")
    unless $P10, rx1792_fail
  # rx subrule "block" subtype=capture negate=
    rx1792_cur."!cursor_pos"(rx1792_pos)
    $P10 = rx1792_cur."block"()
    unless $P10, rx1792_fail
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1792_pos = $P10."pos"()
  # rx pass
    rx1792_cur."!cursor_pass"(rx1792_pos, "quote_escape:sym<{ }>")
    if_null rx1792_debug, debug_1338
    rx1792_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1792_pos)
  debug_1338:
    .return (rx1792_cur)
  rx1792_restart:
.annotate 'line', 10
    if_null rx1792_debug, debug_1339
    rx1792_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1339:
  rx1792_fail:
    (rx1792_rep, rx1792_pos, $I10, $P10) = rx1792_cur."!mark_fail"(0)
    lt rx1792_pos, -1, rx1792_done
    eq rx1792_pos, -1, rx1792_fail
    jump $I10
  rx1792_done:
    rx1792_cur."!cursor_fail"()
    if_null rx1792_debug, debug_1340
    rx1792_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1340:
    .return (rx1792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("361_1304282286.73") :method
.annotate 'line', 10
    new $P1794, "ResizablePMCArray"
    push $P1794, "{"
    .return ($P1794)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("362_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1797, "ResizablePMCArray"
    push $P1797, "{"
    .return ($P1797)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("363_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1799_tgt
    .local int rx1799_pos
    .local int rx1799_off
    .local int rx1799_eos
    .local int rx1799_rep
    .local pmc rx1799_cur
    .local pmc rx1799_debug
    (rx1799_cur, rx1799_pos, rx1799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1799_cur
    .local pmc match
    .lex "$/", match
    length rx1799_eos, rx1799_tgt
    gt rx1799_pos, rx1799_eos, rx1799_done
    set rx1799_off, 0
    lt rx1799_pos, 2, rx1799_start
    sub rx1799_off, rx1799_pos, 1
    substr rx1799_tgt, rx1799_tgt, rx1799_off
  rx1799_start:
    eq $I10, 1, rx1799_restart
    if_null rx1799_debug, debug_1341
    rx1799_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1341:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1802_done
    goto rxscan1802_scan
  rxscan1802_loop:
    (rx1799_pos) = rx1799_cur."from"()
    inc rx1799_pos
    rx1799_cur."!cursor_from"(rx1799_pos)
    ge rx1799_pos, rx1799_eos, rxscan1802_done
  rxscan1802_scan:
    set_addr $I10, rxscan1802_loop
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  rxscan1802_done:
.annotate 'line', 598
  # rx literal  "\\e"
    add $I11, rx1799_pos, 2
    gt $I11, rx1799_eos, rx1799_fail
    sub $I11, rx1799_pos, rx1799_off
    substr $S10, rx1799_tgt, $I11, 2
    ne $S10, "\\e", rx1799_fail
    add rx1799_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1799_cur."!cursor_pos"(rx1799_pos)
    $P10 = rx1799_cur."quotemod_check"("b")
    unless $P10, rx1799_fail
  # rx pass
    rx1799_cur."!cursor_pass"(rx1799_pos, "quote_escape:sym<esc>")
    if_null rx1799_debug, debug_1342
    rx1799_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1799_pos)
  debug_1342:
    .return (rx1799_cur)
  rx1799_restart:
.annotate 'line', 10
    if_null rx1799_debug, debug_1343
    rx1799_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1343:
  rx1799_fail:
    (rx1799_rep, rx1799_pos, $I10, $P10) = rx1799_cur."!mark_fail"(0)
    lt rx1799_pos, -1, rx1799_done
    eq rx1799_pos, -1, rx1799_fail
    jump $I10
  rx1799_done:
    rx1799_cur."!cursor_fail"()
    if_null rx1799_debug, debug_1344
    rx1799_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1344:
    .return (rx1799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("364_1304282286.73") :method
.annotate 'line', 10
    new $P1801, "ResizablePMCArray"
    push $P1801, "\\e"
    .return ($P1801)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("365_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1804, "ResizablePMCArray"
    push $P1804, "\\e"
    .return ($P1804)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("366_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1806_tgt
    .local int rx1806_pos
    .local int rx1806_off
    .local int rx1806_eos
    .local int rx1806_rep
    .local pmc rx1806_cur
    .local pmc rx1806_debug
    (rx1806_cur, rx1806_pos, rx1806_tgt, $I10) = self."!cursor_start"()
    rx1806_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1806_cur
    .local pmc match
    .lex "$/", match
    length rx1806_eos, rx1806_tgt
    gt rx1806_pos, rx1806_eos, rx1806_done
    set rx1806_off, 0
    lt rx1806_pos, 2, rx1806_start
    sub rx1806_off, rx1806_pos, 1
    substr rx1806_tgt, rx1806_tgt, rx1806_off
  rx1806_start:
    eq $I10, 1, rx1806_restart
    if_null rx1806_debug, debug_1345
    rx1806_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1810_done
    goto rxscan1810_scan
  rxscan1810_loop:
    (rx1806_pos) = rx1806_cur."from"()
    inc rx1806_pos
    rx1806_cur."!cursor_from"(rx1806_pos)
    ge rx1806_pos, rx1806_eos, rxscan1810_done
  rxscan1810_scan:
    set_addr $I10, rxscan1810_loop
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  rxscan1810_done:
.annotate 'line', 600
  # rx literal  "("
    add $I11, rx1806_pos, 1
    gt $I11, rx1806_eos, rx1806_fail
    sub $I11, rx1806_pos, rx1806_off
    ord $I11, rx1806_tgt, $I11
    ne $I11, 40, rx1806_fail
    add rx1806_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."ws"()
    unless $P10, rx1806_fail
    rx1806_pos = $P10."pos"()
  # rx rxquantr1811 ** 0..1
    set_addr $I10, rxquantr1811_done
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  rxquantr1811_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."EXPR"()
    unless $P10, rx1806_fail
    goto rxsubrule1812_pass
  rxsubrule1812_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1806_fail
  rxsubrule1812_pass:
    set_addr $I10, rxsubrule1812_back
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1806_pos = $P10."pos"()
    set_addr $I10, rxquantr1811_done
    (rx1806_rep) = rx1806_cur."!mark_commit"($I10)
  rxquantr1811_done:
  # rx literal  ")"
    add $I11, rx1806_pos, 1
    gt $I11, rx1806_eos, rx1806_fail
    sub $I11, rx1806_pos, rx1806_off
    ord $I11, rx1806_tgt, $I11
    ne $I11, 41, rx1806_fail
    add rx1806_pos, 1
  # rx pass
    rx1806_cur."!cursor_pass"(rx1806_pos, "circumfix:sym<( )>")
    if_null rx1806_debug, debug_1346
    rx1806_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1806_pos)
  debug_1346:
    .return (rx1806_cur)
  rx1806_restart:
.annotate 'line', 10
    if_null rx1806_debug, debug_1347
    rx1806_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1347:
  rx1806_fail:
    (rx1806_rep, rx1806_pos, $I10, $P10) = rx1806_cur."!mark_fail"(0)
    lt rx1806_pos, -1, rx1806_done
    eq rx1806_pos, -1, rx1806_fail
    jump $I10
  rx1806_done:
    rx1806_cur."!cursor_fail"()
    if_null rx1806_debug, debug_1348
    rx1806_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1348:
    .return (rx1806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("367_1304282286.73") :method
.annotate 'line', 10
    $P1808 = self."!PREFIX__!subrule"("ws", "(")
    new $P1809, "ResizablePMCArray"
    push $P1809, $P1808
    .return ($P1809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("368_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1814 = self."!PREFIX__!subrule"("ws", "(")
    new $P1815, "ResizablePMCArray"
    push $P1815, $P1814
    .return ($P1815)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("369_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1817_tgt
    .local int rx1817_pos
    .local int rx1817_off
    .local int rx1817_eos
    .local int rx1817_rep
    .local pmc rx1817_cur
    .local pmc rx1817_debug
    (rx1817_cur, rx1817_pos, rx1817_tgt, $I10) = self."!cursor_start"()
    rx1817_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1817_cur
    .local pmc match
    .lex "$/", match
    length rx1817_eos, rx1817_tgt
    gt rx1817_pos, rx1817_eos, rx1817_done
    set rx1817_off, 0
    lt rx1817_pos, 2, rx1817_start
    sub rx1817_off, rx1817_pos, 1
    substr rx1817_tgt, rx1817_tgt, rx1817_off
  rx1817_start:
    eq $I10, 1, rx1817_restart
    if_null rx1817_debug, debug_1349
    rx1817_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1821_done
    goto rxscan1821_scan
  rxscan1821_loop:
    (rx1817_pos) = rx1817_cur."from"()
    inc rx1817_pos
    rx1817_cur."!cursor_from"(rx1817_pos)
    ge rx1817_pos, rx1817_eos, rxscan1821_done
  rxscan1821_scan:
    set_addr $I10, rxscan1821_loop
    rx1817_cur."!mark_push"(0, rx1817_pos, $I10)
  rxscan1821_done:
.annotate 'line', 601
  # rx literal  "["
    add $I11, rx1817_pos, 1
    gt $I11, rx1817_eos, rx1817_fail
    sub $I11, rx1817_pos, rx1817_off
    ord $I11, rx1817_tgt, $I11
    ne $I11, 91, rx1817_fail
    add rx1817_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1817_cur."!cursor_pos"(rx1817_pos)
    $P10 = rx1817_cur."ws"()
    unless $P10, rx1817_fail
    rx1817_pos = $P10."pos"()
  # rx rxquantr1822 ** 0..1
    set_addr $I10, rxquantr1822_done
    rx1817_cur."!mark_push"(0, rx1817_pos, $I10)
  rxquantr1822_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1817_cur."!cursor_pos"(rx1817_pos)
    $P10 = rx1817_cur."EXPR"()
    unless $P10, rx1817_fail
    goto rxsubrule1823_pass
  rxsubrule1823_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1817_fail
  rxsubrule1823_pass:
    set_addr $I10, rxsubrule1823_back
    rx1817_cur."!mark_push"(0, rx1817_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1817_pos = $P10."pos"()
    set_addr $I10, rxquantr1822_done
    (rx1817_rep) = rx1817_cur."!mark_commit"($I10)
  rxquantr1822_done:
  # rx literal  "]"
    add $I11, rx1817_pos, 1
    gt $I11, rx1817_eos, rx1817_fail
    sub $I11, rx1817_pos, rx1817_off
    ord $I11, rx1817_tgt, $I11
    ne $I11, 93, rx1817_fail
    add rx1817_pos, 1
  # rx pass
    rx1817_cur."!cursor_pass"(rx1817_pos, "circumfix:sym<[ ]>")
    if_null rx1817_debug, debug_1350
    rx1817_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1817_pos)
  debug_1350:
    .return (rx1817_cur)
  rx1817_restart:
.annotate 'line', 10
    if_null rx1817_debug, debug_1351
    rx1817_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1351:
  rx1817_fail:
    (rx1817_rep, rx1817_pos, $I10, $P10) = rx1817_cur."!mark_fail"(0)
    lt rx1817_pos, -1, rx1817_done
    eq rx1817_pos, -1, rx1817_fail
    jump $I10
  rx1817_done:
    rx1817_cur."!cursor_fail"()
    if_null rx1817_debug, debug_1352
    rx1817_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1352:
    .return (rx1817_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("370_1304282286.73") :method
.annotate 'line', 10
    $P1819 = self."!PREFIX__!subrule"("ws", "[")
    new $P1820, "ResizablePMCArray"
    push $P1820, $P1819
    .return ($P1820)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("371_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1825 = self."!PREFIX__!subrule"("ws", "[")
    new $P1826, "ResizablePMCArray"
    push $P1826, $P1825
    .return ($P1826)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("372_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1828_tgt
    .local int rx1828_pos
    .local int rx1828_off
    .local int rx1828_eos
    .local int rx1828_rep
    .local pmc rx1828_cur
    .local pmc rx1828_debug
    (rx1828_cur, rx1828_pos, rx1828_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1828_cur
    .local pmc match
    .lex "$/", match
    length rx1828_eos, rx1828_tgt
    gt rx1828_pos, rx1828_eos, rx1828_done
    set rx1828_off, 0
    lt rx1828_pos, 2, rx1828_start
    sub rx1828_off, rx1828_pos, 1
    substr rx1828_tgt, rx1828_tgt, rx1828_off
  rx1828_start:
    eq $I10, 1, rx1828_restart
    if_null rx1828_debug, debug_1353
    rx1828_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1353:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1831_done
    goto rxscan1831_scan
  rxscan1831_loop:
    (rx1828_pos) = rx1828_cur."from"()
    inc rx1828_pos
    rx1828_cur."!cursor_from"(rx1828_pos)
    ge rx1828_pos, rx1828_eos, rxscan1831_done
  rxscan1831_scan:
    set_addr $I10, rxscan1831_loop
    rx1828_cur."!mark_push"(0, rx1828_pos, $I10)
  rxscan1831_done:
.annotate 'line', 602
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1828_pos, rx1828_off
    substr $S10, rx1828_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1828_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1828_cur."!cursor_pos"(rx1828_pos)
    $P10 = rx1828_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1828_fail
    rx1828_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1828_pos = $P10."pos"()
  # rx pass
    rx1828_cur."!cursor_pass"(rx1828_pos, "circumfix:sym<ang>")
    if_null rx1828_debug, debug_1354
    rx1828_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1828_pos)
  debug_1354:
    .return (rx1828_cur)
  rx1828_restart:
.annotate 'line', 10
    if_null rx1828_debug, debug_1355
    rx1828_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1355:
  rx1828_fail:
    (rx1828_rep, rx1828_pos, $I10, $P10) = rx1828_cur."!mark_fail"(0)
    lt rx1828_pos, -1, rx1828_done
    eq rx1828_pos, -1, rx1828_fail
    jump $I10
  rx1828_done:
    rx1828_cur."!cursor_fail"()
    if_null rx1828_debug, debug_1356
    rx1828_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1356:
    .return (rx1828_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("373_1304282286.73") :method
.annotate 'line', 10
    new $P1830, "ResizablePMCArray"
    push $P1830, "<"
    .return ($P1830)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("374_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1833, "ResizablePMCArray"
    push $P1833, "<"
    .return ($P1833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("375_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1835_tgt
    .local int rx1835_pos
    .local int rx1835_off
    .local int rx1835_eos
    .local int rx1835_rep
    .local pmc rx1835_cur
    .local pmc rx1835_debug
    (rx1835_cur, rx1835_pos, rx1835_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1835_cur
    .local pmc match
    .lex "$/", match
    length rx1835_eos, rx1835_tgt
    gt rx1835_pos, rx1835_eos, rx1835_done
    set rx1835_off, 0
    lt rx1835_pos, 2, rx1835_start
    sub rx1835_off, rx1835_pos, 1
    substr rx1835_tgt, rx1835_tgt, rx1835_off
  rx1835_start:
    eq $I10, 1, rx1835_restart
    if_null rx1835_debug, debug_1357
    rx1835_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1838_done
    goto rxscan1838_scan
  rxscan1838_loop:
    (rx1835_pos) = rx1835_cur."from"()
    inc rx1835_pos
    rx1835_cur."!cursor_from"(rx1835_pos)
    ge rx1835_pos, rx1835_eos, rxscan1838_done
  rxscan1838_scan:
    set_addr $I10, rxscan1838_loop
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxscan1838_done:
.annotate 'line', 603
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1835_pos, rx1835_off
    substr $S10, rx1835_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1835_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1835_pos = $P10."pos"()
  # rx pass
    rx1835_cur."!cursor_pass"(rx1835_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1835_debug, debug_1358
    rx1835_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1835_pos)
  debug_1358:
    .return (rx1835_cur)
  rx1835_restart:
.annotate 'line', 10
    if_null rx1835_debug, debug_1359
    rx1835_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1359:
  rx1835_fail:
    (rx1835_rep, rx1835_pos, $I10, $P10) = rx1835_cur."!mark_fail"(0)
    lt rx1835_pos, -1, rx1835_done
    eq rx1835_pos, -1, rx1835_fail
    jump $I10
  rx1835_done:
    rx1835_cur."!cursor_fail"()
    if_null rx1835_debug, debug_1360
    rx1835_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1360:
    .return (rx1835_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("376_1304282286.73") :method
.annotate 'line', 10
    new $P1837, "ResizablePMCArray"
    push $P1837, unicode:"\x{ab}"
    .return ($P1837)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("377_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1840, "ResizablePMCArray"
    push $P1840, unicode:"\x{ab}"
    .return ($P1840)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("378_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1842_tgt
    .local int rx1842_pos
    .local int rx1842_off
    .local int rx1842_eos
    .local int rx1842_rep
    .local pmc rx1842_cur
    .local pmc rx1842_debug
    (rx1842_cur, rx1842_pos, rx1842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1842_cur
    .local pmc match
    .lex "$/", match
    length rx1842_eos, rx1842_tgt
    gt rx1842_pos, rx1842_eos, rx1842_done
    set rx1842_off, 0
    lt rx1842_pos, 2, rx1842_start
    sub rx1842_off, rx1842_pos, 1
    substr rx1842_tgt, rx1842_tgt, rx1842_off
  rx1842_start:
    eq $I10, 1, rx1842_restart
    if_null rx1842_debug, debug_1361
    rx1842_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1361:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1845_done
    goto rxscan1845_scan
  rxscan1845_loop:
    (rx1842_pos) = rx1842_cur."from"()
    inc rx1842_pos
    rx1842_cur."!cursor_from"(rx1842_pos)
    ge rx1842_pos, rx1842_eos, rxscan1845_done
  rxscan1845_scan:
    set_addr $I10, rxscan1845_loop
    rx1842_cur."!mark_push"(0, rx1842_pos, $I10)
  rxscan1845_done:
.annotate 'line', 604
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1842_pos, rx1842_off
    substr $S10, rx1842_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1842_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1842_cur."!cursor_pos"(rx1842_pos)
    $P10 = rx1842_cur."pblock"()
    unless $P10, rx1842_fail
    rx1842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1842_pos = $P10."pos"()
  # rx pass
    rx1842_cur."!cursor_pass"(rx1842_pos, "circumfix:sym<{ }>")
    if_null rx1842_debug, debug_1362
    rx1842_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1842_pos)
  debug_1362:
    .return (rx1842_cur)
  rx1842_restart:
.annotate 'line', 10
    if_null rx1842_debug, debug_1363
    rx1842_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1363:
  rx1842_fail:
    (rx1842_rep, rx1842_pos, $I10, $P10) = rx1842_cur."!mark_fail"(0)
    lt rx1842_pos, -1, rx1842_done
    eq rx1842_pos, -1, rx1842_fail
    jump $I10
  rx1842_done:
    rx1842_cur."!cursor_fail"()
    if_null rx1842_debug, debug_1364
    rx1842_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1364:
    .return (rx1842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("379_1304282286.73") :method
.annotate 'line', 10
    new $P1844, "ResizablePMCArray"
    push $P1844, "{"
    .return ($P1844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("380_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1847, "ResizablePMCArray"
    push $P1847, "{"
    .return ($P1847)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("381_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1849_tgt
    .local int rx1849_pos
    .local int rx1849_off
    .local int rx1849_eos
    .local int rx1849_rep
    .local pmc rx1849_cur
    .local pmc rx1849_debug
    (rx1849_cur, rx1849_pos, rx1849_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1849_cur
    .local pmc match
    .lex "$/", match
    length rx1849_eos, rx1849_tgt
    gt rx1849_pos, rx1849_eos, rx1849_done
    set rx1849_off, 0
    lt rx1849_pos, 2, rx1849_start
    sub rx1849_off, rx1849_pos, 1
    substr rx1849_tgt, rx1849_tgt, rx1849_off
  rx1849_start:
    eq $I10, 1, rx1849_restart
    if_null rx1849_debug, debug_1365
    rx1849_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1853_done
    goto rxscan1853_scan
  rxscan1853_loop:
    (rx1849_pos) = rx1849_cur."from"()
    inc rx1849_pos
    rx1849_cur."!cursor_from"(rx1849_pos)
    ge rx1849_pos, rx1849_eos, rxscan1853_done
  rxscan1853_scan:
    set_addr $I10, rxscan1853_loop
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  rxscan1853_done:
.annotate 'line', 605
  # rx subrule "sigil" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."sigil"()
    unless $P10, rx1849_fail
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1849_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1849_pos, 1
    gt $I11, rx1849_eos, rx1849_fail
    sub $I11, rx1849_pos, rx1849_off
    ord $I11, rx1849_tgt, $I11
    ne $I11, 40, rx1849_fail
    add rx1849_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."semilist"()
    unless $P10, rx1849_fail
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1849_pos = $P10."pos"()
  alt1854_0:
    set_addr $I10, alt1854_1
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  # rx literal  ")"
    add $I11, rx1849_pos, 1
    gt $I11, rx1849_eos, rx1849_fail
    sub $I11, rx1849_pos, rx1849_off
    ord $I11, rx1849_tgt, $I11
    ne $I11, 41, rx1849_fail
    add rx1849_pos, 1
    goto alt1854_end
  alt1854_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."FAILGOAL"("')'")
    unless $P10, rx1849_fail
    goto rxsubrule1856_pass
  rxsubrule1856_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1849_fail
  rxsubrule1856_pass:
    set_addr $I10, rxsubrule1856_back
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10, $P10)
    rx1849_pos = $P10."pos"()
  alt1854_end:
  # rx pass
    rx1849_cur."!cursor_pass"(rx1849_pos, "circumfix:sym<sigil>")
    if_null rx1849_debug, debug_1366
    rx1849_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1849_pos)
  debug_1366:
    .return (rx1849_cur)
  rx1849_restart:
.annotate 'line', 10
    if_null rx1849_debug, debug_1367
    rx1849_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1367:
  rx1849_fail:
    (rx1849_rep, rx1849_pos, $I10, $P10) = rx1849_cur."!mark_fail"(0)
    lt rx1849_pos, -1, rx1849_done
    eq rx1849_pos, -1, rx1849_fail
    jump $I10
  rx1849_done:
    rx1849_cur."!cursor_fail"()
    if_null rx1849_debug, debug_1368
    rx1849_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1368:
    .return (rx1849_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("382_1304282286.73") :method
.annotate 'line', 10
    $P1851 = self."!PREFIX__!subrule"("sigil", "")
    new $P1852, "ResizablePMCArray"
    push $P1852, $P1851
    .return ($P1852)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("383_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1858 = self."!PREFIX__!subrule"("sigil", "")
    new $P1859, "ResizablePMCArray"
    push $P1859, $P1858
    .return ($P1859)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("384_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1861_tgt
    .local int rx1861_pos
    .local int rx1861_off
    .local int rx1861_eos
    .local int rx1861_rep
    .local pmc rx1861_cur
    .local pmc rx1861_debug
    (rx1861_cur, rx1861_pos, rx1861_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1861_cur
    .local pmc match
    .lex "$/", match
    length rx1861_eos, rx1861_tgt
    gt rx1861_pos, rx1861_eos, rx1861_done
    set rx1861_off, 0
    lt rx1861_pos, 2, rx1861_start
    sub rx1861_off, rx1861_pos, 1
    substr rx1861_tgt, rx1861_tgt, rx1861_off
  rx1861_start:
    eq $I10, 1, rx1861_restart
    if_null rx1861_debug, debug_1369
    rx1861_cur."!cursor_debug"("START", "semilist")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1865_done
    goto rxscan1865_scan
  rxscan1865_loop:
    (rx1861_pos) = rx1861_cur."from"()
    inc rx1861_pos
    rx1861_cur."!cursor_from"(rx1861_pos)
    ge rx1861_pos, rx1861_eos, rxscan1865_done
  rxscan1865_scan:
    set_addr $I10, rxscan1865_loop
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  rxscan1865_done:
.annotate 'line', 607
  # rx subrule "ws" subtype=method negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."ws"()
    unless $P10, rx1861_fail
    rx1861_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."statement"()
    unless $P10, rx1861_fail
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1861_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."ws"()
    unless $P10, rx1861_fail
    rx1861_pos = $P10."pos"()
  # rx pass
    rx1861_cur."!cursor_pass"(rx1861_pos, "semilist")
    if_null rx1861_debug, debug_1370
    rx1861_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1861_pos)
  debug_1370:
    .return (rx1861_cur)
  rx1861_restart:
.annotate 'line', 10
    if_null rx1861_debug, debug_1371
    rx1861_cur."!cursor_debug"("NEXT", "semilist")
  debug_1371:
  rx1861_fail:
    (rx1861_rep, rx1861_pos, $I10, $P10) = rx1861_cur."!mark_fail"(0)
    lt rx1861_pos, -1, rx1861_done
    eq rx1861_pos, -1, rx1861_fail
    jump $I10
  rx1861_done:
    rx1861_cur."!cursor_fail"()
    if_null rx1861_debug, debug_1372
    rx1861_cur."!cursor_debug"("FAIL", "semilist")
  debug_1372:
    .return (rx1861_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("385_1304282286.73") :method
.annotate 'line', 10
    $P1863 = self."!PREFIX__!subrule"("ws", "")
    new $P1864, "ResizablePMCArray"
    push $P1864, $P1863
    .return ($P1864)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("386_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1869 = self."!PREFIX__!subrule"("ws", "")
    new $P1870, "ResizablePMCArray"
    push $P1870, $P1869
    .return ($P1870)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("387_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1872_tgt
    .local int rx1872_pos
    .local int rx1872_off
    .local int rx1872_eos
    .local int rx1872_rep
    .local pmc rx1872_cur
    .local pmc rx1872_debug
    (rx1872_cur, rx1872_pos, rx1872_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1872_cur
    .local pmc match
    .lex "$/", match
    length rx1872_eos, rx1872_tgt
    gt rx1872_pos, rx1872_eos, rx1872_done
    set rx1872_off, 0
    lt rx1872_pos, 2, rx1872_start
    sub rx1872_off, rx1872_pos, 1
    substr rx1872_tgt, rx1872_tgt, rx1872_off
  rx1872_start:
    eq $I10, 1, rx1872_restart
    if_null rx1872_debug, debug_1373
    rx1872_cur."!cursor_debug"("START", "infixish")
  debug_1373:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1875_done
    goto rxscan1875_scan
  rxscan1875_loop:
    (rx1872_pos) = rx1872_cur."from"()
    inc rx1872_pos
    rx1872_cur."!cursor_from"(rx1872_pos)
    ge rx1872_pos, rx1872_eos, rxscan1875_done
  rxscan1875_scan:
    set_addr $I10, rxscan1875_loop
    rx1872_cur."!mark_push"(0, rx1872_pos, $I10)
  rxscan1875_done:
.annotate 'line', 630
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1872_cur."!cursor_pos"(rx1872_pos)
    $P10 = rx1872_cur."infixstopper"()
    if $P10, rx1872_fail
  # rx subrule "infix" subtype=capture negate=
    rx1872_cur."!cursor_pos"(rx1872_pos)
    $P10 = rx1872_cur."infix"()
    unless $P10, rx1872_fail
    rx1872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1872_pos = $P10."pos"()
  # rx pass
    rx1872_cur."!cursor_pass"(rx1872_pos, "infixish")
    if_null rx1872_debug, debug_1374
    rx1872_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1872_pos)
  debug_1374:
    .return (rx1872_cur)
  rx1872_restart:
.annotate 'line', 10
    if_null rx1872_debug, debug_1375
    rx1872_cur."!cursor_debug"("NEXT", "infixish")
  debug_1375:
  rx1872_fail:
    (rx1872_rep, rx1872_pos, $I10, $P10) = rx1872_cur."!mark_fail"(0)
    lt rx1872_pos, -1, rx1872_done
    eq rx1872_pos, -1, rx1872_fail
    jump $I10
  rx1872_done:
    rx1872_cur."!cursor_fail"()
    if_null rx1872_debug, debug_1376
    rx1872_cur."!cursor_debug"("FAIL", "infixish")
  debug_1376:
    .return (rx1872_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("388_1304282286.73") :method
.annotate 'line', 10
    new $P1874, "ResizablePMCArray"
    push $P1874, ""
    .return ($P1874)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("389_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1877, "ResizablePMCArray"
    push $P1877, ""
    .return ($P1877)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("390_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1879_tgt
    .local int rx1879_pos
    .local int rx1879_off
    .local int rx1879_eos
    .local int rx1879_rep
    .local pmc rx1879_cur
    .local pmc rx1879_debug
    (rx1879_cur, rx1879_pos, rx1879_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1879_cur
    .local pmc match
    .lex "$/", match
    length rx1879_eos, rx1879_tgt
    gt rx1879_pos, rx1879_eos, rx1879_done
    set rx1879_off, 0
    lt rx1879_pos, 2, rx1879_start
    sub rx1879_off, rx1879_pos, 1
    substr rx1879_tgt, rx1879_tgt, rx1879_off
  rx1879_start:
    eq $I10, 1, rx1879_restart
    if_null rx1879_debug, debug_1377
    rx1879_cur."!cursor_debug"("START", "infixstopper")
  debug_1377:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1882_done
    goto rxscan1882_scan
  rxscan1882_loop:
    (rx1879_pos) = rx1879_cur."from"()
    inc rx1879_pos
    rx1879_cur."!cursor_from"(rx1879_pos)
    ge rx1879_pos, rx1879_eos, rxscan1882_done
  rxscan1882_scan:
    set_addr $I10, rxscan1882_loop
    rx1879_cur."!mark_push"(0, rx1879_pos, $I10)
  rxscan1882_done:
.annotate 'line', 631
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."lambda"()
    unless $P10, rx1879_fail
  # rx pass
    rx1879_cur."!cursor_pass"(rx1879_pos, "infixstopper")
    if_null rx1879_debug, debug_1378
    rx1879_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1879_pos)
  debug_1378:
    .return (rx1879_cur)
  rx1879_restart:
.annotate 'line', 10
    if_null rx1879_debug, debug_1379
    rx1879_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1379:
  rx1879_fail:
    (rx1879_rep, rx1879_pos, $I10, $P10) = rx1879_cur."!mark_fail"(0)
    lt rx1879_pos, -1, rx1879_done
    eq rx1879_pos, -1, rx1879_fail
    jump $I10
  rx1879_done:
    rx1879_cur."!cursor_fail"()
    if_null rx1879_debug, debug_1380
    rx1879_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1380:
    .return (rx1879_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("391_1304282286.73") :method
.annotate 'line', 10
    new $P1881, "ResizablePMCArray"
    push $P1881, ""
    .return ($P1881)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("392_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1884, "ResizablePMCArray"
    push $P1884, ""
    .return ($P1884)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("393_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1886_tgt
    .local int rx1886_pos
    .local int rx1886_off
    .local int rx1886_eos
    .local int rx1886_rep
    .local pmc rx1886_cur
    .local pmc rx1886_debug
    (rx1886_cur, rx1886_pos, rx1886_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1886_cur
    .local pmc match
    .lex "$/", match
    length rx1886_eos, rx1886_tgt
    gt rx1886_pos, rx1886_eos, rx1886_done
    set rx1886_off, 0
    lt rx1886_pos, 2, rx1886_start
    sub rx1886_off, rx1886_pos, 1
    substr rx1886_tgt, rx1886_tgt, rx1886_off
  rx1886_start:
    eq $I10, 1, rx1886_restart
    if_null rx1886_debug, debug_1381
    rx1886_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1381:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1890_done
    goto rxscan1890_scan
  rxscan1890_loop:
    (rx1886_pos) = rx1886_cur."from"()
    inc rx1886_pos
    rx1886_cur."!cursor_from"(rx1886_pos)
    ge rx1886_pos, rx1886_eos, rxscan1890_done
  rxscan1890_scan:
    set_addr $I10, rxscan1890_loop
    rx1886_cur."!mark_push"(0, rx1886_pos, $I10)
  rxscan1890_done:
.annotate 'line', 634
  # rx literal  "["
    add $I11, rx1886_pos, 1
    gt $I11, rx1886_eos, rx1886_fail
    sub $I11, rx1886_pos, rx1886_off
    ord $I11, rx1886_tgt, $I11
    ne $I11, 91, rx1886_fail
    add rx1886_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1886_cur."!cursor_pos"(rx1886_pos)
    $P10 = rx1886_cur."ws"()
    unless $P10, rx1886_fail
    rx1886_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1886_cur."!cursor_pos"(rx1886_pos)
    $P10 = rx1886_cur."EXPR"()
    unless $P10, rx1886_fail
    rx1886_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1886_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1886_pos, 1
    gt $I11, rx1886_eos, rx1886_fail
    sub $I11, rx1886_pos, rx1886_off
    ord $I11, rx1886_tgt, $I11
    ne $I11, 93, rx1886_fail
    add rx1886_pos, 1
.annotate 'line', 635
  # rx subrule "O" subtype=capture negate=
    rx1886_cur."!cursor_pos"(rx1886_pos)
    $P10 = rx1886_cur."O"("%methodop")
    unless $P10, rx1886_fail
    rx1886_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1886_pos = $P10."pos"()
.annotate 'line', 633
  # rx pass
    rx1886_cur."!cursor_pass"(rx1886_pos, "postcircumfix:sym<[ ]>")
    if_null rx1886_debug, debug_1382
    rx1886_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1886_pos)
  debug_1382:
    .return (rx1886_cur)
  rx1886_restart:
.annotate 'line', 10
    if_null rx1886_debug, debug_1383
    rx1886_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1383:
  rx1886_fail:
    (rx1886_rep, rx1886_pos, $I10, $P10) = rx1886_cur."!mark_fail"(0)
    lt rx1886_pos, -1, rx1886_done
    eq rx1886_pos, -1, rx1886_fail
    jump $I10
  rx1886_done:
    rx1886_cur."!cursor_fail"()
    if_null rx1886_debug, debug_1384
    rx1886_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1384:
    .return (rx1886_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("394_1304282286.73") :method
.annotate 'line', 10
    $P1888 = self."!PREFIX__!subrule"("ws", "[")
    new $P1889, "ResizablePMCArray"
    push $P1889, $P1888
    .return ($P1889)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("395_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1892 = self."!PREFIX__!subrule"("ws", "[")
    new $P1893, "ResizablePMCArray"
    push $P1893, $P1892
    .return ($P1893)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("396_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1895_tgt
    .local int rx1895_pos
    .local int rx1895_off
    .local int rx1895_eos
    .local int rx1895_rep
    .local pmc rx1895_cur
    .local pmc rx1895_debug
    (rx1895_cur, rx1895_pos, rx1895_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1895_cur
    .local pmc match
    .lex "$/", match
    length rx1895_eos, rx1895_tgt
    gt rx1895_pos, rx1895_eos, rx1895_done
    set rx1895_off, 0
    lt rx1895_pos, 2, rx1895_start
    sub rx1895_off, rx1895_pos, 1
    substr rx1895_tgt, rx1895_tgt, rx1895_off
  rx1895_start:
    eq $I10, 1, rx1895_restart
    if_null rx1895_debug, debug_1385
    rx1895_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1385:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1899_done
    goto rxscan1899_scan
  rxscan1899_loop:
    (rx1895_pos) = rx1895_cur."from"()
    inc rx1895_pos
    rx1895_cur."!cursor_from"(rx1895_pos)
    ge rx1895_pos, rx1895_eos, rxscan1899_done
  rxscan1899_scan:
    set_addr $I10, rxscan1899_loop
    rx1895_cur."!mark_push"(0, rx1895_pos, $I10)
  rxscan1899_done:
.annotate 'line', 639
  # rx literal  "{"
    add $I11, rx1895_pos, 1
    gt $I11, rx1895_eos, rx1895_fail
    sub $I11, rx1895_pos, rx1895_off
    ord $I11, rx1895_tgt, $I11
    ne $I11, 123, rx1895_fail
    add rx1895_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1895_cur."!cursor_pos"(rx1895_pos)
    $P10 = rx1895_cur."ws"()
    unless $P10, rx1895_fail
    rx1895_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1895_cur."!cursor_pos"(rx1895_pos)
    $P10 = rx1895_cur."EXPR"()
    unless $P10, rx1895_fail
    rx1895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1895_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1895_pos, 1
    gt $I11, rx1895_eos, rx1895_fail
    sub $I11, rx1895_pos, rx1895_off
    ord $I11, rx1895_tgt, $I11
    ne $I11, 125, rx1895_fail
    add rx1895_pos, 1
.annotate 'line', 640
  # rx subrule "O" subtype=capture negate=
    rx1895_cur."!cursor_pos"(rx1895_pos)
    $P10 = rx1895_cur."O"("%methodop")
    unless $P10, rx1895_fail
    rx1895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1895_pos = $P10."pos"()
.annotate 'line', 638
  # rx pass
    rx1895_cur."!cursor_pass"(rx1895_pos, "postcircumfix:sym<{ }>")
    if_null rx1895_debug, debug_1386
    rx1895_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1895_pos)
  debug_1386:
    .return (rx1895_cur)
  rx1895_restart:
.annotate 'line', 10
    if_null rx1895_debug, debug_1387
    rx1895_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1387:
  rx1895_fail:
    (rx1895_rep, rx1895_pos, $I10, $P10) = rx1895_cur."!mark_fail"(0)
    lt rx1895_pos, -1, rx1895_done
    eq rx1895_pos, -1, rx1895_fail
    jump $I10
  rx1895_done:
    rx1895_cur."!cursor_fail"()
    if_null rx1895_debug, debug_1388
    rx1895_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1388:
    .return (rx1895_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("397_1304282286.73") :method
.annotate 'line', 10
    $P1897 = self."!PREFIX__!subrule"("ws", "{")
    new $P1898, "ResizablePMCArray"
    push $P1898, $P1897
    .return ($P1898)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("398_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1901 = self."!PREFIX__!subrule"("ws", "{")
    new $P1902, "ResizablePMCArray"
    push $P1902, $P1901
    .return ($P1902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("399_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1904_tgt
    .local int rx1904_pos
    .local int rx1904_off
    .local int rx1904_eos
    .local int rx1904_rep
    .local pmc rx1904_cur
    .local pmc rx1904_debug
    (rx1904_cur, rx1904_pos, rx1904_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1904_cur
    .local pmc match
    .lex "$/", match
    length rx1904_eos, rx1904_tgt
    gt rx1904_pos, rx1904_eos, rx1904_done
    set rx1904_off, 0
    lt rx1904_pos, 2, rx1904_start
    sub rx1904_off, rx1904_pos, 1
    substr rx1904_tgt, rx1904_tgt, rx1904_off
  rx1904_start:
    eq $I10, 1, rx1904_restart
    if_null rx1904_debug, debug_1389
    rx1904_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1389:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1907_done
    goto rxscan1907_scan
  rxscan1907_loop:
    (rx1904_pos) = rx1904_cur."from"()
    inc rx1904_pos
    rx1904_cur."!cursor_from"(rx1904_pos)
    ge rx1904_pos, rx1904_eos, rxscan1907_done
  rxscan1907_scan:
    set_addr $I10, rxscan1907_loop
    rx1904_cur."!mark_push"(0, rx1904_pos, $I10)
  rxscan1907_done:
.annotate 'line', 644
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1904_pos, rx1904_off
    substr $S10, rx1904_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1904_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1904_cur."!cursor_pos"(rx1904_pos)
    $P10 = rx1904_cur."quote_EXPR"(":q")
    unless $P10, rx1904_fail
    rx1904_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1904_pos = $P10."pos"()
.annotate 'line', 645
  # rx subrule "O" subtype=capture negate=
    rx1904_cur."!cursor_pos"(rx1904_pos)
    $P10 = rx1904_cur."O"("%methodop")
    unless $P10, rx1904_fail
    rx1904_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1904_pos = $P10."pos"()
.annotate 'line', 643
  # rx pass
    rx1904_cur."!cursor_pass"(rx1904_pos, "postcircumfix:sym<ang>")
    if_null rx1904_debug, debug_1390
    rx1904_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1904_pos)
  debug_1390:
    .return (rx1904_cur)
  rx1904_restart:
.annotate 'line', 10
    if_null rx1904_debug, debug_1391
    rx1904_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1391:
  rx1904_fail:
    (rx1904_rep, rx1904_pos, $I10, $P10) = rx1904_cur."!mark_fail"(0)
    lt rx1904_pos, -1, rx1904_done
    eq rx1904_pos, -1, rx1904_fail
    jump $I10
  rx1904_done:
    rx1904_cur."!cursor_fail"()
    if_null rx1904_debug, debug_1392
    rx1904_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1392:
    .return (rx1904_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("400_1304282286.73") :method
.annotate 'line', 10
    new $P1906, "ResizablePMCArray"
    push $P1906, "<"
    .return ($P1906)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("401_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P1909, "ResizablePMCArray"
    push $P1909, "<"
    .return ($P1909)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("402_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1911_tgt
    .local int rx1911_pos
    .local int rx1911_off
    .local int rx1911_eos
    .local int rx1911_rep
    .local pmc rx1911_cur
    .local pmc rx1911_debug
    (rx1911_cur, rx1911_pos, rx1911_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1911_cur
    .local pmc match
    .lex "$/", match
    length rx1911_eos, rx1911_tgt
    gt rx1911_pos, rx1911_eos, rx1911_done
    set rx1911_off, 0
    lt rx1911_pos, 2, rx1911_start
    sub rx1911_off, rx1911_pos, 1
    substr rx1911_tgt, rx1911_tgt, rx1911_off
  rx1911_start:
    eq $I10, 1, rx1911_restart
    if_null rx1911_debug, debug_1393
    rx1911_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1393:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1915_done
    goto rxscan1915_scan
  rxscan1915_loop:
    (rx1911_pos) = rx1911_cur."from"()
    inc rx1911_pos
    rx1911_cur."!cursor_from"(rx1911_pos)
    ge rx1911_pos, rx1911_eos, rxscan1915_done
  rxscan1915_scan:
    set_addr $I10, rxscan1915_loop
    rx1911_cur."!mark_push"(0, rx1911_pos, $I10)
  rxscan1915_done:
.annotate 'line', 649
  # rx literal  "("
    add $I11, rx1911_pos, 1
    gt $I11, rx1911_eos, rx1911_fail
    sub $I11, rx1911_pos, rx1911_off
    ord $I11, rx1911_tgt, $I11
    ne $I11, 40, rx1911_fail
    add rx1911_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."ws"()
    unless $P10, rx1911_fail
    rx1911_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."arglist"()
    unless $P10, rx1911_fail
    rx1911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1911_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1911_pos, 1
    gt $I11, rx1911_eos, rx1911_fail
    sub $I11, rx1911_pos, rx1911_off
    ord $I11, rx1911_tgt, $I11
    ne $I11, 41, rx1911_fail
    add rx1911_pos, 1
.annotate 'line', 650
  # rx subrule "O" subtype=capture negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."O"("%methodop")
    unless $P10, rx1911_fail
    rx1911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1911_pos = $P10."pos"()
.annotate 'line', 648
  # rx pass
    rx1911_cur."!cursor_pass"(rx1911_pos, "postcircumfix:sym<( )>")
    if_null rx1911_debug, debug_1394
    rx1911_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1911_pos)
  debug_1394:
    .return (rx1911_cur)
  rx1911_restart:
.annotate 'line', 10
    if_null rx1911_debug, debug_1395
    rx1911_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1395:
  rx1911_fail:
    (rx1911_rep, rx1911_pos, $I10, $P10) = rx1911_cur."!mark_fail"(0)
    lt rx1911_pos, -1, rx1911_done
    eq rx1911_pos, -1, rx1911_fail
    jump $I10
  rx1911_done:
    rx1911_cur."!cursor_fail"()
    if_null rx1911_debug, debug_1396
    rx1911_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1396:
    .return (rx1911_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("403_1304282286.73") :method
.annotate 'line', 10
    $P1913 = self."!PREFIX__!subrule"("ws", "(")
    new $P1914, "ResizablePMCArray"
    push $P1914, $P1913
    .return ($P1914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("404_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1917 = self."!PREFIX__!subrule"("ws", "(")
    new $P1918, "ResizablePMCArray"
    push $P1918, $P1917
    .return ($P1918)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("405_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1920_tgt
    .local int rx1920_pos
    .local int rx1920_off
    .local int rx1920_eos
    .local int rx1920_rep
    .local pmc rx1920_cur
    .local pmc rx1920_debug
    (rx1920_cur, rx1920_pos, rx1920_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1920_cur
    .local pmc match
    .lex "$/", match
    length rx1920_eos, rx1920_tgt
    gt rx1920_pos, rx1920_eos, rx1920_done
    set rx1920_off, 0
    lt rx1920_pos, 2, rx1920_start
    sub rx1920_off, rx1920_pos, 1
    substr rx1920_tgt, rx1920_tgt, rx1920_off
  rx1920_start:
    eq $I10, 1, rx1920_restart
    if_null rx1920_debug, debug_1397
    rx1920_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1397:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1924_done
    goto rxscan1924_scan
  rxscan1924_loop:
    (rx1920_pos) = rx1920_cur."from"()
    inc rx1920_pos
    rx1920_cur."!cursor_from"(rx1920_pos)
    ge rx1920_pos, rx1920_eos, rxscan1924_done
  rxscan1924_scan:
    set_addr $I10, rxscan1924_loop
    rx1920_cur."!mark_push"(0, rx1920_pos, $I10)
  rxscan1924_done:
.annotate 'line', 653
  # rx subrule "dotty" subtype=capture negate=
    rx1920_cur."!cursor_pos"(rx1920_pos)
    $P10 = rx1920_cur."dotty"()
    unless $P10, rx1920_fail
    rx1920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1920_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1920_cur."!cursor_pos"(rx1920_pos)
    $P10 = rx1920_cur."O"("%methodop")
    unless $P10, rx1920_fail
    rx1920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1920_pos = $P10."pos"()
  # rx pass
    rx1920_cur."!cursor_pass"(rx1920_pos, "postfix:sym<.>")
    if_null rx1920_debug, debug_1398
    rx1920_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1920_pos)
  debug_1398:
    .return (rx1920_cur)
  rx1920_restart:
.annotate 'line', 10
    if_null rx1920_debug, debug_1399
    rx1920_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1399:
  rx1920_fail:
    (rx1920_rep, rx1920_pos, $I10, $P10) = rx1920_cur."!mark_fail"(0)
    lt rx1920_pos, -1, rx1920_done
    eq rx1920_pos, -1, rx1920_fail
    jump $I10
  rx1920_done:
    rx1920_cur."!cursor_fail"()
    if_null rx1920_debug, debug_1400
    rx1920_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1400:
    .return (rx1920_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("406_1304282286.73") :method
.annotate 'line', 10
    $P1922 = self."!PREFIX__!subrule"("dotty", "")
    new $P1923, "ResizablePMCArray"
    push $P1923, $P1922
    .return ($P1923)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("407_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1926 = self."!PREFIX__!subrule"("dotty", "")
    new $P1927, "ResizablePMCArray"
    push $P1927, $P1926
    .return ($P1927)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("408_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1929_tgt
    .local int rx1929_pos
    .local int rx1929_off
    .local int rx1929_eos
    .local int rx1929_rep
    .local pmc rx1929_cur
    .local pmc rx1929_debug
    (rx1929_cur, rx1929_pos, rx1929_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1929_cur
    .local pmc match
    .lex "$/", match
    length rx1929_eos, rx1929_tgt
    gt rx1929_pos, rx1929_eos, rx1929_done
    set rx1929_off, 0
    lt rx1929_pos, 2, rx1929_start
    sub rx1929_off, rx1929_pos, 1
    substr rx1929_tgt, rx1929_tgt, rx1929_off
  rx1929_start:
    eq $I10, 1, rx1929_restart
    if_null rx1929_debug, debug_1401
    rx1929_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1401:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1933_done
    goto rxscan1933_scan
  rxscan1933_loop:
    (rx1929_pos) = rx1929_cur."from"()
    inc rx1929_pos
    rx1929_cur."!cursor_from"(rx1929_pos)
    ge rx1929_pos, rx1929_eos, rxscan1933_done
  rxscan1933_scan:
    set_addr $I10, rxscan1933_loop
    rx1929_cur."!mark_push"(0, rx1929_pos, $I10)
  rxscan1933_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1934_fail
    rx1929_cur."!mark_push"(0, rx1929_pos, $I10)
  # rx literal  "++"
    add $I11, rx1929_pos, 2
    gt $I11, rx1929_eos, rx1929_fail
    sub $I11, rx1929_pos, rx1929_off
    substr $S10, rx1929_tgt, $I11, 2
    ne $S10, "++", rx1929_fail
    add rx1929_pos, 2
    set_addr $I10, rxcap_1934_fail
    ($I12, $I11) = rx1929_cur."!mark_peek"($I10)
    rx1929_cur."!cursor_pos"($I11)
    ($P10) = rx1929_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1929_pos, "")
    rx1929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1934_done
  rxcap_1934_fail:
    goto rx1929_fail
  rxcap_1934_done:
  # rx subrule "O" subtype=capture negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    $P10 = rx1929_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1929_fail
    rx1929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1929_pos = $P10."pos"()
  # rx pass
    rx1929_cur."!cursor_pass"(rx1929_pos, "prefix:sym<++>")
    if_null rx1929_debug, debug_1402
    rx1929_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1929_pos)
  debug_1402:
    .return (rx1929_cur)
  rx1929_restart:
.annotate 'line', 10
    if_null rx1929_debug, debug_1403
    rx1929_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1403:
  rx1929_fail:
    (rx1929_rep, rx1929_pos, $I10, $P10) = rx1929_cur."!mark_fail"(0)
    lt rx1929_pos, -1, rx1929_done
    eq rx1929_pos, -1, rx1929_fail
    jump $I10
  rx1929_done:
    rx1929_cur."!cursor_fail"()
    if_null rx1929_debug, debug_1404
    rx1929_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1404:
    .return (rx1929_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("409_1304282286.73") :method
.annotate 'line', 10
    $P1931 = self."!PREFIX__!subrule"("O", "++")
    new $P1932, "ResizablePMCArray"
    push $P1932, $P1931
    .return ($P1932)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("410_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1936 = self."!PREFIX__!subrule"("O", "++")
    new $P1937, "ResizablePMCArray"
    push $P1937, $P1936
    .return ($P1937)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("411_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1939_tgt
    .local int rx1939_pos
    .local int rx1939_off
    .local int rx1939_eos
    .local int rx1939_rep
    .local pmc rx1939_cur
    .local pmc rx1939_debug
    (rx1939_cur, rx1939_pos, rx1939_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1939_cur
    .local pmc match
    .lex "$/", match
    length rx1939_eos, rx1939_tgt
    gt rx1939_pos, rx1939_eos, rx1939_done
    set rx1939_off, 0
    lt rx1939_pos, 2, rx1939_start
    sub rx1939_off, rx1939_pos, 1
    substr rx1939_tgt, rx1939_tgt, rx1939_off
  rx1939_start:
    eq $I10, 1, rx1939_restart
    if_null rx1939_debug, debug_1405
    rx1939_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1405:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1943_done
    goto rxscan1943_scan
  rxscan1943_loop:
    (rx1939_pos) = rx1939_cur."from"()
    inc rx1939_pos
    rx1939_cur."!cursor_from"(rx1939_pos)
    ge rx1939_pos, rx1939_eos, rxscan1943_done
  rxscan1943_scan:
    set_addr $I10, rxscan1943_loop
    rx1939_cur."!mark_push"(0, rx1939_pos, $I10)
  rxscan1943_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1944_fail
    rx1939_cur."!mark_push"(0, rx1939_pos, $I10)
  # rx literal  "--"
    add $I11, rx1939_pos, 2
    gt $I11, rx1939_eos, rx1939_fail
    sub $I11, rx1939_pos, rx1939_off
    substr $S10, rx1939_tgt, $I11, 2
    ne $S10, "--", rx1939_fail
    add rx1939_pos, 2
    set_addr $I10, rxcap_1944_fail
    ($I12, $I11) = rx1939_cur."!mark_peek"($I10)
    rx1939_cur."!cursor_pos"($I11)
    ($P10) = rx1939_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1939_pos, "")
    rx1939_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1944_done
  rxcap_1944_fail:
    goto rx1939_fail
  rxcap_1944_done:
  # rx subrule "O" subtype=capture negate=
    rx1939_cur."!cursor_pos"(rx1939_pos)
    $P10 = rx1939_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1939_fail
    rx1939_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1939_pos = $P10."pos"()
  # rx pass
    rx1939_cur."!cursor_pass"(rx1939_pos, "prefix:sym<-->")
    if_null rx1939_debug, debug_1406
    rx1939_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1939_pos)
  debug_1406:
    .return (rx1939_cur)
  rx1939_restart:
.annotate 'line', 10
    if_null rx1939_debug, debug_1407
    rx1939_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1407:
  rx1939_fail:
    (rx1939_rep, rx1939_pos, $I10, $P10) = rx1939_cur."!mark_fail"(0)
    lt rx1939_pos, -1, rx1939_done
    eq rx1939_pos, -1, rx1939_fail
    jump $I10
  rx1939_done:
    rx1939_cur."!cursor_fail"()
    if_null rx1939_debug, debug_1408
    rx1939_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1408:
    .return (rx1939_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("412_1304282286.73") :method
.annotate 'line', 10
    $P1941 = self."!PREFIX__!subrule"("O", "--")
    new $P1942, "ResizablePMCArray"
    push $P1942, $P1941
    .return ($P1942)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("413_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1946 = self."!PREFIX__!subrule"("O", "--")
    new $P1947, "ResizablePMCArray"
    push $P1947, $P1946
    .return ($P1947)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("414_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1949_tgt
    .local int rx1949_pos
    .local int rx1949_off
    .local int rx1949_eos
    .local int rx1949_rep
    .local pmc rx1949_cur
    .local pmc rx1949_debug
    (rx1949_cur, rx1949_pos, rx1949_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1949_cur
    .local pmc match
    .lex "$/", match
    length rx1949_eos, rx1949_tgt
    gt rx1949_pos, rx1949_eos, rx1949_done
    set rx1949_off, 0
    lt rx1949_pos, 2, rx1949_start
    sub rx1949_off, rx1949_pos, 1
    substr rx1949_tgt, rx1949_tgt, rx1949_off
  rx1949_start:
    eq $I10, 1, rx1949_restart
    if_null rx1949_debug, debug_1409
    rx1949_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1953_done
    goto rxscan1953_scan
  rxscan1953_loop:
    (rx1949_pos) = rx1949_cur."from"()
    inc rx1949_pos
    rx1949_cur."!cursor_from"(rx1949_pos)
    ge rx1949_pos, rx1949_eos, rxscan1953_done
  rxscan1953_scan:
    set_addr $I10, rxscan1953_loop
    rx1949_cur."!mark_push"(0, rx1949_pos, $I10)
  rxscan1953_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1954_fail
    rx1949_cur."!mark_push"(0, rx1949_pos, $I10)
  # rx literal  "++"
    add $I11, rx1949_pos, 2
    gt $I11, rx1949_eos, rx1949_fail
    sub $I11, rx1949_pos, rx1949_off
    substr $S10, rx1949_tgt, $I11, 2
    ne $S10, "++", rx1949_fail
    add rx1949_pos, 2
    set_addr $I10, rxcap_1954_fail
    ($I12, $I11) = rx1949_cur."!mark_peek"($I10)
    rx1949_cur."!cursor_pos"($I11)
    ($P10) = rx1949_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1949_pos, "")
    rx1949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1954_done
  rxcap_1954_fail:
    goto rx1949_fail
  rxcap_1954_done:
  # rx subrule "O" subtype=capture negate=
    rx1949_cur."!cursor_pos"(rx1949_pos)
    $P10 = rx1949_cur."O"("%autoincrement")
    unless $P10, rx1949_fail
    rx1949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1949_pos = $P10."pos"()
  # rx pass
    rx1949_cur."!cursor_pass"(rx1949_pos, "postfix:sym<++>")
    if_null rx1949_debug, debug_1410
    rx1949_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1949_pos)
  debug_1410:
    .return (rx1949_cur)
  rx1949_restart:
.annotate 'line', 10
    if_null rx1949_debug, debug_1411
    rx1949_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1411:
  rx1949_fail:
    (rx1949_rep, rx1949_pos, $I10, $P10) = rx1949_cur."!mark_fail"(0)
    lt rx1949_pos, -1, rx1949_done
    eq rx1949_pos, -1, rx1949_fail
    jump $I10
  rx1949_done:
    rx1949_cur."!cursor_fail"()
    if_null rx1949_debug, debug_1412
    rx1949_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1412:
    .return (rx1949_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("415_1304282286.73") :method
.annotate 'line', 10
    $P1951 = self."!PREFIX__!subrule"("O", "++")
    new $P1952, "ResizablePMCArray"
    push $P1952, $P1951
    .return ($P1952)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("416_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1956 = self."!PREFIX__!subrule"("O", "++")
    new $P1957, "ResizablePMCArray"
    push $P1957, $P1956
    .return ($P1957)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("417_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1959_tgt
    .local int rx1959_pos
    .local int rx1959_off
    .local int rx1959_eos
    .local int rx1959_rep
    .local pmc rx1959_cur
    .local pmc rx1959_debug
    (rx1959_cur, rx1959_pos, rx1959_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1959_cur
    .local pmc match
    .lex "$/", match
    length rx1959_eos, rx1959_tgt
    gt rx1959_pos, rx1959_eos, rx1959_done
    set rx1959_off, 0
    lt rx1959_pos, 2, rx1959_start
    sub rx1959_off, rx1959_pos, 1
    substr rx1959_tgt, rx1959_tgt, rx1959_off
  rx1959_start:
    eq $I10, 1, rx1959_restart
    if_null rx1959_debug, debug_1413
    rx1959_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1413:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1963_done
    goto rxscan1963_scan
  rxscan1963_loop:
    (rx1959_pos) = rx1959_cur."from"()
    inc rx1959_pos
    rx1959_cur."!cursor_from"(rx1959_pos)
    ge rx1959_pos, rx1959_eos, rxscan1963_done
  rxscan1963_scan:
    set_addr $I10, rxscan1963_loop
    rx1959_cur."!mark_push"(0, rx1959_pos, $I10)
  rxscan1963_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1964_fail
    rx1959_cur."!mark_push"(0, rx1959_pos, $I10)
  # rx literal  "--"
    add $I11, rx1959_pos, 2
    gt $I11, rx1959_eos, rx1959_fail
    sub $I11, rx1959_pos, rx1959_off
    substr $S10, rx1959_tgt, $I11, 2
    ne $S10, "--", rx1959_fail
    add rx1959_pos, 2
    set_addr $I10, rxcap_1964_fail
    ($I12, $I11) = rx1959_cur."!mark_peek"($I10)
    rx1959_cur."!cursor_pos"($I11)
    ($P10) = rx1959_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1959_pos, "")
    rx1959_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1964_done
  rxcap_1964_fail:
    goto rx1959_fail
  rxcap_1964_done:
  # rx subrule "O" subtype=capture negate=
    rx1959_cur."!cursor_pos"(rx1959_pos)
    $P10 = rx1959_cur."O"("%autoincrement")
    unless $P10, rx1959_fail
    rx1959_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1959_pos = $P10."pos"()
  # rx pass
    rx1959_cur."!cursor_pass"(rx1959_pos, "postfix:sym<-->")
    if_null rx1959_debug, debug_1414
    rx1959_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1959_pos)
  debug_1414:
    .return (rx1959_cur)
  rx1959_restart:
.annotate 'line', 10
    if_null rx1959_debug, debug_1415
    rx1959_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1415:
  rx1959_fail:
    (rx1959_rep, rx1959_pos, $I10, $P10) = rx1959_cur."!mark_fail"(0)
    lt rx1959_pos, -1, rx1959_done
    eq rx1959_pos, -1, rx1959_fail
    jump $I10
  rx1959_done:
    rx1959_cur."!cursor_fail"()
    if_null rx1959_debug, debug_1416
    rx1959_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1416:
    .return (rx1959_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("418_1304282286.73") :method
.annotate 'line', 10
    $P1961 = self."!PREFIX__!subrule"("O", "--")
    new $P1962, "ResizablePMCArray"
    push $P1962, $P1961
    .return ($P1962)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("419_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1966 = self."!PREFIX__!subrule"("O", "--")
    new $P1967, "ResizablePMCArray"
    push $P1967, $P1966
    .return ($P1967)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("420_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1969_tgt
    .local int rx1969_pos
    .local int rx1969_off
    .local int rx1969_eos
    .local int rx1969_rep
    .local pmc rx1969_cur
    .local pmc rx1969_debug
    (rx1969_cur, rx1969_pos, rx1969_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1969_cur
    .local pmc match
    .lex "$/", match
    length rx1969_eos, rx1969_tgt
    gt rx1969_pos, rx1969_eos, rx1969_done
    set rx1969_off, 0
    lt rx1969_pos, 2, rx1969_start
    sub rx1969_off, rx1969_pos, 1
    substr rx1969_tgt, rx1969_tgt, rx1969_off
  rx1969_start:
    eq $I10, 1, rx1969_restart
    if_null rx1969_debug, debug_1417
    rx1969_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1417:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1973_done
    goto rxscan1973_scan
  rxscan1973_loop:
    (rx1969_pos) = rx1969_cur."from"()
    inc rx1969_pos
    rx1969_cur."!cursor_from"(rx1969_pos)
    ge rx1969_pos, rx1969_eos, rxscan1973_done
  rxscan1973_scan:
    set_addr $I10, rxscan1973_loop
    rx1969_cur."!mark_push"(0, rx1969_pos, $I10)
  rxscan1973_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1974_fail
    rx1969_cur."!mark_push"(0, rx1969_pos, $I10)
  # rx literal  "**"
    add $I11, rx1969_pos, 2
    gt $I11, rx1969_eos, rx1969_fail
    sub $I11, rx1969_pos, rx1969_off
    substr $S10, rx1969_tgt, $I11, 2
    ne $S10, "**", rx1969_fail
    add rx1969_pos, 2
    set_addr $I10, rxcap_1974_fail
    ($I12, $I11) = rx1969_cur."!mark_peek"($I10)
    rx1969_cur."!cursor_pos"($I11)
    ($P10) = rx1969_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1969_pos, "")
    rx1969_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1974_done
  rxcap_1974_fail:
    goto rx1969_fail
  rxcap_1974_done:
  # rx subrule "O" subtype=capture negate=
    rx1969_cur."!cursor_pos"(rx1969_pos)
    $P10 = rx1969_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1969_fail
    rx1969_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1969_pos = $P10."pos"()
  # rx pass
    rx1969_cur."!cursor_pass"(rx1969_pos, "infix:sym<**>")
    if_null rx1969_debug, debug_1418
    rx1969_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1969_pos)
  debug_1418:
    .return (rx1969_cur)
  rx1969_restart:
.annotate 'line', 10
    if_null rx1969_debug, debug_1419
    rx1969_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1419:
  rx1969_fail:
    (rx1969_rep, rx1969_pos, $I10, $P10) = rx1969_cur."!mark_fail"(0)
    lt rx1969_pos, -1, rx1969_done
    eq rx1969_pos, -1, rx1969_fail
    jump $I10
  rx1969_done:
    rx1969_cur."!cursor_fail"()
    if_null rx1969_debug, debug_1420
    rx1969_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1420:
    .return (rx1969_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("421_1304282286.73") :method
.annotate 'line', 10
    $P1971 = self."!PREFIX__!subrule"("O", "**")
    new $P1972, "ResizablePMCArray"
    push $P1972, $P1971
    .return ($P1972)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("422_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1976 = self."!PREFIX__!subrule"("O", "**")
    new $P1977, "ResizablePMCArray"
    push $P1977, $P1976
    .return ($P1977)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("423_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1979_tgt
    .local int rx1979_pos
    .local int rx1979_off
    .local int rx1979_eos
    .local int rx1979_rep
    .local pmc rx1979_cur
    .local pmc rx1979_debug
    (rx1979_cur, rx1979_pos, rx1979_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1979_cur
    .local pmc match
    .lex "$/", match
    length rx1979_eos, rx1979_tgt
    gt rx1979_pos, rx1979_eos, rx1979_done
    set rx1979_off, 0
    lt rx1979_pos, 2, rx1979_start
    sub rx1979_off, rx1979_pos, 1
    substr rx1979_tgt, rx1979_tgt, rx1979_off
  rx1979_start:
    eq $I10, 1, rx1979_restart
    if_null rx1979_debug, debug_1421
    rx1979_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1983_done
    goto rxscan1983_scan
  rxscan1983_loop:
    (rx1979_pos) = rx1979_cur."from"()
    inc rx1979_pos
    rx1979_cur."!cursor_from"(rx1979_pos)
    ge rx1979_pos, rx1979_eos, rxscan1983_done
  rxscan1983_scan:
    set_addr $I10, rxscan1983_loop
    rx1979_cur."!mark_push"(0, rx1979_pos, $I10)
  rxscan1983_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1984_fail
    rx1979_cur."!mark_push"(0, rx1979_pos, $I10)
  # rx literal  "+"
    add $I11, rx1979_pos, 1
    gt $I11, rx1979_eos, rx1979_fail
    sub $I11, rx1979_pos, rx1979_off
    ord $I11, rx1979_tgt, $I11
    ne $I11, 43, rx1979_fail
    add rx1979_pos, 1
    set_addr $I10, rxcap_1984_fail
    ($I12, $I11) = rx1979_cur."!mark_peek"($I10)
    rx1979_cur."!cursor_pos"($I11)
    ($P10) = rx1979_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1979_pos, "")
    rx1979_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1984_done
  rxcap_1984_fail:
    goto rx1979_fail
  rxcap_1984_done:
  # rx subrule "O" subtype=capture negate=
    rx1979_cur."!cursor_pos"(rx1979_pos)
    $P10 = rx1979_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1979_fail
    rx1979_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1979_pos = $P10."pos"()
  # rx pass
    rx1979_cur."!cursor_pass"(rx1979_pos, "prefix:sym<+>")
    if_null rx1979_debug, debug_1422
    rx1979_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1979_pos)
  debug_1422:
    .return (rx1979_cur)
  rx1979_restart:
.annotate 'line', 10
    if_null rx1979_debug, debug_1423
    rx1979_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1423:
  rx1979_fail:
    (rx1979_rep, rx1979_pos, $I10, $P10) = rx1979_cur."!mark_fail"(0)
    lt rx1979_pos, -1, rx1979_done
    eq rx1979_pos, -1, rx1979_fail
    jump $I10
  rx1979_done:
    rx1979_cur."!cursor_fail"()
    if_null rx1979_debug, debug_1424
    rx1979_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1424:
    .return (rx1979_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("424_1304282286.73") :method
.annotate 'line', 10
    $P1981 = self."!PREFIX__!subrule"("O", "+")
    new $P1982, "ResizablePMCArray"
    push $P1982, $P1981
    .return ($P1982)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("425_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1986 = self."!PREFIX__!subrule"("O", "+")
    new $P1987, "ResizablePMCArray"
    push $P1987, $P1986
    .return ($P1987)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("426_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1989_tgt
    .local int rx1989_pos
    .local int rx1989_off
    .local int rx1989_eos
    .local int rx1989_rep
    .local pmc rx1989_cur
    .local pmc rx1989_debug
    (rx1989_cur, rx1989_pos, rx1989_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1989_cur
    .local pmc match
    .lex "$/", match
    length rx1989_eos, rx1989_tgt
    gt rx1989_pos, rx1989_eos, rx1989_done
    set rx1989_off, 0
    lt rx1989_pos, 2, rx1989_start
    sub rx1989_off, rx1989_pos, 1
    substr rx1989_tgt, rx1989_tgt, rx1989_off
  rx1989_start:
    eq $I10, 1, rx1989_restart
    if_null rx1989_debug, debug_1425
    rx1989_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1425:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1993_done
    goto rxscan1993_scan
  rxscan1993_loop:
    (rx1989_pos) = rx1989_cur."from"()
    inc rx1989_pos
    rx1989_cur."!cursor_from"(rx1989_pos)
    ge rx1989_pos, rx1989_eos, rxscan1993_done
  rxscan1993_scan:
    set_addr $I10, rxscan1993_loop
    rx1989_cur."!mark_push"(0, rx1989_pos, $I10)
  rxscan1993_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1994_fail
    rx1989_cur."!mark_push"(0, rx1989_pos, $I10)
  # rx literal  "~"
    add $I11, rx1989_pos, 1
    gt $I11, rx1989_eos, rx1989_fail
    sub $I11, rx1989_pos, rx1989_off
    ord $I11, rx1989_tgt, $I11
    ne $I11, 126, rx1989_fail
    add rx1989_pos, 1
    set_addr $I10, rxcap_1994_fail
    ($I12, $I11) = rx1989_cur."!mark_peek"($I10)
    rx1989_cur."!cursor_pos"($I11)
    ($P10) = rx1989_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1989_pos, "")
    rx1989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1994_done
  rxcap_1994_fail:
    goto rx1989_fail
  rxcap_1994_done:
  # rx subrule "O" subtype=capture negate=
    rx1989_cur."!cursor_pos"(rx1989_pos)
    $P10 = rx1989_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1989_fail
    rx1989_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1989_pos = $P10."pos"()
  # rx pass
    rx1989_cur."!cursor_pass"(rx1989_pos, "prefix:sym<~>")
    if_null rx1989_debug, debug_1426
    rx1989_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1989_pos)
  debug_1426:
    .return (rx1989_cur)
  rx1989_restart:
.annotate 'line', 10
    if_null rx1989_debug, debug_1427
    rx1989_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1427:
  rx1989_fail:
    (rx1989_rep, rx1989_pos, $I10, $P10) = rx1989_cur."!mark_fail"(0)
    lt rx1989_pos, -1, rx1989_done
    eq rx1989_pos, -1, rx1989_fail
    jump $I10
  rx1989_done:
    rx1989_cur."!cursor_fail"()
    if_null rx1989_debug, debug_1428
    rx1989_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1428:
    .return (rx1989_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("427_1304282286.73") :method
.annotate 'line', 10
    $P1991 = self."!PREFIX__!subrule"("O", "~")
    new $P1992, "ResizablePMCArray"
    push $P1992, $P1991
    .return ($P1992)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("428_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P1996 = self."!PREFIX__!subrule"("O", "~")
    new $P1997, "ResizablePMCArray"
    push $P1997, $P1996
    .return ($P1997)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("429_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx1999_tgt
    .local int rx1999_pos
    .local int rx1999_off
    .local int rx1999_eos
    .local int rx1999_rep
    .local pmc rx1999_cur
    .local pmc rx1999_debug
    (rx1999_cur, rx1999_pos, rx1999_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1999_cur
    .local pmc match
    .lex "$/", match
    length rx1999_eos, rx1999_tgt
    gt rx1999_pos, rx1999_eos, rx1999_done
    set rx1999_off, 0
    lt rx1999_pos, 2, rx1999_start
    sub rx1999_off, rx1999_pos, 1
    substr rx1999_tgt, rx1999_tgt, rx1999_off
  rx1999_start:
    eq $I10, 1, rx1999_restart
    if_null rx1999_debug, debug_1429
    rx1999_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1429:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2002_done
    goto rxscan2002_scan
  rxscan2002_loop:
    (rx1999_pos) = rx1999_cur."from"()
    inc rx1999_pos
    rx1999_cur."!cursor_from"(rx1999_pos)
    ge rx1999_pos, rx1999_eos, rxscan2002_done
  rxscan2002_scan:
    set_addr $I10, rxscan2002_loop
    rx1999_cur."!mark_push"(0, rx1999_pos, $I10)
  rxscan2002_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_2003_fail
    rx1999_cur."!mark_push"(0, rx1999_pos, $I10)
  # rx literal  "-"
    add $I11, rx1999_pos, 1
    gt $I11, rx1999_eos, rx1999_fail
    sub $I11, rx1999_pos, rx1999_off
    ord $I11, rx1999_tgt, $I11
    ne $I11, 45, rx1999_fail
    add rx1999_pos, 1
    set_addr $I10, rxcap_2003_fail
    ($I12, $I11) = rx1999_cur."!mark_peek"($I10)
    rx1999_cur."!cursor_pos"($I11)
    ($P10) = rx1999_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1999_pos, "")
    rx1999_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2003_done
  rxcap_2003_fail:
    goto rx1999_fail
  rxcap_2003_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1999_pos, rx1999_off
    substr $S10, rx1999_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1999_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1999_cur."!cursor_pos"(rx1999_pos)
    $P10 = rx1999_cur."number"()
    if $P10, rx1999_fail
  # rx subrule "O" subtype=capture negate=
    rx1999_cur."!cursor_pos"(rx1999_pos)
    $P10 = rx1999_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1999_fail
    rx1999_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1999_pos = $P10."pos"()
  # rx pass
    rx1999_cur."!cursor_pass"(rx1999_pos, "prefix:sym<->")
    if_null rx1999_debug, debug_1430
    rx1999_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1999_pos)
  debug_1430:
    .return (rx1999_cur)
  rx1999_restart:
.annotate 'line', 10
    if_null rx1999_debug, debug_1431
    rx1999_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1431:
  rx1999_fail:
    (rx1999_rep, rx1999_pos, $I10, $P10) = rx1999_cur."!mark_fail"(0)
    lt rx1999_pos, -1, rx1999_done
    eq rx1999_pos, -1, rx1999_fail
    jump $I10
  rx1999_done:
    rx1999_cur."!cursor_fail"()
    if_null rx1999_debug, debug_1432
    rx1999_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1432:
    .return (rx1999_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("430_1304282286.73") :method
.annotate 'line', 10
    new $P2001, "ResizablePMCArray"
    push $P2001, "-"
    .return ($P2001)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("431_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P2005, "ResizablePMCArray"
    push $P2005, "-"
    .return ($P2005)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("432_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2007_tgt
    .local int rx2007_pos
    .local int rx2007_off
    .local int rx2007_eos
    .local int rx2007_rep
    .local pmc rx2007_cur
    .local pmc rx2007_debug
    (rx2007_cur, rx2007_pos, rx2007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2007_cur
    .local pmc match
    .lex "$/", match
    length rx2007_eos, rx2007_tgt
    gt rx2007_pos, rx2007_eos, rx2007_done
    set rx2007_off, 0
    lt rx2007_pos, 2, rx2007_start
    sub rx2007_off, rx2007_pos, 1
    substr rx2007_tgt, rx2007_tgt, rx2007_off
  rx2007_start:
    eq $I10, 1, rx2007_restart
    if_null rx2007_debug, debug_1433
    rx2007_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2011_done
    goto rxscan2011_scan
  rxscan2011_loop:
    (rx2007_pos) = rx2007_cur."from"()
    inc rx2007_pos
    rx2007_cur."!cursor_from"(rx2007_pos)
    ge rx2007_pos, rx2007_eos, rxscan2011_done
  rxscan2011_scan:
    set_addr $I10, rxscan2011_loop
    rx2007_cur."!mark_push"(0, rx2007_pos, $I10)
  rxscan2011_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_2012_fail
    rx2007_cur."!mark_push"(0, rx2007_pos, $I10)
  # rx literal  "?"
    add $I11, rx2007_pos, 1
    gt $I11, rx2007_eos, rx2007_fail
    sub $I11, rx2007_pos, rx2007_off
    ord $I11, rx2007_tgt, $I11
    ne $I11, 63, rx2007_fail
    add rx2007_pos, 1
    set_addr $I10, rxcap_2012_fail
    ($I12, $I11) = rx2007_cur."!mark_peek"($I10)
    rx2007_cur."!cursor_pos"($I11)
    ($P10) = rx2007_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2007_pos, "")
    rx2007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2012_done
  rxcap_2012_fail:
    goto rx2007_fail
  rxcap_2012_done:
  # rx subrule "O" subtype=capture negate=
    rx2007_cur."!cursor_pos"(rx2007_pos)
    $P10 = rx2007_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2007_fail
    rx2007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2007_pos = $P10."pos"()
  # rx pass
    rx2007_cur."!cursor_pass"(rx2007_pos, "prefix:sym<?>")
    if_null rx2007_debug, debug_1434
    rx2007_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2007_pos)
  debug_1434:
    .return (rx2007_cur)
  rx2007_restart:
.annotate 'line', 10
    if_null rx2007_debug, debug_1435
    rx2007_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1435:
  rx2007_fail:
    (rx2007_rep, rx2007_pos, $I10, $P10) = rx2007_cur."!mark_fail"(0)
    lt rx2007_pos, -1, rx2007_done
    eq rx2007_pos, -1, rx2007_fail
    jump $I10
  rx2007_done:
    rx2007_cur."!cursor_fail"()
    if_null rx2007_debug, debug_1436
    rx2007_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1436:
    .return (rx2007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("433_1304282286.73") :method
.annotate 'line', 10
    $P2009 = self."!PREFIX__!subrule"("O", "?")
    new $P2010, "ResizablePMCArray"
    push $P2010, $P2009
    .return ($P2010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("434_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2014 = self."!PREFIX__!subrule"("O", "?")
    new $P2015, "ResizablePMCArray"
    push $P2015, $P2014
    .return ($P2015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("435_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2017_tgt
    .local int rx2017_pos
    .local int rx2017_off
    .local int rx2017_eos
    .local int rx2017_rep
    .local pmc rx2017_cur
    .local pmc rx2017_debug
    (rx2017_cur, rx2017_pos, rx2017_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2017_cur
    .local pmc match
    .lex "$/", match
    length rx2017_eos, rx2017_tgt
    gt rx2017_pos, rx2017_eos, rx2017_done
    set rx2017_off, 0
    lt rx2017_pos, 2, rx2017_start
    sub rx2017_off, rx2017_pos, 1
    substr rx2017_tgt, rx2017_tgt, rx2017_off
  rx2017_start:
    eq $I10, 1, rx2017_restart
    if_null rx2017_debug, debug_1437
    rx2017_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2021_done
    goto rxscan2021_scan
  rxscan2021_loop:
    (rx2017_pos) = rx2017_cur."from"()
    inc rx2017_pos
    rx2017_cur."!cursor_from"(rx2017_pos)
    ge rx2017_pos, rx2017_eos, rxscan2021_done
  rxscan2021_scan:
    set_addr $I10, rxscan2021_loop
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  rxscan2021_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_2022_fail
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  # rx literal  "!"
    add $I11, rx2017_pos, 1
    gt $I11, rx2017_eos, rx2017_fail
    sub $I11, rx2017_pos, rx2017_off
    ord $I11, rx2017_tgt, $I11
    ne $I11, 33, rx2017_fail
    add rx2017_pos, 1
    set_addr $I10, rxcap_2022_fail
    ($I12, $I11) = rx2017_cur."!mark_peek"($I10)
    rx2017_cur."!cursor_pos"($I11)
    ($P10) = rx2017_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2017_pos, "")
    rx2017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2022_done
  rxcap_2022_fail:
    goto rx2017_fail
  rxcap_2022_done:
  # rx subrule "O" subtype=capture negate=
    rx2017_cur."!cursor_pos"(rx2017_pos)
    $P10 = rx2017_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2017_fail
    rx2017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2017_pos = $P10."pos"()
  # rx pass
    rx2017_cur."!cursor_pass"(rx2017_pos, "prefix:sym<!>")
    if_null rx2017_debug, debug_1438
    rx2017_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2017_pos)
  debug_1438:
    .return (rx2017_cur)
  rx2017_restart:
.annotate 'line', 10
    if_null rx2017_debug, debug_1439
    rx2017_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1439:
  rx2017_fail:
    (rx2017_rep, rx2017_pos, $I10, $P10) = rx2017_cur."!mark_fail"(0)
    lt rx2017_pos, -1, rx2017_done
    eq rx2017_pos, -1, rx2017_fail
    jump $I10
  rx2017_done:
    rx2017_cur."!cursor_fail"()
    if_null rx2017_debug, debug_1440
    rx2017_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1440:
    .return (rx2017_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("436_1304282286.73") :method
.annotate 'line', 10
    $P2019 = self."!PREFIX__!subrule"("O", "!")
    new $P2020, "ResizablePMCArray"
    push $P2020, $P2019
    .return ($P2020)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("437_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2024 = self."!PREFIX__!subrule"("O", "!")
    new $P2025, "ResizablePMCArray"
    push $P2025, $P2024
    .return ($P2025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("438_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2027_tgt
    .local int rx2027_pos
    .local int rx2027_off
    .local int rx2027_eos
    .local int rx2027_rep
    .local pmc rx2027_cur
    .local pmc rx2027_debug
    (rx2027_cur, rx2027_pos, rx2027_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2027_cur
    .local pmc match
    .lex "$/", match
    length rx2027_eos, rx2027_tgt
    gt rx2027_pos, rx2027_eos, rx2027_done
    set rx2027_off, 0
    lt rx2027_pos, 2, rx2027_start
    sub rx2027_off, rx2027_pos, 1
    substr rx2027_tgt, rx2027_tgt, rx2027_off
  rx2027_start:
    eq $I10, 1, rx2027_restart
    if_null rx2027_debug, debug_1441
    rx2027_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2031_done
    goto rxscan2031_scan
  rxscan2031_loop:
    (rx2027_pos) = rx2027_cur."from"()
    inc rx2027_pos
    rx2027_cur."!cursor_from"(rx2027_pos)
    ge rx2027_pos, rx2027_eos, rxscan2031_done
  rxscan2031_scan:
    set_addr $I10, rxscan2031_loop
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  rxscan2031_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_2032_fail
    rx2027_cur."!mark_push"(0, rx2027_pos, $I10)
  # rx literal  "|"
    add $I11, rx2027_pos, 1
    gt $I11, rx2027_eos, rx2027_fail
    sub $I11, rx2027_pos, rx2027_off
    ord $I11, rx2027_tgt, $I11
    ne $I11, 124, rx2027_fail
    add rx2027_pos, 1
    set_addr $I10, rxcap_2032_fail
    ($I12, $I11) = rx2027_cur."!mark_peek"($I10)
    rx2027_cur."!cursor_pos"($I11)
    ($P10) = rx2027_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2027_pos, "")
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2032_done
  rxcap_2032_fail:
    goto rx2027_fail
  rxcap_2032_done:
  # rx subrule "O" subtype=capture negate=
    rx2027_cur."!cursor_pos"(rx2027_pos)
    $P10 = rx2027_cur."O"("%symbolic_unary")
    unless $P10, rx2027_fail
    rx2027_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2027_pos = $P10."pos"()
  # rx pass
    rx2027_cur."!cursor_pass"(rx2027_pos, "prefix:sym<|>")
    if_null rx2027_debug, debug_1442
    rx2027_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2027_pos)
  debug_1442:
    .return (rx2027_cur)
  rx2027_restart:
.annotate 'line', 10
    if_null rx2027_debug, debug_1443
    rx2027_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1443:
  rx2027_fail:
    (rx2027_rep, rx2027_pos, $I10, $P10) = rx2027_cur."!mark_fail"(0)
    lt rx2027_pos, -1, rx2027_done
    eq rx2027_pos, -1, rx2027_fail
    jump $I10
  rx2027_done:
    rx2027_cur."!cursor_fail"()
    if_null rx2027_debug, debug_1444
    rx2027_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1444:
    .return (rx2027_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("439_1304282286.73") :method
.annotate 'line', 10
    $P2029 = self."!PREFIX__!subrule"("O", "|")
    new $P2030, "ResizablePMCArray"
    push $P2030, $P2029
    .return ($P2030)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("440_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2034 = self."!PREFIX__!subrule"("O", "|")
    new $P2035, "ResizablePMCArray"
    push $P2035, $P2034
    .return ($P2035)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("441_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2037_tgt
    .local int rx2037_pos
    .local int rx2037_off
    .local int rx2037_eos
    .local int rx2037_rep
    .local pmc rx2037_cur
    .local pmc rx2037_debug
    (rx2037_cur, rx2037_pos, rx2037_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2037_cur
    .local pmc match
    .lex "$/", match
    length rx2037_eos, rx2037_tgt
    gt rx2037_pos, rx2037_eos, rx2037_done
    set rx2037_off, 0
    lt rx2037_pos, 2, rx2037_start
    sub rx2037_off, rx2037_pos, 1
    substr rx2037_tgt, rx2037_tgt, rx2037_off
  rx2037_start:
    eq $I10, 1, rx2037_restart
    if_null rx2037_debug, debug_1445
    rx2037_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2041_done
    goto rxscan2041_scan
  rxscan2041_loop:
    (rx2037_pos) = rx2037_cur."from"()
    inc rx2037_pos
    rx2037_cur."!cursor_from"(rx2037_pos)
    ge rx2037_pos, rx2037_eos, rxscan2041_done
  rxscan2041_scan:
    set_addr $I10, rxscan2041_loop
    rx2037_cur."!mark_push"(0, rx2037_pos, $I10)
  rxscan2041_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_2042_fail
    rx2037_cur."!mark_push"(0, rx2037_pos, $I10)
  # rx literal  "*"
    add $I11, rx2037_pos, 1
    gt $I11, rx2037_eos, rx2037_fail
    sub $I11, rx2037_pos, rx2037_off
    ord $I11, rx2037_tgt, $I11
    ne $I11, 42, rx2037_fail
    add rx2037_pos, 1
    set_addr $I10, rxcap_2042_fail
    ($I12, $I11) = rx2037_cur."!mark_peek"($I10)
    rx2037_cur."!cursor_pos"($I11)
    ($P10) = rx2037_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2037_pos, "")
    rx2037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2042_done
  rxcap_2042_fail:
    goto rx2037_fail
  rxcap_2042_done:
  # rx subrule "O" subtype=capture negate=
    rx2037_cur."!cursor_pos"(rx2037_pos)
    $P10 = rx2037_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2037_fail
    rx2037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2037_pos = $P10."pos"()
  # rx pass
    rx2037_cur."!cursor_pass"(rx2037_pos, "infix:sym<*>")
    if_null rx2037_debug, debug_1446
    rx2037_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2037_pos)
  debug_1446:
    .return (rx2037_cur)
  rx2037_restart:
.annotate 'line', 10
    if_null rx2037_debug, debug_1447
    rx2037_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1447:
  rx2037_fail:
    (rx2037_rep, rx2037_pos, $I10, $P10) = rx2037_cur."!mark_fail"(0)
    lt rx2037_pos, -1, rx2037_done
    eq rx2037_pos, -1, rx2037_fail
    jump $I10
  rx2037_done:
    rx2037_cur."!cursor_fail"()
    if_null rx2037_debug, debug_1448
    rx2037_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1448:
    .return (rx2037_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("442_1304282286.73") :method
.annotate 'line', 10
    $P2039 = self."!PREFIX__!subrule"("O", "*")
    new $P2040, "ResizablePMCArray"
    push $P2040, $P2039
    .return ($P2040)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("443_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2044 = self."!PREFIX__!subrule"("O", "*")
    new $P2045, "ResizablePMCArray"
    push $P2045, $P2044
    .return ($P2045)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("444_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2047_tgt
    .local int rx2047_pos
    .local int rx2047_off
    .local int rx2047_eos
    .local int rx2047_rep
    .local pmc rx2047_cur
    .local pmc rx2047_debug
    (rx2047_cur, rx2047_pos, rx2047_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2047_cur
    .local pmc match
    .lex "$/", match
    length rx2047_eos, rx2047_tgt
    gt rx2047_pos, rx2047_eos, rx2047_done
    set rx2047_off, 0
    lt rx2047_pos, 2, rx2047_start
    sub rx2047_off, rx2047_pos, 1
    substr rx2047_tgt, rx2047_tgt, rx2047_off
  rx2047_start:
    eq $I10, 1, rx2047_restart
    if_null rx2047_debug, debug_1449
    rx2047_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1449:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2051_done
    goto rxscan2051_scan
  rxscan2051_loop:
    (rx2047_pos) = rx2047_cur."from"()
    inc rx2047_pos
    rx2047_cur."!cursor_from"(rx2047_pos)
    ge rx2047_pos, rx2047_eos, rxscan2051_done
  rxscan2051_scan:
    set_addr $I10, rxscan2051_loop
    rx2047_cur."!mark_push"(0, rx2047_pos, $I10)
  rxscan2051_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_2052_fail
    rx2047_cur."!mark_push"(0, rx2047_pos, $I10)
  # rx literal  "/"
    add $I11, rx2047_pos, 1
    gt $I11, rx2047_eos, rx2047_fail
    sub $I11, rx2047_pos, rx2047_off
    ord $I11, rx2047_tgt, $I11
    ne $I11, 47, rx2047_fail
    add rx2047_pos, 1
    set_addr $I10, rxcap_2052_fail
    ($I12, $I11) = rx2047_cur."!mark_peek"($I10)
    rx2047_cur."!cursor_pos"($I11)
    ($P10) = rx2047_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2047_pos, "")
    rx2047_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2052_done
  rxcap_2052_fail:
    goto rx2047_fail
  rxcap_2052_done:
  # rx subrule "O" subtype=capture negate=
    rx2047_cur."!cursor_pos"(rx2047_pos)
    $P10 = rx2047_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2047_fail
    rx2047_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2047_pos = $P10."pos"()
  # rx pass
    rx2047_cur."!cursor_pass"(rx2047_pos, "infix:sym</>")
    if_null rx2047_debug, debug_1450
    rx2047_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2047_pos)
  debug_1450:
    .return (rx2047_cur)
  rx2047_restart:
.annotate 'line', 10
    if_null rx2047_debug, debug_1451
    rx2047_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1451:
  rx2047_fail:
    (rx2047_rep, rx2047_pos, $I10, $P10) = rx2047_cur."!mark_fail"(0)
    lt rx2047_pos, -1, rx2047_done
    eq rx2047_pos, -1, rx2047_fail
    jump $I10
  rx2047_done:
    rx2047_cur."!cursor_fail"()
    if_null rx2047_debug, debug_1452
    rx2047_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1452:
    .return (rx2047_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("445_1304282286.73") :method
.annotate 'line', 10
    $P2049 = self."!PREFIX__!subrule"("O", "/")
    new $P2050, "ResizablePMCArray"
    push $P2050, $P2049
    .return ($P2050)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("446_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2054 = self."!PREFIX__!subrule"("O", "/")
    new $P2055, "ResizablePMCArray"
    push $P2055, $P2054
    .return ($P2055)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("447_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2057_tgt
    .local int rx2057_pos
    .local int rx2057_off
    .local int rx2057_eos
    .local int rx2057_rep
    .local pmc rx2057_cur
    .local pmc rx2057_debug
    (rx2057_cur, rx2057_pos, rx2057_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2057_cur
    .local pmc match
    .lex "$/", match
    length rx2057_eos, rx2057_tgt
    gt rx2057_pos, rx2057_eos, rx2057_done
    set rx2057_off, 0
    lt rx2057_pos, 2, rx2057_start
    sub rx2057_off, rx2057_pos, 1
    substr rx2057_tgt, rx2057_tgt, rx2057_off
  rx2057_start:
    eq $I10, 1, rx2057_restart
    if_null rx2057_debug, debug_1453
    rx2057_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2061_done
    goto rxscan2061_scan
  rxscan2061_loop:
    (rx2057_pos) = rx2057_cur."from"()
    inc rx2057_pos
    rx2057_cur."!cursor_from"(rx2057_pos)
    ge rx2057_pos, rx2057_eos, rxscan2061_done
  rxscan2061_scan:
    set_addr $I10, rxscan2061_loop
    rx2057_cur."!mark_push"(0, rx2057_pos, $I10)
  rxscan2061_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_2062_fail
    rx2057_cur."!mark_push"(0, rx2057_pos, $I10)
  # rx literal  "%"
    add $I11, rx2057_pos, 1
    gt $I11, rx2057_eos, rx2057_fail
    sub $I11, rx2057_pos, rx2057_off
    ord $I11, rx2057_tgt, $I11
    ne $I11, 37, rx2057_fail
    add rx2057_pos, 1
    set_addr $I10, rxcap_2062_fail
    ($I12, $I11) = rx2057_cur."!mark_peek"($I10)
    rx2057_cur."!cursor_pos"($I11)
    ($P10) = rx2057_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2057_pos, "")
    rx2057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2062_done
  rxcap_2062_fail:
    goto rx2057_fail
  rxcap_2062_done:
  # rx subrule "O" subtype=capture negate=
    rx2057_cur."!cursor_pos"(rx2057_pos)
    $P10 = rx2057_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2057_fail
    rx2057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2057_pos = $P10."pos"()
  # rx pass
    rx2057_cur."!cursor_pass"(rx2057_pos, "infix:sym<%>")
    if_null rx2057_debug, debug_1454
    rx2057_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2057_pos)
  debug_1454:
    .return (rx2057_cur)
  rx2057_restart:
.annotate 'line', 10
    if_null rx2057_debug, debug_1455
    rx2057_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1455:
  rx2057_fail:
    (rx2057_rep, rx2057_pos, $I10, $P10) = rx2057_cur."!mark_fail"(0)
    lt rx2057_pos, -1, rx2057_done
    eq rx2057_pos, -1, rx2057_fail
    jump $I10
  rx2057_done:
    rx2057_cur."!cursor_fail"()
    if_null rx2057_debug, debug_1456
    rx2057_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1456:
    .return (rx2057_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("448_1304282286.73") :method
.annotate 'line', 10
    $P2059 = self."!PREFIX__!subrule"("O", "%")
    new $P2060, "ResizablePMCArray"
    push $P2060, $P2059
    .return ($P2060)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("449_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2064 = self."!PREFIX__!subrule"("O", "%")
    new $P2065, "ResizablePMCArray"
    push $P2065, $P2064
    .return ($P2065)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("450_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2067_tgt
    .local int rx2067_pos
    .local int rx2067_off
    .local int rx2067_eos
    .local int rx2067_rep
    .local pmc rx2067_cur
    .local pmc rx2067_debug
    (rx2067_cur, rx2067_pos, rx2067_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2067_cur
    .local pmc match
    .lex "$/", match
    length rx2067_eos, rx2067_tgt
    gt rx2067_pos, rx2067_eos, rx2067_done
    set rx2067_off, 0
    lt rx2067_pos, 2, rx2067_start
    sub rx2067_off, rx2067_pos, 1
    substr rx2067_tgt, rx2067_tgt, rx2067_off
  rx2067_start:
    eq $I10, 1, rx2067_restart
    if_null rx2067_debug, debug_1457
    rx2067_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2071_done
    goto rxscan2071_scan
  rxscan2071_loop:
    (rx2067_pos) = rx2067_cur."from"()
    inc rx2067_pos
    rx2067_cur."!cursor_from"(rx2067_pos)
    ge rx2067_pos, rx2067_eos, rxscan2071_done
  rxscan2071_scan:
    set_addr $I10, rxscan2071_loop
    rx2067_cur."!mark_push"(0, rx2067_pos, $I10)
  rxscan2071_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_2072_fail
    rx2067_cur."!mark_push"(0, rx2067_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2067_pos, 2
    gt $I11, rx2067_eos, rx2067_fail
    sub $I11, rx2067_pos, rx2067_off
    substr $S10, rx2067_tgt, $I11, 2
    ne $S10, "+&", rx2067_fail
    add rx2067_pos, 2
    set_addr $I10, rxcap_2072_fail
    ($I12, $I11) = rx2067_cur."!mark_peek"($I10)
    rx2067_cur."!cursor_pos"($I11)
    ($P10) = rx2067_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2067_pos, "")
    rx2067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2072_done
  rxcap_2072_fail:
    goto rx2067_fail
  rxcap_2072_done:
  # rx subrule "O" subtype=capture negate=
    rx2067_cur."!cursor_pos"(rx2067_pos)
    $P10 = rx2067_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2067_fail
    rx2067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2067_pos = $P10."pos"()
  # rx pass
    rx2067_cur."!cursor_pass"(rx2067_pos, "infix:sym<+&>")
    if_null rx2067_debug, debug_1458
    rx2067_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2067_pos)
  debug_1458:
    .return (rx2067_cur)
  rx2067_restart:
.annotate 'line', 10
    if_null rx2067_debug, debug_1459
    rx2067_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1459:
  rx2067_fail:
    (rx2067_rep, rx2067_pos, $I10, $P10) = rx2067_cur."!mark_fail"(0)
    lt rx2067_pos, -1, rx2067_done
    eq rx2067_pos, -1, rx2067_fail
    jump $I10
  rx2067_done:
    rx2067_cur."!cursor_fail"()
    if_null rx2067_debug, debug_1460
    rx2067_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1460:
    .return (rx2067_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("451_1304282286.73") :method
.annotate 'line', 10
    $P2069 = self."!PREFIX__!subrule"("O", "+&")
    new $P2070, "ResizablePMCArray"
    push $P2070, $P2069
    .return ($P2070)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("452_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2074 = self."!PREFIX__!subrule"("O", "+&")
    new $P2075, "ResizablePMCArray"
    push $P2075, $P2074
    .return ($P2075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("453_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2077_tgt
    .local int rx2077_pos
    .local int rx2077_off
    .local int rx2077_eos
    .local int rx2077_rep
    .local pmc rx2077_cur
    .local pmc rx2077_debug
    (rx2077_cur, rx2077_pos, rx2077_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2077_cur
    .local pmc match
    .lex "$/", match
    length rx2077_eos, rx2077_tgt
    gt rx2077_pos, rx2077_eos, rx2077_done
    set rx2077_off, 0
    lt rx2077_pos, 2, rx2077_start
    sub rx2077_off, rx2077_pos, 1
    substr rx2077_tgt, rx2077_tgt, rx2077_off
  rx2077_start:
    eq $I10, 1, rx2077_restart
    if_null rx2077_debug, debug_1461
    rx2077_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1461:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2081_done
    goto rxscan2081_scan
  rxscan2081_loop:
    (rx2077_pos) = rx2077_cur."from"()
    inc rx2077_pos
    rx2077_cur."!cursor_from"(rx2077_pos)
    ge rx2077_pos, rx2077_eos, rxscan2081_done
  rxscan2081_scan:
    set_addr $I10, rxscan2081_loop
    rx2077_cur."!mark_push"(0, rx2077_pos, $I10)
  rxscan2081_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_2082_fail
    rx2077_cur."!mark_push"(0, rx2077_pos, $I10)
  # rx literal  "+"
    add $I11, rx2077_pos, 1
    gt $I11, rx2077_eos, rx2077_fail
    sub $I11, rx2077_pos, rx2077_off
    ord $I11, rx2077_tgt, $I11
    ne $I11, 43, rx2077_fail
    add rx2077_pos, 1
    set_addr $I10, rxcap_2082_fail
    ($I12, $I11) = rx2077_cur."!mark_peek"($I10)
    rx2077_cur."!cursor_pos"($I11)
    ($P10) = rx2077_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2077_pos, "")
    rx2077_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2082_done
  rxcap_2082_fail:
    goto rx2077_fail
  rxcap_2082_done:
  # rx subrule "O" subtype=capture negate=
    rx2077_cur."!cursor_pos"(rx2077_pos)
    $P10 = rx2077_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2077_fail
    rx2077_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2077_pos = $P10."pos"()
  # rx pass
    rx2077_cur."!cursor_pass"(rx2077_pos, "infix:sym<+>")
    if_null rx2077_debug, debug_1462
    rx2077_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2077_pos)
  debug_1462:
    .return (rx2077_cur)
  rx2077_restart:
.annotate 'line', 10
    if_null rx2077_debug, debug_1463
    rx2077_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1463:
  rx2077_fail:
    (rx2077_rep, rx2077_pos, $I10, $P10) = rx2077_cur."!mark_fail"(0)
    lt rx2077_pos, -1, rx2077_done
    eq rx2077_pos, -1, rx2077_fail
    jump $I10
  rx2077_done:
    rx2077_cur."!cursor_fail"()
    if_null rx2077_debug, debug_1464
    rx2077_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1464:
    .return (rx2077_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("454_1304282286.73") :method
.annotate 'line', 10
    $P2079 = self."!PREFIX__!subrule"("O", "+")
    new $P2080, "ResizablePMCArray"
    push $P2080, $P2079
    .return ($P2080)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("455_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2084 = self."!PREFIX__!subrule"("O", "+")
    new $P2085, "ResizablePMCArray"
    push $P2085, $P2084
    .return ($P2085)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("456_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2087_tgt
    .local int rx2087_pos
    .local int rx2087_off
    .local int rx2087_eos
    .local int rx2087_rep
    .local pmc rx2087_cur
    .local pmc rx2087_debug
    (rx2087_cur, rx2087_pos, rx2087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2087_cur
    .local pmc match
    .lex "$/", match
    length rx2087_eos, rx2087_tgt
    gt rx2087_pos, rx2087_eos, rx2087_done
    set rx2087_off, 0
    lt rx2087_pos, 2, rx2087_start
    sub rx2087_off, rx2087_pos, 1
    substr rx2087_tgt, rx2087_tgt, rx2087_off
  rx2087_start:
    eq $I10, 1, rx2087_restart
    if_null rx2087_debug, debug_1465
    rx2087_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1465:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2091_done
    goto rxscan2091_scan
  rxscan2091_loop:
    (rx2087_pos) = rx2087_cur."from"()
    inc rx2087_pos
    rx2087_cur."!cursor_from"(rx2087_pos)
    ge rx2087_pos, rx2087_eos, rxscan2091_done
  rxscan2091_scan:
    set_addr $I10, rxscan2091_loop
    rx2087_cur."!mark_push"(0, rx2087_pos, $I10)
  rxscan2091_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_2092_fail
    rx2087_cur."!mark_push"(0, rx2087_pos, $I10)
  # rx literal  "-"
    add $I11, rx2087_pos, 1
    gt $I11, rx2087_eos, rx2087_fail
    sub $I11, rx2087_pos, rx2087_off
    ord $I11, rx2087_tgt, $I11
    ne $I11, 45, rx2087_fail
    add rx2087_pos, 1
    set_addr $I10, rxcap_2092_fail
    ($I12, $I11) = rx2087_cur."!mark_peek"($I10)
    rx2087_cur."!cursor_pos"($I11)
    ($P10) = rx2087_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2087_pos, "")
    rx2087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2092_done
  rxcap_2092_fail:
    goto rx2087_fail
  rxcap_2092_done:
  # rx subrule "O" subtype=capture negate=
    rx2087_cur."!cursor_pos"(rx2087_pos)
    $P10 = rx2087_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2087_fail
    rx2087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2087_pos = $P10."pos"()
  # rx pass
    rx2087_cur."!cursor_pass"(rx2087_pos, "infix:sym<->")
    if_null rx2087_debug, debug_1466
    rx2087_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2087_pos)
  debug_1466:
    .return (rx2087_cur)
  rx2087_restart:
.annotate 'line', 10
    if_null rx2087_debug, debug_1467
    rx2087_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1467:
  rx2087_fail:
    (rx2087_rep, rx2087_pos, $I10, $P10) = rx2087_cur."!mark_fail"(0)
    lt rx2087_pos, -1, rx2087_done
    eq rx2087_pos, -1, rx2087_fail
    jump $I10
  rx2087_done:
    rx2087_cur."!cursor_fail"()
    if_null rx2087_debug, debug_1468
    rx2087_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1468:
    .return (rx2087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("457_1304282286.73") :method
.annotate 'line', 10
    $P2089 = self."!PREFIX__!subrule"("O", "-")
    new $P2090, "ResizablePMCArray"
    push $P2090, $P2089
    .return ($P2090)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("458_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2094 = self."!PREFIX__!subrule"("O", "-")
    new $P2095, "ResizablePMCArray"
    push $P2095, $P2094
    .return ($P2095)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("459_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2097_tgt
    .local int rx2097_pos
    .local int rx2097_off
    .local int rx2097_eos
    .local int rx2097_rep
    .local pmc rx2097_cur
    .local pmc rx2097_debug
    (rx2097_cur, rx2097_pos, rx2097_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2097_cur
    .local pmc match
    .lex "$/", match
    length rx2097_eos, rx2097_tgt
    gt rx2097_pos, rx2097_eos, rx2097_done
    set rx2097_off, 0
    lt rx2097_pos, 2, rx2097_start
    sub rx2097_off, rx2097_pos, 1
    substr rx2097_tgt, rx2097_tgt, rx2097_off
  rx2097_start:
    eq $I10, 1, rx2097_restart
    if_null rx2097_debug, debug_1469
    rx2097_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1469:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2101_done
    goto rxscan2101_scan
  rxscan2101_loop:
    (rx2097_pos) = rx2097_cur."from"()
    inc rx2097_pos
    rx2097_cur."!cursor_from"(rx2097_pos)
    ge rx2097_pos, rx2097_eos, rxscan2101_done
  rxscan2101_scan:
    set_addr $I10, rxscan2101_loop
    rx2097_cur."!mark_push"(0, rx2097_pos, $I10)
  rxscan2101_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_2102_fail
    rx2097_cur."!mark_push"(0, rx2097_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2097_pos, 2
    gt $I11, rx2097_eos, rx2097_fail
    sub $I11, rx2097_pos, rx2097_off
    substr $S10, rx2097_tgt, $I11, 2
    ne $S10, "+|", rx2097_fail
    add rx2097_pos, 2
    set_addr $I10, rxcap_2102_fail
    ($I12, $I11) = rx2097_cur."!mark_peek"($I10)
    rx2097_cur."!cursor_pos"($I11)
    ($P10) = rx2097_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2097_pos, "")
    rx2097_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2102_done
  rxcap_2102_fail:
    goto rx2097_fail
  rxcap_2102_done:
  # rx subrule "O" subtype=capture negate=
    rx2097_cur."!cursor_pos"(rx2097_pos)
    $P10 = rx2097_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2097_fail
    rx2097_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2097_pos = $P10."pos"()
  # rx pass
    rx2097_cur."!cursor_pass"(rx2097_pos, "infix:sym<+|>")
    if_null rx2097_debug, debug_1470
    rx2097_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2097_pos)
  debug_1470:
    .return (rx2097_cur)
  rx2097_restart:
.annotate 'line', 10
    if_null rx2097_debug, debug_1471
    rx2097_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1471:
  rx2097_fail:
    (rx2097_rep, rx2097_pos, $I10, $P10) = rx2097_cur."!mark_fail"(0)
    lt rx2097_pos, -1, rx2097_done
    eq rx2097_pos, -1, rx2097_fail
    jump $I10
  rx2097_done:
    rx2097_cur."!cursor_fail"()
    if_null rx2097_debug, debug_1472
    rx2097_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1472:
    .return (rx2097_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("460_1304282286.73") :method
.annotate 'line', 10
    $P2099 = self."!PREFIX__!subrule"("O", "+|")
    new $P2100, "ResizablePMCArray"
    push $P2100, $P2099
    .return ($P2100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("461_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2104 = self."!PREFIX__!subrule"("O", "+|")
    new $P2105, "ResizablePMCArray"
    push $P2105, $P2104
    .return ($P2105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("462_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2107_tgt
    .local int rx2107_pos
    .local int rx2107_off
    .local int rx2107_eos
    .local int rx2107_rep
    .local pmc rx2107_cur
    .local pmc rx2107_debug
    (rx2107_cur, rx2107_pos, rx2107_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2107_cur
    .local pmc match
    .lex "$/", match
    length rx2107_eos, rx2107_tgt
    gt rx2107_pos, rx2107_eos, rx2107_done
    set rx2107_off, 0
    lt rx2107_pos, 2, rx2107_start
    sub rx2107_off, rx2107_pos, 1
    substr rx2107_tgt, rx2107_tgt, rx2107_off
  rx2107_start:
    eq $I10, 1, rx2107_restart
    if_null rx2107_debug, debug_1473
    rx2107_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1473:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2111_done
    goto rxscan2111_scan
  rxscan2111_loop:
    (rx2107_pos) = rx2107_cur."from"()
    inc rx2107_pos
    rx2107_cur."!cursor_from"(rx2107_pos)
    ge rx2107_pos, rx2107_eos, rxscan2111_done
  rxscan2111_scan:
    set_addr $I10, rxscan2111_loop
    rx2107_cur."!mark_push"(0, rx2107_pos, $I10)
  rxscan2111_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_2112_fail
    rx2107_cur."!mark_push"(0, rx2107_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2107_pos, 2
    gt $I11, rx2107_eos, rx2107_fail
    sub $I11, rx2107_pos, rx2107_off
    substr $S10, rx2107_tgt, $I11, 2
    ne $S10, "+^", rx2107_fail
    add rx2107_pos, 2
    set_addr $I10, rxcap_2112_fail
    ($I12, $I11) = rx2107_cur."!mark_peek"($I10)
    rx2107_cur."!cursor_pos"($I11)
    ($P10) = rx2107_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2107_pos, "")
    rx2107_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2112_done
  rxcap_2112_fail:
    goto rx2107_fail
  rxcap_2112_done:
  # rx subrule "O" subtype=capture negate=
    rx2107_cur."!cursor_pos"(rx2107_pos)
    $P10 = rx2107_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2107_fail
    rx2107_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2107_pos = $P10."pos"()
  # rx pass
    rx2107_cur."!cursor_pass"(rx2107_pos, "infix:sym<+^>")
    if_null rx2107_debug, debug_1474
    rx2107_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2107_pos)
  debug_1474:
    .return (rx2107_cur)
  rx2107_restart:
.annotate 'line', 10
    if_null rx2107_debug, debug_1475
    rx2107_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1475:
  rx2107_fail:
    (rx2107_rep, rx2107_pos, $I10, $P10) = rx2107_cur."!mark_fail"(0)
    lt rx2107_pos, -1, rx2107_done
    eq rx2107_pos, -1, rx2107_fail
    jump $I10
  rx2107_done:
    rx2107_cur."!cursor_fail"()
    if_null rx2107_debug, debug_1476
    rx2107_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1476:
    .return (rx2107_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("463_1304282286.73") :method
.annotate 'line', 10
    $P2109 = self."!PREFIX__!subrule"("O", "+^")
    new $P2110, "ResizablePMCArray"
    push $P2110, $P2109
    .return ($P2110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("464_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2114 = self."!PREFIX__!subrule"("O", "+^")
    new $P2115, "ResizablePMCArray"
    push $P2115, $P2114
    .return ($P2115)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("465_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2117_tgt
    .local int rx2117_pos
    .local int rx2117_off
    .local int rx2117_eos
    .local int rx2117_rep
    .local pmc rx2117_cur
    .local pmc rx2117_debug
    (rx2117_cur, rx2117_pos, rx2117_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2117_cur
    .local pmc match
    .lex "$/", match
    length rx2117_eos, rx2117_tgt
    gt rx2117_pos, rx2117_eos, rx2117_done
    set rx2117_off, 0
    lt rx2117_pos, 2, rx2117_start
    sub rx2117_off, rx2117_pos, 1
    substr rx2117_tgt, rx2117_tgt, rx2117_off
  rx2117_start:
    eq $I10, 1, rx2117_restart
    if_null rx2117_debug, debug_1477
    rx2117_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1477:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2121_done
    goto rxscan2121_scan
  rxscan2121_loop:
    (rx2117_pos) = rx2117_cur."from"()
    inc rx2117_pos
    rx2117_cur."!cursor_from"(rx2117_pos)
    ge rx2117_pos, rx2117_eos, rxscan2121_done
  rxscan2121_scan:
    set_addr $I10, rxscan2121_loop
    rx2117_cur."!mark_push"(0, rx2117_pos, $I10)
  rxscan2121_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_2122_fail
    rx2117_cur."!mark_push"(0, rx2117_pos, $I10)
  # rx literal  "~"
    add $I11, rx2117_pos, 1
    gt $I11, rx2117_eos, rx2117_fail
    sub $I11, rx2117_pos, rx2117_off
    ord $I11, rx2117_tgt, $I11
    ne $I11, 126, rx2117_fail
    add rx2117_pos, 1
    set_addr $I10, rxcap_2122_fail
    ($I12, $I11) = rx2117_cur."!mark_peek"($I10)
    rx2117_cur."!cursor_pos"($I11)
    ($P10) = rx2117_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2117_pos, "")
    rx2117_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2122_done
  rxcap_2122_fail:
    goto rx2117_fail
  rxcap_2122_done:
  # rx subrule "O" subtype=capture negate=
    rx2117_cur."!cursor_pos"(rx2117_pos)
    $P10 = rx2117_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2117_fail
    rx2117_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2117_pos = $P10."pos"()
  # rx pass
    rx2117_cur."!cursor_pass"(rx2117_pos, "infix:sym<~>")
    if_null rx2117_debug, debug_1478
    rx2117_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2117_pos)
  debug_1478:
    .return (rx2117_cur)
  rx2117_restart:
.annotate 'line', 10
    if_null rx2117_debug, debug_1479
    rx2117_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1479:
  rx2117_fail:
    (rx2117_rep, rx2117_pos, $I10, $P10) = rx2117_cur."!mark_fail"(0)
    lt rx2117_pos, -1, rx2117_done
    eq rx2117_pos, -1, rx2117_fail
    jump $I10
  rx2117_done:
    rx2117_cur."!cursor_fail"()
    if_null rx2117_debug, debug_1480
    rx2117_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1480:
    .return (rx2117_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("466_1304282286.73") :method
.annotate 'line', 10
    $P2119 = self."!PREFIX__!subrule"("O", "~")
    new $P2120, "ResizablePMCArray"
    push $P2120, $P2119
    .return ($P2120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("467_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2124 = self."!PREFIX__!subrule"("O", "~")
    new $P2125, "ResizablePMCArray"
    push $P2125, $P2124
    .return ($P2125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("468_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2127_tgt
    .local int rx2127_pos
    .local int rx2127_off
    .local int rx2127_eos
    .local int rx2127_rep
    .local pmc rx2127_cur
    .local pmc rx2127_debug
    (rx2127_cur, rx2127_pos, rx2127_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2127_cur
    .local pmc match
    .lex "$/", match
    length rx2127_eos, rx2127_tgt
    gt rx2127_pos, rx2127_eos, rx2127_done
    set rx2127_off, 0
    lt rx2127_pos, 2, rx2127_start
    sub rx2127_off, rx2127_pos, 1
    substr rx2127_tgt, rx2127_tgt, rx2127_off
  rx2127_start:
    eq $I10, 1, rx2127_restart
    if_null rx2127_debug, debug_1481
    rx2127_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1481:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2131_done
    goto rxscan2131_scan
  rxscan2131_loop:
    (rx2127_pos) = rx2127_cur."from"()
    inc rx2127_pos
    rx2127_cur."!cursor_from"(rx2127_pos)
    ge rx2127_pos, rx2127_eos, rxscan2131_done
  rxscan2131_scan:
    set_addr $I10, rxscan2131_loop
    rx2127_cur."!mark_push"(0, rx2127_pos, $I10)
  rxscan2131_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_2132_fail
    rx2127_cur."!mark_push"(0, rx2127_pos, $I10)
  # rx literal  "=="
    add $I11, rx2127_pos, 2
    gt $I11, rx2127_eos, rx2127_fail
    sub $I11, rx2127_pos, rx2127_off
    substr $S10, rx2127_tgt, $I11, 2
    ne $S10, "==", rx2127_fail
    add rx2127_pos, 2
    set_addr $I10, rxcap_2132_fail
    ($I12, $I11) = rx2127_cur."!mark_peek"($I10)
    rx2127_cur."!cursor_pos"($I11)
    ($P10) = rx2127_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2127_pos, "")
    rx2127_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2132_done
  rxcap_2132_fail:
    goto rx2127_fail
  rxcap_2132_done:
  # rx subrule "O" subtype=capture negate=
    rx2127_cur."!cursor_pos"(rx2127_pos)
    $P10 = rx2127_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2127_fail
    rx2127_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2127_pos = $P10."pos"()
  # rx pass
    rx2127_cur."!cursor_pass"(rx2127_pos, "infix:sym<==>")
    if_null rx2127_debug, debug_1482
    rx2127_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2127_pos)
  debug_1482:
    .return (rx2127_cur)
  rx2127_restart:
.annotate 'line', 10
    if_null rx2127_debug, debug_1483
    rx2127_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1483:
  rx2127_fail:
    (rx2127_rep, rx2127_pos, $I10, $P10) = rx2127_cur."!mark_fail"(0)
    lt rx2127_pos, -1, rx2127_done
    eq rx2127_pos, -1, rx2127_fail
    jump $I10
  rx2127_done:
    rx2127_cur."!cursor_fail"()
    if_null rx2127_debug, debug_1484
    rx2127_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1484:
    .return (rx2127_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("469_1304282286.73") :method
.annotate 'line', 10
    $P2129 = self."!PREFIX__!subrule"("O", "==")
    new $P2130, "ResizablePMCArray"
    push $P2130, $P2129
    .return ($P2130)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("470_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2134 = self."!PREFIX__!subrule"("O", "==")
    new $P2135, "ResizablePMCArray"
    push $P2135, $P2134
    .return ($P2135)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("471_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2137_tgt
    .local int rx2137_pos
    .local int rx2137_off
    .local int rx2137_eos
    .local int rx2137_rep
    .local pmc rx2137_cur
    .local pmc rx2137_debug
    (rx2137_cur, rx2137_pos, rx2137_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2137_cur
    .local pmc match
    .lex "$/", match
    length rx2137_eos, rx2137_tgt
    gt rx2137_pos, rx2137_eos, rx2137_done
    set rx2137_off, 0
    lt rx2137_pos, 2, rx2137_start
    sub rx2137_off, rx2137_pos, 1
    substr rx2137_tgt, rx2137_tgt, rx2137_off
  rx2137_start:
    eq $I10, 1, rx2137_restart
    if_null rx2137_debug, debug_1485
    rx2137_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1485:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2141_done
    goto rxscan2141_scan
  rxscan2141_loop:
    (rx2137_pos) = rx2137_cur."from"()
    inc rx2137_pos
    rx2137_cur."!cursor_from"(rx2137_pos)
    ge rx2137_pos, rx2137_eos, rxscan2141_done
  rxscan2141_scan:
    set_addr $I10, rxscan2141_loop
    rx2137_cur."!mark_push"(0, rx2137_pos, $I10)
  rxscan2141_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_2142_fail
    rx2137_cur."!mark_push"(0, rx2137_pos, $I10)
  # rx literal  "!="
    add $I11, rx2137_pos, 2
    gt $I11, rx2137_eos, rx2137_fail
    sub $I11, rx2137_pos, rx2137_off
    substr $S10, rx2137_tgt, $I11, 2
    ne $S10, "!=", rx2137_fail
    add rx2137_pos, 2
    set_addr $I10, rxcap_2142_fail
    ($I12, $I11) = rx2137_cur."!mark_peek"($I10)
    rx2137_cur."!cursor_pos"($I11)
    ($P10) = rx2137_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2137_pos, "")
    rx2137_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2142_done
  rxcap_2142_fail:
    goto rx2137_fail
  rxcap_2142_done:
  # rx subrule "O" subtype=capture negate=
    rx2137_cur."!cursor_pos"(rx2137_pos)
    $P10 = rx2137_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2137_fail
    rx2137_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2137_pos = $P10."pos"()
  # rx pass
    rx2137_cur."!cursor_pass"(rx2137_pos, "infix:sym<!=>")
    if_null rx2137_debug, debug_1486
    rx2137_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2137_pos)
  debug_1486:
    .return (rx2137_cur)
  rx2137_restart:
.annotate 'line', 10
    if_null rx2137_debug, debug_1487
    rx2137_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1487:
  rx2137_fail:
    (rx2137_rep, rx2137_pos, $I10, $P10) = rx2137_cur."!mark_fail"(0)
    lt rx2137_pos, -1, rx2137_done
    eq rx2137_pos, -1, rx2137_fail
    jump $I10
  rx2137_done:
    rx2137_cur."!cursor_fail"()
    if_null rx2137_debug, debug_1488
    rx2137_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1488:
    .return (rx2137_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("472_1304282286.73") :method
.annotate 'line', 10
    $P2139 = self."!PREFIX__!subrule"("O", "!=")
    new $P2140, "ResizablePMCArray"
    push $P2140, $P2139
    .return ($P2140)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("473_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2144 = self."!PREFIX__!subrule"("O", "!=")
    new $P2145, "ResizablePMCArray"
    push $P2145, $P2144
    .return ($P2145)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("474_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2147_tgt
    .local int rx2147_pos
    .local int rx2147_off
    .local int rx2147_eos
    .local int rx2147_rep
    .local pmc rx2147_cur
    .local pmc rx2147_debug
    (rx2147_cur, rx2147_pos, rx2147_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2147_cur
    .local pmc match
    .lex "$/", match
    length rx2147_eos, rx2147_tgt
    gt rx2147_pos, rx2147_eos, rx2147_done
    set rx2147_off, 0
    lt rx2147_pos, 2, rx2147_start
    sub rx2147_off, rx2147_pos, 1
    substr rx2147_tgt, rx2147_tgt, rx2147_off
  rx2147_start:
    eq $I10, 1, rx2147_restart
    if_null rx2147_debug, debug_1489
    rx2147_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1489:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2151_done
    goto rxscan2151_scan
  rxscan2151_loop:
    (rx2147_pos) = rx2147_cur."from"()
    inc rx2147_pos
    rx2147_cur."!cursor_from"(rx2147_pos)
    ge rx2147_pos, rx2147_eos, rxscan2151_done
  rxscan2151_scan:
    set_addr $I10, rxscan2151_loop
    rx2147_cur."!mark_push"(0, rx2147_pos, $I10)
  rxscan2151_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_2152_fail
    rx2147_cur."!mark_push"(0, rx2147_pos, $I10)
  # rx literal  "<="
    add $I11, rx2147_pos, 2
    gt $I11, rx2147_eos, rx2147_fail
    sub $I11, rx2147_pos, rx2147_off
    substr $S10, rx2147_tgt, $I11, 2
    ne $S10, "<=", rx2147_fail
    add rx2147_pos, 2
    set_addr $I10, rxcap_2152_fail
    ($I12, $I11) = rx2147_cur."!mark_peek"($I10)
    rx2147_cur."!cursor_pos"($I11)
    ($P10) = rx2147_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2147_pos, "")
    rx2147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2152_done
  rxcap_2152_fail:
    goto rx2147_fail
  rxcap_2152_done:
  # rx subrule "O" subtype=capture negate=
    rx2147_cur."!cursor_pos"(rx2147_pos)
    $P10 = rx2147_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2147_fail
    rx2147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2147_pos = $P10."pos"()
  # rx pass
    rx2147_cur."!cursor_pass"(rx2147_pos, "infix:sym<<=>")
    if_null rx2147_debug, debug_1490
    rx2147_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2147_pos)
  debug_1490:
    .return (rx2147_cur)
  rx2147_restart:
.annotate 'line', 10
    if_null rx2147_debug, debug_1491
    rx2147_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1491:
  rx2147_fail:
    (rx2147_rep, rx2147_pos, $I10, $P10) = rx2147_cur."!mark_fail"(0)
    lt rx2147_pos, -1, rx2147_done
    eq rx2147_pos, -1, rx2147_fail
    jump $I10
  rx2147_done:
    rx2147_cur."!cursor_fail"()
    if_null rx2147_debug, debug_1492
    rx2147_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1492:
    .return (rx2147_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("475_1304282286.73") :method
.annotate 'line', 10
    $P2149 = self."!PREFIX__!subrule"("O", "<=")
    new $P2150, "ResizablePMCArray"
    push $P2150, $P2149
    .return ($P2150)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("476_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2154 = self."!PREFIX__!subrule"("O", "<=")
    new $P2155, "ResizablePMCArray"
    push $P2155, $P2154
    .return ($P2155)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("477_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2157_tgt
    .local int rx2157_pos
    .local int rx2157_off
    .local int rx2157_eos
    .local int rx2157_rep
    .local pmc rx2157_cur
    .local pmc rx2157_debug
    (rx2157_cur, rx2157_pos, rx2157_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2157_cur
    .local pmc match
    .lex "$/", match
    length rx2157_eos, rx2157_tgt
    gt rx2157_pos, rx2157_eos, rx2157_done
    set rx2157_off, 0
    lt rx2157_pos, 2, rx2157_start
    sub rx2157_off, rx2157_pos, 1
    substr rx2157_tgt, rx2157_tgt, rx2157_off
  rx2157_start:
    eq $I10, 1, rx2157_restart
    if_null rx2157_debug, debug_1493
    rx2157_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1493:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2161_done
    goto rxscan2161_scan
  rxscan2161_loop:
    (rx2157_pos) = rx2157_cur."from"()
    inc rx2157_pos
    rx2157_cur."!cursor_from"(rx2157_pos)
    ge rx2157_pos, rx2157_eos, rxscan2161_done
  rxscan2161_scan:
    set_addr $I10, rxscan2161_loop
    rx2157_cur."!mark_push"(0, rx2157_pos, $I10)
  rxscan2161_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_2162_fail
    rx2157_cur."!mark_push"(0, rx2157_pos, $I10)
  # rx literal  ">="
    add $I11, rx2157_pos, 2
    gt $I11, rx2157_eos, rx2157_fail
    sub $I11, rx2157_pos, rx2157_off
    substr $S10, rx2157_tgt, $I11, 2
    ne $S10, ">=", rx2157_fail
    add rx2157_pos, 2
    set_addr $I10, rxcap_2162_fail
    ($I12, $I11) = rx2157_cur."!mark_peek"($I10)
    rx2157_cur."!cursor_pos"($I11)
    ($P10) = rx2157_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2157_pos, "")
    rx2157_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2162_done
  rxcap_2162_fail:
    goto rx2157_fail
  rxcap_2162_done:
  # rx subrule "O" subtype=capture negate=
    rx2157_cur."!cursor_pos"(rx2157_pos)
    $P10 = rx2157_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2157_fail
    rx2157_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2157_pos = $P10."pos"()
  # rx pass
    rx2157_cur."!cursor_pass"(rx2157_pos, "infix:sym<>=>")
    if_null rx2157_debug, debug_1494
    rx2157_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2157_pos)
  debug_1494:
    .return (rx2157_cur)
  rx2157_restart:
.annotate 'line', 10
    if_null rx2157_debug, debug_1495
    rx2157_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1495:
  rx2157_fail:
    (rx2157_rep, rx2157_pos, $I10, $P10) = rx2157_cur."!mark_fail"(0)
    lt rx2157_pos, -1, rx2157_done
    eq rx2157_pos, -1, rx2157_fail
    jump $I10
  rx2157_done:
    rx2157_cur."!cursor_fail"()
    if_null rx2157_debug, debug_1496
    rx2157_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1496:
    .return (rx2157_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("478_1304282286.73") :method
.annotate 'line', 10
    $P2159 = self."!PREFIX__!subrule"("O", ">=")
    new $P2160, "ResizablePMCArray"
    push $P2160, $P2159
    .return ($P2160)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("479_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2164 = self."!PREFIX__!subrule"("O", ">=")
    new $P2165, "ResizablePMCArray"
    push $P2165, $P2164
    .return ($P2165)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("480_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2167_tgt
    .local int rx2167_pos
    .local int rx2167_off
    .local int rx2167_eos
    .local int rx2167_rep
    .local pmc rx2167_cur
    .local pmc rx2167_debug
    (rx2167_cur, rx2167_pos, rx2167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2167_cur
    .local pmc match
    .lex "$/", match
    length rx2167_eos, rx2167_tgt
    gt rx2167_pos, rx2167_eos, rx2167_done
    set rx2167_off, 0
    lt rx2167_pos, 2, rx2167_start
    sub rx2167_off, rx2167_pos, 1
    substr rx2167_tgt, rx2167_tgt, rx2167_off
  rx2167_start:
    eq $I10, 1, rx2167_restart
    if_null rx2167_debug, debug_1497
    rx2167_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1497:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2171_done
    goto rxscan2171_scan
  rxscan2171_loop:
    (rx2167_pos) = rx2167_cur."from"()
    inc rx2167_pos
    rx2167_cur."!cursor_from"(rx2167_pos)
    ge rx2167_pos, rx2167_eos, rxscan2171_done
  rxscan2171_scan:
    set_addr $I10, rxscan2171_loop
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  rxscan2171_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_2172_fail
    rx2167_cur."!mark_push"(0, rx2167_pos, $I10)
  # rx literal  "<"
    add $I11, rx2167_pos, 1
    gt $I11, rx2167_eos, rx2167_fail
    sub $I11, rx2167_pos, rx2167_off
    ord $I11, rx2167_tgt, $I11
    ne $I11, 60, rx2167_fail
    add rx2167_pos, 1
    set_addr $I10, rxcap_2172_fail
    ($I12, $I11) = rx2167_cur."!mark_peek"($I10)
    rx2167_cur."!cursor_pos"($I11)
    ($P10) = rx2167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2167_pos, "")
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2172_done
  rxcap_2172_fail:
    goto rx2167_fail
  rxcap_2172_done:
  # rx subrule "O" subtype=capture negate=
    rx2167_cur."!cursor_pos"(rx2167_pos)
    $P10 = rx2167_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2167_fail
    rx2167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2167_pos = $P10."pos"()
  # rx pass
    rx2167_cur."!cursor_pass"(rx2167_pos, "infix:sym<<>")
    if_null rx2167_debug, debug_1498
    rx2167_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2167_pos)
  debug_1498:
    .return (rx2167_cur)
  rx2167_restart:
.annotate 'line', 10
    if_null rx2167_debug, debug_1499
    rx2167_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1499:
  rx2167_fail:
    (rx2167_rep, rx2167_pos, $I10, $P10) = rx2167_cur."!mark_fail"(0)
    lt rx2167_pos, -1, rx2167_done
    eq rx2167_pos, -1, rx2167_fail
    jump $I10
  rx2167_done:
    rx2167_cur."!cursor_fail"()
    if_null rx2167_debug, debug_1500
    rx2167_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1500:
    .return (rx2167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("481_1304282286.73") :method
.annotate 'line', 10
    $P2169 = self."!PREFIX__!subrule"("O", "<")
    new $P2170, "ResizablePMCArray"
    push $P2170, $P2169
    .return ($P2170)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("482_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2174 = self."!PREFIX__!subrule"("O", "<")
    new $P2175, "ResizablePMCArray"
    push $P2175, $P2174
    .return ($P2175)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("483_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2177_tgt
    .local int rx2177_pos
    .local int rx2177_off
    .local int rx2177_eos
    .local int rx2177_rep
    .local pmc rx2177_cur
    .local pmc rx2177_debug
    (rx2177_cur, rx2177_pos, rx2177_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2177_cur
    .local pmc match
    .lex "$/", match
    length rx2177_eos, rx2177_tgt
    gt rx2177_pos, rx2177_eos, rx2177_done
    set rx2177_off, 0
    lt rx2177_pos, 2, rx2177_start
    sub rx2177_off, rx2177_pos, 1
    substr rx2177_tgt, rx2177_tgt, rx2177_off
  rx2177_start:
    eq $I10, 1, rx2177_restart
    if_null rx2177_debug, debug_1501
    rx2177_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1501:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2181_done
    goto rxscan2181_scan
  rxscan2181_loop:
    (rx2177_pos) = rx2177_cur."from"()
    inc rx2177_pos
    rx2177_cur."!cursor_from"(rx2177_pos)
    ge rx2177_pos, rx2177_eos, rxscan2181_done
  rxscan2181_scan:
    set_addr $I10, rxscan2181_loop
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  rxscan2181_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_2182_fail
    rx2177_cur."!mark_push"(0, rx2177_pos, $I10)
  # rx literal  ">"
    add $I11, rx2177_pos, 1
    gt $I11, rx2177_eos, rx2177_fail
    sub $I11, rx2177_pos, rx2177_off
    ord $I11, rx2177_tgt, $I11
    ne $I11, 62, rx2177_fail
    add rx2177_pos, 1
    set_addr $I10, rxcap_2182_fail
    ($I12, $I11) = rx2177_cur."!mark_peek"($I10)
    rx2177_cur."!cursor_pos"($I11)
    ($P10) = rx2177_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2177_pos, "")
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2182_done
  rxcap_2182_fail:
    goto rx2177_fail
  rxcap_2182_done:
  # rx subrule "O" subtype=capture negate=
    rx2177_cur."!cursor_pos"(rx2177_pos)
    $P10 = rx2177_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2177_fail
    rx2177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2177_pos = $P10."pos"()
  # rx pass
    rx2177_cur."!cursor_pass"(rx2177_pos, "infix:sym<>>")
    if_null rx2177_debug, debug_1502
    rx2177_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2177_pos)
  debug_1502:
    .return (rx2177_cur)
  rx2177_restart:
.annotate 'line', 10
    if_null rx2177_debug, debug_1503
    rx2177_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1503:
  rx2177_fail:
    (rx2177_rep, rx2177_pos, $I10, $P10) = rx2177_cur."!mark_fail"(0)
    lt rx2177_pos, -1, rx2177_done
    eq rx2177_pos, -1, rx2177_fail
    jump $I10
  rx2177_done:
    rx2177_cur."!cursor_fail"()
    if_null rx2177_debug, debug_1504
    rx2177_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1504:
    .return (rx2177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("484_1304282286.73") :method
.annotate 'line', 10
    $P2179 = self."!PREFIX__!subrule"("O", ">")
    new $P2180, "ResizablePMCArray"
    push $P2180, $P2179
    .return ($P2180)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("485_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2184 = self."!PREFIX__!subrule"("O", ">")
    new $P2185, "ResizablePMCArray"
    push $P2185, $P2184
    .return ($P2185)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("486_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2187_tgt
    .local int rx2187_pos
    .local int rx2187_off
    .local int rx2187_eos
    .local int rx2187_rep
    .local pmc rx2187_cur
    .local pmc rx2187_debug
    (rx2187_cur, rx2187_pos, rx2187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2187_cur
    .local pmc match
    .lex "$/", match
    length rx2187_eos, rx2187_tgt
    gt rx2187_pos, rx2187_eos, rx2187_done
    set rx2187_off, 0
    lt rx2187_pos, 2, rx2187_start
    sub rx2187_off, rx2187_pos, 1
    substr rx2187_tgt, rx2187_tgt, rx2187_off
  rx2187_start:
    eq $I10, 1, rx2187_restart
    if_null rx2187_debug, debug_1505
    rx2187_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1505:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2191_done
    goto rxscan2191_scan
  rxscan2191_loop:
    (rx2187_pos) = rx2187_cur."from"()
    inc rx2187_pos
    rx2187_cur."!cursor_from"(rx2187_pos)
    ge rx2187_pos, rx2187_eos, rxscan2191_done
  rxscan2191_scan:
    set_addr $I10, rxscan2191_loop
    rx2187_cur."!mark_push"(0, rx2187_pos, $I10)
  rxscan2191_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_2192_fail
    rx2187_cur."!mark_push"(0, rx2187_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2187_pos, 2
    gt $I11, rx2187_eos, rx2187_fail
    sub $I11, rx2187_pos, rx2187_off
    substr $S10, rx2187_tgt, $I11, 2
    ne $S10, "eq", rx2187_fail
    add rx2187_pos, 2
    set_addr $I10, rxcap_2192_fail
    ($I12, $I11) = rx2187_cur."!mark_peek"($I10)
    rx2187_cur."!cursor_pos"($I11)
    ($P10) = rx2187_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2187_pos, "")
    rx2187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2192_done
  rxcap_2192_fail:
    goto rx2187_fail
  rxcap_2192_done:
  # rx subrule "O" subtype=capture negate=
    rx2187_cur."!cursor_pos"(rx2187_pos)
    $P10 = rx2187_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2187_fail
    rx2187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2187_pos = $P10."pos"()
  # rx pass
    rx2187_cur."!cursor_pass"(rx2187_pos, "infix:sym<eq>")
    if_null rx2187_debug, debug_1506
    rx2187_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2187_pos)
  debug_1506:
    .return (rx2187_cur)
  rx2187_restart:
.annotate 'line', 10
    if_null rx2187_debug, debug_1507
    rx2187_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1507:
  rx2187_fail:
    (rx2187_rep, rx2187_pos, $I10, $P10) = rx2187_cur."!mark_fail"(0)
    lt rx2187_pos, -1, rx2187_done
    eq rx2187_pos, -1, rx2187_fail
    jump $I10
  rx2187_done:
    rx2187_cur."!cursor_fail"()
    if_null rx2187_debug, debug_1508
    rx2187_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1508:
    .return (rx2187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("487_1304282286.73") :method
.annotate 'line', 10
    $P2189 = self."!PREFIX__!subrule"("O", "eq")
    new $P2190, "ResizablePMCArray"
    push $P2190, $P2189
    .return ($P2190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("488_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2194 = self."!PREFIX__!subrule"("O", "eq")
    new $P2195, "ResizablePMCArray"
    push $P2195, $P2194
    .return ($P2195)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("489_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2197_tgt
    .local int rx2197_pos
    .local int rx2197_off
    .local int rx2197_eos
    .local int rx2197_rep
    .local pmc rx2197_cur
    .local pmc rx2197_debug
    (rx2197_cur, rx2197_pos, rx2197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2197_cur
    .local pmc match
    .lex "$/", match
    length rx2197_eos, rx2197_tgt
    gt rx2197_pos, rx2197_eos, rx2197_done
    set rx2197_off, 0
    lt rx2197_pos, 2, rx2197_start
    sub rx2197_off, rx2197_pos, 1
    substr rx2197_tgt, rx2197_tgt, rx2197_off
  rx2197_start:
    eq $I10, 1, rx2197_restart
    if_null rx2197_debug, debug_1509
    rx2197_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1509:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2201_done
    goto rxscan2201_scan
  rxscan2201_loop:
    (rx2197_pos) = rx2197_cur."from"()
    inc rx2197_pos
    rx2197_cur."!cursor_from"(rx2197_pos)
    ge rx2197_pos, rx2197_eos, rxscan2201_done
  rxscan2201_scan:
    set_addr $I10, rxscan2201_loop
    rx2197_cur."!mark_push"(0, rx2197_pos, $I10)
  rxscan2201_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_2202_fail
    rx2197_cur."!mark_push"(0, rx2197_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2197_pos, 2
    gt $I11, rx2197_eos, rx2197_fail
    sub $I11, rx2197_pos, rx2197_off
    substr $S10, rx2197_tgt, $I11, 2
    ne $S10, "ne", rx2197_fail
    add rx2197_pos, 2
    set_addr $I10, rxcap_2202_fail
    ($I12, $I11) = rx2197_cur."!mark_peek"($I10)
    rx2197_cur."!cursor_pos"($I11)
    ($P10) = rx2197_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2197_pos, "")
    rx2197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2202_done
  rxcap_2202_fail:
    goto rx2197_fail
  rxcap_2202_done:
  # rx subrule "O" subtype=capture negate=
    rx2197_cur."!cursor_pos"(rx2197_pos)
    $P10 = rx2197_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2197_fail
    rx2197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2197_pos = $P10."pos"()
  # rx pass
    rx2197_cur."!cursor_pass"(rx2197_pos, "infix:sym<ne>")
    if_null rx2197_debug, debug_1510
    rx2197_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2197_pos)
  debug_1510:
    .return (rx2197_cur)
  rx2197_restart:
.annotate 'line', 10
    if_null rx2197_debug, debug_1511
    rx2197_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1511:
  rx2197_fail:
    (rx2197_rep, rx2197_pos, $I10, $P10) = rx2197_cur."!mark_fail"(0)
    lt rx2197_pos, -1, rx2197_done
    eq rx2197_pos, -1, rx2197_fail
    jump $I10
  rx2197_done:
    rx2197_cur."!cursor_fail"()
    if_null rx2197_debug, debug_1512
    rx2197_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1512:
    .return (rx2197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("490_1304282286.73") :method
.annotate 'line', 10
    $P2199 = self."!PREFIX__!subrule"("O", "ne")
    new $P2200, "ResizablePMCArray"
    push $P2200, $P2199
    .return ($P2200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("491_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2204 = self."!PREFIX__!subrule"("O", "ne")
    new $P2205, "ResizablePMCArray"
    push $P2205, $P2204
    .return ($P2205)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("492_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2207_tgt
    .local int rx2207_pos
    .local int rx2207_off
    .local int rx2207_eos
    .local int rx2207_rep
    .local pmc rx2207_cur
    .local pmc rx2207_debug
    (rx2207_cur, rx2207_pos, rx2207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2207_cur
    .local pmc match
    .lex "$/", match
    length rx2207_eos, rx2207_tgt
    gt rx2207_pos, rx2207_eos, rx2207_done
    set rx2207_off, 0
    lt rx2207_pos, 2, rx2207_start
    sub rx2207_off, rx2207_pos, 1
    substr rx2207_tgt, rx2207_tgt, rx2207_off
  rx2207_start:
    eq $I10, 1, rx2207_restart
    if_null rx2207_debug, debug_1513
    rx2207_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1513:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2211_done
    goto rxscan2211_scan
  rxscan2211_loop:
    (rx2207_pos) = rx2207_cur."from"()
    inc rx2207_pos
    rx2207_cur."!cursor_from"(rx2207_pos)
    ge rx2207_pos, rx2207_eos, rxscan2211_done
  rxscan2211_scan:
    set_addr $I10, rxscan2211_loop
    rx2207_cur."!mark_push"(0, rx2207_pos, $I10)
  rxscan2211_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_2212_fail
    rx2207_cur."!mark_push"(0, rx2207_pos, $I10)
  # rx literal  "le"
    add $I11, rx2207_pos, 2
    gt $I11, rx2207_eos, rx2207_fail
    sub $I11, rx2207_pos, rx2207_off
    substr $S10, rx2207_tgt, $I11, 2
    ne $S10, "le", rx2207_fail
    add rx2207_pos, 2
    set_addr $I10, rxcap_2212_fail
    ($I12, $I11) = rx2207_cur."!mark_peek"($I10)
    rx2207_cur."!cursor_pos"($I11)
    ($P10) = rx2207_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2207_pos, "")
    rx2207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2212_done
  rxcap_2212_fail:
    goto rx2207_fail
  rxcap_2212_done:
  # rx subrule "O" subtype=capture negate=
    rx2207_cur."!cursor_pos"(rx2207_pos)
    $P10 = rx2207_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2207_fail
    rx2207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2207_pos = $P10."pos"()
  # rx pass
    rx2207_cur."!cursor_pass"(rx2207_pos, "infix:sym<le>")
    if_null rx2207_debug, debug_1514
    rx2207_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2207_pos)
  debug_1514:
    .return (rx2207_cur)
  rx2207_restart:
.annotate 'line', 10
    if_null rx2207_debug, debug_1515
    rx2207_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1515:
  rx2207_fail:
    (rx2207_rep, rx2207_pos, $I10, $P10) = rx2207_cur."!mark_fail"(0)
    lt rx2207_pos, -1, rx2207_done
    eq rx2207_pos, -1, rx2207_fail
    jump $I10
  rx2207_done:
    rx2207_cur."!cursor_fail"()
    if_null rx2207_debug, debug_1516
    rx2207_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1516:
    .return (rx2207_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("493_1304282286.73") :method
.annotate 'line', 10
    $P2209 = self."!PREFIX__!subrule"("O", "le")
    new $P2210, "ResizablePMCArray"
    push $P2210, $P2209
    .return ($P2210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("494_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2214 = self."!PREFIX__!subrule"("O", "le")
    new $P2215, "ResizablePMCArray"
    push $P2215, $P2214
    .return ($P2215)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("495_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2217_tgt
    .local int rx2217_pos
    .local int rx2217_off
    .local int rx2217_eos
    .local int rx2217_rep
    .local pmc rx2217_cur
    .local pmc rx2217_debug
    (rx2217_cur, rx2217_pos, rx2217_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2217_cur
    .local pmc match
    .lex "$/", match
    length rx2217_eos, rx2217_tgt
    gt rx2217_pos, rx2217_eos, rx2217_done
    set rx2217_off, 0
    lt rx2217_pos, 2, rx2217_start
    sub rx2217_off, rx2217_pos, 1
    substr rx2217_tgt, rx2217_tgt, rx2217_off
  rx2217_start:
    eq $I10, 1, rx2217_restart
    if_null rx2217_debug, debug_1517
    rx2217_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1517:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2221_done
    goto rxscan2221_scan
  rxscan2221_loop:
    (rx2217_pos) = rx2217_cur."from"()
    inc rx2217_pos
    rx2217_cur."!cursor_from"(rx2217_pos)
    ge rx2217_pos, rx2217_eos, rxscan2221_done
  rxscan2221_scan:
    set_addr $I10, rxscan2221_loop
    rx2217_cur."!mark_push"(0, rx2217_pos, $I10)
  rxscan2221_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_2222_fail
    rx2217_cur."!mark_push"(0, rx2217_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2217_pos, 2
    gt $I11, rx2217_eos, rx2217_fail
    sub $I11, rx2217_pos, rx2217_off
    substr $S10, rx2217_tgt, $I11, 2
    ne $S10, "ge", rx2217_fail
    add rx2217_pos, 2
    set_addr $I10, rxcap_2222_fail
    ($I12, $I11) = rx2217_cur."!mark_peek"($I10)
    rx2217_cur."!cursor_pos"($I11)
    ($P10) = rx2217_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2217_pos, "")
    rx2217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2222_done
  rxcap_2222_fail:
    goto rx2217_fail
  rxcap_2222_done:
  # rx subrule "O" subtype=capture negate=
    rx2217_cur."!cursor_pos"(rx2217_pos)
    $P10 = rx2217_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2217_fail
    rx2217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2217_pos = $P10."pos"()
  # rx pass
    rx2217_cur."!cursor_pass"(rx2217_pos, "infix:sym<ge>")
    if_null rx2217_debug, debug_1518
    rx2217_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2217_pos)
  debug_1518:
    .return (rx2217_cur)
  rx2217_restart:
.annotate 'line', 10
    if_null rx2217_debug, debug_1519
    rx2217_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1519:
  rx2217_fail:
    (rx2217_rep, rx2217_pos, $I10, $P10) = rx2217_cur."!mark_fail"(0)
    lt rx2217_pos, -1, rx2217_done
    eq rx2217_pos, -1, rx2217_fail
    jump $I10
  rx2217_done:
    rx2217_cur."!cursor_fail"()
    if_null rx2217_debug, debug_1520
    rx2217_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1520:
    .return (rx2217_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("496_1304282286.73") :method
.annotate 'line', 10
    $P2219 = self."!PREFIX__!subrule"("O", "ge")
    new $P2220, "ResizablePMCArray"
    push $P2220, $P2219
    .return ($P2220)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("497_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2224 = self."!PREFIX__!subrule"("O", "ge")
    new $P2225, "ResizablePMCArray"
    push $P2225, $P2224
    .return ($P2225)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("498_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2227_tgt
    .local int rx2227_pos
    .local int rx2227_off
    .local int rx2227_eos
    .local int rx2227_rep
    .local pmc rx2227_cur
    .local pmc rx2227_debug
    (rx2227_cur, rx2227_pos, rx2227_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2227_cur
    .local pmc match
    .lex "$/", match
    length rx2227_eos, rx2227_tgt
    gt rx2227_pos, rx2227_eos, rx2227_done
    set rx2227_off, 0
    lt rx2227_pos, 2, rx2227_start
    sub rx2227_off, rx2227_pos, 1
    substr rx2227_tgt, rx2227_tgt, rx2227_off
  rx2227_start:
    eq $I10, 1, rx2227_restart
    if_null rx2227_debug, debug_1521
    rx2227_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1521:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2231_done
    goto rxscan2231_scan
  rxscan2231_loop:
    (rx2227_pos) = rx2227_cur."from"()
    inc rx2227_pos
    rx2227_cur."!cursor_from"(rx2227_pos)
    ge rx2227_pos, rx2227_eos, rxscan2231_done
  rxscan2231_scan:
    set_addr $I10, rxscan2231_loop
    rx2227_cur."!mark_push"(0, rx2227_pos, $I10)
  rxscan2231_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_2232_fail
    rx2227_cur."!mark_push"(0, rx2227_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2227_pos, 2
    gt $I11, rx2227_eos, rx2227_fail
    sub $I11, rx2227_pos, rx2227_off
    substr $S10, rx2227_tgt, $I11, 2
    ne $S10, "lt", rx2227_fail
    add rx2227_pos, 2
    set_addr $I10, rxcap_2232_fail
    ($I12, $I11) = rx2227_cur."!mark_peek"($I10)
    rx2227_cur."!cursor_pos"($I11)
    ($P10) = rx2227_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2227_pos, "")
    rx2227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2232_done
  rxcap_2232_fail:
    goto rx2227_fail
  rxcap_2232_done:
  # rx subrule "O" subtype=capture negate=
    rx2227_cur."!cursor_pos"(rx2227_pos)
    $P10 = rx2227_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2227_fail
    rx2227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2227_pos = $P10."pos"()
  # rx pass
    rx2227_cur."!cursor_pass"(rx2227_pos, "infix:sym<lt>")
    if_null rx2227_debug, debug_1522
    rx2227_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2227_pos)
  debug_1522:
    .return (rx2227_cur)
  rx2227_restart:
.annotate 'line', 10
    if_null rx2227_debug, debug_1523
    rx2227_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1523:
  rx2227_fail:
    (rx2227_rep, rx2227_pos, $I10, $P10) = rx2227_cur."!mark_fail"(0)
    lt rx2227_pos, -1, rx2227_done
    eq rx2227_pos, -1, rx2227_fail
    jump $I10
  rx2227_done:
    rx2227_cur."!cursor_fail"()
    if_null rx2227_debug, debug_1524
    rx2227_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1524:
    .return (rx2227_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("499_1304282286.73") :method
.annotate 'line', 10
    $P2229 = self."!PREFIX__!subrule"("O", "lt")
    new $P2230, "ResizablePMCArray"
    push $P2230, $P2229
    .return ($P2230)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("500_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2234 = self."!PREFIX__!subrule"("O", "lt")
    new $P2235, "ResizablePMCArray"
    push $P2235, $P2234
    .return ($P2235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("501_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2237_tgt
    .local int rx2237_pos
    .local int rx2237_off
    .local int rx2237_eos
    .local int rx2237_rep
    .local pmc rx2237_cur
    .local pmc rx2237_debug
    (rx2237_cur, rx2237_pos, rx2237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2237_cur
    .local pmc match
    .lex "$/", match
    length rx2237_eos, rx2237_tgt
    gt rx2237_pos, rx2237_eos, rx2237_done
    set rx2237_off, 0
    lt rx2237_pos, 2, rx2237_start
    sub rx2237_off, rx2237_pos, 1
    substr rx2237_tgt, rx2237_tgt, rx2237_off
  rx2237_start:
    eq $I10, 1, rx2237_restart
    if_null rx2237_debug, debug_1525
    rx2237_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1525:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2241_done
    goto rxscan2241_scan
  rxscan2241_loop:
    (rx2237_pos) = rx2237_cur."from"()
    inc rx2237_pos
    rx2237_cur."!cursor_from"(rx2237_pos)
    ge rx2237_pos, rx2237_eos, rxscan2241_done
  rxscan2241_scan:
    set_addr $I10, rxscan2241_loop
    rx2237_cur."!mark_push"(0, rx2237_pos, $I10)
  rxscan2241_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_2242_fail
    rx2237_cur."!mark_push"(0, rx2237_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2237_pos, 2
    gt $I11, rx2237_eos, rx2237_fail
    sub $I11, rx2237_pos, rx2237_off
    substr $S10, rx2237_tgt, $I11, 2
    ne $S10, "gt", rx2237_fail
    add rx2237_pos, 2
    set_addr $I10, rxcap_2242_fail
    ($I12, $I11) = rx2237_cur."!mark_peek"($I10)
    rx2237_cur."!cursor_pos"($I11)
    ($P10) = rx2237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2237_pos, "")
    rx2237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2242_done
  rxcap_2242_fail:
    goto rx2237_fail
  rxcap_2242_done:
  # rx subrule "O" subtype=capture negate=
    rx2237_cur."!cursor_pos"(rx2237_pos)
    $P10 = rx2237_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2237_fail
    rx2237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2237_pos = $P10."pos"()
  # rx pass
    rx2237_cur."!cursor_pass"(rx2237_pos, "infix:sym<gt>")
    if_null rx2237_debug, debug_1526
    rx2237_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2237_pos)
  debug_1526:
    .return (rx2237_cur)
  rx2237_restart:
.annotate 'line', 10
    if_null rx2237_debug, debug_1527
    rx2237_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1527:
  rx2237_fail:
    (rx2237_rep, rx2237_pos, $I10, $P10) = rx2237_cur."!mark_fail"(0)
    lt rx2237_pos, -1, rx2237_done
    eq rx2237_pos, -1, rx2237_fail
    jump $I10
  rx2237_done:
    rx2237_cur."!cursor_fail"()
    if_null rx2237_debug, debug_1528
    rx2237_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1528:
    .return (rx2237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("502_1304282286.73") :method
.annotate 'line', 10
    $P2239 = self."!PREFIX__!subrule"("O", "gt")
    new $P2240, "ResizablePMCArray"
    push $P2240, $P2239
    .return ($P2240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("503_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2244 = self."!PREFIX__!subrule"("O", "gt")
    new $P2245, "ResizablePMCArray"
    push $P2245, $P2244
    .return ($P2245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("504_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2247_tgt
    .local int rx2247_pos
    .local int rx2247_off
    .local int rx2247_eos
    .local int rx2247_rep
    .local pmc rx2247_cur
    .local pmc rx2247_debug
    (rx2247_cur, rx2247_pos, rx2247_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2247_cur
    .local pmc match
    .lex "$/", match
    length rx2247_eos, rx2247_tgt
    gt rx2247_pos, rx2247_eos, rx2247_done
    set rx2247_off, 0
    lt rx2247_pos, 2, rx2247_start
    sub rx2247_off, rx2247_pos, 1
    substr rx2247_tgt, rx2247_tgt, rx2247_off
  rx2247_start:
    eq $I10, 1, rx2247_restart
    if_null rx2247_debug, debug_1529
    rx2247_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1529:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2251_done
    goto rxscan2251_scan
  rxscan2251_loop:
    (rx2247_pos) = rx2247_cur."from"()
    inc rx2247_pos
    rx2247_cur."!cursor_from"(rx2247_pos)
    ge rx2247_pos, rx2247_eos, rxscan2251_done
  rxscan2251_scan:
    set_addr $I10, rxscan2251_loop
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  rxscan2251_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_2252_fail
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2247_pos, 3
    gt $I11, rx2247_eos, rx2247_fail
    sub $I11, rx2247_pos, rx2247_off
    substr $S10, rx2247_tgt, $I11, 3
    ne $S10, "=:=", rx2247_fail
    add rx2247_pos, 3
    set_addr $I10, rxcap_2252_fail
    ($I12, $I11) = rx2247_cur."!mark_peek"($I10)
    rx2247_cur."!cursor_pos"($I11)
    ($P10) = rx2247_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2247_pos, "")
    rx2247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2252_done
  rxcap_2252_fail:
    goto rx2247_fail
  rxcap_2252_done:
  # rx subrule "O" subtype=capture negate=
    rx2247_cur."!cursor_pos"(rx2247_pos)
    $P10 = rx2247_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2247_fail
    rx2247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2247_pos = $P10."pos"()
  # rx pass
    rx2247_cur."!cursor_pass"(rx2247_pos, "infix:sym<=:=>")
    if_null rx2247_debug, debug_1530
    rx2247_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2247_pos)
  debug_1530:
    .return (rx2247_cur)
  rx2247_restart:
.annotate 'line', 10
    if_null rx2247_debug, debug_1531
    rx2247_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1531:
  rx2247_fail:
    (rx2247_rep, rx2247_pos, $I10, $P10) = rx2247_cur."!mark_fail"(0)
    lt rx2247_pos, -1, rx2247_done
    eq rx2247_pos, -1, rx2247_fail
    jump $I10
  rx2247_done:
    rx2247_cur."!cursor_fail"()
    if_null rx2247_debug, debug_1532
    rx2247_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1532:
    .return (rx2247_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("505_1304282286.73") :method
.annotate 'line', 10
    $P2249 = self."!PREFIX__!subrule"("O", "=:=")
    new $P2250, "ResizablePMCArray"
    push $P2250, $P2249
    .return ($P2250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("506_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2254 = self."!PREFIX__!subrule"("O", "=:=")
    new $P2255, "ResizablePMCArray"
    push $P2255, $P2254
    .return ($P2255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("507_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2257_tgt
    .local int rx2257_pos
    .local int rx2257_off
    .local int rx2257_eos
    .local int rx2257_rep
    .local pmc rx2257_cur
    .local pmc rx2257_debug
    (rx2257_cur, rx2257_pos, rx2257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2257_cur
    .local pmc match
    .lex "$/", match
    length rx2257_eos, rx2257_tgt
    gt rx2257_pos, rx2257_eos, rx2257_done
    set rx2257_off, 0
    lt rx2257_pos, 2, rx2257_start
    sub rx2257_off, rx2257_pos, 1
    substr rx2257_tgt, rx2257_tgt, rx2257_off
  rx2257_start:
    eq $I10, 1, rx2257_restart
    if_null rx2257_debug, debug_1533
    rx2257_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1533:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2261_done
    goto rxscan2261_scan
  rxscan2261_loop:
    (rx2257_pos) = rx2257_cur."from"()
    inc rx2257_pos
    rx2257_cur."!cursor_from"(rx2257_pos)
    ge rx2257_pos, rx2257_eos, rxscan2261_done
  rxscan2261_scan:
    set_addr $I10, rxscan2261_loop
    rx2257_cur."!mark_push"(0, rx2257_pos, $I10)
  rxscan2261_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_2262_fail
    rx2257_cur."!mark_push"(0, rx2257_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2257_pos, 2
    gt $I11, rx2257_eos, rx2257_fail
    sub $I11, rx2257_pos, rx2257_off
    substr $S10, rx2257_tgt, $I11, 2
    ne $S10, "~~", rx2257_fail
    add rx2257_pos, 2
    set_addr $I10, rxcap_2262_fail
    ($I12, $I11) = rx2257_cur."!mark_peek"($I10)
    rx2257_cur."!cursor_pos"($I11)
    ($P10) = rx2257_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2257_pos, "")
    rx2257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2262_done
  rxcap_2262_fail:
    goto rx2257_fail
  rxcap_2262_done:
  # rx subrule "O" subtype=capture negate=
    rx2257_cur."!cursor_pos"(rx2257_pos)
    $P10 = rx2257_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2257_fail
    rx2257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2257_pos = $P10."pos"()
  # rx pass
    rx2257_cur."!cursor_pass"(rx2257_pos, "infix:sym<~~>")
    if_null rx2257_debug, debug_1534
    rx2257_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2257_pos)
  debug_1534:
    .return (rx2257_cur)
  rx2257_restart:
.annotate 'line', 10
    if_null rx2257_debug, debug_1535
    rx2257_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1535:
  rx2257_fail:
    (rx2257_rep, rx2257_pos, $I10, $P10) = rx2257_cur."!mark_fail"(0)
    lt rx2257_pos, -1, rx2257_done
    eq rx2257_pos, -1, rx2257_fail
    jump $I10
  rx2257_done:
    rx2257_cur."!cursor_fail"()
    if_null rx2257_debug, debug_1536
    rx2257_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1536:
    .return (rx2257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("508_1304282286.73") :method
.annotate 'line', 10
    $P2259 = self."!PREFIX__!subrule"("O", "~~")
    new $P2260, "ResizablePMCArray"
    push $P2260, $P2259
    .return ($P2260)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("509_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2264 = self."!PREFIX__!subrule"("O", "~~")
    new $P2265, "ResizablePMCArray"
    push $P2265, $P2264
    .return ($P2265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("510_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2267_tgt
    .local int rx2267_pos
    .local int rx2267_off
    .local int rx2267_eos
    .local int rx2267_rep
    .local pmc rx2267_cur
    .local pmc rx2267_debug
    (rx2267_cur, rx2267_pos, rx2267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2267_cur
    .local pmc match
    .lex "$/", match
    length rx2267_eos, rx2267_tgt
    gt rx2267_pos, rx2267_eos, rx2267_done
    set rx2267_off, 0
    lt rx2267_pos, 2, rx2267_start
    sub rx2267_off, rx2267_pos, 1
    substr rx2267_tgt, rx2267_tgt, rx2267_off
  rx2267_start:
    eq $I10, 1, rx2267_restart
    if_null rx2267_debug, debug_1537
    rx2267_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1537:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2271_done
    goto rxscan2271_scan
  rxscan2271_loop:
    (rx2267_pos) = rx2267_cur."from"()
    inc rx2267_pos
    rx2267_cur."!cursor_from"(rx2267_pos)
    ge rx2267_pos, rx2267_eos, rxscan2271_done
  rxscan2271_scan:
    set_addr $I10, rxscan2271_loop
    rx2267_cur."!mark_push"(0, rx2267_pos, $I10)
  rxscan2271_done:
.annotate 'line', 698
  # rx subcapture "sym"
    set_addr $I10, rxcap_2272_fail
    rx2267_cur."!mark_push"(0, rx2267_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2267_pos, 2
    gt $I11, rx2267_eos, rx2267_fail
    sub $I11, rx2267_pos, rx2267_off
    substr $S10, rx2267_tgt, $I11, 2
    ne $S10, "&&", rx2267_fail
    add rx2267_pos, 2
    set_addr $I10, rxcap_2272_fail
    ($I12, $I11) = rx2267_cur."!mark_peek"($I10)
    rx2267_cur."!cursor_pos"($I11)
    ($P10) = rx2267_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2267_pos, "")
    rx2267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2272_done
  rxcap_2272_fail:
    goto rx2267_fail
  rxcap_2272_done:
  # rx subrule "O" subtype=capture negate=
    rx2267_cur."!cursor_pos"(rx2267_pos)
    $P10 = rx2267_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2267_fail
    rx2267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2267_pos = $P10."pos"()
  # rx pass
    rx2267_cur."!cursor_pass"(rx2267_pos, "infix:sym<&&>")
    if_null rx2267_debug, debug_1538
    rx2267_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2267_pos)
  debug_1538:
    .return (rx2267_cur)
  rx2267_restart:
.annotate 'line', 10
    if_null rx2267_debug, debug_1539
    rx2267_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1539:
  rx2267_fail:
    (rx2267_rep, rx2267_pos, $I10, $P10) = rx2267_cur."!mark_fail"(0)
    lt rx2267_pos, -1, rx2267_done
    eq rx2267_pos, -1, rx2267_fail
    jump $I10
  rx2267_done:
    rx2267_cur."!cursor_fail"()
    if_null rx2267_debug, debug_1540
    rx2267_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1540:
    .return (rx2267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("511_1304282286.73") :method
.annotate 'line', 10
    $P2269 = self."!PREFIX__!subrule"("O", "&&")
    new $P2270, "ResizablePMCArray"
    push $P2270, $P2269
    .return ($P2270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("512_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2274 = self."!PREFIX__!subrule"("O", "&&")
    new $P2275, "ResizablePMCArray"
    push $P2275, $P2274
    .return ($P2275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("513_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2277_tgt
    .local int rx2277_pos
    .local int rx2277_off
    .local int rx2277_eos
    .local int rx2277_rep
    .local pmc rx2277_cur
    .local pmc rx2277_debug
    (rx2277_cur, rx2277_pos, rx2277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2277_cur
    .local pmc match
    .lex "$/", match
    length rx2277_eos, rx2277_tgt
    gt rx2277_pos, rx2277_eos, rx2277_done
    set rx2277_off, 0
    lt rx2277_pos, 2, rx2277_start
    sub rx2277_off, rx2277_pos, 1
    substr rx2277_tgt, rx2277_tgt, rx2277_off
  rx2277_start:
    eq $I10, 1, rx2277_restart
    if_null rx2277_debug, debug_1541
    rx2277_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1541:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2281_done
    goto rxscan2281_scan
  rxscan2281_loop:
    (rx2277_pos) = rx2277_cur."from"()
    inc rx2277_pos
    rx2277_cur."!cursor_from"(rx2277_pos)
    ge rx2277_pos, rx2277_eos, rxscan2281_done
  rxscan2281_scan:
    set_addr $I10, rxscan2281_loop
    rx2277_cur."!mark_push"(0, rx2277_pos, $I10)
  rxscan2281_done:
.annotate 'line', 700
  # rx subcapture "sym"
    set_addr $I10, rxcap_2282_fail
    rx2277_cur."!mark_push"(0, rx2277_pos, $I10)
  # rx literal  "||"
    add $I11, rx2277_pos, 2
    gt $I11, rx2277_eos, rx2277_fail
    sub $I11, rx2277_pos, rx2277_off
    substr $S10, rx2277_tgt, $I11, 2
    ne $S10, "||", rx2277_fail
    add rx2277_pos, 2
    set_addr $I10, rxcap_2282_fail
    ($I12, $I11) = rx2277_cur."!mark_peek"($I10)
    rx2277_cur."!cursor_pos"($I11)
    ($P10) = rx2277_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2277_pos, "")
    rx2277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2282_done
  rxcap_2282_fail:
    goto rx2277_fail
  rxcap_2282_done:
  # rx subrule "O" subtype=capture negate=
    rx2277_cur."!cursor_pos"(rx2277_pos)
    $P10 = rx2277_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2277_fail
    rx2277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2277_pos = $P10."pos"()
  # rx pass
    rx2277_cur."!cursor_pass"(rx2277_pos, "infix:sym<||>")
    if_null rx2277_debug, debug_1542
    rx2277_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2277_pos)
  debug_1542:
    .return (rx2277_cur)
  rx2277_restart:
.annotate 'line', 10
    if_null rx2277_debug, debug_1543
    rx2277_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1543:
  rx2277_fail:
    (rx2277_rep, rx2277_pos, $I10, $P10) = rx2277_cur."!mark_fail"(0)
    lt rx2277_pos, -1, rx2277_done
    eq rx2277_pos, -1, rx2277_fail
    jump $I10
  rx2277_done:
    rx2277_cur."!cursor_fail"()
    if_null rx2277_debug, debug_1544
    rx2277_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1544:
    .return (rx2277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("514_1304282286.73") :method
.annotate 'line', 10
    $P2279 = self."!PREFIX__!subrule"("O", "||")
    new $P2280, "ResizablePMCArray"
    push $P2280, $P2279
    .return ($P2280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("515_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2284 = self."!PREFIX__!subrule"("O", "||")
    new $P2285, "ResizablePMCArray"
    push $P2285, $P2284
    .return ($P2285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("516_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2287_tgt
    .local int rx2287_pos
    .local int rx2287_off
    .local int rx2287_eos
    .local int rx2287_rep
    .local pmc rx2287_cur
    .local pmc rx2287_debug
    (rx2287_cur, rx2287_pos, rx2287_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2287_cur
    .local pmc match
    .lex "$/", match
    length rx2287_eos, rx2287_tgt
    gt rx2287_pos, rx2287_eos, rx2287_done
    set rx2287_off, 0
    lt rx2287_pos, 2, rx2287_start
    sub rx2287_off, rx2287_pos, 1
    substr rx2287_tgt, rx2287_tgt, rx2287_off
  rx2287_start:
    eq $I10, 1, rx2287_restart
    if_null rx2287_debug, debug_1545
    rx2287_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1545:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2291_done
    goto rxscan2291_scan
  rxscan2291_loop:
    (rx2287_pos) = rx2287_cur."from"()
    inc rx2287_pos
    rx2287_cur."!cursor_from"(rx2287_pos)
    ge rx2287_pos, rx2287_eos, rxscan2291_done
  rxscan2291_scan:
    set_addr $I10, rxscan2291_loop
    rx2287_cur."!mark_push"(0, rx2287_pos, $I10)
  rxscan2291_done:
.annotate 'line', 701
  # rx subcapture "sym"
    set_addr $I10, rxcap_2292_fail
    rx2287_cur."!mark_push"(0, rx2287_pos, $I10)
  # rx literal  "//"
    add $I11, rx2287_pos, 2
    gt $I11, rx2287_eos, rx2287_fail
    sub $I11, rx2287_pos, rx2287_off
    substr $S10, rx2287_tgt, $I11, 2
    ne $S10, "//", rx2287_fail
    add rx2287_pos, 2
    set_addr $I10, rxcap_2292_fail
    ($I12, $I11) = rx2287_cur."!mark_peek"($I10)
    rx2287_cur."!cursor_pos"($I11)
    ($P10) = rx2287_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2287_pos, "")
    rx2287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2292_done
  rxcap_2292_fail:
    goto rx2287_fail
  rxcap_2292_done:
  # rx subrule "O" subtype=capture negate=
    rx2287_cur."!cursor_pos"(rx2287_pos)
    $P10 = rx2287_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2287_fail
    rx2287_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2287_pos = $P10."pos"()
  # rx pass
    rx2287_cur."!cursor_pass"(rx2287_pos, "infix:sym<//>")
    if_null rx2287_debug, debug_1546
    rx2287_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2287_pos)
  debug_1546:
    .return (rx2287_cur)
  rx2287_restart:
.annotate 'line', 10
    if_null rx2287_debug, debug_1547
    rx2287_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1547:
  rx2287_fail:
    (rx2287_rep, rx2287_pos, $I10, $P10) = rx2287_cur."!mark_fail"(0)
    lt rx2287_pos, -1, rx2287_done
    eq rx2287_pos, -1, rx2287_fail
    jump $I10
  rx2287_done:
    rx2287_cur."!cursor_fail"()
    if_null rx2287_debug, debug_1548
    rx2287_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1548:
    .return (rx2287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("517_1304282286.73") :method
.annotate 'line', 10
    $P2289 = self."!PREFIX__!subrule"("O", "//")
    new $P2290, "ResizablePMCArray"
    push $P2290, $P2289
    .return ($P2290)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("518_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2294 = self."!PREFIX__!subrule"("O", "//")
    new $P2295, "ResizablePMCArray"
    push $P2295, $P2294
    .return ($P2295)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("519_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2297_tgt
    .local int rx2297_pos
    .local int rx2297_off
    .local int rx2297_eos
    .local int rx2297_rep
    .local pmc rx2297_cur
    .local pmc rx2297_debug
    (rx2297_cur, rx2297_pos, rx2297_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2297_cur
    .local pmc match
    .lex "$/", match
    length rx2297_eos, rx2297_tgt
    gt rx2297_pos, rx2297_eos, rx2297_done
    set rx2297_off, 0
    lt rx2297_pos, 2, rx2297_start
    sub rx2297_off, rx2297_pos, 1
    substr rx2297_tgt, rx2297_tgt, rx2297_off
  rx2297_start:
    eq $I10, 1, rx2297_restart
    if_null rx2297_debug, debug_1549
    rx2297_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1549:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2301_done
    goto rxscan2301_scan
  rxscan2301_loop:
    (rx2297_pos) = rx2297_cur."from"()
    inc rx2297_pos
    rx2297_cur."!cursor_from"(rx2297_pos)
    ge rx2297_pos, rx2297_eos, rxscan2301_done
  rxscan2301_scan:
    set_addr $I10, rxscan2301_loop
    rx2297_cur."!mark_push"(0, rx2297_pos, $I10)
  rxscan2301_done:
.annotate 'line', 704
  # rx literal  "??"
    add $I11, rx2297_pos, 2
    gt $I11, rx2297_eos, rx2297_fail
    sub $I11, rx2297_pos, rx2297_off
    substr $S10, rx2297_tgt, $I11, 2
    ne $S10, "??", rx2297_fail
    add rx2297_pos, 2
.annotate 'line', 705
  # rx subrule "ws" subtype=method negate=
    rx2297_cur."!cursor_pos"(rx2297_pos)
    $P10 = rx2297_cur."ws"()
    unless $P10, rx2297_fail
    rx2297_pos = $P10."pos"()
.annotate 'line', 706
  # rx subrule "EXPR" subtype=capture negate=
    rx2297_cur."!cursor_pos"(rx2297_pos)
    $P10 = rx2297_cur."EXPR"("i=")
    unless $P10, rx2297_fail
    rx2297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2297_pos = $P10."pos"()
.annotate 'line', 707
  # rx literal  "!!"
    add $I11, rx2297_pos, 2
    gt $I11, rx2297_eos, rx2297_fail
    sub $I11, rx2297_pos, rx2297_off
    substr $S10, rx2297_tgt, $I11, 2
    ne $S10, "!!", rx2297_fail
    add rx2297_pos, 2
.annotate 'line', 708
  # rx subrule "O" subtype=capture negate=
    rx2297_cur."!cursor_pos"(rx2297_pos)
    $P10 = rx2297_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2297_fail
    rx2297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2297_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx2297_cur."!cursor_pass"(rx2297_pos, "infix:sym<?? !!>")
    if_null rx2297_debug, debug_1550
    rx2297_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2297_pos)
  debug_1550:
    .return (rx2297_cur)
  rx2297_restart:
.annotate 'line', 10
    if_null rx2297_debug, debug_1551
    rx2297_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1551:
  rx2297_fail:
    (rx2297_rep, rx2297_pos, $I10, $P10) = rx2297_cur."!mark_fail"(0)
    lt rx2297_pos, -1, rx2297_done
    eq rx2297_pos, -1, rx2297_fail
    jump $I10
  rx2297_done:
    rx2297_cur."!cursor_fail"()
    if_null rx2297_debug, debug_1552
    rx2297_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1552:
    .return (rx2297_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("520_1304282286.73") :method
.annotate 'line', 10
    $P2299 = self."!PREFIX__!subrule"("ws", "??")
    new $P2300, "ResizablePMCArray"
    push $P2300, $P2299
    .return ($P2300)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("521_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2303 = self."!PREFIX__!subrule"("ws", "??")
    new $P2304, "ResizablePMCArray"
    push $P2304, $P2303
    .return ($P2304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("522_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2306_tgt
    .local int rx2306_pos
    .local int rx2306_off
    .local int rx2306_eos
    .local int rx2306_rep
    .local pmc rx2306_cur
    .local pmc rx2306_debug
    (rx2306_cur, rx2306_pos, rx2306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2306_cur
    .local pmc match
    .lex "$/", match
    length rx2306_eos, rx2306_tgt
    gt rx2306_pos, rx2306_eos, rx2306_done
    set rx2306_off, 0
    lt rx2306_pos, 2, rx2306_start
    sub rx2306_off, rx2306_pos, 1
    substr rx2306_tgt, rx2306_tgt, rx2306_off
  rx2306_start:
    eq $I10, 1, rx2306_restart
    if_null rx2306_debug, debug_1553
    rx2306_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1553:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2310_done
    goto rxscan2310_scan
  rxscan2310_loop:
    (rx2306_pos) = rx2306_cur."from"()
    inc rx2306_pos
    rx2306_cur."!cursor_from"(rx2306_pos)
    ge rx2306_pos, rx2306_eos, rxscan2310_done
  rxscan2310_scan:
    set_addr $I10, rxscan2310_loop
    rx2306_cur."!mark_push"(0, rx2306_pos, $I10)
  rxscan2310_done:
.annotate 'line', 712
  # rx subcapture "sym"
    set_addr $I10, rxcap_2311_fail
    rx2306_cur."!mark_push"(0, rx2306_pos, $I10)
  # rx literal  "="
    add $I11, rx2306_pos, 1
    gt $I11, rx2306_eos, rx2306_fail
    sub $I11, rx2306_pos, rx2306_off
    ord $I11, rx2306_tgt, $I11
    ne $I11, 61, rx2306_fail
    add rx2306_pos, 1
    set_addr $I10, rxcap_2311_fail
    ($I12, $I11) = rx2306_cur."!mark_peek"($I10)
    rx2306_cur."!cursor_pos"($I11)
    ($P10) = rx2306_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2306_pos, "")
    rx2306_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2311_done
  rxcap_2311_fail:
    goto rx2306_fail
  rxcap_2311_done:
  # rx subrule "panic" subtype=method negate=
    rx2306_cur."!cursor_pos"(rx2306_pos)
    $P10 = rx2306_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2306_fail
    rx2306_pos = $P10."pos"()
.annotate 'line', 711
  # rx pass
    rx2306_cur."!cursor_pass"(rx2306_pos, "infix:sym<=>")
    if_null rx2306_debug, debug_1554
    rx2306_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2306_pos)
  debug_1554:
    .return (rx2306_cur)
  rx2306_restart:
.annotate 'line', 10
    if_null rx2306_debug, debug_1555
    rx2306_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1555:
  rx2306_fail:
    (rx2306_rep, rx2306_pos, $I10, $P10) = rx2306_cur."!mark_fail"(0)
    lt rx2306_pos, -1, rx2306_done
    eq rx2306_pos, -1, rx2306_fail
    jump $I10
  rx2306_done:
    rx2306_cur."!cursor_fail"()
    if_null rx2306_debug, debug_1556
    rx2306_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1556:
    .return (rx2306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("523_1304282286.73") :method
.annotate 'line', 10
    $P2308 = self."!PREFIX__!subrule"("panic", "=")
    new $P2309, "ResizablePMCArray"
    push $P2309, $P2308
    .return ($P2309)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("524_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2313 = self."!PREFIX__!subrule"("panic", "=")
    new $P2314, "ResizablePMCArray"
    push $P2314, $P2313
    .return ($P2314)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("525_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2316_tgt
    .local int rx2316_pos
    .local int rx2316_off
    .local int rx2316_eos
    .local int rx2316_rep
    .local pmc rx2316_cur
    .local pmc rx2316_debug
    (rx2316_cur, rx2316_pos, rx2316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2316_cur
    .local pmc match
    .lex "$/", match
    length rx2316_eos, rx2316_tgt
    gt rx2316_pos, rx2316_eos, rx2316_done
    set rx2316_off, 0
    lt rx2316_pos, 2, rx2316_start
    sub rx2316_off, rx2316_pos, 1
    substr rx2316_tgt, rx2316_tgt, rx2316_off
  rx2316_start:
    eq $I10, 1, rx2316_restart
    if_null rx2316_debug, debug_1557
    rx2316_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1557:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2320_done
    goto rxscan2320_scan
  rxscan2320_loop:
    (rx2316_pos) = rx2316_cur."from"()
    inc rx2316_pos
    rx2316_cur."!cursor_from"(rx2316_pos)
    ge rx2316_pos, rx2316_eos, rxscan2320_done
  rxscan2320_scan:
    set_addr $I10, rxscan2320_loop
    rx2316_cur."!mark_push"(0, rx2316_pos, $I10)
  rxscan2320_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_2321_fail
    rx2316_cur."!mark_push"(0, rx2316_pos, $I10)
  # rx literal  ":="
    add $I11, rx2316_pos, 2
    gt $I11, rx2316_eos, rx2316_fail
    sub $I11, rx2316_pos, rx2316_off
    substr $S10, rx2316_tgt, $I11, 2
    ne $S10, ":=", rx2316_fail
    add rx2316_pos, 2
    set_addr $I10, rxcap_2321_fail
    ($I12, $I11) = rx2316_cur."!mark_peek"($I10)
    rx2316_cur."!cursor_pos"($I11)
    ($P10) = rx2316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2316_pos, "")
    rx2316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2321_done
  rxcap_2321_fail:
    goto rx2316_fail
  rxcap_2321_done:
  # rx subrule "O" subtype=capture negate=
    rx2316_cur."!cursor_pos"(rx2316_pos)
    $P10 = rx2316_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2316_fail
    rx2316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2316_pos = $P10."pos"()
  # rx pass
    rx2316_cur."!cursor_pass"(rx2316_pos, "infix:sym<:=>")
    if_null rx2316_debug, debug_1558
    rx2316_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2316_pos)
  debug_1558:
    .return (rx2316_cur)
  rx2316_restart:
.annotate 'line', 10
    if_null rx2316_debug, debug_1559
    rx2316_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1559:
  rx2316_fail:
    (rx2316_rep, rx2316_pos, $I10, $P10) = rx2316_cur."!mark_fail"(0)
    lt rx2316_pos, -1, rx2316_done
    eq rx2316_pos, -1, rx2316_fail
    jump $I10
  rx2316_done:
    rx2316_cur."!cursor_fail"()
    if_null rx2316_debug, debug_1560
    rx2316_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1560:
    .return (rx2316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("526_1304282286.73") :method
.annotate 'line', 10
    $P2318 = self."!PREFIX__!subrule"("O", ":=")
    new $P2319, "ResizablePMCArray"
    push $P2319, $P2318
    .return ($P2319)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("527_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2323 = self."!PREFIX__!subrule"("O", ":=")
    new $P2324, "ResizablePMCArray"
    push $P2324, $P2323
    .return ($P2324)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("528_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2326_tgt
    .local int rx2326_pos
    .local int rx2326_off
    .local int rx2326_eos
    .local int rx2326_rep
    .local pmc rx2326_cur
    .local pmc rx2326_debug
    (rx2326_cur, rx2326_pos, rx2326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2326_cur
    .local pmc match
    .lex "$/", match
    length rx2326_eos, rx2326_tgt
    gt rx2326_pos, rx2326_eos, rx2326_done
    set rx2326_off, 0
    lt rx2326_pos, 2, rx2326_start
    sub rx2326_off, rx2326_pos, 1
    substr rx2326_tgt, rx2326_tgt, rx2326_off
  rx2326_start:
    eq $I10, 1, rx2326_restart
    if_null rx2326_debug, debug_1561
    rx2326_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1561:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2330_done
    goto rxscan2330_scan
  rxscan2330_loop:
    (rx2326_pos) = rx2326_cur."from"()
    inc rx2326_pos
    rx2326_cur."!cursor_from"(rx2326_pos)
    ge rx2326_pos, rx2326_eos, rxscan2330_done
  rxscan2330_scan:
    set_addr $I10, rxscan2330_loop
    rx2326_cur."!mark_push"(0, rx2326_pos, $I10)
  rxscan2330_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_2331_fail
    rx2326_cur."!mark_push"(0, rx2326_pos, $I10)
  # rx literal  "::="
    add $I11, rx2326_pos, 3
    gt $I11, rx2326_eos, rx2326_fail
    sub $I11, rx2326_pos, rx2326_off
    substr $S10, rx2326_tgt, $I11, 3
    ne $S10, "::=", rx2326_fail
    add rx2326_pos, 3
    set_addr $I10, rxcap_2331_fail
    ($I12, $I11) = rx2326_cur."!mark_peek"($I10)
    rx2326_cur."!cursor_pos"($I11)
    ($P10) = rx2326_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2326_pos, "")
    rx2326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2331_done
  rxcap_2331_fail:
    goto rx2326_fail
  rxcap_2331_done:
  # rx subrule "O" subtype=capture negate=
    rx2326_cur."!cursor_pos"(rx2326_pos)
    $P10 = rx2326_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2326_fail
    rx2326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2326_pos = $P10."pos"()
  # rx pass
    rx2326_cur."!cursor_pass"(rx2326_pos, "infix:sym<::=>")
    if_null rx2326_debug, debug_1562
    rx2326_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2326_pos)
  debug_1562:
    .return (rx2326_cur)
  rx2326_restart:
.annotate 'line', 10
    if_null rx2326_debug, debug_1563
    rx2326_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1563:
  rx2326_fail:
    (rx2326_rep, rx2326_pos, $I10, $P10) = rx2326_cur."!mark_fail"(0)
    lt rx2326_pos, -1, rx2326_done
    eq rx2326_pos, -1, rx2326_fail
    jump $I10
  rx2326_done:
    rx2326_cur."!cursor_fail"()
    if_null rx2326_debug, debug_1564
    rx2326_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1564:
    .return (rx2326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("529_1304282286.73") :method
.annotate 'line', 10
    $P2328 = self."!PREFIX__!subrule"("O", "::=")
    new $P2329, "ResizablePMCArray"
    push $P2329, $P2328
    .return ($P2329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("530_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2333 = self."!PREFIX__!subrule"("O", "::=")
    new $P2334, "ResizablePMCArray"
    push $P2334, $P2333
    .return ($P2334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("531_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2336_tgt
    .local int rx2336_pos
    .local int rx2336_off
    .local int rx2336_eos
    .local int rx2336_rep
    .local pmc rx2336_cur
    .local pmc rx2336_debug
    (rx2336_cur, rx2336_pos, rx2336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2336_cur
    .local pmc match
    .lex "$/", match
    length rx2336_eos, rx2336_tgt
    gt rx2336_pos, rx2336_eos, rx2336_done
    set rx2336_off, 0
    lt rx2336_pos, 2, rx2336_start
    sub rx2336_off, rx2336_pos, 1
    substr rx2336_tgt, rx2336_tgt, rx2336_off
  rx2336_start:
    eq $I10, 1, rx2336_restart
    if_null rx2336_debug, debug_1565
    rx2336_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1565:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2340_done
    goto rxscan2340_scan
  rxscan2340_loop:
    (rx2336_pos) = rx2336_cur."from"()
    inc rx2336_pos
    rx2336_cur."!cursor_from"(rx2336_pos)
    ge rx2336_pos, rx2336_eos, rxscan2340_done
  rxscan2340_scan:
    set_addr $I10, rxscan2340_loop
    rx2336_cur."!mark_push"(0, rx2336_pos, $I10)
  rxscan2340_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_2341_fail
    rx2336_cur."!mark_push"(0, rx2336_pos, $I10)
  # rx literal  ","
    add $I11, rx2336_pos, 1
    gt $I11, rx2336_eos, rx2336_fail
    sub $I11, rx2336_pos, rx2336_off
    ord $I11, rx2336_tgt, $I11
    ne $I11, 44, rx2336_fail
    add rx2336_pos, 1
    set_addr $I10, rxcap_2341_fail
    ($I12, $I11) = rx2336_cur."!mark_peek"($I10)
    rx2336_cur."!cursor_pos"($I11)
    ($P10) = rx2336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2336_pos, "")
    rx2336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2341_done
  rxcap_2341_fail:
    goto rx2336_fail
  rxcap_2341_done:
  # rx subrule "O" subtype=capture negate=
    rx2336_cur."!cursor_pos"(rx2336_pos)
    $P10 = rx2336_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2336_fail
    rx2336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2336_pos = $P10."pos"()
  # rx pass
    rx2336_cur."!cursor_pass"(rx2336_pos, "infix:sym<,>")
    if_null rx2336_debug, debug_1566
    rx2336_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2336_pos)
  debug_1566:
    .return (rx2336_cur)
  rx2336_restart:
.annotate 'line', 10
    if_null rx2336_debug, debug_1567
    rx2336_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1567:
  rx2336_fail:
    (rx2336_rep, rx2336_pos, $I10, $P10) = rx2336_cur."!mark_fail"(0)
    lt rx2336_pos, -1, rx2336_done
    eq rx2336_pos, -1, rx2336_fail
    jump $I10
  rx2336_done:
    rx2336_cur."!cursor_fail"()
    if_null rx2336_debug, debug_1568
    rx2336_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1568:
    .return (rx2336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("532_1304282286.73") :method
.annotate 'line', 10
    $P2338 = self."!PREFIX__!subrule"("O", ",")
    new $P2339, "ResizablePMCArray"
    push $P2339, $P2338
    .return ($P2339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("533_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    $P2343 = self."!PREFIX__!subrule"("O", ",")
    new $P2344, "ResizablePMCArray"
    push $P2344, $P2343
    .return ($P2344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("534_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .const 'Sub' $P2354 = "536_1304282286.73" 
    capture_lex $P2354
    .local string rx2346_tgt
    .local int rx2346_pos
    .local int rx2346_off
    .local int rx2346_eos
    .local int rx2346_rep
    .local pmc rx2346_cur
    .local pmc rx2346_debug
    (rx2346_cur, rx2346_pos, rx2346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2346_cur
    .local pmc match
    .lex "$/", match
    length rx2346_eos, rx2346_tgt
    gt rx2346_pos, rx2346_eos, rx2346_done
    set rx2346_off, 0
    lt rx2346_pos, 2, rx2346_start
    sub rx2346_off, rx2346_pos, 1
    substr rx2346_tgt, rx2346_tgt, rx2346_off
  rx2346_start:
    eq $I10, 1, rx2346_restart
    if_null rx2346_debug, debug_1569
    rx2346_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1569:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2349_done
    goto rxscan2349_scan
  rxscan2349_loop:
    (rx2346_pos) = rx2346_cur."from"()
    inc rx2346_pos
    rx2346_cur."!cursor_from"(rx2346_pos)
    ge rx2346_pos, rx2346_eos, rxscan2349_done
  rxscan2349_scan:
    set_addr $I10, rxscan2349_loop
    rx2346_cur."!mark_push"(0, rx2346_pos, $I10)
  rxscan2349_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_2350_fail
    rx2346_cur."!mark_push"(0, rx2346_pos, $I10)
  # rx literal  "return"
    add $I11, rx2346_pos, 6
    gt $I11, rx2346_eos, rx2346_fail
    sub $I11, rx2346_pos, rx2346_off
    substr $S10, rx2346_tgt, $I11, 6
    ne $S10, "return", rx2346_fail
    add rx2346_pos, 6
    set_addr $I10, rxcap_2350_fail
    ($I12, $I11) = rx2346_cur."!mark_peek"($I10)
    rx2346_cur."!cursor_pos"($I11)
    ($P10) = rx2346_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2346_pos, "")
    rx2346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2350_done
  rxcap_2350_fail:
    goto rx2346_fail
  rxcap_2350_done:
  # rx charclass s
    ge rx2346_pos, rx2346_eos, rx2346_fail
    sub $I10, rx2346_pos, rx2346_off
    is_cclass $I11, 32, rx2346_tgt, $I10
    unless $I11, rx2346_fail
    inc rx2346_pos
  # rx subrule "O" subtype=capture negate=
    rx2346_cur."!cursor_pos"(rx2346_pos)
    $P10 = rx2346_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2346_fail
    rx2346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2346_pos = $P10."pos"()
    rx2346_cur."!cursor_pos"(rx2346_pos)
    find_lex $P2351, unicode:"$\x{a2}"
    $P2352 = $P2351."MATCH"()
    store_lex "$/", $P2352
    .const 'Sub' $P2354 = "536_1304282286.73" 
    capture_lex $P2354
    $P2356 = $P2354()
  # rx pass
    rx2346_cur."!cursor_pass"(rx2346_pos, "prefix:sym<return>")
    if_null rx2346_debug, debug_1570
    rx2346_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2346_pos)
  debug_1570:
    .return (rx2346_cur)
  rx2346_restart:
.annotate 'line', 10
    if_null rx2346_debug, debug_1571
    rx2346_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1571:
  rx2346_fail:
    (rx2346_rep, rx2346_pos, $I10, $P10) = rx2346_cur."!mark_fail"(0)
    lt rx2346_pos, -1, rx2346_done
    eq rx2346_pos, -1, rx2346_fail
    jump $I10
  rx2346_done:
    rx2346_cur."!cursor_fail"()
    if_null rx2346_debug, debug_1572
    rx2346_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1572:
    .return (rx2346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("535_1304282286.73") :method
.annotate 'line', 10
    new $P2348, "ResizablePMCArray"
    push $P2348, "return"
    .return ($P2348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2353"  :anon :subid("536_1304282286.73") :outer("534_1304282286.73")
.annotate 'line', 719
    new $P2355, "Integer"
    assign $P2355, 1
    store_dynamic_lex "$*RETURN_USED", $P2355
    .return ($P2355)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("537_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P2358, "ResizablePMCArray"
    push $P2358, "return"
    .return ($P2358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("538_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2360_tgt
    .local int rx2360_pos
    .local int rx2360_off
    .local int rx2360_eos
    .local int rx2360_rep
    .local pmc rx2360_cur
    .local pmc rx2360_debug
    (rx2360_cur, rx2360_pos, rx2360_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2360_cur
    .local pmc match
    .lex "$/", match
    length rx2360_eos, rx2360_tgt
    gt rx2360_pos, rx2360_eos, rx2360_done
    set rx2360_off, 0
    lt rx2360_pos, 2, rx2360_start
    sub rx2360_off, rx2360_pos, 1
    substr rx2360_tgt, rx2360_tgt, rx2360_off
  rx2360_start:
    eq $I10, 1, rx2360_restart
    if_null rx2360_debug, debug_1573
    rx2360_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1573:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2363_done
    goto rxscan2363_scan
  rxscan2363_loop:
    (rx2360_pos) = rx2360_cur."from"()
    inc rx2360_pos
    rx2360_cur."!cursor_from"(rx2360_pos)
    ge rx2360_pos, rx2360_eos, rxscan2363_done
  rxscan2363_scan:
    set_addr $I10, rxscan2363_loop
    rx2360_cur."!mark_push"(0, rx2360_pos, $I10)
  rxscan2363_done:
.annotate 'line', 720
  # rx subcapture "sym"
    set_addr $I10, rxcap_2364_fail
    rx2360_cur."!mark_push"(0, rx2360_pos, $I10)
  # rx literal  "make"
    add $I11, rx2360_pos, 4
    gt $I11, rx2360_eos, rx2360_fail
    sub $I11, rx2360_pos, rx2360_off
    substr $S10, rx2360_tgt, $I11, 4
    ne $S10, "make", rx2360_fail
    add rx2360_pos, 4
    set_addr $I10, rxcap_2364_fail
    ($I12, $I11) = rx2360_cur."!mark_peek"($I10)
    rx2360_cur."!cursor_pos"($I11)
    ($P10) = rx2360_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2360_pos, "")
    rx2360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2364_done
  rxcap_2364_fail:
    goto rx2360_fail
  rxcap_2364_done:
  # rx charclass s
    ge rx2360_pos, rx2360_eos, rx2360_fail
    sub $I10, rx2360_pos, rx2360_off
    is_cclass $I11, 32, rx2360_tgt, $I10
    unless $I11, rx2360_fail
    inc rx2360_pos
  # rx subrule "O" subtype=capture negate=
    rx2360_cur."!cursor_pos"(rx2360_pos)
    $P10 = rx2360_cur."O"("%list_prefix")
    unless $P10, rx2360_fail
    rx2360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2360_pos = $P10."pos"()
  # rx pass
    rx2360_cur."!cursor_pass"(rx2360_pos, "prefix:sym<make>")
    if_null rx2360_debug, debug_1574
    rx2360_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2360_pos)
  debug_1574:
    .return (rx2360_cur)
  rx2360_restart:
.annotate 'line', 10
    if_null rx2360_debug, debug_1575
    rx2360_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1575:
  rx2360_fail:
    (rx2360_rep, rx2360_pos, $I10, $P10) = rx2360_cur."!mark_fail"(0)
    lt rx2360_pos, -1, rx2360_done
    eq rx2360_pos, -1, rx2360_fail
    jump $I10
  rx2360_done:
    rx2360_cur."!cursor_fail"()
    if_null rx2360_debug, debug_1576
    rx2360_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1576:
    .return (rx2360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("539_1304282286.73") :method
.annotate 'line', 10
    new $P2362, "ResizablePMCArray"
    push $P2362, "make"
    .return ($P2362)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("540_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P2366, "ResizablePMCArray"
    push $P2366, "make"
    .return ($P2366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("541_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2368_tgt
    .local int rx2368_pos
    .local int rx2368_off
    .local int rx2368_eos
    .local int rx2368_rep
    .local pmc rx2368_cur
    .local pmc rx2368_debug
    (rx2368_cur, rx2368_pos, rx2368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2368_cur
    .local pmc match
    .lex "$/", match
    length rx2368_eos, rx2368_tgt
    gt rx2368_pos, rx2368_eos, rx2368_done
    set rx2368_off, 0
    lt rx2368_pos, 2, rx2368_start
    sub rx2368_off, rx2368_pos, 1
    substr rx2368_tgt, rx2368_tgt, rx2368_off
  rx2368_start:
    eq $I10, 1, rx2368_restart
    if_null rx2368_debug, debug_1577
    rx2368_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1577:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2371_done
    goto rxscan2371_scan
  rxscan2371_loop:
    (rx2368_pos) = rx2368_cur."from"()
    inc rx2368_pos
    rx2368_cur."!cursor_from"(rx2368_pos)
    ge rx2368_pos, rx2368_eos, rxscan2371_done
  rxscan2371_scan:
    set_addr $I10, rxscan2371_loop
    rx2368_cur."!mark_push"(0, rx2368_pos, $I10)
  rxscan2371_done:
.annotate 'line', 721
  # rx subcapture "sym"
    set_addr $I10, rxcap_2372_fail
    rx2368_cur."!mark_push"(0, rx2368_pos, $I10)
  # rx literal  "last"
    add $I11, rx2368_pos, 4
    gt $I11, rx2368_eos, rx2368_fail
    sub $I11, rx2368_pos, rx2368_off
    substr $S10, rx2368_tgt, $I11, 4
    ne $S10, "last", rx2368_fail
    add rx2368_pos, 4
    set_addr $I10, rxcap_2372_fail
    ($I12, $I11) = rx2368_cur."!mark_peek"($I10)
    rx2368_cur."!cursor_pos"($I11)
    ($P10) = rx2368_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2368_pos, "")
    rx2368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2372_done
  rxcap_2372_fail:
    goto rx2368_fail
  rxcap_2372_done:
  # rx pass
    rx2368_cur."!cursor_pass"(rx2368_pos, "term:sym<last>")
    if_null rx2368_debug, debug_1578
    rx2368_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2368_pos)
  debug_1578:
    .return (rx2368_cur)
  rx2368_restart:
.annotate 'line', 10
    if_null rx2368_debug, debug_1579
    rx2368_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1579:
  rx2368_fail:
    (rx2368_rep, rx2368_pos, $I10, $P10) = rx2368_cur."!mark_fail"(0)
    lt rx2368_pos, -1, rx2368_done
    eq rx2368_pos, -1, rx2368_fail
    jump $I10
  rx2368_done:
    rx2368_cur."!cursor_fail"()
    if_null rx2368_debug, debug_1580
    rx2368_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1580:
    .return (rx2368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("542_1304282286.73") :method
.annotate 'line', 10
    new $P2370, "ResizablePMCArray"
    push $P2370, "last"
    .return ($P2370)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("543_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P2374, "ResizablePMCArray"
    push $P2374, "last"
    .return ($P2374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("544_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2376_tgt
    .local int rx2376_pos
    .local int rx2376_off
    .local int rx2376_eos
    .local int rx2376_rep
    .local pmc rx2376_cur
    .local pmc rx2376_debug
    (rx2376_cur, rx2376_pos, rx2376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2376_cur
    .local pmc match
    .lex "$/", match
    length rx2376_eos, rx2376_tgt
    gt rx2376_pos, rx2376_eos, rx2376_done
    set rx2376_off, 0
    lt rx2376_pos, 2, rx2376_start
    sub rx2376_off, rx2376_pos, 1
    substr rx2376_tgt, rx2376_tgt, rx2376_off
  rx2376_start:
    eq $I10, 1, rx2376_restart
    if_null rx2376_debug, debug_1581
    rx2376_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1581:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2379_done
    goto rxscan2379_scan
  rxscan2379_loop:
    (rx2376_pos) = rx2376_cur."from"()
    inc rx2376_pos
    rx2376_cur."!cursor_from"(rx2376_pos)
    ge rx2376_pos, rx2376_eos, rxscan2379_done
  rxscan2379_scan:
    set_addr $I10, rxscan2379_loop
    rx2376_cur."!mark_push"(0, rx2376_pos, $I10)
  rxscan2379_done:
.annotate 'line', 722
  # rx subcapture "sym"
    set_addr $I10, rxcap_2380_fail
    rx2376_cur."!mark_push"(0, rx2376_pos, $I10)
  # rx literal  "next"
    add $I11, rx2376_pos, 4
    gt $I11, rx2376_eos, rx2376_fail
    sub $I11, rx2376_pos, rx2376_off
    substr $S10, rx2376_tgt, $I11, 4
    ne $S10, "next", rx2376_fail
    add rx2376_pos, 4
    set_addr $I10, rxcap_2380_fail
    ($I12, $I11) = rx2376_cur."!mark_peek"($I10)
    rx2376_cur."!cursor_pos"($I11)
    ($P10) = rx2376_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2376_pos, "")
    rx2376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2380_done
  rxcap_2380_fail:
    goto rx2376_fail
  rxcap_2380_done:
  # rx pass
    rx2376_cur."!cursor_pass"(rx2376_pos, "term:sym<next>")
    if_null rx2376_debug, debug_1582
    rx2376_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2376_pos)
  debug_1582:
    .return (rx2376_cur)
  rx2376_restart:
.annotate 'line', 10
    if_null rx2376_debug, debug_1583
    rx2376_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1583:
  rx2376_fail:
    (rx2376_rep, rx2376_pos, $I10, $P10) = rx2376_cur."!mark_fail"(0)
    lt rx2376_pos, -1, rx2376_done
    eq rx2376_pos, -1, rx2376_fail
    jump $I10
  rx2376_done:
    rx2376_cur."!cursor_fail"()
    if_null rx2376_debug, debug_1584
    rx2376_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1584:
    .return (rx2376_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("545_1304282286.73") :method
.annotate 'line', 10
    new $P2378, "ResizablePMCArray"
    push $P2378, "next"
    .return ($P2378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("546_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P2382, "ResizablePMCArray"
    push $P2382, "next"
    .return ($P2382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("547_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    .local string rx2384_tgt
    .local int rx2384_pos
    .local int rx2384_off
    .local int rx2384_eos
    .local int rx2384_rep
    .local pmc rx2384_cur
    .local pmc rx2384_debug
    (rx2384_cur, rx2384_pos, rx2384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2384_cur
    .local pmc match
    .lex "$/", match
    length rx2384_eos, rx2384_tgt
    gt rx2384_pos, rx2384_eos, rx2384_done
    set rx2384_off, 0
    lt rx2384_pos, 2, rx2384_start
    sub rx2384_off, rx2384_pos, 1
    substr rx2384_tgt, rx2384_tgt, rx2384_off
  rx2384_start:
    eq $I10, 1, rx2384_restart
    if_null rx2384_debug, debug_1585
    rx2384_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1585:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2387_done
    goto rxscan2387_scan
  rxscan2387_loop:
    (rx2384_pos) = rx2384_cur."from"()
    inc rx2384_pos
    rx2384_cur."!cursor_from"(rx2384_pos)
    ge rx2384_pos, rx2384_eos, rxscan2387_done
  rxscan2387_scan:
    set_addr $I10, rxscan2387_loop
    rx2384_cur."!mark_push"(0, rx2384_pos, $I10)
  rxscan2387_done:
.annotate 'line', 723
  # rx subcapture "sym"
    set_addr $I10, rxcap_2388_fail
    rx2384_cur."!mark_push"(0, rx2384_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2384_pos, 4
    gt $I11, rx2384_eos, rx2384_fail
    sub $I11, rx2384_pos, rx2384_off
    substr $S10, rx2384_tgt, $I11, 4
    ne $S10, "redo", rx2384_fail
    add rx2384_pos, 4
    set_addr $I10, rxcap_2388_fail
    ($I12, $I11) = rx2384_cur."!mark_peek"($I10)
    rx2384_cur."!cursor_pos"($I11)
    ($P10) = rx2384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2384_pos, "")
    rx2384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2388_done
  rxcap_2388_fail:
    goto rx2384_fail
  rxcap_2388_done:
  # rx pass
    rx2384_cur."!cursor_pass"(rx2384_pos, "term:sym<redo>")
    if_null rx2384_debug, debug_1586
    rx2384_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2384_pos)
  debug_1586:
    .return (rx2384_cur)
  rx2384_restart:
.annotate 'line', 10
    if_null rx2384_debug, debug_1587
    rx2384_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1587:
  rx2384_fail:
    (rx2384_rep, rx2384_pos, $I10, $P10) = rx2384_cur."!mark_fail"(0)
    lt rx2384_pos, -1, rx2384_done
    eq rx2384_pos, -1, rx2384_fail
    jump $I10
  rx2384_done:
    rx2384_cur."!cursor_fail"()
    if_null rx2384_debug, debug_1588
    rx2384_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1588:
    .return (rx2384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("548_1304282286.73") :method
.annotate 'line', 10
    new $P2386, "ResizablePMCArray"
    push $P2386, "redo"
    .return ($P2386)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("549_1304282286.73") :method :outer("12_1304282286.73")
.annotate 'line', 10
    new $P2390, "ResizablePMCArray"
    push $P2390, "redo"
    .return ($P2390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("550_1304282286.73") :outer("12_1304282286.73")
    .param pmc param_2392
    .param pmc param_2393
.annotate 'line', 725
    .lex "self", param_2392
    .lex "$/", param_2393
.annotate 'line', 727
    new $P2394, "Undef"
    .lex "$t", $P2394
    find_lex $P2395, "$/"
    unless_null $P2395, vivify_1589
    $P2395 = root_new ['parrot';'ResizablePMCArray']
  vivify_1589:
    set $P2396, $P2395[0]
    unless_null $P2396, vivify_1590
    new $P2396, "Undef"
  vivify_1590:
    store_lex "$t", $P2396
    find_lex $P2397, "$/"
    unless_null $P2397, vivify_1591
    $P2397 = root_new ['parrot';'ResizablePMCArray']
  vivify_1591:
    set $P2398, $P2397[1]
    unless_null $P2398, vivify_1592
    new $P2398, "Undef"
  vivify_1592:
    find_lex $P2399, "$/"
    unless_null $P2399, vivify_1593
    $P2399 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2399
  vivify_1593:
    set $P2399[0], $P2398
    find_lex $P2400, "$t"
    unless_null $P2400, vivify_1594
    new $P2400, "Undef"
  vivify_1594:
    find_lex $P2401, "$/"
    unless_null $P2401, vivify_1595
    $P2401 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2401
  vivify_1595:
    set $P2401[1], $P2400
.annotate 'line', 725
    .return ($P2400)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2408"  :subid("552_1304282286.73") :outer("10_1304282286.73")
.annotate 'line', 731
    .const 'Sub' $P2492 = "581_1304282286.73" 
    capture_lex $P2492
    .const 'Sub' $P2488 = "580_1304282286.73" 
    capture_lex $P2488
    .const 'Sub' $P2482 = "578_1304282286.73" 
    capture_lex $P2482
    .const 'Sub' $P2480 = "577_1304282286.73" 
    capture_lex $P2480
    .const 'Sub' $P2475 = "575_1304282286.73" 
    capture_lex $P2475
    .const 'Sub' $P2472 = "574_1304282286.73" 
    capture_lex $P2472
    .const 'Sub' $P2460 = "571_1304282286.73" 
    capture_lex $P2460
    .const 'Sub' $P2458 = "570_1304282286.73" 
    capture_lex $P2458
    .const 'Sub' $P2448 = "567_1304282286.73" 
    capture_lex $P2448
    .const 'Sub' $P2446 = "566_1304282286.73" 
    capture_lex $P2446
    .const 'Sub' $P2441 = "564_1304282286.73" 
    capture_lex $P2441
    .const 'Sub' $P2439 = "563_1304282286.73" 
    capture_lex $P2439
    .const 'Sub' $P2430 = "560_1304282286.73" 
    capture_lex $P2430
    .const 'Sub' $P2428 = "559_1304282286.73" 
    capture_lex $P2428
    .const 'Sub' $P2423 = "557_1304282286.73" 
    capture_lex $P2423
    .const 'Sub' $P2421 = "556_1304282286.73" 
    capture_lex $P2421
    .const 'Sub' $P2412 = "553_1304282286.73" 
    capture_lex $P2412
    .lex "$?PACKAGE", $P2410
    .lex "$?CLASS", $P2411
    .const 'Sub' $P2488 = "580_1304282286.73" 
    capture_lex $P2488
    .return ($P2488)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1596") :outer("552_1304282286.73")
.annotate 'line', 731
    .const 'Sub' $P2409 = "552_1304282286.73" 
    .local pmc block
    set block, $P2409
    .const 'Sub' $P2492 = "581_1304282286.73" 
    capture_lex $P2492
    $P2492()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2491"  :anon :subid("581_1304282286.73") :outer("552_1304282286.73")
.annotate 'line', 731
    nqp_get_sc_object $P2493, "1304282274.421", 360
    .local pmc type_obj
    set type_obj, $P2493
    get_how $P2494, type_obj
    $P2495 = $P2494."compose"(type_obj)
    .return ($P2495)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("553_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .const 'Sub' $P2418 = "555_1304282286.73" 
    capture_lex $P2418
    .local string rx2413_tgt
    .local int rx2413_pos
    .local int rx2413_off
    .local int rx2413_eos
    .local int rx2413_rep
    .local pmc rx2413_cur
    .local pmc rx2413_debug
    (rx2413_cur, rx2413_pos, rx2413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2413_cur
    .local pmc match
    .lex "$/", match
    length rx2413_eos, rx2413_tgt
    gt rx2413_pos, rx2413_eos, rx2413_done
    set rx2413_off, 0
    lt rx2413_pos, 2, rx2413_start
    sub rx2413_off, rx2413_pos, 1
    substr rx2413_tgt, rx2413_tgt, rx2413_off
  rx2413_start:
    eq $I10, 1, rx2413_restart
    if_null rx2413_debug, debug_1597
    rx2413_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1597:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2416_done
    goto rxscan2416_scan
  rxscan2416_loop:
    (rx2413_pos) = rx2413_cur."from"()
    inc rx2413_pos
    rx2413_cur."!cursor_from"(rx2413_pos)
    ge rx2413_pos, rx2413_eos, rxscan2416_done
  rxscan2416_scan:
    set_addr $I10, rxscan2416_loop
    rx2413_cur."!mark_push"(0, rx2413_pos, $I10)
  rxscan2416_done:
.annotate 'line', 733
  # rx literal  ":"
    add $I11, rx2413_pos, 1
    gt $I11, rx2413_eos, rx2413_fail
    sub $I11, rx2413_pos, rx2413_off
    ord $I11, rx2413_tgt, $I11
    ne $I11, 58, rx2413_fail
    add rx2413_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2413_cur."!cursor_pos"(rx2413_pos)
    .const 'Sub' $P2418 = "555_1304282286.73" 
    capture_lex $P2418
    $P10 = rx2413_cur."before"($P2418)
    unless $P10, rx2413_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2413_cur."!cursor_pos"(rx2413_pos)
    $P10 = rx2413_cur."LANG"("MAIN", "statement")
    unless $P10, rx2413_fail
    rx2413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2413_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2413_cur."!cursor_pos"(rx2413_pos)
    $P10 = rx2413_cur."ws"()
    unless $P10, rx2413_fail
    rx2413_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2413_pos, 1
    gt $I11, rx2413_eos, rx2413_fail
    sub $I11, rx2413_pos, rx2413_off
    ord $I11, rx2413_tgt, $I11
    ne $I11, 59, rx2413_fail
    add rx2413_pos, 1
.annotate 'line', 732
  # rx pass
    rx2413_cur."!cursor_pass"(rx2413_pos, "metachar:sym<:my>")
    if_null rx2413_debug, debug_1602
    rx2413_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2413_pos)
  debug_1602:
    .return (rx2413_cur)
  rx2413_restart:
.annotate 'line', 731
    if_null rx2413_debug, debug_1603
    rx2413_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1603:
  rx2413_fail:
    (rx2413_rep, rx2413_pos, $I10, $P10) = rx2413_cur."!mark_fail"(0)
    lt rx2413_pos, -1, rx2413_done
    eq rx2413_pos, -1, rx2413_fail
    jump $I10
  rx2413_done:
    rx2413_cur."!cursor_fail"()
    if_null rx2413_debug, debug_1604
    rx2413_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1604:
    .return (rx2413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("554_1304282286.73") :method
.annotate 'line', 731
    new $P2415, "ResizablePMCArray"
    push $P2415, ":"
    .return ($P2415)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2417"  :anon :subid("555_1304282286.73") :method :outer("553_1304282286.73")
.annotate 'line', 733
    .local string rx2419_tgt
    .local int rx2419_pos
    .local int rx2419_off
    .local int rx2419_eos
    .local int rx2419_rep
    .local pmc rx2419_cur
    .local pmc rx2419_debug
    (rx2419_cur, rx2419_pos, rx2419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2419_cur
    .local pmc match
    .lex "$/", match
    length rx2419_eos, rx2419_tgt
    gt rx2419_pos, rx2419_eos, rx2419_done
    set rx2419_off, 0
    lt rx2419_pos, 2, rx2419_start
    sub rx2419_off, rx2419_pos, 1
    substr rx2419_tgt, rx2419_tgt, rx2419_off
  rx2419_start:
    eq $I10, 1, rx2419_restart
    if_null rx2419_debug, debug_1598
    rx2419_cur."!cursor_debug"("START", "")
  debug_1598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2420_done
    goto rxscan2420_scan
  rxscan2420_loop:
    (rx2419_pos) = rx2419_cur."from"()
    inc rx2419_pos
    rx2419_cur."!cursor_from"(rx2419_pos)
    ge rx2419_pos, rx2419_eos, rxscan2420_done
  rxscan2420_scan:
    set_addr $I10, rxscan2420_loop
    rx2419_cur."!mark_push"(0, rx2419_pos, $I10)
  rxscan2420_done:
  # rx literal  "my"
    add $I11, rx2419_pos, 2
    gt $I11, rx2419_eos, rx2419_fail
    sub $I11, rx2419_pos, rx2419_off
    substr $S10, rx2419_tgt, $I11, 2
    ne $S10, "my", rx2419_fail
    add rx2419_pos, 2
  # rx pass
    rx2419_cur."!cursor_pass"(rx2419_pos, "")
    if_null rx2419_debug, debug_1599
    rx2419_cur."!cursor_debug"("PASS", "", " at pos=", rx2419_pos)
  debug_1599:
    .return (rx2419_cur)
  rx2419_restart:
    if_null rx2419_debug, debug_1600
    rx2419_cur."!cursor_debug"("NEXT", "")
  debug_1600:
  rx2419_fail:
    (rx2419_rep, rx2419_pos, $I10, $P10) = rx2419_cur."!mark_fail"(0)
    lt rx2419_pos, -1, rx2419_done
    eq rx2419_pos, -1, rx2419_fail
    jump $I10
  rx2419_done:
    rx2419_cur."!cursor_fail"()
    if_null rx2419_debug, debug_1601
    rx2419_cur."!cursor_debug"("FAIL", "")
  debug_1601:
    .return (rx2419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("556_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    new $P2422, "ResizablePMCArray"
    push $P2422, ":"
    .return ($P2422)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("557_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .local string rx2424_tgt
    .local int rx2424_pos
    .local int rx2424_off
    .local int rx2424_eos
    .local int rx2424_rep
    .local pmc rx2424_cur
    .local pmc rx2424_debug
    (rx2424_cur, rx2424_pos, rx2424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2424_cur
    .local pmc match
    .lex "$/", match
    length rx2424_eos, rx2424_tgt
    gt rx2424_pos, rx2424_eos, rx2424_done
    set rx2424_off, 0
    lt rx2424_pos, 2, rx2424_start
    sub rx2424_off, rx2424_pos, 1
    substr rx2424_tgt, rx2424_tgt, rx2424_off
  rx2424_start:
    eq $I10, 1, rx2424_restart
    if_null rx2424_debug, debug_1605
    rx2424_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1605:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2427_done
    goto rxscan2427_scan
  rxscan2427_loop:
    (rx2424_pos) = rx2424_cur."from"()
    inc rx2424_pos
    rx2424_cur."!cursor_from"(rx2424_pos)
    ge rx2424_pos, rx2424_eos, rxscan2427_done
  rxscan2427_scan:
    set_addr $I10, rxscan2427_loop
    rx2424_cur."!mark_push"(0, rx2424_pos, $I10)
  rxscan2427_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2424_pos, rx2424_off
    substr $S10, rx2424_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2424_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2424_cur."!cursor_pos"(rx2424_pos)
    $P10 = rx2424_cur."codeblock"()
    unless $P10, rx2424_fail
    rx2424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2424_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx2424_cur."!cursor_pass"(rx2424_pos, "metachar:sym<{ }>")
    if_null rx2424_debug, debug_1606
    rx2424_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2424_pos)
  debug_1606:
    .return (rx2424_cur)
  rx2424_restart:
.annotate 'line', 731
    if_null rx2424_debug, debug_1607
    rx2424_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1607:
  rx2424_fail:
    (rx2424_rep, rx2424_pos, $I10, $P10) = rx2424_cur."!mark_fail"(0)
    lt rx2424_pos, -1, rx2424_done
    eq rx2424_pos, -1, rx2424_fail
    jump $I10
  rx2424_done:
    rx2424_cur."!cursor_fail"()
    if_null rx2424_debug, debug_1608
    rx2424_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1608:
    .return (rx2424_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("558_1304282286.73") :method
.annotate 'line', 731
    new $P2426, "ResizablePMCArray"
    push $P2426, "{"
    .return ($P2426)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("559_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    new $P2429, "ResizablePMCArray"
    push $P2429, "{"
    .return ($P2429)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("560_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .const 'Sub' $P2436 = "562_1304282286.73" 
    capture_lex $P2436
    .local string rx2431_tgt
    .local int rx2431_pos
    .local int rx2431_off
    .local int rx2431_eos
    .local int rx2431_rep
    .local pmc rx2431_cur
    .local pmc rx2431_debug
    (rx2431_cur, rx2431_pos, rx2431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2431_cur
    .local pmc match
    .lex "$/", match
    length rx2431_eos, rx2431_tgt
    gt rx2431_pos, rx2431_eos, rx2431_done
    set rx2431_off, 0
    lt rx2431_pos, 2, rx2431_start
    sub rx2431_off, rx2431_pos, 1
    substr rx2431_tgt, rx2431_tgt, rx2431_off
  rx2431_start:
    eq $I10, 1, rx2431_restart
    if_null rx2431_debug, debug_1609
    rx2431_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1609:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2434_done
    goto rxscan2434_scan
  rxscan2434_loop:
    (rx2431_pos) = rx2431_cur."from"()
    inc rx2431_pos
    rx2431_cur."!cursor_from"(rx2431_pos)
    ge rx2431_pos, rx2431_eos, rxscan2434_done
  rxscan2434_scan:
    set_addr $I10, rxscan2434_loop
    rx2431_cur."!mark_push"(0, rx2431_pos, $I10)
  rxscan2434_done:
.annotate 'line', 741
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2431_pos, rx2431_off
    substr $S10, rx2431_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2431_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2431_cur."!cursor_pos"(rx2431_pos)
    .const 'Sub' $P2436 = "562_1304282286.73" 
    capture_lex $P2436
    $P10 = rx2431_cur."before"($P2436)
    unless $P10, rx2431_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2431_cur."!cursor_pos"(rx2431_pos)
    $P10 = rx2431_cur."LANG"("MAIN", "variable")
    unless $P10, rx2431_fail
    rx2431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2431_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx2431_cur."!cursor_pass"(rx2431_pos, "metachar:sym<nqpvar>")
    if_null rx2431_debug, debug_1614
    rx2431_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2431_pos)
  debug_1614:
    .return (rx2431_cur)
  rx2431_restart:
.annotate 'line', 731
    if_null rx2431_debug, debug_1615
    rx2431_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1615:
  rx2431_fail:
    (rx2431_rep, rx2431_pos, $I10, $P10) = rx2431_cur."!mark_fail"(0)
    lt rx2431_pos, -1, rx2431_done
    eq rx2431_pos, -1, rx2431_fail
    jump $I10
  rx2431_done:
    rx2431_cur."!cursor_fail"()
    if_null rx2431_debug, debug_1616
    rx2431_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1616:
    .return (rx2431_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("561_1304282286.73") :method
.annotate 'line', 731
    new $P2433, "ResizablePMCArray"
    push $P2433, "$"
    push $P2433, "@"
    .return ($P2433)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2435"  :anon :subid("562_1304282286.73") :method :outer("560_1304282286.73")
.annotate 'line', 741
    .local string rx2437_tgt
    .local int rx2437_pos
    .local int rx2437_off
    .local int rx2437_eos
    .local int rx2437_rep
    .local pmc rx2437_cur
    .local pmc rx2437_debug
    (rx2437_cur, rx2437_pos, rx2437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2437_cur
    .local pmc match
    .lex "$/", match
    length rx2437_eos, rx2437_tgt
    gt rx2437_pos, rx2437_eos, rx2437_done
    set rx2437_off, 0
    lt rx2437_pos, 2, rx2437_start
    sub rx2437_off, rx2437_pos, 1
    substr rx2437_tgt, rx2437_tgt, rx2437_off
  rx2437_start:
    eq $I10, 1, rx2437_restart
    if_null rx2437_debug, debug_1610
    rx2437_cur."!cursor_debug"("START", "")
  debug_1610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2438_done
    goto rxscan2438_scan
  rxscan2438_loop:
    (rx2437_pos) = rx2437_cur."from"()
    inc rx2437_pos
    rx2437_cur."!cursor_from"(rx2437_pos)
    ge rx2437_pos, rx2437_eos, rxscan2438_done
  rxscan2438_scan:
    set_addr $I10, rxscan2438_loop
    rx2437_cur."!mark_push"(0, rx2437_pos, $I10)
  rxscan2438_done:
  # rx charclass .
    ge rx2437_pos, rx2437_eos, rx2437_fail
    inc rx2437_pos
  # rx charclass w
    ge rx2437_pos, rx2437_eos, rx2437_fail
    sub $I10, rx2437_pos, rx2437_off
    is_cclass $I11, 8192, rx2437_tgt, $I10
    unless $I11, rx2437_fail
    inc rx2437_pos
  # rx pass
    rx2437_cur."!cursor_pass"(rx2437_pos, "")
    if_null rx2437_debug, debug_1611
    rx2437_cur."!cursor_debug"("PASS", "", " at pos=", rx2437_pos)
  debug_1611:
    .return (rx2437_cur)
  rx2437_restart:
    if_null rx2437_debug, debug_1612
    rx2437_cur."!cursor_debug"("NEXT", "")
  debug_1612:
  rx2437_fail:
    (rx2437_rep, rx2437_pos, $I10, $P10) = rx2437_cur."!mark_fail"(0)
    lt rx2437_pos, -1, rx2437_done
    eq rx2437_pos, -1, rx2437_fail
    jump $I10
  rx2437_done:
    rx2437_cur."!cursor_fail"()
    if_null rx2437_debug, debug_1613
    rx2437_cur."!cursor_debug"("FAIL", "")
  debug_1613:
    .return (rx2437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("563_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    new $P2440, "ResizablePMCArray"
    push $P2440, "$"
    push $P2440, "@"
    .return ($P2440)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("564_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .local string rx2442_tgt
    .local int rx2442_pos
    .local int rx2442_off
    .local int rx2442_eos
    .local int rx2442_rep
    .local pmc rx2442_cur
    .local pmc rx2442_debug
    (rx2442_cur, rx2442_pos, rx2442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2442_cur
    .local pmc match
    .lex "$/", match
    length rx2442_eos, rx2442_tgt
    gt rx2442_pos, rx2442_eos, rx2442_done
    set rx2442_off, 0
    lt rx2442_pos, 2, rx2442_start
    sub rx2442_off, rx2442_pos, 1
    substr rx2442_tgt, rx2442_tgt, rx2442_off
  rx2442_start:
    eq $I10, 1, rx2442_restart
    if_null rx2442_debug, debug_1617
    rx2442_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2445_done
    goto rxscan2445_scan
  rxscan2445_loop:
    (rx2442_pos) = rx2442_cur."from"()
    inc rx2442_pos
    rx2442_cur."!cursor_from"(rx2442_pos)
    ge rx2442_pos, rx2442_eos, rxscan2445_done
  rxscan2445_scan:
    set_addr $I10, rxscan2445_loop
    rx2442_cur."!mark_push"(0, rx2442_pos, $I10)
  rxscan2445_done:
.annotate 'line', 745
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2442_pos, rx2442_off
    substr $S10, rx2442_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2442_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2442_cur."!cursor_pos"(rx2442_pos)
    $P10 = rx2442_cur."codeblock"()
    unless $P10, rx2442_fail
    rx2442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2442_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx2442_cur."!cursor_pass"(rx2442_pos, "assertion:sym<{ }>")
    if_null rx2442_debug, debug_1618
    rx2442_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2442_pos)
  debug_1618:
    .return (rx2442_cur)
  rx2442_restart:
.annotate 'line', 731
    if_null rx2442_debug, debug_1619
    rx2442_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1619:
  rx2442_fail:
    (rx2442_rep, rx2442_pos, $I10, $P10) = rx2442_cur."!mark_fail"(0)
    lt rx2442_pos, -1, rx2442_done
    eq rx2442_pos, -1, rx2442_fail
    jump $I10
  rx2442_done:
    rx2442_cur."!cursor_fail"()
    if_null rx2442_debug, debug_1620
    rx2442_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1620:
    .return (rx2442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("565_1304282286.73") :method
.annotate 'line', 731
    new $P2444, "ResizablePMCArray"
    push $P2444, "{"
    .return ($P2444)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("566_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    new $P2447, "ResizablePMCArray"
    push $P2447, "{"
    .return ($P2447)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("567_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .const 'Sub' $P2454 = "569_1304282286.73" 
    capture_lex $P2454
    .local string rx2449_tgt
    .local int rx2449_pos
    .local int rx2449_off
    .local int rx2449_eos
    .local int rx2449_rep
    .local pmc rx2449_cur
    .local pmc rx2449_debug
    (rx2449_cur, rx2449_pos, rx2449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2449_cur
    .local pmc match
    .lex "$/", match
    length rx2449_eos, rx2449_tgt
    gt rx2449_pos, rx2449_eos, rx2449_done
    set rx2449_off, 0
    lt rx2449_pos, 2, rx2449_start
    sub rx2449_off, rx2449_pos, 1
    substr rx2449_tgt, rx2449_tgt, rx2449_off
  rx2449_start:
    eq $I10, 1, rx2449_restart
    if_null rx2449_debug, debug_1621
    rx2449_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2452_done
    goto rxscan2452_scan
  rxscan2452_loop:
    (rx2449_pos) = rx2449_cur."from"()
    inc rx2449_pos
    rx2449_cur."!cursor_from"(rx2449_pos)
    ge rx2449_pos, rx2449_eos, rxscan2452_done
  rxscan2452_scan:
    set_addr $I10, rxscan2452_loop
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxscan2452_done:
.annotate 'line', 749
  # rx subcapture "zw"
    set_addr $I10, rxcap_2457_fail
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2449_pos, rx2449_eos, rx2449_fail
    sub $I10, rx2449_pos, rx2449_off
    substr $S10, rx2449_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2449_fail
    inc rx2449_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2449_cur."!cursor_pos"(rx2449_pos)
    .const 'Sub' $P2454 = "569_1304282286.73" 
    capture_lex $P2454
    $P10 = rx2449_cur."before"($P2454)
    unless $P10, rx2449_fail
    set_addr $I10, rxcap_2457_fail
    ($I12, $I11) = rx2449_cur."!mark_peek"($I10)
    rx2449_cur."!cursor_pos"($I11)
    ($P10) = rx2449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2449_pos, "")
    rx2449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2457_done
  rxcap_2457_fail:
    goto rx2449_fail
  rxcap_2457_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2449_cur."!cursor_pos"(rx2449_pos)
    $P10 = rx2449_cur."codeblock"()
    unless $P10, rx2449_fail
    rx2449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2449_pos = $P10."pos"()
.annotate 'line', 748
  # rx pass
    rx2449_cur."!cursor_pass"(rx2449_pos, "assertion:sym<?{ }>")
    if_null rx2449_debug, debug_1626
    rx2449_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2449_pos)
  debug_1626:
    .return (rx2449_cur)
  rx2449_restart:
.annotate 'line', 731
    if_null rx2449_debug, debug_1627
    rx2449_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1627:
  rx2449_fail:
    (rx2449_rep, rx2449_pos, $I10, $P10) = rx2449_cur."!mark_fail"(0)
    lt rx2449_pos, -1, rx2449_done
    eq rx2449_pos, -1, rx2449_fail
    jump $I10
  rx2449_done:
    rx2449_cur."!cursor_fail"()
    if_null rx2449_debug, debug_1628
    rx2449_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1628:
    .return (rx2449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("568_1304282286.73") :method
.annotate 'line', 731
    new $P2451, "ResizablePMCArray"
    push $P2451, "!"
    push $P2451, "?"
    .return ($P2451)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2453"  :anon :subid("569_1304282286.73") :method :outer("567_1304282286.73")
.annotate 'line', 749
    .local string rx2455_tgt
    .local int rx2455_pos
    .local int rx2455_off
    .local int rx2455_eos
    .local int rx2455_rep
    .local pmc rx2455_cur
    .local pmc rx2455_debug
    (rx2455_cur, rx2455_pos, rx2455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2455_cur
    .local pmc match
    .lex "$/", match
    length rx2455_eos, rx2455_tgt
    gt rx2455_pos, rx2455_eos, rx2455_done
    set rx2455_off, 0
    lt rx2455_pos, 2, rx2455_start
    sub rx2455_off, rx2455_pos, 1
    substr rx2455_tgt, rx2455_tgt, rx2455_off
  rx2455_start:
    eq $I10, 1, rx2455_restart
    if_null rx2455_debug, debug_1622
    rx2455_cur."!cursor_debug"("START", "")
  debug_1622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2456_done
    goto rxscan2456_scan
  rxscan2456_loop:
    (rx2455_pos) = rx2455_cur."from"()
    inc rx2455_pos
    rx2455_cur."!cursor_from"(rx2455_pos)
    ge rx2455_pos, rx2455_eos, rxscan2456_done
  rxscan2456_scan:
    set_addr $I10, rxscan2456_loop
    rx2455_cur."!mark_push"(0, rx2455_pos, $I10)
  rxscan2456_done:
  # rx literal  "{"
    add $I11, rx2455_pos, 1
    gt $I11, rx2455_eos, rx2455_fail
    sub $I11, rx2455_pos, rx2455_off
    ord $I11, rx2455_tgt, $I11
    ne $I11, 123, rx2455_fail
    add rx2455_pos, 1
  # rx pass
    rx2455_cur."!cursor_pass"(rx2455_pos, "")
    if_null rx2455_debug, debug_1623
    rx2455_cur."!cursor_debug"("PASS", "", " at pos=", rx2455_pos)
  debug_1623:
    .return (rx2455_cur)
  rx2455_restart:
    if_null rx2455_debug, debug_1624
    rx2455_cur."!cursor_debug"("NEXT", "")
  debug_1624:
  rx2455_fail:
    (rx2455_rep, rx2455_pos, $I10, $P10) = rx2455_cur."!mark_fail"(0)
    lt rx2455_pos, -1, rx2455_done
    eq rx2455_pos, -1, rx2455_fail
    jump $I10
  rx2455_done:
    rx2455_cur."!cursor_fail"()
    if_null rx2455_debug, debug_1625
    rx2455_cur."!cursor_debug"("FAIL", "")
  debug_1625:
    .return (rx2455_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("570_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    new $P2459, "ResizablePMCArray"
    push $P2459, "!"
    push $P2459, "?"
    .return ($P2459)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("571_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .const 'Sub' $P2469 = "573_1304282286.73" 
    capture_lex $P2469
    .local string rx2461_tgt
    .local int rx2461_pos
    .local int rx2461_off
    .local int rx2461_eos
    .local int rx2461_rep
    .local pmc rx2461_cur
    .local pmc rx2461_debug
    (rx2461_cur, rx2461_pos, rx2461_tgt, $I10) = self."!cursor_start"()
    rx2461_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2461_cur
    .local pmc match
    .lex "$/", match
    length rx2461_eos, rx2461_tgt
    gt rx2461_pos, rx2461_eos, rx2461_done
    set rx2461_off, 0
    lt rx2461_pos, 2, rx2461_start
    sub rx2461_off, rx2461_pos, 1
    substr rx2461_tgt, rx2461_tgt, rx2461_off
  rx2461_start:
    eq $I10, 1, rx2461_restart
    if_null rx2461_debug, debug_1629
    rx2461_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2465_done
    goto rxscan2465_scan
  rxscan2465_loop:
    (rx2461_pos) = rx2461_cur."from"()
    inc rx2461_pos
    rx2461_cur."!cursor_from"(rx2461_pos)
    ge rx2461_pos, rx2461_eos, rxscan2465_done
  rxscan2465_scan:
    set_addr $I10, rxscan2465_loop
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
  rxscan2465_done:
.annotate 'line', 753
  # rx subrule "identifier" subtype=capture negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."identifier"()
    unless $P10, rx2461_fail
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2461_pos = $P10."pos"()
.annotate 'line', 760
  # rx rxquantr2466 ** 0..1
    set_addr $I10, rxquantr2466_done
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
  rxquantr2466_loop:
  alt2467_0:
.annotate 'line', 754
    set_addr $I10, alt2467_1
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
.annotate 'line', 755
  # rx subrule "before" subtype=zerowidth negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    .const 'Sub' $P2469 = "573_1304282286.73" 
    capture_lex $P2469
    $P10 = rx2461_cur."before"($P2469)
    unless $P10, rx2461_fail
    goto alt2467_end
  alt2467_1:
    set_addr $I10, alt2467_2
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
.annotate 'line', 756
  # rx literal  "="
    add $I11, rx2461_pos, 1
    gt $I11, rx2461_eos, rx2461_fail
    sub $I11, rx2461_pos, rx2461_off
    ord $I11, rx2461_tgt, $I11
    ne $I11, 61, rx2461_fail
    add rx2461_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."assertion"()
    unless $P10, rx2461_fail
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2461_pos = $P10."pos"()
    goto alt2467_end
  alt2467_2:
    set_addr $I10, alt2467_3
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
.annotate 'line', 757
  # rx literal  ":"
    add $I11, rx2461_pos, 1
    gt $I11, rx2461_eos, rx2461_fail
    sub $I11, rx2461_pos, rx2461_off
    ord $I11, rx2461_tgt, $I11
    ne $I11, 58, rx2461_fail
    add rx2461_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."arglist"()
    unless $P10, rx2461_fail
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2461_pos = $P10."pos"()
    goto alt2467_end
  alt2467_3:
    set_addr $I10, alt2467_4
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
.annotate 'line', 758
  # rx literal  "("
    add $I11, rx2461_pos, 1
    gt $I11, rx2461_eos, rx2461_fail
    sub $I11, rx2461_pos, rx2461_off
    ord $I11, rx2461_tgt, $I11
    ne $I11, 40, rx2461_fail
    add rx2461_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2461_fail
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2461_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2461_pos, 1
    gt $I11, rx2461_eos, rx2461_fail
    sub $I11, rx2461_pos, rx2461_off
    ord $I11, rx2461_tgt, $I11
    ne $I11, 41, rx2461_fail
    add rx2461_pos, 1
    goto alt2467_end
  alt2467_4:
.annotate 'line', 759
  # rx subrule "normspace" subtype=method negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."normspace"()
    unless $P10, rx2461_fail
    rx2461_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."nibbler"()
    unless $P10, rx2461_fail
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2461_pos = $P10."pos"()
  alt2467_end:
.annotate 'line', 760
    set_addr $I10, rxquantr2466_done
    (rx2461_rep) = rx2461_cur."!mark_commit"($I10)
  rxquantr2466_done:
.annotate 'line', 752
  # rx pass
    rx2461_cur."!cursor_pass"(rx2461_pos, "assertion:sym<name>")
    if_null rx2461_debug, debug_1634
    rx2461_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2461_pos)
  debug_1634:
    .return (rx2461_cur)
  rx2461_restart:
.annotate 'line', 731
    if_null rx2461_debug, debug_1635
    rx2461_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1635:
  rx2461_fail:
    (rx2461_rep, rx2461_pos, $I10, $P10) = rx2461_cur."!mark_fail"(0)
    lt rx2461_pos, -1, rx2461_done
    eq rx2461_pos, -1, rx2461_fail
    jump $I10
  rx2461_done:
    rx2461_cur."!cursor_fail"()
    if_null rx2461_debug, debug_1636
    rx2461_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1636:
    .return (rx2461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("572_1304282286.73") :method
.annotate 'line', 731
    $P2463 = self."!PREFIX__!subrule"("identifier", "")
    new $P2464, "ResizablePMCArray"
    push $P2464, $P2463
    .return ($P2464)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2468"  :anon :subid("573_1304282286.73") :method :outer("571_1304282286.73")
.annotate 'line', 755
    .local string rx2470_tgt
    .local int rx2470_pos
    .local int rx2470_off
    .local int rx2470_eos
    .local int rx2470_rep
    .local pmc rx2470_cur
    .local pmc rx2470_debug
    (rx2470_cur, rx2470_pos, rx2470_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2470_cur
    .local pmc match
    .lex "$/", match
    length rx2470_eos, rx2470_tgt
    gt rx2470_pos, rx2470_eos, rx2470_done
    set rx2470_off, 0
    lt rx2470_pos, 2, rx2470_start
    sub rx2470_off, rx2470_pos, 1
    substr rx2470_tgt, rx2470_tgt, rx2470_off
  rx2470_start:
    eq $I10, 1, rx2470_restart
    if_null rx2470_debug, debug_1630
    rx2470_cur."!cursor_debug"("START", "")
  debug_1630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2471_done
    goto rxscan2471_scan
  rxscan2471_loop:
    (rx2470_pos) = rx2470_cur."from"()
    inc rx2470_pos
    rx2470_cur."!cursor_from"(rx2470_pos)
    ge rx2470_pos, rx2470_eos, rxscan2471_done
  rxscan2471_scan:
    set_addr $I10, rxscan2471_loop
    rx2470_cur."!mark_push"(0, rx2470_pos, $I10)
  rxscan2471_done:
  # rx literal  ">"
    add $I11, rx2470_pos, 1
    gt $I11, rx2470_eos, rx2470_fail
    sub $I11, rx2470_pos, rx2470_off
    ord $I11, rx2470_tgt, $I11
    ne $I11, 62, rx2470_fail
    add rx2470_pos, 1
  # rx pass
    rx2470_cur."!cursor_pass"(rx2470_pos, "")
    if_null rx2470_debug, debug_1631
    rx2470_cur."!cursor_debug"("PASS", "", " at pos=", rx2470_pos)
  debug_1631:
    .return (rx2470_cur)
  rx2470_restart:
    if_null rx2470_debug, debug_1632
    rx2470_cur."!cursor_debug"("NEXT", "")
  debug_1632:
  rx2470_fail:
    (rx2470_rep, rx2470_pos, $I10, $P10) = rx2470_cur."!mark_fail"(0)
    lt rx2470_pos, -1, rx2470_done
    eq rx2470_pos, -1, rx2470_fail
    jump $I10
  rx2470_done:
    rx2470_cur."!cursor_fail"()
    if_null rx2470_debug, debug_1633
    rx2470_cur."!cursor_debug"("FAIL", "")
  debug_1633:
    .return (rx2470_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("574_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    $P2473 = self."!PREFIX__!subrule"("identifier", "")
    new $P2474, "ResizablePMCArray"
    push $P2474, $P2473
    .return ($P2474)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("575_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .local string rx2476_tgt
    .local int rx2476_pos
    .local int rx2476_off
    .local int rx2476_eos
    .local int rx2476_rep
    .local pmc rx2476_cur
    .local pmc rx2476_debug
    (rx2476_cur, rx2476_pos, rx2476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2476_cur
    .local pmc match
    .lex "$/", match
    length rx2476_eos, rx2476_tgt
    gt rx2476_pos, rx2476_eos, rx2476_done
    set rx2476_off, 0
    lt rx2476_pos, 2, rx2476_start
    sub rx2476_off, rx2476_pos, 1
    substr rx2476_tgt, rx2476_tgt, rx2476_off
  rx2476_start:
    eq $I10, 1, rx2476_restart
    if_null rx2476_debug, debug_1637
    rx2476_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2479_done
    goto rxscan2479_scan
  rxscan2479_loop:
    (rx2476_pos) = rx2476_cur."from"()
    inc rx2476_pos
    rx2476_cur."!cursor_from"(rx2476_pos)
    ge rx2476_pos, rx2476_eos, rxscan2479_done
  rxscan2479_scan:
    set_addr $I10, rxscan2479_loop
    rx2476_cur."!mark_push"(0, rx2476_pos, $I10)
  rxscan2479_done:
.annotate 'line', 764
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2476_pos, rx2476_off
    substr $S10, rx2476_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2476_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2476_cur."!cursor_pos"(rx2476_pos)
    $P10 = rx2476_cur."LANG"("MAIN", "variable")
    unless $P10, rx2476_fail
    rx2476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2476_pos = $P10."pos"()
.annotate 'line', 763
  # rx pass
    rx2476_cur."!cursor_pass"(rx2476_pos, "assertion:sym<var>")
    if_null rx2476_debug, debug_1638
    rx2476_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2476_pos)
  debug_1638:
    .return (rx2476_cur)
  rx2476_restart:
.annotate 'line', 731
    if_null rx2476_debug, debug_1639
    rx2476_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1639:
  rx2476_fail:
    (rx2476_rep, rx2476_pos, $I10, $P10) = rx2476_cur."!mark_fail"(0)
    lt rx2476_pos, -1, rx2476_done
    eq rx2476_pos, -1, rx2476_fail
    jump $I10
  rx2476_done:
    rx2476_cur."!cursor_fail"()
    if_null rx2476_debug, debug_1640
    rx2476_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1640:
    .return (rx2476_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("576_1304282286.73") :method
.annotate 'line', 731
    new $P2478, "ResizablePMCArray"
    push $P2478, "$"
    push $P2478, "@"
    .return ($P2478)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("577_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    new $P2481, "ResizablePMCArray"
    push $P2481, "$"
    push $P2481, "@"
    .return ($P2481)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("578_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    .local string rx2483_tgt
    .local int rx2483_pos
    .local int rx2483_off
    .local int rx2483_eos
    .local int rx2483_rep
    .local pmc rx2483_cur
    .local pmc rx2483_debug
    (rx2483_cur, rx2483_pos, rx2483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2483_cur
    .local pmc match
    .lex "$/", match
    length rx2483_eos, rx2483_tgt
    gt rx2483_pos, rx2483_eos, rx2483_done
    set rx2483_off, 0
    lt rx2483_pos, 2, rx2483_start
    sub rx2483_off, rx2483_pos, 1
    substr rx2483_tgt, rx2483_tgt, rx2483_off
  rx2483_start:
    eq $I10, 1, rx2483_restart
    if_null rx2483_debug, debug_1641
    rx2483_cur."!cursor_debug"("START", "codeblock")
  debug_1641:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2487_done
    goto rxscan2487_scan
  rxscan2487_loop:
    (rx2483_pos) = rx2483_cur."from"()
    inc rx2483_pos
    rx2483_cur."!cursor_from"(rx2483_pos)
    ge rx2483_pos, rx2483_eos, rxscan2487_done
  rxscan2487_scan:
    set_addr $I10, rxscan2487_loop
    rx2483_cur."!mark_push"(0, rx2483_pos, $I10)
  rxscan2487_done:
.annotate 'line', 768
  # rx subrule "LANG" subtype=capture negate=
    rx2483_cur."!cursor_pos"(rx2483_pos)
    $P10 = rx2483_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2483_fail
    rx2483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2483_pos = $P10."pos"()
.annotate 'line', 767
  # rx pass
    rx2483_cur."!cursor_pass"(rx2483_pos, "codeblock")
    if_null rx2483_debug, debug_1642
    rx2483_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2483_pos)
  debug_1642:
    .return (rx2483_cur)
  rx2483_restart:
.annotate 'line', 731
    if_null rx2483_debug, debug_1643
    rx2483_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1643:
  rx2483_fail:
    (rx2483_rep, rx2483_pos, $I10, $P10) = rx2483_cur."!mark_fail"(0)
    lt rx2483_pos, -1, rx2483_done
    eq rx2483_pos, -1, rx2483_fail
    jump $I10
  rx2483_done:
    rx2483_cur."!cursor_fail"()
    if_null rx2483_debug, debug_1644
    rx2483_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1644:
    .return (rx2483_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("579_1304282286.73") :method
.annotate 'line', 731
    $P2485 = self."!PREFIX__!subrule"("LANG", "")
    new $P2486, "ResizablePMCArray"
    push $P2486, $P2485
    .return ($P2486)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("580_1304282286.73") :method :outer("552_1304282286.73")
.annotate 'line', 731
    $P2489 = self."!PREFIX__!subrule"("LANG", "")
    new $P2490, "ResizablePMCArray"
    push $P2490, $P2489
    .return ($P2490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2496"  :subid("582_1304282286.73") :outer("10_1304282286.73")
.annotate 'line', 774
    .const 'Sub' $P6585 = "757_1304282286.73" 
    capture_lex $P6585
    .const 'Sub' $P6564 = "755_1304282286.73" 
    capture_lex $P6564
    .const 'Sub' $P6549 = "754_1304282286.73" 
    capture_lex $P6549
    .const 'Sub' $P6544 = "753_1304282286.73" 
    capture_lex $P6544
    .const 'Sub' $P6539 = "752_1304282286.73" 
    capture_lex $P6539
    .const 'Sub' $P6534 = "751_1304282286.73" 
    capture_lex $P6534
    .const 'Sub' $P6517 = "750_1304282286.73" 
    capture_lex $P6517
    .const 'Sub' $P6506 = "749_1304282286.73" 
    capture_lex $P6506
    .const 'Sub' $P6495 = "748_1304282286.73" 
    capture_lex $P6495
    .const 'Sub' $P6487 = "747_1304282286.73" 
    capture_lex $P6487
    .const 'Sub' $P6482 = "746_1304282286.73" 
    capture_lex $P6482
    .const 'Sub' $P6467 = "745_1304282286.73" 
    capture_lex $P6467
    .const 'Sub' $P6459 = "744_1304282286.73" 
    capture_lex $P6459
    .const 'Sub' $P6401 = "743_1304282286.73" 
    capture_lex $P6401
    .const 'Sub' $P6386 = "742_1304282286.73" 
    capture_lex $P6386
    .const 'Sub' $P6378 = "741_1304282286.73" 
    capture_lex $P6378
    .const 'Sub' $P6370 = "740_1304282286.73" 
    capture_lex $P6370
    .const 'Sub' $P6362 = "739_1304282286.73" 
    capture_lex $P6362
    .const 'Sub' $P6354 = "738_1304282286.73" 
    capture_lex $P6354
    .const 'Sub' $P6346 = "737_1304282286.73" 
    capture_lex $P6346
    .const 'Sub' $P6317 = "736_1304282286.73" 
    capture_lex $P6317
    .const 'Sub' $P6302 = "735_1304282286.73" 
    capture_lex $P6302
    .const 'Sub' $P6294 = "734_1304282286.73" 
    capture_lex $P6294
    .const 'Sub' $P6280 = "733_1304282286.73" 
    capture_lex $P6280
    .const 'Sub' $P6266 = "732_1304282286.73" 
    capture_lex $P6266
    .const 'Sub' $P6252 = "731_1304282286.73" 
    capture_lex $P6252
    .const 'Sub' $P6244 = "730_1304282286.73" 
    capture_lex $P6244
    .const 'Sub' $P6214 = "729_1304282286.73" 
    capture_lex $P6214
    .const 'Sub' $P6176 = "727_1304282286.73" 
    capture_lex $P6176
    .const 'Sub' $P6168 = "726_1304282286.73" 
    capture_lex $P6168
    .const 'Sub' $P6160 = "725_1304282286.73" 
    capture_lex $P6160
    .const 'Sub' $P6129 = "724_1304282286.73" 
    capture_lex $P6129
    .const 'Sub' $P6110 = "723_1304282286.73" 
    capture_lex $P6110
    .const 'Sub' $P6102 = "722_1304282286.73" 
    capture_lex $P6102
    .const 'Sub' $P6094 = "721_1304282286.73" 
    capture_lex $P6094
    .const 'Sub' $P5986 = "718_1304282286.73" 
    capture_lex $P5986
    .const 'Sub' $P5978 = "717_1304282286.73" 
    capture_lex $P5978
    .const 'Sub' $P5968 = "716_1304282286.73" 
    capture_lex $P5968
    .const 'Sub' $P5934 = "715_1304282286.73" 
    capture_lex $P5934
    .const 'Sub' $P5892 = "713_1304282286.73" 
    capture_lex $P5892
    .const 'Sub' $P5878 = "712_1304282286.73" 
    capture_lex $P5878
    .const 'Sub' $P5868 = "711_1304282286.73" 
    capture_lex $P5868
    .const 'Sub' $P5816 = "710_1304282286.73" 
    capture_lex $P5816
    .const 'Sub' $P5593 = "705_1304282286.73" 
    capture_lex $P5593
    .const 'Sub' $P5520 = "702_1304282286.73" 
    capture_lex $P5520
    .const 'Sub' $P5512 = "701_1304282286.73" 
    capture_lex $P5512
    .const 'Sub' $P5468 = "699_1304282286.73" 
    capture_lex $P5468
    .const 'Sub' $P5453 = "698_1304282286.73" 
    capture_lex $P5453
    .const 'Sub' $P5430 = "697_1304282286.73" 
    capture_lex $P5430
    .const 'Sub' $P5327 = "696_1304282286.73" 
    capture_lex $P5327
    .const 'Sub' $P5273 = "693_1304282286.73" 
    capture_lex $P5273
    .const 'Sub' $P5144 = "690_1304282286.73" 
    capture_lex $P5144
    .const 'Sub' $P4817 = "683_1304282286.73" 
    capture_lex $P4817
    .const 'Sub' $P4809 = "682_1304282286.73" 
    capture_lex $P4809
    .const 'Sub' $P4801 = "681_1304282286.73" 
    capture_lex $P4801
    .const 'Sub' $P4676 = "679_1304282286.73" 
    capture_lex $P4676
    .const 'Sub' $P4668 = "678_1304282286.73" 
    capture_lex $P4668
    .const 'Sub' $P4653 = "677_1304282286.73" 
    capture_lex $P4653
    .const 'Sub' $P4638 = "676_1304282286.73" 
    capture_lex $P4638
    .const 'Sub' $P4623 = "675_1304282286.73" 
    capture_lex $P4623
    .const 'Sub' $P4601 = "674_1304282286.73" 
    capture_lex $P4601
    .const 'Sub' $P4593 = "673_1304282286.73" 
    capture_lex $P4593
    .const 'Sub' $P4585 = "672_1304282286.73" 
    capture_lex $P4585
    .const 'Sub' $P4577 = "671_1304282286.73" 
    capture_lex $P4577
    .const 'Sub' $P4269 = "665_1304282286.73" 
    capture_lex $P4269
    .const 'Sub' $P4261 = "664_1304282286.73" 
    capture_lex $P4261
    .const 'Sub' $P4253 = "663_1304282286.73" 
    capture_lex $P4253
    .const 'Sub' $P4245 = "662_1304282286.73" 
    capture_lex $P4245
    .const 'Sub' $P4237 = "661_1304282286.73" 
    capture_lex $P4237
    .const 'Sub' $P4229 = "660_1304282286.73" 
    capture_lex $P4229
    .const 'Sub' $P4221 = "659_1304282286.73" 
    capture_lex $P4221
    .const 'Sub' $P4018 = "653_1304282286.73" 
    capture_lex $P4018
    .const 'Sub' $P3991 = "652_1304282286.73" 
    capture_lex $P3991
    .const 'Sub' $P3977 = "651_1304282286.73" 
    capture_lex $P3977
    .const 'Sub' $P3969 = "650_1304282286.73" 
    capture_lex $P3969
    .const 'Sub' $P3961 = "649_1304282286.73" 
    capture_lex $P3961
    .const 'Sub' $P3953 = "648_1304282286.73" 
    capture_lex $P3953
    .const 'Sub' $P3945 = "647_1304282286.73" 
    capture_lex $P3945
    .const 'Sub' $P3937 = "646_1304282286.73" 
    capture_lex $P3937
    .const 'Sub' $P3929 = "645_1304282286.73" 
    capture_lex $P3929
    .const 'Sub' $P3921 = "644_1304282286.73" 
    capture_lex $P3921
    .const 'Sub' $P3913 = "643_1304282286.73" 
    capture_lex $P3913
    .const 'Sub' $P3905 = "642_1304282286.73" 
    capture_lex $P3905
    .const 'Sub' $P3897 = "641_1304282286.73" 
    capture_lex $P3897
    .const 'Sub' $P3889 = "640_1304282286.73" 
    capture_lex $P3889
    .const 'Sub' $P3881 = "639_1304282286.73" 
    capture_lex $P3881
    .const 'Sub' $P3873 = "638_1304282286.73" 
    capture_lex $P3873
    .const 'Sub' $P3857 = "637_1304282286.73" 
    capture_lex $P3857
    .const 'Sub' $P3803 = "636_1304282286.73" 
    capture_lex $P3803
    .const 'Sub' $P3786 = "635_1304282286.73" 
    capture_lex $P3786
    .const 'Sub' $P3762 = "634_1304282286.73" 
    capture_lex $P3762
    .const 'Sub' $P3739 = "633_1304282286.73" 
    capture_lex $P3739
    .const 'Sub' $P3712 = "632_1304282286.73" 
    capture_lex $P3712
    .const 'Sub' $P3675 = "631_1304282286.73" 
    capture_lex $P3675
    .const 'Sub' $P3660 = "630_1304282286.73" 
    capture_lex $P3660
    .const 'Sub' $P3648 = "629_1304282286.73" 
    capture_lex $P3648
    .const 'Sub' $P3597 = "627_1304282286.73" 
    capture_lex $P3597
    .const 'Sub' $P3572 = "626_1304282286.73" 
    capture_lex $P3572
    .const 'Sub' $P3565 = "625_1304282286.73" 
    capture_lex $P3565
    .const 'Sub' $P3523 = "624_1304282286.73" 
    capture_lex $P3523
    .const 'Sub' $P3473 = "622_1304282286.73" 
    capture_lex $P3473
    .const 'Sub' $P3456 = "621_1304282286.73" 
    capture_lex $P3456
    .const 'Sub' $P3417 = "619_1304282286.73" 
    capture_lex $P3417
    .const 'Sub' $P3409 = "618_1304282286.73" 
    capture_lex $P3409
    .const 'Sub' $P3401 = "617_1304282286.73" 
    capture_lex $P3401
    .const 'Sub' $P3384 = "616_1304282286.73" 
    capture_lex $P3384
    .const 'Sub' $P3288 = "614_1304282286.73" 
    capture_lex $P3288
    .const 'Sub' $P3244 = "612_1304282286.73" 
    capture_lex $P3244
    .const 'Sub' $P3129 = "611_1304282286.73" 
    capture_lex $P3129
    .const 'Sub' $P3098 = "610_1304282286.73" 
    capture_lex $P3098
    .const 'Sub' $P3090 = "609_1304282286.73" 
    capture_lex $P3090
    .const 'Sub' $P2961 = "603_1304282286.73" 
    capture_lex $P2961
    .const 'Sub' $P2926 = "601_1304282286.73" 
    capture_lex $P2926
    .const 'Sub' $P2921 = "600_1304282286.73" 
    capture_lex $P2921
    .const 'Sub' $P2916 = "599_1304282286.73" 
    capture_lex $P2916
    .const 'Sub' $P2803 = "596_1304282286.73" 
    capture_lex $P2803
    .const 'Sub' $P2785 = "595_1304282286.73" 
    capture_lex $P2785
    .const 'Sub' $P2710 = "593_1304282286.73" 
    capture_lex $P2710
    .const 'Sub' $P2695 = "592_1304282286.73" 
    capture_lex $P2695
    .const 'Sub' $P2608 = "591_1304282286.73" 
    capture_lex $P2608
    .const 'Sub' $P2582 = "589_1304282286.73" 
    capture_lex $P2582
    .const 'Sub' $P2566 = "588_1304282286.73" 
    capture_lex $P2566
    .const 'Sub' $P2542 = "587_1304282286.73" 
    capture_lex $P2542
    .const 'Sub' $P2506 = "584_1304282286.73" 
    capture_lex $P2506
    .const 'Sub' $P2498 = "583_1304282286.73" 
    capture_lex $P2498
.annotate 'line', 778
    .const 'Sub' $P2498 = "583_1304282286.73" 
    newclosure $P2505, $P2498
    .lex "xblock_immediate", $P2505
.annotate 'line', 783
    .const 'Sub' $P2506 = "584_1304282286.73" 
    newclosure $P2541, $P2506
    .lex "block_immediate", $P2541
.annotate 'line', 793
    .const 'Sub' $P2542 = "587_1304282286.73" 
    newclosure $P2565, $P2542
    .lex "vivitype", $P2565
.annotate 'line', 812
    .const 'Sub' $P2566 = "588_1304282286.73" 
    newclosure $P2581, $P2566
    .lex "colonpair_str", $P2581
.annotate 'line', 974
    .const 'Sub' $P2582 = "589_1304282286.73" 
    newclosure $P2607, $P2582
    .lex "import_HOW_exports", $P2607
.annotate 'line', 1079
    .const 'Sub' $P2608 = "591_1304282286.73" 
    newclosure $P2694, $P2608
    .lex "push_block_handler", $P2694
.annotate 'line', 1613
    .const 'Sub' $P2695 = "592_1304282286.73" 
    newclosure $P2709, $P2695
    .lex "only_star_block", $P2709
.annotate 'line', 1622
    .const 'Sub' $P2710 = "593_1304282286.73" 
    newclosure $P2784, $P2710
    .lex "attach_multi_signature", $P2784
.annotate 'line', 2074
    .const 'Sub' $P2785 = "595_1304282286.73" 
    newclosure $P2802, $P2785
    .lex "control", $P2802
.annotate 'line', 2093
    .const 'Sub' $P2803 = "596_1304282286.73" 
    newclosure $P2915, $P2803
    .lex "lexical_package_lookup", $P2915
.annotate 'line', 2142
    .const 'Sub' $P2916 = "599_1304282286.73" 
    newclosure $P2920, $P2916
    .lex "is_lexical", $P2920
.annotate 'line', 2148
    .const 'Sub' $P2921 = "600_1304282286.73" 
    newclosure $P2925, $P2921
    .lex "is_package", $P2925
.annotate 'line', 2154
    .const 'Sub' $P2926 = "601_1304282286.73" 
    newclosure $P2960, $P2926
    .lex "is_scope", $P2960
.annotate 'line', 2177
    .const 'Sub' $P2961 = "603_1304282286.73" 
    newclosure $P3081, $P2961
    .lex "find_sym", $P3081
.annotate 'line', 774
    .lex "$?PACKAGE", $P3082
    .lex "$?CLASS", $P3083
.annotate 'line', 776
    new $P3084, "ResizablePMCArray"
    find_lex $P3085, "$?PACKAGE"
    get_who $P3086, $P3085
    set $P3086["@BLOCK"], $P3084
    find_lex $P3087, "xblock_immediate"
    find_lex $P3088, "block_immediate"
    find_lex $P3089, "vivitype"
.annotate 'line', 804
    find_lex $P3128, "colonpair_str"
.annotate 'line', 957
    find_lex $P3522, "import_HOW_exports"
.annotate 'line', 1072
    find_lex $P3785, "push_block_handler"
.annotate 'line', 1560
    find_lex $P5271, "only_star_block"
    find_lex $P5272, "attach_multi_signature"
.annotate 'line', 2065
    find_lex $P6533, "control"
.annotate 'line', 2087
    find_lex $P6560, "lexical_package_lookup"
    find_lex $P6561, "is_lexical"
    find_lex $P6562, "is_package"
    find_lex $P6563, "is_scope"
.annotate 'line', 2165
    find_lex $P6583, "find_sym"
.annotate 'line', 774
    .return ($P6583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1645") :outer("582_1304282286.73")
.annotate 'line', 774
    .const 'Sub' $P2497 = "582_1304282286.73" 
    .local pmc block
    set block, $P2497
    .const 'Sub' $P6585 = "757_1304282286.73" 
    capture_lex $P6585
    $P6585()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6584"  :anon :subid("757_1304282286.73") :outer("582_1304282286.73")
.annotate 'line', 774
    nqp_get_sc_object $P6586, "1304282274.421", 377
    .local pmc type_obj
    set type_obj, $P6586
    get_how $P6587, type_obj
    $P6588 = $P6587."compose"(type_obj)
    .return ($P6588)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("583_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2499
.annotate 'line', 778
    .lex "$xblock", param_2499
.annotate 'line', 779
    find_lex $P2500, "$xblock"
    unless_null $P2500, vivify_1646
    $P2500 = root_new ['parrot';'ResizablePMCArray']
  vivify_1646:
    set $P2501, $P2500[1]
    unless_null $P2501, vivify_1647
    new $P2501, "Undef"
  vivify_1647:
    $P2502 = "block_immediate"($P2501)
    find_lex $P2503, "$xblock"
    unless_null $P2503, vivify_1648
    $P2503 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2503
  vivify_1648:
    set $P2503[1], $P2502
    find_lex $P2504, "$xblock"
    unless_null $P2504, vivify_1649
    new $P2504, "Undef"
  vivify_1649:
.annotate 'line', 778
    .return ($P2504)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("584_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2507
.annotate 'line', 783
    .const 'Sub' $P2517 = "585_1304282286.73" 
    capture_lex $P2517
    .lex "$block", param_2507
.annotate 'line', 784
    find_lex $P2508, "$block"
    unless_null $P2508, vivify_1650
    new $P2508, "Undef"
  vivify_1650:
    $P2508."blocktype"("immediate")
.annotate 'line', 785
    find_lex $P2512, "$block"
    unless_null $P2512, vivify_1651
    new $P2512, "Undef"
  vivify_1651:
    $P2513 = $P2512."symtable"()
    unless $P2513, unless_2511
    set $P2510, $P2513
    goto unless_2511_end
  unless_2511:
    find_lex $P2514, "$block"
    unless_null $P2514, vivify_1652
    new $P2514, "Undef"
  vivify_1652:
    $P2515 = $P2514."handlers"()
    set $P2510, $P2515
  unless_2511_end:
    if $P2510, unless_2509_end
    .const 'Sub' $P2517 = "585_1304282286.73" 
    capture_lex $P2517
    $P2517()
  unless_2509_end:
    find_lex $P2540, "$block"
    unless_null $P2540, vivify_1659
    new $P2540, "Undef"
  vivify_1659:
.annotate 'line', 783
    .return ($P2540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2516"  :anon :subid("585_1304282286.73") :outer("584_1304282286.73")
.annotate 'line', 785
    .const 'Sub' $P2531 = "586_1304282286.73" 
    capture_lex $P2531
.annotate 'line', 786
    new $P2518, "Undef"
    .lex "$stmts", $P2518
    get_hll_global $P2519, "GLOBAL"
    nqp_get_package_through_who $P2520, $P2519, "PAST"
    get_who $P2521, $P2520
    set $P2522, $P2521["Stmts"]
    find_lex $P2523, "$block"
    unless_null $P2523, vivify_1653
    new $P2523, "Undef"
  vivify_1653:
    $P2524 = $P2522."new"($P2523 :named("node"))
    store_lex "$stmts", $P2524
.annotate 'line', 787
    find_lex $P2526, "$block"
    unless_null $P2526, vivify_1654
    new $P2526, "Undef"
  vivify_1654:
    $P2527 = $P2526."list"()
    defined $I2528, $P2527
    unless $I2528, for_undef_1655
    iter $P2525, $P2527
    new $P2537, 'ExceptionHandler'
    set_label $P2537, loop2536_handler
    $P2537."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2537
  loop2536_test:
    unless $P2525, loop2536_done
    shift $P2529, $P2525
  loop2536_redo:
    .const 'Sub' $P2531 = "586_1304282286.73" 
    capture_lex $P2531
    $P2531($P2529)
  loop2536_next:
    goto loop2536_test
  loop2536_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2538, exception, 'type'
    eq $P2538, .CONTROL_LOOP_NEXT, loop2536_next
    eq $P2538, .CONTROL_LOOP_REDO, loop2536_redo
  loop2536_done:
    pop_eh 
  for_undef_1655:
.annotate 'line', 788
    find_lex $P2539, "$stmts"
    unless_null $P2539, vivify_1658
    new $P2539, "Undef"
  vivify_1658:
    store_lex "$block", $P2539
.annotate 'line', 785
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2530"  :anon :subid("586_1304282286.73") :outer("585_1304282286.73")
    .param pmc param_2532
.annotate 'line', 787
    .lex "$_", param_2532
    find_lex $P2533, "$stmts"
    unless_null $P2533, vivify_1656
    new $P2533, "Undef"
  vivify_1656:
    find_lex $P2534, "$_"
    unless_null $P2534, vivify_1657
    new $P2534, "Undef"
  vivify_1657:
    $P2535 = $P2533."push"($P2534)
    .return ($P2535)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("587_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2543
.annotate 'line', 793
    .lex "$sigil", param_2543
.annotate 'line', 794
    find_lex $P2546, "$sigil"
    unless_null $P2546, vivify_1660
    new $P2546, "Undef"
  vivify_1660:
    set $S2547, $P2546
    iseq $I2548, $S2547, "%"
    if $I2548, if_2545
.annotate 'line', 796
    find_lex $P2556, "$sigil"
    unless_null $P2556, vivify_1661
    new $P2556, "Undef"
  vivify_1661:
    set $S2557, $P2556
    iseq $I2558, $S2557, "@"
    if $I2558, if_2555
    new $P2564, "String"
    assign $P2564, "Undef"
    set $P2554, $P2564
    goto if_2555_end
  if_2555:
.annotate 'line', 797
    get_hll_global $P2559, "GLOBAL"
    nqp_get_package_through_who $P2560, $P2559, "PAST"
    get_who $P2561, $P2560
    set $P2562, $P2561["Op"]
    $P2563 = $P2562."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2554, $P2563
  if_2555_end:
    set $P2544, $P2554
.annotate 'line', 794
    goto if_2545_end
  if_2545:
.annotate 'line', 795
    get_hll_global $P2549, "GLOBAL"
    nqp_get_package_through_who $P2550, $P2549, "PAST"
    get_who $P2551, $P2550
    set $P2552, $P2551["Op"]
    $P2553 = $P2552."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2544, $P2553
  if_2545_end:
.annotate 'line', 793
    .return ($P2544)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("588_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2567
.annotate 'line', 812
    .lex "$ast", param_2567
.annotate 'line', 813
    get_hll_global $P2570, "GLOBAL"
    nqp_get_package_through_who $P2571, $P2570, "PAST"
    get_who $P2572, $P2571
    set $P2573, $P2572["Op"]
    find_lex $P2574, "$ast"
    unless_null $P2574, vivify_1662
    new $P2574, "Undef"
  vivify_1662:
    $P2575 = $P2573."ACCEPTS"($P2574)
    if $P2575, if_2569
.annotate 'line', 815
    find_lex $P2579, "$ast"
    unless_null $P2579, vivify_1663
    new $P2579, "Undef"
  vivify_1663:
    $P2580 = $P2579."value"()
    set $P2568, $P2580
.annotate 'line', 813
    goto if_2569_end
  if_2569:
.annotate 'line', 814
    find_lex $P2576, "$ast"
    unless_null $P2576, vivify_1664
    new $P2576, "Undef"
  vivify_1664:
    $P2577 = $P2576."list"()
    join $S2578, " ", $P2577
    new $P2568, 'String'
    set $P2568, $S2578
  if_2569_end:
.annotate 'line', 812
    .return ($P2568)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("589_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2583
.annotate 'line', 974
    .const 'Sub' $P2595 = "590_1304282286.73" 
    capture_lex $P2595
    .lex "$UNIT", param_2583
.annotate 'line', 976
    find_lex $P2586, "$UNIT"
    unless_null $P2586, vivify_1665
    new $P2586, "Undef"
  vivify_1665:
    exists $I2587, $P2586["EXPORTHOW"]
    if $I2587, if_2585
    new $P2584, 'Integer'
    set $P2584, $I2587
    goto if_2585_end
  if_2585:
.annotate 'line', 977
    find_lex $P2589, "$UNIT"
    unless_null $P2589, vivify_1666
    $P2589 = root_new ['parrot';'Hash']
  vivify_1666:
    set $P2590, $P2589["EXPORTHOW"]
    unless_null $P2590, vivify_1667
    new $P2590, "Undef"
  vivify_1667:
    get_who $P2591, $P2590
    defined $I2592, $P2591
    unless $I2592, for_undef_1668
    iter $P2588, $P2591
    new $P2605, 'ExceptionHandler'
    set_label $P2605, loop2604_handler
    $P2605."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2605
  loop2604_test:
    unless $P2588, loop2604_done
    shift $P2593, $P2588
  loop2604_redo:
    .const 'Sub' $P2595 = "590_1304282286.73" 
    capture_lex $P2595
    $P2595($P2593)
  loop2604_next:
    goto loop2604_test
  loop2604_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2606, exception, 'type'
    eq $P2606, .CONTROL_LOOP_NEXT, loop2604_next
    eq $P2606, .CONTROL_LOOP_REDO, loop2604_redo
  loop2604_done:
    pop_eh 
  for_undef_1668:
.annotate 'line', 976
    set $P2584, $P2588
  if_2585_end:
.annotate 'line', 974
    .return ($P2584)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2594"  :anon :subid("590_1304282286.73") :outer("589_1304282286.73")
    .param pmc param_2596
.annotate 'line', 977
    .lex "$_", param_2596
.annotate 'line', 978
    find_lex $P2597, "$_"
    unless_null $P2597, vivify_1669
    new $P2597, "Undef"
  vivify_1669:
    $P2598 = $P2597."value"()
    find_lex $P2599, "$_"
    unless_null $P2599, vivify_1670
    new $P2599, "Undef"
  vivify_1670:
    $P2600 = $P2599."key"()
    find_dynamic_lex $P2603, "%*HOW"
    unless_null $P2603, vivify_1671
    get_hll_global $P2601, "GLOBAL"
    get_who $P2602, $P2601
    set $P2603, $P2602["%HOW"]
    unless_null $P2603, vivify_1672
    die "Contextual %*HOW not found"
  vivify_1672:
    store_dynamic_lex "%*HOW", $P2603
  vivify_1671:
    set $P2603[$P2600], $P2598
.annotate 'line', 977
    .return ($P2598)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("591_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2609
    .param pmc param_2610
.annotate 'line', 1079
    .lex "$/", param_2609
    .lex "$block", param_2610
.annotate 'line', 1080
    find_lex $P2612, "$?PACKAGE"
    get_who $P2613, $P2612
    set $P2614, $P2613["@BLOCK"]
    unless_null $P2614, vivify_1673
    $P2614 = root_new ['parrot';'ResizablePMCArray']
  vivify_1673:
    set $P2615, $P2614[0]
    unless_null $P2615, vivify_1674
    new $P2615, "Undef"
  vivify_1674:
    $P2616 = $P2615."handlers"()
    if $P2616, unless_2611_end
.annotate 'line', 1081
    find_lex $P2617, "$?PACKAGE"
    get_who $P2618, $P2617
    set $P2619, $P2618["@BLOCK"]
    unless_null $P2619, vivify_1675
    $P2619 = root_new ['parrot';'ResizablePMCArray']
  vivify_1675:
    set $P2620, $P2619[0]
    unless_null $P2620, vivify_1676
    new $P2620, "Undef"
  vivify_1676:
    new $P2621, "ResizablePMCArray"
    $P2620."handlers"($P2621)
  unless_2611_end:
.annotate 'line', 1083
    find_lex $P2623, "$block"
    unless_null $P2623, vivify_1677
    new $P2623, "Undef"
  vivify_1677:
    $P2624 = $P2623."arity"()
    if $P2624, unless_2622_end
.annotate 'line', 1084
    find_lex $P2625, "$block"
    unless_null $P2625, vivify_1678
    new $P2625, "Undef"
  vivify_1678:
.annotate 'line', 1085
    get_hll_global $P2626, "GLOBAL"
    nqp_get_package_through_who $P2627, $P2626, "PAST"
    get_who $P2628, $P2627
    set $P2629, $P2628["Op"]
.annotate 'line', 1086
    get_hll_global $P2630, "GLOBAL"
    nqp_get_package_through_who $P2631, $P2630, "PAST"
    get_who $P2632, $P2631
    set $P2633, $P2632["Var"]
    $P2634 = $P2633."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1087
    get_hll_global $P2635, "GLOBAL"
    nqp_get_package_through_who $P2636, $P2635, "PAST"
    get_who $P2637, $P2636
    set $P2638, $P2637["Var"]
    $P2639 = $P2638."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2640 = $P2629."new"($P2634, $P2639, "bind" :named("pasttype"))
.annotate 'line', 1085
    $P2625."unshift"($P2640)
.annotate 'line', 1090
    find_lex $P2641, "$block"
    unless_null $P2641, vivify_1679
    new $P2641, "Undef"
  vivify_1679:
    get_hll_global $P2642, "GLOBAL"
    nqp_get_package_through_who $P2643, $P2642, "PAST"
    get_who $P2644, $P2643
    set $P2645, $P2644["Var"]
    $P2646 = $P2645."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2641."unshift"($P2646)
.annotate 'line', 1091
    find_lex $P2647, "$block"
    unless_null $P2647, vivify_1680
    new $P2647, "Undef"
  vivify_1680:
    $P2647."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1092
    find_lex $P2648, "$block"
    unless_null $P2648, vivify_1681
    new $P2648, "Undef"
  vivify_1681:
    $P2648."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1093
    find_lex $P2649, "$block"
    unless_null $P2649, vivify_1682
    new $P2649, "Undef"
  vivify_1682:
    $P2649."arity"(1)
  unless_2622_end:
.annotate 'line', 1095
    find_lex $P2650, "$block"
    unless_null $P2650, vivify_1683
    new $P2650, "Undef"
  vivify_1683:
    $P2650."blocktype"("declaration")
.annotate 'line', 1096
    find_lex $P2651, "$?PACKAGE"
    get_who $P2652, $P2651
    set $P2653, $P2652["@BLOCK"]
    unless_null $P2653, vivify_1684
    $P2653 = root_new ['parrot';'ResizablePMCArray']
  vivify_1684:
    set $P2654, $P2653[0]
    unless_null $P2654, vivify_1685
    new $P2654, "Undef"
  vivify_1685:
    $P2655 = $P2654."handlers"()
.annotate 'line', 1097
    get_hll_global $P2656, "GLOBAL"
    nqp_get_package_through_who $P2657, $P2656, "PAST"
    get_who $P2658, $P2657
    set $P2659, $P2658["Control"]
    find_lex $P2660, "$/"
    unless_null $P2660, vivify_1686
    new $P2660, "Undef"
  vivify_1686:
.annotate 'line', 1099
    get_hll_global $P2661, "GLOBAL"
    nqp_get_package_through_who $P2662, $P2661, "PAST"
    get_who $P2663, $P2662
    set $P2664, $P2663["Stmts"]
.annotate 'line', 1100
    get_hll_global $P2665, "GLOBAL"
    nqp_get_package_through_who $P2666, $P2665, "PAST"
    get_who $P2667, $P2666
    set $P2668, $P2667["Op"]
    find_lex $P2669, "$block"
    unless_null $P2669, vivify_1687
    new $P2669, "Undef"
  vivify_1687:
.annotate 'line', 1102
    get_hll_global $P2670, "GLOBAL"
    nqp_get_package_through_who $P2671, $P2670, "PAST"
    get_who $P2672, $P2671
    set $P2673, $P2672["Var"]
    $P2674 = $P2673."new"("register" :named("scope"), "exception" :named("name"))
    $P2675 = $P2668."new"($P2669, $P2674, "call" :named("pasttype"))
.annotate 'line', 1104
    get_hll_global $P2676, "GLOBAL"
    nqp_get_package_through_who $P2677, $P2676, "PAST"
    get_who $P2678, $P2677
    set $P2679, $P2678["Op"]
.annotate 'line', 1105
    get_hll_global $P2680, "GLOBAL"
    nqp_get_package_through_who $P2681, $P2680, "PAST"
    get_who $P2682, $P2681
    set $P2683, $P2682["Var"]
.annotate 'line', 1106
    get_hll_global $P2684, "GLOBAL"
    nqp_get_package_through_who $P2685, $P2684, "PAST"
    get_who $P2686, $P2685
    set $P2687, $P2686["Var"]
    $P2688 = $P2687."new"("register" :named("scope"), "exception" :named("name"))
    $P2689 = $P2683."new"($P2688, "handled", "keyed" :named("scope"))
.annotate 'line', 1105
    $P2690 = $P2679."new"($P2689, 1, "bind" :named("pasttype"))
.annotate 'line', 1104
    $P2691 = $P2664."new"($P2675, $P2690)
.annotate 'line', 1099
    $P2692 = $P2659."new"($P2691, $P2660 :named("node"))
.annotate 'line', 1097
    $P2693 = $P2655."unshift"($P2692)
.annotate 'line', 1079
    .return ($P2693)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("592_1304282286.73") :outer("582_1304282286.73")
.annotate 'line', 1614
    new $P2696, "Undef"
    .lex "$past", $P2696
    find_lex $P2697, "$?PACKAGE"
    get_who $P2698, $P2697
    set $P2699, $P2698["@BLOCK"]
    unless_null $P2699, vivify_1688
    $P2699 = root_new ['parrot';'ResizablePMCArray']
  vivify_1688:
    $P2700 = $P2699."shift"()
    store_lex "$past", $P2700
.annotate 'line', 1615
    find_lex $P2701, "$past"
    unless_null $P2701, vivify_1689
    new $P2701, "Undef"
  vivify_1689:
    $P2701."closure"(1)
.annotate 'line', 1616
    find_lex $P2702, "$past"
    unless_null $P2702, vivify_1690
    new $P2702, "Undef"
  vivify_1690:
    get_hll_global $P2703, "GLOBAL"
    nqp_get_package_through_who $P2704, $P2703, "PAST"
    get_who $P2705, $P2704
    set $P2706, $P2705["Op"]
    $P2707 = $P2706."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2702."push"($P2707)
    find_lex $P2708, "$past"
    unless_null $P2708, vivify_1691
    new $P2708, "Undef"
  vivify_1691:
.annotate 'line', 1613
    .return ($P2708)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("593_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2711
.annotate 'line', 1622
    .const 'Sub' $P2731 = "594_1304282286.73" 
    capture_lex $P2731
    .lex "$routine", param_2711
.annotate 'line', 1626
    new $P2712, "Undef"
    .lex "$types", $P2712
.annotate 'line', 1627
    new $P2713, "Undef"
    .lex "$definednesses", $P2713
.annotate 'line', 1626
    get_hll_global $P2714, "GLOBAL"
    nqp_get_package_through_who $P2715, $P2714, "PAST"
    get_who $P2716, $P2715
    set $P2717, $P2716["Op"]
    $P2718 = $P2717."new"("list" :named("pasttype"))
    store_lex "$types", $P2718
.annotate 'line', 1627
    get_hll_global $P2719, "GLOBAL"
    nqp_get_package_through_who $P2720, $P2719, "PAST"
    get_who $P2721, $P2720
    set $P2722, $P2721["Op"]
    $P2723 = $P2722."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2723
.annotate 'line', 1628
    find_lex $P2725, "$routine"
    unless_null $P2725, vivify_1692
    $P2725 = root_new ['parrot';'ResizablePMCArray']
  vivify_1692:
    set $P2726, $P2725[0]
    unless_null $P2726, vivify_1693
    new $P2726, "Undef"
  vivify_1693:
    $P2727 = $P2726."list"()
    defined $I2728, $P2727
    unless $I2728, for_undef_1694
    iter $P2724, $P2727
    new $P2775, 'ExceptionHandler'
    set_label $P2775, loop2774_handler
    $P2775."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2775
  loop2774_test:
    unless $P2724, loop2774_done
    shift $P2729, $P2724
  loop2774_redo:
    .const 'Sub' $P2731 = "594_1304282286.73" 
    capture_lex $P2731
    $P2731($P2729)
  loop2774_next:
    goto loop2774_test
  loop2774_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2776, exception, 'type'
    eq $P2776, .CONTROL_LOOP_NEXT, loop2774_next
    eq $P2776, .CONTROL_LOOP_REDO, loop2774_redo
  loop2774_done:
    pop_eh 
  for_undef_1694:
.annotate 'line', 1635
    find_dynamic_lex $P2779, "$*SC"
    unless_null $P2779, vivify_1704
    get_hll_global $P2777, "GLOBAL"
    get_who $P2778, $P2777
    set $P2779, $P2778["$SC"]
    unless_null $P2779, vivify_1705
    die "Contextual $*SC not found"
  vivify_1705:
  vivify_1704:
    find_lex $P2780, "$routine"
    unless_null $P2780, vivify_1706
    new $P2780, "Undef"
  vivify_1706:
    find_lex $P2781, "$types"
    unless_null $P2781, vivify_1707
    new $P2781, "Undef"
  vivify_1707:
    find_lex $P2782, "$definednesses"
    unless_null $P2782, vivify_1708
    new $P2782, "Undef"
  vivify_1708:
    $P2783 = $P2779."set_routine_signature"($P2780, $P2781, $P2782)
.annotate 'line', 1622
    .return ($P2783)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2730"  :anon :subid("594_1304282286.73") :outer("593_1304282286.73")
    .param pmc param_2732
.annotate 'line', 1628
    .lex "$_", param_2732
.annotate 'line', 1629
    get_hll_global $P2737, "GLOBAL"
    nqp_get_package_through_who $P2738, $P2737, "PAST"
    get_who $P2739, $P2738
    set $P2740, $P2739["Var"]
    find_lex $P2741, "$_"
    unless_null $P2741, vivify_1695
    new $P2741, "Undef"
  vivify_1695:
    $P2742 = $P2740."ACCEPTS"($P2741)
    if $P2742, if_2736
    set $P2735, $P2742
    goto if_2736_end
  if_2736:
    find_lex $P2743, "$_"
    unless_null $P2743, vivify_1696
    new $P2743, "Undef"
  vivify_1696:
    $S2744 = $P2743."scope"()
    iseq $I2745, $S2744, "parameter"
    new $P2735, 'Integer'
    set $P2735, $I2745
  if_2736_end:
    if $P2735, if_2734
    set $P2733, $P2735
    goto if_2734_end
  if_2734:
.annotate 'line', 1630
    find_lex $P2746, "$types"
    unless_null $P2746, vivify_1697
    new $P2746, "Undef"
  vivify_1697:
    find_lex $P2748, "$_"
    unless_null $P2748, vivify_1698
    new $P2748, "Undef"
  vivify_1698:
    $P2749 = $P2748."multitype"()
    set $P2747, $P2749
    defined $I2751, $P2747
    if $I2751, default_2750
    get_hll_global $P2752, "GLOBAL"
    nqp_get_package_through_who $P2753, $P2752, "PAST"
    get_who $P2754, $P2753
    set $P2755, $P2754["Op"]
    $P2756 = $P2755."new"("null P" :named("pirop"))
    set $P2747, $P2756
  default_2750:
    $P2746."push"($P2747)
.annotate 'line', 1631
    find_lex $P2757, "$definednesses"
    unless_null $P2757, vivify_1699
    new $P2757, "Undef"
  vivify_1699:
    find_lex $P2760, "$_"
    unless_null $P2760, vivify_1700
    $P2760 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P2761, $P2760["definedness"]
    unless_null $P2761, vivify_1701
    new $P2761, "Undef"
  vivify_1701:
    set $S2762, $P2761
    iseq $I2763, $S2762, "D"
    if $I2763, if_2759
.annotate 'line', 1632
    find_lex $P2767, "$_"
    unless_null $P2767, vivify_1702
    $P2767 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P2768, $P2767["definedness"]
    unless_null $P2768, vivify_1703
    new $P2768, "Undef"
  vivify_1703:
    set $S2769, $P2768
    iseq $I2770, $S2769, "U"
    if $I2770, if_2766
    new $P2772, "Integer"
    assign $P2772, 0
    set $P2765, $P2772
    goto if_2766_end
  if_2766:
    new $P2771, "Integer"
    assign $P2771, 2
    set $P2765, $P2771
  if_2766_end:
    set $P2758, $P2765
.annotate 'line', 1631
    goto if_2759_end
  if_2759:
    new $P2764, "Integer"
    assign $P2764, 1
    set $P2758, $P2764
  if_2759_end:
    $P2773 = $P2757."push"($P2758)
.annotate 'line', 1629
    set $P2733, $P2773
  if_2734_end:
.annotate 'line', 1628
    .return ($P2733)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("595_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2786
    .param pmc param_2787
.annotate 'line', 2074
    .lex "$/", param_2786
    .lex "$type", param_2787
.annotate 'line', 2075
    find_lex $P2788, "$/"
    get_hll_global $P2789, "GLOBAL"
    nqp_get_package_through_who $P2790, $P2789, "PAST"
    get_who $P2791, $P2790
    set $P2792, $P2791["Op"]
    find_lex $P2793, "$/"
    unless_null $P2793, vivify_1709
    new $P2793, "Undef"
  vivify_1709:
.annotate 'line', 2079
    get_hll_global $P2794, "GLOBAL"
    nqp_get_package_through_who $P2795, $P2794, "PAST"
    get_who $P2796, $P2795
    set $P2797, $P2796["Val"]
    find_lex $P2798, "$type"
    unless_null $P2798, vivify_1710
    new $P2798, "Undef"
  vivify_1710:
    $P2799 = $P2797."new"($P2798 :named("value"), "!except_types" :named("returns"))
    $P2800 = $P2792."new"(0, $P2799, $P2793 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2075
    $P2801 = $P2788."!make"($P2800)
.annotate 'line', 2074
    .return ($P2801)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("596_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2806
    .param pmc param_2807
.annotate 'line', 2093
    .const 'Sub' $P2860 = "597_1304282286.73" 
    capture_lex $P2860
    new $P2805, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2805, control_2804
    push_eh $P2805
    .lex "@name", param_2806
    .lex "$/", param_2807
.annotate 'line', 2099
    new $P2808, "Undef"
    .lex "$final_name", $P2808
.annotate 'line', 2100
    new $P2809, "Undef"
    .lex "$lookup", $P2809
.annotate 'line', 2095
    find_lex $P2811, "@name"
    unless_null $P2811, vivify_1711
    $P2811 = root_new ['parrot';'ResizablePMCArray']
  vivify_1711:
    set $N2812, $P2811
    iseq $I2813, $N2812, 0.0
    unless $I2813, if_2810_end
    find_lex $P2814, "$/"
    unless_null $P2814, vivify_1712
    new $P2814, "Undef"
  vivify_1712:
    $P2815 = $P2814."CURSOR"()
    $P2815."panic"("Cannot compile empty name")
  if_2810_end:
.annotate 'line', 2099
    find_lex $P2816, "@name"
    unless_null $P2816, vivify_1713
    $P2816 = root_new ['parrot';'ResizablePMCArray']
  vivify_1713:
    $P2817 = $P2816."pop"()
    store_lex "$final_name", $P2817
.annotate 'line', 2100
    get_hll_global $P2818, "GLOBAL"
    nqp_get_package_through_who $P2819, $P2818, "PAST"
    get_who $P2820, $P2819
    set $P2821, $P2820["Var"]
    find_lex $P2822, "$final_name"
    unless_null $P2822, vivify_1714
    new $P2822, "Undef"
  vivify_1714:
    set $S2823, $P2822
    $P2824 = $P2821."new"($S2823, "keyed" :named("scope"))
    store_lex "$lookup", $P2824
.annotate 'line', 2104
    find_lex $P2826, "@name"
    unless_null $P2826, vivify_1715
    $P2826 = root_new ['parrot';'ResizablePMCArray']
  vivify_1715:
    set $N2827, $P2826
    iseq $I2828, $N2827, 0.0
    if $I2828, if_2825
.annotate 'line', 2122
    .const 'Sub' $P2860 = "597_1304282286.73" 
    capture_lex $P2860
    $P2860()
    goto if_2825_end
  if_2825:
.annotate 'line', 2105
    find_lex $P2829, "$lookup"
    unless_null $P2829, vivify_1728
    new $P2829, "Undef"
  vivify_1728:
    get_hll_global $P2830, "GLOBAL"
    nqp_get_package_through_who $P2831, $P2830, "PAST"
    get_who $P2832, $P2831
    set $P2833, $P2832["Op"]
.annotate 'line', 2107
    get_hll_global $P2834, "GLOBAL"
    nqp_get_package_through_who $P2835, $P2834, "PAST"
    get_who $P2836, $P2835
    set $P2837, $P2836["Var"]
    $P2838 = $P2837."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2839 = $P2833."new"($P2838, "get_who PP" :named("pirop"))
.annotate 'line', 2105
    $P2829."unshift"($P2839)
.annotate 'line', 2109
    find_lex $P2840, "$lookup"
    unless_null $P2840, vivify_1729
    new $P2840, "Undef"
  vivify_1729:
    get_hll_global $P2841, "GLOBAL"
    nqp_get_package_through_who $P2842, $P2841, "PAST"
    get_who $P2843, $P2842
    set $P2844, $P2843["Var"]
.annotate 'line', 2111
    get_hll_global $P2845, "GLOBAL"
    nqp_get_package_through_who $P2846, $P2845, "PAST"
    get_who $P2847, $P2846
    set $P2848, $P2847["Op"]
.annotate 'line', 2113
    get_hll_global $P2849, "GLOBAL"
    nqp_get_package_through_who $P2850, $P2849, "PAST"
    get_who $P2851, $P2850
    set $P2852, $P2851["Var"]
    new $P2853, "ResizablePMCArray"
    $P2854 = $P2852."new"("GLOBAL" :named("name"), $P2853 :named("namespace"), "package" :named("scope"))
    $P2855 = $P2848."new"($P2854, "get_who PP" :named("pirop"))
.annotate 'line', 2115
    find_lex $P2856, "$final_name"
    unless_null $P2856, vivify_1730
    new $P2856, "Undef"
  vivify_1730:
    set $S2857, $P2856
    $P2858 = $P2844."new"($P2855, $S2857, "keyed" :named("scope"))
.annotate 'line', 2109
    $P2840."viviself"($P2858)
  if_2825_end:
.annotate 'line', 2137
    new $P2912, "Exception"
    set $P2912['type'], .CONTROL_RETURN
    find_lex $P2913, "$lookup"
    unless_null $P2913, vivify_1731
    new $P2913, "Undef"
  vivify_1731:
    setattribute $P2912, 'payload', $P2913
    throw $P2912
.annotate 'line', 2093
    .return ()
  control_2804:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2914, exception, "payload"
    .return ($P2914)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2859"  :anon :subid("597_1304282286.73") :outer("596_1304282286.73")
.annotate 'line', 2122
    .const 'Sub' $P2891 = "598_1304282286.73" 
    capture_lex $P2891
.annotate 'line', 2123
    new $P2861, "Undef"
    .lex "$path", $P2861
    find_lex $P2864, "@name"
    unless_null $P2864, vivify_1716
    $P2864 = root_new ['parrot';'ResizablePMCArray']
  vivify_1716:
    set $P2865, $P2864[0]
    unless_null $P2865, vivify_1717
    new $P2865, "Undef"
  vivify_1717:
    $P2866 = "is_lexical"($P2865)
    if $P2866, if_2863
.annotate 'line', 2125
    get_hll_global $P2874, "GLOBAL"
    nqp_get_package_through_who $P2875, $P2874, "PAST"
    get_who $P2876, $P2875
    set $P2877, $P2876["Var"]
    new $P2878, "ResizablePMCArray"
    $P2879 = $P2877."new"("GLOBAL" :named("name"), $P2878 :named("namespace"), "package" :named("scope"))
    set $P2862, $P2879
.annotate 'line', 2123
    goto if_2863_end
  if_2863:
.annotate 'line', 2124
    get_hll_global $P2867, "GLOBAL"
    nqp_get_package_through_who $P2868, $P2867, "PAST"
    get_who $P2869, $P2868
    set $P2870, $P2869["Var"]
    find_lex $P2871, "@name"
    unless_null $P2871, vivify_1718
    $P2871 = root_new ['parrot';'ResizablePMCArray']
  vivify_1718:
    $P2872 = $P2871."shift"()
    $P2873 = $P2870."new"($P2872 :named("name"), "lexical" :named("scope"))
    set $P2862, $P2873
  if_2863_end:
.annotate 'line', 2123
    store_lex "$path", $P2862
.annotate 'line', 2126
    find_lex $P2881, "@name"
    unless_null $P2881, vivify_1719
    $P2881 = root_new ['parrot';'ResizablePMCArray']
  vivify_1719:
    set $P2882, $P2881[0]
    unless_null $P2882, vivify_1720
    new $P2882, "Undef"
  vivify_1720:
    set $S2883, $P2882
    iseq $I2884, $S2883, "GLOBAL"
    unless $I2884, if_2880_end
.annotate 'line', 2127
    find_lex $P2885, "@name"
    unless_null $P2885, vivify_1721
    $P2885 = root_new ['parrot';'ResizablePMCArray']
  vivify_1721:
    $P2885."shift"()
  if_2880_end:
.annotate 'line', 2129
    find_lex $P2887, "@name"
    unless_null $P2887, vivify_1722
    $P2887 = root_new ['parrot';'ResizablePMCArray']
  vivify_1722:
    defined $I2888, $P2887
    unless $I2888, for_undef_1723
    iter $P2886, $P2887
    new $P2902, 'ExceptionHandler'
    set_label $P2902, loop2901_handler
    $P2902."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2902
  loop2901_test:
    unless $P2886, loop2901_done
    shift $P2889, $P2886
  loop2901_redo:
    .const 'Sub' $P2891 = "598_1304282286.73" 
    capture_lex $P2891
    $P2891($P2889)
  loop2901_next:
    goto loop2901_test
  loop2901_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2903, exception, 'type'
    eq $P2903, .CONTROL_LOOP_NEXT, loop2901_next
    eq $P2903, .CONTROL_LOOP_REDO, loop2901_redo
  loop2901_done:
    pop_eh 
  for_undef_1723:
.annotate 'line', 2134
    find_lex $P2904, "$lookup"
    unless_null $P2904, vivify_1726
    new $P2904, "Undef"
  vivify_1726:
    get_hll_global $P2905, "GLOBAL"
    nqp_get_package_through_who $P2906, $P2905, "PAST"
    get_who $P2907, $P2906
    set $P2908, $P2907["Op"]
    find_lex $P2909, "$path"
    unless_null $P2909, vivify_1727
    new $P2909, "Undef"
  vivify_1727:
    $P2910 = $P2908."new"($P2909, "get_who PP" :named("pirop"))
    $P2911 = $P2904."unshift"($P2910)
.annotate 'line', 2122
    .return ($P2911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2890"  :anon :subid("598_1304282286.73") :outer("597_1304282286.73")
    .param pmc param_2892
.annotate 'line', 2129
    .lex "$_", param_2892
.annotate 'line', 2130
    get_hll_global $P2893, "GLOBAL"
    nqp_get_package_through_who $P2894, $P2893, "PAST"
    get_who $P2895, $P2894
    set $P2896, $P2895["Op"]
    find_lex $P2897, "$path"
    unless_null $P2897, vivify_1724
    new $P2897, "Undef"
  vivify_1724:
.annotate 'line', 2132
    find_lex $P2898, "$_"
    unless_null $P2898, vivify_1725
    new $P2898, "Undef"
  vivify_1725:
    set $S2899, $P2898
    $P2900 = $P2896."new"($P2897, $S2899, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2130
    store_lex "$path", $P2900
.annotate 'line', 2129
    .return ($P2900)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("599_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2917
.annotate 'line', 2142
    .lex "$name", param_2917
.annotate 'line', 2143
    find_lex $P2918, "$name"
    unless_null $P2918, vivify_1732
    new $P2918, "Undef"
  vivify_1732:
    $P2919 = "is_scope"($P2918, "lexical")
.annotate 'line', 2142
    .return ($P2919)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("600_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2922
.annotate 'line', 2148
    .lex "$name", param_2922
.annotate 'line', 2149
    find_lex $P2923, "$name"
    unless_null $P2923, vivify_1733
    new $P2923, "Undef"
  vivify_1733:
    $P2924 = "is_scope"($P2923, "package")
.annotate 'line', 2148
    .return ($P2924)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("601_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2929
    .param pmc param_2930
.annotate 'line', 2154
    .const 'Sub' $P2938 = "602_1304282286.73" 
    capture_lex $P2938
    new $P2928, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2928, control_2927
    push_eh $P2928
    .lex "$name", param_2929
    .lex "$wanted_scope", param_2930
.annotate 'line', 2155
    find_lex $P2932, "$?PACKAGE"
    get_who $P2933, $P2932
    set $P2934, $P2933["@BLOCK"]
    unless_null $P2934, vivify_1734
    $P2934 = root_new ['parrot';'ResizablePMCArray']
  vivify_1734:
    defined $I2935, $P2934
    unless $I2935, for_undef_1735
    iter $P2931, $P2934
    new $P2957, 'ExceptionHandler'
    set_label $P2957, loop2956_handler
    $P2957."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2957
  loop2956_test:
    unless $P2931, loop2956_done
    shift $P2936, $P2931
  loop2956_redo:
    .const 'Sub' $P2938 = "602_1304282286.73" 
    capture_lex $P2938
    $P2938($P2936)
  loop2956_next:
    goto loop2956_test
  loop2956_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2958, exception, 'type'
    eq $P2958, .CONTROL_LOOP_NEXT, loop2956_next
    eq $P2958, .CONTROL_LOOP_REDO, loop2956_redo
  loop2956_done:
    pop_eh 
  for_undef_1735:
.annotate 'line', 2154
    .return (0)
  control_2927:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2959, exception, "payload"
    .return ($P2959)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2937"  :anon :subid("602_1304282286.73") :outer("601_1304282286.73")
    .param pmc param_2940
.annotate 'line', 2156
    $P2939 = root_new ['parrot';'Hash']
    .lex "%sym", $P2939
    .lex "$_", param_2940
    find_lex $P2941, "$_"
    unless_null $P2941, vivify_1736
    new $P2941, "Undef"
  vivify_1736:
    find_lex $P2942, "$name"
    unless_null $P2942, vivify_1737
    new $P2942, "Undef"
  vivify_1737:
    $P2943 = $P2941."symbol"($P2942)
    store_lex "%sym", $P2943
.annotate 'line', 2157
    find_lex $P2946, "%sym"
    unless_null $P2946, vivify_1738
    $P2946 = root_new ['parrot';'Hash']
  vivify_1738:
    set $N2947, $P2946
    if $N2947, if_2945
    new $P2944, 'Float'
    set $P2944, $N2947
    goto if_2945_end
  if_2945:
.annotate 'line', 2158
    new $P2948, "Exception"
    set $P2948['type'], .CONTROL_RETURN
    find_lex $P2949, "%sym"
    unless_null $P2949, vivify_1739
    $P2949 = root_new ['parrot';'Hash']
  vivify_1739:
    set $P2950, $P2949["scope"]
    unless_null $P2950, vivify_1740
    new $P2950, "Undef"
  vivify_1740:
    set $S2951, $P2950
    find_lex $P2952, "$wanted_scope"
    unless_null $P2952, vivify_1741
    new $P2952, "Undef"
  vivify_1741:
    set $S2953, $P2952
    iseq $I2954, $S2951, $S2953
    new $P2955, 'Integer'
    set $P2955, $I2954
    setattribute $P2948, 'payload', $P2955
    throw $P2948
  if_2945_end:
.annotate 'line', 2155
    .return ($P2944)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("603_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_2964
    .param pmc param_2965
.annotate 'line', 2177
    .const 'Sub' $P3059 = "608_1304282286.73" 
    capture_lex $P3059
    .const 'Sub' $P3019 = "606_1304282286.73" 
    capture_lex $P3019
    .const 'Sub' $P2977 = "604_1304282286.73" 
    capture_lex $P2977
    new $P2963, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2963, control_2962
    push_eh $P2963
    .lex "@name", param_2964
    .lex "$/", param_2965
.annotate 'line', 2201
    new $P2966, "Undef"
    .lex "$result", $P2966
.annotate 'line', 2179
    find_lex $P2968, "@name"
    unless_null $P2968, vivify_1742
    $P2968 = root_new ['parrot';'ResizablePMCArray']
  vivify_1742:
    set $N2969, $P2968
    if $N2969, unless_2967_end
    find_lex $P2970, "$/"
    unless_null $P2970, vivify_1743
    new $P2970, "Undef"
  vivify_1743:
    $P2971 = $P2970."CURSOR"()
    $P2971."panic"("Cannot look up empty name")
  unless_2967_end:
.annotate 'line', 2183
    find_lex $P2973, "@name"
    unless_null $P2973, vivify_1744
    $P2973 = root_new ['parrot';'ResizablePMCArray']
  vivify_1744:
    set $N2974, $P2973
    iseq $I2975, $N2974, 1.0
    unless $I2975, if_2972_end
    .const 'Sub' $P2977 = "604_1304282286.73" 
    capture_lex $P2977
    $P2977()
  if_2972_end:
.annotate 'line', 2201
    find_dynamic_lex $P3013, "$*GLOBALish"
    unless_null $P3013, vivify_1756
    get_hll_global $P3011, "GLOBAL"
    get_who $P3012, $P3011
    set $P3013, $P3012["$GLOBALish"]
    unless_null $P3013, vivify_1757
    die "Contextual $*GLOBALish not found"
  vivify_1757:
  vivify_1756:
    store_lex "$result", $P3013
.annotate 'line', 2202
    find_lex $P3015, "@name"
    unless_null $P3015, vivify_1758
    $P3015 = root_new ['parrot';'ResizablePMCArray']
  vivify_1758:
    set $N3016, $P3015
    isge $I3017, $N3016, 2.0
    unless $I3017, if_3014_end
    .const 'Sub' $P3019 = "606_1304282286.73" 
    capture_lex $P3019
    $P3019()
  if_3014_end:
.annotate 'line', 2220
    find_lex $P3055, "@name"
    unless_null $P3055, vivify_1771
    $P3055 = root_new ['parrot';'ResizablePMCArray']
  vivify_1771:
    defined $I3056, $P3055
    unless $I3056, for_undef_1772
    iter $P3054, $P3055
    new $P3077, 'ExceptionHandler'
    set_label $P3077, loop3076_handler
    $P3077."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3077
  loop3076_test:
    unless $P3054, loop3076_done
    shift $P3057, $P3054
  loop3076_redo:
    .const 'Sub' $P3059 = "608_1304282286.73" 
    capture_lex $P3059
    $P3059($P3057)
  loop3076_next:
    goto loop3076_test
  loop3076_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3078, exception, 'type'
    eq $P3078, .CONTROL_LOOP_NEXT, loop3076_next
    eq $P3078, .CONTROL_LOOP_REDO, loop3076_redo
  loop3076_done:
    pop_eh 
  for_undef_1772:
    find_lex $P3079, "$result"
    unless_null $P3079, vivify_1779
    new $P3079, "Undef"
  vivify_1779:
.annotate 'line', 2177
    .return ($P3079)
  control_2962:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3080, exception, "payload"
    .return ($P3080)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2976"  :anon :subid("604_1304282286.73") :outer("603_1304282286.73")
.annotate 'line', 2183
    .const 'Sub' $P2988 = "605_1304282286.73" 
    capture_lex $P2988
.annotate 'line', 2184
    new $P2978, "Undef"
    .lex "$final_name", $P2978
    find_lex $P2979, "@name"
    unless_null $P2979, vivify_1745
    $P2979 = root_new ['parrot';'ResizablePMCArray']
  vivify_1745:
    set $P2980, $P2979[0]
    unless_null $P2980, vivify_1746
    new $P2980, "Undef"
  vivify_1746:
    store_lex "$final_name", $P2980
.annotate 'line', 2185
    find_lex $P2982, "$?PACKAGE"
    get_who $P2983, $P2982
    set $P2984, $P2983["@BLOCK"]
    unless_null $P2984, vivify_1747
    $P2984 = root_new ['parrot';'ResizablePMCArray']
  vivify_1747:
    defined $I2985, $P2984
    unless $I2985, for_undef_1748
    iter $P2981, $P2984
    new $P3009, 'ExceptionHandler'
    set_label $P3009, loop3008_handler
    $P3009."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3009
  loop3008_test:
    unless $P2981, loop3008_done
    shift $P2986, $P2981
  loop3008_redo:
    .const 'Sub' $P2988 = "605_1304282286.73" 
    capture_lex $P2988
    $P2988($P2986)
  loop3008_next:
    goto loop3008_test
  loop3008_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3010, exception, 'type'
    eq $P3010, .CONTROL_LOOP_NEXT, loop3008_next
    eq $P3010, .CONTROL_LOOP_REDO, loop3008_redo
  loop3008_done:
    pop_eh 
  for_undef_1748:
.annotate 'line', 2183
    .return ($P2981)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2987"  :anon :subid("605_1304282286.73") :outer("604_1304282286.73")
    .param pmc param_2990
.annotate 'line', 2186
    $P2989 = root_new ['parrot';'Hash']
    .lex "%sym", $P2989
    .lex "$_", param_2990
    find_lex $P2991, "$_"
    unless_null $P2991, vivify_1749
    new $P2991, "Undef"
  vivify_1749:
    find_lex $P2992, "$final_name"
    unless_null $P2992, vivify_1750
    new $P2992, "Undef"
  vivify_1750:
    $P2993 = $P2991."symbol"($P2992)
    store_lex "%sym", $P2993
.annotate 'line', 2187
    find_lex $P2996, "%sym"
    unless_null $P2996, vivify_1751
    $P2996 = root_new ['parrot';'Hash']
  vivify_1751:
    set $N2997, $P2996
    if $N2997, if_2995
    new $P2994, 'Float'
    set $P2994, $N2997
    goto if_2995_end
  if_2995:
.annotate 'line', 2188
    find_lex $P3000, "%sym"
    unless_null $P3000, vivify_1752
    $P3000 = root_new ['parrot';'Hash']
  vivify_1752:
    exists $I3001, $P3000["value"]
    if $I3001, if_2999
.annotate 'line', 2192
    new $P3005, 'String'
    set $P3005, "No compile-time value for "
    find_lex $P3006, "$final_name"
    unless_null $P3006, vivify_1753
    new $P3006, "Undef"
  vivify_1753:
    concat $P3007, $P3005, $P3006
    die $P3007
.annotate 'line', 2191
    goto if_2999_end
  if_2999:
.annotate 'line', 2189
    new $P3002, "Exception"
    set $P3002['type'], .CONTROL_RETURN
    find_lex $P3003, "%sym"
    unless_null $P3003, vivify_1754
    $P3003 = root_new ['parrot';'Hash']
  vivify_1754:
    set $P3004, $P3003["value"]
    unless_null $P3004, vivify_1755
    new $P3004, "Undef"
  vivify_1755:
    setattribute $P3002, 'payload', $P3004
    throw $P3002
  if_2999_end:
.annotate 'line', 2187
    set $P2994, $P2998
  if_2995_end:
.annotate 'line', 2185
    .return ($P2994)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3018"  :anon :subid("606_1304282286.73") :outer("603_1304282286.73")
.annotate 'line', 2202
    .const 'Sub' $P3030 = "607_1304282286.73" 
    capture_lex $P3030
.annotate 'line', 2203
    new $P3020, "Undef"
    .lex "$first", $P3020
    find_lex $P3021, "@name"
    unless_null $P3021, vivify_1759
    $P3021 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    set $P3022, $P3021[0]
    unless_null $P3022, vivify_1760
    new $P3022, "Undef"
  vivify_1760:
    store_lex "$first", $P3022
.annotate 'line', 2204
    find_lex $P3024, "$?PACKAGE"
    get_who $P3025, $P3024
    set $P3026, $P3025["@BLOCK"]
    unless_null $P3026, vivify_1761
    $P3026 = root_new ['parrot';'ResizablePMCArray']
  vivify_1761:
    defined $I3027, $P3026
    unless $I3027, for_undef_1762
    iter $P3023, $P3026
    new $P3052, 'ExceptionHandler'
    set_label $P3052, loop3051_handler
    $P3052."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3052
  loop3051_test:
    unless $P3023, loop3051_done
    shift $P3028, $P3023
  loop3051_redo:
    .const 'Sub' $P3030 = "607_1304282286.73" 
    capture_lex $P3030
    $P3030($P3028)
  loop3051_next:
    goto loop3051_test
  loop3051_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3053, exception, 'type'
    eq $P3053, .CONTROL_LOOP_NEXT, loop3051_next
    eq $P3053, .CONTROL_LOOP_REDO, loop3051_redo
  loop3051_done:
    pop_eh 
  for_undef_1762:
.annotate 'line', 2202
    .return ($P3023)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3029"  :anon :subid("607_1304282286.73") :outer("606_1304282286.73")
    .param pmc param_3032
.annotate 'line', 2205
    $P3031 = root_new ['parrot';'Hash']
    .lex "%sym", $P3031
    .lex "$_", param_3032
    find_lex $P3033, "$_"
    unless_null $P3033, vivify_1763
    new $P3033, "Undef"
  vivify_1763:
    find_lex $P3034, "$first"
    unless_null $P3034, vivify_1764
    new $P3034, "Undef"
  vivify_1764:
    $P3035 = $P3033."symbol"($P3034)
    store_lex "%sym", $P3035
.annotate 'line', 2206
    find_lex $P3038, "%sym"
    unless_null $P3038, vivify_1765
    $P3038 = root_new ['parrot';'Hash']
  vivify_1765:
    set $N3039, $P3038
    if $N3039, if_3037
    new $P3036, 'Float'
    set $P3036, $N3039
    goto if_3037_end
  if_3037:
.annotate 'line', 2207
    find_lex $P3042, "%sym"
    unless_null $P3042, vivify_1766
    $P3042 = root_new ['parrot';'Hash']
  vivify_1766:
    exists $I3043, $P3042["value"]
    if $I3043, if_3041
.annotate 'line', 2213
    new $P3048, 'String'
    set $P3048, "No compile-time value for "
    find_lex $P3049, "$first"
    unless_null $P3049, vivify_1767
    new $P3049, "Undef"
  vivify_1767:
    concat $P3050, $P3048, $P3049
    die $P3050
.annotate 'line', 2212
    goto if_3041_end
  if_3041:
.annotate 'line', 2208
    find_lex $P3044, "%sym"
    unless_null $P3044, vivify_1768
    $P3044 = root_new ['parrot';'Hash']
  vivify_1768:
    set $P3045, $P3044["value"]
    unless_null $P3045, vivify_1769
    new $P3045, "Undef"
  vivify_1769:
    store_lex "$result", $P3045
.annotate 'line', 2209
    find_lex $P3046, "@name"
    unless_null $P3046, vivify_1770
    $P3046 = root_new ['parrot';'ResizablePMCArray']
  vivify_1770:
    $P3046."shift"()
.annotate 'line', 2210
    set $I3047, .CONTROL_LOOP_LAST
    die 0, $I3047
  if_3041_end:
.annotate 'line', 2206
    set $P3036, $P3040
  if_3037_end:
.annotate 'line', 2204
    .return ($P3036)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3058"  :anon :subid("608_1304282286.73") :outer("603_1304282286.73")
    .param pmc param_3060
.annotate 'line', 2220
    .lex "$_", param_3060
.annotate 'line', 2221
    find_lex $P3065, "$_"
    unless_null $P3065, vivify_1773
    new $P3065, "Undef"
  vivify_1773:
    set $S3066, $P3065
    find_lex $P3063, "$result"
    unless_null $P3063, vivify_1774
    new $P3063, "Undef"
  vivify_1774:
    get_who $P3064, $P3063
    exists $I3067, $P3064[$S3066]
    if $I3067, if_3062
.annotate 'line', 2225
    new $P3072, "String"
    assign $P3072, "Could not locate compile-time value for symbol "
.annotate 'line', 2226
    find_lex $P3073, "@name"
    unless_null $P3073, vivify_1775
    $P3073 = root_new ['parrot';'ResizablePMCArray']
  vivify_1775:
    join $S3074, "::", $P3073
    concat $P3075, $P3072, $S3074
.annotate 'line', 2225
    die $P3075
.annotate 'line', 2224
    goto if_3062_end
  if_3062:
.annotate 'line', 2222
    find_lex $P3068, "$_"
    unless_null $P3068, vivify_1776
    new $P3068, "Undef"
  vivify_1776:
    find_lex $P3069, "$result"
    unless_null $P3069, vivify_1777
    new $P3069, "Undef"
  vivify_1777:
    get_who $P3070, $P3069
    set $P3071, $P3070[$P3068]
    unless_null $P3071, vivify_1778
    new $P3071, "Undef"
  vivify_1778:
    store_lex "$result", $P3071
.annotate 'line', 2221
    set $P3061, $P3071
  if_3062_end:
.annotate 'line', 2220
    .return ($P3061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("609_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3091
    .param pmc param_3092
.annotate 'line', 802
    .lex "self", param_3091
    .lex "$/", param_3092
    find_lex $P3093, "$/"
    find_lex $P3094, "$/"
    unless_null $P3094, vivify_1780
    $P3094 = root_new ['parrot';'Hash']
  vivify_1780:
    set $P3095, $P3094["comp_unit"]
    unless_null $P3095, vivify_1781
    new $P3095, "Undef"
  vivify_1781:
    $P3096 = $P3095."ast"()
    $P3097 = $P3093."!make"($P3096)
    .return ($P3097)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("610_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3099
    .param pmc param_3100
.annotate 'line', 804
    .lex "self", param_3099
    .lex "$/", param_3100
.annotate 'line', 805
    find_lex $P3101, "$/"
.annotate 'line', 806
    find_lex $P3104, "$/"
    unless_null $P3104, vivify_1782
    $P3104 = root_new ['parrot';'Hash']
  vivify_1782:
    set $P3105, $P3104["colonpair"]
    unless_null $P3105, vivify_1783
    new $P3105, "Undef"
  vivify_1783:
    if $P3105, if_3103
.annotate 'line', 808
    find_lex $P3125, "$/"
    unless_null $P3125, vivify_1784
    new $P3125, "Undef"
  vivify_1784:
    set $S3126, $P3125
    new $P3102, 'String'
    set $P3102, $S3126
.annotate 'line', 806
    goto if_3103_end
  if_3103:
    find_lex $P3106, "$/"
    unless_null $P3106, vivify_1785
    $P3106 = root_new ['parrot';'Hash']
  vivify_1785:
    set $P3107, $P3106["identifier"]
    unless_null $P3107, vivify_1786
    new $P3107, "Undef"
  vivify_1786:
    set $S3108, $P3107
    new $P3109, 'String'
    set $P3109, $S3108
    concat $P3110, $P3109, ":"
    find_lex $P3111, "$/"
    unless_null $P3111, vivify_1787
    $P3111 = root_new ['parrot';'Hash']
  vivify_1787:
    set $P3112, $P3111["colonpair"]
    unless_null $P3112, vivify_1788
    $P3112 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    set $P3113, $P3112[0]
    unless_null $P3113, vivify_1789
    new $P3113, "Undef"
  vivify_1789:
    $P3114 = $P3113."ast"()
    $S3115 = $P3114."named"()
    concat $P3116, $P3110, $S3115
    concat $P3117, $P3116, "<"
.annotate 'line', 807
    find_lex $P3118, "$/"
    unless_null $P3118, vivify_1790
    $P3118 = root_new ['parrot';'Hash']
  vivify_1790:
    set $P3119, $P3118["colonpair"]
    unless_null $P3119, vivify_1791
    $P3119 = root_new ['parrot';'ResizablePMCArray']
  vivify_1791:
    set $P3120, $P3119[0]
    unless_null $P3120, vivify_1792
    new $P3120, "Undef"
  vivify_1792:
    $P3121 = $P3120."ast"()
    $S3122 = "colonpair_str"($P3121)
    concat $P3123, $P3117, $S3122
    concat $P3124, $P3123, ">"
    set $P3102, $P3124
  if_3103_end:
.annotate 'line', 806
    $P3127 = $P3101."!make"($P3102)
.annotate 'line', 804
    .return ($P3127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("611_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3130
    .param pmc param_3131
.annotate 'line', 818
    .lex "self", param_3130
    .lex "$/", param_3131
.annotate 'line', 819
    new $P3132, "Undef"
    .lex "$mainline", $P3132
.annotate 'line', 820
    new $P3133, "Undef"
    .lex "$unit", $P3133
.annotate 'line', 819
    find_lex $P3134, "$/"
    unless_null $P3134, vivify_1793
    $P3134 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3135, $P3134["statementlist"]
    unless_null $P3135, vivify_1794
    new $P3135, "Undef"
  vivify_1794:
    $P3136 = $P3135."ast"()
    store_lex "$mainline", $P3136
.annotate 'line', 820
    find_lex $P3137, "$?PACKAGE"
    get_who $P3138, $P3137
    set $P3139, $P3138["@BLOCK"]
    unless_null $P3139, vivify_1795
    $P3139 = root_new ['parrot';'ResizablePMCArray']
  vivify_1795:
    $P3140 = $P3139."shift"()
    store_lex "$unit", $P3140
.annotate 'line', 824
    find_lex $P3141, "$unit"
    unless_null $P3141, vivify_1796
    new $P3141, "Undef"
  vivify_1796:
    $P3142 = $P3141."loadinit"()
    find_dynamic_lex $P3145, "$*SC"
    unless_null $P3145, vivify_1797
    get_hll_global $P3143, "GLOBAL"
    get_who $P3144, $P3143
    set $P3145, $P3144["$SC"]
    unless_null $P3145, vivify_1798
    die "Contextual $*SC not found"
  vivify_1798:
  vivify_1797:
    $P3146 = $P3145."to_past"()
    $P3142."push"($P3146)
.annotate 'line', 829
    find_lex $P3147, "$unit"
    unless_null $P3147, vivify_1799
    new $P3147, "Undef"
  vivify_1799:
    $P3148 = $P3147."loadinit"()
    get_hll_global $P3149, "GLOBAL"
    nqp_get_package_through_who $P3150, $P3149, "PAST"
    get_who $P3151, $P3150
    set $P3152, $P3151["Op"]
.annotate 'line', 831
    get_hll_global $P3153, "GLOBAL"
    nqp_get_package_through_who $P3154, $P3153, "PAST"
    get_who $P3155, $P3154
    set $P3156, $P3155["Var"]
    new $P3157, "ResizablePMCArray"
    $P3158 = $P3156."new"("GLOBAL" :named("name"), $P3157 :named("namespace"), "package" :named("scope"))
.annotate 'line', 832
    find_dynamic_lex $P3161, "$*SC"
    unless_null $P3161, vivify_1800
    get_hll_global $P3159, "GLOBAL"
    get_who $P3160, $P3159
    set $P3161, $P3160["$SC"]
    unless_null $P3161, vivify_1801
    die "Contextual $*SC not found"
  vivify_1801:
  vivify_1800:
    find_dynamic_lex $P3164, "$*PACKAGE"
    unless_null $P3164, vivify_1802
    get_hll_global $P3162, "GLOBAL"
    get_who $P3163, $P3162
    set $P3164, $P3163["$PACKAGE"]
    unless_null $P3164, vivify_1803
    die "Contextual $*PACKAGE not found"
  vivify_1803:
  vivify_1802:
    $P3165 = $P3161."get_slot_past_for_object"($P3164)
    $P3166 = $P3152."new"($P3158, $P3165, "bind" :named("pasttype"))
.annotate 'line', 829
    $P3148."push"($P3166)
.annotate 'line', 838
    find_dynamic_lex $P3170, "$*HAS_YOU_ARE_HERE"
    unless_null $P3170, vivify_1804
    get_hll_global $P3168, "GLOBAL"
    get_who $P3169, $P3168
    set $P3170, $P3169["$HAS_YOU_ARE_HERE"]
    unless_null $P3170, vivify_1805
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1805:
  vivify_1804:
    if $P3170, unless_3167_end
.annotate 'line', 839
    find_lex $P3171, "$unit"
    unless_null $P3171, vivify_1806
    new $P3171, "Undef"
  vivify_1806:
    find_lex $P3172, "self"
    $P3173 = $P3172."CTXSAVE"()
    $P3171."push"($P3173)
  unless_3167_end:
.annotate 'line', 843
    find_lex $P3174, "$unit"
    unless_null $P3174, vivify_1807
    new $P3174, "Undef"
  vivify_1807:
    $P3174."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 847
    find_dynamic_lex $P3178, "$*MAIN_SUB"
    unless_null $P3178, vivify_1808
    get_hll_global $P3176, "GLOBAL"
    get_who $P3177, $P3176
    set $P3178, $P3177["$MAIN_SUB"]
    unless_null $P3178, vivify_1809
    die "Contextual $*MAIN_SUB not found"
  vivify_1809:
  vivify_1808:
    unless $P3178, if_3175_end
.annotate 'line', 848
    find_lex $P3179, "$unit"
    unless_null $P3179, vivify_1810
    new $P3179, "Undef"
  vivify_1810:
    get_hll_global $P3180, "GLOBAL"
    nqp_get_package_through_who $P3181, $P3180, "PAST"
    get_who $P3182, $P3181
    set $P3183, $P3182["Var"]
    $P3184 = $P3183."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3179."unshift"($P3184)
.annotate 'line', 849
    find_lex $P3185, "$mainline"
    unless_null $P3185, vivify_1811
    new $P3185, "Undef"
  vivify_1811:
    get_hll_global $P3186, "GLOBAL"
    nqp_get_package_through_who $P3187, $P3186, "PAST"
    get_who $P3188, $P3187
    set $P3189, $P3188["Op"]
.annotate 'line', 851
    get_hll_global $P3190, "GLOBAL"
    nqp_get_package_through_who $P3191, $P3190, "PAST"
    get_who $P3192, $P3191
    set $P3193, $P3192["Var"]
    $P3194 = $P3193."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 852
    get_hll_global $P3195, "GLOBAL"
    nqp_get_package_through_who $P3196, $P3195, "PAST"
    get_who $P3197, $P3196
    set $P3198, $P3197["Op"]
.annotate 'line', 853
    get_hll_global $P3199, "GLOBAL"
    nqp_get_package_through_who $P3200, $P3199, "PAST"
    get_who $P3201, $P3200
    set $P3202, $P3201["Val"]
    find_dynamic_lex $P3205, "$*MAIN_SUB"
    unless_null $P3205, vivify_1812
    get_hll_global $P3203, "GLOBAL"
    get_who $P3204, $P3203
    set $P3205, $P3204["$MAIN_SUB"]
    unless_null $P3205, vivify_1813
    die "Contextual $*MAIN_SUB not found"
  vivify_1813:
  vivify_1812:
    $P3206 = $P3202."new"($P3205 :named("value"))
.annotate 'line', 854
    get_hll_global $P3207, "GLOBAL"
    nqp_get_package_through_who $P3208, $P3207, "PAST"
    get_who $P3209, $P3208
    set $P3210, $P3209["Var"]
    $P3211 = $P3210."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3212 = $P3198."new"($P3206, $P3211, "call" :named("pasttype"))
.annotate 'line', 852
    $P3213 = $P3189."new"($P3194, $P3212, "if" :named("pasttype"))
.annotate 'line', 849
    $P3185."push"($P3213)
  if_3175_end:
.annotate 'line', 862
    find_lex $P3214, "$unit"
    unless_null $P3214, vivify_1814
    new $P3214, "Undef"
  vivify_1814:
.annotate 'line', 863
    get_hll_global $P3215, "GLOBAL"
    nqp_get_package_through_who $P3216, $P3215, "PAST"
    get_who $P3217, $P3216
    set $P3218, $P3217["Op"]
    find_lex $P3219, "$mainline"
    unless_null $P3219, vivify_1815
    new $P3219, "Undef"
  vivify_1815:
    $P3220 = $P3218."new"($P3219, "return" :named("pirop"))
    $P3214."push"($P3220)
.annotate 'line', 868
    find_lex $P3221, "$unit"
    unless_null $P3221, vivify_1816
    new $P3221, "Undef"
  vivify_1816:
.annotate 'line', 869
    get_hll_global $P3222, "GLOBAL"
    nqp_get_package_through_who $P3223, $P3222, "PAST"
    get_who $P3224, $P3223
    set $P3225, $P3224["Block"]
.annotate 'line', 871
    get_hll_global $P3226, "GLOBAL"
    nqp_get_package_through_who $P3227, $P3226, "PAST"
    get_who $P3228, $P3227
    set $P3229, $P3228["Op"]
    get_hll_global $P3230, "GLOBAL"
    nqp_get_package_through_who $P3231, $P3230, "PAST"
    get_who $P3232, $P3231
    set $P3233, $P3232["Val"]
    find_lex $P3234, "$unit"
    unless_null $P3234, vivify_1817
    new $P3234, "Undef"
  vivify_1817:
    $P3235 = $P3233."new"($P3234 :named("value"))
    $P3236 = $P3229."new"($P3235, "call" :named("pasttype"))
    $P3237 = $P3225."new"($P3236, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 869
    $P3221."push"($P3237)
.annotate 'line', 874
    find_lex $P3238, "$unit"
    unless_null $P3238, vivify_1818
    new $P3238, "Undef"
  vivify_1818:
    find_lex $P3239, "$/"
    unless_null $P3239, vivify_1819
    new $P3239, "Undef"
  vivify_1819:
    $P3238."node"($P3239)
.annotate 'line', 877
    find_lex $P3240, "$unit"
    unless_null $P3240, vivify_1820
    new $P3240, "Undef"
  vivify_1820:
    $P3240."hll"("nqp")
.annotate 'line', 879
    find_lex $P3241, "$/"
    find_lex $P3242, "$unit"
    unless_null $P3242, vivify_1821
    new $P3242, "Undef"
  vivify_1821:
    $P3243 = $P3241."!make"($P3242)
.annotate 'line', 818
    .return ($P3243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("612_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3245
    .param pmc param_3246
.annotate 'line', 882
    .const 'Sub' $P3263 = "613_1304282286.73" 
    capture_lex $P3263
    .lex "self", param_3245
    .lex "$/", param_3246
.annotate 'line', 883
    new $P3247, "Undef"
    .lex "$past", $P3247
    get_hll_global $P3248, "GLOBAL"
    nqp_get_package_through_who $P3249, $P3248, "PAST"
    get_who $P3250, $P3249
    set $P3251, $P3250["Stmts"]
    find_lex $P3252, "$/"
    unless_null $P3252, vivify_1822
    new $P3252, "Undef"
  vivify_1822:
    $P3253 = $P3251."new"($P3252 :named("node"))
    store_lex "$past", $P3253
.annotate 'line', 884
    find_lex $P3255, "$/"
    unless_null $P3255, vivify_1823
    $P3255 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P3256, $P3255["statement"]
    unless_null $P3256, vivify_1824
    new $P3256, "Undef"
  vivify_1824:
    unless $P3256, if_3254_end
.annotate 'line', 885
    find_lex $P3258, "$/"
    unless_null $P3258, vivify_1825
    $P3258 = root_new ['parrot';'Hash']
  vivify_1825:
    set $P3259, $P3258["statement"]
    unless_null $P3259, vivify_1826
    new $P3259, "Undef"
  vivify_1826:
    defined $I3260, $P3259
    unless $I3260, for_undef_1827
    iter $P3257, $P3259
    new $P3283, 'ExceptionHandler'
    set_label $P3283, loop3282_handler
    $P3283."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3283
  loop3282_test:
    unless $P3257, loop3282_done
    shift $P3261, $P3257
  loop3282_redo:
    .const 'Sub' $P3263 = "613_1304282286.73" 
    capture_lex $P3263
    $P3263($P3261)
  loop3282_next:
    goto loop3282_test
  loop3282_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3284, exception, 'type'
    eq $P3284, .CONTROL_LOOP_NEXT, loop3282_next
    eq $P3284, .CONTROL_LOOP_REDO, loop3282_redo
  loop3282_done:
    pop_eh 
  for_undef_1827:
  if_3254_end:
.annotate 'line', 892
    find_lex $P3285, "$/"
    find_lex $P3286, "$past"
    unless_null $P3286, vivify_1838
    new $P3286, "Undef"
  vivify_1838:
    $P3287 = $P3285."!make"($P3286)
.annotate 'line', 882
    .return ($P3287)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3262"  :anon :subid("613_1304282286.73") :outer("612_1304282286.73")
    .param pmc param_3265
.annotate 'line', 886
    new $P3264, "Undef"
    .lex "$ast", $P3264
    .lex "$_", param_3265
    find_lex $P3266, "$_"
    unless_null $P3266, vivify_1828
    new $P3266, "Undef"
  vivify_1828:
    $P3267 = $P3266."ast"()
    store_lex "$ast", $P3267
.annotate 'line', 887
    find_lex $P3269, "$ast"
    unless_null $P3269, vivify_1829
    $P3269 = root_new ['parrot';'Hash']
  vivify_1829:
    set $P3270, $P3269["sink"]
    unless_null $P3270, vivify_1830
    new $P3270, "Undef"
  vivify_1830:
    defined $I3271, $P3270
    unless $I3271, if_3268_end
    find_lex $P3272, "$ast"
    unless_null $P3272, vivify_1831
    $P3272 = root_new ['parrot';'Hash']
  vivify_1831:
    set $P3273, $P3272["sink"]
    unless_null $P3273, vivify_1832
    new $P3273, "Undef"
  vivify_1832:
    store_lex "$ast", $P3273
  if_3268_end:
.annotate 'line', 888
    find_lex $P3275, "$ast"
    unless_null $P3275, vivify_1833
    $P3275 = root_new ['parrot';'Hash']
  vivify_1833:
    set $P3276, $P3275["bareblock"]
    unless_null $P3276, vivify_1834
    new $P3276, "Undef"
  vivify_1834:
    unless $P3276, if_3274_end
    find_lex $P3277, "$ast"
    unless_null $P3277, vivify_1835
    new $P3277, "Undef"
  vivify_1835:
    $P3278 = "block_immediate"($P3277)
    store_lex "$ast", $P3278
  if_3274_end:
.annotate 'line', 889
    find_lex $P3279, "$past"
    unless_null $P3279, vivify_1836
    new $P3279, "Undef"
  vivify_1836:
    find_lex $P3280, "$ast"
    unless_null $P3280, vivify_1837
    new $P3280, "Undef"
  vivify_1837:
    $P3281 = $P3279."push"($P3280)
.annotate 'line', 885
    .return ($P3281)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("614_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3289
    .param pmc param_3290
    .param pmc param_3291 :optional
    .param int has_param_3291 :opt_flag
.annotate 'line', 895
    .const 'Sub' $P3299 = "615_1304282286.73" 
    capture_lex $P3299
    .lex "self", param_3289
    .lex "$/", param_3290
    if has_param_3291, optparam_1839
    new $P3292, "Undef"
    set param_3291, $P3292
  optparam_1839:
    .lex "$key", param_3291
.annotate 'line', 896
    new $P3293, "Undef"
    .lex "$past", $P3293
.annotate 'line', 895
    find_lex $P3294, "$past"
    unless_null $P3294, vivify_1840
    new $P3294, "Undef"
  vivify_1840:
.annotate 'line', 897
    find_lex $P3296, "$/"
    unless_null $P3296, vivify_1841
    $P3296 = root_new ['parrot';'Hash']
  vivify_1841:
    set $P3297, $P3296["EXPR"]
    unless_null $P3297, vivify_1842
    new $P3297, "Undef"
  vivify_1842:
    if $P3297, if_3295
.annotate 'line', 918
    find_lex $P3375, "$/"
    unless_null $P3375, vivify_1843
    $P3375 = root_new ['parrot';'Hash']
  vivify_1843:
    set $P3376, $P3375["statement_control"]
    unless_null $P3376, vivify_1844
    new $P3376, "Undef"
  vivify_1844:
    if $P3376, if_3374
.annotate 'line', 919
    new $P3380, "Integer"
    assign $P3380, 0
    store_lex "$past", $P3380
    goto if_3374_end
  if_3374:
.annotate 'line', 918
    find_lex $P3377, "$/"
    unless_null $P3377, vivify_1845
    $P3377 = root_new ['parrot';'Hash']
  vivify_1845:
    set $P3378, $P3377["statement_control"]
    unless_null $P3378, vivify_1846
    new $P3378, "Undef"
  vivify_1846:
    $P3379 = $P3378."ast"()
    store_lex "$past", $P3379
  if_3374_end:
    goto if_3295_end
  if_3295:
.annotate 'line', 897
    .const 'Sub' $P3299 = "615_1304282286.73" 
    capture_lex $P3299
    $P3299()
  if_3295_end:
.annotate 'line', 920
    find_lex $P3381, "$/"
    find_lex $P3382, "$past"
    unless_null $P3382, vivify_1880
    new $P3382, "Undef"
  vivify_1880:
    $P3383 = $P3381."!make"($P3382)
.annotate 'line', 895
    .return ($P3383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3298"  :anon :subid("615_1304282286.73") :outer("614_1304282286.73")
.annotate 'line', 898
    new $P3300, "Undef"
    .lex "$mc", $P3300
.annotate 'line', 899
    new $P3301, "Undef"
    .lex "$ml", $P3301
.annotate 'line', 898
    find_lex $P3302, "$/"
    unless_null $P3302, vivify_1847
    $P3302 = root_new ['parrot';'Hash']
  vivify_1847:
    set $P3303, $P3302["statement_mod_cond"]
    unless_null $P3303, vivify_1848
    $P3303 = root_new ['parrot';'ResizablePMCArray']
  vivify_1848:
    set $P3304, $P3303[0]
    unless_null $P3304, vivify_1849
    new $P3304, "Undef"
  vivify_1849:
    store_lex "$mc", $P3304
.annotate 'line', 899
    find_lex $P3305, "$/"
    unless_null $P3305, vivify_1850
    $P3305 = root_new ['parrot';'Hash']
  vivify_1850:
    set $P3306, $P3305["statement_mod_loop"]
    unless_null $P3306, vivify_1851
    $P3306 = root_new ['parrot';'ResizablePMCArray']
  vivify_1851:
    set $P3307, $P3306[0]
    unless_null $P3307, vivify_1852
    new $P3307, "Undef"
  vivify_1852:
    store_lex "$ml", $P3307
.annotate 'line', 900
    find_lex $P3308, "$/"
    unless_null $P3308, vivify_1853
    $P3308 = root_new ['parrot';'Hash']
  vivify_1853:
    set $P3309, $P3308["EXPR"]
    unless_null $P3309, vivify_1854
    new $P3309, "Undef"
  vivify_1854:
    $P3310 = $P3309."ast"()
    store_lex "$past", $P3310
.annotate 'line', 901
    find_lex $P3312, "$mc"
    unless_null $P3312, vivify_1855
    new $P3312, "Undef"
  vivify_1855:
    unless $P3312, if_3311_end
.annotate 'line', 902
    get_hll_global $P3313, "GLOBAL"
    nqp_get_package_through_who $P3314, $P3313, "PAST"
    get_who $P3315, $P3314
    set $P3316, $P3315["Op"]
    find_lex $P3317, "$mc"
    unless_null $P3317, vivify_1856
    $P3317 = root_new ['parrot';'Hash']
  vivify_1856:
    set $P3318, $P3317["cond"]
    unless_null $P3318, vivify_1857
    new $P3318, "Undef"
  vivify_1857:
    $P3319 = $P3318."ast"()
    find_lex $P3320, "$past"
    unless_null $P3320, vivify_1858
    new $P3320, "Undef"
  vivify_1858:
    find_lex $P3321, "$mc"
    unless_null $P3321, vivify_1859
    $P3321 = root_new ['parrot';'Hash']
  vivify_1859:
    set $P3322, $P3321["sym"]
    unless_null $P3322, vivify_1860
    new $P3322, "Undef"
  vivify_1860:
    set $S3323, $P3322
    find_lex $P3324, "$/"
    unless_null $P3324, vivify_1861
    new $P3324, "Undef"
  vivify_1861:
    $P3325 = $P3316."new"($P3319, $P3320, $S3323 :named("pasttype"), $P3324 :named("node"))
    store_lex "$past", $P3325
  if_3311_end:
.annotate 'line', 904
    find_lex $P3328, "$ml"
    unless_null $P3328, vivify_1862
    new $P3328, "Undef"
  vivify_1862:
    if $P3328, if_3327
    set $P3326, $P3328
    goto if_3327_end
  if_3327:
.annotate 'line', 905
    find_lex $P3331, "$ml"
    unless_null $P3331, vivify_1863
    $P3331 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3332, $P3331["sym"]
    unless_null $P3332, vivify_1864
    new $P3332, "Undef"
  vivify_1864:
    set $S3333, $P3332
    iseq $I3334, $S3333, "for"
    if $I3334, if_3330
.annotate 'line', 914
    get_hll_global $P3361, "GLOBAL"
    nqp_get_package_through_who $P3362, $P3361, "PAST"
    get_who $P3363, $P3362
    set $P3364, $P3363["Op"]
    find_lex $P3365, "$ml"
    unless_null $P3365, vivify_1865
    $P3365 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3366, $P3365["cond"]
    unless_null $P3366, vivify_1866
    new $P3366, "Undef"
  vivify_1866:
    $P3367 = $P3366."ast"()
    find_lex $P3368, "$past"
    unless_null $P3368, vivify_1867
    new $P3368, "Undef"
  vivify_1867:
    find_lex $P3369, "$ml"
    unless_null $P3369, vivify_1868
    $P3369 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P3370, $P3369["sym"]
    unless_null $P3370, vivify_1869
    new $P3370, "Undef"
  vivify_1869:
    set $S3371, $P3370
    find_lex $P3372, "$/"
    unless_null $P3372, vivify_1870
    new $P3372, "Undef"
  vivify_1870:
    $P3373 = $P3364."new"($P3367, $P3368, $S3371 :named("pasttype"), $P3372 :named("node"))
    store_lex "$past", $P3373
.annotate 'line', 913
    set $P3329, $P3373
.annotate 'line', 905
    goto if_3330_end
  if_3330:
.annotate 'line', 906
    get_hll_global $P3335, "GLOBAL"
    nqp_get_package_through_who $P3336, $P3335, "PAST"
    get_who $P3337, $P3336
    set $P3338, $P3337["Block"]
.annotate 'line', 907
    get_hll_global $P3339, "GLOBAL"
    nqp_get_package_through_who $P3340, $P3339, "PAST"
    get_who $P3341, $P3340
    set $P3342, $P3341["Var"]
    $P3343 = $P3342."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3344, "$past"
    unless_null $P3344, vivify_1871
    new $P3344, "Undef"
  vivify_1871:
    $P3345 = $P3338."new"($P3343, $P3344, "immediate" :named("blocktype"))
.annotate 'line', 906
    store_lex "$past", $P3345
.annotate 'line', 909
    find_lex $P3346, "$past"
    unless_null $P3346, vivify_1872
    new $P3346, "Undef"
  vivify_1872:
    $P3346."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 910
    find_lex $P3347, "$past"
    unless_null $P3347, vivify_1873
    new $P3347, "Undef"
  vivify_1873:
    $P3347."arity"(1)
.annotate 'line', 911
    get_hll_global $P3348, "GLOBAL"
    nqp_get_package_through_who $P3349, $P3348, "PAST"
    get_who $P3350, $P3349
    set $P3351, $P3350["Op"]
    find_lex $P3352, "$ml"
    unless_null $P3352, vivify_1874
    $P3352 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P3353, $P3352["cond"]
    unless_null $P3353, vivify_1875
    new $P3353, "Undef"
  vivify_1875:
    $P3354 = $P3353."ast"()
    find_lex $P3355, "$past"
    unless_null $P3355, vivify_1876
    new $P3355, "Undef"
  vivify_1876:
    find_lex $P3356, "$ml"
    unless_null $P3356, vivify_1877
    $P3356 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P3357, $P3356["sym"]
    unless_null $P3357, vivify_1878
    new $P3357, "Undef"
  vivify_1878:
    set $S3358, $P3357
    find_lex $P3359, "$/"
    unless_null $P3359, vivify_1879
    new $P3359, "Undef"
  vivify_1879:
    $P3360 = $P3351."new"($P3354, $P3355, $S3358 :named("pasttype"), $P3359 :named("node"))
    store_lex "$past", $P3360
.annotate 'line', 905
    set $P3329, $P3360
  if_3330_end:
.annotate 'line', 904
    set $P3326, $P3329
  if_3327_end:
.annotate 'line', 897
    .return ($P3326)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("616_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3385
    .param pmc param_3386
.annotate 'line', 923
    .lex "self", param_3385
    .lex "$/", param_3386
.annotate 'line', 924
    find_lex $P3387, "$/"
    get_hll_global $P3388, "GLOBAL"
    nqp_get_package_through_who $P3389, $P3388, "PAST"
    get_who $P3390, $P3389
    set $P3391, $P3390["Op"]
    find_lex $P3392, "$/"
    unless_null $P3392, vivify_1881
    $P3392 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P3393, $P3392["EXPR"]
    unless_null $P3393, vivify_1882
    new $P3393, "Undef"
  vivify_1882:
    $P3394 = $P3393."ast"()
    find_lex $P3395, "$/"
    unless_null $P3395, vivify_1883
    $P3395 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P3396, $P3395["pblock"]
    unless_null $P3396, vivify_1884
    new $P3396, "Undef"
  vivify_1884:
    $P3397 = $P3396."ast"()
    find_lex $P3398, "$/"
    unless_null $P3398, vivify_1885
    new $P3398, "Undef"
  vivify_1885:
    $P3399 = $P3391."new"($P3394, $P3397, "if" :named("pasttype"), $P3398 :named("node"))
    $P3400 = $P3387."!make"($P3399)
.annotate 'line', 923
    .return ($P3400)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("617_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3402
    .param pmc param_3403
.annotate 'line', 927
    .lex "self", param_3402
    .lex "$/", param_3403
.annotate 'line', 928
    find_lex $P3404, "$/"
    find_lex $P3405, "$/"
    unless_null $P3405, vivify_1886
    $P3405 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P3406, $P3405["blockoid"]
    unless_null $P3406, vivify_1887
    new $P3406, "Undef"
  vivify_1887:
    $P3407 = $P3406."ast"()
    $P3408 = $P3404."!make"($P3407)
.annotate 'line', 927
    .return ($P3408)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("618_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3410
    .param pmc param_3411
.annotate 'line', 931
    .lex "self", param_3410
    .lex "$/", param_3411
.annotate 'line', 932
    find_lex $P3412, "$/"
    find_lex $P3413, "$/"
    unless_null $P3413, vivify_1888
    $P3413 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P3414, $P3413["blockoid"]
    unless_null $P3414, vivify_1889
    new $P3414, "Undef"
  vivify_1889:
    $P3415 = $P3414."ast"()
    $P3416 = $P3412."!make"($P3415)
.annotate 'line', 931
    .return ($P3416)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("619_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3418
    .param pmc param_3419
.annotate 'line', 935
    .const 'Sub' $P3430 = "620_1304282286.73" 
    capture_lex $P3430
    .lex "self", param_3418
    .lex "$/", param_3419
.annotate 'line', 936
    new $P3420, "Undef"
    .lex "$BLOCK", $P3420
    find_lex $P3421, "$?PACKAGE"
    get_who $P3422, $P3421
    set $P3423, $P3422["@BLOCK"]
    unless_null $P3423, vivify_1890
    $P3423 = root_new ['parrot';'ResizablePMCArray']
  vivify_1890:
    $P3424 = $P3423."shift"()
    store_lex "$BLOCK", $P3424
.annotate 'line', 937
    find_lex $P3427, "$/"
    unless_null $P3427, vivify_1891
    $P3427 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P3428, $P3427["statementlist"]
    unless_null $P3428, vivify_1892
    new $P3428, "Undef"
  vivify_1892:
    if $P3428, if_3426
.annotate 'line', 945
    find_dynamic_lex $P3447, "$*HAS_YOU_ARE_HERE"
    unless_null $P3447, vivify_1893
    get_hll_global $P3445, "GLOBAL"
    get_who $P3446, $P3445
    set $P3447, $P3446["$HAS_YOU_ARE_HERE"]
    unless_null $P3447, vivify_1894
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1894:
  vivify_1893:
    unless $P3447, if_3444_end
.annotate 'line', 946
    find_lex $P3448, "$/"
    unless_null $P3448, vivify_1895
    new $P3448, "Undef"
  vivify_1895:
    $P3449 = $P3448."CURSOR"()
    $P3449."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3444_end:
.annotate 'line', 948
    new $P3450, "Integer"
    assign $P3450, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3450
.annotate 'line', 949
    find_lex $P3451, "$/"
    find_lex $P3452, "$/"
    unless_null $P3452, vivify_1896
    $P3452 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P3453, $P3452["you_are_here"]
    unless_null $P3453, vivify_1897
    new $P3453, "Undef"
  vivify_1897:
    $P3454 = $P3453."ast"()
    $P3455 = $P3451."!make"($P3454)
.annotate 'line', 944
    set $P3425, $P3455
.annotate 'line', 937
    goto if_3426_end
  if_3426:
    .const 'Sub' $P3430 = "620_1304282286.73" 
    capture_lex $P3430
    $P3443 = $P3430()
    set $P3425, $P3443
  if_3426_end:
.annotate 'line', 935
    .return ($P3425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3429"  :anon :subid("620_1304282286.73") :outer("619_1304282286.73")
.annotate 'line', 938
    new $P3431, "Undef"
    .lex "$past", $P3431
    find_lex $P3432, "$/"
    unless_null $P3432, vivify_1898
    $P3432 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P3433, $P3432["statementlist"]
    unless_null $P3433, vivify_1899
    new $P3433, "Undef"
  vivify_1899:
    $P3434 = $P3433."ast"()
    store_lex "$past", $P3434
.annotate 'line', 939
    find_lex $P3435, "$BLOCK"
    unless_null $P3435, vivify_1900
    new $P3435, "Undef"
  vivify_1900:
    find_lex $P3436, "$past"
    unless_null $P3436, vivify_1901
    new $P3436, "Undef"
  vivify_1901:
    $P3435."push"($P3436)
.annotate 'line', 940
    find_lex $P3437, "$BLOCK"
    unless_null $P3437, vivify_1902
    new $P3437, "Undef"
  vivify_1902:
    find_lex $P3438, "$/"
    unless_null $P3438, vivify_1903
    new $P3438, "Undef"
  vivify_1903:
    $P3437."node"($P3438)
.annotate 'line', 941
    find_lex $P3439, "$BLOCK"
    unless_null $P3439, vivify_1904
    new $P3439, "Undef"
  vivify_1904:
    $P3439."closure"(1)
.annotate 'line', 942
    find_dynamic_lex $P3440, "$/"
    find_lex $P3441, "$BLOCK"
    unless_null $P3441, vivify_1905
    new $P3441, "Undef"
  vivify_1905:
    $P3442 = $P3440."!make"($P3441)
.annotate 'line', 937
    .return ($P3442)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("621_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3457
    .param pmc param_3458
.annotate 'line', 953
    .lex "self", param_3457
    .lex "$/", param_3458
.annotate 'line', 954
    find_lex $P3459, "$?PACKAGE"
    get_who $P3460, $P3459
    set $P3461, $P3460["@BLOCK"]
    unless_null $P3461, vivify_1906
    $P3461 = root_new ['parrot';'ResizablePMCArray']
  vivify_1906:
    get_hll_global $P3462, "GLOBAL"
    nqp_get_package_through_who $P3463, $P3462, "PAST"
    get_who $P3464, $P3463
    set $P3465, $P3464["Block"]
    get_hll_global $P3466, "GLOBAL"
    nqp_get_package_through_who $P3467, $P3466, "PAST"
    get_who $P3468, $P3467
    set $P3469, $P3468["Stmts"]
    $P3470 = $P3469."new"()
    $P3471 = $P3465."new"($P3470)
    $P3472 = $P3461."unshift"($P3471)
.annotate 'line', 953
    .return ($P3472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("622_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3474
    .param pmc param_3475
.annotate 'line', 957
    .const 'Sub' $P3484 = "623_1304282286.73" 
    capture_lex $P3484
    .lex "self", param_3474
    .lex "$/", param_3475
.annotate 'line', 958
    find_dynamic_lex $P3479, "%*COMPILING"
    unless_null $P3479, vivify_1907
    get_hll_global $P3477, "GLOBAL"
    get_who $P3478, $P3477
    set $P3479, $P3478["%COMPILING"]
    unless_null $P3479, vivify_1908
    die "Contextual %*COMPILING not found"
  vivify_1908:
  vivify_1907:
    set $P3480, $P3479["%?OPTIONS"]
    unless_null $P3480, vivify_1909
    $P3480 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P3481, $P3480["outer_ctx"]
    unless_null $P3481, vivify_1910
    new $P3481, "Undef"
  vivify_1910:
    defined $I3482, $P3481
    if $I3482, unless_3476_end
    .const 'Sub' $P3484 = "623_1304282286.73" 
    capture_lex $P3484
    $P3484()
  unless_3476_end:
.annotate 'line', 971
    find_lex $P3516, "self"
    find_lex $P3517, "$?PACKAGE"
    get_who $P3518, $P3517
    set $P3519, $P3518["@BLOCK"]
    unless_null $P3519, vivify_1926
    $P3519 = root_new ['parrot';'ResizablePMCArray']
  vivify_1926:
    set $P3520, $P3519[0]
    unless_null $P3520, vivify_1927
    new $P3520, "Undef"
  vivify_1927:
    $P3521 = $P3516."SET_BLOCK_OUTER_CTX"($P3520)
.annotate 'line', 957
    .return ($P3521)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3483"  :anon :subid("623_1304282286.73") :outer("622_1304282286.73")
.annotate 'line', 961
    new $P3485, "Undef"
    .lex "$SETTING", $P3485
    find_dynamic_lex $P3488, "$*SC"
    unless_null $P3488, vivify_1911
    get_hll_global $P3486, "GLOBAL"
    get_who $P3487, $P3486
    set $P3488, $P3487["$SC"]
    unless_null $P3488, vivify_1912
    die "Contextual $*SC not found"
  vivify_1912:
  vivify_1911:
    find_dynamic_lex $P3492, "%*COMPILING"
    unless_null $P3492, vivify_1913
    get_hll_global $P3490, "GLOBAL"
    get_who $P3491, $P3490
    set $P3492, $P3491["%COMPILING"]
    unless_null $P3492, vivify_1914
    die "Contextual %*COMPILING not found"
  vivify_1914:
  vivify_1913:
    set $P3493, $P3492["%?OPTIONS"]
    unless_null $P3493, vivify_1915
    $P3493 = root_new ['parrot';'Hash']
  vivify_1915:
    set $P3494, $P3493["setting"]
    unless_null $P3494, vivify_1916
    new $P3494, "Undef"
  vivify_1916:
    set $P3489, $P3494
    defined $I3496, $P3489
    if $I3496, default_3495
    new $P3497, "String"
    assign $P3497, "NQPCORE"
    set $P3489, $P3497
  default_3495:
    $P3498 = $P3488."load_setting"($P3489)
    store_lex "$SETTING", $P3498
.annotate 'line', 966
    find_dynamic_lex $P3503, "%*COMPILING"
    unless_null $P3503, vivify_1917
    get_hll_global $P3501, "GLOBAL"
    get_who $P3502, $P3501
    set $P3503, $P3502["%COMPILING"]
    unless_null $P3503, vivify_1918
    die "Contextual %*COMPILING not found"
  vivify_1918:
  vivify_1917:
    set $P3504, $P3503["%?OPTIONS"]
    unless_null $P3504, vivify_1919
    $P3504 = root_new ['parrot';'Hash']
  vivify_1919:
    set $P3505, $P3504["setting"]
    unless_null $P3505, vivify_1920
    new $P3505, "Undef"
  vivify_1920:
    set $S3506, $P3505
    iseq $I3507, $S3506, "NULL"
    unless $I3507, unless_3500
    new $P3499, 'Integer'
    set $P3499, $I3507
    goto unless_3500_end
  unless_3500:
.annotate 'line', 967
    find_lex $P3508, "$SETTING"
    unless_null $P3508, vivify_1921
    new $P3508, "Undef"
  vivify_1921:
    "import_HOW_exports"($P3508)
.annotate 'line', 968
    find_dynamic_lex $P3511, "$*SC"
    unless_null $P3511, vivify_1922
    get_hll_global $P3509, "GLOBAL"
    get_who $P3510, $P3509
    set $P3511, $P3510["$SC"]
    unless_null $P3511, vivify_1923
    die "Contextual $*SC not found"
  vivify_1923:
  vivify_1922:
    find_dynamic_lex $P3514, "$*GLOBALish"
    unless_null $P3514, vivify_1924
    get_hll_global $P3512, "GLOBAL"
    get_who $P3513, $P3512
    set $P3514, $P3513["$GLOBALish"]
    unless_null $P3514, vivify_1925
    die "Contextual $*GLOBALish not found"
  vivify_1925:
  vivify_1924:
    $P3515 = $P3511."load_module"("Regex", $P3514)
.annotate 'line', 966
    set $P3499, $P3515
  unless_3500_end:
.annotate 'line', 958
    .return ($P3499)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("624_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3524
    .param pmc param_3525
.annotate 'line', 983
    .lex "self", param_3524
    .lex "$/", param_3525
.annotate 'line', 987
    find_dynamic_lex $P3528, "$*SC"
    unless_null $P3528, vivify_1928
    get_hll_global $P3526, "GLOBAL"
    get_who $P3527, $P3526
    set $P3528, $P3527["$SC"]
    unless_null $P3528, vivify_1929
    die "Contextual $*SC not found"
  vivify_1929:
  vivify_1928:
    find_dynamic_lex $P3531, "%*HOW"
    unless_null $P3531, vivify_1930
    get_hll_global $P3529, "GLOBAL"
    get_who $P3530, $P3529
    set $P3531, $P3530["%HOW"]
    unless_null $P3531, vivify_1931
    die "Contextual %*HOW not found"
  vivify_1931:
  vivify_1930:
    set $P3532, $P3531["knowhow"]
    unless_null $P3532, vivify_1932
    new $P3532, "Undef"
  vivify_1932:
    $P3533 = $P3528."pkg_create_mo"($P3532, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3533
.annotate 'line', 988
    find_dynamic_lex $P3536, "$*GLOBALish"
    unless_null $P3536, vivify_1933
    get_hll_global $P3534, "GLOBAL"
    get_who $P3535, $P3534
    set $P3536, $P3535["$GLOBALish"]
    unless_null $P3536, vivify_1934
    die "Contextual $*GLOBALish not found"
  vivify_1934:
  vivify_1933:
    get_how $P3537, $P3536
    find_dynamic_lex $P3540, "$*GLOBALish"
    unless_null $P3540, vivify_1935
    get_hll_global $P3538, "GLOBAL"
    get_who $P3539, $P3538
    set $P3540, $P3539["$GLOBALish"]
    unless_null $P3540, vivify_1936
    die "Contextual $*GLOBALish not found"
  vivify_1936:
  vivify_1935:
    $P3537."compose"($P3540)
.annotate 'line', 989
    find_dynamic_lex $P3543, "$*SC"
    unless_null $P3543, vivify_1937
    get_hll_global $P3541, "GLOBAL"
    get_who $P3542, $P3541
    set $P3543, $P3542["$SC"]
    unless_null $P3543, vivify_1938
    die "Contextual $*SC not found"
  vivify_1938:
  vivify_1937:
    find_lex $P3544, "$?PACKAGE"
    get_who $P3545, $P3544
    set $P3546, $P3545["@BLOCK"]
    unless_null $P3546, vivify_1939
    $P3546 = root_new ['parrot';'ResizablePMCArray']
  vivify_1939:
    set $P3547, $P3546[0]
    unless_null $P3547, vivify_1940
    new $P3547, "Undef"
  vivify_1940:
    find_dynamic_lex $P3550, "$*GLOBALish"
    unless_null $P3550, vivify_1941
    get_hll_global $P3548, "GLOBAL"
    get_who $P3549, $P3548
    set $P3550, $P3549["$GLOBALish"]
    unless_null $P3550, vivify_1942
    die "Contextual $*GLOBALish not found"
  vivify_1942:
  vivify_1941:
    $P3543."install_lexical_symbol"($P3547, "GLOBALish", $P3550)
.annotate 'line', 992
    find_dynamic_lex $P3553, "$*GLOBALish"
    unless_null $P3553, vivify_1943
    get_hll_global $P3551, "GLOBAL"
    get_who $P3552, $P3551
    set $P3553, $P3552["$GLOBALish"]
    unless_null $P3553, vivify_1944
    die "Contextual $*GLOBALish not found"
  vivify_1944:
  vivify_1943:
    store_dynamic_lex "$*PACKAGE", $P3553
.annotate 'line', 993
    find_dynamic_lex $P3556, "$*SC"
    unless_null $P3556, vivify_1945
    get_hll_global $P3554, "GLOBAL"
    get_who $P3555, $P3554
    set $P3556, $P3555["$SC"]
    unless_null $P3556, vivify_1946
    die "Contextual $*SC not found"
  vivify_1946:
  vivify_1945:
    find_lex $P3557, "$?PACKAGE"
    get_who $P3558, $P3557
    set $P3559, $P3558["@BLOCK"]
    unless_null $P3559, vivify_1947
    $P3559 = root_new ['parrot';'ResizablePMCArray']
  vivify_1947:
    set $P3560, $P3559[0]
    unless_null $P3560, vivify_1948
    new $P3560, "Undef"
  vivify_1948:
    find_dynamic_lex $P3563, "$*PACKAGE"
    unless_null $P3563, vivify_1949
    get_hll_global $P3561, "GLOBAL"
    get_who $P3562, $P3561
    set $P3563, $P3562["$PACKAGE"]
    unless_null $P3563, vivify_1950
    die "Contextual $*PACKAGE not found"
  vivify_1950:
  vivify_1949:
    $P3564 = $P3556."install_lexical_symbol"($P3560, "$?PACKAGE", $P3563)
.annotate 'line', 983
    .return ($P3564)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("625_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3566
    .param pmc param_3567
.annotate 'line', 996
    .lex "self", param_3566
    .lex "$/", param_3567
.annotate 'line', 997
    find_lex $P3568, "$/"
    find_lex $P3569, "self"
    $P3570 = $P3569."CTXSAVE"()
    $P3571 = $P3568."!make"($P3570)
.annotate 'line', 996
    .return ($P3571)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("626_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3573
    .param pmc param_3574
.annotate 'line', 1002
    .lex "self", param_3573
    .lex "$/", param_3574
.annotate 'line', 1003
    new $P3575, "Undef"
    .lex "$module", $P3575
    find_dynamic_lex $P3578, "$*SC"
    unless_null $P3578, vivify_1951
    get_hll_global $P3576, "GLOBAL"
    get_who $P3577, $P3576
    set $P3578, $P3577["$SC"]
    unless_null $P3578, vivify_1952
    die "Contextual $*SC not found"
  vivify_1952:
  vivify_1951:
    find_lex $P3579, "$/"
    unless_null $P3579, vivify_1953
    $P3579 = root_new ['parrot';'Hash']
  vivify_1953:
    set $P3580, $P3579["name"]
    unless_null $P3580, vivify_1954
    new $P3580, "Undef"
  vivify_1954:
    set $S3581, $P3580
    find_dynamic_lex $P3584, "$*GLOBALish"
    unless_null $P3584, vivify_1955
    get_hll_global $P3582, "GLOBAL"
    get_who $P3583, $P3582
    set $P3584, $P3583["$GLOBALish"]
    unless_null $P3584, vivify_1956
    die "Contextual $*GLOBALish not found"
  vivify_1956:
  vivify_1955:
    $P3585 = $P3578."load_module"($S3581, $P3584)
    store_lex "$module", $P3585
.annotate 'line', 1004
    find_lex $P3587, "$module"
    unless_null $P3587, vivify_1957
    new $P3587, "Undef"
  vivify_1957:
    defined $I3588, $P3587
    unless $I3588, if_3586_end
.annotate 'line', 1005
    find_lex $P3589, "$module"
    unless_null $P3589, vivify_1958
    new $P3589, "Undef"
  vivify_1958:
    "import_HOW_exports"($P3589)
  if_3586_end:
.annotate 'line', 1007
    find_lex $P3590, "$/"
    get_hll_global $P3591, "GLOBAL"
    nqp_get_package_through_who $P3592, $P3591, "PAST"
    get_who $P3593, $P3592
    set $P3594, $P3593["Stmts"]
    $P3595 = $P3594."new"()
    $P3596 = $P3590."!make"($P3595)
.annotate 'line', 1002
    .return ($P3596)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("627_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3598
    .param pmc param_3599
.annotate 'line', 1010
    .const 'Sub' $P3627 = "628_1304282286.73" 
    capture_lex $P3627
    .lex "self", param_3598
    .lex "$/", param_3599
.annotate 'line', 1011
    new $P3600, "Undef"
    .lex "$count", $P3600
.annotate 'line', 1012
    new $P3601, "Undef"
    .lex "$past", $P3601
.annotate 'line', 1011
    find_lex $P3602, "$/"
    unless_null $P3602, vivify_1959
    $P3602 = root_new ['parrot';'Hash']
  vivify_1959:
    set $P3603, $P3602["xblock"]
    unless_null $P3603, vivify_1960
    new $P3603, "Undef"
  vivify_1960:
    set $N3604, $P3603
    new $P3605, 'Float'
    set $P3605, $N3604
    sub $P3606, $P3605, 1
    store_lex "$count", $P3606
.annotate 'line', 1012
    find_lex $P3607, "$count"
    unless_null $P3607, vivify_1961
    new $P3607, "Undef"
  vivify_1961:
    set $I3608, $P3607
    find_lex $P3609, "$/"
    unless_null $P3609, vivify_1962
    $P3609 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P3610, $P3609["xblock"]
    unless_null $P3610, vivify_1963
    $P3610 = root_new ['parrot';'ResizablePMCArray']
  vivify_1963:
    set $P3611, $P3610[$I3608]
    unless_null $P3611, vivify_1964
    new $P3611, "Undef"
  vivify_1964:
    $P3612 = $P3611."ast"()
    $P3613 = "xblock_immediate"($P3612)
    store_lex "$past", $P3613
.annotate 'line', 1013
    find_lex $P3615, "$/"
    unless_null $P3615, vivify_1965
    $P3615 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P3616, $P3615["else"]
    unless_null $P3616, vivify_1966
    new $P3616, "Undef"
  vivify_1966:
    unless $P3616, if_3614_end
.annotate 'line', 1014
    find_lex $P3617, "$past"
    unless_null $P3617, vivify_1967
    new $P3617, "Undef"
  vivify_1967:
    find_lex $P3618, "$/"
    unless_null $P3618, vivify_1968
    $P3618 = root_new ['parrot';'Hash']
  vivify_1968:
    set $P3619, $P3618["else"]
    unless_null $P3619, vivify_1969
    $P3619 = root_new ['parrot';'ResizablePMCArray']
  vivify_1969:
    set $P3620, $P3619[0]
    unless_null $P3620, vivify_1970
    new $P3620, "Undef"
  vivify_1970:
    $P3621 = $P3620."ast"()
    $P3622 = "block_immediate"($P3621)
    $P3617."push"($P3622)
  if_3614_end:
.annotate 'line', 1017
    new $P3643, 'ExceptionHandler'
    set_label $P3643, loop3642_handler
    $P3643."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3643
  loop3642_test:
    find_lex $P3623, "$count"
    unless_null $P3623, vivify_1971
    new $P3623, "Undef"
  vivify_1971:
    set $N3624, $P3623
    isgt $I3625, $N3624, 0.0
    unless $I3625, loop3642_done
  loop3642_redo:
    .const 'Sub' $P3627 = "628_1304282286.73" 
    capture_lex $P3627
    $P3627()
  loop3642_next:
    goto loop3642_test
  loop3642_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3644, exception, 'type'
    eq $P3644, .CONTROL_LOOP_NEXT, loop3642_next
    eq $P3644, .CONTROL_LOOP_REDO, loop3642_redo
  loop3642_done:
    pop_eh 
.annotate 'line', 1023
    find_lex $P3645, "$/"
    find_lex $P3646, "$past"
    unless_null $P3646, vivify_1980
    new $P3646, "Undef"
  vivify_1980:
    $P3647 = $P3645."!make"($P3646)
.annotate 'line', 1010
    .return ($P3647)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3626"  :anon :subid("628_1304282286.73") :outer("627_1304282286.73")
.annotate 'line', 1019
    new $P3628, "Undef"
    .lex "$else", $P3628
.annotate 'line', 1017
    find_lex $P3629, "$count"
    unless_null $P3629, vivify_1972
    new $P3629, "Undef"
  vivify_1972:
    clone $P3630, $P3629
    dec $P3629
.annotate 'line', 1019
    find_lex $P3631, "$past"
    unless_null $P3631, vivify_1973
    new $P3631, "Undef"
  vivify_1973:
    store_lex "$else", $P3631
.annotate 'line', 1020
    find_lex $P3632, "$count"
    unless_null $P3632, vivify_1974
    new $P3632, "Undef"
  vivify_1974:
    set $I3633, $P3632
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_1975
    $P3634 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P3635, $P3634["xblock"]
    unless_null $P3635, vivify_1976
    $P3635 = root_new ['parrot';'ResizablePMCArray']
  vivify_1976:
    set $P3636, $P3635[$I3633]
    unless_null $P3636, vivify_1977
    new $P3636, "Undef"
  vivify_1977:
    $P3637 = $P3636."ast"()
    $P3638 = "xblock_immediate"($P3637)
    store_lex "$past", $P3638
.annotate 'line', 1021
    find_lex $P3639, "$past"
    unless_null $P3639, vivify_1978
    new $P3639, "Undef"
  vivify_1978:
    find_lex $P3640, "$else"
    unless_null $P3640, vivify_1979
    new $P3640, "Undef"
  vivify_1979:
    $P3641 = $P3639."push"($P3640)
.annotate 'line', 1017
    .return ($P3641)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("629_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3649
    .param pmc param_3650
.annotate 'line', 1026
    .lex "self", param_3649
    .lex "$/", param_3650
.annotate 'line', 1027
    new $P3651, "Undef"
    .lex "$past", $P3651
    find_lex $P3652, "$/"
    unless_null $P3652, vivify_1981
    $P3652 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P3653, $P3652["xblock"]
    unless_null $P3653, vivify_1982
    new $P3653, "Undef"
  vivify_1982:
    $P3654 = $P3653."ast"()
    $P3655 = "xblock_immediate"($P3654)
    store_lex "$past", $P3655
.annotate 'line', 1028
    find_lex $P3656, "$past"
    unless_null $P3656, vivify_1983
    new $P3656, "Undef"
  vivify_1983:
    $P3656."pasttype"("unless")
.annotate 'line', 1029
    find_lex $P3657, "$/"
    find_lex $P3658, "$past"
    unless_null $P3658, vivify_1984
    new $P3658, "Undef"
  vivify_1984:
    $P3659 = $P3657."!make"($P3658)
.annotate 'line', 1026
    .return ($P3659)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("630_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3661
    .param pmc param_3662
.annotate 'line', 1032
    .lex "self", param_3661
    .lex "$/", param_3662
.annotate 'line', 1033
    new $P3663, "Undef"
    .lex "$past", $P3663
    find_lex $P3664, "$/"
    unless_null $P3664, vivify_1985
    $P3664 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P3665, $P3664["xblock"]
    unless_null $P3665, vivify_1986
    new $P3665, "Undef"
  vivify_1986:
    $P3666 = $P3665."ast"()
    $P3667 = "xblock_immediate"($P3666)
    store_lex "$past", $P3667
.annotate 'line', 1034
    find_lex $P3668, "$past"
    unless_null $P3668, vivify_1987
    new $P3668, "Undef"
  vivify_1987:
    find_lex $P3669, "$/"
    unless_null $P3669, vivify_1988
    $P3669 = root_new ['parrot';'Hash']
  vivify_1988:
    set $P3670, $P3669["sym"]
    unless_null $P3670, vivify_1989
    new $P3670, "Undef"
  vivify_1989:
    set $S3671, $P3670
    $P3668."pasttype"($S3671)
.annotate 'line', 1035
    find_lex $P3672, "$/"
    find_lex $P3673, "$past"
    unless_null $P3673, vivify_1990
    new $P3673, "Undef"
  vivify_1990:
    $P3674 = $P3672."!make"($P3673)
.annotate 'line', 1032
    .return ($P3674)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("631_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3676
    .param pmc param_3677
.annotate 'line', 1038
    .lex "self", param_3676
    .lex "$/", param_3677
.annotate 'line', 1039
    new $P3678, "Undef"
    .lex "$pasttype", $P3678
.annotate 'line', 1040
    new $P3679, "Undef"
    .lex "$past", $P3679
.annotate 'line', 1039
    new $P3680, "String"
    assign $P3680, "repeat_"
    find_lex $P3681, "$/"
    unless_null $P3681, vivify_1991
    $P3681 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P3682, $P3681["wu"]
    unless_null $P3682, vivify_1992
    new $P3682, "Undef"
  vivify_1992:
    set $S3683, $P3682
    concat $P3684, $P3680, $S3683
    store_lex "$pasttype", $P3684
    find_lex $P3685, "$past"
    unless_null $P3685, vivify_1993
    new $P3685, "Undef"
  vivify_1993:
.annotate 'line', 1041
    find_lex $P3687, "$/"
    unless_null $P3687, vivify_1994
    $P3687 = root_new ['parrot';'Hash']
  vivify_1994:
    set $P3688, $P3687["xblock"]
    unless_null $P3688, vivify_1995
    new $P3688, "Undef"
  vivify_1995:
    if $P3688, if_3686
.annotate 'line', 1046
    get_hll_global $P3695, "GLOBAL"
    nqp_get_package_through_who $P3696, $P3695, "PAST"
    get_who $P3697, $P3696
    set $P3698, $P3697["Op"]
    find_lex $P3699, "$/"
    unless_null $P3699, vivify_1996
    $P3699 = root_new ['parrot';'Hash']
  vivify_1996:
    set $P3700, $P3699["EXPR"]
    unless_null $P3700, vivify_1997
    new $P3700, "Undef"
  vivify_1997:
    $P3701 = $P3700."ast"()
    find_lex $P3702, "$/"
    unless_null $P3702, vivify_1998
    $P3702 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P3703, $P3702["pblock"]
    unless_null $P3703, vivify_1999
    new $P3703, "Undef"
  vivify_1999:
    $P3704 = $P3703."ast"()
    $P3705 = "block_immediate"($P3704)
    find_lex $P3706, "$pasttype"
    unless_null $P3706, vivify_2000
    new $P3706, "Undef"
  vivify_2000:
    find_lex $P3707, "$/"
    unless_null $P3707, vivify_2001
    new $P3707, "Undef"
  vivify_2001:
    $P3708 = $P3698."new"($P3701, $P3705, $P3706 :named("pasttype"), $P3707 :named("node"))
    store_lex "$past", $P3708
.annotate 'line', 1045
    goto if_3686_end
  if_3686:
.annotate 'line', 1042
    find_lex $P3689, "$/"
    unless_null $P3689, vivify_2002
    $P3689 = root_new ['parrot';'Hash']
  vivify_2002:
    set $P3690, $P3689["xblock"]
    unless_null $P3690, vivify_2003
    new $P3690, "Undef"
  vivify_2003:
    $P3691 = $P3690."ast"()
    $P3692 = "xblock_immediate"($P3691)
    store_lex "$past", $P3692
.annotate 'line', 1043
    find_lex $P3693, "$past"
    unless_null $P3693, vivify_2004
    new $P3693, "Undef"
  vivify_2004:
    find_lex $P3694, "$pasttype"
    unless_null $P3694, vivify_2005
    new $P3694, "Undef"
  vivify_2005:
    $P3693."pasttype"($P3694)
  if_3686_end:
.annotate 'line', 1049
    find_lex $P3709, "$/"
    find_lex $P3710, "$past"
    unless_null $P3710, vivify_2006
    new $P3710, "Undef"
  vivify_2006:
    $P3711 = $P3709."!make"($P3710)
.annotate 'line', 1038
    .return ($P3711)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("632_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3713
    .param pmc param_3714
.annotate 'line', 1052
    .lex "self", param_3713
    .lex "$/", param_3714
.annotate 'line', 1053
    new $P3715, "Undef"
    .lex "$past", $P3715
.annotate 'line', 1055
    new $P3716, "Undef"
    .lex "$block", $P3716
.annotate 'line', 1053
    find_lex $P3717, "$/"
    unless_null $P3717, vivify_2007
    $P3717 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P3718, $P3717["xblock"]
    unless_null $P3718, vivify_2008
    new $P3718, "Undef"
  vivify_2008:
    $P3719 = $P3718."ast"()
    store_lex "$past", $P3719
.annotate 'line', 1054
    find_lex $P3720, "$past"
    unless_null $P3720, vivify_2009
    new $P3720, "Undef"
  vivify_2009:
    $P3720."pasttype"("for")
.annotate 'line', 1055
    find_lex $P3721, "$past"
    unless_null $P3721, vivify_2010
    $P3721 = root_new ['parrot';'ResizablePMCArray']
  vivify_2010:
    set $P3722, $P3721[1]
    unless_null $P3722, vivify_2011
    new $P3722, "Undef"
  vivify_2011:
    store_lex "$block", $P3722
.annotate 'line', 1056
    find_lex $P3724, "$block"
    unless_null $P3724, vivify_2012
    new $P3724, "Undef"
  vivify_2012:
    $P3725 = $P3724."arity"()
    if $P3725, unless_3723_end
.annotate 'line', 1057
    find_lex $P3726, "$block"
    unless_null $P3726, vivify_2013
    $P3726 = root_new ['parrot';'ResizablePMCArray']
  vivify_2013:
    set $P3727, $P3726[0]
    unless_null $P3727, vivify_2014
    new $P3727, "Undef"
  vivify_2014:
    get_hll_global $P3728, "GLOBAL"
    nqp_get_package_through_who $P3729, $P3728, "PAST"
    get_who $P3730, $P3729
    set $P3731, $P3730["Var"]
    $P3732 = $P3731."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3727."push"($P3732)
.annotate 'line', 1058
    find_lex $P3733, "$block"
    unless_null $P3733, vivify_2015
    new $P3733, "Undef"
  vivify_2015:
    $P3733."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1059
    find_lex $P3734, "$block"
    unless_null $P3734, vivify_2016
    new $P3734, "Undef"
  vivify_2016:
    $P3734."arity"(1)
  unless_3723_end:
.annotate 'line', 1061
    find_lex $P3735, "$block"
    unless_null $P3735, vivify_2017
    new $P3735, "Undef"
  vivify_2017:
    $P3735."blocktype"("immediate")
.annotate 'line', 1062
    find_lex $P3736, "$/"
    find_lex $P3737, "$past"
    unless_null $P3737, vivify_2018
    new $P3737, "Undef"
  vivify_2018:
    $P3738 = $P3736."!make"($P3737)
.annotate 'line', 1052
    .return ($P3738)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("633_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3740
    .param pmc param_3741
.annotate 'line', 1065
    .lex "self", param_3740
    .lex "$/", param_3741
.annotate 'line', 1066
    new $P3742, "Undef"
    .lex "$block", $P3742
    find_lex $P3743, "$/"
    unless_null $P3743, vivify_2019
    $P3743 = root_new ['parrot';'Hash']
  vivify_2019:
    set $P3744, $P3743["block"]
    unless_null $P3744, vivify_2020
    new $P3744, "Undef"
  vivify_2020:
    $P3745 = $P3744."ast"()
    store_lex "$block", $P3745
.annotate 'line', 1067
    find_lex $P3746, "$/"
    unless_null $P3746, vivify_2021
    new $P3746, "Undef"
  vivify_2021:
    find_lex $P3747, "$block"
    unless_null $P3747, vivify_2022
    new $P3747, "Undef"
  vivify_2022:
    "push_block_handler"($P3746, $P3747)
.annotate 'line', 1068
    find_lex $P3748, "$?PACKAGE"
    get_who $P3749, $P3748
    set $P3750, $P3749["@BLOCK"]
    unless_null $P3750, vivify_2023
    $P3750 = root_new ['parrot';'ResizablePMCArray']
  vivify_2023:
    set $P3751, $P3750[0]
    unless_null $P3751, vivify_2024
    new $P3751, "Undef"
  vivify_2024:
    $P3752 = $P3751."handlers"()
    set $P3753, $P3752[0]
    unless_null $P3753, vivify_2025
    new $P3753, "Undef"
  vivify_2025:
    $P3753."handle_types_except"("CONTROL")
.annotate 'line', 1069
    find_lex $P3754, "$/"
    get_hll_global $P3755, "GLOBAL"
    nqp_get_package_through_who $P3756, $P3755, "PAST"
    get_who $P3757, $P3756
    set $P3758, $P3757["Stmts"]
    find_lex $P3759, "$/"
    unless_null $P3759, vivify_2026
    new $P3759, "Undef"
  vivify_2026:
    $P3760 = $P3758."new"($P3759 :named("node"))
    $P3761 = $P3754."!make"($P3760)
.annotate 'line', 1065
    .return ($P3761)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("634_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3763
    .param pmc param_3764
.annotate 'line', 1072
    .lex "self", param_3763
    .lex "$/", param_3764
.annotate 'line', 1073
    new $P3765, "Undef"
    .lex "$block", $P3765
    find_lex $P3766, "$/"
    unless_null $P3766, vivify_2027
    $P3766 = root_new ['parrot';'Hash']
  vivify_2027:
    set $P3767, $P3766["block"]
    unless_null $P3767, vivify_2028
    new $P3767, "Undef"
  vivify_2028:
    $P3768 = $P3767."ast"()
    store_lex "$block", $P3768
.annotate 'line', 1074
    find_lex $P3769, "$/"
    unless_null $P3769, vivify_2029
    new $P3769, "Undef"
  vivify_2029:
    find_lex $P3770, "$block"
    unless_null $P3770, vivify_2030
    new $P3770, "Undef"
  vivify_2030:
    "push_block_handler"($P3769, $P3770)
.annotate 'line', 1075
    find_lex $P3771, "$?PACKAGE"
    get_who $P3772, $P3771
    set $P3773, $P3772["@BLOCK"]
    unless_null $P3773, vivify_2031
    $P3773 = root_new ['parrot';'ResizablePMCArray']
  vivify_2031:
    set $P3774, $P3773[0]
    unless_null $P3774, vivify_2032
    new $P3774, "Undef"
  vivify_2032:
    $P3775 = $P3774."handlers"()
    set $P3776, $P3775[0]
    unless_null $P3776, vivify_2033
    new $P3776, "Undef"
  vivify_2033:
    $P3776."handle_types"("CONTROL")
.annotate 'line', 1076
    find_lex $P3777, "$/"
    get_hll_global $P3778, "GLOBAL"
    nqp_get_package_through_who $P3779, $P3778, "PAST"
    get_who $P3780, $P3779
    set $P3781, $P3780["Stmts"]
    find_lex $P3782, "$/"
    unless_null $P3782, vivify_2034
    new $P3782, "Undef"
  vivify_2034:
    $P3783 = $P3781."new"($P3782 :named("node"))
    $P3784 = $P3777."!make"($P3783)
.annotate 'line', 1072
    .return ($P3784)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("635_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3787
    .param pmc param_3788
.annotate 'line', 1116
    .lex "self", param_3787
    .lex "$/", param_3788
.annotate 'line', 1117
    find_lex $P3789, "$?PACKAGE"
    get_who $P3790, $P3789
    set $P3791, $P3790["@BLOCK"]
    unless_null $P3791, vivify_2035
    $P3791 = root_new ['parrot';'ResizablePMCArray']
  vivify_2035:
    set $P3792, $P3791[0]
    unless_null $P3792, vivify_2036
    new $P3792, "Undef"
  vivify_2036:
    find_lex $P3793, "$/"
    unless_null $P3793, vivify_2037
    $P3793 = root_new ['parrot';'Hash']
  vivify_2037:
    set $P3794, $P3793["blorst"]
    unless_null $P3794, vivify_2038
    new $P3794, "Undef"
  vivify_2038:
    $P3795 = $P3794."ast"()
    $P3792."push"($P3795)
.annotate 'line', 1118
    find_lex $P3796, "$/"
    get_hll_global $P3797, "GLOBAL"
    nqp_get_package_through_who $P3798, $P3797, "PAST"
    get_who $P3799, $P3798
    set $P3800, $P3799["Stmts"]
    $P3801 = $P3800."new"()
    $P3802 = $P3796."!make"($P3801)
.annotate 'line', 1116
    .return ($P3802)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("636_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3804
    .param pmc param_3805
.annotate 'line', 1121
    .lex "self", param_3804
    .lex "$/", param_3805
.annotate 'line', 1122
    new $P3806, "Undef"
    .lex "$past", $P3806
    find_lex $P3807, "$/"
    unless_null $P3807, vivify_2039
    $P3807 = root_new ['parrot';'Hash']
  vivify_2039:
    set $P3808, $P3807["blorst"]
    unless_null $P3808, vivify_2040
    new $P3808, "Undef"
  vivify_2040:
    $P3809 = $P3808."ast"()
    store_lex "$past", $P3809
.annotate 'line', 1123
    get_hll_global $P3811, "GLOBAL"
    nqp_get_package_through_who $P3812, $P3811, "PAST"
    get_who $P3813, $P3812
    set $P3814, $P3813["Block"]
    find_lex $P3815, "$past"
    unless_null $P3815, vivify_2041
    new $P3815, "Undef"
  vivify_2041:
    $P3816 = $P3814."ACCEPTS"($P3815)
    if $P3816, unless_3810_end
.annotate 'line', 1124
    get_hll_global $P3817, "GLOBAL"
    nqp_get_package_through_who $P3818, $P3817, "PAST"
    get_who $P3819, $P3818
    set $P3820, $P3819["Block"]
    find_lex $P3821, "$past"
    unless_null $P3821, vivify_2042
    new $P3821, "Undef"
  vivify_2042:
    find_lex $P3822, "$/"
    unless_null $P3822, vivify_2043
    new $P3822, "Undef"
  vivify_2043:
    $P3823 = $P3820."new"($P3821, "immediate" :named("blocktype"), $P3822 :named("node"))
    store_lex "$past", $P3823
  unless_3810_end:
.annotate 'line', 1126
    find_lex $P3825, "$past"
    unless_null $P3825, vivify_2044
    new $P3825, "Undef"
  vivify_2044:
    $P3826 = $P3825."handlers"()
    if $P3826, unless_3824_end
.annotate 'line', 1127
    find_lex $P3827, "$past"
    unless_null $P3827, vivify_2045
    new $P3827, "Undef"
  vivify_2045:
    get_hll_global $P3828, "GLOBAL"
    nqp_get_package_through_who $P3829, $P3828, "PAST"
    get_who $P3830, $P3829
    set $P3831, $P3830["Control"]
.annotate 'line', 1129
    get_hll_global $P3832, "GLOBAL"
    nqp_get_package_through_who $P3833, $P3832, "PAST"
    get_who $P3834, $P3833
    set $P3835, $P3834["Stmts"]
.annotate 'line', 1130
    get_hll_global $P3836, "GLOBAL"
    nqp_get_package_through_who $P3837, $P3836, "PAST"
    get_who $P3838, $P3837
    set $P3839, $P3838["Op"]
.annotate 'line', 1131
    get_hll_global $P3840, "GLOBAL"
    nqp_get_package_through_who $P3841, $P3840, "PAST"
    get_who $P3842, $P3841
    set $P3843, $P3842["Var"]
.annotate 'line', 1132
    get_hll_global $P3844, "GLOBAL"
    nqp_get_package_through_who $P3845, $P3844, "PAST"
    get_who $P3846, $P3845
    set $P3847, $P3846["Var"]
    $P3848 = $P3847."new"("register" :named("scope"), "exception" :named("name"))
    $P3849 = $P3843."new"($P3848, "handled", "keyed" :named("scope"))
.annotate 'line', 1131
    $P3850 = $P3839."new"($P3849, 1, "bind" :named("pasttype"))
.annotate 'line', 1130
    $P3851 = $P3835."new"($P3850)
.annotate 'line', 1129
    $P3852 = $P3831."new"($P3851, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1127
    new $P3853, "ResizablePMCArray"
    push $P3853, $P3852
    $P3827."handlers"($P3853)
  unless_3824_end:
.annotate 'line', 1141
    find_lex $P3854, "$/"
    find_lex $P3855, "$past"
    unless_null $P3855, vivify_2046
    new $P3855, "Undef"
  vivify_2046:
    $P3856 = $P3854."!make"($P3855)
.annotate 'line', 1121
    .return ($P3856)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("637_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3858
    .param pmc param_3859
.annotate 'line', 1144
    .lex "self", param_3858
    .lex "$/", param_3859
.annotate 'line', 1145
    find_lex $P3860, "$/"
.annotate 'line', 1146
    find_lex $P3863, "$/"
    unless_null $P3863, vivify_2047
    $P3863 = root_new ['parrot';'Hash']
  vivify_2047:
    set $P3864, $P3863["block"]
    unless_null $P3864, vivify_2048
    new $P3864, "Undef"
  vivify_2048:
    if $P3864, if_3862
.annotate 'line', 1147
    find_lex $P3869, "$/"
    unless_null $P3869, vivify_2049
    $P3869 = root_new ['parrot';'Hash']
  vivify_2049:
    set $P3870, $P3869["statement"]
    unless_null $P3870, vivify_2050
    new $P3870, "Undef"
  vivify_2050:
    $P3871 = $P3870."ast"()
    set $P3861, $P3871
.annotate 'line', 1146
    goto if_3862_end
  if_3862:
    find_lex $P3865, "$/"
    unless_null $P3865, vivify_2051
    $P3865 = root_new ['parrot';'Hash']
  vivify_2051:
    set $P3866, $P3865["block"]
    unless_null $P3866, vivify_2052
    new $P3866, "Undef"
  vivify_2052:
    $P3867 = $P3866."ast"()
    $P3868 = "block_immediate"($P3867)
    set $P3861, $P3868
  if_3862_end:
    $P3872 = $P3860."!make"($P3861)
.annotate 'line', 1144
    .return ($P3872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("638_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3874
    .param pmc param_3875
.annotate 'line', 1152
    .lex "self", param_3874
    .lex "$/", param_3875
    find_lex $P3876, "$/"
    find_lex $P3877, "$/"
    unless_null $P3877, vivify_2053
    $P3877 = root_new ['parrot';'Hash']
  vivify_2053:
    set $P3878, $P3877["cond"]
    unless_null $P3878, vivify_2054
    new $P3878, "Undef"
  vivify_2054:
    $P3879 = $P3878."ast"()
    $P3880 = $P3876."!make"($P3879)
    .return ($P3880)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("639_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3882
    .param pmc param_3883
.annotate 'line', 1153
    .lex "self", param_3882
    .lex "$/", param_3883
    find_lex $P3884, "$/"
    find_lex $P3885, "$/"
    unless_null $P3885, vivify_2055
    $P3885 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P3886, $P3885["cond"]
    unless_null $P3886, vivify_2056
    new $P3886, "Undef"
  vivify_2056:
    $P3887 = $P3886."ast"()
    $P3888 = $P3884."!make"($P3887)
    .return ($P3888)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("640_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3890
    .param pmc param_3891
.annotate 'line', 1155
    .lex "self", param_3890
    .lex "$/", param_3891
    find_lex $P3892, "$/"
    find_lex $P3893, "$/"
    unless_null $P3893, vivify_2057
    $P3893 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P3894, $P3893["cond"]
    unless_null $P3894, vivify_2058
    new $P3894, "Undef"
  vivify_2058:
    $P3895 = $P3894."ast"()
    $P3896 = $P3892."!make"($P3895)
    .return ($P3896)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("641_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3898
    .param pmc param_3899
.annotate 'line', 1156
    .lex "self", param_3898
    .lex "$/", param_3899
    find_lex $P3900, "$/"
    find_lex $P3901, "$/"
    unless_null $P3901, vivify_2059
    $P3901 = root_new ['parrot';'Hash']
  vivify_2059:
    set $P3902, $P3901["cond"]
    unless_null $P3902, vivify_2060
    new $P3902, "Undef"
  vivify_2060:
    $P3903 = $P3902."ast"()
    $P3904 = $P3900."!make"($P3903)
    .return ($P3904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("642_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3906
    .param pmc param_3907
.annotate 'line', 1160
    .lex "self", param_3906
    .lex "$/", param_3907
    find_lex $P3908, "$/"
    find_lex $P3909, "$/"
    unless_null $P3909, vivify_2061
    $P3909 = root_new ['parrot';'Hash']
  vivify_2061:
    set $P3910, $P3909["fatarrow"]
    unless_null $P3910, vivify_2062
    new $P3910, "Undef"
  vivify_2062:
    $P3911 = $P3910."ast"()
    $P3912 = $P3908."!make"($P3911)
    .return ($P3912)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("643_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3914
    .param pmc param_3915
.annotate 'line', 1161
    .lex "self", param_3914
    .lex "$/", param_3915
    find_lex $P3916, "$/"
    find_lex $P3917, "$/"
    unless_null $P3917, vivify_2063
    $P3917 = root_new ['parrot';'Hash']
  vivify_2063:
    set $P3918, $P3917["colonpair"]
    unless_null $P3918, vivify_2064
    new $P3918, "Undef"
  vivify_2064:
    $P3919 = $P3918."ast"()
    $P3920 = $P3916."!make"($P3919)
    .return ($P3920)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("644_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3922
    .param pmc param_3923
.annotate 'line', 1162
    .lex "self", param_3922
    .lex "$/", param_3923
    find_lex $P3924, "$/"
    find_lex $P3925, "$/"
    unless_null $P3925, vivify_2065
    $P3925 = root_new ['parrot';'Hash']
  vivify_2065:
    set $P3926, $P3925["variable"]
    unless_null $P3926, vivify_2066
    new $P3926, "Undef"
  vivify_2066:
    $P3927 = $P3926."ast"()
    $P3928 = $P3924."!make"($P3927)
    .return ($P3928)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("645_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3930
    .param pmc param_3931
.annotate 'line', 1163
    .lex "self", param_3930
    .lex "$/", param_3931
    find_lex $P3932, "$/"
    find_lex $P3933, "$/"
    unless_null $P3933, vivify_2067
    $P3933 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P3934, $P3933["package_declarator"]
    unless_null $P3934, vivify_2068
    new $P3934, "Undef"
  vivify_2068:
    $P3935 = $P3934."ast"()
    $P3936 = $P3932."!make"($P3935)
    .return ($P3936)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("646_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3938
    .param pmc param_3939
.annotate 'line', 1164
    .lex "self", param_3938
    .lex "$/", param_3939
    find_lex $P3940, "$/"
    find_lex $P3941, "$/"
    unless_null $P3941, vivify_2069
    $P3941 = root_new ['parrot';'Hash']
  vivify_2069:
    set $P3942, $P3941["scope_declarator"]
    unless_null $P3942, vivify_2070
    new $P3942, "Undef"
  vivify_2070:
    $P3943 = $P3942."ast"()
    $P3944 = $P3940."!make"($P3943)
    .return ($P3944)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("647_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3946
    .param pmc param_3947
.annotate 'line', 1165
    .lex "self", param_3946
    .lex "$/", param_3947
    find_lex $P3948, "$/"
    find_lex $P3949, "$/"
    unless_null $P3949, vivify_2071
    $P3949 = root_new ['parrot';'Hash']
  vivify_2071:
    set $P3950, $P3949["routine_declarator"]
    unless_null $P3950, vivify_2072
    new $P3950, "Undef"
  vivify_2072:
    $P3951 = $P3950."ast"()
    $P3952 = $P3948."!make"($P3951)
    .return ($P3952)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("648_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3954
    .param pmc param_3955
.annotate 'line', 1166
    .lex "self", param_3954
    .lex "$/", param_3955
    find_lex $P3956, "$/"
    find_lex $P3957, "$/"
    unless_null $P3957, vivify_2073
    $P3957 = root_new ['parrot';'Hash']
  vivify_2073:
    set $P3958, $P3957["regex_declarator"]
    unless_null $P3958, vivify_2074
    new $P3958, "Undef"
  vivify_2074:
    $P3959 = $P3958."ast"()
    $P3960 = $P3956."!make"($P3959)
    .return ($P3960)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("649_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3962
    .param pmc param_3963
.annotate 'line', 1167
    .lex "self", param_3962
    .lex "$/", param_3963
    find_lex $P3964, "$/"
    find_lex $P3965, "$/"
    unless_null $P3965, vivify_2075
    $P3965 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P3966, $P3965["statement_prefix"]
    unless_null $P3966, vivify_2076
    new $P3966, "Undef"
  vivify_2076:
    $P3967 = $P3966."ast"()
    $P3968 = $P3964."!make"($P3967)
    .return ($P3968)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("650_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3970
    .param pmc param_3971
.annotate 'line', 1168
    .lex "self", param_3970
    .lex "$/", param_3971
    find_lex $P3972, "$/"
    find_lex $P3973, "$/"
    unless_null $P3973, vivify_2077
    $P3973 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P3974, $P3973["pblock"]
    unless_null $P3974, vivify_2078
    new $P3974, "Undef"
  vivify_2078:
    $P3975 = $P3974."ast"()
    $P3976 = $P3972."!make"($P3975)
    .return ($P3976)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("651_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3978
    .param pmc param_3979
.annotate 'line', 1170
    .lex "self", param_3978
    .lex "$/", param_3979
.annotate 'line', 1171
    new $P3980, "Undef"
    .lex "$past", $P3980
    find_lex $P3981, "$/"
    unless_null $P3981, vivify_2079
    $P3981 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P3982, $P3981["val"]
    unless_null $P3982, vivify_2080
    new $P3982, "Undef"
  vivify_2080:
    $P3983 = $P3982."ast"()
    store_lex "$past", $P3983
.annotate 'line', 1172
    find_lex $P3984, "$past"
    unless_null $P3984, vivify_2081
    new $P3984, "Undef"
  vivify_2081:
    find_lex $P3985, "$/"
    unless_null $P3985, vivify_2082
    $P3985 = root_new ['parrot';'Hash']
  vivify_2082:
    set $P3986, $P3985["key"]
    unless_null $P3986, vivify_2083
    new $P3986, "Undef"
  vivify_2083:
    $P3987 = $P3986."Str"()
    $P3984."named"($P3987)
.annotate 'line', 1173
    find_lex $P3988, "$/"
    find_lex $P3989, "$past"
    unless_null $P3989, vivify_2084
    new $P3989, "Undef"
  vivify_2084:
    $P3990 = $P3988."!make"($P3989)
.annotate 'line', 1170
    .return ($P3990)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("652_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_3992
    .param pmc param_3993
.annotate 'line', 1176
    .lex "self", param_3992
    .lex "$/", param_3993
.annotate 'line', 1177
    new $P3994, "Undef"
    .lex "$past", $P3994
.annotate 'line', 1178
    find_lex $P3997, "$/"
    unless_null $P3997, vivify_2085
    $P3997 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P3998, $P3997["circumfix"]
    unless_null $P3998, vivify_2086
    new $P3998, "Undef"
  vivify_2086:
    if $P3998, if_3996
.annotate 'line', 1179
    get_hll_global $P4003, "GLOBAL"
    nqp_get_package_through_who $P4004, $P4003, "PAST"
    get_who $P4005, $P4004
    set $P4006, $P4005["Val"]
    find_lex $P4007, "$/"
    unless_null $P4007, vivify_2087
    $P4007 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P4008, $P4007["not"]
    unless_null $P4008, vivify_2088
    new $P4008, "Undef"
  vivify_2088:
    isfalse $I4009, $P4008
    $P4010 = $P4006."new"($I4009 :named("value"))
    set $P3995, $P4010
.annotate 'line', 1178
    goto if_3996_end
  if_3996:
    find_lex $P3999, "$/"
    unless_null $P3999, vivify_2089
    $P3999 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P4000, $P3999["circumfix"]
    unless_null $P4000, vivify_2090
    $P4000 = root_new ['parrot';'ResizablePMCArray']
  vivify_2090:
    set $P4001, $P4000[0]
    unless_null $P4001, vivify_2091
    new $P4001, "Undef"
  vivify_2091:
    $P4002 = $P4001."ast"()
    set $P3995, $P4002
  if_3996_end:
    store_lex "$past", $P3995
.annotate 'line', 1180
    find_lex $P4011, "$past"
    unless_null $P4011, vivify_2092
    new $P4011, "Undef"
  vivify_2092:
    find_lex $P4012, "$/"
    unless_null $P4012, vivify_2093
    $P4012 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P4013, $P4012["identifier"]
    unless_null $P4013, vivify_2094
    new $P4013, "Undef"
  vivify_2094:
    set $S4014, $P4013
    $P4011."named"($S4014)
.annotate 'line', 1181
    find_lex $P4015, "$/"
    find_lex $P4016, "$past"
    unless_null $P4016, vivify_2095
    new $P4016, "Undef"
  vivify_2095:
    $P4017 = $P4015."!make"($P4016)
.annotate 'line', 1176
    .return ($P4017)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("653_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4019
    .param pmc param_4020
.annotate 'line', 1184
    .const 'Sub' $P4036 = "654_1304282286.73" 
    capture_lex $P4036
    .lex "self", param_4019
    .lex "$/", param_4020
.annotate 'line', 1185
    new $P4021, "Undef"
    .lex "$past", $P4021
.annotate 'line', 1184
    find_lex $P4022, "$past"
    unless_null $P4022, vivify_2096
    new $P4022, "Undef"
  vivify_2096:
.annotate 'line', 1186
    find_lex $P4024, "$/"
    unless_null $P4024, vivify_2097
    $P4024 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P4025, $P4024["postcircumfix"]
    unless_null $P4025, vivify_2098
    new $P4025, "Undef"
  vivify_2098:
    if $P4025, if_4023
.annotate 'line', 1190
    .const 'Sub' $P4036 = "654_1304282286.73" 
    capture_lex $P4036
    $P4036()
    goto if_4023_end
  if_4023:
.annotate 'line', 1187
    find_lex $P4026, "$/"
    unless_null $P4026, vivify_2155
    $P4026 = root_new ['parrot';'Hash']
  vivify_2155:
    set $P4027, $P4026["postcircumfix"]
    unless_null $P4027, vivify_2156
    new $P4027, "Undef"
  vivify_2156:
    $P4028 = $P4027."ast"()
    store_lex "$past", $P4028
.annotate 'line', 1188
    find_lex $P4029, "$past"
    unless_null $P4029, vivify_2157
    new $P4029, "Undef"
  vivify_2157:
    get_hll_global $P4030, "GLOBAL"
    nqp_get_package_through_who $P4031, $P4030, "PAST"
    get_who $P4032, $P4031
    set $P4033, $P4032["Var"]
    $P4034 = $P4033."new"("$/" :named("name"))
    $P4029."unshift"($P4034)
  if_4023_end:
.annotate 'line', 1249
    find_lex $P4218, "$/"
    find_lex $P4219, "$past"
    unless_null $P4219, vivify_2158
    new $P4219, "Undef"
  vivify_2158:
    $P4220 = $P4218."!make"($P4219)
.annotate 'line', 1184
    .return ($P4220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4035"  :anon :subid("654_1304282286.73") :outer("653_1304282286.73")
.annotate 'line', 1190
    .const 'Sub' $P4112 = "656_1304282286.73" 
    capture_lex $P4112
    .const 'Sub' $P4071 = "655_1304282286.73" 
    capture_lex $P4071
.annotate 'line', 1191
    $P4037 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4037
    get_hll_global $P4038, "GLOBAL"
    nqp_get_package_through_who $P4039, $P4038, "NQP"
    get_who $P4040, $P4039
    set $P4041, $P4040["Compiler"]
    find_lex $P4042, "$/"
    unless_null $P4042, vivify_2099
    new $P4042, "Undef"
  vivify_2099:
    set $S4043, $P4042
    $P4044 = $P4041."parse_name"($S4043)
    store_lex "@name", $P4044
.annotate 'line', 1192
    find_lex $P4047, "@name"
    unless_null $P4047, vivify_2100
    $P4047 = root_new ['parrot';'ResizablePMCArray']
  vivify_2100:
    set $N4048, $P4047
    isgt $I4049, $N4048, 1.0
    if $I4049, if_4046
.annotate 'line', 1199
    find_lex $P4065, "$/"
    unless_null $P4065, vivify_2101
    $P4065 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4066, $P4065["twigil"]
    unless_null $P4066, vivify_2102
    $P4066 = root_new ['parrot';'ResizablePMCArray']
  vivify_2102:
    set $P4067, $P4066[0]
    unless_null $P4067, vivify_2103
    new $P4067, "Undef"
  vivify_2103:
    set $S4068, $P4067
    iseq $I4069, $S4068, "*"
    if $I4069, if_4064
.annotate 'line', 1210
    find_lex $P4106, "$/"
    unless_null $P4106, vivify_2104
    $P4106 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P4107, $P4106["twigil"]
    unless_null $P4107, vivify_2105
    $P4107 = root_new ['parrot';'ResizablePMCArray']
  vivify_2105:
    set $P4108, $P4107[0]
    unless_null $P4108, vivify_2106
    new $P4108, "Undef"
  vivify_2106:
    set $S4109, $P4108
    iseq $I4110, $S4109, "!"
    if $I4110, if_4105
.annotate 'line', 1239
    find_lex $P4195, "@name"
    unless_null $P4195, vivify_2107
    $P4195 = root_new ['parrot';'ResizablePMCArray']
  vivify_2107:
    set $P4196, $P4195[0]
    unless_null $P4196, vivify_2108
    new $P4196, "Undef"
  vivify_2108:
    set $S4197, $P4196
    $P4198 = "is_package"($S4197)
    if $P4198, if_4194
.annotate 'line', 1244
    get_hll_global $P4207, "GLOBAL"
    nqp_get_package_through_who $P4208, $P4207, "PAST"
    get_who $P4209, $P4208
    set $P4210, $P4209["Var"]
.annotate 'line', 1245
    find_lex $P4211, "@name"
    unless_null $P4211, vivify_2109
    $P4211 = root_new ['parrot';'ResizablePMCArray']
  vivify_2109:
    $P4212 = $P4211."pop"()
    set $S4213, $P4212
    find_lex $P4214, "$/"
    unless_null $P4214, vivify_2110
    $P4214 = root_new ['parrot';'Hash']
  vivify_2110:
    set $P4215, $P4214["sigil"]
    unless_null $P4215, vivify_2111
    new $P4215, "Undef"
  vivify_2111:
    $P4216 = "vivitype"($P4215)
    $P4217 = $P4210."new"($S4213 :named("name"), $P4216 :named("viviself"))
.annotate 'line', 1244
    store_lex "$past", $P4217
.annotate 'line', 1243
    set $P4193, $P4217
.annotate 'line', 1239
    goto if_4194_end
  if_4194:
.annotate 'line', 1240
    find_lex $P4199, "@name"
    unless_null $P4199, vivify_2112
    $P4199 = root_new ['parrot';'ResizablePMCArray']
  vivify_2112:
    find_lex $P4200, "$/"
    unless_null $P4200, vivify_2113
    new $P4200, "Undef"
  vivify_2113:
    $P4201 = "lexical_package_lookup"($P4199, $P4200)
    store_lex "$past", $P4201
.annotate 'line', 1241
    find_lex $P4202, "$past"
    unless_null $P4202, vivify_2114
    new $P4202, "Undef"
  vivify_2114:
    find_lex $P4203, "$/"
    unless_null $P4203, vivify_2115
    $P4203 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4204, $P4203["sigil"]
    unless_null $P4204, vivify_2116
    new $P4204, "Undef"
  vivify_2116:
    $P4205 = "vivitype"($P4204)
    $P4206 = $P4202."viviself"($P4205)
.annotate 'line', 1239
    set $P4193, $P4206
  if_4194_end:
    set $P4104, $P4193
.annotate 'line', 1210
    goto if_4105_end
  if_4105:
    .const 'Sub' $P4112 = "656_1304282286.73" 
    capture_lex $P4112
    $P4192 = $P4112()
    set $P4104, $P4192
  if_4105_end:
    set $P4063, $P4104
.annotate 'line', 1199
    goto if_4064_end
  if_4064:
    .const 'Sub' $P4071 = "655_1304282286.73" 
    capture_lex $P4071
    $P4103 = $P4071()
    set $P4063, $P4103
  if_4064_end:
    set $P4045, $P4063
.annotate 'line', 1192
    goto if_4046_end
  if_4046:
.annotate 'line', 1193
    find_lex $P4051, "$/"
    unless_null $P4051, vivify_2147
    $P4051 = root_new ['parrot';'Hash']
  vivify_2147:
    set $P4052, $P4051["twigil"]
    unless_null $P4052, vivify_2148
    new $P4052, "Undef"
  vivify_2148:
    unless $P4052, if_4050_end
.annotate 'line', 1194
    find_lex $P4053, "$/"
    unless_null $P4053, vivify_2149
    new $P4053, "Undef"
  vivify_2149:
    $P4054 = $P4053."CURSOR"()
    $P4054."panic"("Twigil not allowed on multi-part name")
  if_4050_end:
.annotate 'line', 1196
    find_lex $P4055, "@name"
    unless_null $P4055, vivify_2150
    $P4055 = root_new ['parrot';'ResizablePMCArray']
  vivify_2150:
    find_lex $P4056, "$/"
    unless_null $P4056, vivify_2151
    new $P4056, "Undef"
  vivify_2151:
    $P4057 = "lexical_package_lookup"($P4055, $P4056)
    store_lex "$past", $P4057
.annotate 'line', 1197
    find_lex $P4058, "$past"
    unless_null $P4058, vivify_2152
    new $P4058, "Undef"
  vivify_2152:
    find_lex $P4059, "$/"
    unless_null $P4059, vivify_2153
    $P4059 = root_new ['parrot';'Hash']
  vivify_2153:
    set $P4060, $P4059["sigil"]
    unless_null $P4060, vivify_2154
    new $P4060, "Undef"
  vivify_2154:
    $P4061 = "vivitype"($P4060)
    $P4062 = $P4058."viviself"($P4061)
.annotate 'line', 1192
    set $P4045, $P4062
  if_4046_end:
.annotate 'line', 1190
    .return ($P4045)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4111"  :anon :subid("656_1304282286.73") :outer("654_1304282286.73")
.annotate 'line', 1210
    .const 'Sub' $P4143 = "657_1304282286.73" 
    capture_lex $P4143
.annotate 'line', 1212
    new $P4113, "Undef"
    .lex "$name", $P4113
    find_lex $P4114, "@name"
    unless_null $P4114, vivify_2117
    $P4114 = root_new ['parrot';'ResizablePMCArray']
  vivify_2117:
    $P4115 = $P4114."pop"()
    set $S4116, $P4115
    new $P4117, 'String'
    set $P4117, $S4116
    store_lex "$name", $P4117
.annotate 'line', 1213
    get_hll_global $P4118, "GLOBAL"
    nqp_get_package_through_who $P4119, $P4118, "PAST"
    get_who $P4120, $P4119
    set $P4121, $P4120["Var"]
    find_lex $P4122, "$name"
    unless_null $P4122, vivify_2118
    new $P4122, "Undef"
  vivify_2118:
.annotate 'line', 1215
    find_lex $P4123, "$/"
    unless_null $P4123, vivify_2119
    $P4123 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4124, $P4123["sigil"]
    unless_null $P4124, vivify_2120
    new $P4124, "Undef"
  vivify_2120:
    $P4125 = "vivitype"($P4124)
.annotate 'line', 1216
    get_hll_global $P4126, "GLOBAL"
    nqp_get_package_through_who $P4127, $P4126, "PAST"
    get_who $P4128, $P4127
    set $P4129, $P4128["Var"]
    $P4130 = $P4129."new"("self" :named("name"))
.annotate 'line', 1217
    get_hll_global $P4131, "GLOBAL"
    nqp_get_package_through_who $P4132, $P4131, "PAST"
    get_who $P4133, $P4132
    set $P4134, $P4133["Var"]
    $P4135 = $P4134."new"("$?CLASS" :named("name"))
    $P4136 = $P4121."new"($P4130, $P4135, $P4122 :named("name"), "attribute_6model" :named("scope"), $P4125 :named("viviself"))
.annotate 'line', 1213
    store_lex "$past", $P4136
.annotate 'line', 1221
    find_dynamic_lex $P4141, "$*IN_DECL"
    unless_null $P4141, vivify_2121
    get_hll_global $P4139, "GLOBAL"
    get_who $P4140, $P4139
    set $P4141, $P4140["$IN_DECL"]
    unless_null $P4141, vivify_2122
    die "Contextual $*IN_DECL not found"
  vivify_2122:
  vivify_2121:
    unless $P4141, unless_4138
    set $P4137, $P4141
    goto unless_4138_end
  unless_4138:
    .const 'Sub' $P4143 = "657_1304282286.73" 
    capture_lex $P4143
    $P4191 = $P4143()
    set $P4137, $P4191
  unless_4138_end:
.annotate 'line', 1210
    .return ($P4137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4142"  :anon :subid("657_1304282286.73") :outer("656_1304282286.73")
.annotate 'line', 1221
    .const 'Sub' $P4158 = "658_1304282286.73" 
    capture_lex $P4158
.annotate 'line', 1222
    new $P4144, "Undef"
    .lex "$attr", $P4144
.annotate 'line', 1221
    find_lex $P4145, "$attr"
    unless_null $P4145, vivify_2123
    new $P4145, "Undef"
  vivify_2123:
.annotate 'line', 1223
    find_dynamic_lex $P4149, "$*PACKAGE"
    unless_null $P4149, vivify_2124
    get_hll_global $P4147, "GLOBAL"
    get_who $P4148, $P4147
    set $P4149, $P4148["$PACKAGE"]
    unless_null $P4149, vivify_2125
    die "Contextual $*PACKAGE not found"
  vivify_2125:
  vivify_2124:
    get_how $P4150, $P4149
    find_dynamic_lex $P4153, "$*PACKAGE"
    unless_null $P4153, vivify_2126
    get_hll_global $P4151, "GLOBAL"
    get_who $P4152, $P4151
    set $P4153, $P4152["$PACKAGE"]
    unless_null $P4153, vivify_2127
    die "Contextual $*PACKAGE not found"
  vivify_2127:
  vivify_2126:
    $P4154 = $P4150."attributes"($P4153, 1 :named("local"))
    defined $I4155, $P4154
    unless $I4155, for_undef_2128
    iter $P4146, $P4154
    new $P4170, 'ExceptionHandler'
    set_label $P4170, loop4169_handler
    $P4170."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4170
  loop4169_test:
    unless $P4146, loop4169_done
    shift $P4156, $P4146
  loop4169_redo:
    .const 'Sub' $P4158 = "658_1304282286.73" 
    capture_lex $P4158
    $P4158($P4156)
  loop4169_next:
    goto loop4169_test
  loop4169_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4171, exception, 'type'
    eq $P4171, .CONTROL_LOOP_NEXT, loop4169_next
    eq $P4171, .CONTROL_LOOP_REDO, loop4169_redo
  loop4169_done:
    pop_eh 
  for_undef_2128:
.annotate 'line', 1229
    find_lex $P4174, "$attr"
    unless_null $P4174, vivify_2132
    new $P4174, "Undef"
  vivify_2132:
    defined $I4175, $P4174
    if $I4175, if_4173
.annotate 'line', 1235
    find_lex $P4184, "$/"
    unless_null $P4184, vivify_2133
    new $P4184, "Undef"
  vivify_2133:
    $P4185 = $P4184."CURSOR"()
    new $P4186, 'String'
    set $P4186, "Attribute '"
    find_lex $P4187, "$name"
    unless_null $P4187, vivify_2134
    new $P4187, "Undef"
  vivify_2134:
    concat $P4188, $P4186, $P4187
    concat $P4189, $P4188, "' not declared"
    $P4190 = $P4185."panic"($P4189)
.annotate 'line', 1234
    set $P4172, $P4190
.annotate 'line', 1229
    goto if_4173_end
  if_4173:
.annotate 'line', 1230
    find_lex $P4178, "$attr"
    unless_null $P4178, vivify_2135
    new $P4178, "Undef"
  vivify_2135:
    can $I4179, $P4178, "type"
    if $I4179, if_4177
    new $P4176, 'Integer'
    set $P4176, $I4179
    goto if_4177_end
  if_4177:
.annotate 'line', 1231
    find_lex $P4180, "$past"
    unless_null $P4180, vivify_2136
    new $P4180, "Undef"
  vivify_2136:
    find_lex $P4181, "$attr"
    unless_null $P4181, vivify_2137
    new $P4181, "Undef"
  vivify_2137:
    $P4182 = $P4181."type"()
    $P4183 = $P4180."type"($P4182)
.annotate 'line', 1230
    set $P4176, $P4183
  if_4177_end:
.annotate 'line', 1229
    set $P4172, $P4176
  if_4173_end:
.annotate 'line', 1221
    .return ($P4172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4157"  :anon :subid("658_1304282286.73") :outer("657_1304282286.73")
    .param pmc param_4159
.annotate 'line', 1223
    .lex "$_", param_4159
.annotate 'line', 1224
    find_lex $P4162, "$_"
    unless_null $P4162, vivify_2129
    new $P4162, "Undef"
  vivify_2129:
    $S4163 = $P4162."name"()
    find_lex $P4164, "$name"
    unless_null $P4164, vivify_2130
    new $P4164, "Undef"
  vivify_2130:
    set $S4165, $P4164
    iseq $I4166, $S4163, $S4165
    if $I4166, if_4161
    new $P4160, 'Integer'
    set $P4160, $I4166
    goto if_4161_end
  if_4161:
.annotate 'line', 1225
    find_lex $P4167, "$_"
    unless_null $P4167, vivify_2131
    new $P4167, "Undef"
  vivify_2131:
    store_lex "$attr", $P4167
.annotate 'line', 1226
    set $I4168, .CONTROL_LOOP_LAST
    die 0, $I4168
  if_4161_end:
.annotate 'line', 1223
    .return ($P4160)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4070"  :anon :subid("655_1304282286.73") :outer("654_1304282286.73")
.annotate 'line', 1200
    new $P4072, "Undef"
    .lex "$global_fallback", $P4072
    find_lex $P4073, "$/"
    unless_null $P4073, vivify_2138
    $P4073 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P4074, $P4073["sigil"]
    unless_null $P4074, vivify_2139
    new $P4074, "Undef"
  vivify_2139:
    set $S4075, $P4074
    new $P4076, 'String'
    set $P4076, $S4075
    find_lex $P4077, "$/"
    unless_null $P4077, vivify_2140
    $P4077 = root_new ['parrot';'Hash']
  vivify_2140:
    set $P4078, $P4077["desigilname"]
    unless_null $P4078, vivify_2141
    new $P4078, "Undef"
  vivify_2141:
    concat $P4079, $P4076, $P4078
    new $P4080, "ResizablePMCArray"
    push $P4080, "GLOBAL"
    push $P4080, $P4079
    find_lex $P4081, "$/"
    unless_null $P4081, vivify_2142
    new $P4081, "Undef"
  vivify_2142:
    $P4082 = "lexical_package_lookup"($P4080, $P4081)
    store_lex "$global_fallback", $P4082
.annotate 'line', 1201
    find_lex $P4083, "$global_fallback"
    unless_null $P4083, vivify_2143
    new $P4083, "Undef"
  vivify_2143:
    get_hll_global $P4084, "GLOBAL"
    nqp_get_package_through_who $P4085, $P4084, "PAST"
    get_who $P4086, $P4085
    set $P4087, $P4086["Op"]
.annotate 'line', 1202
    new $P4088, "String"
    assign $P4088, "Contextual "
    find_lex $P4089, "$/"
    unless_null $P4089, vivify_2144
    new $P4089, "Undef"
  vivify_2144:
    set $S4090, $P4089
    concat $P4091, $P4088, $S4090
    concat $P4092, $P4091, " not found"
    $P4093 = $P4087."new"($P4092, "die" :named("pirop"))
.annotate 'line', 1201
    $P4083."viviself"($P4093)
.annotate 'line', 1205
    get_hll_global $P4094, "GLOBAL"
    nqp_get_package_through_who $P4095, $P4094, "PAST"
    get_who $P4096, $P4095
    set $P4097, $P4096["Var"]
.annotate 'line', 1206
    find_lex $P4098, "@name"
    unless_null $P4098, vivify_2145
    $P4098 = root_new ['parrot';'ResizablePMCArray']
  vivify_2145:
    $P4099 = $P4098."pop"()
    set $S4100, $P4099
    find_lex $P4101, "$global_fallback"
    unless_null $P4101, vivify_2146
    new $P4101, "Undef"
  vivify_2146:
    $P4102 = $P4097."new"($S4100 :named("name"), "contextual" :named("scope"), $P4101 :named("viviself"))
.annotate 'line', 1205
    store_lex "$past", $P4102
.annotate 'line', 1199
    .return ($P4102)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("659_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4222
    .param pmc param_4223
.annotate 'line', 1252
    .lex "self", param_4222
    .lex "$/", param_4223
    find_lex $P4224, "$/"
    find_lex $P4225, "$/"
    unless_null $P4225, vivify_2159
    $P4225 = root_new ['parrot';'Hash']
  vivify_2159:
    set $P4226, $P4225["package_def"]
    unless_null $P4226, vivify_2160
    new $P4226, "Undef"
  vivify_2160:
    $P4227 = $P4226."ast"()
    $P4228 = $P4224."!make"($P4227)
    .return ($P4228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("660_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4230
    .param pmc param_4231
.annotate 'line', 1253
    .lex "self", param_4230
    .lex "$/", param_4231
    find_lex $P4232, "$/"
    find_lex $P4233, "$/"
    unless_null $P4233, vivify_2161
    $P4233 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P4234, $P4233["package_def"]
    unless_null $P4234, vivify_2162
    new $P4234, "Undef"
  vivify_2162:
    $P4235 = $P4234."ast"()
    $P4236 = $P4232."!make"($P4235)
    .return ($P4236)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("661_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4238
    .param pmc param_4239
.annotate 'line', 1254
    .lex "self", param_4238
    .lex "$/", param_4239
    find_lex $P4240, "$/"
    find_lex $P4241, "$/"
    unless_null $P4241, vivify_2163
    $P4241 = root_new ['parrot';'Hash']
  vivify_2163:
    set $P4242, $P4241["package_def"]
    unless_null $P4242, vivify_2164
    new $P4242, "Undef"
  vivify_2164:
    $P4243 = $P4242."ast"()
    $P4244 = $P4240."!make"($P4243)
    .return ($P4244)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("662_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4246
    .param pmc param_4247
.annotate 'line', 1255
    .lex "self", param_4246
    .lex "$/", param_4247
    find_lex $P4248, "$/"
    find_lex $P4249, "$/"
    unless_null $P4249, vivify_2165
    $P4249 = root_new ['parrot';'Hash']
  vivify_2165:
    set $P4250, $P4249["package_def"]
    unless_null $P4250, vivify_2166
    new $P4250, "Undef"
  vivify_2166:
    $P4251 = $P4250."ast"()
    $P4252 = $P4248."!make"($P4251)
    .return ($P4252)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("663_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4254
    .param pmc param_4255
.annotate 'line', 1256
    .lex "self", param_4254
    .lex "$/", param_4255
    find_lex $P4256, "$/"
    find_lex $P4257, "$/"
    unless_null $P4257, vivify_2167
    $P4257 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P4258, $P4257["package_def"]
    unless_null $P4258, vivify_2168
    new $P4258, "Undef"
  vivify_2168:
    $P4259 = $P4258."ast"()
    $P4260 = $P4256."!make"($P4259)
    .return ($P4260)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("664_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4262
    .param pmc param_4263
.annotate 'line', 1257
    .lex "self", param_4262
    .lex "$/", param_4263
    find_lex $P4264, "$/"
    find_lex $P4265, "$/"
    unless_null $P4265, vivify_2169
    $P4265 = root_new ['parrot';'Hash']
  vivify_2169:
    set $P4266, $P4265["package_def"]
    unless_null $P4266, vivify_2170
    new $P4266, "Undef"
  vivify_2170:
    $P4267 = $P4266."ast"()
    $P4268 = $P4264."!make"($P4267)
    .return ($P4268)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("665_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4270
    .param pmc param_4271
.annotate 'line', 1259
    .const 'Sub' $P4498 = "669_1304282286.73" 
    capture_lex $P4498
    .const 'Sub' $P4468 = "668_1304282286.73" 
    capture_lex $P4468
    .const 'Sub' $P4421 = "666_1304282286.73" 
    capture_lex $P4421
    .lex "self", param_4270
    .lex "$/", param_4271
.annotate 'line', 1261
    $P4272 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4272
.annotate 'line', 1262
    new $P4273, "Undef"
    .lex "$name", $P4273
.annotate 'line', 1263
    new $P4274, "Undef"
    .lex "$how", $P4274
.annotate 'line', 1266
    new $P4275, "Undef"
    .lex "$past", $P4275
.annotate 'line', 1261
    find_lex $P4276, "$/"
    unless_null $P4276, vivify_2171
    $P4276 = root_new ['parrot';'Hash']
  vivify_2171:
    set $P4277, $P4276["name"]
    unless_null $P4277, vivify_2172
    $P4277 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P4278, $P4277["identifier"]
    unless_null $P4278, vivify_2173
    new $P4278, "Undef"
  vivify_2173:
    clone $P4279, $P4278
    store_lex "@ns", $P4279
.annotate 'line', 1262
    find_lex $P4280, "@ns"
    unless_null $P4280, vivify_2174
    $P4280 = root_new ['parrot';'ResizablePMCArray']
  vivify_2174:
    $P4281 = $P4280."pop"()
    set $S4282, $P4281
    new $P4283, 'String'
    set $P4283, $S4282
    store_lex "$name", $P4283
.annotate 'line', 1263
    find_dynamic_lex $P4286, "$*PKGDECL"
    unless_null $P4286, vivify_2175
    get_hll_global $P4284, "GLOBAL"
    get_who $P4285, $P4284
    set $P4286, $P4285["$PKGDECL"]
    unless_null $P4286, vivify_2176
    die "Contextual $*PKGDECL not found"
  vivify_2176:
  vivify_2175:
    find_dynamic_lex $P4289, "%*HOW"
    unless_null $P4289, vivify_2177
    get_hll_global $P4287, "GLOBAL"
    get_who $P4288, $P4287
    set $P4289, $P4288["%HOW"]
    unless_null $P4289, vivify_2178
    die "Contextual %*HOW not found"
  vivify_2178:
  vivify_2177:
    set $P4290, $P4289[$P4286]
    unless_null $P4290, vivify_2179
    new $P4290, "Undef"
  vivify_2179:
    store_lex "$how", $P4290
.annotate 'line', 1266
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_2180
    $P4293 = root_new ['parrot';'Hash']
  vivify_2180:
    set $P4294, $P4293["block"]
    unless_null $P4294, vivify_2181
    new $P4294, "Undef"
  vivify_2181:
    if $P4294, if_4292
    find_lex $P4298, "$/"
    unless_null $P4298, vivify_2182
    $P4298 = root_new ['parrot';'Hash']
  vivify_2182:
    set $P4299, $P4298["comp_unit"]
    unless_null $P4299, vivify_2183
    new $P4299, "Undef"
  vivify_2183:
    $P4300 = $P4299."ast"()
    set $P4291, $P4300
    goto if_4292_end
  if_4292:
    find_lex $P4295, "$/"
    unless_null $P4295, vivify_2184
    $P4295 = root_new ['parrot';'Hash']
  vivify_2184:
    set $P4296, $P4295["block"]
    unless_null $P4296, vivify_2185
    new $P4296, "Undef"
  vivify_2185:
    $P4297 = $P4296."ast"()
    set $P4291, $P4297
  if_4292_end:
    store_lex "$past", $P4291
.annotate 'line', 1267
    find_dynamic_lex $P4306, "$*SCOPE"
    unless_null $P4306, vivify_2186
    get_hll_global $P4304, "GLOBAL"
    get_who $P4305, $P4304
    set $P4306, $P4305["$SCOPE"]
    unless_null $P4306, vivify_2187
    die "Contextual $*SCOPE not found"
  vivify_2187:
  vivify_2186:
    set $S4307, $P4306
    iseq $I4308, $S4307, "our"
    unless $I4308, unless_4303
    new $P4302, 'Integer'
    set $P4302, $I4308
    goto unless_4303_end
  unless_4303:
    find_dynamic_lex $P4311, "$*SCOPE"
    unless_null $P4311, vivify_2188
    get_hll_global $P4309, "GLOBAL"
    get_who $P4310, $P4309
    set $P4311, $P4310["$SCOPE"]
    unless_null $P4311, vivify_2189
    die "Contextual $*SCOPE not found"
  vivify_2189:
  vivify_2188:
    set $S4312, $P4311
    iseq $I4313, $S4312, ""
    new $P4302, 'Integer'
    set $P4302, $I4313
  unless_4303_end:
    unless $P4302, if_4301_end
.annotate 'line', 1268
    find_lex $P4314, "$past"
    unless_null $P4314, vivify_2190
    new $P4314, "Undef"
  vivify_2190:
    find_lex $P4315, "$/"
    unless_null $P4315, vivify_2191
    $P4315 = root_new ['parrot';'Hash']
  vivify_2191:
    set $P4316, $P4315["name"]
    unless_null $P4316, vivify_2192
    $P4316 = root_new ['parrot';'Hash']
  vivify_2192:
    set $P4317, $P4316["identifier"]
    unless_null $P4317, vivify_2193
    new $P4317, "Undef"
  vivify_2193:
    $P4314."namespace"($P4317)
  if_4301_end:
.annotate 'line', 1272
    find_dynamic_lex $P4320, "$*PACKAGE-SETUP"
    unless_null $P4320, vivify_2194
    get_hll_global $P4318, "GLOBAL"
    get_who $P4319, $P4318
    set $P4320, $P4319["$PACKAGE-SETUP"]
    unless_null $P4320, vivify_2195
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2195:
  vivify_2194:
    get_hll_global $P4321, "GLOBAL"
    nqp_get_package_through_who $P4322, $P4321, "PAST"
    get_who $P4323, $P4322
    set $P4324, $P4323["Stmts"]
.annotate 'line', 1273
    get_hll_global $P4325, "GLOBAL"
    nqp_get_package_through_who $P4326, $P4325, "PAST"
    get_who $P4327, $P4326
    set $P4328, $P4327["Op"]
.annotate 'line', 1274
    get_hll_global $P4329, "GLOBAL"
    nqp_get_package_through_who $P4330, $P4329, "PAST"
    get_who $P4331, $P4330
    set $P4332, $P4331["Var"]
    $P4333 = $P4332."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1275
    find_dynamic_lex $P4336, "$*SC"
    unless_null $P4336, vivify_2196
    get_hll_global $P4334, "GLOBAL"
    get_who $P4335, $P4334
    set $P4336, $P4335["$SC"]
    unless_null $P4336, vivify_2197
    die "Contextual $*SC not found"
  vivify_2197:
  vivify_2196:
    find_dynamic_lex $P4339, "$*PACKAGE"
    unless_null $P4339, vivify_2198
    get_hll_global $P4337, "GLOBAL"
    get_who $P4338, $P4337
    set $P4339, $P4338["$PACKAGE"]
    unless_null $P4339, vivify_2199
    die "Contextual $*PACKAGE not found"
  vivify_2199:
  vivify_2198:
    $P4340 = $P4336."get_slot_past_for_object"($P4339)
    $P4341 = $P4328."new"($P4333, $P4340, "bind" :named("pasttype"))
.annotate 'line', 1273
    $P4342 = $P4324."new"($P4341)
.annotate 'line', 1272
    $P4320."unshift"($P4342)
.annotate 'line', 1283
    find_lex $P4346, "$how"
    unless_null $P4346, vivify_2200
    new $P4346, "Undef"
  vivify_2200:
    can $I4347, $P4346, "parametric"
    if $I4347, if_4345
    new $P4344, 'Integer'
    set $P4344, $I4347
    goto if_4345_end
  if_4345:
    find_lex $P4348, "$how"
    unless_null $P4348, vivify_2201
    new $P4348, "Undef"
  vivify_2201:
    find_lex $P4349, "$how"
    unless_null $P4349, vivify_2202
    new $P4349, "Undef"
  vivify_2202:
    $P4350 = $P4348."parametric"($P4349)
    set $P4344, $P4350
  if_4345_end:
    if $P4344, if_4343
.annotate 'line', 1301
    find_lex $P4402, "$past"
    unless_null $P4402, vivify_2203
    new $P4402, "Undef"
  vivify_2203:
    $P4402."blocktype"("immediate")
.annotate 'line', 1302
    find_dynamic_lex $P4405, "$*SC"
    unless_null $P4405, vivify_2204
    get_hll_global $P4403, "GLOBAL"
    get_who $P4404, $P4403
    set $P4405, $P4404["$SC"]
    unless_null $P4405, vivify_2205
    die "Contextual $*SC not found"
  vivify_2205:
  vivify_2204:
    find_lex $P4406, "$past"
    unless_null $P4406, vivify_2206
    new $P4406, "Undef"
  vivify_2206:
    find_dynamic_lex $P4409, "$*PACKAGE"
    unless_null $P4409, vivify_2207
    get_hll_global $P4407, "GLOBAL"
    get_who $P4408, $P4407
    set $P4409, $P4408["$PACKAGE"]
    unless_null $P4409, vivify_2208
    die "Contextual $*PACKAGE not found"
  vivify_2208:
  vivify_2207:
    $P4405."install_lexical_symbol"($P4406, "$?PACKAGE", $P4409)
.annotate 'line', 1303
    find_dynamic_lex $P4412, "$*SC"
    unless_null $P4412, vivify_2209
    get_hll_global $P4410, "GLOBAL"
    get_who $P4411, $P4410
    set $P4412, $P4411["$SC"]
    unless_null $P4412, vivify_2210
    die "Contextual $*SC not found"
  vivify_2210:
  vivify_2209:
    find_lex $P4413, "$past"
    unless_null $P4413, vivify_2211
    new $P4413, "Undef"
  vivify_2211:
    find_dynamic_lex $P4416, "$*PACKAGE"
    unless_null $P4416, vivify_2212
    get_hll_global $P4414, "GLOBAL"
    get_who $P4415, $P4414
    set $P4416, $P4415["$PACKAGE"]
    unless_null $P4416, vivify_2213
    die "Contextual $*PACKAGE not found"
  vivify_2213:
  vivify_2212:
    $P4412."install_lexical_symbol"($P4413, "$?CLASS", $P4416)
.annotate 'line', 1300
    goto if_4343_end
  if_4343:
.annotate 'line', 1284
    find_lex $P4351, "$past"
    unless_null $P4351, vivify_2214
    new $P4351, "Undef"
  vivify_2214:
    $P4351."blocktype"("declaration")
.annotate 'line', 1285
    find_lex $P4352, "$past"
    unless_null $P4352, vivify_2215
    new $P4352, "Undef"
  vivify_2215:
    get_hll_global $P4353, "GLOBAL"
    nqp_get_package_through_who $P4354, $P4353, "PAST"
    get_who $P4355, $P4354
    set $P4356, $P4355["Var"]
    $P4357 = $P4356."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4352."unshift"($P4357)
.annotate 'line', 1286
    find_lex $P4358, "$past"
    unless_null $P4358, vivify_2216
    new $P4358, "Undef"
  vivify_2216:
    $P4358."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1287
    find_dynamic_lex $P4361, "$*PACKAGE-SETUP"
    unless_null $P4361, vivify_2217
    get_hll_global $P4359, "GLOBAL"
    get_who $P4360, $P4359
    set $P4361, $P4360["$PACKAGE-SETUP"]
    unless_null $P4361, vivify_2218
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2218:
  vivify_2217:
    get_hll_global $P4362, "GLOBAL"
    nqp_get_package_through_who $P4363, $P4362, "PAST"
    get_who $P4364, $P4363
    set $P4365, $P4364["Op"]
.annotate 'line', 1289
    get_hll_global $P4366, "GLOBAL"
    nqp_get_package_through_who $P4367, $P4366, "PAST"
    get_who $P4368, $P4367
    set $P4369, $P4368["Op"]
.annotate 'line', 1292
    get_hll_global $P4370, "GLOBAL"
    nqp_get_package_through_who $P4371, $P4370, "PAST"
    get_who $P4372, $P4371
    set $P4373, $P4372["Var"]
    $P4374 = $P4373."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4375 = $P4369."new"($P4374, "get_how PP" :named("pirop"))
.annotate 'line', 1294
    get_hll_global $P4376, "GLOBAL"
    nqp_get_package_through_who $P4377, $P4376, "PAST"
    get_who $P4378, $P4377
    set $P4379, $P4378["Var"]
    $P4380 = $P4379."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1295
    get_hll_global $P4381, "GLOBAL"
    nqp_get_package_through_who $P4382, $P4381, "PAST"
    get_who $P4383, $P4382
    set $P4384, $P4383["Val"]
    find_lex $P4385, "$past"
    unless_null $P4385, vivify_2219
    new $P4385, "Undef"
  vivify_2219:
    $P4386 = $P4384."new"($P4385 :named("value"))
    $P4387 = $P4365."new"($P4375, $P4380, $P4386, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1287
    $P4361."push"($P4387)
.annotate 'line', 1297
    find_dynamic_lex $P4390, "$*SC"
    unless_null $P4390, vivify_2220
    get_hll_global $P4388, "GLOBAL"
    get_who $P4389, $P4388
    set $P4390, $P4389["$SC"]
    unless_null $P4390, vivify_2221
    die "Contextual $*SC not found"
  vivify_2221:
  vivify_2220:
    find_lex $P4391, "$past"
    unless_null $P4391, vivify_2222
    new $P4391, "Undef"
  vivify_2222:
    find_dynamic_lex $P4394, "$*PACKAGE"
    unless_null $P4394, vivify_2223
    get_hll_global $P4392, "GLOBAL"
    get_who $P4393, $P4392
    set $P4394, $P4393["$PACKAGE"]
    unless_null $P4394, vivify_2224
    die "Contextual $*PACKAGE not found"
  vivify_2224:
  vivify_2223:
    $P4390."install_lexical_symbol"($P4391, "$?PACKAGE", $P4394)
.annotate 'line', 1298
    find_dynamic_lex $P4397, "$*SC"
    unless_null $P4397, vivify_2225
    get_hll_global $P4395, "GLOBAL"
    get_who $P4396, $P4395
    set $P4397, $P4396["$SC"]
    unless_null $P4397, vivify_2226
    die "Contextual $*SC not found"
  vivify_2226:
  vivify_2225:
    find_lex $P4398, "$past"
    unless_null $P4398, vivify_2227
    new $P4398, "Undef"
  vivify_2227:
    find_dynamic_lex $P4401, "$*PACKAGE"
    unless_null $P4401, vivify_2228
    get_hll_global $P4399, "GLOBAL"
    get_who $P4400, $P4399
    set $P4401, $P4400["$PACKAGE"]
    unless_null $P4401, vivify_2229
    die "Contextual $*PACKAGE not found"
  vivify_2229:
  vivify_2228:
    $P4397."install_lexical_symbol"($P4398, "$?ROLE", $P4401)
  if_4343_end:
.annotate 'line', 1307
    find_lex $P4418, "$/"
    unless_null $P4418, vivify_2230
    $P4418 = root_new ['parrot';'Hash']
  vivify_2230:
    set $P4419, $P4418["parent"]
    unless_null $P4419, vivify_2231
    new $P4419, "Undef"
  vivify_2231:
    if $P4419, if_4417
.annotate 'line', 1321
    find_lex $P4465, "$how"
    unless_null $P4465, vivify_2232
    new $P4465, "Undef"
  vivify_2232:
    can $I4466, $P4465, "set_default_parent"
    unless $I4466, if_4464_end
    .const 'Sub' $P4468 = "668_1304282286.73" 
    capture_lex $P4468
    $P4468()
  if_4464_end:
    goto if_4417_end
  if_4417:
.annotate 'line', 1307
    .const 'Sub' $P4421 = "666_1304282286.73" 
    capture_lex $P4421
    $P4421()
  if_4417_end:
.annotate 'line', 1328
    find_lex $P4490, "$/"
    unless_null $P4490, vivify_2258
    $P4490 = root_new ['parrot';'Hash']
  vivify_2258:
    set $P4491, $P4490["role"]
    unless_null $P4491, vivify_2259
    new $P4491, "Undef"
  vivify_2259:
    unless $P4491, if_4489_end
.annotate 'line', 1329
    find_lex $P4493, "$/"
    unless_null $P4493, vivify_2260
    $P4493 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P4494, $P4493["role"]
    unless_null $P4494, vivify_2261
    new $P4494, "Undef"
  vivify_2261:
    defined $I4495, $P4494
    unless $I4495, for_undef_2262
    iter $P4492, $P4494
    new $P4539, 'ExceptionHandler'
    set_label $P4539, loop4538_handler
    $P4539."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4539
  loop4538_test:
    unless $P4492, loop4538_done
    shift $P4496, $P4492
  loop4538_redo:
    .const 'Sub' $P4498 = "669_1304282286.73" 
    capture_lex $P4498
    $P4498($P4496)
  loop4538_next:
    goto loop4538_test
  loop4538_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4540, exception, 'type'
    eq $P4540, .CONTROL_LOOP_NEXT, loop4538_next
    eq $P4540, .CONTROL_LOOP_REDO, loop4538_redo
  loop4538_done:
    pop_eh 
  for_undef_2262:
  if_4489_end:
.annotate 'line', 1346
    find_dynamic_lex $P4543, "$*PACKAGE-SETUP"
    unless_null $P4543, vivify_2276
    get_hll_global $P4541, "GLOBAL"
    get_who $P4542, $P4541
    set $P4543, $P4542["$PACKAGE-SETUP"]
    unless_null $P4543, vivify_2277
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2277:
  vivify_2276:
    get_hll_global $P4544, "GLOBAL"
    nqp_get_package_through_who $P4545, $P4544, "PAST"
    get_who $P4546, $P4545
    set $P4547, $P4546["Op"]
.annotate 'line', 1348
    get_hll_global $P4548, "GLOBAL"
    nqp_get_package_through_who $P4549, $P4548, "PAST"
    get_who $P4550, $P4549
    set $P4551, $P4550["Op"]
.annotate 'line', 1351
    get_hll_global $P4552, "GLOBAL"
    nqp_get_package_through_who $P4553, $P4552, "PAST"
    get_who $P4554, $P4553
    set $P4555, $P4554["Var"]
    $P4556 = $P4555."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4557 = $P4551."new"($P4556, "get_how PP" :named("pirop"))
.annotate 'line', 1353
    get_hll_global $P4558, "GLOBAL"
    nqp_get_package_through_who $P4559, $P4558, "PAST"
    get_who $P4560, $P4559
    set $P4561, $P4560["Var"]
    $P4562 = $P4561."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4563 = $P4547."new"($P4557, $P4562, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1346
    $P4543."push"($P4563)
.annotate 'line', 1357
    find_lex $P4564, "$past"
    unless_null $P4564, vivify_2278
    new $P4564, "Undef"
  vivify_2278:
    $P4565 = $P4564."loadinit"()
    get_hll_global $P4566, "GLOBAL"
    nqp_get_package_through_who $P4567, $P4566, "PAST"
    get_who $P4568, $P4567
    set $P4569, $P4568["Block"]
    find_dynamic_lex $P4572, "$*PACKAGE-SETUP"
    unless_null $P4572, vivify_2279
    get_hll_global $P4570, "GLOBAL"
    get_who $P4571, $P4570
    set $P4572, $P4571["$PACKAGE-SETUP"]
    unless_null $P4572, vivify_2280
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2280:
  vivify_2279:
    $P4573 = $P4569."new"($P4572, "immediate" :named("blocktype"))
    $P4565."push"($P4573)
.annotate 'line', 1359
    find_lex $P4574, "$/"
    find_lex $P4575, "$past"
    unless_null $P4575, vivify_2281
    new $P4575, "Undef"
  vivify_2281:
    $P4576 = $P4574."!make"($P4575)
.annotate 'line', 1259
    .return ($P4576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4467"  :anon :subid("668_1304282286.73") :outer("665_1304282286.73")
.annotate 'line', 1322
    new $P4469, "Undef"
    .lex "$default", $P4469
    find_dynamic_lex $P4474, "$*PKGDECL"
    unless_null $P4474, vivify_2233
    get_hll_global $P4472, "GLOBAL"
    get_who $P4473, $P4472
    set $P4474, $P4473["$PKGDECL"]
    unless_null $P4474, vivify_2234
    die "Contextual $*PKGDECL not found"
  vivify_2234:
  vivify_2233:
    set $S4475, $P4474
    iseq $I4476, $S4475, "grammar"
    if $I4476, if_4471
    new $P4478, "ResizablePMCArray"
    push $P4478, "NQPMu"
    set $P4470, $P4478
    goto if_4471_end
  if_4471:
    new $P4477, "ResizablePMCArray"
    push $P4477, "Regex"
    push $P4477, "Cursor"
    set $P4470, $P4477
  if_4471_end:
    store_lex "$default", $P4470
.annotate 'line', 1323
    find_dynamic_lex $P4481, "$*SC"
    unless_null $P4481, vivify_2235
    get_hll_global $P4479, "GLOBAL"
    get_who $P4480, $P4479
    set $P4481, $P4480["$SC"]
    unless_null $P4481, vivify_2236
    die "Contextual $*SC not found"
  vivify_2236:
  vivify_2235:
    find_dynamic_lex $P4484, "$*PACKAGE"
    unless_null $P4484, vivify_2237
    get_hll_global $P4482, "GLOBAL"
    get_who $P4483, $P4482
    set $P4484, $P4483["$PACKAGE"]
    unless_null $P4484, vivify_2238
    die "Contextual $*PACKAGE not found"
  vivify_2238:
  vivify_2237:
.annotate 'line', 1324
    find_lex $P4485, "$default"
    unless_null $P4485, vivify_2239
    new $P4485, "Undef"
  vivify_2239:
    find_lex $P4486, "$/"
    unless_null $P4486, vivify_2240
    new $P4486, "Undef"
  vivify_2240:
    $P4487 = "find_sym"($P4485, $P4486)
    $P4488 = $P4481."pkg_add_parent_or_role"($P4484, "set_default_parent", $P4487)
.annotate 'line', 1321
    .return ($P4488)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4420"  :anon :subid("666_1304282286.73") :outer("665_1304282286.73")
.annotate 'line', 1307
    .const 'Sub' $P4427 = "667_1304282286.73" 
    capture_lex $P4427
.annotate 'line', 1308
    new $P4422, "Undef"
    .lex "$parent", $P4422
.annotate 'line', 1309
    new $P4423, "Undef"
    .lex "$parent_found", $P4423
.annotate 'line', 1307
    find_lex $P4424, "$parent"
    unless_null $P4424, vivify_2241
    new $P4424, "Undef"
  vivify_2241:
    find_lex $P4425, "$parent_found"
    unless_null $P4425, vivify_2242
    new $P4425, "Undef"
  vivify_2242:
.annotate 'line', 1310
    .const 'Sub' $P4427 = "667_1304282286.73" 
    capture_lex $P4427
    $P4427()
.annotate 'line', 1314
    find_lex $P4445, "$parent_found"
    unless_null $P4445, vivify_2248
    new $P4445, "Undef"
  vivify_2248:
    if $P4445, if_4444
.annotate 'line', 1318
    find_lex $P4454, "$/"
    unless_null $P4454, vivify_2249
    new $P4454, "Undef"
  vivify_2249:
    $P4455 = $P4454."CURSOR"()
    new $P4456, "String"
    assign $P4456, "Could not find parent class '"
    find_lex $P4457, "$/"
    unless_null $P4457, vivify_2250
    $P4457 = root_new ['parrot';'Hash']
  vivify_2250:
    set $P4458, $P4457["parent"]
    unless_null $P4458, vivify_2251
    $P4458 = root_new ['parrot';'ResizablePMCArray']
  vivify_2251:
    set $P4459, $P4458[0]
    unless_null $P4459, vivify_2252
    new $P4459, "Undef"
  vivify_2252:
    set $S4460, $P4459
    concat $P4461, $P4456, $S4460
    concat $P4462, $P4461, "'"
    $P4463 = $P4455."panic"($P4462)
.annotate 'line', 1317
    set $P4443, $P4463
.annotate 'line', 1314
    goto if_4444_end
  if_4444:
.annotate 'line', 1315
    find_dynamic_lex $P4448, "$*SC"
    unless_null $P4448, vivify_2253
    get_hll_global $P4446, "GLOBAL"
    get_who $P4447, $P4446
    set $P4448, $P4447["$SC"]
    unless_null $P4448, vivify_2254
    die "Contextual $*SC not found"
  vivify_2254:
  vivify_2253:
    find_dynamic_lex $P4451, "$*PACKAGE"
    unless_null $P4451, vivify_2255
    get_hll_global $P4449, "GLOBAL"
    get_who $P4450, $P4449
    set $P4451, $P4450["$PACKAGE"]
    unless_null $P4451, vivify_2256
    die "Contextual $*PACKAGE not found"
  vivify_2256:
  vivify_2255:
    find_lex $P4452, "$parent"
    unless_null $P4452, vivify_2257
    new $P4452, "Undef"
  vivify_2257:
    $P4453 = $P4448."pkg_add_parent_or_role"($P4451, "add_parent", $P4452)
.annotate 'line', 1314
    set $P4443, $P4453
  if_4444_end:
.annotate 'line', 1307
    .return ($P4443)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4426"  :anon :subid("667_1304282286.73") :outer("666_1304282286.73")
.annotate 'line', 1310
    new $P4438, 'ExceptionHandler'
    set_label $P4438, control_4437
    $P4438."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4438
.annotate 'line', 1311
    find_lex $P4428, "$/"
    unless_null $P4428, vivify_2243
    $P4428 = root_new ['parrot';'Hash']
  vivify_2243:
    set $P4429, $P4428["parent"]
    unless_null $P4429, vivify_2244
    $P4429 = root_new ['parrot';'ResizablePMCArray']
  vivify_2244:
    set $P4430, $P4429[0]
    unless_null $P4430, vivify_2245
    $P4430 = root_new ['parrot';'Hash']
  vivify_2245:
    set $P4431, $P4430["identifier"]
    unless_null $P4431, vivify_2246
    new $P4431, "Undef"
  vivify_2246:
    clone $P4432, $P4431
    find_lex $P4433, "$/"
    unless_null $P4433, vivify_2247
    new $P4433, "Undef"
  vivify_2247:
    $P4434 = "find_sym"($P4432, $P4433)
    store_lex "$parent", $P4434
.annotate 'line', 1312
    new $P4435, "Integer"
    assign $P4435, 1
    store_lex "$parent_found", $P4435
.annotate 'line', 1310
    pop_eh 
    goto skip_handler_4436
  control_4437:
    .local pmc exception 
    .get_results (exception) 
    new $P4441, 'Integer'
    set $P4441, 1
    set exception["handled"], $P4441
    set $I4442, exception["handled"]
    ne $I4442, 1, nothandled_4440
  handled_4439:
    .return (exception)
  nothandled_4440:
    rethrow exception
  skip_handler_4436:
    .return ($P4435)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4497"  :anon :subid("669_1304282286.73") :outer("665_1304282286.73")
    .param pmc param_4501
.annotate 'line', 1329
    .const 'Sub' $P4505 = "670_1304282286.73" 
    capture_lex $P4505
.annotate 'line', 1330
    new $P4499, "Undef"
    .lex "$role", $P4499
.annotate 'line', 1331
    new $P4500, "Undef"
    .lex "$role_found", $P4500
    .lex "$_", param_4501
.annotate 'line', 1329
    find_lex $P4502, "$role"
    unless_null $P4502, vivify_2263
    new $P4502, "Undef"
  vivify_2263:
    find_lex $P4503, "$role_found"
    unless_null $P4503, vivify_2264
    new $P4503, "Undef"
  vivify_2264:
.annotate 'line', 1332
    .const 'Sub' $P4505 = "670_1304282286.73" 
    capture_lex $P4505
    $P4505()
.annotate 'line', 1336
    find_lex $P4521, "$role_found"
    unless_null $P4521, vivify_2268
    new $P4521, "Undef"
  vivify_2268:
    if $P4521, if_4520
.annotate 'line', 1340
    find_lex $P4530, "$/"
    unless_null $P4530, vivify_2269
    new $P4530, "Undef"
  vivify_2269:
    $P4531 = $P4530."CURSOR"()
    new $P4532, "String"
    assign $P4532, "Could not find role '"
    find_lex $P4533, "$_"
    unless_null $P4533, vivify_2270
    new $P4533, "Undef"
  vivify_2270:
    set $S4534, $P4533
    concat $P4535, $P4532, $S4534
    concat $P4536, $P4535, "'"
    $P4537 = $P4531."panic"($P4536)
.annotate 'line', 1339
    set $P4519, $P4537
.annotate 'line', 1336
    goto if_4520_end
  if_4520:
.annotate 'line', 1337
    find_dynamic_lex $P4524, "$*SC"
    unless_null $P4524, vivify_2271
    get_hll_global $P4522, "GLOBAL"
    get_who $P4523, $P4522
    set $P4524, $P4523["$SC"]
    unless_null $P4524, vivify_2272
    die "Contextual $*SC not found"
  vivify_2272:
  vivify_2271:
    find_dynamic_lex $P4527, "$*PACKAGE"
    unless_null $P4527, vivify_2273
    get_hll_global $P4525, "GLOBAL"
    get_who $P4526, $P4525
    set $P4527, $P4526["$PACKAGE"]
    unless_null $P4527, vivify_2274
    die "Contextual $*PACKAGE not found"
  vivify_2274:
  vivify_2273:
    find_lex $P4528, "$role"
    unless_null $P4528, vivify_2275
    new $P4528, "Undef"
  vivify_2275:
    $P4529 = $P4524."pkg_add_parent_or_role"($P4527, "add_role", $P4528)
.annotate 'line', 1336
    set $P4519, $P4529
  if_4520_end:
.annotate 'line', 1329
    .return ($P4519)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4504"  :anon :subid("670_1304282286.73") :outer("669_1304282286.73")
.annotate 'line', 1332
    new $P4514, 'ExceptionHandler'
    set_label $P4514, control_4513
    $P4514."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4514
.annotate 'line', 1333
    find_lex $P4506, "$_"
    unless_null $P4506, vivify_2265
    $P4506 = root_new ['parrot';'Hash']
  vivify_2265:
    set $P4507, $P4506["identifier"]
    unless_null $P4507, vivify_2266
    new $P4507, "Undef"
  vivify_2266:
    clone $P4508, $P4507
    find_lex $P4509, "$/"
    unless_null $P4509, vivify_2267
    new $P4509, "Undef"
  vivify_2267:
    $P4510 = "find_sym"($P4508, $P4509)
    store_lex "$role", $P4510
.annotate 'line', 1334
    new $P4511, "Integer"
    assign $P4511, 1
    store_lex "$role_found", $P4511
.annotate 'line', 1332
    pop_eh 
    goto skip_handler_4512
  control_4513:
    .local pmc exception 
    .get_results (exception) 
    new $P4517, 'Integer'
    set $P4517, 1
    set exception["handled"], $P4517
    set $I4518, exception["handled"]
    ne $I4518, 1, nothandled_4516
  handled_4515:
    .return (exception)
  nothandled_4516:
    rethrow exception
  skip_handler_4512:
    .return ($P4511)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("671_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4578
    .param pmc param_4579
.annotate 'line', 1362
    .lex "self", param_4578
    .lex "$/", param_4579
    find_lex $P4580, "$/"
    find_lex $P4581, "$/"
    unless_null $P4581, vivify_2282
    $P4581 = root_new ['parrot';'Hash']
  vivify_2282:
    set $P4582, $P4581["scoped"]
    unless_null $P4582, vivify_2283
    new $P4582, "Undef"
  vivify_2283:
    $P4583 = $P4582."ast"()
    $P4584 = $P4580."!make"($P4583)
    .return ($P4584)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("672_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4586
    .param pmc param_4587
.annotate 'line', 1363
    .lex "self", param_4586
    .lex "$/", param_4587
    find_lex $P4588, "$/"
    find_lex $P4589, "$/"
    unless_null $P4589, vivify_2284
    $P4589 = root_new ['parrot';'Hash']
  vivify_2284:
    set $P4590, $P4589["scoped"]
    unless_null $P4590, vivify_2285
    new $P4590, "Undef"
  vivify_2285:
    $P4591 = $P4590."ast"()
    $P4592 = $P4588."!make"($P4591)
    .return ($P4592)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("673_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4594
    .param pmc param_4595
.annotate 'line', 1364
    .lex "self", param_4594
    .lex "$/", param_4595
    find_lex $P4596, "$/"
    find_lex $P4597, "$/"
    unless_null $P4597, vivify_2286
    $P4597 = root_new ['parrot';'Hash']
  vivify_2286:
    set $P4598, $P4597["scoped"]
    unless_null $P4598, vivify_2287
    new $P4598, "Undef"
  vivify_2287:
    $P4599 = $P4598."ast"()
    $P4600 = $P4596."!make"($P4599)
    .return ($P4600)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("674_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4602
    .param pmc param_4603
.annotate 'line', 1366
    .lex "self", param_4602
    .lex "$/", param_4603
.annotate 'line', 1367
    find_lex $P4604, "$/"
    find_lex $P4607, "$/"
    unless_null $P4607, vivify_2288
    $P4607 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P4608, $P4607["declarator"]
    unless_null $P4608, vivify_2289
    new $P4608, "Undef"
  vivify_2289:
    if $P4608, if_4606
.annotate 'line', 1368
    find_lex $P4614, "$/"
    unless_null $P4614, vivify_2290
    $P4614 = root_new ['parrot';'Hash']
  vivify_2290:
    set $P4615, $P4614["multi_declarator"]
    unless_null $P4615, vivify_2291
    new $P4615, "Undef"
  vivify_2291:
    if $P4615, if_4613
.annotate 'line', 1369
    find_lex $P4619, "$/"
    unless_null $P4619, vivify_2292
    $P4619 = root_new ['parrot';'Hash']
  vivify_2292:
    set $P4620, $P4619["package_declarator"]
    unless_null $P4620, vivify_2293
    new $P4620, "Undef"
  vivify_2293:
    $P4621 = $P4620."ast"()
    set $P4612, $P4621
.annotate 'line', 1368
    goto if_4613_end
  if_4613:
    find_lex $P4616, "$/"
    unless_null $P4616, vivify_2294
    $P4616 = root_new ['parrot';'Hash']
  vivify_2294:
    set $P4617, $P4616["multi_declarator"]
    unless_null $P4617, vivify_2295
    new $P4617, "Undef"
  vivify_2295:
    $P4618 = $P4617."ast"()
    set $P4612, $P4618
  if_4613_end:
    set $P4605, $P4612
.annotate 'line', 1367
    goto if_4606_end
  if_4606:
    find_lex $P4609, "$/"
    unless_null $P4609, vivify_2296
    $P4609 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P4610, $P4609["declarator"]
    unless_null $P4610, vivify_2297
    new $P4610, "Undef"
  vivify_2297:
    $P4611 = $P4610."ast"()
    set $P4605, $P4611
  if_4606_end:
    $P4622 = $P4604."!make"($P4605)
.annotate 'line', 1366
    .return ($P4622)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("675_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4624
    .param pmc param_4625
.annotate 'line', 1372
    .lex "self", param_4624
    .lex "$/", param_4625
.annotate 'line', 1373
    find_lex $P4626, "$/"
.annotate 'line', 1374
    find_lex $P4629, "$/"
    unless_null $P4629, vivify_2298
    $P4629 = root_new ['parrot';'Hash']
  vivify_2298:
    set $P4630, $P4629["routine_declarator"]
    unless_null $P4630, vivify_2299
    new $P4630, "Undef"
  vivify_2299:
    if $P4630, if_4628
.annotate 'line', 1375
    find_lex $P4634, "$/"
    unless_null $P4634, vivify_2300
    $P4634 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4635, $P4634["variable_declarator"]
    unless_null $P4635, vivify_2301
    new $P4635, "Undef"
  vivify_2301:
    $P4636 = $P4635."ast"()
    set $P4627, $P4636
.annotate 'line', 1374
    goto if_4628_end
  if_4628:
    find_lex $P4631, "$/"
    unless_null $P4631, vivify_2302
    $P4631 = root_new ['parrot';'Hash']
  vivify_2302:
    set $P4632, $P4631["routine_declarator"]
    unless_null $P4632, vivify_2303
    new $P4632, "Undef"
  vivify_2303:
    $P4633 = $P4632."ast"()
    set $P4627, $P4633
  if_4628_end:
    $P4637 = $P4626."!make"($P4627)
.annotate 'line', 1372
    .return ($P4637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("676_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4639
    .param pmc param_4640
.annotate 'line', 1378
    .lex "self", param_4639
    .lex "$/", param_4640
    find_lex $P4641, "$/"
    find_lex $P4644, "$/"
    unless_null $P4644, vivify_2304
    $P4644 = root_new ['parrot';'Hash']
  vivify_2304:
    set $P4645, $P4644["declarator"]
    unless_null $P4645, vivify_2305
    new $P4645, "Undef"
  vivify_2305:
    if $P4645, if_4643
    find_lex $P4649, "$/"
    unless_null $P4649, vivify_2306
    $P4649 = root_new ['parrot';'Hash']
  vivify_2306:
    set $P4650, $P4649["routine_def"]
    unless_null $P4650, vivify_2307
    new $P4650, "Undef"
  vivify_2307:
    $P4651 = $P4650."ast"()
    set $P4642, $P4651
    goto if_4643_end
  if_4643:
    find_lex $P4646, "$/"
    unless_null $P4646, vivify_2308
    $P4646 = root_new ['parrot';'Hash']
  vivify_2308:
    set $P4647, $P4646["declarator"]
    unless_null $P4647, vivify_2309
    new $P4647, "Undef"
  vivify_2309:
    $P4648 = $P4647."ast"()
    set $P4642, $P4648
  if_4643_end:
    $P4652 = $P4641."!make"($P4642)
    .return ($P4652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("677_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4654
    .param pmc param_4655
.annotate 'line', 1379
    .lex "self", param_4654
    .lex "$/", param_4655
    find_lex $P4656, "$/"
    find_lex $P4659, "$/"
    unless_null $P4659, vivify_2310
    $P4659 = root_new ['parrot';'Hash']
  vivify_2310:
    set $P4660, $P4659["declarator"]
    unless_null $P4660, vivify_2311
    new $P4660, "Undef"
  vivify_2311:
    if $P4660, if_4658
    find_lex $P4664, "$/"
    unless_null $P4664, vivify_2312
    $P4664 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P4665, $P4664["routine_def"]
    unless_null $P4665, vivify_2313
    new $P4665, "Undef"
  vivify_2313:
    $P4666 = $P4665."ast"()
    set $P4657, $P4666
    goto if_4658_end
  if_4658:
    find_lex $P4661, "$/"
    unless_null $P4661, vivify_2314
    $P4661 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P4662, $P4661["declarator"]
    unless_null $P4662, vivify_2315
    new $P4662, "Undef"
  vivify_2315:
    $P4663 = $P4662."ast"()
    set $P4657, $P4663
  if_4658_end:
    $P4667 = $P4656."!make"($P4657)
    .return ($P4667)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("678_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4669
    .param pmc param_4670
.annotate 'line', 1380
    .lex "self", param_4669
    .lex "$/", param_4670
    find_lex $P4671, "$/"
    find_lex $P4672, "$/"
    unless_null $P4672, vivify_2316
    $P4672 = root_new ['parrot';'Hash']
  vivify_2316:
    set $P4673, $P4672["declarator"]
    unless_null $P4673, vivify_2317
    new $P4673, "Undef"
  vivify_2317:
    $P4674 = $P4673."ast"()
    $P4675 = $P4671."!make"($P4674)
    .return ($P4675)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("679_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4677
    .param pmc param_4678
.annotate 'line', 1383
    .const 'Sub' $P4712 = "680_1304282286.73" 
    capture_lex $P4712
    .lex "self", param_4677
    .lex "$/", param_4678
.annotate 'line', 1384
    new $P4679, "Undef"
    .lex "$past", $P4679
.annotate 'line', 1385
    new $P4680, "Undef"
    .lex "$sigil", $P4680
.annotate 'line', 1386
    new $P4681, "Undef"
    .lex "$name", $P4681
.annotate 'line', 1387
    new $P4682, "Undef"
    .lex "$BLOCK", $P4682
.annotate 'line', 1384
    find_lex $P4683, "$/"
    unless_null $P4683, vivify_2318
    $P4683 = root_new ['parrot';'Hash']
  vivify_2318:
    set $P4684, $P4683["variable"]
    unless_null $P4684, vivify_2319
    new $P4684, "Undef"
  vivify_2319:
    $P4685 = $P4684."ast"()
    store_lex "$past", $P4685
.annotate 'line', 1385
    find_lex $P4686, "$/"
    unless_null $P4686, vivify_2320
    $P4686 = root_new ['parrot';'Hash']
  vivify_2320:
    set $P4687, $P4686["variable"]
    unless_null $P4687, vivify_2321
    $P4687 = root_new ['parrot';'Hash']
  vivify_2321:
    set $P4688, $P4687["sigil"]
    unless_null $P4688, vivify_2322
    new $P4688, "Undef"
  vivify_2322:
    store_lex "$sigil", $P4688
.annotate 'line', 1386
    find_lex $P4689, "$past"
    unless_null $P4689, vivify_2323
    new $P4689, "Undef"
  vivify_2323:
    $P4690 = $P4689."name"()
    store_lex "$name", $P4690
.annotate 'line', 1387
    find_lex $P4691, "$?PACKAGE"
    get_who $P4692, $P4691
    set $P4693, $P4692["@BLOCK"]
    unless_null $P4693, vivify_2324
    $P4693 = root_new ['parrot';'ResizablePMCArray']
  vivify_2324:
    set $P4694, $P4693[0]
    unless_null $P4694, vivify_2325
    new $P4694, "Undef"
  vivify_2325:
    store_lex "$BLOCK", $P4694
.annotate 'line', 1388
    find_lex $P4698, "$name"
    unless_null $P4698, vivify_2326
    new $P4698, "Undef"
  vivify_2326:
    if $P4698, if_4697
    set $P4696, $P4698
    goto if_4697_end
  if_4697:
    find_lex $P4699, "$BLOCK"
    unless_null $P4699, vivify_2327
    new $P4699, "Undef"
  vivify_2327:
    find_lex $P4700, "$name"
    unless_null $P4700, vivify_2328
    new $P4700, "Undef"
  vivify_2328:
    $P4701 = $P4699."symbol"($P4700)
    set $P4696, $P4701
  if_4697_end:
    unless $P4696, if_4695_end
.annotate 'line', 1389
    find_lex $P4702, "$/"
    unless_null $P4702, vivify_2329
    new $P4702, "Undef"
  vivify_2329:
    $P4703 = $P4702."CURSOR"()
    find_lex $P4704, "$name"
    unless_null $P4704, vivify_2330
    new $P4704, "Undef"
  vivify_2330:
    $P4703."panic"("Redeclaration of symbol ", $P4704)
  if_4695_end:
.annotate 'line', 1391
    find_dynamic_lex $P4708, "$*SCOPE"
    unless_null $P4708, vivify_2331
    get_hll_global $P4706, "GLOBAL"
    get_who $P4707, $P4706
    set $P4708, $P4707["$SCOPE"]
    unless_null $P4708, vivify_2332
    die "Contextual $*SCOPE not found"
  vivify_2332:
  vivify_2331:
    set $S4709, $P4708
    iseq $I4710, $S4709, "has"
    if $I4710, if_4705
.annotate 'line', 1411
    find_dynamic_lex $P4769, "$*SCOPE"
    unless_null $P4769, vivify_2333
    get_hll_global $P4767, "GLOBAL"
    get_who $P4768, $P4767
    set $P4769, $P4768["$SCOPE"]
    unless_null $P4769, vivify_2334
    die "Contextual $*SCOPE not found"
  vivify_2334:
  vivify_2333:
    set $S4770, $P4769
    iseq $I4771, $S4770, "our"
    if $I4771, if_4766
.annotate 'line', 1421
    find_lex $P4785, "$BLOCK"
    unless_null $P4785, vivify_2335
    $P4785 = root_new ['parrot';'ResizablePMCArray']
  vivify_2335:
    set $P4786, $P4785[0]
    unless_null $P4786, vivify_2336
    new $P4786, "Undef"
  vivify_2336:
    get_hll_global $P4787, "GLOBAL"
    nqp_get_package_through_who $P4788, $P4787, "PAST"
    get_who $P4789, $P4788
    set $P4790, $P4789["Var"]
    find_lex $P4791, "$name"
    unless_null $P4791, vivify_2337
    new $P4791, "Undef"
  vivify_2337:
.annotate 'line', 1423
    find_lex $P4792, "$sigil"
    unless_null $P4792, vivify_2338
    new $P4792, "Undef"
  vivify_2338:
    $P4793 = "vivitype"($P4792)
    find_lex $P4794, "$/"
    unless_null $P4794, vivify_2339
    new $P4794, "Undef"
  vivify_2339:
    $P4795 = $P4790."new"($P4791 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4793 :named("viviself"), $P4794 :named("node"))
.annotate 'line', 1421
    $P4786."push"($P4795)
.annotate 'line', 1426
    find_lex $P4796, "$BLOCK"
    unless_null $P4796, vivify_2340
    new $P4796, "Undef"
  vivify_2340:
    find_lex $P4797, "$name"
    unless_null $P4797, vivify_2341
    new $P4797, "Undef"
  vivify_2341:
    $P4796."symbol"($P4797, "lexical" :named("scope"))
.annotate 'line', 1420
    goto if_4766_end
  if_4766:
.annotate 'line', 1415
    find_lex $P4772, "$/"
    unless_null $P4772, vivify_2342
    $P4772 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P4773, $P4772["variable"]
    unless_null $P4773, vivify_2343
    new $P4773, "Undef"
  vivify_2343:
    set $S4774, $P4773
    new $P4775, 'String'
    set $P4775, $S4774
    store_lex "$name", $P4775
.annotate 'line', 1416
    find_lex $P4776, "$name"
    unless_null $P4776, vivify_2344
    new $P4776, "Undef"
  vivify_2344:
    new $P4777, "ResizablePMCArray"
    push $P4777, $P4776
    find_lex $P4778, "$/"
    unless_null $P4778, vivify_2345
    new $P4778, "Undef"
  vivify_2345:
    $P4779 = "lexical_package_lookup"($P4777, $P4778)
    store_lex "$past", $P4779
.annotate 'line', 1417
    find_lex $P4780, "$past"
    unless_null $P4780, vivify_2346
    new $P4780, "Undef"
  vivify_2346:
    find_lex $P4781, "$sigil"
    unless_null $P4781, vivify_2347
    new $P4781, "Undef"
  vivify_2347:
    $P4782 = "vivitype"($P4781)
    $P4780."viviself"($P4782)
.annotate 'line', 1418
    find_lex $P4783, "$BLOCK"
    unless_null $P4783, vivify_2348
    new $P4783, "Undef"
  vivify_2348:
    find_lex $P4784, "$name"
    unless_null $P4784, vivify_2349
    new $P4784, "Undef"
  vivify_2349:
    $P4783."symbol"($P4784, "package" :named("scope"))
  if_4766_end:
.annotate 'line', 1411
    goto if_4705_end
  if_4705:
.annotate 'line', 1391
    .const 'Sub' $P4712 = "680_1304282286.73" 
    capture_lex $P4712
    $P4712()
  if_4705_end:
.annotate 'line', 1428
    find_lex $P4798, "$/"
    find_lex $P4799, "$past"
    unless_null $P4799, vivify_2379
    new $P4799, "Undef"
  vivify_2379:
    $P4800 = $P4798."!make"($P4799)
.annotate 'line', 1383
    .return ($P4800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4711"  :anon :subid("680_1304282286.73") :outer("679_1304282286.73")
.annotate 'line', 1398
    $P4713 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P4713
.annotate 'line', 1399
    $P4714 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P4714
.annotate 'line', 1393
    find_dynamic_lex $P4721, "$*PKGDECL"
    unless_null $P4721, vivify_2350
    get_hll_global $P4719, "GLOBAL"
    get_who $P4720, $P4719
    set $P4721, $P4720["$PKGDECL"]
    unless_null $P4721, vivify_2351
    die "Contextual $*PKGDECL not found"
  vivify_2351:
  vivify_2350:
    concat $P4722, $P4721, "-attr"
    find_dynamic_lex $P4718, "%*HOW"
    unless_null $P4718, vivify_2352
    get_hll_global $P4716, "GLOBAL"
    get_who $P4717, $P4716
    set $P4718, $P4717["%HOW"]
    unless_null $P4718, vivify_2353
    die "Contextual %*HOW not found"
  vivify_2353:
  vivify_2352:
    exists $I4723, $P4718[$P4722]
    if $I4723, unless_4715_end
.annotate 'line', 1394
    find_lex $P4724, "$/"
    unless_null $P4724, vivify_2354
    new $P4724, "Undef"
  vivify_2354:
    $P4725 = $P4724."CURSOR"()
    find_dynamic_lex $P4728, "$*PKGDECL"
    unless_null $P4728, vivify_2355
    get_hll_global $P4726, "GLOBAL"
    get_who $P4727, $P4726
    set $P4728, $P4727["$PKGDECL"]
    unless_null $P4728, vivify_2356
    die "Contextual $*PKGDECL not found"
  vivify_2356:
  vivify_2355:
    concat $P4729, $P4728, " packages do not support attributes"
    $P4725."panic"($P4729)
  unless_4715_end:
.annotate 'line', 1393
    find_lex $P4730, "%lit_args"
    unless_null $P4730, vivify_2357
    $P4730 = root_new ['parrot';'Hash']
  vivify_2357:
    find_lex $P4731, "%obj_args"
    unless_null $P4731, vivify_2358
    $P4731 = root_new ['parrot';'Hash']
  vivify_2358:
.annotate 'line', 1400
    find_lex $P4732, "$name"
    unless_null $P4732, vivify_2359
    new $P4732, "Undef"
  vivify_2359:
    find_lex $P4733, "%lit_args"
    unless_null $P4733, vivify_2360
    $P4733 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P4733
  vivify_2360:
    set $P4733["name"], $P4732
.annotate 'line', 1401
    find_lex $P4735, "$/"
    unless_null $P4735, vivify_2361
    $P4735 = root_new ['parrot';'Hash']
  vivify_2361:
    set $P4736, $P4735["typename"]
    unless_null $P4736, vivify_2362
    new $P4736, "Undef"
  vivify_2362:
    unless $P4736, if_4734_end
.annotate 'line', 1402
    find_lex $P4737, "$/"
    unless_null $P4737, vivify_2363
    $P4737 = root_new ['parrot';'Hash']
  vivify_2363:
    set $P4738, $P4737["typename"]
    unless_null $P4738, vivify_2364
    $P4738 = root_new ['parrot';'ResizablePMCArray']
  vivify_2364:
    set $P4739, $P4738[0]
    unless_null $P4739, vivify_2365
    new $P4739, "Undef"
  vivify_2365:
    set $S4740, $P4739
    new $P4741, "ResizablePMCArray"
    push $P4741, $S4740
    find_lex $P4742, "$/"
    unless_null $P4742, vivify_2366
    new $P4742, "Undef"
  vivify_2366:
    $P4743 = "find_sym"($P4741, $P4742)
    find_lex $P4744, "%obj_args"
    unless_null $P4744, vivify_2367
    $P4744 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P4744
  vivify_2367:
    set $P4744["type"], $P4743
  if_4734_end:
.annotate 'line', 1406
    find_dynamic_lex $P4747, "$*SC"
    unless_null $P4747, vivify_2368
    get_hll_global $P4745, "GLOBAL"
    get_who $P4746, $P4745
    set $P4747, $P4746["$SC"]
    unless_null $P4747, vivify_2369
    die "Contextual $*SC not found"
  vivify_2369:
  vivify_2368:
    find_dynamic_lex $P4750, "$*PACKAGE"
    unless_null $P4750, vivify_2370
    get_hll_global $P4748, "GLOBAL"
    get_who $P4749, $P4748
    set $P4750, $P4749["$PACKAGE"]
    unless_null $P4750, vivify_2371
    die "Contextual $*PACKAGE not found"
  vivify_2371:
  vivify_2370:
    find_dynamic_lex $P4753, "$*PKGDECL"
    unless_null $P4753, vivify_2372
    get_hll_global $P4751, "GLOBAL"
    get_who $P4752, $P4751
    set $P4753, $P4752["$PKGDECL"]
    unless_null $P4753, vivify_2373
    die "Contextual $*PKGDECL not found"
  vivify_2373:
  vivify_2372:
    concat $P4754, $P4753, "-attr"
    find_dynamic_lex $P4757, "%*HOW"
    unless_null $P4757, vivify_2374
    get_hll_global $P4755, "GLOBAL"
    get_who $P4756, $P4755
    set $P4757, $P4756["%HOW"]
    unless_null $P4757, vivify_2375
    die "Contextual %*HOW not found"
  vivify_2375:
  vivify_2374:
    set $P4758, $P4757[$P4754]
    unless_null $P4758, vivify_2376
    new $P4758, "Undef"
  vivify_2376:
    find_lex $P4759, "%lit_args"
    unless_null $P4759, vivify_2377
    $P4759 = root_new ['parrot';'Hash']
  vivify_2377:
    find_lex $P4760, "%obj_args"
    unless_null $P4760, vivify_2378
    $P4760 = root_new ['parrot';'Hash']
  vivify_2378:
    $P4747."pkg_add_attribute"($P4750, $P4758, $P4759, $P4760)
.annotate 'line', 1409
    get_hll_global $P4761, "GLOBAL"
    nqp_get_package_through_who $P4762, $P4761, "PAST"
    get_who $P4763, $P4762
    set $P4764, $P4763["Stmts"]
    $P4765 = $P4764."new"()
    store_lex "$past", $P4765
.annotate 'line', 1391
    .return ($P4765)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("681_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4802
    .param pmc param_4803
.annotate 'line', 1431
    .lex "self", param_4802
    .lex "$/", param_4803
    find_lex $P4804, "$/"
    find_lex $P4805, "$/"
    unless_null $P4805, vivify_2380
    $P4805 = root_new ['parrot';'Hash']
  vivify_2380:
    set $P4806, $P4805["routine_def"]
    unless_null $P4806, vivify_2381
    new $P4806, "Undef"
  vivify_2381:
    $P4807 = $P4806."ast"()
    $P4808 = $P4804."!make"($P4807)
    .return ($P4808)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("682_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4810
    .param pmc param_4811
.annotate 'line', 1432
    .lex "self", param_4810
    .lex "$/", param_4811
    find_lex $P4812, "$/"
    find_lex $P4813, "$/"
    unless_null $P4813, vivify_2382
    $P4813 = root_new ['parrot';'Hash']
  vivify_2382:
    set $P4814, $P4813["method_def"]
    unless_null $P4814, vivify_2383
    new $P4814, "Undef"
  vivify_2383:
    $P4815 = $P4814."ast"()
    $P4816 = $P4812."!make"($P4815)
    .return ($P4816)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("683_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_4818
    .param pmc param_4819
.annotate 'line', 1434
    .const 'Sub' $P5132 = "689_1304282286.73" 
    capture_lex $P5132
    .const 'Sub' $P4841 = "684_1304282286.73" 
    capture_lex $P4841
    .lex "self", param_4818
    .lex "$/", param_4819
.annotate 'line', 1437
    new $P4820, "Undef"
    .lex "$past", $P4820
.annotate 'line', 1448
    new $P4821, "Undef"
    .lex "$block", $P4821
.annotate 'line', 1434
    find_lex $P4822, "$past"
    unless_null $P4822, vivify_2384
    new $P4822, "Undef"
  vivify_2384:
.annotate 'line', 1438
    find_lex $P4824, "$/"
    unless_null $P4824, vivify_2385
    $P4824 = root_new ['parrot';'Hash']
  vivify_2385:
    set $P4825, $P4824["onlystar"]
    unless_null $P4825, vivify_2386
    new $P4825, "Undef"
  vivify_2386:
    if $P4825, if_4823
.annotate 'line', 1442
    find_lex $P4827, "$/"
    unless_null $P4827, vivify_2387
    $P4827 = root_new ['parrot';'Hash']
  vivify_2387:
    set $P4828, $P4827["blockoid"]
    unless_null $P4828, vivify_2388
    new $P4828, "Undef"
  vivify_2388:
    $P4829 = $P4828."ast"()
    store_lex "$past", $P4829
.annotate 'line', 1443
    find_lex $P4830, "$past"
    unless_null $P4830, vivify_2389
    new $P4830, "Undef"
  vivify_2389:
    $P4830."blocktype"("declaration")
.annotate 'line', 1444
    find_dynamic_lex $P4834, "$*RETURN_USED"
    unless_null $P4834, vivify_2390
    get_hll_global $P4832, "GLOBAL"
    get_who $P4833, $P4832
    set $P4834, $P4833["$RETURN_USED"]
    unless_null $P4834, vivify_2391
    die "Contextual $*RETURN_USED not found"
  vivify_2391:
  vivify_2390:
    unless $P4834, if_4831_end
.annotate 'line', 1445
    find_lex $P4835, "$past"
    unless_null $P4835, vivify_2392
    new $P4835, "Undef"
  vivify_2392:
    $P4835."control"("return_pir")
  if_4831_end:
.annotate 'line', 1441
    goto if_4823_end
  if_4823:
.annotate 'line', 1439
    $P4826 = "only_star_block"()
    store_lex "$past", $P4826
  if_4823_end:
.annotate 'line', 1448
    find_lex $P4836, "$past"
    unless_null $P4836, vivify_2393
    new $P4836, "Undef"
  vivify_2393:
    store_lex "$block", $P4836
.annotate 'line', 1450
    find_lex $P4838, "$/"
    unless_null $P4838, vivify_2394
    $P4838 = root_new ['parrot';'Hash']
  vivify_2394:
    set $P4839, $P4838["deflongname"]
    unless_null $P4839, vivify_2395
    new $P4839, "Undef"
  vivify_2395:
    unless $P4839, if_4837_end
    .const 'Sub' $P4841 = "684_1304282286.73" 
    capture_lex $P4841
    $P4841()
  if_4837_end:
.annotate 'line', 1551
    find_lex $P5121, "$block"
    unless_null $P5121, vivify_2501
    new $P5121, "Undef"
  vivify_2501:
    find_lex $P5122, "$past"
    unless_null $P5122, vivify_2502
    $P5122 = root_new ['parrot';'Hash']
    store_lex "$past", $P5122
  vivify_2502:
    set $P5122["block_past"], $P5121
.annotate 'line', 1552
    find_lex $P5124, "$/"
    unless_null $P5124, vivify_2503
    $P5124 = root_new ['parrot';'Hash']
  vivify_2503:
    set $P5125, $P5124["trait"]
    unless_null $P5125, vivify_2504
    new $P5125, "Undef"
  vivify_2504:
    unless $P5125, if_5123_end
.annotate 'line', 1553
    find_lex $P5127, "$/"
    unless_null $P5127, vivify_2505
    $P5127 = root_new ['parrot';'Hash']
  vivify_2505:
    set $P5128, $P5127["trait"]
    unless_null $P5128, vivify_2506
    new $P5128, "Undef"
  vivify_2506:
    defined $I5129, $P5128
    unless $I5129, for_undef_2507
    iter $P5126, $P5128
    new $P5139, 'ExceptionHandler'
    set_label $P5139, loop5138_handler
    $P5139."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5139
  loop5138_test:
    unless $P5126, loop5138_done
    shift $P5130, $P5126
  loop5138_redo:
    .const 'Sub' $P5132 = "689_1304282286.73" 
    capture_lex $P5132
    $P5132($P5130)
  loop5138_next:
    goto loop5138_test
  loop5138_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5140, exception, 'type'
    eq $P5140, .CONTROL_LOOP_NEXT, loop5138_next
    eq $P5140, .CONTROL_LOOP_REDO, loop5138_redo
  loop5138_done:
    pop_eh 
  for_undef_2507:
  if_5123_end:
.annotate 'line', 1556
    find_lex $P5141, "$/"
    find_lex $P5142, "$past"
    unless_null $P5142, vivify_2510
    new $P5142, "Undef"
  vivify_2510:
    $P5143 = $P5141."!make"($P5142)
.annotate 'line', 1434
    .return ($P5143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4840"  :anon :subid("684_1304282286.73") :outer("683_1304282286.73")
.annotate 'line', 1450
    .const 'Sub' $P4995 = "688_1304282286.73" 
    capture_lex $P4995
    .const 'Sub' $P4882 = "685_1304282286.73" 
    capture_lex $P4882
.annotate 'line', 1451
    new $P4842, "Undef"
    .lex "$name", $P4842
    find_lex $P4843, "$/"
    unless_null $P4843, vivify_2396
    $P4843 = root_new ['parrot';'Hash']
  vivify_2396:
    set $P4844, $P4843["sigil"]
    unless_null $P4844, vivify_2397
    $P4844 = root_new ['parrot';'ResizablePMCArray']
  vivify_2397:
    set $P4845, $P4844[0]
    unless_null $P4845, vivify_2398
    new $P4845, "Undef"
  vivify_2398:
    set $S4846, $P4845
    new $P4847, 'String'
    set $P4847, $S4846
    find_lex $P4848, "$/"
    unless_null $P4848, vivify_2399
    $P4848 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P4849, $P4848["deflongname"]
    unless_null $P4849, vivify_2400
    $P4849 = root_new ['parrot';'ResizablePMCArray']
  vivify_2400:
    set $P4850, $P4849[0]
    unless_null $P4850, vivify_2401
    new $P4850, "Undef"
  vivify_2401:
    $S4851 = $P4850."ast"()
    concat $P4852, $P4847, $S4851
    store_lex "$name", $P4852
.annotate 'line', 1452
    find_lex $P4853, "$past"
    unless_null $P4853, vivify_2402
    new $P4853, "Undef"
  vivify_2402:
    find_lex $P4854, "$name"
    unless_null $P4854, vivify_2403
    new $P4854, "Undef"
  vivify_2403:
    $P4853."name"($P4854)
.annotate 'line', 1453
    find_dynamic_lex $P4862, "$*SCOPE"
    unless_null $P4862, vivify_2404
    get_hll_global $P4860, "GLOBAL"
    get_who $P4861, $P4860
    set $P4862, $P4861["$SCOPE"]
    unless_null $P4862, vivify_2405
    die "Contextual $*SCOPE not found"
  vivify_2405:
  vivify_2404:
    set $S4863, $P4862
    iseq $I4864, $S4863, ""
    unless $I4864, unless_4859
    new $P4858, 'Integer'
    set $P4858, $I4864
    goto unless_4859_end
  unless_4859:
    find_dynamic_lex $P4867, "$*SCOPE"
    unless_null $P4867, vivify_2406
    get_hll_global $P4865, "GLOBAL"
    get_who $P4866, $P4865
    set $P4867, $P4866["$SCOPE"]
    unless_null $P4867, vivify_2407
    die "Contextual $*SCOPE not found"
  vivify_2407:
  vivify_2406:
    set $S4868, $P4867
    iseq $I4869, $S4868, "my"
    new $P4858, 'Integer'
    set $P4858, $I4869
  unless_4859_end:
    unless $P4858, unless_4857
    set $P4856, $P4858
    goto unless_4857_end
  unless_4857:
    find_dynamic_lex $P4872, "$*SCOPE"
    unless_null $P4872, vivify_2408
    get_hll_global $P4870, "GLOBAL"
    get_who $P4871, $P4870
    set $P4872, $P4871["$SCOPE"]
    unless_null $P4872, vivify_2409
    die "Contextual $*SCOPE not found"
  vivify_2409:
  vivify_2408:
    set $S4873, $P4872
    iseq $I4874, $S4873, "our"
    new $P4856, 'Integer'
    set $P4856, $I4874
  unless_4857_end:
    if $P4856, if_4855
.annotate 'line', 1541
    find_lex $P5102, "$/"
    unless_null $P5102, vivify_2410
    new $P5102, "Undef"
  vivify_2410:
    $P5103 = $P5102."CURSOR"()
    find_dynamic_lex $P5106, "$*SCOPE"
    unless_null $P5106, vivify_2411
    get_hll_global $P5104, "GLOBAL"
    get_who $P5105, $P5104
    set $P5106, $P5105["$SCOPE"]
    unless_null $P5106, vivify_2412
    die "Contextual $*SCOPE not found"
  vivify_2412:
  vivify_2411:
    concat $P5107, $P5106, " scoped routines are not supported yet"
    $P5103."panic"($P5107)
.annotate 'line', 1540
    goto if_4855_end
  if_4855:
.annotate 'line', 1454
    find_dynamic_lex $P4878, "$*MULTINESS"
    unless_null $P4878, vivify_2413
    get_hll_global $P4876, "GLOBAL"
    get_who $P4877, $P4876
    set $P4878, $P4877["$MULTINESS"]
    unless_null $P4878, vivify_2414
    die "Contextual $*MULTINESS not found"
  vivify_2414:
  vivify_2413:
    set $S4879, $P4878
    iseq $I4880, $S4879, "multi"
    if $I4880, if_4875
.annotate 'line', 1505
    find_dynamic_lex $P4991, "$*MULTINESS"
    unless_null $P4991, vivify_2415
    get_hll_global $P4989, "GLOBAL"
    get_who $P4990, $P4989
    set $P4991, $P4990["$MULTINESS"]
    unless_null $P4991, vivify_2416
    die "Contextual $*MULTINESS not found"
  vivify_2416:
  vivify_2415:
    set $S4992, $P4991
    iseq $I4993, $S4992, "proto"
    if $I4993, if_4988
.annotate 'line', 1524
    find_lex $P5045, "$?PACKAGE"
    get_who $P5046, $P5045
    set $P5047, $P5046["@BLOCK"]
    unless_null $P5047, vivify_2417
    $P5047 = root_new ['parrot';'ResizablePMCArray']
  vivify_2417:
    set $P5048, $P5047[0]
    unless_null $P5048, vivify_2418
    $P5048 = root_new ['parrot';'ResizablePMCArray']
  vivify_2418:
    set $P5049, $P5048[0]
    unless_null $P5049, vivify_2419
    new $P5049, "Undef"
  vivify_2419:
    get_hll_global $P5050, "GLOBAL"
    nqp_get_package_through_who $P5051, $P5050, "PAST"
    get_who $P5052, $P5051
    set $P5053, $P5052["Var"]
    find_lex $P5054, "$name"
    unless_null $P5054, vivify_2420
    new $P5054, "Undef"
  vivify_2420:
    find_lex $P5055, "$past"
    unless_null $P5055, vivify_2421
    new $P5055, "Undef"
  vivify_2421:
    $P5056 = $P5053."new"($P5054 :named("name"), 1 :named("isdecl"), $P5055 :named("viviself"), "lexical" :named("scope"))
    $P5049."push"($P5056)
.annotate 'line', 1526
    find_lex $P5057, "$?PACKAGE"
    get_who $P5058, $P5057
    set $P5059, $P5058["@BLOCK"]
    unless_null $P5059, vivify_2422
    $P5059 = root_new ['parrot';'ResizablePMCArray']
  vivify_2422:
    set $P5060, $P5059[0]
    unless_null $P5060, vivify_2423
    new $P5060, "Undef"
  vivify_2423:
    find_lex $P5061, "$name"
    unless_null $P5061, vivify_2424
    new $P5061, "Undef"
  vivify_2424:
    $P5060."symbol"($P5061, "lexical" :named("scope"))
.annotate 'line', 1527
    find_dynamic_lex $P5065, "$*SCOPE"
    unless_null $P5065, vivify_2425
    get_hll_global $P5063, "GLOBAL"
    get_who $P5064, $P5063
    set $P5065, $P5064["$SCOPE"]
    unless_null $P5065, vivify_2426
    die "Contextual $*SCOPE not found"
  vivify_2426:
  vivify_2425:
    set $S5066, $P5065
    iseq $I5067, $S5066, "our"
    unless $I5067, if_5062_end
.annotate 'line', 1530
    find_dynamic_lex $P5070, "$*SC"
    unless_null $P5070, vivify_2427
    get_hll_global $P5068, "GLOBAL"
    get_who $P5069, $P5068
    set $P5070, $P5069["$SC"]
    unless_null $P5070, vivify_2428
    die "Contextual $*SC not found"
  vivify_2428:
  vivify_2427:
    find_dynamic_lex $P5073, "$*PACKAGE"
    unless_null $P5073, vivify_2429
    get_hll_global $P5071, "GLOBAL"
    get_who $P5072, $P5071
    set $P5073, $P5072["$PACKAGE"]
    unless_null $P5073, vivify_2430
    die "Contextual $*PACKAGE not found"
  vivify_2430:
  vivify_2429:
    find_lex $P5074, "$name"
    unless_null $P5074, vivify_2431
    new $P5074, "Undef"
  vivify_2431:
    find_lex $P5075, "$past"
    unless_null $P5075, vivify_2432
    new $P5075, "Undef"
  vivify_2432:
    $P5070."install_package_routine"($P5073, $P5074, $P5075)
.annotate 'line', 1531
    find_lex $P5076, "$?PACKAGE"
    get_who $P5077, $P5076
    set $P5078, $P5077["@BLOCK"]
    unless_null $P5078, vivify_2433
    $P5078 = root_new ['parrot';'ResizablePMCArray']
  vivify_2433:
    set $P5079, $P5078[0]
    unless_null $P5079, vivify_2434
    $P5079 = root_new ['parrot';'ResizablePMCArray']
  vivify_2434:
    set $P5080, $P5079[0]
    unless_null $P5080, vivify_2435
    new $P5080, "Undef"
  vivify_2435:
    get_hll_global $P5081, "GLOBAL"
    nqp_get_package_through_who $P5082, $P5081, "PAST"
    get_who $P5083, $P5082
    set $P5084, $P5083["Op"]
.annotate 'line', 1533
    find_lex $P5085, "$name"
    unless_null $P5085, vivify_2436
    new $P5085, "Undef"
  vivify_2436:
    new $P5086, "ResizablePMCArray"
    push $P5086, $P5085
    find_lex $P5087, "$/"
    unless_null $P5087, vivify_2437
    new $P5087, "Undef"
  vivify_2437:
    $P5088 = "lexical_package_lookup"($P5086, $P5087)
.annotate 'line', 1534
    get_hll_global $P5089, "GLOBAL"
    nqp_get_package_through_who $P5090, $P5089, "PAST"
    get_who $P5091, $P5090
    set $P5092, $P5091["Var"]
    find_lex $P5093, "$name"
    unless_null $P5093, vivify_2438
    new $P5093, "Undef"
  vivify_2438:
    $P5094 = $P5092."new"($P5093 :named("name"), "lexical" :named("scope"))
    $P5095 = $P5084."new"($P5088, $P5094, "bind" :named("pasttype"))
.annotate 'line', 1531
    $P5080."push"($P5095)
  if_5062_end:
.annotate 'line', 1523
    goto if_4988_end
  if_4988:
.annotate 'line', 1505
    .const 'Sub' $P4995 = "688_1304282286.73" 
    capture_lex $P4995
    $P4995()
  if_4988_end:
    goto if_4875_end
  if_4875:
.annotate 'line', 1454
    .const 'Sub' $P4882 = "685_1304282286.73" 
    capture_lex $P4882
    $P4882()
  if_4875_end:
.annotate 'line', 1538
    get_hll_global $P5096, "GLOBAL"
    nqp_get_package_through_who $P5097, $P5096, "PAST"
    get_who $P5098, $P5097
    set $P5099, $P5098["Var"]
    find_lex $P5100, "$name"
    unless_null $P5100, vivify_2496
    new $P5100, "Undef"
  vivify_2496:
    $P5101 = $P5099."new"($P5100 :named("name"))
    store_lex "$past", $P5101
  if_4855_end:
.annotate 'line', 1545
    find_lex $P5112, "$name"
    unless_null $P5112, vivify_2497
    new $P5112, "Undef"
  vivify_2497:
    set $S5113, $P5112
    iseq $I5114, $S5113, "MAIN"
    if $I5114, if_5111
    new $P5110, 'Integer'
    set $P5110, $I5114
    goto if_5111_end
  if_5111:
    find_dynamic_lex $P5117, "$*MULTINESS"
    unless_null $P5117, vivify_2498
    get_hll_global $P5115, "GLOBAL"
    get_who $P5116, $P5115
    set $P5117, $P5116["$MULTINESS"]
    unless_null $P5117, vivify_2499
    die "Contextual $*MULTINESS not found"
  vivify_2499:
  vivify_2498:
    set $S5118, $P5117
    isne $I5119, $S5118, "multi"
    new $P5110, 'Integer'
    set $P5110, $I5119
  if_5111_end:
    if $P5110, if_5109
    set $P5108, $P5110
    goto if_5109_end
  if_5109:
.annotate 'line', 1546
    find_lex $P5120, "$block"
    unless_null $P5120, vivify_2500
    new $P5120, "Undef"
  vivify_2500:
    store_dynamic_lex "$*MAIN_SUB", $P5120
.annotate 'line', 1545
    set $P5108, $P5120
  if_5109_end:
.annotate 'line', 1450
    .return ($P5108)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4994"  :anon :subid("688_1304282286.73") :outer("684_1304282286.73")
.annotate 'line', 1510
    new $P4996, "Undef"
    .lex "$cholder", $P4996
.annotate 'line', 1509
    find_dynamic_lex $P5000, "$*SCOPE"
    unless_null $P5000, vivify_2439
    get_hll_global $P4998, "GLOBAL"
    get_who $P4999, $P4998
    set $P5000, $P4999["$SCOPE"]
    unless_null $P5000, vivify_2440
    die "Contextual $*SCOPE not found"
  vivify_2440:
  vivify_2439:
    set $S5001, $P5000
    iseq $I5002, $S5001, "our"
    unless $I5002, if_4997_end
    die "our-scoped protos not yet implemented"
  if_4997_end:
.annotate 'line', 1510
    get_hll_global $P5003, "GLOBAL"
    nqp_get_package_through_who $P5004, $P5003, "PAST"
    get_who $P5005, $P5004
    set $P5006, $P5005["Op"]
    $P5007 = $P5006."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5007
.annotate 'line', 1511
    find_lex $P5008, "$?PACKAGE"
    get_who $P5009, $P5008
    set $P5010, $P5009["@BLOCK"]
    unless_null $P5010, vivify_2441
    $P5010 = root_new ['parrot';'ResizablePMCArray']
  vivify_2441:
    set $P5011, $P5010[0]
    unless_null $P5011, vivify_2442
    $P5011 = root_new ['parrot';'ResizablePMCArray']
  vivify_2442:
    set $P5012, $P5011[0]
    unless_null $P5012, vivify_2443
    new $P5012, "Undef"
  vivify_2443:
    get_hll_global $P5013, "GLOBAL"
    nqp_get_package_through_who $P5014, $P5013, "PAST"
    get_who $P5015, $P5014
    set $P5016, $P5015["Var"]
    find_lex $P5017, "$name"
    unless_null $P5017, vivify_2444
    new $P5017, "Undef"
  vivify_2444:
    find_lex $P5018, "$past"
    unless_null $P5018, vivify_2445
    new $P5018, "Undef"
  vivify_2445:
    $P5019 = $P5016."new"($P5017 :named("name"), 1 :named("isdecl"), $P5018 :named("viviself"), "lexical" :named("scope"))
    $P5012."push"($P5019)
.annotate 'line', 1513
    find_lex $P5020, "$?PACKAGE"
    get_who $P5021, $P5020
    set $P5022, $P5021["@BLOCK"]
    unless_null $P5022, vivify_2446
    $P5022 = root_new ['parrot';'ResizablePMCArray']
  vivify_2446:
    set $P5023, $P5022[0]
    unless_null $P5023, vivify_2447
    $P5023 = root_new ['parrot';'ResizablePMCArray']
  vivify_2447:
    set $P5024, $P5023[0]
    unless_null $P5024, vivify_2448
    new $P5024, "Undef"
  vivify_2448:
    get_hll_global $P5025, "GLOBAL"
    nqp_get_package_through_who $P5026, $P5025, "PAST"
    get_who $P5027, $P5026
    set $P5028, $P5027["Op"]
.annotate 'line', 1515
    get_hll_global $P5029, "GLOBAL"
    nqp_get_package_through_who $P5030, $P5029, "PAST"
    get_who $P5031, $P5030
    set $P5032, $P5031["Var"]
    find_lex $P5033, "$name"
    unless_null $P5033, vivify_2449
    new $P5033, "Undef"
  vivify_2449:
    $P5034 = $P5032."new"($P5033 :named("name"))
    find_lex $P5035, "$cholder"
    unless_null $P5035, vivify_2450
    new $P5035, "Undef"
  vivify_2450:
    $P5036 = $P5028."new"($P5034, $P5035, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1513
    $P5024."push"($P5036)
.annotate 'line', 1518
    find_lex $P5037, "$?PACKAGE"
    get_who $P5038, $P5037
    set $P5039, $P5038["@BLOCK"]
    unless_null $P5039, vivify_2451
    $P5039 = root_new ['parrot';'ResizablePMCArray']
  vivify_2451:
    set $P5040, $P5039[0]
    unless_null $P5040, vivify_2452
    new $P5040, "Undef"
  vivify_2452:
    find_lex $P5041, "$name"
    unless_null $P5041, vivify_2453
    new $P5041, "Undef"
  vivify_2453:
    find_lex $P5042, "$cholder"
    unless_null $P5042, vivify_2454
    new $P5042, "Undef"
  vivify_2454:
    $P5040."symbol"($P5041, "lexical" :named("scope"), 1 :named("proto"), $P5042 :named("cholder"))
.annotate 'line', 1521
    find_lex $P5043, "$past"
    unless_null $P5043, vivify_2455
    new $P5043, "Undef"
  vivify_2455:
    $P5044 = $P5043."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1505
    .return ($P5044)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4881"  :anon :subid("685_1304282286.73") :outer("684_1304282286.73")
.annotate 'line', 1454
    .const 'Sub' $P4904 = "686_1304282286.73" 
    capture_lex $P4904
.annotate 'line', 1457
    new $P4883, "Undef"
    .lex "$cholder", $P4883
.annotate 'line', 1458
    $P4884 = root_new ['parrot';'Hash']
    .lex "%sym", $P4884
.annotate 'line', 1456
    find_dynamic_lex $P4888, "$*SCOPE"
    unless_null $P4888, vivify_2456
    get_hll_global $P4886, "GLOBAL"
    get_who $P4887, $P4886
    set $P4888, $P4887["$SCOPE"]
    unless_null $P4888, vivify_2457
    die "Contextual $*SCOPE not found"
  vivify_2457:
  vivify_2456:
    set $S4889, $P4888
    iseq $I4890, $S4889, "our"
    unless $I4890, if_4885_end
    die "our-scoped multis not yet implemented"
  if_4885_end:
    find_lex $P4891, "$cholder"
    unless_null $P4891, vivify_2458
    new $P4891, "Undef"
  vivify_2458:
.annotate 'line', 1458
    find_lex $P4892, "$?PACKAGE"
    get_who $P4893, $P4892
    set $P4894, $P4893["@BLOCK"]
    unless_null $P4894, vivify_2459
    $P4894 = root_new ['parrot';'ResizablePMCArray']
  vivify_2459:
    set $P4895, $P4894[0]
    unless_null $P4895, vivify_2460
    new $P4895, "Undef"
  vivify_2460:
    find_lex $P4896, "$name"
    unless_null $P4896, vivify_2461
    new $P4896, "Undef"
  vivify_2461:
    $P4897 = $P4895."symbol"($P4896)
    store_lex "%sym", $P4897
.annotate 'line', 1459
    find_lex $P4899, "%sym"
    unless_null $P4899, vivify_2462
    $P4899 = root_new ['parrot';'Hash']
  vivify_2462:
    set $P4900, $P4899["cholder"]
    unless_null $P4900, vivify_2463
    new $P4900, "Undef"
  vivify_2463:
    if $P4900, if_4898
.annotate 'line', 1464
    .const 'Sub' $P4904 = "686_1304282286.73" 
    capture_lex $P4904
    $P4904()
    goto if_4898_end
  if_4898:
.annotate 'line', 1460
    find_lex $P4901, "%sym"
    unless_null $P4901, vivify_2491
    $P4901 = root_new ['parrot';'Hash']
  vivify_2491:
    set $P4902, $P4901["cholder"]
    unless_null $P4902, vivify_2492
    new $P4902, "Undef"
  vivify_2492:
    store_lex "$cholder", $P4902
  if_4898_end:
.annotate 'line', 1500
    find_lex $P4984, "$cholder"
    unless_null $P4984, vivify_2493
    new $P4984, "Undef"
  vivify_2493:
    find_lex $P4985, "$past"
    unless_null $P4985, vivify_2494
    new $P4985, "Undef"
  vivify_2494:
    $P4984."push"($P4985)
.annotate 'line', 1503
    find_lex $P4986, "$past"
    unless_null $P4986, vivify_2495
    new $P4986, "Undef"
  vivify_2495:
    $P4987 = "attach_multi_signature"($P4986)
.annotate 'line', 1454
    .return ($P4987)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4903"  :anon :subid("686_1304282286.73") :outer("685_1304282286.73")
.annotate 'line', 1464
    .const 'Sub' $P4920 = "687_1304282286.73" 
    capture_lex $P4920
.annotate 'line', 1471
    new $P4905, "Undef"
    .lex "$found_proto", $P4905
.annotate 'line', 1489
    new $P4906, "Undef"
    .lex "$dispatch_setup", $P4906
.annotate 'line', 1466
    find_lex $P4908, "%sym"
    unless_null $P4908, vivify_2464
    $P4908 = root_new ['parrot';'Hash']
  vivify_2464:
    set $P4909, $P4908["proto"]
    unless_null $P4909, vivify_2465
    new $P4909, "Undef"
  vivify_2465:
    unless $P4909, if_4907_end
.annotate 'line', 1469
    find_lex $P4910, "$/"
    unless_null $P4910, vivify_2466
    new $P4910, "Undef"
  vivify_2466:
    $P4911 = $P4910."CURSOR"()
    $P4911."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4907_end:
.annotate 'line', 1466
    find_lex $P4912, "$found_proto"
    unless_null $P4912, vivify_2467
    new $P4912, "Undef"
  vivify_2467:
.annotate 'line', 1472
    find_lex $P4914, "$?PACKAGE"
    get_who $P4915, $P4914
    set $P4916, $P4915["@BLOCK"]
    unless_null $P4916, vivify_2468
    $P4916 = root_new ['parrot';'ResizablePMCArray']
  vivify_2468:
    defined $I4917, $P4916
    unless $I4917, for_undef_2469
    iter $P4913, $P4916
    new $P4942, 'ExceptionHandler'
    set_label $P4942, loop4941_handler
    $P4942."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4942
  loop4941_test:
    unless $P4913, loop4941_done
    shift $P4918, $P4913
  loop4941_redo:
    .const 'Sub' $P4920 = "687_1304282286.73" 
    capture_lex $P4920
    $P4920($P4918)
  loop4941_next:
    goto loop4941_test
  loop4941_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4943, exception, 'type'
    eq $P4943, .CONTROL_LOOP_NEXT, loop4941_next
    eq $P4943, .CONTROL_LOOP_REDO, loop4941_redo
  loop4941_done:
    pop_eh 
  for_undef_2469:
.annotate 'line', 1483
    find_lex $P4945, "$found_proto"
    unless_null $P4945, vivify_2478
    new $P4945, "Undef"
  vivify_2478:
    if $P4945, unless_4944_end
.annotate 'line', 1484
    find_lex $P4946, "$/"
    unless_null $P4946, vivify_2479
    new $P4946, "Undef"
  vivify_2479:
    $P4947 = $P4946."CURSOR"()
    $P4947."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4944_end:
.annotate 'line', 1488
    get_hll_global $P4948, "GLOBAL"
    nqp_get_package_through_who $P4949, $P4948, "PAST"
    get_who $P4950, $P4949
    set $P4951, $P4950["Op"]
    $P4952 = $P4951."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4952
.annotate 'line', 1489
    get_hll_global $P4953, "GLOBAL"
    nqp_get_package_through_who $P4954, $P4953, "PAST"
    get_who $P4955, $P4954
    set $P4956, $P4955["Op"]
.annotate 'line', 1491
    get_hll_global $P4957, "GLOBAL"
    nqp_get_package_through_who $P4958, $P4957, "PAST"
    get_who $P4959, $P4958
    set $P4960, $P4959["Var"]
    find_lex $P4961, "$name"
    unless_null $P4961, vivify_2480
    new $P4961, "Undef"
  vivify_2480:
    $P4962 = $P4960."new"($P4961 :named("name"), "outer" :named("scope"))
    find_lex $P4963, "$cholder"
    unless_null $P4963, vivify_2481
    new $P4963, "Undef"
  vivify_2481:
    $P4964 = $P4956."new"($P4962, $P4963, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1489
    store_lex "$dispatch_setup", $P4964
.annotate 'line', 1494
    find_lex $P4965, "$?PACKAGE"
    get_who $P4966, $P4965
    set $P4967, $P4966["@BLOCK"]
    unless_null $P4967, vivify_2482
    $P4967 = root_new ['parrot';'ResizablePMCArray']
  vivify_2482:
    set $P4968, $P4967[0]
    unless_null $P4968, vivify_2483
    $P4968 = root_new ['parrot';'ResizablePMCArray']
  vivify_2483:
    set $P4969, $P4968[0]
    unless_null $P4969, vivify_2484
    new $P4969, "Undef"
  vivify_2484:
    get_hll_global $P4970, "GLOBAL"
    nqp_get_package_through_who $P4971, $P4970, "PAST"
    get_who $P4972, $P4971
    set $P4973, $P4972["Var"]
    find_lex $P4974, "$name"
    unless_null $P4974, vivify_2485
    new $P4974, "Undef"
  vivify_2485:
    find_lex $P4975, "$dispatch_setup"
    unless_null $P4975, vivify_2486
    new $P4975, "Undef"
  vivify_2486:
    $P4976 = $P4973."new"($P4974 :named("name"), 1 :named("isdecl"), $P4975 :named("viviself"), "lexical" :named("scope"))
    $P4969."push"($P4976)
.annotate 'line', 1496
    find_lex $P4977, "$?PACKAGE"
    get_who $P4978, $P4977
    set $P4979, $P4978["@BLOCK"]
    unless_null $P4979, vivify_2487
    $P4979 = root_new ['parrot';'ResizablePMCArray']
  vivify_2487:
    set $P4980, $P4979[0]
    unless_null $P4980, vivify_2488
    new $P4980, "Undef"
  vivify_2488:
    find_lex $P4981, "$name"
    unless_null $P4981, vivify_2489
    new $P4981, "Undef"
  vivify_2489:
    find_lex $P4982, "$cholder"
    unless_null $P4982, vivify_2490
    new $P4982, "Undef"
  vivify_2490:
    $P4983 = $P4980."symbol"($P4981, "lexical" :named("scope"), $P4982 :named("cholder"))
.annotate 'line', 1464
    .return ($P4983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4919"  :anon :subid("687_1304282286.73") :outer("686_1304282286.73")
    .param pmc param_4922
.annotate 'line', 1473
    $P4921 = root_new ['parrot';'Hash']
    .lex "%sym", $P4921
    .lex "$_", param_4922
    find_lex $P4923, "$_"
    unless_null $P4923, vivify_2470
    new $P4923, "Undef"
  vivify_2470:
    find_lex $P4924, "$name"
    unless_null $P4924, vivify_2471
    new $P4924, "Undef"
  vivify_2471:
    $P4925 = $P4923."symbol"($P4924)
    store_lex "%sym", $P4925
.annotate 'line', 1474
    find_lex $P4930, "%sym"
    unless_null $P4930, vivify_2472
    $P4930 = root_new ['parrot';'Hash']
  vivify_2472:
    set $P4931, $P4930["proto"]
    unless_null $P4931, vivify_2473
    new $P4931, "Undef"
  vivify_2473:
    unless $P4931, unless_4929
    set $P4928, $P4931
    goto unless_4929_end
  unless_4929:
    find_lex $P4932, "%sym"
    unless_null $P4932, vivify_2474
    $P4932 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P4933, $P4932["cholder"]
    unless_null $P4933, vivify_2475
    new $P4933, "Undef"
  vivify_2475:
    set $P4928, $P4933
  unless_4929_end:
    if $P4928, if_4927
.annotate 'line', 1477
    find_lex $P4937, "%sym"
    unless_null $P4937, vivify_2476
    $P4937 = root_new ['parrot';'Hash']
  vivify_2476:
    if $P4937, if_4936
    set $P4935, $P4937
    goto if_4936_end
  if_4936:
.annotate 'line', 1478
    find_lex $P4938, "$/"
    unless_null $P4938, vivify_2477
    new $P4938, "Undef"
  vivify_2477:
    $P4939 = $P4938."CURSOR"()
    $P4940 = $P4939."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1477
    set $P4935, $P4940
  if_4936_end:
    set $P4926, $P4935
.annotate 'line', 1474
    goto if_4927_end
  if_4927:
.annotate 'line', 1475
    new $P4934, "Integer"
    assign $P4934, 1
    store_lex "$found_proto", $P4934
.annotate 'line', 1474
    set $P4926, $P4934
  if_4927_end:
.annotate 'line', 1472
    .return ($P4926)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5131"  :anon :subid("689_1304282286.73") :outer("683_1304282286.73")
    .param pmc param_5133
.annotate 'line', 1553
    .lex "$_", param_5133
    find_lex $P5134, "$_"
    unless_null $P5134, vivify_2508
    new $P5134, "Undef"
  vivify_2508:
    $P5135 = $P5134."ast"()
    find_lex $P5136, "$/"
    unless_null $P5136, vivify_2509
    new $P5136, "Undef"
  vivify_2509:
    $P5137 = $P5135($P5136)
    .return ($P5137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("690_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5145
    .param pmc param_5146
.annotate 'line', 1560
    .const 'Sub' $P5262 = "692_1304282286.73" 
    capture_lex $P5262
    .const 'Sub' $P5184 = "691_1304282286.73" 
    capture_lex $P5184
    .lex "self", param_5145
    .lex "$/", param_5146
.annotate 'line', 1563
    new $P5147, "Undef"
    .lex "$past", $P5147
.annotate 'line', 1560
    find_lex $P5148, "$past"
    unless_null $P5148, vivify_2511
    new $P5148, "Undef"
  vivify_2511:
.annotate 'line', 1564
    find_lex $P5150, "$/"
    unless_null $P5150, vivify_2512
    $P5150 = root_new ['parrot';'Hash']
  vivify_2512:
    set $P5151, $P5150["onlystar"]
    unless_null $P5151, vivify_2513
    new $P5151, "Undef"
  vivify_2513:
    if $P5151, if_5149
.annotate 'line', 1568
    find_lex $P5153, "$/"
    unless_null $P5153, vivify_2514
    $P5153 = root_new ['parrot';'Hash']
  vivify_2514:
    set $P5154, $P5153["blockoid"]
    unless_null $P5154, vivify_2515
    new $P5154, "Undef"
  vivify_2515:
    $P5155 = $P5154."ast"()
    store_lex "$past", $P5155
.annotate 'line', 1569
    find_lex $P5156, "$past"
    unless_null $P5156, vivify_2516
    new $P5156, "Undef"
  vivify_2516:
    $P5156."blocktype"("declaration")
.annotate 'line', 1570
    find_dynamic_lex $P5160, "$*RETURN_USED"
    unless_null $P5160, vivify_2517
    get_hll_global $P5158, "GLOBAL"
    get_who $P5159, $P5158
    set $P5160, $P5159["$RETURN_USED"]
    unless_null $P5160, vivify_2518
    die "Contextual $*RETURN_USED not found"
  vivify_2518:
  vivify_2517:
    unless $P5160, if_5157_end
.annotate 'line', 1571
    find_lex $P5161, "$past"
    unless_null $P5161, vivify_2519
    new $P5161, "Undef"
  vivify_2519:
    $P5161."control"("return_pir")
  if_5157_end:
.annotate 'line', 1567
    goto if_5149_end
  if_5149:
.annotate 'line', 1565
    $P5152 = "only_star_block"()
    store_lex "$past", $P5152
  if_5149_end:
.annotate 'line', 1576
    find_lex $P5163, "$past"
    unless_null $P5163, vivify_2520
    $P5163 = root_new ['parrot';'Hash']
  vivify_2520:
    set $P5164, $P5163["signature_has_invocant"]
    unless_null $P5164, vivify_2521
    new $P5164, "Undef"
  vivify_2521:
    if $P5164, unless_5162_end
.annotate 'line', 1577
    find_lex $P5165, "$past"
    unless_null $P5165, vivify_2522
    $P5165 = root_new ['parrot';'ResizablePMCArray']
  vivify_2522:
    set $P5166, $P5165[0]
    unless_null $P5166, vivify_2523
    new $P5166, "Undef"
  vivify_2523:
    get_hll_global $P5167, "GLOBAL"
    nqp_get_package_through_who $P5168, $P5167, "PAST"
    get_who $P5169, $P5168
    set $P5170, $P5169["Var"]
.annotate 'line', 1579
    find_dynamic_lex $P5173, "$*SC"
    unless_null $P5173, vivify_2524
    get_hll_global $P5171, "GLOBAL"
    get_who $P5172, $P5171
    set $P5173, $P5172["$SC"]
    unless_null $P5173, vivify_2525
    die "Contextual $*SC not found"
  vivify_2525:
  vivify_2524:
    find_dynamic_lex $P5176, "$*PACKAGE"
    unless_null $P5176, vivify_2526
    get_hll_global $P5174, "GLOBAL"
    get_who $P5175, $P5174
    set $P5176, $P5175["$PACKAGE"]
    unless_null $P5176, vivify_2527
    die "Contextual $*PACKAGE not found"
  vivify_2527:
  vivify_2526:
    $P5177 = $P5173."get_object_sc_ref_past"($P5176)
    $P5178 = $P5170."new"("self" :named("name"), "parameter" :named("scope"), $P5177 :named("multitype"))
.annotate 'line', 1577
    $P5166."unshift"($P5178)
  unless_5162_end:
.annotate 'line', 1582
    find_lex $P5179, "$past"
    unless_null $P5179, vivify_2528
    new $P5179, "Undef"
  vivify_2528:
    $P5179."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1585
    find_lex $P5181, "$/"
    unless_null $P5181, vivify_2529
    $P5181 = root_new ['parrot';'Hash']
  vivify_2529:
    set $P5182, $P5181["deflongname"]
    unless_null $P5182, vivify_2530
    new $P5182, "Undef"
  vivify_2530:
    unless $P5182, if_5180_end
    .const 'Sub' $P5184 = "691_1304282286.73" 
    capture_lex $P5184
    $P5184()
  if_5180_end:
.annotate 'line', 1606
    find_lex $P5248, "$/"
    find_lex $P5249, "$past"
    unless_null $P5249, vivify_2561
    new $P5249, "Undef"
  vivify_2561:
    $P5248."!make"($P5249)
.annotate 'line', 1607
    find_lex $P5250, "$past"
    unless_null $P5250, vivify_2562
    new $P5250, "Undef"
  vivify_2562:
    find_lex $P5251, "$past"
    unless_null $P5251, vivify_2563
    $P5251 = root_new ['parrot';'Hash']
    store_lex "$past", $P5251
  vivify_2563:
    set $P5251["block_past"], $P5250
.annotate 'line', 1608
    find_lex $P5254, "$/"
    unless_null $P5254, vivify_2564
    $P5254 = root_new ['parrot';'Hash']
  vivify_2564:
    set $P5255, $P5254["trait"]
    unless_null $P5255, vivify_2565
    new $P5255, "Undef"
  vivify_2565:
    if $P5255, if_5253
    set $P5252, $P5255
    goto if_5253_end
  if_5253:
.annotate 'line', 1609
    find_lex $P5257, "$/"
    unless_null $P5257, vivify_2566
    $P5257 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P5258, $P5257["trait"]
    unless_null $P5258, vivify_2567
    new $P5258, "Undef"
  vivify_2567:
    defined $I5259, $P5258
    unless $I5259, for_undef_2568
    iter $P5256, $P5258
    new $P5269, 'ExceptionHandler'
    set_label $P5269, loop5268_handler
    $P5269."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5269
  loop5268_test:
    unless $P5256, loop5268_done
    shift $P5260, $P5256
  loop5268_redo:
    .const 'Sub' $P5262 = "692_1304282286.73" 
    capture_lex $P5262
    $P5262($P5260)
  loop5268_next:
    goto loop5268_test
  loop5268_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5270, exception, 'type'
    eq $P5270, .CONTROL_LOOP_NEXT, loop5268_next
    eq $P5270, .CONTROL_LOOP_REDO, loop5268_redo
  loop5268_done:
    pop_eh 
  for_undef_2568:
.annotate 'line', 1608
    set $P5252, $P5256
  if_5253_end:
.annotate 'line', 1560
    .return ($P5252)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5183"  :anon :subid("691_1304282286.73") :outer("690_1304282286.73")
.annotate 'line', 1587
    new $P5185, "Undef"
    .lex "$name", $P5185
.annotate 'line', 1595
    new $P5186, "Undef"
    .lex "$meta_meth", $P5186
.annotate 'line', 1596
    new $P5187, "Undef"
    .lex "$is_dispatcher", $P5187
.annotate 'line', 1587
    find_lex $P5188, "$/"
    unless_null $P5188, vivify_2531
    $P5188 = root_new ['parrot';'Hash']
  vivify_2531:
    set $P5189, $P5188["private"]
    unless_null $P5189, vivify_2532
    new $P5189, "Undef"
  vivify_2532:
    set $S5190, $P5189
    new $P5191, 'String'
    set $P5191, $S5190
    find_lex $P5192, "$/"
    unless_null $P5192, vivify_2533
    $P5192 = root_new ['parrot';'Hash']
  vivify_2533:
    set $P5193, $P5192["deflongname"]
    unless_null $P5193, vivify_2534
    $P5193 = root_new ['parrot';'ResizablePMCArray']
  vivify_2534:
    set $P5194, $P5193[0]
    unless_null $P5194, vivify_2535
    new $P5194, "Undef"
  vivify_2535:
    $P5195 = $P5194."ast"()
    set $S5196, $P5195
    concat $P5197, $P5191, $S5196
    store_lex "$name", $P5197
.annotate 'line', 1588
    find_lex $P5198, "$past"
    unless_null $P5198, vivify_2536
    new $P5198, "Undef"
  vivify_2536:
    find_lex $P5199, "$name"
    unless_null $P5199, vivify_2537
    new $P5199, "Undef"
  vivify_2537:
    $P5198."name"($P5199)
.annotate 'line', 1592
    find_dynamic_lex $P5203, "$*MULTINESS"
    unless_null $P5203, vivify_2538
    get_hll_global $P5201, "GLOBAL"
    get_who $P5202, $P5201
    set $P5203, $P5202["$MULTINESS"]
    unless_null $P5203, vivify_2539
    die "Contextual $*MULTINESS not found"
  vivify_2539:
  vivify_2538:
    set $S5204, $P5203
    iseq $I5205, $S5204, "multi"
    unless $I5205, if_5200_end
    find_lex $P5206, "$past"
    unless_null $P5206, vivify_2540
    new $P5206, "Undef"
  vivify_2540:
    "attach_multi_signature"($P5206)
  if_5200_end:
.annotate 'line', 1595
    find_dynamic_lex $P5211, "$*MULTINESS"
    unless_null $P5211, vivify_2541
    get_hll_global $P5209, "GLOBAL"
    get_who $P5210, $P5209
    set $P5211, $P5210["$MULTINESS"]
    unless_null $P5211, vivify_2542
    die "Contextual $*MULTINESS not found"
  vivify_2542:
  vivify_2541:
    set $S5212, $P5211
    iseq $I5213, $S5212, "multi"
    if $I5213, if_5208
    new $P5215, "String"
    assign $P5215, "add_method"
    set $P5207, $P5215
    goto if_5208_end
  if_5208:
    new $P5214, "String"
    assign $P5214, "add_multi_method"
    set $P5207, $P5214
  if_5208_end:
    store_lex "$meta_meth", $P5207
.annotate 'line', 1596
    find_dynamic_lex $P5218, "$*MULTINESS"
    unless_null $P5218, vivify_2543
    get_hll_global $P5216, "GLOBAL"
    get_who $P5217, $P5216
    set $P5218, $P5217["$MULTINESS"]
    unless_null $P5218, vivify_2544
    die "Contextual $*MULTINESS not found"
  vivify_2544:
  vivify_2543:
    set $S5219, $P5218
    iseq $I5220, $S5219, "proto"
    new $P5221, 'Integer'
    set $P5221, $I5220
    store_lex "$is_dispatcher", $P5221
.annotate 'line', 1597
    find_dynamic_lex $P5224, "$*SC"
    unless_null $P5224, vivify_2545
    get_hll_global $P5222, "GLOBAL"
    get_who $P5223, $P5222
    set $P5224, $P5223["$SC"]
    unless_null $P5224, vivify_2546
    die "Contextual $*SC not found"
  vivify_2546:
  vivify_2545:
    find_dynamic_lex $P5227, "$*PACKAGE"
    unless_null $P5227, vivify_2547
    get_hll_global $P5225, "GLOBAL"
    get_who $P5226, $P5225
    set $P5227, $P5226["$PACKAGE"]
    unless_null $P5227, vivify_2548
    die "Contextual $*PACKAGE not found"
  vivify_2548:
  vivify_2547:
    find_lex $P5228, "$meta_meth"
    unless_null $P5228, vivify_2549
    new $P5228, "Undef"
  vivify_2549:
    find_lex $P5229, "$name"
    unless_null $P5229, vivify_2550
    new $P5229, "Undef"
  vivify_2550:
    find_lex $P5230, "$past"
    unless_null $P5230, vivify_2551
    new $P5230, "Undef"
  vivify_2551:
    find_lex $P5231, "$is_dispatcher"
    unless_null $P5231, vivify_2552
    new $P5231, "Undef"
  vivify_2552:
    $P5224."pkg_add_method"($P5227, $P5228, $P5229, $P5230, $P5231)
.annotate 'line', 1600
    find_dynamic_lex $P5236, "$*SCOPE"
    unless_null $P5236, vivify_2553
    get_hll_global $P5234, "GLOBAL"
    get_who $P5235, $P5234
    set $P5236, $P5235["$SCOPE"]
    unless_null $P5236, vivify_2554
    die "Contextual $*SCOPE not found"
  vivify_2554:
  vivify_2553:
    set $S5237, $P5236
    iseq $I5238, $S5237, "our"
    if $I5238, if_5233
    new $P5232, 'Integer'
    set $P5232, $I5238
    goto if_5233_end
  if_5233:
.annotate 'line', 1601
    find_dynamic_lex $P5241, "$*SC"
    unless_null $P5241, vivify_2555
    get_hll_global $P5239, "GLOBAL"
    get_who $P5240, $P5239
    set $P5241, $P5240["$SC"]
    unless_null $P5241, vivify_2556
    die "Contextual $*SC not found"
  vivify_2556:
  vivify_2555:
    find_dynamic_lex $P5244, "$*PACKAGE"
    unless_null $P5244, vivify_2557
    get_hll_global $P5242, "GLOBAL"
    get_who $P5243, $P5242
    set $P5244, $P5243["$PACKAGE"]
    unless_null $P5244, vivify_2558
    die "Contextual $*PACKAGE not found"
  vivify_2558:
  vivify_2557:
    find_lex $P5245, "$name"
    unless_null $P5245, vivify_2559
    new $P5245, "Undef"
  vivify_2559:
    find_lex $P5246, "$past"
    unless_null $P5246, vivify_2560
    new $P5246, "Undef"
  vivify_2560:
    $P5247 = $P5241."install_package_routine"($P5244, $P5245, $P5246)
.annotate 'line', 1600
    set $P5232, $P5247
  if_5233_end:
.annotate 'line', 1585
    .return ($P5232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5261"  :anon :subid("692_1304282286.73") :outer("690_1304282286.73")
    .param pmc param_5263
.annotate 'line', 1609
    .lex "$_", param_5263
    find_lex $P5264, "$_"
    unless_null $P5264, vivify_2569
    new $P5264, "Undef"
  vivify_2569:
    $P5265 = $P5264."ast"()
    find_lex $P5266, "$/"
    unless_null $P5266, vivify_2570
    new $P5266, "Undef"
  vivify_2570:
    $P5267 = $P5265($P5266)
    .return ($P5267)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("693_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5274
    .param pmc param_5275
.annotate 'line', 1638
    .const 'Sub' $P5318 = "695_1304282286.73" 
    capture_lex $P5318
    .const 'Sub' $P5286 = "694_1304282286.73" 
    capture_lex $P5286
    .lex "self", param_5274
    .lex "$/", param_5275
.annotate 'line', 1639
    new $P5276, "Undef"
    .lex "$BLOCKINIT", $P5276
    find_lex $P5277, "$?PACKAGE"
    get_who $P5278, $P5277
    set $P5279, $P5278["@BLOCK"]
    unless_null $P5279, vivify_2571
    $P5279 = root_new ['parrot';'ResizablePMCArray']
  vivify_2571:
    set $P5280, $P5279[0]
    unless_null $P5280, vivify_2572
    $P5280 = root_new ['parrot';'ResizablePMCArray']
  vivify_2572:
    set $P5281, $P5280[0]
    unless_null $P5281, vivify_2573
    new $P5281, "Undef"
  vivify_2573:
    store_lex "$BLOCKINIT", $P5281
.annotate 'line', 1640
    find_lex $P5283, "$/"
    unless_null $P5283, vivify_2574
    $P5283 = root_new ['parrot';'Hash']
  vivify_2574:
    set $P5284, $P5283["invocant"]
    unless_null $P5284, vivify_2575
    new $P5284, "Undef"
  vivify_2575:
    unless $P5284, if_5282_end
    .const 'Sub' $P5286 = "694_1304282286.73" 
    capture_lex $P5286
    $P5286()
  if_5282_end:
.annotate 'line', 1649
    find_lex $P5313, "$/"
    unless_null $P5313, vivify_2585
    $P5313 = root_new ['parrot';'Hash']
  vivify_2585:
    set $P5314, $P5313["parameter"]
    unless_null $P5314, vivify_2586
    new $P5314, "Undef"
  vivify_2586:
    defined $I5315, $P5314
    unless $I5315, for_undef_2587
    iter $P5312, $P5314
    new $P5325, 'ExceptionHandler'
    set_label $P5325, loop5324_handler
    $P5325."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5325
  loop5324_test:
    unless $P5312, loop5324_done
    shift $P5316, $P5312
  loop5324_redo:
    .const 'Sub' $P5318 = "695_1304282286.73" 
    capture_lex $P5318
    $P5318($P5316)
  loop5324_next:
    goto loop5324_test
  loop5324_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5326, exception, 'type'
    eq $P5326, .CONTROL_LOOP_NEXT, loop5324_next
    eq $P5326, .CONTROL_LOOP_REDO, loop5324_redo
  loop5324_done:
    pop_eh 
  for_undef_2587:
.annotate 'line', 1638
    .return ($P5312)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5285"  :anon :subid("694_1304282286.73") :outer("693_1304282286.73")
.annotate 'line', 1641
    new $P5287, "Undef"
    .lex "$inv", $P5287
    find_lex $P5288, "$/"
    unless_null $P5288, vivify_2576
    $P5288 = root_new ['parrot';'Hash']
  vivify_2576:
    set $P5289, $P5288["invocant"]
    unless_null $P5289, vivify_2577
    $P5289 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P5290, $P5289[0]
    unless_null $P5290, vivify_2578
    new $P5290, "Undef"
  vivify_2578:
    $P5291 = $P5290."ast"()
    store_lex "$inv", $P5291
.annotate 'line', 1642
    find_lex $P5292, "$BLOCKINIT"
    unless_null $P5292, vivify_2579
    new $P5292, "Undef"
  vivify_2579:
    find_lex $P5293, "$inv"
    unless_null $P5293, vivify_2580
    new $P5293, "Undef"
  vivify_2580:
    $P5292."push"($P5293)
.annotate 'line', 1643
    find_lex $P5294, "$BLOCKINIT"
    unless_null $P5294, vivify_2581
    new $P5294, "Undef"
  vivify_2581:
    get_hll_global $P5295, "GLOBAL"
    nqp_get_package_through_who $P5296, $P5295, "PAST"
    get_who $P5297, $P5296
    set $P5298, $P5297["Var"]
.annotate 'line', 1645
    get_hll_global $P5299, "GLOBAL"
    nqp_get_package_through_who $P5300, $P5299, "PAST"
    get_who $P5301, $P5300
    set $P5302, $P5301["Var"]
    find_lex $P5303, "$inv"
    unless_null $P5303, vivify_2582
    new $P5303, "Undef"
  vivify_2582:
    $P5304 = $P5303."name"()
    $P5305 = $P5302."new"("lexical" :named("scope"), $P5304 :named("name"))
    $P5306 = $P5298."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5305 :named("viviself"))
.annotate 'line', 1643
    $P5294."push"($P5306)
.annotate 'line', 1647
    new $P5307, "Integer"
    assign $P5307, 1
    find_lex $P5308, "$?PACKAGE"
    get_who $P5309, $P5308
    set $P5310, $P5309["@BLOCK"]
    unless_null $P5310, vivify_2583
    $P5310 = root_new ['parrot';'ResizablePMCArray']
    set $P5309["@BLOCK"], $P5310
  vivify_2583:
    set $P5311, $P5310[0]
    unless_null $P5311, vivify_2584
    $P5311 = root_new ['parrot';'Hash']
    set $P5310[0], $P5311
  vivify_2584:
    set $P5311["signature_has_invocant"], $P5307
.annotate 'line', 1640
    .return ($P5307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5317"  :anon :subid("695_1304282286.73") :outer("693_1304282286.73")
    .param pmc param_5319
.annotate 'line', 1649
    .lex "$_", param_5319
    find_lex $P5320, "$BLOCKINIT"
    unless_null $P5320, vivify_2588
    new $P5320, "Undef"
  vivify_2588:
    find_lex $P5321, "$_"
    unless_null $P5321, vivify_2589
    new $P5321, "Undef"
  vivify_2589:
    $P5322 = $P5321."ast"()
    $P5323 = $P5320."push"($P5322)
    .return ($P5323)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("696_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5328
    .param pmc param_5329
.annotate 'line', 1652
    .lex "self", param_5328
    .lex "$/", param_5329
.annotate 'line', 1653
    new $P5330, "Undef"
    .lex "$quant", $P5330
.annotate 'line', 1654
    new $P5331, "Undef"
    .lex "$past", $P5331
.annotate 'line', 1653
    find_lex $P5332, "$/"
    unless_null $P5332, vivify_2590
    $P5332 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5333, $P5332["quant"]
    unless_null $P5333, vivify_2591
    new $P5333, "Undef"
  vivify_2591:
    store_lex "$quant", $P5333
    find_lex $P5334, "$past"
    unless_null $P5334, vivify_2592
    new $P5334, "Undef"
  vivify_2592:
.annotate 'line', 1655
    find_lex $P5336, "$/"
    unless_null $P5336, vivify_2593
    $P5336 = root_new ['parrot';'Hash']
  vivify_2593:
    set $P5337, $P5336["named_param"]
    unless_null $P5337, vivify_2594
    new $P5337, "Undef"
  vivify_2594:
    if $P5337, if_5335
.annotate 'line', 1662
    find_lex $P5351, "$/"
    unless_null $P5351, vivify_2595
    $P5351 = root_new ['parrot';'Hash']
  vivify_2595:
    set $P5352, $P5351["param_var"]
    unless_null $P5352, vivify_2596
    new $P5352, "Undef"
  vivify_2596:
    $P5353 = $P5352."ast"()
    store_lex "$past", $P5353
.annotate 'line', 1663
    find_lex $P5355, "$quant"
    unless_null $P5355, vivify_2597
    new $P5355, "Undef"
  vivify_2597:
    set $S5356, $P5355
    iseq $I5357, $S5356, "*"
    if $I5357, if_5354
.annotate 'line', 1667
    find_lex $P5366, "$quant"
    unless_null $P5366, vivify_2598
    new $P5366, "Undef"
  vivify_2598:
    set $S5367, $P5366
    iseq $I5368, $S5367, "?"
    unless $I5368, if_5365_end
.annotate 'line', 1668
    find_lex $P5369, "$past"
    unless_null $P5369, vivify_2599
    new $P5369, "Undef"
  vivify_2599:
    find_lex $P5370, "$/"
    unless_null $P5370, vivify_2600
    $P5370 = root_new ['parrot';'Hash']
  vivify_2600:
    set $P5371, $P5370["param_var"]
    unless_null $P5371, vivify_2601
    $P5371 = root_new ['parrot';'Hash']
  vivify_2601:
    set $P5372, $P5371["sigil"]
    unless_null $P5372, vivify_2602
    new $P5372, "Undef"
  vivify_2602:
    $P5373 = "vivitype"($P5372)
    $P5369."viviself"($P5373)
  if_5365_end:
.annotate 'line', 1667
    goto if_5354_end
  if_5354:
.annotate 'line', 1664
    find_lex $P5358, "$past"
    unless_null $P5358, vivify_2603
    new $P5358, "Undef"
  vivify_2603:
    $P5358."slurpy"(1)
.annotate 'line', 1665
    find_lex $P5359, "$past"
    unless_null $P5359, vivify_2604
    new $P5359, "Undef"
  vivify_2604:
    find_lex $P5360, "$/"
    unless_null $P5360, vivify_2605
    $P5360 = root_new ['parrot';'Hash']
  vivify_2605:
    set $P5361, $P5360["param_var"]
    unless_null $P5361, vivify_2606
    $P5361 = root_new ['parrot';'Hash']
  vivify_2606:
    set $P5362, $P5361["sigil"]
    unless_null $P5362, vivify_2607
    new $P5362, "Undef"
  vivify_2607:
    set $S5363, $P5362
    iseq $I5364, $S5363, "%"
    $P5359."named"($I5364)
  if_5354_end:
.annotate 'line', 1661
    goto if_5335_end
  if_5335:
.annotate 'line', 1656
    find_lex $P5338, "$/"
    unless_null $P5338, vivify_2608
    $P5338 = root_new ['parrot';'Hash']
  vivify_2608:
    set $P5339, $P5338["named_param"]
    unless_null $P5339, vivify_2609
    new $P5339, "Undef"
  vivify_2609:
    $P5340 = $P5339."ast"()
    store_lex "$past", $P5340
.annotate 'line', 1657
    find_lex $P5342, "$quant"
    unless_null $P5342, vivify_2610
    new $P5342, "Undef"
  vivify_2610:
    set $S5343, $P5342
    isne $I5344, $S5343, "!"
    unless $I5344, if_5341_end
.annotate 'line', 1658
    find_lex $P5345, "$past"
    unless_null $P5345, vivify_2611
    new $P5345, "Undef"
  vivify_2611:
    find_lex $P5346, "$/"
    unless_null $P5346, vivify_2612
    $P5346 = root_new ['parrot';'Hash']
  vivify_2612:
    set $P5347, $P5346["named_param"]
    unless_null $P5347, vivify_2613
    $P5347 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5348, $P5347["param_var"]
    unless_null $P5348, vivify_2614
    $P5348 = root_new ['parrot';'Hash']
  vivify_2614:
    set $P5349, $P5348["sigil"]
    unless_null $P5349, vivify_2615
    new $P5349, "Undef"
  vivify_2615:
    $P5350 = "vivitype"($P5349)
    $P5345."viviself"($P5350)
  if_5341_end:
  if_5335_end:
.annotate 'line', 1671
    find_lex $P5375, "$/"
    unless_null $P5375, vivify_2616
    $P5375 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P5376, $P5375["default_value"]
    unless_null $P5376, vivify_2617
    new $P5376, "Undef"
  vivify_2617:
    unless $P5376, if_5374_end
.annotate 'line', 1672
    find_lex $P5378, "$quant"
    unless_null $P5378, vivify_2618
    new $P5378, "Undef"
  vivify_2618:
    set $S5379, $P5378
    iseq $I5380, $S5379, "*"
    unless $I5380, if_5377_end
.annotate 'line', 1673
    find_lex $P5381, "$/"
    unless_null $P5381, vivify_2619
    new $P5381, "Undef"
  vivify_2619:
    $P5382 = $P5381."CURSOR"()
    $P5382."panic"("Can't put default on slurpy parameter")
  if_5377_end:
.annotate 'line', 1675
    find_lex $P5384, "$quant"
    unless_null $P5384, vivify_2620
    new $P5384, "Undef"
  vivify_2620:
    set $S5385, $P5384
    iseq $I5386, $S5385, "!"
    unless $I5386, if_5383_end
.annotate 'line', 1676
    find_lex $P5387, "$/"
    unless_null $P5387, vivify_2621
    new $P5387, "Undef"
  vivify_2621:
    $P5388 = $P5387."CURSOR"()
    $P5388."panic"("Can't put default on required parameter")
  if_5383_end:
.annotate 'line', 1678
    find_lex $P5389, "$past"
    unless_null $P5389, vivify_2622
    new $P5389, "Undef"
  vivify_2622:
    find_lex $P5390, "$/"
    unless_null $P5390, vivify_2623
    $P5390 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5391, $P5390["default_value"]
    unless_null $P5391, vivify_2624
    $P5391 = root_new ['parrot';'ResizablePMCArray']
  vivify_2624:
    set $P5392, $P5391[0]
    unless_null $P5392, vivify_2625
    $P5392 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P5393, $P5392["EXPR"]
    unless_null $P5393, vivify_2626
    new $P5393, "Undef"
  vivify_2626:
    $P5394 = $P5393."ast"()
    $P5389."viviself"($P5394)
  if_5374_end:
.annotate 'line', 1680
    find_lex $P5396, "$past"
    unless_null $P5396, vivify_2627
    new $P5396, "Undef"
  vivify_2627:
    $P5397 = $P5396."viviself"()
    if $P5397, unless_5395_end
    find_lex $P5398, "$?PACKAGE"
    get_who $P5399, $P5398
    set $P5400, $P5399["@BLOCK"]
    unless_null $P5400, vivify_2628
    $P5400 = root_new ['parrot';'ResizablePMCArray']
  vivify_2628:
    set $P5401, $P5400[0]
    unless_null $P5401, vivify_2629
    new $P5401, "Undef"
  vivify_2629:
    find_lex $P5402, "$?PACKAGE"
    get_who $P5403, $P5402
    set $P5404, $P5403["@BLOCK"]
    unless_null $P5404, vivify_2630
    $P5404 = root_new ['parrot';'ResizablePMCArray']
  vivify_2630:
    set $P5405, $P5404[0]
    unless_null $P5405, vivify_2631
    new $P5405, "Undef"
  vivify_2631:
    $P5406 = $P5405."arity"()
    set $N5407, $P5406
    new $P5408, 'Float'
    set $P5408, $N5407
    add $P5409, $P5408, 1
    $P5401."arity"($P5409)
  unless_5395_end:
.annotate 'line', 1684
    find_lex $P5411, "$/"
    unless_null $P5411, vivify_2632
    $P5411 = root_new ['parrot';'Hash']
  vivify_2632:
    set $P5412, $P5411["typename"]
    unless_null $P5412, vivify_2633
    new $P5412, "Undef"
  vivify_2633:
    unless $P5412, if_5410_end
.annotate 'line', 1685
    find_lex $P5413, "$past"
    unless_null $P5413, vivify_2634
    new $P5413, "Undef"
  vivify_2634:
    find_lex $P5414, "$/"
    unless_null $P5414, vivify_2635
    $P5414 = root_new ['parrot';'Hash']
  vivify_2635:
    set $P5415, $P5414["typename"]
    unless_null $P5415, vivify_2636
    $P5415 = root_new ['parrot';'ResizablePMCArray']
  vivify_2636:
    set $P5416, $P5415[0]
    unless_null $P5416, vivify_2637
    new $P5416, "Undef"
  vivify_2637:
    $P5417 = $P5416."ast"()
    $P5413."multitype"($P5417)
  if_5410_end:
.annotate 'line', 1689
    find_lex $P5419, "$/"
    unless_null $P5419, vivify_2638
    $P5419 = root_new ['parrot';'Hash']
  vivify_2638:
    set $P5420, $P5419["definedness"]
    unless_null $P5420, vivify_2639
    new $P5420, "Undef"
  vivify_2639:
    unless $P5420, if_5418_end
.annotate 'line', 1690
    find_lex $P5421, "$/"
    unless_null $P5421, vivify_2640
    $P5421 = root_new ['parrot';'Hash']
  vivify_2640:
    set $P5422, $P5421["definedness"]
    unless_null $P5422, vivify_2641
    $P5422 = root_new ['parrot';'ResizablePMCArray']
  vivify_2641:
    set $P5423, $P5422[0]
    unless_null $P5423, vivify_2642
    new $P5423, "Undef"
  vivify_2642:
    set $S5424, $P5423
    new $P5425, 'String'
    set $P5425, $S5424
    find_lex $P5426, "$past"
    unless_null $P5426, vivify_2643
    $P5426 = root_new ['parrot';'Hash']
    store_lex "$past", $P5426
  vivify_2643:
    set $P5426["definedness"], $P5425
  if_5418_end:
.annotate 'line', 1693
    find_lex $P5427, "$/"
    find_lex $P5428, "$past"
    unless_null $P5428, vivify_2644
    new $P5428, "Undef"
  vivify_2644:
    $P5429 = $P5427."!make"($P5428)
.annotate 'line', 1652
    .return ($P5429)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("697_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5431
    .param pmc param_5432
.annotate 'line', 1696
    .lex "self", param_5431
    .lex "$/", param_5432
.annotate 'line', 1697
    new $P5433, "Undef"
    .lex "$name", $P5433
.annotate 'line', 1698
    new $P5434, "Undef"
    .lex "$past", $P5434
.annotate 'line', 1697
    find_lex $P5435, "$/"
    unless_null $P5435, vivify_2645
    new $P5435, "Undef"
  vivify_2645:
    set $S5436, $P5435
    new $P5437, 'String'
    set $P5437, $S5436
    store_lex "$name", $P5437
.annotate 'line', 1698
    get_hll_global $P5438, "GLOBAL"
    nqp_get_package_through_who $P5439, $P5438, "PAST"
    get_who $P5440, $P5439
    set $P5441, $P5440["Var"]
    find_lex $P5442, "$name"
    unless_null $P5442, vivify_2646
    new $P5442, "Undef"
  vivify_2646:
    find_lex $P5443, "$/"
    unless_null $P5443, vivify_2647
    new $P5443, "Undef"
  vivify_2647:
    $P5444 = $P5441."new"($P5442 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5443 :named("node"))
    store_lex "$past", $P5444
.annotate 'line', 1700
    find_lex $P5445, "$?PACKAGE"
    get_who $P5446, $P5445
    set $P5447, $P5446["@BLOCK"]
    unless_null $P5447, vivify_2648
    $P5447 = root_new ['parrot';'ResizablePMCArray']
  vivify_2648:
    set $P5448, $P5447[0]
    unless_null $P5448, vivify_2649
    new $P5448, "Undef"
  vivify_2649:
    find_lex $P5449, "$name"
    unless_null $P5449, vivify_2650
    new $P5449, "Undef"
  vivify_2650:
    $P5448."symbol"($P5449, "lexical" :named("scope"))
.annotate 'line', 1701
    find_lex $P5450, "$/"
    find_lex $P5451, "$past"
    unless_null $P5451, vivify_2651
    new $P5451, "Undef"
  vivify_2651:
    $P5452 = $P5450."!make"($P5451)
.annotate 'line', 1696
    .return ($P5452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("698_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5454
    .param pmc param_5455
.annotate 'line', 1704
    .lex "self", param_5454
    .lex "$/", param_5455
.annotate 'line', 1705
    new $P5456, "Undef"
    .lex "$past", $P5456
    find_lex $P5457, "$/"
    unless_null $P5457, vivify_2652
    $P5457 = root_new ['parrot';'Hash']
  vivify_2652:
    set $P5458, $P5457["param_var"]
    unless_null $P5458, vivify_2653
    new $P5458, "Undef"
  vivify_2653:
    $P5459 = $P5458."ast"()
    store_lex "$past", $P5459
.annotate 'line', 1706
    find_lex $P5460, "$past"
    unless_null $P5460, vivify_2654
    new $P5460, "Undef"
  vivify_2654:
    find_lex $P5461, "$/"
    unless_null $P5461, vivify_2655
    $P5461 = root_new ['parrot';'Hash']
  vivify_2655:
    set $P5462, $P5461["param_var"]
    unless_null $P5462, vivify_2656
    $P5462 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P5463, $P5462["name"]
    unless_null $P5463, vivify_2657
    new $P5463, "Undef"
  vivify_2657:
    set $S5464, $P5463
    $P5460."named"($S5464)
.annotate 'line', 1707
    find_lex $P5465, "$/"
    find_lex $P5466, "$past"
    unless_null $P5466, vivify_2658
    new $P5466, "Undef"
  vivify_2658:
    $P5467 = $P5465."!make"($P5466)
.annotate 'line', 1704
    .return ($P5467)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("699_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5469
    .param pmc param_5470
.annotate 'line', 1710
    .const 'Sub' $P5482 = "700_1304282286.73" 
    capture_lex $P5482
    .lex "self", param_5469
    .lex "$/", param_5470
.annotate 'line', 1714
    $P5471 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5471
.annotate 'line', 1715
    new $P5472, "Undef"
    .lex "$found", $P5472
.annotate 'line', 1714
    get_hll_global $P5473, "GLOBAL"
    nqp_get_package_through_who $P5474, $P5473, "HLL"
    get_who $P5475, $P5474
    set $P5476, $P5475["Compiler"]
    find_lex $P5477, "$/"
    unless_null $P5477, vivify_2659
    new $P5477, "Undef"
  vivify_2659:
    set $S5478, $P5477
    $P5479 = $P5476."parse_name"($S5478)
    store_lex "@name", $P5479
.annotate 'line', 1715
    new $P5480, "Integer"
    assign $P5480, 0
    store_lex "$found", $P5480
.annotate 'line', 1716
    .const 'Sub' $P5482 = "700_1304282286.73" 
    capture_lex $P5482
    $P5482()
.annotate 'line', 1721
    find_lex $P5503, "$found"
    unless_null $P5503, vivify_2665
    new $P5503, "Undef"
  vivify_2665:
    unless $P5503, unless_5502
    set $P5501, $P5503
    goto unless_5502_end
  unless_5502:
.annotate 'line', 1722
    find_lex $P5504, "$/"
    unless_null $P5504, vivify_2666
    new $P5504, "Undef"
  vivify_2666:
    $P5505 = $P5504."CURSOR"()
    new $P5506, "String"
    assign $P5506, "Use of undeclared type '"
    find_lex $P5507, "$/"
    unless_null $P5507, vivify_2667
    new $P5507, "Undef"
  vivify_2667:
    set $S5508, $P5507
    concat $P5509, $P5506, $S5508
    concat $P5510, $P5509, "'"
    $P5511 = $P5505."panic"($P5510)
.annotate 'line', 1721
    set $P5501, $P5511
  unless_5502_end:
.annotate 'line', 1710
    .return ($P5501)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5481"  :anon :subid("700_1304282286.73") :outer("699_1304282286.73")
.annotate 'line', 1716
    new $P5496, 'ExceptionHandler'
    set_label $P5496, control_5495
    $P5496."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5496
.annotate 'line', 1717
    new $P5483, "Undef"
    .lex "$sym", $P5483
    find_lex $P5484, "@name"
    unless_null $P5484, vivify_2660
    $P5484 = root_new ['parrot';'ResizablePMCArray']
  vivify_2660:
    find_lex $P5485, "$/"
    unless_null $P5485, vivify_2661
    new $P5485, "Undef"
  vivify_2661:
    $P5486 = "find_sym"($P5484, $P5485)
    store_lex "$sym", $P5486
.annotate 'line', 1718
    find_dynamic_lex $P5487, "$/"
    find_dynamic_lex $P5490, "$*SC"
    unless_null $P5490, vivify_2662
    get_hll_global $P5488, "GLOBAL"
    get_who $P5489, $P5488
    set $P5490, $P5489["$SC"]
    unless_null $P5490, vivify_2663
    die "Contextual $*SC not found"
  vivify_2663:
  vivify_2662:
    find_lex $P5491, "$sym"
    unless_null $P5491, vivify_2664
    new $P5491, "Undef"
  vivify_2664:
    $P5492 = $P5490."get_object_sc_ref_past"($P5491)
    $P5487."!make"($P5492)
.annotate 'line', 1719
    new $P5493, "Integer"
    assign $P5493, 1
    store_lex "$found", $P5493
.annotate 'line', 1716
    pop_eh 
    goto skip_handler_5494
  control_5495:
    .local pmc exception 
    .get_results (exception) 
    new $P5499, 'Integer'
    set $P5499, 1
    set exception["handled"], $P5499
    set $I5500, exception["handled"]
    ne $I5500, 1, nothandled_5498
  handled_5497:
    .return (exception)
  nothandled_5498:
    rethrow exception
  skip_handler_5494:
    .return ($P5493)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("701_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5513
    .param pmc param_5514
.annotate 'line', 1726
    .lex "self", param_5513
    .lex "$/", param_5514
.annotate 'line', 1727
    find_lex $P5515, "$/"
    find_lex $P5516, "$/"
    unless_null $P5516, vivify_2668
    $P5516 = root_new ['parrot';'Hash']
  vivify_2668:
    set $P5517, $P5516["trait_mod"]
    unless_null $P5517, vivify_2669
    new $P5517, "Undef"
  vivify_2669:
    $P5518 = $P5517."ast"()
    $P5519 = $P5515."!make"($P5518)
.annotate 'line', 1726
    .return ($P5519)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("702_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5521
    .param pmc param_5522
.annotate 'line', 1730
    .const 'Sub' $P5530 = "703_1304282286.73" 
    capture_lex $P5530
    .lex "self", param_5521
    .lex "$/", param_5522
.annotate 'line', 1731
    find_lex $P5525, "$/"
    unless_null $P5525, vivify_2670
    $P5525 = root_new ['parrot';'Hash']
  vivify_2670:
    set $P5526, $P5525["longname"]
    unless_null $P5526, vivify_2671
    new $P5526, "Undef"
  vivify_2671:
    set $S5527, $P5526
    iseq $I5528, $S5527, "parrot_vtable"
    if $I5528, if_5524
.annotate 'line', 1744
    find_lex $P5578, "$/"
    unless_null $P5578, vivify_2672
    $P5578 = root_new ['parrot';'Hash']
  vivify_2672:
    set $P5579, $P5578["longname"]
    unless_null $P5579, vivify_2673
    new $P5579, "Undef"
  vivify_2673:
    set $S5580, $P5579
    iseq $I5581, $S5580, "pirflags"
    if $I5581, if_5577
.annotate 'line', 1748
    find_lex $P5585, "$/"
    unless_null $P5585, vivify_2674
    new $P5585, "Undef"
  vivify_2674:
    $P5586 = $P5585."CURSOR"()
    new $P5587, 'String'
    set $P5587, "Trait '"
    find_lex $P5588, "$/"
    unless_null $P5588, vivify_2675
    $P5588 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P5589, $P5588["longname"]
    unless_null $P5589, vivify_2676
    new $P5589, "Undef"
  vivify_2676:
    concat $P5590, $P5587, $P5589
    concat $P5591, $P5590, "' not implemented"
    $P5592 = $P5586."panic"($P5591)
.annotate 'line', 1747
    set $P5576, $P5592
.annotate 'line', 1744
    goto if_5577_end
  if_5577:
.annotate 'line', 1745
    find_lex $P5582, "$/"
    unless_null $P5582, vivify_2677
    new $P5582, "Undef"
  vivify_2677:
    $P5583 = $P5582."CURSOR"()
    $P5584 = $P5583."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1744
    set $P5576, $P5584
  if_5577_end:
    set $P5523, $P5576
.annotate 'line', 1731
    goto if_5524_end
  if_5524:
    .const 'Sub' $P5530 = "703_1304282286.73" 
    capture_lex $P5530
    $P5575 = $P5530()
    set $P5523, $P5575
  if_5524_end:
.annotate 'line', 1730
    .return ($P5523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5529"  :anon :subid("703_1304282286.73") :outer("702_1304282286.73")
.annotate 'line', 1731
    .const 'Sub' $P5561 = "704_1304282286.73" 
    capture_lex $P5561
.annotate 'line', 1733
    new $P5531, "Undef"
    .lex "$cpast", $P5531
.annotate 'line', 1736
    new $P5532, "Undef"
    .lex "$name", $P5532
.annotate 'line', 1737
    new $P5533, "Undef"
    .lex "$package", $P5533
.annotate 'line', 1738
    new $P5534, "Undef"
    .lex "$is_dispatcher", $P5534
.annotate 'line', 1733
    find_lex $P5535, "$/"
    unless_null $P5535, vivify_2678
    $P5535 = root_new ['parrot';'Hash']
  vivify_2678:
    set $P5536, $P5535["circumfix"]
    unless_null $P5536, vivify_2679
    $P5536 = root_new ['parrot';'ResizablePMCArray']
  vivify_2679:
    set $P5537, $P5536[0]
    unless_null $P5537, vivify_2680
    new $P5537, "Undef"
  vivify_2680:
    $P5538 = $P5537."ast"()
    store_lex "$cpast", $P5538
.annotate 'line', 1735
    get_hll_global $P5540, "GLOBAL"
    nqp_get_package_through_who $P5541, $P5540, "PAST"
    get_who $P5542, $P5541
    set $P5543, $P5542["Val"]
    find_lex $P5544, "$cpast"
    unless_null $P5544, vivify_2681
    new $P5544, "Undef"
  vivify_2681:
    $P5545 = $P5543."ACCEPTS"($P5544)
    if $P5545, unless_5539_end
.annotate 'line', 1734
    find_lex $P5546, "$/"
    unless_null $P5546, vivify_2682
    new $P5546, "Undef"
  vivify_2682:
    $P5547 = $P5546."CURSOR"()
    $P5547."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5539_end:
.annotate 'line', 1736
    find_lex $P5548, "$cpast"
    unless_null $P5548, vivify_2683
    new $P5548, "Undef"
  vivify_2683:
    $P5549 = $P5548."value"()
    store_lex "$name", $P5549
.annotate 'line', 1737
    find_dynamic_lex $P5552, "$*PACKAGE"
    unless_null $P5552, vivify_2684
    get_hll_global $P5550, "GLOBAL"
    get_who $P5551, $P5550
    set $P5552, $P5551["$PACKAGE"]
    unless_null $P5552, vivify_2685
    die "Contextual $*PACKAGE not found"
  vivify_2685:
  vivify_2684:
    store_lex "$package", $P5552
.annotate 'line', 1738
    find_dynamic_lex $P5555, "$*SCOPE"
    unless_null $P5555, vivify_2686
    get_hll_global $P5553, "GLOBAL"
    get_who $P5554, $P5553
    set $P5555, $P5554["$SCOPE"]
    unless_null $P5555, vivify_2687
    die "Contextual $*SCOPE not found"
  vivify_2687:
  vivify_2686:
    set $S5556, $P5555
    iseq $I5557, $S5556, "proto"
    new $P5558, 'Integer'
    set $P5558, $I5557
    store_lex "$is_dispatcher", $P5558
.annotate 'line', 1739
    find_dynamic_lex $P5559, "$/"
    .const 'Sub' $P5561 = "704_1304282286.73" 
    newclosure $P5573, $P5561
    $P5574 = $P5559."!make"($P5573)
.annotate 'line', 1731
    .return ($P5574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5560"  :anon :subid("704_1304282286.73") :outer("703_1304282286.73")
    .param pmc param_5562
.annotate 'line', 1739
    .lex "$match", param_5562
.annotate 'line', 1740
    find_dynamic_lex $P5565, "$*SC"
    unless_null $P5565, vivify_2688
    get_hll_global $P5563, "GLOBAL"
    get_who $P5564, $P5563
    set $P5565, $P5564["$SC"]
    unless_null $P5565, vivify_2689
    die "Contextual $*SC not found"
  vivify_2689:
  vivify_2688:
    find_lex $P5566, "$package"
    unless_null $P5566, vivify_2690
    new $P5566, "Undef"
  vivify_2690:
    find_lex $P5567, "$name"
    unless_null $P5567, vivify_2691
    new $P5567, "Undef"
  vivify_2691:
.annotate 'line', 1741
    find_lex $P5568, "$match"
    unless_null $P5568, vivify_2692
    new $P5568, "Undef"
  vivify_2692:
    $P5569 = $P5568."ast"()
    set $P5570, $P5569["block_past"]
    unless_null $P5570, vivify_2693
    new $P5570, "Undef"
  vivify_2693:
.annotate 'line', 1740
    find_lex $P5571, "$is_dispatcher"
    unless_null $P5571, vivify_2694
    new $P5571, "Undef"
  vivify_2694:
    $P5572 = $P5565."pkg_add_method"($P5566, "add_parrot_vtable_mapping", $P5567, $P5570, $P5571)
.annotate 'line', 1739
    .return ($P5572)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("705_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5596
    .param pmc param_5597
    .param pmc param_5598 :optional
    .param int has_param_5598 :opt_flag
.annotate 'line', 1752
    .const 'Sub' $P5725 = "708_1304282286.73" 
    capture_lex $P5725
    .const 'Sub' $P5687 = "707_1304282286.73" 
    capture_lex $P5687
    .const 'Sub' $P5667 = "706_1304282286.73" 
    capture_lex $P5667
    new $P5595, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5595, control_5594
    push_eh $P5595
    .lex "self", param_5596
    .lex "$/", param_5597
    if has_param_5598, optparam_2695
    new $P5599, "Undef"
    set param_5598, $P5599
  optparam_2695:
    .lex "$key", param_5598
.annotate 'line', 1753
    $P5600 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5600
.annotate 'line', 1754
    new $P5601, "Undef"
    .lex "$name", $P5601
.annotate 'line', 1755
    new $P5602, "Undef"
    .lex "$past", $P5602
.annotate 'line', 1753
    get_hll_global $P5603, "GLOBAL"
    nqp_get_package_through_who $P5604, $P5603, "Regex"
    nqp_get_package_through_who $P5605, $P5604, "P6Regex"
    nqp_get_package_through_who $P5606, $P5605, "Actions"
    get_who $P5607, $P5606
    set $P5608, $P5607["@MODIFIERS"]
    unless_null $P5608, vivify_2696
    $P5608 = root_new ['parrot';'ResizablePMCArray']
  vivify_2696:
    store_lex "@MODIFIERS", $P5608
.annotate 'line', 1754
    find_lex $P5609, "$/"
    unless_null $P5609, vivify_2697
    $P5609 = root_new ['parrot';'Hash']
  vivify_2697:
    set $P5610, $P5609["deflongname"]
    unless_null $P5610, vivify_2698
    new $P5610, "Undef"
  vivify_2698:
    $P5611 = $P5610."ast"()
    set $S5612, $P5611
    new $P5613, 'String'
    set $P5613, $S5612
    store_lex "$name", $P5613
    find_lex $P5614, "$past"
    unless_null $P5614, vivify_2699
    new $P5614, "Undef"
  vivify_2699:
.annotate 'line', 1756
    find_lex $P5616, "$/"
    unless_null $P5616, vivify_2700
    $P5616 = root_new ['parrot';'Hash']
  vivify_2700:
    set $P5617, $P5616["proto"]
    unless_null $P5617, vivify_2701
    new $P5617, "Undef"
  vivify_2701:
    if $P5617, if_5615
.annotate 'line', 1786
    find_lex $P5683, "$key"
    unless_null $P5683, vivify_2702
    new $P5683, "Undef"
  vivify_2702:
    set $S5684, $P5683
    iseq $I5685, $S5684, "open"
    if $I5685, if_5682
.annotate 'line', 1796
    .const 'Sub' $P5725 = "708_1304282286.73" 
    capture_lex $P5725
    $P5725()
    goto if_5682_end
  if_5682:
.annotate 'line', 1786
    .const 'Sub' $P5687 = "707_1304282286.73" 
    capture_lex $P5687
    $P5687()
  if_5682_end:
    goto if_5615_end
  if_5615:
.annotate 'line', 1758
    get_hll_global $P5618, "GLOBAL"
    nqp_get_package_through_who $P5619, $P5618, "PAST"
    get_who $P5620, $P5619
    set $P5621, $P5620["Stmts"]
.annotate 'line', 1759
    get_hll_global $P5622, "GLOBAL"
    nqp_get_package_through_who $P5623, $P5622, "PAST"
    get_who $P5624, $P5623
    set $P5625, $P5624["Block"]
    find_lex $P5626, "$name"
    unless_null $P5626, vivify_2750
    new $P5626, "Undef"
  vivify_2750:
.annotate 'line', 1760
    get_hll_global $P5627, "GLOBAL"
    nqp_get_package_through_who $P5628, $P5627, "PAST"
    get_who $P5629, $P5628
    set $P5630, $P5629["Op"]
.annotate 'line', 1761
    get_hll_global $P5631, "GLOBAL"
    nqp_get_package_through_who $P5632, $P5631, "PAST"
    get_who $P5633, $P5632
    set $P5634, $P5633["Var"]
    $P5635 = $P5634."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5636, "$name"
    unless_null $P5636, vivify_2751
    new $P5636, "Undef"
  vivify_2751:
    $P5637 = $P5630."new"($P5635, $P5636, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1760
    find_lex $P5638, "$/"
    unless_null $P5638, vivify_2752
    new $P5638, "Undef"
  vivify_2752:
    $P5639 = $P5625."new"($P5637, $P5626 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5638 :named("node"))
.annotate 'line', 1770
    get_hll_global $P5640, "GLOBAL"
    nqp_get_package_through_who $P5641, $P5640, "PAST"
    get_who $P5642, $P5641
    set $P5643, $P5642["Block"]
    new $P5644, "String"
    assign $P5644, "!PREFIX__"
    find_lex $P5645, "$name"
    unless_null $P5645, vivify_2753
    new $P5645, "Undef"
  vivify_2753:
    concat $P5646, $P5644, $P5645
.annotate 'line', 1771
    get_hll_global $P5647, "GLOBAL"
    nqp_get_package_through_who $P5648, $P5647, "PAST"
    get_who $P5649, $P5648
    set $P5650, $P5649["Op"]
.annotate 'line', 1772
    get_hll_global $P5651, "GLOBAL"
    nqp_get_package_through_who $P5652, $P5651, "PAST"
    get_who $P5653, $P5652
    set $P5654, $P5653["Var"]
    $P5655 = $P5654."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5656, "$name"
    unless_null $P5656, vivify_2754
    new $P5656, "Undef"
  vivify_2754:
    $P5657 = $P5650."new"($P5655, $P5656, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1771
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2755
    new $P5658, "Undef"
  vivify_2755:
    $P5659 = $P5643."new"($P5657, $P5646 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5658 :named("node"))
.annotate 'line', 1770
    $P5660 = $P5621."new"($P5639, $P5659)
.annotate 'line', 1758
    store_lex "$past", $P5660
.annotate 'line', 1782
    find_lex $P5662, "$past"
    unless_null $P5662, vivify_2756
    new $P5662, "Undef"
  vivify_2756:
    $P5663 = $P5662."list"()
    defined $I5664, $P5663
    unless $I5664, for_undef_2757
    iter $P5661, $P5663
    new $P5680, 'ExceptionHandler'
    set_label $P5680, loop5679_handler
    $P5680."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5680
  loop5679_test:
    unless $P5661, loop5679_done
    shift $P5665, $P5661
  loop5679_redo:
    .const 'Sub' $P5667 = "706_1304282286.73" 
    capture_lex $P5667
    $P5667($P5665)
  loop5679_next:
    goto loop5679_test
  loop5679_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5681, exception, 'type'
    eq $P5681, .CONTROL_LOOP_NEXT, loop5679_next
    eq $P5681, .CONTROL_LOOP_REDO, loop5679_redo
  loop5679_done:
    pop_eh 
  for_undef_2757:
  if_5615_end:
.annotate 'line', 1827
    find_lex $P5812, "$/"
    find_lex $P5813, "$past"
    unless_null $P5813, vivify_2764
    new $P5813, "Undef"
  vivify_2764:
    $P5814 = $P5812."!make"($P5813)
.annotate 'line', 1752
    .return ($P5814)
  control_5594:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5815, exception, "payload"
    .return ($P5815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5724"  :anon :subid("708_1304282286.73") :outer("705_1304282286.73")
.annotate 'line', 1796
    .const 'Sub' $P5751 = "709_1304282286.73" 
    capture_lex $P5751
.annotate 'line', 1797
    new $P5726, "Undef"
    .lex "$regex", $P5726
.annotate 'line', 1800
    new $P5727, "Undef"
    .lex "$prefix_meth", $P5727
.annotate 'line', 1798
    get_hll_global $P5728, "GLOBAL"
    nqp_get_package_through_who $P5729, $P5728, "Regex"
    nqp_get_package_through_who $P5730, $P5729, "P6Regex"
    nqp_get_package_through_who $P5731, $P5730, "Actions"
    get_who $P5732, $P5731
    set $P5733, $P5732["buildsub"]
    find_lex $P5734, "$/"
    unless_null $P5734, vivify_2703
    $P5734 = root_new ['parrot';'Hash']
  vivify_2703:
    set $P5735, $P5734["p6regex"]
    unless_null $P5735, vivify_2704
    new $P5735, "Undef"
  vivify_2704:
    $P5736 = $P5735."ast"()
    find_lex $P5737, "$?PACKAGE"
    get_who $P5738, $P5737
    set $P5739, $P5738["@BLOCK"]
    unless_null $P5739, vivify_2705
    $P5739 = root_new ['parrot';'ResizablePMCArray']
  vivify_2705:
    $P5740 = $P5739."shift"()
    $P5741 = $P5733($P5736, $P5740)
    store_lex "$regex", $P5741
.annotate 'line', 1799
    find_lex $P5742, "$regex"
    unless_null $P5742, vivify_2706
    new $P5742, "Undef"
  vivify_2706:
    find_lex $P5743, "$name"
    unless_null $P5743, vivify_2707
    new $P5743, "Undef"
  vivify_2707:
    $P5742."name"($P5743)
    find_lex $P5744, "$prefix_meth"
    unless_null $P5744, vivify_2708
    new $P5744, "Undef"
  vivify_2708:
.annotate 'line', 1802
    find_dynamic_lex $P5748, "$*PACKAGE-SETUP"
    unless_null $P5748, vivify_2709
    get_hll_global $P5746, "GLOBAL"
    get_who $P5747, $P5746
    set $P5748, $P5747["$PACKAGE-SETUP"]
    unless_null $P5748, vivify_2710
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2710:
  vivify_2709:
    defined $I5749, $P5748
    unless $I5749, if_5745_end
    .const 'Sub' $P5751 = "709_1304282286.73" 
    capture_lex $P5751
    $P5751()
  if_5745_end:
.annotate 'line', 1817
    get_hll_global $P5789, "GLOBAL"
    nqp_get_package_through_who $P5790, $P5789, "PAST"
    get_who $P5791, $P5790
    set $P5792, $P5791["Op"]
.annotate 'line', 1819
    new $P5793, "ResizablePMCArray"
    push $P5793, "Regex"
    push $P5793, "Method"
    find_lex $P5794, "$/"
    unless_null $P5794, vivify_2727
    new $P5794, "Undef"
  vivify_2727:
    $P5795 = "lexical_package_lookup"($P5793, $P5794)
    find_lex $P5796, "$regex"
    unless_null $P5796, vivify_2728
    new $P5796, "Undef"
  vivify_2728:
    $P5797 = $P5792."new"($P5795, $P5796, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1817
    store_lex "$past", $P5797
.annotate 'line', 1822
    find_lex $P5800, "$prefix_meth"
    unless_null $P5800, vivify_2729
    new $P5800, "Undef"
  vivify_2729:
    if $P5800, if_5799
    find_lex $P5808, "$regex"
    unless_null $P5808, vivify_2730
    new $P5808, "Undef"
  vivify_2730:
    set $P5798, $P5808
    goto if_5799_end
  if_5799:
.annotate 'line', 1823
    get_hll_global $P5801, "GLOBAL"
    nqp_get_package_through_who $P5802, $P5801, "PAST"
    get_who $P5803, $P5802
    set $P5804, $P5803["Stmts"]
    find_lex $P5805, "$regex"
    unless_null $P5805, vivify_2731
    new $P5805, "Undef"
  vivify_2731:
    find_lex $P5806, "$prefix_meth"
    unless_null $P5806, vivify_2732
    new $P5806, "Undef"
  vivify_2732:
    $P5807 = $P5804."new"($P5805, $P5806)
    set $P5798, $P5807
  if_5799_end:
.annotate 'line', 1822
    find_lex $P5809, "$past"
    unless_null $P5809, vivify_2733
    $P5809 = root_new ['parrot';'Hash']
    store_lex "$past", $P5809
  vivify_2733:
    set $P5809["sink"], $P5798
.annotate 'line', 1825
    find_lex $P5810, "@MODIFIERS"
    unless_null $P5810, vivify_2734
    $P5810 = root_new ['parrot';'ResizablePMCArray']
  vivify_2734:
    $P5811 = $P5810."shift"()
.annotate 'line', 1796
    .return ($P5811)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5750"  :anon :subid("709_1304282286.73") :outer("708_1304282286.73")
.annotate 'line', 1807
    $P5752 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P5752
.annotate 'line', 1804
    find_dynamic_lex $P5755, "$*SC"
    unless_null $P5755, vivify_2711
    get_hll_global $P5753, "GLOBAL"
    get_who $P5754, $P5753
    set $P5755, $P5754["$SC"]
    unless_null $P5755, vivify_2712
    die "Contextual $*SC not found"
  vivify_2712:
  vivify_2711:
    find_dynamic_lex $P5758, "$*PACKAGE"
    unless_null $P5758, vivify_2713
    get_hll_global $P5756, "GLOBAL"
    get_who $P5757, $P5756
    set $P5758, $P5757["$PACKAGE"]
    unless_null $P5758, vivify_2714
    die "Contextual $*PACKAGE not found"
  vivify_2714:
  vivify_2713:
    find_lex $P5759, "$name"
    unless_null $P5759, vivify_2715
    new $P5759, "Undef"
  vivify_2715:
    find_lex $P5760, "$regex"
    unless_null $P5760, vivify_2716
    new $P5760, "Undef"
  vivify_2716:
    $P5755."pkg_add_method"($P5758, "add_method", $P5759, $P5760, 0)
.annotate 'line', 1807
    find_lex $P5761, "$/"
    unless_null $P5761, vivify_2717
    $P5761 = root_new ['parrot';'Hash']
  vivify_2717:
    set $P5762, $P5761["p6regex"]
    unless_null $P5762, vivify_2718
    new $P5762, "Undef"
  vivify_2718:
    $P5763 = $P5762."ast"()
    $P5764 = $P5763."prefix_list"()
    store_lex "@prefixes", $P5764
.annotate 'line', 1808
    get_hll_global $P5765, "GLOBAL"
    nqp_get_package_through_who $P5766, $P5765, "PAST"
    get_who $P5767, $P5766
    set $P5768, $P5767["Block"]
.annotate 'line', 1809
    new $P5769, "String"
    assign $P5769, "!PREFIX__"
    find_lex $P5770, "$name"
    unless_null $P5770, vivify_2719
    new $P5770, "Undef"
  vivify_2719:
    concat $P5771, $P5769, $P5770
.annotate 'line', 1810
    get_hll_global $P5772, "GLOBAL"
    nqp_get_package_through_who $P5773, $P5772, "PAST"
    get_who $P5774, $P5773
    set $P5775, $P5774["Op"]
    find_lex $P5776, "@prefixes"
    unless_null $P5776, vivify_2720
    $P5776 = root_new ['parrot';'ResizablePMCArray']
  vivify_2720:
    $P5777 = $P5775."new"($P5776 :flat, "list" :named("pasttype"))
    $P5778 = $P5768."new"($P5777, $P5771 :named("name"), "method" :named("blocktype"))
.annotate 'line', 1808
    store_lex "$prefix_meth", $P5778
.annotate 'line', 1812
    find_dynamic_lex $P5781, "$*SC"
    unless_null $P5781, vivify_2721
    get_hll_global $P5779, "GLOBAL"
    get_who $P5780, $P5779
    set $P5781, $P5780["$SC"]
    unless_null $P5781, vivify_2722
    die "Contextual $*SC not found"
  vivify_2722:
  vivify_2721:
    find_dynamic_lex $P5784, "$*PACKAGE"
    unless_null $P5784, vivify_2723
    get_hll_global $P5782, "GLOBAL"
    get_who $P5783, $P5782
    set $P5784, $P5783["$PACKAGE"]
    unless_null $P5784, vivify_2724
    die "Contextual $*PACKAGE not found"
  vivify_2724:
  vivify_2723:
    find_lex $P5785, "$prefix_meth"
    unless_null $P5785, vivify_2725
    new $P5785, "Undef"
  vivify_2725:
    $P5786 = $P5785."name"()
    find_lex $P5787, "$prefix_meth"
    unless_null $P5787, vivify_2726
    new $P5787, "Undef"
  vivify_2726:
    $P5788 = $P5781."pkg_add_method"($P5784, "add_method", $P5786, $P5787, 0)
.annotate 'line', 1802
    .return ($P5788)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5686"  :anon :subid("707_1304282286.73") :outer("705_1304282286.73")
.annotate 'line', 1787
    $P5688 = root_new ['parrot';'Hash']
    .lex "%h", $P5688
.annotate 'line', 1786
    find_lex $P5689, "%h"
    unless_null $P5689, vivify_2735
    $P5689 = root_new ['parrot';'Hash']
  vivify_2735:
.annotate 'line', 1788
    find_lex $P5691, "$/"
    unless_null $P5691, vivify_2736
    $P5691 = root_new ['parrot';'Hash']
  vivify_2736:
    set $P5692, $P5691["sym"]
    unless_null $P5692, vivify_2737
    new $P5692, "Undef"
  vivify_2737:
    set $S5693, $P5692
    iseq $I5694, $S5693, "token"
    unless $I5694, if_5690_end
    new $P5695, "Integer"
    assign $P5695, 1
    find_lex $P5696, "%h"
    unless_null $P5696, vivify_2738
    $P5696 = root_new ['parrot';'Hash']
    store_lex "%h", $P5696
  vivify_2738:
    set $P5696["r"], $P5695
  if_5690_end:
.annotate 'line', 1789
    find_lex $P5698, "$/"
    unless_null $P5698, vivify_2739
    $P5698 = root_new ['parrot';'Hash']
  vivify_2739:
    set $P5699, $P5698["sym"]
    unless_null $P5699, vivify_2740
    new $P5699, "Undef"
  vivify_2740:
    set $S5700, $P5699
    iseq $I5701, $S5700, "rule"
    unless $I5701, if_5697_end
    new $P5702, "Integer"
    assign $P5702, 1
    find_lex $P5703, "%h"
    unless_null $P5703, vivify_2741
    $P5703 = root_new ['parrot';'Hash']
    store_lex "%h", $P5703
  vivify_2741:
    set $P5703["r"], $P5702
    new $P5704, "Integer"
    assign $P5704, 1
    find_lex $P5705, "%h"
    unless_null $P5705, vivify_2742
    $P5705 = root_new ['parrot';'Hash']
    store_lex "%h", $P5705
  vivify_2742:
    set $P5705["s"], $P5704
  if_5697_end:
.annotate 'line', 1790
    find_lex $P5706, "@MODIFIERS"
    unless_null $P5706, vivify_2743
    $P5706 = root_new ['parrot';'ResizablePMCArray']
  vivify_2743:
    find_lex $P5707, "%h"
    unless_null $P5707, vivify_2744
    $P5707 = root_new ['parrot';'Hash']
  vivify_2744:
    $P5706."unshift"($P5707)
.annotate 'line', 1791
    find_lex $P5708, "$name"
    unless_null $P5708, vivify_2745
    new $P5708, "Undef"
  vivify_2745:
    get_hll_global $P5709, "GLOBAL"
    nqp_get_package_through_who $P5710, $P5709, "Regex"
    nqp_get_package_through_who $P5711, $P5710, "P6Regex"
    nqp_get_package_through_who $P5712, $P5711, "Actions"
    get_who $P5713, $P5712
    set $P5713["$REGEXNAME"], $P5708
.annotate 'line', 1792
    find_lex $P5714, "$?PACKAGE"
    get_who $P5715, $P5714
    set $P5716, $P5715["@BLOCK"]
    unless_null $P5716, vivify_2746
    $P5716 = root_new ['parrot';'ResizablePMCArray']
  vivify_2746:
    set $P5717, $P5716[0]
    unless_null $P5717, vivify_2747
    new $P5717, "Undef"
  vivify_2747:
    $P5717."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1793
    find_lex $P5718, "$?PACKAGE"
    get_who $P5719, $P5718
    set $P5720, $P5719["@BLOCK"]
    unless_null $P5720, vivify_2748
    $P5720 = root_new ['parrot';'ResizablePMCArray']
  vivify_2748:
    set $P5721, $P5720[0]
    unless_null $P5721, vivify_2749
    new $P5721, "Undef"
  vivify_2749:
    $P5721."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1794
    new $P5722, "Exception"
    set $P5722['type'], .CONTROL_RETURN
    new $P5723, "Integer"
    assign $P5723, 0
    setattribute $P5722, 'payload', $P5723
    throw $P5722
.annotate 'line', 1786
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5666"  :anon :subid("706_1304282286.73") :outer("705_1304282286.73")
    .param pmc param_5668
.annotate 'line', 1782
    .lex "$_", param_5668
.annotate 'line', 1783
    find_dynamic_lex $P5671, "$*SC"
    unless_null $P5671, vivify_2758
    get_hll_global $P5669, "GLOBAL"
    get_who $P5670, $P5669
    set $P5671, $P5670["$SC"]
    unless_null $P5671, vivify_2759
    die "Contextual $*SC not found"
  vivify_2759:
  vivify_2758:
    find_dynamic_lex $P5674, "$*PACKAGE"
    unless_null $P5674, vivify_2760
    get_hll_global $P5672, "GLOBAL"
    get_who $P5673, $P5672
    set $P5674, $P5673["$PACKAGE"]
    unless_null $P5674, vivify_2761
    die "Contextual $*PACKAGE not found"
  vivify_2761:
  vivify_2760:
    find_lex $P5675, "$_"
    unless_null $P5675, vivify_2762
    new $P5675, "Undef"
  vivify_2762:
    $P5676 = $P5675."name"()
    find_lex $P5677, "$_"
    unless_null $P5677, vivify_2763
    new $P5677, "Undef"
  vivify_2763:
    $P5678 = $P5671."pkg_add_method"($P5674, "add_method", $P5676, $P5677, 0)
.annotate 'line', 1782
    .return ($P5678)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("710_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5817
    .param pmc param_5818
.annotate 'line', 1831
    .lex "self", param_5817
    .lex "$/", param_5818
.annotate 'line', 1832
    new $P5819, "Undef"
    .lex "$past", $P5819
    find_lex $P5822, "$/"
    unless_null $P5822, vivify_2765
    $P5822 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P5823, $P5822["args"]
    unless_null $P5823, vivify_2766
    new $P5823, "Undef"
  vivify_2766:
    if $P5823, if_5821
    get_hll_global $P5828, "GLOBAL"
    nqp_get_package_through_who $P5829, $P5828, "PAST"
    get_who $P5830, $P5829
    set $P5831, $P5830["Op"]
    find_lex $P5832, "$/"
    unless_null $P5832, vivify_2767
    new $P5832, "Undef"
  vivify_2767:
    $P5833 = $P5831."new"($P5832 :named("node"))
    set $P5820, $P5833
    goto if_5821_end
  if_5821:
    find_lex $P5824, "$/"
    unless_null $P5824, vivify_2768
    $P5824 = root_new ['parrot';'Hash']
  vivify_2768:
    set $P5825, $P5824["args"]
    unless_null $P5825, vivify_2769
    $P5825 = root_new ['parrot';'ResizablePMCArray']
  vivify_2769:
    set $P5826, $P5825[0]
    unless_null $P5826, vivify_2770
    new $P5826, "Undef"
  vivify_2770:
    $P5827 = $P5826."ast"()
    set $P5820, $P5827
  if_5821_end:
    store_lex "$past", $P5820
.annotate 'line', 1833
    find_lex $P5835, "$/"
    unless_null $P5835, vivify_2771
    $P5835 = root_new ['parrot';'Hash']
  vivify_2771:
    set $P5836, $P5835["quote"]
    unless_null $P5836, vivify_2772
    new $P5836, "Undef"
  vivify_2772:
    if $P5836, if_5834
.annotate 'line', 1837
    find_lex $P5843, "$/"
    unless_null $P5843, vivify_2773
    $P5843 = root_new ['parrot';'Hash']
  vivify_2773:
    set $P5844, $P5843["longname"]
    unless_null $P5844, vivify_2774
    new $P5844, "Undef"
  vivify_2774:
    set $S5845, $P5844
    iseq $I5846, $S5845, "HOW"
    if $I5846, if_5842
.annotate 'line', 1840
    find_lex $P5849, "$/"
    unless_null $P5849, vivify_2775
    $P5849 = root_new ['parrot';'Hash']
  vivify_2775:
    set $P5850, $P5849["longname"]
    unless_null $P5850, vivify_2776
    new $P5850, "Undef"
  vivify_2776:
    set $S5851, $P5850
    iseq $I5852, $S5851, "WHAT"
    if $I5852, if_5848
.annotate 'line', 1843
    find_lex $P5855, "$/"
    unless_null $P5855, vivify_2777
    $P5855 = root_new ['parrot';'Hash']
  vivify_2777:
    set $P5856, $P5855["longname"]
    unless_null $P5856, vivify_2778
    new $P5856, "Undef"
  vivify_2778:
    set $S5857, $P5856
    iseq $I5858, $S5857, "WHO"
    if $I5858, if_5854
.annotate 'line', 1847
    find_lex $P5860, "$past"
    unless_null $P5860, vivify_2779
    new $P5860, "Undef"
  vivify_2779:
    find_lex $P5861, "$/"
    unless_null $P5861, vivify_2780
    $P5861 = root_new ['parrot';'Hash']
  vivify_2780:
    set $P5862, $P5861["longname"]
    unless_null $P5862, vivify_2781
    new $P5862, "Undef"
  vivify_2781:
    set $S5863, $P5862
    $P5860."name"($S5863)
.annotate 'line', 1848
    find_lex $P5864, "$past"
    unless_null $P5864, vivify_2782
    new $P5864, "Undef"
  vivify_2782:
    $P5864."pasttype"("callmethod")
.annotate 'line', 1846
    goto if_5854_end
  if_5854:
.annotate 'line', 1844
    find_lex $P5859, "$past"
    unless_null $P5859, vivify_2783
    new $P5859, "Undef"
  vivify_2783:
    $P5859."pirop"("get_who PP")
  if_5854_end:
.annotate 'line', 1843
    goto if_5848_end
  if_5848:
.annotate 'line', 1841
    find_lex $P5853, "$past"
    unless_null $P5853, vivify_2784
    new $P5853, "Undef"
  vivify_2784:
    $P5853."pirop"("get_what PP")
  if_5848_end:
.annotate 'line', 1840
    goto if_5842_end
  if_5842:
.annotate 'line', 1838
    find_lex $P5847, "$past"
    unless_null $P5847, vivify_2785
    new $P5847, "Undef"
  vivify_2785:
    $P5847."pirop"("get_how PP")
  if_5842_end:
.annotate 'line', 1837
    goto if_5834_end
  if_5834:
.annotate 'line', 1834
    find_lex $P5837, "$past"
    unless_null $P5837, vivify_2786
    new $P5837, "Undef"
  vivify_2786:
    find_lex $P5838, "$/"
    unless_null $P5838, vivify_2787
    $P5838 = root_new ['parrot';'Hash']
  vivify_2787:
    set $P5839, $P5838["quote"]
    unless_null $P5839, vivify_2788
    new $P5839, "Undef"
  vivify_2788:
    $P5840 = $P5839."ast"()
    $P5837."name"($P5840)
.annotate 'line', 1835
    find_lex $P5841, "$past"
    unless_null $P5841, vivify_2789
    new $P5841, "Undef"
  vivify_2789:
    $P5841."pasttype"("callmethod")
  if_5834_end:
.annotate 'line', 1850
    find_lex $P5865, "$/"
    find_lex $P5866, "$past"
    unless_null $P5866, vivify_2790
    new $P5866, "Undef"
  vivify_2790:
    $P5867 = $P5865."!make"($P5866)
.annotate 'line', 1831
    .return ($P5867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("711_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5869
    .param pmc param_5870
.annotate 'line', 1855
    .lex "self", param_5869
    .lex "$/", param_5870
.annotate 'line', 1856
    find_lex $P5871, "$/"
    get_hll_global $P5872, "GLOBAL"
    nqp_get_package_through_who $P5873, $P5872, "PAST"
    get_who $P5874, $P5873
    set $P5875, $P5874["Var"]
    $P5876 = $P5875."new"("self" :named("name"))
    $P5877 = $P5871."!make"($P5876)
.annotate 'line', 1855
    .return ($P5877)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("712_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5879
    .param pmc param_5880
.annotate 'line', 1859
    .lex "self", param_5879
    .lex "$/", param_5880
.annotate 'line', 1860
    new $P5881, "Undef"
    .lex "$past", $P5881
    find_lex $P5882, "$/"
    unless_null $P5882, vivify_2791
    $P5882 = root_new ['parrot';'Hash']
  vivify_2791:
    set $P5883, $P5882["args"]
    unless_null $P5883, vivify_2792
    new $P5883, "Undef"
  vivify_2792:
    $P5884 = $P5883."ast"()
    store_lex "$past", $P5884
.annotate 'line', 1861
    find_lex $P5885, "$past"
    unless_null $P5885, vivify_2793
    new $P5885, "Undef"
  vivify_2793:
    find_lex $P5886, "$/"
    unless_null $P5886, vivify_2794
    $P5886 = root_new ['parrot';'Hash']
  vivify_2794:
    set $P5887, $P5886["deflongname"]
    unless_null $P5887, vivify_2795
    new $P5887, "Undef"
  vivify_2795:
    set $S5888, $P5887
    $P5885."name"($S5888)
.annotate 'line', 1862
    find_lex $P5889, "$/"
    find_lex $P5890, "$past"
    unless_null $P5890, vivify_2796
    new $P5890, "Undef"
  vivify_2796:
    $P5891 = $P5889."!make"($P5890)
.annotate 'line', 1859
    .return ($P5891)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("713_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5893
    .param pmc param_5894
.annotate 'line', 1865
    .const 'Sub' $P5912 = "714_1304282286.73" 
    capture_lex $P5912
    .lex "self", param_5893
    .lex "$/", param_5894
.annotate 'line', 1867
    new $P5895, "Undef"
    .lex "$var", $P5895
.annotate 'line', 1877
    new $P5896, "Undef"
    .lex "$past", $P5896
.annotate 'line', 1865
    find_lex $P5897, "$var"
    unless_null $P5897, vivify_2797
    new $P5897, "Undef"
  vivify_2797:
.annotate 'line', 1868
    find_lex $P5899, "$/"
    unless_null $P5899, vivify_2798
    $P5899 = root_new ['parrot';'Hash']
  vivify_2798:
    set $P5900, $P5899["name"]
    unless_null $P5900, vivify_2799
    new $P5900, "Undef"
  vivify_2799:
    set $S5901, $P5900
    $P5902 = "is_lexical"($S5901)
    if $P5902, if_5898
.annotate 'line', 1871
    .const 'Sub' $P5912 = "714_1304282286.73" 
    capture_lex $P5912
    $P5912()
    goto if_5898_end
  if_5898:
.annotate 'line', 1869
    get_hll_global $P5903, "GLOBAL"
    nqp_get_package_through_who $P5904, $P5903, "PAST"
    get_who $P5905, $P5904
    set $P5906, $P5905["Var"]
    find_lex $P5907, "$/"
    unless_null $P5907, vivify_2805
    $P5907 = root_new ['parrot';'Hash']
  vivify_2805:
    set $P5908, $P5907["name"]
    unless_null $P5908, vivify_2806
    new $P5908, "Undef"
  vivify_2806:
    set $S5909, $P5908
    $P5910 = $P5906."new"($S5909 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5910
  if_5898_end:
.annotate 'line', 1877
    find_lex $P5921, "$var"
    unless_null $P5921, vivify_2807
    new $P5921, "Undef"
  vivify_2807:
    store_lex "$past", $P5921
.annotate 'line', 1878
    find_lex $P5923, "$/"
    unless_null $P5923, vivify_2808
    $P5923 = root_new ['parrot';'Hash']
  vivify_2808:
    set $P5924, $P5923["args"]
    unless_null $P5924, vivify_2809
    new $P5924, "Undef"
  vivify_2809:
    unless $P5924, if_5922_end
.annotate 'line', 1879
    find_lex $P5925, "$/"
    unless_null $P5925, vivify_2810
    $P5925 = root_new ['parrot';'Hash']
  vivify_2810:
    set $P5926, $P5925["args"]
    unless_null $P5926, vivify_2811
    $P5926 = root_new ['parrot';'ResizablePMCArray']
  vivify_2811:
    set $P5927, $P5926[0]
    unless_null $P5927, vivify_2812
    new $P5927, "Undef"
  vivify_2812:
    $P5928 = $P5927."ast"()
    store_lex "$past", $P5928
.annotate 'line', 1880
    find_lex $P5929, "$past"
    unless_null $P5929, vivify_2813
    new $P5929, "Undef"
  vivify_2813:
    find_lex $P5930, "$var"
    unless_null $P5930, vivify_2814
    new $P5930, "Undef"
  vivify_2814:
    $P5929."unshift"($P5930)
  if_5922_end:
.annotate 'line', 1882
    find_lex $P5931, "$/"
    find_lex $P5932, "$past"
    unless_null $P5932, vivify_2815
    new $P5932, "Undef"
  vivify_2815:
    $P5933 = $P5931."!make"($P5932)
.annotate 'line', 1865
    .return ($P5933)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5911"  :anon :subid("714_1304282286.73") :outer("713_1304282286.73")
.annotate 'line', 1872
    $P5913 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5913
    find_lex $P5914, "$/"
    unless_null $P5914, vivify_2800
    $P5914 = root_new ['parrot';'Hash']
  vivify_2800:
    set $P5915, $P5914["name"]
    unless_null $P5915, vivify_2801
    $P5915 = root_new ['parrot';'Hash']
  vivify_2801:
    set $P5916, $P5915["identifier"]
    unless_null $P5916, vivify_2802
    new $P5916, "Undef"
  vivify_2802:
    clone $P5917, $P5916
    store_lex "@ns", $P5917
.annotate 'line', 1873
    find_lex $P5918, "@ns"
    unless_null $P5918, vivify_2803
    $P5918 = root_new ['parrot';'ResizablePMCArray']
  vivify_2803:
    find_lex $P5919, "$/"
    unless_null $P5919, vivify_2804
    new $P5919, "Undef"
  vivify_2804:
    $P5920 = "lexical_package_lookup"($P5918, $P5919)
    store_lex "$var", $P5920
.annotate 'line', 1871
    .return ($P5920)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("715_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5935
    .param pmc param_5936
.annotate 'line', 1885
    .lex "self", param_5935
    .lex "$/", param_5936
.annotate 'line', 1886
    new $P5937, "Undef"
    .lex "$past", $P5937
.annotate 'line', 1887
    new $P5938, "Undef"
    .lex "$pirop", $P5938
.annotate 'line', 1886
    find_lex $P5941, "$/"
    unless_null $P5941, vivify_2816
    $P5941 = root_new ['parrot';'Hash']
  vivify_2816:
    set $P5942, $P5941["args"]
    unless_null $P5942, vivify_2817
    new $P5942, "Undef"
  vivify_2817:
    if $P5942, if_5940
    get_hll_global $P5947, "GLOBAL"
    nqp_get_package_through_who $P5948, $P5947, "PAST"
    get_who $P5949, $P5948
    set $P5950, $P5949["Op"]
    find_lex $P5951, "$/"
    unless_null $P5951, vivify_2818
    new $P5951, "Undef"
  vivify_2818:
    $P5952 = $P5950."new"($P5951 :named("node"))
    set $P5939, $P5952
    goto if_5940_end
  if_5940:
    find_lex $P5943, "$/"
    unless_null $P5943, vivify_2819
    $P5943 = root_new ['parrot';'Hash']
  vivify_2819:
    set $P5944, $P5943["args"]
    unless_null $P5944, vivify_2820
    $P5944 = root_new ['parrot';'ResizablePMCArray']
  vivify_2820:
    set $P5945, $P5944[0]
    unless_null $P5945, vivify_2821
    new $P5945, "Undef"
  vivify_2821:
    $P5946 = $P5945."ast"()
    set $P5939, $P5946
  if_5940_end:
    store_lex "$past", $P5939
.annotate 'line', 1887
    find_lex $P5953, "$/"
    unless_null $P5953, vivify_2822
    $P5953 = root_new ['parrot';'Hash']
  vivify_2822:
    set $P5954, $P5953["op"]
    unless_null $P5954, vivify_2823
    new $P5954, "Undef"
  vivify_2823:
    set $S5955, $P5954
    new $P5956, 'String'
    set $P5956, $S5955
    store_lex "$pirop", $P5956
.annotate 'line', 1888
    find_lex $P5957, "$pirop"
    unless_null $P5957, vivify_2824
    new $P5957, "Undef"
  vivify_2824:
    set $S5958, $P5957
    split $P5959, "__", $S5958
    join $S5960, " ", $P5959
    new $P5961, 'String'
    set $P5961, $S5960
    store_lex "$pirop", $P5961
.annotate 'line', 1889
    find_lex $P5962, "$past"
    unless_null $P5962, vivify_2825
    new $P5962, "Undef"
  vivify_2825:
    find_lex $P5963, "$pirop"
    unless_null $P5963, vivify_2826
    new $P5963, "Undef"
  vivify_2826:
    $P5962."pirop"($P5963)
.annotate 'line', 1890
    find_lex $P5964, "$past"
    unless_null $P5964, vivify_2827
    new $P5964, "Undef"
  vivify_2827:
    $P5964."pasttype"("pirop")
.annotate 'line', 1891
    find_lex $P5965, "$/"
    find_lex $P5966, "$past"
    unless_null $P5966, vivify_2828
    new $P5966, "Undef"
  vivify_2828:
    $P5967 = $P5965."!make"($P5966)
.annotate 'line', 1885
    .return ($P5967)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("716_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5969
    .param pmc param_5970
.annotate 'line', 1894
    .lex "self", param_5969
    .lex "$/", param_5970
.annotate 'line', 1895
    find_lex $P5971, "$/"
    get_hll_global $P5972, "GLOBAL"
    nqp_get_package_through_who $P5973, $P5972, "PAST"
    get_who $P5974, $P5973
    set $P5975, $P5974["Op"]
    $P5976 = $P5975."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5977 = $P5971."!make"($P5976)
.annotate 'line', 1894
    .return ($P5977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("717_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5979
    .param pmc param_5980
.annotate 'line', 1900
    .lex "self", param_5979
    .lex "$/", param_5980
    find_lex $P5981, "$/"
    find_lex $P5982, "$/"
    unless_null $P5982, vivify_2829
    $P5982 = root_new ['parrot';'Hash']
  vivify_2829:
    set $P5983, $P5982["arglist"]
    unless_null $P5983, vivify_2830
    new $P5983, "Undef"
  vivify_2830:
    $P5984 = $P5983."ast"()
    $P5985 = $P5981."!make"($P5984)
    .return ($P5985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("718_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_5987
    .param pmc param_5988
.annotate 'line', 1902
    .const 'Sub' $P6002 = "719_1304282286.73" 
    capture_lex $P6002
    .lex "self", param_5987
    .lex "$/", param_5988
.annotate 'line', 1903
    new $P5989, "Undef"
    .lex "$past", $P5989
.annotate 'line', 1911
    new $P5990, "Undef"
    .lex "$i", $P5990
.annotate 'line', 1912
    new $P5991, "Undef"
    .lex "$n", $P5991
.annotate 'line', 1903
    get_hll_global $P5992, "GLOBAL"
    nqp_get_package_through_who $P5993, $P5992, "PAST"
    get_who $P5994, $P5993
    set $P5995, $P5994["Op"]
    find_lex $P5996, "$/"
    unless_null $P5996, vivify_2831
    new $P5996, "Undef"
  vivify_2831:
    $P5997 = $P5995."new"("call" :named("pasttype"), $P5996 :named("node"))
    store_lex "$past", $P5997
.annotate 'line', 1904
    find_lex $P5999, "$/"
    unless_null $P5999, vivify_2832
    $P5999 = root_new ['parrot';'Hash']
  vivify_2832:
    set $P6000, $P5999["EXPR"]
    unless_null $P6000, vivify_2833
    new $P6000, "Undef"
  vivify_2833:
    unless $P6000, if_5998_end
    .const 'Sub' $P6002 = "719_1304282286.73" 
    capture_lex $P6002
    $P6002()
  if_5998_end:
.annotate 'line', 1911
    new $P6034, "Integer"
    assign $P6034, 0
    store_lex "$i", $P6034
.annotate 'line', 1912
    find_lex $P6035, "$past"
    unless_null $P6035, vivify_2844
    new $P6035, "Undef"
  vivify_2844:
    $P6036 = $P6035."list"()
    set $N6037, $P6036
    new $P6038, 'Float'
    set $P6038, $N6037
    store_lex "$n", $P6038
.annotate 'line', 1913
    new $P6089, 'ExceptionHandler'
    set_label $P6089, loop6088_handler
    $P6089."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6089
  loop6088_test:
    find_lex $P6039, "$i"
    unless_null $P6039, vivify_2845
    new $P6039, "Undef"
  vivify_2845:
    set $N6040, $P6039
    find_lex $P6041, "$n"
    unless_null $P6041, vivify_2846
    new $P6041, "Undef"
  vivify_2846:
    set $N6042, $P6041
    islt $I6043, $N6040, $N6042
    unless $I6043, loop6088_done
  loop6088_redo:
.annotate 'line', 1914
    find_lex $P6045, "$i"
    unless_null $P6045, vivify_2847
    new $P6045, "Undef"
  vivify_2847:
    set $I6046, $P6045
    find_lex $P6047, "$past"
    unless_null $P6047, vivify_2848
    $P6047 = root_new ['parrot';'ResizablePMCArray']
  vivify_2848:
    set $P6048, $P6047[$I6046]
    unless_null $P6048, vivify_2849
    new $P6048, "Undef"
  vivify_2849:
    $S6049 = $P6048."name"()
    iseq $I6050, $S6049, "&prefix:<|>"
    unless $I6050, if_6044_end
.annotate 'line', 1915
    find_lex $P6051, "$i"
    unless_null $P6051, vivify_2850
    new $P6051, "Undef"
  vivify_2850:
    set $I6052, $P6051
    find_lex $P6053, "$past"
    unless_null $P6053, vivify_2851
    $P6053 = root_new ['parrot';'ResizablePMCArray']
  vivify_2851:
    set $P6054, $P6053[$I6052]
    unless_null $P6054, vivify_2852
    $P6054 = root_new ['parrot';'ResizablePMCArray']
  vivify_2852:
    set $P6055, $P6054[0]
    unless_null $P6055, vivify_2853
    new $P6055, "Undef"
  vivify_2853:
    find_lex $P6056, "$i"
    unless_null $P6056, vivify_2854
    new $P6056, "Undef"
  vivify_2854:
    set $I6057, $P6056
    find_lex $P6058, "$past"
    unless_null $P6058, vivify_2855
    $P6058 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6058
  vivify_2855:
    set $P6058[$I6057], $P6055
.annotate 'line', 1916
    find_lex $P6059, "$i"
    unless_null $P6059, vivify_2856
    new $P6059, "Undef"
  vivify_2856:
    set $I6060, $P6059
    find_lex $P6061, "$past"
    unless_null $P6061, vivify_2857
    $P6061 = root_new ['parrot';'ResizablePMCArray']
  vivify_2857:
    set $P6062, $P6061[$I6060]
    unless_null $P6062, vivify_2858
    new $P6062, "Undef"
  vivify_2858:
    $P6062."flat"(1)
.annotate 'line', 1917
    find_lex $P6066, "$i"
    unless_null $P6066, vivify_2859
    new $P6066, "Undef"
  vivify_2859:
    set $I6067, $P6066
    find_lex $P6068, "$past"
    unless_null $P6068, vivify_2860
    $P6068 = root_new ['parrot';'ResizablePMCArray']
  vivify_2860:
    set $P6069, $P6068[$I6067]
    unless_null $P6069, vivify_2861
    new $P6069, "Undef"
  vivify_2861:
    get_hll_global $P6070, "GLOBAL"
    nqp_get_package_through_who $P6071, $P6070, "PAST"
    get_who $P6072, $P6071
    set $P6073, $P6072["Val"]
    $P6074 = $P6069."isa"($P6073)
    if $P6074, if_6065
    set $P6064, $P6074
    goto if_6065_end
  if_6065:
.annotate 'line', 1918
    find_lex $P6075, "$i"
    unless_null $P6075, vivify_2862
    new $P6075, "Undef"
  vivify_2862:
    set $I6076, $P6075
    find_lex $P6077, "$past"
    unless_null $P6077, vivify_2863
    $P6077 = root_new ['parrot';'ResizablePMCArray']
  vivify_2863:
    set $P6078, $P6077[$I6076]
    unless_null $P6078, vivify_2864
    new $P6078, "Undef"
  vivify_2864:
    $S6079 = $P6078."name"()
    substr $S6080, $S6079, 0, 1
    iseq $I6081, $S6080, "%"
    new $P6064, 'Integer'
    set $P6064, $I6081
  if_6065_end:
    unless $P6064, if_6063_end
.annotate 'line', 1919
    find_lex $P6082, "$i"
    unless_null $P6082, vivify_2865
    new $P6082, "Undef"
  vivify_2865:
    set $I6083, $P6082
    find_lex $P6084, "$past"
    unless_null $P6084, vivify_2866
    $P6084 = root_new ['parrot';'ResizablePMCArray']
  vivify_2866:
    set $P6085, $P6084[$I6083]
    unless_null $P6085, vivify_2867
    new $P6085, "Undef"
  vivify_2867:
    $P6085."named"(1)
  if_6063_end:
  if_6044_end:
.annotate 'line', 1914
    find_lex $P6086, "$i"
    unless_null $P6086, vivify_2868
    new $P6086, "Undef"
  vivify_2868:
    clone $P6087, $P6086
    inc $P6086
  loop6088_next:
.annotate 'line', 1913
    goto loop6088_test
  loop6088_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6090, exception, 'type'
    eq $P6090, .CONTROL_LOOP_NEXT, loop6088_next
    eq $P6090, .CONTROL_LOOP_REDO, loop6088_redo
  loop6088_done:
    pop_eh 
.annotate 'line', 1924
    find_lex $P6091, "$/"
    find_lex $P6092, "$past"
    unless_null $P6092, vivify_2869
    new $P6092, "Undef"
  vivify_2869:
    $P6093 = $P6091."!make"($P6092)
.annotate 'line', 1902
    .return ($P6093)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6001"  :anon :subid("719_1304282286.73") :outer("718_1304282286.73")
.annotate 'line', 1904
    .const 'Sub' $P6023 = "720_1304282286.73" 
    capture_lex $P6023
.annotate 'line', 1905
    new $P6003, "Undef"
    .lex "$expr", $P6003
    find_lex $P6004, "$/"
    unless_null $P6004, vivify_2834
    $P6004 = root_new ['parrot';'Hash']
  vivify_2834:
    set $P6005, $P6004["EXPR"]
    unless_null $P6005, vivify_2835
    new $P6005, "Undef"
  vivify_2835:
    $P6006 = $P6005."ast"()
    store_lex "$expr", $P6006
.annotate 'line', 1906
    find_lex $P6011, "$expr"
    unless_null $P6011, vivify_2836
    new $P6011, "Undef"
  vivify_2836:
    $S6012 = $P6011."name"()
    iseq $I6013, $S6012, "&infix:<,>"
    if $I6013, if_6010
    new $P6009, 'Integer'
    set $P6009, $I6013
    goto if_6010_end
  if_6010:
    find_lex $P6014, "$expr"
    unless_null $P6014, vivify_2837
    new $P6014, "Undef"
  vivify_2837:
    $P6015 = $P6014."named"()
    isfalse $I6016, $P6015
    new $P6009, 'Integer'
    set $P6009, $I6016
  if_6010_end:
    if $P6009, if_6008
.annotate 'line', 1909
    find_lex $P6031, "$past"
    unless_null $P6031, vivify_2838
    new $P6031, "Undef"
  vivify_2838:
    find_lex $P6032, "$expr"
    unless_null $P6032, vivify_2839
    new $P6032, "Undef"
  vivify_2839:
    $P6033 = $P6031."push"($P6032)
    set $P6007, $P6033
.annotate 'line', 1906
    goto if_6008_end
  if_6008:
.annotate 'line', 1907
    find_lex $P6018, "$expr"
    unless_null $P6018, vivify_2840
    new $P6018, "Undef"
  vivify_2840:
    $P6019 = $P6018."list"()
    defined $I6020, $P6019
    unless $I6020, for_undef_2841
    iter $P6017, $P6019
    new $P6029, 'ExceptionHandler'
    set_label $P6029, loop6028_handler
    $P6029."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6029
  loop6028_test:
    unless $P6017, loop6028_done
    shift $P6021, $P6017
  loop6028_redo:
    .const 'Sub' $P6023 = "720_1304282286.73" 
    capture_lex $P6023
    $P6023($P6021)
  loop6028_next:
    goto loop6028_test
  loop6028_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6030, exception, 'type'
    eq $P6030, .CONTROL_LOOP_NEXT, loop6028_next
    eq $P6030, .CONTROL_LOOP_REDO, loop6028_redo
  loop6028_done:
    pop_eh 
  for_undef_2841:
.annotate 'line', 1906
    set $P6007, $P6017
  if_6008_end:
.annotate 'line', 1904
    .return ($P6007)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6022"  :anon :subid("720_1304282286.73") :outer("719_1304282286.73")
    .param pmc param_6024
.annotate 'line', 1907
    .lex "$_", param_6024
    find_lex $P6025, "$past"
    unless_null $P6025, vivify_2842
    new $P6025, "Undef"
  vivify_2842:
    find_lex $P6026, "$_"
    unless_null $P6026, vivify_2843
    new $P6026, "Undef"
  vivify_2843:
    $P6027 = $P6025."push"($P6026)
    .return ($P6027)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("721_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6095
    .param pmc param_6096
.annotate 'line', 1927
    .lex "self", param_6095
    .lex "$/", param_6096
    find_lex $P6097, "$/"
    find_lex $P6098, "$/"
    unless_null $P6098, vivify_2870
    $P6098 = root_new ['parrot';'Hash']
  vivify_2870:
    set $P6099, $P6098["multi_declarator"]
    unless_null $P6099, vivify_2871
    new $P6099, "Undef"
  vivify_2871:
    $P6100 = $P6099."ast"()
    $P6101 = $P6097."!make"($P6100)
    .return ($P6101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("722_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6103
    .param pmc param_6104
.annotate 'line', 1929
    .lex "self", param_6103
    .lex "$/", param_6104
    find_lex $P6105, "$/"
    find_lex $P6106, "$/"
    unless_null $P6106, vivify_2872
    $P6106 = root_new ['parrot';'Hash']
  vivify_2872:
    set $P6107, $P6106["value"]
    unless_null $P6107, vivify_2873
    new $P6107, "Undef"
  vivify_2873:
    $P6108 = $P6107."ast"()
    $P6109 = $P6105."!make"($P6108)
    .return ($P6109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("723_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6111
    .param pmc param_6112
.annotate 'line', 1931
    .lex "self", param_6111
    .lex "$/", param_6112
.annotate 'line', 1932
    find_lex $P6113, "$/"
.annotate 'line', 1933
    find_lex $P6116, "$/"
    unless_null $P6116, vivify_2874
    $P6116 = root_new ['parrot';'Hash']
  vivify_2874:
    set $P6117, $P6116["EXPR"]
    unless_null $P6117, vivify_2875
    new $P6117, "Undef"
  vivify_2875:
    if $P6117, if_6115
.annotate 'line', 1934
    get_hll_global $P6122, "GLOBAL"
    nqp_get_package_through_who $P6123, $P6122, "PAST"
    get_who $P6124, $P6123
    set $P6125, $P6124["Op"]
    find_lex $P6126, "$/"
    unless_null $P6126, vivify_2876
    new $P6126, "Undef"
  vivify_2876:
    $P6127 = $P6125."new"("list" :named("pasttype"), $P6126 :named("node"))
    set $P6114, $P6127
.annotate 'line', 1933
    goto if_6115_end
  if_6115:
    find_lex $P6118, "$/"
    unless_null $P6118, vivify_2877
    $P6118 = root_new ['parrot';'Hash']
  vivify_2877:
    set $P6119, $P6118["EXPR"]
    unless_null $P6119, vivify_2878
    $P6119 = root_new ['parrot';'ResizablePMCArray']
  vivify_2878:
    set $P6120, $P6119[0]
    unless_null $P6120, vivify_2879
    new $P6120, "Undef"
  vivify_2879:
    $P6121 = $P6120."ast"()
    set $P6114, $P6121
  if_6115_end:
    $P6128 = $P6113."!make"($P6114)
.annotate 'line', 1931
    .return ($P6128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("724_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6130
    .param pmc param_6131
.annotate 'line', 1937
    .lex "self", param_6130
    .lex "$/", param_6131
.annotate 'line', 1938
    new $P6132, "Undef"
    .lex "$past", $P6132
.annotate 'line', 1937
    find_lex $P6133, "$past"
    unless_null $P6133, vivify_2880
    new $P6133, "Undef"
  vivify_2880:
.annotate 'line', 1939
    find_lex $P6135, "$/"
    unless_null $P6135, vivify_2881
    $P6135 = root_new ['parrot';'Hash']
  vivify_2881:
    set $P6136, $P6135["EXPR"]
    unless_null $P6136, vivify_2882
    new $P6136, "Undef"
  vivify_2882:
    if $P6136, if_6134
.annotate 'line', 1946
    get_hll_global $P6151, "GLOBAL"
    nqp_get_package_through_who $P6152, $P6151, "PAST"
    get_who $P6153, $P6152
    set $P6154, $P6153["Op"]
    $P6155 = $P6154."new"("list" :named("pasttype"))
    store_lex "$past", $P6155
.annotate 'line', 1945
    goto if_6134_end
  if_6134:
.annotate 'line', 1940
    find_lex $P6137, "$/"
    unless_null $P6137, vivify_2883
    $P6137 = root_new ['parrot';'Hash']
  vivify_2883:
    set $P6138, $P6137["EXPR"]
    unless_null $P6138, vivify_2884
    $P6138 = root_new ['parrot';'ResizablePMCArray']
  vivify_2884:
    set $P6139, $P6138[0]
    unless_null $P6139, vivify_2885
    new $P6139, "Undef"
  vivify_2885:
    $P6140 = $P6139."ast"()
    store_lex "$past", $P6140
.annotate 'line', 1941
    find_lex $P6142, "$past"
    unless_null $P6142, vivify_2886
    new $P6142, "Undef"
  vivify_2886:
    $S6143 = $P6142."name"()
    isne $I6144, $S6143, "&infix:<,>"
    unless $I6144, if_6141_end
.annotate 'line', 1942
    get_hll_global $P6145, "GLOBAL"
    nqp_get_package_through_who $P6146, $P6145, "PAST"
    get_who $P6147, $P6146
    set $P6148, $P6147["Op"]
    find_lex $P6149, "$past"
    unless_null $P6149, vivify_2887
    new $P6149, "Undef"
  vivify_2887:
    $P6150 = $P6148."new"($P6149, "list" :named("pasttype"))
    store_lex "$past", $P6150
  if_6141_end:
  if_6134_end:
.annotate 'line', 1948
    find_lex $P6156, "$past"
    unless_null $P6156, vivify_2888
    new $P6156, "Undef"
  vivify_2888:
    $P6156."name"("&circumfix:<[ ]>")
.annotate 'line', 1949
    find_lex $P6157, "$/"
    find_lex $P6158, "$past"
    unless_null $P6158, vivify_2889
    new $P6158, "Undef"
  vivify_2889:
    $P6159 = $P6157."!make"($P6158)
.annotate 'line', 1937
    .return ($P6159)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("725_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6161
    .param pmc param_6162
.annotate 'line', 1952
    .lex "self", param_6161
    .lex "$/", param_6162
    find_lex $P6163, "$/"
    find_lex $P6164, "$/"
    unless_null $P6164, vivify_2890
    $P6164 = root_new ['parrot';'Hash']
  vivify_2890:
    set $P6165, $P6164["quote_EXPR"]
    unless_null $P6165, vivify_2891
    new $P6165, "Undef"
  vivify_2891:
    $P6166 = $P6165."ast"()
    $P6167 = $P6163."!make"($P6166)
    .return ($P6167)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("726_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6169
    .param pmc param_6170
.annotate 'line', 1953
    .lex "self", param_6169
    .lex "$/", param_6170
    find_lex $P6171, "$/"
    find_lex $P6172, "$/"
    unless_null $P6172, vivify_2892
    $P6172 = root_new ['parrot';'Hash']
  vivify_2892:
    set $P6173, $P6172["quote_EXPR"]
    unless_null $P6173, vivify_2893
    new $P6173, "Undef"
  vivify_2893:
    $P6174 = $P6173."ast"()
    $P6175 = $P6171."!make"($P6174)
    .return ($P6175)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("727_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6177
    .param pmc param_6178
.annotate 'line', 1955
    .const 'Sub' $P6189 = "728_1304282286.73" 
    capture_lex $P6189
    .lex "self", param_6177
    .lex "$/", param_6178
.annotate 'line', 1956
    find_lex $P6181, "$/"
    unless_null $P6181, vivify_2894
    $P6181 = root_new ['parrot';'Hash']
  vivify_2894:
    set $P6182, $P6181["pblock"]
    unless_null $P6182, vivify_2895
    $P6182 = root_new ['parrot';'Hash']
  vivify_2895:
    set $P6183, $P6182["blockoid"]
    unless_null $P6183, vivify_2896
    $P6183 = root_new ['parrot';'Hash']
  vivify_2896:
    set $P6184, $P6183["statementlist"]
    unless_null $P6184, vivify_2897
    $P6184 = root_new ['parrot';'Hash']
  vivify_2897:
    set $P6185, $P6184["statement"]
    unless_null $P6185, vivify_2898
    new $P6185, "Undef"
  vivify_2898:
    set $N6186, $P6185
    isgt $I6187, $N6186, 0.0
    if $I6187, if_6180
.annotate 'line', 1961
    find_lex $P6202, "$/"
    unless_null $P6202, vivify_2899
    $P6202 = root_new ['parrot';'Hash']
  vivify_2899:
    set $P6203, $P6202["pblock"]
    unless_null $P6203, vivify_2900
    $P6203 = root_new ['parrot';'Hash']
  vivify_2900:
    set $P6204, $P6203["blockoid"]
    unless_null $P6204, vivify_2901
    $P6204 = root_new ['parrot';'Hash']
  vivify_2901:
    set $P6205, $P6204["you_are_here"]
    unless_null $P6205, vivify_2902
    new $P6205, "Undef"
  vivify_2902:
    if $P6205, if_6201
.annotate 'line', 1965
    find_lex $P6211, "$/"
    $P6212 = "vivitype"("%")
    $P6213 = $P6211."!make"($P6212)
.annotate 'line', 1964
    set $P6200, $P6213
.annotate 'line', 1961
    goto if_6201_end
  if_6201:
.annotate 'line', 1962
    find_lex $P6206, "$/"
    find_lex $P6207, "$/"
    unless_null $P6207, vivify_2903
    $P6207 = root_new ['parrot';'Hash']
  vivify_2903:
    set $P6208, $P6207["pblock"]
    unless_null $P6208, vivify_2904
    new $P6208, "Undef"
  vivify_2904:
    $P6209 = $P6208."ast"()
    $P6210 = $P6206."!make"($P6209)
.annotate 'line', 1961
    set $P6200, $P6210
  if_6201_end:
    set $P6179, $P6200
.annotate 'line', 1956
    goto if_6180_end
  if_6180:
    .const 'Sub' $P6189 = "728_1304282286.73" 
    capture_lex $P6189
    $P6199 = $P6189()
    set $P6179, $P6199
  if_6180_end:
.annotate 'line', 1955
    .return ($P6179)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6188"  :anon :subid("728_1304282286.73") :outer("727_1304282286.73")
.annotate 'line', 1957
    new $P6190, "Undef"
    .lex "$past", $P6190
    find_lex $P6191, "$/"
    unless_null $P6191, vivify_2905
    $P6191 = root_new ['parrot';'Hash']
  vivify_2905:
    set $P6192, $P6191["pblock"]
    unless_null $P6192, vivify_2906
    new $P6192, "Undef"
  vivify_2906:
    $P6193 = $P6192."ast"()
    store_lex "$past", $P6193
.annotate 'line', 1958
    new $P6194, "Integer"
    assign $P6194, 1
    find_lex $P6195, "$past"
    unless_null $P6195, vivify_2907
    $P6195 = root_new ['parrot';'Hash']
    store_lex "$past", $P6195
  vivify_2907:
    set $P6195["bareblock"], $P6194
.annotate 'line', 1959
    find_dynamic_lex $P6196, "$/"
    find_lex $P6197, "$past"
    unless_null $P6197, vivify_2908
    new $P6197, "Undef"
  vivify_2908:
    $P6198 = $P6196."!make"($P6197)
.annotate 'line', 1956
    .return ($P6198)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("729_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6215
    .param pmc param_6216
.annotate 'line', 1969
    .lex "self", param_6215
    .lex "$/", param_6216
.annotate 'line', 1970
    new $P6217, "Undef"
    .lex "$name", $P6217
    find_lex $P6220, "$/"
    unless_null $P6220, vivify_2909
    $P6220 = root_new ['parrot';'Hash']
  vivify_2909:
    set $P6221, $P6220["sigil"]
    unless_null $P6221, vivify_2910
    new $P6221, "Undef"
  vivify_2910:
    set $S6222, $P6221
    iseq $I6223, $S6222, "@"
    if $I6223, if_6219
.annotate 'line', 1971
    find_lex $P6227, "$/"
    unless_null $P6227, vivify_2911
    $P6227 = root_new ['parrot';'Hash']
  vivify_2911:
    set $P6228, $P6227["sigil"]
    unless_null $P6228, vivify_2912
    new $P6228, "Undef"
  vivify_2912:
    set $S6229, $P6228
    iseq $I6230, $S6229, "%"
    if $I6230, if_6226
    new $P6232, "String"
    assign $P6232, "item"
    set $P6225, $P6232
    goto if_6226_end
  if_6226:
    new $P6231, "String"
    assign $P6231, "hash"
    set $P6225, $P6231
  if_6226_end:
    set $P6218, $P6225
.annotate 'line', 1970
    goto if_6219_end
  if_6219:
    new $P6224, "String"
    assign $P6224, "list"
    set $P6218, $P6224
  if_6219_end:
    store_lex "$name", $P6218
.annotate 'line', 1973
    find_lex $P6233, "$/"
    get_hll_global $P6234, "GLOBAL"
    nqp_get_package_through_who $P6235, $P6234, "PAST"
    get_who $P6236, $P6235
    set $P6237, $P6236["Op"]
    find_lex $P6238, "$name"
    unless_null $P6238, vivify_2913
    new $P6238, "Undef"
  vivify_2913:
    find_lex $P6239, "$/"
    unless_null $P6239, vivify_2914
    $P6239 = root_new ['parrot';'Hash']
  vivify_2914:
    set $P6240, $P6239["semilist"]
    unless_null $P6240, vivify_2915
    new $P6240, "Undef"
  vivify_2915:
    $P6241 = $P6240."ast"()
    $P6242 = $P6237."new"($P6241, "callmethod" :named("pasttype"), $P6238 :named("name"))
    $P6243 = $P6233."!make"($P6242)
.annotate 'line', 1969
    .return ($P6243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("730_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6245
    .param pmc param_6246
.annotate 'line', 1976
    .lex "self", param_6245
    .lex "$/", param_6246
    find_lex $P6247, "$/"
    find_lex $P6248, "$/"
    unless_null $P6248, vivify_2916
    $P6248 = root_new ['parrot';'Hash']
  vivify_2916:
    set $P6249, $P6248["statement"]
    unless_null $P6249, vivify_2917
    new $P6249, "Undef"
  vivify_2917:
    $P6250 = $P6249."ast"()
    $P6251 = $P6247."!make"($P6250)
    .return ($P6251)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("731_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6253
    .param pmc param_6254
.annotate 'line', 1978
    .lex "self", param_6253
    .lex "$/", param_6254
.annotate 'line', 1979
    find_lex $P6255, "$/"
    get_hll_global $P6256, "GLOBAL"
    nqp_get_package_through_who $P6257, $P6256, "PAST"
    get_who $P6258, $P6257
    set $P6259, $P6258["Var"]
    find_lex $P6260, "$/"
    unless_null $P6260, vivify_2918
    $P6260 = root_new ['parrot';'Hash']
  vivify_2918:
    set $P6261, $P6260["EXPR"]
    unless_null $P6261, vivify_2919
    new $P6261, "Undef"
  vivify_2919:
    $P6262 = $P6261."ast"()
.annotate 'line', 1981
    $P6263 = "vivitype"("@")
    $P6264 = $P6259."new"($P6262, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6263 :named("vivibase"))
.annotate 'line', 1979
    $P6265 = $P6255."!make"($P6264)
.annotate 'line', 1978
    .return ($P6265)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("732_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6267
    .param pmc param_6268
.annotate 'line', 1984
    .lex "self", param_6267
    .lex "$/", param_6268
.annotate 'line', 1985
    find_lex $P6269, "$/"
    get_hll_global $P6270, "GLOBAL"
    nqp_get_package_through_who $P6271, $P6270, "PAST"
    get_who $P6272, $P6271
    set $P6273, $P6272["Var"]
    find_lex $P6274, "$/"
    unless_null $P6274, vivify_2920
    $P6274 = root_new ['parrot';'Hash']
  vivify_2920:
    set $P6275, $P6274["EXPR"]
    unless_null $P6275, vivify_2921
    new $P6275, "Undef"
  vivify_2921:
    $P6276 = $P6275."ast"()
.annotate 'line', 1987
    $P6277 = "vivitype"("%")
    $P6278 = $P6273."new"($P6276, "keyed" :named("scope"), "Undef" :named("viviself"), $P6277 :named("vivibase"))
.annotate 'line', 1985
    $P6279 = $P6269."!make"($P6278)
.annotate 'line', 1984
    .return ($P6279)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("733_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6281
    .param pmc param_6282
.annotate 'line', 1990
    .lex "self", param_6281
    .lex "$/", param_6282
.annotate 'line', 1991
    find_lex $P6283, "$/"
    get_hll_global $P6284, "GLOBAL"
    nqp_get_package_through_who $P6285, $P6284, "PAST"
    get_who $P6286, $P6285
    set $P6287, $P6286["Var"]
    find_lex $P6288, "$/"
    unless_null $P6288, vivify_2922
    $P6288 = root_new ['parrot';'Hash']
  vivify_2922:
    set $P6289, $P6288["quote_EXPR"]
    unless_null $P6289, vivify_2923
    new $P6289, "Undef"
  vivify_2923:
    $P6290 = $P6289."ast"()
.annotate 'line', 1993
    $P6291 = "vivitype"("%")
    $P6292 = $P6287."new"($P6290, "keyed" :named("scope"), "Undef" :named("viviself"), $P6291 :named("vivibase"))
.annotate 'line', 1991
    $P6293 = $P6283."!make"($P6292)
.annotate 'line', 1990
    .return ($P6293)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("734_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6295
    .param pmc param_6296
.annotate 'line', 1996
    .lex "self", param_6295
    .lex "$/", param_6296
.annotate 'line', 1997
    find_lex $P6297, "$/"
    find_lex $P6298, "$/"
    unless_null $P6298, vivify_2924
    $P6298 = root_new ['parrot';'Hash']
  vivify_2924:
    set $P6299, $P6298["arglist"]
    unless_null $P6299, vivify_2925
    new $P6299, "Undef"
  vivify_2925:
    $P6300 = $P6299."ast"()
    $P6301 = $P6297."!make"($P6300)
.annotate 'line', 1996
    .return ($P6301)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("735_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6303
    .param pmc param_6304
.annotate 'line', 2000
    .lex "self", param_6303
    .lex "$/", param_6304
.annotate 'line', 2001
    find_lex $P6305, "$/"
    find_lex $P6308, "$/"
    unless_null $P6308, vivify_2926
    $P6308 = root_new ['parrot';'Hash']
  vivify_2926:
    set $P6309, $P6308["quote"]
    unless_null $P6309, vivify_2927
    new $P6309, "Undef"
  vivify_2927:
    if $P6309, if_6307
    find_lex $P6313, "$/"
    unless_null $P6313, vivify_2928
    $P6313 = root_new ['parrot';'Hash']
  vivify_2928:
    set $P6314, $P6313["number"]
    unless_null $P6314, vivify_2929
    new $P6314, "Undef"
  vivify_2929:
    $P6315 = $P6314."ast"()
    set $P6306, $P6315
    goto if_6307_end
  if_6307:
    find_lex $P6310, "$/"
    unless_null $P6310, vivify_2930
    $P6310 = root_new ['parrot';'Hash']
  vivify_2930:
    set $P6311, $P6310["quote"]
    unless_null $P6311, vivify_2931
    new $P6311, "Undef"
  vivify_2931:
    $P6312 = $P6311."ast"()
    set $P6306, $P6312
  if_6307_end:
    $P6316 = $P6305."!make"($P6306)
.annotate 'line', 2000
    .return ($P6316)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("736_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6318
    .param pmc param_6319
.annotate 'line', 2004
    .lex "self", param_6318
    .lex "$/", param_6319
.annotate 'line', 2005
    new $P6320, "Undef"
    .lex "$value", $P6320
    find_lex $P6323, "$/"
    unless_null $P6323, vivify_2932
    $P6323 = root_new ['parrot';'Hash']
  vivify_2932:
    set $P6324, $P6323["dec_number"]
    unless_null $P6324, vivify_2933
    new $P6324, "Undef"
  vivify_2933:
    if $P6324, if_6322
    find_lex $P6328, "$/"
    unless_null $P6328, vivify_2934
    $P6328 = root_new ['parrot';'Hash']
  vivify_2934:
    set $P6329, $P6328["integer"]
    unless_null $P6329, vivify_2935
    new $P6329, "Undef"
  vivify_2935:
    $P6330 = $P6329."ast"()
    set $P6321, $P6330
    goto if_6322_end
  if_6322:
    find_lex $P6325, "$/"
    unless_null $P6325, vivify_2936
    $P6325 = root_new ['parrot';'Hash']
  vivify_2936:
    set $P6326, $P6325["dec_number"]
    unless_null $P6326, vivify_2937
    new $P6326, "Undef"
  vivify_2937:
    $P6327 = $P6326."ast"()
    set $P6321, $P6327
  if_6322_end:
    store_lex "$value", $P6321
.annotate 'line', 2006
    find_lex $P6332, "$/"
    unless_null $P6332, vivify_2938
    $P6332 = root_new ['parrot';'Hash']
  vivify_2938:
    set $P6333, $P6332["sign"]
    unless_null $P6333, vivify_2939
    new $P6333, "Undef"
  vivify_2939:
    set $S6334, $P6333
    iseq $I6335, $S6334, "-"
    unless $I6335, if_6331_end
    find_lex $P6336, "$value"
    unless_null $P6336, vivify_2940
    new $P6336, "Undef"
  vivify_2940:
    neg $P6337, $P6336
    store_lex "$value", $P6337
  if_6331_end:
.annotate 'line', 2007
    find_lex $P6338, "$/"
    get_hll_global $P6339, "GLOBAL"
    nqp_get_package_through_who $P6340, $P6339, "PAST"
    get_who $P6341, $P6340
    set $P6342, $P6341["Val"]
    find_lex $P6343, "$value"
    unless_null $P6343, vivify_2941
    new $P6343, "Undef"
  vivify_2941:
    $P6344 = $P6342."new"($P6343 :named("value"))
    $P6345 = $P6338."!make"($P6344)
.annotate 'line', 2004
    .return ($P6345)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("737_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6347
    .param pmc param_6348
.annotate 'line', 2010
    .lex "self", param_6347
    .lex "$/", param_6348
    find_lex $P6349, "$/"
    find_lex $P6350, "$/"
    unless_null $P6350, vivify_2942
    $P6350 = root_new ['parrot';'Hash']
  vivify_2942:
    set $P6351, $P6350["quote_EXPR"]
    unless_null $P6351, vivify_2943
    new $P6351, "Undef"
  vivify_2943:
    $P6352 = $P6351."ast"()
    $P6353 = $P6349."!make"($P6352)
    .return ($P6353)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("738_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6355
    .param pmc param_6356
.annotate 'line', 2011
    .lex "self", param_6355
    .lex "$/", param_6356
    find_lex $P6357, "$/"
    find_lex $P6358, "$/"
    unless_null $P6358, vivify_2944
    $P6358 = root_new ['parrot';'Hash']
  vivify_2944:
    set $P6359, $P6358["quote_EXPR"]
    unless_null $P6359, vivify_2945
    new $P6359, "Undef"
  vivify_2945:
    $P6360 = $P6359."ast"()
    $P6361 = $P6357."!make"($P6360)
    .return ($P6361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("739_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6363
    .param pmc param_6364
.annotate 'line', 2012
    .lex "self", param_6363
    .lex "$/", param_6364
    find_lex $P6365, "$/"
    find_lex $P6366, "$/"
    unless_null $P6366, vivify_2946
    $P6366 = root_new ['parrot';'Hash']
  vivify_2946:
    set $P6367, $P6366["quote_EXPR"]
    unless_null $P6367, vivify_2947
    new $P6367, "Undef"
  vivify_2947:
    $P6368 = $P6367."ast"()
    $P6369 = $P6365."!make"($P6368)
    .return ($P6369)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("740_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6371
    .param pmc param_6372
.annotate 'line', 2013
    .lex "self", param_6371
    .lex "$/", param_6372
    find_lex $P6373, "$/"
    find_lex $P6374, "$/"
    unless_null $P6374, vivify_2948
    $P6374 = root_new ['parrot';'Hash']
  vivify_2948:
    set $P6375, $P6374["quote_EXPR"]
    unless_null $P6375, vivify_2949
    new $P6375, "Undef"
  vivify_2949:
    $P6376 = $P6375."ast"()
    $P6377 = $P6373."!make"($P6376)
    .return ($P6377)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("741_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6379
    .param pmc param_6380
.annotate 'line', 2014
    .lex "self", param_6379
    .lex "$/", param_6380
    find_lex $P6381, "$/"
    find_lex $P6382, "$/"
    unless_null $P6382, vivify_2950
    $P6382 = root_new ['parrot';'Hash']
  vivify_2950:
    set $P6383, $P6382["quote_EXPR"]
    unless_null $P6383, vivify_2951
    new $P6383, "Undef"
  vivify_2951:
    $P6384 = $P6383."ast"()
    $P6385 = $P6381."!make"($P6384)
    .return ($P6385)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("742_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6387
    .param pmc param_6388
.annotate 'line', 2015
    .lex "self", param_6387
    .lex "$/", param_6388
.annotate 'line', 2016
    find_lex $P6389, "$/"
    get_hll_global $P6390, "GLOBAL"
    nqp_get_package_through_who $P6391, $P6390, "PAST"
    get_who $P6392, $P6391
    set $P6393, $P6392["Op"]
    find_lex $P6394, "$/"
    unless_null $P6394, vivify_2952
    $P6394 = root_new ['parrot';'Hash']
  vivify_2952:
    set $P6395, $P6394["quote_EXPR"]
    unless_null $P6395, vivify_2953
    new $P6395, "Undef"
  vivify_2953:
    $P6396 = $P6395."ast"()
    $P6397 = $P6396."value"()
    find_lex $P6398, "$/"
    unless_null $P6398, vivify_2954
    new $P6398, "Undef"
  vivify_2954:
    $P6399 = $P6393."new"($P6397 :named("inline"), "inline" :named("pasttype"), $P6398 :named("node"))
    $P6400 = $P6389."!make"($P6399)
.annotate 'line', 2015
    .return ($P6400)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("743_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6404
    .param pmc param_6405
    .param pmc param_6406 :optional
    .param int has_param_6406 :opt_flag
.annotate 'line', 2021
    new $P6403, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6403, control_6402
    push_eh $P6403
    .lex "self", param_6404
    .lex "$/", param_6405
    if has_param_6406, optparam_2955
    new $P6407, "Undef"
    set param_6406, $P6407
  optparam_2955:
    .lex "$key", param_6406
.annotate 'line', 2028
    new $P6408, "Undef"
    .lex "$regex", $P6408
.annotate 'line', 2030
    new $P6409, "Undef"
    .lex "$past", $P6409
.annotate 'line', 2022
    find_lex $P6411, "$key"
    unless_null $P6411, vivify_2956
    new $P6411, "Undef"
  vivify_2956:
    set $S6412, $P6411
    iseq $I6413, $S6412, "open"
    unless $I6413, if_6410_end
.annotate 'line', 2023
    null $P6414
    get_hll_global $P6415, "GLOBAL"
    nqp_get_package_through_who $P6416, $P6415, "Regex"
    nqp_get_package_through_who $P6417, $P6416, "P6Regex"
    nqp_get_package_through_who $P6418, $P6417, "Actions"
    get_who $P6419, $P6418
    set $P6419["$REGEXNAME"], $P6414
.annotate 'line', 2024
    find_lex $P6420, "$?PACKAGE"
    get_who $P6421, $P6420
    set $P6422, $P6421["@BLOCK"]
    unless_null $P6422, vivify_2957
    $P6422 = root_new ['parrot';'ResizablePMCArray']
  vivify_2957:
    set $P6423, $P6422[0]
    unless_null $P6423, vivify_2958
    new $P6423, "Undef"
  vivify_2958:
    $P6423."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2025
    find_lex $P6424, "$?PACKAGE"
    get_who $P6425, $P6424
    set $P6426, $P6425["@BLOCK"]
    unless_null $P6426, vivify_2959
    $P6426 = root_new ['parrot';'ResizablePMCArray']
  vivify_2959:
    set $P6427, $P6426[0]
    unless_null $P6427, vivify_2960
    new $P6427, "Undef"
  vivify_2960:
    $P6427."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2026
    new $P6428, "Exception"
    set $P6428['type'], .CONTROL_RETURN
    new $P6429, "Integer"
    assign $P6429, 0
    setattribute $P6428, 'payload', $P6429
    throw $P6428
  if_6410_end:
.annotate 'line', 2029
    get_hll_global $P6430, "GLOBAL"
    nqp_get_package_through_who $P6431, $P6430, "Regex"
    nqp_get_package_through_who $P6432, $P6431, "P6Regex"
    nqp_get_package_through_who $P6433, $P6432, "Actions"
    get_who $P6434, $P6433
    set $P6435, $P6434["buildsub"]
    find_lex $P6436, "$/"
    unless_null $P6436, vivify_2961
    $P6436 = root_new ['parrot';'Hash']
  vivify_2961:
    set $P6437, $P6436["p6regex"]
    unless_null $P6437, vivify_2962
    new $P6437, "Undef"
  vivify_2962:
    $P6438 = $P6437."ast"()
    find_lex $P6439, "$?PACKAGE"
    get_who $P6440, $P6439
    set $P6441, $P6440["@BLOCK"]
    unless_null $P6441, vivify_2963
    $P6441 = root_new ['parrot';'ResizablePMCArray']
  vivify_2963:
    $P6442 = $P6441."shift"()
    $P6443 = $P6435($P6438, $P6442)
    store_lex "$regex", $P6443
.annotate 'line', 2031
    get_hll_global $P6444, "GLOBAL"
    nqp_get_package_through_who $P6445, $P6444, "PAST"
    get_who $P6446, $P6445
    set $P6447, $P6446["Op"]
.annotate 'line', 2033
    new $P6448, "ResizablePMCArray"
    push $P6448, "Regex"
    push $P6448, "Regex"
    find_lex $P6449, "$/"
    unless_null $P6449, vivify_2964
    new $P6449, "Undef"
  vivify_2964:
    $P6450 = "lexical_package_lookup"($P6448, $P6449)
    find_lex $P6451, "$regex"
    unless_null $P6451, vivify_2965
    new $P6451, "Undef"
  vivify_2965:
    $P6452 = $P6447."new"($P6450, $P6451, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2031
    store_lex "$past", $P6452
.annotate 'line', 2037
    find_lex $P6453, "$regex"
    unless_null $P6453, vivify_2966
    new $P6453, "Undef"
  vivify_2966:
    find_lex $P6454, "$past"
    unless_null $P6454, vivify_2967
    $P6454 = root_new ['parrot';'Hash']
    store_lex "$past", $P6454
  vivify_2967:
    set $P6454["sink"], $P6453
.annotate 'line', 2038
    find_lex $P6455, "$/"
    find_lex $P6456, "$past"
    unless_null $P6456, vivify_2968
    new $P6456, "Undef"
  vivify_2968:
    $P6457 = $P6455."!make"($P6456)
.annotate 'line', 2021
    .return ($P6457)
  control_6402:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6458, exception, "payload"
    .return ($P6458)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("744_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6460
    .param pmc param_6461
.annotate 'line', 2041
    .lex "self", param_6460
    .lex "$/", param_6461
    find_lex $P6462, "$/"
    find_lex $P6463, "$/"
    unless_null $P6463, vivify_2969
    $P6463 = root_new ['parrot';'Hash']
  vivify_2969:
    set $P6464, $P6463["variable"]
    unless_null $P6464, vivify_2970
    new $P6464, "Undef"
  vivify_2970:
    $P6465 = $P6464."ast"()
    $P6466 = $P6462."!make"($P6465)
    .return ($P6466)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("745_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6468
    .param pmc param_6469
.annotate 'line', 2042
    .lex "self", param_6468
    .lex "$/", param_6469
.annotate 'line', 2043
    find_lex $P6470, "$/"
    get_hll_global $P6471, "GLOBAL"
    nqp_get_package_through_who $P6472, $P6471, "PAST"
    get_who $P6473, $P6472
    set $P6474, $P6473["Op"]
.annotate 'line', 2044
    find_lex $P6475, "$/"
    unless_null $P6475, vivify_2971
    $P6475 = root_new ['parrot';'Hash']
  vivify_2971:
    set $P6476, $P6475["block"]
    unless_null $P6476, vivify_2972
    new $P6476, "Undef"
  vivify_2972:
    $P6477 = $P6476."ast"()
    $P6478 = "block_immediate"($P6477)
    find_lex $P6479, "$/"
    unless_null $P6479, vivify_2973
    new $P6479, "Undef"
  vivify_2973:
    $P6480 = $P6474."new"($P6478, "set S*" :named("pirop"), $P6479 :named("node"))
.annotate 'line', 2043
    $P6481 = $P6470."!make"($P6480)
.annotate 'line', 2042
    .return ($P6481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("746_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6483
    .param pmc param_6484
.annotate 'line', 2047
    .lex "self", param_6483
    .lex "$/", param_6484
    find_lex $P6485, "$/"
    $P6486 = $P6485."!make"("\e")
    .return ($P6486)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("747_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6488
    .param pmc param_6489
.annotate 'line', 2051
    .lex "self", param_6488
    .lex "$/", param_6489
    find_lex $P6490, "$/"
    find_lex $P6491, "$/"
    unless_null $P6491, vivify_2974
    $P6491 = root_new ['parrot';'Hash']
  vivify_2974:
    set $P6492, $P6491["dotty"]
    unless_null $P6492, vivify_2975
    new $P6492, "Undef"
  vivify_2975:
    $P6493 = $P6492."ast"()
    $P6494 = $P6490."!make"($P6493)
    .return ($P6494)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("748_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6496
    .param pmc param_6497
.annotate 'line', 2053
    .lex "self", param_6496
    .lex "$/", param_6497
.annotate 'line', 2054
    find_lex $P6498, "$/"
    get_hll_global $P6499, "GLOBAL"
    nqp_get_package_through_who $P6500, $P6499, "PAST"
    get_who $P6501, $P6500
    set $P6502, $P6501["Op"]
.annotate 'line', 2055
    new $P6503, "ResizablePMCArray"
    push $P6503, "    clone %r, %0"
    push $P6503, "    inc %0"
    $P6504 = $P6502."new"("postfix:<++>" :named("name"), $P6503 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2054
    $P6505 = $P6498."!make"($P6504)
.annotate 'line', 2053
    .return ($P6505)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("749_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6507
    .param pmc param_6508
.annotate 'line', 2059
    .lex "self", param_6507
    .lex "$/", param_6508
.annotate 'line', 2060
    find_lex $P6509, "$/"
    get_hll_global $P6510, "GLOBAL"
    nqp_get_package_through_who $P6511, $P6510, "PAST"
    get_who $P6512, $P6511
    set $P6513, $P6512["Op"]
.annotate 'line', 2061
    new $P6514, "ResizablePMCArray"
    push $P6514, "    clone %r, %0"
    push $P6514, "    dec %0"
    $P6515 = $P6513."new"("postfix:<-->" :named("name"), $P6514 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2060
    $P6516 = $P6509."!make"($P6515)
.annotate 'line', 2059
    .return ($P6516)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("750_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6518
    .param pmc param_6519
.annotate 'line', 2065
    .lex "self", param_6518
    .lex "$/", param_6519
.annotate 'line', 2066
    find_lex $P6520, "$/"
    get_hll_global $P6521, "GLOBAL"
    nqp_get_package_through_who $P6522, $P6521, "PAST"
    get_who $P6523, $P6522
    set $P6524, $P6523["Op"]
.annotate 'line', 2067
    get_hll_global $P6525, "GLOBAL"
    nqp_get_package_through_who $P6526, $P6525, "PAST"
    get_who $P6527, $P6526
    set $P6528, $P6527["Var"]
    $P6529 = $P6528."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6530, "$/"
    unless_null $P6530, vivify_2976
    new $P6530, "Undef"
  vivify_2976:
    $P6531 = $P6524."new"($P6529, "callmethod" :named("pasttype"), "!make" :named("name"), $P6530 :named("node"))
.annotate 'line', 2066
    $P6532 = $P6520."!make"($P6531)
.annotate 'line', 2065
    .return ($P6532)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("751_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6535
    .param pmc param_6536
.annotate 'line', 2083
    .lex "self", param_6535
    .lex "$/", param_6536
    find_lex $P6537, "$/"
    unless_null $P6537, vivify_2977
    new $P6537, "Undef"
  vivify_2977:
    $P6538 = "control"($P6537, "CONTROL_LOOP_NEXT")
    .return ($P6538)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("752_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6540
    .param pmc param_6541
.annotate 'line', 2084
    .lex "self", param_6540
    .lex "$/", param_6541
    find_lex $P6542, "$/"
    unless_null $P6542, vivify_2978
    new $P6542, "Undef"
  vivify_2978:
    $P6543 = "control"($P6542, "CONTROL_LOOP_LAST")
    .return ($P6543)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("753_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6545
    .param pmc param_6546
.annotate 'line', 2085
    .lex "self", param_6545
    .lex "$/", param_6546
    find_lex $P6547, "$/"
    unless_null $P6547, vivify_2979
    new $P6547, "Undef"
  vivify_2979:
    $P6548 = "control"($P6547, "CONTROL_LOOP_REDO")
    .return ($P6548)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("754_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6550
    .param pmc param_6551
.annotate 'line', 2087
    .lex "self", param_6550
    .lex "$/", param_6551
.annotate 'line', 2088
    find_lex $P6552, "$/"
    get_hll_global $P6553, "GLOBAL"
    nqp_get_package_through_who $P6554, $P6553, "PAST"
    get_who $P6555, $P6554
    set $P6556, $P6555["Op"]
    find_lex $P6557, "$/"
    unless_null $P6557, vivify_2980
    new $P6557, "Undef"
  vivify_2980:
    $P6558 = $P6556."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6557 :named("node"))
    $P6559 = $P6552."!make"($P6558)
.annotate 'line', 2087
    .return ($P6559)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym"  :subid("755_1304282286.73") :outer("582_1304282286.73")
    .param pmc param_6565
    .param pmc param_6566
    .param pmc param_6567
.annotate 'line', 2165
    .const 'Sub' $P6571 = "756_1304282286.73" 
    capture_lex $P6571
    .lex "self", param_6565
    .lex "$/", param_6566
    .lex "@name", param_6567
.annotate 'line', 2166
    new $P6568, "Undef"
    .lex "$known", $P6568
    new $P6569, "Integer"
    assign $P6569, 0
    store_lex "$known", $P6569
.annotate 'line', 2167
    .const 'Sub' $P6571 = "756_1304282286.73" 
    capture_lex $P6571
    $P6571()
    find_lex $P6582, "$known"
    unless_null $P6582, vivify_2983
    new $P6582, "Undef"
  vivify_2983:
.annotate 'line', 2165
    .return ($P6582)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6570"  :anon :subid("756_1304282286.73") :outer("755_1304282286.73")
.annotate 'line', 2167
    new $P6577, 'ExceptionHandler'
    set_label $P6577, control_6576
    $P6577."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6577
.annotate 'line', 2168
    find_lex $P6572, "@name"
    unless_null $P6572, vivify_2981
    $P6572 = root_new ['parrot';'ResizablePMCArray']
  vivify_2981:
    find_lex $P6573, "$/"
    unless_null $P6573, vivify_2982
    new $P6573, "Undef"
  vivify_2982:
    "find_sym"($P6572, $P6573)
.annotate 'line', 2169
    new $P6574, "Integer"
    assign $P6574, 1
    store_lex "$known", $P6574
.annotate 'line', 2167
    pop_eh 
    goto skip_handler_6575
  control_6576:
    .local pmc exception 
    .get_results (exception) 
    new $P6580, 'Integer'
    set $P6580, 1
    set exception["handled"], $P6580
    set $I6581, exception["handled"]
    ne $I6581, 1, nothandled_6579
  handled_6578:
    .return (exception)
  nothandled_6579:
    rethrow exception
  skip_handler_6575:
    .return ($P6574)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6589"  :subid("758_1304282286.73") :outer("10_1304282286.73")
.annotate 'line', 2234
    .const 'Sub' $P6723 = "766_1304282286.73" 
    capture_lex $P6723
    .const 'Sub' $P6683 = "765_1304282286.73" 
    capture_lex $P6683
    .const 'Sub' $P6669 = "764_1304282286.73" 
    capture_lex $P6669
    .const 'Sub' $P6651 = "763_1304282286.73" 
    capture_lex $P6651
    .const 'Sub' $P6637 = "762_1304282286.73" 
    capture_lex $P6637
    .const 'Sub' $P6623 = "761_1304282286.73" 
    capture_lex $P6623
    .const 'Sub' $P6609 = "760_1304282286.73" 
    capture_lex $P6609
    .const 'Sub' $P6593 = "759_1304282286.73" 
    capture_lex $P6593
    .lex "$?PACKAGE", $P6591
    .lex "$?CLASS", $P6592
.annotate 'line', 2268
    .const 'Sub' $P6683 = "765_1304282286.73" 
    newclosure $P6721, $P6683
.annotate 'line', 2234
    .return ($P6721)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2984") :outer("758_1304282286.73")
.annotate 'line', 2234
    .const 'Sub' $P6590 = "758_1304282286.73" 
    .local pmc block
    set block, $P6590
    .const 'Sub' $P6723 = "766_1304282286.73" 
    capture_lex $P6723
    $P6723()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6722"  :anon :subid("766_1304282286.73") :outer("758_1304282286.73")
.annotate 'line', 2234
    nqp_get_sc_object $P6724, "1304282274.421", 488
    .local pmc type_obj
    set type_obj, $P6724
    get_how $P6725, type_obj
    $P6726 = $P6725."compose"(type_obj)
    .return ($P6726)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("759_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6594
    .param pmc param_6595
.annotate 'line', 2236
    .lex "self", param_6594
    .lex "$/", param_6595
.annotate 'line', 2237
    new $P6596, "Undef"
    .lex "$past", $P6596
    find_lex $P6597, "$/"
    unless_null $P6597, vivify_2985
    $P6597 = root_new ['parrot';'Hash']
  vivify_2985:
    set $P6598, $P6597["statement"]
    unless_null $P6598, vivify_2986
    new $P6598, "Undef"
  vivify_2986:
    $P6599 = $P6598."ast"()
    store_lex "$past", $P6599
.annotate 'line', 2238
    find_lex $P6600, "$/"
    get_hll_global $P6601, "GLOBAL"
    nqp_get_package_through_who $P6602, $P6601, "PAST"
    get_who $P6603, $P6602
    set $P6604, $P6603["Regex"]
    find_lex $P6605, "$past"
    unless_null $P6605, vivify_2987
    new $P6605, "Undef"
  vivify_2987:
    find_lex $P6606, "$/"
    unless_null $P6606, vivify_2988
    new $P6606, "Undef"
  vivify_2988:
    $P6607 = $P6604."new"($P6605, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6606 :named("node"))
    $P6608 = $P6600."!make"($P6607)
.annotate 'line', 2236
    .return ($P6608)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("760_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6610
    .param pmc param_6611
.annotate 'line', 2242
    .lex "self", param_6610
    .lex "$/", param_6611
.annotate 'line', 2243
    find_lex $P6612, "$/"
    get_hll_global $P6613, "GLOBAL"
    nqp_get_package_through_who $P6614, $P6613, "PAST"
    get_who $P6615, $P6614
    set $P6616, $P6615["Regex"]
    find_lex $P6617, "$/"
    unless_null $P6617, vivify_2989
    $P6617 = root_new ['parrot';'Hash']
  vivify_2989:
    set $P6618, $P6617["codeblock"]
    unless_null $P6618, vivify_2990
    new $P6618, "Undef"
  vivify_2990:
    $P6619 = $P6618."ast"()
    find_lex $P6620, "$/"
    unless_null $P6620, vivify_2991
    new $P6620, "Undef"
  vivify_2991:
    $P6621 = $P6616."new"($P6619, "pastnode" :named("pasttype"), $P6620 :named("node"))
    $P6622 = $P6612."!make"($P6621)
.annotate 'line', 2242
    .return ($P6622)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("761_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6624
    .param pmc param_6625
.annotate 'line', 2247
    .lex "self", param_6624
    .lex "$/", param_6625
.annotate 'line', 2248
    find_lex $P6626, "$/"
    get_hll_global $P6627, "GLOBAL"
    nqp_get_package_through_who $P6628, $P6627, "PAST"
    get_who $P6629, $P6628
    set $P6630, $P6629["Regex"]
    find_lex $P6631, "$/"
    unless_null $P6631, vivify_2992
    $P6631 = root_new ['parrot';'Hash']
  vivify_2992:
    set $P6632, $P6631["var"]
    unless_null $P6632, vivify_2993
    new $P6632, "Undef"
  vivify_2993:
    $P6633 = $P6632."ast"()
    find_lex $P6634, "$/"
    unless_null $P6634, vivify_2994
    new $P6634, "Undef"
  vivify_2994:
    $P6635 = $P6630."new"("!INTERPOLATE", $P6633, "subrule" :named("pasttype"), "method" :named("subtype"), $P6634 :named("node"))
    $P6636 = $P6626."!make"($P6635)
.annotate 'line', 2247
    .return ($P6636)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("762_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6638
    .param pmc param_6639
.annotate 'line', 2252
    .lex "self", param_6638
    .lex "$/", param_6639
.annotate 'line', 2253
    find_lex $P6640, "$/"
    get_hll_global $P6641, "GLOBAL"
    nqp_get_package_through_who $P6642, $P6641, "PAST"
    get_who $P6643, $P6642
    set $P6644, $P6643["Regex"]
    find_lex $P6645, "$/"
    unless_null $P6645, vivify_2995
    $P6645 = root_new ['parrot';'Hash']
  vivify_2995:
    set $P6646, $P6645["codeblock"]
    unless_null $P6646, vivify_2996
    new $P6646, "Undef"
  vivify_2996:
    $P6647 = $P6646."ast"()
    find_lex $P6648, "$/"
    unless_null $P6648, vivify_2997
    new $P6648, "Undef"
  vivify_2997:
    $P6649 = $P6644."new"("!INTERPOLATE_REGEX", $P6647, "subrule" :named("pasttype"), "method" :named("subtype"), $P6648 :named("node"))
    $P6650 = $P6640."!make"($P6649)
.annotate 'line', 2252
    .return ($P6650)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("763_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6652
    .param pmc param_6653
.annotate 'line', 2257
    .lex "self", param_6652
    .lex "$/", param_6653
.annotate 'line', 2258
    find_lex $P6654, "$/"
    get_hll_global $P6655, "GLOBAL"
    nqp_get_package_through_who $P6656, $P6655, "PAST"
    get_who $P6657, $P6656
    set $P6658, $P6657["Regex"]
    find_lex $P6659, "$/"
    unless_null $P6659, vivify_2998
    $P6659 = root_new ['parrot';'Hash']
  vivify_2998:
    set $P6660, $P6659["codeblock"]
    unless_null $P6660, vivify_2999
    new $P6660, "Undef"
  vivify_2999:
    $P6661 = $P6660."ast"()
.annotate 'line', 2259
    find_lex $P6662, "$/"
    unless_null $P6662, vivify_3000
    $P6662 = root_new ['parrot';'Hash']
  vivify_3000:
    set $P6663, $P6662["zw"]
    unless_null $P6663, vivify_3001
    new $P6663, "Undef"
  vivify_3001:
    set $S6664, $P6663
    iseq $I6665, $S6664, "!"
    find_lex $P6666, "$/"
    unless_null $P6666, vivify_3002
    new $P6666, "Undef"
  vivify_3002:
    $P6667 = $P6658."new"($P6661, "zerowidth" :named("subtype"), $I6665 :named("negate"), "pastnode" :named("pasttype"), $P6666 :named("node"))
.annotate 'line', 2258
    $P6668 = $P6654."!make"($P6667)
.annotate 'line', 2257
    .return ($P6668)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("764_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6670
    .param pmc param_6671
.annotate 'line', 2263
    .lex "self", param_6670
    .lex "$/", param_6671
.annotate 'line', 2264
    find_lex $P6672, "$/"
    get_hll_global $P6673, "GLOBAL"
    nqp_get_package_through_who $P6674, $P6673, "PAST"
    get_who $P6675, $P6674
    set $P6676, $P6675["Regex"]
    find_lex $P6677, "$/"
    unless_null $P6677, vivify_3003
    $P6677 = root_new ['parrot';'Hash']
  vivify_3003:
    set $P6678, $P6677["var"]
    unless_null $P6678, vivify_3004
    new $P6678, "Undef"
  vivify_3004:
    $P6679 = $P6678."ast"()
    find_lex $P6680, "$/"
    unless_null $P6680, vivify_3005
    new $P6680, "Undef"
  vivify_3005:
    $P6681 = $P6676."new"("!INTERPOLATE_REGEX", $P6679, "subrule" :named("pasttype"), "method" :named("subtype"), $P6680 :named("node"))
    $P6682 = $P6672."!make"($P6681)
.annotate 'line', 2263
    .return ($P6682)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("765_1304282286.73") :outer("758_1304282286.73")
    .param pmc param_6684
    .param pmc param_6685
.annotate 'line', 2268
    .lex "self", param_6684
    .lex "$/", param_6685
.annotate 'line', 2269
    new $P6686, "Undef"
    .lex "$block", $P6686
.annotate 'line', 2271
    new $P6687, "Undef"
    .lex "$past", $P6687
.annotate 'line', 2269
    find_lex $P6688, "$/"
    unless_null $P6688, vivify_3006
    $P6688 = root_new ['parrot';'Hash']
  vivify_3006:
    set $P6689, $P6688["block"]
    unless_null $P6689, vivify_3007
    new $P6689, "Undef"
  vivify_3007:
    $P6690 = $P6689."ast"()
    store_lex "$block", $P6690
.annotate 'line', 2270
    find_lex $P6691, "$block"
    unless_null $P6691, vivify_3008
    new $P6691, "Undef"
  vivify_3008:
    $P6691."blocktype"("immediate")
.annotate 'line', 2272
    get_hll_global $P6692, "GLOBAL"
    nqp_get_package_through_who $P6693, $P6692, "PAST"
    get_who $P6694, $P6693
    set $P6695, $P6694["Stmts"]
.annotate 'line', 2273
    get_hll_global $P6696, "GLOBAL"
    nqp_get_package_through_who $P6697, $P6696, "PAST"
    get_who $P6698, $P6697
    set $P6699, $P6698["Op"]
.annotate 'line', 2274
    get_hll_global $P6700, "GLOBAL"
    nqp_get_package_through_who $P6701, $P6700, "PAST"
    get_who $P6702, $P6701
    set $P6703, $P6702["Var"]
    $P6704 = $P6703."new"("$/" :named("name"))
.annotate 'line', 2275
    get_hll_global $P6705, "GLOBAL"
    nqp_get_package_through_who $P6706, $P6705, "PAST"
    get_who $P6707, $P6706
    set $P6708, $P6707["Op"]
.annotate 'line', 2276
    get_hll_global $P6709, "GLOBAL"
    nqp_get_package_through_who $P6710, $P6709, "PAST"
    get_who $P6711, $P6710
    set $P6712, $P6711["Var"]
    $P6713 = $P6712."new"(unicode:"$\x{a2}" :named("name"))
    $P6714 = $P6708."new"($P6713, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2275
    $P6715 = $P6699."new"($P6704, $P6714, "bind" :named("pasttype"))
.annotate 'line', 2273
    find_lex $P6716, "$block"
    unless_null $P6716, vivify_3009
    new $P6716, "Undef"
  vivify_3009:
    $P6717 = $P6695."new"($P6715, $P6716)
.annotate 'line', 2272
    store_lex "$past", $P6717
.annotate 'line', 2284
    find_lex $P6718, "$/"
    find_lex $P6719, "$past"
    unless_null $P6719, vivify_3010
    new $P6719, "Undef"
  vivify_3010:
    $P6720 = $P6718."!make"($P6719)
.annotate 'line', 2268
    .return ($P6720)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6727"  :subid("767_1304282286.73") :outer("10_1304282286.73")
.annotate 'line', 2289
    .const 'Sub' $P6732 = "768_1304282286.73" 
    capture_lex $P6732
    .lex "$?PACKAGE", $P6729
    .lex "$?CLASS", $P6730
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post3011") :outer("767_1304282286.73")
.annotate 'line', 2289
    .const 'Sub' $P6728 = "767_1304282286.73" 
    .local pmc block
    set block, $P6728
    .const 'Sub' $P6732 = "768_1304282286.73" 
    capture_lex $P6732
    $P6732()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6731"  :anon :subid("768_1304282286.73") :outer("767_1304282286.73")
.annotate 'line', 2289
    nqp_get_sc_object $P6733, "1304282274.421", 496
    .local pmc type_obj
    set type_obj, $P6733
    get_how $P6734, type_obj
    $P6735 = $P6734."compose"(type_obj)
    .return ($P6735)
.end


.HLL "nqp"

.namespace []
.sub "_block6743" :load :anon :subid("769_1304282286.73")
.annotate 'line', 1
    .const 'Sub' $P6745 = "10_1304282286.73" 
    $P6746 = $P6745()
    .return ($P6746)
.end

