
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303857440.612")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7255 = "584_1303857440.612" 
    capture_lex $P7255
    .const 'Sub' $P7103 = "575_1303857440.612" 
    capture_lex $P7103
    .const 'Sub' $P2753 = "406_1303857440.612" 
    capture_lex $P2753
    .const 'Sub' $P2651 = "384_1303857440.612" 
    capture_lex $P2651
    .const 'Sub' $P47 = "12_1303857440.612" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1303857440.612" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2293
    .const 'Sub' $P16 = "11_1303857440.612" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303857440.612" 
    capture_lex $P47
    $P47()
.annotate 'line', 724
    .const 'Sub' $P2651 = "384_1303857440.612" 
    capture_lex $P2651
    $P2651()
.annotate 'line', 767
    .const 'Sub' $P2753 = "406_1303857440.612" 
    capture_lex $P2753
    $P2753()
.annotate 'line', 2235
    .const 'Sub' $P7103 = "575_1303857440.612" 
    capture_lex $P7103
    $P7103()
.annotate 'line', 2290
    .const 'Sub' $P7255 = "584_1303857440.612" 
    capture_lex $P7255
    $P7255()
    find_lex $P7263, "MAIN"
    find_lex $P7266, "@ARGS"
    if $P7266, if_7265
    set $P7264, $P7266
    goto if_7265_end
  if_7265:
    .const 'Sub' $P7267 = "11_1303857440.612" 
    find_lex $P7268, "@ARGS"
    $P7269 = $P7267($P7268 :flat)
    set $P7264, $P7269
  if_7265_end:
.annotate 'line', 1
    .return ($P7264)
    .const 'Sub' $P7271 = "586_1303857440.612" 
    .return ($P7271)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post587") :outer("10_1303857440.612")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303857440.612" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7275, "1303857428.33"
    isnull $I7276, $P7275
    if $I7276, if_7274
    .const 'Sub' $P7404 = "10_1303857440.612" 
    $P7405 = $P7404."get_lexinfo"()
    nqp_get_sc_object $P7406, "1303857428.33", 0
    $P7405."set_static_lexpad_value"("GLOBALish", $P7406)
    .const 'Sub' $P7407 = "10_1303857440.612" 
    $P7408 = $P7407."get_lexinfo"()
    $P7408."finish_static_lexpad"()
    .const 'Sub' $P7409 = "10_1303857440.612" 
    $P7410 = $P7409."get_lexinfo"()
    nqp_get_sc_object $P7411, "1303857428.33", 0
    $P7410."set_static_lexpad_value"("$?PACKAGE", $P7411)
    .const 'Sub' $P7412 = "10_1303857440.612" 
    $P7413 = $P7412."get_lexinfo"()
    $P7413."finish_static_lexpad"()
    nqp_get_sc_object $P7414, "1303857428.33", 1
    set_hll_global ["NQP"], "Grammar", $P7414
    .const 'Sub' $P7415 = "12_1303857440.612" 
    $P7416 = $P7415."get_lexinfo"()
    nqp_get_sc_object $P7417, "1303857428.33", 1
    $P7416."set_static_lexpad_value"("$?PACKAGE", $P7417)
    .const 'Sub' $P7418 = "12_1303857440.612" 
    $P7419 = $P7418."get_lexinfo"()
    $P7419."finish_static_lexpad"()
    .const 'Sub' $P7420 = "12_1303857440.612" 
    $P7421 = $P7420."get_lexinfo"()
    nqp_get_sc_object $P7422, "1303857428.33", 1
    $P7421."set_static_lexpad_value"("$?CLASS", $P7422)
    .const 'Sub' $P7423 = "12_1303857440.612" 
    $P7424 = $P7423."get_lexinfo"()
    $P7424."finish_static_lexpad"()
    nqp_get_sc_object $P7425, "1303857428.33", 2
    set_hll_global ["NQP"], "Regex", $P7425
    .const 'Sub' $P7426 = "384_1303857440.612" 
    $P7427 = $P7426."get_lexinfo"()
    nqp_get_sc_object $P7428, "1303857428.33", 2
    $P7427."set_static_lexpad_value"("$?PACKAGE", $P7428)
    .const 'Sub' $P7429 = "384_1303857440.612" 
    $P7430 = $P7429."get_lexinfo"()
    $P7430."finish_static_lexpad"()
    .const 'Sub' $P7431 = "384_1303857440.612" 
    $P7432 = $P7431."get_lexinfo"()
    nqp_get_sc_object $P7433, "1303857428.33", 2
    $P7432."set_static_lexpad_value"("$?CLASS", $P7433)
    .const 'Sub' $P7434 = "384_1303857440.612" 
    $P7435 = $P7434."get_lexinfo"()
    $P7435."finish_static_lexpad"()
    nqp_get_sc_object $P7436, "1303857428.33", 3
    set_hll_global ["NQP"], "Actions", $P7436
    .const 'Sub' $P7437 = "406_1303857440.612" 
    $P7438 = $P7437."get_lexinfo"()
    nqp_get_sc_object $P7439, "1303857428.33", 3
    $P7438."set_static_lexpad_value"("$?PACKAGE", $P7439)
    .const 'Sub' $P7440 = "406_1303857440.612" 
    $P7441 = $P7440."get_lexinfo"()
    $P7441."finish_static_lexpad"()
    .const 'Sub' $P7442 = "406_1303857440.612" 
    $P7443 = $P7442."get_lexinfo"()
    nqp_get_sc_object $P7444, "1303857428.33", 3
    $P7443."set_static_lexpad_value"("$?CLASS", $P7444)
    .const 'Sub' $P7445 = "406_1303857440.612" 
    $P7446 = $P7445."get_lexinfo"()
    $P7446."finish_static_lexpad"()
    nqp_get_sc_object $P7447, "1303857428.33", 4
    set_hll_global ["NQP"], "RegexActions", $P7447
    .const 'Sub' $P7448 = "575_1303857440.612" 
    $P7449 = $P7448."get_lexinfo"()
    nqp_get_sc_object $P7450, "1303857428.33", 4
    $P7449."set_static_lexpad_value"("$?PACKAGE", $P7450)
    .const 'Sub' $P7451 = "575_1303857440.612" 
    $P7452 = $P7451."get_lexinfo"()
    $P7452."finish_static_lexpad"()
    .const 'Sub' $P7453 = "575_1303857440.612" 
    $P7454 = $P7453."get_lexinfo"()
    nqp_get_sc_object $P7455, "1303857428.33", 4
    $P7454."set_static_lexpad_value"("$?CLASS", $P7455)
    .const 'Sub' $P7456 = "575_1303857440.612" 
    $P7457 = $P7456."get_lexinfo"()
    $P7457."finish_static_lexpad"()
    nqp_get_sc_object $P7458, "1303857428.33", 5
    set_hll_global ["NQP"], "Compiler", $P7458
    .const 'Sub' $P7459 = "584_1303857440.612" 
    $P7460 = $P7459."get_lexinfo"()
    nqp_get_sc_object $P7461, "1303857428.33", 5
    $P7460."set_static_lexpad_value"("$?PACKAGE", $P7461)
    .const 'Sub' $P7462 = "584_1303857440.612" 
    $P7463 = $P7462."get_lexinfo"()
    $P7463."finish_static_lexpad"()
    .const 'Sub' $P7464 = "584_1303857440.612" 
    $P7465 = $P7464."get_lexinfo"()
    nqp_get_sc_object $P7466, "1303857428.33", 5
    $P7465."set_static_lexpad_value"("$?CLASS", $P7466)
    .const 'Sub' $P7467 = "584_1303857440.612" 
    $P7468 = $P7467."get_lexinfo"()
    $P7468."finish_static_lexpad"()
    goto if_7274_end
  if_7274:
    nqp_dynop_setup 
    getinterp $P7277
    get_class $P7278, "LexPad"
    get_class $P7279, "NQPLexPad"
    $P7277."hll_map"($P7278, $P7279)
    nqp_create_sc $P7280, "1303857428.33"
    .local pmc cur_sc
    set cur_sc, $P7280
    nqp_get_sc_object $P7281, "__6MODEL_CORE__", 0
    $P7282 = $P7281."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7282, cur_sc
    nqp_set_sc_object "1303857428.33", 0, $P7282
    .const 'Sub' $P7283 = "10_1303857440.612" 
    $P7284 = $P7283."get_lexinfo"()
    nqp_get_sc_object $P7285, "1303857428.33", 0
    $P7284."set_static_lexpad_value"("GLOBALish", $P7285)
    .const 'Sub' $P7286 = "10_1303857440.612" 
    $P7287 = $P7286."get_lexinfo"()
    $P7287."finish_static_lexpad"()
    .const 'Sub' $P7288 = "10_1303857440.612" 
    $P7289 = $P7288."get_lexinfo"()
    nqp_get_sc_object $P7290, "1303857428.33", 0
    $P7289."set_static_lexpad_value"("$?PACKAGE", $P7290)
    .const 'Sub' $P7291 = "10_1303857440.612" 
    $P7292 = $P7291."get_lexinfo"()
    $P7292."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7293, "ModuleLoader"
    $P7294 = $P7293."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7294)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7295, "ModuleLoader"
    nqp_get_sc_object $P7296, "1303857428.33", 0
    $P7295."load_module"("Regex", $P7296)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7297, "ModuleLoader"
    nqp_get_sc_object $P7298, "1303857428.33", 0
    $P7297."load_module"("P6Regex", $P7298)
    nqp_get_sc_object $P7299, "1303857403.801", 6
    $P7300 = $P7299."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7300, cur_sc
    nqp_set_sc_object "1303857428.33", 1, $P7300
    nqp_get_sc_object $P7301, "1303857428.33", 1
    nqp_get_sc_object $P7302, "1303857428.33", 0
    nqp_get_package_through_who $P7303, $P7302, "NQP"
    get_who $P7304, $P7303
    set $P7304["Grammar"], $P7301
    nqp_get_sc_object $P7305, "1303857428.33", 1
    set_hll_global ["NQP"], "Grammar", $P7305
    .const 'Sub' $P7306 = "12_1303857440.612" 
    $P7307 = $P7306."get_lexinfo"()
    nqp_get_sc_object $P7308, "1303857428.33", 1
    $P7307."set_static_lexpad_value"("$?PACKAGE", $P7308)
    .const 'Sub' $P7309 = "12_1303857440.612" 
    $P7310 = $P7309."get_lexinfo"()
    $P7310."finish_static_lexpad"()
    .const 'Sub' $P7311 = "12_1303857440.612" 
    $P7312 = $P7311."get_lexinfo"()
    nqp_get_sc_object $P7313, "1303857428.33", 1
    $P7312."set_static_lexpad_value"("$?CLASS", $P7313)
    .const 'Sub' $P7314 = "12_1303857440.612" 
    $P7315 = $P7314."get_lexinfo"()
    $P7315."finish_static_lexpad"()
    nqp_get_sc_object $P7316, "1303857428.33", 1
    get_how $P7317, $P7316
    nqp_get_sc_object $P7318, "1303857428.33", 1
    nqp_get_sc_object $P7319, "1303857411.111", 1
    $P7317."add_parent"($P7318, $P7319)
    nqp_get_sc_object $P7320, "1303857403.801", 6
    $P7321 = $P7320."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7321, cur_sc
    nqp_set_sc_object "1303857428.33", 2, $P7321
    nqp_get_sc_object $P7322, "1303857428.33", 2
    nqp_get_sc_object $P7323, "1303857428.33", 0
    nqp_get_package_through_who $P7324, $P7323, "NQP"
    get_who $P7325, $P7324
    set $P7325["Regex"], $P7322
    nqp_get_sc_object $P7326, "1303857428.33", 2
    set_hll_global ["NQP"], "Regex", $P7326
    .const 'Sub' $P7327 = "384_1303857440.612" 
    $P7328 = $P7327."get_lexinfo"()
    nqp_get_sc_object $P7329, "1303857428.33", 2
    $P7328."set_static_lexpad_value"("$?PACKAGE", $P7329)
    .const 'Sub' $P7330 = "384_1303857440.612" 
    $P7331 = $P7330."get_lexinfo"()
    $P7331."finish_static_lexpad"()
    .const 'Sub' $P7332 = "384_1303857440.612" 
    $P7333 = $P7332."get_lexinfo"()
    nqp_get_sc_object $P7334, "1303857428.33", 2
    $P7333."set_static_lexpad_value"("$?CLASS", $P7334)
    .const 'Sub' $P7335 = "384_1303857440.612" 
    $P7336 = $P7335."get_lexinfo"()
    $P7336."finish_static_lexpad"()
    nqp_get_sc_object $P7337, "1303857428.33", 2
    get_how $P7338, $P7337
    nqp_get_sc_object $P7339, "1303857428.33", 2
    nqp_get_sc_object $P7340, "1303857421.716", 1
    $P7338."add_parent"($P7339, $P7340)
    nqp_get_sc_object $P7341, "1303857403.801", 6
    $P7342 = $P7341."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7342, cur_sc
    nqp_set_sc_object "1303857428.33", 3, $P7342
    nqp_get_sc_object $P7343, "1303857428.33", 3
    nqp_get_sc_object $P7344, "1303857428.33", 0
    nqp_get_package_through_who $P7345, $P7344, "NQP"
    get_who $P7346, $P7345
    set $P7346["Actions"], $P7343
    nqp_get_sc_object $P7347, "1303857428.33", 3
    set_hll_global ["NQP"], "Actions", $P7347
    .const 'Sub' $P7348 = "406_1303857440.612" 
    $P7349 = $P7348."get_lexinfo"()
    nqp_get_sc_object $P7350, "1303857428.33", 3
    $P7349."set_static_lexpad_value"("$?PACKAGE", $P7350)
    .const 'Sub' $P7351 = "406_1303857440.612" 
    $P7352 = $P7351."get_lexinfo"()
    $P7352."finish_static_lexpad"()
    .const 'Sub' $P7353 = "406_1303857440.612" 
    $P7354 = $P7353."get_lexinfo"()
    nqp_get_sc_object $P7355, "1303857428.33", 3
    $P7354."set_static_lexpad_value"("$?CLASS", $P7355)
    .const 'Sub' $P7356 = "406_1303857440.612" 
    $P7357 = $P7356."get_lexinfo"()
    $P7357."finish_static_lexpad"()
    nqp_get_sc_object $P7358, "1303857428.33", 3
    get_how $P7359, $P7358
    nqp_get_sc_object $P7360, "1303857428.33", 3
    nqp_get_sc_object $P7361, "1303857411.111", 2
    $P7359."add_parent"($P7360, $P7361)
    nqp_get_sc_object $P7362, "1303857403.801", 6
    $P7363 = $P7362."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P7363, cur_sc
    nqp_set_sc_object "1303857428.33", 4, $P7363
    nqp_get_sc_object $P7364, "1303857428.33", 4
    nqp_get_sc_object $P7365, "1303857428.33", 0
    nqp_get_package_through_who $P7366, $P7365, "NQP"
    get_who $P7367, $P7366
    set $P7367["RegexActions"], $P7364
    nqp_get_sc_object $P7368, "1303857428.33", 4
    set_hll_global ["NQP"], "RegexActions", $P7368
    .const 'Sub' $P7369 = "575_1303857440.612" 
    $P7370 = $P7369."get_lexinfo"()
    nqp_get_sc_object $P7371, "1303857428.33", 4
    $P7370."set_static_lexpad_value"("$?PACKAGE", $P7371)
    .const 'Sub' $P7372 = "575_1303857440.612" 
    $P7373 = $P7372."get_lexinfo"()
    $P7373."finish_static_lexpad"()
    .const 'Sub' $P7374 = "575_1303857440.612" 
    $P7375 = $P7374."get_lexinfo"()
    nqp_get_sc_object $P7376, "1303857428.33", 4
    $P7375."set_static_lexpad_value"("$?CLASS", $P7376)
    .const 'Sub' $P7377 = "575_1303857440.612" 
    $P7378 = $P7377."get_lexinfo"()
    $P7378."finish_static_lexpad"()
    nqp_get_sc_object $P7379, "1303857428.33", 4
    get_how $P7380, $P7379
    nqp_get_sc_object $P7381, "1303857428.33", 4
    nqp_get_sc_object $P7382, "1303857421.716", 2
    $P7380."add_parent"($P7381, $P7382)
    nqp_get_sc_object $P7383, "1303857403.801", 6
    $P7384 = $P7383."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P7384, cur_sc
    nqp_set_sc_object "1303857428.33", 5, $P7384
    nqp_get_sc_object $P7385, "1303857428.33", 5
    nqp_get_sc_object $P7386, "1303857428.33", 0
    nqp_get_package_through_who $P7387, $P7386, "NQP"
    get_who $P7388, $P7387
    set $P7388["Compiler"], $P7385
    nqp_get_sc_object $P7389, "1303857428.33", 5
    set_hll_global ["NQP"], "Compiler", $P7389
    .const 'Sub' $P7390 = "584_1303857440.612" 
    $P7391 = $P7390."get_lexinfo"()
    nqp_get_sc_object $P7392, "1303857428.33", 5
    $P7391."set_static_lexpad_value"("$?PACKAGE", $P7392)
    .const 'Sub' $P7393 = "584_1303857440.612" 
    $P7394 = $P7393."get_lexinfo"()
    $P7394."finish_static_lexpad"()
    .const 'Sub' $P7395 = "584_1303857440.612" 
    $P7396 = $P7395."get_lexinfo"()
    nqp_get_sc_object $P7397, "1303857428.33", 5
    $P7396."set_static_lexpad_value"("$?CLASS", $P7397)
    .const 'Sub' $P7398 = "584_1303857440.612" 
    $P7399 = $P7398."get_lexinfo"()
    $P7399."finish_static_lexpad"()
    nqp_get_sc_object $P7400, "1303857428.33", 5
    get_how $P7401, $P7400
    nqp_get_sc_object $P7402, "1303857428.33", 5
    nqp_get_sc_object $P7403, "1303857411.111", 3
    $P7401."add_parent"($P7402, $P7403)
  if_7274_end:
    nqp_get_sc_object $P7469, "1303857428.33", 0
    set_hll_global "GLOBAL", $P7469
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303857440.612") :outer("10_1303857440.612")
    .param pmc param_17
.annotate 'line', 2293
    .lex "@ARGS", param_17
.annotate 'line', 2295
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2301
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2295
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2296
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_588
    new $P25, "Undef"
  vivify_588:
    $P25."language"("nqp")
.annotate 'line', 2297
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_589
    new $P26, "Undef"
  vivify_589:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2298
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_590
    new $P31, "Undef"
  vivify_590:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2301
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_591
    new $P36, "Undef"
  vivify_591:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2302
    find_lex $P38, "@clo"
    unless_null $P38, vivify_592
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    $P38."push"("parsetrace")
.annotate 'line', 2303
    find_lex $P39, "@clo"
    unless_null $P39, vivify_593
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_593:
    $P39."push"("setting=s")
.annotate 'line', 2304
    find_lex $P40, "@clo"
    unless_null $P40, vivify_594
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_594:
    $P40."push"("setting-path=s")
.annotate 'line', 2305
    find_lex $P41, "@clo"
    unless_null $P41, vivify_595
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_595:
    $P41."push"("module-path=s")
.annotate 'line', 2308
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_596
    new $P42, "Undef"
  vivify_596:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_597
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_597:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2293
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1303857440.612") :outer("10_1303857440.612")
.annotate 'line', 9
    .const 'Sub' $P1930 = "383_1303857440.612" 
    capture_lex $P1930
    .const 'Sub' $P1917 = "382_1303857440.612" 
    capture_lex $P1917
    .const 'Sub' $P1911 = "380_1303857440.612" 
    capture_lex $P1911
    .const 'Sub' $P1905 = "378_1303857440.612" 
    capture_lex $P1905
    .const 'Sub' $P1899 = "376_1303857440.612" 
    capture_lex $P1899
    .const 'Sub' $P1893 = "374_1303857440.612" 
    capture_lex $P1893
    .const 'Sub' $P1881 = "371_1303857440.612" 
    capture_lex $P1881
    .const 'Sub' $P1874 = "369_1303857440.612" 
    capture_lex $P1874
    .const 'Sub' $P1867 = "367_1303857440.612" 
    capture_lex $P1867
    .const 'Sub' $P1860 = "365_1303857440.612" 
    capture_lex $P1860
    .const 'Sub' $P1853 = "363_1303857440.612" 
    capture_lex $P1853
    .const 'Sub' $P1847 = "361_1303857440.612" 
    capture_lex $P1847
    .const 'Sub' $P1840 = "359_1303857440.612" 
    capture_lex $P1840
    .const 'Sub' $P1833 = "357_1303857440.612" 
    capture_lex $P1833
    .const 'Sub' $P1826 = "355_1303857440.612" 
    capture_lex $P1826
    .const 'Sub' $P1819 = "353_1303857440.612" 
    capture_lex $P1819
    .const 'Sub' $P1812 = "351_1303857440.612" 
    capture_lex $P1812
    .const 'Sub' $P1805 = "349_1303857440.612" 
    capture_lex $P1805
    .const 'Sub' $P1798 = "347_1303857440.612" 
    capture_lex $P1798
    .const 'Sub' $P1791 = "345_1303857440.612" 
    capture_lex $P1791
    .const 'Sub' $P1784 = "343_1303857440.612" 
    capture_lex $P1784
    .const 'Sub' $P1777 = "341_1303857440.612" 
    capture_lex $P1777
    .const 'Sub' $P1770 = "339_1303857440.612" 
    capture_lex $P1770
    .const 'Sub' $P1763 = "337_1303857440.612" 
    capture_lex $P1763
    .const 'Sub' $P1756 = "335_1303857440.612" 
    capture_lex $P1756
    .const 'Sub' $P1749 = "333_1303857440.612" 
    capture_lex $P1749
    .const 'Sub' $P1742 = "331_1303857440.612" 
    capture_lex $P1742
    .const 'Sub' $P1735 = "329_1303857440.612" 
    capture_lex $P1735
    .const 'Sub' $P1728 = "327_1303857440.612" 
    capture_lex $P1728
    .const 'Sub' $P1721 = "325_1303857440.612" 
    capture_lex $P1721
    .const 'Sub' $P1714 = "323_1303857440.612" 
    capture_lex $P1714
    .const 'Sub' $P1707 = "321_1303857440.612" 
    capture_lex $P1707
    .const 'Sub' $P1700 = "319_1303857440.612" 
    capture_lex $P1700
    .const 'Sub' $P1693 = "317_1303857440.612" 
    capture_lex $P1693
    .const 'Sub' $P1686 = "315_1303857440.612" 
    capture_lex $P1686
    .const 'Sub' $P1679 = "313_1303857440.612" 
    capture_lex $P1679
    .const 'Sub' $P1672 = "311_1303857440.612" 
    capture_lex $P1672
    .const 'Sub' $P1665 = "309_1303857440.612" 
    capture_lex $P1665
    .const 'Sub' $P1658 = "307_1303857440.612" 
    capture_lex $P1658
    .const 'Sub' $P1651 = "305_1303857440.612" 
    capture_lex $P1651
    .const 'Sub' $P1644 = "303_1303857440.612" 
    capture_lex $P1644
    .const 'Sub' $P1638 = "301_1303857440.612" 
    capture_lex $P1638
    .const 'Sub' $P1631 = "299_1303857440.612" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "297_1303857440.612" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "295_1303857440.612" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "293_1303857440.612" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "291_1303857440.612" 
    capture_lex $P1603
    .const 'Sub' $P1596 = "289_1303857440.612" 
    capture_lex $P1596
    .const 'Sub' $P1589 = "287_1303857440.612" 
    capture_lex $P1589
    .const 'Sub' $P1583 = "285_1303857440.612" 
    capture_lex $P1583
    .const 'Sub' $P1577 = "283_1303857440.612" 
    capture_lex $P1577
    .const 'Sub' $P1572 = "281_1303857440.612" 
    capture_lex $P1572
    .const 'Sub' $P1566 = "279_1303857440.612" 
    capture_lex $P1566
    .const 'Sub' $P1560 = "277_1303857440.612" 
    capture_lex $P1560
    .const 'Sub' $P1555 = "275_1303857440.612" 
    capture_lex $P1555
    .const 'Sub' $P1550 = "273_1303857440.612" 
    capture_lex $P1550
    .const 'Sub' $P1542 = "271_1303857440.612" 
    capture_lex $P1542
    .const 'Sub' $P1533 = "269_1303857440.612" 
    capture_lex $P1533
    .const 'Sub' $P1528 = "267_1303857440.612" 
    capture_lex $P1528
    .const 'Sub' $P1523 = "265_1303857440.612" 
    capture_lex $P1523
    .const 'Sub' $P1518 = "263_1303857440.612" 
    capture_lex $P1518
    .const 'Sub' $P1510 = "261_1303857440.612" 
    capture_lex $P1510
    .const 'Sub' $P1502 = "259_1303857440.612" 
    capture_lex $P1502
    .const 'Sub' $P1497 = "257_1303857440.612" 
    capture_lex $P1497
    .const 'Sub' $P1492 = "255_1303857440.612" 
    capture_lex $P1492
    .const 'Sub' $P1487 = "253_1303857440.612" 
    capture_lex $P1487
    .const 'Sub' $P1481 = "251_1303857440.612" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "249_1303857440.612" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "247_1303857440.612" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "245_1303857440.612" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "243_1303857440.612" 
    capture_lex $P1453
    .const 'Sub' $P1448 = "241_1303857440.612" 
    capture_lex $P1448
    .const 'Sub' $P1443 = "239_1303857440.612" 
    capture_lex $P1443
    .const 'Sub' $P1429 = "235_1303857440.612" 
    capture_lex $P1429
    .const 'Sub' $P1421 = "233_1303857440.612" 
    capture_lex $P1421
    .const 'Sub' $P1415 = "231_1303857440.612" 
    capture_lex $P1415
    .const 'Sub' $P1408 = "229_1303857440.612" 
    capture_lex $P1408
    .const 'Sub' $P1402 = "227_1303857440.612" 
    capture_lex $P1402
    .const 'Sub' $P1386 = "224_1303857440.612" 
    capture_lex $P1386
    .const 'Sub' $P1378 = "222_1303857440.612" 
    capture_lex $P1378
    .const 'Sub' $P1370 = "220_1303857440.612" 
    capture_lex $P1370
    .const 'Sub' $P1364 = "218_1303857440.612" 
    capture_lex $P1364
    .const 'Sub' $P1358 = "216_1303857440.612" 
    capture_lex $P1358
    .const 'Sub' $P1342 = "212_1303857440.612" 
    capture_lex $P1342
    .const 'Sub' $P1301 = "210_1303857440.612" 
    capture_lex $P1301
    .const 'Sub' $P1290 = "208_1303857440.612" 
    capture_lex $P1290
    .const 'Sub' $P1276 = "204_1303857440.612" 
    capture_lex $P1276
    .const 'Sub' $P1267 = "202_1303857440.612" 
    capture_lex $P1267
    .const 'Sub' $P1261 = "200_1303857440.612" 
    capture_lex $P1261
    .const 'Sub' $P1251 = "198_1303857440.612" 
    capture_lex $P1251
    .const 'Sub' $P1236 = "196_1303857440.612" 
    capture_lex $P1236
    .const 'Sub' $P1220 = "193_1303857440.612" 
    capture_lex $P1220
    .const 'Sub' $P1212 = "191_1303857440.612" 
    capture_lex $P1212
    .const 'Sub' $P1202 = "189_1303857440.612" 
    capture_lex $P1202
    .const 'Sub' $P1192 = "187_1303857440.612" 
    capture_lex $P1192
    .const 'Sub' $P1171 = "182_1303857440.612" 
    capture_lex $P1171
    .const 'Sub' $P1127 = "179_1303857440.612" 
    capture_lex $P1127
    .const 'Sub' $P1093 = "177_1303857440.612" 
    capture_lex $P1093
    .const 'Sub' $P1086 = "175_1303857440.612" 
    capture_lex $P1086
    .const 'Sub' $P1079 = "173_1303857440.612" 
    capture_lex $P1079
    .const 'Sub' $P1062 = "169_1303857440.612" 
    capture_lex $P1062
    .const 'Sub' $P1054 = "167_1303857440.612" 
    capture_lex $P1054
    .const 'Sub' $P1048 = "165_1303857440.612" 
    capture_lex $P1048
    .const 'Sub' $P1032 = "163_1303857440.612" 
    capture_lex $P1032
    .const 'Sub' $P1025 = "161_1303857440.612" 
    capture_lex $P1025
    .const 'Sub' $P1018 = "159_1303857440.612" 
    capture_lex $P1018
    .const 'Sub' $P1011 = "157_1303857440.612" 
    capture_lex $P1011
    .const 'Sub' $P833 = "152_1303857440.612" 
    capture_lex $P833
    .const 'Sub' $P814 = "150_1303857440.612" 
    capture_lex $P814
    .const 'Sub' $P795 = "148_1303857440.612" 
    capture_lex $P795
    .const 'Sub' $P776 = "146_1303857440.612" 
    capture_lex $P776
    .const 'Sub' $P757 = "144_1303857440.612" 
    capture_lex $P757
    .const 'Sub' $P738 = "142_1303857440.612" 
    capture_lex $P738
    .const 'Sub' $P719 = "140_1303857440.612" 
    capture_lex $P719
    .const 'Sub' $P708 = "136_1303857440.612" 
    capture_lex $P708
    .const 'Sub' $P703 = "134_1303857440.612" 
    capture_lex $P703
    .const 'Sub' $P691 = "132_1303857440.612" 
    capture_lex $P691
    .const 'Sub' $P679 = "130_1303857440.612" 
    capture_lex $P679
    .const 'Sub' $P672 = "128_1303857440.612" 
    capture_lex $P672
    .const 'Sub' $P667 = "126_1303857440.612" 
    capture_lex $P667
    .const 'Sub' $P661 = "124_1303857440.612" 
    capture_lex $P661
    .const 'Sub' $P655 = "122_1303857440.612" 
    capture_lex $P655
    .const 'Sub' $P640 = "118_1303857440.612" 
    capture_lex $P640
    .const 'Sub' $P634 = "116_1303857440.612" 
    capture_lex $P634
    .const 'Sub' $P628 = "114_1303857440.612" 
    capture_lex $P628
    .const 'Sub' $P622 = "112_1303857440.612" 
    capture_lex $P622
    .const 'Sub' $P616 = "110_1303857440.612" 
    capture_lex $P616
    .const 'Sub' $P610 = "108_1303857440.612" 
    capture_lex $P610
    .const 'Sub' $P604 = "106_1303857440.612" 
    capture_lex $P604
    .const 'Sub' $P595 = "104_1303857440.612" 
    capture_lex $P595
    .const 'Sub' $P586 = "102_1303857440.612" 
    capture_lex $P586
    .const 'Sub' $P577 = "100_1303857440.612" 
    capture_lex $P577
    .const 'Sub' $P562 = "96_1303857440.612" 
    capture_lex $P562
    .const 'Sub' $P553 = "94_1303857440.612" 
    capture_lex $P553
    .const 'Sub' $P541 = "90_1303857440.612" 
    capture_lex $P541
    .const 'Sub' $P534 = "88_1303857440.612" 
    capture_lex $P534
    .const 'Sub' $P527 = "86_1303857440.612" 
    capture_lex $P527
    .const 'Sub' $P513 = "82_1303857440.612" 
    capture_lex $P513
    .const 'Sub' $P505 = "80_1303857440.612" 
    capture_lex $P505
    .const 'Sub' $P497 = "78_1303857440.612" 
    capture_lex $P497
    .const 'Sub' $P477 = "76_1303857440.612" 
    capture_lex $P477
    .const 'Sub' $P468 = "74_1303857440.612" 
    capture_lex $P468
    .const 'Sub' $P450 = "71_1303857440.612" 
    capture_lex $P450
    .const 'Sub' $P432 = "69_1303857440.612" 
    capture_lex $P432
    .const 'Sub' $P424 = "67_1303857440.612" 
    capture_lex $P424
    .const 'Sub' $P413 = "63_1303857440.612" 
    capture_lex $P413
    .const 'Sub' $P408 = "61_1303857440.612" 
    capture_lex $P408
    .const 'Sub' $P397 = "57_1303857440.612" 
    capture_lex $P397
    .const 'Sub' $P392 = "55_1303857440.612" 
    capture_lex $P392
    .const 'Sub' $P387 = "53_1303857440.612" 
    capture_lex $P387
    .const 'Sub' $P382 = "51_1303857440.612" 
    capture_lex $P382
    .const 'Sub' $P377 = "49_1303857440.612" 
    capture_lex $P377
    .const 'Sub' $P367 = "47_1303857440.612" 
    capture_lex $P367
    .const 'Sub' $P360 = "45_1303857440.612" 
    capture_lex $P360
    .const 'Sub' $P354 = "43_1303857440.612" 
    capture_lex $P354
    .const 'Sub' $P346 = "41_1303857440.612" 
    capture_lex $P346
    .const 'Sub' $P340 = "39_1303857440.612" 
    capture_lex $P340
    .const 'Sub' $P334 = "37_1303857440.612" 
    capture_lex $P334
    .const 'Sub' $P319 = "34_1303857440.612" 
    capture_lex $P319
    .const 'Sub' $P305 = "32_1303857440.612" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1303857440.612" 
    capture_lex $P284
    .const 'Sub' $P245 = "27_1303857440.612" 
    capture_lex $P245
    .const 'Sub' $P230 = "24_1303857440.612" 
    capture_lex $P230
    .const 'Sub' $P219 = "22_1303857440.612" 
    capture_lex $P219
    .const 'Sub' $P207 = "20_1303857440.612" 
    capture_lex $P207
    .const 'Sub' $P199 = "18_1303857440.612" 
    capture_lex $P199
    .const 'Sub' $P192 = "16_1303857440.612" 
    capture_lex $P192
    .const 'Sub' $P185 = "14_1303857440.612" 
    capture_lex $P185
    .const 'Sub' $P110 = "13_1303857440.612" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 605
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 606
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 607
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 608
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 609
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 610
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 611
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 612
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 613
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 614
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 615
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 616
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 617
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 618
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 619
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 718
    .const 'Sub' $P1917 = "382_1303857440.612" 
    newclosure $P1928, $P1917
.annotate 'line', 9
    .return ($P1928)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post598") :outer("12_1303857440.612")
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303857440.612" 
    .local pmc block
    set block, $P47
    .const 'Sub' $P1930 = "383_1303857440.612" 
    capture_lex $P1930
    $P1930()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1929"  :anon :subid("383_1303857440.612") :outer("12_1303857440.612")
.annotate 'line', 9
    nqp_get_sc_object $P1931, "1303857428.33", 1
    .local pmc type_obj
    set type_obj, $P1931
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "13_1303857440.612" 
    $P1932."add_method"(type_obj, "TOP", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "14_1303857440.612" 
    $P1934."add_method"(type_obj, "identifier", $P1935)
    get_how $P1936, type_obj
    get_global $P1937, "!PREFIX__identifier"
    $P1936."add_method"(type_obj, "!PREFIX__identifier", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "16_1303857440.612" 
    $P1938."add_method"(type_obj, "name", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__name"
    $P1940."add_method"(type_obj, "!PREFIX__name", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "18_1303857440.612" 
    $P1942."add_method"(type_obj, "deflongname", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__deflongname"
    $P1944."add_method"(type_obj, "!PREFIX__deflongname", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "20_1303857440.612" 
    $P1946."add_method"(type_obj, "ENDSTMT", $P1947)
    get_how $P1948, type_obj
    get_global $P1949, "!PREFIX__ENDSTMT"
    $P1948."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "22_1303857440.612" 
    $P1950."add_method"(type_obj, "ws", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__ws"
    $P1952."add_method"(type_obj, "!PREFIX__ws", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "24_1303857440.612" 
    $P1954."add_method"(type_obj, "unv", $P1955)
    get_how $P1956, type_obj
    get_global $P1957, "!PREFIX__unv"
    $P1956."add_method"(type_obj, "!PREFIX__unv", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "27_1303857440.612" 
    $P1958."add_method"(type_obj, "pod_comment", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__pod_comment"
    $P1960."add_method"(type_obj, "!PREFIX__pod_comment", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "30_1303857440.612" 
    $P1962."add_method"(type_obj, "comp_unit", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__comp_unit"
    $P1964."add_method"(type_obj, "!PREFIX__comp_unit", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "32_1303857440.612" 
    $P1966."add_method"(type_obj, "statementlist", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__statementlist"
    $P1968."add_method"(type_obj, "!PREFIX__statementlist", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "34_1303857440.612" 
    $P1970."add_method"(type_obj, "statement", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__statement"
    $P1972."add_method"(type_obj, "!PREFIX__statement", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "37_1303857440.612" 
    $P1974."add_method"(type_obj, "eat_terminator", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__eat_terminator"
    $P1976."add_method"(type_obj, "!PREFIX__eat_terminator", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "39_1303857440.612" 
    $P1978."add_method"(type_obj, "xblock", $P1979)
    get_how $P1980, type_obj
    get_global $P1981, "!PREFIX__xblock"
    $P1980."add_method"(type_obj, "!PREFIX__xblock", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "41_1303857440.612" 
    $P1982."add_method"(type_obj, "pblock", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__pblock"
    $P1984."add_method"(type_obj, "!PREFIX__pblock", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "43_1303857440.612" 
    $P1986."add_method"(type_obj, "lambda", $P1987)
    get_how $P1988, type_obj
    get_global $P1989, "!PREFIX__lambda"
    $P1988."add_method"(type_obj, "!PREFIX__lambda", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "45_1303857440.612" 
    $P1990."add_method"(type_obj, "block", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__block"
    $P1992."add_method"(type_obj, "!PREFIX__block", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "47_1303857440.612" 
    $P1994."add_method"(type_obj, "blockoid", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__blockoid"
    $P1996."add_method"(type_obj, "!PREFIX__blockoid", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "49_1303857440.612" 
    $P1998."add_method"(type_obj, "newpad", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__newpad"
    $P2000."add_method"(type_obj, "!PREFIX__newpad", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "51_1303857440.612" 
    $P2002."add_method"(type_obj, "outerctx", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__outerctx"
    $P2004."add_method"(type_obj, "!PREFIX__outerctx", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "53_1303857440.612" 
    $P2006."add_method"(type_obj, "GLOBALish", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__GLOBALish"
    $P2008."add_method"(type_obj, "!PREFIX__GLOBALish", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "55_1303857440.612" 
    $P2010."add_method"(type_obj, "finishpad", $P2011)
    get_how $P2012, type_obj
    get_global $P2013, "!PREFIX__finishpad"
    $P2012."add_method"(type_obj, "!PREFIX__finishpad", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "57_1303857440.612" 
    $P2014."add_method"(type_obj, "you_are_here", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__you_are_here"
    $P2016."add_method"(type_obj, "!PREFIX__you_are_here", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "59_1303857440.612" 
    $P2018."add_method"(type_obj, "terminator", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "60_1303857440.612" 
    $P2020."add_method"(type_obj, "!PREFIX__terminator", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "61_1303857440.612" 
    $P2022."add_method"(type_obj, "terminator:sym<;>", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__terminator:sym<;>"
    $P2024."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "63_1303857440.612" 
    $P2026."add_method"(type_obj, "terminator:sym<}>", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__terminator:sym<}>"
    $P2028."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "65_1303857440.612" 
    $P2030."add_method"(type_obj, "statement_control", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "66_1303857440.612" 
    $P2032."add_method"(type_obj, "!PREFIX__statement_control", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "67_1303857440.612" 
    $P2034."add_method"(type_obj, "statement_control:sym<use>", $P2035)
    get_how $P2036, type_obj
    get_global $P2037, "!PREFIX__statement_control:sym<use>"
    $P2036."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "69_1303857440.612" 
    $P2038."add_method"(type_obj, "statement_control:sym<if>", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__statement_control:sym<if>"
    $P2040."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "71_1303857440.612" 
    $P2042."add_method"(type_obj, "statement_control:sym<unless>", $P2043)
    get_how $P2044, type_obj
    get_global $P2045, "!PREFIX__statement_control:sym<unless>"
    $P2044."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "74_1303857440.612" 
    $P2046."add_method"(type_obj, "statement_control:sym<while>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__statement_control:sym<while>"
    $P2048."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "76_1303857440.612" 
    $P2050."add_method"(type_obj, "statement_control:sym<repeat>", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__statement_control:sym<repeat>"
    $P2052."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "78_1303857440.612" 
    $P2054."add_method"(type_obj, "statement_control:sym<for>", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__statement_control:sym<for>"
    $P2056."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "80_1303857440.612" 
    $P2058."add_method"(type_obj, "statement_control:sym<CATCH>", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__statement_control:sym<CATCH>"
    $P2060."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "82_1303857440.612" 
    $P2062."add_method"(type_obj, "statement_control:sym<CONTROL>", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__statement_control:sym<CONTROL>"
    $P2064."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "84_1303857440.612" 
    $P2066."add_method"(type_obj, "statement_prefix", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "85_1303857440.612" 
    $P2068."add_method"(type_obj, "!PREFIX__statement_prefix", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "86_1303857440.612" 
    $P2070."add_method"(type_obj, "statement_prefix:sym<INIT>", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__statement_prefix:sym<INIT>"
    $P2072."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "88_1303857440.612" 
    $P2074."add_method"(type_obj, "statement_prefix:sym<try>", $P2075)
    get_how $P2076, type_obj
    get_global $P2077, "!PREFIX__statement_prefix:sym<try>"
    $P2076."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "90_1303857440.612" 
    $P2078."add_method"(type_obj, "blorst", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__blorst"
    $P2080."add_method"(type_obj, "!PREFIX__blorst", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "92_1303857440.612" 
    $P2082."add_method"(type_obj, "statement_mod_cond", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "93_1303857440.612" 
    $P2084."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "94_1303857440.612" 
    $P2086."add_method"(type_obj, "statement_mod_cond:sym<if>", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__statement_mod_cond:sym<if>"
    $P2088."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "96_1303857440.612" 
    $P2090."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P2091)
    get_how $P2092, type_obj
    get_global $P2093, "!PREFIX__statement_mod_cond:sym<unless>"
    $P2092."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "98_1303857440.612" 
    $P2094."add_method"(type_obj, "statement_mod_loop", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "99_1303857440.612" 
    $P2096."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "100_1303857440.612" 
    $P2098."add_method"(type_obj, "statement_mod_loop:sym<while>", $P2099)
    get_how $P2100, type_obj
    get_global $P2101, "!PREFIX__statement_mod_loop:sym<while>"
    $P2100."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "102_1303857440.612" 
    $P2102."add_method"(type_obj, "statement_mod_loop:sym<until>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__statement_mod_loop:sym<until>"
    $P2104."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "104_1303857440.612" 
    $P2106."add_method"(type_obj, "statement_mod_loop:sym<for>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__statement_mod_loop:sym<for>"
    $P2108."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "106_1303857440.612" 
    $P2110."add_method"(type_obj, "term:sym<fatarrow>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__term:sym<fatarrow>"
    $P2112."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "108_1303857440.612" 
    $P2114."add_method"(type_obj, "term:sym<colonpair>", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__term:sym<colonpair>"
    $P2116."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "110_1303857440.612" 
    $P2118."add_method"(type_obj, "term:sym<variable>", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__term:sym<variable>"
    $P2120."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "112_1303857440.612" 
    $P2122."add_method"(type_obj, "term:sym<package_declarator>", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__term:sym<package_declarator>"
    $P2124."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "114_1303857440.612" 
    $P2126."add_method"(type_obj, "term:sym<scope_declarator>", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__term:sym<scope_declarator>"
    $P2128."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "116_1303857440.612" 
    $P2130."add_method"(type_obj, "term:sym<routine_declarator>", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__term:sym<routine_declarator>"
    $P2132."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "118_1303857440.612" 
    $P2134."add_method"(type_obj, "term:sym<multi_declarator>", $P2135)
    get_how $P2136, type_obj
    get_global $P2137, "!PREFIX__term:sym<multi_declarator>"
    $P2136."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "122_1303857440.612" 
    $P2138."add_method"(type_obj, "term:sym<regex_declarator>", $P2139)
    get_how $P2140, type_obj
    get_global $P2141, "!PREFIX__term:sym<regex_declarator>"
    $P2140."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "124_1303857440.612" 
    $P2142."add_method"(type_obj, "term:sym<statement_prefix>", $P2143)
    get_how $P2144, type_obj
    get_global $P2145, "!PREFIX__term:sym<statement_prefix>"
    $P2144."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "126_1303857440.612" 
    $P2146."add_method"(type_obj, "term:sym<lambda>", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__term:sym<lambda>"
    $P2148."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "128_1303857440.612" 
    $P2150."add_method"(type_obj, "fatarrow", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__fatarrow"
    $P2152."add_method"(type_obj, "!PREFIX__fatarrow", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "130_1303857440.612" 
    $P2154."add_method"(type_obj, "colonpair", $P2155)
    get_how $P2156, type_obj
    get_global $P2157, "!PREFIX__colonpair"
    $P2156."add_method"(type_obj, "!PREFIX__colonpair", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "132_1303857440.612" 
    $P2158."add_method"(type_obj, "variable", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__variable"
    $P2160."add_method"(type_obj, "!PREFIX__variable", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "134_1303857440.612" 
    $P2162."add_method"(type_obj, "sigil", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__sigil"
    $P2164."add_method"(type_obj, "!PREFIX__sigil", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "136_1303857440.612" 
    $P2166."add_method"(type_obj, "twigil", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__twigil"
    $P2168."add_method"(type_obj, "!PREFIX__twigil", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "138_1303857440.612" 
    $P2170."add_method"(type_obj, "package_declarator", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "139_1303857440.612" 
    $P2172."add_method"(type_obj, "!PREFIX__package_declarator", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "140_1303857440.612" 
    $P2174."add_method"(type_obj, "package_declarator:sym<module>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__package_declarator:sym<module>"
    $P2176."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "142_1303857440.612" 
    $P2178."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__package_declarator:sym<knowhow>"
    $P2180."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "144_1303857440.612" 
    $P2182."add_method"(type_obj, "package_declarator:sym<class>", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__package_declarator:sym<class>"
    $P2184."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "146_1303857440.612" 
    $P2186."add_method"(type_obj, "package_declarator:sym<grammar>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__package_declarator:sym<grammar>"
    $P2188."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "148_1303857440.612" 
    $P2190."add_method"(type_obj, "package_declarator:sym<role>", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, "!PREFIX__package_declarator:sym<role>"
    $P2192."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "150_1303857440.612" 
    $P2194."add_method"(type_obj, "package_declarator:sym<native>", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__package_declarator:sym<native>"
    $P2196."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "152_1303857440.612" 
    $P2198."add_method"(type_obj, "package_def", $P2199)
    get_how $P2200, type_obj
    get_global $P2201, "!PREFIX__package_def"
    $P2200."add_method"(type_obj, "!PREFIX__package_def", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "155_1303857440.612" 
    $P2202."add_method"(type_obj, "scope_declarator", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "156_1303857440.612" 
    $P2204."add_method"(type_obj, "!PREFIX__scope_declarator", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "157_1303857440.612" 
    $P2206."add_method"(type_obj, "scope_declarator:sym<my>", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__scope_declarator:sym<my>"
    $P2208."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "159_1303857440.612" 
    $P2210."add_method"(type_obj, "scope_declarator:sym<our>", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__scope_declarator:sym<our>"
    $P2212."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "161_1303857440.612" 
    $P2214."add_method"(type_obj, "scope_declarator:sym<has>", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__scope_declarator:sym<has>"
    $P2216."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "163_1303857440.612" 
    $P2218."add_method"(type_obj, "scoped", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__scoped"
    $P2220."add_method"(type_obj, "!PREFIX__scoped", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "165_1303857440.612" 
    $P2222."add_method"(type_obj, "typename", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__typename"
    $P2224."add_method"(type_obj, "!PREFIX__typename", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "167_1303857440.612" 
    $P2226."add_method"(type_obj, "declarator", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__declarator"
    $P2228."add_method"(type_obj, "!PREFIX__declarator", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "169_1303857440.612" 
    $P2230."add_method"(type_obj, "variable_declarator", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__variable_declarator"
    $P2232."add_method"(type_obj, "!PREFIX__variable_declarator", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "171_1303857440.612" 
    $P2234."add_method"(type_obj, "routine_declarator", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "172_1303857440.612" 
    $P2236."add_method"(type_obj, "!PREFIX__routine_declarator", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "173_1303857440.612" 
    $P2238."add_method"(type_obj, "routine_declarator:sym<sub>", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__routine_declarator:sym<sub>"
    $P2240."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "175_1303857440.612" 
    $P2242."add_method"(type_obj, "routine_declarator:sym<method>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__routine_declarator:sym<method>"
    $P2244."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "177_1303857440.612" 
    $P2246."add_method"(type_obj, "routine_def", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__routine_def"
    $P2248."add_method"(type_obj, "!PREFIX__routine_def", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "179_1303857440.612" 
    $P2250."add_method"(type_obj, "method_def", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__method_def"
    $P2252."add_method"(type_obj, "!PREFIX__method_def", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "182_1303857440.612" 
    $P2254."add_method"(type_obj, "onlystar", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, "!PREFIX__onlystar"
    $P2256."add_method"(type_obj, "!PREFIX__onlystar", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "185_1303857440.612" 
    $P2258."add_method"(type_obj, "multi_declarator", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "186_1303857440.612" 
    $P2260."add_method"(type_obj, "!PREFIX__multi_declarator", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "187_1303857440.612" 
    $P2262."add_method"(type_obj, "multi_declarator:sym<multi>", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__multi_declarator:sym<multi>"
    $P2264."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "189_1303857440.612" 
    $P2266."add_method"(type_obj, "multi_declarator:sym<proto>", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__multi_declarator:sym<proto>"
    $P2268."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "191_1303857440.612" 
    $P2270."add_method"(type_obj, "multi_declarator:sym<null>", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__multi_declarator:sym<null>"
    $P2272."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "193_1303857440.612" 
    $P2274."add_method"(type_obj, "signature", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__signature"
    $P2276."add_method"(type_obj, "!PREFIX__signature", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "196_1303857440.612" 
    $P2278."add_method"(type_obj, "parameter", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__parameter"
    $P2280."add_method"(type_obj, "!PREFIX__parameter", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "198_1303857440.612" 
    $P2282."add_method"(type_obj, "param_var", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__param_var"
    $P2284."add_method"(type_obj, "!PREFIX__param_var", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "200_1303857440.612" 
    $P2286."add_method"(type_obj, "named_param", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__named_param"
    $P2288."add_method"(type_obj, "!PREFIX__named_param", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "202_1303857440.612" 
    $P2290."add_method"(type_obj, "default_value", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__default_value"
    $P2292."add_method"(type_obj, "!PREFIX__default_value", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "204_1303857440.612" 
    $P2294."add_method"(type_obj, "trait", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__trait"
    $P2296."add_method"(type_obj, "!PREFIX__trait", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "206_1303857440.612" 
    $P2298."add_method"(type_obj, "trait_mod", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "207_1303857440.612" 
    $P2300."add_method"(type_obj, "!PREFIX__trait_mod", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "208_1303857440.612" 
    $P2302."add_method"(type_obj, "trait_mod:sym<is>", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__trait_mod:sym<is>"
    $P2304."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "210_1303857440.612" 
    $P2306."add_method"(type_obj, "regex_declarator", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__regex_declarator"
    $P2308."add_method"(type_obj, "!PREFIX__regex_declarator", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "212_1303857440.612" 
    $P2310."add_method"(type_obj, "dotty", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__dotty"
    $P2312."add_method"(type_obj, "!PREFIX__dotty", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "214_1303857440.612" 
    $P2314."add_method"(type_obj, "term", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "215_1303857440.612" 
    $P2316."add_method"(type_obj, "!PREFIX__term", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "216_1303857440.612" 
    $P2318."add_method"(type_obj, "term:sym<self>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__term:sym<self>"
    $P2320."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "218_1303857440.612" 
    $P2322."add_method"(type_obj, "term:sym<identifier>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__term:sym<identifier>"
    $P2324."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "220_1303857440.612" 
    $P2326."add_method"(type_obj, "term:sym<name>", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__term:sym<name>"
    $P2328."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "222_1303857440.612" 
    $P2330."add_method"(type_obj, "term:sym<pir::op>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__term:sym<pir::op>"
    $P2332."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "224_1303857440.612" 
    $P2334."add_method"(type_obj, "term:sym<onlystar>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__term:sym<onlystar>"
    $P2336."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "227_1303857440.612" 
    $P2338."add_method"(type_obj, "args", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__args"
    $P2340."add_method"(type_obj, "!PREFIX__args", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "229_1303857440.612" 
    $P2342."add_method"(type_obj, "arglist", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__arglist"
    $P2344."add_method"(type_obj, "!PREFIX__arglist", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "231_1303857440.612" 
    $P2346."add_method"(type_obj, "term:sym<value>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__term:sym<value>"
    $P2348."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "233_1303857440.612" 
    $P2350."add_method"(type_obj, "value", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__value"
    $P2352."add_method"(type_obj, "!PREFIX__value", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "235_1303857440.612" 
    $P2354."add_method"(type_obj, "number", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__number"
    $P2356."add_method"(type_obj, "!PREFIX__number", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "237_1303857440.612" 
    $P2358."add_method"(type_obj, "quote", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "238_1303857440.612" 
    $P2360."add_method"(type_obj, "!PREFIX__quote", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "239_1303857440.612" 
    $P2362."add_method"(type_obj, "quote:sym<apos>", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__quote:sym<apos>"
    $P2364."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "241_1303857440.612" 
    $P2366."add_method"(type_obj, "quote:sym<dblq>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__quote:sym<dblq>"
    $P2368."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "243_1303857440.612" 
    $P2370."add_method"(type_obj, "quote:sym<q>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__quote:sym<q>"
    $P2372."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "245_1303857440.612" 
    $P2374."add_method"(type_obj, "quote:sym<qq>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__quote:sym<qq>"
    $P2376."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "247_1303857440.612" 
    $P2378."add_method"(type_obj, "quote:sym<Q>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__quote:sym<Q>"
    $P2380."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "249_1303857440.612" 
    $P2382."add_method"(type_obj, "quote:sym<Q:PIR>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__quote:sym<Q:PIR>"
    $P2384."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "251_1303857440.612" 
    $P2386."add_method"(type_obj, "quote:sym</ />", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__quote:sym</ />"
    $P2388."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "253_1303857440.612" 
    $P2390."add_method"(type_obj, "quote_escape:sym<$>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__quote_escape:sym<$>"
    $P2392."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "255_1303857440.612" 
    $P2394."add_method"(type_obj, "quote_escape:sym<{ }>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__quote_escape:sym<{ }>"
    $P2396."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "257_1303857440.612" 
    $P2398."add_method"(type_obj, "quote_escape:sym<esc>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__quote_escape:sym<esc>"
    $P2400."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "259_1303857440.612" 
    $P2402."add_method"(type_obj, "circumfix:sym<( )>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__circumfix:sym<( )>"
    $P2404."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "261_1303857440.612" 
    $P2406."add_method"(type_obj, "circumfix:sym<[ ]>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__circumfix:sym<[ ]>"
    $P2408."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "263_1303857440.612" 
    $P2410."add_method"(type_obj, "circumfix:sym<ang>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__circumfix:sym<ang>"
    $P2412."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "265_1303857440.612" 
    $P2414."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2416."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "267_1303857440.612" 
    $P2418."add_method"(type_obj, "circumfix:sym<{ }>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__circumfix:sym<{ }>"
    $P2420."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "269_1303857440.612" 
    $P2422."add_method"(type_obj, "circumfix:sym<sigil>", $P2423)
    get_how $P2424, type_obj
    get_global $P2425, "!PREFIX__circumfix:sym<sigil>"
    $P2424."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2425)
    get_how $P2426, type_obj
    .const 'Sub' $P2427 = "271_1303857440.612" 
    $P2426."add_method"(type_obj, "semilist", $P2427)
    get_how $P2428, type_obj
    get_global $P2429, "!PREFIX__semilist"
    $P2428."add_method"(type_obj, "!PREFIX__semilist", $P2429)
    get_how $P2430, type_obj
    .const 'Sub' $P2431 = "273_1303857440.612" 
    $P2430."add_method"(type_obj, "infixish", $P2431)
    get_how $P2432, type_obj
    get_global $P2433, "!PREFIX__infixish"
    $P2432."add_method"(type_obj, "!PREFIX__infixish", $P2433)
    get_how $P2434, type_obj
    .const 'Sub' $P2435 = "275_1303857440.612" 
    $P2434."add_method"(type_obj, "infixstopper", $P2435)
    get_how $P2436, type_obj
    get_global $P2437, "!PREFIX__infixstopper"
    $P2436."add_method"(type_obj, "!PREFIX__infixstopper", $P2437)
    get_how $P2438, type_obj
    .const 'Sub' $P2439 = "277_1303857440.612" 
    $P2438."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2439)
    get_how $P2440, type_obj
    get_global $P2441, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2440."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2441)
    get_how $P2442, type_obj
    .const 'Sub' $P2443 = "279_1303857440.612" 
    $P2442."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2443)
    get_how $P2444, type_obj
    get_global $P2445, "!PREFIX__postcircumfix:sym<{ }>"
    $P2444."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2445)
    get_how $P2446, type_obj
    .const 'Sub' $P2447 = "281_1303857440.612" 
    $P2446."add_method"(type_obj, "postcircumfix:sym<ang>", $P2447)
    get_how $P2448, type_obj
    get_global $P2449, "!PREFIX__postcircumfix:sym<ang>"
    $P2448."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2449)
    get_how $P2450, type_obj
    .const 'Sub' $P2451 = "283_1303857440.612" 
    $P2450."add_method"(type_obj, "postcircumfix:sym<( )>", $P2451)
    get_how $P2452, type_obj
    get_global $P2453, "!PREFIX__postcircumfix:sym<( )>"
    $P2452."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2453)
    get_how $P2454, type_obj
    .const 'Sub' $P2455 = "285_1303857440.612" 
    $P2454."add_method"(type_obj, "postfix:sym<.>", $P2455)
    get_how $P2456, type_obj
    get_global $P2457, "!PREFIX__postfix:sym<.>"
    $P2456."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2457)
    get_how $P2458, type_obj
    .const 'Sub' $P2459 = "287_1303857440.612" 
    $P2458."add_method"(type_obj, "prefix:sym<++>", $P2459)
    get_how $P2460, type_obj
    get_global $P2461, "!PREFIX__prefix:sym<++>"
    $P2460."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2461)
    get_how $P2462, type_obj
    .const 'Sub' $P2463 = "289_1303857440.612" 
    $P2462."add_method"(type_obj, "prefix:sym<-->", $P2463)
    get_how $P2464, type_obj
    get_global $P2465, "!PREFIX__prefix:sym<-->"
    $P2464."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2465)
    get_how $P2466, type_obj
    .const 'Sub' $P2467 = "291_1303857440.612" 
    $P2466."add_method"(type_obj, "postfix:sym<++>", $P2467)
    get_how $P2468, type_obj
    get_global $P2469, "!PREFIX__postfix:sym<++>"
    $P2468."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2469)
    get_how $P2470, type_obj
    .const 'Sub' $P2471 = "293_1303857440.612" 
    $P2470."add_method"(type_obj, "postfix:sym<-->", $P2471)
    get_how $P2472, type_obj
    get_global $P2473, "!PREFIX__postfix:sym<-->"
    $P2472."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2473)
    get_how $P2474, type_obj
    .const 'Sub' $P2475 = "295_1303857440.612" 
    $P2474."add_method"(type_obj, "infix:sym<**>", $P2475)
    get_how $P2476, type_obj
    get_global $P2477, "!PREFIX__infix:sym<**>"
    $P2476."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2477)
    get_how $P2478, type_obj
    .const 'Sub' $P2479 = "297_1303857440.612" 
    $P2478."add_method"(type_obj, "prefix:sym<+>", $P2479)
    get_how $P2480, type_obj
    get_global $P2481, "!PREFIX__prefix:sym<+>"
    $P2480."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2481)
    get_how $P2482, type_obj
    .const 'Sub' $P2483 = "299_1303857440.612" 
    $P2482."add_method"(type_obj, "prefix:sym<~>", $P2483)
    get_how $P2484, type_obj
    get_global $P2485, "!PREFIX__prefix:sym<~>"
    $P2484."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2485)
    get_how $P2486, type_obj
    .const 'Sub' $P2487 = "301_1303857440.612" 
    $P2486."add_method"(type_obj, "prefix:sym<->", $P2487)
    get_how $P2488, type_obj
    get_global $P2489, "!PREFIX__prefix:sym<->"
    $P2488."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2489)
    get_how $P2490, type_obj
    .const 'Sub' $P2491 = "303_1303857440.612" 
    $P2490."add_method"(type_obj, "prefix:sym<?>", $P2491)
    get_how $P2492, type_obj
    get_global $P2493, "!PREFIX__prefix:sym<?>"
    $P2492."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2493)
    get_how $P2494, type_obj
    .const 'Sub' $P2495 = "305_1303857440.612" 
    $P2494."add_method"(type_obj, "prefix:sym<!>", $P2495)
    get_how $P2496, type_obj
    get_global $P2497, "!PREFIX__prefix:sym<!>"
    $P2496."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2497)
    get_how $P2498, type_obj
    .const 'Sub' $P2499 = "307_1303857440.612" 
    $P2498."add_method"(type_obj, "prefix:sym<|>", $P2499)
    get_how $P2500, type_obj
    get_global $P2501, "!PREFIX__prefix:sym<|>"
    $P2500."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2501)
    get_how $P2502, type_obj
    .const 'Sub' $P2503 = "309_1303857440.612" 
    $P2502."add_method"(type_obj, "infix:sym<*>", $P2503)
    get_how $P2504, type_obj
    get_global $P2505, "!PREFIX__infix:sym<*>"
    $P2504."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2505)
    get_how $P2506, type_obj
    .const 'Sub' $P2507 = "311_1303857440.612" 
    $P2506."add_method"(type_obj, "infix:sym</>", $P2507)
    get_how $P2508, type_obj
    get_global $P2509, "!PREFIX__infix:sym</>"
    $P2508."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2509)
    get_how $P2510, type_obj
    .const 'Sub' $P2511 = "313_1303857440.612" 
    $P2510."add_method"(type_obj, "infix:sym<%>", $P2511)
    get_how $P2512, type_obj
    get_global $P2513, "!PREFIX__infix:sym<%>"
    $P2512."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2513)
    get_how $P2514, type_obj
    .const 'Sub' $P2515 = "315_1303857440.612" 
    $P2514."add_method"(type_obj, "infix:sym<+&>", $P2515)
    get_how $P2516, type_obj
    get_global $P2517, "!PREFIX__infix:sym<+&>"
    $P2516."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2517)
    get_how $P2518, type_obj
    .const 'Sub' $P2519 = "317_1303857440.612" 
    $P2518."add_method"(type_obj, "infix:sym<+>", $P2519)
    get_how $P2520, type_obj
    get_global $P2521, "!PREFIX__infix:sym<+>"
    $P2520."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2521)
    get_how $P2522, type_obj
    .const 'Sub' $P2523 = "319_1303857440.612" 
    $P2522."add_method"(type_obj, "infix:sym<->", $P2523)
    get_how $P2524, type_obj
    get_global $P2525, "!PREFIX__infix:sym<->"
    $P2524."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2525)
    get_how $P2526, type_obj
    .const 'Sub' $P2527 = "321_1303857440.612" 
    $P2526."add_method"(type_obj, "infix:sym<+|>", $P2527)
    get_how $P2528, type_obj
    get_global $P2529, "!PREFIX__infix:sym<+|>"
    $P2528."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2529)
    get_how $P2530, type_obj
    .const 'Sub' $P2531 = "323_1303857440.612" 
    $P2530."add_method"(type_obj, "infix:sym<+^>", $P2531)
    get_how $P2532, type_obj
    get_global $P2533, "!PREFIX__infix:sym<+^>"
    $P2532."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2533)
    get_how $P2534, type_obj
    .const 'Sub' $P2535 = "325_1303857440.612" 
    $P2534."add_method"(type_obj, "infix:sym<~>", $P2535)
    get_how $P2536, type_obj
    get_global $P2537, "!PREFIX__infix:sym<~>"
    $P2536."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2537)
    get_how $P2538, type_obj
    .const 'Sub' $P2539 = "327_1303857440.612" 
    $P2538."add_method"(type_obj, "infix:sym<==>", $P2539)
    get_how $P2540, type_obj
    get_global $P2541, "!PREFIX__infix:sym<==>"
    $P2540."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2541)
    get_how $P2542, type_obj
    .const 'Sub' $P2543 = "329_1303857440.612" 
    $P2542."add_method"(type_obj, "infix:sym<!=>", $P2543)
    get_how $P2544, type_obj
    get_global $P2545, "!PREFIX__infix:sym<!=>"
    $P2544."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2545)
    get_how $P2546, type_obj
    .const 'Sub' $P2547 = "331_1303857440.612" 
    $P2546."add_method"(type_obj, "infix:sym<<=>", $P2547)
    get_how $P2548, type_obj
    get_global $P2549, "!PREFIX__infix:sym<<=>"
    $P2548."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2549)
    get_how $P2550, type_obj
    .const 'Sub' $P2551 = "333_1303857440.612" 
    $P2550."add_method"(type_obj, "infix:sym<>=>", $P2551)
    get_how $P2552, type_obj
    get_global $P2553, "!PREFIX__infix:sym<>=>"
    $P2552."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2553)
    get_how $P2554, type_obj
    .const 'Sub' $P2555 = "335_1303857440.612" 
    $P2554."add_method"(type_obj, "infix:sym<<>", $P2555)
    get_how $P2556, type_obj
    get_global $P2557, "!PREFIX__infix:sym<<>"
    $P2556."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2557)
    get_how $P2558, type_obj
    .const 'Sub' $P2559 = "337_1303857440.612" 
    $P2558."add_method"(type_obj, "infix:sym<>>", $P2559)
    get_how $P2560, type_obj
    get_global $P2561, "!PREFIX__infix:sym<>>"
    $P2560."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2561)
    get_how $P2562, type_obj
    .const 'Sub' $P2563 = "339_1303857440.612" 
    $P2562."add_method"(type_obj, "infix:sym<eq>", $P2563)
    get_how $P2564, type_obj
    get_global $P2565, "!PREFIX__infix:sym<eq>"
    $P2564."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2565)
    get_how $P2566, type_obj
    .const 'Sub' $P2567 = "341_1303857440.612" 
    $P2566."add_method"(type_obj, "infix:sym<ne>", $P2567)
    get_how $P2568, type_obj
    get_global $P2569, "!PREFIX__infix:sym<ne>"
    $P2568."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2569)
    get_how $P2570, type_obj
    .const 'Sub' $P2571 = "343_1303857440.612" 
    $P2570."add_method"(type_obj, "infix:sym<le>", $P2571)
    get_how $P2572, type_obj
    get_global $P2573, "!PREFIX__infix:sym<le>"
    $P2572."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2573)
    get_how $P2574, type_obj
    .const 'Sub' $P2575 = "345_1303857440.612" 
    $P2574."add_method"(type_obj, "infix:sym<ge>", $P2575)
    get_how $P2576, type_obj
    get_global $P2577, "!PREFIX__infix:sym<ge>"
    $P2576."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2577)
    get_how $P2578, type_obj
    .const 'Sub' $P2579 = "347_1303857440.612" 
    $P2578."add_method"(type_obj, "infix:sym<lt>", $P2579)
    get_how $P2580, type_obj
    get_global $P2581, "!PREFIX__infix:sym<lt>"
    $P2580."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2581)
    get_how $P2582, type_obj
    .const 'Sub' $P2583 = "349_1303857440.612" 
    $P2582."add_method"(type_obj, "infix:sym<gt>", $P2583)
    get_how $P2584, type_obj
    get_global $P2585, "!PREFIX__infix:sym<gt>"
    $P2584."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2585)
    get_how $P2586, type_obj
    .const 'Sub' $P2587 = "351_1303857440.612" 
    $P2586."add_method"(type_obj, "infix:sym<=:=>", $P2587)
    get_how $P2588, type_obj
    get_global $P2589, "!PREFIX__infix:sym<=:=>"
    $P2588."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2589)
    get_how $P2590, type_obj
    .const 'Sub' $P2591 = "353_1303857440.612" 
    $P2590."add_method"(type_obj, "infix:sym<~~>", $P2591)
    get_how $P2592, type_obj
    get_global $P2593, "!PREFIX__infix:sym<~~>"
    $P2592."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2593)
    get_how $P2594, type_obj
    .const 'Sub' $P2595 = "355_1303857440.612" 
    $P2594."add_method"(type_obj, "infix:sym<&&>", $P2595)
    get_how $P2596, type_obj
    get_global $P2597, "!PREFIX__infix:sym<&&>"
    $P2596."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2597)
    get_how $P2598, type_obj
    .const 'Sub' $P2599 = "357_1303857440.612" 
    $P2598."add_method"(type_obj, "infix:sym<||>", $P2599)
    get_how $P2600, type_obj
    get_global $P2601, "!PREFIX__infix:sym<||>"
    $P2600."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2601)
    get_how $P2602, type_obj
    .const 'Sub' $P2603 = "359_1303857440.612" 
    $P2602."add_method"(type_obj, "infix:sym<//>", $P2603)
    get_how $P2604, type_obj
    get_global $P2605, "!PREFIX__infix:sym<//>"
    $P2604."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2605)
    get_how $P2606, type_obj
    .const 'Sub' $P2607 = "361_1303857440.612" 
    $P2606."add_method"(type_obj, "infix:sym<?? !!>", $P2607)
    get_how $P2608, type_obj
    get_global $P2609, "!PREFIX__infix:sym<?? !!>"
    $P2608."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2609)
    get_how $P2610, type_obj
    .const 'Sub' $P2611 = "363_1303857440.612" 
    $P2610."add_method"(type_obj, "infix:sym<=>", $P2611)
    get_how $P2612, type_obj
    get_global $P2613, "!PREFIX__infix:sym<=>"
    $P2612."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2613)
    get_how $P2614, type_obj
    .const 'Sub' $P2615 = "365_1303857440.612" 
    $P2614."add_method"(type_obj, "infix:sym<:=>", $P2615)
    get_how $P2616, type_obj
    get_global $P2617, "!PREFIX__infix:sym<:=>"
    $P2616."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2617)
    get_how $P2618, type_obj
    .const 'Sub' $P2619 = "367_1303857440.612" 
    $P2618."add_method"(type_obj, "infix:sym<::=>", $P2619)
    get_how $P2620, type_obj
    get_global $P2621, "!PREFIX__infix:sym<::=>"
    $P2620."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2621)
    get_how $P2622, type_obj
    .const 'Sub' $P2623 = "369_1303857440.612" 
    $P2622."add_method"(type_obj, "infix:sym<,>", $P2623)
    get_how $P2624, type_obj
    get_global $P2625, "!PREFIX__infix:sym<,>"
    $P2624."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2625)
    get_how $P2626, type_obj
    .const 'Sub' $P2627 = "371_1303857440.612" 
    $P2626."add_method"(type_obj, "prefix:sym<return>", $P2627)
    get_how $P2628, type_obj
    get_global $P2629, "!PREFIX__prefix:sym<return>"
    $P2628."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2629)
    get_how $P2630, type_obj
    .const 'Sub' $P2631 = "374_1303857440.612" 
    $P2630."add_method"(type_obj, "prefix:sym<make>", $P2631)
    get_how $P2632, type_obj
    get_global $P2633, "!PREFIX__prefix:sym<make>"
    $P2632."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2633)
    get_how $P2634, type_obj
    .const 'Sub' $P2635 = "376_1303857440.612" 
    $P2634."add_method"(type_obj, "term:sym<last>", $P2635)
    get_how $P2636, type_obj
    get_global $P2637, "!PREFIX__term:sym<last>"
    $P2636."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2637)
    get_how $P2638, type_obj
    .const 'Sub' $P2639 = "378_1303857440.612" 
    $P2638."add_method"(type_obj, "term:sym<next>", $P2639)
    get_how $P2640, type_obj
    get_global $P2641, "!PREFIX__term:sym<next>"
    $P2640."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2641)
    get_how $P2642, type_obj
    .const 'Sub' $P2643 = "380_1303857440.612" 
    $P2642."add_method"(type_obj, "term:sym<redo>", $P2643)
    get_how $P2644, type_obj
    get_global $P2645, "!PREFIX__term:sym<redo>"
    $P2644."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2645)
    get_how $P2646, type_obj
    .const 'Sub' $P2647 = "382_1303857440.612" 
    $P2646."add_method"(type_obj, "smartmatch", $P2647)
    get_how $P2648, type_obj
    $P2649 = $P2648."compose"(type_obj)
    .return ($P2649)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303857440.612") :outer("12_1303857440.612")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 20
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 24
    new $P114, "Undef"
    .lex "$*DEFAULT-METAATTR", $P114
.annotate 'line', 25
    $P115 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P115
.annotate 'line', 31
    new $P116, "Undef"
    .lex "$*SC", $P116
.annotate 'line', 35
    new $P117, "Undef"
    .lex "$*SCOPE", $P117
.annotate 'line', 36
    new $P118, "Undef"
    .lex "$*MULTINESS", $P118
.annotate 'line', 37
    new $P119, "Undef"
    .lex "$*INVOCANT_OK", $P119
.annotate 'line', 38
    new $P120, "Undef"
    .lex "$*RETURN_USED", $P120
.annotate 'line', 39
    new $P121, "Undef"
    .lex "$*PACKAGE-SETUP", $P121
.annotate 'line', 10
    find_lex $P124, "%*LANG"
    unless_null $P124, vivify_599
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%LANG"]
    unless_null $P124, vivify_600
    die "Contextual %*LANG not found"
  vivify_600:
  vivify_599:
.annotate 'line', 13
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "NQP"
    get_who $P127, $P126
    set $P128, $P127["Regex"]
    find_lex $P131, "%*LANG"
    unless_null $P131, vivify_601
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%LANG"]
    unless_null $P131, vivify_602
    die "Contextual %*LANG not found"
  vivify_602:
    store_lex "%*LANG", $P131
  vivify_601:
    set $P131["Regex"], $P128
.annotate 'line', 14
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "NQP"
    get_who $P134, $P133
    set $P135, $P134["RegexActions"]
    find_lex $P138, "%*LANG"
    unless_null $P138, vivify_603
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["%LANG"]
    unless_null $P138, vivify_604
    die "Contextual %*LANG not found"
  vivify_604:
    store_lex "%*LANG", $P138
  vivify_603:
    set $P138["Regex-actions"], $P135
.annotate 'line', 15
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "NQP"
    get_who $P141, $P140
    set $P142, $P141["Grammar"]
    find_lex $P145, "%*LANG"
    unless_null $P145, vivify_605
    get_hll_global $P143, "GLOBAL"
    get_who $P144, $P143
    set $P145, $P144["%LANG"]
    unless_null $P145, vivify_606
    die "Contextual %*LANG not found"
  vivify_606:
    store_lex "%*LANG", $P145
  vivify_605:
    set $P145["MAIN"], $P142
.annotate 'line', 16
    get_hll_global $P146, "GLOBAL"
    nqp_get_package_through_who $P147, $P146, "NQP"
    get_who $P148, $P147
    set $P149, $P148["Actions"]
    find_lex $P152, "%*LANG"
    unless_null $P152, vivify_607
    get_hll_global $P150, "GLOBAL"
    get_who $P151, $P150
    set $P152, $P151["%LANG"]
    unless_null $P152, vivify_608
    die "Contextual %*LANG not found"
  vivify_608:
    store_lex "%*LANG", $P152
  vivify_607:
    set $P152["MAIN-actions"], $P149
    find_lex $P155, "%*HOW"
    unless_null $P155, vivify_609
    get_hll_global $P153, "GLOBAL"
    get_who $P154, $P153
    set $P155, $P154["%HOW"]
    unless_null $P155, vivify_610
    die "Contextual %*HOW not found"
  vivify_610:
  vivify_609:
.annotate 'line', 21
    get_knowhow $P156
    find_lex $P159, "%*HOW"
    unless_null $P159, vivify_611
    get_hll_global $P157, "GLOBAL"
    get_who $P158, $P157
    set $P159, $P158["%HOW"]
    unless_null $P159, vivify_612
    die "Contextual %*HOW not found"
  vivify_612:
    store_lex "%*HOW", $P159
  vivify_611:
    set $P159["knowhow"], $P156
.annotate 'line', 24
    new $P160, "String"
    assign $P160, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P160
    find_lex $P163, "%*HOW-METAATTR"
    unless_null $P163, vivify_613
    get_hll_global $P161, "GLOBAL"
    get_who $P162, $P161
    set $P163, $P162["%HOW-METAATTR"]
    unless_null $P163, vivify_614
    die "Contextual %*HOW-METAATTR not found"
  vivify_614:
  vivify_613:
.annotate 'line', 26
    new $P164, "String"
    assign $P164, "KnowHOWAttribute"
    find_lex $P167, "%*HOW-METAATTR"
    unless_null $P167, vivify_615
    get_hll_global $P165, "GLOBAL"
    get_who $P166, $P165
    set $P167, $P166["%HOW-METAATTR"]
    unless_null $P167, vivify_616
    die "Contextual %*HOW-METAATTR not found"
  vivify_616:
    store_lex "%*HOW-METAATTR", $P167
  vivify_615:
    set $P167["knowhow"], $P164
.annotate 'line', 31
    get_hll_global $P168, "GLOBAL"
    nqp_get_package_through_who $P169, $P168, "HLL"
    nqp_get_package_through_who $P170, $P169, "Compiler"
    get_who $P171, $P170
    set $P172, $P171["SerializationContextBuilder"]
.annotate 'line', 33
    time $N173
    set $S174, $N173
    $P175 = $P172."new"($S174 :named("handle"))
.annotate 'line', 31
    store_lex "$*SC", $P175
.annotate 'line', 35
    new $P176, "String"
    assign $P176, ""
    store_lex "$*SCOPE", $P176
.annotate 'line', 36
    new $P177, "String"
    assign $P177, ""
    store_lex "$*MULTINESS", $P177
.annotate 'line', 37
    new $P178, "Integer"
    assign $P178, 0
    store_lex "$*INVOCANT_OK", $P178
.annotate 'line', 38
    new $P179, "Integer"
    assign $P179, 0
    store_lex "$*RETURN_USED", $P179
    find_lex $P182, "$*PACKAGE-SETUP"
    unless_null $P182, vivify_617
    get_hll_global $P180, "GLOBAL"
    get_who $P181, $P180
    set $P182, $P181["$PACKAGE-SETUP"]
    unless_null $P182, vivify_618
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_618:
  vivify_617:
.annotate 'line', 40
    find_lex $P183, "self"
    $P184 = $P183."comp_unit"()
.annotate 'line', 10
    .return ($P184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx186_tgt
    .local int rx186_pos
    .local int rx186_off
    .local int rx186_eos
    .local int rx186_rep
    .local pmc rx186_cur
    .local pmc rx186_debug
    (rx186_cur, rx186_pos, rx186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx186_cur
    .local pmc match
    .lex "$/", match
    length rx186_eos, rx186_tgt
    gt rx186_pos, rx186_eos, rx186_done
    set rx186_off, 0
    lt rx186_pos, 2, rx186_start
    sub rx186_off, rx186_pos, 1
    substr rx186_tgt, rx186_tgt, rx186_off
  rx186_start:
    eq $I10, 1, rx186_restart
    if_null rx186_debug, debug_619
    rx186_cur."!cursor_debug"("START", "identifier")
  debug_619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx186_pos) = rx186_cur."from"()
    inc rx186_pos
    rx186_cur."!cursor_from"(rx186_pos)
    ge rx186_pos, rx186_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx186_cur."!mark_push"(0, rx186_pos, $I10)
  rxscan190_done:
.annotate 'line', 45
  # rx subrule "ident" subtype=method negate=
    rx186_cur."!cursor_pos"(rx186_pos)
    $P10 = rx186_cur."ident"()
    unless $P10, rx186_fail
    rx186_pos = $P10."pos"()
  # rx rxquantr191 ** 0..*
    set_addr $I10, rxquantr191_done
    rx186_cur."!mark_push"(0, rx186_pos, $I10)
  rxquantr191_loop:
  # rx enumcharlist negate=0 
    ge rx186_pos, rx186_eos, rx186_fail
    sub $I10, rx186_pos, rx186_off
    substr $S10, rx186_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx186_fail
    inc rx186_pos
  # rx subrule "ident" subtype=method negate=
    rx186_cur."!cursor_pos"(rx186_pos)
    $P10 = rx186_cur."ident"()
    unless $P10, rx186_fail
    rx186_pos = $P10."pos"()
    set_addr $I10, rxquantr191_done
    (rx186_rep) = rx186_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr191_done
    rx186_cur."!mark_push"(rx186_rep, rx186_pos, $I10)
    goto rxquantr191_loop
  rxquantr191_done:
  # rx pass
    rx186_cur."!cursor_pass"(rx186_pos, "identifier")
    if_null rx186_debug, debug_620
    rx186_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx186_pos)
  debug_620:
    .return (rx186_cur)
  rx186_restart:
.annotate 'line', 10
    if_null rx186_debug, debug_621
    rx186_cur."!cursor_debug"("NEXT", "identifier")
  debug_621:
  rx186_fail:
    (rx186_rep, rx186_pos, $I10, $P10) = rx186_cur."!mark_fail"(0)
    lt rx186_pos, -1, rx186_done
    eq rx186_pos, -1, rx186_fail
    jump $I10
  rx186_done:
    rx186_cur."!cursor_fail"()
    if_null rx186_debug, debug_622
    rx186_cur."!cursor_debug"("FAIL", "identifier")
  debug_622:
    .return (rx186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303857440.612") :method
.annotate 'line', 10
    $P188 = self."!PREFIX__!subrule"("ident", "")
    new $P189, "ResizablePMCArray"
    push $P189, $P188
    .return ($P189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx193_tgt
    .local int rx193_pos
    .local int rx193_off
    .local int rx193_eos
    .local int rx193_rep
    .local pmc rx193_cur
    .local pmc rx193_debug
    (rx193_cur, rx193_pos, rx193_tgt, $I10) = self."!cursor_start"()
    rx193_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx193_cur
    .local pmc match
    .lex "$/", match
    length rx193_eos, rx193_tgt
    gt rx193_pos, rx193_eos, rx193_done
    set rx193_off, 0
    lt rx193_pos, 2, rx193_start
    sub rx193_off, rx193_pos, 1
    substr rx193_tgt, rx193_tgt, rx193_off
  rx193_start:
    eq $I10, 1, rx193_restart
    if_null rx193_debug, debug_623
    rx193_cur."!cursor_debug"("START", "name")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan196_done
    goto rxscan196_scan
  rxscan196_loop:
    (rx193_pos) = rx193_cur."from"()
    inc rx193_pos
    rx193_cur."!cursor_from"(rx193_pos)
    ge rx193_pos, rx193_eos, rxscan196_done
  rxscan196_scan:
    set_addr $I10, rxscan196_loop
    rx193_cur."!mark_push"(0, rx193_pos, $I10)
  rxscan196_done:
.annotate 'line', 47
  # rx rxquantr197 ** 1..*
    set_addr $I10, rxquantr197_done
    rx193_cur."!mark_push"(0, -1, $I10)
  rxquantr197_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx193_cur."!cursor_pos"(rx193_pos)
    $P10 = rx193_cur."identifier"()
    unless $P10, rx193_fail
    goto rxsubrule198_pass
  rxsubrule198_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx193_fail
  rxsubrule198_pass:
    set_addr $I10, rxsubrule198_back
    rx193_cur."!mark_push"(0, rx193_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx193_pos = $P10."pos"()
    set_addr $I10, rxquantr197_done
    (rx193_rep) = rx193_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr197_done
    rx193_cur."!mark_push"(rx193_rep, rx193_pos, $I10)
  # rx literal  "::"
    add $I11, rx193_pos, 2
    gt $I11, rx193_eos, rx193_fail
    sub $I11, rx193_pos, rx193_off
    substr $S10, rx193_tgt, $I11, 2
    ne $S10, "::", rx193_fail
    add rx193_pos, 2
    goto rxquantr197_loop
  rxquantr197_done:
  # rx pass
    rx193_cur."!cursor_pass"(rx193_pos, "name")
    if_null rx193_debug, debug_624
    rx193_cur."!cursor_debug"("PASS", "name", " at pos=", rx193_pos)
  debug_624:
    .return (rx193_cur)
  rx193_restart:
.annotate 'line', 10
    if_null rx193_debug, debug_625
    rx193_cur."!cursor_debug"("NEXT", "name")
  debug_625:
  rx193_fail:
    (rx193_rep, rx193_pos, $I10, $P10) = rx193_cur."!mark_fail"(0)
    lt rx193_pos, -1, rx193_done
    eq rx193_pos, -1, rx193_fail
    jump $I10
  rx193_done:
    rx193_cur."!cursor_fail"()
    if_null rx193_debug, debug_626
    rx193_cur."!cursor_debug"("FAIL", "name")
  debug_626:
    .return (rx193_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303857440.612") :method
.annotate 'line', 10
    new $P195, "ResizablePMCArray"
    push $P195, ""
    .return ($P195)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    rx200_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_627
    rx200_cur."!cursor_debug"("START", "deflongname")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan204_done
    goto rxscan204_scan
  rxscan204_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan204_done
  rxscan204_scan:
    set_addr $I10, rxscan204_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan204_done:
.annotate 'line', 50
  # rx subrule "identifier" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."identifier"()
    unless $P10, rx200_fail
    rx200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx200_pos = $P10."pos"()
  # rx rxquantr205 ** 0..1
    set_addr $I10, rxquantr205_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr205_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."colonpair"()
    unless $P10, rx200_fail
    goto rxsubrule206_pass
  rxsubrule206_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx200_fail
  rxsubrule206_pass:
    set_addr $I10, rxsubrule206_back
    rx200_cur."!mark_push"(0, rx200_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx200_pos = $P10."pos"()
    set_addr $I10, rxquantr205_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr205_done:
.annotate 'line', 49
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "deflongname")
    if_null rx200_debug, debug_628
    rx200_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx200_pos)
  debug_628:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 10
    if_null rx200_debug, debug_629
    rx200_cur."!cursor_debug"("NEXT", "deflongname")
  debug_629:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_630
    rx200_cur."!cursor_debug"("FAIL", "deflongname")
  debug_630:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303857440.612") :method
.annotate 'line', 10
    $P202 = self."!PREFIX__!subrule"("identifier", "")
    new $P203, "ResizablePMCArray"
    push $P203, $P202
    .return ($P203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx208_tgt
    .local int rx208_pos
    .local int rx208_off
    .local int rx208_eos
    .local int rx208_rep
    .local pmc rx208_cur
    .local pmc rx208_debug
    (rx208_cur, rx208_pos, rx208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx208_cur
    .local pmc match
    .lex "$/", match
    length rx208_eos, rx208_tgt
    gt rx208_pos, rx208_eos, rx208_done
    set rx208_off, 0
    lt rx208_pos, 2, rx208_start
    sub rx208_off, rx208_pos, 1
    substr rx208_tgt, rx208_tgt, rx208_off
  rx208_start:
    eq $I10, 1, rx208_restart
    if_null rx208_debug, debug_631
    rx208_cur."!cursor_debug"("START", "ENDSTMT")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan211_done
    goto rxscan211_scan
  rxscan211_loop:
    (rx208_pos) = rx208_cur."from"()
    inc rx208_pos
    rx208_cur."!cursor_from"(rx208_pos)
    ge rx208_pos, rx208_eos, rxscan211_done
  rxscan211_scan:
    set_addr $I10, rxscan211_loop
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxscan211_done:
.annotate 'line', 57
  # rx rxquantr212 ** 0..1
    set_addr $I10, rxquantr212_done
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxquantr212_loop:
  alt213_0:
.annotate 'line', 54
    set_addr $I10, alt213_1
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
.annotate 'line', 55
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx208_pos, rx208_off
    set rx208_rep, 0
    sub $I12, rx208_eos, rx208_pos
  rxenumcharlistq214_loop:
    le $I12, 0, rxenumcharlistq214_done
    substr $S10, rx208_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq214_done
    inc rx208_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq214_loop
  rxenumcharlistq214_done:
    add rx208_pos, rx208_pos, rx208_rep
  # rxanchor eol
    sub $I10, rx208_pos, rx208_off
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rxanchor215_done
    ne rx208_pos, rx208_eos, rx208_fail
    eq rx208_pos, 0, rxanchor215_done
    dec $I10
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rx208_fail
  rxanchor215_done:
  # rx subrule "ws" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."ws"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."MARKER"("endstmt")
    unless $P10, rx208_fail
    goto alt213_end
  alt213_1:
.annotate 'line', 56
  # rx rxquantr216 ** 0..1
    set_addr $I10, rxquantr216_done
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxquantr216_loop:
  # rx subrule "unv" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."unv"()
    unless $P10, rx208_fail
    goto rxsubrule217_pass
  rxsubrule217_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx208_fail
  rxsubrule217_pass:
    set_addr $I10, rxsubrule217_back
    rx208_cur."!mark_push"(0, rx208_pos, $I10, $P10)
    rx208_pos = $P10."pos"()
    set_addr $I10, rxquantr216_done
    (rx208_rep) = rx208_cur."!mark_commit"($I10)
  rxquantr216_done:
  # rxanchor eol
    sub $I10, rx208_pos, rx208_off
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rxanchor218_done
    ne rx208_pos, rx208_eos, rx208_fail
    eq rx208_pos, 0, rxanchor218_done
    dec $I10
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rx208_fail
  rxanchor218_done:
  # rx subrule "ws" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."ws"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."MARKER"("endstmt")
    unless $P10, rx208_fail
  alt213_end:
.annotate 'line', 57
    set_addr $I10, rxquantr212_done
    (rx208_rep) = rx208_cur."!mark_commit"($I10)
  rxquantr212_done:
.annotate 'line', 53
  # rx pass
    rx208_cur."!cursor_pass"(rx208_pos, "ENDSTMT")
    if_null rx208_debug, debug_632
    rx208_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx208_pos)
  debug_632:
    .return (rx208_cur)
  rx208_restart:
.annotate 'line', 10
    if_null rx208_debug, debug_633
    rx208_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_633:
  rx208_fail:
    (rx208_rep, rx208_pos, $I10, $P10) = rx208_cur."!mark_fail"(0)
    lt rx208_pos, -1, rx208_done
    eq rx208_pos, -1, rx208_fail
    jump $I10
  rx208_done:
    rx208_cur."!cursor_fail"()
    if_null rx208_debug, debug_634
    rx208_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_634:
    .return (rx208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303857440.612") :method
.annotate 'line', 10
    new $P210, "ResizablePMCArray"
    push $P210, ""
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_635
    rx220_cur."!cursor_debug"("START", "ws")
  debug_635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 60
    set_addr $I10, alt224_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 61
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."MARKED"("ws")
    unless $P10, rx220_fail
    goto alt224_end
  alt224_1:
.annotate 'line', 62
  # rx subrule "ww" subtype=zerowidth negate=1
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ww"()
    if $P10, rx220_fail
.annotate 'line', 67
  # rx rxquantr225 ** 0..*
    set_addr $I10, rxquantr225_done
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxquantr225_loop:
  alt226_0:
.annotate 'line', 63
    set_addr $I10, alt226_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx220_pos, rx220_off
    set rx220_rep, 0
    sub $I12, rx220_eos, rx220_pos
  rxenumcharlistq227_loop:
    le $I12, 0, rxenumcharlistq227_done
    substr $S10, rx220_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq227_done
    inc rx220_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq227_loop
  rxenumcharlistq227_done:
    lt rx220_rep, 1, rx220_fail
    add rx220_pos, rx220_pos, rx220_rep
    goto alt226_end
  alt226_1:
    set_addr $I10, alt226_2
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 64
  # rx literal  "#"
    add $I11, rx220_pos, 1
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    ord $I11, rx220_tgt, $I11
    ne $I11, 35, rx220_fail
    add rx220_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx220_pos, rx220_off
    find_cclass $I11, 4096, rx220_tgt, $I10, rx220_eos
    add rx220_pos, rx220_off, $I11
    goto alt226_end
  alt226_2:
    set_addr $I10, alt226_3
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 65
  # rxanchor bol
    eq rx220_pos, 0, rxanchor228_done
    ge rx220_pos, rx220_eos, rx220_fail
    sub $I10, rx220_pos, rx220_off
    dec $I10
    is_cclass $I11, 4096, rx220_tgt, $I10
    unless $I11, rx220_fail
  rxanchor228_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."pod_comment"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
    goto alt226_end
  alt226_3:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx220_pos, rx220_off
    set rx220_rep, 0
    sub $I12, rx220_eos, rx220_pos
  rxenumcharlistq229_loop:
    le $I12, 0, rxenumcharlistq229_done
    substr $S10, rx220_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq229_done
    inc rx220_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq229_loop
  rxenumcharlistq229_done:
    lt rx220_rep, 1, rx220_fail
    add rx220_pos, rx220_pos, rx220_rep
  alt226_end:
.annotate 'line', 67
    set_addr $I10, rxquantr225_done
    (rx220_rep) = rx220_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr225_done
    rx220_cur."!mark_push"(rx220_rep, rx220_pos, $I10)
    goto rxquantr225_loop
  rxquantr225_done:
.annotate 'line', 68
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."MARKER"("ws")
    unless $P10, rx220_fail
  alt224_end:
.annotate 'line', 60
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "ws")
    if_null rx220_debug, debug_636
    rx220_cur."!cursor_debug"("PASS", "ws", " at pos=", rx220_pos)
  debug_636:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 10
    if_null rx220_debug, debug_637
    rx220_cur."!cursor_debug"("NEXT", "ws")
  debug_637:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_638
    rx220_cur."!cursor_debug"("FAIL", "ws")
  debug_638:
    .return (rx220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303857440.612") :method
.annotate 'line', 10
    new $P222, "ResizablePMCArray"
    push $P222, ""
    push $P222, ""
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P238 = "26_1303857440.612" 
    capture_lex $P238
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_639
    rx231_cur."!cursor_debug"("START", "unv")
  debug_639:
    $I10 = self.'from'()
    ne $I10, -1, rxscan234_done
    goto rxscan234_scan
  rxscan234_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan234_done
  rxscan234_scan:
    set_addr $I10, rxscan234_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan234_done:
  alt235_0:
.annotate 'line', 73
    set_addr $I10, alt235_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 74
  # rxanchor bol
    eq rx231_pos, 0, rxanchor236_done
    ge rx231_pos, rx231_eos, rx231_fail
    sub $I10, rx231_pos, rx231_off
    dec $I10
    is_cclass $I11, 4096, rx231_tgt, $I10
    unless $I11, rx231_fail
  rxanchor236_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    .const 'Sub' $P238 = "26_1303857440.612" 
    capture_lex $P238
    $P10 = rx231_cur."before"($P238)
    unless $P10, rx231_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."pod_comment"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
    goto alt235_end
  alt235_1:
    set_addr $I10, alt235_2
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 75
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx231_pos, rx231_off
    set rx231_rep, 0
    sub $I12, rx231_eos, rx231_pos
  rxenumcharlistq243_loop:
    le $I12, 0, rxenumcharlistq243_done
    substr $S10, rx231_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq243_done
    inc rx231_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq243_loop
  rxenumcharlistq243_done:
    add rx231_pos, rx231_pos, rx231_rep
  # rx literal  "#"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 35, rx231_fail
    add rx231_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx231_pos, rx231_off
    find_cclass $I11, 4096, rx231_tgt, $I10, rx231_eos
    add rx231_pos, rx231_off, $I11
    goto alt235_end
  alt235_2:
.annotate 'line', 76
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx231_pos, rx231_off
    set rx231_rep, 0
    sub $I12, rx231_eos, rx231_pos
  rxenumcharlistq244_loop:
    le $I12, 0, rxenumcharlistq244_done
    substr $S10, rx231_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq244_done
    inc rx231_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq244_loop
  rxenumcharlistq244_done:
    lt rx231_rep, 1, rx231_fail
    add rx231_pos, rx231_pos, rx231_rep
  alt235_end:
.annotate 'line', 71
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "unv")
    if_null rx231_debug, debug_644
    rx231_cur."!cursor_debug"("PASS", "unv", " at pos=", rx231_pos)
  debug_644:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 10
    if_null rx231_debug, debug_645
    rx231_cur."!cursor_debug"("NEXT", "unv")
  debug_645:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_646
    rx231_cur."!cursor_debug"("FAIL", "unv")
  debug_646:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303857440.612") :method
.annotate 'line', 10
    new $P233, "ResizablePMCArray"
    push $P233, ""
    push $P233, ""
    push $P233, ""
    .return ($P233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block237"  :anon :subid("26_1303857440.612") :method :outer("24_1303857440.612")
.annotate 'line', 74
    .local string rx239_tgt
    .local int rx239_pos
    .local int rx239_off
    .local int rx239_eos
    .local int rx239_rep
    .local pmc rx239_cur
    .local pmc rx239_debug
    (rx239_cur, rx239_pos, rx239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx239_cur
    .local pmc match
    .lex "$/", match
    length rx239_eos, rx239_tgt
    gt rx239_pos, rx239_eos, rx239_done
    set rx239_off, 0
    lt rx239_pos, 2, rx239_start
    sub rx239_off, rx239_pos, 1
    substr rx239_tgt, rx239_tgt, rx239_off
  rx239_start:
    eq $I10, 1, rx239_restart
    if_null rx239_debug, debug_640
    rx239_cur."!cursor_debug"("START", "")
  debug_640:
    $I10 = self.'from'()
    ne $I10, -1, rxscan240_done
    goto rxscan240_scan
  rxscan240_loop:
    (rx239_pos) = rx239_cur."from"()
    inc rx239_pos
    rx239_cur."!cursor_from"(rx239_pos)
    ge rx239_pos, rx239_eos, rxscan240_done
  rxscan240_scan:
    set_addr $I10, rxscan240_loop
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  rxscan240_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx239_pos, rx239_off
    set rx239_rep, 0
    sub $I12, rx239_eos, rx239_pos
  rxenumcharlistq241_loop:
    le $I12, 0, rxenumcharlistq241_done
    substr $S10, rx239_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq241_done
    inc rx239_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq241_loop
  rxenumcharlistq241_done:
    add rx239_pos, rx239_pos, rx239_rep
  # rx literal  "="
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 61, rx239_fail
    add rx239_pos, 1
  alt242_0:
    set_addr $I10, alt242_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  # rx charclass w
    ge rx239_pos, rx239_eos, rx239_fail
    sub $I10, rx239_pos, rx239_off
    is_cclass $I11, 8192, rx239_tgt, $I10
    unless $I11, rx239_fail
    inc rx239_pos
    goto alt242_end
  alt242_1:
  # rx literal  "\\"
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 92, rx239_fail
    add rx239_pos, 1
  alt242_end:
  # rx pass
    rx239_cur."!cursor_pass"(rx239_pos, "")
    if_null rx239_debug, debug_641
    rx239_cur."!cursor_debug"("PASS", "", " at pos=", rx239_pos)
  debug_641:
    .return (rx239_cur)
  rx239_restart:
    if_null rx239_debug, debug_642
    rx239_cur."!cursor_debug"("NEXT", "")
  debug_642:
  rx239_fail:
    (rx239_rep, rx239_pos, $I10, $P10) = rx239_cur."!mark_fail"(0)
    lt rx239_pos, -1, rx239_done
    eq rx239_pos, -1, rx239_fail
    jump $I10
  rx239_done:
    rx239_cur."!cursor_fail"()
    if_null rx239_debug, debug_643
    rx239_cur."!cursor_debug"("FAIL", "")
  debug_643:
    .return (rx239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P277 = "29_1303857440.612" 
    capture_lex $P277
    .local string rx246_tgt
    .local int rx246_pos
    .local int rx246_off
    .local int rx246_eos
    .local int rx246_rep
    .local pmc rx246_cur
    .local pmc rx246_debug
    (rx246_cur, rx246_pos, rx246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx246_cur
    .local pmc match
    .lex "$/", match
    length rx246_eos, rx246_tgt
    gt rx246_pos, rx246_eos, rx246_done
    set rx246_off, 0
    lt rx246_pos, 2, rx246_start
    sub rx246_off, rx246_pos, 1
    substr rx246_tgt, rx246_tgt, rx246_off
  rx246_start:
    eq $I10, 1, rx246_restart
    if_null rx246_debug, debug_647
    rx246_cur."!cursor_debug"("START", "pod_comment")
  debug_647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan249_done
    goto rxscan249_scan
  rxscan249_loop:
    (rx246_pos) = rx246_cur."from"()
    inc rx246_pos
    rx246_cur."!cursor_from"(rx246_pos)
    ge rx246_pos, rx246_eos, rxscan249_done
  rxscan249_scan:
    set_addr $I10, rxscan249_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  rxscan249_done:
.annotate 'line', 81
  # rxanchor bol
    eq rx246_pos, 0, rxanchor250_done
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
  rxanchor250_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq251_loop:
    le $I12, 0, rxenumcharlistq251_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq251_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq251_loop
  rxenumcharlistq251_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "="
    add $I11, rx246_pos, 1
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    ord $I11, rx246_tgt, $I11
    ne $I11, 61, rx246_fail
    add rx246_pos, 1
  alt252_0:
.annotate 'line', 82
    set_addr $I10, alt252_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 83
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "END"
    add $I11, rx246_pos, 3
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 3
    ne $S10, "END", rx246_fail
    add rx246_pos, 3
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  alt254_0:
.annotate 'line', 84
    set_addr $I10, alt254_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx rxquantf255 ** 0..*
    set_addr $I10, rxquantf255_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf255_done
  rxquantf255_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf255_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf255_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq257_loop:
    le $I12, 0, rxenumcharlistq257_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq257_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq257_loop
  rxenumcharlistq257_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq258_loop:
    le $I12, 0, rxenumcharlistq258_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq258_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq258_loop
  rxenumcharlistq258_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "END"
    add $I11, rx246_pos, 3
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 3
    ne $S10, "END", rx246_fail
    add rx246_pos, 3
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt254_end
  alt254_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_not_cclass $I11, 65535, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
  alt254_end:
.annotate 'line', 83
    goto alt252_end
  alt252_1:
    set_addr $I10, alt252_2
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 85
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq259_loop:
    le $I12, 0, rxenumcharlistq259_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq259_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq259_loop
  rxenumcharlistq259_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx subrule "identifier" subtype=capture negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."identifier"()
    unless $P10, rx246_fail
    rx246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx246_pos = $P10."pos"()
  alt260_0:
.annotate 'line', 86
    set_addr $I10, alt260_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 87
  # rx rxquantf261 ** 0..*
    set_addr $I10, rxquantf261_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf261_done
  rxquantf261_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf261_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf261_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq263_loop:
    le $I12, 0, rxenumcharlistq263_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq263_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq263_loop
  rxenumcharlistq263_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq264_loop:
    le $I12, 0, rxenumcharlistq264_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq264_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq264_loop
  rxenumcharlistq264_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."!BACKREF"("identifier")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt260_end
  alt260_1:
.annotate 'line', 88
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("=begin without matching =end")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt260_end:
.annotate 'line', 85
    goto alt252_end
  alt252_2:
    set_addr $I10, alt252_3
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 90
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq266_loop:
    le $I12, 0, rxenumcharlistq266_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq266_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq266_loop
  rxenumcharlistq266_done:
    add rx246_pos, rx246_pos, rx246_rep
  alt267_0:
.annotate 'line', 91
    set_addr $I10, alt267_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rxanchor eol
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    if $I11, rxanchor268_done
    ne rx246_pos, rx246_eos, rx246_fail
    eq rx246_pos, 0, rxanchor268_done
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    if $I11, rx246_fail
  rxanchor268_done:
    goto alt267_end
  alt267_1:
    set_addr $I10, alt267_2
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx literal  "#"
    add $I11, rx246_pos, 1
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    ord $I11, rx246_tgt, $I11
    ne $I11, 35, rx246_fail
    add rx246_pos, 1
    goto alt267_end
  alt267_2:
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt267_end:
  alt269_0:
.annotate 'line', 92
    set_addr $I10, alt269_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 93
  # rx rxquantf270 ** 0..*
    set_addr $I10, rxquantf270_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf270_done
  rxquantf270_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf270_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf270_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq272_loop:
    le $I12, 0, rxenumcharlistq272_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq272_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq272_loop
  rxenumcharlistq272_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt269_end
  alt269_1:
.annotate 'line', 94
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("=begin without matching =end")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt269_end:
.annotate 'line', 90
    goto alt252_end
  alt252_3:
    set_addr $I10, alt252_4
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 96
  # rx subrule "identifier" subtype=capture negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."identifier"()
    unless $P10, rx246_fail
    rx246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx246_pos = $P10."pos"()
.annotate 'line', 97
  # rx rxquantf273 ** 0..*
    set_addr $I10, rxquantf273_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf273_done
  rxquantf273_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf273_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf273_done:
  # rxanchor bol
    eq rx246_pos, 0, rxanchor275_done
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
  rxanchor275_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    .const 'Sub' $P277 = "29_1303857440.612" 
    capture_lex $P277
    $P10 = rx246_cur."before"($P277)
    unless $P10, rx246_fail
.annotate 'line', 96
    goto alt252_end
  alt252_4:
  alt283_0:
.annotate 'line', 103
    set_addr $I10, alt283_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx charclass s
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 32, rx246_tgt, $I10
    unless $I11, rx246_fail
    inc rx246_pos
    goto alt283_end
  alt283_1:
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("Illegal pod directive")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt283_end:
.annotate 'line', 104
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
  alt252_end:
.annotate 'line', 80
  # rx pass
    rx246_cur."!cursor_pass"(rx246_pos, "pod_comment")
    if_null rx246_debug, debug_652
    rx246_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx246_pos)
  debug_652:
    .return (rx246_cur)
  rx246_restart:
.annotate 'line', 10
    if_null rx246_debug, debug_653
    rx246_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_653:
  rx246_fail:
    (rx246_rep, rx246_pos, $I10, $P10) = rx246_cur."!mark_fail"(0)
    lt rx246_pos, -1, rx246_done
    eq rx246_pos, -1, rx246_fail
    jump $I10
  rx246_done:
    rx246_cur."!cursor_fail"()
    if_null rx246_debug, debug_654
    rx246_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_654:
    .return (rx246_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303857440.612") :method
.annotate 'line', 10
    new $P248, "ResizablePMCArray"
    push $P248, ""
    .return ($P248)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block276"  :anon :subid("29_1303857440.612") :method :outer("27_1303857440.612")
.annotate 'line', 97
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_648
    rx278_cur."!cursor_debug"("START", "")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan279_done
    goto rxscan279_scan
  rxscan279_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan279_done
  rxscan279_scan:
    set_addr $I10, rxscan279_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan279_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx278_pos, rx278_off
    set rx278_rep, 0
    sub $I12, rx278_eos, rx278_pos
  rxenumcharlistq280_loop:
    le $I12, 0, rxenumcharlistq280_done
    substr $S10, rx278_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq280_done
    inc rx278_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq280_loop
  rxenumcharlistq280_done:
    add rx278_pos, rx278_pos, rx278_rep
  alt281_0:
    set_addr $I10, alt281_1
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
.annotate 'line', 98
  # rx literal  "="
    add $I11, rx278_pos, 1
    gt $I11, rx278_eos, rx278_fail
    sub $I11, rx278_pos, rx278_off
    ord $I11, rx278_tgt, $I11
    ne $I11, 61, rx278_fail
    add rx278_pos, 1
.annotate 'line', 100
  # rx rxquantr282 ** 0..1
    set_addr $I10, rxquantr282_done
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxquantr282_loop:
.annotate 'line', 99
  # rx literal  "cut"
    add $I11, rx278_pos, 3
    gt $I11, rx278_eos, rx278_fail
    sub $I11, rx278_pos, rx278_off
    substr $S10, rx278_tgt, $I11, 3
    ne $S10, "cut", rx278_fail
    add rx278_pos, 3
  # rxanchor rwb
    le rx278_pos, 0, rx278_fail
    sub $I10, rx278_pos, rx278_off
    is_cclass $I11, 8192, rx278_tgt, $I10
    if $I11, rx278_fail
    dec $I10
    is_cclass $I11, 8192, rx278_tgt, $I10
    unless $I11, rx278_fail
.annotate 'line', 100
  # rx subrule "panic" subtype=method negate=
    rx278_cur."!cursor_pos"(rx278_pos)
    $P10 = rx278_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx278_fail
    rx278_pos = $P10."pos"()
    set_addr $I10, rxquantr282_done
    (rx278_rep) = rx278_cur."!mark_commit"($I10)
  rxquantr282_done:
.annotate 'line', 97
    goto alt281_end
  alt281_1:
.annotate 'line', 101
  # rx charclass nl
    ge rx278_pos, rx278_eos, rx278_fail
    sub $I10, rx278_pos, rx278_off
    is_cclass $I11, 4096, rx278_tgt, $I10
    unless $I11, rx278_fail
    substr $S10, rx278_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx278_pos, $I11
    inc rx278_pos
  alt281_end:
.annotate 'line', 97
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "")
    if_null rx278_debug, debug_649
    rx278_cur."!cursor_debug"("PASS", "", " at pos=", rx278_pos)
  debug_649:
    .return (rx278_cur)
  rx278_restart:
    if_null rx278_debug, debug_650
    rx278_cur."!cursor_debug"("NEXT", "")
  debug_650:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_651
    rx278_cur."!cursor_debug"("FAIL", "")
  debug_651:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 112
    new $P285, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P285
.annotate 'line', 113
    new $P286, "Undef"
    .lex "$*MAIN_SUB", $P286
.annotate 'line', 116
    new $P287, "Undef"
    .lex "$*PACKAGE", $P287
.annotate 'line', 117
    new $P288, "Undef"
    .lex "$*GLOBALish", $P288
.annotate 'line', 10
    .local string rx289_tgt
    .local int rx289_pos
    .local int rx289_off
    .local int rx289_eos
    .local int rx289_rep
    .local pmc rx289_cur
    .local pmc rx289_debug
    (rx289_cur, rx289_pos, rx289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx289_cur
    .local pmc match
    .lex "$/", match
    length rx289_eos, rx289_tgt
    gt rx289_pos, rx289_eos, rx289_done
    set rx289_off, 0
    lt rx289_pos, 2, rx289_start
    sub rx289_off, rx289_pos, 1
    substr rx289_tgt, rx289_tgt, rx289_off
  rx289_start:
    eq $I10, 1, rx289_restart
    if_null rx289_debug, debug_655
    rx289_cur."!cursor_debug"("START", "comp_unit")
  debug_655:
    $I10 = self.'from'()
    ne $I10, -1, rxscan293_done
    goto rxscan293_scan
  rxscan293_loop:
    (rx289_pos) = rx289_cur."from"()
    inc rx289_pos
    rx289_cur."!cursor_from"(rx289_pos)
    ge rx289_pos, rx289_eos, rxscan293_done
  rxscan293_scan:
    set_addr $I10, rxscan293_loop
    rx289_cur."!mark_push"(0, rx289_pos, $I10)
  rxscan293_done:
.annotate 'line', 112
    rx289_cur."!cursor_pos"(rx289_pos)
    new $P294, "Integer"
    assign $P294, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P294
.annotate 'line', 113
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P297, "$*MAIN_SUB"
    unless_null $P297, vivify_656
    get_hll_global $P295, "GLOBAL"
    get_who $P296, $P295
    set $P297, $P296["$MAIN_SUB"]
    unless_null $P297, vivify_657
    die "Contextual $*MAIN_SUB not found"
  vivify_657:
  vivify_656:
.annotate 'line', 114
  # rx subrule "newpad" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."newpad"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 116
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P300, "$*PACKAGE"
    unless_null $P300, vivify_658
    get_hll_global $P298, "GLOBAL"
    get_who $P299, $P298
    set $P300, $P299["$PACKAGE"]
    unless_null $P300, vivify_659
    die "Contextual $*PACKAGE not found"
  vivify_659:
  vivify_658:
.annotate 'line', 117
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P303, "$*GLOBALish"
    unless_null $P303, vivify_660
    get_hll_global $P301, "GLOBAL"
    get_who $P302, $P301
    set $P303, $P302["$GLOBALish"]
    unless_null $P303, vivify_661
    die "Contextual $*GLOBALish not found"
  vivify_661:
  vivify_660:
.annotate 'line', 118
  # rx subrule "GLOBALish" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."GLOBALish"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 120
  # rx subrule "outerctx" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."outerctx"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 122
  # rx subrule "statementlist" subtype=capture negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."statementlist"()
    unless $P10, rx289_fail
    rx289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx289_pos = $P10."pos"()
  alt304_0:
.annotate 'line', 123
    set_addr $I10, alt304_1
    rx289_cur."!mark_push"(0, rx289_pos, $I10)
  # rxanchor eos
    ne rx289_pos, rx289_eos, rx289_fail
    goto alt304_end
  alt304_1:
  # rx subrule "panic" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."panic"("Confused")
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
  alt304_end:
.annotate 'line', 111
  # rx pass
    rx289_cur."!cursor_pass"(rx289_pos, "comp_unit")
    if_null rx289_debug, debug_662
    rx289_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx289_pos)
  debug_662:
    .return (rx289_cur)
  rx289_restart:
.annotate 'line', 10
    if_null rx289_debug, debug_663
    rx289_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_663:
  rx289_fail:
    (rx289_rep, rx289_pos, $I10, $P10) = rx289_cur."!mark_fail"(0)
    lt rx289_pos, -1, rx289_done
    eq rx289_pos, -1, rx289_fail
    jump $I10
  rx289_done:
    rx289_cur."!cursor_fail"()
    if_null rx289_debug, debug_664
    rx289_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_664:
    .return (rx289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303857440.612") :method
.annotate 'line', 10
    $P291 = self."!PREFIX__!subrule"("newpad", "")
    new $P292, "ResizablePMCArray"
    push $P292, $P291
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    rx306_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_665
    rx306_cur."!cursor_debug"("START", "statementlist")
  debug_665:
    $I10 = self.'from'()
    ne $I10, -1, rxscan311_done
    goto rxscan311_scan
  rxscan311_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan311_done
  rxscan311_scan:
    set_addr $I10, rxscan311_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan311_done:
  alt312_0:
.annotate 'line', 126
    set_addr $I10, alt312_1
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rxanchor eos
    ne rx306_pos, rx306_eos, rx306_fail
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
    goto alt312_end
  alt312_1:
.annotate 'line', 128
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rx rxquantr316 ** 0..*
    set_addr $I10, rxquantr316_done
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxquantr316_loop:
  # rx subrule "statement" subtype=capture negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."statement"()
    unless $P10, rx306_fail
    rx306_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx306_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."eat_terminator"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
    set_addr $I10, rxquantr316_done
    (rx306_rep) = rx306_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr316_done
    rx306_cur."!mark_push"(rx306_rep, rx306_pos, $I10)
    goto rxquantr316_loop
  rxquantr316_done:
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  alt312_end:
.annotate 'line', 126
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "statementlist")
    if_null rx306_debug, debug_666
    rx306_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx306_pos)
  debug_666:
    .return (rx306_cur)
  rx306_restart:
.annotate 'line', 10
    if_null rx306_debug, debug_667
    rx306_cur."!cursor_debug"("NEXT", "statementlist")
  debug_667:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_668
    rx306_cur."!cursor_debug"("FAIL", "statementlist")
  debug_668:
    .return (rx306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303857440.612") :method
.annotate 'line', 10
    $P308 = self."!PREFIX__!subrule"("ws", "")
    $P309 = self."!PREFIX__!subrule"("ws", "")
    new $P310, "ResizablePMCArray"
    push $P310, $P308
    push $P310, $P309
    .return ($P310)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P325 = "36_1303857440.612" 
    capture_lex $P325
    .local string rx320_tgt
    .local int rx320_pos
    .local int rx320_off
    .local int rx320_eos
    .local int rx320_rep
    .local pmc rx320_cur
    .local pmc rx320_debug
    (rx320_cur, rx320_pos, rx320_tgt, $I10) = self."!cursor_start"()
    rx320_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx320_cur
    .local pmc match
    .lex "$/", match
    length rx320_eos, rx320_tgt
    gt rx320_pos, rx320_eos, rx320_done
    set rx320_off, 0
    lt rx320_pos, 2, rx320_start
    sub rx320_off, rx320_pos, 1
    substr rx320_tgt, rx320_tgt, rx320_off
  rx320_start:
    eq $I10, 1, rx320_restart
    if_null rx320_debug, debug_669
    rx320_cur."!cursor_debug"("START", "statement")
  debug_669:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx320_pos) = rx320_cur."from"()
    inc rx320_pos
    rx320_cur."!cursor_from"(rx320_pos)
    ge rx320_pos, rx320_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxscan323_done:
.annotate 'line', 132
  # rx subrule "before" subtype=zerowidth negate=1
    rx320_cur."!cursor_pos"(rx320_pos)
    .const 'Sub' $P325 = "36_1303857440.612" 
    capture_lex $P325
    $P10 = rx320_cur."before"($P325)
    if $P10, rx320_fail
  alt329_0:
.annotate 'line', 133
    set_addr $I10, alt329_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 134
  # rx subrule "statement_control" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_control"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx320_pos = $P10."pos"()
    goto alt329_end
  alt329_1:
.annotate 'line', 135
  # rx subrule "EXPR" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."EXPR"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
.annotate 'line', 140
  # rx rxquantr330 ** 0..1
    set_addr $I10, rxquantr330_done
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxquantr330_loop:
  alt331_0:
.annotate 'line', 136
    set_addr $I10, alt331_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 137
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."MARKED"("endstmt")
    unless $P10, rx320_fail
    goto alt331_end
  alt331_1:
    set_addr $I10, alt331_2
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 138
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_cond"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx320_pos = $P10."pos"()
  # rx rxquantr332 ** 0..1
    set_addr $I10, rxquantr332_done
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxquantr332_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_loop"()
    unless $P10, rx320_fail
    goto rxsubrule333_pass
  rxsubrule333_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx320_fail
  rxsubrule333_pass:
    set_addr $I10, rxsubrule333_back
    rx320_cur."!mark_push"(0, rx320_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx320_pos = $P10."pos"()
    set_addr $I10, rxquantr332_done
    (rx320_rep) = rx320_cur."!mark_commit"($I10)
  rxquantr332_done:
    goto alt331_end
  alt331_2:
.annotate 'line', 139
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_loop"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx320_pos = $P10."pos"()
  alt331_end:
.annotate 'line', 140
    set_addr $I10, rxquantr330_done
    (rx320_rep) = rx320_cur."!mark_commit"($I10)
  rxquantr330_done:
  alt329_end:
.annotate 'line', 131
  # rx pass
    rx320_cur."!cursor_pass"(rx320_pos, "statement")
    if_null rx320_debug, debug_674
    rx320_cur."!cursor_debug"("PASS", "statement", " at pos=", rx320_pos)
  debug_674:
    .return (rx320_cur)
  rx320_restart:
.annotate 'line', 10
    if_null rx320_debug, debug_675
    rx320_cur."!cursor_debug"("NEXT", "statement")
  debug_675:
  rx320_fail:
    (rx320_rep, rx320_pos, $I10, $P10) = rx320_cur."!mark_fail"(0)
    lt rx320_pos, -1, rx320_done
    eq rx320_pos, -1, rx320_fail
    jump $I10
  rx320_done:
    rx320_cur."!cursor_fail"()
    if_null rx320_debug, debug_676
    rx320_cur."!cursor_debug"("FAIL", "statement")
  debug_676:
    .return (rx320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303857440.612") :method
.annotate 'line', 10
    new $P322, "ResizablePMCArray"
    push $P322, ""
    .return ($P322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block324"  :anon :subid("36_1303857440.612") :method :outer("34_1303857440.612")
.annotate 'line', 132
    .local string rx326_tgt
    .local int rx326_pos
    .local int rx326_off
    .local int rx326_eos
    .local int rx326_rep
    .local pmc rx326_cur
    .local pmc rx326_debug
    (rx326_cur, rx326_pos, rx326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx326_cur
    .local pmc match
    .lex "$/", match
    length rx326_eos, rx326_tgt
    gt rx326_pos, rx326_eos, rx326_done
    set rx326_off, 0
    lt rx326_pos, 2, rx326_start
    sub rx326_off, rx326_pos, 1
    substr rx326_tgt, rx326_tgt, rx326_off
  rx326_start:
    eq $I10, 1, rx326_restart
    if_null rx326_debug, debug_670
    rx326_cur."!cursor_debug"("START", "")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan327_done
    goto rxscan327_scan
  rxscan327_loop:
    (rx326_pos) = rx326_cur."from"()
    inc rx326_pos
    rx326_cur."!cursor_from"(rx326_pos)
    ge rx326_pos, rx326_eos, rxscan327_done
  rxscan327_scan:
    set_addr $I10, rxscan327_loop
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  rxscan327_done:
  alt328_0:
    set_addr $I10, alt328_1
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx326_pos, rx326_eos, rx326_fail
    sub $I10, rx326_pos, rx326_off
    substr $S10, rx326_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx326_fail
    inc rx326_pos
    goto alt328_end
  alt328_1:
  # rxanchor eos
    ne rx326_pos, rx326_eos, rx326_fail
  alt328_end:
  # rx pass
    rx326_cur."!cursor_pass"(rx326_pos, "")
    if_null rx326_debug, debug_671
    rx326_cur."!cursor_debug"("PASS", "", " at pos=", rx326_pos)
  debug_671:
    .return (rx326_cur)
  rx326_restart:
    if_null rx326_debug, debug_672
    rx326_cur."!cursor_debug"("NEXT", "")
  debug_672:
  rx326_fail:
    (rx326_rep, rx326_pos, $I10, $P10) = rx326_cur."!mark_fail"(0)
    lt rx326_pos, -1, rx326_done
    eq rx326_pos, -1, rx326_fail
    jump $I10
  rx326_done:
    rx326_cur."!cursor_fail"()
    if_null rx326_debug, debug_673
    rx326_cur."!cursor_debug"("FAIL", "")
  debug_673:
    .return (rx326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx335_tgt
    .local int rx335_pos
    .local int rx335_off
    .local int rx335_eos
    .local int rx335_rep
    .local pmc rx335_cur
    .local pmc rx335_debug
    (rx335_cur, rx335_pos, rx335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx335_cur
    .local pmc match
    .lex "$/", match
    length rx335_eos, rx335_tgt
    gt rx335_pos, rx335_eos, rx335_done
    set rx335_off, 0
    lt rx335_pos, 2, rx335_start
    sub rx335_off, rx335_pos, 1
    substr rx335_tgt, rx335_tgt, rx335_off
  rx335_start:
    eq $I10, 1, rx335_restart
    if_null rx335_debug, debug_677
    rx335_cur."!cursor_debug"("START", "eat_terminator")
  debug_677:
    $I10 = self.'from'()
    ne $I10, -1, rxscan338_done
    goto rxscan338_scan
  rxscan338_loop:
    (rx335_pos) = rx335_cur."from"()
    inc rx335_pos
    rx335_cur."!cursor_from"(rx335_pos)
    ge rx335_pos, rx335_eos, rxscan338_done
  rxscan338_scan:
    set_addr $I10, rxscan338_loop
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
  rxscan338_done:
  alt339_0:
.annotate 'line', 144
    set_addr $I10, alt339_1
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 145
  # rx literal  ";"
    add $I11, rx335_pos, 1
    gt $I11, rx335_eos, rx335_fail
    sub $I11, rx335_pos, rx335_off
    ord $I11, rx335_tgt, $I11
    ne $I11, 59, rx335_fail
    add rx335_pos, 1
    goto alt339_end
  alt339_1:
    set_addr $I10, alt339_2
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 146
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."MARKED"("endstmt")
    unless $P10, rx335_fail
    goto alt339_end
  alt339_2:
    set_addr $I10, alt339_3
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 147
  # rx subrule "terminator" subtype=zerowidth negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."terminator"()
    unless $P10, rx335_fail
    goto alt339_end
  alt339_3:
.annotate 'line', 148
  # rxanchor eos
    ne rx335_pos, rx335_eos, rx335_fail
  alt339_end:
.annotate 'line', 144
  # rx pass
    rx335_cur."!cursor_pass"(rx335_pos, "eat_terminator")
    if_null rx335_debug, debug_678
    rx335_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx335_pos)
  debug_678:
    .return (rx335_cur)
  rx335_restart:
.annotate 'line', 10
    if_null rx335_debug, debug_679
    rx335_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_679:
  rx335_fail:
    (rx335_rep, rx335_pos, $I10, $P10) = rx335_cur."!mark_fail"(0)
    lt rx335_pos, -1, rx335_done
    eq rx335_pos, -1, rx335_fail
    jump $I10
  rx335_done:
    rx335_cur."!cursor_fail"()
    if_null rx335_debug, debug_680
    rx335_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_680:
    .return (rx335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303857440.612") :method
.annotate 'line', 10
    new $P337, "ResizablePMCArray"
    push $P337, ""
    push $P337, ""
    push $P337, ""
    push $P337, ";"
    .return ($P337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx341_tgt
    .local int rx341_pos
    .local int rx341_off
    .local int rx341_eos
    .local int rx341_rep
    .local pmc rx341_cur
    .local pmc rx341_debug
    (rx341_cur, rx341_pos, rx341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx341_cur
    .local pmc match
    .lex "$/", match
    length rx341_eos, rx341_tgt
    gt rx341_pos, rx341_eos, rx341_done
    set rx341_off, 0
    lt rx341_pos, 2, rx341_start
    sub rx341_off, rx341_pos, 1
    substr rx341_tgt, rx341_tgt, rx341_off
  rx341_start:
    eq $I10, 1, rx341_restart
    if_null rx341_debug, debug_681
    rx341_cur."!cursor_debug"("START", "xblock")
  debug_681:
    $I10 = self.'from'()
    ne $I10, -1, rxscan345_done
    goto rxscan345_scan
  rxscan345_loop:
    (rx341_pos) = rx341_cur."from"()
    inc rx341_pos
    rx341_cur."!cursor_from"(rx341_pos)
    ge rx341_pos, rx341_eos, rxscan345_done
  rxscan345_scan:
    set_addr $I10, rxscan345_loop
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  rxscan345_done:
.annotate 'line', 152
  # rx subrule "EXPR" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."EXPR"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx341_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."pblock"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx341_pos = $P10."pos"()
.annotate 'line', 151
  # rx pass
    rx341_cur."!cursor_pass"(rx341_pos, "xblock")
    if_null rx341_debug, debug_682
    rx341_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx341_pos)
  debug_682:
    .return (rx341_cur)
  rx341_restart:
.annotate 'line', 10
    if_null rx341_debug, debug_683
    rx341_cur."!cursor_debug"("NEXT", "xblock")
  debug_683:
  rx341_fail:
    (rx341_rep, rx341_pos, $I10, $P10) = rx341_cur."!mark_fail"(0)
    lt rx341_pos, -1, rx341_done
    eq rx341_pos, -1, rx341_fail
    jump $I10
  rx341_done:
    rx341_cur."!cursor_fail"()
    if_null rx341_debug, debug_684
    rx341_cur."!cursor_debug"("FAIL", "xblock")
  debug_684:
    .return (rx341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303857440.612") :method
.annotate 'line', 10
    $P343 = self."!PREFIX__!subrule"("EXPR", "")
    new $P344, "ResizablePMCArray"
    push $P344, $P343
    .return ($P344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_685
    rx347_cur."!cursor_debug"("START", "pblock")
  debug_685:
    $I10 = self.'from'()
    ne $I10, -1, rxscan352_done
    goto rxscan352_scan
  rxscan352_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan352_done
  rxscan352_scan:
    set_addr $I10, rxscan352_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan352_done:
  alt353_0:
.annotate 'line', 155
    set_addr $I10, alt353_1
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 156
  # rx subrule "lambda" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."lambda"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "newpad" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."newpad"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "signature" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."signature"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx347_pos = $P10."pos"()
.annotate 'line', 159
  # rx subrule "blockoid" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."blockoid"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx347_pos = $P10."pos"()
.annotate 'line', 156
    goto alt353_end
  alt353_1:
    set_addr $I10, alt353_2
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 160
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx347_fail
.annotate 'line', 161
  # rx subrule "newpad" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."newpad"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."blockoid"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx347_pos = $P10."pos"()
.annotate 'line', 160
    goto alt353_end
  alt353_2:
.annotate 'line', 163
  # rx subrule "panic" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."panic"("Missing block")
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  alt353_end:
.annotate 'line', 155
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "pblock")
    if_null rx347_debug, debug_686
    rx347_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx347_pos)
  debug_686:
    .return (rx347_cur)
  rx347_restart:
.annotate 'line', 10
    if_null rx347_debug, debug_687
    rx347_cur."!cursor_debug"("NEXT", "pblock")
  debug_687:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_688
    rx347_cur."!cursor_debug"("FAIL", "pblock")
  debug_688:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303857440.612") :method
.annotate 'line', 10
    $P349 = self."!PREFIX__!subrule"("panic", "")
    $P350 = self."!PREFIX__!subrule"("lambda", "")
    new $P351, "ResizablePMCArray"
    push $P351, $P349
    push $P351, "{"
    push $P351, $P350
    .return ($P351)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx355_tgt
    .local int rx355_pos
    .local int rx355_off
    .local int rx355_eos
    .local int rx355_rep
    .local pmc rx355_cur
    .local pmc rx355_debug
    (rx355_cur, rx355_pos, rx355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx355_cur
    .local pmc match
    .lex "$/", match
    length rx355_eos, rx355_tgt
    gt rx355_pos, rx355_eos, rx355_done
    set rx355_off, 0
    lt rx355_pos, 2, rx355_start
    sub rx355_off, rx355_pos, 1
    substr rx355_tgt, rx355_tgt, rx355_off
  rx355_start:
    eq $I10, 1, rx355_restart
    if_null rx355_debug, debug_689
    rx355_cur."!cursor_debug"("START", "lambda")
  debug_689:
    $I10 = self.'from'()
    ne $I10, -1, rxscan358_done
    goto rxscan358_scan
  rxscan358_loop:
    (rx355_pos) = rx355_cur."from"()
    inc rx355_pos
    rx355_cur."!cursor_from"(rx355_pos)
    ge rx355_pos, rx355_eos, rxscan358_done
  rxscan358_scan:
    set_addr $I10, rxscan358_loop
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  rxscan358_done:
  alt359_0:
.annotate 'line', 166
    set_addr $I10, alt359_1
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  # rx literal  "->"
    add $I11, rx355_pos, 2
    gt $I11, rx355_eos, rx355_fail
    sub $I11, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I11, 2
    ne $S10, "->", rx355_fail
    add rx355_pos, 2
    goto alt359_end
  alt359_1:
  # rx literal  "<->"
    add $I11, rx355_pos, 3
    gt $I11, rx355_eos, rx355_fail
    sub $I11, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I11, 3
    ne $S10, "<->", rx355_fail
    add rx355_pos, 3
  alt359_end:
  # rx pass
    rx355_cur."!cursor_pass"(rx355_pos, "lambda")
    if_null rx355_debug, debug_690
    rx355_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx355_pos)
  debug_690:
    .return (rx355_cur)
  rx355_restart:
.annotate 'line', 10
    if_null rx355_debug, debug_691
    rx355_cur."!cursor_debug"("NEXT", "lambda")
  debug_691:
  rx355_fail:
    (rx355_rep, rx355_pos, $I10, $P10) = rx355_cur."!mark_fail"(0)
    lt rx355_pos, -1, rx355_done
    eq rx355_pos, -1, rx355_fail
    jump $I10
  rx355_done:
    rx355_cur."!cursor_fail"()
    if_null rx355_debug, debug_692
    rx355_cur."!cursor_debug"("FAIL", "lambda")
  debug_692:
    .return (rx355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303857440.612") :method
.annotate 'line', 10
    new $P357, "ResizablePMCArray"
    push $P357, "<->"
    push $P357, "->"
    .return ($P357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx361_tgt
    .local int rx361_pos
    .local int rx361_off
    .local int rx361_eos
    .local int rx361_rep
    .local pmc rx361_cur
    .local pmc rx361_debug
    (rx361_cur, rx361_pos, rx361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx361_cur
    .local pmc match
    .lex "$/", match
    length rx361_eos, rx361_tgt
    gt rx361_pos, rx361_eos, rx361_done
    set rx361_off, 0
    lt rx361_pos, 2, rx361_start
    sub rx361_off, rx361_pos, 1
    substr rx361_tgt, rx361_tgt, rx361_off
  rx361_start:
    eq $I10, 1, rx361_restart
    if_null rx361_debug, debug_693
    rx361_cur."!cursor_debug"("START", "block")
  debug_693:
    $I10 = self.'from'()
    ne $I10, -1, rxscan365_done
    goto rxscan365_scan
  rxscan365_loop:
    (rx361_pos) = rx361_cur."from"()
    inc rx361_pos
    rx361_cur."!cursor_from"(rx361_pos)
    ge rx361_pos, rx361_eos, rxscan365_done
  rxscan365_scan:
    set_addr $I10, rxscan365_loop
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  rxscan365_done:
  alt366_0:
.annotate 'line', 169
    set_addr $I10, alt366_1
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx361_pos, rx361_off
    substr $S10, rx361_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx361_fail
    goto alt366_end
  alt366_1:
  # rx subrule "panic" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."panic"("Missing block")
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
  alt366_end:
.annotate 'line', 170
  # rx subrule "newpad" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."newpad"()
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
.annotate 'line', 171
  # rx subrule "blockoid" subtype=capture negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."blockoid"()
    unless $P10, rx361_fail
    rx361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx361_pos = $P10."pos"()
.annotate 'line', 168
  # rx pass
    rx361_cur."!cursor_pass"(rx361_pos, "block")
    if_null rx361_debug, debug_694
    rx361_cur."!cursor_debug"("PASS", "block", " at pos=", rx361_pos)
  debug_694:
    .return (rx361_cur)
  rx361_restart:
.annotate 'line', 10
    if_null rx361_debug, debug_695
    rx361_cur."!cursor_debug"("NEXT", "block")
  debug_695:
  rx361_fail:
    (rx361_rep, rx361_pos, $I10, $P10) = rx361_cur."!mark_fail"(0)
    lt rx361_pos, -1, rx361_done
    eq rx361_pos, -1, rx361_fail
    jump $I10
  rx361_done:
    rx361_cur."!cursor_fail"()
    if_null rx361_debug, debug_696
    rx361_cur."!cursor_debug"("FAIL", "block")
  debug_696:
    .return (rx361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303857440.612") :method
.annotate 'line', 10
    $P363 = self."!PREFIX__!subrule"("panic", "")
    new $P364, "ResizablePMCArray"
    push $P364, $P363
    push $P364, "{"
    .return ($P364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx368_tgt
    .local int rx368_pos
    .local int rx368_off
    .local int rx368_eos
    .local int rx368_rep
    .local pmc rx368_cur
    .local pmc rx368_debug
    (rx368_cur, rx368_pos, rx368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx368_cur
    .local pmc match
    .lex "$/", match
    length rx368_eos, rx368_tgt
    gt rx368_pos, rx368_eos, rx368_done
    set rx368_off, 0
    lt rx368_pos, 2, rx368_start
    sub rx368_off, rx368_pos, 1
    substr rx368_tgt, rx368_tgt, rx368_off
  rx368_start:
    eq $I10, 1, rx368_restart
    if_null rx368_debug, debug_697
    rx368_cur."!cursor_debug"("START", "blockoid")
  debug_697:
    $I10 = self.'from'()
    ne $I10, -1, rxscan372_done
    goto rxscan372_scan
  rxscan372_loop:
    (rx368_pos) = rx368_cur."from"()
    inc rx368_pos
    rx368_cur."!cursor_from"(rx368_pos)
    ge rx368_pos, rx368_eos, rxscan372_done
  rxscan372_scan:
    set_addr $I10, rxscan372_loop
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  rxscan372_done:
.annotate 'line', 175
  # rx subrule "finishpad" subtype=method negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."finishpad"()
    unless $P10, rx368_fail
    rx368_pos = $P10."pos"()
  alt373_0:
.annotate 'line', 176
    set_addr $I10, alt373_1
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
.annotate 'line', 177
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx368_pos, 14
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    substr $S10, rx368_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx368_fail
    add rx368_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."you_are_here"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx368_pos = $P10."pos"()
    goto alt373_end
  alt373_1:
.annotate 'line', 178
  # rx literal  "{"
    add $I11, rx368_pos, 1
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    ord $I11, rx368_tgt, $I11
    ne $I11, 123, rx368_fail
    add rx368_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."statementlist"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx368_pos = $P10."pos"()
  alt374_0:
    set_addr $I10, alt374_1
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  # rx literal  "}"
    add $I11, rx368_pos, 1
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    ord $I11, rx368_tgt, $I11
    ne $I11, 125, rx368_fail
    add rx368_pos, 1
    goto alt374_end
  alt374_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."FAILGOAL"("'}'")
    unless $P10, rx368_fail
    goto rxsubrule376_pass
  rxsubrule376_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx368_fail
  rxsubrule376_pass:
    set_addr $I10, rxsubrule376_back
    rx368_cur."!mark_push"(0, rx368_pos, $I10, $P10)
    rx368_pos = $P10."pos"()
  alt374_end:
  alt373_end:
.annotate 'line', 180
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."ENDSTMT"()
    unless $P10, rx368_fail
.annotate 'line', 174
  # rx pass
    rx368_cur."!cursor_pass"(rx368_pos, "blockoid")
    if_null rx368_debug, debug_698
    rx368_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx368_pos)
  debug_698:
    .return (rx368_cur)
  rx368_restart:
.annotate 'line', 10
    if_null rx368_debug, debug_699
    rx368_cur."!cursor_debug"("NEXT", "blockoid")
  debug_699:
  rx368_fail:
    (rx368_rep, rx368_pos, $I10, $P10) = rx368_cur."!mark_fail"(0)
    lt rx368_pos, -1, rx368_done
    eq rx368_pos, -1, rx368_fail
    jump $I10
  rx368_done:
    rx368_cur."!cursor_fail"()
    if_null rx368_debug, debug_700
    rx368_cur."!cursor_debug"("FAIL", "blockoid")
  debug_700:
    .return (rx368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303857440.612") :method
.annotate 'line', 10
    $P370 = self."!PREFIX__!subrule"("finishpad", "")
    new $P371, "ResizablePMCArray"
    push $P371, $P370
    .return ($P371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx378_tgt
    .local int rx378_pos
    .local int rx378_off
    .local int rx378_eos
    .local int rx378_rep
    .local pmc rx378_cur
    .local pmc rx378_debug
    (rx378_cur, rx378_pos, rx378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx378_cur
    .local pmc match
    .lex "$/", match
    length rx378_eos, rx378_tgt
    gt rx378_pos, rx378_eos, rx378_done
    set rx378_off, 0
    lt rx378_pos, 2, rx378_start
    sub rx378_off, rx378_pos, 1
    substr rx378_tgt, rx378_tgt, rx378_off
  rx378_start:
    eq $I10, 1, rx378_restart
    if_null rx378_debug, debug_701
    rx378_cur."!cursor_debug"("START", "newpad")
  debug_701:
    $I10 = self.'from'()
    ne $I10, -1, rxscan381_done
    goto rxscan381_scan
  rxscan381_loop:
    (rx378_pos) = rx378_cur."from"()
    inc rx378_pos
    rx378_cur."!cursor_from"(rx378_pos)
    ge rx378_pos, rx378_eos, rxscan381_done
  rxscan381_scan:
    set_addr $I10, rxscan381_loop
    rx378_cur."!mark_push"(0, rx378_pos, $I10)
  rxscan381_done:
.annotate 'line', 183
  # rx pass
    rx378_cur."!cursor_pass"(rx378_pos, "newpad")
    if_null rx378_debug, debug_702
    rx378_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx378_pos)
  debug_702:
    .return (rx378_cur)
  rx378_restart:
.annotate 'line', 10
    if_null rx378_debug, debug_703
    rx378_cur."!cursor_debug"("NEXT", "newpad")
  debug_703:
  rx378_fail:
    (rx378_rep, rx378_pos, $I10, $P10) = rx378_cur."!mark_fail"(0)
    lt rx378_pos, -1, rx378_done
    eq rx378_pos, -1, rx378_fail
    jump $I10
  rx378_done:
    rx378_cur."!cursor_fail"()
    if_null rx378_debug, debug_704
    rx378_cur."!cursor_debug"("FAIL", "newpad")
  debug_704:
    .return (rx378_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303857440.612") :method
.annotate 'line', 10
    new $P380, "ResizablePMCArray"
    push $P380, ""
    .return ($P380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_705
    rx383_cur."!cursor_debug"("START", "outerctx")
  debug_705:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 184
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "outerctx")
    if_null rx383_debug, debug_706
    rx383_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx383_pos)
  debug_706:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_707
    rx383_cur."!cursor_debug"("NEXT", "outerctx")
  debug_707:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_708
    rx383_cur."!cursor_debug"("FAIL", "outerctx")
  debug_708:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303857440.612") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, ""
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx388_tgt
    .local int rx388_pos
    .local int rx388_off
    .local int rx388_eos
    .local int rx388_rep
    .local pmc rx388_cur
    .local pmc rx388_debug
    (rx388_cur, rx388_pos, rx388_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx388_cur
    .local pmc match
    .lex "$/", match
    length rx388_eos, rx388_tgt
    gt rx388_pos, rx388_eos, rx388_done
    set rx388_off, 0
    lt rx388_pos, 2, rx388_start
    sub rx388_off, rx388_pos, 1
    substr rx388_tgt, rx388_tgt, rx388_off
  rx388_start:
    eq $I10, 1, rx388_restart
    if_null rx388_debug, debug_709
    rx388_cur."!cursor_debug"("START", "GLOBALish")
  debug_709:
    $I10 = self.'from'()
    ne $I10, -1, rxscan391_done
    goto rxscan391_scan
  rxscan391_loop:
    (rx388_pos) = rx388_cur."from"()
    inc rx388_pos
    rx388_cur."!cursor_from"(rx388_pos)
    ge rx388_pos, rx388_eos, rxscan391_done
  rxscan391_scan:
    set_addr $I10, rxscan391_loop
    rx388_cur."!mark_push"(0, rx388_pos, $I10)
  rxscan391_done:
.annotate 'line', 185
  # rx pass
    rx388_cur."!cursor_pass"(rx388_pos, "GLOBALish")
    if_null rx388_debug, debug_710
    rx388_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx388_pos)
  debug_710:
    .return (rx388_cur)
  rx388_restart:
.annotate 'line', 10
    if_null rx388_debug, debug_711
    rx388_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_711:
  rx388_fail:
    (rx388_rep, rx388_pos, $I10, $P10) = rx388_cur."!mark_fail"(0)
    lt rx388_pos, -1, rx388_done
    eq rx388_pos, -1, rx388_fail
    jump $I10
  rx388_done:
    rx388_cur."!cursor_fail"()
    if_null rx388_debug, debug_712
    rx388_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_712:
    .return (rx388_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303857440.612") :method
.annotate 'line', 10
    new $P390, "ResizablePMCArray"
    push $P390, ""
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx393_tgt
    .local int rx393_pos
    .local int rx393_off
    .local int rx393_eos
    .local int rx393_rep
    .local pmc rx393_cur
    .local pmc rx393_debug
    (rx393_cur, rx393_pos, rx393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx393_cur
    .local pmc match
    .lex "$/", match
    length rx393_eos, rx393_tgt
    gt rx393_pos, rx393_eos, rx393_done
    set rx393_off, 0
    lt rx393_pos, 2, rx393_start
    sub rx393_off, rx393_pos, 1
    substr rx393_tgt, rx393_tgt, rx393_off
  rx393_start:
    eq $I10, 1, rx393_restart
    if_null rx393_debug, debug_713
    rx393_cur."!cursor_debug"("START", "finishpad")
  debug_713:
    $I10 = self.'from'()
    ne $I10, -1, rxscan396_done
    goto rxscan396_scan
  rxscan396_loop:
    (rx393_pos) = rx393_cur."from"()
    inc rx393_pos
    rx393_cur."!cursor_from"(rx393_pos)
    ge rx393_pos, rx393_eos, rxscan396_done
  rxscan396_scan:
    set_addr $I10, rxscan396_loop
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  rxscan396_done:
.annotate 'line', 186
  # rx pass
    rx393_cur."!cursor_pass"(rx393_pos, "finishpad")
    if_null rx393_debug, debug_714
    rx393_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx393_pos)
  debug_714:
    .return (rx393_cur)
  rx393_restart:
.annotate 'line', 10
    if_null rx393_debug, debug_715
    rx393_cur."!cursor_debug"("NEXT", "finishpad")
  debug_715:
  rx393_fail:
    (rx393_rep, rx393_pos, $I10, $P10) = rx393_cur."!mark_fail"(0)
    lt rx393_pos, -1, rx393_done
    eq rx393_pos, -1, rx393_fail
    jump $I10
  rx393_done:
    rx393_cur."!cursor_fail"()
    if_null rx393_debug, debug_716
    rx393_cur."!cursor_debug"("FAIL", "finishpad")
  debug_716:
    .return (rx393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303857440.612") :method
.annotate 'line', 10
    new $P395, "ResizablePMCArray"
    push $P395, ""
    .return ($P395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx398_tgt
    .local int rx398_pos
    .local int rx398_off
    .local int rx398_eos
    .local int rx398_rep
    .local pmc rx398_cur
    .local pmc rx398_debug
    (rx398_cur, rx398_pos, rx398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx398_cur
    .local pmc match
    .lex "$/", match
    length rx398_eos, rx398_tgt
    gt rx398_pos, rx398_eos, rx398_done
    set rx398_off, 0
    lt rx398_pos, 2, rx398_start
    sub rx398_off, rx398_pos, 1
    substr rx398_tgt, rx398_tgt, rx398_off
  rx398_start:
    eq $I10, 1, rx398_restart
    if_null rx398_debug, debug_717
    rx398_cur."!cursor_debug"("START", "you_are_here")
  debug_717:
    $I10 = self.'from'()
    ne $I10, -1, rxscan401_done
    goto rxscan401_scan
  rxscan401_loop:
    (rx398_pos) = rx398_cur."from"()
    inc rx398_pos
    rx398_cur."!cursor_from"(rx398_pos)
    ge rx398_pos, rx398_eos, rxscan401_done
  rxscan401_scan:
    set_addr $I10, rxscan401_loop
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  rxscan401_done:
.annotate 'line', 187
  # rx pass
    rx398_cur."!cursor_pass"(rx398_pos, "you_are_here")
    if_null rx398_debug, debug_718
    rx398_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx398_pos)
  debug_718:
    .return (rx398_cur)
  rx398_restart:
.annotate 'line', 10
    if_null rx398_debug, debug_719
    rx398_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_719:
  rx398_fail:
    (rx398_rep, rx398_pos, $I10, $P10) = rx398_cur."!mark_fail"(0)
    lt rx398_pos, -1, rx398_done
    eq rx398_pos, -1, rx398_fail
    jump $I10
  rx398_done:
    rx398_cur."!cursor_fail"()
    if_null rx398_debug, debug_720
    rx398_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_720:
    .return (rx398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303857440.612") :method
.annotate 'line', 10
    new $P400, "ResizablePMCArray"
    push $P400, ""
    .return ($P400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303857440.612")
    .param pmc param_403
.annotate 'line', 189
    .lex "self", param_403
    $P404 = param_403."!protoregex"("terminator")
    .return ($P404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303857440.612")
    .param pmc param_406
.annotate 'line', 189
    .lex "self", param_406
    $P407 = param_406."!PREFIX__!protoregex"("terminator")
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx409_tgt
    .local int rx409_pos
    .local int rx409_off
    .local int rx409_eos
    .local int rx409_rep
    .local pmc rx409_cur
    .local pmc rx409_debug
    (rx409_cur, rx409_pos, rx409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx409_cur
    .local pmc match
    .lex "$/", match
    length rx409_eos, rx409_tgt
    gt rx409_pos, rx409_eos, rx409_done
    set rx409_off, 0
    lt rx409_pos, 2, rx409_start
    sub rx409_off, rx409_pos, 1
    substr rx409_tgt, rx409_tgt, rx409_off
  rx409_start:
    eq $I10, 1, rx409_restart
    if_null rx409_debug, debug_721
    rx409_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_721:
    $I10 = self.'from'()
    ne $I10, -1, rxscan412_done
    goto rxscan412_scan
  rxscan412_loop:
    (rx409_pos) = rx409_cur."from"()
    inc rx409_pos
    rx409_cur."!cursor_from"(rx409_pos)
    ge rx409_pos, rx409_eos, rxscan412_done
  rxscan412_scan:
    set_addr $I10, rxscan412_loop
    rx409_cur."!mark_push"(0, rx409_pos, $I10)
  rxscan412_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx409_pos, rx409_off
    substr $S10, rx409_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx409_fail
  # rx pass
    rx409_cur."!cursor_pass"(rx409_pos, "terminator:sym<;>")
    if_null rx409_debug, debug_722
    rx409_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx409_pos)
  debug_722:
    .return (rx409_cur)
  rx409_restart:
.annotate 'line', 10
    if_null rx409_debug, debug_723
    rx409_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_723:
  rx409_fail:
    (rx409_rep, rx409_pos, $I10, $P10) = rx409_cur."!mark_fail"(0)
    lt rx409_pos, -1, rx409_done
    eq rx409_pos, -1, rx409_fail
    jump $I10
  rx409_done:
    rx409_cur."!cursor_fail"()
    if_null rx409_debug, debug_724
    rx409_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_724:
    .return (rx409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303857440.612") :method
.annotate 'line', 10
    new $P411, "ResizablePMCArray"
    push $P411, ";"
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx414_tgt
    .local int rx414_pos
    .local int rx414_off
    .local int rx414_eos
    .local int rx414_rep
    .local pmc rx414_cur
    .local pmc rx414_debug
    (rx414_cur, rx414_pos, rx414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx414_cur
    .local pmc match
    .lex "$/", match
    length rx414_eos, rx414_tgt
    gt rx414_pos, rx414_eos, rx414_done
    set rx414_off, 0
    lt rx414_pos, 2, rx414_start
    sub rx414_off, rx414_pos, 1
    substr rx414_tgt, rx414_tgt, rx414_off
  rx414_start:
    eq $I10, 1, rx414_restart
    if_null rx414_debug, debug_725
    rx414_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_725:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx414_pos) = rx414_cur."from"()
    inc rx414_pos
    rx414_cur."!cursor_from"(rx414_pos)
    ge rx414_pos, rx414_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx414_cur."!mark_push"(0, rx414_pos, $I10)
  rxscan417_done:
.annotate 'line', 192
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx414_pos, rx414_off
    substr $S10, rx414_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx414_fail
  # rx pass
    rx414_cur."!cursor_pass"(rx414_pos, "terminator:sym<}>")
    if_null rx414_debug, debug_726
    rx414_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx414_pos)
  debug_726:
    .return (rx414_cur)
  rx414_restart:
.annotate 'line', 10
    if_null rx414_debug, debug_727
    rx414_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_727:
  rx414_fail:
    (rx414_rep, rx414_pos, $I10, $P10) = rx414_cur."!mark_fail"(0)
    lt rx414_pos, -1, rx414_done
    eq rx414_pos, -1, rx414_fail
    jump $I10
  rx414_done:
    rx414_cur."!cursor_fail"()
    if_null rx414_debug, debug_728
    rx414_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_728:
    .return (rx414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303857440.612") :method
.annotate 'line', 10
    new $P416, "ResizablePMCArray"
    push $P416, "}"
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303857440.612")
    .param pmc param_419
.annotate 'line', 196
    .lex "self", param_419
    $P420 = param_419."!protoregex"("statement_control")
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303857440.612")
    .param pmc param_422
.annotate 'line', 196
    .lex "self", param_422
    $P423 = param_422."!PREFIX__!protoregex"("statement_control")
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx425_tgt
    .local int rx425_pos
    .local int rx425_off
    .local int rx425_eos
    .local int rx425_rep
    .local pmc rx425_cur
    .local pmc rx425_debug
    (rx425_cur, rx425_pos, rx425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx425_cur
    .local pmc match
    .lex "$/", match
    length rx425_eos, rx425_tgt
    gt rx425_pos, rx425_eos, rx425_done
    set rx425_off, 0
    lt rx425_pos, 2, rx425_start
    sub rx425_off, rx425_pos, 1
    substr rx425_tgt, rx425_tgt, rx425_off
  rx425_start:
    eq $I10, 1, rx425_restart
    if_null rx425_debug, debug_729
    rx425_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_729:
    $I10 = self.'from'()
    ne $I10, -1, rxscan428_done
    goto rxscan428_scan
  rxscan428_loop:
    (rx425_pos) = rx425_cur."from"()
    inc rx425_pos
    rx425_cur."!cursor_from"(rx425_pos)
    ge rx425_pos, rx425_eos, rxscan428_done
  rxscan428_scan:
    set_addr $I10, rxscan428_loop
    rx425_cur."!mark_push"(0, rx425_pos, $I10)
  rxscan428_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_429_fail
    rx425_cur."!mark_push"(0, rx425_pos, $I10)
  # rx literal  "use"
    add $I11, rx425_pos, 3
    gt $I11, rx425_eos, rx425_fail
    sub $I11, rx425_pos, rx425_off
    substr $S10, rx425_tgt, $I11, 3
    ne $S10, "use", rx425_fail
    add rx425_pos, 3
    set_addr $I10, rxcap_429_fail
    ($I12, $I11) = rx425_cur."!mark_peek"($I10)
    rx425_cur."!cursor_pos"($I11)
    ($P10) = rx425_cur."!cursor_start"()
    $P10."!cursor_pass"(rx425_pos, "")
    rx425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_429_done
  rxcap_429_fail:
    goto rx425_fail
  rxcap_429_done:
  # rx charclass s
    ge rx425_pos, rx425_eos, rx425_fail
    sub $I10, rx425_pos, rx425_off
    is_cclass $I11, 32, rx425_tgt, $I10
    unless $I11, rx425_fail
    inc rx425_pos
  # rx subrule "ws" subtype=method negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."ws"()
    unless $P10, rx425_fail
    rx425_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."name"()
    unless $P10, rx425_fail
    rx425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx425_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."ws"()
    unless $P10, rx425_fail
    rx425_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx425_cur."!cursor_pass"(rx425_pos, "statement_control:sym<use>")
    if_null rx425_debug, debug_730
    rx425_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx425_pos)
  debug_730:
    .return (rx425_cur)
  rx425_restart:
.annotate 'line', 10
    if_null rx425_debug, debug_731
    rx425_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_731:
  rx425_fail:
    (rx425_rep, rx425_pos, $I10, $P10) = rx425_cur."!mark_fail"(0)
    lt rx425_pos, -1, rx425_done
    eq rx425_pos, -1, rx425_fail
    jump $I10
  rx425_done:
    rx425_cur."!cursor_fail"()
    if_null rx425_debug, debug_732
    rx425_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_732:
    .return (rx425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303857440.612") :method
.annotate 'line', 10
    new $P427, "ResizablePMCArray"
    push $P427, "use"
    .return ($P427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx433_tgt
    .local int rx433_pos
    .local int rx433_off
    .local int rx433_eos
    .local int rx433_rep
    .local pmc rx433_cur
    .local pmc rx433_debug
    (rx433_cur, rx433_pos, rx433_tgt, $I10) = self."!cursor_start"()
    rx433_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx433_cur
    .local pmc match
    .lex "$/", match
    length rx433_eos, rx433_tgt
    gt rx433_pos, rx433_eos, rx433_done
    set rx433_off, 0
    lt rx433_pos, 2, rx433_start
    sub rx433_off, rx433_pos, 1
    substr rx433_tgt, rx433_tgt, rx433_off
  rx433_start:
    eq $I10, 1, rx433_restart
    if_null rx433_debug, debug_733
    rx433_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_733:
    $I10 = self.'from'()
    ne $I10, -1, rxscan436_done
    goto rxscan436_scan
  rxscan436_loop:
    (rx433_pos) = rx433_cur."from"()
    inc rx433_pos
    rx433_cur."!cursor_from"(rx433_pos)
    ge rx433_pos, rx433_eos, rxscan436_done
  rxscan436_scan:
    set_addr $I10, rxscan436_loop
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxscan436_done:
.annotate 'line', 203
  # rx subcapture "sym"
    set_addr $I10, rxcap_437_fail
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  # rx literal  "if"
    add $I11, rx433_pos, 2
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 2
    ne $S10, "if", rx433_fail
    add rx433_pos, 2
    set_addr $I10, rxcap_437_fail
    ($I12, $I11) = rx433_cur."!mark_peek"($I10)
    rx433_cur."!cursor_pos"($I11)
    ($P10) = rx433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx433_pos, "")
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_437_done
  rxcap_437_fail:
    goto rx433_fail
  rxcap_437_done:
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 204
  # rx subrule "xblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."xblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr440 ** 0..*
    set_addr $I10, rxquantr440_done
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxquantr440_loop:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx433_pos, 5
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 5
    ne $S10, "elsif", rx433_fail
    add rx433_pos, 5
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."xblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
    set_addr $I10, rxquantr440_done
    (rx433_rep) = rx433_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr440_done
    rx433_cur."!mark_push"(rx433_rep, rx433_pos, $I10)
    goto rxquantr440_loop
  rxquantr440_done:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 206
  # rx rxquantr445 ** 0..1
    set_addr $I10, rxquantr445_done
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxquantr445_loop:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx433_pos, 4
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 4
    ne $S10, "else", rx433_fail
    add rx433_pos, 4
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."pblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
    set_addr $I10, rxquantr445_done
    (rx433_rep) = rx433_cur."!mark_commit"($I10)
  rxquantr445_done:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 202
  # rx pass
    rx433_cur."!cursor_pass"(rx433_pos, "statement_control:sym<if>")
    if_null rx433_debug, debug_734
    rx433_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx433_pos)
  debug_734:
    .return (rx433_cur)
  rx433_restart:
.annotate 'line', 10
    if_null rx433_debug, debug_735
    rx433_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_735:
  rx433_fail:
    (rx433_rep, rx433_pos, $I10, $P10) = rx433_cur."!mark_fail"(0)
    lt rx433_pos, -1, rx433_done
    eq rx433_pos, -1, rx433_fail
    jump $I10
  rx433_done:
    rx433_cur."!cursor_fail"()
    if_null rx433_debug, debug_736
    rx433_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_736:
    .return (rx433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303857440.612") :method
.annotate 'line', 10
    new $P435, "ResizablePMCArray"
    push $P435, "if"
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P461 = "73_1303857440.612" 
    capture_lex $P461
    .local string rx451_tgt
    .local int rx451_pos
    .local int rx451_off
    .local int rx451_eos
    .local int rx451_rep
    .local pmc rx451_cur
    .local pmc rx451_debug
    (rx451_cur, rx451_pos, rx451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx451_cur
    .local pmc match
    .lex "$/", match
    length rx451_eos, rx451_tgt
    gt rx451_pos, rx451_eos, rx451_done
    set rx451_off, 0
    lt rx451_pos, 2, rx451_start
    sub rx451_off, rx451_pos, 1
    substr rx451_tgt, rx451_tgt, rx451_off
  rx451_start:
    eq $I10, 1, rx451_restart
    if_null rx451_debug, debug_737
    rx451_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_737:
    $I10 = self.'from'()
    ne $I10, -1, rxscan454_done
    goto rxscan454_scan
  rxscan454_loop:
    (rx451_pos) = rx451_cur."from"()
    inc rx451_pos
    rx451_cur."!cursor_from"(rx451_pos)
    ge rx451_pos, rx451_eos, rxscan454_done
  rxscan454_scan:
    set_addr $I10, rxscan454_loop
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  rxscan454_done:
.annotate 'line', 210
  # rx subcapture "sym"
    set_addr $I10, rxcap_455_fail
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  # rx literal  "unless"
    add $I11, rx451_pos, 6
    gt $I11, rx451_eos, rx451_fail
    sub $I11, rx451_pos, rx451_off
    substr $S10, rx451_tgt, $I11, 6
    ne $S10, "unless", rx451_fail
    add rx451_pos, 6
    set_addr $I10, rxcap_455_fail
    ($I12, $I11) = rx451_cur."!mark_peek"($I10)
    rx451_cur."!cursor_pos"($I11)
    ($P10) = rx451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx451_pos, "")
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_455_done
  rxcap_455_fail:
    goto rx451_fail
  rxcap_455_done:
  # rx charclass s
    ge rx451_pos, rx451_eos, rx451_fail
    sub $I10, rx451_pos, rx451_off
    is_cclass $I11, 32, rx451_tgt, $I10
    unless $I11, rx451_fail
    inc rx451_pos
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
.annotate 'line', 211
  # rx subrule "xblock" subtype=capture negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."xblock"()
    unless $P10, rx451_fail
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  alt458_0:
.annotate 'line', 212
    set_addr $I10, alt458_1
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx451_cur."!cursor_pos"(rx451_pos)
    .const 'Sub' $P461 = "73_1303857440.612" 
    capture_lex $P461
    $P10 = rx451_cur."before"($P461)
    if $P10, rx451_fail
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
    goto alt458_end
  alt458_1:
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  alt458_end:
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
.annotate 'line', 209
  # rx pass
    rx451_cur."!cursor_pass"(rx451_pos, "statement_control:sym<unless>")
    if_null rx451_debug, debug_742
    rx451_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx451_pos)
  debug_742:
    .return (rx451_cur)
  rx451_restart:
.annotate 'line', 10
    if_null rx451_debug, debug_743
    rx451_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_743:
  rx451_fail:
    (rx451_rep, rx451_pos, $I10, $P10) = rx451_cur."!mark_fail"(0)
    lt rx451_pos, -1, rx451_done
    eq rx451_pos, -1, rx451_fail
    jump $I10
  rx451_done:
    rx451_cur."!cursor_fail"()
    if_null rx451_debug, debug_744
    rx451_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_744:
    .return (rx451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303857440.612") :method
.annotate 'line', 10
    new $P453, "ResizablePMCArray"
    push $P453, "unless"
    .return ($P453)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block460"  :anon :subid("73_1303857440.612") :method :outer("71_1303857440.612")
.annotate 'line', 212
    .local string rx462_tgt
    .local int rx462_pos
    .local int rx462_off
    .local int rx462_eos
    .local int rx462_rep
    .local pmc rx462_cur
    .local pmc rx462_debug
    (rx462_cur, rx462_pos, rx462_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx462_cur
    .local pmc match
    .lex "$/", match
    length rx462_eos, rx462_tgt
    gt rx462_pos, rx462_eos, rx462_done
    set rx462_off, 0
    lt rx462_pos, 2, rx462_start
    sub rx462_off, rx462_pos, 1
    substr rx462_tgt, rx462_tgt, rx462_off
  rx462_start:
    eq $I10, 1, rx462_restart
    if_null rx462_debug, debug_738
    rx462_cur."!cursor_debug"("START", "")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan463_done
    goto rxscan463_scan
  rxscan463_loop:
    (rx462_pos) = rx462_cur."from"()
    inc rx462_pos
    rx462_cur."!cursor_from"(rx462_pos)
    ge rx462_pos, rx462_eos, rxscan463_done
  rxscan463_scan:
    set_addr $I10, rxscan463_loop
    rx462_cur."!mark_push"(0, rx462_pos, $I10)
  rxscan463_done:
  # rx literal  "else"
    add $I11, rx462_pos, 4
    gt $I11, rx462_eos, rx462_fail
    sub $I11, rx462_pos, rx462_off
    substr $S10, rx462_tgt, $I11, 4
    ne $S10, "else", rx462_fail
    add rx462_pos, 4
  # rx pass
    rx462_cur."!cursor_pass"(rx462_pos, "")
    if_null rx462_debug, debug_739
    rx462_cur."!cursor_debug"("PASS", "", " at pos=", rx462_pos)
  debug_739:
    .return (rx462_cur)
  rx462_restart:
    if_null rx462_debug, debug_740
    rx462_cur."!cursor_debug"("NEXT", "")
  debug_740:
  rx462_fail:
    (rx462_rep, rx462_pos, $I10, $P10) = rx462_cur."!mark_fail"(0)
    lt rx462_pos, -1, rx462_done
    eq rx462_pos, -1, rx462_fail
    jump $I10
  rx462_done:
    rx462_cur."!cursor_fail"()
    if_null rx462_debug, debug_741
    rx462_cur."!cursor_debug"("FAIL", "")
  debug_741:
    .return (rx462_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_745
    rx469_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_745:
    $I10 = self.'from'()
    ne $I10, -1, rxscan472_done
    goto rxscan472_scan
  rxscan472_loop:
    (rx469_pos) = rx469_cur."from"()
    inc rx469_pos
    rx469_cur."!cursor_from"(rx469_pos)
    ge rx469_pos, rx469_eos, rxscan472_done
  rxscan472_scan:
    set_addr $I10, rxscan472_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan472_done:
.annotate 'line', 216
  # rx subcapture "sym"
    set_addr $I10, rxcap_474_fail
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  alt473_0:
    set_addr $I10, alt473_1
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  # rx literal  "while"
    add $I11, rx469_pos, 5
    gt $I11, rx469_eos, rx469_fail
    sub $I11, rx469_pos, rx469_off
    substr $S10, rx469_tgt, $I11, 5
    ne $S10, "while", rx469_fail
    add rx469_pos, 5
    goto alt473_end
  alt473_1:
  # rx literal  "until"
    add $I11, rx469_pos, 5
    gt $I11, rx469_eos, rx469_fail
    sub $I11, rx469_pos, rx469_off
    substr $S10, rx469_tgt, $I11, 5
    ne $S10, "until", rx469_fail
    add rx469_pos, 5
  alt473_end:
    set_addr $I10, rxcap_474_fail
    ($I12, $I11) = rx469_cur."!mark_peek"($I10)
    rx469_cur."!cursor_pos"($I11)
    ($P10) = rx469_cur."!cursor_start"()
    $P10."!cursor_pass"(rx469_pos, "")
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_474_done
  rxcap_474_fail:
    goto rx469_fail
  rxcap_474_done:
  # rx charclass s
    ge rx469_pos, rx469_eos, rx469_fail
    sub $I10, rx469_pos, rx469_off
    is_cclass $I11, 32, rx469_tgt, $I10
    unless $I11, rx469_fail
    inc rx469_pos
  # rx subrule "ws" subtype=method negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."ws"()
    unless $P10, rx469_fail
    rx469_pos = $P10."pos"()
.annotate 'line', 217
  # rx subrule "xblock" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."xblock"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx469_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."ws"()
    unless $P10, rx469_fail
    rx469_pos = $P10."pos"()
.annotate 'line', 215
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "statement_control:sym<while>")
    if_null rx469_debug, debug_746
    rx469_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx469_pos)
  debug_746:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 10
    if_null rx469_debug, debug_747
    rx469_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_747:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_748
    rx469_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_748:
    .return (rx469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303857440.612") :method
.annotate 'line', 10
    new $P471, "ResizablePMCArray"
    push $P471, "until"
    push $P471, "while"
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx478_tgt
    .local int rx478_pos
    .local int rx478_off
    .local int rx478_eos
    .local int rx478_rep
    .local pmc rx478_cur
    .local pmc rx478_debug
    (rx478_cur, rx478_pos, rx478_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx478_cur
    .local pmc match
    .lex "$/", match
    length rx478_eos, rx478_tgt
    gt rx478_pos, rx478_eos, rx478_done
    set rx478_off, 0
    lt rx478_pos, 2, rx478_start
    sub rx478_off, rx478_pos, 1
    substr rx478_tgt, rx478_tgt, rx478_off
  rx478_start:
    eq $I10, 1, rx478_restart
    if_null rx478_debug, debug_749
    rx478_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_749:
    $I10 = self.'from'()
    ne $I10, -1, rxscan481_done
    goto rxscan481_scan
  rxscan481_loop:
    (rx478_pos) = rx478_cur."from"()
    inc rx478_pos
    rx478_cur."!cursor_from"(rx478_pos)
    ge rx478_pos, rx478_eos, rxscan481_done
  rxscan481_scan:
    set_addr $I10, rxscan481_loop
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  rxscan481_done:
.annotate 'line', 221
  # rx subcapture "sym"
    set_addr $I10, rxcap_482_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx478_pos, 6
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 6
    ne $S10, "repeat", rx478_fail
    add rx478_pos, 6
    set_addr $I10, rxcap_482_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_482_done
  rxcap_482_fail:
    goto rx478_fail
  rxcap_482_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  alt484_0:
.annotate 'line', 222
    set_addr $I10, alt484_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_487_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  alt486_0:
    set_addr $I10, alt486_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "while"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "while", rx478_fail
    add rx478_pos, 5
    goto alt486_end
  alt486_1:
  # rx literal  "until"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "until", rx478_fail
    add rx478_pos, 5
  alt486_end:
    set_addr $I10, rxcap_487_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_487_done
  rxcap_487_fail:
    goto rx478_fail
  rxcap_487_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."xblock"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
    goto alt484_end
  alt484_1:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."pblock"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_493_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  alt492_0:
    set_addr $I10, alt492_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "while"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "while", rx478_fail
    add rx478_pos, 5
    goto alt492_end
  alt492_1:
  # rx literal  "until"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "until", rx478_fail
    add rx478_pos, 5
  alt492_end:
    set_addr $I10, rxcap_493_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_493_done
  rxcap_493_fail:
    goto rx478_fail
  rxcap_493_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."EXPR"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  alt484_end:
.annotate 'line', 225
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
.annotate 'line', 220
  # rx pass
    rx478_cur."!cursor_pass"(rx478_pos, "statement_control:sym<repeat>")
    if_null rx478_debug, debug_750
    rx478_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx478_pos)
  debug_750:
    .return (rx478_cur)
  rx478_restart:
.annotate 'line', 10
    if_null rx478_debug, debug_751
    rx478_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_751:
  rx478_fail:
    (rx478_rep, rx478_pos, $I10, $P10) = rx478_cur."!mark_fail"(0)
    lt rx478_pos, -1, rx478_done
    eq rx478_pos, -1, rx478_fail
    jump $I10
  rx478_done:
    rx478_cur."!cursor_fail"()
    if_null rx478_debug, debug_752
    rx478_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_752:
    .return (rx478_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303857440.612") :method
.annotate 'line', 10
    new $P480, "ResizablePMCArray"
    push $P480, "repeat"
    .return ($P480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx498_tgt
    .local int rx498_pos
    .local int rx498_off
    .local int rx498_eos
    .local int rx498_rep
    .local pmc rx498_cur
    .local pmc rx498_debug
    (rx498_cur, rx498_pos, rx498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx498_cur
    .local pmc match
    .lex "$/", match
    length rx498_eos, rx498_tgt
    gt rx498_pos, rx498_eos, rx498_done
    set rx498_off, 0
    lt rx498_pos, 2, rx498_start
    sub rx498_off, rx498_pos, 1
    substr rx498_tgt, rx498_tgt, rx498_off
  rx498_start:
    eq $I10, 1, rx498_restart
    if_null rx498_debug, debug_753
    rx498_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_753:
    $I10 = self.'from'()
    ne $I10, -1, rxscan501_done
    goto rxscan501_scan
  rxscan501_loop:
    (rx498_pos) = rx498_cur."from"()
    inc rx498_pos
    rx498_cur."!cursor_from"(rx498_pos)
    ge rx498_pos, rx498_eos, rxscan501_done
  rxscan501_scan:
    set_addr $I10, rxscan501_loop
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  rxscan501_done:
.annotate 'line', 229
  # rx subcapture "sym"
    set_addr $I10, rxcap_502_fail
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  # rx literal  "for"
    add $I11, rx498_pos, 3
    gt $I11, rx498_eos, rx498_fail
    sub $I11, rx498_pos, rx498_off
    substr $S10, rx498_tgt, $I11, 3
    ne $S10, "for", rx498_fail
    add rx498_pos, 3
    set_addr $I10, rxcap_502_fail
    ($I12, $I11) = rx498_cur."!mark_peek"($I10)
    rx498_cur."!cursor_pos"($I11)
    ($P10) = rx498_cur."!cursor_start"()
    $P10."!cursor_pass"(rx498_pos, "")
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_502_done
  rxcap_502_fail:
    goto rx498_fail
  rxcap_502_done:
  # rx charclass s
    ge rx498_pos, rx498_eos, rx498_fail
    sub $I10, rx498_pos, rx498_off
    is_cclass $I11, 32, rx498_tgt, $I10
    unless $I11, rx498_fail
    inc rx498_pos
  # rx subrule "ws" subtype=method negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."ws"()
    unless $P10, rx498_fail
    rx498_pos = $P10."pos"()
.annotate 'line', 230
  # rx subrule "xblock" subtype=capture negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."xblock"()
    unless $P10, rx498_fail
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx498_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."ws"()
    unless $P10, rx498_fail
    rx498_pos = $P10."pos"()
.annotate 'line', 228
  # rx pass
    rx498_cur."!cursor_pass"(rx498_pos, "statement_control:sym<for>")
    if_null rx498_debug, debug_754
    rx498_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx498_pos)
  debug_754:
    .return (rx498_cur)
  rx498_restart:
.annotate 'line', 10
    if_null rx498_debug, debug_755
    rx498_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_755:
  rx498_fail:
    (rx498_rep, rx498_pos, $I10, $P10) = rx498_cur."!mark_fail"(0)
    lt rx498_pos, -1, rx498_done
    eq rx498_pos, -1, rx498_fail
    jump $I10
  rx498_done:
    rx498_cur."!cursor_fail"()
    if_null rx498_debug, debug_756
    rx498_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_756:
    .return (rx498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303857440.612") :method
.annotate 'line', 10
    new $P500, "ResizablePMCArray"
    push $P500, "for"
    .return ($P500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_757
    rx506_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_757:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan509_done:
.annotate 'line', 234
  # rx subcapture "sym"
    set_addr $I10, rxcap_510_fail
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx506_pos, 5
    gt $I11, rx506_eos, rx506_fail
    sub $I11, rx506_pos, rx506_off
    substr $S10, rx506_tgt, $I11, 5
    ne $S10, "CATCH", rx506_fail
    add rx506_pos, 5
    set_addr $I10, rxcap_510_fail
    ($I12, $I11) = rx506_cur."!mark_peek"($I10)
    rx506_cur."!cursor_pos"($I11)
    ($P10) = rx506_cur."!cursor_start"()
    $P10."!cursor_pass"(rx506_pos, "")
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_510_done
  rxcap_510_fail:
    goto rx506_fail
  rxcap_510_done:
  # rx charclass s
    ge rx506_pos, rx506_eos, rx506_fail
    sub $I10, rx506_pos, rx506_off
    is_cclass $I11, 32, rx506_tgt, $I10
    unless $I11, rx506_fail
    inc rx506_pos
  # rx subrule "ws" subtype=method negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."ws"()
    unless $P10, rx506_fail
    rx506_pos = $P10."pos"()
.annotate 'line', 235
  # rx subrule "block" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."block"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx506_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."ws"()
    unless $P10, rx506_fail
    rx506_pos = $P10."pos"()
.annotate 'line', 233
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "statement_control:sym<CATCH>")
    if_null rx506_debug, debug_758
    rx506_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx506_pos)
  debug_758:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 10
    if_null rx506_debug, debug_759
    rx506_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_759:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_760
    rx506_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_760:
    .return (rx506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303857440.612") :method
.annotate 'line', 10
    new $P508, "ResizablePMCArray"
    push $P508, "CATCH"
    .return ($P508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_761
    rx514_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_761:
    $I10 = self.'from'()
    ne $I10, -1, rxscan517_done
    goto rxscan517_scan
  rxscan517_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan517_done
  rxscan517_scan:
    set_addr $I10, rxscan517_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan517_done:
.annotate 'line', 239
  # rx subcapture "sym"
    set_addr $I10, rxcap_518_fail
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx514_pos, 7
    gt $I11, rx514_eos, rx514_fail
    sub $I11, rx514_pos, rx514_off
    substr $S10, rx514_tgt, $I11, 7
    ne $S10, "CONTROL", rx514_fail
    add rx514_pos, 7
    set_addr $I10, rxcap_518_fail
    ($I12, $I11) = rx514_cur."!mark_peek"($I10)
    rx514_cur."!cursor_pos"($I11)
    ($P10) = rx514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx514_pos, "")
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_518_done
  rxcap_518_fail:
    goto rx514_fail
  rxcap_518_done:
  # rx charclass s
    ge rx514_pos, rx514_eos, rx514_fail
    sub $I10, rx514_pos, rx514_off
    is_cclass $I11, 32, rx514_tgt, $I10
    unless $I11, rx514_fail
    inc rx514_pos
  # rx subrule "ws" subtype=method negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."ws"()
    unless $P10, rx514_fail
    rx514_pos = $P10."pos"()
.annotate 'line', 240
  # rx subrule "block" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."block"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx514_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."ws"()
    unless $P10, rx514_fail
    rx514_pos = $P10."pos"()
.annotate 'line', 238
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "statement_control:sym<CONTROL>")
    if_null rx514_debug, debug_762
    rx514_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx514_pos)
  debug_762:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 10
    if_null rx514_debug, debug_763
    rx514_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_763:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_764
    rx514_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_764:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303857440.612") :method
.annotate 'line', 10
    new $P516, "ResizablePMCArray"
    push $P516, "CONTROL"
    .return ($P516)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303857440.612")
    .param pmc param_522
.annotate 'line', 243
    .lex "self", param_522
    $P523 = param_522."!protoregex"("statement_prefix")
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303857440.612")
    .param pmc param_525
.annotate 'line', 243
    .lex "self", param_525
    $P526 = param_525."!PREFIX__!protoregex"("statement_prefix")
    .return ($P526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx528_tgt
    .local int rx528_pos
    .local int rx528_off
    .local int rx528_eos
    .local int rx528_rep
    .local pmc rx528_cur
    .local pmc rx528_debug
    (rx528_cur, rx528_pos, rx528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx528_cur
    .local pmc match
    .lex "$/", match
    length rx528_eos, rx528_tgt
    gt rx528_pos, rx528_eos, rx528_done
    set rx528_off, 0
    lt rx528_pos, 2, rx528_start
    sub rx528_off, rx528_pos, 1
    substr rx528_tgt, rx528_tgt, rx528_off
  rx528_start:
    eq $I10, 1, rx528_restart
    if_null rx528_debug, debug_765
    rx528_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_765:
    $I10 = self.'from'()
    ne $I10, -1, rxscan532_done
    goto rxscan532_scan
  rxscan532_loop:
    (rx528_pos) = rx528_cur."from"()
    inc rx528_pos
    rx528_cur."!cursor_from"(rx528_pos)
    ge rx528_pos, rx528_eos, rxscan532_done
  rxscan532_scan:
    set_addr $I10, rxscan532_loop
    rx528_cur."!mark_push"(0, rx528_pos, $I10)
  rxscan532_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_533_fail
    rx528_cur."!mark_push"(0, rx528_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx528_pos, 4
    gt $I11, rx528_eos, rx528_fail
    sub $I11, rx528_pos, rx528_off
    substr $S10, rx528_tgt, $I11, 4
    ne $S10, "INIT", rx528_fail
    add rx528_pos, 4
    set_addr $I10, rxcap_533_fail
    ($I12, $I11) = rx528_cur."!mark_peek"($I10)
    rx528_cur."!cursor_pos"($I11)
    ($P10) = rx528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx528_pos, "")
    rx528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_533_done
  rxcap_533_fail:
    goto rx528_fail
  rxcap_533_done:
  # rx subrule "blorst" subtype=capture negate=
    rx528_cur."!cursor_pos"(rx528_pos)
    $P10 = rx528_cur."blorst"()
    unless $P10, rx528_fail
    rx528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx528_pos = $P10."pos"()
  # rx pass
    rx528_cur."!cursor_pass"(rx528_pos, "statement_prefix:sym<INIT>")
    if_null rx528_debug, debug_766
    rx528_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx528_pos)
  debug_766:
    .return (rx528_cur)
  rx528_restart:
.annotate 'line', 10
    if_null rx528_debug, debug_767
    rx528_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_767:
  rx528_fail:
    (rx528_rep, rx528_pos, $I10, $P10) = rx528_cur."!mark_fail"(0)
    lt rx528_pos, -1, rx528_done
    eq rx528_pos, -1, rx528_fail
    jump $I10
  rx528_done:
    rx528_cur."!cursor_fail"()
    if_null rx528_debug, debug_768
    rx528_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_768:
    .return (rx528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303857440.612") :method
.annotate 'line', 10
    $P530 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P531, "ResizablePMCArray"
    push $P531, $P530
    .return ($P531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx535_tgt
    .local int rx535_pos
    .local int rx535_off
    .local int rx535_eos
    .local int rx535_rep
    .local pmc rx535_cur
    .local pmc rx535_debug
    (rx535_cur, rx535_pos, rx535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx535_cur
    .local pmc match
    .lex "$/", match
    length rx535_eos, rx535_tgt
    gt rx535_pos, rx535_eos, rx535_done
    set rx535_off, 0
    lt rx535_pos, 2, rx535_start
    sub rx535_off, rx535_pos, 1
    substr rx535_tgt, rx535_tgt, rx535_off
  rx535_start:
    eq $I10, 1, rx535_restart
    if_null rx535_debug, debug_769
    rx535_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_769:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    (rx535_pos) = rx535_cur."from"()
    inc rx535_pos
    rx535_cur."!cursor_from"(rx535_pos)
    ge rx535_pos, rx535_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  rxscan539_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_540_fail
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  # rx literal  "try"
    add $I11, rx535_pos, 3
    gt $I11, rx535_eos, rx535_fail
    sub $I11, rx535_pos, rx535_off
    substr $S10, rx535_tgt, $I11, 3
    ne $S10, "try", rx535_fail
    add rx535_pos, 3
    set_addr $I10, rxcap_540_fail
    ($I12, $I11) = rx535_cur."!mark_peek"($I10)
    rx535_cur."!cursor_pos"($I11)
    ($P10) = rx535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx535_pos, "")
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_540_done
  rxcap_540_fail:
    goto rx535_fail
  rxcap_540_done:
.annotate 'line', 248
  # rx subrule "blorst" subtype=capture negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    $P10 = rx535_cur."blorst"()
    unless $P10, rx535_fail
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx535_pos = $P10."pos"()
.annotate 'line', 246
  # rx pass
    rx535_cur."!cursor_pass"(rx535_pos, "statement_prefix:sym<try>")
    if_null rx535_debug, debug_770
    rx535_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx535_pos)
  debug_770:
    .return (rx535_cur)
  rx535_restart:
.annotate 'line', 10
    if_null rx535_debug, debug_771
    rx535_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_771:
  rx535_fail:
    (rx535_rep, rx535_pos, $I10, $P10) = rx535_cur."!mark_fail"(0)
    lt rx535_pos, -1, rx535_done
    eq rx535_pos, -1, rx535_fail
    jump $I10
  rx535_done:
    rx535_cur."!cursor_fail"()
    if_null rx535_debug, debug_772
    rx535_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_772:
    .return (rx535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303857440.612") :method
.annotate 'line', 10
    $P537 = self."!PREFIX__!subrule"("blorst", "try")
    new $P538, "ResizablePMCArray"
    push $P538, $P537
    .return ($P538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_773
    rx542_cur."!cursor_debug"("START", "blorst")
  debug_773:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan545_done:
.annotate 'line', 252
  # rx charclass s
    ge rx542_pos, rx542_eos, rx542_fail
    sub $I10, rx542_pos, rx542_off
    is_cclass $I11, 32, rx542_tgt, $I10
    unless $I11, rx542_fail
    inc rx542_pos
  # rx subrule "ws" subtype=method negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."ws"()
    unless $P10, rx542_fail
    rx542_pos = $P10."pos"()
  alt546_0:
    set_addr $I10, alt546_1
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx542_pos, rx542_off
    substr $S10, rx542_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx542_fail
  # rx subrule "block" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."block"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx542_pos = $P10."pos"()
    goto alt546_end
  alt546_1:
  # rx subrule "statement" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."statement"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx542_pos = $P10."pos"()
  alt546_end:
.annotate 'line', 251
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "blorst")
    if_null rx542_debug, debug_774
    rx542_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx542_pos)
  debug_774:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 10
    if_null rx542_debug, debug_775
    rx542_cur."!cursor_debug"("NEXT", "blorst")
  debug_775:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_776
    rx542_cur."!cursor_debug"("FAIL", "blorst")
  debug_776:
    .return (rx542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303857440.612") :method
.annotate 'line', 10
    new $P544, "ResizablePMCArray"
    push $P544, ""
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303857440.612")
    .param pmc param_548
.annotate 'line', 257
    .lex "self", param_548
    $P549 = param_548."!protoregex"("statement_mod_cond")
    .return ($P549)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303857440.612")
    .param pmc param_551
.annotate 'line', 257
    .lex "self", param_551
    $P552 = param_551."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_777
    rx554_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_777:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    (rx554_pos) = rx554_cur."from"()
    inc rx554_pos
    rx554_cur."!cursor_from"(rx554_pos)
    ge rx554_pos, rx554_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan558_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_559_fail
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  # rx literal  "if"
    add $I11, rx554_pos, 2
    gt $I11, rx554_eos, rx554_fail
    sub $I11, rx554_pos, rx554_off
    substr $S10, rx554_tgt, $I11, 2
    ne $S10, "if", rx554_fail
    add rx554_pos, 2
    set_addr $I10, rxcap_559_fail
    ($I12, $I11) = rx554_cur."!mark_peek"($I10)
    rx554_cur."!cursor_pos"($I11)
    ($P10) = rx554_cur."!cursor_start"()
    $P10."!cursor_pass"(rx554_pos, "")
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_559_done
  rxcap_559_fail:
    goto rx554_fail
  rxcap_559_done:
  # rx subrule "ws" subtype=method negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."ws"()
    unless $P10, rx554_fail
    rx554_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."EXPR"()
    unless $P10, rx554_fail
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx554_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."ws"()
    unless $P10, rx554_fail
    rx554_pos = $P10."pos"()
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "statement_mod_cond:sym<if>")
    if_null rx554_debug, debug_778
    rx554_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx554_pos)
  debug_778:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 10
    if_null rx554_debug, debug_779
    rx554_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_779:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_780
    rx554_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_780:
    .return (rx554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303857440.612") :method
.annotate 'line', 10
    $P556 = self."!PREFIX__!subrule"("ws", "if")
    new $P557, "ResizablePMCArray"
    push $P557, $P556
    .return ($P557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx563_tgt
    .local int rx563_pos
    .local int rx563_off
    .local int rx563_eos
    .local int rx563_rep
    .local pmc rx563_cur
    .local pmc rx563_debug
    (rx563_cur, rx563_pos, rx563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx563_cur
    .local pmc match
    .lex "$/", match
    length rx563_eos, rx563_tgt
    gt rx563_pos, rx563_eos, rx563_done
    set rx563_off, 0
    lt rx563_pos, 2, rx563_start
    sub rx563_off, rx563_pos, 1
    substr rx563_tgt, rx563_tgt, rx563_off
  rx563_start:
    eq $I10, 1, rx563_restart
    if_null rx563_debug, debug_781
    rx563_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_781:
    $I10 = self.'from'()
    ne $I10, -1, rxscan567_done
    goto rxscan567_scan
  rxscan567_loop:
    (rx563_pos) = rx563_cur."from"()
    inc rx563_pos
    rx563_cur."!cursor_from"(rx563_pos)
    ge rx563_pos, rx563_eos, rxscan567_done
  rxscan567_scan:
    set_addr $I10, rxscan567_loop
    rx563_cur."!mark_push"(0, rx563_pos, $I10)
  rxscan567_done:
.annotate 'line', 260
  # rx subcapture "sym"
    set_addr $I10, rxcap_568_fail
    rx563_cur."!mark_push"(0, rx563_pos, $I10)
  # rx literal  "unless"
    add $I11, rx563_pos, 6
    gt $I11, rx563_eos, rx563_fail
    sub $I11, rx563_pos, rx563_off
    substr $S10, rx563_tgt, $I11, 6
    ne $S10, "unless", rx563_fail
    add rx563_pos, 6
    set_addr $I10, rxcap_568_fail
    ($I12, $I11) = rx563_cur."!mark_peek"($I10)
    rx563_cur."!cursor_pos"($I11)
    ($P10) = rx563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx563_pos, "")
    rx563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_568_done
  rxcap_568_fail:
    goto rx563_fail
  rxcap_568_done:
  # rx subrule "ws" subtype=method negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."ws"()
    unless $P10, rx563_fail
    rx563_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."EXPR"()
    unless $P10, rx563_fail
    rx563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx563_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."ws"()
    unless $P10, rx563_fail
    rx563_pos = $P10."pos"()
  # rx pass
    rx563_cur."!cursor_pass"(rx563_pos, "statement_mod_cond:sym<unless>")
    if_null rx563_debug, debug_782
    rx563_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx563_pos)
  debug_782:
    .return (rx563_cur)
  rx563_restart:
.annotate 'line', 10
    if_null rx563_debug, debug_783
    rx563_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_783:
  rx563_fail:
    (rx563_rep, rx563_pos, $I10, $P10) = rx563_cur."!mark_fail"(0)
    lt rx563_pos, -1, rx563_done
    eq rx563_pos, -1, rx563_fail
    jump $I10
  rx563_done:
    rx563_cur."!cursor_fail"()
    if_null rx563_debug, debug_784
    rx563_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_784:
    .return (rx563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303857440.612") :method
.annotate 'line', 10
    $P565 = self."!PREFIX__!subrule"("ws", "unless")
    new $P566, "ResizablePMCArray"
    push $P566, $P565
    .return ($P566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303857440.612")
    .param pmc param_572
.annotate 'line', 262
    .lex "self", param_572
    $P573 = param_572."!protoregex"("statement_mod_loop")
    .return ($P573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303857440.612")
    .param pmc param_575
.annotate 'line', 262
    .lex "self", param_575
    $P576 = param_575."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx578_tgt
    .local int rx578_pos
    .local int rx578_off
    .local int rx578_eos
    .local int rx578_rep
    .local pmc rx578_cur
    .local pmc rx578_debug
    (rx578_cur, rx578_pos, rx578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx578_cur
    .local pmc match
    .lex "$/", match
    length rx578_eos, rx578_tgt
    gt rx578_pos, rx578_eos, rx578_done
    set rx578_off, 0
    lt rx578_pos, 2, rx578_start
    sub rx578_off, rx578_pos, 1
    substr rx578_tgt, rx578_tgt, rx578_off
  rx578_start:
    eq $I10, 1, rx578_restart
    if_null rx578_debug, debug_785
    rx578_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_785:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx578_pos) = rx578_cur."from"()
    inc rx578_pos
    rx578_cur."!cursor_from"(rx578_pos)
    ge rx578_pos, rx578_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  rxscan582_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_583_fail
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  # rx literal  "while"
    add $I11, rx578_pos, 5
    gt $I11, rx578_eos, rx578_fail
    sub $I11, rx578_pos, rx578_off
    substr $S10, rx578_tgt, $I11, 5
    ne $S10, "while", rx578_fail
    add rx578_pos, 5
    set_addr $I10, rxcap_583_fail
    ($I12, $I11) = rx578_cur."!mark_peek"($I10)
    rx578_cur."!cursor_pos"($I11)
    ($P10) = rx578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx578_pos, "")
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_583_done
  rxcap_583_fail:
    goto rx578_fail
  rxcap_583_done:
  # rx subrule "ws" subtype=method negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."ws"()
    unless $P10, rx578_fail
    rx578_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."EXPR"()
    unless $P10, rx578_fail
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx578_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."ws"()
    unless $P10, rx578_fail
    rx578_pos = $P10."pos"()
  # rx pass
    rx578_cur."!cursor_pass"(rx578_pos, "statement_mod_loop:sym<while>")
    if_null rx578_debug, debug_786
    rx578_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx578_pos)
  debug_786:
    .return (rx578_cur)
  rx578_restart:
.annotate 'line', 10
    if_null rx578_debug, debug_787
    rx578_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_787:
  rx578_fail:
    (rx578_rep, rx578_pos, $I10, $P10) = rx578_cur."!mark_fail"(0)
    lt rx578_pos, -1, rx578_done
    eq rx578_pos, -1, rx578_fail
    jump $I10
  rx578_done:
    rx578_cur."!cursor_fail"()
    if_null rx578_debug, debug_788
    rx578_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_788:
    .return (rx578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303857440.612") :method
.annotate 'line', 10
    $P580 = self."!PREFIX__!subrule"("ws", "while")
    new $P581, "ResizablePMCArray"
    push $P581, $P580
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx587_tgt
    .local int rx587_pos
    .local int rx587_off
    .local int rx587_eos
    .local int rx587_rep
    .local pmc rx587_cur
    .local pmc rx587_debug
    (rx587_cur, rx587_pos, rx587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx587_cur
    .local pmc match
    .lex "$/", match
    length rx587_eos, rx587_tgt
    gt rx587_pos, rx587_eos, rx587_done
    set rx587_off, 0
    lt rx587_pos, 2, rx587_start
    sub rx587_off, rx587_pos, 1
    substr rx587_tgt, rx587_tgt, rx587_off
  rx587_start:
    eq $I10, 1, rx587_restart
    if_null rx587_debug, debug_789
    rx587_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_789:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx587_pos) = rx587_cur."from"()
    inc rx587_pos
    rx587_cur."!cursor_from"(rx587_pos)
    ge rx587_pos, rx587_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  rxscan591_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_592_fail
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  # rx literal  "until"
    add $I11, rx587_pos, 5
    gt $I11, rx587_eos, rx587_fail
    sub $I11, rx587_pos, rx587_off
    substr $S10, rx587_tgt, $I11, 5
    ne $S10, "until", rx587_fail
    add rx587_pos, 5
    set_addr $I10, rxcap_592_fail
    ($I12, $I11) = rx587_cur."!mark_peek"($I10)
    rx587_cur."!cursor_pos"($I11)
    ($P10) = rx587_cur."!cursor_start"()
    $P10."!cursor_pass"(rx587_pos, "")
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_592_done
  rxcap_592_fail:
    goto rx587_fail
  rxcap_592_done:
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."EXPR"()
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx587_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx pass
    rx587_cur."!cursor_pass"(rx587_pos, "statement_mod_loop:sym<until>")
    if_null rx587_debug, debug_790
    rx587_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx587_pos)
  debug_790:
    .return (rx587_cur)
  rx587_restart:
.annotate 'line', 10
    if_null rx587_debug, debug_791
    rx587_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_791:
  rx587_fail:
    (rx587_rep, rx587_pos, $I10, $P10) = rx587_cur."!mark_fail"(0)
    lt rx587_pos, -1, rx587_done
    eq rx587_pos, -1, rx587_fail
    jump $I10
  rx587_done:
    rx587_cur."!cursor_fail"()
    if_null rx587_debug, debug_792
    rx587_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_792:
    .return (rx587_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303857440.612") :method
.annotate 'line', 10
    $P589 = self."!PREFIX__!subrule"("ws", "until")
    new $P590, "ResizablePMCArray"
    push $P590, $P589
    .return ($P590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx596_tgt
    .local int rx596_pos
    .local int rx596_off
    .local int rx596_eos
    .local int rx596_rep
    .local pmc rx596_cur
    .local pmc rx596_debug
    (rx596_cur, rx596_pos, rx596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx596_cur
    .local pmc match
    .lex "$/", match
    length rx596_eos, rx596_tgt
    gt rx596_pos, rx596_eos, rx596_done
    set rx596_off, 0
    lt rx596_pos, 2, rx596_start
    sub rx596_off, rx596_pos, 1
    substr rx596_tgt, rx596_tgt, rx596_off
  rx596_start:
    eq $I10, 1, rx596_restart
    if_null rx596_debug, debug_793
    rx596_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_793:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx596_pos) = rx596_cur."from"()
    inc rx596_pos
    rx596_cur."!cursor_from"(rx596_pos)
    ge rx596_pos, rx596_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  rxscan600_done:
.annotate 'line', 266
  # rx subcapture "sym"
    set_addr $I10, rxcap_601_fail
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  # rx literal  "for"
    add $I11, rx596_pos, 3
    gt $I11, rx596_eos, rx596_fail
    sub $I11, rx596_pos, rx596_off
    substr $S10, rx596_tgt, $I11, 3
    ne $S10, "for", rx596_fail
    add rx596_pos, 3
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx596_cur."!mark_peek"($I10)
    rx596_cur."!cursor_pos"($I11)
    ($P10) = rx596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx596_pos, "")
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx596_fail
  rxcap_601_done:
  # rx subrule "ws" subtype=method negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."ws"()
    unless $P10, rx596_fail
    rx596_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."EXPR"()
    unless $P10, rx596_fail
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx596_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."ws"()
    unless $P10, rx596_fail
    rx596_pos = $P10."pos"()
  # rx pass
    rx596_cur."!cursor_pass"(rx596_pos, "statement_mod_loop:sym<for>")
    if_null rx596_debug, debug_794
    rx596_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx596_pos)
  debug_794:
    .return (rx596_cur)
  rx596_restart:
.annotate 'line', 10
    if_null rx596_debug, debug_795
    rx596_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_795:
  rx596_fail:
    (rx596_rep, rx596_pos, $I10, $P10) = rx596_cur."!mark_fail"(0)
    lt rx596_pos, -1, rx596_done
    eq rx596_pos, -1, rx596_fail
    jump $I10
  rx596_done:
    rx596_cur."!cursor_fail"()
    if_null rx596_debug, debug_796
    rx596_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_796:
    .return (rx596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303857440.612") :method
.annotate 'line', 10
    $P598 = self."!PREFIX__!subrule"("ws", "for")
    new $P599, "ResizablePMCArray"
    push $P599, $P598
    .return ($P599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_797
    rx605_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_797:
    $I10 = self.'from'()
    ne $I10, -1, rxscan609_done
    goto rxscan609_scan
  rxscan609_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan609_done
  rxscan609_scan:
    set_addr $I10, rxscan609_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan609_done:
.annotate 'line', 270
  # rx subrule "fatarrow" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."fatarrow"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx605_pos = $P10."pos"()
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "term:sym<fatarrow>")
    if_null rx605_debug, debug_798
    rx605_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx605_pos)
  debug_798:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_799
    rx605_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_799:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_800
    rx605_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_800:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303857440.612") :method
.annotate 'line', 10
    $P607 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P608, "ResizablePMCArray"
    push $P608, $P607
    .return ($P608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx611_tgt
    .local int rx611_pos
    .local int rx611_off
    .local int rx611_eos
    .local int rx611_rep
    .local pmc rx611_cur
    .local pmc rx611_debug
    (rx611_cur, rx611_pos, rx611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx611_cur
    .local pmc match
    .lex "$/", match
    length rx611_eos, rx611_tgt
    gt rx611_pos, rx611_eos, rx611_done
    set rx611_off, 0
    lt rx611_pos, 2, rx611_start
    sub rx611_off, rx611_pos, 1
    substr rx611_tgt, rx611_tgt, rx611_off
  rx611_start:
    eq $I10, 1, rx611_restart
    if_null rx611_debug, debug_801
    rx611_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_801:
    $I10 = self.'from'()
    ne $I10, -1, rxscan615_done
    goto rxscan615_scan
  rxscan615_loop:
    (rx611_pos) = rx611_cur."from"()
    inc rx611_pos
    rx611_cur."!cursor_from"(rx611_pos)
    ge rx611_pos, rx611_eos, rxscan615_done
  rxscan615_scan:
    set_addr $I10, rxscan615_loop
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  rxscan615_done:
.annotate 'line', 271
  # rx subrule "colonpair" subtype=capture negate=
    rx611_cur."!cursor_pos"(rx611_pos)
    $P10 = rx611_cur."colonpair"()
    unless $P10, rx611_fail
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx611_pos = $P10."pos"()
  # rx pass
    rx611_cur."!cursor_pass"(rx611_pos, "term:sym<colonpair>")
    if_null rx611_debug, debug_802
    rx611_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx611_pos)
  debug_802:
    .return (rx611_cur)
  rx611_restart:
.annotate 'line', 10
    if_null rx611_debug, debug_803
    rx611_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_803:
  rx611_fail:
    (rx611_rep, rx611_pos, $I10, $P10) = rx611_cur."!mark_fail"(0)
    lt rx611_pos, -1, rx611_done
    eq rx611_pos, -1, rx611_fail
    jump $I10
  rx611_done:
    rx611_cur."!cursor_fail"()
    if_null rx611_debug, debug_804
    rx611_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_804:
    .return (rx611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303857440.612") :method
.annotate 'line', 10
    $P613 = self."!PREFIX__!subrule"("colonpair", "")
    new $P614, "ResizablePMCArray"
    push $P614, $P613
    .return ($P614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_805
    rx617_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_805:
    $I10 = self.'from'()
    ne $I10, -1, rxscan621_done
    goto rxscan621_scan
  rxscan621_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan621_done
  rxscan621_scan:
    set_addr $I10, rxscan621_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan621_done:
.annotate 'line', 272
  # rx subrule "variable" subtype=capture negate=
    rx617_cur."!cursor_pos"(rx617_pos)
    $P10 = rx617_cur."variable"()
    unless $P10, rx617_fail
    rx617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx617_pos = $P10."pos"()
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "term:sym<variable>")
    if_null rx617_debug, debug_806
    rx617_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx617_pos)
  debug_806:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_807
    rx617_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_807:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_808
    rx617_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_808:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303857440.612") :method
.annotate 'line', 10
    $P619 = self."!PREFIX__!subrule"("variable", "")
    new $P620, "ResizablePMCArray"
    push $P620, $P619
    .return ($P620)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_809
    rx623_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_809:
    $I10 = self.'from'()
    ne $I10, -1, rxscan627_done
    goto rxscan627_scan
  rxscan627_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan627_done
  rxscan627_scan:
    set_addr $I10, rxscan627_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan627_done:
.annotate 'line', 273
  # rx subrule "package_declarator" subtype=capture negate=
    rx623_cur."!cursor_pos"(rx623_pos)
    $P10 = rx623_cur."package_declarator"()
    unless $P10, rx623_fail
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx623_pos = $P10."pos"()
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "term:sym<package_declarator>")
    if_null rx623_debug, debug_810
    rx623_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx623_pos)
  debug_810:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 10
    if_null rx623_debug, debug_811
    rx623_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_811:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_812
    rx623_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_812:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303857440.612") :method
.annotate 'line', 10
    $P625 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P626, "ResizablePMCArray"
    push $P626, $P625
    .return ($P626)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx629_tgt
    .local int rx629_pos
    .local int rx629_off
    .local int rx629_eos
    .local int rx629_rep
    .local pmc rx629_cur
    .local pmc rx629_debug
    (rx629_cur, rx629_pos, rx629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx629_cur
    .local pmc match
    .lex "$/", match
    length rx629_eos, rx629_tgt
    gt rx629_pos, rx629_eos, rx629_done
    set rx629_off, 0
    lt rx629_pos, 2, rx629_start
    sub rx629_off, rx629_pos, 1
    substr rx629_tgt, rx629_tgt, rx629_off
  rx629_start:
    eq $I10, 1, rx629_restart
    if_null rx629_debug, debug_813
    rx629_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_813:
    $I10 = self.'from'()
    ne $I10, -1, rxscan633_done
    goto rxscan633_scan
  rxscan633_loop:
    (rx629_pos) = rx629_cur."from"()
    inc rx629_pos
    rx629_cur."!cursor_from"(rx629_pos)
    ge rx629_pos, rx629_eos, rxscan633_done
  rxscan633_scan:
    set_addr $I10, rxscan633_loop
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxscan633_done:
.annotate 'line', 274
  # rx subrule "scope_declarator" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."scope_declarator"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx629_pos = $P10."pos"()
  # rx pass
    rx629_cur."!cursor_pass"(rx629_pos, "term:sym<scope_declarator>")
    if_null rx629_debug, debug_814
    rx629_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx629_pos)
  debug_814:
    .return (rx629_cur)
  rx629_restart:
.annotate 'line', 10
    if_null rx629_debug, debug_815
    rx629_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_815:
  rx629_fail:
    (rx629_rep, rx629_pos, $I10, $P10) = rx629_cur."!mark_fail"(0)
    lt rx629_pos, -1, rx629_done
    eq rx629_pos, -1, rx629_fail
    jump $I10
  rx629_done:
    rx629_cur."!cursor_fail"()
    if_null rx629_debug, debug_816
    rx629_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_816:
    .return (rx629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303857440.612") :method
.annotate 'line', 10
    $P631 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P632, "ResizablePMCArray"
    push $P632, $P631
    .return ($P632)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_817
    rx635_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_817:
    $I10 = self.'from'()
    ne $I10, -1, rxscan639_done
    goto rxscan639_scan
  rxscan639_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan639_done
  rxscan639_scan:
    set_addr $I10, rxscan639_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan639_done:
.annotate 'line', 275
  # rx subrule "routine_declarator" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."routine_declarator"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx635_pos = $P10."pos"()
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "term:sym<routine_declarator>")
    if_null rx635_debug, debug_818
    rx635_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx635_pos)
  debug_818:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_819
    rx635_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_819:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_820
    rx635_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_820:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303857440.612") :method
.annotate 'line', 10
    $P637 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P638, "ResizablePMCArray"
    push $P638, $P637
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P651 = "121_1303857440.612" 
    capture_lex $P651
    .const 'Sub' $P646 = "120_1303857440.612" 
    capture_lex $P646
    .local string rx641_tgt
    .local int rx641_pos
    .local int rx641_off
    .local int rx641_eos
    .local int rx641_rep
    .local pmc rx641_cur
    .local pmc rx641_debug
    (rx641_cur, rx641_pos, rx641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx641_cur
    .local pmc match
    .lex "$/", match
    length rx641_eos, rx641_tgt
    gt rx641_pos, rx641_eos, rx641_done
    set rx641_off, 0
    lt rx641_pos, 2, rx641_start
    sub rx641_off, rx641_pos, 1
    substr rx641_tgt, rx641_tgt, rx641_off
  rx641_start:
    eq $I10, 1, rx641_restart
    if_null rx641_debug, debug_821
    rx641_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx641_pos) = rx641_cur."from"()
    inc rx641_pos
    rx641_cur."!cursor_from"(rx641_pos)
    ge rx641_pos, rx641_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx641_cur."!mark_push"(0, rx641_pos, $I10)
  rxscan644_done:
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=
    rx641_cur."!cursor_pos"(rx641_pos)
    .const 'Sub' $P646 = "120_1303857440.612" 
    capture_lex $P646
    $P10 = rx641_cur."before"($P646)
    unless $P10, rx641_fail
.annotate 'line', 278
  # rx subrule "before" subtype=zerowidth negate=1
    rx641_cur."!cursor_pos"(rx641_pos)
    .const 'Sub' $P651 = "121_1303857440.612" 
    capture_lex $P651
    $P10 = rx641_cur."before"($P651)
    if $P10, rx641_fail
.annotate 'line', 279
  # rx subrule "multi_declarator" subtype=capture negate=
    rx641_cur."!cursor_pos"(rx641_pos)
    $P10 = rx641_cur."multi_declarator"()
    unless $P10, rx641_fail
    rx641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx641_pos = $P10."pos"()
.annotate 'line', 276
  # rx pass
    rx641_cur."!cursor_pass"(rx641_pos, "term:sym<multi_declarator>")
    if_null rx641_debug, debug_830
    rx641_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx641_pos)
  debug_830:
    .return (rx641_cur)
  rx641_restart:
.annotate 'line', 10
    if_null rx641_debug, debug_831
    rx641_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_831:
  rx641_fail:
    (rx641_rep, rx641_pos, $I10, $P10) = rx641_cur."!mark_fail"(0)
    lt rx641_pos, -1, rx641_done
    eq rx641_pos, -1, rx641_fail
    jump $I10
  rx641_done:
    rx641_cur."!cursor_fail"()
    if_null rx641_debug, debug_832
    rx641_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_832:
    .return (rx641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303857440.612") :method
.annotate 'line', 10
    new $P643, "ResizablePMCArray"
    push $P643, ""
    .return ($P643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block645"  :anon :subid("120_1303857440.612") :method :outer("118_1303857440.612")
.annotate 'line', 277
    .local string rx647_tgt
    .local int rx647_pos
    .local int rx647_off
    .local int rx647_eos
    .local int rx647_rep
    .local pmc rx647_cur
    .local pmc rx647_debug
    (rx647_cur, rx647_pos, rx647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx647_cur
    .local pmc match
    .lex "$/", match
    length rx647_eos, rx647_tgt
    gt rx647_pos, rx647_eos, rx647_done
    set rx647_off, 0
    lt rx647_pos, 2, rx647_start
    sub rx647_off, rx647_pos, 1
    substr rx647_tgt, rx647_tgt, rx647_off
  rx647_start:
    eq $I10, 1, rx647_restart
    if_null rx647_debug, debug_822
    rx647_cur."!cursor_debug"("START", "")
  debug_822:
    $I10 = self.'from'()
    ne $I10, -1, rxscan648_done
    goto rxscan648_scan
  rxscan648_loop:
    (rx647_pos) = rx647_cur."from"()
    inc rx647_pos
    rx647_cur."!cursor_from"(rx647_pos)
    ge rx647_pos, rx647_eos, rxscan648_done
  rxscan648_scan:
    set_addr $I10, rxscan648_loop
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  rxscan648_done:
  alt649_0:
    set_addr $I10, alt649_1
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "multi"
    add $I11, rx647_pos, 5
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 5
    ne $S10, "multi", rx647_fail
    add rx647_pos, 5
    goto alt649_end
  alt649_1:
    set_addr $I10, alt649_2
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "proto"
    add $I11, rx647_pos, 5
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 5
    ne $S10, "proto", rx647_fail
    add rx647_pos, 5
    goto alt649_end
  alt649_2:
  # rx literal  "only"
    add $I11, rx647_pos, 4
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 4
    ne $S10, "only", rx647_fail
    add rx647_pos, 4
  alt649_end:
  # rx pass
    rx647_cur."!cursor_pass"(rx647_pos, "")
    if_null rx647_debug, debug_823
    rx647_cur."!cursor_debug"("PASS", "", " at pos=", rx647_pos)
  debug_823:
    .return (rx647_cur)
  rx647_restart:
    if_null rx647_debug, debug_824
    rx647_cur."!cursor_debug"("NEXT", "")
  debug_824:
  rx647_fail:
    (rx647_rep, rx647_pos, $I10, $P10) = rx647_cur."!mark_fail"(0)
    lt rx647_pos, -1, rx647_done
    eq rx647_pos, -1, rx647_fail
    jump $I10
  rx647_done:
    rx647_cur."!cursor_fail"()
    if_null rx647_debug, debug_825
    rx647_cur."!cursor_debug"("FAIL", "")
  debug_825:
    .return (rx647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block650"  :anon :subid("121_1303857440.612") :method :outer("118_1303857440.612")
.annotate 'line', 278
    .local string rx652_tgt
    .local int rx652_pos
    .local int rx652_off
    .local int rx652_eos
    .local int rx652_rep
    .local pmc rx652_cur
    .local pmc rx652_debug
    (rx652_cur, rx652_pos, rx652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx652_cur
    .local pmc match
    .lex "$/", match
    length rx652_eos, rx652_tgt
    gt rx652_pos, rx652_eos, rx652_done
    set rx652_off, 0
    lt rx652_pos, 2, rx652_start
    sub rx652_off, rx652_pos, 1
    substr rx652_tgt, rx652_tgt, rx652_off
  rx652_start:
    eq $I10, 1, rx652_restart
    if_null rx652_debug, debug_826
    rx652_cur."!cursor_debug"("START", "")
  debug_826:
    $I10 = self.'from'()
    ne $I10, -1, rxscan653_done
    goto rxscan653_scan
  rxscan653_loop:
    (rx652_pos) = rx652_cur."from"()
    inc rx652_pos
    rx652_cur."!cursor_from"(rx652_pos)
    ge rx652_pos, rx652_eos, rxscan653_done
  rxscan653_scan:
    set_addr $I10, rxscan653_loop
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  rxscan653_done:
  # rx literal  "proto"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "proto", rx652_fail
    add rx652_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx652_cur."!cursor_pos"(rx652_pos)
    $P10 = rx652_cur."ws"()
    unless $P10, rx652_fail
    rx652_pos = $P10."pos"()
  alt654_0:
    set_addr $I10, alt654_1
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "regex"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "regex", rx652_fail
    add rx652_pos, 5
    goto alt654_end
  alt654_1:
    set_addr $I10, alt654_2
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "token"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "token", rx652_fail
    add rx652_pos, 5
    goto alt654_end
  alt654_2:
  # rx literal  "rule"
    add $I11, rx652_pos, 4
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 4
    ne $S10, "rule", rx652_fail
    add rx652_pos, 4
  alt654_end:
  # rx pass
    rx652_cur."!cursor_pass"(rx652_pos, "")
    if_null rx652_debug, debug_827
    rx652_cur."!cursor_debug"("PASS", "", " at pos=", rx652_pos)
  debug_827:
    .return (rx652_cur)
  rx652_restart:
    if_null rx652_debug, debug_828
    rx652_cur."!cursor_debug"("NEXT", "")
  debug_828:
  rx652_fail:
    (rx652_rep, rx652_pos, $I10, $P10) = rx652_cur."!mark_fail"(0)
    lt rx652_pos, -1, rx652_done
    eq rx652_pos, -1, rx652_fail
    jump $I10
  rx652_done:
    rx652_cur."!cursor_fail"()
    if_null rx652_debug, debug_829
    rx652_cur."!cursor_debug"("FAIL", "")
  debug_829:
    .return (rx652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx656_tgt
    .local int rx656_pos
    .local int rx656_off
    .local int rx656_eos
    .local int rx656_rep
    .local pmc rx656_cur
    .local pmc rx656_debug
    (rx656_cur, rx656_pos, rx656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx656_cur
    .local pmc match
    .lex "$/", match
    length rx656_eos, rx656_tgt
    gt rx656_pos, rx656_eos, rx656_done
    set rx656_off, 0
    lt rx656_pos, 2, rx656_start
    sub rx656_off, rx656_pos, 1
    substr rx656_tgt, rx656_tgt, rx656_off
  rx656_start:
    eq $I10, 1, rx656_restart
    if_null rx656_debug, debug_833
    rx656_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_833:
    $I10 = self.'from'()
    ne $I10, -1, rxscan660_done
    goto rxscan660_scan
  rxscan660_loop:
    (rx656_pos) = rx656_cur."from"()
    inc rx656_pos
    rx656_cur."!cursor_from"(rx656_pos)
    ge rx656_pos, rx656_eos, rxscan660_done
  rxscan660_scan:
    set_addr $I10, rxscan660_loop
    rx656_cur."!mark_push"(0, rx656_pos, $I10)
  rxscan660_done:
.annotate 'line', 281
  # rx subrule "regex_declarator" subtype=capture negate=
    rx656_cur."!cursor_pos"(rx656_pos)
    $P10 = rx656_cur."regex_declarator"()
    unless $P10, rx656_fail
    rx656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx656_pos = $P10."pos"()
  # rx pass
    rx656_cur."!cursor_pass"(rx656_pos, "term:sym<regex_declarator>")
    if_null rx656_debug, debug_834
    rx656_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx656_pos)
  debug_834:
    .return (rx656_cur)
  rx656_restart:
.annotate 'line', 10
    if_null rx656_debug, debug_835
    rx656_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_835:
  rx656_fail:
    (rx656_rep, rx656_pos, $I10, $P10) = rx656_cur."!mark_fail"(0)
    lt rx656_pos, -1, rx656_done
    eq rx656_pos, -1, rx656_fail
    jump $I10
  rx656_done:
    rx656_cur."!cursor_fail"()
    if_null rx656_debug, debug_836
    rx656_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_836:
    .return (rx656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303857440.612") :method
.annotate 'line', 10
    $P658 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P659, "ResizablePMCArray"
    push $P659, $P658
    .return ($P659)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx662_tgt
    .local int rx662_pos
    .local int rx662_off
    .local int rx662_eos
    .local int rx662_rep
    .local pmc rx662_cur
    .local pmc rx662_debug
    (rx662_cur, rx662_pos, rx662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx662_cur
    .local pmc match
    .lex "$/", match
    length rx662_eos, rx662_tgt
    gt rx662_pos, rx662_eos, rx662_done
    set rx662_off, 0
    lt rx662_pos, 2, rx662_start
    sub rx662_off, rx662_pos, 1
    substr rx662_tgt, rx662_tgt, rx662_off
  rx662_start:
    eq $I10, 1, rx662_restart
    if_null rx662_debug, debug_837
    rx662_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_837:
    $I10 = self.'from'()
    ne $I10, -1, rxscan666_done
    goto rxscan666_scan
  rxscan666_loop:
    (rx662_pos) = rx662_cur."from"()
    inc rx662_pos
    rx662_cur."!cursor_from"(rx662_pos)
    ge rx662_pos, rx662_eos, rxscan666_done
  rxscan666_scan:
    set_addr $I10, rxscan666_loop
    rx662_cur."!mark_push"(0, rx662_pos, $I10)
  rxscan666_done:
.annotate 'line', 282
  # rx subrule "statement_prefix" subtype=capture negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."statement_prefix"()
    unless $P10, rx662_fail
    rx662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx662_pos = $P10."pos"()
  # rx pass
    rx662_cur."!cursor_pass"(rx662_pos, "term:sym<statement_prefix>")
    if_null rx662_debug, debug_838
    rx662_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx662_pos)
  debug_838:
    .return (rx662_cur)
  rx662_restart:
.annotate 'line', 10
    if_null rx662_debug, debug_839
    rx662_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_839:
  rx662_fail:
    (rx662_rep, rx662_pos, $I10, $P10) = rx662_cur."!mark_fail"(0)
    lt rx662_pos, -1, rx662_done
    eq rx662_pos, -1, rx662_fail
    jump $I10
  rx662_done:
    rx662_cur."!cursor_fail"()
    if_null rx662_debug, debug_840
    rx662_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_840:
    .return (rx662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303857440.612") :method
.annotate 'line', 10
    $P664 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P665, "ResizablePMCArray"
    push $P665, $P664
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx668_tgt
    .local int rx668_pos
    .local int rx668_off
    .local int rx668_eos
    .local int rx668_rep
    .local pmc rx668_cur
    .local pmc rx668_debug
    (rx668_cur, rx668_pos, rx668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx668_cur
    .local pmc match
    .lex "$/", match
    length rx668_eos, rx668_tgt
    gt rx668_pos, rx668_eos, rx668_done
    set rx668_off, 0
    lt rx668_pos, 2, rx668_start
    sub rx668_off, rx668_pos, 1
    substr rx668_tgt, rx668_tgt, rx668_off
  rx668_start:
    eq $I10, 1, rx668_restart
    if_null rx668_debug, debug_841
    rx668_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_841:
    $I10 = self.'from'()
    ne $I10, -1, rxscan671_done
    goto rxscan671_scan
  rxscan671_loop:
    (rx668_pos) = rx668_cur."from"()
    inc rx668_pos
    rx668_cur."!cursor_from"(rx668_pos)
    ge rx668_pos, rx668_eos, rxscan671_done
  rxscan671_scan:
    set_addr $I10, rxscan671_loop
    rx668_cur."!mark_push"(0, rx668_pos, $I10)
  rxscan671_done:
.annotate 'line', 283
  # rx subrule "lambda" subtype=zerowidth negate=
    rx668_cur."!cursor_pos"(rx668_pos)
    $P10 = rx668_cur."lambda"()
    unless $P10, rx668_fail
  # rx subrule "pblock" subtype=capture negate=
    rx668_cur."!cursor_pos"(rx668_pos)
    $P10 = rx668_cur."pblock"()
    unless $P10, rx668_fail
    rx668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx668_pos = $P10."pos"()
  # rx pass
    rx668_cur."!cursor_pass"(rx668_pos, "term:sym<lambda>")
    if_null rx668_debug, debug_842
    rx668_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx668_pos)
  debug_842:
    .return (rx668_cur)
  rx668_restart:
.annotate 'line', 10
    if_null rx668_debug, debug_843
    rx668_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_843:
  rx668_fail:
    (rx668_rep, rx668_pos, $I10, $P10) = rx668_cur."!mark_fail"(0)
    lt rx668_pos, -1, rx668_done
    eq rx668_pos, -1, rx668_fail
    jump $I10
  rx668_done:
    rx668_cur."!cursor_fail"()
    if_null rx668_debug, debug_844
    rx668_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_844:
    .return (rx668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303857440.612") :method
.annotate 'line', 10
    new $P670, "ResizablePMCArray"
    push $P670, ""
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx673_tgt
    .local int rx673_pos
    .local int rx673_off
    .local int rx673_eos
    .local int rx673_rep
    .local pmc rx673_cur
    .local pmc rx673_debug
    (rx673_cur, rx673_pos, rx673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx673_cur
    .local pmc match
    .lex "$/", match
    length rx673_eos, rx673_tgt
    gt rx673_pos, rx673_eos, rx673_done
    set rx673_off, 0
    lt rx673_pos, 2, rx673_start
    sub rx673_off, rx673_pos, 1
    substr rx673_tgt, rx673_tgt, rx673_off
  rx673_start:
    eq $I10, 1, rx673_restart
    if_null rx673_debug, debug_845
    rx673_cur."!cursor_debug"("START", "fatarrow")
  debug_845:
    $I10 = self.'from'()
    ne $I10, -1, rxscan677_done
    goto rxscan677_scan
  rxscan677_loop:
    (rx673_pos) = rx673_cur."from"()
    inc rx673_pos
    rx673_cur."!cursor_from"(rx673_pos)
    ge rx673_pos, rx673_eos, rxscan677_done
  rxscan677_scan:
    set_addr $I10, rxscan677_loop
    rx673_cur."!mark_push"(0, rx673_pos, $I10)
  rxscan677_done:
.annotate 'line', 286
  # rx subrule "identifier" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."identifier"()
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx673_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx673_pos, rx673_off
    set rx673_rep, 0
    sub $I12, rx673_eos, rx673_pos
  rxenumcharlistq678_loop:
    le $I12, 0, rxenumcharlistq678_done
    substr $S10, rx673_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq678_done
    inc rx673_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq678_loop
  rxenumcharlistq678_done:
    add rx673_pos, rx673_pos, rx673_rep
  # rx literal  "=>"
    add $I11, rx673_pos, 2
    gt $I11, rx673_eos, rx673_fail
    sub $I11, rx673_pos, rx673_off
    substr $S10, rx673_tgt, $I11, 2
    ne $S10, "=>", rx673_fail
    add rx673_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."EXPR"("i=")
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx673_pos = $P10."pos"()
.annotate 'line', 285
  # rx pass
    rx673_cur."!cursor_pass"(rx673_pos, "fatarrow")
    if_null rx673_debug, debug_846
    rx673_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx673_pos)
  debug_846:
    .return (rx673_cur)
  rx673_restart:
.annotate 'line', 10
    if_null rx673_debug, debug_847
    rx673_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_847:
  rx673_fail:
    (rx673_rep, rx673_pos, $I10, $P10) = rx673_cur."!mark_fail"(0)
    lt rx673_pos, -1, rx673_done
    eq rx673_pos, -1, rx673_fail
    jump $I10
  rx673_done:
    rx673_cur."!cursor_fail"()
    if_null rx673_debug, debug_848
    rx673_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_848:
    .return (rx673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303857440.612") :method
.annotate 'line', 10
    $P675 = self."!PREFIX__!subrule"("identifier", "")
    new $P676, "ResizablePMCArray"
    push $P676, $P675
    .return ($P676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx680_tgt
    .local int rx680_pos
    .local int rx680_off
    .local int rx680_eos
    .local int rx680_rep
    .local pmc rx680_cur
    .local pmc rx680_debug
    (rx680_cur, rx680_pos, rx680_tgt, $I10) = self."!cursor_start"()
    rx680_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx680_cur
    .local pmc match
    .lex "$/", match
    length rx680_eos, rx680_tgt
    gt rx680_pos, rx680_eos, rx680_done
    set rx680_off, 0
    lt rx680_pos, 2, rx680_start
    sub rx680_off, rx680_pos, 1
    substr rx680_tgt, rx680_tgt, rx680_off
  rx680_start:
    eq $I10, 1, rx680_restart
    if_null rx680_debug, debug_849
    rx680_cur."!cursor_debug"("START", "colonpair")
  debug_849:
    $I10 = self.'from'()
    ne $I10, -1, rxscan686_done
    goto rxscan686_scan
  rxscan686_loop:
    (rx680_pos) = rx680_cur."from"()
    inc rx680_pos
    rx680_cur."!cursor_from"(rx680_pos)
    ge rx680_pos, rx680_eos, rxscan686_done
  rxscan686_scan:
    set_addr $I10, rxscan686_loop
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  rxscan686_done:
.annotate 'line', 290
  # rx literal  ":"
    add $I11, rx680_pos, 1
    gt $I11, rx680_eos, rx680_fail
    sub $I11, rx680_pos, rx680_off
    ord $I11, rx680_tgt, $I11
    ne $I11, 58, rx680_fail
    add rx680_pos, 1
  alt687_0:
.annotate 'line', 291
    set_addr $I10, alt687_1
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
.annotate 'line', 292
  # rx subcapture "not"
    set_addr $I10, rxcap_688_fail
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  # rx literal  "!"
    add $I11, rx680_pos, 1
    gt $I11, rx680_eos, rx680_fail
    sub $I11, rx680_pos, rx680_off
    ord $I11, rx680_tgt, $I11
    ne $I11, 33, rx680_fail
    add rx680_pos, 1
    set_addr $I10, rxcap_688_fail
    ($I12, $I11) = rx680_cur."!mark_peek"($I10)
    rx680_cur."!cursor_pos"($I11)
    ($P10) = rx680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx680_pos, "")
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_688_done
  rxcap_688_fail:
    goto rx680_fail
  rxcap_688_done:
  # rx subrule "identifier" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."identifier"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx680_pos = $P10."pos"()
    goto alt687_end
  alt687_1:
    set_addr $I10, alt687_2
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
.annotate 'line', 293
  # rx subrule "identifier" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."identifier"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx680_pos = $P10."pos"()
  # rx rxquantr689 ** 0..1
    set_addr $I10, rxquantr689_done
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  rxquantr689_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."circumfix"()
    unless $P10, rx680_fail
    goto rxsubrule690_pass
  rxsubrule690_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx680_fail
  rxsubrule690_pass:
    set_addr $I10, rxsubrule690_back
    rx680_cur."!mark_push"(0, rx680_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx680_pos = $P10."pos"()
    set_addr $I10, rxquantr689_done
    (rx680_rep) = rx680_cur."!mark_commit"($I10)
  rxquantr689_done:
    goto alt687_end
  alt687_2:
.annotate 'line', 294
  # rx subrule "circumfix" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."circumfix"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx680_pos = $P10."pos"()
  alt687_end:
.annotate 'line', 289
  # rx pass
    rx680_cur."!cursor_pass"(rx680_pos, "colonpair")
    if_null rx680_debug, debug_850
    rx680_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx680_pos)
  debug_850:
    .return (rx680_cur)
  rx680_restart:
.annotate 'line', 10
    if_null rx680_debug, debug_851
    rx680_cur."!cursor_debug"("NEXT", "colonpair")
  debug_851:
  rx680_fail:
    (rx680_rep, rx680_pos, $I10, $P10) = rx680_cur."!mark_fail"(0)
    lt rx680_pos, -1, rx680_done
    eq rx680_pos, -1, rx680_fail
    jump $I10
  rx680_done:
    rx680_cur."!cursor_fail"()
    if_null rx680_debug, debug_852
    rx680_cur."!cursor_debug"("FAIL", "colonpair")
  debug_852:
    .return (rx680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303857440.612") :method
.annotate 'line', 10
    $P682 = self."!PREFIX__!subrule"("circumfix", ":")
    $P683 = self."!PREFIX__!subrule"("identifier", ":")
    $P684 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P685, "ResizablePMCArray"
    push $P685, $P682
    push $P685, $P683
    push $P685, $P684
    .return ($P685)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    rx692_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_853
    rx692_cur."!cursor_debug"("START", "variable")
  debug_853:
    $I10 = self.'from'()
    ne $I10, -1, rxscan697_done
    goto rxscan697_scan
  rxscan697_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan697_done
  rxscan697_scan:
    set_addr $I10, rxscan697_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan697_done:
  alt698_0:
.annotate 'line', 298
    set_addr $I10, alt698_1
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."sigil"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx692_pos = $P10."pos"()
  # rx rxquantr699 ** 0..1
    set_addr $I10, rxquantr699_done
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxquantr699_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."twigil"()
    unless $P10, rx692_fail
    goto rxsubrule700_pass
  rxsubrule700_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx692_fail
  rxsubrule700_pass:
    set_addr $I10, rxsubrule700_back
    rx692_cur."!mark_push"(0, rx692_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx692_pos = $P10."pos"()
    set_addr $I10, rxquantr699_done
    (rx692_rep) = rx692_cur."!mark_commit"($I10)
  rxquantr699_done:
  # rx subrule "name" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."name"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx692_pos = $P10."pos"()
    goto alt698_end
  alt698_1:
    set_addr $I10, alt698_2
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
.annotate 'line', 300
  # rx subrule "sigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."sigil"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx692_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx692_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."postcircumfix"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx692_pos = $P10."pos"()
    goto alt698_end
  alt698_2:
.annotate 'line', 301
  # rx subcapture "sigil"
    set_addr $I10, rxcap_701_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "$"
    add $I11, rx692_pos, 1
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    ord $I11, rx692_tgt, $I11
    ne $I11, 36, rx692_fail
    add rx692_pos, 1
    set_addr $I10, rxcap_701_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_701_done
  rxcap_701_fail:
    goto rx692_fail
  rxcap_701_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_702_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx692_pos, rx692_eos, rx692_fail
    sub $I10, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx692_fail
    inc rx692_pos
    set_addr $I10, rxcap_702_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_702_done
  rxcap_702_fail:
    goto rx692_fail
  rxcap_702_done:
  alt698_end:
.annotate 'line', 298
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "variable")
    if_null rx692_debug, debug_854
    rx692_cur."!cursor_debug"("PASS", "variable", " at pos=", rx692_pos)
  debug_854:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 10
    if_null rx692_debug, debug_855
    rx692_cur."!cursor_debug"("NEXT", "variable")
  debug_855:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_856
    rx692_cur."!cursor_debug"("FAIL", "variable")
  debug_856:
    .return (rx692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303857440.612") :method
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("sigil", "")
    $P695 = self."!PREFIX__!subrule"("sigil", "")
    new $P696, "ResizablePMCArray"
    push $P696, "$!"
    push $P696, "$_"
    push $P696, "$/"
    push $P696, $P694
    push $P696, $P695
    .return ($P696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx704_tgt
    .local int rx704_pos
    .local int rx704_off
    .local int rx704_eos
    .local int rx704_rep
    .local pmc rx704_cur
    .local pmc rx704_debug
    (rx704_cur, rx704_pos, rx704_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx704_cur
    .local pmc match
    .lex "$/", match
    length rx704_eos, rx704_tgt
    gt rx704_pos, rx704_eos, rx704_done
    set rx704_off, 0
    lt rx704_pos, 2, rx704_start
    sub rx704_off, rx704_pos, 1
    substr rx704_tgt, rx704_tgt, rx704_off
  rx704_start:
    eq $I10, 1, rx704_restart
    if_null rx704_debug, debug_857
    rx704_cur."!cursor_debug"("START", "sigil")
  debug_857:
    $I10 = self.'from'()
    ne $I10, -1, rxscan707_done
    goto rxscan707_scan
  rxscan707_loop:
    (rx704_pos) = rx704_cur."from"()
    inc rx704_pos
    rx704_cur."!cursor_from"(rx704_pos)
    ge rx704_pos, rx704_eos, rxscan707_done
  rxscan707_scan:
    set_addr $I10, rxscan707_loop
    rx704_cur."!mark_push"(0, rx704_pos, $I10)
  rxscan707_done:
.annotate 'line', 304
  # rx enumcharlist negate=0 
    ge rx704_pos, rx704_eos, rx704_fail
    sub $I10, rx704_pos, rx704_off
    substr $S10, rx704_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx704_fail
    inc rx704_pos
  # rx pass
    rx704_cur."!cursor_pass"(rx704_pos, "sigil")
    if_null rx704_debug, debug_858
    rx704_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx704_pos)
  debug_858:
    .return (rx704_cur)
  rx704_restart:
.annotate 'line', 10
    if_null rx704_debug, debug_859
    rx704_cur."!cursor_debug"("NEXT", "sigil")
  debug_859:
  rx704_fail:
    (rx704_rep, rx704_pos, $I10, $P10) = rx704_cur."!mark_fail"(0)
    lt rx704_pos, -1, rx704_done
    eq rx704_pos, -1, rx704_fail
    jump $I10
  rx704_done:
    rx704_cur."!cursor_fail"()
    if_null rx704_debug, debug_860
    rx704_cur."!cursor_debug"("FAIL", "sigil")
  debug_860:
    .return (rx704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303857440.612") :method
.annotate 'line', 10
    new $P706, "ResizablePMCArray"
    push $P706, "&"
    push $P706, "%"
    push $P706, "@"
    push $P706, "$"
    .return ($P706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx709_tgt
    .local int rx709_pos
    .local int rx709_off
    .local int rx709_eos
    .local int rx709_rep
    .local pmc rx709_cur
    .local pmc rx709_debug
    (rx709_cur, rx709_pos, rx709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx709_cur
    .local pmc match
    .lex "$/", match
    length rx709_eos, rx709_tgt
    gt rx709_pos, rx709_eos, rx709_done
    set rx709_off, 0
    lt rx709_pos, 2, rx709_start
    sub rx709_off, rx709_pos, 1
    substr rx709_tgt, rx709_tgt, rx709_off
  rx709_start:
    eq $I10, 1, rx709_restart
    if_null rx709_debug, debug_861
    rx709_cur."!cursor_debug"("START", "twigil")
  debug_861:
    $I10 = self.'from'()
    ne $I10, -1, rxscan712_done
    goto rxscan712_scan
  rxscan712_loop:
    (rx709_pos) = rx709_cur."from"()
    inc rx709_pos
    rx709_cur."!cursor_from"(rx709_pos)
    ge rx709_pos, rx709_eos, rxscan712_done
  rxscan712_scan:
    set_addr $I10, rxscan712_loop
    rx709_cur."!mark_push"(0, rx709_pos, $I10)
  rxscan712_done:
.annotate 'line', 306
  # rx enumcharlist negate=0 
    ge rx709_pos, rx709_eos, rx709_fail
    sub $I10, rx709_pos, rx709_off
    substr $S10, rx709_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx709_fail
    inc rx709_pos
  # rx pass
    rx709_cur."!cursor_pass"(rx709_pos, "twigil")
    if_null rx709_debug, debug_862
    rx709_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx709_pos)
  debug_862:
    .return (rx709_cur)
  rx709_restart:
.annotate 'line', 10
    if_null rx709_debug, debug_863
    rx709_cur."!cursor_debug"("NEXT", "twigil")
  debug_863:
  rx709_fail:
    (rx709_rep, rx709_pos, $I10, $P10) = rx709_cur."!mark_fail"(0)
    lt rx709_pos, -1, rx709_done
    eq rx709_pos, -1, rx709_fail
    jump $I10
  rx709_done:
    rx709_cur."!cursor_fail"()
    if_null rx709_debug, debug_864
    rx709_cur."!cursor_debug"("FAIL", "twigil")
  debug_864:
    .return (rx709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303857440.612") :method
.annotate 'line', 10
    new $P711, "ResizablePMCArray"
    push $P711, "?"
    push $P711, "!"
    push $P711, "*"
    .return ($P711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303857440.612")
    .param pmc param_714
.annotate 'line', 308
    .lex "self", param_714
    $P715 = param_714."!protoregex"("package_declarator")
    .return ($P715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303857440.612")
    .param pmc param_717
.annotate 'line', 308
    .lex "self", param_717
    $P718 = param_717."!PREFIX__!protoregex"("package_declarator")
    .return ($P718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 310
    new $P720, "Undef"
    .lex "$*OUTERPACKAGE", $P720
.annotate 'line', 311
    new $P721, "Undef"
    .lex "$*PACKAGE-SETUP", $P721
.annotate 'line', 312
    new $P722, "Undef"
    .lex "$*PKGDECL", $P722
.annotate 'line', 10
    .local string rx723_tgt
    .local int rx723_pos
    .local int rx723_off
    .local int rx723_eos
    .local int rx723_rep
    .local pmc rx723_cur
    .local pmc rx723_debug
    (rx723_cur, rx723_pos, rx723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx723_cur
    .local pmc match
    .lex "$/", match
    length rx723_eos, rx723_tgt
    gt rx723_pos, rx723_eos, rx723_done
    set rx723_off, 0
    lt rx723_pos, 2, rx723_start
    sub rx723_off, rx723_pos, 1
    substr rx723_tgt, rx723_tgt, rx723_off
  rx723_start:
    eq $I10, 1, rx723_restart
    if_null rx723_debug, debug_865
    rx723_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_865:
    $I10 = self.'from'()
    ne $I10, -1, rxscan727_done
    goto rxscan727_scan
  rxscan727_loop:
    (rx723_pos) = rx723_cur."from"()
    inc rx723_pos
    rx723_cur."!cursor_from"(rx723_pos)
    ge rx723_pos, rx723_eos, rxscan727_done
  rxscan727_scan:
    set_addr $I10, rxscan727_loop
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  rxscan727_done:
.annotate 'line', 310
    rx723_cur."!cursor_pos"(rx723_pos)
    find_dynamic_lex $P730, "$*PACKAGE"
    unless_null $P730, vivify_866
    get_hll_global $P728, "GLOBAL"
    get_who $P729, $P728
    set $P730, $P729["$PACKAGE"]
    unless_null $P730, vivify_867
    die "Contextual $*PACKAGE not found"
  vivify_867:
  vivify_866:
    store_lex "$*OUTERPACKAGE", $P730
.annotate 'line', 311
    rx723_cur."!cursor_pos"(rx723_pos)
    get_hll_global $P731, "GLOBAL"
    nqp_get_package_through_who $P732, $P731, "PAST"
    get_who $P733, $P732
    set $P734, $P733["Stmts"]
    $P735 = $P734."new"()
    store_lex "$*PACKAGE-SETUP", $P735
.annotate 'line', 312
    rx723_cur."!cursor_pos"(rx723_pos)
    new $P736, "String"
    assign $P736, "module"
    store_lex "$*PKGDECL", $P736
.annotate 'line', 313
  # rx subcapture "sym"
    set_addr $I10, rxcap_737_fail
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  # rx literal  "module"
    add $I11, rx723_pos, 6
    gt $I11, rx723_eos, rx723_fail
    sub $I11, rx723_pos, rx723_off
    substr $S10, rx723_tgt, $I11, 6
    ne $S10, "module", rx723_fail
    add rx723_pos, 6
    set_addr $I10, rxcap_737_fail
    ($I12, $I11) = rx723_cur."!mark_peek"($I10)
    rx723_cur."!cursor_pos"($I11)
    ($P10) = rx723_cur."!cursor_start"()
    $P10."!cursor_pass"(rx723_pos, "")
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_737_done
  rxcap_737_fail:
    goto rx723_fail
  rxcap_737_done:
  # rx subrule "package_def" subtype=capture negate=
    rx723_cur."!cursor_pos"(rx723_pos)
    $P10 = rx723_cur."package_def"()
    unless $P10, rx723_fail
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx723_pos = $P10."pos"()
.annotate 'line', 309
  # rx pass
    rx723_cur."!cursor_pass"(rx723_pos, "package_declarator:sym<module>")
    if_null rx723_debug, debug_868
    rx723_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx723_pos)
  debug_868:
    .return (rx723_cur)
  rx723_restart:
.annotate 'line', 10
    if_null rx723_debug, debug_869
    rx723_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_869:
  rx723_fail:
    (rx723_rep, rx723_pos, $I10, $P10) = rx723_cur."!mark_fail"(0)
    lt rx723_pos, -1, rx723_done
    eq rx723_pos, -1, rx723_fail
    jump $I10
  rx723_done:
    rx723_cur."!cursor_fail"()
    if_null rx723_debug, debug_870
    rx723_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_870:
    .return (rx723_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303857440.612") :method
.annotate 'line', 10
    $P725 = self."!PREFIX__!subrule"("package_def", "module")
    new $P726, "ResizablePMCArray"
    push $P726, $P725
    .return ($P726)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 316
    new $P739, "Undef"
    .lex "$*OUTERPACKAGE", $P739
.annotate 'line', 317
    new $P740, "Undef"
    .lex "$*PACKAGE-SETUP", $P740
.annotate 'line', 318
    new $P741, "Undef"
    .lex "$*PKGDECL", $P741
.annotate 'line', 10
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_871
    rx742_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_871:
    $I10 = self.'from'()
    ne $I10, -1, rxscan746_done
    goto rxscan746_scan
  rxscan746_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan746_done
  rxscan746_scan:
    set_addr $I10, rxscan746_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan746_done:
.annotate 'line', 316
    rx742_cur."!cursor_pos"(rx742_pos)
    find_dynamic_lex $P749, "$*PACKAGE"
    unless_null $P749, vivify_872
    get_hll_global $P747, "GLOBAL"
    get_who $P748, $P747
    set $P749, $P748["$PACKAGE"]
    unless_null $P749, vivify_873
    die "Contextual $*PACKAGE not found"
  vivify_873:
  vivify_872:
    store_lex "$*OUTERPACKAGE", $P749
.annotate 'line', 317
    rx742_cur."!cursor_pos"(rx742_pos)
    get_hll_global $P750, "GLOBAL"
    nqp_get_package_through_who $P751, $P750, "PAST"
    get_who $P752, $P751
    set $P753, $P752["Stmts"]
    $P754 = $P753."new"()
    store_lex "$*PACKAGE-SETUP", $P754
.annotate 'line', 318
    rx742_cur."!cursor_pos"(rx742_pos)
    new $P755, "String"
    assign $P755, "knowhow"
    store_lex "$*PKGDECL", $P755
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_756_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx742_pos, 7
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 7
    ne $S10, "knowhow", rx742_fail
    add rx742_pos, 7
    set_addr $I10, rxcap_756_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_756_done
  rxcap_756_fail:
    goto rx742_fail
  rxcap_756_done:
  # rx subrule "package_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."package_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx742_pos = $P10."pos"()
.annotate 'line', 315
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "package_declarator:sym<knowhow>")
    if_null rx742_debug, debug_874
    rx742_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx742_pos)
  debug_874:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 10
    if_null rx742_debug, debug_875
    rx742_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_875:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_876
    rx742_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_876:
    .return (rx742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303857440.612") :method
.annotate 'line', 10
    $P744 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P745, "ResizablePMCArray"
    push $P745, $P744
    .return ($P745)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 322
    new $P758, "Undef"
    .lex "$*OUTERPACKAGE", $P758
.annotate 'line', 323
    new $P759, "Undef"
    .lex "$*PACKAGE-SETUP", $P759
.annotate 'line', 324
    new $P760, "Undef"
    .lex "$*PKGDECL", $P760
.annotate 'line', 10
    .local string rx761_tgt
    .local int rx761_pos
    .local int rx761_off
    .local int rx761_eos
    .local int rx761_rep
    .local pmc rx761_cur
    .local pmc rx761_debug
    (rx761_cur, rx761_pos, rx761_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx761_cur
    .local pmc match
    .lex "$/", match
    length rx761_eos, rx761_tgt
    gt rx761_pos, rx761_eos, rx761_done
    set rx761_off, 0
    lt rx761_pos, 2, rx761_start
    sub rx761_off, rx761_pos, 1
    substr rx761_tgt, rx761_tgt, rx761_off
  rx761_start:
    eq $I10, 1, rx761_restart
    if_null rx761_debug, debug_877
    rx761_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_877:
    $I10 = self.'from'()
    ne $I10, -1, rxscan765_done
    goto rxscan765_scan
  rxscan765_loop:
    (rx761_pos) = rx761_cur."from"()
    inc rx761_pos
    rx761_cur."!cursor_from"(rx761_pos)
    ge rx761_pos, rx761_eos, rxscan765_done
  rxscan765_scan:
    set_addr $I10, rxscan765_loop
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxscan765_done:
.annotate 'line', 322
    rx761_cur."!cursor_pos"(rx761_pos)
    find_dynamic_lex $P768, "$*PACKAGE"
    unless_null $P768, vivify_878
    get_hll_global $P766, "GLOBAL"
    get_who $P767, $P766
    set $P768, $P767["$PACKAGE"]
    unless_null $P768, vivify_879
    die "Contextual $*PACKAGE not found"
  vivify_879:
  vivify_878:
    store_lex "$*OUTERPACKAGE", $P768
.annotate 'line', 323
    rx761_cur."!cursor_pos"(rx761_pos)
    get_hll_global $P769, "GLOBAL"
    nqp_get_package_through_who $P770, $P769, "PAST"
    get_who $P771, $P770
    set $P772, $P771["Stmts"]
    $P773 = $P772."new"()
    store_lex "$*PACKAGE-SETUP", $P773
.annotate 'line', 324
    rx761_cur."!cursor_pos"(rx761_pos)
    new $P774, "String"
    assign $P774, "class"
    store_lex "$*PKGDECL", $P774
.annotate 'line', 325
  # rx subcapture "sym"
    set_addr $I10, rxcap_775_fail
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx literal  "class"
    add $I11, rx761_pos, 5
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 5
    ne $S10, "class", rx761_fail
    add rx761_pos, 5
    set_addr $I10, rxcap_775_fail
    ($I12, $I11) = rx761_cur."!mark_peek"($I10)
    rx761_cur."!cursor_pos"($I11)
    ($P10) = rx761_cur."!cursor_start"()
    $P10."!cursor_pass"(rx761_pos, "")
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_775_done
  rxcap_775_fail:
    goto rx761_fail
  rxcap_775_done:
  # rx subrule "package_def" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."package_def"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx761_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx761_cur."!cursor_pass"(rx761_pos, "package_declarator:sym<class>")
    if_null rx761_debug, debug_880
    rx761_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx761_pos)
  debug_880:
    .return (rx761_cur)
  rx761_restart:
.annotate 'line', 10
    if_null rx761_debug, debug_881
    rx761_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_881:
  rx761_fail:
    (rx761_rep, rx761_pos, $I10, $P10) = rx761_cur."!mark_fail"(0)
    lt rx761_pos, -1, rx761_done
    eq rx761_pos, -1, rx761_fail
    jump $I10
  rx761_done:
    rx761_cur."!cursor_fail"()
    if_null rx761_debug, debug_882
    rx761_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_882:
    .return (rx761_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303857440.612") :method
.annotate 'line', 10
    $P763 = self."!PREFIX__!subrule"("package_def", "class")
    new $P764, "ResizablePMCArray"
    push $P764, $P763
    .return ($P764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 328
    new $P777, "Undef"
    .lex "$*OUTERPACKAGE", $P777
.annotate 'line', 329
    new $P778, "Undef"
    .lex "$*PACKAGE-SETUP", $P778
.annotate 'line', 330
    new $P779, "Undef"
    .lex "$*PKGDECL", $P779
.annotate 'line', 10
    .local string rx780_tgt
    .local int rx780_pos
    .local int rx780_off
    .local int rx780_eos
    .local int rx780_rep
    .local pmc rx780_cur
    .local pmc rx780_debug
    (rx780_cur, rx780_pos, rx780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx780_cur
    .local pmc match
    .lex "$/", match
    length rx780_eos, rx780_tgt
    gt rx780_pos, rx780_eos, rx780_done
    set rx780_off, 0
    lt rx780_pos, 2, rx780_start
    sub rx780_off, rx780_pos, 1
    substr rx780_tgt, rx780_tgt, rx780_off
  rx780_start:
    eq $I10, 1, rx780_restart
    if_null rx780_debug, debug_883
    rx780_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_883:
    $I10 = self.'from'()
    ne $I10, -1, rxscan784_done
    goto rxscan784_scan
  rxscan784_loop:
    (rx780_pos) = rx780_cur."from"()
    inc rx780_pos
    rx780_cur."!cursor_from"(rx780_pos)
    ge rx780_pos, rx780_eos, rxscan784_done
  rxscan784_scan:
    set_addr $I10, rxscan784_loop
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxscan784_done:
.annotate 'line', 328
    rx780_cur."!cursor_pos"(rx780_pos)
    find_dynamic_lex $P787, "$*PACKAGE"
    unless_null $P787, vivify_884
    get_hll_global $P785, "GLOBAL"
    get_who $P786, $P785
    set $P787, $P786["$PACKAGE"]
    unless_null $P787, vivify_885
    die "Contextual $*PACKAGE not found"
  vivify_885:
  vivify_884:
    store_lex "$*OUTERPACKAGE", $P787
.annotate 'line', 329
    rx780_cur."!cursor_pos"(rx780_pos)
    get_hll_global $P788, "GLOBAL"
    nqp_get_package_through_who $P789, $P788, "PAST"
    get_who $P790, $P789
    set $P791, $P790["Stmts"]
    $P792 = $P791."new"()
    store_lex "$*PACKAGE-SETUP", $P792
.annotate 'line', 330
    rx780_cur."!cursor_pos"(rx780_pos)
    new $P793, "String"
    assign $P793, "grammar"
    store_lex "$*PKGDECL", $P793
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_794_fail
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx780_pos, 7
    gt $I11, rx780_eos, rx780_fail
    sub $I11, rx780_pos, rx780_off
    substr $S10, rx780_tgt, $I11, 7
    ne $S10, "grammar", rx780_fail
    add rx780_pos, 7
    set_addr $I10, rxcap_794_fail
    ($I12, $I11) = rx780_cur."!mark_peek"($I10)
    rx780_cur."!cursor_pos"($I11)
    ($P10) = rx780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx780_pos, "")
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_794_done
  rxcap_794_fail:
    goto rx780_fail
  rxcap_794_done:
  # rx subrule "package_def" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."package_def"()
    unless $P10, rx780_fail
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx780_pos = $P10."pos"()
.annotate 'line', 327
  # rx pass
    rx780_cur."!cursor_pass"(rx780_pos, "package_declarator:sym<grammar>")
    if_null rx780_debug, debug_886
    rx780_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx780_pos)
  debug_886:
    .return (rx780_cur)
  rx780_restart:
.annotate 'line', 10
    if_null rx780_debug, debug_887
    rx780_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_887:
  rx780_fail:
    (rx780_rep, rx780_pos, $I10, $P10) = rx780_cur."!mark_fail"(0)
    lt rx780_pos, -1, rx780_done
    eq rx780_pos, -1, rx780_fail
    jump $I10
  rx780_done:
    rx780_cur."!cursor_fail"()
    if_null rx780_debug, debug_888
    rx780_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_888:
    .return (rx780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303857440.612") :method
.annotate 'line', 10
    $P782 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P783, "ResizablePMCArray"
    push $P783, $P782
    .return ($P783)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 334
    new $P796, "Undef"
    .lex "$*OUTERPACKAGE", $P796
.annotate 'line', 335
    new $P797, "Undef"
    .lex "$*PACKAGE-SETUP", $P797
.annotate 'line', 336
    new $P798, "Undef"
    .lex "$*PKGDECL", $P798
.annotate 'line', 10
    .local string rx799_tgt
    .local int rx799_pos
    .local int rx799_off
    .local int rx799_eos
    .local int rx799_rep
    .local pmc rx799_cur
    .local pmc rx799_debug
    (rx799_cur, rx799_pos, rx799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx799_cur
    .local pmc match
    .lex "$/", match
    length rx799_eos, rx799_tgt
    gt rx799_pos, rx799_eos, rx799_done
    set rx799_off, 0
    lt rx799_pos, 2, rx799_start
    sub rx799_off, rx799_pos, 1
    substr rx799_tgt, rx799_tgt, rx799_off
  rx799_start:
    eq $I10, 1, rx799_restart
    if_null rx799_debug, debug_889
    rx799_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan803_done
    goto rxscan803_scan
  rxscan803_loop:
    (rx799_pos) = rx799_cur."from"()
    inc rx799_pos
    rx799_cur."!cursor_from"(rx799_pos)
    ge rx799_pos, rx799_eos, rxscan803_done
  rxscan803_scan:
    set_addr $I10, rxscan803_loop
    rx799_cur."!mark_push"(0, rx799_pos, $I10)
  rxscan803_done:
.annotate 'line', 334
    rx799_cur."!cursor_pos"(rx799_pos)
    find_dynamic_lex $P806, "$*PACKAGE"
    unless_null $P806, vivify_890
    get_hll_global $P804, "GLOBAL"
    get_who $P805, $P804
    set $P806, $P805["$PACKAGE"]
    unless_null $P806, vivify_891
    die "Contextual $*PACKAGE not found"
  vivify_891:
  vivify_890:
    store_lex "$*OUTERPACKAGE", $P806
.annotate 'line', 335
    rx799_cur."!cursor_pos"(rx799_pos)
    get_hll_global $P807, "GLOBAL"
    nqp_get_package_through_who $P808, $P807, "PAST"
    get_who $P809, $P808
    set $P810, $P809["Stmts"]
    $P811 = $P810."new"()
    store_lex "$*PACKAGE-SETUP", $P811
.annotate 'line', 336
    rx799_cur."!cursor_pos"(rx799_pos)
    new $P812, "String"
    assign $P812, "role"
    store_lex "$*PKGDECL", $P812
.annotate 'line', 337
  # rx subcapture "sym"
    set_addr $I10, rxcap_813_fail
    rx799_cur."!mark_push"(0, rx799_pos, $I10)
  # rx literal  "role"
    add $I11, rx799_pos, 4
    gt $I11, rx799_eos, rx799_fail
    sub $I11, rx799_pos, rx799_off
    substr $S10, rx799_tgt, $I11, 4
    ne $S10, "role", rx799_fail
    add rx799_pos, 4
    set_addr $I10, rxcap_813_fail
    ($I12, $I11) = rx799_cur."!mark_peek"($I10)
    rx799_cur."!cursor_pos"($I11)
    ($P10) = rx799_cur."!cursor_start"()
    $P10."!cursor_pass"(rx799_pos, "")
    rx799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_813_done
  rxcap_813_fail:
    goto rx799_fail
  rxcap_813_done:
  # rx subrule "package_def" subtype=capture negate=
    rx799_cur."!cursor_pos"(rx799_pos)
    $P10 = rx799_cur."package_def"()
    unless $P10, rx799_fail
    rx799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx799_pos = $P10."pos"()
.annotate 'line', 333
  # rx pass
    rx799_cur."!cursor_pass"(rx799_pos, "package_declarator:sym<role>")
    if_null rx799_debug, debug_892
    rx799_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx799_pos)
  debug_892:
    .return (rx799_cur)
  rx799_restart:
.annotate 'line', 10
    if_null rx799_debug, debug_893
    rx799_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_893:
  rx799_fail:
    (rx799_rep, rx799_pos, $I10, $P10) = rx799_cur."!mark_fail"(0)
    lt rx799_pos, -1, rx799_done
    eq rx799_pos, -1, rx799_fail
    jump $I10
  rx799_done:
    rx799_cur."!cursor_fail"()
    if_null rx799_debug, debug_894
    rx799_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_894:
    .return (rx799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303857440.612") :method
.annotate 'line', 10
    $P801 = self."!PREFIX__!subrule"("package_def", "role")
    new $P802, "ResizablePMCArray"
    push $P802, $P801
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 340
    new $P815, "Undef"
    .lex "$*OUTERPACKAGE", $P815
.annotate 'line', 341
    new $P816, "Undef"
    .lex "$*PACKAGE-SETUP", $P816
.annotate 'line', 342
    new $P817, "Undef"
    .lex "$*PKGDECL", $P817
.annotate 'line', 10
    .local string rx818_tgt
    .local int rx818_pos
    .local int rx818_off
    .local int rx818_eos
    .local int rx818_rep
    .local pmc rx818_cur
    .local pmc rx818_debug
    (rx818_cur, rx818_pos, rx818_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx818_cur
    .local pmc match
    .lex "$/", match
    length rx818_eos, rx818_tgt
    gt rx818_pos, rx818_eos, rx818_done
    set rx818_off, 0
    lt rx818_pos, 2, rx818_start
    sub rx818_off, rx818_pos, 1
    substr rx818_tgt, rx818_tgt, rx818_off
  rx818_start:
    eq $I10, 1, rx818_restart
    if_null rx818_debug, debug_895
    rx818_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan822_done
    goto rxscan822_scan
  rxscan822_loop:
    (rx818_pos) = rx818_cur."from"()
    inc rx818_pos
    rx818_cur."!cursor_from"(rx818_pos)
    ge rx818_pos, rx818_eos, rxscan822_done
  rxscan822_scan:
    set_addr $I10, rxscan822_loop
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxscan822_done:
.annotate 'line', 340
    rx818_cur."!cursor_pos"(rx818_pos)
    find_dynamic_lex $P825, "$*PACKAGE"
    unless_null $P825, vivify_896
    get_hll_global $P823, "GLOBAL"
    get_who $P824, $P823
    set $P825, $P824["$PACKAGE"]
    unless_null $P825, vivify_897
    die "Contextual $*PACKAGE not found"
  vivify_897:
  vivify_896:
    store_lex "$*OUTERPACKAGE", $P825
.annotate 'line', 341
    rx818_cur."!cursor_pos"(rx818_pos)
    get_hll_global $P826, "GLOBAL"
    nqp_get_package_through_who $P827, $P826, "PAST"
    get_who $P828, $P827
    set $P829, $P828["Stmts"]
    $P830 = $P829."new"()
    store_lex "$*PACKAGE-SETUP", $P830
.annotate 'line', 342
    rx818_cur."!cursor_pos"(rx818_pos)
    new $P831, "String"
    assign $P831, "native"
    store_lex "$*PKGDECL", $P831
.annotate 'line', 343
  # rx subcapture "sym"
    set_addr $I10, rxcap_832_fail
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  # rx literal  "native"
    add $I11, rx818_pos, 6
    gt $I11, rx818_eos, rx818_fail
    sub $I11, rx818_pos, rx818_off
    substr $S10, rx818_tgt, $I11, 6
    ne $S10, "native", rx818_fail
    add rx818_pos, 6
    set_addr $I10, rxcap_832_fail
    ($I12, $I11) = rx818_cur."!mark_peek"($I10)
    rx818_cur."!cursor_pos"($I11)
    ($P10) = rx818_cur."!cursor_start"()
    $P10."!cursor_pass"(rx818_pos, "")
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_832_done
  rxcap_832_fail:
    goto rx818_fail
  rxcap_832_done:
  # rx subrule "package_def" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."package_def"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx818_pos = $P10."pos"()
.annotate 'line', 339
  # rx pass
    rx818_cur."!cursor_pass"(rx818_pos, "package_declarator:sym<native>")
    if_null rx818_debug, debug_898
    rx818_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx818_pos)
  debug_898:
    .return (rx818_cur)
  rx818_restart:
.annotate 'line', 10
    if_null rx818_debug, debug_899
    rx818_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_899:
  rx818_fail:
    (rx818_rep, rx818_pos, $I10, $P10) = rx818_cur."!mark_fail"(0)
    lt rx818_pos, -1, rx818_done
    eq rx818_pos, -1, rx818_fail
    jump $I10
  rx818_done:
    rx818_cur."!cursor_fail"()
    if_null rx818_debug, debug_900
    rx818_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_900:
    .return (rx818_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303857440.612") :method
.annotate 'line', 10
    $P820 = self."!PREFIX__!subrule"("package_def", "native")
    new $P821, "ResizablePMCArray"
    push $P821, $P820
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P861 = "154_1303857440.612" 
    capture_lex $P861
.annotate 'line', 347
    new $P834, "Undef"
    .lex "$*PACKAGE", $P834
.annotate 'line', 348
    $P835 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P835
.annotate 'line', 10
    .local string rx836_tgt
    .local int rx836_pos
    .local int rx836_off
    .local int rx836_eos
    .local int rx836_rep
    .local pmc rx836_cur
    .local pmc rx836_debug
    (rx836_cur, rx836_pos, rx836_tgt, $I10) = self."!cursor_start"()
    rx836_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx836_cur
    .local pmc match
    .lex "$/", match
    length rx836_eos, rx836_tgt
    gt rx836_pos, rx836_eos, rx836_done
    set rx836_off, 0
    lt rx836_pos, 2, rx836_start
    sub rx836_off, rx836_pos, 1
    substr rx836_tgt, rx836_tgt, rx836_off
  rx836_start:
    eq $I10, 1, rx836_restart
    if_null rx836_debug, debug_901
    rx836_cur."!cursor_debug"("START", "package_def")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan840_done
    goto rxscan840_scan
  rxscan840_loop:
    (rx836_pos) = rx836_cur."from"()
    inc rx836_pos
    rx836_cur."!cursor_from"(rx836_pos)
    ge rx836_pos, rx836_eos, rxscan840_done
  rxscan840_scan:
    set_addr $I10, rxscan840_loop
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxscan840_done:
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 347
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P844, "$*PACKAGE"
    unless_null $P844, vivify_902
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["$PACKAGE"]
    unless_null $P844, vivify_903
    die "Contextual $*PACKAGE not found"
  vivify_903:
  vivify_902:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 348
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P848, "%*ATTR-CHECK"
    unless_null $P848, vivify_904
    get_hll_global $P846, "GLOBAL"
    get_who $P847, $P846
    set $P848, $P847["%ATTR-CHECK"]
    unless_null $P848, vivify_905
    die "Contextual %*ATTR-CHECK not found"
  vivify_905:
  vivify_904:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 350
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 351
  # rx rxquantr851 ** 0..1
    set_addr $I10, rxquantr851_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr851_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx836_pos, 2
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 2
    ne $S10, "is", rx836_fail
    add rx836_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx836_pos, 5
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 5
    ne $S10, "repr(", rx836_fail
    add rx836_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."quote_EXPR"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx836_pos, 1
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    ord $I11, rx836_tgt, $I11
    ne $I11, 41, rx836_fail
    add rx836_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr851_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
  rxquantr851_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 353
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P858, unicode:"$\x{a2}"
    $P859 = $P858."MATCH"()
    store_lex "$/", $P859
    .const 'Sub' $P861 = "154_1303857440.612" 
    capture_lex $P861
    $P983 = $P861()
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 381
  # rx rxquantr985 ** 0..1
    set_addr $I10, rxquantr985_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr985_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx836_pos, 2
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 2
    ne $S10, "is", rx836_fail
    add rx836_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr985_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
  rxquantr985_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 382
  # rx rxquantr990 ** 0..*
    set_addr $I10, rxquantr990_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr990_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx836_pos, 4
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 4
    ne $S10, "does", rx836_fail
    add rx836_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr990_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr990_done
    rx836_cur."!mark_push"(rx836_rep, rx836_pos, $I10)
    goto rxquantr990_loop
  rxquantr990_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  alt995_0:
.annotate 'line', 383
    set_addr $I10, alt995_1
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx836_pos, 1
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    ord $I11, rx836_tgt, $I11
    ne $I11, 59, rx836_fail
    add rx836_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."comp_unit"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    goto alt995_end
  alt995_1:
    set_addr $I10, alt995_2
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx836_fail
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."block"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    goto alt995_end
  alt995_2:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."panic"("Malformed package declaration")
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  alt995_end:
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 346
  # rx pass
    rx836_cur."!cursor_pass"(rx836_pos, "package_def")
    if_null rx836_debug, debug_973
    rx836_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx836_pos)
  debug_973:
    .return (rx836_cur)
  rx836_restart:
.annotate 'line', 10
    if_null rx836_debug, debug_974
    rx836_cur."!cursor_debug"("NEXT", "package_def")
  debug_974:
  rx836_fail:
    (rx836_rep, rx836_pos, $I10, $P10) = rx836_cur."!mark_fail"(0)
    lt rx836_pos, -1, rx836_done
    eq rx836_pos, -1, rx836_fail
    jump $I10
  rx836_done:
    rx836_cur."!cursor_fail"()
    if_null rx836_debug, debug_975
    rx836_cur."!cursor_debug"("FAIL", "package_def")
  debug_975:
    .return (rx836_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303857440.612") :method
.annotate 'line', 10
    $P838 = self."!PREFIX__!subrule"("ws", "")
    new $P839, "ResizablePMCArray"
    push $P839, $P838
    .return ($P839)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block860"  :anon :subid("154_1303857440.612") :outer("152_1303857440.612")
.annotate 'line', 356
    $P862 = root_new ['parrot';'Hash']
    .lex "%args", $P862
.annotate 'line', 353
    find_lex $P863, "%args"
    unless_null $P863, vivify_906
    $P863 = root_new ['parrot';'Hash']
  vivify_906:
.annotate 'line', 357
    find_lex $P864, "$/"
    unless_null $P864, vivify_907
    $P864 = root_new ['parrot';'Hash']
  vivify_907:
    set $P865, $P864["name"]
    unless_null $P865, vivify_908
    new $P865, "Undef"
  vivify_908:
    set $S866, $P865
    new $P867, 'String'
    set $P867, $S866
    find_lex $P868, "%args"
    unless_null $P868, vivify_909
    $P868 = root_new ['parrot';'Hash']
    store_lex "%args", $P868
  vivify_909:
    set $P868["name"], $P867
.annotate 'line', 358
    find_lex $P870, "$/"
    unless_null $P870, vivify_910
    $P870 = root_new ['parrot';'Hash']
  vivify_910:
    set $P871, $P870["repr"]
    unless_null $P871, vivify_911
    new $P871, "Undef"
  vivify_911:
    unless $P871, if_869_end
.annotate 'line', 359
    find_lex $P872, "$/"
    unless_null $P872, vivify_912
    $P872 = root_new ['parrot';'Hash']
  vivify_912:
    set $P873, $P872["repr"]
    unless_null $P873, vivify_913
    $P873 = root_new ['parrot';'ResizablePMCArray']
  vivify_913:
    set $P874, $P873[0]
    unless_null $P874, vivify_914
    $P874 = root_new ['parrot';'Hash']
  vivify_914:
    set $P875, $P874["quote_delimited"]
    unless_null $P875, vivify_915
    $P875 = root_new ['parrot';'Hash']
  vivify_915:
    set $P876, $P875["quote_atom"]
    unless_null $P876, vivify_916
    $P876 = root_new ['parrot';'ResizablePMCArray']
  vivify_916:
    set $P877, $P876[0]
    unless_null $P877, vivify_917
    new $P877, "Undef"
  vivify_917:
    set $S878, $P877
    new $P879, 'String'
    set $P879, $S878
    find_lex $P880, "%args"
    unless_null $P880, vivify_918
    $P880 = root_new ['parrot';'Hash']
    store_lex "%args", $P880
  vivify_918:
    set $P880["repr"], $P879
  if_869_end:
.annotate 'line', 361
    find_dynamic_lex $P883, "$*SC"
    unless_null $P883, vivify_919
    get_hll_global $P881, "GLOBAL"
    get_who $P882, $P881
    set $P883, $P882["$SC"]
    unless_null $P883, vivify_920
    die "Contextual $*SC not found"
  vivify_920:
  vivify_919:
    find_dynamic_lex $P886, "$*PKGDECL"
    unless_null $P886, vivify_921
    get_hll_global $P884, "GLOBAL"
    get_who $P885, $P884
    set $P886, $P885["$PKGDECL"]
    unless_null $P886, vivify_922
    die "Contextual $*PKGDECL not found"
  vivify_922:
  vivify_921:
    find_dynamic_lex $P889, "%*HOW"
    unless_null $P889, vivify_923
    get_hll_global $P887, "GLOBAL"
    get_who $P888, $P887
    set $P889, $P888["%HOW"]
    unless_null $P889, vivify_924
    die "Contextual %*HOW not found"
  vivify_924:
  vivify_923:
    set $P890, $P889[$P886]
    unless_null $P890, vivify_925
    new $P890, "Undef"
  vivify_925:
    find_lex $P891, "%args"
    unless_null $P891, vivify_926
    $P891 = root_new ['parrot';'Hash']
  vivify_926:
    $P892 = $P883."pkg_create_mo"($P890, $P891 :flat)
    store_dynamic_lex "$*PACKAGE", $P892
.annotate 'line', 364
    find_dynamic_lex $P899, "$*SCOPE"
    unless_null $P899, vivify_927
    get_hll_global $P897, "GLOBAL"
    get_who $P898, $P897
    set $P899, $P898["$SCOPE"]
    unless_null $P899, vivify_928
    die "Contextual $*SCOPE not found"
  vivify_928:
  vivify_927:
    set $S900, $P899
    iseq $I901, $S900, "our"
    unless $I901, unless_896
    new $P895, 'Integer'
    set $P895, $I901
    goto unless_896_end
  unless_896:
    find_dynamic_lex $P904, "$*SCOPE"
    unless_null $P904, vivify_929
    get_hll_global $P902, "GLOBAL"
    get_who $P903, $P902
    set $P904, $P903["$SCOPE"]
    unless_null $P904, vivify_930
    die "Contextual $*SCOPE not found"
  vivify_930:
  vivify_929:
    set $S905, $P904
    iseq $I906, $S905, ""
    new $P895, 'Integer'
    set $P895, $I906
  unless_896_end:
    if $P895, if_894
.annotate 'line', 370
    find_dynamic_lex $P947, "$*SCOPE"
    unless_null $P947, vivify_931
    get_hll_global $P945, "GLOBAL"
    get_who $P946, $P945
    set $P947, $P946["$SCOPE"]
    unless_null $P947, vivify_932
    die "Contextual $*SCOPE not found"
  vivify_932:
  vivify_931:
    set $S948, $P947
    iseq $I949, $S948, "my"
    if $I949, if_944
.annotate 'line', 377
    find_lex $P976, "$/"
    unless_null $P976, vivify_933
    new $P976, "Undef"
  vivify_933:
    $P977 = $P976."CURSOR"()
    find_dynamic_lex $P980, "$*SCOPE"
    unless_null $P980, vivify_934
    get_hll_global $P978, "GLOBAL"
    get_who $P979, $P978
    set $P980, $P979["$SCOPE"]
    unless_null $P980, vivify_935
    die "Contextual $*SCOPE not found"
  vivify_935:
  vivify_934:
    concat $P981, $P980, " scoped packages are not supported"
    $P982 = $P977."panic"($P981)
.annotate 'line', 376
    set $P943, $P982
.annotate 'line', 370
    goto if_944_end
  if_944:
.annotate 'line', 371
    find_lex $P951, "$/"
    unless_null $P951, vivify_936
    $P951 = root_new ['parrot';'Hash']
  vivify_936:
    set $P952, $P951["name"]
    unless_null $P952, vivify_937
    $P952 = root_new ['parrot';'Hash']
  vivify_937:
    set $P953, $P952["identifier"]
    unless_null $P953, vivify_938
    new $P953, "Undef"
  vivify_938:
    set $N954, $P953
    isne $I955, $N954, 1.0
    unless $I955, if_950_end
.annotate 'line', 372
    find_lex $P956, "$/"
    unless_null $P956, vivify_939
    $P956 = root_new ['parrot';'Hash']
  vivify_939:
    set $P957, $P956["name"]
    unless_null $P957, vivify_940
    new $P957, "Undef"
  vivify_940:
    $P958 = $P957."CURSOR"()
    $P958."panic"("A my scoped package cannot have a multi-part name yet")
  if_950_end:
.annotate 'line', 374
    find_dynamic_lex $P961, "$*SC"
    unless_null $P961, vivify_941
    get_hll_global $P959, "GLOBAL"
    get_who $P960, $P959
    set $P961, $P960["$SC"]
    unless_null $P961, vivify_942
    die "Contextual $*SC not found"
  vivify_942:
  vivify_941:
    get_hll_global $P962, "GLOBAL"
    nqp_get_package_through_who $P963, $P962, "NQP"
    nqp_get_package_through_who $P964, $P963, "Actions"
    get_who $P965, $P964
    set $P966, $P965["@BLOCK"]
    unless_null $P966, vivify_943
    $P966 = root_new ['parrot';'ResizablePMCArray']
  vivify_943:
    set $P967, $P966[0]
    unless_null $P967, vivify_944
    new $P967, "Undef"
  vivify_944:
    find_lex $P968, "$/"
    unless_null $P968, vivify_945
    $P968 = root_new ['parrot';'Hash']
  vivify_945:
    set $P969, $P968["name"]
    unless_null $P969, vivify_946
    $P969 = root_new ['parrot';'Hash']
  vivify_946:
    set $P970, $P969["identifier"]
    unless_null $P970, vivify_947
    $P970 = root_new ['parrot';'ResizablePMCArray']
  vivify_947:
    set $P971, $P970[0]
    unless_null $P971, vivify_948
    new $P971, "Undef"
  vivify_948:
    find_dynamic_lex $P974, "$*PACKAGE"
    unless_null $P974, vivify_949
    get_hll_global $P972, "GLOBAL"
    get_who $P973, $P972
    set $P974, $P973["$PACKAGE"]
    unless_null $P974, vivify_950
    die "Contextual $*PACKAGE not found"
  vivify_950:
  vivify_949:
    $P975 = $P961."install_lexical_symbol"($P967, $P971, $P974)
.annotate 'line', 370
    set $P943, $P975
  if_944_end:
    set $P893, $P943
.annotate 'line', 364
    goto if_894_end
  if_894:
.annotate 'line', 365
    find_dynamic_lex $P909, "$*SC"
    unless_null $P909, vivify_951
    get_hll_global $P907, "GLOBAL"
    get_who $P908, $P907
    set $P909, $P908["$SC"]
    unless_null $P909, vivify_952
    die "Contextual $*SC not found"
  vivify_952:
  vivify_951:
    find_dynamic_lex $P912, "$*OUTERPACKAGE"
    unless_null $P912, vivify_953
    get_hll_global $P910, "GLOBAL"
    get_who $P911, $P910
    set $P912, $P911["$OUTERPACKAGE"]
    unless_null $P912, vivify_954
    die "Contextual $*OUTERPACKAGE not found"
  vivify_954:
  vivify_953:
    find_lex $P913, "$/"
    unless_null $P913, vivify_955
    $P913 = root_new ['parrot';'Hash']
  vivify_955:
    set $P914, $P913["name"]
    unless_null $P914, vivify_956
    $P914 = root_new ['parrot';'Hash']
  vivify_956:
    set $P915, $P914["identifier"]
    unless_null $P915, vivify_957
    new $P915, "Undef"
  vivify_957:
    find_dynamic_lex $P918, "$*PACKAGE"
    unless_null $P918, vivify_958
    get_hll_global $P916, "GLOBAL"
    get_who $P917, $P916
    set $P918, $P917["$PACKAGE"]
    unless_null $P918, vivify_959
    die "Contextual $*PACKAGE not found"
  vivify_959:
  vivify_958:
    $P909."install_package_symbol"($P912, $P915, $P918)
.annotate 'line', 366
    find_lex $P921, "$/"
    unless_null $P921, vivify_960
    $P921 = root_new ['parrot';'Hash']
  vivify_960:
    set $P922, $P921["name"]
    unless_null $P922, vivify_961
    $P922 = root_new ['parrot';'Hash']
  vivify_961:
    set $P923, $P922["identifier"]
    unless_null $P923, vivify_962
    new $P923, "Undef"
  vivify_962:
    set $N924, $P923
    iseq $I925, $N924, 1.0
    if $I925, if_920
    new $P919, 'Integer'
    set $P919, $I925
    goto if_920_end
  if_920:
.annotate 'line', 367
    find_dynamic_lex $P928, "$*SC"
    unless_null $P928, vivify_963
    get_hll_global $P926, "GLOBAL"
    get_who $P927, $P926
    set $P928, $P927["$SC"]
    unless_null $P928, vivify_964
    die "Contextual $*SC not found"
  vivify_964:
  vivify_963:
    get_hll_global $P929, "GLOBAL"
    nqp_get_package_through_who $P930, $P929, "NQP"
    nqp_get_package_through_who $P931, $P930, "Actions"
    get_who $P932, $P931
    set $P933, $P932["@BLOCK"]
    unless_null $P933, vivify_965
    $P933 = root_new ['parrot';'ResizablePMCArray']
  vivify_965:
    set $P934, $P933[0]
    unless_null $P934, vivify_966
    new $P934, "Undef"
  vivify_966:
    find_lex $P935, "$/"
    unless_null $P935, vivify_967
    $P935 = root_new ['parrot';'Hash']
  vivify_967:
    set $P936, $P935["name"]
    unless_null $P936, vivify_968
    $P936 = root_new ['parrot';'Hash']
  vivify_968:
    set $P937, $P936["identifier"]
    unless_null $P937, vivify_969
    $P937 = root_new ['parrot';'ResizablePMCArray']
  vivify_969:
    set $P938, $P937[0]
    unless_null $P938, vivify_970
    new $P938, "Undef"
  vivify_970:
    find_dynamic_lex $P941, "$*PACKAGE"
    unless_null $P941, vivify_971
    get_hll_global $P939, "GLOBAL"
    get_who $P940, $P939
    set $P941, $P940["$PACKAGE"]
    unless_null $P941, vivify_972
    die "Contextual $*PACKAGE not found"
  vivify_972:
  vivify_971:
    $P942 = $P928."install_lexical_symbol"($P934, $P938, $P941)
.annotate 'line', 366
    set $P919, $P942
  if_920_end:
.annotate 'line', 364
    set $P893, $P919
  if_894_end:
.annotate 'line', 353
    .return ($P893)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303857440.612")
    .param pmc param_1006
.annotate 'line', 390
    .lex "self", param_1006
    $P1007 = param_1006."!protoregex"("scope_declarator")
    .return ($P1007)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303857440.612")
    .param pmc param_1009
.annotate 'line', 390
    .lex "self", param_1009
    $P1010 = param_1009."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1012_tgt
    .local int rx1012_pos
    .local int rx1012_off
    .local int rx1012_eos
    .local int rx1012_rep
    .local pmc rx1012_cur
    .local pmc rx1012_debug
    (rx1012_cur, rx1012_pos, rx1012_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1012_cur
    .local pmc match
    .lex "$/", match
    length rx1012_eos, rx1012_tgt
    gt rx1012_pos, rx1012_eos, rx1012_done
    set rx1012_off, 0
    lt rx1012_pos, 2, rx1012_start
    sub rx1012_off, rx1012_pos, 1
    substr rx1012_tgt, rx1012_tgt, rx1012_off
  rx1012_start:
    eq $I10, 1, rx1012_restart
    if_null rx1012_debug, debug_976
    rx1012_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_976:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1016_done
    goto rxscan1016_scan
  rxscan1016_loop:
    (rx1012_pos) = rx1012_cur."from"()
    inc rx1012_pos
    rx1012_cur."!cursor_from"(rx1012_pos)
    ge rx1012_pos, rx1012_eos, rxscan1016_done
  rxscan1016_scan:
    set_addr $I10, rxscan1016_loop
    rx1012_cur."!mark_push"(0, rx1012_pos, $I10)
  rxscan1016_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_1017_fail
    rx1012_cur."!mark_push"(0, rx1012_pos, $I10)
  # rx literal  "my"
    add $I11, rx1012_pos, 2
    gt $I11, rx1012_eos, rx1012_fail
    sub $I11, rx1012_pos, rx1012_off
    substr $S10, rx1012_tgt, $I11, 2
    ne $S10, "my", rx1012_fail
    add rx1012_pos, 2
    set_addr $I10, rxcap_1017_fail
    ($I12, $I11) = rx1012_cur."!mark_peek"($I10)
    rx1012_cur."!cursor_pos"($I11)
    ($P10) = rx1012_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1012_pos, "")
    rx1012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1017_done
  rxcap_1017_fail:
    goto rx1012_fail
  rxcap_1017_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1012_cur."!cursor_pos"(rx1012_pos)
    $P10 = rx1012_cur."scoped"("my")
    unless $P10, rx1012_fail
    rx1012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1012_pos = $P10."pos"()
  # rx pass
    rx1012_cur."!cursor_pass"(rx1012_pos, "scope_declarator:sym<my>")
    if_null rx1012_debug, debug_977
    rx1012_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1012_pos)
  debug_977:
    .return (rx1012_cur)
  rx1012_restart:
.annotate 'line', 10
    if_null rx1012_debug, debug_978
    rx1012_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_978:
  rx1012_fail:
    (rx1012_rep, rx1012_pos, $I10, $P10) = rx1012_cur."!mark_fail"(0)
    lt rx1012_pos, -1, rx1012_done
    eq rx1012_pos, -1, rx1012_fail
    jump $I10
  rx1012_done:
    rx1012_cur."!cursor_fail"()
    if_null rx1012_debug, debug_979
    rx1012_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_979:
    .return (rx1012_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303857440.612") :method
.annotate 'line', 10
    $P1014 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1015, "ResizablePMCArray"
    push $P1015, $P1014
    .return ($P1015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1019_tgt
    .local int rx1019_pos
    .local int rx1019_off
    .local int rx1019_eos
    .local int rx1019_rep
    .local pmc rx1019_cur
    .local pmc rx1019_debug
    (rx1019_cur, rx1019_pos, rx1019_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1019_cur
    .local pmc match
    .lex "$/", match
    length rx1019_eos, rx1019_tgt
    gt rx1019_pos, rx1019_eos, rx1019_done
    set rx1019_off, 0
    lt rx1019_pos, 2, rx1019_start
    sub rx1019_off, rx1019_pos, 1
    substr rx1019_tgt, rx1019_tgt, rx1019_off
  rx1019_start:
    eq $I10, 1, rx1019_restart
    if_null rx1019_debug, debug_980
    rx1019_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_980:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1023_done
    goto rxscan1023_scan
  rxscan1023_loop:
    (rx1019_pos) = rx1019_cur."from"()
    inc rx1019_pos
    rx1019_cur."!cursor_from"(rx1019_pos)
    ge rx1019_pos, rx1019_eos, rxscan1023_done
  rxscan1023_scan:
    set_addr $I10, rxscan1023_loop
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  rxscan1023_done:
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_1024_fail
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  # rx literal  "our"
    add $I11, rx1019_pos, 3
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    substr $S10, rx1019_tgt, $I11, 3
    ne $S10, "our", rx1019_fail
    add rx1019_pos, 3
    set_addr $I10, rxcap_1024_fail
    ($I12, $I11) = rx1019_cur."!mark_peek"($I10)
    rx1019_cur."!cursor_pos"($I11)
    ($P10) = rx1019_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1019_pos, "")
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1024_done
  rxcap_1024_fail:
    goto rx1019_fail
  rxcap_1024_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."scoped"("our")
    unless $P10, rx1019_fail
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1019_pos = $P10."pos"()
  # rx pass
    rx1019_cur."!cursor_pass"(rx1019_pos, "scope_declarator:sym<our>")
    if_null rx1019_debug, debug_981
    rx1019_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1019_pos)
  debug_981:
    .return (rx1019_cur)
  rx1019_restart:
.annotate 'line', 10
    if_null rx1019_debug, debug_982
    rx1019_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_982:
  rx1019_fail:
    (rx1019_rep, rx1019_pos, $I10, $P10) = rx1019_cur."!mark_fail"(0)
    lt rx1019_pos, -1, rx1019_done
    eq rx1019_pos, -1, rx1019_fail
    jump $I10
  rx1019_done:
    rx1019_cur."!cursor_fail"()
    if_null rx1019_debug, debug_983
    rx1019_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_983:
    .return (rx1019_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303857440.612") :method
.annotate 'line', 10
    $P1021 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1022, "ResizablePMCArray"
    push $P1022, $P1021
    .return ($P1022)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1026_tgt
    .local int rx1026_pos
    .local int rx1026_off
    .local int rx1026_eos
    .local int rx1026_rep
    .local pmc rx1026_cur
    .local pmc rx1026_debug
    (rx1026_cur, rx1026_pos, rx1026_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1026_cur
    .local pmc match
    .lex "$/", match
    length rx1026_eos, rx1026_tgt
    gt rx1026_pos, rx1026_eos, rx1026_done
    set rx1026_off, 0
    lt rx1026_pos, 2, rx1026_start
    sub rx1026_off, rx1026_pos, 1
    substr rx1026_tgt, rx1026_tgt, rx1026_off
  rx1026_start:
    eq $I10, 1, rx1026_restart
    if_null rx1026_debug, debug_984
    rx1026_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_984:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1030_done
    goto rxscan1030_scan
  rxscan1030_loop:
    (rx1026_pos) = rx1026_cur."from"()
    inc rx1026_pos
    rx1026_cur."!cursor_from"(rx1026_pos)
    ge rx1026_pos, rx1026_eos, rxscan1030_done
  rxscan1030_scan:
    set_addr $I10, rxscan1030_loop
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  rxscan1030_done:
.annotate 'line', 393
  # rx subcapture "sym"
    set_addr $I10, rxcap_1031_fail
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  # rx literal  "has"
    add $I11, rx1026_pos, 3
    gt $I11, rx1026_eos, rx1026_fail
    sub $I11, rx1026_pos, rx1026_off
    substr $S10, rx1026_tgt, $I11, 3
    ne $S10, "has", rx1026_fail
    add rx1026_pos, 3
    set_addr $I10, rxcap_1031_fail
    ($I12, $I11) = rx1026_cur."!mark_peek"($I10)
    rx1026_cur."!cursor_pos"($I11)
    ($P10) = rx1026_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1026_pos, "")
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1031_done
  rxcap_1031_fail:
    goto rx1026_fail
  rxcap_1031_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."scoped"("has")
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1026_pos = $P10."pos"()
  # rx pass
    rx1026_cur."!cursor_pass"(rx1026_pos, "scope_declarator:sym<has>")
    if_null rx1026_debug, debug_985
    rx1026_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1026_pos)
  debug_985:
    .return (rx1026_cur)
  rx1026_restart:
.annotate 'line', 10
    if_null rx1026_debug, debug_986
    rx1026_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_986:
  rx1026_fail:
    (rx1026_rep, rx1026_pos, $I10, $P10) = rx1026_cur."!mark_fail"(0)
    lt rx1026_pos, -1, rx1026_done
    eq rx1026_pos, -1, rx1026_fail
    jump $I10
  rx1026_done:
    rx1026_cur."!cursor_fail"()
    if_null rx1026_debug, debug_987
    rx1026_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_987:
    .return (rx1026_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303857440.612") :method
.annotate 'line', 10
    $P1028 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1029, "ResizablePMCArray"
    push $P1029, $P1028
    .return ($P1029)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303857440.612") :method :outer("12_1303857440.612")
    .param pmc param_1033
.annotate 'line', 395
    .lex "$*SCOPE", param_1033
.annotate 'line', 10
    .local string rx1034_tgt
    .local int rx1034_pos
    .local int rx1034_off
    .local int rx1034_eos
    .local int rx1034_rep
    .local pmc rx1034_cur
    .local pmc rx1034_debug
    (rx1034_cur, rx1034_pos, rx1034_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1034_cur
    .local pmc match
    .lex "$/", match
    length rx1034_eos, rx1034_tgt
    gt rx1034_pos, rx1034_eos, rx1034_done
    set rx1034_off, 0
    lt rx1034_pos, 2, rx1034_start
    sub rx1034_off, rx1034_pos, 1
    substr rx1034_tgt, rx1034_tgt, rx1034_off
  rx1034_start:
    eq $I10, 1, rx1034_restart
    if_null rx1034_debug, debug_988
    rx1034_cur."!cursor_debug"("START", "scoped")
  debug_988:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1040_done
    goto rxscan1040_scan
  rxscan1040_loop:
    (rx1034_pos) = rx1034_cur."from"()
    inc rx1034_pos
    rx1034_cur."!cursor_from"(rx1034_pos)
    ge rx1034_pos, rx1034_eos, rxscan1040_done
  rxscan1040_scan:
    set_addr $I10, rxscan1040_loop
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
  rxscan1040_done:
  alt1041_0:
.annotate 'line', 395
    set_addr $I10, alt1041_1
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
    goto alt1041_end
  alt1041_1:
    set_addr $I10, alt1041_2
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."multi_declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
    goto alt1041_end
  alt1041_2:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."package_declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  alt1041_end:
.annotate 'line', 395
  # rx pass
    rx1034_cur."!cursor_pass"(rx1034_pos, "scoped")
    if_null rx1034_debug, debug_989
    rx1034_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1034_pos)
  debug_989:
    .return (rx1034_cur)
  rx1034_restart:
.annotate 'line', 10
    if_null rx1034_debug, debug_990
    rx1034_cur."!cursor_debug"("NEXT", "scoped")
  debug_990:
  rx1034_fail:
    (rx1034_rep, rx1034_pos, $I10, $P10) = rx1034_cur."!mark_fail"(0)
    lt rx1034_pos, -1, rx1034_done
    eq rx1034_pos, -1, rx1034_fail
    jump $I10
  rx1034_done:
    rx1034_cur."!cursor_fail"()
    if_null rx1034_debug, debug_991
    rx1034_cur."!cursor_debug"("FAIL", "scoped")
  debug_991:
    .return (rx1034_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303857440.612") :method
.annotate 'line', 10
    $P1036 = self."!PREFIX__!subrule"("ws", "")
    $P1037 = self."!PREFIX__!subrule"("ws", "")
    $P1038 = self."!PREFIX__!subrule"("ws", "")
    new $P1039, "ResizablePMCArray"
    push $P1039, $P1036
    push $P1039, $P1037
    push $P1039, $P1038
    .return ($P1039)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1049_tgt
    .local int rx1049_pos
    .local int rx1049_off
    .local int rx1049_eos
    .local int rx1049_rep
    .local pmc rx1049_cur
    .local pmc rx1049_debug
    (rx1049_cur, rx1049_pos, rx1049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1049_cur
    .local pmc match
    .lex "$/", match
    length rx1049_eos, rx1049_tgt
    gt rx1049_pos, rx1049_eos, rx1049_done
    set rx1049_off, 0
    lt rx1049_pos, 2, rx1049_start
    sub rx1049_off, rx1049_pos, 1
    substr rx1049_tgt, rx1049_tgt, rx1049_off
  rx1049_start:
    eq $I10, 1, rx1049_restart
    if_null rx1049_debug, debug_992
    rx1049_cur."!cursor_debug"("START", "typename")
  debug_992:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1053_done
    goto rxscan1053_scan
  rxscan1053_loop:
    (rx1049_pos) = rx1049_cur."from"()
    inc rx1049_pos
    rx1049_cur."!cursor_from"(rx1049_pos)
    ge rx1049_pos, rx1049_eos, rxscan1053_done
  rxscan1053_scan:
    set_addr $I10, rxscan1053_loop
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  rxscan1053_done:
.annotate 'line', 401
  # rx subrule "name" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."name"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1049_pos = $P10."pos"()
  # rx pass
    rx1049_cur."!cursor_pass"(rx1049_pos, "typename")
    if_null rx1049_debug, debug_993
    rx1049_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1049_pos)
  debug_993:
    .return (rx1049_cur)
  rx1049_restart:
.annotate 'line', 10
    if_null rx1049_debug, debug_994
    rx1049_cur."!cursor_debug"("NEXT", "typename")
  debug_994:
  rx1049_fail:
    (rx1049_rep, rx1049_pos, $I10, $P10) = rx1049_cur."!mark_fail"(0)
    lt rx1049_pos, -1, rx1049_done
    eq rx1049_pos, -1, rx1049_fail
    jump $I10
  rx1049_done:
    rx1049_cur."!cursor_fail"()
    if_null rx1049_debug, debug_995
    rx1049_cur."!cursor_debug"("FAIL", "typename")
  debug_995:
    .return (rx1049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303857440.612") :method
.annotate 'line', 10
    $P1051 = self."!PREFIX__!subrule"("name", "")
    new $P1052, "ResizablePMCArray"
    push $P1052, $P1051
    .return ($P1052)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1055_tgt
    .local int rx1055_pos
    .local int rx1055_off
    .local int rx1055_eos
    .local int rx1055_rep
    .local pmc rx1055_cur
    .local pmc rx1055_debug
    (rx1055_cur, rx1055_pos, rx1055_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1055_cur
    .local pmc match
    .lex "$/", match
    length rx1055_eos, rx1055_tgt
    gt rx1055_pos, rx1055_eos, rx1055_done
    set rx1055_off, 0
    lt rx1055_pos, 2, rx1055_start
    sub rx1055_off, rx1055_pos, 1
    substr rx1055_tgt, rx1055_tgt, rx1055_off
  rx1055_start:
    eq $I10, 1, rx1055_restart
    if_null rx1055_debug, debug_996
    rx1055_cur."!cursor_debug"("START", "declarator")
  debug_996:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1060_done
    goto rxscan1060_scan
  rxscan1060_loop:
    (rx1055_pos) = rx1055_cur."from"()
    inc rx1055_pos
    rx1055_cur."!cursor_from"(rx1055_pos)
    ge rx1055_pos, rx1055_eos, rxscan1060_done
  rxscan1060_scan:
    set_addr $I10, rxscan1060_loop
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
  rxscan1060_done:
  alt1061_0:
.annotate 'line', 403
    set_addr $I10, alt1061_1
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
.annotate 'line', 404
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."variable_declarator"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1055_pos = $P10."pos"()
    goto alt1061_end
  alt1061_1:
.annotate 'line', 405
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."routine_declarator"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1055_pos = $P10."pos"()
  alt1061_end:
.annotate 'line', 403
  # rx pass
    rx1055_cur."!cursor_pass"(rx1055_pos, "declarator")
    if_null rx1055_debug, debug_997
    rx1055_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1055_pos)
  debug_997:
    .return (rx1055_cur)
  rx1055_restart:
.annotate 'line', 10
    if_null rx1055_debug, debug_998
    rx1055_cur."!cursor_debug"("NEXT", "declarator")
  debug_998:
  rx1055_fail:
    (rx1055_rep, rx1055_pos, $I10, $P10) = rx1055_cur."!mark_fail"(0)
    lt rx1055_pos, -1, rx1055_done
    eq rx1055_pos, -1, rx1055_fail
    jump $I10
  rx1055_done:
    rx1055_cur."!cursor_fail"()
    if_null rx1055_debug, debug_999
    rx1055_cur."!cursor_debug"("FAIL", "declarator")
  debug_999:
    .return (rx1055_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303857440.612") :method
.annotate 'line', 10
    $P1057 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1058 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1059, "ResizablePMCArray"
    push $P1059, $P1057
    push $P1059, $P1058
    .return ($P1059)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1063_tgt
    .local int rx1063_pos
    .local int rx1063_off
    .local int rx1063_eos
    .local int rx1063_rep
    .local pmc rx1063_cur
    .local pmc rx1063_debug
    (rx1063_cur, rx1063_pos, rx1063_tgt, $I10) = self."!cursor_start"()
    rx1063_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1063_cur
    .local pmc match
    .lex "$/", match
    length rx1063_eos, rx1063_tgt
    gt rx1063_pos, rx1063_eos, rx1063_done
    set rx1063_off, 0
    lt rx1063_pos, 2, rx1063_start
    sub rx1063_off, rx1063_pos, 1
    substr rx1063_tgt, rx1063_tgt, rx1063_off
  rx1063_start:
    eq $I10, 1, rx1063_restart
    if_null rx1063_debug, debug_1000
    rx1063_cur."!cursor_debug"("START", "variable_declarator")
  debug_1000:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1067_done
    goto rxscan1067_scan
  rxscan1067_loop:
    (rx1063_pos) = rx1063_cur."from"()
    inc rx1063_pos
    rx1063_cur."!cursor_from"(rx1063_pos)
    ge rx1063_pos, rx1063_eos, rxscan1067_done
  rxscan1067_scan:
    set_addr $I10, rxscan1067_loop
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10)
  rxscan1067_done:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx rxquantr1069 ** 0..1
    set_addr $I10, rxquantr1069_done
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10)
  rxquantr1069_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."typename"()
    unless $P10, rx1063_fail
    goto rxsubrule1070_pass
  rxsubrule1070_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1063_fail
  rxsubrule1070_pass:
    set_addr $I10, rxsubrule1070_back
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1063_pos = $P10."pos"()
    set_addr $I10, rxquantr1069_done
    (rx1063_rep) = rx1063_cur."!mark_commit"($I10)
  rxquantr1069_done:
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."variable"()
    unless $P10, rx1063_fail
    rx1063_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1063_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx pass
    rx1063_cur."!cursor_pass"(rx1063_pos, "variable_declarator")
    if_null rx1063_debug, debug_1001
    rx1063_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1063_pos)
  debug_1001:
    .return (rx1063_cur)
  rx1063_restart:
.annotate 'line', 10
    if_null rx1063_debug, debug_1002
    rx1063_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1002:
  rx1063_fail:
    (rx1063_rep, rx1063_pos, $I10, $P10) = rx1063_cur."!mark_fail"(0)
    lt rx1063_pos, -1, rx1063_done
    eq rx1063_pos, -1, rx1063_fail
    jump $I10
  rx1063_done:
    rx1063_cur."!cursor_fail"()
    if_null rx1063_debug, debug_1003
    rx1063_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1003:
    .return (rx1063_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303857440.612") :method
.annotate 'line', 10
    $P1065 = self."!PREFIX__!subrule"("ws", "")
    new $P1066, "ResizablePMCArray"
    push $P1066, $P1065
    .return ($P1066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303857440.612")
    .param pmc param_1074
.annotate 'line', 410
    .lex "self", param_1074
    $P1075 = param_1074."!protoregex"("routine_declarator")
    .return ($P1075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303857440.612")
    .param pmc param_1077
.annotate 'line', 410
    .lex "self", param_1077
    $P1078 = param_1077."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1078)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_1004
    rx1080_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1004:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1084_done:
.annotate 'line', 411
  # rx subcapture "sym"
    set_addr $I10, rxcap_1085_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1080_pos, 3
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 3
    ne $S10, "sub", rx1080_fail
    add rx1080_pos, 3
    set_addr $I10, rxcap_1085_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1085_done
  rxcap_1085_fail:
    goto rx1080_fail
  rxcap_1085_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."routine_def"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1080_pos = $P10."pos"()
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "routine_declarator:sym<sub>")
    if_null rx1080_debug, debug_1005
    rx1080_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1080_pos)
  debug_1005:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 10
    if_null rx1080_debug, debug_1006
    rx1080_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1006:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_1007
    rx1080_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1007:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303857440.612") :method
.annotate 'line', 10
    $P1082 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1083, "ResizablePMCArray"
    push $P1083, $P1082
    .return ($P1083)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1087_tgt
    .local int rx1087_pos
    .local int rx1087_off
    .local int rx1087_eos
    .local int rx1087_rep
    .local pmc rx1087_cur
    .local pmc rx1087_debug
    (rx1087_cur, rx1087_pos, rx1087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1087_cur
    .local pmc match
    .lex "$/", match
    length rx1087_eos, rx1087_tgt
    gt rx1087_pos, rx1087_eos, rx1087_done
    set rx1087_off, 0
    lt rx1087_pos, 2, rx1087_start
    sub rx1087_off, rx1087_pos, 1
    substr rx1087_tgt, rx1087_tgt, rx1087_off
  rx1087_start:
    eq $I10, 1, rx1087_restart
    if_null rx1087_debug, debug_1008
    rx1087_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1008:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1091_done
    goto rxscan1091_scan
  rxscan1091_loop:
    (rx1087_pos) = rx1087_cur."from"()
    inc rx1087_pos
    rx1087_cur."!cursor_from"(rx1087_pos)
    ge rx1087_pos, rx1087_eos, rxscan1091_done
  rxscan1091_scan:
    set_addr $I10, rxscan1091_loop
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxscan1091_done:
.annotate 'line', 412
  # rx subcapture "sym"
    set_addr $I10, rxcap_1092_fail
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  # rx literal  "method"
    add $I11, rx1087_pos, 6
    gt $I11, rx1087_eos, rx1087_fail
    sub $I11, rx1087_pos, rx1087_off
    substr $S10, rx1087_tgt, $I11, 6
    ne $S10, "method", rx1087_fail
    add rx1087_pos, 6
    set_addr $I10, rxcap_1092_fail
    ($I12, $I11) = rx1087_cur."!mark_peek"($I10)
    rx1087_cur."!cursor_pos"($I11)
    ($P10) = rx1087_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1087_pos, "")
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1092_done
  rxcap_1092_fail:
    goto rx1087_fail
  rxcap_1092_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."method_def"()
    unless $P10, rx1087_fail
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1087_pos = $P10."pos"()
  # rx pass
    rx1087_cur."!cursor_pass"(rx1087_pos, "routine_declarator:sym<method>")
    if_null rx1087_debug, debug_1009
    rx1087_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1087_pos)
  debug_1009:
    .return (rx1087_cur)
  rx1087_restart:
.annotate 'line', 10
    if_null rx1087_debug, debug_1010
    rx1087_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1010:
  rx1087_fail:
    (rx1087_rep, rx1087_pos, $I10, $P10) = rx1087_cur."!mark_fail"(0)
    lt rx1087_pos, -1, rx1087_done
    eq rx1087_pos, -1, rx1087_fail
    jump $I10
  rx1087_done:
    rx1087_cur."!cursor_fail"()
    if_null rx1087_debug, debug_1011
    rx1087_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1011:
    .return (rx1087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303857440.612") :method
.annotate 'line', 10
    $P1089 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1090, "ResizablePMCArray"
    push $P1090, $P1089
    .return ($P1090)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 415
    new $P1094, "Undef"
    .lex "$*RETURN_USED", $P1094
.annotate 'line', 10
    .local string rx1095_tgt
    .local int rx1095_pos
    .local int rx1095_off
    .local int rx1095_eos
    .local int rx1095_rep
    .local pmc rx1095_cur
    .local pmc rx1095_debug
    (rx1095_cur, rx1095_pos, rx1095_tgt, $I10) = self."!cursor_start"()
    rx1095_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1095_cur
    .local pmc match
    .lex "$/", match
    length rx1095_eos, rx1095_tgt
    gt rx1095_pos, rx1095_eos, rx1095_done
    set rx1095_off, 0
    lt rx1095_pos, 2, rx1095_start
    sub rx1095_off, rx1095_pos, 1
    substr rx1095_tgt, rx1095_tgt, rx1095_off
  rx1095_start:
    eq $I10, 1, rx1095_restart
    if_null rx1095_debug, debug_1012
    rx1095_cur."!cursor_debug"("START", "routine_def")
  debug_1012:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1099_done
    goto rxscan1099_scan
  rxscan1099_loop:
    (rx1095_pos) = rx1095_cur."from"()
    inc rx1095_pos
    rx1095_cur."!cursor_from"(rx1095_pos)
    ge rx1095_pos, rx1095_eos, rxscan1099_done
  rxscan1099_scan:
    set_addr $I10, rxscan1099_loop
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxscan1099_done:
.annotate 'line', 414
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 415
    rx1095_cur."!cursor_pos"(rx1095_pos)
    new $P1101, "Integer"
    assign $P1101, 0
    store_lex "$*RETURN_USED", $P1101
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 416
  # rx rxquantr1103 ** 0..1
    set_addr $I10, rxquantr1103_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1103_loop:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1106_fail
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx rxquantr1105 ** 0..1
    set_addr $I10, rxquantr1105_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1105_loop:
  # rx literal  "&"
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 38, rx1095_fail
    add rx1095_pos, 1
    set_addr $I10, rxquantr1105_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1105_done:
    set_addr $I10, rxcap_1106_fail
    ($I12, $I11) = rx1095_cur."!mark_peek"($I10)
    rx1095_cur."!cursor_pos"($I11)
    ($P10) = rx1095_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1095_pos, "")
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1106_done
  rxcap_1106_fail:
    goto rx1095_fail
  rxcap_1106_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."deflongname"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1103_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1103_done:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 417
  # rx subrule "newpad" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."newpad"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1110_0:
.annotate 'line', 418
    set_addr $I10, alt1110_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 40, rx1095_fail
    add rx1095_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."signature"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 41, rx1095_fail
    add rx1095_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    goto alt1110_end
  alt1110_1:
.annotate 'line', 419
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1110_end:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 420
  # rx rxquantr1118 ** 0..*
    set_addr $I10, rxquantr1118_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1118_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."trait"()
    unless $P10, rx1095_fail
    goto rxsubrule1119_pass
  rxsubrule1119_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1095_fail
  rxsubrule1119_pass:
    set_addr $I10, rxsubrule1119_back
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1118_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1118_done
    rx1095_cur."!mark_push"(rx1095_rep, rx1095_pos, $I10)
    goto rxquantr1118_loop
  rxquantr1118_done:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1121_0:
.annotate 'line', 421
    set_addr $I10, alt1121_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."onlystar"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    goto alt1121_end
  alt1121_1:
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."blockoid"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1121_end:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 414
  # rx pass
    rx1095_cur."!cursor_pass"(rx1095_pos, "routine_def")
    if_null rx1095_debug, debug_1013
    rx1095_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1095_pos)
  debug_1013:
    .return (rx1095_cur)
  rx1095_restart:
.annotate 'line', 10
    if_null rx1095_debug, debug_1014
    rx1095_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1014:
  rx1095_fail:
    (rx1095_rep, rx1095_pos, $I10, $P10) = rx1095_cur."!mark_fail"(0)
    lt rx1095_pos, -1, rx1095_done
    eq rx1095_pos, -1, rx1095_fail
    jump $I10
  rx1095_done:
    rx1095_cur."!cursor_fail"()
    if_null rx1095_debug, debug_1015
    rx1095_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1015:
    .return (rx1095_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303857440.612") :method
.annotate 'line', 10
    $P1097 = self."!PREFIX__!subrule"("ws", "")
    new $P1098, "ResizablePMCArray"
    push $P1098, $P1097
    .return ($P1098)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P1158 = "181_1303857440.612" 
    capture_lex $P1158
.annotate 'line', 428
    new $P1128, "Undef"
    .lex "$*RETURN_USED", $P1128
.annotate 'line', 429
    new $P1129, "Undef"
    .lex "$*INVOCANT_OK", $P1129
.annotate 'line', 10
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    rx1130_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_1016
    rx1130_cur."!cursor_debug"("START", "method_def")
  debug_1016:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 428
    rx1130_cur."!cursor_pos"(rx1130_pos)
    new $P1136, "Integer"
    assign $P1136, 0
    store_lex "$*RETURN_USED", $P1136
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 429
    rx1130_cur."!cursor_pos"(rx1130_pos)
    new $P1138, "Integer"
    assign $P1138, 1
    store_lex "$*INVOCANT_OK", $P1138
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 430
  # rx subcapture "private"
    set_addr $I10, rxcap_1141_fail
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  # rx rxquantr1140 ** 0..1
    set_addr $I10, rxquantr1140_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1140_loop:
  # rx literal  "!"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 33, rx1130_fail
    add rx1130_pos, 1
    set_addr $I10, rxquantr1140_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1140_done:
    set_addr $I10, rxcap_1141_fail
    ($I12, $I11) = rx1130_cur."!mark_peek"($I10)
    rx1130_cur."!cursor_pos"($I11)
    ($P10) = rx1130_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1130_pos, "")
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1141_done
  rxcap_1141_fail:
    goto rx1130_fail
  rxcap_1141_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 431
  # rx rxquantr1143 ** 0..1
    set_addr $I10, rxquantr1143_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1143_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."deflongname"()
    unless $P10, rx1130_fail
    goto rxsubrule1144_pass
  rxsubrule1144_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1144_pass:
    set_addr $I10, rxsubrule1144_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1143_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1143_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 432
  # rx subrule "newpad" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."newpad"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1147_0:
.annotate 'line', 433
    set_addr $I10, alt1147_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 40, rx1130_fail
    add rx1130_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."signature"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 41, rx1130_fail
    add rx1130_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
    goto alt1147_end
  alt1147_1:
.annotate 'line', 434
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1147_end:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 435
    rx1130_cur."!cursor_pos"(rx1130_pos)
    find_lex $P1155, unicode:"$\x{a2}"
    $P1156 = $P1155."MATCH"()
    store_lex "$/", $P1156
    .const 'Sub' $P1158 = "181_1303857440.612" 
    capture_lex $P1158
    $P1160 = $P1158()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 436
  # rx rxquantr1162 ** 0..*
    set_addr $I10, rxquantr1162_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1162_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."trait"()
    unless $P10, rx1130_fail
    goto rxsubrule1163_pass
  rxsubrule1163_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1163_pass:
    set_addr $I10, rxsubrule1163_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1162_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1162_done
    rx1130_cur."!mark_push"(rx1130_rep, rx1130_pos, $I10)
    goto rxquantr1162_loop
  rxquantr1162_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1165_0:
.annotate 'line', 437
    set_addr $I10, alt1165_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."onlystar"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
    goto alt1165_end
  alt1165_1:
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."blockoid"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1165_end:
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 427
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "method_def")
    if_null rx1130_debug, debug_1017
    rx1130_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1130_pos)
  debug_1017:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 10
    if_null rx1130_debug, debug_1018
    rx1130_cur."!cursor_debug"("NEXT", "method_def")
  debug_1018:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_1019
    rx1130_cur."!cursor_debug"("FAIL", "method_def")
  debug_1019:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303857440.612") :method
.annotate 'line', 10
    $P1132 = self."!PREFIX__!subrule"("ws", "")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1157"  :anon :subid("181_1303857440.612") :outer("179_1303857440.612")
.annotate 'line', 435
    new $P1159, "Integer"
    assign $P1159, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1159
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P1179 = "184_1303857440.612" 
    capture_lex $P1179
    .local string rx1172_tgt
    .local int rx1172_pos
    .local int rx1172_off
    .local int rx1172_eos
    .local int rx1172_rep
    .local pmc rx1172_cur
    .local pmc rx1172_debug
    (rx1172_cur, rx1172_pos, rx1172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1172_cur
    .local pmc match
    .lex "$/", match
    length rx1172_eos, rx1172_tgt
    gt rx1172_pos, rx1172_eos, rx1172_done
    set rx1172_off, 0
    lt rx1172_pos, 2, rx1172_start
    sub rx1172_off, rx1172_pos, 1
    substr rx1172_tgt, rx1172_tgt, rx1172_off
  rx1172_start:
    eq $I10, 1, rx1172_restart
    if_null rx1172_debug, debug_1020
    rx1172_cur."!cursor_debug"("START", "onlystar")
  debug_1020:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1172_pos) = rx1172_cur."from"()
    inc rx1172_pos
    rx1172_cur."!cursor_from"(rx1172_pos)
    ge rx1172_pos, rx1172_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1172_cur."!mark_push"(0, rx1172_pos, $I10)
  rxscan1175_done:
.annotate 'line', 444
    rx1172_cur."!cursor_pos"(rx1172_pos)
    find_lex $P1176, unicode:"$\x{a2}"
    $P1177 = $P1176."MATCH"()
    store_lex "$/", $P1177
    .const 'Sub' $P1179 = "184_1303857440.612" 
    capture_lex $P1179
    $P1185 = $P1179()
    unless $P1185, rx1172_fail
.annotate 'line', 445
  # rx literal  "{"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 123, rx1172_fail
    add rx1172_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 42, rx1172_fail
    add rx1172_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 125, rx1172_fail
    add rx1172_pos, 1
.annotate 'line', 446
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ENDSTMT"()
    unless $P10, rx1172_fail
.annotate 'line', 447
  # rx subrule "finishpad" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."finishpad"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
.annotate 'line', 443
  # rx pass
    rx1172_cur."!cursor_pass"(rx1172_pos, "onlystar")
    if_null rx1172_debug, debug_1023
    rx1172_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1172_pos)
  debug_1023:
    .return (rx1172_cur)
  rx1172_restart:
.annotate 'line', 10
    if_null rx1172_debug, debug_1024
    rx1172_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1024:
  rx1172_fail:
    (rx1172_rep, rx1172_pos, $I10, $P10) = rx1172_cur."!mark_fail"(0)
    lt rx1172_pos, -1, rx1172_done
    eq rx1172_pos, -1, rx1172_fail
    jump $I10
  rx1172_done:
    rx1172_cur."!cursor_fail"()
    if_null rx1172_debug, debug_1025
    rx1172_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1025:
    .return (rx1172_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303857440.612") :method
.annotate 'line', 10
    new $P1174, "ResizablePMCArray"
    push $P1174, ""
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1178"  :anon :subid("184_1303857440.612") :outer("182_1303857440.612")
.annotate 'line', 444
    find_dynamic_lex $P1182, "$*MULTINESS"
    unless_null $P1182, vivify_1021
    get_hll_global $P1180, "GLOBAL"
    get_who $P1181, $P1180
    set $P1182, $P1181["$MULTINESS"]
    unless_null $P1182, vivify_1022
    die "Contextual $*MULTINESS not found"
  vivify_1022:
  vivify_1021:
    set $S1183, $P1182
    iseq $I1184, $S1183, "proto"
    .return ($I1184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303857440.612")
    .param pmc param_1187
.annotate 'line', 450
    .lex "self", param_1187
    $P1188 = param_1187."!protoregex"("multi_declarator")
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303857440.612")
    .param pmc param_1190
.annotate 'line', 450
    .lex "self", param_1190
    $P1191 = param_1190."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1191)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 452
    new $P1193, "Undef"
    .lex "$*MULTINESS", $P1193
.annotate 'line', 10
    .local string rx1194_tgt
    .local int rx1194_pos
    .local int rx1194_off
    .local int rx1194_eos
    .local int rx1194_rep
    .local pmc rx1194_cur
    .local pmc rx1194_debug
    (rx1194_cur, rx1194_pos, rx1194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1194_cur
    .local pmc match
    .lex "$/", match
    length rx1194_eos, rx1194_tgt
    gt rx1194_pos, rx1194_eos, rx1194_done
    set rx1194_off, 0
    lt rx1194_pos, 2, rx1194_start
    sub rx1194_off, rx1194_pos, 1
    substr rx1194_tgt, rx1194_tgt, rx1194_off
  rx1194_start:
    eq $I10, 1, rx1194_restart
    if_null rx1194_debug, debug_1026
    rx1194_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1026:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1194_pos) = rx1194_cur."from"()
    inc rx1194_pos
    rx1194_cur."!cursor_from"(rx1194_pos)
    ge rx1194_pos, rx1194_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  rxscan1198_done:
.annotate 'line', 452
    rx1194_cur."!cursor_pos"(rx1194_pos)
    new $P1199, "String"
    assign $P1199, "multi"
    store_lex "$*MULTINESS", $P1199
.annotate 'line', 453
  # rx subcapture "sym"
    set_addr $I10, rxcap_1200_fail
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1194_pos, 5
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    substr $S10, rx1194_tgt, $I11, 5
    ne $S10, "multi", rx1194_fail
    add rx1194_pos, 5
    set_addr $I10, rxcap_1200_fail
    ($I12, $I11) = rx1194_cur."!mark_peek"($I10)
    rx1194_cur."!cursor_pos"($I11)
    ($P10) = rx1194_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1194_pos, "")
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1200_done
  rxcap_1200_fail:
    goto rx1194_fail
  rxcap_1200_done:
.annotate 'line', 454
  # rx subrule "ws" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."ws"()
    unless $P10, rx1194_fail
    rx1194_pos = $P10."pos"()
  alt1201_0:
    set_addr $I10, alt1201_1
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."declarator"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1194_pos = $P10."pos"()
    goto alt1201_end
  alt1201_1:
    set_addr $I10, alt1201_2
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."routine_def"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1194_pos = $P10."pos"()
    goto alt1201_end
  alt1201_2:
  # rx subrule "panic" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."panic"("Malformed multi")
    unless $P10, rx1194_fail
    rx1194_pos = $P10."pos"()
  alt1201_end:
.annotate 'line', 451
  # rx pass
    rx1194_cur."!cursor_pass"(rx1194_pos, "multi_declarator:sym<multi>")
    if_null rx1194_debug, debug_1027
    rx1194_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1194_pos)
  debug_1027:
    .return (rx1194_cur)
  rx1194_restart:
.annotate 'line', 10
    if_null rx1194_debug, debug_1028
    rx1194_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1028:
  rx1194_fail:
    (rx1194_rep, rx1194_pos, $I10, $P10) = rx1194_cur."!mark_fail"(0)
    lt rx1194_pos, -1, rx1194_done
    eq rx1194_pos, -1, rx1194_fail
    jump $I10
  rx1194_done:
    rx1194_cur."!cursor_fail"()
    if_null rx1194_debug, debug_1029
    rx1194_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1029:
    .return (rx1194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303857440.612") :method
.annotate 'line', 10
    $P1196 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1197, "ResizablePMCArray"
    push $P1197, $P1196
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 457
    new $P1203, "Undef"
    .lex "$*MULTINESS", $P1203
.annotate 'line', 10
    .local string rx1204_tgt
    .local int rx1204_pos
    .local int rx1204_off
    .local int rx1204_eos
    .local int rx1204_rep
    .local pmc rx1204_cur
    .local pmc rx1204_debug
    (rx1204_cur, rx1204_pos, rx1204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1204_cur
    .local pmc match
    .lex "$/", match
    length rx1204_eos, rx1204_tgt
    gt rx1204_pos, rx1204_eos, rx1204_done
    set rx1204_off, 0
    lt rx1204_pos, 2, rx1204_start
    sub rx1204_off, rx1204_pos, 1
    substr rx1204_tgt, rx1204_tgt, rx1204_off
  rx1204_start:
    eq $I10, 1, rx1204_restart
    if_null rx1204_debug, debug_1030
    rx1204_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1030:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1208_done
    goto rxscan1208_scan
  rxscan1208_loop:
    (rx1204_pos) = rx1204_cur."from"()
    inc rx1204_pos
    rx1204_cur."!cursor_from"(rx1204_pos)
    ge rx1204_pos, rx1204_eos, rxscan1208_done
  rxscan1208_scan:
    set_addr $I10, rxscan1208_loop
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  rxscan1208_done:
.annotate 'line', 457
    rx1204_cur."!cursor_pos"(rx1204_pos)
    new $P1209, "String"
    assign $P1209, "proto"
    store_lex "$*MULTINESS", $P1209
.annotate 'line', 458
  # rx subcapture "sym"
    set_addr $I10, rxcap_1210_fail
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1204_pos, 5
    gt $I11, rx1204_eos, rx1204_fail
    sub $I11, rx1204_pos, rx1204_off
    substr $S10, rx1204_tgt, $I11, 5
    ne $S10, "proto", rx1204_fail
    add rx1204_pos, 5
    set_addr $I10, rxcap_1210_fail
    ($I12, $I11) = rx1204_cur."!mark_peek"($I10)
    rx1204_cur."!cursor_pos"($I11)
    ($P10) = rx1204_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1204_pos, "")
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1210_done
  rxcap_1210_fail:
    goto rx1204_fail
  rxcap_1210_done:
.annotate 'line', 459
  # rx subrule "ws" subtype=method negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."ws"()
    unless $P10, rx1204_fail
    rx1204_pos = $P10."pos"()
  alt1211_0:
    set_addr $I10, alt1211_1
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."declarator"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1204_pos = $P10."pos"()
    goto alt1211_end
  alt1211_1:
    set_addr $I10, alt1211_2
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."routine_def"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1204_pos = $P10."pos"()
    goto alt1211_end
  alt1211_2:
  # rx subrule "panic" subtype=method negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."panic"("Malformed proto")
    unless $P10, rx1204_fail
    rx1204_pos = $P10."pos"()
  alt1211_end:
.annotate 'line', 456
  # rx pass
    rx1204_cur."!cursor_pass"(rx1204_pos, "multi_declarator:sym<proto>")
    if_null rx1204_debug, debug_1031
    rx1204_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1204_pos)
  debug_1031:
    .return (rx1204_cur)
  rx1204_restart:
.annotate 'line', 10
    if_null rx1204_debug, debug_1032
    rx1204_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1032:
  rx1204_fail:
    (rx1204_rep, rx1204_pos, $I10, $P10) = rx1204_cur."!mark_fail"(0)
    lt rx1204_pos, -1, rx1204_done
    eq rx1204_pos, -1, rx1204_fail
    jump $I10
  rx1204_done:
    rx1204_cur."!cursor_fail"()
    if_null rx1204_debug, debug_1033
    rx1204_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1033:
    .return (rx1204_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303857440.612") :method
.annotate 'line', 10
    $P1206 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1207, "ResizablePMCArray"
    push $P1207, $P1206
    .return ($P1207)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 462
    new $P1213, "Undef"
    .lex "$*MULTINESS", $P1213
.annotate 'line', 10
    .local string rx1214_tgt
    .local int rx1214_pos
    .local int rx1214_off
    .local int rx1214_eos
    .local int rx1214_rep
    .local pmc rx1214_cur
    .local pmc rx1214_debug
    (rx1214_cur, rx1214_pos, rx1214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1214_cur
    .local pmc match
    .lex "$/", match
    length rx1214_eos, rx1214_tgt
    gt rx1214_pos, rx1214_eos, rx1214_done
    set rx1214_off, 0
    lt rx1214_pos, 2, rx1214_start
    sub rx1214_off, rx1214_pos, 1
    substr rx1214_tgt, rx1214_tgt, rx1214_off
  rx1214_start:
    eq $I10, 1, rx1214_restart
    if_null rx1214_debug, debug_1034
    rx1214_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1214_pos) = rx1214_cur."from"()
    inc rx1214_pos
    rx1214_cur."!cursor_from"(rx1214_pos)
    ge rx1214_pos, rx1214_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxscan1218_done:
.annotate 'line', 462
    rx1214_cur."!cursor_pos"(rx1214_pos)
    new $P1219, "String"
    assign $P1219, ""
    store_lex "$*MULTINESS", $P1219
.annotate 'line', 463
  # rx subrule "declarator" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."declarator"()
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1214_pos = $P10."pos"()
.annotate 'line', 461
  # rx pass
    rx1214_cur."!cursor_pass"(rx1214_pos, "multi_declarator:sym<null>")
    if_null rx1214_debug, debug_1035
    rx1214_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1214_pos)
  debug_1035:
    .return (rx1214_cur)
  rx1214_restart:
.annotate 'line', 10
    if_null rx1214_debug, debug_1036
    rx1214_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1036:
  rx1214_fail:
    (rx1214_rep, rx1214_pos, $I10, $P10) = rx1214_cur."!mark_fail"(0)
    lt rx1214_pos, -1, rx1214_done
    eq rx1214_pos, -1, rx1214_fail
    jump $I10
  rx1214_done:
    rx1214_cur."!cursor_fail"()
    if_null rx1214_debug, debug_1037
    rx1214_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1037:
    .return (rx1214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303857440.612") :method
.annotate 'line', 10
    $P1216 = self."!PREFIX__!subrule"("declarator", "")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1216
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P1229 = "195_1303857440.612" 
    capture_lex $P1229
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    rx1221_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1038
    rx1221_cur."!cursor_debug"("START", "signature")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 467
  # rx rxquantr1225 ** 0..1
    set_addr $I10, rxquantr1225_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1225_loop:
    rx1221_cur."!cursor_pos"(rx1221_pos)
    find_lex $P1226, unicode:"$\x{a2}"
    $P1227 = $P1226."MATCH"()
    store_lex "$/", $P1227
    .const 'Sub' $P1229 = "195_1303857440.612" 
    capture_lex $P1229
    $P1233 = $P1229()
    unless $P1233, rx1221_fail
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."parameter"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1221_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1221_pos, 1
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    ord $I11, rx1221_tgt, $I11
    ne $I11, 58, rx1221_fail
    add rx1221_pos, 1
    set_addr $I10, rxquantr1225_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1225_done:
.annotate 'line', 468
  # rx rxquantr1234 ** 0..1
    set_addr $I10, rxquantr1234_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1234_loop:
  # rx rxquantr1235 ** 1..*
    set_addr $I10, rxquantr1235_done
    rx1221_cur."!mark_push"(0, -1, $I10)
  rxquantr1235_loop:
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."parameter"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1221_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
    set_addr $I10, rxquantr1235_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1235_done
    rx1221_cur."!mark_push"(rx1221_rep, rx1221_pos, $I10)
  # rx literal  ","
    add $I11, rx1221_pos, 1
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    ord $I11, rx1221_tgt, $I11
    ne $I11, 44, rx1221_fail
    add rx1221_pos, 1
    goto rxquantr1235_loop
  rxquantr1235_done:
    set_addr $I10, rxquantr1234_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1234_done:
.annotate 'line', 466
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "signature")
    if_null rx1221_debug, debug_1041
    rx1221_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1221_pos)
  debug_1041:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1042
    rx1221_cur."!cursor_debug"("NEXT", "signature")
  debug_1042:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1043
    rx1221_cur."!cursor_debug"("FAIL", "signature")
  debug_1043:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303857440.612") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, ""
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1228"  :anon :subid("195_1303857440.612") :outer("193_1303857440.612")
.annotate 'line', 467
    find_dynamic_lex $P1232, "$*INVOCANT_OK"
    unless_null $P1232, vivify_1039
    get_hll_global $P1230, "GLOBAL"
    get_who $P1231, $P1230
    set $P1232, $P1231["$INVOCANT_OK"]
    unless_null $P1232, vivify_1040
    die "Contextual $*INVOCANT_OK not found"
  vivify_1040:
  vivify_1039:
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    rx1237_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_1044
    rx1237_cur."!cursor_debug"("START", "parameter")
  debug_1044:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1240_done:
.annotate 'line', 472
  # rx rxquantr1241 ** 0..*
    set_addr $I10, rxquantr1241_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1241_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."typename"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1237_pos = $P10."pos"()
  # rx rxquantr1242 ** 0..1
    set_addr $I10, rxquantr1242_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1242_loop:
  # rx literal  ":"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 58, rx1237_fail
    add rx1237_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1243_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1237_pos, rx1237_eos, rx1237_fail
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1237_fail
    inc rx1237_pos
    set_addr $I10, rxcap_1243_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1243_done
  rxcap_1243_fail:
    goto rx1237_fail
  rxcap_1243_done:
    set_addr $I10, rxquantr1242_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
  rxquantr1242_done:
  # rx subrule "ws" subtype=method negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."ws"()
    unless $P10, rx1237_fail
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1241_done
    rx1237_cur."!mark_push"(rx1237_rep, rx1237_pos, $I10)
    goto rxquantr1241_loop
  rxquantr1241_done:
  alt1244_0:
.annotate 'line', 473
    set_addr $I10, alt1244_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
.annotate 'line', 474
  # rx subcapture "quant"
    set_addr $I10, rxcap_1245_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "*"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 42, rx1237_fail
    add rx1237_pos, 1
    set_addr $I10, rxcap_1245_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1245_done
  rxcap_1245_fail:
    goto rx1237_fail
  rxcap_1245_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."param_var"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1237_pos = $P10."pos"()
    goto alt1244_end
  alt1244_1:
  alt1246_0:
.annotate 'line', 475
    set_addr $I10, alt1246_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."param_var"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1237_pos = $P10."pos"()
    goto alt1246_end
  alt1246_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."named_param"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1237_pos = $P10."pos"()
  alt1246_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1248_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  alt1247_0:
    set_addr $I10, alt1247_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "?"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 63, rx1237_fail
    add rx1237_pos, 1
    goto alt1247_end
  alt1247_1:
    set_addr $I10, alt1247_2
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "!"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 33, rx1237_fail
    add rx1237_pos, 1
    goto alt1247_end
  alt1247_2:
  alt1247_end:
    set_addr $I10, rxcap_1248_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1248_done
  rxcap_1248_fail:
    goto rx1237_fail
  rxcap_1248_done:
  alt1244_end:
.annotate 'line', 477
  # rx rxquantr1249 ** 0..1
    set_addr $I10, rxquantr1249_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1249_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."default_value"()
    unless $P10, rx1237_fail
    goto rxsubrule1250_pass
  rxsubrule1250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1237_fail
  rxsubrule1250_pass:
    set_addr $I10, rxsubrule1250_back
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1249_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
  rxquantr1249_done:
.annotate 'line', 471
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "parameter")
    if_null rx1237_debug, debug_1045
    rx1237_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1237_pos)
  debug_1045:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 10
    if_null rx1237_debug, debug_1046
    rx1237_cur."!cursor_debug"("NEXT", "parameter")
  debug_1046:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_1047
    rx1237_cur."!cursor_debug"("FAIL", "parameter")
  debug_1047:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303857440.612") :method
.annotate 'line', 10
    new $P1239, "ResizablePMCArray"
    push $P1239, ""
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    rx1252_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_1048
    rx1252_cur."!cursor_debug"("START", "param_var")
  debug_1048:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1256_done
    goto rxscan1256_scan
  rxscan1256_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1256_done
  rxscan1256_scan:
    set_addr $I10, rxscan1256_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1256_done:
.annotate 'line', 481
  # rx subrule "sigil" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."sigil"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1252_pos = $P10."pos"()
  # rx rxquantr1257 ** 0..1
    set_addr $I10, rxquantr1257_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1257_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."twigil"()
    unless $P10, rx1252_fail
    goto rxsubrule1258_pass
  rxsubrule1258_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1252_fail
  rxsubrule1258_pass:
    set_addr $I10, rxsubrule1258_back
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1252_pos = $P10."pos"()
    set_addr $I10, rxquantr1257_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1257_done:
  alt1259_0:
.annotate 'line', 482
    set_addr $I10, alt1259_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ident"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1252_pos = $P10."pos"()
    goto alt1259_end
  alt1259_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1260_fail
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1252_pos, rx1252_eos, rx1252_fail
    sub $I10, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1252_fail
    inc rx1252_pos
    set_addr $I10, rxcap_1260_fail
    ($I12, $I11) = rx1252_cur."!mark_peek"($I10)
    rx1252_cur."!cursor_pos"($I11)
    ($P10) = rx1252_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1252_pos, "")
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1260_done
  rxcap_1260_fail:
    goto rx1252_fail
  rxcap_1260_done:
  alt1259_end:
.annotate 'line', 480
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "param_var")
    if_null rx1252_debug, debug_1049
    rx1252_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1252_pos)
  debug_1049:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 10
    if_null rx1252_debug, debug_1050
    rx1252_cur."!cursor_debug"("NEXT", "param_var")
  debug_1050:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_1051
    rx1252_cur."!cursor_debug"("FAIL", "param_var")
  debug_1051:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303857440.612") :method
.annotate 'line', 10
    $P1254 = self."!PREFIX__!subrule"("sigil", "")
    new $P1255, "ResizablePMCArray"
    push $P1255, $P1254
    .return ($P1255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1052
    rx1262_cur."!cursor_debug"("START", "named_param")
  debug_1052:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1266_done
    goto rxscan1266_scan
  rxscan1266_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1266_done
  rxscan1266_scan:
    set_addr $I10, rxscan1266_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1266_done:
.annotate 'line', 486
  # rx literal  ":"
    add $I11, rx1262_pos, 1
    gt $I11, rx1262_eos, rx1262_fail
    sub $I11, rx1262_pos, rx1262_off
    ord $I11, rx1262_tgt, $I11
    ne $I11, 58, rx1262_fail
    add rx1262_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."param_var"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1262_pos = $P10."pos"()
.annotate 'line', 485
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "named_param")
    if_null rx1262_debug, debug_1053
    rx1262_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1262_pos)
  debug_1053:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1054
    rx1262_cur."!cursor_debug"("NEXT", "named_param")
  debug_1054:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1055
    rx1262_cur."!cursor_debug"("FAIL", "named_param")
  debug_1055:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303857440.612") :method
.annotate 'line', 10
    $P1264 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1265, "ResizablePMCArray"
    push $P1265, $P1264
    .return ($P1265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1268_tgt
    .local int rx1268_pos
    .local int rx1268_off
    .local int rx1268_eos
    .local int rx1268_rep
    .local pmc rx1268_cur
    .local pmc rx1268_debug
    (rx1268_cur, rx1268_pos, rx1268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1268_cur
    .local pmc match
    .lex "$/", match
    length rx1268_eos, rx1268_tgt
    gt rx1268_pos, rx1268_eos, rx1268_done
    set rx1268_off, 0
    lt rx1268_pos, 2, rx1268_start
    sub rx1268_off, rx1268_pos, 1
    substr rx1268_tgt, rx1268_tgt, rx1268_off
  rx1268_start:
    eq $I10, 1, rx1268_restart
    if_null rx1268_debug, debug_1056
    rx1268_cur."!cursor_debug"("START", "default_value")
  debug_1056:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1272_done
    goto rxscan1272_scan
  rxscan1272_loop:
    (rx1268_pos) = rx1268_cur."from"()
    inc rx1268_pos
    rx1268_cur."!cursor_from"(rx1268_pos)
    ge rx1268_pos, rx1268_eos, rxscan1272_done
  rxscan1272_scan:
    set_addr $I10, rxscan1272_loop
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10)
  rxscan1272_done:
.annotate 'line', 489
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1268_pos, 1
    gt $I11, rx1268_eos, rx1268_fail
    sub $I11, rx1268_pos, rx1268_off
    ord $I11, rx1268_tgt, $I11
    ne $I11, 61, rx1268_fail
    add rx1268_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."EXPR"("i=")
    unless $P10, rx1268_fail
    rx1268_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1268_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx pass
    rx1268_cur."!cursor_pass"(rx1268_pos, "default_value")
    if_null rx1268_debug, debug_1057
    rx1268_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1268_pos)
  debug_1057:
    .return (rx1268_cur)
  rx1268_restart:
.annotate 'line', 10
    if_null rx1268_debug, debug_1058
    rx1268_cur."!cursor_debug"("NEXT", "default_value")
  debug_1058:
  rx1268_fail:
    (rx1268_rep, rx1268_pos, $I10, $P10) = rx1268_cur."!mark_fail"(0)
    lt rx1268_pos, -1, rx1268_done
    eq rx1268_pos, -1, rx1268_fail
    jump $I10
  rx1268_done:
    rx1268_cur."!cursor_fail"()
    if_null rx1268_debug, debug_1059
    rx1268_cur."!cursor_debug"("FAIL", "default_value")
  debug_1059:
    .return (rx1268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303857440.612") :method
.annotate 'line', 10
    $P1270 = self."!PREFIX__!subrule"("ws", "")
    new $P1271, "ResizablePMCArray"
    push $P1271, $P1270
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1277_tgt
    .local int rx1277_pos
    .local int rx1277_off
    .local int rx1277_eos
    .local int rx1277_rep
    .local pmc rx1277_cur
    .local pmc rx1277_debug
    (rx1277_cur, rx1277_pos, rx1277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1277_cur
    .local pmc match
    .lex "$/", match
    length rx1277_eos, rx1277_tgt
    gt rx1277_pos, rx1277_eos, rx1277_done
    set rx1277_off, 0
    lt rx1277_pos, 2, rx1277_start
    sub rx1277_off, rx1277_pos, 1
    substr rx1277_tgt, rx1277_tgt, rx1277_off
  rx1277_start:
    eq $I10, 1, rx1277_restart
    if_null rx1277_debug, debug_1060
    rx1277_cur."!cursor_debug"("START", "trait")
  debug_1060:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1281_done
    goto rxscan1281_scan
  rxscan1281_loop:
    (rx1277_pos) = rx1277_cur."from"()
    inc rx1277_pos
    rx1277_cur."!cursor_from"(rx1277_pos)
    ge rx1277_pos, rx1277_eos, rxscan1281_done
  rxscan1281_scan:
    set_addr $I10, rxscan1281_loop
    rx1277_cur."!mark_push"(0, rx1277_pos, $I10)
  rxscan1281_done:
.annotate 'line', 491
  # rx subrule "ws" subtype=method negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."ws"()
    unless $P10, rx1277_fail
    rx1277_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."trait_mod"()
    unless $P10, rx1277_fail
    rx1277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."ws"()
    unless $P10, rx1277_fail
    rx1277_pos = $P10."pos"()
  # rx pass
    rx1277_cur."!cursor_pass"(rx1277_pos, "trait")
    if_null rx1277_debug, debug_1061
    rx1277_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1277_pos)
  debug_1061:
    .return (rx1277_cur)
  rx1277_restart:
.annotate 'line', 10
    if_null rx1277_debug, debug_1062
    rx1277_cur."!cursor_debug"("NEXT", "trait")
  debug_1062:
  rx1277_fail:
    (rx1277_rep, rx1277_pos, $I10, $P10) = rx1277_cur."!mark_fail"(0)
    lt rx1277_pos, -1, rx1277_done
    eq rx1277_pos, -1, rx1277_fail
    jump $I10
  rx1277_done:
    rx1277_cur."!cursor_fail"()
    if_null rx1277_debug, debug_1063
    rx1277_cur."!cursor_debug"("FAIL", "trait")
  debug_1063:
    .return (rx1277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303857440.612") :method
.annotate 'line', 10
    $P1279 = self."!PREFIX__!subrule"("ws", "")
    new $P1280, "ResizablePMCArray"
    push $P1280, $P1279
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303857440.612")
    .param pmc param_1285
.annotate 'line', 493
    .lex "self", param_1285
    $P1286 = param_1285."!protoregex"("trait_mod")
    .return ($P1286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303857440.612")
    .param pmc param_1288
.annotate 'line', 493
    .lex "self", param_1288
    $P1289 = param_1288."!PREFIX__!protoregex"("trait_mod")
    .return ($P1289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1291_tgt
    .local int rx1291_pos
    .local int rx1291_off
    .local int rx1291_eos
    .local int rx1291_rep
    .local pmc rx1291_cur
    .local pmc rx1291_debug
    (rx1291_cur, rx1291_pos, rx1291_tgt, $I10) = self."!cursor_start"()
    rx1291_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1291_cur
    .local pmc match
    .lex "$/", match
    length rx1291_eos, rx1291_tgt
    gt rx1291_pos, rx1291_eos, rx1291_done
    set rx1291_off, 0
    lt rx1291_pos, 2, rx1291_start
    sub rx1291_off, rx1291_pos, 1
    substr rx1291_tgt, rx1291_tgt, rx1291_off
  rx1291_start:
    eq $I10, 1, rx1291_restart
    if_null rx1291_debug, debug_1064
    rx1291_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1064:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1295_done
    goto rxscan1295_scan
  rxscan1295_loop:
    (rx1291_pos) = rx1291_cur."from"()
    inc rx1291_pos
    rx1291_cur."!cursor_from"(rx1291_pos)
    ge rx1291_pos, rx1291_eos, rxscan1295_done
  rxscan1295_scan:
    set_addr $I10, rxscan1295_loop
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxscan1295_done:
.annotate 'line', 494
  # rx subcapture "sym"
    set_addr $I10, rxcap_1296_fail
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  # rx literal  "is"
    add $I11, rx1291_pos, 2
    gt $I11, rx1291_eos, rx1291_fail
    sub $I11, rx1291_pos, rx1291_off
    substr $S10, rx1291_tgt, $I11, 2
    ne $S10, "is", rx1291_fail
    add rx1291_pos, 2
    set_addr $I10, rxcap_1296_fail
    ($I12, $I11) = rx1291_cur."!mark_peek"($I10)
    rx1291_cur."!cursor_pos"($I11)
    ($P10) = rx1291_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1291_pos, "")
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1296_done
  rxcap_1296_fail:
    goto rx1291_fail
  rxcap_1296_done:
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."deflongname"()
    unless $P10, rx1291_fail
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1291_pos = $P10."pos"()
  # rx rxquantr1298 ** 0..1
    set_addr $I10, rxquantr1298_done
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxquantr1298_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."circumfix"()
    unless $P10, rx1291_fail
    goto rxsubrule1299_pass
  rxsubrule1299_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1291_fail
  rxsubrule1299_pass:
    set_addr $I10, rxsubrule1299_back
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1291_pos = $P10."pos"()
    set_addr $I10, rxquantr1298_done
    (rx1291_rep) = rx1291_cur."!mark_commit"($I10)
  rxquantr1298_done:
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx pass
    rx1291_cur."!cursor_pass"(rx1291_pos, "trait_mod:sym<is>")
    if_null rx1291_debug, debug_1065
    rx1291_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1291_pos)
  debug_1065:
    .return (rx1291_cur)
  rx1291_restart:
.annotate 'line', 10
    if_null rx1291_debug, debug_1066
    rx1291_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1066:
  rx1291_fail:
    (rx1291_rep, rx1291_pos, $I10, $P10) = rx1291_cur."!mark_fail"(0)
    lt rx1291_pos, -1, rx1291_done
    eq rx1291_pos, -1, rx1291_fail
    jump $I10
  rx1291_done:
    rx1291_cur."!cursor_fail"()
    if_null rx1291_debug, debug_1067
    rx1291_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1067:
    .return (rx1291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303857440.612") :method
.annotate 'line', 10
    $P1293 = self."!PREFIX__!subrule"("ws", "is")
    new $P1294, "ResizablePMCArray"
    push $P1294, $P1293
    .return ($P1294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    rx1302_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_1068
    rx1302_cur."!cursor_debug"("START", "regex_declarator")
  debug_1068:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 496
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1308_0:
.annotate 'line', 497
    set_addr $I10, alt1308_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 498
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1310_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "proto", rx1302_fail
    add rx1302_pos, 5
    set_addr $I10, rxcap_1310_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1310_done
  rxcap_1310_fail:
    goto rx1302_fail
  rxcap_1310_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1312_0:
    set_addr $I10, alt1312_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "regex", rx1302_fail
    add rx1302_pos, 5
    goto alt1312_end
  alt1312_1:
    set_addr $I10, alt1312_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "token"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "token", rx1302_fail
    add rx1302_pos, 5
    goto alt1312_end
  alt1312_2:
  # rx literal  "rule"
    add $I11, rx1302_pos, 4
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 4
    ne $S10, "rule", rx1302_fail
    add rx1302_pos, 4
  alt1312_end:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 499
  # rx subrule "deflongname" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."deflongname"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1315_0:
.annotate 'line', 500
    set_addr $I10, alt1315_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "<...>", rx1302_fail
    add rx1302_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    goto alt1315_end
  alt1315_1:
    set_addr $I10, alt1315_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 502
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1302_pos, 3
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 3
    ne $S10, "<*>", rx1302_fail
    add rx1302_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    goto alt1315_end
  alt1315_2:
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1315_end:
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 498
    goto alt1308_end
  alt1308_1:
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1329_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  alt1328_0:
    set_addr $I10, alt1328_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "regex", rx1302_fail
    add rx1302_pos, 5
    goto alt1328_end
  alt1328_1:
    set_addr $I10, alt1328_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "token"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "token", rx1302_fail
    add rx1302_pos, 5
    goto alt1328_end
  alt1328_2:
  # rx literal  "rule"
    add $I11, rx1302_pos, 4
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 4
    ne $S10, "rule", rx1302_fail
    add rx1302_pos, 4
  alt1328_end:
    set_addr $I10, rxcap_1329_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1329_done
  rxcap_1329_fail:
    goto rx1302_fail
  rxcap_1329_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 506
  # rx subrule "deflongname" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."deflongname"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 507
  # rx subrule "newpad" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."newpad"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 508
  # rx rxquantr1333 ** 0..1
    set_addr $I10, rxquantr1333_done
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxquantr1333_loop:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 40, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."signature"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 41, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    set_addr $I10, rxquantr1333_done
    (rx1302_rep) = rx1302_cur."!mark_commit"($I10)
  rxquantr1333_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 509
  # rx reduce name="regex_declarator" key="open"
    rx1302_cur."!cursor_pos"(rx1302_pos)
    rx1302_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 510
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1308_end:
.annotate 'line', 511
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 496
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "regex_declarator")
    if_null rx1302_debug, debug_1069
    rx1302_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1302_pos)
  debug_1069:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 10
    if_null rx1302_debug, debug_1070
    rx1302_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1070:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_1071
    rx1302_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1071:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303857440.612") :method
.annotate 'line', 10
    $P1304 = self."!PREFIX__!subrule"("ws", "")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    rx1343_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_1072
    rx1343_cur."!cursor_debug"("START", "dotty")
  debug_1072:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 515
  # rx literal  "."
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 46, rx1343_fail
    add rx1343_pos, 1
  alt1348_0:
.annotate 'line', 516
    set_addr $I10, alt1348_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."deflongname"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1343_pos = $P10."pos"()
    goto alt1348_end
  alt1348_1:
.annotate 'line', 517
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1343_fail
  # rx subrule "quote" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."quote"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1343_pos = $P10."pos"()
  alt1349_0:
.annotate 'line', 518
    set_addr $I10, alt1349_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1343_fail
    goto alt1349_end
  alt1349_1:
  # rx subrule "panic" subtype=method negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1343_fail
    rx1343_pos = $P10."pos"()
  alt1349_end:
  alt1348_end:
.annotate 'line', 524
  # rx rxquantr1350 ** 0..1
    set_addr $I10, rxquantr1350_done
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxquantr1350_loop:
  alt1351_0:
.annotate 'line', 521
    set_addr $I10, alt1351_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
.annotate 'line', 522
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1343_fail
  # rx subrule "args" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."args"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1343_pos = $P10."pos"()
    goto alt1351_end
  alt1351_1:
.annotate 'line', 523
  # rx literal  ":"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 58, rx1343_fail
    add rx1343_pos, 1
  # rx charclass s
    ge rx1343_pos, rx1343_eos, rx1343_fail
    sub $I10, rx1343_pos, rx1343_off
    is_cclass $I11, 32, rx1343_tgt, $I10
    unless $I11, rx1343_fail
    inc rx1343_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."arglist"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1343_pos = $P10."pos"()
  alt1351_end:
.annotate 'line', 524
    set_addr $I10, rxquantr1350_done
    (rx1343_rep) = rx1343_cur."!mark_commit"($I10)
  rxquantr1350_done:
.annotate 'line', 514
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "dotty")
    if_null rx1343_debug, debug_1073
    rx1343_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1343_pos)
  debug_1073:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 10
    if_null rx1343_debug, debug_1074
    rx1343_cur."!cursor_debug"("NEXT", "dotty")
  debug_1074:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_1075
    rx1343_cur."!cursor_debug"("FAIL", "dotty")
  debug_1075:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303857440.612") :method
.annotate 'line', 10
    $P1345 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1346, "ResizablePMCArray"
    push $P1346, "'"
    push $P1346, "\""
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303857440.612")
    .param pmc param_1353
.annotate 'line', 528
    .lex "self", param_1353
    $P1354 = param_1353."!protoregex"("term")
    .return ($P1354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303857440.612")
    .param pmc param_1356
.annotate 'line', 528
    .lex "self", param_1356
    $P1357 = param_1356."!PREFIX__!protoregex"("term")
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_1076
    rx1359_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1362_done
    goto rxscan1362_scan
  rxscan1362_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1362_done
  rxscan1362_scan:
    set_addr $I10, rxscan1362_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1362_done:
.annotate 'line', 530
  # rx subcapture "sym"
    set_addr $I10, rxcap_1363_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "self"
    add $I11, rx1359_pos, 4
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 4
    ne $S10, "self", rx1359_fail
    add rx1359_pos, 4
    set_addr $I10, rxcap_1363_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1363_done
  rxcap_1363_fail:
    goto rx1359_fail
  rxcap_1363_done:
  # rxanchor rwb
    le rx1359_pos, 0, rx1359_fail
    sub $I10, rx1359_pos, rx1359_off
    is_cclass $I11, 8192, rx1359_tgt, $I10
    if $I11, rx1359_fail
    dec $I10
    is_cclass $I11, 8192, rx1359_tgt, $I10
    unless $I11, rx1359_fail
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "term:sym<self>")
    if_null rx1359_debug, debug_1077
    rx1359_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1359_pos)
  debug_1077:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 10
    if_null rx1359_debug, debug_1078
    rx1359_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1078:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_1079
    rx1359_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1079:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303857440.612") :method
.annotate 'line', 10
    new $P1361, "ResizablePMCArray"
    push $P1361, "self"
    .return ($P1361)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_1080
    rx1365_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1080:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1369_done:
.annotate 'line', 533
  # rx subrule "deflongname" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."deflongname"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1365_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1365_fail
  # rx subrule "args" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."args"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1365_pos = $P10."pos"()
.annotate 'line', 532
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "term:sym<identifier>")
    if_null rx1365_debug, debug_1081
    rx1365_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1365_pos)
  debug_1081:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 10
    if_null rx1365_debug, debug_1082
    rx1365_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1082:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_1083
    rx1365_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1083:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303857440.612") :method
.annotate 'line', 10
    $P1367 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1368, "ResizablePMCArray"
    push $P1368, $P1367
    .return ($P1368)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    rx1371_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_1084
    rx1371_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1084:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1375_done
    goto rxscan1375_scan
  rxscan1375_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1375_done
  rxscan1375_scan:
    set_addr $I10, rxscan1375_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1375_done:
.annotate 'line', 537
  # rx subrule "name" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."name"()
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1371_pos = $P10."pos"()
  # rx rxquantr1376 ** 0..1
    set_addr $I10, rxquantr1376_done
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxquantr1376_loop:
  # rx subrule "args" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."args"()
    unless $P10, rx1371_fail
    goto rxsubrule1377_pass
  rxsubrule1377_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1371_fail
  rxsubrule1377_pass:
    set_addr $I10, rxsubrule1377_back
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1371_pos = $P10."pos"()
    set_addr $I10, rxquantr1376_done
    (rx1371_rep) = rx1371_cur."!mark_commit"($I10)
  rxquantr1376_done:
.annotate 'line', 536
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "term:sym<name>")
    if_null rx1371_debug, debug_1085
    rx1371_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1371_pos)
  debug_1085:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 10
    if_null rx1371_debug, debug_1086
    rx1371_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1086:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_1087
    rx1371_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1087:
    .return (rx1371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303857440.612") :method
.annotate 'line', 10
    $P1373 = self."!PREFIX__!subrule"("name", "")
    new $P1374, "ResizablePMCArray"
    push $P1374, $P1373
    .return ($P1374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1379_tgt
    .local int rx1379_pos
    .local int rx1379_off
    .local int rx1379_eos
    .local int rx1379_rep
    .local pmc rx1379_cur
    .local pmc rx1379_debug
    (rx1379_cur, rx1379_pos, rx1379_tgt, $I10) = self."!cursor_start"()
    rx1379_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1379_cur
    .local pmc match
    .lex "$/", match
    length rx1379_eos, rx1379_tgt
    gt rx1379_pos, rx1379_eos, rx1379_done
    set rx1379_off, 0
    lt rx1379_pos, 2, rx1379_start
    sub rx1379_off, rx1379_pos, 1
    substr rx1379_tgt, rx1379_tgt, rx1379_off
  rx1379_start:
    eq $I10, 1, rx1379_restart
    if_null rx1379_debug, debug_1088
    rx1379_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1088:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1382_done
    goto rxscan1382_scan
  rxscan1382_loop:
    (rx1379_pos) = rx1379_cur."from"()
    inc rx1379_pos
    rx1379_cur."!cursor_from"(rx1379_pos)
    ge rx1379_pos, rx1379_eos, rxscan1382_done
  rxscan1382_scan:
    set_addr $I10, rxscan1382_loop
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxscan1382_done:
.annotate 'line', 541
  # rx literal  "pir::"
    add $I11, rx1379_pos, 5
    gt $I11, rx1379_eos, rx1379_fail
    sub $I11, rx1379_pos, rx1379_off
    substr $S10, rx1379_tgt, $I11, 5
    ne $S10, "pir::", rx1379_fail
    add rx1379_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1383_fail
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1379_pos, rx1379_off
    find_not_cclass $I11, 8192, rx1379_tgt, $I10, rx1379_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1379_fail
    add rx1379_pos, rx1379_off, $I11
    set_addr $I10, rxcap_1383_fail
    ($I12, $I11) = rx1379_cur."!mark_peek"($I10)
    rx1379_cur."!cursor_pos"($I11)
    ($P10) = rx1379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1379_pos, "")
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1383_done
  rxcap_1383_fail:
    goto rx1379_fail
  rxcap_1383_done:
  # rx rxquantr1384 ** 0..1
    set_addr $I10, rxquantr1384_done
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxquantr1384_loop:
  # rx subrule "args" subtype=capture negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."args"()
    unless $P10, rx1379_fail
    goto rxsubrule1385_pass
  rxsubrule1385_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1379_fail
  rxsubrule1385_pass:
    set_addr $I10, rxsubrule1385_back
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1379_pos = $P10."pos"()
    set_addr $I10, rxquantr1384_done
    (rx1379_rep) = rx1379_cur."!mark_commit"($I10)
  rxquantr1384_done:
.annotate 'line', 540
  # rx pass
    rx1379_cur."!cursor_pass"(rx1379_pos, "term:sym<pir::op>")
    if_null rx1379_debug, debug_1089
    rx1379_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1379_pos)
  debug_1089:
    .return (rx1379_cur)
  rx1379_restart:
.annotate 'line', 10
    if_null rx1379_debug, debug_1090
    rx1379_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1090:
  rx1379_fail:
    (rx1379_rep, rx1379_pos, $I10, $P10) = rx1379_cur."!mark_fail"(0)
    lt rx1379_pos, -1, rx1379_done
    eq rx1379_pos, -1, rx1379_fail
    jump $I10
  rx1379_done:
    rx1379_cur."!cursor_fail"()
    if_null rx1379_debug, debug_1091
    rx1379_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1091:
    .return (rx1379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303857440.612") :method
.annotate 'line', 10
    new $P1381, "ResizablePMCArray"
    push $P1381, "pir::"
    .return ($P1381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P1395 = "226_1303857440.612" 
    capture_lex $P1395
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_1092
    rx1387_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1092:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1390_done
    goto rxscan1390_scan
  rxscan1390_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1390_done
  rxscan1390_scan:
    set_addr $I10, rxscan1390_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1390_done:
.annotate 'line', 545
  # rx literal  "{*}"
    add $I11, rx1387_pos, 3
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    substr $S10, rx1387_tgt, $I11, 3
    ne $S10, "{*}", rx1387_fail
    add rx1387_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ENDSTMT"()
    unless $P10, rx1387_fail
  alt1391_0:
.annotate 'line', 546
    set_addr $I10, alt1391_1
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
    rx1387_cur."!cursor_pos"(rx1387_pos)
    find_lex $P1392, unicode:"$\x{a2}"
    $P1393 = $P1392."MATCH"()
    store_lex "$/", $P1393
    .const 'Sub' $P1395 = "226_1303857440.612" 
    capture_lex $P1395
    $P1401 = $P1395()
    unless $P1401, rx1387_fail
    goto alt1391_end
  alt1391_1:
  # rx subrule "panic" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
  alt1391_end:
.annotate 'line', 544
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "term:sym<onlystar>")
    if_null rx1387_debug, debug_1095
    rx1387_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1387_pos)
  debug_1095:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 10
    if_null rx1387_debug, debug_1096
    rx1387_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1096:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_1097
    rx1387_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1097:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303857440.612") :method
.annotate 'line', 10
    new $P1389, "ResizablePMCArray"
    push $P1389, "{*}"
    .return ($P1389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1394"  :anon :subid("226_1303857440.612") :outer("224_1303857440.612")
.annotate 'line', 546
    find_dynamic_lex $P1398, "$*MULTINESS"
    unless_null $P1398, vivify_1093
    get_hll_global $P1396, "GLOBAL"
    get_who $P1397, $P1396
    set $P1398, $P1397["$MULTINESS"]
    unless_null $P1398, vivify_1094
    die "Contextual $*MULTINESS not found"
  vivify_1094:
  vivify_1093:
    set $S1399, $P1398
    iseq $I1400, $S1399, "proto"
    .return ($I1400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1098
    rx1403_cur."!cursor_debug"("START", "args")
  debug_1098:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1407_done
    goto rxscan1407_scan
  rxscan1407_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1407_done
  rxscan1407_scan:
    set_addr $I10, rxscan1407_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1407_done:
.annotate 'line', 550
  # rx literal  "("
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 40, rx1403_fail
    add rx1403_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."arglist"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1403_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 41, rx1403_fail
    add rx1403_pos, 1
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "args")
    if_null rx1403_debug, debug_1099
    rx1403_cur."!cursor_debug"("PASS", "args", " at pos=", rx1403_pos)
  debug_1099:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 10
    if_null rx1403_debug, debug_1100
    rx1403_cur."!cursor_debug"("NEXT", "args")
  debug_1100:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1101
    rx1403_cur."!cursor_debug"("FAIL", "args")
  debug_1101:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303857440.612") :method
.annotate 'line', 10
    $P1405 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1406, "ResizablePMCArray"
    push $P1406, $P1405
    .return ($P1406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1102
    rx1409_cur."!cursor_debug"("START", "arglist")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 554
  # rx subrule "ws" subtype=method negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."ws"()
    unless $P10, rx1409_fail
    rx1409_pos = $P10."pos"()
  alt1414_0:
.annotate 'line', 555
    set_addr $I10, alt1414_1
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
.annotate 'line', 556
  # rx subrule "EXPR" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."EXPR"("f=")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1409_pos = $P10."pos"()
    goto alt1414_end
  alt1414_1:
  alt1414_end:
.annotate 'line', 553
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "arglist")
    if_null rx1409_debug, debug_1103
    rx1409_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1409_pos)
  debug_1103:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1104
    rx1409_cur."!cursor_debug"("NEXT", "arglist")
  debug_1104:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1105
    rx1409_cur."!cursor_debug"("FAIL", "arglist")
  debug_1105:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303857440.612") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("ws", "")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_1106
    rx1416_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1420_done:
.annotate 'line', 562
  # rx subrule "value" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."value"()
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1416_pos = $P10."pos"()
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "term:sym<value>")
    if_null rx1416_debug, debug_1107
    rx1416_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1416_pos)
  debug_1107:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 10
    if_null rx1416_debug, debug_1108
    rx1416_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1108:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_1109
    rx1416_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1109:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303857440.612") :method
.annotate 'line', 10
    $P1418 = self."!PREFIX__!subrule"("value", "")
    new $P1419, "ResizablePMCArray"
    push $P1419, $P1418
    .return ($P1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1422_tgt
    .local int rx1422_pos
    .local int rx1422_off
    .local int rx1422_eos
    .local int rx1422_rep
    .local pmc rx1422_cur
    .local pmc rx1422_debug
    (rx1422_cur, rx1422_pos, rx1422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1422_cur
    .local pmc match
    .lex "$/", match
    length rx1422_eos, rx1422_tgt
    gt rx1422_pos, rx1422_eos, rx1422_done
    set rx1422_off, 0
    lt rx1422_pos, 2, rx1422_start
    sub rx1422_off, rx1422_pos, 1
    substr rx1422_tgt, rx1422_tgt, rx1422_off
  rx1422_start:
    eq $I10, 1, rx1422_restart
    if_null rx1422_debug, debug_1110
    rx1422_cur."!cursor_debug"("START", "value")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1422_pos) = rx1422_cur."from"()
    inc rx1422_pos
    rx1422_cur."!cursor_from"(rx1422_pos)
    ge rx1422_pos, rx1422_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  rxscan1427_done:
  alt1428_0:
.annotate 'line', 564
    set_addr $I10, alt1428_1
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
.annotate 'line', 565
  # rx subrule "quote" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."quote"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1422_pos = $P10."pos"()
    goto alt1428_end
  alt1428_1:
.annotate 'line', 566
  # rx subrule "number" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."number"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1422_pos = $P10."pos"()
  alt1428_end:
.annotate 'line', 564
  # rx pass
    rx1422_cur."!cursor_pass"(rx1422_pos, "value")
    if_null rx1422_debug, debug_1111
    rx1422_cur."!cursor_debug"("PASS", "value", " at pos=", rx1422_pos)
  debug_1111:
    .return (rx1422_cur)
  rx1422_restart:
.annotate 'line', 10
    if_null rx1422_debug, debug_1112
    rx1422_cur."!cursor_debug"("NEXT", "value")
  debug_1112:
  rx1422_fail:
    (rx1422_rep, rx1422_pos, $I10, $P10) = rx1422_cur."!mark_fail"(0)
    lt rx1422_pos, -1, rx1422_done
    eq rx1422_pos, -1, rx1422_fail
    jump $I10
  rx1422_done:
    rx1422_cur."!cursor_fail"()
    if_null rx1422_debug, debug_1113
    rx1422_cur."!cursor_debug"("FAIL", "value")
  debug_1113:
    .return (rx1422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303857440.612") :method
.annotate 'line', 10
    $P1424 = self."!PREFIX__!subrule"("number", "")
    $P1425 = self."!PREFIX__!subrule"("quote", "")
    new $P1426, "ResizablePMCArray"
    push $P1426, $P1424
    push $P1426, $P1425
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1114
    rx1430_cur."!cursor_debug"("START", "number")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1433_done
    goto rxscan1433_scan
  rxscan1433_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1433_done
  rxscan1433_scan:
    set_addr $I10, rxscan1433_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1433_done:
.annotate 'line', 570
  # rx subcapture "sign"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1430_pos, rx1430_off
    set rx1430_rep, 0
    sub $I12, rx1430_eos, rx1430_pos
    le $I12, 1, rxenumcharlistq1434_loop
    set $I12, 1
  rxenumcharlistq1434_loop:
    le $I12, 0, rxenumcharlistq1434_done
    substr $S10, rx1430_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1434_done
    inc rx1430_rep
  rxenumcharlistq1434_done:
    add rx1430_pos, rx1430_pos, rx1430_rep
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  alt1436_0:
.annotate 'line', 571
    set_addr $I10, alt1436_1
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."dec_number"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1430_pos = $P10."pos"()
    goto alt1436_end
  alt1436_1:
  # rx subrule "integer" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."integer"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1430_pos = $P10."pos"()
  alt1436_end:
.annotate 'line', 569
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "number")
    if_null rx1430_debug, debug_1115
    rx1430_cur."!cursor_debug"("PASS", "number", " at pos=", rx1430_pos)
  debug_1115:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1116
    rx1430_cur."!cursor_debug"("NEXT", "number")
  debug_1116:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1117
    rx1430_cur."!cursor_debug"("FAIL", "number")
  debug_1117:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303857440.612") :method
.annotate 'line', 10
    new $P1432, "ResizablePMCArray"
    push $P1432, ""
    .return ($P1432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303857440.612")
    .param pmc param_1438
.annotate 'line', 574
    .lex "self", param_1438
    $P1439 = param_1438."!protoregex"("quote")
    .return ($P1439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303857440.612")
    .param pmc param_1441
.annotate 'line', 574
    .lex "self", param_1441
    $P1442 = param_1441."!PREFIX__!protoregex"("quote")
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1118
    rx1444_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1447_done
    goto rxscan1447_scan
  rxscan1447_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1447_done
  rxscan1447_scan:
    set_addr $I10, rxscan1447_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1447_done:
.annotate 'line', 575
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1444_pos, rx1444_off
    substr $S10, rx1444_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1444_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."quote_EXPR"(":q")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "quote:sym<apos>")
    if_null rx1444_debug, debug_1119
    rx1444_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1444_pos)
  debug_1119:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1120
    rx1444_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1120:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1121
    rx1444_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1121:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303857440.612") :method
.annotate 'line', 10
    new $P1446, "ResizablePMCArray"
    push $P1446, "'"
    .return ($P1446)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1122
    rx1449_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1452_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1449_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."quote_EXPR"(":qq")
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "quote:sym<dblq>")
    if_null rx1449_debug, debug_1123
    rx1449_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1449_pos)
  debug_1123:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1124
    rx1449_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1124:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1125
    rx1449_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1125:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303857440.612") :method
.annotate 'line', 10
    new $P1451, "ResizablePMCArray"
    push $P1451, "\""
    .return ($P1451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1126
    rx1454_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1454_pos) = rx1454_cur."from"()
    inc rx1454_pos
    rx1454_cur."!cursor_from"(rx1454_pos)
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 577
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "q"
    add $I11, rx1454_pos, 1
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    ord $I11, rx1454_tgt, $I11
    ne $I11, 113, rx1454_fail
    add rx1454_pos, 1
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rxanchor rwb
    le rx1454_pos, 0, rx1454_fail
    sub $I10, rx1454_pos, rx1454_off
    is_cclass $I11, 8192, rx1454_tgt, $I10
    if $I11, rx1454_fail
    dec $I10
    is_cclass $I11, 8192, rx1454_tgt, $I10
    unless $I11, rx1454_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1454_fail
  # rx subrule "ws" subtype=method negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."ws"()
    unless $P10, rx1454_fail
    rx1454_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."quote_EXPR"(":q")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "quote:sym<q>")
    if_null rx1454_debug, debug_1127
    rx1454_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1454_pos)
  debug_1127:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 10
    if_null rx1454_debug, debug_1128
    rx1454_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1128:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1129
    rx1454_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1129:
    .return (rx1454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303857440.612") :method
.annotate 'line', 10
    $P1456 = self."!PREFIX__!subrule"("ws", "q")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1130
    rx1461_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "qq", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rxanchor rwb
    le rx1461_pos, 0, rx1461_fail
    sub $I10, rx1461_pos, rx1461_off
    is_cclass $I11, 8192, rx1461_tgt, $I10
    if $I11, rx1461_fail
    dec $I10
    is_cclass $I11, 8192, rx1461_tgt, $I10
    unless $I11, rx1461_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1461_fail
  # rx subrule "ws" subtype=method negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."ws"()
    unless $P10, rx1461_fail
    rx1461_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."quote_EXPR"(":qq")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "quote:sym<qq>")
    if_null rx1461_debug, debug_1131
    rx1461_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1461_pos)
  debug_1131:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 10
    if_null rx1461_debug, debug_1132
    rx1461_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1132:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1133
    rx1461_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1133:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303857440.612") :method
.annotate 'line', 10
    $P1463 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1134
    rx1468_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1468_pos, 1
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    ord $I11, rx1468_tgt, $I11
    ne $I11, 81, rx1468_fail
    add rx1468_pos, 1
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rxanchor rwb
    le rx1468_pos, 0, rx1468_fail
    sub $I10, rx1468_pos, rx1468_off
    is_cclass $I11, 8192, rx1468_tgt, $I10
    if $I11, rx1468_fail
    dec $I10
    is_cclass $I11, 8192, rx1468_tgt, $I10
    unless $I11, rx1468_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1468_fail
  # rx subrule "ws" subtype=method negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."ws"()
    unless $P10, rx1468_fail
    rx1468_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."quote_EXPR"()
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "quote:sym<Q>")
    if_null rx1468_debug, debug_1135
    rx1468_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1468_pos)
  debug_1135:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 10
    if_null rx1468_debug, debug_1136
    rx1468_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1136:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1137
    rx1468_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1137:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303857440.612") :method
.annotate 'line', 10
    $P1470 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1138
    rx1475_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1138:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1475_pos) = rx1475_cur."from"()
    inc rx1475_pos
    rx1475_cur."!cursor_from"(rx1475_pos)
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1475_pos, 5
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1475_fail
    add rx1475_pos, 5
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "ws" subtype=method negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."ws"()
    unless $P10, rx1475_fail
    rx1475_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."quote_EXPR"()
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "quote:sym<Q:PIR>")
    if_null rx1475_debug, debug_1139
    rx1475_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1475_pos)
  debug_1139:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 10
    if_null rx1475_debug, debug_1140
    rx1475_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1140:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1141
    rx1475_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1141:
    .return (rx1475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303857440.612") :method
.annotate 'line', 10
    $P1477 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1142
    rx1482_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 582
  # rx literal  "/"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 47, rx1482_fail
    add rx1482_pos, 1
.annotate 'line', 583
  # rx subrule "newpad" subtype=method negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."newpad"()
    unless $P10, rx1482_fail
    rx1482_pos = $P10."pos"()
.annotate 'line', 584
  # rx reduce name="quote:sym</ />" key="open"
    rx1482_cur."!cursor_pos"(rx1482_pos)
    rx1482_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 585
  # rx subrule "LANG" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1482_pos = $P10."pos"()
.annotate 'line', 586
  # rx literal  "/"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 47, rx1482_fail
    add rx1482_pos, 1
.annotate 'line', 581
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "quote:sym</ />")
    if_null rx1482_debug, debug_1143
    rx1482_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1482_pos)
  debug_1143:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 10
    if_null rx1482_debug, debug_1144
    rx1482_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1144:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1145
    rx1482_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1145:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303857440.612") :method
.annotate 'line', 10
    $P1484 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1146
    rx1488_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1491_done:
.annotate 'line', 589
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1488_pos, rx1488_off
    substr $S10, rx1488_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1488_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."quotemod_check"("s")
    unless $P10, rx1488_fail
  # rx subrule "variable" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."variable"()
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1488_pos = $P10."pos"()
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "quote_escape:sym<$>")
    if_null rx1488_debug, debug_1147
    rx1488_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1488_pos)
  debug_1147:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 10
    if_null rx1488_debug, debug_1148
    rx1488_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1148:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1149
    rx1488_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1149:
    .return (rx1488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303857440.612") :method
.annotate 'line', 10
    new $P1490, "ResizablePMCArray"
    push $P1490, "$"
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1150
    rx1493_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1150:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1496_done:
.annotate 'line', 590
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1493_pos, rx1493_off
    substr $S10, rx1493_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1493_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."quotemod_check"("c")
    unless $P10, rx1493_fail
  # rx subrule "block" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."block"()
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "quote_escape:sym<{ }>")
    if_null rx1493_debug, debug_1151
    rx1493_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1493_pos)
  debug_1151:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1152
    rx1493_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1152:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1153
    rx1493_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1153:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303857440.612") :method
.annotate 'line', 10
    new $P1495, "ResizablePMCArray"
    push $P1495, "{"
    .return ($P1495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1498_tgt
    .local int rx1498_pos
    .local int rx1498_off
    .local int rx1498_eos
    .local int rx1498_rep
    .local pmc rx1498_cur
    .local pmc rx1498_debug
    (rx1498_cur, rx1498_pos, rx1498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1498_cur
    .local pmc match
    .lex "$/", match
    length rx1498_eos, rx1498_tgt
    gt rx1498_pos, rx1498_eos, rx1498_done
    set rx1498_off, 0
    lt rx1498_pos, 2, rx1498_start
    sub rx1498_off, rx1498_pos, 1
    substr rx1498_tgt, rx1498_tgt, rx1498_off
  rx1498_start:
    eq $I10, 1, rx1498_restart
    if_null rx1498_debug, debug_1154
    rx1498_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1498_pos) = rx1498_cur."from"()
    inc rx1498_pos
    rx1498_cur."!cursor_from"(rx1498_pos)
    ge rx1498_pos, rx1498_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  rxscan1501_done:
.annotate 'line', 591
  # rx literal  "\\e"
    add $I11, rx1498_pos, 2
    gt $I11, rx1498_eos, rx1498_fail
    sub $I11, rx1498_pos, rx1498_off
    substr $S10, rx1498_tgt, $I11, 2
    ne $S10, "\\e", rx1498_fail
    add rx1498_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1498_cur."!cursor_pos"(rx1498_pos)
    $P10 = rx1498_cur."quotemod_check"("b")
    unless $P10, rx1498_fail
  # rx pass
    rx1498_cur."!cursor_pass"(rx1498_pos, "quote_escape:sym<esc>")
    if_null rx1498_debug, debug_1155
    rx1498_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1498_pos)
  debug_1155:
    .return (rx1498_cur)
  rx1498_restart:
.annotate 'line', 10
    if_null rx1498_debug, debug_1156
    rx1498_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1156:
  rx1498_fail:
    (rx1498_rep, rx1498_pos, $I10, $P10) = rx1498_cur."!mark_fail"(0)
    lt rx1498_pos, -1, rx1498_done
    eq rx1498_pos, -1, rx1498_fail
    jump $I10
  rx1498_done:
    rx1498_cur."!cursor_fail"()
    if_null rx1498_debug, debug_1157
    rx1498_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1157:
    .return (rx1498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303857440.612") :method
.annotate 'line', 10
    new $P1500, "ResizablePMCArray"
    push $P1500, "\\e"
    .return ($P1500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1503_tgt
    .local int rx1503_pos
    .local int rx1503_off
    .local int rx1503_eos
    .local int rx1503_rep
    .local pmc rx1503_cur
    .local pmc rx1503_debug
    (rx1503_cur, rx1503_pos, rx1503_tgt, $I10) = self."!cursor_start"()
    rx1503_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1503_cur
    .local pmc match
    .lex "$/", match
    length rx1503_eos, rx1503_tgt
    gt rx1503_pos, rx1503_eos, rx1503_done
    set rx1503_off, 0
    lt rx1503_pos, 2, rx1503_start
    sub rx1503_off, rx1503_pos, 1
    substr rx1503_tgt, rx1503_tgt, rx1503_off
  rx1503_start:
    eq $I10, 1, rx1503_restart
    if_null rx1503_debug, debug_1158
    rx1503_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1158:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1503_pos) = rx1503_cur."from"()
    inc rx1503_pos
    rx1503_cur."!cursor_from"(rx1503_pos)
    ge rx1503_pos, rx1503_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxscan1507_done:
.annotate 'line', 593
  # rx literal  "("
    add $I11, rx1503_pos, 1
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    ord $I11, rx1503_tgt, $I11
    ne $I11, 40, rx1503_fail
    add rx1503_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."ws"()
    unless $P10, rx1503_fail
    rx1503_pos = $P10."pos"()
  # rx rxquantr1508 ** 0..1
    set_addr $I10, rxquantr1508_done
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxquantr1508_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."EXPR"()
    unless $P10, rx1503_fail
    goto rxsubrule1509_pass
  rxsubrule1509_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1503_fail
  rxsubrule1509_pass:
    set_addr $I10, rxsubrule1509_back
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1503_pos = $P10."pos"()
    set_addr $I10, rxquantr1508_done
    (rx1503_rep) = rx1503_cur."!mark_commit"($I10)
  rxquantr1508_done:
  # rx literal  ")"
    add $I11, rx1503_pos, 1
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    ord $I11, rx1503_tgt, $I11
    ne $I11, 41, rx1503_fail
    add rx1503_pos, 1
  # rx pass
    rx1503_cur."!cursor_pass"(rx1503_pos, "circumfix:sym<( )>")
    if_null rx1503_debug, debug_1159
    rx1503_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1503_pos)
  debug_1159:
    .return (rx1503_cur)
  rx1503_restart:
.annotate 'line', 10
    if_null rx1503_debug, debug_1160
    rx1503_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1160:
  rx1503_fail:
    (rx1503_rep, rx1503_pos, $I10, $P10) = rx1503_cur."!mark_fail"(0)
    lt rx1503_pos, -1, rx1503_done
    eq rx1503_pos, -1, rx1503_fail
    jump $I10
  rx1503_done:
    rx1503_cur."!cursor_fail"()
    if_null rx1503_debug, debug_1161
    rx1503_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1161:
    .return (rx1503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303857440.612") :method
.annotate 'line', 10
    $P1505 = self."!PREFIX__!subrule"("ws", "(")
    new $P1506, "ResizablePMCArray"
    push $P1506, $P1505
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    rx1511_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1162
    rx1511_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1515_done
    goto rxscan1515_scan
  rxscan1515_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1515_done
  rxscan1515_scan:
    set_addr $I10, rxscan1515_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1515_done:
.annotate 'line', 594
  # rx literal  "["
    add $I11, rx1511_pos, 1
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    ord $I11, rx1511_tgt, $I11
    ne $I11, 91, rx1511_fail
    add rx1511_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."ws"()
    unless $P10, rx1511_fail
    rx1511_pos = $P10."pos"()
  # rx rxquantr1516 ** 0..1
    set_addr $I10, rxquantr1516_done
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxquantr1516_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."EXPR"()
    unless $P10, rx1511_fail
    goto rxsubrule1517_pass
  rxsubrule1517_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1511_fail
  rxsubrule1517_pass:
    set_addr $I10, rxsubrule1517_back
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1511_pos = $P10."pos"()
    set_addr $I10, rxquantr1516_done
    (rx1511_rep) = rx1511_cur."!mark_commit"($I10)
  rxquantr1516_done:
  # rx literal  "]"
    add $I11, rx1511_pos, 1
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    ord $I11, rx1511_tgt, $I11
    ne $I11, 93, rx1511_fail
    add rx1511_pos, 1
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "circumfix:sym<[ ]>")
    if_null rx1511_debug, debug_1163
    rx1511_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1511_pos)
  debug_1163:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 10
    if_null rx1511_debug, debug_1164
    rx1511_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1164:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1165
    rx1511_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1165:
    .return (rx1511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303857440.612") :method
.annotate 'line', 10
    $P1513 = self."!PREFIX__!subrule"("ws", "[")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1166
    rx1519_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1522_done:
.annotate 'line', 595
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1519_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "circumfix:sym<ang>")
    if_null rx1519_debug, debug_1167
    rx1519_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1519_pos)
  debug_1167:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 10
    if_null rx1519_debug, debug_1168
    rx1519_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1168:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1169
    rx1519_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1169:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303857440.612") :method
.annotate 'line', 10
    new $P1521, "ResizablePMCArray"
    push $P1521, "<"
    .return ($P1521)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1170
    rx1524_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1170:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1527_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1524_pos, rx1524_off
    substr $S10, rx1524_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1524_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1524_debug, debug_1171
    rx1524_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1524_pos)
  debug_1171:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 10
    if_null rx1524_debug, debug_1172
    rx1524_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1172:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1173
    rx1524_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1173:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303857440.612") :method
.annotate 'line', 10
    new $P1526, "ResizablePMCArray"
    push $P1526, unicode:"\x{ab}"
    .return ($P1526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1529_tgt
    .local int rx1529_pos
    .local int rx1529_off
    .local int rx1529_eos
    .local int rx1529_rep
    .local pmc rx1529_cur
    .local pmc rx1529_debug
    (rx1529_cur, rx1529_pos, rx1529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1529_cur
    .local pmc match
    .lex "$/", match
    length rx1529_eos, rx1529_tgt
    gt rx1529_pos, rx1529_eos, rx1529_done
    set rx1529_off, 0
    lt rx1529_pos, 2, rx1529_start
    sub rx1529_off, rx1529_pos, 1
    substr rx1529_tgt, rx1529_tgt, rx1529_off
  rx1529_start:
    eq $I10, 1, rx1529_restart
    if_null rx1529_debug, debug_1174
    rx1529_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1174:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1529_pos) = rx1529_cur."from"()
    inc rx1529_pos
    rx1529_cur."!cursor_from"(rx1529_pos)
    ge rx1529_pos, rx1529_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  rxscan1532_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1529_pos, rx1529_off
    substr $S10, rx1529_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1529_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1529_cur."!cursor_pos"(rx1529_pos)
    $P10 = rx1529_cur."pblock"()
    unless $P10, rx1529_fail
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1529_pos = $P10."pos"()
  # rx pass
    rx1529_cur."!cursor_pass"(rx1529_pos, "circumfix:sym<{ }>")
    if_null rx1529_debug, debug_1175
    rx1529_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1529_pos)
  debug_1175:
    .return (rx1529_cur)
  rx1529_restart:
.annotate 'line', 10
    if_null rx1529_debug, debug_1176
    rx1529_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1176:
  rx1529_fail:
    (rx1529_rep, rx1529_pos, $I10, $P10) = rx1529_cur."!mark_fail"(0)
    lt rx1529_pos, -1, rx1529_done
    eq rx1529_pos, -1, rx1529_fail
    jump $I10
  rx1529_done:
    rx1529_cur."!cursor_fail"()
    if_null rx1529_debug, debug_1177
    rx1529_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1177:
    .return (rx1529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303857440.612") :method
.annotate 'line', 10
    new $P1531, "ResizablePMCArray"
    push $P1531, "{"
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1178
    rx1534_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1178:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1534_pos) = rx1534_cur."from"()
    inc rx1534_pos
    rx1534_cur."!cursor_from"(rx1534_pos)
    ge rx1534_pos, rx1534_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1538_done:
.annotate 'line', 598
  # rx subrule "sigil" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."sigil"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1534_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 40, rx1534_fail
    add rx1534_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."semilist"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1534_pos = $P10."pos"()
  alt1539_0:
    set_addr $I10, alt1539_1
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  # rx literal  ")"
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 41, rx1534_fail
    add rx1534_pos, 1
    goto alt1539_end
  alt1539_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."FAILGOAL"("')'")
    unless $P10, rx1534_fail
    goto rxsubrule1541_pass
  rxsubrule1541_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1534_fail
  rxsubrule1541_pass:
    set_addr $I10, rxsubrule1541_back
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10, $P10)
    rx1534_pos = $P10."pos"()
  alt1539_end:
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "circumfix:sym<sigil>")
    if_null rx1534_debug, debug_1179
    rx1534_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1534_pos)
  debug_1179:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 10
    if_null rx1534_debug, debug_1180
    rx1534_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1180:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1181
    rx1534_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1181:
    .return (rx1534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303857440.612") :method
.annotate 'line', 10
    $P1536 = self."!PREFIX__!subrule"("sigil", "")
    new $P1537, "ResizablePMCArray"
    push $P1537, $P1536
    .return ($P1537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1182
    rx1543_cur."!cursor_debug"("START", "semilist")
  debug_1182:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 600
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."statement"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1543_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "semilist")
    if_null rx1543_debug, debug_1183
    rx1543_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1543_pos)
  debug_1183:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 10
    if_null rx1543_debug, debug_1184
    rx1543_cur."!cursor_debug"("NEXT", "semilist")
  debug_1184:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1185
    rx1543_cur."!cursor_debug"("FAIL", "semilist")
  debug_1185:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303857440.612") :method
.annotate 'line', 10
    $P1545 = self."!PREFIX__!subrule"("ws", "")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1186
    rx1551_cur."!cursor_debug"("START", "infixish")
  debug_1186:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1554_done:
.annotate 'line', 623
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."infixstopper"()
    if $P10, rx1551_fail
  # rx subrule "infix" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."infix"()
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1551_pos = $P10."pos"()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "infixish")
    if_null rx1551_debug, debug_1187
    rx1551_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1551_pos)
  debug_1187:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 10
    if_null rx1551_debug, debug_1188
    rx1551_cur."!cursor_debug"("NEXT", "infixish")
  debug_1188:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1189
    rx1551_cur."!cursor_debug"("FAIL", "infixish")
  debug_1189:
    .return (rx1551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303857440.612") :method
.annotate 'line', 10
    new $P1553, "ResizablePMCArray"
    push $P1553, ""
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1190
    rx1556_cur."!cursor_debug"("START", "infixstopper")
  debug_1190:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1559_done
    goto rxscan1559_scan
  rxscan1559_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1559_done
  rxscan1559_scan:
    set_addr $I10, rxscan1559_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1559_done:
.annotate 'line', 624
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."lambda"()
    unless $P10, rx1556_fail
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infixstopper")
    if_null rx1556_debug, debug_1191
    rx1556_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1556_pos)
  debug_1191:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1192
    rx1556_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1192:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1193
    rx1556_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1193:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303857440.612") :method
.annotate 'line', 10
    new $P1558, "ResizablePMCArray"
    push $P1558, ""
    .return ($P1558)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1194
    rx1561_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1194:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1565_done:
.annotate 'line', 627
  # rx literal  "["
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 91, rx1561_fail
    add rx1561_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."ws"()
    unless $P10, rx1561_fail
    rx1561_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."EXPR"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1561_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 93, rx1561_fail
    add rx1561_pos, 1
.annotate 'line', 628
  # rx subrule "O" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."O"("%methodop")
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1561_pos = $P10."pos"()
.annotate 'line', 626
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "postcircumfix:sym<[ ]>")
    if_null rx1561_debug, debug_1195
    rx1561_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1561_pos)
  debug_1195:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 10
    if_null rx1561_debug, debug_1196
    rx1561_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1196:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1197
    rx1561_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1197:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303857440.612") :method
.annotate 'line', 10
    $P1563 = self."!PREFIX__!subrule"("ws", "[")
    new $P1564, "ResizablePMCArray"
    push $P1564, $P1563
    .return ($P1564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1198
    rx1567_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1198:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1571_done
    goto rxscan1571_scan
  rxscan1571_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1571_done
  rxscan1571_scan:
    set_addr $I10, rxscan1571_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1571_done:
.annotate 'line', 632
  # rx literal  "{"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 123, rx1567_fail
    add rx1567_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."ws"()
    unless $P10, rx1567_fail
    rx1567_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."EXPR"()
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1567_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 125, rx1567_fail
    add rx1567_pos, 1
.annotate 'line', 633
  # rx subrule "O" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."O"("%methodop")
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1567_pos = $P10."pos"()
.annotate 'line', 631
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "postcircumfix:sym<{ }>")
    if_null rx1567_debug, debug_1199
    rx1567_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1567_pos)
  debug_1199:
    .return (rx1567_cur)
  rx1567_restart:
.annotate 'line', 10
    if_null rx1567_debug, debug_1200
    rx1567_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1200:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1201
    rx1567_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1201:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303857440.612") :method
.annotate 'line', 10
    $P1569 = self."!PREFIX__!subrule"("ws", "{")
    new $P1570, "ResizablePMCArray"
    push $P1570, $P1569
    .return ($P1570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1202
    rx1573_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1202:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1576_done
    goto rxscan1576_scan
  rxscan1576_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1576_done
  rxscan1576_scan:
    set_addr $I10, rxscan1576_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1576_done:
.annotate 'line', 637
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1573_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."quote_EXPR"(":q")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1573_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "O" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."O"("%methodop")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1573_pos = $P10."pos"()
.annotate 'line', 636
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "postcircumfix:sym<ang>")
    if_null rx1573_debug, debug_1203
    rx1573_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1573_pos)
  debug_1203:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 10
    if_null rx1573_debug, debug_1204
    rx1573_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1204:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1205
    rx1573_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1205:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303857440.612") :method
.annotate 'line', 10
    new $P1575, "ResizablePMCArray"
    push $P1575, "<"
    .return ($P1575)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1206
    rx1578_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1206:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1582_done:
.annotate 'line', 642
  # rx literal  "("
    add $I11, rx1578_pos, 1
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    ord $I11, rx1578_tgt, $I11
    ne $I11, 40, rx1578_fail
    add rx1578_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."ws"()
    unless $P10, rx1578_fail
    rx1578_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."arglist"()
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1578_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1578_pos, 1
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    ord $I11, rx1578_tgt, $I11
    ne $I11, 41, rx1578_fail
    add rx1578_pos, 1
.annotate 'line', 643
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%methodop")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
.annotate 'line', 641
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "postcircumfix:sym<( )>")
    if_null rx1578_debug, debug_1207
    rx1578_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1578_pos)
  debug_1207:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 10
    if_null rx1578_debug, debug_1208
    rx1578_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1208:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1209
    rx1578_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1209:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303857440.612") :method
.annotate 'line', 10
    $P1580 = self."!PREFIX__!subrule"("ws", "(")
    new $P1581, "ResizablePMCArray"
    push $P1581, $P1580
    .return ($P1581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1210
    rx1584_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1210:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 646
  # rx subrule "dotty" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."dotty"()
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1584_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%methodop")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "postfix:sym<.>")
    if_null rx1584_debug, debug_1211
    rx1584_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1584_pos)
  debug_1211:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1212
    rx1584_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1212:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1213
    rx1584_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1213:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303857440.612") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("dotty", "")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1214
    rx1590_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1214:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1594_done
    goto rxscan1594_scan
  rxscan1594_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1594_done
  rxscan1594_scan:
    set_addr $I10, rxscan1594_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1594_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1595_fail
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  # rx literal  "++"
    add $I11, rx1590_pos, 2
    gt $I11, rx1590_eos, rx1590_fail
    sub $I11, rx1590_pos, rx1590_off
    substr $S10, rx1590_tgt, $I11, 2
    ne $S10, "++", rx1590_fail
    add rx1590_pos, 2
    set_addr $I10, rxcap_1595_fail
    ($I12, $I11) = rx1590_cur."!mark_peek"($I10)
    rx1590_cur."!cursor_pos"($I11)
    ($P10) = rx1590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1590_pos, "")
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1595_done
  rxcap_1595_fail:
    goto rx1590_fail
  rxcap_1595_done:
  # rx subrule "O" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "prefix:sym<++>")
    if_null rx1590_debug, debug_1215
    rx1590_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1590_pos)
  debug_1215:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 10
    if_null rx1590_debug, debug_1216
    rx1590_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1216:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1217
    rx1590_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1217:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303857440.612") :method
.annotate 'line', 10
    $P1592 = self."!PREFIX__!subrule"("O", "++")
    new $P1593, "ResizablePMCArray"
    push $P1593, $P1592
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1597_tgt
    .local int rx1597_pos
    .local int rx1597_off
    .local int rx1597_eos
    .local int rx1597_rep
    .local pmc rx1597_cur
    .local pmc rx1597_debug
    (rx1597_cur, rx1597_pos, rx1597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1597_cur
    .local pmc match
    .lex "$/", match
    length rx1597_eos, rx1597_tgt
    gt rx1597_pos, rx1597_eos, rx1597_done
    set rx1597_off, 0
    lt rx1597_pos, 2, rx1597_start
    sub rx1597_off, rx1597_pos, 1
    substr rx1597_tgt, rx1597_tgt, rx1597_off
  rx1597_start:
    eq $I10, 1, rx1597_restart
    if_null rx1597_debug, debug_1218
    rx1597_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1218:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1597_pos) = rx1597_cur."from"()
    inc rx1597_pos
    rx1597_cur."!cursor_from"(rx1597_pos)
    ge rx1597_pos, rx1597_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  rxscan1601_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1602_fail
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  # rx literal  "--"
    add $I11, rx1597_pos, 2
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    substr $S10, rx1597_tgt, $I11, 2
    ne $S10, "--", rx1597_fail
    add rx1597_pos, 2
    set_addr $I10, rxcap_1602_fail
    ($I12, $I11) = rx1597_cur."!mark_peek"($I10)
    rx1597_cur."!cursor_pos"($I11)
    ($P10) = rx1597_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1597_pos, "")
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1602_done
  rxcap_1602_fail:
    goto rx1597_fail
  rxcap_1602_done:
  # rx subrule "O" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1597_pos = $P10."pos"()
  # rx pass
    rx1597_cur."!cursor_pass"(rx1597_pos, "prefix:sym<-->")
    if_null rx1597_debug, debug_1219
    rx1597_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1597_pos)
  debug_1219:
    .return (rx1597_cur)
  rx1597_restart:
.annotate 'line', 10
    if_null rx1597_debug, debug_1220
    rx1597_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1220:
  rx1597_fail:
    (rx1597_rep, rx1597_pos, $I10, $P10) = rx1597_cur."!mark_fail"(0)
    lt rx1597_pos, -1, rx1597_done
    eq rx1597_pos, -1, rx1597_fail
    jump $I10
  rx1597_done:
    rx1597_cur."!cursor_fail"()
    if_null rx1597_debug, debug_1221
    rx1597_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1221:
    .return (rx1597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303857440.612") :method
.annotate 'line', 10
    $P1599 = self."!PREFIX__!subrule"("O", "--")
    new $P1600, "ResizablePMCArray"
    push $P1600, $P1599
    .return ($P1600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1222
    rx1604_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1222:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "++"
    add $I11, rx1604_pos, 2
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    substr $S10, rx1604_tgt, $I11, 2
    ne $S10, "++", rx1604_fail
    add rx1604_pos, 2
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "O" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."O"("%autoincrement")
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1604_pos = $P10."pos"()
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "postfix:sym<++>")
    if_null rx1604_debug, debug_1223
    rx1604_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1604_pos)
  debug_1223:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1224
    rx1604_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1224:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1225
    rx1604_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1225:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303857440.612") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("O", "++")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1226
    rx1611_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1226:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  "--"
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, "--", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%autoincrement")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "postfix:sym<-->")
    if_null rx1611_debug, debug_1227
    rx1611_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1611_pos)
  debug_1227:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1228
    rx1611_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1228:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1229
    rx1611_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1229:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303857440.612") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", "--")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1230
    rx1618_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1230:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "**"
    add $I11, rx1618_pos, 2
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 2
    ne $S10, "**", rx1618_fail
    add rx1618_pos, 2
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<**>")
    if_null rx1618_debug, debug_1231
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1618_pos)
  debug_1231:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1232
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1232:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1233
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1233:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303857440.612") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "**")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1234
    rx1625_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  "+"
    add $I11, rx1625_pos, 1
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    ord $I11, rx1625_tgt, $I11
    ne $I11, 43, rx1625_fail
    add rx1625_pos, 1
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "prefix:sym<+>")
    if_null rx1625_debug, debug_1235
    rx1625_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1625_pos)
  debug_1235:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1236
    rx1625_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1236:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1237
    rx1625_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1237:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303857440.612") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", "+")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1238
    rx1632_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1636_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1637_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "~"
    add $I11, rx1632_pos, 1
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    ord $I11, rx1632_tgt, $I11
    ne $I11, 126, rx1632_fail
    add rx1632_pos, 1
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1632_fail
  rxcap_1637_done:
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "prefix:sym<~>")
    if_null rx1632_debug, debug_1239
    rx1632_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1632_pos)
  debug_1239:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1240
    rx1632_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1240:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1241
    rx1632_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1241:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303857440.612") :method
.annotate 'line', 10
    $P1634 = self."!PREFIX__!subrule"("O", "~")
    new $P1635, "ResizablePMCArray"
    push $P1635, $P1634
    .return ($P1635)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1639_tgt
    .local int rx1639_pos
    .local int rx1639_off
    .local int rx1639_eos
    .local int rx1639_rep
    .local pmc rx1639_cur
    .local pmc rx1639_debug
    (rx1639_cur, rx1639_pos, rx1639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1639_cur
    .local pmc match
    .lex "$/", match
    length rx1639_eos, rx1639_tgt
    gt rx1639_pos, rx1639_eos, rx1639_done
    set rx1639_off, 0
    lt rx1639_pos, 2, rx1639_start
    sub rx1639_off, rx1639_pos, 1
    substr rx1639_tgt, rx1639_tgt, rx1639_off
  rx1639_start:
    eq $I10, 1, rx1639_restart
    if_null rx1639_debug, debug_1242
    rx1639_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1639_pos) = rx1639_cur."from"()
    inc rx1639_pos
    rx1639_cur."!cursor_from"(rx1639_pos)
    ge rx1639_pos, rx1639_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  rxscan1642_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1643_fail
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  # rx literal  "-"
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 45, rx1639_fail
    add rx1639_pos, 1
    set_addr $I10, rxcap_1643_fail
    ($I12, $I11) = rx1639_cur."!mark_peek"($I10)
    rx1639_cur."!cursor_pos"($I11)
    ($P10) = rx1639_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1639_pos, "")
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1643_done
  rxcap_1643_fail:
    goto rx1639_fail
  rxcap_1643_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1639_pos, rx1639_off
    substr $S10, rx1639_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1639_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."number"()
    if $P10, rx1639_fail
  # rx subrule "O" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1639_pos = $P10."pos"()
  # rx pass
    rx1639_cur."!cursor_pass"(rx1639_pos, "prefix:sym<->")
    if_null rx1639_debug, debug_1243
    rx1639_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1639_pos)
  debug_1243:
    .return (rx1639_cur)
  rx1639_restart:
.annotate 'line', 10
    if_null rx1639_debug, debug_1244
    rx1639_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1244:
  rx1639_fail:
    (rx1639_rep, rx1639_pos, $I10, $P10) = rx1639_cur."!mark_fail"(0)
    lt rx1639_pos, -1, rx1639_done
    eq rx1639_pos, -1, rx1639_fail
    jump $I10
  rx1639_done:
    rx1639_cur."!cursor_fail"()
    if_null rx1639_debug, debug_1245
    rx1639_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1245:
    .return (rx1639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303857440.612") :method
.annotate 'line', 10
    new $P1641, "ResizablePMCArray"
    push $P1641, "-"
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1645_tgt
    .local int rx1645_pos
    .local int rx1645_off
    .local int rx1645_eos
    .local int rx1645_rep
    .local pmc rx1645_cur
    .local pmc rx1645_debug
    (rx1645_cur, rx1645_pos, rx1645_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1645_cur
    .local pmc match
    .lex "$/", match
    length rx1645_eos, rx1645_tgt
    gt rx1645_pos, rx1645_eos, rx1645_done
    set rx1645_off, 0
    lt rx1645_pos, 2, rx1645_start
    sub rx1645_off, rx1645_pos, 1
    substr rx1645_tgt, rx1645_tgt, rx1645_off
  rx1645_start:
    eq $I10, 1, rx1645_restart
    if_null rx1645_debug, debug_1246
    rx1645_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1645_pos) = rx1645_cur."from"()
    inc rx1645_pos
    rx1645_cur."!cursor_from"(rx1645_pos)
    ge rx1645_pos, rx1645_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  rxscan1649_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1650_fail
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  # rx literal  "?"
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 63, rx1645_fail
    add rx1645_pos, 1
    set_addr $I10, rxcap_1650_fail
    ($I12, $I11) = rx1645_cur."!mark_peek"($I10)
    rx1645_cur."!cursor_pos"($I11)
    ($P10) = rx1645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1645_pos, "")
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1650_done
  rxcap_1650_fail:
    goto rx1645_fail
  rxcap_1650_done:
  # rx subrule "O" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1645_pos = $P10."pos"()
  # rx pass
    rx1645_cur."!cursor_pass"(rx1645_pos, "prefix:sym<?>")
    if_null rx1645_debug, debug_1247
    rx1645_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1645_pos)
  debug_1247:
    .return (rx1645_cur)
  rx1645_restart:
.annotate 'line', 10
    if_null rx1645_debug, debug_1248
    rx1645_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1248:
  rx1645_fail:
    (rx1645_rep, rx1645_pos, $I10, $P10) = rx1645_cur."!mark_fail"(0)
    lt rx1645_pos, -1, rx1645_done
    eq rx1645_pos, -1, rx1645_fail
    jump $I10
  rx1645_done:
    rx1645_cur."!cursor_fail"()
    if_null rx1645_debug, debug_1249
    rx1645_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1249:
    .return (rx1645_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303857440.612") :method
.annotate 'line', 10
    $P1647 = self."!PREFIX__!subrule"("O", "?")
    new $P1648, "ResizablePMCArray"
    push $P1648, $P1647
    .return ($P1648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1652_tgt
    .local int rx1652_pos
    .local int rx1652_off
    .local int rx1652_eos
    .local int rx1652_rep
    .local pmc rx1652_cur
    .local pmc rx1652_debug
    (rx1652_cur, rx1652_pos, rx1652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1652_cur
    .local pmc match
    .lex "$/", match
    length rx1652_eos, rx1652_tgt
    gt rx1652_pos, rx1652_eos, rx1652_done
    set rx1652_off, 0
    lt rx1652_pos, 2, rx1652_start
    sub rx1652_off, rx1652_pos, 1
    substr rx1652_tgt, rx1652_tgt, rx1652_off
  rx1652_start:
    eq $I10, 1, rx1652_restart
    if_null rx1652_debug, debug_1250
    rx1652_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1250:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1652_pos) = rx1652_cur."from"()
    inc rx1652_pos
    rx1652_cur."!cursor_from"(rx1652_pos)
    ge rx1652_pos, rx1652_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  rxscan1656_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1657_fail
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  # rx literal  "!"
    add $I11, rx1652_pos, 1
    gt $I11, rx1652_eos, rx1652_fail
    sub $I11, rx1652_pos, rx1652_off
    ord $I11, rx1652_tgt, $I11
    ne $I11, 33, rx1652_fail
    add rx1652_pos, 1
    set_addr $I10, rxcap_1657_fail
    ($I12, $I11) = rx1652_cur."!mark_peek"($I10)
    rx1652_cur."!cursor_pos"($I11)
    ($P10) = rx1652_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1652_pos, "")
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1657_done
  rxcap_1657_fail:
    goto rx1652_fail
  rxcap_1657_done:
  # rx subrule "O" subtype=capture negate=
    rx1652_cur."!cursor_pos"(rx1652_pos)
    $P10 = rx1652_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1652_fail
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1652_pos = $P10."pos"()
  # rx pass
    rx1652_cur."!cursor_pass"(rx1652_pos, "prefix:sym<!>")
    if_null rx1652_debug, debug_1251
    rx1652_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1652_pos)
  debug_1251:
    .return (rx1652_cur)
  rx1652_restart:
.annotate 'line', 10
    if_null rx1652_debug, debug_1252
    rx1652_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1252:
  rx1652_fail:
    (rx1652_rep, rx1652_pos, $I10, $P10) = rx1652_cur."!mark_fail"(0)
    lt rx1652_pos, -1, rx1652_done
    eq rx1652_pos, -1, rx1652_fail
    jump $I10
  rx1652_done:
    rx1652_cur."!cursor_fail"()
    if_null rx1652_debug, debug_1253
    rx1652_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1253:
    .return (rx1652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303857440.612") :method
.annotate 'line', 10
    $P1654 = self."!PREFIX__!subrule"("O", "!")
    new $P1655, "ResizablePMCArray"
    push $P1655, $P1654
    .return ($P1655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1659_tgt
    .local int rx1659_pos
    .local int rx1659_off
    .local int rx1659_eos
    .local int rx1659_rep
    .local pmc rx1659_cur
    .local pmc rx1659_debug
    (rx1659_cur, rx1659_pos, rx1659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1659_cur
    .local pmc match
    .lex "$/", match
    length rx1659_eos, rx1659_tgt
    gt rx1659_pos, rx1659_eos, rx1659_done
    set rx1659_off, 0
    lt rx1659_pos, 2, rx1659_start
    sub rx1659_off, rx1659_pos, 1
    substr rx1659_tgt, rx1659_tgt, rx1659_off
  rx1659_start:
    eq $I10, 1, rx1659_restart
    if_null rx1659_debug, debug_1254
    rx1659_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1254:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1663_done
    goto rxscan1663_scan
  rxscan1663_loop:
    (rx1659_pos) = rx1659_cur."from"()
    inc rx1659_pos
    rx1659_cur."!cursor_from"(rx1659_pos)
    ge rx1659_pos, rx1659_eos, rxscan1663_done
  rxscan1663_scan:
    set_addr $I10, rxscan1663_loop
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  rxscan1663_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1664_fail
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  # rx literal  "|"
    add $I11, rx1659_pos, 1
    gt $I11, rx1659_eos, rx1659_fail
    sub $I11, rx1659_pos, rx1659_off
    ord $I11, rx1659_tgt, $I11
    ne $I11, 124, rx1659_fail
    add rx1659_pos, 1
    set_addr $I10, rxcap_1664_fail
    ($I12, $I11) = rx1659_cur."!mark_peek"($I10)
    rx1659_cur."!cursor_pos"($I11)
    ($P10) = rx1659_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1659_pos, "")
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1664_done
  rxcap_1664_fail:
    goto rx1659_fail
  rxcap_1664_done:
  # rx subrule "O" subtype=capture negate=
    rx1659_cur."!cursor_pos"(rx1659_pos)
    $P10 = rx1659_cur."O"("%symbolic_unary")
    unless $P10, rx1659_fail
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1659_pos = $P10."pos"()
  # rx pass
    rx1659_cur."!cursor_pass"(rx1659_pos, "prefix:sym<|>")
    if_null rx1659_debug, debug_1255
    rx1659_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1659_pos)
  debug_1255:
    .return (rx1659_cur)
  rx1659_restart:
.annotate 'line', 10
    if_null rx1659_debug, debug_1256
    rx1659_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1256:
  rx1659_fail:
    (rx1659_rep, rx1659_pos, $I10, $P10) = rx1659_cur."!mark_fail"(0)
    lt rx1659_pos, -1, rx1659_done
    eq rx1659_pos, -1, rx1659_fail
    jump $I10
  rx1659_done:
    rx1659_cur."!cursor_fail"()
    if_null rx1659_debug, debug_1257
    rx1659_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1257:
    .return (rx1659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303857440.612") :method
.annotate 'line', 10
    $P1661 = self."!PREFIX__!subrule"("O", "|")
    new $P1662, "ResizablePMCArray"
    push $P1662, $P1661
    .return ($P1662)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1666_tgt
    .local int rx1666_pos
    .local int rx1666_off
    .local int rx1666_eos
    .local int rx1666_rep
    .local pmc rx1666_cur
    .local pmc rx1666_debug
    (rx1666_cur, rx1666_pos, rx1666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1666_cur
    .local pmc match
    .lex "$/", match
    length rx1666_eos, rx1666_tgt
    gt rx1666_pos, rx1666_eos, rx1666_done
    set rx1666_off, 0
    lt rx1666_pos, 2, rx1666_start
    sub rx1666_off, rx1666_pos, 1
    substr rx1666_tgt, rx1666_tgt, rx1666_off
  rx1666_start:
    eq $I10, 1, rx1666_restart
    if_null rx1666_debug, debug_1258
    rx1666_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1258:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1670_done
    goto rxscan1670_scan
  rxscan1670_loop:
    (rx1666_pos) = rx1666_cur."from"()
    inc rx1666_pos
    rx1666_cur."!cursor_from"(rx1666_pos)
    ge rx1666_pos, rx1666_eos, rxscan1670_done
  rxscan1670_scan:
    set_addr $I10, rxscan1670_loop
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  rxscan1670_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1671_fail
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  # rx literal  "*"
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 42, rx1666_fail
    add rx1666_pos, 1
    set_addr $I10, rxcap_1671_fail
    ($I12, $I11) = rx1666_cur."!mark_peek"($I10)
    rx1666_cur."!cursor_pos"($I11)
    ($P10) = rx1666_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1666_pos, "")
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1671_done
  rxcap_1671_fail:
    goto rx1666_fail
  rxcap_1671_done:
  # rx subrule "O" subtype=capture negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1666_fail
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1666_pos = $P10."pos"()
  # rx pass
    rx1666_cur."!cursor_pass"(rx1666_pos, "infix:sym<*>")
    if_null rx1666_debug, debug_1259
    rx1666_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1666_pos)
  debug_1259:
    .return (rx1666_cur)
  rx1666_restart:
.annotate 'line', 10
    if_null rx1666_debug, debug_1260
    rx1666_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1260:
  rx1666_fail:
    (rx1666_rep, rx1666_pos, $I10, $P10) = rx1666_cur."!mark_fail"(0)
    lt rx1666_pos, -1, rx1666_done
    eq rx1666_pos, -1, rx1666_fail
    jump $I10
  rx1666_done:
    rx1666_cur."!cursor_fail"()
    if_null rx1666_debug, debug_1261
    rx1666_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1261:
    .return (rx1666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303857440.612") :method
.annotate 'line', 10
    $P1668 = self."!PREFIX__!subrule"("O", "*")
    new $P1669, "ResizablePMCArray"
    push $P1669, $P1668
    .return ($P1669)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1673_tgt
    .local int rx1673_pos
    .local int rx1673_off
    .local int rx1673_eos
    .local int rx1673_rep
    .local pmc rx1673_cur
    .local pmc rx1673_debug
    (rx1673_cur, rx1673_pos, rx1673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1673_cur
    .local pmc match
    .lex "$/", match
    length rx1673_eos, rx1673_tgt
    gt rx1673_pos, rx1673_eos, rx1673_done
    set rx1673_off, 0
    lt rx1673_pos, 2, rx1673_start
    sub rx1673_off, rx1673_pos, 1
    substr rx1673_tgt, rx1673_tgt, rx1673_off
  rx1673_start:
    eq $I10, 1, rx1673_restart
    if_null rx1673_debug, debug_1262
    rx1673_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1262:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1677_done
    goto rxscan1677_scan
  rxscan1677_loop:
    (rx1673_pos) = rx1673_cur."from"()
    inc rx1673_pos
    rx1673_cur."!cursor_from"(rx1673_pos)
    ge rx1673_pos, rx1673_eos, rxscan1677_done
  rxscan1677_scan:
    set_addr $I10, rxscan1677_loop
    rx1673_cur."!mark_push"(0, rx1673_pos, $I10)
  rxscan1677_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1678_fail
    rx1673_cur."!mark_push"(0, rx1673_pos, $I10)
  # rx literal  "/"
    add $I11, rx1673_pos, 1
    gt $I11, rx1673_eos, rx1673_fail
    sub $I11, rx1673_pos, rx1673_off
    ord $I11, rx1673_tgt, $I11
    ne $I11, 47, rx1673_fail
    add rx1673_pos, 1
    set_addr $I10, rxcap_1678_fail
    ($I12, $I11) = rx1673_cur."!mark_peek"($I10)
    rx1673_cur."!cursor_pos"($I11)
    ($P10) = rx1673_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1673_pos, "")
    rx1673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1678_done
  rxcap_1678_fail:
    goto rx1673_fail
  rxcap_1678_done:
  # rx subrule "O" subtype=capture negate=
    rx1673_cur."!cursor_pos"(rx1673_pos)
    $P10 = rx1673_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1673_fail
    rx1673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1673_pos = $P10."pos"()
  # rx pass
    rx1673_cur."!cursor_pass"(rx1673_pos, "infix:sym</>")
    if_null rx1673_debug, debug_1263
    rx1673_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1673_pos)
  debug_1263:
    .return (rx1673_cur)
  rx1673_restart:
.annotate 'line', 10
    if_null rx1673_debug, debug_1264
    rx1673_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1264:
  rx1673_fail:
    (rx1673_rep, rx1673_pos, $I10, $P10) = rx1673_cur."!mark_fail"(0)
    lt rx1673_pos, -1, rx1673_done
    eq rx1673_pos, -1, rx1673_fail
    jump $I10
  rx1673_done:
    rx1673_cur."!cursor_fail"()
    if_null rx1673_debug, debug_1265
    rx1673_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1265:
    .return (rx1673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303857440.612") :method
.annotate 'line', 10
    $P1675 = self."!PREFIX__!subrule"("O", "/")
    new $P1676, "ResizablePMCArray"
    push $P1676, $P1675
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1266
    rx1680_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1266:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1684_done
    goto rxscan1684_scan
  rxscan1684_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1684_done
  rxscan1684_scan:
    set_addr $I10, rxscan1684_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1684_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1685_fail
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  # rx literal  "%"
    add $I11, rx1680_pos, 1
    gt $I11, rx1680_eos, rx1680_fail
    sub $I11, rx1680_pos, rx1680_off
    ord $I11, rx1680_tgt, $I11
    ne $I11, 37, rx1680_fail
    add rx1680_pos, 1
    set_addr $I10, rxcap_1685_fail
    ($I12, $I11) = rx1680_cur."!mark_peek"($I10)
    rx1680_cur."!cursor_pos"($I11)
    ($P10) = rx1680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1680_pos, "")
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1685_done
  rxcap_1685_fail:
    goto rx1680_fail
  rxcap_1685_done:
  # rx subrule "O" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1680_pos = $P10."pos"()
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "infix:sym<%>")
    if_null rx1680_debug, debug_1267
    rx1680_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1680_pos)
  debug_1267:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 10
    if_null rx1680_debug, debug_1268
    rx1680_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1268:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1269
    rx1680_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1269:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303857440.612") :method
.annotate 'line', 10
    $P1682 = self."!PREFIX__!subrule"("O", "%")
    new $P1683, "ResizablePMCArray"
    push $P1683, $P1682
    .return ($P1683)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1687_tgt
    .local int rx1687_pos
    .local int rx1687_off
    .local int rx1687_eos
    .local int rx1687_rep
    .local pmc rx1687_cur
    .local pmc rx1687_debug
    (rx1687_cur, rx1687_pos, rx1687_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1687_cur
    .local pmc match
    .lex "$/", match
    length rx1687_eos, rx1687_tgt
    gt rx1687_pos, rx1687_eos, rx1687_done
    set rx1687_off, 0
    lt rx1687_pos, 2, rx1687_start
    sub rx1687_off, rx1687_pos, 1
    substr rx1687_tgt, rx1687_tgt, rx1687_off
  rx1687_start:
    eq $I10, 1, rx1687_restart
    if_null rx1687_debug, debug_1270
    rx1687_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1270:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1691_done
    goto rxscan1691_scan
  rxscan1691_loop:
    (rx1687_pos) = rx1687_cur."from"()
    inc rx1687_pos
    rx1687_cur."!cursor_from"(rx1687_pos)
    ge rx1687_pos, rx1687_eos, rxscan1691_done
  rxscan1691_scan:
    set_addr $I10, rxscan1691_loop
    rx1687_cur."!mark_push"(0, rx1687_pos, $I10)
  rxscan1691_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1692_fail
    rx1687_cur."!mark_push"(0, rx1687_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1687_pos, 2
    gt $I11, rx1687_eos, rx1687_fail
    sub $I11, rx1687_pos, rx1687_off
    substr $S10, rx1687_tgt, $I11, 2
    ne $S10, "+&", rx1687_fail
    add rx1687_pos, 2
    set_addr $I10, rxcap_1692_fail
    ($I12, $I11) = rx1687_cur."!mark_peek"($I10)
    rx1687_cur."!cursor_pos"($I11)
    ($P10) = rx1687_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1687_pos, "")
    rx1687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1692_done
  rxcap_1692_fail:
    goto rx1687_fail
  rxcap_1692_done:
  # rx subrule "O" subtype=capture negate=
    rx1687_cur."!cursor_pos"(rx1687_pos)
    $P10 = rx1687_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1687_fail
    rx1687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1687_pos = $P10."pos"()
  # rx pass
    rx1687_cur."!cursor_pass"(rx1687_pos, "infix:sym<+&>")
    if_null rx1687_debug, debug_1271
    rx1687_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1687_pos)
  debug_1271:
    .return (rx1687_cur)
  rx1687_restart:
.annotate 'line', 10
    if_null rx1687_debug, debug_1272
    rx1687_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1272:
  rx1687_fail:
    (rx1687_rep, rx1687_pos, $I10, $P10) = rx1687_cur."!mark_fail"(0)
    lt rx1687_pos, -1, rx1687_done
    eq rx1687_pos, -1, rx1687_fail
    jump $I10
  rx1687_done:
    rx1687_cur."!cursor_fail"()
    if_null rx1687_debug, debug_1273
    rx1687_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1273:
    .return (rx1687_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303857440.612") :method
.annotate 'line', 10
    $P1689 = self."!PREFIX__!subrule"("O", "+&")
    new $P1690, "ResizablePMCArray"
    push $P1690, $P1689
    .return ($P1690)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1694_tgt
    .local int rx1694_pos
    .local int rx1694_off
    .local int rx1694_eos
    .local int rx1694_rep
    .local pmc rx1694_cur
    .local pmc rx1694_debug
    (rx1694_cur, rx1694_pos, rx1694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1694_cur
    .local pmc match
    .lex "$/", match
    length rx1694_eos, rx1694_tgt
    gt rx1694_pos, rx1694_eos, rx1694_done
    set rx1694_off, 0
    lt rx1694_pos, 2, rx1694_start
    sub rx1694_off, rx1694_pos, 1
    substr rx1694_tgt, rx1694_tgt, rx1694_off
  rx1694_start:
    eq $I10, 1, rx1694_restart
    if_null rx1694_debug, debug_1274
    rx1694_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1274:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1698_done
    goto rxscan1698_scan
  rxscan1698_loop:
    (rx1694_pos) = rx1694_cur."from"()
    inc rx1694_pos
    rx1694_cur."!cursor_from"(rx1694_pos)
    ge rx1694_pos, rx1694_eos, rxscan1698_done
  rxscan1698_scan:
    set_addr $I10, rxscan1698_loop
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  rxscan1698_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1699_fail
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  # rx literal  "+"
    add $I11, rx1694_pos, 1
    gt $I11, rx1694_eos, rx1694_fail
    sub $I11, rx1694_pos, rx1694_off
    ord $I11, rx1694_tgt, $I11
    ne $I11, 43, rx1694_fail
    add rx1694_pos, 1
    set_addr $I10, rxcap_1699_fail
    ($I12, $I11) = rx1694_cur."!mark_peek"($I10)
    rx1694_cur."!cursor_pos"($I11)
    ($P10) = rx1694_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1694_pos, "")
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1699_done
  rxcap_1699_fail:
    goto rx1694_fail
  rxcap_1699_done:
  # rx subrule "O" subtype=capture negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1694_fail
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1694_pos = $P10."pos"()
  # rx pass
    rx1694_cur."!cursor_pass"(rx1694_pos, "infix:sym<+>")
    if_null rx1694_debug, debug_1275
    rx1694_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1694_pos)
  debug_1275:
    .return (rx1694_cur)
  rx1694_restart:
.annotate 'line', 10
    if_null rx1694_debug, debug_1276
    rx1694_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1276:
  rx1694_fail:
    (rx1694_rep, rx1694_pos, $I10, $P10) = rx1694_cur."!mark_fail"(0)
    lt rx1694_pos, -1, rx1694_done
    eq rx1694_pos, -1, rx1694_fail
    jump $I10
  rx1694_done:
    rx1694_cur."!cursor_fail"()
    if_null rx1694_debug, debug_1277
    rx1694_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1277:
    .return (rx1694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303857440.612") :method
.annotate 'line', 10
    $P1696 = self."!PREFIX__!subrule"("O", "+")
    new $P1697, "ResizablePMCArray"
    push $P1697, $P1696
    .return ($P1697)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1701_tgt
    .local int rx1701_pos
    .local int rx1701_off
    .local int rx1701_eos
    .local int rx1701_rep
    .local pmc rx1701_cur
    .local pmc rx1701_debug
    (rx1701_cur, rx1701_pos, rx1701_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1701_cur
    .local pmc match
    .lex "$/", match
    length rx1701_eos, rx1701_tgt
    gt rx1701_pos, rx1701_eos, rx1701_done
    set rx1701_off, 0
    lt rx1701_pos, 2, rx1701_start
    sub rx1701_off, rx1701_pos, 1
    substr rx1701_tgt, rx1701_tgt, rx1701_off
  rx1701_start:
    eq $I10, 1, rx1701_restart
    if_null rx1701_debug, debug_1278
    rx1701_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1278:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1705_done
    goto rxscan1705_scan
  rxscan1705_loop:
    (rx1701_pos) = rx1701_cur."from"()
    inc rx1701_pos
    rx1701_cur."!cursor_from"(rx1701_pos)
    ge rx1701_pos, rx1701_eos, rxscan1705_done
  rxscan1705_scan:
    set_addr $I10, rxscan1705_loop
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  rxscan1705_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1706_fail
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  # rx literal  "-"
    add $I11, rx1701_pos, 1
    gt $I11, rx1701_eos, rx1701_fail
    sub $I11, rx1701_pos, rx1701_off
    ord $I11, rx1701_tgt, $I11
    ne $I11, 45, rx1701_fail
    add rx1701_pos, 1
    set_addr $I10, rxcap_1706_fail
    ($I12, $I11) = rx1701_cur."!mark_peek"($I10)
    rx1701_cur."!cursor_pos"($I11)
    ($P10) = rx1701_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1701_pos, "")
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1706_done
  rxcap_1706_fail:
    goto rx1701_fail
  rxcap_1706_done:
  # rx subrule "O" subtype=capture negate=
    rx1701_cur."!cursor_pos"(rx1701_pos)
    $P10 = rx1701_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1701_fail
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1701_pos = $P10."pos"()
  # rx pass
    rx1701_cur."!cursor_pass"(rx1701_pos, "infix:sym<->")
    if_null rx1701_debug, debug_1279
    rx1701_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1701_pos)
  debug_1279:
    .return (rx1701_cur)
  rx1701_restart:
.annotate 'line', 10
    if_null rx1701_debug, debug_1280
    rx1701_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1280:
  rx1701_fail:
    (rx1701_rep, rx1701_pos, $I10, $P10) = rx1701_cur."!mark_fail"(0)
    lt rx1701_pos, -1, rx1701_done
    eq rx1701_pos, -1, rx1701_fail
    jump $I10
  rx1701_done:
    rx1701_cur."!cursor_fail"()
    if_null rx1701_debug, debug_1281
    rx1701_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1281:
    .return (rx1701_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303857440.612") :method
.annotate 'line', 10
    $P1703 = self."!PREFIX__!subrule"("O", "-")
    new $P1704, "ResizablePMCArray"
    push $P1704, $P1703
    .return ($P1704)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1708_tgt
    .local int rx1708_pos
    .local int rx1708_off
    .local int rx1708_eos
    .local int rx1708_rep
    .local pmc rx1708_cur
    .local pmc rx1708_debug
    (rx1708_cur, rx1708_pos, rx1708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1708_cur
    .local pmc match
    .lex "$/", match
    length rx1708_eos, rx1708_tgt
    gt rx1708_pos, rx1708_eos, rx1708_done
    set rx1708_off, 0
    lt rx1708_pos, 2, rx1708_start
    sub rx1708_off, rx1708_pos, 1
    substr rx1708_tgt, rx1708_tgt, rx1708_off
  rx1708_start:
    eq $I10, 1, rx1708_restart
    if_null rx1708_debug, debug_1282
    rx1708_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1282:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1712_done
    goto rxscan1712_scan
  rxscan1712_loop:
    (rx1708_pos) = rx1708_cur."from"()
    inc rx1708_pos
    rx1708_cur."!cursor_from"(rx1708_pos)
    ge rx1708_pos, rx1708_eos, rxscan1712_done
  rxscan1712_scan:
    set_addr $I10, rxscan1712_loop
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  rxscan1712_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1713_fail
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1708_pos, 2
    gt $I11, rx1708_eos, rx1708_fail
    sub $I11, rx1708_pos, rx1708_off
    substr $S10, rx1708_tgt, $I11, 2
    ne $S10, "+|", rx1708_fail
    add rx1708_pos, 2
    set_addr $I10, rxcap_1713_fail
    ($I12, $I11) = rx1708_cur."!mark_peek"($I10)
    rx1708_cur."!cursor_pos"($I11)
    ($P10) = rx1708_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1708_pos, "")
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1713_done
  rxcap_1713_fail:
    goto rx1708_fail
  rxcap_1713_done:
  # rx subrule "O" subtype=capture negate=
    rx1708_cur."!cursor_pos"(rx1708_pos)
    $P10 = rx1708_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1708_fail
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1708_pos = $P10."pos"()
  # rx pass
    rx1708_cur."!cursor_pass"(rx1708_pos, "infix:sym<+|>")
    if_null rx1708_debug, debug_1283
    rx1708_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1708_pos)
  debug_1283:
    .return (rx1708_cur)
  rx1708_restart:
.annotate 'line', 10
    if_null rx1708_debug, debug_1284
    rx1708_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1284:
  rx1708_fail:
    (rx1708_rep, rx1708_pos, $I10, $P10) = rx1708_cur."!mark_fail"(0)
    lt rx1708_pos, -1, rx1708_done
    eq rx1708_pos, -1, rx1708_fail
    jump $I10
  rx1708_done:
    rx1708_cur."!cursor_fail"()
    if_null rx1708_debug, debug_1285
    rx1708_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1285:
    .return (rx1708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303857440.612") :method
.annotate 'line', 10
    $P1710 = self."!PREFIX__!subrule"("O", "+|")
    new $P1711, "ResizablePMCArray"
    push $P1711, $P1710
    .return ($P1711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1715_tgt
    .local int rx1715_pos
    .local int rx1715_off
    .local int rx1715_eos
    .local int rx1715_rep
    .local pmc rx1715_cur
    .local pmc rx1715_debug
    (rx1715_cur, rx1715_pos, rx1715_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1715_cur
    .local pmc match
    .lex "$/", match
    length rx1715_eos, rx1715_tgt
    gt rx1715_pos, rx1715_eos, rx1715_done
    set rx1715_off, 0
    lt rx1715_pos, 2, rx1715_start
    sub rx1715_off, rx1715_pos, 1
    substr rx1715_tgt, rx1715_tgt, rx1715_off
  rx1715_start:
    eq $I10, 1, rx1715_restart
    if_null rx1715_debug, debug_1286
    rx1715_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1719_done
    goto rxscan1719_scan
  rxscan1719_loop:
    (rx1715_pos) = rx1715_cur."from"()
    inc rx1715_pos
    rx1715_cur."!cursor_from"(rx1715_pos)
    ge rx1715_pos, rx1715_eos, rxscan1719_done
  rxscan1719_scan:
    set_addr $I10, rxscan1719_loop
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  rxscan1719_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1720_fail
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1715_pos, 2
    gt $I11, rx1715_eos, rx1715_fail
    sub $I11, rx1715_pos, rx1715_off
    substr $S10, rx1715_tgt, $I11, 2
    ne $S10, "+^", rx1715_fail
    add rx1715_pos, 2
    set_addr $I10, rxcap_1720_fail
    ($I12, $I11) = rx1715_cur."!mark_peek"($I10)
    rx1715_cur."!cursor_pos"($I11)
    ($P10) = rx1715_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1715_pos, "")
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1720_done
  rxcap_1720_fail:
    goto rx1715_fail
  rxcap_1720_done:
  # rx subrule "O" subtype=capture negate=
    rx1715_cur."!cursor_pos"(rx1715_pos)
    $P10 = rx1715_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1715_fail
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1715_pos = $P10."pos"()
  # rx pass
    rx1715_cur."!cursor_pass"(rx1715_pos, "infix:sym<+^>")
    if_null rx1715_debug, debug_1287
    rx1715_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1715_pos)
  debug_1287:
    .return (rx1715_cur)
  rx1715_restart:
.annotate 'line', 10
    if_null rx1715_debug, debug_1288
    rx1715_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1288:
  rx1715_fail:
    (rx1715_rep, rx1715_pos, $I10, $P10) = rx1715_cur."!mark_fail"(0)
    lt rx1715_pos, -1, rx1715_done
    eq rx1715_pos, -1, rx1715_fail
    jump $I10
  rx1715_done:
    rx1715_cur."!cursor_fail"()
    if_null rx1715_debug, debug_1289
    rx1715_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1289:
    .return (rx1715_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303857440.612") :method
.annotate 'line', 10
    $P1717 = self."!PREFIX__!subrule"("O", "+^")
    new $P1718, "ResizablePMCArray"
    push $P1718, $P1717
    .return ($P1718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1722_tgt
    .local int rx1722_pos
    .local int rx1722_off
    .local int rx1722_eos
    .local int rx1722_rep
    .local pmc rx1722_cur
    .local pmc rx1722_debug
    (rx1722_cur, rx1722_pos, rx1722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1722_cur
    .local pmc match
    .lex "$/", match
    length rx1722_eos, rx1722_tgt
    gt rx1722_pos, rx1722_eos, rx1722_done
    set rx1722_off, 0
    lt rx1722_pos, 2, rx1722_start
    sub rx1722_off, rx1722_pos, 1
    substr rx1722_tgt, rx1722_tgt, rx1722_off
  rx1722_start:
    eq $I10, 1, rx1722_restart
    if_null rx1722_debug, debug_1290
    rx1722_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1726_done
    goto rxscan1726_scan
  rxscan1726_loop:
    (rx1722_pos) = rx1722_cur."from"()
    inc rx1722_pos
    rx1722_cur."!cursor_from"(rx1722_pos)
    ge rx1722_pos, rx1722_eos, rxscan1726_done
  rxscan1726_scan:
    set_addr $I10, rxscan1726_loop
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  rxscan1726_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1727_fail
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  # rx literal  "~"
    add $I11, rx1722_pos, 1
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    ord $I11, rx1722_tgt, $I11
    ne $I11, 126, rx1722_fail
    add rx1722_pos, 1
    set_addr $I10, rxcap_1727_fail
    ($I12, $I11) = rx1722_cur."!mark_peek"($I10)
    rx1722_cur."!cursor_pos"($I11)
    ($P10) = rx1722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1722_pos, "")
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1727_done
  rxcap_1727_fail:
    goto rx1722_fail
  rxcap_1727_done:
  # rx subrule "O" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1722_pos = $P10."pos"()
  # rx pass
    rx1722_cur."!cursor_pass"(rx1722_pos, "infix:sym<~>")
    if_null rx1722_debug, debug_1291
    rx1722_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1722_pos)
  debug_1291:
    .return (rx1722_cur)
  rx1722_restart:
.annotate 'line', 10
    if_null rx1722_debug, debug_1292
    rx1722_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1292:
  rx1722_fail:
    (rx1722_rep, rx1722_pos, $I10, $P10) = rx1722_cur."!mark_fail"(0)
    lt rx1722_pos, -1, rx1722_done
    eq rx1722_pos, -1, rx1722_fail
    jump $I10
  rx1722_done:
    rx1722_cur."!cursor_fail"()
    if_null rx1722_debug, debug_1293
    rx1722_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1293:
    .return (rx1722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303857440.612") :method
.annotate 'line', 10
    $P1724 = self."!PREFIX__!subrule"("O", "~")
    new $P1725, "ResizablePMCArray"
    push $P1725, $P1724
    .return ($P1725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1729_tgt
    .local int rx1729_pos
    .local int rx1729_off
    .local int rx1729_eos
    .local int rx1729_rep
    .local pmc rx1729_cur
    .local pmc rx1729_debug
    (rx1729_cur, rx1729_pos, rx1729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1729_cur
    .local pmc match
    .lex "$/", match
    length rx1729_eos, rx1729_tgt
    gt rx1729_pos, rx1729_eos, rx1729_done
    set rx1729_off, 0
    lt rx1729_pos, 2, rx1729_start
    sub rx1729_off, rx1729_pos, 1
    substr rx1729_tgt, rx1729_tgt, rx1729_off
  rx1729_start:
    eq $I10, 1, rx1729_restart
    if_null rx1729_debug, debug_1294
    rx1729_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1733_done
    goto rxscan1733_scan
  rxscan1733_loop:
    (rx1729_pos) = rx1729_cur."from"()
    inc rx1729_pos
    rx1729_cur."!cursor_from"(rx1729_pos)
    ge rx1729_pos, rx1729_eos, rxscan1733_done
  rxscan1733_scan:
    set_addr $I10, rxscan1733_loop
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  rxscan1733_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1734_fail
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  # rx literal  "=="
    add $I11, rx1729_pos, 2
    gt $I11, rx1729_eos, rx1729_fail
    sub $I11, rx1729_pos, rx1729_off
    substr $S10, rx1729_tgt, $I11, 2
    ne $S10, "==", rx1729_fail
    add rx1729_pos, 2
    set_addr $I10, rxcap_1734_fail
    ($I12, $I11) = rx1729_cur."!mark_peek"($I10)
    rx1729_cur."!cursor_pos"($I11)
    ($P10) = rx1729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1729_pos, "")
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1734_done
  rxcap_1734_fail:
    goto rx1729_fail
  rxcap_1734_done:
  # rx subrule "O" subtype=capture negate=
    rx1729_cur."!cursor_pos"(rx1729_pos)
    $P10 = rx1729_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1729_fail
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1729_pos = $P10."pos"()
  # rx pass
    rx1729_cur."!cursor_pass"(rx1729_pos, "infix:sym<==>")
    if_null rx1729_debug, debug_1295
    rx1729_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1729_pos)
  debug_1295:
    .return (rx1729_cur)
  rx1729_restart:
.annotate 'line', 10
    if_null rx1729_debug, debug_1296
    rx1729_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1296:
  rx1729_fail:
    (rx1729_rep, rx1729_pos, $I10, $P10) = rx1729_cur."!mark_fail"(0)
    lt rx1729_pos, -1, rx1729_done
    eq rx1729_pos, -1, rx1729_fail
    jump $I10
  rx1729_done:
    rx1729_cur."!cursor_fail"()
    if_null rx1729_debug, debug_1297
    rx1729_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1297:
    .return (rx1729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303857440.612") :method
.annotate 'line', 10
    $P1731 = self."!PREFIX__!subrule"("O", "==")
    new $P1732, "ResizablePMCArray"
    push $P1732, $P1731
    .return ($P1732)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1736_tgt
    .local int rx1736_pos
    .local int rx1736_off
    .local int rx1736_eos
    .local int rx1736_rep
    .local pmc rx1736_cur
    .local pmc rx1736_debug
    (rx1736_cur, rx1736_pos, rx1736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1736_cur
    .local pmc match
    .lex "$/", match
    length rx1736_eos, rx1736_tgt
    gt rx1736_pos, rx1736_eos, rx1736_done
    set rx1736_off, 0
    lt rx1736_pos, 2, rx1736_start
    sub rx1736_off, rx1736_pos, 1
    substr rx1736_tgt, rx1736_tgt, rx1736_off
  rx1736_start:
    eq $I10, 1, rx1736_restart
    if_null rx1736_debug, debug_1298
    rx1736_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1740_done
    goto rxscan1740_scan
  rxscan1740_loop:
    (rx1736_pos) = rx1736_cur."from"()
    inc rx1736_pos
    rx1736_cur."!cursor_from"(rx1736_pos)
    ge rx1736_pos, rx1736_eos, rxscan1740_done
  rxscan1740_scan:
    set_addr $I10, rxscan1740_loop
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  rxscan1740_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1741_fail
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  # rx literal  "!="
    add $I11, rx1736_pos, 2
    gt $I11, rx1736_eos, rx1736_fail
    sub $I11, rx1736_pos, rx1736_off
    substr $S10, rx1736_tgt, $I11, 2
    ne $S10, "!=", rx1736_fail
    add rx1736_pos, 2
    set_addr $I10, rxcap_1741_fail
    ($I12, $I11) = rx1736_cur."!mark_peek"($I10)
    rx1736_cur."!cursor_pos"($I11)
    ($P10) = rx1736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1736_pos, "")
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1741_done
  rxcap_1741_fail:
    goto rx1736_fail
  rxcap_1741_done:
  # rx subrule "O" subtype=capture negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1736_fail
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1736_pos = $P10."pos"()
  # rx pass
    rx1736_cur."!cursor_pass"(rx1736_pos, "infix:sym<!=>")
    if_null rx1736_debug, debug_1299
    rx1736_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1736_pos)
  debug_1299:
    .return (rx1736_cur)
  rx1736_restart:
.annotate 'line', 10
    if_null rx1736_debug, debug_1300
    rx1736_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1300:
  rx1736_fail:
    (rx1736_rep, rx1736_pos, $I10, $P10) = rx1736_cur."!mark_fail"(0)
    lt rx1736_pos, -1, rx1736_done
    eq rx1736_pos, -1, rx1736_fail
    jump $I10
  rx1736_done:
    rx1736_cur."!cursor_fail"()
    if_null rx1736_debug, debug_1301
    rx1736_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1301:
    .return (rx1736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303857440.612") :method
.annotate 'line', 10
    $P1738 = self."!PREFIX__!subrule"("O", "!=")
    new $P1739, "ResizablePMCArray"
    push $P1739, $P1738
    .return ($P1739)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1743_tgt
    .local int rx1743_pos
    .local int rx1743_off
    .local int rx1743_eos
    .local int rx1743_rep
    .local pmc rx1743_cur
    .local pmc rx1743_debug
    (rx1743_cur, rx1743_pos, rx1743_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1743_cur
    .local pmc match
    .lex "$/", match
    length rx1743_eos, rx1743_tgt
    gt rx1743_pos, rx1743_eos, rx1743_done
    set rx1743_off, 0
    lt rx1743_pos, 2, rx1743_start
    sub rx1743_off, rx1743_pos, 1
    substr rx1743_tgt, rx1743_tgt, rx1743_off
  rx1743_start:
    eq $I10, 1, rx1743_restart
    if_null rx1743_debug, debug_1302
    rx1743_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1302:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1747_done
    goto rxscan1747_scan
  rxscan1747_loop:
    (rx1743_pos) = rx1743_cur."from"()
    inc rx1743_pos
    rx1743_cur."!cursor_from"(rx1743_pos)
    ge rx1743_pos, rx1743_eos, rxscan1747_done
  rxscan1747_scan:
    set_addr $I10, rxscan1747_loop
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  rxscan1747_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1748_fail
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  # rx literal  "<="
    add $I11, rx1743_pos, 2
    gt $I11, rx1743_eos, rx1743_fail
    sub $I11, rx1743_pos, rx1743_off
    substr $S10, rx1743_tgt, $I11, 2
    ne $S10, "<=", rx1743_fail
    add rx1743_pos, 2
    set_addr $I10, rxcap_1748_fail
    ($I12, $I11) = rx1743_cur."!mark_peek"($I10)
    rx1743_cur."!cursor_pos"($I11)
    ($P10) = rx1743_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1743_pos, "")
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1748_done
  rxcap_1748_fail:
    goto rx1743_fail
  rxcap_1748_done:
  # rx subrule "O" subtype=capture negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1743_fail
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1743_pos = $P10."pos"()
  # rx pass
    rx1743_cur."!cursor_pass"(rx1743_pos, "infix:sym<<=>")
    if_null rx1743_debug, debug_1303
    rx1743_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1743_pos)
  debug_1303:
    .return (rx1743_cur)
  rx1743_restart:
.annotate 'line', 10
    if_null rx1743_debug, debug_1304
    rx1743_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1304:
  rx1743_fail:
    (rx1743_rep, rx1743_pos, $I10, $P10) = rx1743_cur."!mark_fail"(0)
    lt rx1743_pos, -1, rx1743_done
    eq rx1743_pos, -1, rx1743_fail
    jump $I10
  rx1743_done:
    rx1743_cur."!cursor_fail"()
    if_null rx1743_debug, debug_1305
    rx1743_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1305:
    .return (rx1743_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303857440.612") :method
.annotate 'line', 10
    $P1745 = self."!PREFIX__!subrule"("O", "<=")
    new $P1746, "ResizablePMCArray"
    push $P1746, $P1745
    .return ($P1746)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1750_tgt
    .local int rx1750_pos
    .local int rx1750_off
    .local int rx1750_eos
    .local int rx1750_rep
    .local pmc rx1750_cur
    .local pmc rx1750_debug
    (rx1750_cur, rx1750_pos, rx1750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1750_cur
    .local pmc match
    .lex "$/", match
    length rx1750_eos, rx1750_tgt
    gt rx1750_pos, rx1750_eos, rx1750_done
    set rx1750_off, 0
    lt rx1750_pos, 2, rx1750_start
    sub rx1750_off, rx1750_pos, 1
    substr rx1750_tgt, rx1750_tgt, rx1750_off
  rx1750_start:
    eq $I10, 1, rx1750_restart
    if_null rx1750_debug, debug_1306
    rx1750_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1306:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1754_done
    goto rxscan1754_scan
  rxscan1754_loop:
    (rx1750_pos) = rx1750_cur."from"()
    inc rx1750_pos
    rx1750_cur."!cursor_from"(rx1750_pos)
    ge rx1750_pos, rx1750_eos, rxscan1754_done
  rxscan1754_scan:
    set_addr $I10, rxscan1754_loop
    rx1750_cur."!mark_push"(0, rx1750_pos, $I10)
  rxscan1754_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1755_fail
    rx1750_cur."!mark_push"(0, rx1750_pos, $I10)
  # rx literal  ">="
    add $I11, rx1750_pos, 2
    gt $I11, rx1750_eos, rx1750_fail
    sub $I11, rx1750_pos, rx1750_off
    substr $S10, rx1750_tgt, $I11, 2
    ne $S10, ">=", rx1750_fail
    add rx1750_pos, 2
    set_addr $I10, rxcap_1755_fail
    ($I12, $I11) = rx1750_cur."!mark_peek"($I10)
    rx1750_cur."!cursor_pos"($I11)
    ($P10) = rx1750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1750_pos, "")
    rx1750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1755_done
  rxcap_1755_fail:
    goto rx1750_fail
  rxcap_1755_done:
  # rx subrule "O" subtype=capture negate=
    rx1750_cur."!cursor_pos"(rx1750_pos)
    $P10 = rx1750_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1750_fail
    rx1750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1750_pos = $P10."pos"()
  # rx pass
    rx1750_cur."!cursor_pass"(rx1750_pos, "infix:sym<>=>")
    if_null rx1750_debug, debug_1307
    rx1750_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1750_pos)
  debug_1307:
    .return (rx1750_cur)
  rx1750_restart:
.annotate 'line', 10
    if_null rx1750_debug, debug_1308
    rx1750_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1308:
  rx1750_fail:
    (rx1750_rep, rx1750_pos, $I10, $P10) = rx1750_cur."!mark_fail"(0)
    lt rx1750_pos, -1, rx1750_done
    eq rx1750_pos, -1, rx1750_fail
    jump $I10
  rx1750_done:
    rx1750_cur."!cursor_fail"()
    if_null rx1750_debug, debug_1309
    rx1750_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1309:
    .return (rx1750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303857440.612") :method
.annotate 'line', 10
    $P1752 = self."!PREFIX__!subrule"("O", ">=")
    new $P1753, "ResizablePMCArray"
    push $P1753, $P1752
    .return ($P1753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1757_tgt
    .local int rx1757_pos
    .local int rx1757_off
    .local int rx1757_eos
    .local int rx1757_rep
    .local pmc rx1757_cur
    .local pmc rx1757_debug
    (rx1757_cur, rx1757_pos, rx1757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1757_cur
    .local pmc match
    .lex "$/", match
    length rx1757_eos, rx1757_tgt
    gt rx1757_pos, rx1757_eos, rx1757_done
    set rx1757_off, 0
    lt rx1757_pos, 2, rx1757_start
    sub rx1757_off, rx1757_pos, 1
    substr rx1757_tgt, rx1757_tgt, rx1757_off
  rx1757_start:
    eq $I10, 1, rx1757_restart
    if_null rx1757_debug, debug_1310
    rx1757_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1310:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1761_done
    goto rxscan1761_scan
  rxscan1761_loop:
    (rx1757_pos) = rx1757_cur."from"()
    inc rx1757_pos
    rx1757_cur."!cursor_from"(rx1757_pos)
    ge rx1757_pos, rx1757_eos, rxscan1761_done
  rxscan1761_scan:
    set_addr $I10, rxscan1761_loop
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  rxscan1761_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1762_fail
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  # rx literal  "<"
    add $I11, rx1757_pos, 1
    gt $I11, rx1757_eos, rx1757_fail
    sub $I11, rx1757_pos, rx1757_off
    ord $I11, rx1757_tgt, $I11
    ne $I11, 60, rx1757_fail
    add rx1757_pos, 1
    set_addr $I10, rxcap_1762_fail
    ($I12, $I11) = rx1757_cur."!mark_peek"($I10)
    rx1757_cur."!cursor_pos"($I11)
    ($P10) = rx1757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1757_pos, "")
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1762_done
  rxcap_1762_fail:
    goto rx1757_fail
  rxcap_1762_done:
  # rx subrule "O" subtype=capture negate=
    rx1757_cur."!cursor_pos"(rx1757_pos)
    $P10 = rx1757_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1757_fail
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1757_pos = $P10."pos"()
  # rx pass
    rx1757_cur."!cursor_pass"(rx1757_pos, "infix:sym<<>")
    if_null rx1757_debug, debug_1311
    rx1757_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1757_pos)
  debug_1311:
    .return (rx1757_cur)
  rx1757_restart:
.annotate 'line', 10
    if_null rx1757_debug, debug_1312
    rx1757_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1312:
  rx1757_fail:
    (rx1757_rep, rx1757_pos, $I10, $P10) = rx1757_cur."!mark_fail"(0)
    lt rx1757_pos, -1, rx1757_done
    eq rx1757_pos, -1, rx1757_fail
    jump $I10
  rx1757_done:
    rx1757_cur."!cursor_fail"()
    if_null rx1757_debug, debug_1313
    rx1757_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1313:
    .return (rx1757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303857440.612") :method
.annotate 'line', 10
    $P1759 = self."!PREFIX__!subrule"("O", "<")
    new $P1760, "ResizablePMCArray"
    push $P1760, $P1759
    .return ($P1760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1764_tgt
    .local int rx1764_pos
    .local int rx1764_off
    .local int rx1764_eos
    .local int rx1764_rep
    .local pmc rx1764_cur
    .local pmc rx1764_debug
    (rx1764_cur, rx1764_pos, rx1764_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1764_cur
    .local pmc match
    .lex "$/", match
    length rx1764_eos, rx1764_tgt
    gt rx1764_pos, rx1764_eos, rx1764_done
    set rx1764_off, 0
    lt rx1764_pos, 2, rx1764_start
    sub rx1764_off, rx1764_pos, 1
    substr rx1764_tgt, rx1764_tgt, rx1764_off
  rx1764_start:
    eq $I10, 1, rx1764_restart
    if_null rx1764_debug, debug_1314
    rx1764_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1314:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1768_done
    goto rxscan1768_scan
  rxscan1768_loop:
    (rx1764_pos) = rx1764_cur."from"()
    inc rx1764_pos
    rx1764_cur."!cursor_from"(rx1764_pos)
    ge rx1764_pos, rx1764_eos, rxscan1768_done
  rxscan1768_scan:
    set_addr $I10, rxscan1768_loop
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  rxscan1768_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1769_fail
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  # rx literal  ">"
    add $I11, rx1764_pos, 1
    gt $I11, rx1764_eos, rx1764_fail
    sub $I11, rx1764_pos, rx1764_off
    ord $I11, rx1764_tgt, $I11
    ne $I11, 62, rx1764_fail
    add rx1764_pos, 1
    set_addr $I10, rxcap_1769_fail
    ($I12, $I11) = rx1764_cur."!mark_peek"($I10)
    rx1764_cur."!cursor_pos"($I11)
    ($P10) = rx1764_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1764_pos, "")
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1769_done
  rxcap_1769_fail:
    goto rx1764_fail
  rxcap_1769_done:
  # rx subrule "O" subtype=capture negate=
    rx1764_cur."!cursor_pos"(rx1764_pos)
    $P10 = rx1764_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1764_fail
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1764_pos = $P10."pos"()
  # rx pass
    rx1764_cur."!cursor_pass"(rx1764_pos, "infix:sym<>>")
    if_null rx1764_debug, debug_1315
    rx1764_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1764_pos)
  debug_1315:
    .return (rx1764_cur)
  rx1764_restart:
.annotate 'line', 10
    if_null rx1764_debug, debug_1316
    rx1764_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1316:
  rx1764_fail:
    (rx1764_rep, rx1764_pos, $I10, $P10) = rx1764_cur."!mark_fail"(0)
    lt rx1764_pos, -1, rx1764_done
    eq rx1764_pos, -1, rx1764_fail
    jump $I10
  rx1764_done:
    rx1764_cur."!cursor_fail"()
    if_null rx1764_debug, debug_1317
    rx1764_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1317:
    .return (rx1764_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303857440.612") :method
.annotate 'line', 10
    $P1766 = self."!PREFIX__!subrule"("O", ">")
    new $P1767, "ResizablePMCArray"
    push $P1767, $P1766
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1771_tgt
    .local int rx1771_pos
    .local int rx1771_off
    .local int rx1771_eos
    .local int rx1771_rep
    .local pmc rx1771_cur
    .local pmc rx1771_debug
    (rx1771_cur, rx1771_pos, rx1771_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1771_cur
    .local pmc match
    .lex "$/", match
    length rx1771_eos, rx1771_tgt
    gt rx1771_pos, rx1771_eos, rx1771_done
    set rx1771_off, 0
    lt rx1771_pos, 2, rx1771_start
    sub rx1771_off, rx1771_pos, 1
    substr rx1771_tgt, rx1771_tgt, rx1771_off
  rx1771_start:
    eq $I10, 1, rx1771_restart
    if_null rx1771_debug, debug_1318
    rx1771_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1318:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1775_done
    goto rxscan1775_scan
  rxscan1775_loop:
    (rx1771_pos) = rx1771_cur."from"()
    inc rx1771_pos
    rx1771_cur."!cursor_from"(rx1771_pos)
    ge rx1771_pos, rx1771_eos, rxscan1775_done
  rxscan1775_scan:
    set_addr $I10, rxscan1775_loop
    rx1771_cur."!mark_push"(0, rx1771_pos, $I10)
  rxscan1775_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1776_fail
    rx1771_cur."!mark_push"(0, rx1771_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1771_pos, 2
    gt $I11, rx1771_eos, rx1771_fail
    sub $I11, rx1771_pos, rx1771_off
    substr $S10, rx1771_tgt, $I11, 2
    ne $S10, "eq", rx1771_fail
    add rx1771_pos, 2
    set_addr $I10, rxcap_1776_fail
    ($I12, $I11) = rx1771_cur."!mark_peek"($I10)
    rx1771_cur."!cursor_pos"($I11)
    ($P10) = rx1771_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1771_pos, "")
    rx1771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1776_done
  rxcap_1776_fail:
    goto rx1771_fail
  rxcap_1776_done:
  # rx subrule "O" subtype=capture negate=
    rx1771_cur."!cursor_pos"(rx1771_pos)
    $P10 = rx1771_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1771_fail
    rx1771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1771_pos = $P10."pos"()
  # rx pass
    rx1771_cur."!cursor_pass"(rx1771_pos, "infix:sym<eq>")
    if_null rx1771_debug, debug_1319
    rx1771_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1771_pos)
  debug_1319:
    .return (rx1771_cur)
  rx1771_restart:
.annotate 'line', 10
    if_null rx1771_debug, debug_1320
    rx1771_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1320:
  rx1771_fail:
    (rx1771_rep, rx1771_pos, $I10, $P10) = rx1771_cur."!mark_fail"(0)
    lt rx1771_pos, -1, rx1771_done
    eq rx1771_pos, -1, rx1771_fail
    jump $I10
  rx1771_done:
    rx1771_cur."!cursor_fail"()
    if_null rx1771_debug, debug_1321
    rx1771_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1321:
    .return (rx1771_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303857440.612") :method
.annotate 'line', 10
    $P1773 = self."!PREFIX__!subrule"("O", "eq")
    new $P1774, "ResizablePMCArray"
    push $P1774, $P1773
    .return ($P1774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1778_tgt
    .local int rx1778_pos
    .local int rx1778_off
    .local int rx1778_eos
    .local int rx1778_rep
    .local pmc rx1778_cur
    .local pmc rx1778_debug
    (rx1778_cur, rx1778_pos, rx1778_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1778_cur
    .local pmc match
    .lex "$/", match
    length rx1778_eos, rx1778_tgt
    gt rx1778_pos, rx1778_eos, rx1778_done
    set rx1778_off, 0
    lt rx1778_pos, 2, rx1778_start
    sub rx1778_off, rx1778_pos, 1
    substr rx1778_tgt, rx1778_tgt, rx1778_off
  rx1778_start:
    eq $I10, 1, rx1778_restart
    if_null rx1778_debug, debug_1322
    rx1778_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1322:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1782_done
    goto rxscan1782_scan
  rxscan1782_loop:
    (rx1778_pos) = rx1778_cur."from"()
    inc rx1778_pos
    rx1778_cur."!cursor_from"(rx1778_pos)
    ge rx1778_pos, rx1778_eos, rxscan1782_done
  rxscan1782_scan:
    set_addr $I10, rxscan1782_loop
    rx1778_cur."!mark_push"(0, rx1778_pos, $I10)
  rxscan1782_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1783_fail
    rx1778_cur."!mark_push"(0, rx1778_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1778_pos, 2
    gt $I11, rx1778_eos, rx1778_fail
    sub $I11, rx1778_pos, rx1778_off
    substr $S10, rx1778_tgt, $I11, 2
    ne $S10, "ne", rx1778_fail
    add rx1778_pos, 2
    set_addr $I10, rxcap_1783_fail
    ($I12, $I11) = rx1778_cur."!mark_peek"($I10)
    rx1778_cur."!cursor_pos"($I11)
    ($P10) = rx1778_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1778_pos, "")
    rx1778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1783_done
  rxcap_1783_fail:
    goto rx1778_fail
  rxcap_1783_done:
  # rx subrule "O" subtype=capture negate=
    rx1778_cur."!cursor_pos"(rx1778_pos)
    $P10 = rx1778_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1778_fail
    rx1778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1778_pos = $P10."pos"()
  # rx pass
    rx1778_cur."!cursor_pass"(rx1778_pos, "infix:sym<ne>")
    if_null rx1778_debug, debug_1323
    rx1778_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1778_pos)
  debug_1323:
    .return (rx1778_cur)
  rx1778_restart:
.annotate 'line', 10
    if_null rx1778_debug, debug_1324
    rx1778_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1324:
  rx1778_fail:
    (rx1778_rep, rx1778_pos, $I10, $P10) = rx1778_cur."!mark_fail"(0)
    lt rx1778_pos, -1, rx1778_done
    eq rx1778_pos, -1, rx1778_fail
    jump $I10
  rx1778_done:
    rx1778_cur."!cursor_fail"()
    if_null rx1778_debug, debug_1325
    rx1778_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1325:
    .return (rx1778_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303857440.612") :method
.annotate 'line', 10
    $P1780 = self."!PREFIX__!subrule"("O", "ne")
    new $P1781, "ResizablePMCArray"
    push $P1781, $P1780
    .return ($P1781)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1785_tgt
    .local int rx1785_pos
    .local int rx1785_off
    .local int rx1785_eos
    .local int rx1785_rep
    .local pmc rx1785_cur
    .local pmc rx1785_debug
    (rx1785_cur, rx1785_pos, rx1785_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1785_cur
    .local pmc match
    .lex "$/", match
    length rx1785_eos, rx1785_tgt
    gt rx1785_pos, rx1785_eos, rx1785_done
    set rx1785_off, 0
    lt rx1785_pos, 2, rx1785_start
    sub rx1785_off, rx1785_pos, 1
    substr rx1785_tgt, rx1785_tgt, rx1785_off
  rx1785_start:
    eq $I10, 1, rx1785_restart
    if_null rx1785_debug, debug_1326
    rx1785_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1326:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1789_done
    goto rxscan1789_scan
  rxscan1789_loop:
    (rx1785_pos) = rx1785_cur."from"()
    inc rx1785_pos
    rx1785_cur."!cursor_from"(rx1785_pos)
    ge rx1785_pos, rx1785_eos, rxscan1789_done
  rxscan1789_scan:
    set_addr $I10, rxscan1789_loop
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  rxscan1789_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1790_fail
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  # rx literal  "le"
    add $I11, rx1785_pos, 2
    gt $I11, rx1785_eos, rx1785_fail
    sub $I11, rx1785_pos, rx1785_off
    substr $S10, rx1785_tgt, $I11, 2
    ne $S10, "le", rx1785_fail
    add rx1785_pos, 2
    set_addr $I10, rxcap_1790_fail
    ($I12, $I11) = rx1785_cur."!mark_peek"($I10)
    rx1785_cur."!cursor_pos"($I11)
    ($P10) = rx1785_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1785_pos, "")
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1790_done
  rxcap_1790_fail:
    goto rx1785_fail
  rxcap_1790_done:
  # rx subrule "O" subtype=capture negate=
    rx1785_cur."!cursor_pos"(rx1785_pos)
    $P10 = rx1785_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1785_fail
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1785_pos = $P10."pos"()
  # rx pass
    rx1785_cur."!cursor_pass"(rx1785_pos, "infix:sym<le>")
    if_null rx1785_debug, debug_1327
    rx1785_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1785_pos)
  debug_1327:
    .return (rx1785_cur)
  rx1785_restart:
.annotate 'line', 10
    if_null rx1785_debug, debug_1328
    rx1785_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1328:
  rx1785_fail:
    (rx1785_rep, rx1785_pos, $I10, $P10) = rx1785_cur."!mark_fail"(0)
    lt rx1785_pos, -1, rx1785_done
    eq rx1785_pos, -1, rx1785_fail
    jump $I10
  rx1785_done:
    rx1785_cur."!cursor_fail"()
    if_null rx1785_debug, debug_1329
    rx1785_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1329:
    .return (rx1785_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303857440.612") :method
.annotate 'line', 10
    $P1787 = self."!PREFIX__!subrule"("O", "le")
    new $P1788, "ResizablePMCArray"
    push $P1788, $P1787
    .return ($P1788)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1792_tgt
    .local int rx1792_pos
    .local int rx1792_off
    .local int rx1792_eos
    .local int rx1792_rep
    .local pmc rx1792_cur
    .local pmc rx1792_debug
    (rx1792_cur, rx1792_pos, rx1792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1792_cur
    .local pmc match
    .lex "$/", match
    length rx1792_eos, rx1792_tgt
    gt rx1792_pos, rx1792_eos, rx1792_done
    set rx1792_off, 0
    lt rx1792_pos, 2, rx1792_start
    sub rx1792_off, rx1792_pos, 1
    substr rx1792_tgt, rx1792_tgt, rx1792_off
  rx1792_start:
    eq $I10, 1, rx1792_restart
    if_null rx1792_debug, debug_1330
    rx1792_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1330:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1796_done
    goto rxscan1796_scan
  rxscan1796_loop:
    (rx1792_pos) = rx1792_cur."from"()
    inc rx1792_pos
    rx1792_cur."!cursor_from"(rx1792_pos)
    ge rx1792_pos, rx1792_eos, rxscan1796_done
  rxscan1796_scan:
    set_addr $I10, rxscan1796_loop
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  rxscan1796_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1797_fail
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1792_pos, 2
    gt $I11, rx1792_eos, rx1792_fail
    sub $I11, rx1792_pos, rx1792_off
    substr $S10, rx1792_tgt, $I11, 2
    ne $S10, "ge", rx1792_fail
    add rx1792_pos, 2
    set_addr $I10, rxcap_1797_fail
    ($I12, $I11) = rx1792_cur."!mark_peek"($I10)
    rx1792_cur."!cursor_pos"($I11)
    ($P10) = rx1792_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1792_pos, "")
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1797_done
  rxcap_1797_fail:
    goto rx1792_fail
  rxcap_1797_done:
  # rx subrule "O" subtype=capture negate=
    rx1792_cur."!cursor_pos"(rx1792_pos)
    $P10 = rx1792_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1792_fail
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1792_pos = $P10."pos"()
  # rx pass
    rx1792_cur."!cursor_pass"(rx1792_pos, "infix:sym<ge>")
    if_null rx1792_debug, debug_1331
    rx1792_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1792_pos)
  debug_1331:
    .return (rx1792_cur)
  rx1792_restart:
.annotate 'line', 10
    if_null rx1792_debug, debug_1332
    rx1792_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1332:
  rx1792_fail:
    (rx1792_rep, rx1792_pos, $I10, $P10) = rx1792_cur."!mark_fail"(0)
    lt rx1792_pos, -1, rx1792_done
    eq rx1792_pos, -1, rx1792_fail
    jump $I10
  rx1792_done:
    rx1792_cur."!cursor_fail"()
    if_null rx1792_debug, debug_1333
    rx1792_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1333:
    .return (rx1792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303857440.612") :method
.annotate 'line', 10
    $P1794 = self."!PREFIX__!subrule"("O", "ge")
    new $P1795, "ResizablePMCArray"
    push $P1795, $P1794
    .return ($P1795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1799_tgt
    .local int rx1799_pos
    .local int rx1799_off
    .local int rx1799_eos
    .local int rx1799_rep
    .local pmc rx1799_cur
    .local pmc rx1799_debug
    (rx1799_cur, rx1799_pos, rx1799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1799_cur
    .local pmc match
    .lex "$/", match
    length rx1799_eos, rx1799_tgt
    gt rx1799_pos, rx1799_eos, rx1799_done
    set rx1799_off, 0
    lt rx1799_pos, 2, rx1799_start
    sub rx1799_off, rx1799_pos, 1
    substr rx1799_tgt, rx1799_tgt, rx1799_off
  rx1799_start:
    eq $I10, 1, rx1799_restart
    if_null rx1799_debug, debug_1334
    rx1799_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1334:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1803_done
    goto rxscan1803_scan
  rxscan1803_loop:
    (rx1799_pos) = rx1799_cur."from"()
    inc rx1799_pos
    rx1799_cur."!cursor_from"(rx1799_pos)
    ge rx1799_pos, rx1799_eos, rxscan1803_done
  rxscan1803_scan:
    set_addr $I10, rxscan1803_loop
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  rxscan1803_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1804_fail
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1799_pos, 2
    gt $I11, rx1799_eos, rx1799_fail
    sub $I11, rx1799_pos, rx1799_off
    substr $S10, rx1799_tgt, $I11, 2
    ne $S10, "lt", rx1799_fail
    add rx1799_pos, 2
    set_addr $I10, rxcap_1804_fail
    ($I12, $I11) = rx1799_cur."!mark_peek"($I10)
    rx1799_cur."!cursor_pos"($I11)
    ($P10) = rx1799_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1799_pos, "")
    rx1799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1804_done
  rxcap_1804_fail:
    goto rx1799_fail
  rxcap_1804_done:
  # rx subrule "O" subtype=capture negate=
    rx1799_cur."!cursor_pos"(rx1799_pos)
    $P10 = rx1799_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1799_fail
    rx1799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1799_pos = $P10."pos"()
  # rx pass
    rx1799_cur."!cursor_pass"(rx1799_pos, "infix:sym<lt>")
    if_null rx1799_debug, debug_1335
    rx1799_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1799_pos)
  debug_1335:
    .return (rx1799_cur)
  rx1799_restart:
.annotate 'line', 10
    if_null rx1799_debug, debug_1336
    rx1799_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1336:
  rx1799_fail:
    (rx1799_rep, rx1799_pos, $I10, $P10) = rx1799_cur."!mark_fail"(0)
    lt rx1799_pos, -1, rx1799_done
    eq rx1799_pos, -1, rx1799_fail
    jump $I10
  rx1799_done:
    rx1799_cur."!cursor_fail"()
    if_null rx1799_debug, debug_1337
    rx1799_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1337:
    .return (rx1799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303857440.612") :method
.annotate 'line', 10
    $P1801 = self."!PREFIX__!subrule"("O", "lt")
    new $P1802, "ResizablePMCArray"
    push $P1802, $P1801
    .return ($P1802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1806_tgt
    .local int rx1806_pos
    .local int rx1806_off
    .local int rx1806_eos
    .local int rx1806_rep
    .local pmc rx1806_cur
    .local pmc rx1806_debug
    (rx1806_cur, rx1806_pos, rx1806_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1806_cur
    .local pmc match
    .lex "$/", match
    length rx1806_eos, rx1806_tgt
    gt rx1806_pos, rx1806_eos, rx1806_done
    set rx1806_off, 0
    lt rx1806_pos, 2, rx1806_start
    sub rx1806_off, rx1806_pos, 1
    substr rx1806_tgt, rx1806_tgt, rx1806_off
  rx1806_start:
    eq $I10, 1, rx1806_restart
    if_null rx1806_debug, debug_1338
    rx1806_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1338:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1810_done
    goto rxscan1810_scan
  rxscan1810_loop:
    (rx1806_pos) = rx1806_cur."from"()
    inc rx1806_pos
    rx1806_cur."!cursor_from"(rx1806_pos)
    ge rx1806_pos, rx1806_eos, rxscan1810_done
  rxscan1810_scan:
    set_addr $I10, rxscan1810_loop
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  rxscan1810_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1811_fail
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1806_pos, 2
    gt $I11, rx1806_eos, rx1806_fail
    sub $I11, rx1806_pos, rx1806_off
    substr $S10, rx1806_tgt, $I11, 2
    ne $S10, "gt", rx1806_fail
    add rx1806_pos, 2
    set_addr $I10, rxcap_1811_fail
    ($I12, $I11) = rx1806_cur."!mark_peek"($I10)
    rx1806_cur."!cursor_pos"($I11)
    ($P10) = rx1806_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1806_pos, "")
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1811_done
  rxcap_1811_fail:
    goto rx1806_fail
  rxcap_1811_done:
  # rx subrule "O" subtype=capture negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1806_fail
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1806_pos = $P10."pos"()
  # rx pass
    rx1806_cur."!cursor_pass"(rx1806_pos, "infix:sym<gt>")
    if_null rx1806_debug, debug_1339
    rx1806_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1806_pos)
  debug_1339:
    .return (rx1806_cur)
  rx1806_restart:
.annotate 'line', 10
    if_null rx1806_debug, debug_1340
    rx1806_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1340:
  rx1806_fail:
    (rx1806_rep, rx1806_pos, $I10, $P10) = rx1806_cur."!mark_fail"(0)
    lt rx1806_pos, -1, rx1806_done
    eq rx1806_pos, -1, rx1806_fail
    jump $I10
  rx1806_done:
    rx1806_cur."!cursor_fail"()
    if_null rx1806_debug, debug_1341
    rx1806_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1341:
    .return (rx1806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303857440.612") :method
.annotate 'line', 10
    $P1808 = self."!PREFIX__!subrule"("O", "gt")
    new $P1809, "ResizablePMCArray"
    push $P1809, $P1808
    .return ($P1809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1813_tgt
    .local int rx1813_pos
    .local int rx1813_off
    .local int rx1813_eos
    .local int rx1813_rep
    .local pmc rx1813_cur
    .local pmc rx1813_debug
    (rx1813_cur, rx1813_pos, rx1813_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1813_cur
    .local pmc match
    .lex "$/", match
    length rx1813_eos, rx1813_tgt
    gt rx1813_pos, rx1813_eos, rx1813_done
    set rx1813_off, 0
    lt rx1813_pos, 2, rx1813_start
    sub rx1813_off, rx1813_pos, 1
    substr rx1813_tgt, rx1813_tgt, rx1813_off
  rx1813_start:
    eq $I10, 1, rx1813_restart
    if_null rx1813_debug, debug_1342
    rx1813_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1342:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1817_done
    goto rxscan1817_scan
  rxscan1817_loop:
    (rx1813_pos) = rx1813_cur."from"()
    inc rx1813_pos
    rx1813_cur."!cursor_from"(rx1813_pos)
    ge rx1813_pos, rx1813_eos, rxscan1817_done
  rxscan1817_scan:
    set_addr $I10, rxscan1817_loop
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  rxscan1817_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1818_fail
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1813_pos, 3
    gt $I11, rx1813_eos, rx1813_fail
    sub $I11, rx1813_pos, rx1813_off
    substr $S10, rx1813_tgt, $I11, 3
    ne $S10, "=:=", rx1813_fail
    add rx1813_pos, 3
    set_addr $I10, rxcap_1818_fail
    ($I12, $I11) = rx1813_cur."!mark_peek"($I10)
    rx1813_cur."!cursor_pos"($I11)
    ($P10) = rx1813_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1813_pos, "")
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1818_done
  rxcap_1818_fail:
    goto rx1813_fail
  rxcap_1818_done:
  # rx subrule "O" subtype=capture negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1813_fail
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1813_pos = $P10."pos"()
  # rx pass
    rx1813_cur."!cursor_pass"(rx1813_pos, "infix:sym<=:=>")
    if_null rx1813_debug, debug_1343
    rx1813_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1813_pos)
  debug_1343:
    .return (rx1813_cur)
  rx1813_restart:
.annotate 'line', 10
    if_null rx1813_debug, debug_1344
    rx1813_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1344:
  rx1813_fail:
    (rx1813_rep, rx1813_pos, $I10, $P10) = rx1813_cur."!mark_fail"(0)
    lt rx1813_pos, -1, rx1813_done
    eq rx1813_pos, -1, rx1813_fail
    jump $I10
  rx1813_done:
    rx1813_cur."!cursor_fail"()
    if_null rx1813_debug, debug_1345
    rx1813_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1345:
    .return (rx1813_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303857440.612") :method
.annotate 'line', 10
    $P1815 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1816, "ResizablePMCArray"
    push $P1816, $P1815
    .return ($P1816)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1820_tgt
    .local int rx1820_pos
    .local int rx1820_off
    .local int rx1820_eos
    .local int rx1820_rep
    .local pmc rx1820_cur
    .local pmc rx1820_debug
    (rx1820_cur, rx1820_pos, rx1820_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1820_cur
    .local pmc match
    .lex "$/", match
    length rx1820_eos, rx1820_tgt
    gt rx1820_pos, rx1820_eos, rx1820_done
    set rx1820_off, 0
    lt rx1820_pos, 2, rx1820_start
    sub rx1820_off, rx1820_pos, 1
    substr rx1820_tgt, rx1820_tgt, rx1820_off
  rx1820_start:
    eq $I10, 1, rx1820_restart
    if_null rx1820_debug, debug_1346
    rx1820_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1346:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1824_done
    goto rxscan1824_scan
  rxscan1824_loop:
    (rx1820_pos) = rx1820_cur."from"()
    inc rx1820_pos
    rx1820_cur."!cursor_from"(rx1820_pos)
    ge rx1820_pos, rx1820_eos, rxscan1824_done
  rxscan1824_scan:
    set_addr $I10, rxscan1824_loop
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  rxscan1824_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1825_fail
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1820_pos, 2
    gt $I11, rx1820_eos, rx1820_fail
    sub $I11, rx1820_pos, rx1820_off
    substr $S10, rx1820_tgt, $I11, 2
    ne $S10, "~~", rx1820_fail
    add rx1820_pos, 2
    set_addr $I10, rxcap_1825_fail
    ($I12, $I11) = rx1820_cur."!mark_peek"($I10)
    rx1820_cur."!cursor_pos"($I11)
    ($P10) = rx1820_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1820_pos, "")
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1825_done
  rxcap_1825_fail:
    goto rx1820_fail
  rxcap_1825_done:
  # rx subrule "O" subtype=capture negate=
    rx1820_cur."!cursor_pos"(rx1820_pos)
    $P10 = rx1820_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1820_fail
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1820_pos = $P10."pos"()
  # rx pass
    rx1820_cur."!cursor_pass"(rx1820_pos, "infix:sym<~~>")
    if_null rx1820_debug, debug_1347
    rx1820_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1820_pos)
  debug_1347:
    .return (rx1820_cur)
  rx1820_restart:
.annotate 'line', 10
    if_null rx1820_debug, debug_1348
    rx1820_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1348:
  rx1820_fail:
    (rx1820_rep, rx1820_pos, $I10, $P10) = rx1820_cur."!mark_fail"(0)
    lt rx1820_pos, -1, rx1820_done
    eq rx1820_pos, -1, rx1820_fail
    jump $I10
  rx1820_done:
    rx1820_cur."!cursor_fail"()
    if_null rx1820_debug, debug_1349
    rx1820_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1349:
    .return (rx1820_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303857440.612") :method
.annotate 'line', 10
    $P1822 = self."!PREFIX__!subrule"("O", "~~")
    new $P1823, "ResizablePMCArray"
    push $P1823, $P1822
    .return ($P1823)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1827_tgt
    .local int rx1827_pos
    .local int rx1827_off
    .local int rx1827_eos
    .local int rx1827_rep
    .local pmc rx1827_cur
    .local pmc rx1827_debug
    (rx1827_cur, rx1827_pos, rx1827_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1827_cur
    .local pmc match
    .lex "$/", match
    length rx1827_eos, rx1827_tgt
    gt rx1827_pos, rx1827_eos, rx1827_done
    set rx1827_off, 0
    lt rx1827_pos, 2, rx1827_start
    sub rx1827_off, rx1827_pos, 1
    substr rx1827_tgt, rx1827_tgt, rx1827_off
  rx1827_start:
    eq $I10, 1, rx1827_restart
    if_null rx1827_debug, debug_1350
    rx1827_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1350:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1831_done
    goto rxscan1831_scan
  rxscan1831_loop:
    (rx1827_pos) = rx1827_cur."from"()
    inc rx1827_pos
    rx1827_cur."!cursor_from"(rx1827_pos)
    ge rx1827_pos, rx1827_eos, rxscan1831_done
  rxscan1831_scan:
    set_addr $I10, rxscan1831_loop
    rx1827_cur."!mark_push"(0, rx1827_pos, $I10)
  rxscan1831_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1832_fail
    rx1827_cur."!mark_push"(0, rx1827_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1827_pos, 2
    gt $I11, rx1827_eos, rx1827_fail
    sub $I11, rx1827_pos, rx1827_off
    substr $S10, rx1827_tgt, $I11, 2
    ne $S10, "&&", rx1827_fail
    add rx1827_pos, 2
    set_addr $I10, rxcap_1832_fail
    ($I12, $I11) = rx1827_cur."!mark_peek"($I10)
    rx1827_cur."!cursor_pos"($I11)
    ($P10) = rx1827_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1827_pos, "")
    rx1827_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1832_done
  rxcap_1832_fail:
    goto rx1827_fail
  rxcap_1832_done:
  # rx subrule "O" subtype=capture negate=
    rx1827_cur."!cursor_pos"(rx1827_pos)
    $P10 = rx1827_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1827_fail
    rx1827_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1827_pos = $P10."pos"()
  # rx pass
    rx1827_cur."!cursor_pass"(rx1827_pos, "infix:sym<&&>")
    if_null rx1827_debug, debug_1351
    rx1827_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1827_pos)
  debug_1351:
    .return (rx1827_cur)
  rx1827_restart:
.annotate 'line', 10
    if_null rx1827_debug, debug_1352
    rx1827_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1352:
  rx1827_fail:
    (rx1827_rep, rx1827_pos, $I10, $P10) = rx1827_cur."!mark_fail"(0)
    lt rx1827_pos, -1, rx1827_done
    eq rx1827_pos, -1, rx1827_fail
    jump $I10
  rx1827_done:
    rx1827_cur."!cursor_fail"()
    if_null rx1827_debug, debug_1353
    rx1827_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1353:
    .return (rx1827_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303857440.612") :method
.annotate 'line', 10
    $P1829 = self."!PREFIX__!subrule"("O", "&&")
    new $P1830, "ResizablePMCArray"
    push $P1830, $P1829
    .return ($P1830)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1834_tgt
    .local int rx1834_pos
    .local int rx1834_off
    .local int rx1834_eos
    .local int rx1834_rep
    .local pmc rx1834_cur
    .local pmc rx1834_debug
    (rx1834_cur, rx1834_pos, rx1834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1834_cur
    .local pmc match
    .lex "$/", match
    length rx1834_eos, rx1834_tgt
    gt rx1834_pos, rx1834_eos, rx1834_done
    set rx1834_off, 0
    lt rx1834_pos, 2, rx1834_start
    sub rx1834_off, rx1834_pos, 1
    substr rx1834_tgt, rx1834_tgt, rx1834_off
  rx1834_start:
    eq $I10, 1, rx1834_restart
    if_null rx1834_debug, debug_1354
    rx1834_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1354:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1838_done
    goto rxscan1838_scan
  rxscan1838_loop:
    (rx1834_pos) = rx1834_cur."from"()
    inc rx1834_pos
    rx1834_cur."!cursor_from"(rx1834_pos)
    ge rx1834_pos, rx1834_eos, rxscan1838_done
  rxscan1838_scan:
    set_addr $I10, rxscan1838_loop
    rx1834_cur."!mark_push"(0, rx1834_pos, $I10)
  rxscan1838_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1839_fail
    rx1834_cur."!mark_push"(0, rx1834_pos, $I10)
  # rx literal  "||"
    add $I11, rx1834_pos, 2
    gt $I11, rx1834_eos, rx1834_fail
    sub $I11, rx1834_pos, rx1834_off
    substr $S10, rx1834_tgt, $I11, 2
    ne $S10, "||", rx1834_fail
    add rx1834_pos, 2
    set_addr $I10, rxcap_1839_fail
    ($I12, $I11) = rx1834_cur."!mark_peek"($I10)
    rx1834_cur."!cursor_pos"($I11)
    ($P10) = rx1834_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1834_pos, "")
    rx1834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1839_done
  rxcap_1839_fail:
    goto rx1834_fail
  rxcap_1839_done:
  # rx subrule "O" subtype=capture negate=
    rx1834_cur."!cursor_pos"(rx1834_pos)
    $P10 = rx1834_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1834_fail
    rx1834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1834_pos = $P10."pos"()
  # rx pass
    rx1834_cur."!cursor_pass"(rx1834_pos, "infix:sym<||>")
    if_null rx1834_debug, debug_1355
    rx1834_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1834_pos)
  debug_1355:
    .return (rx1834_cur)
  rx1834_restart:
.annotate 'line', 10
    if_null rx1834_debug, debug_1356
    rx1834_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1356:
  rx1834_fail:
    (rx1834_rep, rx1834_pos, $I10, $P10) = rx1834_cur."!mark_fail"(0)
    lt rx1834_pos, -1, rx1834_done
    eq rx1834_pos, -1, rx1834_fail
    jump $I10
  rx1834_done:
    rx1834_cur."!cursor_fail"()
    if_null rx1834_debug, debug_1357
    rx1834_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1357:
    .return (rx1834_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303857440.612") :method
.annotate 'line', 10
    $P1836 = self."!PREFIX__!subrule"("O", "||")
    new $P1837, "ResizablePMCArray"
    push $P1837, $P1836
    .return ($P1837)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1841_tgt
    .local int rx1841_pos
    .local int rx1841_off
    .local int rx1841_eos
    .local int rx1841_rep
    .local pmc rx1841_cur
    .local pmc rx1841_debug
    (rx1841_cur, rx1841_pos, rx1841_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1841_cur
    .local pmc match
    .lex "$/", match
    length rx1841_eos, rx1841_tgt
    gt rx1841_pos, rx1841_eos, rx1841_done
    set rx1841_off, 0
    lt rx1841_pos, 2, rx1841_start
    sub rx1841_off, rx1841_pos, 1
    substr rx1841_tgt, rx1841_tgt, rx1841_off
  rx1841_start:
    eq $I10, 1, rx1841_restart
    if_null rx1841_debug, debug_1358
    rx1841_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1358:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1845_done
    goto rxscan1845_scan
  rxscan1845_loop:
    (rx1841_pos) = rx1841_cur."from"()
    inc rx1841_pos
    rx1841_cur."!cursor_from"(rx1841_pos)
    ge rx1841_pos, rx1841_eos, rxscan1845_done
  rxscan1845_scan:
    set_addr $I10, rxscan1845_loop
    rx1841_cur."!mark_push"(0, rx1841_pos, $I10)
  rxscan1845_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1846_fail
    rx1841_cur."!mark_push"(0, rx1841_pos, $I10)
  # rx literal  "//"
    add $I11, rx1841_pos, 2
    gt $I11, rx1841_eos, rx1841_fail
    sub $I11, rx1841_pos, rx1841_off
    substr $S10, rx1841_tgt, $I11, 2
    ne $S10, "//", rx1841_fail
    add rx1841_pos, 2
    set_addr $I10, rxcap_1846_fail
    ($I12, $I11) = rx1841_cur."!mark_peek"($I10)
    rx1841_cur."!cursor_pos"($I11)
    ($P10) = rx1841_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1841_pos, "")
    rx1841_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1846_done
  rxcap_1846_fail:
    goto rx1841_fail
  rxcap_1846_done:
  # rx subrule "O" subtype=capture negate=
    rx1841_cur."!cursor_pos"(rx1841_pos)
    $P10 = rx1841_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1841_fail
    rx1841_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1841_pos = $P10."pos"()
  # rx pass
    rx1841_cur."!cursor_pass"(rx1841_pos, "infix:sym<//>")
    if_null rx1841_debug, debug_1359
    rx1841_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1841_pos)
  debug_1359:
    .return (rx1841_cur)
  rx1841_restart:
.annotate 'line', 10
    if_null rx1841_debug, debug_1360
    rx1841_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1360:
  rx1841_fail:
    (rx1841_rep, rx1841_pos, $I10, $P10) = rx1841_cur."!mark_fail"(0)
    lt rx1841_pos, -1, rx1841_done
    eq rx1841_pos, -1, rx1841_fail
    jump $I10
  rx1841_done:
    rx1841_cur."!cursor_fail"()
    if_null rx1841_debug, debug_1361
    rx1841_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1361:
    .return (rx1841_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303857440.612") :method
.annotate 'line', 10
    $P1843 = self."!PREFIX__!subrule"("O", "//")
    new $P1844, "ResizablePMCArray"
    push $P1844, $P1843
    .return ($P1844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1848_tgt
    .local int rx1848_pos
    .local int rx1848_off
    .local int rx1848_eos
    .local int rx1848_rep
    .local pmc rx1848_cur
    .local pmc rx1848_debug
    (rx1848_cur, rx1848_pos, rx1848_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1848_cur
    .local pmc match
    .lex "$/", match
    length rx1848_eos, rx1848_tgt
    gt rx1848_pos, rx1848_eos, rx1848_done
    set rx1848_off, 0
    lt rx1848_pos, 2, rx1848_start
    sub rx1848_off, rx1848_pos, 1
    substr rx1848_tgt, rx1848_tgt, rx1848_off
  rx1848_start:
    eq $I10, 1, rx1848_restart
    if_null rx1848_debug, debug_1362
    rx1848_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1362:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1852_done
    goto rxscan1852_scan
  rxscan1852_loop:
    (rx1848_pos) = rx1848_cur."from"()
    inc rx1848_pos
    rx1848_cur."!cursor_from"(rx1848_pos)
    ge rx1848_pos, rx1848_eos, rxscan1852_done
  rxscan1852_scan:
    set_addr $I10, rxscan1852_loop
    rx1848_cur."!mark_push"(0, rx1848_pos, $I10)
  rxscan1852_done:
.annotate 'line', 697
  # rx literal  "??"
    add $I11, rx1848_pos, 2
    gt $I11, rx1848_eos, rx1848_fail
    sub $I11, rx1848_pos, rx1848_off
    substr $S10, rx1848_tgt, $I11, 2
    ne $S10, "??", rx1848_fail
    add rx1848_pos, 2
.annotate 'line', 698
  # rx subrule "ws" subtype=method negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."ws"()
    unless $P10, rx1848_fail
    rx1848_pos = $P10."pos"()
.annotate 'line', 699
  # rx subrule "EXPR" subtype=capture negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."EXPR"("i=")
    unless $P10, rx1848_fail
    rx1848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1848_pos = $P10."pos"()
.annotate 'line', 700
  # rx literal  "!!"
    add $I11, rx1848_pos, 2
    gt $I11, rx1848_eos, rx1848_fail
    sub $I11, rx1848_pos, rx1848_off
    substr $S10, rx1848_tgt, $I11, 2
    ne $S10, "!!", rx1848_fail
    add rx1848_pos, 2
.annotate 'line', 701
  # rx subrule "O" subtype=capture negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1848_fail
    rx1848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1848_pos = $P10."pos"()
.annotate 'line', 696
  # rx pass
    rx1848_cur."!cursor_pass"(rx1848_pos, "infix:sym<?? !!>")
    if_null rx1848_debug, debug_1363
    rx1848_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1848_pos)
  debug_1363:
    .return (rx1848_cur)
  rx1848_restart:
.annotate 'line', 10
    if_null rx1848_debug, debug_1364
    rx1848_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1364:
  rx1848_fail:
    (rx1848_rep, rx1848_pos, $I10, $P10) = rx1848_cur."!mark_fail"(0)
    lt rx1848_pos, -1, rx1848_done
    eq rx1848_pos, -1, rx1848_fail
    jump $I10
  rx1848_done:
    rx1848_cur."!cursor_fail"()
    if_null rx1848_debug, debug_1365
    rx1848_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1365:
    .return (rx1848_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303857440.612") :method
.annotate 'line', 10
    $P1850 = self."!PREFIX__!subrule"("ws", "??")
    new $P1851, "ResizablePMCArray"
    push $P1851, $P1850
    .return ($P1851)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1854_tgt
    .local int rx1854_pos
    .local int rx1854_off
    .local int rx1854_eos
    .local int rx1854_rep
    .local pmc rx1854_cur
    .local pmc rx1854_debug
    (rx1854_cur, rx1854_pos, rx1854_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1854_cur
    .local pmc match
    .lex "$/", match
    length rx1854_eos, rx1854_tgt
    gt rx1854_pos, rx1854_eos, rx1854_done
    set rx1854_off, 0
    lt rx1854_pos, 2, rx1854_start
    sub rx1854_off, rx1854_pos, 1
    substr rx1854_tgt, rx1854_tgt, rx1854_off
  rx1854_start:
    eq $I10, 1, rx1854_restart
    if_null rx1854_debug, debug_1366
    rx1854_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1366:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1858_done
    goto rxscan1858_scan
  rxscan1858_loop:
    (rx1854_pos) = rx1854_cur."from"()
    inc rx1854_pos
    rx1854_cur."!cursor_from"(rx1854_pos)
    ge rx1854_pos, rx1854_eos, rxscan1858_done
  rxscan1858_scan:
    set_addr $I10, rxscan1858_loop
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  rxscan1858_done:
.annotate 'line', 705
  # rx subcapture "sym"
    set_addr $I10, rxcap_1859_fail
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  # rx literal  "="
    add $I11, rx1854_pos, 1
    gt $I11, rx1854_eos, rx1854_fail
    sub $I11, rx1854_pos, rx1854_off
    ord $I11, rx1854_tgt, $I11
    ne $I11, 61, rx1854_fail
    add rx1854_pos, 1
    set_addr $I10, rxcap_1859_fail
    ($I12, $I11) = rx1854_cur."!mark_peek"($I10)
    rx1854_cur."!cursor_pos"($I11)
    ($P10) = rx1854_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1854_pos, "")
    rx1854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1859_done
  rxcap_1859_fail:
    goto rx1854_fail
  rxcap_1859_done:
  # rx subrule "panic" subtype=method negate=
    rx1854_cur."!cursor_pos"(rx1854_pos)
    $P10 = rx1854_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1854_fail
    rx1854_pos = $P10."pos"()
.annotate 'line', 704
  # rx pass
    rx1854_cur."!cursor_pass"(rx1854_pos, "infix:sym<=>")
    if_null rx1854_debug, debug_1367
    rx1854_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1854_pos)
  debug_1367:
    .return (rx1854_cur)
  rx1854_restart:
.annotate 'line', 10
    if_null rx1854_debug, debug_1368
    rx1854_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1368:
  rx1854_fail:
    (rx1854_rep, rx1854_pos, $I10, $P10) = rx1854_cur."!mark_fail"(0)
    lt rx1854_pos, -1, rx1854_done
    eq rx1854_pos, -1, rx1854_fail
    jump $I10
  rx1854_done:
    rx1854_cur."!cursor_fail"()
    if_null rx1854_debug, debug_1369
    rx1854_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1369:
    .return (rx1854_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303857440.612") :method
.annotate 'line', 10
    $P1856 = self."!PREFIX__!subrule"("panic", "=")
    new $P1857, "ResizablePMCArray"
    push $P1857, $P1856
    .return ($P1857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1861_tgt
    .local int rx1861_pos
    .local int rx1861_off
    .local int rx1861_eos
    .local int rx1861_rep
    .local pmc rx1861_cur
    .local pmc rx1861_debug
    (rx1861_cur, rx1861_pos, rx1861_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1861_cur
    .local pmc match
    .lex "$/", match
    length rx1861_eos, rx1861_tgt
    gt rx1861_pos, rx1861_eos, rx1861_done
    set rx1861_off, 0
    lt rx1861_pos, 2, rx1861_start
    sub rx1861_off, rx1861_pos, 1
    substr rx1861_tgt, rx1861_tgt, rx1861_off
  rx1861_start:
    eq $I10, 1, rx1861_restart
    if_null rx1861_debug, debug_1370
    rx1861_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1370:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1865_done
    goto rxscan1865_scan
  rxscan1865_loop:
    (rx1861_pos) = rx1861_cur."from"()
    inc rx1861_pos
    rx1861_cur."!cursor_from"(rx1861_pos)
    ge rx1861_pos, rx1861_eos, rxscan1865_done
  rxscan1865_scan:
    set_addr $I10, rxscan1865_loop
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  rxscan1865_done:
.annotate 'line', 707
  # rx subcapture "sym"
    set_addr $I10, rxcap_1866_fail
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  # rx literal  ":="
    add $I11, rx1861_pos, 2
    gt $I11, rx1861_eos, rx1861_fail
    sub $I11, rx1861_pos, rx1861_off
    substr $S10, rx1861_tgt, $I11, 2
    ne $S10, ":=", rx1861_fail
    add rx1861_pos, 2
    set_addr $I10, rxcap_1866_fail
    ($I12, $I11) = rx1861_cur."!mark_peek"($I10)
    rx1861_cur."!cursor_pos"($I11)
    ($P10) = rx1861_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1861_pos, "")
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1866_done
  rxcap_1866_fail:
    goto rx1861_fail
  rxcap_1866_done:
  # rx subrule "O" subtype=capture negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1861_fail
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1861_pos = $P10."pos"()
  # rx pass
    rx1861_cur."!cursor_pass"(rx1861_pos, "infix:sym<:=>")
    if_null rx1861_debug, debug_1371
    rx1861_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1861_pos)
  debug_1371:
    .return (rx1861_cur)
  rx1861_restart:
.annotate 'line', 10
    if_null rx1861_debug, debug_1372
    rx1861_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1372:
  rx1861_fail:
    (rx1861_rep, rx1861_pos, $I10, $P10) = rx1861_cur."!mark_fail"(0)
    lt rx1861_pos, -1, rx1861_done
    eq rx1861_pos, -1, rx1861_fail
    jump $I10
  rx1861_done:
    rx1861_cur."!cursor_fail"()
    if_null rx1861_debug, debug_1373
    rx1861_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1373:
    .return (rx1861_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303857440.612") :method
.annotate 'line', 10
    $P1863 = self."!PREFIX__!subrule"("O", ":=")
    new $P1864, "ResizablePMCArray"
    push $P1864, $P1863
    .return ($P1864)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1868_tgt
    .local int rx1868_pos
    .local int rx1868_off
    .local int rx1868_eos
    .local int rx1868_rep
    .local pmc rx1868_cur
    .local pmc rx1868_debug
    (rx1868_cur, rx1868_pos, rx1868_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1868_cur
    .local pmc match
    .lex "$/", match
    length rx1868_eos, rx1868_tgt
    gt rx1868_pos, rx1868_eos, rx1868_done
    set rx1868_off, 0
    lt rx1868_pos, 2, rx1868_start
    sub rx1868_off, rx1868_pos, 1
    substr rx1868_tgt, rx1868_tgt, rx1868_off
  rx1868_start:
    eq $I10, 1, rx1868_restart
    if_null rx1868_debug, debug_1374
    rx1868_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1374:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1872_done
    goto rxscan1872_scan
  rxscan1872_loop:
    (rx1868_pos) = rx1868_cur."from"()
    inc rx1868_pos
    rx1868_cur."!cursor_from"(rx1868_pos)
    ge rx1868_pos, rx1868_eos, rxscan1872_done
  rxscan1872_scan:
    set_addr $I10, rxscan1872_loop
    rx1868_cur."!mark_push"(0, rx1868_pos, $I10)
  rxscan1872_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1873_fail
    rx1868_cur."!mark_push"(0, rx1868_pos, $I10)
  # rx literal  "::="
    add $I11, rx1868_pos, 3
    gt $I11, rx1868_eos, rx1868_fail
    sub $I11, rx1868_pos, rx1868_off
    substr $S10, rx1868_tgt, $I11, 3
    ne $S10, "::=", rx1868_fail
    add rx1868_pos, 3
    set_addr $I10, rxcap_1873_fail
    ($I12, $I11) = rx1868_cur."!mark_peek"($I10)
    rx1868_cur."!cursor_pos"($I11)
    ($P10) = rx1868_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1868_pos, "")
    rx1868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1873_done
  rxcap_1873_fail:
    goto rx1868_fail
  rxcap_1873_done:
  # rx subrule "O" subtype=capture negate=
    rx1868_cur."!cursor_pos"(rx1868_pos)
    $P10 = rx1868_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1868_fail
    rx1868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1868_pos = $P10."pos"()
  # rx pass
    rx1868_cur."!cursor_pass"(rx1868_pos, "infix:sym<::=>")
    if_null rx1868_debug, debug_1375
    rx1868_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1868_pos)
  debug_1375:
    .return (rx1868_cur)
  rx1868_restart:
.annotate 'line', 10
    if_null rx1868_debug, debug_1376
    rx1868_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1376:
  rx1868_fail:
    (rx1868_rep, rx1868_pos, $I10, $P10) = rx1868_cur."!mark_fail"(0)
    lt rx1868_pos, -1, rx1868_done
    eq rx1868_pos, -1, rx1868_fail
    jump $I10
  rx1868_done:
    rx1868_cur."!cursor_fail"()
    if_null rx1868_debug, debug_1377
    rx1868_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1377:
    .return (rx1868_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303857440.612") :method
.annotate 'line', 10
    $P1870 = self."!PREFIX__!subrule"("O", "::=")
    new $P1871, "ResizablePMCArray"
    push $P1871, $P1870
    .return ($P1871)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1875_tgt
    .local int rx1875_pos
    .local int rx1875_off
    .local int rx1875_eos
    .local int rx1875_rep
    .local pmc rx1875_cur
    .local pmc rx1875_debug
    (rx1875_cur, rx1875_pos, rx1875_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1875_cur
    .local pmc match
    .lex "$/", match
    length rx1875_eos, rx1875_tgt
    gt rx1875_pos, rx1875_eos, rx1875_done
    set rx1875_off, 0
    lt rx1875_pos, 2, rx1875_start
    sub rx1875_off, rx1875_pos, 1
    substr rx1875_tgt, rx1875_tgt, rx1875_off
  rx1875_start:
    eq $I10, 1, rx1875_restart
    if_null rx1875_debug, debug_1378
    rx1875_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1378:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1879_done
    goto rxscan1879_scan
  rxscan1879_loop:
    (rx1875_pos) = rx1875_cur."from"()
    inc rx1875_pos
    rx1875_cur."!cursor_from"(rx1875_pos)
    ge rx1875_pos, rx1875_eos, rxscan1879_done
  rxscan1879_scan:
    set_addr $I10, rxscan1879_loop
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  rxscan1879_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1880_fail
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  # rx literal  ","
    add $I11, rx1875_pos, 1
    gt $I11, rx1875_eos, rx1875_fail
    sub $I11, rx1875_pos, rx1875_off
    ord $I11, rx1875_tgt, $I11
    ne $I11, 44, rx1875_fail
    add rx1875_pos, 1
    set_addr $I10, rxcap_1880_fail
    ($I12, $I11) = rx1875_cur."!mark_peek"($I10)
    rx1875_cur."!cursor_pos"($I11)
    ($P10) = rx1875_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1875_pos, "")
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1880_done
  rxcap_1880_fail:
    goto rx1875_fail
  rxcap_1880_done:
  # rx subrule "O" subtype=capture negate=
    rx1875_cur."!cursor_pos"(rx1875_pos)
    $P10 = rx1875_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1875_fail
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1875_pos = $P10."pos"()
  # rx pass
    rx1875_cur."!cursor_pass"(rx1875_pos, "infix:sym<,>")
    if_null rx1875_debug, debug_1379
    rx1875_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1875_pos)
  debug_1379:
    .return (rx1875_cur)
  rx1875_restart:
.annotate 'line', 10
    if_null rx1875_debug, debug_1380
    rx1875_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1380:
  rx1875_fail:
    (rx1875_rep, rx1875_pos, $I10, $P10) = rx1875_cur."!mark_fail"(0)
    lt rx1875_pos, -1, rx1875_done
    eq rx1875_pos, -1, rx1875_fail
    jump $I10
  rx1875_done:
    rx1875_cur."!cursor_fail"()
    if_null rx1875_debug, debug_1381
    rx1875_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1381:
    .return (rx1875_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303857440.612") :method
.annotate 'line', 10
    $P1877 = self."!PREFIX__!subrule"("O", ",")
    new $P1878, "ResizablePMCArray"
    push $P1878, $P1877
    .return ($P1878)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .const 'Sub' $P1890 = "373_1303857440.612" 
    capture_lex $P1890
    .local string rx1882_tgt
    .local int rx1882_pos
    .local int rx1882_off
    .local int rx1882_eos
    .local int rx1882_rep
    .local pmc rx1882_cur
    .local pmc rx1882_debug
    (rx1882_cur, rx1882_pos, rx1882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1882_cur
    .local pmc match
    .lex "$/", match
    length rx1882_eos, rx1882_tgt
    gt rx1882_pos, rx1882_eos, rx1882_done
    set rx1882_off, 0
    lt rx1882_pos, 2, rx1882_start
    sub rx1882_off, rx1882_pos, 1
    substr rx1882_tgt, rx1882_tgt, rx1882_off
  rx1882_start:
    eq $I10, 1, rx1882_restart
    if_null rx1882_debug, debug_1382
    rx1882_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1382:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1885_done
    goto rxscan1885_scan
  rxscan1885_loop:
    (rx1882_pos) = rx1882_cur."from"()
    inc rx1882_pos
    rx1882_cur."!cursor_from"(rx1882_pos)
    ge rx1882_pos, rx1882_eos, rxscan1885_done
  rxscan1885_scan:
    set_addr $I10, rxscan1885_loop
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  rxscan1885_done:
.annotate 'line', 712
  # rx subcapture "sym"
    set_addr $I10, rxcap_1886_fail
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  # rx literal  "return"
    add $I11, rx1882_pos, 6
    gt $I11, rx1882_eos, rx1882_fail
    sub $I11, rx1882_pos, rx1882_off
    substr $S10, rx1882_tgt, $I11, 6
    ne $S10, "return", rx1882_fail
    add rx1882_pos, 6
    set_addr $I10, rxcap_1886_fail
    ($I12, $I11) = rx1882_cur."!mark_peek"($I10)
    rx1882_cur."!cursor_pos"($I11)
    ($P10) = rx1882_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1882_pos, "")
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1886_done
  rxcap_1886_fail:
    goto rx1882_fail
  rxcap_1886_done:
  # rx charclass s
    ge rx1882_pos, rx1882_eos, rx1882_fail
    sub $I10, rx1882_pos, rx1882_off
    is_cclass $I11, 32, rx1882_tgt, $I10
    unless $I11, rx1882_fail
    inc rx1882_pos
  # rx subrule "O" subtype=capture negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1882_fail
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1882_pos = $P10."pos"()
    rx1882_cur."!cursor_pos"(rx1882_pos)
    find_lex $P1887, unicode:"$\x{a2}"
    $P1888 = $P1887."MATCH"()
    store_lex "$/", $P1888
    .const 'Sub' $P1890 = "373_1303857440.612" 
    capture_lex $P1890
    $P1892 = $P1890()
  # rx pass
    rx1882_cur."!cursor_pass"(rx1882_pos, "prefix:sym<return>")
    if_null rx1882_debug, debug_1383
    rx1882_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1882_pos)
  debug_1383:
    .return (rx1882_cur)
  rx1882_restart:
.annotate 'line', 10
    if_null rx1882_debug, debug_1384
    rx1882_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1384:
  rx1882_fail:
    (rx1882_rep, rx1882_pos, $I10, $P10) = rx1882_cur."!mark_fail"(0)
    lt rx1882_pos, -1, rx1882_done
    eq rx1882_pos, -1, rx1882_fail
    jump $I10
  rx1882_done:
    rx1882_cur."!cursor_fail"()
    if_null rx1882_debug, debug_1385
    rx1882_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1385:
    .return (rx1882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303857440.612") :method
.annotate 'line', 10
    new $P1884, "ResizablePMCArray"
    push $P1884, "return"
    .return ($P1884)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1889"  :anon :subid("373_1303857440.612") :outer("371_1303857440.612")
.annotate 'line', 712
    new $P1891, "Integer"
    assign $P1891, 1
    store_dynamic_lex "$*RETURN_USED", $P1891
    .return ($P1891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1894_tgt
    .local int rx1894_pos
    .local int rx1894_off
    .local int rx1894_eos
    .local int rx1894_rep
    .local pmc rx1894_cur
    .local pmc rx1894_debug
    (rx1894_cur, rx1894_pos, rx1894_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1894_cur
    .local pmc match
    .lex "$/", match
    length rx1894_eos, rx1894_tgt
    gt rx1894_pos, rx1894_eos, rx1894_done
    set rx1894_off, 0
    lt rx1894_pos, 2, rx1894_start
    sub rx1894_off, rx1894_pos, 1
    substr rx1894_tgt, rx1894_tgt, rx1894_off
  rx1894_start:
    eq $I10, 1, rx1894_restart
    if_null rx1894_debug, debug_1386
    rx1894_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1386:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1897_done
    goto rxscan1897_scan
  rxscan1897_loop:
    (rx1894_pos) = rx1894_cur."from"()
    inc rx1894_pos
    rx1894_cur."!cursor_from"(rx1894_pos)
    ge rx1894_pos, rx1894_eos, rxscan1897_done
  rxscan1897_scan:
    set_addr $I10, rxscan1897_loop
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxscan1897_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1898_fail
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  # rx literal  "make"
    add $I11, rx1894_pos, 4
    gt $I11, rx1894_eos, rx1894_fail
    sub $I11, rx1894_pos, rx1894_off
    substr $S10, rx1894_tgt, $I11, 4
    ne $S10, "make", rx1894_fail
    add rx1894_pos, 4
    set_addr $I10, rxcap_1898_fail
    ($I12, $I11) = rx1894_cur."!mark_peek"($I10)
    rx1894_cur."!cursor_pos"($I11)
    ($P10) = rx1894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1894_pos, "")
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1898_done
  rxcap_1898_fail:
    goto rx1894_fail
  rxcap_1898_done:
  # rx charclass s
    ge rx1894_pos, rx1894_eos, rx1894_fail
    sub $I10, rx1894_pos, rx1894_off
    is_cclass $I11, 32, rx1894_tgt, $I10
    unless $I11, rx1894_fail
    inc rx1894_pos
  # rx subrule "O" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."O"("%list_prefix")
    unless $P10, rx1894_fail
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1894_pos = $P10."pos"()
  # rx pass
    rx1894_cur."!cursor_pass"(rx1894_pos, "prefix:sym<make>")
    if_null rx1894_debug, debug_1387
    rx1894_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1894_pos)
  debug_1387:
    .return (rx1894_cur)
  rx1894_restart:
.annotate 'line', 10
    if_null rx1894_debug, debug_1388
    rx1894_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1388:
  rx1894_fail:
    (rx1894_rep, rx1894_pos, $I10, $P10) = rx1894_cur."!mark_fail"(0)
    lt rx1894_pos, -1, rx1894_done
    eq rx1894_pos, -1, rx1894_fail
    jump $I10
  rx1894_done:
    rx1894_cur."!cursor_fail"()
    if_null rx1894_debug, debug_1389
    rx1894_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1389:
    .return (rx1894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303857440.612") :method
.annotate 'line', 10
    new $P1896, "ResizablePMCArray"
    push $P1896, "make"
    .return ($P1896)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1900_tgt
    .local int rx1900_pos
    .local int rx1900_off
    .local int rx1900_eos
    .local int rx1900_rep
    .local pmc rx1900_cur
    .local pmc rx1900_debug
    (rx1900_cur, rx1900_pos, rx1900_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1900_cur
    .local pmc match
    .lex "$/", match
    length rx1900_eos, rx1900_tgt
    gt rx1900_pos, rx1900_eos, rx1900_done
    set rx1900_off, 0
    lt rx1900_pos, 2, rx1900_start
    sub rx1900_off, rx1900_pos, 1
    substr rx1900_tgt, rx1900_tgt, rx1900_off
  rx1900_start:
    eq $I10, 1, rx1900_restart
    if_null rx1900_debug, debug_1390
    rx1900_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1390:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1903_done
    goto rxscan1903_scan
  rxscan1903_loop:
    (rx1900_pos) = rx1900_cur."from"()
    inc rx1900_pos
    rx1900_cur."!cursor_from"(rx1900_pos)
    ge rx1900_pos, rx1900_eos, rxscan1903_done
  rxscan1903_scan:
    set_addr $I10, rxscan1903_loop
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  rxscan1903_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1904_fail
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "last"
    add $I11, rx1900_pos, 4
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 4
    ne $S10, "last", rx1900_fail
    add rx1900_pos, 4
    set_addr $I10, rxcap_1904_fail
    ($I12, $I11) = rx1900_cur."!mark_peek"($I10)
    rx1900_cur."!cursor_pos"($I11)
    ($P10) = rx1900_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1900_pos, "")
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1904_done
  rxcap_1904_fail:
    goto rx1900_fail
  rxcap_1904_done:
  # rx pass
    rx1900_cur."!cursor_pass"(rx1900_pos, "term:sym<last>")
    if_null rx1900_debug, debug_1391
    rx1900_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1900_pos)
  debug_1391:
    .return (rx1900_cur)
  rx1900_restart:
.annotate 'line', 10
    if_null rx1900_debug, debug_1392
    rx1900_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1392:
  rx1900_fail:
    (rx1900_rep, rx1900_pos, $I10, $P10) = rx1900_cur."!mark_fail"(0)
    lt rx1900_pos, -1, rx1900_done
    eq rx1900_pos, -1, rx1900_fail
    jump $I10
  rx1900_done:
    rx1900_cur."!cursor_fail"()
    if_null rx1900_debug, debug_1393
    rx1900_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1393:
    .return (rx1900_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303857440.612") :method
.annotate 'line', 10
    new $P1902, "ResizablePMCArray"
    push $P1902, "last"
    .return ($P1902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1906_tgt
    .local int rx1906_pos
    .local int rx1906_off
    .local int rx1906_eos
    .local int rx1906_rep
    .local pmc rx1906_cur
    .local pmc rx1906_debug
    (rx1906_cur, rx1906_pos, rx1906_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1906_cur
    .local pmc match
    .lex "$/", match
    length rx1906_eos, rx1906_tgt
    gt rx1906_pos, rx1906_eos, rx1906_done
    set rx1906_off, 0
    lt rx1906_pos, 2, rx1906_start
    sub rx1906_off, rx1906_pos, 1
    substr rx1906_tgt, rx1906_tgt, rx1906_off
  rx1906_start:
    eq $I10, 1, rx1906_restart
    if_null rx1906_debug, debug_1394
    rx1906_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1394:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1909_done
    goto rxscan1909_scan
  rxscan1909_loop:
    (rx1906_pos) = rx1906_cur."from"()
    inc rx1906_pos
    rx1906_cur."!cursor_from"(rx1906_pos)
    ge rx1906_pos, rx1906_eos, rxscan1909_done
  rxscan1909_scan:
    set_addr $I10, rxscan1909_loop
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  rxscan1909_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1910_fail
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  # rx literal  "next"
    add $I11, rx1906_pos, 4
    gt $I11, rx1906_eos, rx1906_fail
    sub $I11, rx1906_pos, rx1906_off
    substr $S10, rx1906_tgt, $I11, 4
    ne $S10, "next", rx1906_fail
    add rx1906_pos, 4
    set_addr $I10, rxcap_1910_fail
    ($I12, $I11) = rx1906_cur."!mark_peek"($I10)
    rx1906_cur."!cursor_pos"($I11)
    ($P10) = rx1906_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1906_pos, "")
    rx1906_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1910_done
  rxcap_1910_fail:
    goto rx1906_fail
  rxcap_1910_done:
  # rx pass
    rx1906_cur."!cursor_pass"(rx1906_pos, "term:sym<next>")
    if_null rx1906_debug, debug_1395
    rx1906_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1906_pos)
  debug_1395:
    .return (rx1906_cur)
  rx1906_restart:
.annotate 'line', 10
    if_null rx1906_debug, debug_1396
    rx1906_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1396:
  rx1906_fail:
    (rx1906_rep, rx1906_pos, $I10, $P10) = rx1906_cur."!mark_fail"(0)
    lt rx1906_pos, -1, rx1906_done
    eq rx1906_pos, -1, rx1906_fail
    jump $I10
  rx1906_done:
    rx1906_cur."!cursor_fail"()
    if_null rx1906_debug, debug_1397
    rx1906_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1397:
    .return (rx1906_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303857440.612") :method
.annotate 'line', 10
    new $P1908, "ResizablePMCArray"
    push $P1908, "next"
    .return ($P1908)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303857440.612") :method :outer("12_1303857440.612")
.annotate 'line', 10
    .local string rx1912_tgt
    .local int rx1912_pos
    .local int rx1912_off
    .local int rx1912_eos
    .local int rx1912_rep
    .local pmc rx1912_cur
    .local pmc rx1912_debug
    (rx1912_cur, rx1912_pos, rx1912_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1912_cur
    .local pmc match
    .lex "$/", match
    length rx1912_eos, rx1912_tgt
    gt rx1912_pos, rx1912_eos, rx1912_done
    set rx1912_off, 0
    lt rx1912_pos, 2, rx1912_start
    sub rx1912_off, rx1912_pos, 1
    substr rx1912_tgt, rx1912_tgt, rx1912_off
  rx1912_start:
    eq $I10, 1, rx1912_restart
    if_null rx1912_debug, debug_1398
    rx1912_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1398:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1915_done
    goto rxscan1915_scan
  rxscan1915_loop:
    (rx1912_pos) = rx1912_cur."from"()
    inc rx1912_pos
    rx1912_cur."!cursor_from"(rx1912_pos)
    ge rx1912_pos, rx1912_eos, rxscan1915_done
  rxscan1915_scan:
    set_addr $I10, rxscan1915_loop
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxscan1915_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1916_fail
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1912_pos, 4
    gt $I11, rx1912_eos, rx1912_fail
    sub $I11, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I11, 4
    ne $S10, "redo", rx1912_fail
    add rx1912_pos, 4
    set_addr $I10, rxcap_1916_fail
    ($I12, $I11) = rx1912_cur."!mark_peek"($I10)
    rx1912_cur."!cursor_pos"($I11)
    ($P10) = rx1912_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1912_pos, "")
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1916_done
  rxcap_1916_fail:
    goto rx1912_fail
  rxcap_1916_done:
  # rx pass
    rx1912_cur."!cursor_pass"(rx1912_pos, "term:sym<redo>")
    if_null rx1912_debug, debug_1399
    rx1912_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1912_pos)
  debug_1399:
    .return (rx1912_cur)
  rx1912_restart:
.annotate 'line', 10
    if_null rx1912_debug, debug_1400
    rx1912_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1400:
  rx1912_fail:
    (rx1912_rep, rx1912_pos, $I10, $P10) = rx1912_cur."!mark_fail"(0)
    lt rx1912_pos, -1, rx1912_done
    eq rx1912_pos, -1, rx1912_fail
    jump $I10
  rx1912_done:
    rx1912_cur."!cursor_fail"()
    if_null rx1912_debug, debug_1401
    rx1912_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1401:
    .return (rx1912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303857440.612") :method
.annotate 'line', 10
    new $P1914, "ResizablePMCArray"
    push $P1914, "redo"
    .return ($P1914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303857440.612") :outer("12_1303857440.612")
    .param pmc param_1918
    .param pmc param_1919
.annotate 'line', 718
    .lex "self", param_1918
    .lex "$/", param_1919
.annotate 'line', 720
    new $P1920, "Undef"
    .lex "$t", $P1920
    find_lex $P1921, "$/"
    unless_null $P1921, vivify_1402
    $P1921 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P1922, $P1921[0]
    unless_null $P1922, vivify_1403
    new $P1922, "Undef"
  vivify_1403:
    store_lex "$t", $P1922
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_1404
    $P1923 = root_new ['parrot';'ResizablePMCArray']
  vivify_1404:
    set $P1924, $P1923[1]
    unless_null $P1924, vivify_1405
    new $P1924, "Undef"
  vivify_1405:
    find_lex $P1925, "$/"
    unless_null $P1925, vivify_1406
    $P1925 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1925
  vivify_1406:
    set $P1925[0], $P1924
    find_lex $P1926, "$t"
    unless_null $P1926, vivify_1407
    new $P1926, "Undef"
  vivify_1407:
    find_lex $P1927, "$/"
    unless_null $P1927, vivify_1408
    $P1927 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1927
  vivify_1408:
    set $P1927[1], $P1926
.annotate 'line', 718
    .return ($P1926)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2650"  :subid("384_1303857440.612") :outer("10_1303857440.612")
.annotate 'line', 724
    .const 'Sub' $P2716 = "405_1303857440.612" 
    capture_lex $P2716
    .const 'Sub' $P2709 = "403_1303857440.612" 
    capture_lex $P2709
    .const 'Sub' $P2704 = "401_1303857440.612" 
    capture_lex $P2704
    .const 'Sub' $P2692 = "398_1303857440.612" 
    capture_lex $P2692
    .const 'Sub' $P2682 = "395_1303857440.612" 
    capture_lex $P2682
    .const 'Sub' $P2677 = "393_1303857440.612" 
    capture_lex $P2677
    .const 'Sub' $P2668 = "390_1303857440.612" 
    capture_lex $P2668
    .const 'Sub' $P2663 = "388_1303857440.612" 
    capture_lex $P2663
    .const 'Sub' $P2654 = "385_1303857440.612" 
    capture_lex $P2654
    .lex "$?PACKAGE", $P2652
    .lex "$?CLASS", $P2653
    .const 'Sub' $P2709 = "403_1303857440.612" 
    capture_lex $P2709
    .return ($P2709)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1409") :outer("384_1303857440.612")
.annotate 'line', 724
    .const 'Sub' $P2651 = "384_1303857440.612" 
    .local pmc block
    set block, $P2651
    .const 'Sub' $P2716 = "405_1303857440.612" 
    capture_lex $P2716
    $P2716()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2715"  :anon :subid("405_1303857440.612") :outer("384_1303857440.612")
.annotate 'line', 724
    nqp_get_sc_object $P2717, "1303857428.33", 2
    .local pmc type_obj
    set type_obj, $P2717
    get_how $P2718, type_obj
    .const 'Sub' $P2719 = "385_1303857440.612" 
    $P2718."add_method"(type_obj, "metachar:sym<:my>", $P2719)
    get_how $P2720, type_obj
    get_global $P2721, "!PREFIX__metachar:sym<:my>"
    $P2720."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2721)
    get_how $P2722, type_obj
    .const 'Sub' $P2723 = "388_1303857440.612" 
    $P2722."add_method"(type_obj, "metachar:sym<{ }>", $P2723)
    get_how $P2724, type_obj
    get_global $P2725, "!PREFIX__metachar:sym<{ }>"
    $P2724."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2725)
    get_how $P2726, type_obj
    .const 'Sub' $P2727 = "390_1303857440.612" 
    $P2726."add_method"(type_obj, "metachar:sym<nqpvar>", $P2727)
    get_how $P2728, type_obj
    get_global $P2729, "!PREFIX__metachar:sym<nqpvar>"
    $P2728."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2729)
    get_how $P2730, type_obj
    .const 'Sub' $P2731 = "393_1303857440.612" 
    $P2730."add_method"(type_obj, "assertion:sym<{ }>", $P2731)
    get_how $P2732, type_obj
    get_global $P2733, "!PREFIX__assertion:sym<{ }>"
    $P2732."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2733)
    get_how $P2734, type_obj
    .const 'Sub' $P2735 = "395_1303857440.612" 
    $P2734."add_method"(type_obj, "assertion:sym<?{ }>", $P2735)
    get_how $P2736, type_obj
    get_global $P2737, "!PREFIX__assertion:sym<?{ }>"
    $P2736."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2737)
    get_how $P2738, type_obj
    .const 'Sub' $P2739 = "398_1303857440.612" 
    $P2738."add_method"(type_obj, "assertion:sym<name>", $P2739)
    get_how $P2740, type_obj
    get_global $P2741, "!PREFIX__assertion:sym<name>"
    $P2740."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2741)
    get_how $P2742, type_obj
    .const 'Sub' $P2743 = "401_1303857440.612" 
    $P2742."add_method"(type_obj, "assertion:sym<var>", $P2743)
    get_how $P2744, type_obj
    get_global $P2745, "!PREFIX__assertion:sym<var>"
    $P2744."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2745)
    get_how $P2746, type_obj
    .const 'Sub' $P2747 = "403_1303857440.612" 
    $P2746."add_method"(type_obj, "codeblock", $P2747)
    get_how $P2748, type_obj
    get_global $P2749, "!PREFIX__codeblock"
    $P2748."add_method"(type_obj, "!PREFIX__codeblock", $P2749)
    get_how $P2750, type_obj
    $P2751 = $P2750."compose"(type_obj)
    .return ($P2751)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .const 'Sub' $P2660 = "387_1303857440.612" 
    capture_lex $P2660
    .local string rx2655_tgt
    .local int rx2655_pos
    .local int rx2655_off
    .local int rx2655_eos
    .local int rx2655_rep
    .local pmc rx2655_cur
    .local pmc rx2655_debug
    (rx2655_cur, rx2655_pos, rx2655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2655_cur
    .local pmc match
    .lex "$/", match
    length rx2655_eos, rx2655_tgt
    gt rx2655_pos, rx2655_eos, rx2655_done
    set rx2655_off, 0
    lt rx2655_pos, 2, rx2655_start
    sub rx2655_off, rx2655_pos, 1
    substr rx2655_tgt, rx2655_tgt, rx2655_off
  rx2655_start:
    eq $I10, 1, rx2655_restart
    if_null rx2655_debug, debug_1410
    rx2655_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1410:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2658_done
    goto rxscan2658_scan
  rxscan2658_loop:
    (rx2655_pos) = rx2655_cur."from"()
    inc rx2655_pos
    rx2655_cur."!cursor_from"(rx2655_pos)
    ge rx2655_pos, rx2655_eos, rxscan2658_done
  rxscan2658_scan:
    set_addr $I10, rxscan2658_loop
    rx2655_cur."!mark_push"(0, rx2655_pos, $I10)
  rxscan2658_done:
.annotate 'line', 726
  # rx literal  ":"
    add $I11, rx2655_pos, 1
    gt $I11, rx2655_eos, rx2655_fail
    sub $I11, rx2655_pos, rx2655_off
    ord $I11, rx2655_tgt, $I11
    ne $I11, 58, rx2655_fail
    add rx2655_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    .const 'Sub' $P2660 = "387_1303857440.612" 
    capture_lex $P2660
    $P10 = rx2655_cur."before"($P2660)
    unless $P10, rx2655_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    $P10 = rx2655_cur."LANG"("MAIN", "statement")
    unless $P10, rx2655_fail
    rx2655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2655_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    $P10 = rx2655_cur."ws"()
    unless $P10, rx2655_fail
    rx2655_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2655_pos, 1
    gt $I11, rx2655_eos, rx2655_fail
    sub $I11, rx2655_pos, rx2655_off
    ord $I11, rx2655_tgt, $I11
    ne $I11, 59, rx2655_fail
    add rx2655_pos, 1
.annotate 'line', 725
  # rx pass
    rx2655_cur."!cursor_pass"(rx2655_pos, "metachar:sym<:my>")
    if_null rx2655_debug, debug_1415
    rx2655_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2655_pos)
  debug_1415:
    .return (rx2655_cur)
  rx2655_restart:
.annotate 'line', 724
    if_null rx2655_debug, debug_1416
    rx2655_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1416:
  rx2655_fail:
    (rx2655_rep, rx2655_pos, $I10, $P10) = rx2655_cur."!mark_fail"(0)
    lt rx2655_pos, -1, rx2655_done
    eq rx2655_pos, -1, rx2655_fail
    jump $I10
  rx2655_done:
    rx2655_cur."!cursor_fail"()
    if_null rx2655_debug, debug_1417
    rx2655_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1417:
    .return (rx2655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303857440.612") :method
.annotate 'line', 724
    new $P2657, "ResizablePMCArray"
    push $P2657, ":"
    .return ($P2657)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2659"  :anon :subid("387_1303857440.612") :method :outer("385_1303857440.612")
.annotate 'line', 726
    .local string rx2661_tgt
    .local int rx2661_pos
    .local int rx2661_off
    .local int rx2661_eos
    .local int rx2661_rep
    .local pmc rx2661_cur
    .local pmc rx2661_debug
    (rx2661_cur, rx2661_pos, rx2661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2661_cur
    .local pmc match
    .lex "$/", match
    length rx2661_eos, rx2661_tgt
    gt rx2661_pos, rx2661_eos, rx2661_done
    set rx2661_off, 0
    lt rx2661_pos, 2, rx2661_start
    sub rx2661_off, rx2661_pos, 1
    substr rx2661_tgt, rx2661_tgt, rx2661_off
  rx2661_start:
    eq $I10, 1, rx2661_restart
    if_null rx2661_debug, debug_1411
    rx2661_cur."!cursor_debug"("START", "")
  debug_1411:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2662_done
    goto rxscan2662_scan
  rxscan2662_loop:
    (rx2661_pos) = rx2661_cur."from"()
    inc rx2661_pos
    rx2661_cur."!cursor_from"(rx2661_pos)
    ge rx2661_pos, rx2661_eos, rxscan2662_done
  rxscan2662_scan:
    set_addr $I10, rxscan2662_loop
    rx2661_cur."!mark_push"(0, rx2661_pos, $I10)
  rxscan2662_done:
  # rx literal  "my"
    add $I11, rx2661_pos, 2
    gt $I11, rx2661_eos, rx2661_fail
    sub $I11, rx2661_pos, rx2661_off
    substr $S10, rx2661_tgt, $I11, 2
    ne $S10, "my", rx2661_fail
    add rx2661_pos, 2
  # rx pass
    rx2661_cur."!cursor_pass"(rx2661_pos, "")
    if_null rx2661_debug, debug_1412
    rx2661_cur."!cursor_debug"("PASS", "", " at pos=", rx2661_pos)
  debug_1412:
    .return (rx2661_cur)
  rx2661_restart:
    if_null rx2661_debug, debug_1413
    rx2661_cur."!cursor_debug"("NEXT", "")
  debug_1413:
  rx2661_fail:
    (rx2661_rep, rx2661_pos, $I10, $P10) = rx2661_cur."!mark_fail"(0)
    lt rx2661_pos, -1, rx2661_done
    eq rx2661_pos, -1, rx2661_fail
    jump $I10
  rx2661_done:
    rx2661_cur."!cursor_fail"()
    if_null rx2661_debug, debug_1414
    rx2661_cur."!cursor_debug"("FAIL", "")
  debug_1414:
    .return (rx2661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .local string rx2664_tgt
    .local int rx2664_pos
    .local int rx2664_off
    .local int rx2664_eos
    .local int rx2664_rep
    .local pmc rx2664_cur
    .local pmc rx2664_debug
    (rx2664_cur, rx2664_pos, rx2664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2664_cur
    .local pmc match
    .lex "$/", match
    length rx2664_eos, rx2664_tgt
    gt rx2664_pos, rx2664_eos, rx2664_done
    set rx2664_off, 0
    lt rx2664_pos, 2, rx2664_start
    sub rx2664_off, rx2664_pos, 1
    substr rx2664_tgt, rx2664_tgt, rx2664_off
  rx2664_start:
    eq $I10, 1, rx2664_restart
    if_null rx2664_debug, debug_1418
    rx2664_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1418:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2667_done
    goto rxscan2667_scan
  rxscan2667_loop:
    (rx2664_pos) = rx2664_cur."from"()
    inc rx2664_pos
    rx2664_cur."!cursor_from"(rx2664_pos)
    ge rx2664_pos, rx2664_eos, rxscan2667_done
  rxscan2667_scan:
    set_addr $I10, rxscan2667_loop
    rx2664_cur."!mark_push"(0, rx2664_pos, $I10)
  rxscan2667_done:
.annotate 'line', 730
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2664_pos, rx2664_off
    substr $S10, rx2664_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2664_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2664_cur."!cursor_pos"(rx2664_pos)
    $P10 = rx2664_cur."codeblock"()
    unless $P10, rx2664_fail
    rx2664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2664_pos = $P10."pos"()
.annotate 'line', 729
  # rx pass
    rx2664_cur."!cursor_pass"(rx2664_pos, "metachar:sym<{ }>")
    if_null rx2664_debug, debug_1419
    rx2664_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2664_pos)
  debug_1419:
    .return (rx2664_cur)
  rx2664_restart:
.annotate 'line', 724
    if_null rx2664_debug, debug_1420
    rx2664_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1420:
  rx2664_fail:
    (rx2664_rep, rx2664_pos, $I10, $P10) = rx2664_cur."!mark_fail"(0)
    lt rx2664_pos, -1, rx2664_done
    eq rx2664_pos, -1, rx2664_fail
    jump $I10
  rx2664_done:
    rx2664_cur."!cursor_fail"()
    if_null rx2664_debug, debug_1421
    rx2664_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1421:
    .return (rx2664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303857440.612") :method
.annotate 'line', 724
    new $P2666, "ResizablePMCArray"
    push $P2666, "{"
    .return ($P2666)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .const 'Sub' $P2674 = "392_1303857440.612" 
    capture_lex $P2674
    .local string rx2669_tgt
    .local int rx2669_pos
    .local int rx2669_off
    .local int rx2669_eos
    .local int rx2669_rep
    .local pmc rx2669_cur
    .local pmc rx2669_debug
    (rx2669_cur, rx2669_pos, rx2669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2669_cur
    .local pmc match
    .lex "$/", match
    length rx2669_eos, rx2669_tgt
    gt rx2669_pos, rx2669_eos, rx2669_done
    set rx2669_off, 0
    lt rx2669_pos, 2, rx2669_start
    sub rx2669_off, rx2669_pos, 1
    substr rx2669_tgt, rx2669_tgt, rx2669_off
  rx2669_start:
    eq $I10, 1, rx2669_restart
    if_null rx2669_debug, debug_1422
    rx2669_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1422:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2672_done
    goto rxscan2672_scan
  rxscan2672_loop:
    (rx2669_pos) = rx2669_cur."from"()
    inc rx2669_pos
    rx2669_cur."!cursor_from"(rx2669_pos)
    ge rx2669_pos, rx2669_eos, rxscan2672_done
  rxscan2672_scan:
    set_addr $I10, rxscan2672_loop
    rx2669_cur."!mark_push"(0, rx2669_pos, $I10)
  rxscan2672_done:
.annotate 'line', 734
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2669_pos, rx2669_off
    substr $S10, rx2669_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2669_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2669_cur."!cursor_pos"(rx2669_pos)
    .const 'Sub' $P2674 = "392_1303857440.612" 
    capture_lex $P2674
    $P10 = rx2669_cur."before"($P2674)
    unless $P10, rx2669_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2669_cur."!cursor_pos"(rx2669_pos)
    $P10 = rx2669_cur."LANG"("MAIN", "variable")
    unless $P10, rx2669_fail
    rx2669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2669_pos = $P10."pos"()
.annotate 'line', 733
  # rx pass
    rx2669_cur."!cursor_pass"(rx2669_pos, "metachar:sym<nqpvar>")
    if_null rx2669_debug, debug_1427
    rx2669_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2669_pos)
  debug_1427:
    .return (rx2669_cur)
  rx2669_restart:
.annotate 'line', 724
    if_null rx2669_debug, debug_1428
    rx2669_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1428:
  rx2669_fail:
    (rx2669_rep, rx2669_pos, $I10, $P10) = rx2669_cur."!mark_fail"(0)
    lt rx2669_pos, -1, rx2669_done
    eq rx2669_pos, -1, rx2669_fail
    jump $I10
  rx2669_done:
    rx2669_cur."!cursor_fail"()
    if_null rx2669_debug, debug_1429
    rx2669_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1429:
    .return (rx2669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303857440.612") :method
.annotate 'line', 724
    new $P2671, "ResizablePMCArray"
    push $P2671, "$"
    push $P2671, "@"
    .return ($P2671)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2673"  :anon :subid("392_1303857440.612") :method :outer("390_1303857440.612")
.annotate 'line', 734
    .local string rx2675_tgt
    .local int rx2675_pos
    .local int rx2675_off
    .local int rx2675_eos
    .local int rx2675_rep
    .local pmc rx2675_cur
    .local pmc rx2675_debug
    (rx2675_cur, rx2675_pos, rx2675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2675_cur
    .local pmc match
    .lex "$/", match
    length rx2675_eos, rx2675_tgt
    gt rx2675_pos, rx2675_eos, rx2675_done
    set rx2675_off, 0
    lt rx2675_pos, 2, rx2675_start
    sub rx2675_off, rx2675_pos, 1
    substr rx2675_tgt, rx2675_tgt, rx2675_off
  rx2675_start:
    eq $I10, 1, rx2675_restart
    if_null rx2675_debug, debug_1423
    rx2675_cur."!cursor_debug"("START", "")
  debug_1423:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2676_done
    goto rxscan2676_scan
  rxscan2676_loop:
    (rx2675_pos) = rx2675_cur."from"()
    inc rx2675_pos
    rx2675_cur."!cursor_from"(rx2675_pos)
    ge rx2675_pos, rx2675_eos, rxscan2676_done
  rxscan2676_scan:
    set_addr $I10, rxscan2676_loop
    rx2675_cur."!mark_push"(0, rx2675_pos, $I10)
  rxscan2676_done:
  # rx charclass .
    ge rx2675_pos, rx2675_eos, rx2675_fail
    inc rx2675_pos
  # rx charclass w
    ge rx2675_pos, rx2675_eos, rx2675_fail
    sub $I10, rx2675_pos, rx2675_off
    is_cclass $I11, 8192, rx2675_tgt, $I10
    unless $I11, rx2675_fail
    inc rx2675_pos
  # rx pass
    rx2675_cur."!cursor_pass"(rx2675_pos, "")
    if_null rx2675_debug, debug_1424
    rx2675_cur."!cursor_debug"("PASS", "", " at pos=", rx2675_pos)
  debug_1424:
    .return (rx2675_cur)
  rx2675_restart:
    if_null rx2675_debug, debug_1425
    rx2675_cur."!cursor_debug"("NEXT", "")
  debug_1425:
  rx2675_fail:
    (rx2675_rep, rx2675_pos, $I10, $P10) = rx2675_cur."!mark_fail"(0)
    lt rx2675_pos, -1, rx2675_done
    eq rx2675_pos, -1, rx2675_fail
    jump $I10
  rx2675_done:
    rx2675_cur."!cursor_fail"()
    if_null rx2675_debug, debug_1426
    rx2675_cur."!cursor_debug"("FAIL", "")
  debug_1426:
    .return (rx2675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .local string rx2678_tgt
    .local int rx2678_pos
    .local int rx2678_off
    .local int rx2678_eos
    .local int rx2678_rep
    .local pmc rx2678_cur
    .local pmc rx2678_debug
    (rx2678_cur, rx2678_pos, rx2678_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2678_cur
    .local pmc match
    .lex "$/", match
    length rx2678_eos, rx2678_tgt
    gt rx2678_pos, rx2678_eos, rx2678_done
    set rx2678_off, 0
    lt rx2678_pos, 2, rx2678_start
    sub rx2678_off, rx2678_pos, 1
    substr rx2678_tgt, rx2678_tgt, rx2678_off
  rx2678_start:
    eq $I10, 1, rx2678_restart
    if_null rx2678_debug, debug_1430
    rx2678_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2681_done
    goto rxscan2681_scan
  rxscan2681_loop:
    (rx2678_pos) = rx2678_cur."from"()
    inc rx2678_pos
    rx2678_cur."!cursor_from"(rx2678_pos)
    ge rx2678_pos, rx2678_eos, rxscan2681_done
  rxscan2681_scan:
    set_addr $I10, rxscan2681_loop
    rx2678_cur."!mark_push"(0, rx2678_pos, $I10)
  rxscan2681_done:
.annotate 'line', 738
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2678_pos, rx2678_off
    substr $S10, rx2678_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2678_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2678_cur."!cursor_pos"(rx2678_pos)
    $P10 = rx2678_cur."codeblock"()
    unless $P10, rx2678_fail
    rx2678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2678_pos = $P10."pos"()
.annotate 'line', 737
  # rx pass
    rx2678_cur."!cursor_pass"(rx2678_pos, "assertion:sym<{ }>")
    if_null rx2678_debug, debug_1431
    rx2678_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2678_pos)
  debug_1431:
    .return (rx2678_cur)
  rx2678_restart:
.annotate 'line', 724
    if_null rx2678_debug, debug_1432
    rx2678_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1432:
  rx2678_fail:
    (rx2678_rep, rx2678_pos, $I10, $P10) = rx2678_cur."!mark_fail"(0)
    lt rx2678_pos, -1, rx2678_done
    eq rx2678_pos, -1, rx2678_fail
    jump $I10
  rx2678_done:
    rx2678_cur."!cursor_fail"()
    if_null rx2678_debug, debug_1433
    rx2678_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1433:
    .return (rx2678_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303857440.612") :method
.annotate 'line', 724
    new $P2680, "ResizablePMCArray"
    push $P2680, "{"
    .return ($P2680)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .const 'Sub' $P2688 = "397_1303857440.612" 
    capture_lex $P2688
    .local string rx2683_tgt
    .local int rx2683_pos
    .local int rx2683_off
    .local int rx2683_eos
    .local int rx2683_rep
    .local pmc rx2683_cur
    .local pmc rx2683_debug
    (rx2683_cur, rx2683_pos, rx2683_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2683_cur
    .local pmc match
    .lex "$/", match
    length rx2683_eos, rx2683_tgt
    gt rx2683_pos, rx2683_eos, rx2683_done
    set rx2683_off, 0
    lt rx2683_pos, 2, rx2683_start
    sub rx2683_off, rx2683_pos, 1
    substr rx2683_tgt, rx2683_tgt, rx2683_off
  rx2683_start:
    eq $I10, 1, rx2683_restart
    if_null rx2683_debug, debug_1434
    rx2683_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2686_done
    goto rxscan2686_scan
  rxscan2686_loop:
    (rx2683_pos) = rx2683_cur."from"()
    inc rx2683_pos
    rx2683_cur."!cursor_from"(rx2683_pos)
    ge rx2683_pos, rx2683_eos, rxscan2686_done
  rxscan2686_scan:
    set_addr $I10, rxscan2686_loop
    rx2683_cur."!mark_push"(0, rx2683_pos, $I10)
  rxscan2686_done:
.annotate 'line', 742
  # rx subcapture "zw"
    set_addr $I10, rxcap_2691_fail
    rx2683_cur."!mark_push"(0, rx2683_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2683_pos, rx2683_eos, rx2683_fail
    sub $I10, rx2683_pos, rx2683_off
    substr $S10, rx2683_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2683_fail
    inc rx2683_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2683_cur."!cursor_pos"(rx2683_pos)
    .const 'Sub' $P2688 = "397_1303857440.612" 
    capture_lex $P2688
    $P10 = rx2683_cur."before"($P2688)
    unless $P10, rx2683_fail
    set_addr $I10, rxcap_2691_fail
    ($I12, $I11) = rx2683_cur."!mark_peek"($I10)
    rx2683_cur."!cursor_pos"($I11)
    ($P10) = rx2683_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2683_pos, "")
    rx2683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2691_done
  rxcap_2691_fail:
    goto rx2683_fail
  rxcap_2691_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2683_cur."!cursor_pos"(rx2683_pos)
    $P10 = rx2683_cur."codeblock"()
    unless $P10, rx2683_fail
    rx2683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2683_pos = $P10."pos"()
.annotate 'line', 741
  # rx pass
    rx2683_cur."!cursor_pass"(rx2683_pos, "assertion:sym<?{ }>")
    if_null rx2683_debug, debug_1439
    rx2683_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2683_pos)
  debug_1439:
    .return (rx2683_cur)
  rx2683_restart:
.annotate 'line', 724
    if_null rx2683_debug, debug_1440
    rx2683_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1440:
  rx2683_fail:
    (rx2683_rep, rx2683_pos, $I10, $P10) = rx2683_cur."!mark_fail"(0)
    lt rx2683_pos, -1, rx2683_done
    eq rx2683_pos, -1, rx2683_fail
    jump $I10
  rx2683_done:
    rx2683_cur."!cursor_fail"()
    if_null rx2683_debug, debug_1441
    rx2683_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1441:
    .return (rx2683_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303857440.612") :method
.annotate 'line', 724
    new $P2685, "ResizablePMCArray"
    push $P2685, "!"
    push $P2685, "?"
    .return ($P2685)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2687"  :anon :subid("397_1303857440.612") :method :outer("395_1303857440.612")
.annotate 'line', 742
    .local string rx2689_tgt
    .local int rx2689_pos
    .local int rx2689_off
    .local int rx2689_eos
    .local int rx2689_rep
    .local pmc rx2689_cur
    .local pmc rx2689_debug
    (rx2689_cur, rx2689_pos, rx2689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2689_cur
    .local pmc match
    .lex "$/", match
    length rx2689_eos, rx2689_tgt
    gt rx2689_pos, rx2689_eos, rx2689_done
    set rx2689_off, 0
    lt rx2689_pos, 2, rx2689_start
    sub rx2689_off, rx2689_pos, 1
    substr rx2689_tgt, rx2689_tgt, rx2689_off
  rx2689_start:
    eq $I10, 1, rx2689_restart
    if_null rx2689_debug, debug_1435
    rx2689_cur."!cursor_debug"("START", "")
  debug_1435:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2690_done
    goto rxscan2690_scan
  rxscan2690_loop:
    (rx2689_pos) = rx2689_cur."from"()
    inc rx2689_pos
    rx2689_cur."!cursor_from"(rx2689_pos)
    ge rx2689_pos, rx2689_eos, rxscan2690_done
  rxscan2690_scan:
    set_addr $I10, rxscan2690_loop
    rx2689_cur."!mark_push"(0, rx2689_pos, $I10)
  rxscan2690_done:
  # rx literal  "{"
    add $I11, rx2689_pos, 1
    gt $I11, rx2689_eos, rx2689_fail
    sub $I11, rx2689_pos, rx2689_off
    ord $I11, rx2689_tgt, $I11
    ne $I11, 123, rx2689_fail
    add rx2689_pos, 1
  # rx pass
    rx2689_cur."!cursor_pass"(rx2689_pos, "")
    if_null rx2689_debug, debug_1436
    rx2689_cur."!cursor_debug"("PASS", "", " at pos=", rx2689_pos)
  debug_1436:
    .return (rx2689_cur)
  rx2689_restart:
    if_null rx2689_debug, debug_1437
    rx2689_cur."!cursor_debug"("NEXT", "")
  debug_1437:
  rx2689_fail:
    (rx2689_rep, rx2689_pos, $I10, $P10) = rx2689_cur."!mark_fail"(0)
    lt rx2689_pos, -1, rx2689_done
    eq rx2689_pos, -1, rx2689_fail
    jump $I10
  rx2689_done:
    rx2689_cur."!cursor_fail"()
    if_null rx2689_debug, debug_1438
    rx2689_cur."!cursor_debug"("FAIL", "")
  debug_1438:
    .return (rx2689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .const 'Sub' $P2701 = "400_1303857440.612" 
    capture_lex $P2701
    .local string rx2693_tgt
    .local int rx2693_pos
    .local int rx2693_off
    .local int rx2693_eos
    .local int rx2693_rep
    .local pmc rx2693_cur
    .local pmc rx2693_debug
    (rx2693_cur, rx2693_pos, rx2693_tgt, $I10) = self."!cursor_start"()
    rx2693_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2693_cur
    .local pmc match
    .lex "$/", match
    length rx2693_eos, rx2693_tgt
    gt rx2693_pos, rx2693_eos, rx2693_done
    set rx2693_off, 0
    lt rx2693_pos, 2, rx2693_start
    sub rx2693_off, rx2693_pos, 1
    substr rx2693_tgt, rx2693_tgt, rx2693_off
  rx2693_start:
    eq $I10, 1, rx2693_restart
    if_null rx2693_debug, debug_1442
    rx2693_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2697_done
    goto rxscan2697_scan
  rxscan2697_loop:
    (rx2693_pos) = rx2693_cur."from"()
    inc rx2693_pos
    rx2693_cur."!cursor_from"(rx2693_pos)
    ge rx2693_pos, rx2693_eos, rxscan2697_done
  rxscan2697_scan:
    set_addr $I10, rxscan2697_loop
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
  rxscan2697_done:
.annotate 'line', 746
  # rx subrule "identifier" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."identifier"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2693_pos = $P10."pos"()
.annotate 'line', 753
  # rx rxquantr2698 ** 0..1
    set_addr $I10, rxquantr2698_done
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
  rxquantr2698_loop:
  alt2699_0:
.annotate 'line', 747
    set_addr $I10, alt2699_1
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 748
  # rx subrule "before" subtype=zerowidth negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    .const 'Sub' $P2701 = "400_1303857440.612" 
    capture_lex $P2701
    $P10 = rx2693_cur."before"($P2701)
    unless $P10, rx2693_fail
    goto alt2699_end
  alt2699_1:
    set_addr $I10, alt2699_2
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 749
  # rx literal  "="
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 61, rx2693_fail
    add rx2693_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."assertion"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2693_pos = $P10."pos"()
    goto alt2699_end
  alt2699_2:
    set_addr $I10, alt2699_3
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 750
  # rx literal  ":"
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 58, rx2693_fail
    add rx2693_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."arglist"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2693_pos = $P10."pos"()
    goto alt2699_end
  alt2699_3:
    set_addr $I10, alt2699_4
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 751
  # rx literal  "("
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 40, rx2693_fail
    add rx2693_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2693_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 41, rx2693_fail
    add rx2693_pos, 1
    goto alt2699_end
  alt2699_4:
.annotate 'line', 752
  # rx subrule "normspace" subtype=method negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."normspace"()
    unless $P10, rx2693_fail
    rx2693_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."nibbler"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2693_pos = $P10."pos"()
  alt2699_end:
.annotate 'line', 753
    set_addr $I10, rxquantr2698_done
    (rx2693_rep) = rx2693_cur."!mark_commit"($I10)
  rxquantr2698_done:
.annotate 'line', 745
  # rx pass
    rx2693_cur."!cursor_pass"(rx2693_pos, "assertion:sym<name>")
    if_null rx2693_debug, debug_1447
    rx2693_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2693_pos)
  debug_1447:
    .return (rx2693_cur)
  rx2693_restart:
.annotate 'line', 724
    if_null rx2693_debug, debug_1448
    rx2693_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1448:
  rx2693_fail:
    (rx2693_rep, rx2693_pos, $I10, $P10) = rx2693_cur."!mark_fail"(0)
    lt rx2693_pos, -1, rx2693_done
    eq rx2693_pos, -1, rx2693_fail
    jump $I10
  rx2693_done:
    rx2693_cur."!cursor_fail"()
    if_null rx2693_debug, debug_1449
    rx2693_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1449:
    .return (rx2693_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303857440.612") :method
.annotate 'line', 724
    $P2695 = self."!PREFIX__!subrule"("identifier", "")
    new $P2696, "ResizablePMCArray"
    push $P2696, $P2695
    .return ($P2696)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2700"  :anon :subid("400_1303857440.612") :method :outer("398_1303857440.612")
.annotate 'line', 748
    .local string rx2702_tgt
    .local int rx2702_pos
    .local int rx2702_off
    .local int rx2702_eos
    .local int rx2702_rep
    .local pmc rx2702_cur
    .local pmc rx2702_debug
    (rx2702_cur, rx2702_pos, rx2702_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2702_cur
    .local pmc match
    .lex "$/", match
    length rx2702_eos, rx2702_tgt
    gt rx2702_pos, rx2702_eos, rx2702_done
    set rx2702_off, 0
    lt rx2702_pos, 2, rx2702_start
    sub rx2702_off, rx2702_pos, 1
    substr rx2702_tgt, rx2702_tgt, rx2702_off
  rx2702_start:
    eq $I10, 1, rx2702_restart
    if_null rx2702_debug, debug_1443
    rx2702_cur."!cursor_debug"("START", "")
  debug_1443:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2703_done
    goto rxscan2703_scan
  rxscan2703_loop:
    (rx2702_pos) = rx2702_cur."from"()
    inc rx2702_pos
    rx2702_cur."!cursor_from"(rx2702_pos)
    ge rx2702_pos, rx2702_eos, rxscan2703_done
  rxscan2703_scan:
    set_addr $I10, rxscan2703_loop
    rx2702_cur."!mark_push"(0, rx2702_pos, $I10)
  rxscan2703_done:
  # rx literal  ">"
    add $I11, rx2702_pos, 1
    gt $I11, rx2702_eos, rx2702_fail
    sub $I11, rx2702_pos, rx2702_off
    ord $I11, rx2702_tgt, $I11
    ne $I11, 62, rx2702_fail
    add rx2702_pos, 1
  # rx pass
    rx2702_cur."!cursor_pass"(rx2702_pos, "")
    if_null rx2702_debug, debug_1444
    rx2702_cur."!cursor_debug"("PASS", "", " at pos=", rx2702_pos)
  debug_1444:
    .return (rx2702_cur)
  rx2702_restart:
    if_null rx2702_debug, debug_1445
    rx2702_cur."!cursor_debug"("NEXT", "")
  debug_1445:
  rx2702_fail:
    (rx2702_rep, rx2702_pos, $I10, $P10) = rx2702_cur."!mark_fail"(0)
    lt rx2702_pos, -1, rx2702_done
    eq rx2702_pos, -1, rx2702_fail
    jump $I10
  rx2702_done:
    rx2702_cur."!cursor_fail"()
    if_null rx2702_debug, debug_1446
    rx2702_cur."!cursor_debug"("FAIL", "")
  debug_1446:
    .return (rx2702_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .local string rx2705_tgt
    .local int rx2705_pos
    .local int rx2705_off
    .local int rx2705_eos
    .local int rx2705_rep
    .local pmc rx2705_cur
    .local pmc rx2705_debug
    (rx2705_cur, rx2705_pos, rx2705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2705_cur
    .local pmc match
    .lex "$/", match
    length rx2705_eos, rx2705_tgt
    gt rx2705_pos, rx2705_eos, rx2705_done
    set rx2705_off, 0
    lt rx2705_pos, 2, rx2705_start
    sub rx2705_off, rx2705_pos, 1
    substr rx2705_tgt, rx2705_tgt, rx2705_off
  rx2705_start:
    eq $I10, 1, rx2705_restart
    if_null rx2705_debug, debug_1450
    rx2705_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2708_done
    goto rxscan2708_scan
  rxscan2708_loop:
    (rx2705_pos) = rx2705_cur."from"()
    inc rx2705_pos
    rx2705_cur."!cursor_from"(rx2705_pos)
    ge rx2705_pos, rx2705_eos, rxscan2708_done
  rxscan2708_scan:
    set_addr $I10, rxscan2708_loop
    rx2705_cur."!mark_push"(0, rx2705_pos, $I10)
  rxscan2708_done:
.annotate 'line', 757
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2705_pos, rx2705_off
    substr $S10, rx2705_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2705_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2705_cur."!cursor_pos"(rx2705_pos)
    $P10 = rx2705_cur."LANG"("MAIN", "variable")
    unless $P10, rx2705_fail
    rx2705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2705_pos = $P10."pos"()
.annotate 'line', 756
  # rx pass
    rx2705_cur."!cursor_pass"(rx2705_pos, "assertion:sym<var>")
    if_null rx2705_debug, debug_1451
    rx2705_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2705_pos)
  debug_1451:
    .return (rx2705_cur)
  rx2705_restart:
.annotate 'line', 724
    if_null rx2705_debug, debug_1452
    rx2705_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1452:
  rx2705_fail:
    (rx2705_rep, rx2705_pos, $I10, $P10) = rx2705_cur."!mark_fail"(0)
    lt rx2705_pos, -1, rx2705_done
    eq rx2705_pos, -1, rx2705_fail
    jump $I10
  rx2705_done:
    rx2705_cur."!cursor_fail"()
    if_null rx2705_debug, debug_1453
    rx2705_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1453:
    .return (rx2705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303857440.612") :method
.annotate 'line', 724
    new $P2707, "ResizablePMCArray"
    push $P2707, "$"
    push $P2707, "@"
    .return ($P2707)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303857440.612") :method :outer("384_1303857440.612")
.annotate 'line', 724
    .local string rx2710_tgt
    .local int rx2710_pos
    .local int rx2710_off
    .local int rx2710_eos
    .local int rx2710_rep
    .local pmc rx2710_cur
    .local pmc rx2710_debug
    (rx2710_cur, rx2710_pos, rx2710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2710_cur
    .local pmc match
    .lex "$/", match
    length rx2710_eos, rx2710_tgt
    gt rx2710_pos, rx2710_eos, rx2710_done
    set rx2710_off, 0
    lt rx2710_pos, 2, rx2710_start
    sub rx2710_off, rx2710_pos, 1
    substr rx2710_tgt, rx2710_tgt, rx2710_off
  rx2710_start:
    eq $I10, 1, rx2710_restart
    if_null rx2710_debug, debug_1454
    rx2710_cur."!cursor_debug"("START", "codeblock")
  debug_1454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2714_done
    goto rxscan2714_scan
  rxscan2714_loop:
    (rx2710_pos) = rx2710_cur."from"()
    inc rx2710_pos
    rx2710_cur."!cursor_from"(rx2710_pos)
    ge rx2710_pos, rx2710_eos, rxscan2714_done
  rxscan2714_scan:
    set_addr $I10, rxscan2714_loop
    rx2710_cur."!mark_push"(0, rx2710_pos, $I10)
  rxscan2714_done:
.annotate 'line', 761
  # rx subrule "LANG" subtype=capture negate=
    rx2710_cur."!cursor_pos"(rx2710_pos)
    $P10 = rx2710_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2710_fail
    rx2710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2710_pos = $P10."pos"()
.annotate 'line', 760
  # rx pass
    rx2710_cur."!cursor_pass"(rx2710_pos, "codeblock")
    if_null rx2710_debug, debug_1455
    rx2710_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2710_pos)
  debug_1455:
    .return (rx2710_cur)
  rx2710_restart:
.annotate 'line', 724
    if_null rx2710_debug, debug_1456
    rx2710_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1456:
  rx2710_fail:
    (rx2710_rep, rx2710_pos, $I10, $P10) = rx2710_cur."!mark_fail"(0)
    lt rx2710_pos, -1, rx2710_done
    eq rx2710_pos, -1, rx2710_fail
    jump $I10
  rx2710_done:
    rx2710_cur."!cursor_fail"()
    if_null rx2710_debug, debug_1457
    rx2710_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1457:
    .return (rx2710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303857440.612") :method
.annotate 'line', 724
    $P2712 = self."!PREFIX__!subrule"("LANG", "")
    new $P2713, "ResizablePMCArray"
    push $P2713, $P2712
    .return ($P2713)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2752"  :subid("406_1303857440.612") :outer("10_1303857440.612")
.annotate 'line', 767
    .const 'Sub' $P6880 = "574_1303857440.612" 
    capture_lex $P6880
    .const 'Sub' $P6863 = "573_1303857440.612" 
    capture_lex $P6863
    .const 'Sub' $P6858 = "572_1303857440.612" 
    capture_lex $P6858
    .const 'Sub' $P6853 = "571_1303857440.612" 
    capture_lex $P6853
    .const 'Sub' $P6848 = "570_1303857440.612" 
    capture_lex $P6848
    .const 'Sub' $P6831 = "569_1303857440.612" 
    capture_lex $P6831
    .const 'Sub' $P6820 = "568_1303857440.612" 
    capture_lex $P6820
    .const 'Sub' $P6809 = "567_1303857440.612" 
    capture_lex $P6809
    .const 'Sub' $P6801 = "566_1303857440.612" 
    capture_lex $P6801
    .const 'Sub' $P6796 = "565_1303857440.612" 
    capture_lex $P6796
    .const 'Sub' $P6781 = "564_1303857440.612" 
    capture_lex $P6781
    .const 'Sub' $P6773 = "563_1303857440.612" 
    capture_lex $P6773
    .const 'Sub' $P6712 = "562_1303857440.612" 
    capture_lex $P6712
    .const 'Sub' $P6697 = "561_1303857440.612" 
    capture_lex $P6697
    .const 'Sub' $P6689 = "560_1303857440.612" 
    capture_lex $P6689
    .const 'Sub' $P6681 = "559_1303857440.612" 
    capture_lex $P6681
    .const 'Sub' $P6673 = "558_1303857440.612" 
    capture_lex $P6673
    .const 'Sub' $P6665 = "557_1303857440.612" 
    capture_lex $P6665
    .const 'Sub' $P6657 = "556_1303857440.612" 
    capture_lex $P6657
    .const 'Sub' $P6628 = "555_1303857440.612" 
    capture_lex $P6628
    .const 'Sub' $P6613 = "554_1303857440.612" 
    capture_lex $P6613
    .const 'Sub' $P6605 = "553_1303857440.612" 
    capture_lex $P6605
    .const 'Sub' $P6591 = "552_1303857440.612" 
    capture_lex $P6591
    .const 'Sub' $P6577 = "551_1303857440.612" 
    capture_lex $P6577
    .const 'Sub' $P6563 = "550_1303857440.612" 
    capture_lex $P6563
    .const 'Sub' $P6555 = "549_1303857440.612" 
    capture_lex $P6555
    .const 'Sub' $P6525 = "548_1303857440.612" 
    capture_lex $P6525
    .const 'Sub' $P6487 = "546_1303857440.612" 
    capture_lex $P6487
    .const 'Sub' $P6479 = "545_1303857440.612" 
    capture_lex $P6479
    .const 'Sub' $P6471 = "544_1303857440.612" 
    capture_lex $P6471
    .const 'Sub' $P6440 = "543_1303857440.612" 
    capture_lex $P6440
    .const 'Sub' $P6421 = "542_1303857440.612" 
    capture_lex $P6421
    .const 'Sub' $P6413 = "541_1303857440.612" 
    capture_lex $P6413
    .const 'Sub' $P6405 = "540_1303857440.612" 
    capture_lex $P6405
    .const 'Sub' $P6297 = "537_1303857440.612" 
    capture_lex $P6297
    .const 'Sub' $P6289 = "536_1303857440.612" 
    capture_lex $P6289
    .const 'Sub' $P6279 = "535_1303857440.612" 
    capture_lex $P6279
    .const 'Sub' $P6245 = "534_1303857440.612" 
    capture_lex $P6245
    .const 'Sub' $P6203 = "532_1303857440.612" 
    capture_lex $P6203
    .const 'Sub' $P6189 = "531_1303857440.612" 
    capture_lex $P6189
    .const 'Sub' $P6179 = "530_1303857440.612" 
    capture_lex $P6179
    .const 'Sub' $P6127 = "529_1303857440.612" 
    capture_lex $P6127
    .const 'Sub' $P5851 = "525_1303857440.612" 
    capture_lex $P5851
    .const 'Sub' $P5769 = "523_1303857440.612" 
    capture_lex $P5769
    .const 'Sub' $P5761 = "522_1303857440.612" 
    capture_lex $P5761
    .const 'Sub' $P5745 = "521_1303857440.612" 
    capture_lex $P5745
    .const 'Sub' $P5730 = "520_1303857440.612" 
    capture_lex $P5730
    .const 'Sub' $P5707 = "519_1303857440.612" 
    capture_lex $P5707
    .const 'Sub' $P5604 = "518_1303857440.612" 
    capture_lex $P5604
    .const 'Sub' $P5550 = "515_1303857440.612" 
    capture_lex $P5550
    .const 'Sub' $P5369 = "512_1303857440.612" 
    capture_lex $P5369
    .const 'Sub' $P5042 = "505_1303857440.612" 
    capture_lex $P5042
    .const 'Sub' $P5034 = "504_1303857440.612" 
    capture_lex $P5034
    .const 'Sub' $P5026 = "503_1303857440.612" 
    capture_lex $P5026
    .const 'Sub' $P4879 = "500_1303857440.612" 
    capture_lex $P4879
    .const 'Sub' $P4871 = "499_1303857440.612" 
    capture_lex $P4871
    .const 'Sub' $P4856 = "498_1303857440.612" 
    capture_lex $P4856
    .const 'Sub' $P4841 = "497_1303857440.612" 
    capture_lex $P4841
    .const 'Sub' $P4826 = "496_1303857440.612" 
    capture_lex $P4826
    .const 'Sub' $P4804 = "495_1303857440.612" 
    capture_lex $P4804
    .const 'Sub' $P4796 = "494_1303857440.612" 
    capture_lex $P4796
    .const 'Sub' $P4788 = "493_1303857440.612" 
    capture_lex $P4788
    .const 'Sub' $P4780 = "492_1303857440.612" 
    capture_lex $P4780
    .const 'Sub' $P4472 = "486_1303857440.612" 
    capture_lex $P4472
    .const 'Sub' $P4464 = "485_1303857440.612" 
    capture_lex $P4464
    .const 'Sub' $P4456 = "484_1303857440.612" 
    capture_lex $P4456
    .const 'Sub' $P4448 = "483_1303857440.612" 
    capture_lex $P4448
    .const 'Sub' $P4440 = "482_1303857440.612" 
    capture_lex $P4440
    .const 'Sub' $P4432 = "481_1303857440.612" 
    capture_lex $P4432
    .const 'Sub' $P4424 = "480_1303857440.612" 
    capture_lex $P4424
    .const 'Sub' $P4282 = "477_1303857440.612" 
    capture_lex $P4282
    .const 'Sub' $P4255 = "476_1303857440.612" 
    capture_lex $P4255
    .const 'Sub' $P4241 = "475_1303857440.612" 
    capture_lex $P4241
    .const 'Sub' $P4233 = "474_1303857440.612" 
    capture_lex $P4233
    .const 'Sub' $P4225 = "473_1303857440.612" 
    capture_lex $P4225
    .const 'Sub' $P4217 = "472_1303857440.612" 
    capture_lex $P4217
    .const 'Sub' $P4209 = "471_1303857440.612" 
    capture_lex $P4209
    .const 'Sub' $P4201 = "470_1303857440.612" 
    capture_lex $P4201
    .const 'Sub' $P4193 = "469_1303857440.612" 
    capture_lex $P4193
    .const 'Sub' $P4185 = "468_1303857440.612" 
    capture_lex $P4185
    .const 'Sub' $P4177 = "467_1303857440.612" 
    capture_lex $P4177
    .const 'Sub' $P4169 = "466_1303857440.612" 
    capture_lex $P4169
    .const 'Sub' $P4161 = "465_1303857440.612" 
    capture_lex $P4161
    .const 'Sub' $P4153 = "464_1303857440.612" 
    capture_lex $P4153
    .const 'Sub' $P4145 = "463_1303857440.612" 
    capture_lex $P4145
    .const 'Sub' $P4137 = "462_1303857440.612" 
    capture_lex $P4137
    .const 'Sub' $P4121 = "461_1303857440.612" 
    capture_lex $P4121
    .const 'Sub' $P4067 = "460_1303857440.612" 
    capture_lex $P4067
    .const 'Sub' $P4050 = "459_1303857440.612" 
    capture_lex $P4050
    .const 'Sub' $P4026 = "458_1303857440.612" 
    capture_lex $P4026
    .const 'Sub' $P4003 = "457_1303857440.612" 
    capture_lex $P4003
    .const 'Sub' $P3976 = "456_1303857440.612" 
    capture_lex $P3976
    .const 'Sub' $P3939 = "455_1303857440.612" 
    capture_lex $P3939
    .const 'Sub' $P3924 = "454_1303857440.612" 
    capture_lex $P3924
    .const 'Sub' $P3912 = "453_1303857440.612" 
    capture_lex $P3912
    .const 'Sub' $P3861 = "451_1303857440.612" 
    capture_lex $P3861
    .const 'Sub' $P3836 = "450_1303857440.612" 
    capture_lex $P3836
    .const 'Sub' $P3829 = "449_1303857440.612" 
    capture_lex $P3829
    .const 'Sub' $P3787 = "448_1303857440.612" 
    capture_lex $P3787
    .const 'Sub' $P3737 = "446_1303857440.612" 
    capture_lex $P3737
    .const 'Sub' $P3720 = "445_1303857440.612" 
    capture_lex $P3720
    .const 'Sub' $P3681 = "443_1303857440.612" 
    capture_lex $P3681
    .const 'Sub' $P3673 = "442_1303857440.612" 
    capture_lex $P3673
    .const 'Sub' $P3665 = "441_1303857440.612" 
    capture_lex $P3665
    .const 'Sub' $P3648 = "440_1303857440.612" 
    capture_lex $P3648
    .const 'Sub' $P3552 = "438_1303857440.612" 
    capture_lex $P3552
    .const 'Sub' $P3508 = "436_1303857440.612" 
    capture_lex $P3508
    .const 'Sub' $P3393 = "435_1303857440.612" 
    capture_lex $P3393
    .const 'Sub' $P3362 = "434_1303857440.612" 
    capture_lex $P3362
    .const 'Sub' $P3354 = "433_1303857440.612" 
    capture_lex $P3354
    .const 'Sub' $P3225 = "427_1303857440.612" 
    capture_lex $P3225
    .const 'Sub' $P3190 = "425_1303857440.612" 
    capture_lex $P3190
    .const 'Sub' $P3185 = "424_1303857440.612" 
    capture_lex $P3185
    .const 'Sub' $P3180 = "423_1303857440.612" 
    capture_lex $P3180
    .const 'Sub' $P3067 = "420_1303857440.612" 
    capture_lex $P3067
    .const 'Sub' $P3049 = "419_1303857440.612" 
    capture_lex $P3049
    .const 'Sub' $P2966 = "417_1303857440.612" 
    capture_lex $P2966
    .const 'Sub' $P2951 = "416_1303857440.612" 
    capture_lex $P2951
    .const 'Sub' $P2864 = "415_1303857440.612" 
    capture_lex $P2864
    .const 'Sub' $P2838 = "413_1303857440.612" 
    capture_lex $P2838
    .const 'Sub' $P2822 = "412_1303857440.612" 
    capture_lex $P2822
    .const 'Sub' $P2798 = "411_1303857440.612" 
    capture_lex $P2798
    .const 'Sub' $P2762 = "408_1303857440.612" 
    capture_lex $P2762
    .const 'Sub' $P2754 = "407_1303857440.612" 
    capture_lex $P2754
.annotate 'line', 771
    .const 'Sub' $P2754 = "407_1303857440.612" 
    newclosure $P2761, $P2754
    .lex "xblock_immediate", $P2761
.annotate 'line', 776
    .const 'Sub' $P2762 = "408_1303857440.612" 
    newclosure $P2797, $P2762
    .lex "block_immediate", $P2797
.annotate 'line', 786
    .const 'Sub' $P2798 = "411_1303857440.612" 
    newclosure $P2821, $P2798
    .lex "vivitype", $P2821
.annotate 'line', 805
    .const 'Sub' $P2822 = "412_1303857440.612" 
    newclosure $P2837, $P2822
    .lex "colonpair_str", $P2837
.annotate 'line', 967
    .const 'Sub' $P2838 = "413_1303857440.612" 
    newclosure $P2863, $P2838
    .lex "import_HOW_exports", $P2863
.annotate 'line', 1072
    .const 'Sub' $P2864 = "415_1303857440.612" 
    newclosure $P2950, $P2864
    .lex "push_block_handler", $P2950
.annotate 'line', 1610
    .const 'Sub' $P2951 = "416_1303857440.612" 
    newclosure $P2965, $P2951
    .lex "only_star_block", $P2965
.annotate 'line', 1619
    .const 'Sub' $P2966 = "417_1303857440.612" 
    newclosure $P3048, $P2966
    .lex "attach_multi_signature", $P3048
.annotate 'line', 2085
    .const 'Sub' $P3049 = "419_1303857440.612" 
    newclosure $P3066, $P3049
    .lex "control", $P3066
.annotate 'line', 2104
    .const 'Sub' $P3067 = "420_1303857440.612" 
    newclosure $P3179, $P3067
    .lex "lexical_package_lookup", $P3179
.annotate 'line', 2153
    .const 'Sub' $P3180 = "423_1303857440.612" 
    newclosure $P3184, $P3180
    .lex "is_lexical", $P3184
.annotate 'line', 2159
    .const 'Sub' $P3185 = "424_1303857440.612" 
    newclosure $P3189, $P3185
    .lex "is_package", $P3189
.annotate 'line', 2165
    .const 'Sub' $P3190 = "425_1303857440.612" 
    newclosure $P3224, $P3190
    .lex "is_scope", $P3224
.annotate 'line', 2178
    .const 'Sub' $P3225 = "427_1303857440.612" 
    newclosure $P3345, $P3225
    .lex "find_sym", $P3345
.annotate 'line', 767
    .lex "$?PACKAGE", $P3346
    .lex "$?CLASS", $P3347
.annotate 'line', 769
    new $P3348, "ResizablePMCArray"
    find_lex $P3349, "$?PACKAGE"
    get_who $P3350, $P3349
    set $P3350["@BLOCK"], $P3348
    find_lex $P3351, "xblock_immediate"
    find_lex $P3352, "block_immediate"
    find_lex $P3353, "vivitype"
.annotate 'line', 797
    find_lex $P3392, "colonpair_str"
.annotate 'line', 950
    find_lex $P3786, "import_HOW_exports"
.annotate 'line', 1065
    find_lex $P4049, "push_block_handler"
.annotate 'line', 1537
    find_lex $P5548, "only_star_block"
    find_lex $P5549, "attach_multi_signature"
.annotate 'line', 2076
    find_lex $P6847, "control"
.annotate 'line', 2098
    find_lex $P6874, "lexical_package_lookup"
    find_lex $P6875, "is_lexical"
    find_lex $P6876, "is_package"
    find_lex $P6877, "is_scope"
    find_lex $P6878, "find_sym"
.annotate 'line', 767
    .return ($P6878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1458") :outer("406_1303857440.612")
.annotate 'line', 767
    .const 'Sub' $P2753 = "406_1303857440.612" 
    .local pmc block
    set block, $P2753
    .const 'Sub' $P6880 = "574_1303857440.612" 
    capture_lex $P6880
    $P6880()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6879"  :anon :subid("574_1303857440.612") :outer("406_1303857440.612")
.annotate 'line', 767
    nqp_get_sc_object $P6881, "1303857428.33", 3
    .local pmc type_obj
    set type_obj, $P6881
    get_how $P6882, type_obj
    .const 'Sub' $P6883 = "433_1303857440.612" 
    $P6882."add_method"(type_obj, "TOP", $P6883)
    get_how $P6884, type_obj
    .const 'Sub' $P6885 = "434_1303857440.612" 
    $P6884."add_method"(type_obj, "deflongname", $P6885)
    get_how $P6886, type_obj
    .const 'Sub' $P6887 = "435_1303857440.612" 
    $P6886."add_method"(type_obj, "comp_unit", $P6887)
    get_how $P6888, type_obj
    .const 'Sub' $P6889 = "436_1303857440.612" 
    $P6888."add_method"(type_obj, "statementlist", $P6889)
    get_how $P6890, type_obj
    .const 'Sub' $P6891 = "438_1303857440.612" 
    $P6890."add_method"(type_obj, "statement", $P6891)
    get_how $P6892, type_obj
    .const 'Sub' $P6893 = "440_1303857440.612" 
    $P6892."add_method"(type_obj, "xblock", $P6893)
    get_how $P6894, type_obj
    .const 'Sub' $P6895 = "441_1303857440.612" 
    $P6894."add_method"(type_obj, "pblock", $P6895)
    get_how $P6896, type_obj
    .const 'Sub' $P6897 = "442_1303857440.612" 
    $P6896."add_method"(type_obj, "block", $P6897)
    get_how $P6898, type_obj
    .const 'Sub' $P6899 = "443_1303857440.612" 
    $P6898."add_method"(type_obj, "blockoid", $P6899)
    get_how $P6900, type_obj
    .const 'Sub' $P6901 = "445_1303857440.612" 
    $P6900."add_method"(type_obj, "newpad", $P6901)
    get_how $P6902, type_obj
    .const 'Sub' $P6903 = "446_1303857440.612" 
    $P6902."add_method"(type_obj, "outerctx", $P6903)
    get_how $P6904, type_obj
    .const 'Sub' $P6905 = "448_1303857440.612" 
    $P6904."add_method"(type_obj, "GLOBALish", $P6905)
    get_how $P6906, type_obj
    .const 'Sub' $P6907 = "449_1303857440.612" 
    $P6906."add_method"(type_obj, "you_are_here", $P6907)
    get_how $P6908, type_obj
    .const 'Sub' $P6909 = "450_1303857440.612" 
    $P6908."add_method"(type_obj, "statement_control:sym<use>", $P6909)
    get_how $P6910, type_obj
    .const 'Sub' $P6911 = "451_1303857440.612" 
    $P6910."add_method"(type_obj, "statement_control:sym<if>", $P6911)
    get_how $P6912, type_obj
    .const 'Sub' $P6913 = "453_1303857440.612" 
    $P6912."add_method"(type_obj, "statement_control:sym<unless>", $P6913)
    get_how $P6914, type_obj
    .const 'Sub' $P6915 = "454_1303857440.612" 
    $P6914."add_method"(type_obj, "statement_control:sym<while>", $P6915)
    get_how $P6916, type_obj
    .const 'Sub' $P6917 = "455_1303857440.612" 
    $P6916."add_method"(type_obj, "statement_control:sym<repeat>", $P6917)
    get_how $P6918, type_obj
    .const 'Sub' $P6919 = "456_1303857440.612" 
    $P6918."add_method"(type_obj, "statement_control:sym<for>", $P6919)
    get_how $P6920, type_obj
    .const 'Sub' $P6921 = "457_1303857440.612" 
    $P6920."add_method"(type_obj, "statement_control:sym<CATCH>", $P6921)
    get_how $P6922, type_obj
    .const 'Sub' $P6923 = "458_1303857440.612" 
    $P6922."add_method"(type_obj, "statement_control:sym<CONTROL>", $P6923)
    get_how $P6924, type_obj
    .const 'Sub' $P6925 = "459_1303857440.612" 
    $P6924."add_method"(type_obj, "statement_prefix:sym<INIT>", $P6925)
    get_how $P6926, type_obj
    .const 'Sub' $P6927 = "460_1303857440.612" 
    $P6926."add_method"(type_obj, "statement_prefix:sym<try>", $P6927)
    get_how $P6928, type_obj
    .const 'Sub' $P6929 = "461_1303857440.612" 
    $P6928."add_method"(type_obj, "blorst", $P6929)
    get_how $P6930, type_obj
    .const 'Sub' $P6931 = "462_1303857440.612" 
    $P6930."add_method"(type_obj, "statement_mod_cond:sym<if>", $P6931)
    get_how $P6932, type_obj
    .const 'Sub' $P6933 = "463_1303857440.612" 
    $P6932."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P6933)
    get_how $P6934, type_obj
    .const 'Sub' $P6935 = "464_1303857440.612" 
    $P6934."add_method"(type_obj, "statement_mod_loop:sym<while>", $P6935)
    get_how $P6936, type_obj
    .const 'Sub' $P6937 = "465_1303857440.612" 
    $P6936."add_method"(type_obj, "statement_mod_loop:sym<until>", $P6937)
    get_how $P6938, type_obj
    .const 'Sub' $P6939 = "466_1303857440.612" 
    $P6938."add_method"(type_obj, "term:sym<fatarrow>", $P6939)
    get_how $P6940, type_obj
    .const 'Sub' $P6941 = "467_1303857440.612" 
    $P6940."add_method"(type_obj, "term:sym<colonpair>", $P6941)
    get_how $P6942, type_obj
    .const 'Sub' $P6943 = "468_1303857440.612" 
    $P6942."add_method"(type_obj, "term:sym<variable>", $P6943)
    get_how $P6944, type_obj
    .const 'Sub' $P6945 = "469_1303857440.612" 
    $P6944."add_method"(type_obj, "term:sym<package_declarator>", $P6945)
    get_how $P6946, type_obj
    .const 'Sub' $P6947 = "470_1303857440.612" 
    $P6946."add_method"(type_obj, "term:sym<scope_declarator>", $P6947)
    get_how $P6948, type_obj
    .const 'Sub' $P6949 = "471_1303857440.612" 
    $P6948."add_method"(type_obj, "term:sym<routine_declarator>", $P6949)
    get_how $P6950, type_obj
    .const 'Sub' $P6951 = "472_1303857440.612" 
    $P6950."add_method"(type_obj, "term:sym<regex_declarator>", $P6951)
    get_how $P6952, type_obj
    .const 'Sub' $P6953 = "473_1303857440.612" 
    $P6952."add_method"(type_obj, "term:sym<statement_prefix>", $P6953)
    get_how $P6954, type_obj
    .const 'Sub' $P6955 = "474_1303857440.612" 
    $P6954."add_method"(type_obj, "term:sym<lambda>", $P6955)
    get_how $P6956, type_obj
    .const 'Sub' $P6957 = "475_1303857440.612" 
    $P6956."add_method"(type_obj, "fatarrow", $P6957)
    get_how $P6958, type_obj
    .const 'Sub' $P6959 = "476_1303857440.612" 
    $P6958."add_method"(type_obj, "colonpair", $P6959)
    get_how $P6960, type_obj
    .const 'Sub' $P6961 = "477_1303857440.612" 
    $P6960."add_method"(type_obj, "variable", $P6961)
    get_how $P6962, type_obj
    .const 'Sub' $P6963 = "480_1303857440.612" 
    $P6962."add_method"(type_obj, "package_declarator:sym<module>", $P6963)
    get_how $P6964, type_obj
    .const 'Sub' $P6965 = "481_1303857440.612" 
    $P6964."add_method"(type_obj, "package_declarator:sym<knowhow>", $P6965)
    get_how $P6966, type_obj
    .const 'Sub' $P6967 = "482_1303857440.612" 
    $P6966."add_method"(type_obj, "package_declarator:sym<class>", $P6967)
    get_how $P6968, type_obj
    .const 'Sub' $P6969 = "483_1303857440.612" 
    $P6968."add_method"(type_obj, "package_declarator:sym<grammar>", $P6969)
    get_how $P6970, type_obj
    .const 'Sub' $P6971 = "484_1303857440.612" 
    $P6970."add_method"(type_obj, "package_declarator:sym<role>", $P6971)
    get_how $P6972, type_obj
    .const 'Sub' $P6973 = "485_1303857440.612" 
    $P6972."add_method"(type_obj, "package_declarator:sym<native>", $P6973)
    get_how $P6974, type_obj
    .const 'Sub' $P6975 = "486_1303857440.612" 
    $P6974."add_method"(type_obj, "package_def", $P6975)
    get_how $P6976, type_obj
    .const 'Sub' $P6977 = "492_1303857440.612" 
    $P6976."add_method"(type_obj, "scope_declarator:sym<my>", $P6977)
    get_how $P6978, type_obj
    .const 'Sub' $P6979 = "493_1303857440.612" 
    $P6978."add_method"(type_obj, "scope_declarator:sym<our>", $P6979)
    get_how $P6980, type_obj
    .const 'Sub' $P6981 = "494_1303857440.612" 
    $P6980."add_method"(type_obj, "scope_declarator:sym<has>", $P6981)
    get_how $P6982, type_obj
    .const 'Sub' $P6983 = "495_1303857440.612" 
    $P6982."add_method"(type_obj, "scoped", $P6983)
    get_how $P6984, type_obj
    .const 'Sub' $P6985 = "496_1303857440.612" 
    $P6984."add_method"(type_obj, "declarator", $P6985)
    get_how $P6986, type_obj
    .const 'Sub' $P6987 = "497_1303857440.612" 
    $P6986."add_method"(type_obj, "multi_declarator:sym<multi>", $P6987)
    get_how $P6988, type_obj
    .const 'Sub' $P6989 = "498_1303857440.612" 
    $P6988."add_method"(type_obj, "multi_declarator:sym<proto>", $P6989)
    get_how $P6990, type_obj
    .const 'Sub' $P6991 = "499_1303857440.612" 
    $P6990."add_method"(type_obj, "multi_declarator:sym<null>", $P6991)
    get_how $P6992, type_obj
    .const 'Sub' $P6993 = "500_1303857440.612" 
    $P6992."add_method"(type_obj, "variable_declarator", $P6993)
    get_how $P6994, type_obj
    .const 'Sub' $P6995 = "503_1303857440.612" 
    $P6994."add_method"(type_obj, "routine_declarator:sym<sub>", $P6995)
    get_how $P6996, type_obj
    .const 'Sub' $P6997 = "504_1303857440.612" 
    $P6996."add_method"(type_obj, "routine_declarator:sym<method>", $P6997)
    get_how $P6998, type_obj
    .const 'Sub' $P6999 = "505_1303857440.612" 
    $P6998."add_method"(type_obj, "routine_def", $P6999)
    get_how $P7000, type_obj
    .const 'Sub' $P7001 = "512_1303857440.612" 
    $P7000."add_method"(type_obj, "method_def", $P7001)
    get_how $P7002, type_obj
    .const 'Sub' $P7003 = "515_1303857440.612" 
    $P7002."add_method"(type_obj, "signature", $P7003)
    get_how $P7004, type_obj
    .const 'Sub' $P7005 = "518_1303857440.612" 
    $P7004."add_method"(type_obj, "parameter", $P7005)
    get_how $P7006, type_obj
    .const 'Sub' $P7007 = "519_1303857440.612" 
    $P7006."add_method"(type_obj, "param_var", $P7007)
    get_how $P7008, type_obj
    .const 'Sub' $P7009 = "520_1303857440.612" 
    $P7008."add_method"(type_obj, "named_param", $P7009)
    get_how $P7010, type_obj
    .const 'Sub' $P7011 = "521_1303857440.612" 
    $P7010."add_method"(type_obj, "typename", $P7011)
    get_how $P7012, type_obj
    .const 'Sub' $P7013 = "522_1303857440.612" 
    $P7012."add_method"(type_obj, "trait", $P7013)
    get_how $P7014, type_obj
    .const 'Sub' $P7015 = "523_1303857440.612" 
    $P7014."add_method"(type_obj, "trait_mod:sym<is>", $P7015)
    get_how $P7016, type_obj
    .const 'Sub' $P7017 = "525_1303857440.612" 
    $P7016."add_method"(type_obj, "regex_declarator", $P7017)
    get_how $P7018, type_obj
    .const 'Sub' $P7019 = "529_1303857440.612" 
    $P7018."add_method"(type_obj, "dotty", $P7019)
    get_how $P7020, type_obj
    .const 'Sub' $P7021 = "530_1303857440.612" 
    $P7020."add_method"(type_obj, "term:sym<self>", $P7021)
    get_how $P7022, type_obj
    .const 'Sub' $P7023 = "531_1303857440.612" 
    $P7022."add_method"(type_obj, "term:sym<identifier>", $P7023)
    get_how $P7024, type_obj
    .const 'Sub' $P7025 = "532_1303857440.612" 
    $P7024."add_method"(type_obj, "term:sym<name>", $P7025)
    get_how $P7026, type_obj
    .const 'Sub' $P7027 = "534_1303857440.612" 
    $P7026."add_method"(type_obj, "term:sym<pir::op>", $P7027)
    get_how $P7028, type_obj
    .const 'Sub' $P7029 = "535_1303857440.612" 
    $P7028."add_method"(type_obj, "term:sym<onlystar>", $P7029)
    get_how $P7030, type_obj
    .const 'Sub' $P7031 = "536_1303857440.612" 
    $P7030."add_method"(type_obj, "args", $P7031)
    get_how $P7032, type_obj
    .const 'Sub' $P7033 = "537_1303857440.612" 
    $P7032."add_method"(type_obj, "arglist", $P7033)
    get_how $P7034, type_obj
    .const 'Sub' $P7035 = "540_1303857440.612" 
    $P7034."add_method"(type_obj, "term:sym<multi_declarator>", $P7035)
    get_how $P7036, type_obj
    .const 'Sub' $P7037 = "541_1303857440.612" 
    $P7036."add_method"(type_obj, "term:sym<value>", $P7037)
    get_how $P7038, type_obj
    .const 'Sub' $P7039 = "542_1303857440.612" 
    $P7038."add_method"(type_obj, "circumfix:sym<( )>", $P7039)
    get_how $P7040, type_obj
    .const 'Sub' $P7041 = "543_1303857440.612" 
    $P7040."add_method"(type_obj, "circumfix:sym<[ ]>", $P7041)
    get_how $P7042, type_obj
    .const 'Sub' $P7043 = "544_1303857440.612" 
    $P7042."add_method"(type_obj, "circumfix:sym<ang>", $P7043)
    get_how $P7044, type_obj
    .const 'Sub' $P7045 = "545_1303857440.612" 
    $P7044."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7045)
    get_how $P7046, type_obj
    .const 'Sub' $P7047 = "546_1303857440.612" 
    $P7046."add_method"(type_obj, "circumfix:sym<{ }>", $P7047)
    get_how $P7048, type_obj
    .const 'Sub' $P7049 = "548_1303857440.612" 
    $P7048."add_method"(type_obj, "circumfix:sym<sigil>", $P7049)
    get_how $P7050, type_obj
    .const 'Sub' $P7051 = "549_1303857440.612" 
    $P7050."add_method"(type_obj, "semilist", $P7051)
    get_how $P7052, type_obj
    .const 'Sub' $P7053 = "550_1303857440.612" 
    $P7052."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P7053)
    get_how $P7054, type_obj
    .const 'Sub' $P7055 = "551_1303857440.612" 
    $P7054."add_method"(type_obj, "postcircumfix:sym<{ }>", $P7055)
    get_how $P7056, type_obj
    .const 'Sub' $P7057 = "552_1303857440.612" 
    $P7056."add_method"(type_obj, "postcircumfix:sym<ang>", $P7057)
    get_how $P7058, type_obj
    .const 'Sub' $P7059 = "553_1303857440.612" 
    $P7058."add_method"(type_obj, "postcircumfix:sym<( )>", $P7059)
    get_how $P7060, type_obj
    .const 'Sub' $P7061 = "554_1303857440.612" 
    $P7060."add_method"(type_obj, "value", $P7061)
    get_how $P7062, type_obj
    .const 'Sub' $P7063 = "555_1303857440.612" 
    $P7062."add_method"(type_obj, "number", $P7063)
    get_how $P7064, type_obj
    .const 'Sub' $P7065 = "556_1303857440.612" 
    $P7064."add_method"(type_obj, "quote:sym<apos>", $P7065)
    get_how $P7066, type_obj
    .const 'Sub' $P7067 = "557_1303857440.612" 
    $P7066."add_method"(type_obj, "quote:sym<dblq>", $P7067)
    get_how $P7068, type_obj
    .const 'Sub' $P7069 = "558_1303857440.612" 
    $P7068."add_method"(type_obj, "quote:sym<qq>", $P7069)
    get_how $P7070, type_obj
    .const 'Sub' $P7071 = "559_1303857440.612" 
    $P7070."add_method"(type_obj, "quote:sym<q>", $P7071)
    get_how $P7072, type_obj
    .const 'Sub' $P7073 = "560_1303857440.612" 
    $P7072."add_method"(type_obj, "quote:sym<Q>", $P7073)
    get_how $P7074, type_obj
    .const 'Sub' $P7075 = "561_1303857440.612" 
    $P7074."add_method"(type_obj, "quote:sym<Q:PIR>", $P7075)
    get_how $P7076, type_obj
    .const 'Sub' $P7077 = "562_1303857440.612" 
    $P7076."add_method"(type_obj, "quote:sym</ />", $P7077)
    get_how $P7078, type_obj
    .const 'Sub' $P7079 = "563_1303857440.612" 
    $P7078."add_method"(type_obj, "quote_escape:sym<$>", $P7079)
    get_how $P7080, type_obj
    .const 'Sub' $P7081 = "564_1303857440.612" 
    $P7080."add_method"(type_obj, "quote_escape:sym<{ }>", $P7081)
    get_how $P7082, type_obj
    .const 'Sub' $P7083 = "565_1303857440.612" 
    $P7082."add_method"(type_obj, "quote_escape:sym<esc>", $P7083)
    get_how $P7084, type_obj
    .const 'Sub' $P7085 = "566_1303857440.612" 
    $P7084."add_method"(type_obj, "postfix:sym<.>", $P7085)
    get_how $P7086, type_obj
    .const 'Sub' $P7087 = "567_1303857440.612" 
    $P7086."add_method"(type_obj, "postfix:sym<++>", $P7087)
    get_how $P7088, type_obj
    .const 'Sub' $P7089 = "568_1303857440.612" 
    $P7088."add_method"(type_obj, "postfix:sym<-->", $P7089)
    get_how $P7090, type_obj
    .const 'Sub' $P7091 = "569_1303857440.612" 
    $P7090."add_method"(type_obj, "prefix:sym<make>", $P7091)
    get_how $P7092, type_obj
    .const 'Sub' $P7093 = "570_1303857440.612" 
    $P7092."add_method"(type_obj, "term:sym<next>", $P7093)
    get_how $P7094, type_obj
    .const 'Sub' $P7095 = "571_1303857440.612" 
    $P7094."add_method"(type_obj, "term:sym<last>", $P7095)
    get_how $P7096, type_obj
    .const 'Sub' $P7097 = "572_1303857440.612" 
    $P7096."add_method"(type_obj, "term:sym<redo>", $P7097)
    get_how $P7098, type_obj
    .const 'Sub' $P7099 = "573_1303857440.612" 
    $P7098."add_method"(type_obj, "infix:sym<~~>", $P7099)
    get_how $P7100, type_obj
    $P7101 = $P7100."compose"(type_obj)
    .return ($P7101)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2755
.annotate 'line', 771
    .lex "$xblock", param_2755
.annotate 'line', 772
    find_lex $P2756, "$xblock"
    unless_null $P2756, vivify_1459
    $P2756 = root_new ['parrot';'ResizablePMCArray']
  vivify_1459:
    set $P2757, $P2756[1]
    unless_null $P2757, vivify_1460
    new $P2757, "Undef"
  vivify_1460:
    $P2758 = "block_immediate"($P2757)
    find_lex $P2759, "$xblock"
    unless_null $P2759, vivify_1461
    $P2759 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2759
  vivify_1461:
    set $P2759[1], $P2758
    find_lex $P2760, "$xblock"
    unless_null $P2760, vivify_1462
    new $P2760, "Undef"
  vivify_1462:
.annotate 'line', 771
    .return ($P2760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2763
.annotate 'line', 776
    .const 'Sub' $P2773 = "409_1303857440.612" 
    capture_lex $P2773
    .lex "$block", param_2763
.annotate 'line', 777
    find_lex $P2764, "$block"
    unless_null $P2764, vivify_1463
    new $P2764, "Undef"
  vivify_1463:
    $P2764."blocktype"("immediate")
.annotate 'line', 778
    find_lex $P2768, "$block"
    unless_null $P2768, vivify_1464
    new $P2768, "Undef"
  vivify_1464:
    $P2769 = $P2768."symtable"()
    unless $P2769, unless_2767
    set $P2766, $P2769
    goto unless_2767_end
  unless_2767:
    find_lex $P2770, "$block"
    unless_null $P2770, vivify_1465
    new $P2770, "Undef"
  vivify_1465:
    $P2771 = $P2770."handlers"()
    set $P2766, $P2771
  unless_2767_end:
    if $P2766, unless_2765_end
    .const 'Sub' $P2773 = "409_1303857440.612" 
    capture_lex $P2773
    $P2773()
  unless_2765_end:
    find_lex $P2796, "$block"
    unless_null $P2796, vivify_1472
    new $P2796, "Undef"
  vivify_1472:
.annotate 'line', 776
    .return ($P2796)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2772"  :anon :subid("409_1303857440.612") :outer("408_1303857440.612")
.annotate 'line', 778
    .const 'Sub' $P2787 = "410_1303857440.612" 
    capture_lex $P2787
.annotate 'line', 779
    new $P2774, "Undef"
    .lex "$stmts", $P2774
    get_hll_global $P2775, "GLOBAL"
    nqp_get_package_through_who $P2776, $P2775, "PAST"
    get_who $P2777, $P2776
    set $P2778, $P2777["Stmts"]
    find_lex $P2779, "$block"
    unless_null $P2779, vivify_1466
    new $P2779, "Undef"
  vivify_1466:
    $P2780 = $P2778."new"($P2779 :named("node"))
    store_lex "$stmts", $P2780
.annotate 'line', 780
    find_lex $P2782, "$block"
    unless_null $P2782, vivify_1467
    new $P2782, "Undef"
  vivify_1467:
    $P2783 = $P2782."list"()
    defined $I2784, $P2783
    unless $I2784, for_undef_1468
    iter $P2781, $P2783
    new $P2793, 'ExceptionHandler'
    set_label $P2793, loop2792_handler
    $P2793."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2793
  loop2792_test:
    unless $P2781, loop2792_done
    shift $P2785, $P2781
  loop2792_redo:
    .const 'Sub' $P2787 = "410_1303857440.612" 
    capture_lex $P2787
    $P2787($P2785)
  loop2792_next:
    goto loop2792_test
  loop2792_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2794, exception, 'type'
    eq $P2794, .CONTROL_LOOP_NEXT, loop2792_next
    eq $P2794, .CONTROL_LOOP_REDO, loop2792_redo
  loop2792_done:
    pop_eh 
  for_undef_1468:
.annotate 'line', 781
    find_lex $P2795, "$stmts"
    unless_null $P2795, vivify_1471
    new $P2795, "Undef"
  vivify_1471:
    store_lex "$block", $P2795
.annotate 'line', 778
    .return ($P2795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2786"  :anon :subid("410_1303857440.612") :outer("409_1303857440.612")
    .param pmc param_2788
.annotate 'line', 780
    .lex "$_", param_2788
    find_lex $P2789, "$stmts"
    unless_null $P2789, vivify_1469
    new $P2789, "Undef"
  vivify_1469:
    find_lex $P2790, "$_"
    unless_null $P2790, vivify_1470
    new $P2790, "Undef"
  vivify_1470:
    $P2791 = $P2789."push"($P2790)
    .return ($P2791)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2799
.annotate 'line', 786
    .lex "$sigil", param_2799
.annotate 'line', 787
    find_lex $P2802, "$sigil"
    unless_null $P2802, vivify_1473
    new $P2802, "Undef"
  vivify_1473:
    set $S2803, $P2802
    iseq $I2804, $S2803, "%"
    if $I2804, if_2801
.annotate 'line', 789
    find_lex $P2812, "$sigil"
    unless_null $P2812, vivify_1474
    new $P2812, "Undef"
  vivify_1474:
    set $S2813, $P2812
    iseq $I2814, $S2813, "@"
    if $I2814, if_2811
    new $P2820, "String"
    assign $P2820, "Undef"
    set $P2810, $P2820
    goto if_2811_end
  if_2811:
.annotate 'line', 790
    get_hll_global $P2815, "GLOBAL"
    nqp_get_package_through_who $P2816, $P2815, "PAST"
    get_who $P2817, $P2816
    set $P2818, $P2817["Op"]
    $P2819 = $P2818."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2810, $P2819
  if_2811_end:
    set $P2800, $P2810
.annotate 'line', 787
    goto if_2801_end
  if_2801:
.annotate 'line', 788
    get_hll_global $P2805, "GLOBAL"
    nqp_get_package_through_who $P2806, $P2805, "PAST"
    get_who $P2807, $P2806
    set $P2808, $P2807["Op"]
    $P2809 = $P2808."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2800, $P2809
  if_2801_end:
.annotate 'line', 786
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2823
.annotate 'line', 805
    .lex "$ast", param_2823
.annotate 'line', 806
    get_hll_global $P2826, "GLOBAL"
    nqp_get_package_through_who $P2827, $P2826, "PAST"
    get_who $P2828, $P2827
    set $P2829, $P2828["Op"]
    find_lex $P2830, "$ast"
    unless_null $P2830, vivify_1475
    new $P2830, "Undef"
  vivify_1475:
    $P2831 = $P2829."ACCEPTS"($P2830)
    if $P2831, if_2825
.annotate 'line', 808
    find_lex $P2835, "$ast"
    unless_null $P2835, vivify_1476
    new $P2835, "Undef"
  vivify_1476:
    $P2836 = $P2835."value"()
    set $P2824, $P2836
.annotate 'line', 806
    goto if_2825_end
  if_2825:
.annotate 'line', 807
    find_lex $P2832, "$ast"
    unless_null $P2832, vivify_1477
    new $P2832, "Undef"
  vivify_1477:
    $P2833 = $P2832."list"()
    join $S2834, " ", $P2833
    new $P2824, 'String'
    set $P2824, $S2834
  if_2825_end:
.annotate 'line', 805
    .return ($P2824)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("413_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2839
.annotate 'line', 967
    .const 'Sub' $P2851 = "414_1303857440.612" 
    capture_lex $P2851
    .lex "$UNIT", param_2839
.annotate 'line', 969
    find_lex $P2842, "$UNIT"
    unless_null $P2842, vivify_1478
    new $P2842, "Undef"
  vivify_1478:
    exists $I2843, $P2842["EXPORTHOW"]
    if $I2843, if_2841
    new $P2840, 'Integer'
    set $P2840, $I2843
    goto if_2841_end
  if_2841:
.annotate 'line', 970
    find_lex $P2845, "$UNIT"
    unless_null $P2845, vivify_1479
    $P2845 = root_new ['parrot';'Hash']
  vivify_1479:
    set $P2846, $P2845["EXPORTHOW"]
    unless_null $P2846, vivify_1480
    new $P2846, "Undef"
  vivify_1480:
    get_who $P2847, $P2846
    defined $I2848, $P2847
    unless $I2848, for_undef_1481
    iter $P2844, $P2847
    new $P2861, 'ExceptionHandler'
    set_label $P2861, loop2860_handler
    $P2861."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2861
  loop2860_test:
    unless $P2844, loop2860_done
    shift $P2849, $P2844
  loop2860_redo:
    .const 'Sub' $P2851 = "414_1303857440.612" 
    capture_lex $P2851
    $P2851($P2849)
  loop2860_next:
    goto loop2860_test
  loop2860_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2862, exception, 'type'
    eq $P2862, .CONTROL_LOOP_NEXT, loop2860_next
    eq $P2862, .CONTROL_LOOP_REDO, loop2860_redo
  loop2860_done:
    pop_eh 
  for_undef_1481:
.annotate 'line', 969
    set $P2840, $P2844
  if_2841_end:
.annotate 'line', 967
    .return ($P2840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2850"  :anon :subid("414_1303857440.612") :outer("413_1303857440.612")
    .param pmc param_2852
.annotate 'line', 970
    .lex "$_", param_2852
.annotate 'line', 971
    find_lex $P2853, "$_"
    unless_null $P2853, vivify_1482
    new $P2853, "Undef"
  vivify_1482:
    $P2854 = $P2853."value"()
    find_lex $P2855, "$_"
    unless_null $P2855, vivify_1483
    new $P2855, "Undef"
  vivify_1483:
    $P2856 = $P2855."key"()
    find_dynamic_lex $P2859, "%*HOW"
    unless_null $P2859, vivify_1484
    get_hll_global $P2857, "GLOBAL"
    get_who $P2858, $P2857
    set $P2859, $P2858["%HOW"]
    unless_null $P2859, vivify_1485
    die "Contextual %*HOW not found"
  vivify_1485:
    store_dynamic_lex "%*HOW", $P2859
  vivify_1484:
    set $P2859[$P2856], $P2854
.annotate 'line', 970
    .return ($P2854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("415_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2865
    .param pmc param_2866
.annotate 'line', 1072
    .lex "$/", param_2865
    .lex "$block", param_2866
.annotate 'line', 1073
    find_lex $P2868, "$?PACKAGE"
    get_who $P2869, $P2868
    set $P2870, $P2869["@BLOCK"]
    unless_null $P2870, vivify_1486
    $P2870 = root_new ['parrot';'ResizablePMCArray']
  vivify_1486:
    set $P2871, $P2870[0]
    unless_null $P2871, vivify_1487
    new $P2871, "Undef"
  vivify_1487:
    $P2872 = $P2871."handlers"()
    if $P2872, unless_2867_end
.annotate 'line', 1074
    find_lex $P2873, "$?PACKAGE"
    get_who $P2874, $P2873
    set $P2875, $P2874["@BLOCK"]
    unless_null $P2875, vivify_1488
    $P2875 = root_new ['parrot';'ResizablePMCArray']
  vivify_1488:
    set $P2876, $P2875[0]
    unless_null $P2876, vivify_1489
    new $P2876, "Undef"
  vivify_1489:
    new $P2877, "ResizablePMCArray"
    $P2876."handlers"($P2877)
  unless_2867_end:
.annotate 'line', 1076
    find_lex $P2879, "$block"
    unless_null $P2879, vivify_1490
    new $P2879, "Undef"
  vivify_1490:
    $P2880 = $P2879."arity"()
    if $P2880, unless_2878_end
.annotate 'line', 1077
    find_lex $P2881, "$block"
    unless_null $P2881, vivify_1491
    new $P2881, "Undef"
  vivify_1491:
.annotate 'line', 1078
    get_hll_global $P2882, "GLOBAL"
    nqp_get_package_through_who $P2883, $P2882, "PAST"
    get_who $P2884, $P2883
    set $P2885, $P2884["Op"]
.annotate 'line', 1079
    get_hll_global $P2886, "GLOBAL"
    nqp_get_package_through_who $P2887, $P2886, "PAST"
    get_who $P2888, $P2887
    set $P2889, $P2888["Var"]
    $P2890 = $P2889."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1080
    get_hll_global $P2891, "GLOBAL"
    nqp_get_package_through_who $P2892, $P2891, "PAST"
    get_who $P2893, $P2892
    set $P2894, $P2893["Var"]
    $P2895 = $P2894."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2896 = $P2885."new"($P2890, $P2895, "bind" :named("pasttype"))
.annotate 'line', 1078
    $P2881."unshift"($P2896)
.annotate 'line', 1083
    find_lex $P2897, "$block"
    unless_null $P2897, vivify_1492
    new $P2897, "Undef"
  vivify_1492:
    get_hll_global $P2898, "GLOBAL"
    nqp_get_package_through_who $P2899, $P2898, "PAST"
    get_who $P2900, $P2899
    set $P2901, $P2900["Var"]
    $P2902 = $P2901."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2897."unshift"($P2902)
.annotate 'line', 1084
    find_lex $P2903, "$block"
    unless_null $P2903, vivify_1493
    new $P2903, "Undef"
  vivify_1493:
    $P2903."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1085
    find_lex $P2904, "$block"
    unless_null $P2904, vivify_1494
    new $P2904, "Undef"
  vivify_1494:
    $P2904."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1086
    find_lex $P2905, "$block"
    unless_null $P2905, vivify_1495
    new $P2905, "Undef"
  vivify_1495:
    $P2905."arity"(1)
  unless_2878_end:
.annotate 'line', 1088
    find_lex $P2906, "$block"
    unless_null $P2906, vivify_1496
    new $P2906, "Undef"
  vivify_1496:
    $P2906."blocktype"("declaration")
.annotate 'line', 1089
    find_lex $P2907, "$?PACKAGE"
    get_who $P2908, $P2907
    set $P2909, $P2908["@BLOCK"]
    unless_null $P2909, vivify_1497
    $P2909 = root_new ['parrot';'ResizablePMCArray']
  vivify_1497:
    set $P2910, $P2909[0]
    unless_null $P2910, vivify_1498
    new $P2910, "Undef"
  vivify_1498:
    $P2911 = $P2910."handlers"()
.annotate 'line', 1090
    get_hll_global $P2912, "GLOBAL"
    nqp_get_package_through_who $P2913, $P2912, "PAST"
    get_who $P2914, $P2913
    set $P2915, $P2914["Control"]
    find_lex $P2916, "$/"
    unless_null $P2916, vivify_1499
    new $P2916, "Undef"
  vivify_1499:
.annotate 'line', 1092
    get_hll_global $P2917, "GLOBAL"
    nqp_get_package_through_who $P2918, $P2917, "PAST"
    get_who $P2919, $P2918
    set $P2920, $P2919["Stmts"]
.annotate 'line', 1093
    get_hll_global $P2921, "GLOBAL"
    nqp_get_package_through_who $P2922, $P2921, "PAST"
    get_who $P2923, $P2922
    set $P2924, $P2923["Op"]
    find_lex $P2925, "$block"
    unless_null $P2925, vivify_1500
    new $P2925, "Undef"
  vivify_1500:
.annotate 'line', 1095
    get_hll_global $P2926, "GLOBAL"
    nqp_get_package_through_who $P2927, $P2926, "PAST"
    get_who $P2928, $P2927
    set $P2929, $P2928["Var"]
    $P2930 = $P2929."new"("register" :named("scope"), "exception" :named("name"))
    $P2931 = $P2924."new"($P2925, $P2930, "call" :named("pasttype"))
.annotate 'line', 1097
    get_hll_global $P2932, "GLOBAL"
    nqp_get_package_through_who $P2933, $P2932, "PAST"
    get_who $P2934, $P2933
    set $P2935, $P2934["Op"]
.annotate 'line', 1098
    get_hll_global $P2936, "GLOBAL"
    nqp_get_package_through_who $P2937, $P2936, "PAST"
    get_who $P2938, $P2937
    set $P2939, $P2938["Var"]
.annotate 'line', 1099
    get_hll_global $P2940, "GLOBAL"
    nqp_get_package_through_who $P2941, $P2940, "PAST"
    get_who $P2942, $P2941
    set $P2943, $P2942["Var"]
    $P2944 = $P2943."new"("register" :named("scope"), "exception" :named("name"))
    $P2945 = $P2939."new"($P2944, "handled", "keyed" :named("scope"))
.annotate 'line', 1098
    $P2946 = $P2935."new"($P2945, 1, "bind" :named("pasttype"))
.annotate 'line', 1097
    $P2947 = $P2920."new"($P2931, $P2946)
.annotate 'line', 1092
    $P2948 = $P2915."new"($P2947, $P2916 :named("node"))
.annotate 'line', 1090
    $P2949 = $P2911."unshift"($P2948)
.annotate 'line', 1072
    .return ($P2949)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("416_1303857440.612") :outer("406_1303857440.612")
.annotate 'line', 1611
    new $P2952, "Undef"
    .lex "$past", $P2952
    find_lex $P2953, "$?PACKAGE"
    get_who $P2954, $P2953
    set $P2955, $P2954["@BLOCK"]
    unless_null $P2955, vivify_1501
    $P2955 = root_new ['parrot';'ResizablePMCArray']
  vivify_1501:
    $P2956 = $P2955."shift"()
    store_lex "$past", $P2956
.annotate 'line', 1612
    find_lex $P2957, "$past"
    unless_null $P2957, vivify_1502
    new $P2957, "Undef"
  vivify_1502:
    $P2957."closure"(1)
.annotate 'line', 1613
    find_lex $P2958, "$past"
    unless_null $P2958, vivify_1503
    new $P2958, "Undef"
  vivify_1503:
    get_hll_global $P2959, "GLOBAL"
    nqp_get_package_through_who $P2960, $P2959, "PAST"
    get_who $P2961, $P2960
    set $P2962, $P2961["Op"]
    $P2963 = $P2962."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2958."push"($P2963)
    find_lex $P2964, "$past"
    unless_null $P2964, vivify_1504
    new $P2964, "Undef"
  vivify_1504:
.annotate 'line', 1610
    .return ($P2964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("417_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_2967
.annotate 'line', 1619
    .const 'Sub' $P2987 = "418_1303857440.612" 
    capture_lex $P2987
    .lex "$routine", param_2967
.annotate 'line', 1623
    new $P2968, "Undef"
    .lex "$types", $P2968
.annotate 'line', 1624
    new $P2969, "Undef"
    .lex "$definednesses", $P2969
.annotate 'line', 1623
    get_hll_global $P2970, "GLOBAL"
    nqp_get_package_through_who $P2971, $P2970, "PAST"
    get_who $P2972, $P2971
    set $P2973, $P2972["Op"]
    $P2974 = $P2973."new"("list" :named("pasttype"))
    store_lex "$types", $P2974
.annotate 'line', 1624
    get_hll_global $P2975, "GLOBAL"
    nqp_get_package_through_who $P2976, $P2975, "PAST"
    get_who $P2977, $P2976
    set $P2978, $P2977["Op"]
    $P2979 = $P2978."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2979
.annotate 'line', 1625
    find_lex $P2981, "$routine"
    unless_null $P2981, vivify_1505
    $P2981 = root_new ['parrot';'ResizablePMCArray']
  vivify_1505:
    set $P2982, $P2981[0]
    unless_null $P2982, vivify_1506
    new $P2982, "Undef"
  vivify_1506:
    $P2983 = $P2982."list"()
    defined $I2984, $P2983
    unless $I2984, for_undef_1507
    iter $P2980, $P2983
    new $P3031, 'ExceptionHandler'
    set_label $P3031, loop3030_handler
    $P3031."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3031
  loop3030_test:
    unless $P2980, loop3030_done
    shift $P2985, $P2980
  loop3030_redo:
    .const 'Sub' $P2987 = "418_1303857440.612" 
    capture_lex $P2987
    $P2987($P2985)
  loop3030_next:
    goto loop3030_test
  loop3030_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3032, exception, 'type'
    eq $P3032, .CONTROL_LOOP_NEXT, loop3030_next
    eq $P3032, .CONTROL_LOOP_REDO, loop3030_redo
  loop3030_done:
    pop_eh 
  for_undef_1507:
.annotate 'line', 1632
    find_lex $P3033, "$routine"
    unless_null $P3033, vivify_1517
    new $P3033, "Undef"
  vivify_1517:
    $P3034 = $P3033."loadinit"()
    get_hll_global $P3035, "GLOBAL"
    nqp_get_package_through_who $P3036, $P3035, "PAST"
    get_who $P3037, $P3036
    set $P3038, $P3037["Op"]
.annotate 'line', 1633
    get_hll_global $P3039, "GLOBAL"
    nqp_get_package_through_who $P3040, $P3039, "PAST"
    get_who $P3041, $P3040
    set $P3042, $P3041["Var"]
    $P3043 = $P3042."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P3044, "$types"
    unless_null $P3044, vivify_1518
    new $P3044, "Undef"
  vivify_1518:
    find_lex $P3045, "$definednesses"
    unless_null $P3045, vivify_1519
    new $P3045, "Undef"
  vivify_1519:
    $P3046 = $P3038."new"($P3043, $P3044, $P3045, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1632
    $P3047 = $P3034."push"($P3046)
.annotate 'line', 1619
    .return ($P3047)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2986"  :anon :subid("418_1303857440.612") :outer("417_1303857440.612")
    .param pmc param_2988
.annotate 'line', 1625
    .lex "$_", param_2988
.annotate 'line', 1626
    get_hll_global $P2993, "GLOBAL"
    nqp_get_package_through_who $P2994, $P2993, "PAST"
    get_who $P2995, $P2994
    set $P2996, $P2995["Var"]
    find_lex $P2997, "$_"
    unless_null $P2997, vivify_1508
    new $P2997, "Undef"
  vivify_1508:
    $P2998 = $P2996."ACCEPTS"($P2997)
    if $P2998, if_2992
    set $P2991, $P2998
    goto if_2992_end
  if_2992:
    find_lex $P2999, "$_"
    unless_null $P2999, vivify_1509
    new $P2999, "Undef"
  vivify_1509:
    $S3000 = $P2999."scope"()
    iseq $I3001, $S3000, "parameter"
    new $P2991, 'Integer'
    set $P2991, $I3001
  if_2992_end:
    if $P2991, if_2990
    set $P2989, $P2991
    goto if_2990_end
  if_2990:
.annotate 'line', 1627
    find_lex $P3002, "$types"
    unless_null $P3002, vivify_1510
    new $P3002, "Undef"
  vivify_1510:
    find_lex $P3004, "$_"
    unless_null $P3004, vivify_1511
    new $P3004, "Undef"
  vivify_1511:
    $P3005 = $P3004."multitype"()
    set $P3003, $P3005
    defined $I3007, $P3003
    if $I3007, default_3006
    get_hll_global $P3008, "GLOBAL"
    nqp_get_package_through_who $P3009, $P3008, "PAST"
    get_who $P3010, $P3009
    set $P3011, $P3010["Op"]
    $P3012 = $P3011."new"("null P" :named("pirop"))
    set $P3003, $P3012
  default_3006:
    $P3002."push"($P3003)
.annotate 'line', 1628
    find_lex $P3013, "$definednesses"
    unless_null $P3013, vivify_1512
    new $P3013, "Undef"
  vivify_1512:
    find_lex $P3016, "$_"
    unless_null $P3016, vivify_1513
    $P3016 = root_new ['parrot';'Hash']
  vivify_1513:
    set $P3017, $P3016["definedness"]
    unless_null $P3017, vivify_1514
    new $P3017, "Undef"
  vivify_1514:
    set $S3018, $P3017
    iseq $I3019, $S3018, "D"
    if $I3019, if_3015
.annotate 'line', 1629
    find_lex $P3023, "$_"
    unless_null $P3023, vivify_1515
    $P3023 = root_new ['parrot';'Hash']
  vivify_1515:
    set $P3024, $P3023["definedness"]
    unless_null $P3024, vivify_1516
    new $P3024, "Undef"
  vivify_1516:
    set $S3025, $P3024
    iseq $I3026, $S3025, "U"
    if $I3026, if_3022
    new $P3028, "Integer"
    assign $P3028, 0
    set $P3021, $P3028
    goto if_3022_end
  if_3022:
    new $P3027, "Integer"
    assign $P3027, 2
    set $P3021, $P3027
  if_3022_end:
    set $P3014, $P3021
.annotate 'line', 1628
    goto if_3015_end
  if_3015:
    new $P3020, "Integer"
    assign $P3020, 1
    set $P3014, $P3020
  if_3015_end:
    $P3029 = $P3013."push"($P3014)
.annotate 'line', 1626
    set $P2989, $P3029
  if_2990_end:
.annotate 'line', 1625
    .return ($P2989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("419_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3050
    .param pmc param_3051
.annotate 'line', 2085
    .lex "$/", param_3050
    .lex "$type", param_3051
.annotate 'line', 2086
    find_lex $P3052, "$/"
    get_hll_global $P3053, "GLOBAL"
    nqp_get_package_through_who $P3054, $P3053, "PAST"
    get_who $P3055, $P3054
    set $P3056, $P3055["Op"]
    find_lex $P3057, "$/"
    unless_null $P3057, vivify_1520
    new $P3057, "Undef"
  vivify_1520:
.annotate 'line', 2090
    get_hll_global $P3058, "GLOBAL"
    nqp_get_package_through_who $P3059, $P3058, "PAST"
    get_who $P3060, $P3059
    set $P3061, $P3060["Val"]
    find_lex $P3062, "$type"
    unless_null $P3062, vivify_1521
    new $P3062, "Undef"
  vivify_1521:
    $P3063 = $P3061."new"($P3062 :named("value"), "!except_types" :named("returns"))
    $P3064 = $P3056."new"(0, $P3063, $P3057 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2086
    $P3065 = $P3052."!make"($P3064)
.annotate 'line', 2085
    .return ($P3065)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("420_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3070
    .param pmc param_3071
.annotate 'line', 2104
    .const 'Sub' $P3124 = "421_1303857440.612" 
    capture_lex $P3124
    new $P3069, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3069, control_3068
    push_eh $P3069
    .lex "@name", param_3070
    .lex "$/", param_3071
.annotate 'line', 2110
    new $P3072, "Undef"
    .lex "$final_name", $P3072
.annotate 'line', 2111
    new $P3073, "Undef"
    .lex "$lookup", $P3073
.annotate 'line', 2106
    find_lex $P3075, "@name"
    unless_null $P3075, vivify_1522
    $P3075 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    set $N3076, $P3075
    iseq $I3077, $N3076, 0.0
    unless $I3077, if_3074_end
    find_lex $P3078, "$/"
    unless_null $P3078, vivify_1523
    new $P3078, "Undef"
  vivify_1523:
    $P3079 = $P3078."CURSOR"()
    $P3079."panic"("Cannot compile empty name")
  if_3074_end:
.annotate 'line', 2110
    find_lex $P3080, "@name"
    unless_null $P3080, vivify_1524
    $P3080 = root_new ['parrot';'ResizablePMCArray']
  vivify_1524:
    $P3081 = $P3080."pop"()
    store_lex "$final_name", $P3081
.annotate 'line', 2111
    get_hll_global $P3082, "GLOBAL"
    nqp_get_package_through_who $P3083, $P3082, "PAST"
    get_who $P3084, $P3083
    set $P3085, $P3084["Var"]
    find_lex $P3086, "$final_name"
    unless_null $P3086, vivify_1525
    new $P3086, "Undef"
  vivify_1525:
    set $S3087, $P3086
    $P3088 = $P3085."new"($S3087, "keyed" :named("scope"))
    store_lex "$lookup", $P3088
.annotate 'line', 2115
    find_lex $P3090, "@name"
    unless_null $P3090, vivify_1526
    $P3090 = root_new ['parrot';'ResizablePMCArray']
  vivify_1526:
    set $N3091, $P3090
    iseq $I3092, $N3091, 0.0
    if $I3092, if_3089
.annotate 'line', 2133
    .const 'Sub' $P3124 = "421_1303857440.612" 
    capture_lex $P3124
    $P3124()
    goto if_3089_end
  if_3089:
.annotate 'line', 2116
    find_lex $P3093, "$lookup"
    unless_null $P3093, vivify_1539
    new $P3093, "Undef"
  vivify_1539:
    get_hll_global $P3094, "GLOBAL"
    nqp_get_package_through_who $P3095, $P3094, "PAST"
    get_who $P3096, $P3095
    set $P3097, $P3096["Op"]
.annotate 'line', 2118
    get_hll_global $P3098, "GLOBAL"
    nqp_get_package_through_who $P3099, $P3098, "PAST"
    get_who $P3100, $P3099
    set $P3101, $P3100["Var"]
    $P3102 = $P3101."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3103 = $P3097."new"($P3102, "get_who PP" :named("pirop"))
.annotate 'line', 2116
    $P3093."unshift"($P3103)
.annotate 'line', 2120
    find_lex $P3104, "$lookup"
    unless_null $P3104, vivify_1540
    new $P3104, "Undef"
  vivify_1540:
    get_hll_global $P3105, "GLOBAL"
    nqp_get_package_through_who $P3106, $P3105, "PAST"
    get_who $P3107, $P3106
    set $P3108, $P3107["Var"]
.annotate 'line', 2122
    get_hll_global $P3109, "GLOBAL"
    nqp_get_package_through_who $P3110, $P3109, "PAST"
    get_who $P3111, $P3110
    set $P3112, $P3111["Op"]
.annotate 'line', 2124
    get_hll_global $P3113, "GLOBAL"
    nqp_get_package_through_who $P3114, $P3113, "PAST"
    get_who $P3115, $P3114
    set $P3116, $P3115["Var"]
    new $P3117, "ResizablePMCArray"
    $P3118 = $P3116."new"("GLOBAL" :named("name"), $P3117 :named("namespace"), "package" :named("scope"))
    $P3119 = $P3112."new"($P3118, "get_who PP" :named("pirop"))
.annotate 'line', 2126
    find_lex $P3120, "$final_name"
    unless_null $P3120, vivify_1541
    new $P3120, "Undef"
  vivify_1541:
    set $S3121, $P3120
    $P3122 = $P3108."new"($P3119, $S3121, "keyed" :named("scope"))
.annotate 'line', 2120
    $P3104."viviself"($P3122)
  if_3089_end:
.annotate 'line', 2148
    new $P3176, "Exception"
    set $P3176['type'], .CONTROL_RETURN
    find_lex $P3177, "$lookup"
    unless_null $P3177, vivify_1542
    new $P3177, "Undef"
  vivify_1542:
    setattribute $P3176, 'payload', $P3177
    throw $P3176
.annotate 'line', 2104
    .return ()
  control_3068:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3178, exception, "payload"
    .return ($P3178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3123"  :anon :subid("421_1303857440.612") :outer("420_1303857440.612")
.annotate 'line', 2133
    .const 'Sub' $P3155 = "422_1303857440.612" 
    capture_lex $P3155
.annotate 'line', 2134
    new $P3125, "Undef"
    .lex "$path", $P3125
    find_lex $P3128, "@name"
    unless_null $P3128, vivify_1527
    $P3128 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    set $P3129, $P3128[0]
    unless_null $P3129, vivify_1528
    new $P3129, "Undef"
  vivify_1528:
    $P3130 = "is_lexical"($P3129)
    if $P3130, if_3127
.annotate 'line', 2136
    get_hll_global $P3138, "GLOBAL"
    nqp_get_package_through_who $P3139, $P3138, "PAST"
    get_who $P3140, $P3139
    set $P3141, $P3140["Var"]
    new $P3142, "ResizablePMCArray"
    $P3143 = $P3141."new"("GLOBAL" :named("name"), $P3142 :named("namespace"), "package" :named("scope"))
    set $P3126, $P3143
.annotate 'line', 2134
    goto if_3127_end
  if_3127:
.annotate 'line', 2135
    get_hll_global $P3131, "GLOBAL"
    nqp_get_package_through_who $P3132, $P3131, "PAST"
    get_who $P3133, $P3132
    set $P3134, $P3133["Var"]
    find_lex $P3135, "@name"
    unless_null $P3135, vivify_1529
    $P3135 = root_new ['parrot';'ResizablePMCArray']
  vivify_1529:
    $P3136 = $P3135."shift"()
    $P3137 = $P3134."new"($P3136 :named("name"), "lexical" :named("scope"))
    set $P3126, $P3137
  if_3127_end:
.annotate 'line', 2134
    store_lex "$path", $P3126
.annotate 'line', 2137
    find_lex $P3145, "@name"
    unless_null $P3145, vivify_1530
    $P3145 = root_new ['parrot';'ResizablePMCArray']
  vivify_1530:
    set $P3146, $P3145[0]
    unless_null $P3146, vivify_1531
    new $P3146, "Undef"
  vivify_1531:
    set $S3147, $P3146
    iseq $I3148, $S3147, "GLOBAL"
    unless $I3148, if_3144_end
.annotate 'line', 2138
    find_lex $P3149, "@name"
    unless_null $P3149, vivify_1532
    $P3149 = root_new ['parrot';'ResizablePMCArray']
  vivify_1532:
    $P3149."shift"()
  if_3144_end:
.annotate 'line', 2140
    find_lex $P3151, "@name"
    unless_null $P3151, vivify_1533
    $P3151 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    defined $I3152, $P3151
    unless $I3152, for_undef_1534
    iter $P3150, $P3151
    new $P3166, 'ExceptionHandler'
    set_label $P3166, loop3165_handler
    $P3166."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3166
  loop3165_test:
    unless $P3150, loop3165_done
    shift $P3153, $P3150
  loop3165_redo:
    .const 'Sub' $P3155 = "422_1303857440.612" 
    capture_lex $P3155
    $P3155($P3153)
  loop3165_next:
    goto loop3165_test
  loop3165_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3167, exception, 'type'
    eq $P3167, .CONTROL_LOOP_NEXT, loop3165_next
    eq $P3167, .CONTROL_LOOP_REDO, loop3165_redo
  loop3165_done:
    pop_eh 
  for_undef_1534:
.annotate 'line', 2145
    find_lex $P3168, "$lookup"
    unless_null $P3168, vivify_1537
    new $P3168, "Undef"
  vivify_1537:
    get_hll_global $P3169, "GLOBAL"
    nqp_get_package_through_who $P3170, $P3169, "PAST"
    get_who $P3171, $P3170
    set $P3172, $P3171["Op"]
    find_lex $P3173, "$path"
    unless_null $P3173, vivify_1538
    new $P3173, "Undef"
  vivify_1538:
    $P3174 = $P3172."new"($P3173, "get_who PP" :named("pirop"))
    $P3175 = $P3168."unshift"($P3174)
.annotate 'line', 2133
    .return ($P3175)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3154"  :anon :subid("422_1303857440.612") :outer("421_1303857440.612")
    .param pmc param_3156
.annotate 'line', 2140
    .lex "$_", param_3156
.annotate 'line', 2141
    get_hll_global $P3157, "GLOBAL"
    nqp_get_package_through_who $P3158, $P3157, "PAST"
    get_who $P3159, $P3158
    set $P3160, $P3159["Op"]
    find_lex $P3161, "$path"
    unless_null $P3161, vivify_1535
    new $P3161, "Undef"
  vivify_1535:
.annotate 'line', 2143
    find_lex $P3162, "$_"
    unless_null $P3162, vivify_1536
    new $P3162, "Undef"
  vivify_1536:
    set $S3163, $P3162
    $P3164 = $P3160."new"($P3161, $S3163, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2141
    store_lex "$path", $P3164
.annotate 'line', 2140
    .return ($P3164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("423_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3181
.annotate 'line', 2153
    .lex "$name", param_3181
.annotate 'line', 2154
    find_lex $P3182, "$name"
    unless_null $P3182, vivify_1543
    new $P3182, "Undef"
  vivify_1543:
    $P3183 = "is_scope"($P3182, "lexical")
.annotate 'line', 2153
    .return ($P3183)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("424_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3186
.annotate 'line', 2159
    .lex "$name", param_3186
.annotate 'line', 2160
    find_lex $P3187, "$name"
    unless_null $P3187, vivify_1544
    new $P3187, "Undef"
  vivify_1544:
    $P3188 = "is_scope"($P3187, "package")
.annotate 'line', 2159
    .return ($P3188)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("425_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3193
    .param pmc param_3194
.annotate 'line', 2165
    .const 'Sub' $P3202 = "426_1303857440.612" 
    capture_lex $P3202
    new $P3192, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3192, control_3191
    push_eh $P3192
    .lex "$name", param_3193
    .lex "$wanted_scope", param_3194
.annotate 'line', 2166
    find_lex $P3196, "$?PACKAGE"
    get_who $P3197, $P3196
    set $P3198, $P3197["@BLOCK"]
    unless_null $P3198, vivify_1545
    $P3198 = root_new ['parrot';'ResizablePMCArray']
  vivify_1545:
    defined $I3199, $P3198
    unless $I3199, for_undef_1546
    iter $P3195, $P3198
    new $P3221, 'ExceptionHandler'
    set_label $P3221, loop3220_handler
    $P3221."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3221
  loop3220_test:
    unless $P3195, loop3220_done
    shift $P3200, $P3195
  loop3220_redo:
    .const 'Sub' $P3202 = "426_1303857440.612" 
    capture_lex $P3202
    $P3202($P3200)
  loop3220_next:
    goto loop3220_test
  loop3220_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3222, exception, 'type'
    eq $P3222, .CONTROL_LOOP_NEXT, loop3220_next
    eq $P3222, .CONTROL_LOOP_REDO, loop3220_redo
  loop3220_done:
    pop_eh 
  for_undef_1546:
.annotate 'line', 2165
    .return (0)
  control_3191:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3223, exception, "payload"
    .return ($P3223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3201"  :anon :subid("426_1303857440.612") :outer("425_1303857440.612")
    .param pmc param_3204
.annotate 'line', 2167
    $P3203 = root_new ['parrot';'Hash']
    .lex "%sym", $P3203
    .lex "$_", param_3204
    find_lex $P3205, "$_"
    unless_null $P3205, vivify_1547
    new $P3205, "Undef"
  vivify_1547:
    find_lex $P3206, "$name"
    unless_null $P3206, vivify_1548
    new $P3206, "Undef"
  vivify_1548:
    $P3207 = $P3205."symbol"($P3206)
    store_lex "%sym", $P3207
.annotate 'line', 2168
    find_lex $P3210, "%sym"
    unless_null $P3210, vivify_1549
    $P3210 = root_new ['parrot';'Hash']
  vivify_1549:
    set $N3211, $P3210
    if $N3211, if_3209
    new $P3208, 'Float'
    set $P3208, $N3211
    goto if_3209_end
  if_3209:
.annotate 'line', 2169
    new $P3212, "Exception"
    set $P3212['type'], .CONTROL_RETURN
    find_lex $P3213, "%sym"
    unless_null $P3213, vivify_1550
    $P3213 = root_new ['parrot';'Hash']
  vivify_1550:
    set $P3214, $P3213["scope"]
    unless_null $P3214, vivify_1551
    new $P3214, "Undef"
  vivify_1551:
    set $S3215, $P3214
    find_lex $P3216, "$wanted_scope"
    unless_null $P3216, vivify_1552
    new $P3216, "Undef"
  vivify_1552:
    set $S3217, $P3216
    iseq $I3218, $S3215, $S3217
    new $P3219, 'Integer'
    set $P3219, $I3218
    setattribute $P3212, 'payload', $P3219
    throw $P3212
  if_3209_end:
.annotate 'line', 2166
    .return ($P3208)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("427_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3228
    .param pmc param_3229
.annotate 'line', 2178
    .const 'Sub' $P3323 = "432_1303857440.612" 
    capture_lex $P3323
    .const 'Sub' $P3283 = "430_1303857440.612" 
    capture_lex $P3283
    .const 'Sub' $P3241 = "428_1303857440.612" 
    capture_lex $P3241
    new $P3227, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3227, control_3226
    push_eh $P3227
    .lex "@name", param_3228
    .lex "$/", param_3229
.annotate 'line', 2202
    new $P3230, "Undef"
    .lex "$result", $P3230
.annotate 'line', 2180
    find_lex $P3232, "@name"
    unless_null $P3232, vivify_1553
    $P3232 = root_new ['parrot';'ResizablePMCArray']
  vivify_1553:
    set $N3233, $P3232
    if $N3233, unless_3231_end
    find_lex $P3234, "$/"
    unless_null $P3234, vivify_1554
    new $P3234, "Undef"
  vivify_1554:
    $P3235 = $P3234."CURSOR"()
    $P3235."panic"("Cannot look up empty name")
  unless_3231_end:
.annotate 'line', 2184
    find_lex $P3237, "@name"
    unless_null $P3237, vivify_1555
    $P3237 = root_new ['parrot';'ResizablePMCArray']
  vivify_1555:
    set $N3238, $P3237
    iseq $I3239, $N3238, 1.0
    unless $I3239, if_3236_end
    .const 'Sub' $P3241 = "428_1303857440.612" 
    capture_lex $P3241
    $P3241()
  if_3236_end:
.annotate 'line', 2202
    find_dynamic_lex $P3277, "$*GLOBALish"
    unless_null $P3277, vivify_1567
    get_hll_global $P3275, "GLOBAL"
    get_who $P3276, $P3275
    set $P3277, $P3276["$GLOBALish"]
    unless_null $P3277, vivify_1568
    die "Contextual $*GLOBALish not found"
  vivify_1568:
  vivify_1567:
    store_lex "$result", $P3277
.annotate 'line', 2203
    find_lex $P3279, "@name"
    unless_null $P3279, vivify_1569
    $P3279 = root_new ['parrot';'ResizablePMCArray']
  vivify_1569:
    set $N3280, $P3279
    isge $I3281, $N3280, 2.0
    unless $I3281, if_3278_end
    .const 'Sub' $P3283 = "430_1303857440.612" 
    capture_lex $P3283
    $P3283()
  if_3278_end:
.annotate 'line', 2221
    find_lex $P3319, "@name"
    unless_null $P3319, vivify_1582
    $P3319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1582:
    defined $I3320, $P3319
    unless $I3320, for_undef_1583
    iter $P3318, $P3319
    new $P3341, 'ExceptionHandler'
    set_label $P3341, loop3340_handler
    $P3341."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3341
  loop3340_test:
    unless $P3318, loop3340_done
    shift $P3321, $P3318
  loop3340_redo:
    .const 'Sub' $P3323 = "432_1303857440.612" 
    capture_lex $P3323
    $P3323($P3321)
  loop3340_next:
    goto loop3340_test
  loop3340_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3342, exception, 'type'
    eq $P3342, .CONTROL_LOOP_NEXT, loop3340_next
    eq $P3342, .CONTROL_LOOP_REDO, loop3340_redo
  loop3340_done:
    pop_eh 
  for_undef_1583:
    find_lex $P3343, "$result"
    unless_null $P3343, vivify_1590
    new $P3343, "Undef"
  vivify_1590:
.annotate 'line', 2178
    .return ($P3343)
  control_3226:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3344, exception, "payload"
    .return ($P3344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3240"  :anon :subid("428_1303857440.612") :outer("427_1303857440.612")
.annotate 'line', 2184
    .const 'Sub' $P3252 = "429_1303857440.612" 
    capture_lex $P3252
.annotate 'line', 2185
    new $P3242, "Undef"
    .lex "$final_name", $P3242
    find_lex $P3243, "@name"
    unless_null $P3243, vivify_1556
    $P3243 = root_new ['parrot';'ResizablePMCArray']
  vivify_1556:
    set $P3244, $P3243[0]
    unless_null $P3244, vivify_1557
    new $P3244, "Undef"
  vivify_1557:
    store_lex "$final_name", $P3244
.annotate 'line', 2186
    find_lex $P3246, "$?PACKAGE"
    get_who $P3247, $P3246
    set $P3248, $P3247["@BLOCK"]
    unless_null $P3248, vivify_1558
    $P3248 = root_new ['parrot';'ResizablePMCArray']
  vivify_1558:
    defined $I3249, $P3248
    unless $I3249, for_undef_1559
    iter $P3245, $P3248
    new $P3273, 'ExceptionHandler'
    set_label $P3273, loop3272_handler
    $P3273."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3273
  loop3272_test:
    unless $P3245, loop3272_done
    shift $P3250, $P3245
  loop3272_redo:
    .const 'Sub' $P3252 = "429_1303857440.612" 
    capture_lex $P3252
    $P3252($P3250)
  loop3272_next:
    goto loop3272_test
  loop3272_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3274, exception, 'type'
    eq $P3274, .CONTROL_LOOP_NEXT, loop3272_next
    eq $P3274, .CONTROL_LOOP_REDO, loop3272_redo
  loop3272_done:
    pop_eh 
  for_undef_1559:
.annotate 'line', 2184
    .return ($P3245)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3251"  :anon :subid("429_1303857440.612") :outer("428_1303857440.612")
    .param pmc param_3254
.annotate 'line', 2187
    $P3253 = root_new ['parrot';'Hash']
    .lex "%sym", $P3253
    .lex "$_", param_3254
    find_lex $P3255, "$_"
    unless_null $P3255, vivify_1560
    new $P3255, "Undef"
  vivify_1560:
    find_lex $P3256, "$final_name"
    unless_null $P3256, vivify_1561
    new $P3256, "Undef"
  vivify_1561:
    $P3257 = $P3255."symbol"($P3256)
    store_lex "%sym", $P3257
.annotate 'line', 2188
    find_lex $P3260, "%sym"
    unless_null $P3260, vivify_1562
    $P3260 = root_new ['parrot';'Hash']
  vivify_1562:
    set $N3261, $P3260
    if $N3261, if_3259
    new $P3258, 'Float'
    set $P3258, $N3261
    goto if_3259_end
  if_3259:
.annotate 'line', 2189
    find_lex $P3264, "%sym"
    unless_null $P3264, vivify_1563
    $P3264 = root_new ['parrot';'Hash']
  vivify_1563:
    exists $I3265, $P3264["value"]
    if $I3265, if_3263
.annotate 'line', 2193
    new $P3269, 'String'
    set $P3269, "No compile-time value for "
    find_lex $P3270, "$final_name"
    unless_null $P3270, vivify_1564
    new $P3270, "Undef"
  vivify_1564:
    concat $P3271, $P3269, $P3270
    die $P3271
.annotate 'line', 2192
    goto if_3263_end
  if_3263:
.annotate 'line', 2190
    new $P3266, "Exception"
    set $P3266['type'], .CONTROL_RETURN
    find_lex $P3267, "%sym"
    unless_null $P3267, vivify_1565
    $P3267 = root_new ['parrot';'Hash']
  vivify_1565:
    set $P3268, $P3267["value"]
    unless_null $P3268, vivify_1566
    new $P3268, "Undef"
  vivify_1566:
    setattribute $P3266, 'payload', $P3268
    throw $P3266
  if_3263_end:
.annotate 'line', 2188
    set $P3258, $P3262
  if_3259_end:
.annotate 'line', 2186
    .return ($P3258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3282"  :anon :subid("430_1303857440.612") :outer("427_1303857440.612")
.annotate 'line', 2203
    .const 'Sub' $P3294 = "431_1303857440.612" 
    capture_lex $P3294
.annotate 'line', 2204
    new $P3284, "Undef"
    .lex "$first", $P3284
    find_lex $P3285, "@name"
    unless_null $P3285, vivify_1570
    $P3285 = root_new ['parrot';'ResizablePMCArray']
  vivify_1570:
    set $P3286, $P3285[0]
    unless_null $P3286, vivify_1571
    new $P3286, "Undef"
  vivify_1571:
    store_lex "$first", $P3286
.annotate 'line', 2205
    find_lex $P3288, "$?PACKAGE"
    get_who $P3289, $P3288
    set $P3290, $P3289["@BLOCK"]
    unless_null $P3290, vivify_1572
    $P3290 = root_new ['parrot';'ResizablePMCArray']
  vivify_1572:
    defined $I3291, $P3290
    unless $I3291, for_undef_1573
    iter $P3287, $P3290
    new $P3316, 'ExceptionHandler'
    set_label $P3316, loop3315_handler
    $P3316."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3316
  loop3315_test:
    unless $P3287, loop3315_done
    shift $P3292, $P3287
  loop3315_redo:
    .const 'Sub' $P3294 = "431_1303857440.612" 
    capture_lex $P3294
    $P3294($P3292)
  loop3315_next:
    goto loop3315_test
  loop3315_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3317, exception, 'type'
    eq $P3317, .CONTROL_LOOP_NEXT, loop3315_next
    eq $P3317, .CONTROL_LOOP_REDO, loop3315_redo
  loop3315_done:
    pop_eh 
  for_undef_1573:
.annotate 'line', 2203
    .return ($P3287)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3293"  :anon :subid("431_1303857440.612") :outer("430_1303857440.612")
    .param pmc param_3296
.annotate 'line', 2206
    $P3295 = root_new ['parrot';'Hash']
    .lex "%sym", $P3295
    .lex "$_", param_3296
    find_lex $P3297, "$_"
    unless_null $P3297, vivify_1574
    new $P3297, "Undef"
  vivify_1574:
    find_lex $P3298, "$first"
    unless_null $P3298, vivify_1575
    new $P3298, "Undef"
  vivify_1575:
    $P3299 = $P3297."symbol"($P3298)
    store_lex "%sym", $P3299
.annotate 'line', 2207
    find_lex $P3302, "%sym"
    unless_null $P3302, vivify_1576
    $P3302 = root_new ['parrot';'Hash']
  vivify_1576:
    set $N3303, $P3302
    if $N3303, if_3301
    new $P3300, 'Float'
    set $P3300, $N3303
    goto if_3301_end
  if_3301:
.annotate 'line', 2208
    find_lex $P3306, "%sym"
    unless_null $P3306, vivify_1577
    $P3306 = root_new ['parrot';'Hash']
  vivify_1577:
    exists $I3307, $P3306["value"]
    if $I3307, if_3305
.annotate 'line', 2214
    new $P3312, 'String'
    set $P3312, "No compile-time value for "
    find_lex $P3313, "$first"
    unless_null $P3313, vivify_1578
    new $P3313, "Undef"
  vivify_1578:
    concat $P3314, $P3312, $P3313
    die $P3314
.annotate 'line', 2213
    goto if_3305_end
  if_3305:
.annotate 'line', 2209
    find_lex $P3308, "%sym"
    unless_null $P3308, vivify_1579
    $P3308 = root_new ['parrot';'Hash']
  vivify_1579:
    set $P3309, $P3308["value"]
    unless_null $P3309, vivify_1580
    new $P3309, "Undef"
  vivify_1580:
    store_lex "$result", $P3309
.annotate 'line', 2210
    find_lex $P3310, "@name"
    unless_null $P3310, vivify_1581
    $P3310 = root_new ['parrot';'ResizablePMCArray']
  vivify_1581:
    $P3310."shift"()
.annotate 'line', 2211
    set $I3311, .CONTROL_LOOP_LAST
    die 0, $I3311
  if_3305_end:
.annotate 'line', 2207
    set $P3300, $P3304
  if_3301_end:
.annotate 'line', 2205
    .return ($P3300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3322"  :anon :subid("432_1303857440.612") :outer("427_1303857440.612")
    .param pmc param_3324
.annotate 'line', 2221
    .lex "$_", param_3324
.annotate 'line', 2222
    find_lex $P3329, "$_"
    unless_null $P3329, vivify_1584
    new $P3329, "Undef"
  vivify_1584:
    set $S3330, $P3329
    find_lex $P3327, "$result"
    unless_null $P3327, vivify_1585
    new $P3327, "Undef"
  vivify_1585:
    get_who $P3328, $P3327
    exists $I3331, $P3328[$S3330]
    if $I3331, if_3326
.annotate 'line', 2226
    new $P3336, "String"
    assign $P3336, "Could not locate compile-time value for symbol "
.annotate 'line', 2227
    find_lex $P3337, "@name"
    unless_null $P3337, vivify_1586
    $P3337 = root_new ['parrot';'ResizablePMCArray']
  vivify_1586:
    join $S3338, "::", $P3337
    concat $P3339, $P3336, $S3338
.annotate 'line', 2226
    die $P3339
.annotate 'line', 2225
    goto if_3326_end
  if_3326:
.annotate 'line', 2223
    find_lex $P3332, "$_"
    unless_null $P3332, vivify_1587
    new $P3332, "Undef"
  vivify_1587:
    find_lex $P3333, "$result"
    unless_null $P3333, vivify_1588
    new $P3333, "Undef"
  vivify_1588:
    get_who $P3334, $P3333
    set $P3335, $P3334[$P3332]
    unless_null $P3335, vivify_1589
    new $P3335, "Undef"
  vivify_1589:
    store_lex "$result", $P3335
.annotate 'line', 2222
    set $P3325, $P3335
  if_3326_end:
.annotate 'line', 2221
    .return ($P3325)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("433_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3355
    .param pmc param_3356
.annotate 'line', 795
    .lex "self", param_3355
    .lex "$/", param_3356
    find_lex $P3357, "$/"
    find_lex $P3358, "$/"
    unless_null $P3358, vivify_1591
    $P3358 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3359, $P3358["comp_unit"]
    unless_null $P3359, vivify_1592
    new $P3359, "Undef"
  vivify_1592:
    $P3360 = $P3359."ast"()
    $P3361 = $P3357."!make"($P3360)
    .return ($P3361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("434_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3363
    .param pmc param_3364
.annotate 'line', 797
    .lex "self", param_3363
    .lex "$/", param_3364
.annotate 'line', 798
    find_lex $P3365, "$/"
.annotate 'line', 799
    find_lex $P3368, "$/"
    unless_null $P3368, vivify_1593
    $P3368 = root_new ['parrot';'Hash']
  vivify_1593:
    set $P3369, $P3368["colonpair"]
    unless_null $P3369, vivify_1594
    new $P3369, "Undef"
  vivify_1594:
    if $P3369, if_3367
.annotate 'line', 801
    find_lex $P3389, "$/"
    unless_null $P3389, vivify_1595
    new $P3389, "Undef"
  vivify_1595:
    set $S3390, $P3389
    new $P3366, 'String'
    set $P3366, $S3390
.annotate 'line', 799
    goto if_3367_end
  if_3367:
    find_lex $P3370, "$/"
    unless_null $P3370, vivify_1596
    $P3370 = root_new ['parrot';'Hash']
  vivify_1596:
    set $P3371, $P3370["identifier"]
    unless_null $P3371, vivify_1597
    new $P3371, "Undef"
  vivify_1597:
    set $S3372, $P3371
    new $P3373, 'String'
    set $P3373, $S3372
    concat $P3374, $P3373, ":"
    find_lex $P3375, "$/"
    unless_null $P3375, vivify_1598
    $P3375 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P3376, $P3375["colonpair"]
    unless_null $P3376, vivify_1599
    $P3376 = root_new ['parrot';'ResizablePMCArray']
  vivify_1599:
    set $P3377, $P3376[0]
    unless_null $P3377, vivify_1600
    new $P3377, "Undef"
  vivify_1600:
    $P3378 = $P3377."ast"()
    $S3379 = $P3378."named"()
    concat $P3380, $P3374, $S3379
    concat $P3381, $P3380, "<"
.annotate 'line', 800
    find_lex $P3382, "$/"
    unless_null $P3382, vivify_1601
    $P3382 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P3383, $P3382["colonpair"]
    unless_null $P3383, vivify_1602
    $P3383 = root_new ['parrot';'ResizablePMCArray']
  vivify_1602:
    set $P3384, $P3383[0]
    unless_null $P3384, vivify_1603
    new $P3384, "Undef"
  vivify_1603:
    $P3385 = $P3384."ast"()
    $S3386 = "colonpair_str"($P3385)
    concat $P3387, $P3381, $S3386
    concat $P3388, $P3387, ">"
    set $P3366, $P3388
  if_3367_end:
.annotate 'line', 799
    $P3391 = $P3365."!make"($P3366)
.annotate 'line', 797
    .return ($P3391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("435_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3394
    .param pmc param_3395
.annotate 'line', 811
    .lex "self", param_3394
    .lex "$/", param_3395
.annotate 'line', 812
    new $P3396, "Undef"
    .lex "$mainline", $P3396
.annotate 'line', 813
    new $P3397, "Undef"
    .lex "$unit", $P3397
.annotate 'line', 812
    find_lex $P3398, "$/"
    unless_null $P3398, vivify_1604
    $P3398 = root_new ['parrot';'Hash']
  vivify_1604:
    set $P3399, $P3398["statementlist"]
    unless_null $P3399, vivify_1605
    new $P3399, "Undef"
  vivify_1605:
    $P3400 = $P3399."ast"()
    store_lex "$mainline", $P3400
.annotate 'line', 813
    find_lex $P3401, "$?PACKAGE"
    get_who $P3402, $P3401
    set $P3403, $P3402["@BLOCK"]
    unless_null $P3403, vivify_1606
    $P3403 = root_new ['parrot';'ResizablePMCArray']
  vivify_1606:
    $P3404 = $P3403."shift"()
    store_lex "$unit", $P3404
.annotate 'line', 817
    find_lex $P3405, "$unit"
    unless_null $P3405, vivify_1607
    new $P3405, "Undef"
  vivify_1607:
    $P3406 = $P3405."loadinit"()
    find_dynamic_lex $P3409, "$*SC"
    unless_null $P3409, vivify_1608
    get_hll_global $P3407, "GLOBAL"
    get_who $P3408, $P3407
    set $P3409, $P3408["$SC"]
    unless_null $P3409, vivify_1609
    die "Contextual $*SC not found"
  vivify_1609:
  vivify_1608:
    $P3410 = $P3409."to_past"()
    $P3406."push"($P3410)
.annotate 'line', 822
    find_lex $P3411, "$unit"
    unless_null $P3411, vivify_1610
    new $P3411, "Undef"
  vivify_1610:
    $P3412 = $P3411."loadinit"()
    get_hll_global $P3413, "GLOBAL"
    nqp_get_package_through_who $P3414, $P3413, "PAST"
    get_who $P3415, $P3414
    set $P3416, $P3415["Op"]
.annotate 'line', 824
    get_hll_global $P3417, "GLOBAL"
    nqp_get_package_through_who $P3418, $P3417, "PAST"
    get_who $P3419, $P3418
    set $P3420, $P3419["Var"]
    new $P3421, "ResizablePMCArray"
    $P3422 = $P3420."new"("GLOBAL" :named("name"), $P3421 :named("namespace"), "package" :named("scope"))
.annotate 'line', 825
    find_dynamic_lex $P3425, "$*SC"
    unless_null $P3425, vivify_1611
    get_hll_global $P3423, "GLOBAL"
    get_who $P3424, $P3423
    set $P3425, $P3424["$SC"]
    unless_null $P3425, vivify_1612
    die "Contextual $*SC not found"
  vivify_1612:
  vivify_1611:
    find_dynamic_lex $P3428, "$*PACKAGE"
    unless_null $P3428, vivify_1613
    get_hll_global $P3426, "GLOBAL"
    get_who $P3427, $P3426
    set $P3428, $P3427["$PACKAGE"]
    unless_null $P3428, vivify_1614
    die "Contextual $*PACKAGE not found"
  vivify_1614:
  vivify_1613:
    $P3429 = $P3425."get_slot_past_for_object"($P3428)
    $P3430 = $P3416."new"($P3422, $P3429, "bind" :named("pasttype"))
.annotate 'line', 822
    $P3412."push"($P3430)
.annotate 'line', 831
    find_dynamic_lex $P3434, "$*HAS_YOU_ARE_HERE"
    unless_null $P3434, vivify_1615
    get_hll_global $P3432, "GLOBAL"
    get_who $P3433, $P3432
    set $P3434, $P3433["$HAS_YOU_ARE_HERE"]
    unless_null $P3434, vivify_1616
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1616:
  vivify_1615:
    if $P3434, unless_3431_end
.annotate 'line', 832
    find_lex $P3435, "$unit"
    unless_null $P3435, vivify_1617
    new $P3435, "Undef"
  vivify_1617:
    find_lex $P3436, "self"
    $P3437 = $P3436."CTXSAVE"()
    $P3435."push"($P3437)
  unless_3431_end:
.annotate 'line', 836
    find_lex $P3438, "$unit"
    unless_null $P3438, vivify_1618
    new $P3438, "Undef"
  vivify_1618:
    $P3438."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 840
    find_dynamic_lex $P3442, "$*MAIN_SUB"
    unless_null $P3442, vivify_1619
    get_hll_global $P3440, "GLOBAL"
    get_who $P3441, $P3440
    set $P3442, $P3441["$MAIN_SUB"]
    unless_null $P3442, vivify_1620
    die "Contextual $*MAIN_SUB not found"
  vivify_1620:
  vivify_1619:
    unless $P3442, if_3439_end
.annotate 'line', 841
    find_lex $P3443, "$unit"
    unless_null $P3443, vivify_1621
    new $P3443, "Undef"
  vivify_1621:
    get_hll_global $P3444, "GLOBAL"
    nqp_get_package_through_who $P3445, $P3444, "PAST"
    get_who $P3446, $P3445
    set $P3447, $P3446["Var"]
    $P3448 = $P3447."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3443."unshift"($P3448)
.annotate 'line', 842
    find_lex $P3449, "$mainline"
    unless_null $P3449, vivify_1622
    new $P3449, "Undef"
  vivify_1622:
    get_hll_global $P3450, "GLOBAL"
    nqp_get_package_through_who $P3451, $P3450, "PAST"
    get_who $P3452, $P3451
    set $P3453, $P3452["Op"]
.annotate 'line', 844
    get_hll_global $P3454, "GLOBAL"
    nqp_get_package_through_who $P3455, $P3454, "PAST"
    get_who $P3456, $P3455
    set $P3457, $P3456["Var"]
    $P3458 = $P3457."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 845
    get_hll_global $P3459, "GLOBAL"
    nqp_get_package_through_who $P3460, $P3459, "PAST"
    get_who $P3461, $P3460
    set $P3462, $P3461["Op"]
.annotate 'line', 846
    get_hll_global $P3463, "GLOBAL"
    nqp_get_package_through_who $P3464, $P3463, "PAST"
    get_who $P3465, $P3464
    set $P3466, $P3465["Val"]
    find_dynamic_lex $P3469, "$*MAIN_SUB"
    unless_null $P3469, vivify_1623
    get_hll_global $P3467, "GLOBAL"
    get_who $P3468, $P3467
    set $P3469, $P3468["$MAIN_SUB"]
    unless_null $P3469, vivify_1624
    die "Contextual $*MAIN_SUB not found"
  vivify_1624:
  vivify_1623:
    $P3470 = $P3466."new"($P3469 :named("value"))
.annotate 'line', 847
    get_hll_global $P3471, "GLOBAL"
    nqp_get_package_through_who $P3472, $P3471, "PAST"
    get_who $P3473, $P3472
    set $P3474, $P3473["Var"]
    $P3475 = $P3474."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3476 = $P3462."new"($P3470, $P3475, "call" :named("pasttype"))
.annotate 'line', 845
    $P3477 = $P3453."new"($P3458, $P3476, "if" :named("pasttype"))
.annotate 'line', 842
    $P3449."push"($P3477)
  if_3439_end:
.annotate 'line', 855
    find_lex $P3478, "$unit"
    unless_null $P3478, vivify_1625
    new $P3478, "Undef"
  vivify_1625:
.annotate 'line', 856
    get_hll_global $P3479, "GLOBAL"
    nqp_get_package_through_who $P3480, $P3479, "PAST"
    get_who $P3481, $P3480
    set $P3482, $P3481["Op"]
    find_lex $P3483, "$mainline"
    unless_null $P3483, vivify_1626
    new $P3483, "Undef"
  vivify_1626:
    $P3484 = $P3482."new"($P3483, "return" :named("pirop"))
    $P3478."push"($P3484)
.annotate 'line', 861
    find_lex $P3485, "$unit"
    unless_null $P3485, vivify_1627
    new $P3485, "Undef"
  vivify_1627:
.annotate 'line', 862
    get_hll_global $P3486, "GLOBAL"
    nqp_get_package_through_who $P3487, $P3486, "PAST"
    get_who $P3488, $P3487
    set $P3489, $P3488["Block"]
.annotate 'line', 864
    get_hll_global $P3490, "GLOBAL"
    nqp_get_package_through_who $P3491, $P3490, "PAST"
    get_who $P3492, $P3491
    set $P3493, $P3492["Op"]
    get_hll_global $P3494, "GLOBAL"
    nqp_get_package_through_who $P3495, $P3494, "PAST"
    get_who $P3496, $P3495
    set $P3497, $P3496["Val"]
    find_lex $P3498, "$unit"
    unless_null $P3498, vivify_1628
    new $P3498, "Undef"
  vivify_1628:
    $P3499 = $P3497."new"($P3498 :named("value"))
    $P3500 = $P3493."new"($P3499, "call" :named("pasttype"))
    $P3501 = $P3489."new"($P3500, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 862
    $P3485."push"($P3501)
.annotate 'line', 867
    find_lex $P3502, "$unit"
    unless_null $P3502, vivify_1629
    new $P3502, "Undef"
  vivify_1629:
    find_lex $P3503, "$/"
    unless_null $P3503, vivify_1630
    new $P3503, "Undef"
  vivify_1630:
    $P3502."node"($P3503)
.annotate 'line', 870
    find_lex $P3504, "$unit"
    unless_null $P3504, vivify_1631
    new $P3504, "Undef"
  vivify_1631:
    $P3504."hll"("nqp")
.annotate 'line', 872
    find_lex $P3505, "$/"
    find_lex $P3506, "$unit"
    unless_null $P3506, vivify_1632
    new $P3506, "Undef"
  vivify_1632:
    $P3507 = $P3505."!make"($P3506)
.annotate 'line', 811
    .return ($P3507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("436_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3509
    .param pmc param_3510
.annotate 'line', 875
    .const 'Sub' $P3527 = "437_1303857440.612" 
    capture_lex $P3527
    .lex "self", param_3509
    .lex "$/", param_3510
.annotate 'line', 876
    new $P3511, "Undef"
    .lex "$past", $P3511
    get_hll_global $P3512, "GLOBAL"
    nqp_get_package_through_who $P3513, $P3512, "PAST"
    get_who $P3514, $P3513
    set $P3515, $P3514["Stmts"]
    find_lex $P3516, "$/"
    unless_null $P3516, vivify_1633
    new $P3516, "Undef"
  vivify_1633:
    $P3517 = $P3515."new"($P3516 :named("node"))
    store_lex "$past", $P3517
.annotate 'line', 877
    find_lex $P3519, "$/"
    unless_null $P3519, vivify_1634
    $P3519 = root_new ['parrot';'Hash']
  vivify_1634:
    set $P3520, $P3519["statement"]
    unless_null $P3520, vivify_1635
    new $P3520, "Undef"
  vivify_1635:
    unless $P3520, if_3518_end
.annotate 'line', 878
    find_lex $P3522, "$/"
    unless_null $P3522, vivify_1636
    $P3522 = root_new ['parrot';'Hash']
  vivify_1636:
    set $P3523, $P3522["statement"]
    unless_null $P3523, vivify_1637
    new $P3523, "Undef"
  vivify_1637:
    defined $I3524, $P3523
    unless $I3524, for_undef_1638
    iter $P3521, $P3523
    new $P3547, 'ExceptionHandler'
    set_label $P3547, loop3546_handler
    $P3547."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3547
  loop3546_test:
    unless $P3521, loop3546_done
    shift $P3525, $P3521
  loop3546_redo:
    .const 'Sub' $P3527 = "437_1303857440.612" 
    capture_lex $P3527
    $P3527($P3525)
  loop3546_next:
    goto loop3546_test
  loop3546_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3548, exception, 'type'
    eq $P3548, .CONTROL_LOOP_NEXT, loop3546_next
    eq $P3548, .CONTROL_LOOP_REDO, loop3546_redo
  loop3546_done:
    pop_eh 
  for_undef_1638:
  if_3518_end:
.annotate 'line', 885
    find_lex $P3549, "$/"
    find_lex $P3550, "$past"
    unless_null $P3550, vivify_1649
    new $P3550, "Undef"
  vivify_1649:
    $P3551 = $P3549."!make"($P3550)
.annotate 'line', 875
    .return ($P3551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3526"  :anon :subid("437_1303857440.612") :outer("436_1303857440.612")
    .param pmc param_3529
.annotate 'line', 879
    new $P3528, "Undef"
    .lex "$ast", $P3528
    .lex "$_", param_3529
    find_lex $P3530, "$_"
    unless_null $P3530, vivify_1639
    new $P3530, "Undef"
  vivify_1639:
    $P3531 = $P3530."ast"()
    store_lex "$ast", $P3531
.annotate 'line', 880
    find_lex $P3533, "$ast"
    unless_null $P3533, vivify_1640
    $P3533 = root_new ['parrot';'Hash']
  vivify_1640:
    set $P3534, $P3533["sink"]
    unless_null $P3534, vivify_1641
    new $P3534, "Undef"
  vivify_1641:
    defined $I3535, $P3534
    unless $I3535, if_3532_end
    find_lex $P3536, "$ast"
    unless_null $P3536, vivify_1642
    $P3536 = root_new ['parrot';'Hash']
  vivify_1642:
    set $P3537, $P3536["sink"]
    unless_null $P3537, vivify_1643
    new $P3537, "Undef"
  vivify_1643:
    store_lex "$ast", $P3537
  if_3532_end:
.annotate 'line', 881
    find_lex $P3539, "$ast"
    unless_null $P3539, vivify_1644
    $P3539 = root_new ['parrot';'Hash']
  vivify_1644:
    set $P3540, $P3539["bareblock"]
    unless_null $P3540, vivify_1645
    new $P3540, "Undef"
  vivify_1645:
    unless $P3540, if_3538_end
    find_lex $P3541, "$ast"
    unless_null $P3541, vivify_1646
    new $P3541, "Undef"
  vivify_1646:
    $P3542 = "block_immediate"($P3541)
    store_lex "$ast", $P3542
  if_3538_end:
.annotate 'line', 882
    find_lex $P3543, "$past"
    unless_null $P3543, vivify_1647
    new $P3543, "Undef"
  vivify_1647:
    find_lex $P3544, "$ast"
    unless_null $P3544, vivify_1648
    new $P3544, "Undef"
  vivify_1648:
    $P3545 = $P3543."push"($P3544)
.annotate 'line', 878
    .return ($P3545)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("438_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3553
    .param pmc param_3554
    .param pmc param_3555 :optional
    .param int has_param_3555 :opt_flag
.annotate 'line', 888
    .const 'Sub' $P3563 = "439_1303857440.612" 
    capture_lex $P3563
    .lex "self", param_3553
    .lex "$/", param_3554
    if has_param_3555, optparam_1650
    new $P3556, "Undef"
    set param_3555, $P3556
  optparam_1650:
    .lex "$key", param_3555
.annotate 'line', 889
    new $P3557, "Undef"
    .lex "$past", $P3557
.annotate 'line', 888
    find_lex $P3558, "$past"
    unless_null $P3558, vivify_1651
    new $P3558, "Undef"
  vivify_1651:
.annotate 'line', 890
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_1652
    $P3560 = root_new ['parrot';'Hash']
  vivify_1652:
    set $P3561, $P3560["EXPR"]
    unless_null $P3561, vivify_1653
    new $P3561, "Undef"
  vivify_1653:
    if $P3561, if_3559
.annotate 'line', 911
    find_lex $P3639, "$/"
    unless_null $P3639, vivify_1654
    $P3639 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3640, $P3639["statement_control"]
    unless_null $P3640, vivify_1655
    new $P3640, "Undef"
  vivify_1655:
    if $P3640, if_3638
.annotate 'line', 912
    new $P3644, "Integer"
    assign $P3644, 0
    store_lex "$past", $P3644
    goto if_3638_end
  if_3638:
.annotate 'line', 911
    find_lex $P3641, "$/"
    unless_null $P3641, vivify_1656
    $P3641 = root_new ['parrot';'Hash']
  vivify_1656:
    set $P3642, $P3641["statement_control"]
    unless_null $P3642, vivify_1657
    new $P3642, "Undef"
  vivify_1657:
    $P3643 = $P3642."ast"()
    store_lex "$past", $P3643
  if_3638_end:
    goto if_3559_end
  if_3559:
.annotate 'line', 890
    .const 'Sub' $P3563 = "439_1303857440.612" 
    capture_lex $P3563
    $P3563()
  if_3559_end:
.annotate 'line', 913
    find_lex $P3645, "$/"
    find_lex $P3646, "$past"
    unless_null $P3646, vivify_1691
    new $P3646, "Undef"
  vivify_1691:
    $P3647 = $P3645."!make"($P3646)
.annotate 'line', 888
    .return ($P3647)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3562"  :anon :subid("439_1303857440.612") :outer("438_1303857440.612")
.annotate 'line', 891
    new $P3564, "Undef"
    .lex "$mc", $P3564
.annotate 'line', 892
    new $P3565, "Undef"
    .lex "$ml", $P3565
.annotate 'line', 891
    find_lex $P3566, "$/"
    unless_null $P3566, vivify_1658
    $P3566 = root_new ['parrot';'Hash']
  vivify_1658:
    set $P3567, $P3566["statement_mod_cond"]
    unless_null $P3567, vivify_1659
    $P3567 = root_new ['parrot';'ResizablePMCArray']
  vivify_1659:
    set $P3568, $P3567[0]
    unless_null $P3568, vivify_1660
    new $P3568, "Undef"
  vivify_1660:
    store_lex "$mc", $P3568
.annotate 'line', 892
    find_lex $P3569, "$/"
    unless_null $P3569, vivify_1661
    $P3569 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P3570, $P3569["statement_mod_loop"]
    unless_null $P3570, vivify_1662
    $P3570 = root_new ['parrot';'ResizablePMCArray']
  vivify_1662:
    set $P3571, $P3570[0]
    unless_null $P3571, vivify_1663
    new $P3571, "Undef"
  vivify_1663:
    store_lex "$ml", $P3571
.annotate 'line', 893
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_1664
    $P3572 = root_new ['parrot';'Hash']
  vivify_1664:
    set $P3573, $P3572["EXPR"]
    unless_null $P3573, vivify_1665
    new $P3573, "Undef"
  vivify_1665:
    $P3574 = $P3573."ast"()
    store_lex "$past", $P3574
.annotate 'line', 894
    find_lex $P3576, "$mc"
    unless_null $P3576, vivify_1666
    new $P3576, "Undef"
  vivify_1666:
    unless $P3576, if_3575_end
.annotate 'line', 895
    get_hll_global $P3577, "GLOBAL"
    nqp_get_package_through_who $P3578, $P3577, "PAST"
    get_who $P3579, $P3578
    set $P3580, $P3579["Op"]
    find_lex $P3581, "$mc"
    unless_null $P3581, vivify_1667
    $P3581 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3582, $P3581["cond"]
    unless_null $P3582, vivify_1668
    new $P3582, "Undef"
  vivify_1668:
    $P3583 = $P3582."ast"()
    find_lex $P3584, "$past"
    unless_null $P3584, vivify_1669
    new $P3584, "Undef"
  vivify_1669:
    find_lex $P3585, "$mc"
    unless_null $P3585, vivify_1670
    $P3585 = root_new ['parrot';'Hash']
  vivify_1670:
    set $P3586, $P3585["sym"]
    unless_null $P3586, vivify_1671
    new $P3586, "Undef"
  vivify_1671:
    set $S3587, $P3586
    find_lex $P3588, "$/"
    unless_null $P3588, vivify_1672
    new $P3588, "Undef"
  vivify_1672:
    $P3589 = $P3580."new"($P3583, $P3584, $S3587 :named("pasttype"), $P3588 :named("node"))
    store_lex "$past", $P3589
  if_3575_end:
.annotate 'line', 897
    find_lex $P3592, "$ml"
    unless_null $P3592, vivify_1673
    new $P3592, "Undef"
  vivify_1673:
    if $P3592, if_3591
    set $P3590, $P3592
    goto if_3591_end
  if_3591:
.annotate 'line', 898
    find_lex $P3595, "$ml"
    unless_null $P3595, vivify_1674
    $P3595 = root_new ['parrot';'Hash']
  vivify_1674:
    set $P3596, $P3595["sym"]
    unless_null $P3596, vivify_1675
    new $P3596, "Undef"
  vivify_1675:
    set $S3597, $P3596
    iseq $I3598, $S3597, "for"
    if $I3598, if_3594
.annotate 'line', 907
    get_hll_global $P3625, "GLOBAL"
    nqp_get_package_through_who $P3626, $P3625, "PAST"
    get_who $P3627, $P3626
    set $P3628, $P3627["Op"]
    find_lex $P3629, "$ml"
    unless_null $P3629, vivify_1676
    $P3629 = root_new ['parrot';'Hash']
  vivify_1676:
    set $P3630, $P3629["cond"]
    unless_null $P3630, vivify_1677
    new $P3630, "Undef"
  vivify_1677:
    $P3631 = $P3630."ast"()
    find_lex $P3632, "$past"
    unless_null $P3632, vivify_1678
    new $P3632, "Undef"
  vivify_1678:
    find_lex $P3633, "$ml"
    unless_null $P3633, vivify_1679
    $P3633 = root_new ['parrot';'Hash']
  vivify_1679:
    set $P3634, $P3633["sym"]
    unless_null $P3634, vivify_1680
    new $P3634, "Undef"
  vivify_1680:
    set $S3635, $P3634
    find_lex $P3636, "$/"
    unless_null $P3636, vivify_1681
    new $P3636, "Undef"
  vivify_1681:
    $P3637 = $P3628."new"($P3631, $P3632, $S3635 :named("pasttype"), $P3636 :named("node"))
    store_lex "$past", $P3637
.annotate 'line', 906
    set $P3593, $P3637
.annotate 'line', 898
    goto if_3594_end
  if_3594:
.annotate 'line', 899
    get_hll_global $P3599, "GLOBAL"
    nqp_get_package_through_who $P3600, $P3599, "PAST"
    get_who $P3601, $P3600
    set $P3602, $P3601["Block"]
.annotate 'line', 900
    get_hll_global $P3603, "GLOBAL"
    nqp_get_package_through_who $P3604, $P3603, "PAST"
    get_who $P3605, $P3604
    set $P3606, $P3605["Var"]
    $P3607 = $P3606."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3608, "$past"
    unless_null $P3608, vivify_1682
    new $P3608, "Undef"
  vivify_1682:
    $P3609 = $P3602."new"($P3607, $P3608, "immediate" :named("blocktype"))
.annotate 'line', 899
    store_lex "$past", $P3609
.annotate 'line', 902
    find_lex $P3610, "$past"
    unless_null $P3610, vivify_1683
    new $P3610, "Undef"
  vivify_1683:
    $P3610."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 903
    find_lex $P3611, "$past"
    unless_null $P3611, vivify_1684
    new $P3611, "Undef"
  vivify_1684:
    $P3611."arity"(1)
.annotate 'line', 904
    get_hll_global $P3612, "GLOBAL"
    nqp_get_package_through_who $P3613, $P3612, "PAST"
    get_who $P3614, $P3613
    set $P3615, $P3614["Op"]
    find_lex $P3616, "$ml"
    unless_null $P3616, vivify_1685
    $P3616 = root_new ['parrot';'Hash']
  vivify_1685:
    set $P3617, $P3616["cond"]
    unless_null $P3617, vivify_1686
    new $P3617, "Undef"
  vivify_1686:
    $P3618 = $P3617."ast"()
    find_lex $P3619, "$past"
    unless_null $P3619, vivify_1687
    new $P3619, "Undef"
  vivify_1687:
    find_lex $P3620, "$ml"
    unless_null $P3620, vivify_1688
    $P3620 = root_new ['parrot';'Hash']
  vivify_1688:
    set $P3621, $P3620["sym"]
    unless_null $P3621, vivify_1689
    new $P3621, "Undef"
  vivify_1689:
    set $S3622, $P3621
    find_lex $P3623, "$/"
    unless_null $P3623, vivify_1690
    new $P3623, "Undef"
  vivify_1690:
    $P3624 = $P3615."new"($P3618, $P3619, $S3622 :named("pasttype"), $P3623 :named("node"))
    store_lex "$past", $P3624
.annotate 'line', 898
    set $P3593, $P3624
  if_3594_end:
.annotate 'line', 897
    set $P3590, $P3593
  if_3591_end:
.annotate 'line', 890
    .return ($P3590)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("440_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3649
    .param pmc param_3650
.annotate 'line', 916
    .lex "self", param_3649
    .lex "$/", param_3650
.annotate 'line', 917
    find_lex $P3651, "$/"
    get_hll_global $P3652, "GLOBAL"
    nqp_get_package_through_who $P3653, $P3652, "PAST"
    get_who $P3654, $P3653
    set $P3655, $P3654["Op"]
    find_lex $P3656, "$/"
    unless_null $P3656, vivify_1692
    $P3656 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3657, $P3656["EXPR"]
    unless_null $P3657, vivify_1693
    new $P3657, "Undef"
  vivify_1693:
    $P3658 = $P3657."ast"()
    find_lex $P3659, "$/"
    unless_null $P3659, vivify_1694
    $P3659 = root_new ['parrot';'Hash']
  vivify_1694:
    set $P3660, $P3659["pblock"]
    unless_null $P3660, vivify_1695
    new $P3660, "Undef"
  vivify_1695:
    $P3661 = $P3660."ast"()
    find_lex $P3662, "$/"
    unless_null $P3662, vivify_1696
    new $P3662, "Undef"
  vivify_1696:
    $P3663 = $P3655."new"($P3658, $P3661, "if" :named("pasttype"), $P3662 :named("node"))
    $P3664 = $P3651."!make"($P3663)
.annotate 'line', 916
    .return ($P3664)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("441_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3666
    .param pmc param_3667
.annotate 'line', 920
    .lex "self", param_3666
    .lex "$/", param_3667
.annotate 'line', 921
    find_lex $P3668, "$/"
    find_lex $P3669, "$/"
    unless_null $P3669, vivify_1697
    $P3669 = root_new ['parrot';'Hash']
  vivify_1697:
    set $P3670, $P3669["blockoid"]
    unless_null $P3670, vivify_1698
    new $P3670, "Undef"
  vivify_1698:
    $P3671 = $P3670."ast"()
    $P3672 = $P3668."!make"($P3671)
.annotate 'line', 920
    .return ($P3672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("442_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3674
    .param pmc param_3675
.annotate 'line', 924
    .lex "self", param_3674
    .lex "$/", param_3675
.annotate 'line', 925
    find_lex $P3676, "$/"
    find_lex $P3677, "$/"
    unless_null $P3677, vivify_1699
    $P3677 = root_new ['parrot';'Hash']
  vivify_1699:
    set $P3678, $P3677["blockoid"]
    unless_null $P3678, vivify_1700
    new $P3678, "Undef"
  vivify_1700:
    $P3679 = $P3678."ast"()
    $P3680 = $P3676."!make"($P3679)
.annotate 'line', 924
    .return ($P3680)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("443_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3682
    .param pmc param_3683
.annotate 'line', 928
    .const 'Sub' $P3694 = "444_1303857440.612" 
    capture_lex $P3694
    .lex "self", param_3682
    .lex "$/", param_3683
.annotate 'line', 929
    new $P3684, "Undef"
    .lex "$BLOCK", $P3684
    find_lex $P3685, "$?PACKAGE"
    get_who $P3686, $P3685
    set $P3687, $P3686["@BLOCK"]
    unless_null $P3687, vivify_1701
    $P3687 = root_new ['parrot';'ResizablePMCArray']
  vivify_1701:
    $P3688 = $P3687."shift"()
    store_lex "$BLOCK", $P3688
.annotate 'line', 930
    find_lex $P3691, "$/"
    unless_null $P3691, vivify_1702
    $P3691 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P3692, $P3691["statementlist"]
    unless_null $P3692, vivify_1703
    new $P3692, "Undef"
  vivify_1703:
    if $P3692, if_3690
.annotate 'line', 938
    find_dynamic_lex $P3711, "$*HAS_YOU_ARE_HERE"
    unless_null $P3711, vivify_1704
    get_hll_global $P3709, "GLOBAL"
    get_who $P3710, $P3709
    set $P3711, $P3710["$HAS_YOU_ARE_HERE"]
    unless_null $P3711, vivify_1705
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1705:
  vivify_1704:
    unless $P3711, if_3708_end
.annotate 'line', 939
    find_lex $P3712, "$/"
    unless_null $P3712, vivify_1706
    new $P3712, "Undef"
  vivify_1706:
    $P3713 = $P3712."CURSOR"()
    $P3713."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3708_end:
.annotate 'line', 941
    new $P3714, "Integer"
    assign $P3714, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3714
.annotate 'line', 942
    find_lex $P3715, "$/"
    find_lex $P3716, "$/"
    unless_null $P3716, vivify_1707
    $P3716 = root_new ['parrot';'Hash']
  vivify_1707:
    set $P3717, $P3716["you_are_here"]
    unless_null $P3717, vivify_1708
    new $P3717, "Undef"
  vivify_1708:
    $P3718 = $P3717."ast"()
    $P3719 = $P3715."!make"($P3718)
.annotate 'line', 937
    set $P3689, $P3719
.annotate 'line', 930
    goto if_3690_end
  if_3690:
    .const 'Sub' $P3694 = "444_1303857440.612" 
    capture_lex $P3694
    $P3707 = $P3694()
    set $P3689, $P3707
  if_3690_end:
.annotate 'line', 928
    .return ($P3689)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3693"  :anon :subid("444_1303857440.612") :outer("443_1303857440.612")
.annotate 'line', 931
    new $P3695, "Undef"
    .lex "$past", $P3695
    find_lex $P3696, "$/"
    unless_null $P3696, vivify_1709
    $P3696 = root_new ['parrot';'Hash']
  vivify_1709:
    set $P3697, $P3696["statementlist"]
    unless_null $P3697, vivify_1710
    new $P3697, "Undef"
  vivify_1710:
    $P3698 = $P3697."ast"()
    store_lex "$past", $P3698
.annotate 'line', 932
    find_lex $P3699, "$BLOCK"
    unless_null $P3699, vivify_1711
    new $P3699, "Undef"
  vivify_1711:
    find_lex $P3700, "$past"
    unless_null $P3700, vivify_1712
    new $P3700, "Undef"
  vivify_1712:
    $P3699."push"($P3700)
.annotate 'line', 933
    find_lex $P3701, "$BLOCK"
    unless_null $P3701, vivify_1713
    new $P3701, "Undef"
  vivify_1713:
    find_lex $P3702, "$/"
    unless_null $P3702, vivify_1714
    new $P3702, "Undef"
  vivify_1714:
    $P3701."node"($P3702)
.annotate 'line', 934
    find_lex $P3703, "$BLOCK"
    unless_null $P3703, vivify_1715
    new $P3703, "Undef"
  vivify_1715:
    $P3703."closure"(1)
.annotate 'line', 935
    find_dynamic_lex $P3704, "$/"
    find_lex $P3705, "$BLOCK"
    unless_null $P3705, vivify_1716
    new $P3705, "Undef"
  vivify_1716:
    $P3706 = $P3704."!make"($P3705)
.annotate 'line', 930
    .return ($P3706)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("445_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3721
    .param pmc param_3722
.annotate 'line', 946
    .lex "self", param_3721
    .lex "$/", param_3722
.annotate 'line', 947
    find_lex $P3723, "$?PACKAGE"
    get_who $P3724, $P3723
    set $P3725, $P3724["@BLOCK"]
    unless_null $P3725, vivify_1717
    $P3725 = root_new ['parrot';'ResizablePMCArray']
  vivify_1717:
    get_hll_global $P3726, "GLOBAL"
    nqp_get_package_through_who $P3727, $P3726, "PAST"
    get_who $P3728, $P3727
    set $P3729, $P3728["Block"]
    get_hll_global $P3730, "GLOBAL"
    nqp_get_package_through_who $P3731, $P3730, "PAST"
    get_who $P3732, $P3731
    set $P3733, $P3732["Stmts"]
    $P3734 = $P3733."new"()
    $P3735 = $P3729."new"($P3734)
    $P3736 = $P3725."unshift"($P3735)
.annotate 'line', 946
    .return ($P3736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("446_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3738
    .param pmc param_3739
.annotate 'line', 950
    .const 'Sub' $P3748 = "447_1303857440.612" 
    capture_lex $P3748
    .lex "self", param_3738
    .lex "$/", param_3739
.annotate 'line', 951
    find_dynamic_lex $P3743, "%*COMPILING"
    unless_null $P3743, vivify_1718
    get_hll_global $P3741, "GLOBAL"
    get_who $P3742, $P3741
    set $P3743, $P3742["%COMPILING"]
    unless_null $P3743, vivify_1719
    die "Contextual %*COMPILING not found"
  vivify_1719:
  vivify_1718:
    set $P3744, $P3743["%?OPTIONS"]
    unless_null $P3744, vivify_1720
    $P3744 = root_new ['parrot';'Hash']
  vivify_1720:
    set $P3745, $P3744["outer_ctx"]
    unless_null $P3745, vivify_1721
    new $P3745, "Undef"
  vivify_1721:
    defined $I3746, $P3745
    if $I3746, unless_3740_end
    .const 'Sub' $P3748 = "447_1303857440.612" 
    capture_lex $P3748
    $P3748()
  unless_3740_end:
.annotate 'line', 964
    find_lex $P3780, "self"
    find_lex $P3781, "$?PACKAGE"
    get_who $P3782, $P3781
    set $P3783, $P3782["@BLOCK"]
    unless_null $P3783, vivify_1737
    $P3783 = root_new ['parrot';'ResizablePMCArray']
  vivify_1737:
    set $P3784, $P3783[0]
    unless_null $P3784, vivify_1738
    new $P3784, "Undef"
  vivify_1738:
    $P3785 = $P3780."SET_BLOCK_OUTER_CTX"($P3784)
.annotate 'line', 950
    .return ($P3785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3747"  :anon :subid("447_1303857440.612") :outer("446_1303857440.612")
.annotate 'line', 954
    new $P3749, "Undef"
    .lex "$SETTING", $P3749
    find_dynamic_lex $P3752, "$*SC"
    unless_null $P3752, vivify_1722
    get_hll_global $P3750, "GLOBAL"
    get_who $P3751, $P3750
    set $P3752, $P3751["$SC"]
    unless_null $P3752, vivify_1723
    die "Contextual $*SC not found"
  vivify_1723:
  vivify_1722:
    find_dynamic_lex $P3756, "%*COMPILING"
    unless_null $P3756, vivify_1724
    get_hll_global $P3754, "GLOBAL"
    get_who $P3755, $P3754
    set $P3756, $P3755["%COMPILING"]
    unless_null $P3756, vivify_1725
    die "Contextual %*COMPILING not found"
  vivify_1725:
  vivify_1724:
    set $P3757, $P3756["%?OPTIONS"]
    unless_null $P3757, vivify_1726
    $P3757 = root_new ['parrot';'Hash']
  vivify_1726:
    set $P3758, $P3757["setting"]
    unless_null $P3758, vivify_1727
    new $P3758, "Undef"
  vivify_1727:
    set $P3753, $P3758
    defined $I3760, $P3753
    if $I3760, default_3759
    new $P3761, "String"
    assign $P3761, "NQPCORE"
    set $P3753, $P3761
  default_3759:
    $P3762 = $P3752."load_setting"($P3753)
    store_lex "$SETTING", $P3762
.annotate 'line', 959
    find_dynamic_lex $P3767, "%*COMPILING"
    unless_null $P3767, vivify_1728
    get_hll_global $P3765, "GLOBAL"
    get_who $P3766, $P3765
    set $P3767, $P3766["%COMPILING"]
    unless_null $P3767, vivify_1729
    die "Contextual %*COMPILING not found"
  vivify_1729:
  vivify_1728:
    set $P3768, $P3767["%?OPTIONS"]
    unless_null $P3768, vivify_1730
    $P3768 = root_new ['parrot';'Hash']
  vivify_1730:
    set $P3769, $P3768["setting"]
    unless_null $P3769, vivify_1731
    new $P3769, "Undef"
  vivify_1731:
    set $S3770, $P3769
    iseq $I3771, $S3770, "NULL"
    unless $I3771, unless_3764
    new $P3763, 'Integer'
    set $P3763, $I3771
    goto unless_3764_end
  unless_3764:
.annotate 'line', 960
    find_lex $P3772, "$SETTING"
    unless_null $P3772, vivify_1732
    new $P3772, "Undef"
  vivify_1732:
    "import_HOW_exports"($P3772)
.annotate 'line', 961
    find_dynamic_lex $P3775, "$*SC"
    unless_null $P3775, vivify_1733
    get_hll_global $P3773, "GLOBAL"
    get_who $P3774, $P3773
    set $P3775, $P3774["$SC"]
    unless_null $P3775, vivify_1734
    die "Contextual $*SC not found"
  vivify_1734:
  vivify_1733:
    find_dynamic_lex $P3778, "$*GLOBALish"
    unless_null $P3778, vivify_1735
    get_hll_global $P3776, "GLOBAL"
    get_who $P3777, $P3776
    set $P3778, $P3777["$GLOBALish"]
    unless_null $P3778, vivify_1736
    die "Contextual $*GLOBALish not found"
  vivify_1736:
  vivify_1735:
    $P3779 = $P3775."load_module"("Regex", $P3778)
.annotate 'line', 959
    set $P3763, $P3779
  unless_3764_end:
.annotate 'line', 951
    .return ($P3763)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("448_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3788
    .param pmc param_3789
.annotate 'line', 976
    .lex "self", param_3788
    .lex "$/", param_3789
.annotate 'line', 980
    find_dynamic_lex $P3792, "$*SC"
    unless_null $P3792, vivify_1739
    get_hll_global $P3790, "GLOBAL"
    get_who $P3791, $P3790
    set $P3792, $P3791["$SC"]
    unless_null $P3792, vivify_1740
    die "Contextual $*SC not found"
  vivify_1740:
  vivify_1739:
    find_dynamic_lex $P3795, "%*HOW"
    unless_null $P3795, vivify_1741
    get_hll_global $P3793, "GLOBAL"
    get_who $P3794, $P3793
    set $P3795, $P3794["%HOW"]
    unless_null $P3795, vivify_1742
    die "Contextual %*HOW not found"
  vivify_1742:
  vivify_1741:
    set $P3796, $P3795["knowhow"]
    unless_null $P3796, vivify_1743
    new $P3796, "Undef"
  vivify_1743:
    $P3797 = $P3792."pkg_create_mo"($P3796, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3797
.annotate 'line', 981
    find_dynamic_lex $P3800, "$*GLOBALish"
    unless_null $P3800, vivify_1744
    get_hll_global $P3798, "GLOBAL"
    get_who $P3799, $P3798
    set $P3800, $P3799["$GLOBALish"]
    unless_null $P3800, vivify_1745
    die "Contextual $*GLOBALish not found"
  vivify_1745:
  vivify_1744:
    get_how $P3801, $P3800
    find_dynamic_lex $P3804, "$*GLOBALish"
    unless_null $P3804, vivify_1746
    get_hll_global $P3802, "GLOBAL"
    get_who $P3803, $P3802
    set $P3804, $P3803["$GLOBALish"]
    unless_null $P3804, vivify_1747
    die "Contextual $*GLOBALish not found"
  vivify_1747:
  vivify_1746:
    $P3801."compose"($P3804)
.annotate 'line', 982
    find_dynamic_lex $P3807, "$*SC"
    unless_null $P3807, vivify_1748
    get_hll_global $P3805, "GLOBAL"
    get_who $P3806, $P3805
    set $P3807, $P3806["$SC"]
    unless_null $P3807, vivify_1749
    die "Contextual $*SC not found"
  vivify_1749:
  vivify_1748:
    find_lex $P3808, "$?PACKAGE"
    get_who $P3809, $P3808
    set $P3810, $P3809["@BLOCK"]
    unless_null $P3810, vivify_1750
    $P3810 = root_new ['parrot';'ResizablePMCArray']
  vivify_1750:
    set $P3811, $P3810[0]
    unless_null $P3811, vivify_1751
    new $P3811, "Undef"
  vivify_1751:
    find_dynamic_lex $P3814, "$*GLOBALish"
    unless_null $P3814, vivify_1752
    get_hll_global $P3812, "GLOBAL"
    get_who $P3813, $P3812
    set $P3814, $P3813["$GLOBALish"]
    unless_null $P3814, vivify_1753
    die "Contextual $*GLOBALish not found"
  vivify_1753:
  vivify_1752:
    $P3807."install_lexical_symbol"($P3811, "GLOBALish", $P3814)
.annotate 'line', 985
    find_dynamic_lex $P3817, "$*GLOBALish"
    unless_null $P3817, vivify_1754
    get_hll_global $P3815, "GLOBAL"
    get_who $P3816, $P3815
    set $P3817, $P3816["$GLOBALish"]
    unless_null $P3817, vivify_1755
    die "Contextual $*GLOBALish not found"
  vivify_1755:
  vivify_1754:
    store_dynamic_lex "$*PACKAGE", $P3817
.annotate 'line', 986
    find_dynamic_lex $P3820, "$*SC"
    unless_null $P3820, vivify_1756
    get_hll_global $P3818, "GLOBAL"
    get_who $P3819, $P3818
    set $P3820, $P3819["$SC"]
    unless_null $P3820, vivify_1757
    die "Contextual $*SC not found"
  vivify_1757:
  vivify_1756:
    find_lex $P3821, "$?PACKAGE"
    get_who $P3822, $P3821
    set $P3823, $P3822["@BLOCK"]
    unless_null $P3823, vivify_1758
    $P3823 = root_new ['parrot';'ResizablePMCArray']
  vivify_1758:
    set $P3824, $P3823[0]
    unless_null $P3824, vivify_1759
    new $P3824, "Undef"
  vivify_1759:
    find_dynamic_lex $P3827, "$*PACKAGE"
    unless_null $P3827, vivify_1760
    get_hll_global $P3825, "GLOBAL"
    get_who $P3826, $P3825
    set $P3827, $P3826["$PACKAGE"]
    unless_null $P3827, vivify_1761
    die "Contextual $*PACKAGE not found"
  vivify_1761:
  vivify_1760:
    $P3828 = $P3820."install_lexical_symbol"($P3824, "$?PACKAGE", $P3827)
.annotate 'line', 976
    .return ($P3828)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("449_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3830
    .param pmc param_3831
.annotate 'line', 989
    .lex "self", param_3830
    .lex "$/", param_3831
.annotate 'line', 990
    find_lex $P3832, "$/"
    find_lex $P3833, "self"
    $P3834 = $P3833."CTXSAVE"()
    $P3835 = $P3832."!make"($P3834)
.annotate 'line', 989
    .return ($P3835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("450_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3837
    .param pmc param_3838
.annotate 'line', 995
    .lex "self", param_3837
    .lex "$/", param_3838
.annotate 'line', 996
    new $P3839, "Undef"
    .lex "$module", $P3839
    find_dynamic_lex $P3842, "$*SC"
    unless_null $P3842, vivify_1762
    get_hll_global $P3840, "GLOBAL"
    get_who $P3841, $P3840
    set $P3842, $P3841["$SC"]
    unless_null $P3842, vivify_1763
    die "Contextual $*SC not found"
  vivify_1763:
  vivify_1762:
    find_lex $P3843, "$/"
    unless_null $P3843, vivify_1764
    $P3843 = root_new ['parrot';'Hash']
  vivify_1764:
    set $P3844, $P3843["name"]
    unless_null $P3844, vivify_1765
    new $P3844, "Undef"
  vivify_1765:
    set $S3845, $P3844
    find_dynamic_lex $P3848, "$*GLOBALish"
    unless_null $P3848, vivify_1766
    get_hll_global $P3846, "GLOBAL"
    get_who $P3847, $P3846
    set $P3848, $P3847["$GLOBALish"]
    unless_null $P3848, vivify_1767
    die "Contextual $*GLOBALish not found"
  vivify_1767:
  vivify_1766:
    $P3849 = $P3842."load_module"($S3845, $P3848)
    store_lex "$module", $P3849
.annotate 'line', 997
    find_lex $P3851, "$module"
    unless_null $P3851, vivify_1768
    new $P3851, "Undef"
  vivify_1768:
    defined $I3852, $P3851
    unless $I3852, if_3850_end
.annotate 'line', 998
    find_lex $P3853, "$module"
    unless_null $P3853, vivify_1769
    new $P3853, "Undef"
  vivify_1769:
    "import_HOW_exports"($P3853)
  if_3850_end:
.annotate 'line', 1000
    find_lex $P3854, "$/"
    get_hll_global $P3855, "GLOBAL"
    nqp_get_package_through_who $P3856, $P3855, "PAST"
    get_who $P3857, $P3856
    set $P3858, $P3857["Stmts"]
    $P3859 = $P3858."new"()
    $P3860 = $P3854."!make"($P3859)
.annotate 'line', 995
    .return ($P3860)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("451_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3862
    .param pmc param_3863
.annotate 'line', 1003
    .const 'Sub' $P3891 = "452_1303857440.612" 
    capture_lex $P3891
    .lex "self", param_3862
    .lex "$/", param_3863
.annotate 'line', 1004
    new $P3864, "Undef"
    .lex "$count", $P3864
.annotate 'line', 1005
    new $P3865, "Undef"
    .lex "$past", $P3865
.annotate 'line', 1004
    find_lex $P3866, "$/"
    unless_null $P3866, vivify_1770
    $P3866 = root_new ['parrot';'Hash']
  vivify_1770:
    set $P3867, $P3866["xblock"]
    unless_null $P3867, vivify_1771
    new $P3867, "Undef"
  vivify_1771:
    set $N3868, $P3867
    new $P3869, 'Float'
    set $P3869, $N3868
    sub $P3870, $P3869, 1
    store_lex "$count", $P3870
.annotate 'line', 1005
    find_lex $P3871, "$count"
    unless_null $P3871, vivify_1772
    new $P3871, "Undef"
  vivify_1772:
    set $I3872, $P3871
    find_lex $P3873, "$/"
    unless_null $P3873, vivify_1773
    $P3873 = root_new ['parrot';'Hash']
  vivify_1773:
    set $P3874, $P3873["xblock"]
    unless_null $P3874, vivify_1774
    $P3874 = root_new ['parrot';'ResizablePMCArray']
  vivify_1774:
    set $P3875, $P3874[$I3872]
    unless_null $P3875, vivify_1775
    new $P3875, "Undef"
  vivify_1775:
    $P3876 = $P3875."ast"()
    $P3877 = "xblock_immediate"($P3876)
    store_lex "$past", $P3877
.annotate 'line', 1006
    find_lex $P3879, "$/"
    unless_null $P3879, vivify_1776
    $P3879 = root_new ['parrot';'Hash']
  vivify_1776:
    set $P3880, $P3879["else"]
    unless_null $P3880, vivify_1777
    new $P3880, "Undef"
  vivify_1777:
    unless $P3880, if_3878_end
.annotate 'line', 1007
    find_lex $P3881, "$past"
    unless_null $P3881, vivify_1778
    new $P3881, "Undef"
  vivify_1778:
    find_lex $P3882, "$/"
    unless_null $P3882, vivify_1779
    $P3882 = root_new ['parrot';'Hash']
  vivify_1779:
    set $P3883, $P3882["else"]
    unless_null $P3883, vivify_1780
    $P3883 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    set $P3884, $P3883[0]
    unless_null $P3884, vivify_1781
    new $P3884, "Undef"
  vivify_1781:
    $P3885 = $P3884."ast"()
    $P3886 = "block_immediate"($P3885)
    $P3881."push"($P3886)
  if_3878_end:
.annotate 'line', 1010
    new $P3907, 'ExceptionHandler'
    set_label $P3907, loop3906_handler
    $P3907."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3907
  loop3906_test:
    find_lex $P3887, "$count"
    unless_null $P3887, vivify_1782
    new $P3887, "Undef"
  vivify_1782:
    set $N3888, $P3887
    isgt $I3889, $N3888, 0.0
    unless $I3889, loop3906_done
  loop3906_redo:
    .const 'Sub' $P3891 = "452_1303857440.612" 
    capture_lex $P3891
    $P3891()
  loop3906_next:
    goto loop3906_test
  loop3906_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3908, exception, 'type'
    eq $P3908, .CONTROL_LOOP_NEXT, loop3906_next
    eq $P3908, .CONTROL_LOOP_REDO, loop3906_redo
  loop3906_done:
    pop_eh 
.annotate 'line', 1016
    find_lex $P3909, "$/"
    find_lex $P3910, "$past"
    unless_null $P3910, vivify_1791
    new $P3910, "Undef"
  vivify_1791:
    $P3911 = $P3909."!make"($P3910)
.annotate 'line', 1003
    .return ($P3911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3890"  :anon :subid("452_1303857440.612") :outer("451_1303857440.612")
.annotate 'line', 1012
    new $P3892, "Undef"
    .lex "$else", $P3892
.annotate 'line', 1010
    find_lex $P3893, "$count"
    unless_null $P3893, vivify_1783
    new $P3893, "Undef"
  vivify_1783:
    clone $P3894, $P3893
    dec $P3893
.annotate 'line', 1012
    find_lex $P3895, "$past"
    unless_null $P3895, vivify_1784
    new $P3895, "Undef"
  vivify_1784:
    store_lex "$else", $P3895
.annotate 'line', 1013
    find_lex $P3896, "$count"
    unless_null $P3896, vivify_1785
    new $P3896, "Undef"
  vivify_1785:
    set $I3897, $P3896
    find_lex $P3898, "$/"
    unless_null $P3898, vivify_1786
    $P3898 = root_new ['parrot';'Hash']
  vivify_1786:
    set $P3899, $P3898["xblock"]
    unless_null $P3899, vivify_1787
    $P3899 = root_new ['parrot';'ResizablePMCArray']
  vivify_1787:
    set $P3900, $P3899[$I3897]
    unless_null $P3900, vivify_1788
    new $P3900, "Undef"
  vivify_1788:
    $P3901 = $P3900."ast"()
    $P3902 = "xblock_immediate"($P3901)
    store_lex "$past", $P3902
.annotate 'line', 1014
    find_lex $P3903, "$past"
    unless_null $P3903, vivify_1789
    new $P3903, "Undef"
  vivify_1789:
    find_lex $P3904, "$else"
    unless_null $P3904, vivify_1790
    new $P3904, "Undef"
  vivify_1790:
    $P3905 = $P3903."push"($P3904)
.annotate 'line', 1010
    .return ($P3905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("453_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3913
    .param pmc param_3914
.annotate 'line', 1019
    .lex "self", param_3913
    .lex "$/", param_3914
.annotate 'line', 1020
    new $P3915, "Undef"
    .lex "$past", $P3915
    find_lex $P3916, "$/"
    unless_null $P3916, vivify_1792
    $P3916 = root_new ['parrot';'Hash']
  vivify_1792:
    set $P3917, $P3916["xblock"]
    unless_null $P3917, vivify_1793
    new $P3917, "Undef"
  vivify_1793:
    $P3918 = $P3917."ast"()
    $P3919 = "xblock_immediate"($P3918)
    store_lex "$past", $P3919
.annotate 'line', 1021
    find_lex $P3920, "$past"
    unless_null $P3920, vivify_1794
    new $P3920, "Undef"
  vivify_1794:
    $P3920."pasttype"("unless")
.annotate 'line', 1022
    find_lex $P3921, "$/"
    find_lex $P3922, "$past"
    unless_null $P3922, vivify_1795
    new $P3922, "Undef"
  vivify_1795:
    $P3923 = $P3921."!make"($P3922)
.annotate 'line', 1019
    .return ($P3923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("454_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3925
    .param pmc param_3926
.annotate 'line', 1025
    .lex "self", param_3925
    .lex "$/", param_3926
.annotate 'line', 1026
    new $P3927, "Undef"
    .lex "$past", $P3927
    find_lex $P3928, "$/"
    unless_null $P3928, vivify_1796
    $P3928 = root_new ['parrot';'Hash']
  vivify_1796:
    set $P3929, $P3928["xblock"]
    unless_null $P3929, vivify_1797
    new $P3929, "Undef"
  vivify_1797:
    $P3930 = $P3929."ast"()
    $P3931 = "xblock_immediate"($P3930)
    store_lex "$past", $P3931
.annotate 'line', 1027
    find_lex $P3932, "$past"
    unless_null $P3932, vivify_1798
    new $P3932, "Undef"
  vivify_1798:
    find_lex $P3933, "$/"
    unless_null $P3933, vivify_1799
    $P3933 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P3934, $P3933["sym"]
    unless_null $P3934, vivify_1800
    new $P3934, "Undef"
  vivify_1800:
    set $S3935, $P3934
    $P3932."pasttype"($S3935)
.annotate 'line', 1028
    find_lex $P3936, "$/"
    find_lex $P3937, "$past"
    unless_null $P3937, vivify_1801
    new $P3937, "Undef"
  vivify_1801:
    $P3938 = $P3936."!make"($P3937)
.annotate 'line', 1025
    .return ($P3938)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("455_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3940
    .param pmc param_3941
.annotate 'line', 1031
    .lex "self", param_3940
    .lex "$/", param_3941
.annotate 'line', 1032
    new $P3942, "Undef"
    .lex "$pasttype", $P3942
.annotate 'line', 1033
    new $P3943, "Undef"
    .lex "$past", $P3943
.annotate 'line', 1032
    new $P3944, "String"
    assign $P3944, "repeat_"
    find_lex $P3945, "$/"
    unless_null $P3945, vivify_1802
    $P3945 = root_new ['parrot';'Hash']
  vivify_1802:
    set $P3946, $P3945["wu"]
    unless_null $P3946, vivify_1803
    new $P3946, "Undef"
  vivify_1803:
    set $S3947, $P3946
    concat $P3948, $P3944, $S3947
    store_lex "$pasttype", $P3948
    find_lex $P3949, "$past"
    unless_null $P3949, vivify_1804
    new $P3949, "Undef"
  vivify_1804:
.annotate 'line', 1034
    find_lex $P3951, "$/"
    unless_null $P3951, vivify_1805
    $P3951 = root_new ['parrot';'Hash']
  vivify_1805:
    set $P3952, $P3951["xblock"]
    unless_null $P3952, vivify_1806
    new $P3952, "Undef"
  vivify_1806:
    if $P3952, if_3950
.annotate 'line', 1039
    get_hll_global $P3959, "GLOBAL"
    nqp_get_package_through_who $P3960, $P3959, "PAST"
    get_who $P3961, $P3960
    set $P3962, $P3961["Op"]
    find_lex $P3963, "$/"
    unless_null $P3963, vivify_1807
    $P3963 = root_new ['parrot';'Hash']
  vivify_1807:
    set $P3964, $P3963["EXPR"]
    unless_null $P3964, vivify_1808
    new $P3964, "Undef"
  vivify_1808:
    $P3965 = $P3964."ast"()
    find_lex $P3966, "$/"
    unless_null $P3966, vivify_1809
    $P3966 = root_new ['parrot';'Hash']
  vivify_1809:
    set $P3967, $P3966["pblock"]
    unless_null $P3967, vivify_1810
    new $P3967, "Undef"
  vivify_1810:
    $P3968 = $P3967."ast"()
    $P3969 = "block_immediate"($P3968)
    find_lex $P3970, "$pasttype"
    unless_null $P3970, vivify_1811
    new $P3970, "Undef"
  vivify_1811:
    find_lex $P3971, "$/"
    unless_null $P3971, vivify_1812
    new $P3971, "Undef"
  vivify_1812:
    $P3972 = $P3962."new"($P3965, $P3969, $P3970 :named("pasttype"), $P3971 :named("node"))
    store_lex "$past", $P3972
.annotate 'line', 1038
    goto if_3950_end
  if_3950:
.annotate 'line', 1035
    find_lex $P3953, "$/"
    unless_null $P3953, vivify_1813
    $P3953 = root_new ['parrot';'Hash']
  vivify_1813:
    set $P3954, $P3953["xblock"]
    unless_null $P3954, vivify_1814
    new $P3954, "Undef"
  vivify_1814:
    $P3955 = $P3954."ast"()
    $P3956 = "xblock_immediate"($P3955)
    store_lex "$past", $P3956
.annotate 'line', 1036
    find_lex $P3957, "$past"
    unless_null $P3957, vivify_1815
    new $P3957, "Undef"
  vivify_1815:
    find_lex $P3958, "$pasttype"
    unless_null $P3958, vivify_1816
    new $P3958, "Undef"
  vivify_1816:
    $P3957."pasttype"($P3958)
  if_3950_end:
.annotate 'line', 1042
    find_lex $P3973, "$/"
    find_lex $P3974, "$past"
    unless_null $P3974, vivify_1817
    new $P3974, "Undef"
  vivify_1817:
    $P3975 = $P3973."!make"($P3974)
.annotate 'line', 1031
    .return ($P3975)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("456_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_3977
    .param pmc param_3978
.annotate 'line', 1045
    .lex "self", param_3977
    .lex "$/", param_3978
.annotate 'line', 1046
    new $P3979, "Undef"
    .lex "$past", $P3979
.annotate 'line', 1048
    new $P3980, "Undef"
    .lex "$block", $P3980
.annotate 'line', 1046
    find_lex $P3981, "$/"
    unless_null $P3981, vivify_1818
    $P3981 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P3982, $P3981["xblock"]
    unless_null $P3982, vivify_1819
    new $P3982, "Undef"
  vivify_1819:
    $P3983 = $P3982."ast"()
    store_lex "$past", $P3983
.annotate 'line', 1047
    find_lex $P3984, "$past"
    unless_null $P3984, vivify_1820
    new $P3984, "Undef"
  vivify_1820:
    $P3984."pasttype"("for")
.annotate 'line', 1048
    find_lex $P3985, "$past"
    unless_null $P3985, vivify_1821
    $P3985 = root_new ['parrot';'ResizablePMCArray']
  vivify_1821:
    set $P3986, $P3985[1]
    unless_null $P3986, vivify_1822
    new $P3986, "Undef"
  vivify_1822:
    store_lex "$block", $P3986
.annotate 'line', 1049
    find_lex $P3988, "$block"
    unless_null $P3988, vivify_1823
    new $P3988, "Undef"
  vivify_1823:
    $P3989 = $P3988."arity"()
    if $P3989, unless_3987_end
.annotate 'line', 1050
    find_lex $P3990, "$block"
    unless_null $P3990, vivify_1824
    $P3990 = root_new ['parrot';'ResizablePMCArray']
  vivify_1824:
    set $P3991, $P3990[0]
    unless_null $P3991, vivify_1825
    new $P3991, "Undef"
  vivify_1825:
    get_hll_global $P3992, "GLOBAL"
    nqp_get_package_through_who $P3993, $P3992, "PAST"
    get_who $P3994, $P3993
    set $P3995, $P3994["Var"]
    $P3996 = $P3995."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3991."push"($P3996)
.annotate 'line', 1051
    find_lex $P3997, "$block"
    unless_null $P3997, vivify_1826
    new $P3997, "Undef"
  vivify_1826:
    $P3997."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1052
    find_lex $P3998, "$block"
    unless_null $P3998, vivify_1827
    new $P3998, "Undef"
  vivify_1827:
    $P3998."arity"(1)
  unless_3987_end:
.annotate 'line', 1054
    find_lex $P3999, "$block"
    unless_null $P3999, vivify_1828
    new $P3999, "Undef"
  vivify_1828:
    $P3999."blocktype"("immediate")
.annotate 'line', 1055
    find_lex $P4000, "$/"
    find_lex $P4001, "$past"
    unless_null $P4001, vivify_1829
    new $P4001, "Undef"
  vivify_1829:
    $P4002 = $P4000."!make"($P4001)
.annotate 'line', 1045
    .return ($P4002)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("457_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4004
    .param pmc param_4005
.annotate 'line', 1058
    .lex "self", param_4004
    .lex "$/", param_4005
.annotate 'line', 1059
    new $P4006, "Undef"
    .lex "$block", $P4006
    find_lex $P4007, "$/"
    unless_null $P4007, vivify_1830
    $P4007 = root_new ['parrot';'Hash']
  vivify_1830:
    set $P4008, $P4007["block"]
    unless_null $P4008, vivify_1831
    new $P4008, "Undef"
  vivify_1831:
    $P4009 = $P4008."ast"()
    store_lex "$block", $P4009
.annotate 'line', 1060
    find_lex $P4010, "$/"
    unless_null $P4010, vivify_1832
    new $P4010, "Undef"
  vivify_1832:
    find_lex $P4011, "$block"
    unless_null $P4011, vivify_1833
    new $P4011, "Undef"
  vivify_1833:
    "push_block_handler"($P4010, $P4011)
.annotate 'line', 1061
    find_lex $P4012, "$?PACKAGE"
    get_who $P4013, $P4012
    set $P4014, $P4013["@BLOCK"]
    unless_null $P4014, vivify_1834
    $P4014 = root_new ['parrot';'ResizablePMCArray']
  vivify_1834:
    set $P4015, $P4014[0]
    unless_null $P4015, vivify_1835
    new $P4015, "Undef"
  vivify_1835:
    $P4016 = $P4015."handlers"()
    set $P4017, $P4016[0]
    unless_null $P4017, vivify_1836
    new $P4017, "Undef"
  vivify_1836:
    $P4017."handle_types_except"("CONTROL")
.annotate 'line', 1062
    find_lex $P4018, "$/"
    get_hll_global $P4019, "GLOBAL"
    nqp_get_package_through_who $P4020, $P4019, "PAST"
    get_who $P4021, $P4020
    set $P4022, $P4021["Stmts"]
    find_lex $P4023, "$/"
    unless_null $P4023, vivify_1837
    new $P4023, "Undef"
  vivify_1837:
    $P4024 = $P4022."new"($P4023 :named("node"))
    $P4025 = $P4018."!make"($P4024)
.annotate 'line', 1058
    .return ($P4025)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("458_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4027
    .param pmc param_4028
.annotate 'line', 1065
    .lex "self", param_4027
    .lex "$/", param_4028
.annotate 'line', 1066
    new $P4029, "Undef"
    .lex "$block", $P4029
    find_lex $P4030, "$/"
    unless_null $P4030, vivify_1838
    $P4030 = root_new ['parrot';'Hash']
  vivify_1838:
    set $P4031, $P4030["block"]
    unless_null $P4031, vivify_1839
    new $P4031, "Undef"
  vivify_1839:
    $P4032 = $P4031."ast"()
    store_lex "$block", $P4032
.annotate 'line', 1067
    find_lex $P4033, "$/"
    unless_null $P4033, vivify_1840
    new $P4033, "Undef"
  vivify_1840:
    find_lex $P4034, "$block"
    unless_null $P4034, vivify_1841
    new $P4034, "Undef"
  vivify_1841:
    "push_block_handler"($P4033, $P4034)
.annotate 'line', 1068
    find_lex $P4035, "$?PACKAGE"
    get_who $P4036, $P4035
    set $P4037, $P4036["@BLOCK"]
    unless_null $P4037, vivify_1842
    $P4037 = root_new ['parrot';'ResizablePMCArray']
  vivify_1842:
    set $P4038, $P4037[0]
    unless_null $P4038, vivify_1843
    new $P4038, "Undef"
  vivify_1843:
    $P4039 = $P4038."handlers"()
    set $P4040, $P4039[0]
    unless_null $P4040, vivify_1844
    new $P4040, "Undef"
  vivify_1844:
    $P4040."handle_types"("CONTROL")
.annotate 'line', 1069
    find_lex $P4041, "$/"
    get_hll_global $P4042, "GLOBAL"
    nqp_get_package_through_who $P4043, $P4042, "PAST"
    get_who $P4044, $P4043
    set $P4045, $P4044["Stmts"]
    find_lex $P4046, "$/"
    unless_null $P4046, vivify_1845
    new $P4046, "Undef"
  vivify_1845:
    $P4047 = $P4045."new"($P4046 :named("node"))
    $P4048 = $P4041."!make"($P4047)
.annotate 'line', 1065
    .return ($P4048)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("459_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4051
    .param pmc param_4052
.annotate 'line', 1109
    .lex "self", param_4051
    .lex "$/", param_4052
.annotate 'line', 1110
    find_lex $P4053, "$?PACKAGE"
    get_who $P4054, $P4053
    set $P4055, $P4054["@BLOCK"]
    unless_null $P4055, vivify_1846
    $P4055 = root_new ['parrot';'ResizablePMCArray']
  vivify_1846:
    set $P4056, $P4055[0]
    unless_null $P4056, vivify_1847
    new $P4056, "Undef"
  vivify_1847:
    find_lex $P4057, "$/"
    unless_null $P4057, vivify_1848
    $P4057 = root_new ['parrot';'Hash']
  vivify_1848:
    set $P4058, $P4057["blorst"]
    unless_null $P4058, vivify_1849
    new $P4058, "Undef"
  vivify_1849:
    $P4059 = $P4058."ast"()
    $P4056."push"($P4059)
.annotate 'line', 1111
    find_lex $P4060, "$/"
    get_hll_global $P4061, "GLOBAL"
    nqp_get_package_through_who $P4062, $P4061, "PAST"
    get_who $P4063, $P4062
    set $P4064, $P4063["Stmts"]
    $P4065 = $P4064."new"()
    $P4066 = $P4060."!make"($P4065)
.annotate 'line', 1109
    .return ($P4066)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("460_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4068
    .param pmc param_4069
.annotate 'line', 1114
    .lex "self", param_4068
    .lex "$/", param_4069
.annotate 'line', 1115
    new $P4070, "Undef"
    .lex "$past", $P4070
    find_lex $P4071, "$/"
    unless_null $P4071, vivify_1850
    $P4071 = root_new ['parrot';'Hash']
  vivify_1850:
    set $P4072, $P4071["blorst"]
    unless_null $P4072, vivify_1851
    new $P4072, "Undef"
  vivify_1851:
    $P4073 = $P4072."ast"()
    store_lex "$past", $P4073
.annotate 'line', 1116
    get_hll_global $P4075, "GLOBAL"
    nqp_get_package_through_who $P4076, $P4075, "PAST"
    get_who $P4077, $P4076
    set $P4078, $P4077["Block"]
    find_lex $P4079, "$past"
    unless_null $P4079, vivify_1852
    new $P4079, "Undef"
  vivify_1852:
    $P4080 = $P4078."ACCEPTS"($P4079)
    if $P4080, unless_4074_end
.annotate 'line', 1117
    get_hll_global $P4081, "GLOBAL"
    nqp_get_package_through_who $P4082, $P4081, "PAST"
    get_who $P4083, $P4082
    set $P4084, $P4083["Block"]
    find_lex $P4085, "$past"
    unless_null $P4085, vivify_1853
    new $P4085, "Undef"
  vivify_1853:
    find_lex $P4086, "$/"
    unless_null $P4086, vivify_1854
    new $P4086, "Undef"
  vivify_1854:
    $P4087 = $P4084."new"($P4085, "immediate" :named("blocktype"), $P4086 :named("node"))
    store_lex "$past", $P4087
  unless_4074_end:
.annotate 'line', 1119
    find_lex $P4089, "$past"
    unless_null $P4089, vivify_1855
    new $P4089, "Undef"
  vivify_1855:
    $P4090 = $P4089."handlers"()
    if $P4090, unless_4088_end
.annotate 'line', 1120
    find_lex $P4091, "$past"
    unless_null $P4091, vivify_1856
    new $P4091, "Undef"
  vivify_1856:
    get_hll_global $P4092, "GLOBAL"
    nqp_get_package_through_who $P4093, $P4092, "PAST"
    get_who $P4094, $P4093
    set $P4095, $P4094["Control"]
.annotate 'line', 1122
    get_hll_global $P4096, "GLOBAL"
    nqp_get_package_through_who $P4097, $P4096, "PAST"
    get_who $P4098, $P4097
    set $P4099, $P4098["Stmts"]
.annotate 'line', 1123
    get_hll_global $P4100, "GLOBAL"
    nqp_get_package_through_who $P4101, $P4100, "PAST"
    get_who $P4102, $P4101
    set $P4103, $P4102["Op"]
.annotate 'line', 1124
    get_hll_global $P4104, "GLOBAL"
    nqp_get_package_through_who $P4105, $P4104, "PAST"
    get_who $P4106, $P4105
    set $P4107, $P4106["Var"]
.annotate 'line', 1125
    get_hll_global $P4108, "GLOBAL"
    nqp_get_package_through_who $P4109, $P4108, "PAST"
    get_who $P4110, $P4109
    set $P4111, $P4110["Var"]
    $P4112 = $P4111."new"("register" :named("scope"), "exception" :named("name"))
    $P4113 = $P4107."new"($P4112, "handled", "keyed" :named("scope"))
.annotate 'line', 1124
    $P4114 = $P4103."new"($P4113, 1, "bind" :named("pasttype"))
.annotate 'line', 1123
    $P4115 = $P4099."new"($P4114)
.annotate 'line', 1122
    $P4116 = $P4095."new"($P4115, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1120
    new $P4117, "ResizablePMCArray"
    push $P4117, $P4116
    $P4091."handlers"($P4117)
  unless_4088_end:
.annotate 'line', 1134
    find_lex $P4118, "$/"
    find_lex $P4119, "$past"
    unless_null $P4119, vivify_1857
    new $P4119, "Undef"
  vivify_1857:
    $P4120 = $P4118."!make"($P4119)
.annotate 'line', 1114
    .return ($P4120)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("461_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4122
    .param pmc param_4123
.annotate 'line', 1137
    .lex "self", param_4122
    .lex "$/", param_4123
.annotate 'line', 1138
    find_lex $P4124, "$/"
.annotate 'line', 1139
    find_lex $P4127, "$/"
    unless_null $P4127, vivify_1858
    $P4127 = root_new ['parrot';'Hash']
  vivify_1858:
    set $P4128, $P4127["block"]
    unless_null $P4128, vivify_1859
    new $P4128, "Undef"
  vivify_1859:
    if $P4128, if_4126
.annotate 'line', 1140
    find_lex $P4133, "$/"
    unless_null $P4133, vivify_1860
    $P4133 = root_new ['parrot';'Hash']
  vivify_1860:
    set $P4134, $P4133["statement"]
    unless_null $P4134, vivify_1861
    new $P4134, "Undef"
  vivify_1861:
    $P4135 = $P4134."ast"()
    set $P4125, $P4135
.annotate 'line', 1139
    goto if_4126_end
  if_4126:
    find_lex $P4129, "$/"
    unless_null $P4129, vivify_1862
    $P4129 = root_new ['parrot';'Hash']
  vivify_1862:
    set $P4130, $P4129["block"]
    unless_null $P4130, vivify_1863
    new $P4130, "Undef"
  vivify_1863:
    $P4131 = $P4130."ast"()
    $P4132 = "block_immediate"($P4131)
    set $P4125, $P4132
  if_4126_end:
    $P4136 = $P4124."!make"($P4125)
.annotate 'line', 1137
    .return ($P4136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("462_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4138
    .param pmc param_4139
.annotate 'line', 1145
    .lex "self", param_4138
    .lex "$/", param_4139
    find_lex $P4140, "$/"
    find_lex $P4141, "$/"
    unless_null $P4141, vivify_1864
    $P4141 = root_new ['parrot';'Hash']
  vivify_1864:
    set $P4142, $P4141["cond"]
    unless_null $P4142, vivify_1865
    new $P4142, "Undef"
  vivify_1865:
    $P4143 = $P4142."ast"()
    $P4144 = $P4140."!make"($P4143)
    .return ($P4144)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("463_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4146
    .param pmc param_4147
.annotate 'line', 1146
    .lex "self", param_4146
    .lex "$/", param_4147
    find_lex $P4148, "$/"
    find_lex $P4149, "$/"
    unless_null $P4149, vivify_1866
    $P4149 = root_new ['parrot';'Hash']
  vivify_1866:
    set $P4150, $P4149["cond"]
    unless_null $P4150, vivify_1867
    new $P4150, "Undef"
  vivify_1867:
    $P4151 = $P4150."ast"()
    $P4152 = $P4148."!make"($P4151)
    .return ($P4152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("464_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4154
    .param pmc param_4155
.annotate 'line', 1148
    .lex "self", param_4154
    .lex "$/", param_4155
    find_lex $P4156, "$/"
    find_lex $P4157, "$/"
    unless_null $P4157, vivify_1868
    $P4157 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P4158, $P4157["cond"]
    unless_null $P4158, vivify_1869
    new $P4158, "Undef"
  vivify_1869:
    $P4159 = $P4158."ast"()
    $P4160 = $P4156."!make"($P4159)
    .return ($P4160)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("465_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4162
    .param pmc param_4163
.annotate 'line', 1149
    .lex "self", param_4162
    .lex "$/", param_4163
    find_lex $P4164, "$/"
    find_lex $P4165, "$/"
    unless_null $P4165, vivify_1870
    $P4165 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P4166, $P4165["cond"]
    unless_null $P4166, vivify_1871
    new $P4166, "Undef"
  vivify_1871:
    $P4167 = $P4166."ast"()
    $P4168 = $P4164."!make"($P4167)
    .return ($P4168)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("466_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4170
    .param pmc param_4171
.annotate 'line', 1153
    .lex "self", param_4170
    .lex "$/", param_4171
    find_lex $P4172, "$/"
    find_lex $P4173, "$/"
    unless_null $P4173, vivify_1872
    $P4173 = root_new ['parrot';'Hash']
  vivify_1872:
    set $P4174, $P4173["fatarrow"]
    unless_null $P4174, vivify_1873
    new $P4174, "Undef"
  vivify_1873:
    $P4175 = $P4174."ast"()
    $P4176 = $P4172."!make"($P4175)
    .return ($P4176)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("467_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4178
    .param pmc param_4179
.annotate 'line', 1154
    .lex "self", param_4178
    .lex "$/", param_4179
    find_lex $P4180, "$/"
    find_lex $P4181, "$/"
    unless_null $P4181, vivify_1874
    $P4181 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P4182, $P4181["colonpair"]
    unless_null $P4182, vivify_1875
    new $P4182, "Undef"
  vivify_1875:
    $P4183 = $P4182."ast"()
    $P4184 = $P4180."!make"($P4183)
    .return ($P4184)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("468_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4186
    .param pmc param_4187
.annotate 'line', 1155
    .lex "self", param_4186
    .lex "$/", param_4187
    find_lex $P4188, "$/"
    find_lex $P4189, "$/"
    unless_null $P4189, vivify_1876
    $P4189 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P4190, $P4189["variable"]
    unless_null $P4190, vivify_1877
    new $P4190, "Undef"
  vivify_1877:
    $P4191 = $P4190."ast"()
    $P4192 = $P4188."!make"($P4191)
    .return ($P4192)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("469_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4194
    .param pmc param_4195
.annotate 'line', 1156
    .lex "self", param_4194
    .lex "$/", param_4195
    find_lex $P4196, "$/"
    find_lex $P4197, "$/"
    unless_null $P4197, vivify_1878
    $P4197 = root_new ['parrot';'Hash']
  vivify_1878:
    set $P4198, $P4197["package_declarator"]
    unless_null $P4198, vivify_1879
    new $P4198, "Undef"
  vivify_1879:
    $P4199 = $P4198."ast"()
    $P4200 = $P4196."!make"($P4199)
    .return ($P4200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("470_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4202
    .param pmc param_4203
.annotate 'line', 1157
    .lex "self", param_4202
    .lex "$/", param_4203
    find_lex $P4204, "$/"
    find_lex $P4205, "$/"
    unless_null $P4205, vivify_1880
    $P4205 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P4206, $P4205["scope_declarator"]
    unless_null $P4206, vivify_1881
    new $P4206, "Undef"
  vivify_1881:
    $P4207 = $P4206."ast"()
    $P4208 = $P4204."!make"($P4207)
    .return ($P4208)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("471_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4210
    .param pmc param_4211
.annotate 'line', 1158
    .lex "self", param_4210
    .lex "$/", param_4211
    find_lex $P4212, "$/"
    find_lex $P4213, "$/"
    unless_null $P4213, vivify_1882
    $P4213 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P4214, $P4213["routine_declarator"]
    unless_null $P4214, vivify_1883
    new $P4214, "Undef"
  vivify_1883:
    $P4215 = $P4214."ast"()
    $P4216 = $P4212."!make"($P4215)
    .return ($P4216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("472_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4218
    .param pmc param_4219
.annotate 'line', 1159
    .lex "self", param_4218
    .lex "$/", param_4219
    find_lex $P4220, "$/"
    find_lex $P4221, "$/"
    unless_null $P4221, vivify_1884
    $P4221 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P4222, $P4221["regex_declarator"]
    unless_null $P4222, vivify_1885
    new $P4222, "Undef"
  vivify_1885:
    $P4223 = $P4222."ast"()
    $P4224 = $P4220."!make"($P4223)
    .return ($P4224)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("473_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4226
    .param pmc param_4227
.annotate 'line', 1160
    .lex "self", param_4226
    .lex "$/", param_4227
    find_lex $P4228, "$/"
    find_lex $P4229, "$/"
    unless_null $P4229, vivify_1886
    $P4229 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P4230, $P4229["statement_prefix"]
    unless_null $P4230, vivify_1887
    new $P4230, "Undef"
  vivify_1887:
    $P4231 = $P4230."ast"()
    $P4232 = $P4228."!make"($P4231)
    .return ($P4232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("474_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4234
    .param pmc param_4235
.annotate 'line', 1161
    .lex "self", param_4234
    .lex "$/", param_4235
    find_lex $P4236, "$/"
    find_lex $P4237, "$/"
    unless_null $P4237, vivify_1888
    $P4237 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P4238, $P4237["pblock"]
    unless_null $P4238, vivify_1889
    new $P4238, "Undef"
  vivify_1889:
    $P4239 = $P4238."ast"()
    $P4240 = $P4236."!make"($P4239)
    .return ($P4240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("475_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4242
    .param pmc param_4243
.annotate 'line', 1163
    .lex "self", param_4242
    .lex "$/", param_4243
.annotate 'line', 1164
    new $P4244, "Undef"
    .lex "$past", $P4244
    find_lex $P4245, "$/"
    unless_null $P4245, vivify_1890
    $P4245 = root_new ['parrot';'Hash']
  vivify_1890:
    set $P4246, $P4245["val"]
    unless_null $P4246, vivify_1891
    new $P4246, "Undef"
  vivify_1891:
    $P4247 = $P4246."ast"()
    store_lex "$past", $P4247
.annotate 'line', 1165
    find_lex $P4248, "$past"
    unless_null $P4248, vivify_1892
    new $P4248, "Undef"
  vivify_1892:
    find_lex $P4249, "$/"
    unless_null $P4249, vivify_1893
    $P4249 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P4250, $P4249["key"]
    unless_null $P4250, vivify_1894
    new $P4250, "Undef"
  vivify_1894:
    $P4251 = $P4250."Str"()
    $P4248."named"($P4251)
.annotate 'line', 1166
    find_lex $P4252, "$/"
    find_lex $P4253, "$past"
    unless_null $P4253, vivify_1895
    new $P4253, "Undef"
  vivify_1895:
    $P4254 = $P4252."!make"($P4253)
.annotate 'line', 1163
    .return ($P4254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("476_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4256
    .param pmc param_4257
.annotate 'line', 1169
    .lex "self", param_4256
    .lex "$/", param_4257
.annotate 'line', 1170
    new $P4258, "Undef"
    .lex "$past", $P4258
.annotate 'line', 1171
    find_lex $P4261, "$/"
    unless_null $P4261, vivify_1896
    $P4261 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P4262, $P4261["circumfix"]
    unless_null $P4262, vivify_1897
    new $P4262, "Undef"
  vivify_1897:
    if $P4262, if_4260
.annotate 'line', 1172
    get_hll_global $P4267, "GLOBAL"
    nqp_get_package_through_who $P4268, $P4267, "PAST"
    get_who $P4269, $P4268
    set $P4270, $P4269["Val"]
    find_lex $P4271, "$/"
    unless_null $P4271, vivify_1898
    $P4271 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P4272, $P4271["not"]
    unless_null $P4272, vivify_1899
    new $P4272, "Undef"
  vivify_1899:
    isfalse $I4273, $P4272
    $P4274 = $P4270."new"($I4273 :named("value"))
    set $P4259, $P4274
.annotate 'line', 1171
    goto if_4260_end
  if_4260:
    find_lex $P4263, "$/"
    unless_null $P4263, vivify_1900
    $P4263 = root_new ['parrot';'Hash']
  vivify_1900:
    set $P4264, $P4263["circumfix"]
    unless_null $P4264, vivify_1901
    $P4264 = root_new ['parrot';'ResizablePMCArray']
  vivify_1901:
    set $P4265, $P4264[0]
    unless_null $P4265, vivify_1902
    new $P4265, "Undef"
  vivify_1902:
    $P4266 = $P4265."ast"()
    set $P4259, $P4266
  if_4260_end:
    store_lex "$past", $P4259
.annotate 'line', 1173
    find_lex $P4275, "$past"
    unless_null $P4275, vivify_1903
    new $P4275, "Undef"
  vivify_1903:
    find_lex $P4276, "$/"
    unless_null $P4276, vivify_1904
    $P4276 = root_new ['parrot';'Hash']
  vivify_1904:
    set $P4277, $P4276["identifier"]
    unless_null $P4277, vivify_1905
    new $P4277, "Undef"
  vivify_1905:
    set $S4278, $P4277
    $P4275."named"($S4278)
.annotate 'line', 1174
    find_lex $P4279, "$/"
    find_lex $P4280, "$past"
    unless_null $P4280, vivify_1906
    new $P4280, "Undef"
  vivify_1906:
    $P4281 = $P4279."!make"($P4280)
.annotate 'line', 1169
    .return ($P4281)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("477_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4283
    .param pmc param_4284
.annotate 'line', 1177
    .const 'Sub' $P4300 = "478_1303857440.612" 
    capture_lex $P4300
    .lex "self", param_4283
    .lex "$/", param_4284
.annotate 'line', 1178
    new $P4285, "Undef"
    .lex "$past", $P4285
.annotate 'line', 1177
    find_lex $P4286, "$past"
    unless_null $P4286, vivify_1907
    new $P4286, "Undef"
  vivify_1907:
.annotate 'line', 1179
    find_lex $P4288, "$/"
    unless_null $P4288, vivify_1908
    $P4288 = root_new ['parrot';'Hash']
  vivify_1908:
    set $P4289, $P4288["postcircumfix"]
    unless_null $P4289, vivify_1909
    new $P4289, "Undef"
  vivify_1909:
    if $P4289, if_4287
.annotate 'line', 1183
    .const 'Sub' $P4300 = "478_1303857440.612" 
    capture_lex $P4300
    $P4300()
    goto if_4287_end
  if_4287:
.annotate 'line', 1180
    find_lex $P4290, "$/"
    unless_null $P4290, vivify_1948
    $P4290 = root_new ['parrot';'Hash']
  vivify_1948:
    set $P4291, $P4290["postcircumfix"]
    unless_null $P4291, vivify_1949
    new $P4291, "Undef"
  vivify_1949:
    $P4292 = $P4291."ast"()
    store_lex "$past", $P4292
.annotate 'line', 1181
    find_lex $P4293, "$past"
    unless_null $P4293, vivify_1950
    new $P4293, "Undef"
  vivify_1950:
    get_hll_global $P4294, "GLOBAL"
    nqp_get_package_through_who $P4295, $P4294, "PAST"
    get_who $P4296, $P4295
    set $P4297, $P4296["Var"]
    $P4298 = $P4297."new"("$/" :named("name"))
    $P4293."unshift"($P4298)
  if_4287_end:
.annotate 'line', 1221
    find_lex $P4421, "$/"
    find_lex $P4422, "$past"
    unless_null $P4422, vivify_1951
    new $P4422, "Undef"
  vivify_1951:
    $P4423 = $P4421."!make"($P4422)
.annotate 'line', 1177
    .return ($P4423)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4299"  :anon :subid("478_1303857440.612") :outer("477_1303857440.612")
.annotate 'line', 1183
    .const 'Sub' $P4335 = "479_1303857440.612" 
    capture_lex $P4335
.annotate 'line', 1184
    $P4301 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4301
    get_hll_global $P4302, "GLOBAL"
    nqp_get_package_through_who $P4303, $P4302, "NQP"
    get_who $P4304, $P4303
    set $P4305, $P4304["Compiler"]
    find_lex $P4306, "$/"
    unless_null $P4306, vivify_1910
    new $P4306, "Undef"
  vivify_1910:
    set $S4307, $P4306
    $P4308 = $P4305."parse_name"($S4307)
    store_lex "@name", $P4308
.annotate 'line', 1185
    find_lex $P4311, "@name"
    unless_null $P4311, vivify_1911
    $P4311 = root_new ['parrot';'ResizablePMCArray']
  vivify_1911:
    set $N4312, $P4311
    isgt $I4313, $N4312, 1.0
    if $I4313, if_4310
.annotate 'line', 1192
    find_lex $P4329, "$/"
    unless_null $P4329, vivify_1912
    $P4329 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P4330, $P4329["twigil"]
    unless_null $P4330, vivify_1913
    $P4330 = root_new ['parrot';'ResizablePMCArray']
  vivify_1913:
    set $P4331, $P4330[0]
    unless_null $P4331, vivify_1914
    new $P4331, "Undef"
  vivify_1914:
    set $S4332, $P4331
    iseq $I4333, $S4332, "*"
    if $I4333, if_4328
.annotate 'line', 1203
    find_lex $P4370, "$/"
    unless_null $P4370, vivify_1915
    $P4370 = root_new ['parrot';'Hash']
  vivify_1915:
    set $P4371, $P4370["twigil"]
    unless_null $P4371, vivify_1916
    $P4371 = root_new ['parrot';'ResizablePMCArray']
  vivify_1916:
    set $P4372, $P4371[0]
    unless_null $P4372, vivify_1917
    new $P4372, "Undef"
  vivify_1917:
    set $S4373, $P4372
    iseq $I4374, $S4373, "!"
    if $I4374, if_4369
.annotate 'line', 1211
    find_lex $P4398, "@name"
    unless_null $P4398, vivify_1918
    $P4398 = root_new ['parrot';'ResizablePMCArray']
  vivify_1918:
    set $P4399, $P4398[0]
    unless_null $P4399, vivify_1919
    new $P4399, "Undef"
  vivify_1919:
    set $S4400, $P4399
    $P4401 = "is_package"($S4400)
    if $P4401, if_4397
.annotate 'line', 1216
    get_hll_global $P4410, "GLOBAL"
    nqp_get_package_through_who $P4411, $P4410, "PAST"
    get_who $P4412, $P4411
    set $P4413, $P4412["Var"]
.annotate 'line', 1217
    find_lex $P4414, "@name"
    unless_null $P4414, vivify_1920
    $P4414 = root_new ['parrot';'ResizablePMCArray']
  vivify_1920:
    $P4415 = $P4414."pop"()
    set $S4416, $P4415
    find_lex $P4417, "$/"
    unless_null $P4417, vivify_1921
    $P4417 = root_new ['parrot';'Hash']
  vivify_1921:
    set $P4418, $P4417["sigil"]
    unless_null $P4418, vivify_1922
    new $P4418, "Undef"
  vivify_1922:
    $P4419 = "vivitype"($P4418)
    $P4420 = $P4413."new"($S4416 :named("name"), $P4419 :named("viviself"))
.annotate 'line', 1216
    store_lex "$past", $P4420
.annotate 'line', 1215
    set $P4396, $P4420
.annotate 'line', 1211
    goto if_4397_end
  if_4397:
.annotate 'line', 1212
    find_lex $P4402, "@name"
    unless_null $P4402, vivify_1923
    $P4402 = root_new ['parrot';'ResizablePMCArray']
  vivify_1923:
    find_lex $P4403, "$/"
    unless_null $P4403, vivify_1924
    new $P4403, "Undef"
  vivify_1924:
    $P4404 = "lexical_package_lookup"($P4402, $P4403)
    store_lex "$past", $P4404
.annotate 'line', 1213
    find_lex $P4405, "$past"
    unless_null $P4405, vivify_1925
    new $P4405, "Undef"
  vivify_1925:
    find_lex $P4406, "$/"
    unless_null $P4406, vivify_1926
    $P4406 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P4407, $P4406["sigil"]
    unless_null $P4407, vivify_1927
    new $P4407, "Undef"
  vivify_1927:
    $P4408 = "vivitype"($P4407)
    $P4409 = $P4405."viviself"($P4408)
.annotate 'line', 1211
    set $P4396, $P4409
  if_4397_end:
    set $P4368, $P4396
.annotate 'line', 1203
    goto if_4369_end
  if_4369:
.annotate 'line', 1204
    get_hll_global $P4375, "GLOBAL"
    nqp_get_package_through_who $P4376, $P4375, "PAST"
    get_who $P4377, $P4376
    set $P4378, $P4377["Var"]
.annotate 'line', 1205
    find_lex $P4379, "@name"
    unless_null $P4379, vivify_1928
    $P4379 = root_new ['parrot';'ResizablePMCArray']
  vivify_1928:
    $P4380 = $P4379."pop"()
    set $S4381, $P4380
.annotate 'line', 1206
    find_lex $P4382, "$/"
    unless_null $P4382, vivify_1929
    $P4382 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P4383, $P4382["sigil"]
    unless_null $P4383, vivify_1930
    new $P4383, "Undef"
  vivify_1930:
    $P4384 = "vivitype"($P4383)
.annotate 'line', 1207
    get_hll_global $P4385, "GLOBAL"
    nqp_get_package_through_who $P4386, $P4385, "PAST"
    get_who $P4387, $P4386
    set $P4388, $P4387["Var"]
    $P4389 = $P4388."new"("self" :named("name"))
.annotate 'line', 1208
    get_hll_global $P4390, "GLOBAL"
    nqp_get_package_through_who $P4391, $P4390, "PAST"
    get_who $P4392, $P4391
    set $P4393, $P4392["Var"]
    $P4394 = $P4393."new"("$?CLASS" :named("name"))
    $P4395 = $P4378."new"($P4389, $P4394, $S4381 :named("name"), "attribute" :named("scope"), $P4384 :named("viviself"))
.annotate 'line', 1204
    store_lex "$past", $P4395
.annotate 'line', 1203
    set $P4368, $P4395
  if_4369_end:
    set $P4327, $P4368
.annotate 'line', 1192
    goto if_4328_end
  if_4328:
    .const 'Sub' $P4335 = "479_1303857440.612" 
    capture_lex $P4335
    $P4367 = $P4335()
    set $P4327, $P4367
  if_4328_end:
    set $P4309, $P4327
.annotate 'line', 1185
    goto if_4310_end
  if_4310:
.annotate 'line', 1186
    find_lex $P4315, "$/"
    unless_null $P4315, vivify_1940
    $P4315 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P4316, $P4315["twigil"]
    unless_null $P4316, vivify_1941
    new $P4316, "Undef"
  vivify_1941:
    unless $P4316, if_4314_end
.annotate 'line', 1187
    find_lex $P4317, "$/"
    unless_null $P4317, vivify_1942
    new $P4317, "Undef"
  vivify_1942:
    $P4318 = $P4317."CURSOR"()
    $P4318."panic"("Twigil not allowed on multi-part name")
  if_4314_end:
.annotate 'line', 1189
    find_lex $P4319, "@name"
    unless_null $P4319, vivify_1943
    $P4319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1943:
    find_lex $P4320, "$/"
    unless_null $P4320, vivify_1944
    new $P4320, "Undef"
  vivify_1944:
    $P4321 = "lexical_package_lookup"($P4319, $P4320)
    store_lex "$past", $P4321
.annotate 'line', 1190
    find_lex $P4322, "$past"
    unless_null $P4322, vivify_1945
    new $P4322, "Undef"
  vivify_1945:
    find_lex $P4323, "$/"
    unless_null $P4323, vivify_1946
    $P4323 = root_new ['parrot';'Hash']
  vivify_1946:
    set $P4324, $P4323["sigil"]
    unless_null $P4324, vivify_1947
    new $P4324, "Undef"
  vivify_1947:
    $P4325 = "vivitype"($P4324)
    $P4326 = $P4322."viviself"($P4325)
.annotate 'line', 1185
    set $P4309, $P4326
  if_4310_end:
.annotate 'line', 1183
    .return ($P4309)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4334"  :anon :subid("479_1303857440.612") :outer("478_1303857440.612")
.annotate 'line', 1193
    new $P4336, "Undef"
    .lex "$global_fallback", $P4336
    find_lex $P4337, "$/"
    unless_null $P4337, vivify_1931
    $P4337 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P4338, $P4337["sigil"]
    unless_null $P4338, vivify_1932
    new $P4338, "Undef"
  vivify_1932:
    set $S4339, $P4338
    new $P4340, 'String'
    set $P4340, $S4339
    find_lex $P4341, "$/"
    unless_null $P4341, vivify_1933
    $P4341 = root_new ['parrot';'Hash']
  vivify_1933:
    set $P4342, $P4341["desigilname"]
    unless_null $P4342, vivify_1934
    new $P4342, "Undef"
  vivify_1934:
    concat $P4343, $P4340, $P4342
    new $P4344, "ResizablePMCArray"
    push $P4344, "GLOBAL"
    push $P4344, $P4343
    find_lex $P4345, "$/"
    unless_null $P4345, vivify_1935
    new $P4345, "Undef"
  vivify_1935:
    $P4346 = "lexical_package_lookup"($P4344, $P4345)
    store_lex "$global_fallback", $P4346
.annotate 'line', 1194
    find_lex $P4347, "$global_fallback"
    unless_null $P4347, vivify_1936
    new $P4347, "Undef"
  vivify_1936:
    get_hll_global $P4348, "GLOBAL"
    nqp_get_package_through_who $P4349, $P4348, "PAST"
    get_who $P4350, $P4349
    set $P4351, $P4350["Op"]
.annotate 'line', 1195
    new $P4352, "String"
    assign $P4352, "Contextual "
    find_lex $P4353, "$/"
    unless_null $P4353, vivify_1937
    new $P4353, "Undef"
  vivify_1937:
    set $S4354, $P4353
    concat $P4355, $P4352, $S4354
    concat $P4356, $P4355, " not found"
    $P4357 = $P4351."new"($P4356, "die" :named("pirop"))
.annotate 'line', 1194
    $P4347."viviself"($P4357)
.annotate 'line', 1198
    get_hll_global $P4358, "GLOBAL"
    nqp_get_package_through_who $P4359, $P4358, "PAST"
    get_who $P4360, $P4359
    set $P4361, $P4360["Var"]
.annotate 'line', 1199
    find_lex $P4362, "@name"
    unless_null $P4362, vivify_1938
    $P4362 = root_new ['parrot';'ResizablePMCArray']
  vivify_1938:
    $P4363 = $P4362."pop"()
    set $S4364, $P4363
    find_lex $P4365, "$global_fallback"
    unless_null $P4365, vivify_1939
    new $P4365, "Undef"
  vivify_1939:
    $P4366 = $P4361."new"($S4364 :named("name"), "contextual" :named("scope"), $P4365 :named("viviself"))
.annotate 'line', 1198
    store_lex "$past", $P4366
.annotate 'line', 1192
    .return ($P4366)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("480_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4425
    .param pmc param_4426
.annotate 'line', 1224
    .lex "self", param_4425
    .lex "$/", param_4426
    find_lex $P4427, "$/"
    find_lex $P4428, "$/"
    unless_null $P4428, vivify_1952
    $P4428 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P4429, $P4428["package_def"]
    unless_null $P4429, vivify_1953
    new $P4429, "Undef"
  vivify_1953:
    $P4430 = $P4429."ast"()
    $P4431 = $P4427."!make"($P4430)
    .return ($P4431)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("481_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4433
    .param pmc param_4434
.annotate 'line', 1225
    .lex "self", param_4433
    .lex "$/", param_4434
    find_lex $P4435, "$/"
    find_lex $P4436, "$/"
    unless_null $P4436, vivify_1954
    $P4436 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P4437, $P4436["package_def"]
    unless_null $P4437, vivify_1955
    new $P4437, "Undef"
  vivify_1955:
    $P4438 = $P4437."ast"()
    $P4439 = $P4435."!make"($P4438)
    .return ($P4439)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("482_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4441
    .param pmc param_4442
.annotate 'line', 1226
    .lex "self", param_4441
    .lex "$/", param_4442
    find_lex $P4443, "$/"
    find_lex $P4444, "$/"
    unless_null $P4444, vivify_1956
    $P4444 = root_new ['parrot';'Hash']
  vivify_1956:
    set $P4445, $P4444["package_def"]
    unless_null $P4445, vivify_1957
    new $P4445, "Undef"
  vivify_1957:
    $P4446 = $P4445."ast"()
    $P4447 = $P4443."!make"($P4446)
    .return ($P4447)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("483_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4449
    .param pmc param_4450
.annotate 'line', 1227
    .lex "self", param_4449
    .lex "$/", param_4450
    find_lex $P4451, "$/"
    find_lex $P4452, "$/"
    unless_null $P4452, vivify_1958
    $P4452 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P4453, $P4452["package_def"]
    unless_null $P4453, vivify_1959
    new $P4453, "Undef"
  vivify_1959:
    $P4454 = $P4453."ast"()
    $P4455 = $P4451."!make"($P4454)
    .return ($P4455)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("484_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4457
    .param pmc param_4458
.annotate 'line', 1228
    .lex "self", param_4457
    .lex "$/", param_4458
    find_lex $P4459, "$/"
    find_lex $P4460, "$/"
    unless_null $P4460, vivify_1960
    $P4460 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P4461, $P4460["package_def"]
    unless_null $P4461, vivify_1961
    new $P4461, "Undef"
  vivify_1961:
    $P4462 = $P4461."ast"()
    $P4463 = $P4459."!make"($P4462)
    .return ($P4463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("485_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4465
    .param pmc param_4466
.annotate 'line', 1229
    .lex "self", param_4465
    .lex "$/", param_4466
    find_lex $P4467, "$/"
    find_lex $P4468, "$/"
    unless_null $P4468, vivify_1962
    $P4468 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P4469, $P4468["package_def"]
    unless_null $P4469, vivify_1963
    new $P4469, "Undef"
  vivify_1963:
    $P4470 = $P4469."ast"()
    $P4471 = $P4467."!make"($P4470)
    .return ($P4471)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("486_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4473
    .param pmc param_4474
.annotate 'line', 1231
    .const 'Sub' $P4701 = "490_1303857440.612" 
    capture_lex $P4701
    .const 'Sub' $P4671 = "489_1303857440.612" 
    capture_lex $P4671
    .const 'Sub' $P4624 = "487_1303857440.612" 
    capture_lex $P4624
    .lex "self", param_4473
    .lex "$/", param_4474
.annotate 'line', 1233
    $P4475 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4475
.annotate 'line', 1234
    new $P4476, "Undef"
    .lex "$name", $P4476
.annotate 'line', 1235
    new $P4477, "Undef"
    .lex "$how", $P4477
.annotate 'line', 1238
    new $P4478, "Undef"
    .lex "$past", $P4478
.annotate 'line', 1233
    find_lex $P4479, "$/"
    unless_null $P4479, vivify_1964
    $P4479 = root_new ['parrot';'Hash']
  vivify_1964:
    set $P4480, $P4479["name"]
    unless_null $P4480, vivify_1965
    $P4480 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P4481, $P4480["identifier"]
    unless_null $P4481, vivify_1966
    new $P4481, "Undef"
  vivify_1966:
    clone $P4482, $P4481
    store_lex "@ns", $P4482
.annotate 'line', 1234
    find_lex $P4483, "@ns"
    unless_null $P4483, vivify_1967
    $P4483 = root_new ['parrot';'ResizablePMCArray']
  vivify_1967:
    $P4484 = $P4483."pop"()
    set $S4485, $P4484
    new $P4486, 'String'
    set $P4486, $S4485
    store_lex "$name", $P4486
.annotate 'line', 1235
    find_dynamic_lex $P4489, "$*PKGDECL"
    unless_null $P4489, vivify_1968
    get_hll_global $P4487, "GLOBAL"
    get_who $P4488, $P4487
    set $P4489, $P4488["$PKGDECL"]
    unless_null $P4489, vivify_1969
    die "Contextual $*PKGDECL not found"
  vivify_1969:
  vivify_1968:
    find_dynamic_lex $P4492, "%*HOW"
    unless_null $P4492, vivify_1970
    get_hll_global $P4490, "GLOBAL"
    get_who $P4491, $P4490
    set $P4492, $P4491["%HOW"]
    unless_null $P4492, vivify_1971
    die "Contextual %*HOW not found"
  vivify_1971:
  vivify_1970:
    set $P4493, $P4492[$P4489]
    unless_null $P4493, vivify_1972
    new $P4493, "Undef"
  vivify_1972:
    store_lex "$how", $P4493
.annotate 'line', 1238
    find_lex $P4496, "$/"
    unless_null $P4496, vivify_1973
    $P4496 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P4497, $P4496["block"]
    unless_null $P4497, vivify_1974
    new $P4497, "Undef"
  vivify_1974:
    if $P4497, if_4495
    find_lex $P4501, "$/"
    unless_null $P4501, vivify_1975
    $P4501 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P4502, $P4501["comp_unit"]
    unless_null $P4502, vivify_1976
    new $P4502, "Undef"
  vivify_1976:
    $P4503 = $P4502."ast"()
    set $P4494, $P4503
    goto if_4495_end
  if_4495:
    find_lex $P4498, "$/"
    unless_null $P4498, vivify_1977
    $P4498 = root_new ['parrot';'Hash']
  vivify_1977:
    set $P4499, $P4498["block"]
    unless_null $P4499, vivify_1978
    new $P4499, "Undef"
  vivify_1978:
    $P4500 = $P4499."ast"()
    set $P4494, $P4500
  if_4495_end:
    store_lex "$past", $P4494
.annotate 'line', 1239
    find_dynamic_lex $P4509, "$*SCOPE"
    unless_null $P4509, vivify_1979
    get_hll_global $P4507, "GLOBAL"
    get_who $P4508, $P4507
    set $P4509, $P4508["$SCOPE"]
    unless_null $P4509, vivify_1980
    die "Contextual $*SCOPE not found"
  vivify_1980:
  vivify_1979:
    set $S4510, $P4509
    iseq $I4511, $S4510, "our"
    unless $I4511, unless_4506
    new $P4505, 'Integer'
    set $P4505, $I4511
    goto unless_4506_end
  unless_4506:
    find_dynamic_lex $P4514, "$*SCOPE"
    unless_null $P4514, vivify_1981
    get_hll_global $P4512, "GLOBAL"
    get_who $P4513, $P4512
    set $P4514, $P4513["$SCOPE"]
    unless_null $P4514, vivify_1982
    die "Contextual $*SCOPE not found"
  vivify_1982:
  vivify_1981:
    set $S4515, $P4514
    iseq $I4516, $S4515, ""
    new $P4505, 'Integer'
    set $P4505, $I4516
  unless_4506_end:
    unless $P4505, if_4504_end
.annotate 'line', 1240
    find_lex $P4517, "$past"
    unless_null $P4517, vivify_1983
    new $P4517, "Undef"
  vivify_1983:
    find_lex $P4518, "$/"
    unless_null $P4518, vivify_1984
    $P4518 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4519, $P4518["name"]
    unless_null $P4519, vivify_1985
    $P4519 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P4520, $P4519["identifier"]
    unless_null $P4520, vivify_1986
    new $P4520, "Undef"
  vivify_1986:
    $P4517."namespace"($P4520)
  if_4504_end:
.annotate 'line', 1244
    find_dynamic_lex $P4523, "$*PACKAGE-SETUP"
    unless_null $P4523, vivify_1987
    get_hll_global $P4521, "GLOBAL"
    get_who $P4522, $P4521
    set $P4523, $P4522["$PACKAGE-SETUP"]
    unless_null $P4523, vivify_1988
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1988:
  vivify_1987:
    get_hll_global $P4524, "GLOBAL"
    nqp_get_package_through_who $P4525, $P4524, "PAST"
    get_who $P4526, $P4525
    set $P4527, $P4526["Stmts"]
.annotate 'line', 1245
    get_hll_global $P4528, "GLOBAL"
    nqp_get_package_through_who $P4529, $P4528, "PAST"
    get_who $P4530, $P4529
    set $P4531, $P4530["Op"]
.annotate 'line', 1246
    get_hll_global $P4532, "GLOBAL"
    nqp_get_package_through_who $P4533, $P4532, "PAST"
    get_who $P4534, $P4533
    set $P4535, $P4534["Var"]
    $P4536 = $P4535."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1247
    find_dynamic_lex $P4539, "$*SC"
    unless_null $P4539, vivify_1989
    get_hll_global $P4537, "GLOBAL"
    get_who $P4538, $P4537
    set $P4539, $P4538["$SC"]
    unless_null $P4539, vivify_1990
    die "Contextual $*SC not found"
  vivify_1990:
  vivify_1989:
    find_dynamic_lex $P4542, "$*PACKAGE"
    unless_null $P4542, vivify_1991
    get_hll_global $P4540, "GLOBAL"
    get_who $P4541, $P4540
    set $P4542, $P4541["$PACKAGE"]
    unless_null $P4542, vivify_1992
    die "Contextual $*PACKAGE not found"
  vivify_1992:
  vivify_1991:
    $P4543 = $P4539."get_slot_past_for_object"($P4542)
    $P4544 = $P4531."new"($P4536, $P4543, "bind" :named("pasttype"))
.annotate 'line', 1245
    $P4545 = $P4527."new"($P4544)
.annotate 'line', 1244
    $P4523."unshift"($P4545)
.annotate 'line', 1255
    find_lex $P4549, "$how"
    unless_null $P4549, vivify_1993
    new $P4549, "Undef"
  vivify_1993:
    can $I4550, $P4549, "parametric"
    if $I4550, if_4548
    new $P4547, 'Integer'
    set $P4547, $I4550
    goto if_4548_end
  if_4548:
    find_lex $P4551, "$how"
    unless_null $P4551, vivify_1994
    new $P4551, "Undef"
  vivify_1994:
    find_lex $P4552, "$how"
    unless_null $P4552, vivify_1995
    new $P4552, "Undef"
  vivify_1995:
    $P4553 = $P4551."parametric"($P4552)
    set $P4547, $P4553
  if_4548_end:
    if $P4547, if_4546
.annotate 'line', 1273
    find_lex $P4605, "$past"
    unless_null $P4605, vivify_1996
    new $P4605, "Undef"
  vivify_1996:
    $P4605."blocktype"("immediate")
.annotate 'line', 1274
    find_dynamic_lex $P4608, "$*SC"
    unless_null $P4608, vivify_1997
    get_hll_global $P4606, "GLOBAL"
    get_who $P4607, $P4606
    set $P4608, $P4607["$SC"]
    unless_null $P4608, vivify_1998
    die "Contextual $*SC not found"
  vivify_1998:
  vivify_1997:
    find_lex $P4609, "$past"
    unless_null $P4609, vivify_1999
    new $P4609, "Undef"
  vivify_1999:
    find_dynamic_lex $P4612, "$*PACKAGE"
    unless_null $P4612, vivify_2000
    get_hll_global $P4610, "GLOBAL"
    get_who $P4611, $P4610
    set $P4612, $P4611["$PACKAGE"]
    unless_null $P4612, vivify_2001
    die "Contextual $*PACKAGE not found"
  vivify_2001:
  vivify_2000:
    $P4608."install_lexical_symbol"($P4609, "$?PACKAGE", $P4612)
.annotate 'line', 1275
    find_dynamic_lex $P4615, "$*SC"
    unless_null $P4615, vivify_2002
    get_hll_global $P4613, "GLOBAL"
    get_who $P4614, $P4613
    set $P4615, $P4614["$SC"]
    unless_null $P4615, vivify_2003
    die "Contextual $*SC not found"
  vivify_2003:
  vivify_2002:
    find_lex $P4616, "$past"
    unless_null $P4616, vivify_2004
    new $P4616, "Undef"
  vivify_2004:
    find_dynamic_lex $P4619, "$*PACKAGE"
    unless_null $P4619, vivify_2005
    get_hll_global $P4617, "GLOBAL"
    get_who $P4618, $P4617
    set $P4619, $P4618["$PACKAGE"]
    unless_null $P4619, vivify_2006
    die "Contextual $*PACKAGE not found"
  vivify_2006:
  vivify_2005:
    $P4615."install_lexical_symbol"($P4616, "$?CLASS", $P4619)
.annotate 'line', 1272
    goto if_4546_end
  if_4546:
.annotate 'line', 1256
    find_lex $P4554, "$past"
    unless_null $P4554, vivify_2007
    new $P4554, "Undef"
  vivify_2007:
    $P4554."blocktype"("declaration")
.annotate 'line', 1257
    find_lex $P4555, "$past"
    unless_null $P4555, vivify_2008
    new $P4555, "Undef"
  vivify_2008:
    get_hll_global $P4556, "GLOBAL"
    nqp_get_package_through_who $P4557, $P4556, "PAST"
    get_who $P4558, $P4557
    set $P4559, $P4558["Var"]
    $P4560 = $P4559."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4555."unshift"($P4560)
.annotate 'line', 1258
    find_lex $P4561, "$past"
    unless_null $P4561, vivify_2009
    new $P4561, "Undef"
  vivify_2009:
    $P4561."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1259
    find_dynamic_lex $P4564, "$*PACKAGE-SETUP"
    unless_null $P4564, vivify_2010
    get_hll_global $P4562, "GLOBAL"
    get_who $P4563, $P4562
    set $P4564, $P4563["$PACKAGE-SETUP"]
    unless_null $P4564, vivify_2011
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2011:
  vivify_2010:
    get_hll_global $P4565, "GLOBAL"
    nqp_get_package_through_who $P4566, $P4565, "PAST"
    get_who $P4567, $P4566
    set $P4568, $P4567["Op"]
.annotate 'line', 1261
    get_hll_global $P4569, "GLOBAL"
    nqp_get_package_through_who $P4570, $P4569, "PAST"
    get_who $P4571, $P4570
    set $P4572, $P4571["Op"]
.annotate 'line', 1264
    get_hll_global $P4573, "GLOBAL"
    nqp_get_package_through_who $P4574, $P4573, "PAST"
    get_who $P4575, $P4574
    set $P4576, $P4575["Var"]
    $P4577 = $P4576."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4578 = $P4572."new"($P4577, "get_how PP" :named("pirop"))
.annotate 'line', 1266
    get_hll_global $P4579, "GLOBAL"
    nqp_get_package_through_who $P4580, $P4579, "PAST"
    get_who $P4581, $P4580
    set $P4582, $P4581["Var"]
    $P4583 = $P4582."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1267
    get_hll_global $P4584, "GLOBAL"
    nqp_get_package_through_who $P4585, $P4584, "PAST"
    get_who $P4586, $P4585
    set $P4587, $P4586["Val"]
    find_lex $P4588, "$past"
    unless_null $P4588, vivify_2012
    new $P4588, "Undef"
  vivify_2012:
    $P4589 = $P4587."new"($P4588 :named("value"))
    $P4590 = $P4568."new"($P4578, $P4583, $P4589, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1259
    $P4564."push"($P4590)
.annotate 'line', 1269
    find_dynamic_lex $P4593, "$*SC"
    unless_null $P4593, vivify_2013
    get_hll_global $P4591, "GLOBAL"
    get_who $P4592, $P4591
    set $P4593, $P4592["$SC"]
    unless_null $P4593, vivify_2014
    die "Contextual $*SC not found"
  vivify_2014:
  vivify_2013:
    find_lex $P4594, "$past"
    unless_null $P4594, vivify_2015
    new $P4594, "Undef"
  vivify_2015:
    find_dynamic_lex $P4597, "$*PACKAGE"
    unless_null $P4597, vivify_2016
    get_hll_global $P4595, "GLOBAL"
    get_who $P4596, $P4595
    set $P4597, $P4596["$PACKAGE"]
    unless_null $P4597, vivify_2017
    die "Contextual $*PACKAGE not found"
  vivify_2017:
  vivify_2016:
    $P4593."install_lexical_symbol"($P4594, "$?PACKAGE", $P4597)
.annotate 'line', 1270
    find_dynamic_lex $P4600, "$*SC"
    unless_null $P4600, vivify_2018
    get_hll_global $P4598, "GLOBAL"
    get_who $P4599, $P4598
    set $P4600, $P4599["$SC"]
    unless_null $P4600, vivify_2019
    die "Contextual $*SC not found"
  vivify_2019:
  vivify_2018:
    find_lex $P4601, "$past"
    unless_null $P4601, vivify_2020
    new $P4601, "Undef"
  vivify_2020:
    find_dynamic_lex $P4604, "$*PACKAGE"
    unless_null $P4604, vivify_2021
    get_hll_global $P4602, "GLOBAL"
    get_who $P4603, $P4602
    set $P4604, $P4603["$PACKAGE"]
    unless_null $P4604, vivify_2022
    die "Contextual $*PACKAGE not found"
  vivify_2022:
  vivify_2021:
    $P4600."install_lexical_symbol"($P4601, "$?ROLE", $P4604)
  if_4546_end:
.annotate 'line', 1279
    find_lex $P4621, "$/"
    unless_null $P4621, vivify_2023
    $P4621 = root_new ['parrot';'Hash']
  vivify_2023:
    set $P4622, $P4621["parent"]
    unless_null $P4622, vivify_2024
    new $P4622, "Undef"
  vivify_2024:
    if $P4622, if_4620
.annotate 'line', 1293
    find_lex $P4668, "$how"
    unless_null $P4668, vivify_2025
    new $P4668, "Undef"
  vivify_2025:
    can $I4669, $P4668, "set_default_parent"
    unless $I4669, if_4667_end
    .const 'Sub' $P4671 = "489_1303857440.612" 
    capture_lex $P4671
    $P4671()
  if_4667_end:
    goto if_4620_end
  if_4620:
.annotate 'line', 1279
    .const 'Sub' $P4624 = "487_1303857440.612" 
    capture_lex $P4624
    $P4624()
  if_4620_end:
.annotate 'line', 1300
    find_lex $P4693, "$/"
    unless_null $P4693, vivify_2051
    $P4693 = root_new ['parrot';'Hash']
  vivify_2051:
    set $P4694, $P4693["role"]
    unless_null $P4694, vivify_2052
    new $P4694, "Undef"
  vivify_2052:
    unless $P4694, if_4692_end
.annotate 'line', 1301
    find_lex $P4696, "$/"
    unless_null $P4696, vivify_2053
    $P4696 = root_new ['parrot';'Hash']
  vivify_2053:
    set $P4697, $P4696["role"]
    unless_null $P4697, vivify_2054
    new $P4697, "Undef"
  vivify_2054:
    defined $I4698, $P4697
    unless $I4698, for_undef_2055
    iter $P4695, $P4697
    new $P4742, 'ExceptionHandler'
    set_label $P4742, loop4741_handler
    $P4742."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4742
  loop4741_test:
    unless $P4695, loop4741_done
    shift $P4699, $P4695
  loop4741_redo:
    .const 'Sub' $P4701 = "490_1303857440.612" 
    capture_lex $P4701
    $P4701($P4699)
  loop4741_next:
    goto loop4741_test
  loop4741_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4743, exception, 'type'
    eq $P4743, .CONTROL_LOOP_NEXT, loop4741_next
    eq $P4743, .CONTROL_LOOP_REDO, loop4741_redo
  loop4741_done:
    pop_eh 
  for_undef_2055:
  if_4692_end:
.annotate 'line', 1318
    find_dynamic_lex $P4746, "$*PACKAGE-SETUP"
    unless_null $P4746, vivify_2069
    get_hll_global $P4744, "GLOBAL"
    get_who $P4745, $P4744
    set $P4746, $P4745["$PACKAGE-SETUP"]
    unless_null $P4746, vivify_2070
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2070:
  vivify_2069:
    get_hll_global $P4747, "GLOBAL"
    nqp_get_package_through_who $P4748, $P4747, "PAST"
    get_who $P4749, $P4748
    set $P4750, $P4749["Op"]
.annotate 'line', 1320
    get_hll_global $P4751, "GLOBAL"
    nqp_get_package_through_who $P4752, $P4751, "PAST"
    get_who $P4753, $P4752
    set $P4754, $P4753["Op"]
.annotate 'line', 1323
    get_hll_global $P4755, "GLOBAL"
    nqp_get_package_through_who $P4756, $P4755, "PAST"
    get_who $P4757, $P4756
    set $P4758, $P4757["Var"]
    $P4759 = $P4758."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4760 = $P4754."new"($P4759, "get_how PP" :named("pirop"))
.annotate 'line', 1325
    get_hll_global $P4761, "GLOBAL"
    nqp_get_package_through_who $P4762, $P4761, "PAST"
    get_who $P4763, $P4762
    set $P4764, $P4763["Var"]
    $P4765 = $P4764."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4766 = $P4750."new"($P4760, $P4765, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1318
    $P4746."push"($P4766)
.annotate 'line', 1329
    find_lex $P4767, "$past"
    unless_null $P4767, vivify_2071
    new $P4767, "Undef"
  vivify_2071:
    $P4768 = $P4767."loadinit"()
    get_hll_global $P4769, "GLOBAL"
    nqp_get_package_through_who $P4770, $P4769, "PAST"
    get_who $P4771, $P4770
    set $P4772, $P4771["Block"]
    find_dynamic_lex $P4775, "$*PACKAGE-SETUP"
    unless_null $P4775, vivify_2072
    get_hll_global $P4773, "GLOBAL"
    get_who $P4774, $P4773
    set $P4775, $P4774["$PACKAGE-SETUP"]
    unless_null $P4775, vivify_2073
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2073:
  vivify_2072:
    $P4776 = $P4772."new"($P4775, "immediate" :named("blocktype"))
    $P4768."push"($P4776)
.annotate 'line', 1331
    find_lex $P4777, "$/"
    find_lex $P4778, "$past"
    unless_null $P4778, vivify_2074
    new $P4778, "Undef"
  vivify_2074:
    $P4779 = $P4777."!make"($P4778)
.annotate 'line', 1231
    .return ($P4779)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4670"  :anon :subid("489_1303857440.612") :outer("486_1303857440.612")
.annotate 'line', 1294
    new $P4672, "Undef"
    .lex "$default", $P4672
    find_dynamic_lex $P4677, "$*PKGDECL"
    unless_null $P4677, vivify_2026
    get_hll_global $P4675, "GLOBAL"
    get_who $P4676, $P4675
    set $P4677, $P4676["$PKGDECL"]
    unless_null $P4677, vivify_2027
    die "Contextual $*PKGDECL not found"
  vivify_2027:
  vivify_2026:
    set $S4678, $P4677
    iseq $I4679, $S4678, "grammar"
    if $I4679, if_4674
    new $P4681, "ResizablePMCArray"
    push $P4681, "NQPMu"
    set $P4673, $P4681
    goto if_4674_end
  if_4674:
    new $P4680, "ResizablePMCArray"
    push $P4680, "Regex"
    push $P4680, "Cursor"
    set $P4673, $P4680
  if_4674_end:
    store_lex "$default", $P4673
.annotate 'line', 1295
    find_dynamic_lex $P4684, "$*SC"
    unless_null $P4684, vivify_2028
    get_hll_global $P4682, "GLOBAL"
    get_who $P4683, $P4682
    set $P4684, $P4683["$SC"]
    unless_null $P4684, vivify_2029
    die "Contextual $*SC not found"
  vivify_2029:
  vivify_2028:
    find_dynamic_lex $P4687, "$*PACKAGE"
    unless_null $P4687, vivify_2030
    get_hll_global $P4685, "GLOBAL"
    get_who $P4686, $P4685
    set $P4687, $P4686["$PACKAGE"]
    unless_null $P4687, vivify_2031
    die "Contextual $*PACKAGE not found"
  vivify_2031:
  vivify_2030:
.annotate 'line', 1296
    find_lex $P4688, "$default"
    unless_null $P4688, vivify_2032
    new $P4688, "Undef"
  vivify_2032:
    find_lex $P4689, "$/"
    unless_null $P4689, vivify_2033
    new $P4689, "Undef"
  vivify_2033:
    $P4690 = "find_sym"($P4688, $P4689)
    $P4691 = $P4684."pkg_add_parent_or_role"($P4687, "set_default_parent", $P4690)
.annotate 'line', 1293
    .return ($P4691)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4623"  :anon :subid("487_1303857440.612") :outer("486_1303857440.612")
.annotate 'line', 1279
    .const 'Sub' $P4630 = "488_1303857440.612" 
    capture_lex $P4630
.annotate 'line', 1280
    new $P4625, "Undef"
    .lex "$parent", $P4625
.annotate 'line', 1281
    new $P4626, "Undef"
    .lex "$parent_found", $P4626
.annotate 'line', 1279
    find_lex $P4627, "$parent"
    unless_null $P4627, vivify_2034
    new $P4627, "Undef"
  vivify_2034:
    find_lex $P4628, "$parent_found"
    unless_null $P4628, vivify_2035
    new $P4628, "Undef"
  vivify_2035:
.annotate 'line', 1282
    .const 'Sub' $P4630 = "488_1303857440.612" 
    capture_lex $P4630
    $P4630()
.annotate 'line', 1286
    find_lex $P4648, "$parent_found"
    unless_null $P4648, vivify_2041
    new $P4648, "Undef"
  vivify_2041:
    if $P4648, if_4647
.annotate 'line', 1290
    find_lex $P4657, "$/"
    unless_null $P4657, vivify_2042
    new $P4657, "Undef"
  vivify_2042:
    $P4658 = $P4657."CURSOR"()
    new $P4659, "String"
    assign $P4659, "Could not find parent class '"
    find_lex $P4660, "$/"
    unless_null $P4660, vivify_2043
    $P4660 = root_new ['parrot';'Hash']
  vivify_2043:
    set $P4661, $P4660["parent"]
    unless_null $P4661, vivify_2044
    $P4661 = root_new ['parrot';'ResizablePMCArray']
  vivify_2044:
    set $P4662, $P4661[0]
    unless_null $P4662, vivify_2045
    new $P4662, "Undef"
  vivify_2045:
    set $S4663, $P4662
    concat $P4664, $P4659, $S4663
    concat $P4665, $P4664, "'"
    $P4666 = $P4658."panic"($P4665)
.annotate 'line', 1289
    set $P4646, $P4666
.annotate 'line', 1286
    goto if_4647_end
  if_4647:
.annotate 'line', 1287
    find_dynamic_lex $P4651, "$*SC"
    unless_null $P4651, vivify_2046
    get_hll_global $P4649, "GLOBAL"
    get_who $P4650, $P4649
    set $P4651, $P4650["$SC"]
    unless_null $P4651, vivify_2047
    die "Contextual $*SC not found"
  vivify_2047:
  vivify_2046:
    find_dynamic_lex $P4654, "$*PACKAGE"
    unless_null $P4654, vivify_2048
    get_hll_global $P4652, "GLOBAL"
    get_who $P4653, $P4652
    set $P4654, $P4653["$PACKAGE"]
    unless_null $P4654, vivify_2049
    die "Contextual $*PACKAGE not found"
  vivify_2049:
  vivify_2048:
    find_lex $P4655, "$parent"
    unless_null $P4655, vivify_2050
    new $P4655, "Undef"
  vivify_2050:
    $P4656 = $P4651."pkg_add_parent_or_role"($P4654, "add_parent", $P4655)
.annotate 'line', 1286
    set $P4646, $P4656
  if_4647_end:
.annotate 'line', 1279
    .return ($P4646)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4629"  :anon :subid("488_1303857440.612") :outer("487_1303857440.612")
.annotate 'line', 1282
    new $P4641, 'ExceptionHandler'
    set_label $P4641, control_4640
    $P4641."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4641
.annotate 'line', 1283
    find_lex $P4631, "$/"
    unless_null $P4631, vivify_2036
    $P4631 = root_new ['parrot';'Hash']
  vivify_2036:
    set $P4632, $P4631["parent"]
    unless_null $P4632, vivify_2037
    $P4632 = root_new ['parrot';'ResizablePMCArray']
  vivify_2037:
    set $P4633, $P4632[0]
    unless_null $P4633, vivify_2038
    $P4633 = root_new ['parrot';'Hash']
  vivify_2038:
    set $P4634, $P4633["identifier"]
    unless_null $P4634, vivify_2039
    new $P4634, "Undef"
  vivify_2039:
    clone $P4635, $P4634
    find_lex $P4636, "$/"
    unless_null $P4636, vivify_2040
    new $P4636, "Undef"
  vivify_2040:
    $P4637 = "find_sym"($P4635, $P4636)
    store_lex "$parent", $P4637
.annotate 'line', 1284
    new $P4638, "Integer"
    assign $P4638, 1
    store_lex "$parent_found", $P4638
.annotate 'line', 1282
    pop_eh 
    goto skip_handler_4639
  control_4640:
    .local pmc exception 
    .get_results (exception) 
    new $P4644, 'Integer'
    set $P4644, 1
    set exception["handled"], $P4644
    set $I4645, exception["handled"]
    ne $I4645, 1, nothandled_4643
  handled_4642:
    .return (exception)
  nothandled_4643:
    rethrow exception
  skip_handler_4639:
    .return ($P4638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4700"  :anon :subid("490_1303857440.612") :outer("486_1303857440.612")
    .param pmc param_4704
.annotate 'line', 1301
    .const 'Sub' $P4708 = "491_1303857440.612" 
    capture_lex $P4708
.annotate 'line', 1302
    new $P4702, "Undef"
    .lex "$role", $P4702
.annotate 'line', 1303
    new $P4703, "Undef"
    .lex "$role_found", $P4703
    .lex "$_", param_4704
.annotate 'line', 1301
    find_lex $P4705, "$role"
    unless_null $P4705, vivify_2056
    new $P4705, "Undef"
  vivify_2056:
    find_lex $P4706, "$role_found"
    unless_null $P4706, vivify_2057
    new $P4706, "Undef"
  vivify_2057:
.annotate 'line', 1304
    .const 'Sub' $P4708 = "491_1303857440.612" 
    capture_lex $P4708
    $P4708()
.annotate 'line', 1308
    find_lex $P4724, "$role_found"
    unless_null $P4724, vivify_2061
    new $P4724, "Undef"
  vivify_2061:
    if $P4724, if_4723
.annotate 'line', 1312
    find_lex $P4733, "$/"
    unless_null $P4733, vivify_2062
    new $P4733, "Undef"
  vivify_2062:
    $P4734 = $P4733."CURSOR"()
    new $P4735, "String"
    assign $P4735, "Could not find role '"
    find_lex $P4736, "$_"
    unless_null $P4736, vivify_2063
    new $P4736, "Undef"
  vivify_2063:
    set $S4737, $P4736
    concat $P4738, $P4735, $S4737
    concat $P4739, $P4738, "'"
    $P4740 = $P4734."panic"($P4739)
.annotate 'line', 1311
    set $P4722, $P4740
.annotate 'line', 1308
    goto if_4723_end
  if_4723:
.annotate 'line', 1309
    find_dynamic_lex $P4727, "$*SC"
    unless_null $P4727, vivify_2064
    get_hll_global $P4725, "GLOBAL"
    get_who $P4726, $P4725
    set $P4727, $P4726["$SC"]
    unless_null $P4727, vivify_2065
    die "Contextual $*SC not found"
  vivify_2065:
  vivify_2064:
    find_dynamic_lex $P4730, "$*PACKAGE"
    unless_null $P4730, vivify_2066
    get_hll_global $P4728, "GLOBAL"
    get_who $P4729, $P4728
    set $P4730, $P4729["$PACKAGE"]
    unless_null $P4730, vivify_2067
    die "Contextual $*PACKAGE not found"
  vivify_2067:
  vivify_2066:
    find_lex $P4731, "$role"
    unless_null $P4731, vivify_2068
    new $P4731, "Undef"
  vivify_2068:
    $P4732 = $P4727."pkg_add_parent_or_role"($P4730, "add_role", $P4731)
.annotate 'line', 1308
    set $P4722, $P4732
  if_4723_end:
.annotate 'line', 1301
    .return ($P4722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4707"  :anon :subid("491_1303857440.612") :outer("490_1303857440.612")
.annotate 'line', 1304
    new $P4717, 'ExceptionHandler'
    set_label $P4717, control_4716
    $P4717."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4717
.annotate 'line', 1305
    find_lex $P4709, "$_"
    unless_null $P4709, vivify_2058
    $P4709 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P4710, $P4709["identifier"]
    unless_null $P4710, vivify_2059
    new $P4710, "Undef"
  vivify_2059:
    clone $P4711, $P4710
    find_lex $P4712, "$/"
    unless_null $P4712, vivify_2060
    new $P4712, "Undef"
  vivify_2060:
    $P4713 = "find_sym"($P4711, $P4712)
    store_lex "$role", $P4713
.annotate 'line', 1306
    new $P4714, "Integer"
    assign $P4714, 1
    store_lex "$role_found", $P4714
.annotate 'line', 1304
    pop_eh 
    goto skip_handler_4715
  control_4716:
    .local pmc exception 
    .get_results (exception) 
    new $P4720, 'Integer'
    set $P4720, 1
    set exception["handled"], $P4720
    set $I4721, exception["handled"]
    ne $I4721, 1, nothandled_4719
  handled_4718:
    .return (exception)
  nothandled_4719:
    rethrow exception
  skip_handler_4715:
    .return ($P4714)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("492_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4781
    .param pmc param_4782
.annotate 'line', 1334
    .lex "self", param_4781
    .lex "$/", param_4782
    find_lex $P4783, "$/"
    find_lex $P4784, "$/"
    unless_null $P4784, vivify_2075
    $P4784 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P4785, $P4784["scoped"]
    unless_null $P4785, vivify_2076
    new $P4785, "Undef"
  vivify_2076:
    $P4786 = $P4785."ast"()
    $P4787 = $P4783."!make"($P4786)
    .return ($P4787)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("493_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4789
    .param pmc param_4790
.annotate 'line', 1335
    .lex "self", param_4789
    .lex "$/", param_4790
    find_lex $P4791, "$/"
    find_lex $P4792, "$/"
    unless_null $P4792, vivify_2077
    $P4792 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4793, $P4792["scoped"]
    unless_null $P4793, vivify_2078
    new $P4793, "Undef"
  vivify_2078:
    $P4794 = $P4793."ast"()
    $P4795 = $P4791."!make"($P4794)
    .return ($P4795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("494_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4797
    .param pmc param_4798
.annotate 'line', 1336
    .lex "self", param_4797
    .lex "$/", param_4798
    find_lex $P4799, "$/"
    find_lex $P4800, "$/"
    unless_null $P4800, vivify_2079
    $P4800 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P4801, $P4800["scoped"]
    unless_null $P4801, vivify_2080
    new $P4801, "Undef"
  vivify_2080:
    $P4802 = $P4801."ast"()
    $P4803 = $P4799."!make"($P4802)
    .return ($P4803)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("495_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4805
    .param pmc param_4806
.annotate 'line', 1338
    .lex "self", param_4805
    .lex "$/", param_4806
.annotate 'line', 1339
    find_lex $P4807, "$/"
    find_lex $P4810, "$/"
    unless_null $P4810, vivify_2081
    $P4810 = root_new ['parrot';'Hash']
  vivify_2081:
    set $P4811, $P4810["declarator"]
    unless_null $P4811, vivify_2082
    new $P4811, "Undef"
  vivify_2082:
    if $P4811, if_4809
.annotate 'line', 1340
    find_lex $P4817, "$/"
    unless_null $P4817, vivify_2083
    $P4817 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P4818, $P4817["multi_declarator"]
    unless_null $P4818, vivify_2084
    new $P4818, "Undef"
  vivify_2084:
    if $P4818, if_4816
.annotate 'line', 1341
    find_lex $P4822, "$/"
    unless_null $P4822, vivify_2085
    $P4822 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P4823, $P4822["package_declarator"]
    unless_null $P4823, vivify_2086
    new $P4823, "Undef"
  vivify_2086:
    $P4824 = $P4823."ast"()
    set $P4815, $P4824
.annotate 'line', 1340
    goto if_4816_end
  if_4816:
    find_lex $P4819, "$/"
    unless_null $P4819, vivify_2087
    $P4819 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P4820, $P4819["multi_declarator"]
    unless_null $P4820, vivify_2088
    new $P4820, "Undef"
  vivify_2088:
    $P4821 = $P4820."ast"()
    set $P4815, $P4821
  if_4816_end:
    set $P4808, $P4815
.annotate 'line', 1339
    goto if_4809_end
  if_4809:
    find_lex $P4812, "$/"
    unless_null $P4812, vivify_2089
    $P4812 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P4813, $P4812["declarator"]
    unless_null $P4813, vivify_2090
    new $P4813, "Undef"
  vivify_2090:
    $P4814 = $P4813."ast"()
    set $P4808, $P4814
  if_4809_end:
    $P4825 = $P4807."!make"($P4808)
.annotate 'line', 1338
    .return ($P4825)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("496_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4827
    .param pmc param_4828
.annotate 'line', 1344
    .lex "self", param_4827
    .lex "$/", param_4828
.annotate 'line', 1345
    find_lex $P4829, "$/"
.annotate 'line', 1346
    find_lex $P4832, "$/"
    unless_null $P4832, vivify_2091
    $P4832 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P4833, $P4832["routine_declarator"]
    unless_null $P4833, vivify_2092
    new $P4833, "Undef"
  vivify_2092:
    if $P4833, if_4831
.annotate 'line', 1347
    find_lex $P4837, "$/"
    unless_null $P4837, vivify_2093
    $P4837 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P4838, $P4837["variable_declarator"]
    unless_null $P4838, vivify_2094
    new $P4838, "Undef"
  vivify_2094:
    $P4839 = $P4838."ast"()
    set $P4830, $P4839
.annotate 'line', 1346
    goto if_4831_end
  if_4831:
    find_lex $P4834, "$/"
    unless_null $P4834, vivify_2095
    $P4834 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P4835, $P4834["routine_declarator"]
    unless_null $P4835, vivify_2096
    new $P4835, "Undef"
  vivify_2096:
    $P4836 = $P4835."ast"()
    set $P4830, $P4836
  if_4831_end:
    $P4840 = $P4829."!make"($P4830)
.annotate 'line', 1344
    .return ($P4840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("497_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4842
    .param pmc param_4843
.annotate 'line', 1350
    .lex "self", param_4842
    .lex "$/", param_4843
    find_lex $P4844, "$/"
    find_lex $P4847, "$/"
    unless_null $P4847, vivify_2097
    $P4847 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P4848, $P4847["declarator"]
    unless_null $P4848, vivify_2098
    new $P4848, "Undef"
  vivify_2098:
    if $P4848, if_4846
    find_lex $P4852, "$/"
    unless_null $P4852, vivify_2099
    $P4852 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P4853, $P4852["routine_def"]
    unless_null $P4853, vivify_2100
    new $P4853, "Undef"
  vivify_2100:
    $P4854 = $P4853."ast"()
    set $P4845, $P4854
    goto if_4846_end
  if_4846:
    find_lex $P4849, "$/"
    unless_null $P4849, vivify_2101
    $P4849 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4850, $P4849["declarator"]
    unless_null $P4850, vivify_2102
    new $P4850, "Undef"
  vivify_2102:
    $P4851 = $P4850."ast"()
    set $P4845, $P4851
  if_4846_end:
    $P4855 = $P4844."!make"($P4845)
    .return ($P4855)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("498_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4857
    .param pmc param_4858
.annotate 'line', 1351
    .lex "self", param_4857
    .lex "$/", param_4858
    find_lex $P4859, "$/"
    find_lex $P4862, "$/"
    unless_null $P4862, vivify_2103
    $P4862 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P4863, $P4862["declarator"]
    unless_null $P4863, vivify_2104
    new $P4863, "Undef"
  vivify_2104:
    if $P4863, if_4861
    find_lex $P4867, "$/"
    unless_null $P4867, vivify_2105
    $P4867 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P4868, $P4867["routine_def"]
    unless_null $P4868, vivify_2106
    new $P4868, "Undef"
  vivify_2106:
    $P4869 = $P4868."ast"()
    set $P4860, $P4869
    goto if_4861_end
  if_4861:
    find_lex $P4864, "$/"
    unless_null $P4864, vivify_2107
    $P4864 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P4865, $P4864["declarator"]
    unless_null $P4865, vivify_2108
    new $P4865, "Undef"
  vivify_2108:
    $P4866 = $P4865."ast"()
    set $P4860, $P4866
  if_4861_end:
    $P4870 = $P4859."!make"($P4860)
    .return ($P4870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("499_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4872
    .param pmc param_4873
.annotate 'line', 1352
    .lex "self", param_4872
    .lex "$/", param_4873
    find_lex $P4874, "$/"
    find_lex $P4875, "$/"
    unless_null $P4875, vivify_2109
    $P4875 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4876, $P4875["declarator"]
    unless_null $P4876, vivify_2110
    new $P4876, "Undef"
  vivify_2110:
    $P4877 = $P4876."ast"()
    $P4878 = $P4874."!make"($P4877)
    .return ($P4878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("500_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_4880
    .param pmc param_4881
.annotate 'line', 1355
    .const 'Sub' $P4915 = "501_1303857440.612" 
    capture_lex $P4915
    .lex "self", param_4880
    .lex "$/", param_4881
.annotate 'line', 1356
    new $P4882, "Undef"
    .lex "$past", $P4882
.annotate 'line', 1357
    new $P4883, "Undef"
    .lex "$sigil", $P4883
.annotate 'line', 1358
    new $P4884, "Undef"
    .lex "$name", $P4884
.annotate 'line', 1359
    new $P4885, "Undef"
    .lex "$BLOCK", $P4885
.annotate 'line', 1356
    find_lex $P4886, "$/"
    unless_null $P4886, vivify_2111
    $P4886 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4887, $P4886["variable"]
    unless_null $P4887, vivify_2112
    new $P4887, "Undef"
  vivify_2112:
    $P4888 = $P4887."ast"()
    store_lex "$past", $P4888
.annotate 'line', 1357
    find_lex $P4889, "$/"
    unless_null $P4889, vivify_2113
    $P4889 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P4890, $P4889["variable"]
    unless_null $P4890, vivify_2114
    $P4890 = root_new ['parrot';'Hash']
  vivify_2114:
    set $P4891, $P4890["sigil"]
    unless_null $P4891, vivify_2115
    new $P4891, "Undef"
  vivify_2115:
    store_lex "$sigil", $P4891
.annotate 'line', 1358
    find_lex $P4892, "$past"
    unless_null $P4892, vivify_2116
    new $P4892, "Undef"
  vivify_2116:
    $P4893 = $P4892."name"()
    store_lex "$name", $P4893
.annotate 'line', 1359
    find_lex $P4894, "$?PACKAGE"
    get_who $P4895, $P4894
    set $P4896, $P4895["@BLOCK"]
    unless_null $P4896, vivify_2117
    $P4896 = root_new ['parrot';'ResizablePMCArray']
  vivify_2117:
    set $P4897, $P4896[0]
    unless_null $P4897, vivify_2118
    new $P4897, "Undef"
  vivify_2118:
    store_lex "$BLOCK", $P4897
.annotate 'line', 1360
    find_lex $P4901, "$name"
    unless_null $P4901, vivify_2119
    new $P4901, "Undef"
  vivify_2119:
    if $P4901, if_4900
    set $P4899, $P4901
    goto if_4900_end
  if_4900:
    find_lex $P4902, "$BLOCK"
    unless_null $P4902, vivify_2120
    new $P4902, "Undef"
  vivify_2120:
    find_lex $P4903, "$name"
    unless_null $P4903, vivify_2121
    new $P4903, "Undef"
  vivify_2121:
    $P4904 = $P4902."symbol"($P4903)
    set $P4899, $P4904
  if_4900_end:
    unless $P4899, if_4898_end
.annotate 'line', 1361
    find_lex $P4905, "$/"
    unless_null $P4905, vivify_2122
    new $P4905, "Undef"
  vivify_2122:
    $P4906 = $P4905."CURSOR"()
    find_lex $P4907, "$name"
    unless_null $P4907, vivify_2123
    new $P4907, "Undef"
  vivify_2123:
    $P4906."panic"("Redeclaration of symbol ", $P4907)
  if_4898_end:
.annotate 'line', 1363
    find_dynamic_lex $P4911, "$*SCOPE"
    unless_null $P4911, vivify_2124
    get_hll_global $P4909, "GLOBAL"
    get_who $P4910, $P4909
    set $P4911, $P4910["$SCOPE"]
    unless_null $P4911, vivify_2125
    die "Contextual $*SCOPE not found"
  vivify_2125:
  vivify_2124:
    set $S4912, $P4911
    iseq $I4913, $S4912, "has"
    if $I4913, if_4908
.annotate 'line', 1388
    find_dynamic_lex $P4994, "$*SCOPE"
    unless_null $P4994, vivify_2126
    get_hll_global $P4992, "GLOBAL"
    get_who $P4993, $P4992
    set $P4994, $P4993["$SCOPE"]
    unless_null $P4994, vivify_2127
    die "Contextual $*SCOPE not found"
  vivify_2127:
  vivify_2126:
    set $S4995, $P4994
    iseq $I4996, $S4995, "our"
    if $I4996, if_4991
.annotate 'line', 1398
    find_lex $P5010, "$BLOCK"
    unless_null $P5010, vivify_2128
    $P5010 = root_new ['parrot';'ResizablePMCArray']
  vivify_2128:
    set $P5011, $P5010[0]
    unless_null $P5011, vivify_2129
    new $P5011, "Undef"
  vivify_2129:
    get_hll_global $P5012, "GLOBAL"
    nqp_get_package_through_who $P5013, $P5012, "PAST"
    get_who $P5014, $P5013
    set $P5015, $P5014["Var"]
    find_lex $P5016, "$name"
    unless_null $P5016, vivify_2130
    new $P5016, "Undef"
  vivify_2130:
.annotate 'line', 1400
    find_lex $P5017, "$sigil"
    unless_null $P5017, vivify_2131
    new $P5017, "Undef"
  vivify_2131:
    $P5018 = "vivitype"($P5017)
    find_lex $P5019, "$/"
    unless_null $P5019, vivify_2132
    new $P5019, "Undef"
  vivify_2132:
    $P5020 = $P5015."new"($P5016 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5018 :named("viviself"), $P5019 :named("node"))
.annotate 'line', 1398
    $P5011."push"($P5020)
.annotate 'line', 1403
    find_lex $P5021, "$BLOCK"
    unless_null $P5021, vivify_2133
    new $P5021, "Undef"
  vivify_2133:
    find_lex $P5022, "$name"
    unless_null $P5022, vivify_2134
    new $P5022, "Undef"
  vivify_2134:
    $P5021."symbol"($P5022, "lexical" :named("scope"))
.annotate 'line', 1397
    goto if_4991_end
  if_4991:
.annotate 'line', 1392
    find_lex $P4997, "$/"
    unless_null $P4997, vivify_2135
    $P4997 = root_new ['parrot';'Hash']
  vivify_2135:
    set $P4998, $P4997["variable"]
    unless_null $P4998, vivify_2136
    new $P4998, "Undef"
  vivify_2136:
    set $S4999, $P4998
    new $P5000, 'String'
    set $P5000, $S4999
    store_lex "$name", $P5000
.annotate 'line', 1393
    find_lex $P5001, "$name"
    unless_null $P5001, vivify_2137
    new $P5001, "Undef"
  vivify_2137:
    new $P5002, "ResizablePMCArray"
    push $P5002, $P5001
    find_lex $P5003, "$/"
    unless_null $P5003, vivify_2138
    new $P5003, "Undef"
  vivify_2138:
    $P5004 = "lexical_package_lookup"($P5002, $P5003)
    store_lex "$past", $P5004
.annotate 'line', 1394
    find_lex $P5005, "$past"
    unless_null $P5005, vivify_2139
    new $P5005, "Undef"
  vivify_2139:
    find_lex $P5006, "$sigil"
    unless_null $P5006, vivify_2140
    new $P5006, "Undef"
  vivify_2140:
    $P5007 = "vivitype"($P5006)
    $P5005."viviself"($P5007)
.annotate 'line', 1395
    find_lex $P5008, "$BLOCK"
    unless_null $P5008, vivify_2141
    new $P5008, "Undef"
  vivify_2141:
    find_lex $P5009, "$name"
    unless_null $P5009, vivify_2142
    new $P5009, "Undef"
  vivify_2142:
    $P5008."symbol"($P5009, "package" :named("scope"))
  if_4991_end:
.annotate 'line', 1388
    goto if_4908_end
  if_4908:
.annotate 'line', 1363
    .const 'Sub' $P4915 = "501_1303857440.612" 
    capture_lex $P4915
    $P4915()
  if_4908_end:
.annotate 'line', 1405
    find_lex $P5023, "$/"
    find_lex $P5024, "$past"
    unless_null $P5024, vivify_2164
    new $P5024, "Undef"
  vivify_2164:
    $P5025 = $P5023."!make"($P5024)
.annotate 'line', 1355
    .return ($P5025)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4914"  :anon :subid("501_1303857440.612") :outer("500_1303857440.612")
.annotate 'line', 1363
    .const 'Sub' $P4974 = "502_1303857440.612" 
    capture_lex $P4974
.annotate 'line', 1365
    new $P4916, "Undef"
    .lex "$meta-attr-type", $P4916
.annotate 'line', 1373
    new $P4917, "Undef"
    .lex "$meta_args", $P4917
.annotate 'line', 1365
    find_dynamic_lex $P4922, "$*PKGDECL"
    unless_null $P4922, vivify_2143
    get_hll_global $P4920, "GLOBAL"
    get_who $P4921, $P4920
    set $P4922, $P4921["$PKGDECL"]
    unless_null $P4922, vivify_2144
    die "Contextual $*PKGDECL not found"
  vivify_2144:
  vivify_2143:
    find_dynamic_lex $P4925, "%*HOW-METAATTR"
    unless_null $P4925, vivify_2145
    get_hll_global $P4923, "GLOBAL"
    get_who $P4924, $P4923
    set $P4925, $P4924["%HOW-METAATTR"]
    unless_null $P4925, vivify_2146
    die "Contextual %*HOW-METAATTR not found"
  vivify_2146:
  vivify_2145:
    set $P4926, $P4925[$P4922]
    unless_null $P4926, vivify_2147
    new $P4926, "Undef"
  vivify_2147:
    unless $P4926, unless_4919
    set $P4918, $P4926
    goto unless_4919_end
  unless_4919:
    find_dynamic_lex $P4929, "$*DEFAULT-METAATTR"
    unless_null $P4929, vivify_2148
    get_hll_global $P4927, "GLOBAL"
    get_who $P4928, $P4927
    set $P4929, $P4928["$DEFAULT-METAATTR"]
    unless_null $P4929, vivify_2149
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2149:
  vivify_2148:
    set $P4918, $P4929
  unless_4919_end:
    store_lex "$meta-attr-type", $P4918
.annotate 'line', 1366
    find_dynamic_lex $P4932, "$*PACKAGE-SETUP"
    unless_null $P4932, vivify_2150
    get_hll_global $P4930, "GLOBAL"
    get_who $P4931, $P4930
    set $P4932, $P4931["$PACKAGE-SETUP"]
    unless_null $P4932, vivify_2151
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2151:
  vivify_2150:
    get_hll_global $P4933, "GLOBAL"
    nqp_get_package_through_who $P4934, $P4933, "PAST"
    get_who $P4935, $P4934
    set $P4936, $P4935["Op"]
.annotate 'line', 1368
    get_hll_global $P4937, "GLOBAL"
    nqp_get_package_through_who $P4938, $P4937, "PAST"
    get_who $P4939, $P4938
    set $P4940, $P4939["Op"]
.annotate 'line', 1370
    get_hll_global $P4941, "GLOBAL"
    nqp_get_package_through_who $P4942, $P4941, "PAST"
    get_who $P4943, $P4942
    set $P4944, $P4943["Var"]
    $P4945 = $P4944."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4946 = $P4940."new"($P4945, "get_how PP" :named("pirop"))
.annotate 'line', 1372
    get_hll_global $P4947, "GLOBAL"
    nqp_get_package_through_who $P4948, $P4947, "PAST"
    get_who $P4949, $P4948
    set $P4950, $P4949["Var"]
    $P4951 = $P4950."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1373
    get_hll_global $P4952, "GLOBAL"
    nqp_get_package_through_who $P4953, $P4952, "PAST"
    get_who $P4954, $P4953
    set $P4955, $P4954["Op"]
.annotate 'line', 1375
    get_hll_global $P4956, "GLOBAL"
    nqp_get_package_through_who $P4957, $P4956, "PAST"
    get_who $P4958, $P4957
    set $P4959, $P4958["Var"]
    find_lex $P4960, "$meta-attr-type"
    unless_null $P4960, vivify_2152
    new $P4960, "Undef"
  vivify_2152:
    $P4961 = $P4959."new"($P4960 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1376
    get_hll_global $P4962, "GLOBAL"
    nqp_get_package_through_who $P4963, $P4962, "PAST"
    get_who $P4964, $P4963
    set $P4965, $P4964["Val"]
    find_lex $P4966, "$name"
    unless_null $P4966, vivify_2153
    new $P4966, "Undef"
  vivify_2153:
    $P4967 = $P4965."new"($P4966 :named("value"), "name" :named("named"))
    $P4968 = $P4955."new"($P4961, $P4967, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1373
    store_lex "$meta_args", $P4968
    $P4969 = $P4936."new"($P4946, $P4951, $P4968, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1366
    $P4932."push"($P4969)
.annotate 'line', 1379
    find_lex $P4971, "$/"
    unless_null $P4971, vivify_2154
    $P4971 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P4972, $P4971["typename"]
    unless_null $P4972, vivify_2155
    new $P4972, "Undef"
  vivify_2155:
    unless $P4972, if_4970_end
    .const 'Sub' $P4974 = "502_1303857440.612" 
    capture_lex $P4974
    $P4974()
  if_4970_end:
.annotate 'line', 1385
    find_lex $P4984, "$BLOCK"
    unless_null $P4984, vivify_2162
    new $P4984, "Undef"
  vivify_2162:
    find_lex $P4985, "$name"
    unless_null $P4985, vivify_2163
    new $P4985, "Undef"
  vivify_2163:
    $P4984."symbol"($P4985, "attribute" :named("scope"))
.annotate 'line', 1386
    get_hll_global $P4986, "GLOBAL"
    nqp_get_package_through_who $P4987, $P4986, "PAST"
    get_who $P4988, $P4987
    set $P4989, $P4988["Stmts"]
    $P4990 = $P4989."new"()
    store_lex "$past", $P4990
.annotate 'line', 1363
    .return ($P4990)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4973"  :anon :subid("502_1303857440.612") :outer("501_1303857440.612")
.annotate 'line', 1380
    new $P4975, "Undef"
    .lex "$type", $P4975
    find_lex $P4976, "$/"
    unless_null $P4976, vivify_2156
    $P4976 = root_new ['parrot';'Hash']
  vivify_2156:
    set $P4977, $P4976["typename"]
    unless_null $P4977, vivify_2157
    $P4977 = root_new ['parrot';'ResizablePMCArray']
  vivify_2157:
    set $P4978, $P4977[0]
    unless_null $P4978, vivify_2158
    new $P4978, "Undef"
  vivify_2158:
    $P4979 = $P4978."ast"()
    store_lex "$type", $P4979
.annotate 'line', 1381
    find_lex $P4980, "$type"
    unless_null $P4980, vivify_2159
    new $P4980, "Undef"
  vivify_2159:
    $P4980."named"("type")
.annotate 'line', 1382
    find_lex $P4981, "$meta_args"
    unless_null $P4981, vivify_2160
    new $P4981, "Undef"
  vivify_2160:
    find_lex $P4982, "$type"
    unless_null $P4982, vivify_2161
    new $P4982, "Undef"
  vivify_2161:
    $P4983 = $P4981."push"($P4982)
.annotate 'line', 1379
    .return ($P4983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("503_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5027
    .param pmc param_5028
.annotate 'line', 1408
    .lex "self", param_5027
    .lex "$/", param_5028
    find_lex $P5029, "$/"
    find_lex $P5030, "$/"
    unless_null $P5030, vivify_2165
    $P5030 = root_new ['parrot';'Hash']
  vivify_2165:
    set $P5031, $P5030["routine_def"]
    unless_null $P5031, vivify_2166
    new $P5031, "Undef"
  vivify_2166:
    $P5032 = $P5031."ast"()
    $P5033 = $P5029."!make"($P5032)
    .return ($P5033)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("504_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5035
    .param pmc param_5036
.annotate 'line', 1409
    .lex "self", param_5035
    .lex "$/", param_5036
    find_lex $P5037, "$/"
    find_lex $P5038, "$/"
    unless_null $P5038, vivify_2167
    $P5038 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P5039, $P5038["method_def"]
    unless_null $P5039, vivify_2168
    new $P5039, "Undef"
  vivify_2168:
    $P5040 = $P5039."ast"()
    $P5041 = $P5037."!make"($P5040)
    .return ($P5041)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("505_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5043
    .param pmc param_5044
.annotate 'line', 1411
    .const 'Sub' $P5357 = "511_1303857440.612" 
    capture_lex $P5357
    .const 'Sub' $P5066 = "506_1303857440.612" 
    capture_lex $P5066
    .lex "self", param_5043
    .lex "$/", param_5044
.annotate 'line', 1414
    new $P5045, "Undef"
    .lex "$past", $P5045
.annotate 'line', 1425
    new $P5046, "Undef"
    .lex "$block", $P5046
.annotate 'line', 1411
    find_lex $P5047, "$past"
    unless_null $P5047, vivify_2169
    new $P5047, "Undef"
  vivify_2169:
.annotate 'line', 1415
    find_lex $P5049, "$/"
    unless_null $P5049, vivify_2170
    $P5049 = root_new ['parrot';'Hash']
  vivify_2170:
    set $P5050, $P5049["onlystar"]
    unless_null $P5050, vivify_2171
    new $P5050, "Undef"
  vivify_2171:
    if $P5050, if_5048
.annotate 'line', 1419
    find_lex $P5052, "$/"
    unless_null $P5052, vivify_2172
    $P5052 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P5053, $P5052["blockoid"]
    unless_null $P5053, vivify_2173
    new $P5053, "Undef"
  vivify_2173:
    $P5054 = $P5053."ast"()
    store_lex "$past", $P5054
.annotate 'line', 1420
    find_lex $P5055, "$past"
    unless_null $P5055, vivify_2174
    new $P5055, "Undef"
  vivify_2174:
    $P5055."blocktype"("declaration")
.annotate 'line', 1421
    find_dynamic_lex $P5059, "$*RETURN_USED"
    unless_null $P5059, vivify_2175
    get_hll_global $P5057, "GLOBAL"
    get_who $P5058, $P5057
    set $P5059, $P5058["$RETURN_USED"]
    unless_null $P5059, vivify_2176
    die "Contextual $*RETURN_USED not found"
  vivify_2176:
  vivify_2175:
    unless $P5059, if_5056_end
.annotate 'line', 1422
    find_lex $P5060, "$past"
    unless_null $P5060, vivify_2177
    new $P5060, "Undef"
  vivify_2177:
    $P5060."control"("return_pir")
  if_5056_end:
.annotate 'line', 1418
    goto if_5048_end
  if_5048:
.annotate 'line', 1416
    $P5051 = "only_star_block"()
    store_lex "$past", $P5051
  if_5048_end:
.annotate 'line', 1425
    find_lex $P5061, "$past"
    unless_null $P5061, vivify_2178
    new $P5061, "Undef"
  vivify_2178:
    store_lex "$block", $P5061
.annotate 'line', 1427
    find_lex $P5063, "$/"
    unless_null $P5063, vivify_2179
    $P5063 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P5064, $P5063["deflongname"]
    unless_null $P5064, vivify_2180
    new $P5064, "Undef"
  vivify_2180:
    unless $P5064, if_5062_end
    .const 'Sub' $P5066 = "506_1303857440.612" 
    capture_lex $P5066
    $P5066()
  if_5062_end:
.annotate 'line', 1528
    find_lex $P5346, "$block"
    unless_null $P5346, vivify_2286
    new $P5346, "Undef"
  vivify_2286:
    find_lex $P5347, "$past"
    unless_null $P5347, vivify_2287
    $P5347 = root_new ['parrot';'Hash']
    store_lex "$past", $P5347
  vivify_2287:
    set $P5347["block_past"], $P5346
.annotate 'line', 1529
    find_lex $P5349, "$/"
    unless_null $P5349, vivify_2288
    $P5349 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P5350, $P5349["trait"]
    unless_null $P5350, vivify_2289
    new $P5350, "Undef"
  vivify_2289:
    unless $P5350, if_5348_end
.annotate 'line', 1530
    find_lex $P5352, "$/"
    unless_null $P5352, vivify_2290
    $P5352 = root_new ['parrot';'Hash']
  vivify_2290:
    set $P5353, $P5352["trait"]
    unless_null $P5353, vivify_2291
    new $P5353, "Undef"
  vivify_2291:
    defined $I5354, $P5353
    unless $I5354, for_undef_2292
    iter $P5351, $P5353
    new $P5364, 'ExceptionHandler'
    set_label $P5364, loop5363_handler
    $P5364."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5364
  loop5363_test:
    unless $P5351, loop5363_done
    shift $P5355, $P5351
  loop5363_redo:
    .const 'Sub' $P5357 = "511_1303857440.612" 
    capture_lex $P5357
    $P5357($P5355)
  loop5363_next:
    goto loop5363_test
  loop5363_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5365, exception, 'type'
    eq $P5365, .CONTROL_LOOP_NEXT, loop5363_next
    eq $P5365, .CONTROL_LOOP_REDO, loop5363_redo
  loop5363_done:
    pop_eh 
  for_undef_2292:
  if_5348_end:
.annotate 'line', 1533
    find_lex $P5366, "$/"
    find_lex $P5367, "$past"
    unless_null $P5367, vivify_2295
    new $P5367, "Undef"
  vivify_2295:
    $P5368 = $P5366."!make"($P5367)
.annotate 'line', 1411
    .return ($P5368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5065"  :anon :subid("506_1303857440.612") :outer("505_1303857440.612")
.annotate 'line', 1427
    .const 'Sub' $P5220 = "510_1303857440.612" 
    capture_lex $P5220
    .const 'Sub' $P5107 = "507_1303857440.612" 
    capture_lex $P5107
.annotate 'line', 1428
    new $P5067, "Undef"
    .lex "$name", $P5067
    find_lex $P5068, "$/"
    unless_null $P5068, vivify_2181
    $P5068 = root_new ['parrot';'Hash']
  vivify_2181:
    set $P5069, $P5068["sigil"]
    unless_null $P5069, vivify_2182
    $P5069 = root_new ['parrot';'ResizablePMCArray']
  vivify_2182:
    set $P5070, $P5069[0]
    unless_null $P5070, vivify_2183
    new $P5070, "Undef"
  vivify_2183:
    set $S5071, $P5070
    new $P5072, 'String'
    set $P5072, $S5071
    find_lex $P5073, "$/"
    unless_null $P5073, vivify_2184
    $P5073 = root_new ['parrot';'Hash']
  vivify_2184:
    set $P5074, $P5073["deflongname"]
    unless_null $P5074, vivify_2185
    $P5074 = root_new ['parrot';'ResizablePMCArray']
  vivify_2185:
    set $P5075, $P5074[0]
    unless_null $P5075, vivify_2186
    new $P5075, "Undef"
  vivify_2186:
    $S5076 = $P5075."ast"()
    concat $P5077, $P5072, $S5076
    store_lex "$name", $P5077
.annotate 'line', 1429
    find_lex $P5078, "$past"
    unless_null $P5078, vivify_2187
    new $P5078, "Undef"
  vivify_2187:
    find_lex $P5079, "$name"
    unless_null $P5079, vivify_2188
    new $P5079, "Undef"
  vivify_2188:
    $P5078."name"($P5079)
.annotate 'line', 1430
    find_dynamic_lex $P5087, "$*SCOPE"
    unless_null $P5087, vivify_2189
    get_hll_global $P5085, "GLOBAL"
    get_who $P5086, $P5085
    set $P5087, $P5086["$SCOPE"]
    unless_null $P5087, vivify_2190
    die "Contextual $*SCOPE not found"
  vivify_2190:
  vivify_2189:
    set $S5088, $P5087
    iseq $I5089, $S5088, ""
    unless $I5089, unless_5084
    new $P5083, 'Integer'
    set $P5083, $I5089
    goto unless_5084_end
  unless_5084:
    find_dynamic_lex $P5092, "$*SCOPE"
    unless_null $P5092, vivify_2191
    get_hll_global $P5090, "GLOBAL"
    get_who $P5091, $P5090
    set $P5092, $P5091["$SCOPE"]
    unless_null $P5092, vivify_2192
    die "Contextual $*SCOPE not found"
  vivify_2192:
  vivify_2191:
    set $S5093, $P5092
    iseq $I5094, $S5093, "my"
    new $P5083, 'Integer'
    set $P5083, $I5094
  unless_5084_end:
    unless $P5083, unless_5082
    set $P5081, $P5083
    goto unless_5082_end
  unless_5082:
    find_dynamic_lex $P5097, "$*SCOPE"
    unless_null $P5097, vivify_2193
    get_hll_global $P5095, "GLOBAL"
    get_who $P5096, $P5095
    set $P5097, $P5096["$SCOPE"]
    unless_null $P5097, vivify_2194
    die "Contextual $*SCOPE not found"
  vivify_2194:
  vivify_2193:
    set $S5098, $P5097
    iseq $I5099, $S5098, "our"
    new $P5081, 'Integer'
    set $P5081, $I5099
  unless_5082_end:
    if $P5081, if_5080
.annotate 'line', 1518
    find_lex $P5327, "$/"
    unless_null $P5327, vivify_2195
    new $P5327, "Undef"
  vivify_2195:
    $P5328 = $P5327."CURSOR"()
    find_dynamic_lex $P5331, "$*SCOPE"
    unless_null $P5331, vivify_2196
    get_hll_global $P5329, "GLOBAL"
    get_who $P5330, $P5329
    set $P5331, $P5330["$SCOPE"]
    unless_null $P5331, vivify_2197
    die "Contextual $*SCOPE not found"
  vivify_2197:
  vivify_2196:
    concat $P5332, $P5331, " scoped routines are not supported yet"
    $P5328."panic"($P5332)
.annotate 'line', 1517
    goto if_5080_end
  if_5080:
.annotate 'line', 1431
    find_dynamic_lex $P5103, "$*MULTINESS"
    unless_null $P5103, vivify_2198
    get_hll_global $P5101, "GLOBAL"
    get_who $P5102, $P5101
    set $P5103, $P5102["$MULTINESS"]
    unless_null $P5103, vivify_2199
    die "Contextual $*MULTINESS not found"
  vivify_2199:
  vivify_2198:
    set $S5104, $P5103
    iseq $I5105, $S5104, "multi"
    if $I5105, if_5100
.annotate 'line', 1482
    find_dynamic_lex $P5216, "$*MULTINESS"
    unless_null $P5216, vivify_2200
    get_hll_global $P5214, "GLOBAL"
    get_who $P5215, $P5214
    set $P5216, $P5215["$MULTINESS"]
    unless_null $P5216, vivify_2201
    die "Contextual $*MULTINESS not found"
  vivify_2201:
  vivify_2200:
    set $S5217, $P5216
    iseq $I5218, $S5217, "proto"
    if $I5218, if_5213
.annotate 'line', 1501
    find_lex $P5270, "$?PACKAGE"
    get_who $P5271, $P5270
    set $P5272, $P5271["@BLOCK"]
    unless_null $P5272, vivify_2202
    $P5272 = root_new ['parrot';'ResizablePMCArray']
  vivify_2202:
    set $P5273, $P5272[0]
    unless_null $P5273, vivify_2203
    $P5273 = root_new ['parrot';'ResizablePMCArray']
  vivify_2203:
    set $P5274, $P5273[0]
    unless_null $P5274, vivify_2204
    new $P5274, "Undef"
  vivify_2204:
    get_hll_global $P5275, "GLOBAL"
    nqp_get_package_through_who $P5276, $P5275, "PAST"
    get_who $P5277, $P5276
    set $P5278, $P5277["Var"]
    find_lex $P5279, "$name"
    unless_null $P5279, vivify_2205
    new $P5279, "Undef"
  vivify_2205:
    find_lex $P5280, "$past"
    unless_null $P5280, vivify_2206
    new $P5280, "Undef"
  vivify_2206:
    $P5281 = $P5278."new"($P5279 :named("name"), 1 :named("isdecl"), $P5280 :named("viviself"), "lexical" :named("scope"))
    $P5274."push"($P5281)
.annotate 'line', 1503
    find_lex $P5282, "$?PACKAGE"
    get_who $P5283, $P5282
    set $P5284, $P5283["@BLOCK"]
    unless_null $P5284, vivify_2207
    $P5284 = root_new ['parrot';'ResizablePMCArray']
  vivify_2207:
    set $P5285, $P5284[0]
    unless_null $P5285, vivify_2208
    new $P5285, "Undef"
  vivify_2208:
    find_lex $P5286, "$name"
    unless_null $P5286, vivify_2209
    new $P5286, "Undef"
  vivify_2209:
    $P5285."symbol"($P5286, "lexical" :named("scope"))
.annotate 'line', 1504
    find_dynamic_lex $P5290, "$*SCOPE"
    unless_null $P5290, vivify_2210
    get_hll_global $P5288, "GLOBAL"
    get_who $P5289, $P5288
    set $P5290, $P5289["$SCOPE"]
    unless_null $P5290, vivify_2211
    die "Contextual $*SCOPE not found"
  vivify_2211:
  vivify_2210:
    set $S5291, $P5290
    iseq $I5292, $S5291, "our"
    unless $I5292, if_5287_end
.annotate 'line', 1507
    find_dynamic_lex $P5295, "$*SC"
    unless_null $P5295, vivify_2212
    get_hll_global $P5293, "GLOBAL"
    get_who $P5294, $P5293
    set $P5295, $P5294["$SC"]
    unless_null $P5295, vivify_2213
    die "Contextual $*SC not found"
  vivify_2213:
  vivify_2212:
    find_dynamic_lex $P5298, "$*PACKAGE"
    unless_null $P5298, vivify_2214
    get_hll_global $P5296, "GLOBAL"
    get_who $P5297, $P5296
    set $P5298, $P5297["$PACKAGE"]
    unless_null $P5298, vivify_2215
    die "Contextual $*PACKAGE not found"
  vivify_2215:
  vivify_2214:
    find_lex $P5299, "$name"
    unless_null $P5299, vivify_2216
    new $P5299, "Undef"
  vivify_2216:
    find_lex $P5300, "$past"
    unless_null $P5300, vivify_2217
    new $P5300, "Undef"
  vivify_2217:
    $P5295."install_package_routine"($P5298, $P5299, $P5300)
.annotate 'line', 1508
    find_lex $P5301, "$?PACKAGE"
    get_who $P5302, $P5301
    set $P5303, $P5302["@BLOCK"]
    unless_null $P5303, vivify_2218
    $P5303 = root_new ['parrot';'ResizablePMCArray']
  vivify_2218:
    set $P5304, $P5303[0]
    unless_null $P5304, vivify_2219
    $P5304 = root_new ['parrot';'ResizablePMCArray']
  vivify_2219:
    set $P5305, $P5304[0]
    unless_null $P5305, vivify_2220
    new $P5305, "Undef"
  vivify_2220:
    get_hll_global $P5306, "GLOBAL"
    nqp_get_package_through_who $P5307, $P5306, "PAST"
    get_who $P5308, $P5307
    set $P5309, $P5308["Op"]
.annotate 'line', 1510
    find_lex $P5310, "$name"
    unless_null $P5310, vivify_2221
    new $P5310, "Undef"
  vivify_2221:
    new $P5311, "ResizablePMCArray"
    push $P5311, $P5310
    find_lex $P5312, "$/"
    unless_null $P5312, vivify_2222
    new $P5312, "Undef"
  vivify_2222:
    $P5313 = "lexical_package_lookup"($P5311, $P5312)
.annotate 'line', 1511
    get_hll_global $P5314, "GLOBAL"
    nqp_get_package_through_who $P5315, $P5314, "PAST"
    get_who $P5316, $P5315
    set $P5317, $P5316["Var"]
    find_lex $P5318, "$name"
    unless_null $P5318, vivify_2223
    new $P5318, "Undef"
  vivify_2223:
    $P5319 = $P5317."new"($P5318 :named("name"), "lexical" :named("scope"))
    $P5320 = $P5309."new"($P5313, $P5319, "bind" :named("pasttype"))
.annotate 'line', 1508
    $P5305."push"($P5320)
  if_5287_end:
.annotate 'line', 1500
    goto if_5213_end
  if_5213:
.annotate 'line', 1482
    .const 'Sub' $P5220 = "510_1303857440.612" 
    capture_lex $P5220
    $P5220()
  if_5213_end:
    goto if_5100_end
  if_5100:
.annotate 'line', 1431
    .const 'Sub' $P5107 = "507_1303857440.612" 
    capture_lex $P5107
    $P5107()
  if_5100_end:
.annotate 'line', 1515
    get_hll_global $P5321, "GLOBAL"
    nqp_get_package_through_who $P5322, $P5321, "PAST"
    get_who $P5323, $P5322
    set $P5324, $P5323["Var"]
    find_lex $P5325, "$name"
    unless_null $P5325, vivify_2281
    new $P5325, "Undef"
  vivify_2281:
    $P5326 = $P5324."new"($P5325 :named("name"))
    store_lex "$past", $P5326
  if_5080_end:
.annotate 'line', 1522
    find_lex $P5337, "$name"
    unless_null $P5337, vivify_2282
    new $P5337, "Undef"
  vivify_2282:
    set $S5338, $P5337
    iseq $I5339, $S5338, "MAIN"
    if $I5339, if_5336
    new $P5335, 'Integer'
    set $P5335, $I5339
    goto if_5336_end
  if_5336:
    find_dynamic_lex $P5342, "$*MULTINESS"
    unless_null $P5342, vivify_2283
    get_hll_global $P5340, "GLOBAL"
    get_who $P5341, $P5340
    set $P5342, $P5341["$MULTINESS"]
    unless_null $P5342, vivify_2284
    die "Contextual $*MULTINESS not found"
  vivify_2284:
  vivify_2283:
    set $S5343, $P5342
    isne $I5344, $S5343, "multi"
    new $P5335, 'Integer'
    set $P5335, $I5344
  if_5336_end:
    if $P5335, if_5334
    set $P5333, $P5335
    goto if_5334_end
  if_5334:
.annotate 'line', 1523
    find_lex $P5345, "$block"
    unless_null $P5345, vivify_2285
    new $P5345, "Undef"
  vivify_2285:
    store_dynamic_lex "$*MAIN_SUB", $P5345
.annotate 'line', 1522
    set $P5333, $P5345
  if_5334_end:
.annotate 'line', 1427
    .return ($P5333)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5219"  :anon :subid("510_1303857440.612") :outer("506_1303857440.612")
.annotate 'line', 1487
    new $P5221, "Undef"
    .lex "$cholder", $P5221
.annotate 'line', 1486
    find_dynamic_lex $P5225, "$*SCOPE"
    unless_null $P5225, vivify_2224
    get_hll_global $P5223, "GLOBAL"
    get_who $P5224, $P5223
    set $P5225, $P5224["$SCOPE"]
    unless_null $P5225, vivify_2225
    die "Contextual $*SCOPE not found"
  vivify_2225:
  vivify_2224:
    set $S5226, $P5225
    iseq $I5227, $S5226, "our"
    unless $I5227, if_5222_end
    die "our-scoped protos not yet implemented"
  if_5222_end:
.annotate 'line', 1487
    get_hll_global $P5228, "GLOBAL"
    nqp_get_package_through_who $P5229, $P5228, "PAST"
    get_who $P5230, $P5229
    set $P5231, $P5230["Op"]
    $P5232 = $P5231."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5232
.annotate 'line', 1488
    find_lex $P5233, "$?PACKAGE"
    get_who $P5234, $P5233
    set $P5235, $P5234["@BLOCK"]
    unless_null $P5235, vivify_2226
    $P5235 = root_new ['parrot';'ResizablePMCArray']
  vivify_2226:
    set $P5236, $P5235[0]
    unless_null $P5236, vivify_2227
    $P5236 = root_new ['parrot';'ResizablePMCArray']
  vivify_2227:
    set $P5237, $P5236[0]
    unless_null $P5237, vivify_2228
    new $P5237, "Undef"
  vivify_2228:
    get_hll_global $P5238, "GLOBAL"
    nqp_get_package_through_who $P5239, $P5238, "PAST"
    get_who $P5240, $P5239
    set $P5241, $P5240["Var"]
    find_lex $P5242, "$name"
    unless_null $P5242, vivify_2229
    new $P5242, "Undef"
  vivify_2229:
    find_lex $P5243, "$past"
    unless_null $P5243, vivify_2230
    new $P5243, "Undef"
  vivify_2230:
    $P5244 = $P5241."new"($P5242 :named("name"), 1 :named("isdecl"), $P5243 :named("viviself"), "lexical" :named("scope"))
    $P5237."push"($P5244)
.annotate 'line', 1490
    find_lex $P5245, "$?PACKAGE"
    get_who $P5246, $P5245
    set $P5247, $P5246["@BLOCK"]
    unless_null $P5247, vivify_2231
    $P5247 = root_new ['parrot';'ResizablePMCArray']
  vivify_2231:
    set $P5248, $P5247[0]
    unless_null $P5248, vivify_2232
    $P5248 = root_new ['parrot';'ResizablePMCArray']
  vivify_2232:
    set $P5249, $P5248[0]
    unless_null $P5249, vivify_2233
    new $P5249, "Undef"
  vivify_2233:
    get_hll_global $P5250, "GLOBAL"
    nqp_get_package_through_who $P5251, $P5250, "PAST"
    get_who $P5252, $P5251
    set $P5253, $P5252["Op"]
.annotate 'line', 1492
    get_hll_global $P5254, "GLOBAL"
    nqp_get_package_through_who $P5255, $P5254, "PAST"
    get_who $P5256, $P5255
    set $P5257, $P5256["Var"]
    find_lex $P5258, "$name"
    unless_null $P5258, vivify_2234
    new $P5258, "Undef"
  vivify_2234:
    $P5259 = $P5257."new"($P5258 :named("name"))
    find_lex $P5260, "$cholder"
    unless_null $P5260, vivify_2235
    new $P5260, "Undef"
  vivify_2235:
    $P5261 = $P5253."new"($P5259, $P5260, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1490
    $P5249."push"($P5261)
.annotate 'line', 1495
    find_lex $P5262, "$?PACKAGE"
    get_who $P5263, $P5262
    set $P5264, $P5263["@BLOCK"]
    unless_null $P5264, vivify_2236
    $P5264 = root_new ['parrot';'ResizablePMCArray']
  vivify_2236:
    set $P5265, $P5264[0]
    unless_null $P5265, vivify_2237
    new $P5265, "Undef"
  vivify_2237:
    find_lex $P5266, "$name"
    unless_null $P5266, vivify_2238
    new $P5266, "Undef"
  vivify_2238:
    find_lex $P5267, "$cholder"
    unless_null $P5267, vivify_2239
    new $P5267, "Undef"
  vivify_2239:
    $P5265."symbol"($P5266, "lexical" :named("scope"), 1 :named("proto"), $P5267 :named("cholder"))
.annotate 'line', 1498
    find_lex $P5268, "$past"
    unless_null $P5268, vivify_2240
    new $P5268, "Undef"
  vivify_2240:
    $P5269 = $P5268."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1482
    .return ($P5269)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5106"  :anon :subid("507_1303857440.612") :outer("506_1303857440.612")
.annotate 'line', 1431
    .const 'Sub' $P5129 = "508_1303857440.612" 
    capture_lex $P5129
.annotate 'line', 1434
    new $P5108, "Undef"
    .lex "$cholder", $P5108
.annotate 'line', 1435
    $P5109 = root_new ['parrot';'Hash']
    .lex "%sym", $P5109
.annotate 'line', 1433
    find_dynamic_lex $P5113, "$*SCOPE"
    unless_null $P5113, vivify_2241
    get_hll_global $P5111, "GLOBAL"
    get_who $P5112, $P5111
    set $P5113, $P5112["$SCOPE"]
    unless_null $P5113, vivify_2242
    die "Contextual $*SCOPE not found"
  vivify_2242:
  vivify_2241:
    set $S5114, $P5113
    iseq $I5115, $S5114, "our"
    unless $I5115, if_5110_end
    die "our-scoped multis not yet implemented"
  if_5110_end:
    find_lex $P5116, "$cholder"
    unless_null $P5116, vivify_2243
    new $P5116, "Undef"
  vivify_2243:
.annotate 'line', 1435
    find_lex $P5117, "$?PACKAGE"
    get_who $P5118, $P5117
    set $P5119, $P5118["@BLOCK"]
    unless_null $P5119, vivify_2244
    $P5119 = root_new ['parrot';'ResizablePMCArray']
  vivify_2244:
    set $P5120, $P5119[0]
    unless_null $P5120, vivify_2245
    new $P5120, "Undef"
  vivify_2245:
    find_lex $P5121, "$name"
    unless_null $P5121, vivify_2246
    new $P5121, "Undef"
  vivify_2246:
    $P5122 = $P5120."symbol"($P5121)
    store_lex "%sym", $P5122
.annotate 'line', 1436
    find_lex $P5124, "%sym"
    unless_null $P5124, vivify_2247
    $P5124 = root_new ['parrot';'Hash']
  vivify_2247:
    set $P5125, $P5124["cholder"]
    unless_null $P5125, vivify_2248
    new $P5125, "Undef"
  vivify_2248:
    if $P5125, if_5123
.annotate 'line', 1441
    .const 'Sub' $P5129 = "508_1303857440.612" 
    capture_lex $P5129
    $P5129()
    goto if_5123_end
  if_5123:
.annotate 'line', 1437
    find_lex $P5126, "%sym"
    unless_null $P5126, vivify_2276
    $P5126 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P5127, $P5126["cholder"]
    unless_null $P5127, vivify_2277
    new $P5127, "Undef"
  vivify_2277:
    store_lex "$cholder", $P5127
  if_5123_end:
.annotate 'line', 1477
    find_lex $P5209, "$cholder"
    unless_null $P5209, vivify_2278
    new $P5209, "Undef"
  vivify_2278:
    find_lex $P5210, "$past"
    unless_null $P5210, vivify_2279
    new $P5210, "Undef"
  vivify_2279:
    $P5209."push"($P5210)
.annotate 'line', 1480
    find_lex $P5211, "$past"
    unless_null $P5211, vivify_2280
    new $P5211, "Undef"
  vivify_2280:
    $P5212 = "attach_multi_signature"($P5211)
.annotate 'line', 1431
    .return ($P5212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5128"  :anon :subid("508_1303857440.612") :outer("507_1303857440.612")
.annotate 'line', 1441
    .const 'Sub' $P5145 = "509_1303857440.612" 
    capture_lex $P5145
.annotate 'line', 1448
    new $P5130, "Undef"
    .lex "$found_proto", $P5130
.annotate 'line', 1466
    new $P5131, "Undef"
    .lex "$dispatch_setup", $P5131
.annotate 'line', 1443
    find_lex $P5133, "%sym"
    unless_null $P5133, vivify_2249
    $P5133 = root_new ['parrot';'Hash']
  vivify_2249:
    set $P5134, $P5133["proto"]
    unless_null $P5134, vivify_2250
    new $P5134, "Undef"
  vivify_2250:
    unless $P5134, if_5132_end
.annotate 'line', 1446
    find_lex $P5135, "$/"
    unless_null $P5135, vivify_2251
    new $P5135, "Undef"
  vivify_2251:
    $P5136 = $P5135."CURSOR"()
    $P5136."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5132_end:
.annotate 'line', 1443
    find_lex $P5137, "$found_proto"
    unless_null $P5137, vivify_2252
    new $P5137, "Undef"
  vivify_2252:
.annotate 'line', 1449
    find_lex $P5139, "$?PACKAGE"
    get_who $P5140, $P5139
    set $P5141, $P5140["@BLOCK"]
    unless_null $P5141, vivify_2253
    $P5141 = root_new ['parrot';'ResizablePMCArray']
  vivify_2253:
    defined $I5142, $P5141
    unless $I5142, for_undef_2254
    iter $P5138, $P5141
    new $P5167, 'ExceptionHandler'
    set_label $P5167, loop5166_handler
    $P5167."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5167
  loop5166_test:
    unless $P5138, loop5166_done
    shift $P5143, $P5138
  loop5166_redo:
    .const 'Sub' $P5145 = "509_1303857440.612" 
    capture_lex $P5145
    $P5145($P5143)
  loop5166_next:
    goto loop5166_test
  loop5166_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5168, exception, 'type'
    eq $P5168, .CONTROL_LOOP_NEXT, loop5166_next
    eq $P5168, .CONTROL_LOOP_REDO, loop5166_redo
  loop5166_done:
    pop_eh 
  for_undef_2254:
.annotate 'line', 1460
    find_lex $P5170, "$found_proto"
    unless_null $P5170, vivify_2263
    new $P5170, "Undef"
  vivify_2263:
    if $P5170, unless_5169_end
.annotate 'line', 1461
    find_lex $P5171, "$/"
    unless_null $P5171, vivify_2264
    new $P5171, "Undef"
  vivify_2264:
    $P5172 = $P5171."CURSOR"()
    $P5172."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5169_end:
.annotate 'line', 1465
    get_hll_global $P5173, "GLOBAL"
    nqp_get_package_through_who $P5174, $P5173, "PAST"
    get_who $P5175, $P5174
    set $P5176, $P5175["Op"]
    $P5177 = $P5176."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5177
.annotate 'line', 1466
    get_hll_global $P5178, "GLOBAL"
    nqp_get_package_through_who $P5179, $P5178, "PAST"
    get_who $P5180, $P5179
    set $P5181, $P5180["Op"]
.annotate 'line', 1468
    get_hll_global $P5182, "GLOBAL"
    nqp_get_package_through_who $P5183, $P5182, "PAST"
    get_who $P5184, $P5183
    set $P5185, $P5184["Var"]
    find_lex $P5186, "$name"
    unless_null $P5186, vivify_2265
    new $P5186, "Undef"
  vivify_2265:
    $P5187 = $P5185."new"($P5186 :named("name"), "outer" :named("scope"))
    find_lex $P5188, "$cholder"
    unless_null $P5188, vivify_2266
    new $P5188, "Undef"
  vivify_2266:
    $P5189 = $P5181."new"($P5187, $P5188, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1466
    store_lex "$dispatch_setup", $P5189
.annotate 'line', 1471
    find_lex $P5190, "$?PACKAGE"
    get_who $P5191, $P5190
    set $P5192, $P5191["@BLOCK"]
    unless_null $P5192, vivify_2267
    $P5192 = root_new ['parrot';'ResizablePMCArray']
  vivify_2267:
    set $P5193, $P5192[0]
    unless_null $P5193, vivify_2268
    $P5193 = root_new ['parrot';'ResizablePMCArray']
  vivify_2268:
    set $P5194, $P5193[0]
    unless_null $P5194, vivify_2269
    new $P5194, "Undef"
  vivify_2269:
    get_hll_global $P5195, "GLOBAL"
    nqp_get_package_through_who $P5196, $P5195, "PAST"
    get_who $P5197, $P5196
    set $P5198, $P5197["Var"]
    find_lex $P5199, "$name"
    unless_null $P5199, vivify_2270
    new $P5199, "Undef"
  vivify_2270:
    find_lex $P5200, "$dispatch_setup"
    unless_null $P5200, vivify_2271
    new $P5200, "Undef"
  vivify_2271:
    $P5201 = $P5198."new"($P5199 :named("name"), 1 :named("isdecl"), $P5200 :named("viviself"), "lexical" :named("scope"))
    $P5194."push"($P5201)
.annotate 'line', 1473
    find_lex $P5202, "$?PACKAGE"
    get_who $P5203, $P5202
    set $P5204, $P5203["@BLOCK"]
    unless_null $P5204, vivify_2272
    $P5204 = root_new ['parrot';'ResizablePMCArray']
  vivify_2272:
    set $P5205, $P5204[0]
    unless_null $P5205, vivify_2273
    new $P5205, "Undef"
  vivify_2273:
    find_lex $P5206, "$name"
    unless_null $P5206, vivify_2274
    new $P5206, "Undef"
  vivify_2274:
    find_lex $P5207, "$cholder"
    unless_null $P5207, vivify_2275
    new $P5207, "Undef"
  vivify_2275:
    $P5208 = $P5205."symbol"($P5206, "lexical" :named("scope"), $P5207 :named("cholder"))
.annotate 'line', 1441
    .return ($P5208)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5144"  :anon :subid("509_1303857440.612") :outer("508_1303857440.612")
    .param pmc param_5147
.annotate 'line', 1450
    $P5146 = root_new ['parrot';'Hash']
    .lex "%sym", $P5146
    .lex "$_", param_5147
    find_lex $P5148, "$_"
    unless_null $P5148, vivify_2255
    new $P5148, "Undef"
  vivify_2255:
    find_lex $P5149, "$name"
    unless_null $P5149, vivify_2256
    new $P5149, "Undef"
  vivify_2256:
    $P5150 = $P5148."symbol"($P5149)
    store_lex "%sym", $P5150
.annotate 'line', 1451
    find_lex $P5155, "%sym"
    unless_null $P5155, vivify_2257
    $P5155 = root_new ['parrot';'Hash']
  vivify_2257:
    set $P5156, $P5155["proto"]
    unless_null $P5156, vivify_2258
    new $P5156, "Undef"
  vivify_2258:
    unless $P5156, unless_5154
    set $P5153, $P5156
    goto unless_5154_end
  unless_5154:
    find_lex $P5157, "%sym"
    unless_null $P5157, vivify_2259
    $P5157 = root_new ['parrot';'Hash']
  vivify_2259:
    set $P5158, $P5157["cholder"]
    unless_null $P5158, vivify_2260
    new $P5158, "Undef"
  vivify_2260:
    set $P5153, $P5158
  unless_5154_end:
    if $P5153, if_5152
.annotate 'line', 1454
    find_lex $P5162, "%sym"
    unless_null $P5162, vivify_2261
    $P5162 = root_new ['parrot';'Hash']
  vivify_2261:
    if $P5162, if_5161
    set $P5160, $P5162
    goto if_5161_end
  if_5161:
.annotate 'line', 1455
    find_lex $P5163, "$/"
    unless_null $P5163, vivify_2262
    new $P5163, "Undef"
  vivify_2262:
    $P5164 = $P5163."CURSOR"()
    $P5165 = $P5164."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1454
    set $P5160, $P5165
  if_5161_end:
    set $P5151, $P5160
.annotate 'line', 1451
    goto if_5152_end
  if_5152:
.annotate 'line', 1452
    new $P5159, "Integer"
    assign $P5159, 1
    store_lex "$found_proto", $P5159
.annotate 'line', 1451
    set $P5151, $P5159
  if_5152_end:
.annotate 'line', 1449
    .return ($P5151)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5356"  :anon :subid("511_1303857440.612") :outer("505_1303857440.612")
    .param pmc param_5358
.annotate 'line', 1530
    .lex "$_", param_5358
    find_lex $P5359, "$_"
    unless_null $P5359, vivify_2293
    new $P5359, "Undef"
  vivify_2293:
    $P5360 = $P5359."ast"()
    find_lex $P5361, "$/"
    unless_null $P5361, vivify_2294
    new $P5361, "Undef"
  vivify_2294:
    $P5362 = $P5360($P5361)
    .return ($P5362)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("512_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5370
    .param pmc param_5371
.annotate 'line', 1537
    .const 'Sub' $P5539 = "514_1303857440.612" 
    capture_lex $P5539
    .const 'Sub' $P5407 = "513_1303857440.612" 
    capture_lex $P5407
    .lex "self", param_5370
    .lex "$/", param_5371
.annotate 'line', 1540
    new $P5372, "Undef"
    .lex "$past", $P5372
.annotate 'line', 1537
    find_lex $P5373, "$past"
    unless_null $P5373, vivify_2296
    new $P5373, "Undef"
  vivify_2296:
.annotate 'line', 1541
    find_lex $P5375, "$/"
    unless_null $P5375, vivify_2297
    $P5375 = root_new ['parrot';'Hash']
  vivify_2297:
    set $P5376, $P5375["onlystar"]
    unless_null $P5376, vivify_2298
    new $P5376, "Undef"
  vivify_2298:
    if $P5376, if_5374
.annotate 'line', 1545
    find_lex $P5378, "$/"
    unless_null $P5378, vivify_2299
    $P5378 = root_new ['parrot';'Hash']
  vivify_2299:
    set $P5379, $P5378["blockoid"]
    unless_null $P5379, vivify_2300
    new $P5379, "Undef"
  vivify_2300:
    $P5380 = $P5379."ast"()
    store_lex "$past", $P5380
.annotate 'line', 1546
    find_lex $P5381, "$past"
    unless_null $P5381, vivify_2301
    new $P5381, "Undef"
  vivify_2301:
    $P5381."blocktype"("declaration")
.annotate 'line', 1547
    find_dynamic_lex $P5385, "$*RETURN_USED"
    unless_null $P5385, vivify_2302
    get_hll_global $P5383, "GLOBAL"
    get_who $P5384, $P5383
    set $P5385, $P5384["$RETURN_USED"]
    unless_null $P5385, vivify_2303
    die "Contextual $*RETURN_USED not found"
  vivify_2303:
  vivify_2302:
    unless $P5385, if_5382_end
.annotate 'line', 1548
    find_lex $P5386, "$past"
    unless_null $P5386, vivify_2304
    new $P5386, "Undef"
  vivify_2304:
    $P5386."control"("return_pir")
  if_5382_end:
.annotate 'line', 1544
    goto if_5374_end
  if_5374:
.annotate 'line', 1542
    $P5377 = "only_star_block"()
    store_lex "$past", $P5377
  if_5374_end:
.annotate 'line', 1553
    find_lex $P5388, "$past"
    unless_null $P5388, vivify_2305
    $P5388 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P5389, $P5388["signature_has_invocant"]
    unless_null $P5389, vivify_2306
    new $P5389, "Undef"
  vivify_2306:
    if $P5389, unless_5387_end
.annotate 'line', 1554
    find_lex $P5390, "$past"
    unless_null $P5390, vivify_2307
    $P5390 = root_new ['parrot';'ResizablePMCArray']
  vivify_2307:
    set $P5391, $P5390[0]
    unless_null $P5391, vivify_2308
    new $P5391, "Undef"
  vivify_2308:
    get_hll_global $P5392, "GLOBAL"
    nqp_get_package_through_who $P5393, $P5392, "PAST"
    get_who $P5394, $P5393
    set $P5395, $P5394["Var"]
.annotate 'line', 1556
    get_hll_global $P5396, "GLOBAL"
    nqp_get_package_through_who $P5397, $P5396, "PAST"
    get_who $P5398, $P5397
    set $P5399, $P5398["Var"]
    $P5400 = $P5399."new"("$?CLASS" :named("name"))
    $P5401 = $P5395."new"("self" :named("name"), "parameter" :named("scope"), $P5400 :named("multitype"))
.annotate 'line', 1554
    $P5391."unshift"($P5401)
  unless_5387_end:
.annotate 'line', 1559
    find_lex $P5402, "$past"
    unless_null $P5402, vivify_2309
    new $P5402, "Undef"
  vivify_2309:
    $P5402."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1562
    find_lex $P5404, "$/"
    unless_null $P5404, vivify_2310
    $P5404 = root_new ['parrot';'Hash']
  vivify_2310:
    set $P5405, $P5404["deflongname"]
    unless_null $P5405, vivify_2311
    new $P5405, "Undef"
  vivify_2311:
    unless $P5405, if_5403_end
    .const 'Sub' $P5407 = "513_1303857440.612" 
    capture_lex $P5407
    $P5407()
  if_5403_end:
.annotate 'line', 1603
    find_lex $P5525, "$/"
    find_lex $P5526, "$past"
    unless_null $P5526, vivify_2345
    new $P5526, "Undef"
  vivify_2345:
    $P5525."!make"($P5526)
.annotate 'line', 1604
    find_lex $P5527, "$past"
    unless_null $P5527, vivify_2346
    new $P5527, "Undef"
  vivify_2346:
    find_lex $P5528, "$past"
    unless_null $P5528, vivify_2347
    $P5528 = root_new ['parrot';'Hash']
    store_lex "$past", $P5528
  vivify_2347:
    set $P5528["block_past"], $P5527
.annotate 'line', 1605
    find_lex $P5531, "$/"
    unless_null $P5531, vivify_2348
    $P5531 = root_new ['parrot';'Hash']
  vivify_2348:
    set $P5532, $P5531["trait"]
    unless_null $P5532, vivify_2349
    new $P5532, "Undef"
  vivify_2349:
    if $P5532, if_5530
    set $P5529, $P5532
    goto if_5530_end
  if_5530:
.annotate 'line', 1606
    find_lex $P5534, "$/"
    unless_null $P5534, vivify_2350
    $P5534 = root_new ['parrot';'Hash']
  vivify_2350:
    set $P5535, $P5534["trait"]
    unless_null $P5535, vivify_2351
    new $P5535, "Undef"
  vivify_2351:
    defined $I5536, $P5535
    unless $I5536, for_undef_2352
    iter $P5533, $P5535
    new $P5546, 'ExceptionHandler'
    set_label $P5546, loop5545_handler
    $P5546."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5546
  loop5545_test:
    unless $P5533, loop5545_done
    shift $P5537, $P5533
  loop5545_redo:
    .const 'Sub' $P5539 = "514_1303857440.612" 
    capture_lex $P5539
    $P5539($P5537)
  loop5545_next:
    goto loop5545_test
  loop5545_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5547, exception, 'type'
    eq $P5547, .CONTROL_LOOP_NEXT, loop5545_next
    eq $P5547, .CONTROL_LOOP_REDO, loop5545_redo
  loop5545_done:
    pop_eh 
  for_undef_2352:
.annotate 'line', 1605
    set $P5529, $P5533
  if_5530_end:
.annotate 'line', 1537
    .return ($P5529)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5406"  :anon :subid("513_1303857440.612") :outer("512_1303857440.612")
.annotate 'line', 1564
    new $P5408, "Undef"
    .lex "$name", $P5408
.annotate 'line', 1569
    new $P5409, "Undef"
    .lex "$to_add", $P5409
.annotate 'line', 1564
    find_lex $P5410, "$/"
    unless_null $P5410, vivify_2312
    $P5410 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P5411, $P5410["private"]
    unless_null $P5411, vivify_2313
    new $P5411, "Undef"
  vivify_2313:
    set $S5412, $P5411
    new $P5413, 'String'
    set $P5413, $S5412
    find_lex $P5414, "$/"
    unless_null $P5414, vivify_2314
    $P5414 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P5415, $P5414["deflongname"]
    unless_null $P5415, vivify_2315
    $P5415 = root_new ['parrot';'ResizablePMCArray']
  vivify_2315:
    set $P5416, $P5415[0]
    unless_null $P5416, vivify_2316
    new $P5416, "Undef"
  vivify_2316:
    $P5417 = $P5416."ast"()
    set $S5418, $P5417
    concat $P5419, $P5413, $S5418
    store_lex "$name", $P5419
.annotate 'line', 1565
    find_lex $P5420, "$past"
    unless_null $P5420, vivify_2317
    new $P5420, "Undef"
  vivify_2317:
    find_lex $P5421, "$name"
    unless_null $P5421, vivify_2318
    new $P5421, "Undef"
  vivify_2318:
    $P5420."name"($P5421)
.annotate 'line', 1569
    find_dynamic_lex $P5426, "$*MULTINESS"
    unless_null $P5426, vivify_2319
    get_hll_global $P5424, "GLOBAL"
    get_who $P5425, $P5424
    set $P5426, $P5425["$MULTINESS"]
    unless_null $P5426, vivify_2320
    die "Contextual $*MULTINESS not found"
  vivify_2320:
  vivify_2319:
    set $S5427, $P5426
    isne $I5428, $S5427, "proto"
    if $I5428, if_5423
.annotate 'line', 1571
    get_hll_global $P5435, "GLOBAL"
    nqp_get_package_through_who $P5436, $P5435, "PAST"
    get_who $P5437, $P5436
    set $P5438, $P5437["Op"]
.annotate 'line', 1573
    get_hll_global $P5439, "GLOBAL"
    nqp_get_package_through_who $P5440, $P5439, "PAST"
    get_who $P5441, $P5440
    set $P5442, $P5441["Val"]
    find_lex $P5443, "$past"
    unless_null $P5443, vivify_2321
    new $P5443, "Undef"
  vivify_2321:
    $P5444 = $P5442."new"($P5443 :named("value"))
.annotate 'line', 1574
    get_hll_global $P5445, "GLOBAL"
    nqp_get_package_through_who $P5446, $P5445, "PAST"
    get_who $P5447, $P5446
    set $P5448, $P5447["Op"]
    $P5449 = $P5448."new"("list" :named("pasttype"))
    $P5450 = $P5438."new"($P5444, $P5449, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1571
    set $P5422, $P5450
.annotate 'line', 1569
    goto if_5423_end
  if_5423:
.annotate 'line', 1570
    get_hll_global $P5429, "GLOBAL"
    nqp_get_package_through_who $P5430, $P5429, "PAST"
    get_who $P5431, $P5430
    set $P5432, $P5431["Val"]
    find_lex $P5433, "$past"
    unless_null $P5433, vivify_2322
    new $P5433, "Undef"
  vivify_2322:
    $P5434 = $P5432."new"($P5433 :named("value"))
    set $P5422, $P5434
  if_5423_end:
.annotate 'line', 1569
    store_lex "$to_add", $P5422
.annotate 'line', 1576
    find_dynamic_lex $P5454, "$*MULTINESS"
    unless_null $P5454, vivify_2323
    get_hll_global $P5452, "GLOBAL"
    get_who $P5453, $P5452
    set $P5454, $P5453["$MULTINESS"]
    unless_null $P5454, vivify_2324
    die "Contextual $*MULTINESS not found"
  vivify_2324:
  vivify_2323:
    set $S5455, $P5454
    iseq $I5456, $S5455, "proto"
    unless $I5456, if_5451_end
    find_lex $P5457, "$past"
    unless_null $P5457, vivify_2325
    new $P5457, "Undef"
  vivify_2325:
    $P5457."pirflags"(":instanceof(\"DispatcherSub\")")
  if_5451_end:
.annotate 'line', 1580
    find_dynamic_lex $P5461, "$*MULTINESS"
    unless_null $P5461, vivify_2326
    get_hll_global $P5459, "GLOBAL"
    get_who $P5460, $P5459
    set $P5461, $P5460["$MULTINESS"]
    unless_null $P5461, vivify_2327
    die "Contextual $*MULTINESS not found"
  vivify_2327:
  vivify_2326:
    set $S5462, $P5461
    iseq $I5463, $S5462, "multi"
    unless $I5463, if_5458_end
    find_lex $P5464, "$past"
    unless_null $P5464, vivify_2328
    new $P5464, "Undef"
  vivify_2328:
    "attach_multi_signature"($P5464)
  if_5458_end:
.annotate 'line', 1583
    find_dynamic_lex $P5468, "$*PACKAGE-SETUP"
    unless_null $P5468, vivify_2329
    get_hll_global $P5466, "GLOBAL"
    get_who $P5467, $P5466
    set $P5468, $P5467["$PACKAGE-SETUP"]
    unless_null $P5468, vivify_2330
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2330:
  vivify_2329:
    defined $I5469, $P5468
    unless $I5469, if_5465_end
.annotate 'line', 1584
    find_dynamic_lex $P5472, "$*PACKAGE-SETUP"
    unless_null $P5472, vivify_2331
    get_hll_global $P5470, "GLOBAL"
    get_who $P5471, $P5470
    set $P5472, $P5471["$PACKAGE-SETUP"]
    unless_null $P5472, vivify_2332
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2332:
  vivify_2331:
    get_hll_global $P5473, "GLOBAL"
    nqp_get_package_through_who $P5474, $P5473, "PAST"
    get_who $P5475, $P5474
    set $P5476, $P5475["Op"]
.annotate 'line', 1585
    find_dynamic_lex $P5481, "$*MULTINESS"
    unless_null $P5481, vivify_2333
    get_hll_global $P5479, "GLOBAL"
    get_who $P5480, $P5479
    set $P5481, $P5480["$MULTINESS"]
    unless_null $P5481, vivify_2334
    die "Contextual $*MULTINESS not found"
  vivify_2334:
  vivify_2333:
    set $S5482, $P5481
    iseq $I5483, $S5482, "multi"
    if $I5483, if_5478
    new $P5485, "String"
    assign $P5485, "add_method"
    set $P5477, $P5485
    goto if_5478_end
  if_5478:
    new $P5484, "String"
    assign $P5484, "add_multi_method"
    set $P5477, $P5484
  if_5478_end:
.annotate 'line', 1586
    get_hll_global $P5486, "GLOBAL"
    nqp_get_package_through_who $P5487, $P5486, "PAST"
    get_who $P5488, $P5487
    set $P5489, $P5488["Op"]
.annotate 'line', 1589
    get_hll_global $P5490, "GLOBAL"
    nqp_get_package_through_who $P5491, $P5490, "PAST"
    get_who $P5492, $P5491
    set $P5493, $P5492["Var"]
    $P5494 = $P5493."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5495 = $P5489."new"($P5494, "get_how PP" :named("pirop"))
.annotate 'line', 1591
    get_hll_global $P5496, "GLOBAL"
    nqp_get_package_through_who $P5497, $P5496, "PAST"
    get_who $P5498, $P5497
    set $P5499, $P5498["Var"]
    $P5500 = $P5499."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1592
    get_hll_global $P5501, "GLOBAL"
    nqp_get_package_through_who $P5502, $P5501, "PAST"
    get_who $P5503, $P5502
    set $P5504, $P5503["Val"]
    find_lex $P5505, "$name"
    unless_null $P5505, vivify_2335
    new $P5505, "Undef"
  vivify_2335:
    $P5506 = $P5504."new"($P5505 :named("value"))
    find_lex $P5507, "$to_add"
    unless_null $P5507, vivify_2336
    new $P5507, "Undef"
  vivify_2336:
    $P5508 = $P5476."new"($P5495, $P5500, $P5506, $P5507, "callmethod" :named("pasttype"), $P5477 :named("name"))
.annotate 'line', 1584
    $P5472."push"($P5508)
  if_5465_end:
.annotate 'line', 1597
    find_dynamic_lex $P5513, "$*SCOPE"
    unless_null $P5513, vivify_2337
    get_hll_global $P5511, "GLOBAL"
    get_who $P5512, $P5511
    set $P5513, $P5512["$SCOPE"]
    unless_null $P5513, vivify_2338
    die "Contextual $*SCOPE not found"
  vivify_2338:
  vivify_2337:
    set $S5514, $P5513
    iseq $I5515, $S5514, "our"
    if $I5515, if_5510
    new $P5509, 'Integer'
    set $P5509, $I5515
    goto if_5510_end
  if_5510:
.annotate 'line', 1598
    find_dynamic_lex $P5518, "$*SC"
    unless_null $P5518, vivify_2339
    get_hll_global $P5516, "GLOBAL"
    get_who $P5517, $P5516
    set $P5518, $P5517["$SC"]
    unless_null $P5518, vivify_2340
    die "Contextual $*SC not found"
  vivify_2340:
  vivify_2339:
    find_dynamic_lex $P5521, "$*PACKAGE"
    unless_null $P5521, vivify_2341
    get_hll_global $P5519, "GLOBAL"
    get_who $P5520, $P5519
    set $P5521, $P5520["$PACKAGE"]
    unless_null $P5521, vivify_2342
    die "Contextual $*PACKAGE not found"
  vivify_2342:
  vivify_2341:
    find_lex $P5522, "$name"
    unless_null $P5522, vivify_2343
    new $P5522, "Undef"
  vivify_2343:
    find_lex $P5523, "$past"
    unless_null $P5523, vivify_2344
    new $P5523, "Undef"
  vivify_2344:
    $P5524 = $P5518."install_package_routine"($P5521, $P5522, $P5523)
.annotate 'line', 1597
    set $P5509, $P5524
  if_5510_end:
.annotate 'line', 1562
    .return ($P5509)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5538"  :anon :subid("514_1303857440.612") :outer("512_1303857440.612")
    .param pmc param_5540
.annotate 'line', 1606
    .lex "$_", param_5540
    find_lex $P5541, "$_"
    unless_null $P5541, vivify_2353
    new $P5541, "Undef"
  vivify_2353:
    $P5542 = $P5541."ast"()
    find_lex $P5543, "$/"
    unless_null $P5543, vivify_2354
    new $P5543, "Undef"
  vivify_2354:
    $P5544 = $P5542($P5543)
    .return ($P5544)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("515_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5551
    .param pmc param_5552
.annotate 'line', 1638
    .const 'Sub' $P5595 = "517_1303857440.612" 
    capture_lex $P5595
    .const 'Sub' $P5563 = "516_1303857440.612" 
    capture_lex $P5563
    .lex "self", param_5551
    .lex "$/", param_5552
.annotate 'line', 1639
    new $P5553, "Undef"
    .lex "$BLOCKINIT", $P5553
    find_lex $P5554, "$?PACKAGE"
    get_who $P5555, $P5554
    set $P5556, $P5555["@BLOCK"]
    unless_null $P5556, vivify_2355
    $P5556 = root_new ['parrot';'ResizablePMCArray']
  vivify_2355:
    set $P5557, $P5556[0]
    unless_null $P5557, vivify_2356
    $P5557 = root_new ['parrot';'ResizablePMCArray']
  vivify_2356:
    set $P5558, $P5557[0]
    unless_null $P5558, vivify_2357
    new $P5558, "Undef"
  vivify_2357:
    store_lex "$BLOCKINIT", $P5558
.annotate 'line', 1640
    find_lex $P5560, "$/"
    unless_null $P5560, vivify_2358
    $P5560 = root_new ['parrot';'Hash']
  vivify_2358:
    set $P5561, $P5560["invocant"]
    unless_null $P5561, vivify_2359
    new $P5561, "Undef"
  vivify_2359:
    unless $P5561, if_5559_end
    .const 'Sub' $P5563 = "516_1303857440.612" 
    capture_lex $P5563
    $P5563()
  if_5559_end:
.annotate 'line', 1649
    find_lex $P5590, "$/"
    unless_null $P5590, vivify_2369
    $P5590 = root_new ['parrot';'Hash']
  vivify_2369:
    set $P5591, $P5590["parameter"]
    unless_null $P5591, vivify_2370
    new $P5591, "Undef"
  vivify_2370:
    defined $I5592, $P5591
    unless $I5592, for_undef_2371
    iter $P5589, $P5591
    new $P5602, 'ExceptionHandler'
    set_label $P5602, loop5601_handler
    $P5602."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5602
  loop5601_test:
    unless $P5589, loop5601_done
    shift $P5593, $P5589
  loop5601_redo:
    .const 'Sub' $P5595 = "517_1303857440.612" 
    capture_lex $P5595
    $P5595($P5593)
  loop5601_next:
    goto loop5601_test
  loop5601_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5603, exception, 'type'
    eq $P5603, .CONTROL_LOOP_NEXT, loop5601_next
    eq $P5603, .CONTROL_LOOP_REDO, loop5601_redo
  loop5601_done:
    pop_eh 
  for_undef_2371:
.annotate 'line', 1638
    .return ($P5589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5562"  :anon :subid("516_1303857440.612") :outer("515_1303857440.612")
.annotate 'line', 1641
    new $P5564, "Undef"
    .lex "$inv", $P5564
    find_lex $P5565, "$/"
    unless_null $P5565, vivify_2360
    $P5565 = root_new ['parrot';'Hash']
  vivify_2360:
    set $P5566, $P5565["invocant"]
    unless_null $P5566, vivify_2361
    $P5566 = root_new ['parrot';'ResizablePMCArray']
  vivify_2361:
    set $P5567, $P5566[0]
    unless_null $P5567, vivify_2362
    new $P5567, "Undef"
  vivify_2362:
    $P5568 = $P5567."ast"()
    store_lex "$inv", $P5568
.annotate 'line', 1642
    find_lex $P5569, "$BLOCKINIT"
    unless_null $P5569, vivify_2363
    new $P5569, "Undef"
  vivify_2363:
    find_lex $P5570, "$inv"
    unless_null $P5570, vivify_2364
    new $P5570, "Undef"
  vivify_2364:
    $P5569."push"($P5570)
.annotate 'line', 1643
    find_lex $P5571, "$BLOCKINIT"
    unless_null $P5571, vivify_2365
    new $P5571, "Undef"
  vivify_2365:
    get_hll_global $P5572, "GLOBAL"
    nqp_get_package_through_who $P5573, $P5572, "PAST"
    get_who $P5574, $P5573
    set $P5575, $P5574["Var"]
.annotate 'line', 1645
    get_hll_global $P5576, "GLOBAL"
    nqp_get_package_through_who $P5577, $P5576, "PAST"
    get_who $P5578, $P5577
    set $P5579, $P5578["Var"]
    find_lex $P5580, "$inv"
    unless_null $P5580, vivify_2366
    new $P5580, "Undef"
  vivify_2366:
    $P5581 = $P5580."name"()
    $P5582 = $P5579."new"("lexical" :named("scope"), $P5581 :named("name"))
    $P5583 = $P5575."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5582 :named("viviself"))
.annotate 'line', 1643
    $P5571."push"($P5583)
.annotate 'line', 1647
    new $P5584, "Integer"
    assign $P5584, 1
    find_lex $P5585, "$?PACKAGE"
    get_who $P5586, $P5585
    set $P5587, $P5586["@BLOCK"]
    unless_null $P5587, vivify_2367
    $P5587 = root_new ['parrot';'ResizablePMCArray']
    set $P5586["@BLOCK"], $P5587
  vivify_2367:
    set $P5588, $P5587[0]
    unless_null $P5588, vivify_2368
    $P5588 = root_new ['parrot';'Hash']
    set $P5587[0], $P5588
  vivify_2368:
    set $P5588["signature_has_invocant"], $P5584
.annotate 'line', 1640
    .return ($P5584)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5594"  :anon :subid("517_1303857440.612") :outer("515_1303857440.612")
    .param pmc param_5596
.annotate 'line', 1649
    .lex "$_", param_5596
    find_lex $P5597, "$BLOCKINIT"
    unless_null $P5597, vivify_2372
    new $P5597, "Undef"
  vivify_2372:
    find_lex $P5598, "$_"
    unless_null $P5598, vivify_2373
    new $P5598, "Undef"
  vivify_2373:
    $P5599 = $P5598."ast"()
    $P5600 = $P5597."push"($P5599)
    .return ($P5600)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("518_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5605
    .param pmc param_5606
.annotate 'line', 1652
    .lex "self", param_5605
    .lex "$/", param_5606
.annotate 'line', 1653
    new $P5607, "Undef"
    .lex "$quant", $P5607
.annotate 'line', 1654
    new $P5608, "Undef"
    .lex "$past", $P5608
.annotate 'line', 1653
    find_lex $P5609, "$/"
    unless_null $P5609, vivify_2374
    $P5609 = root_new ['parrot';'Hash']
  vivify_2374:
    set $P5610, $P5609["quant"]
    unless_null $P5610, vivify_2375
    new $P5610, "Undef"
  vivify_2375:
    store_lex "$quant", $P5610
    find_lex $P5611, "$past"
    unless_null $P5611, vivify_2376
    new $P5611, "Undef"
  vivify_2376:
.annotate 'line', 1655
    find_lex $P5613, "$/"
    unless_null $P5613, vivify_2377
    $P5613 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P5614, $P5613["named_param"]
    unless_null $P5614, vivify_2378
    new $P5614, "Undef"
  vivify_2378:
    if $P5614, if_5612
.annotate 'line', 1662
    find_lex $P5628, "$/"
    unless_null $P5628, vivify_2379
    $P5628 = root_new ['parrot';'Hash']
  vivify_2379:
    set $P5629, $P5628["param_var"]
    unless_null $P5629, vivify_2380
    new $P5629, "Undef"
  vivify_2380:
    $P5630 = $P5629."ast"()
    store_lex "$past", $P5630
.annotate 'line', 1663
    find_lex $P5632, "$quant"
    unless_null $P5632, vivify_2381
    new $P5632, "Undef"
  vivify_2381:
    set $S5633, $P5632
    iseq $I5634, $S5633, "*"
    if $I5634, if_5631
.annotate 'line', 1667
    find_lex $P5643, "$quant"
    unless_null $P5643, vivify_2382
    new $P5643, "Undef"
  vivify_2382:
    set $S5644, $P5643
    iseq $I5645, $S5644, "?"
    unless $I5645, if_5642_end
.annotate 'line', 1668
    find_lex $P5646, "$past"
    unless_null $P5646, vivify_2383
    new $P5646, "Undef"
  vivify_2383:
    find_lex $P5647, "$/"
    unless_null $P5647, vivify_2384
    $P5647 = root_new ['parrot';'Hash']
  vivify_2384:
    set $P5648, $P5647["param_var"]
    unless_null $P5648, vivify_2385
    $P5648 = root_new ['parrot';'Hash']
  vivify_2385:
    set $P5649, $P5648["sigil"]
    unless_null $P5649, vivify_2386
    new $P5649, "Undef"
  vivify_2386:
    $P5650 = "vivitype"($P5649)
    $P5646."viviself"($P5650)
  if_5642_end:
.annotate 'line', 1667
    goto if_5631_end
  if_5631:
.annotate 'line', 1664
    find_lex $P5635, "$past"
    unless_null $P5635, vivify_2387
    new $P5635, "Undef"
  vivify_2387:
    $P5635."slurpy"(1)
.annotate 'line', 1665
    find_lex $P5636, "$past"
    unless_null $P5636, vivify_2388
    new $P5636, "Undef"
  vivify_2388:
    find_lex $P5637, "$/"
    unless_null $P5637, vivify_2389
    $P5637 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P5638, $P5637["param_var"]
    unless_null $P5638, vivify_2390
    $P5638 = root_new ['parrot';'Hash']
  vivify_2390:
    set $P5639, $P5638["sigil"]
    unless_null $P5639, vivify_2391
    new $P5639, "Undef"
  vivify_2391:
    set $S5640, $P5639
    iseq $I5641, $S5640, "%"
    $P5636."named"($I5641)
  if_5631_end:
.annotate 'line', 1661
    goto if_5612_end
  if_5612:
.annotate 'line', 1656
    find_lex $P5615, "$/"
    unless_null $P5615, vivify_2392
    $P5615 = root_new ['parrot';'Hash']
  vivify_2392:
    set $P5616, $P5615["named_param"]
    unless_null $P5616, vivify_2393
    new $P5616, "Undef"
  vivify_2393:
    $P5617 = $P5616."ast"()
    store_lex "$past", $P5617
.annotate 'line', 1657
    find_lex $P5619, "$quant"
    unless_null $P5619, vivify_2394
    new $P5619, "Undef"
  vivify_2394:
    set $S5620, $P5619
    isne $I5621, $S5620, "!"
    unless $I5621, if_5618_end
.annotate 'line', 1658
    find_lex $P5622, "$past"
    unless_null $P5622, vivify_2395
    new $P5622, "Undef"
  vivify_2395:
    find_lex $P5623, "$/"
    unless_null $P5623, vivify_2396
    $P5623 = root_new ['parrot';'Hash']
  vivify_2396:
    set $P5624, $P5623["named_param"]
    unless_null $P5624, vivify_2397
    $P5624 = root_new ['parrot';'Hash']
  vivify_2397:
    set $P5625, $P5624["param_var"]
    unless_null $P5625, vivify_2398
    $P5625 = root_new ['parrot';'Hash']
  vivify_2398:
    set $P5626, $P5625["sigil"]
    unless_null $P5626, vivify_2399
    new $P5626, "Undef"
  vivify_2399:
    $P5627 = "vivitype"($P5626)
    $P5622."viviself"($P5627)
  if_5618_end:
  if_5612_end:
.annotate 'line', 1671
    find_lex $P5652, "$/"
    unless_null $P5652, vivify_2400
    $P5652 = root_new ['parrot';'Hash']
  vivify_2400:
    set $P5653, $P5652["default_value"]
    unless_null $P5653, vivify_2401
    new $P5653, "Undef"
  vivify_2401:
    unless $P5653, if_5651_end
.annotate 'line', 1672
    find_lex $P5655, "$quant"
    unless_null $P5655, vivify_2402
    new $P5655, "Undef"
  vivify_2402:
    set $S5656, $P5655
    iseq $I5657, $S5656, "*"
    unless $I5657, if_5654_end
.annotate 'line', 1673
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2403
    new $P5658, "Undef"
  vivify_2403:
    $P5659 = $P5658."CURSOR"()
    $P5659."panic"("Can't put default on slurpy parameter")
  if_5654_end:
.annotate 'line', 1675
    find_lex $P5661, "$quant"
    unless_null $P5661, vivify_2404
    new $P5661, "Undef"
  vivify_2404:
    set $S5662, $P5661
    iseq $I5663, $S5662, "!"
    unless $I5663, if_5660_end
.annotate 'line', 1676
    find_lex $P5664, "$/"
    unless_null $P5664, vivify_2405
    new $P5664, "Undef"
  vivify_2405:
    $P5665 = $P5664."CURSOR"()
    $P5665."panic"("Can't put default on required parameter")
  if_5660_end:
.annotate 'line', 1678
    find_lex $P5666, "$past"
    unless_null $P5666, vivify_2406
    new $P5666, "Undef"
  vivify_2406:
    find_lex $P5667, "$/"
    unless_null $P5667, vivify_2407
    $P5667 = root_new ['parrot';'Hash']
  vivify_2407:
    set $P5668, $P5667["default_value"]
    unless_null $P5668, vivify_2408
    $P5668 = root_new ['parrot';'ResizablePMCArray']
  vivify_2408:
    set $P5669, $P5668[0]
    unless_null $P5669, vivify_2409
    $P5669 = root_new ['parrot';'Hash']
  vivify_2409:
    set $P5670, $P5669["EXPR"]
    unless_null $P5670, vivify_2410
    new $P5670, "Undef"
  vivify_2410:
    $P5671 = $P5670."ast"()
    $P5666."viviself"($P5671)
  if_5651_end:
.annotate 'line', 1680
    find_lex $P5673, "$past"
    unless_null $P5673, vivify_2411
    new $P5673, "Undef"
  vivify_2411:
    $P5674 = $P5673."viviself"()
    if $P5674, unless_5672_end
    find_lex $P5675, "$?PACKAGE"
    get_who $P5676, $P5675
    set $P5677, $P5676["@BLOCK"]
    unless_null $P5677, vivify_2412
    $P5677 = root_new ['parrot';'ResizablePMCArray']
  vivify_2412:
    set $P5678, $P5677[0]
    unless_null $P5678, vivify_2413
    new $P5678, "Undef"
  vivify_2413:
    find_lex $P5679, "$?PACKAGE"
    get_who $P5680, $P5679
    set $P5681, $P5680["@BLOCK"]
    unless_null $P5681, vivify_2414
    $P5681 = root_new ['parrot';'ResizablePMCArray']
  vivify_2414:
    set $P5682, $P5681[0]
    unless_null $P5682, vivify_2415
    new $P5682, "Undef"
  vivify_2415:
    $P5683 = $P5682."arity"()
    set $N5684, $P5683
    new $P5685, 'Float'
    set $P5685, $N5684
    add $P5686, $P5685, 1
    $P5678."arity"($P5686)
  unless_5672_end:
.annotate 'line', 1684
    find_lex $P5688, "$/"
    unless_null $P5688, vivify_2416
    $P5688 = root_new ['parrot';'Hash']
  vivify_2416:
    set $P5689, $P5688["typename"]
    unless_null $P5689, vivify_2417
    new $P5689, "Undef"
  vivify_2417:
    unless $P5689, if_5687_end
.annotate 'line', 1685
    find_lex $P5690, "$past"
    unless_null $P5690, vivify_2418
    new $P5690, "Undef"
  vivify_2418:
    find_lex $P5691, "$/"
    unless_null $P5691, vivify_2419
    $P5691 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P5692, $P5691["typename"]
    unless_null $P5692, vivify_2420
    $P5692 = root_new ['parrot';'ResizablePMCArray']
  vivify_2420:
    set $P5693, $P5692[0]
    unless_null $P5693, vivify_2421
    new $P5693, "Undef"
  vivify_2421:
    $P5694 = $P5693."ast"()
    $P5690."multitype"($P5694)
  if_5687_end:
.annotate 'line', 1689
    find_lex $P5696, "$/"
    unless_null $P5696, vivify_2422
    $P5696 = root_new ['parrot';'Hash']
  vivify_2422:
    set $P5697, $P5696["definedness"]
    unless_null $P5697, vivify_2423
    new $P5697, "Undef"
  vivify_2423:
    unless $P5697, if_5695_end
.annotate 'line', 1690
    find_lex $P5698, "$/"
    unless_null $P5698, vivify_2424
    $P5698 = root_new ['parrot';'Hash']
  vivify_2424:
    set $P5699, $P5698["definedness"]
    unless_null $P5699, vivify_2425
    $P5699 = root_new ['parrot';'ResizablePMCArray']
  vivify_2425:
    set $P5700, $P5699[0]
    unless_null $P5700, vivify_2426
    new $P5700, "Undef"
  vivify_2426:
    set $S5701, $P5700
    new $P5702, 'String'
    set $P5702, $S5701
    find_lex $P5703, "$past"
    unless_null $P5703, vivify_2427
    $P5703 = root_new ['parrot';'Hash']
    store_lex "$past", $P5703
  vivify_2427:
    set $P5703["definedness"], $P5702
  if_5695_end:
.annotate 'line', 1693
    find_lex $P5704, "$/"
    find_lex $P5705, "$past"
    unless_null $P5705, vivify_2428
    new $P5705, "Undef"
  vivify_2428:
    $P5706 = $P5704."!make"($P5705)
.annotate 'line', 1652
    .return ($P5706)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("519_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5708
    .param pmc param_5709
.annotate 'line', 1696
    .lex "self", param_5708
    .lex "$/", param_5709
.annotate 'line', 1697
    new $P5710, "Undef"
    .lex "$name", $P5710
.annotate 'line', 1698
    new $P5711, "Undef"
    .lex "$past", $P5711
.annotate 'line', 1697
    find_lex $P5712, "$/"
    unless_null $P5712, vivify_2429
    new $P5712, "Undef"
  vivify_2429:
    set $S5713, $P5712
    new $P5714, 'String'
    set $P5714, $S5713
    store_lex "$name", $P5714
.annotate 'line', 1698
    get_hll_global $P5715, "GLOBAL"
    nqp_get_package_through_who $P5716, $P5715, "PAST"
    get_who $P5717, $P5716
    set $P5718, $P5717["Var"]
    find_lex $P5719, "$name"
    unless_null $P5719, vivify_2430
    new $P5719, "Undef"
  vivify_2430:
    find_lex $P5720, "$/"
    unless_null $P5720, vivify_2431
    new $P5720, "Undef"
  vivify_2431:
    $P5721 = $P5718."new"($P5719 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5720 :named("node"))
    store_lex "$past", $P5721
.annotate 'line', 1700
    find_lex $P5722, "$?PACKAGE"
    get_who $P5723, $P5722
    set $P5724, $P5723["@BLOCK"]
    unless_null $P5724, vivify_2432
    $P5724 = root_new ['parrot';'ResizablePMCArray']
  vivify_2432:
    set $P5725, $P5724[0]
    unless_null $P5725, vivify_2433
    new $P5725, "Undef"
  vivify_2433:
    find_lex $P5726, "$name"
    unless_null $P5726, vivify_2434
    new $P5726, "Undef"
  vivify_2434:
    $P5725."symbol"($P5726, "lexical" :named("scope"))
.annotate 'line', 1701
    find_lex $P5727, "$/"
    find_lex $P5728, "$past"
    unless_null $P5728, vivify_2435
    new $P5728, "Undef"
  vivify_2435:
    $P5729 = $P5727."!make"($P5728)
.annotate 'line', 1696
    .return ($P5729)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("520_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5731
    .param pmc param_5732
.annotate 'line', 1704
    .lex "self", param_5731
    .lex "$/", param_5732
.annotate 'line', 1705
    new $P5733, "Undef"
    .lex "$past", $P5733
    find_lex $P5734, "$/"
    unless_null $P5734, vivify_2436
    $P5734 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P5735, $P5734["param_var"]
    unless_null $P5735, vivify_2437
    new $P5735, "Undef"
  vivify_2437:
    $P5736 = $P5735."ast"()
    store_lex "$past", $P5736
.annotate 'line', 1706
    find_lex $P5737, "$past"
    unless_null $P5737, vivify_2438
    new $P5737, "Undef"
  vivify_2438:
    find_lex $P5738, "$/"
    unless_null $P5738, vivify_2439
    $P5738 = root_new ['parrot';'Hash']
  vivify_2439:
    set $P5739, $P5738["param_var"]
    unless_null $P5739, vivify_2440
    $P5739 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P5740, $P5739["name"]
    unless_null $P5740, vivify_2441
    new $P5740, "Undef"
  vivify_2441:
    set $S5741, $P5740
    $P5737."named"($S5741)
.annotate 'line', 1707
    find_lex $P5742, "$/"
    find_lex $P5743, "$past"
    unless_null $P5743, vivify_2442
    new $P5743, "Undef"
  vivify_2442:
    $P5744 = $P5742."!make"($P5743)
.annotate 'line', 1704
    .return ($P5744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("521_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5746
    .param pmc param_5747
.annotate 'line', 1710
    .lex "self", param_5746
    .lex "$/", param_5747
.annotate 'line', 1711
    $P5748 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5748
    get_hll_global $P5749, "GLOBAL"
    nqp_get_package_through_who $P5750, $P5749, "HLL"
    get_who $P5751, $P5750
    set $P5752, $P5751["Compiler"]
    find_lex $P5753, "$/"
    unless_null $P5753, vivify_2443
    new $P5753, "Undef"
  vivify_2443:
    set $S5754, $P5753
    $P5755 = $P5752."parse_name"($S5754)
    store_lex "@name", $P5755
.annotate 'line', 1712
    find_lex $P5756, "$/"
    find_lex $P5757, "@name"
    unless_null $P5757, vivify_2444
    $P5757 = root_new ['parrot';'ResizablePMCArray']
  vivify_2444:
    find_lex $P5758, "$/"
    unless_null $P5758, vivify_2445
    new $P5758, "Undef"
  vivify_2445:
    $P5759 = "lexical_package_lookup"($P5757, $P5758)
    $P5760 = $P5756."!make"($P5759)
.annotate 'line', 1710
    .return ($P5760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("522_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5762
    .param pmc param_5763
.annotate 'line', 1715
    .lex "self", param_5762
    .lex "$/", param_5763
.annotate 'line', 1716
    find_lex $P5764, "$/"
    find_lex $P5765, "$/"
    unless_null $P5765, vivify_2446
    $P5765 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P5766, $P5765["trait_mod"]
    unless_null $P5766, vivify_2447
    new $P5766, "Undef"
  vivify_2447:
    $P5767 = $P5766."ast"()
    $P5768 = $P5764."!make"($P5767)
.annotate 'line', 1715
    .return ($P5768)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("523_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5770
    .param pmc param_5771
.annotate 'line', 1719
    .const 'Sub' $P5794 = "524_1303857440.612" 
    capture_lex $P5794
    .lex "self", param_5770
    .lex "$/", param_5771
.annotate 'line', 1720
    new $P5772, "Undef"
    .lex "$cpast", $P5772
    find_lex $P5773, "$/"
    unless_null $P5773, vivify_2448
    $P5773 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P5774, $P5773["circumfix"]
    unless_null $P5774, vivify_2449
    $P5774 = root_new ['parrot';'ResizablePMCArray']
  vivify_2449:
    set $P5775, $P5774[0]
    unless_null $P5775, vivify_2450
    new $P5775, "Undef"
  vivify_2450:
    $P5776 = $P5775."ast"()
    store_lex "$cpast", $P5776
.annotate 'line', 1721
    find_lex $P5779, "$/"
    unless_null $P5779, vivify_2451
    $P5779 = root_new ['parrot';'Hash']
  vivify_2451:
    set $P5780, $P5779["longname"]
    unless_null $P5780, vivify_2452
    new $P5780, "Undef"
  vivify_2452:
    set $S5781, $P5780
    iseq $I5782, $S5781, "parrot_vtable"
    if $I5782, if_5778
.annotate 'line', 1741
    find_lex $P5836, "$/"
    unless_null $P5836, vivify_2453
    $P5836 = root_new ['parrot';'Hash']
  vivify_2453:
    set $P5837, $P5836["longname"]
    unless_null $P5837, vivify_2454
    new $P5837, "Undef"
  vivify_2454:
    set $S5838, $P5837
    iseq $I5839, $S5838, "pirflags"
    if $I5839, if_5835
.annotate 'line', 1745
    find_lex $P5843, "$/"
    unless_null $P5843, vivify_2455
    new $P5843, "Undef"
  vivify_2455:
    $P5844 = $P5843."CURSOR"()
    new $P5845, 'String'
    set $P5845, "Trait '"
    find_lex $P5846, "$/"
    unless_null $P5846, vivify_2456
    $P5846 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P5847, $P5846["longname"]
    unless_null $P5847, vivify_2457
    new $P5847, "Undef"
  vivify_2457:
    concat $P5848, $P5845, $P5847
    concat $P5849, $P5848, "' not implemented"
    $P5850 = $P5844."panic"($P5849)
.annotate 'line', 1744
    set $P5834, $P5850
.annotate 'line', 1741
    goto if_5835_end
  if_5835:
.annotate 'line', 1742
    find_lex $P5840, "$/"
    unless_null $P5840, vivify_2458
    new $P5840, "Undef"
  vivify_2458:
    $P5841 = $P5840."CURSOR"()
    $P5842 = $P5841."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1741
    set $P5834, $P5842
  if_5835_end:
    set $P5777, $P5834
.annotate 'line', 1721
    goto if_5778_end
  if_5778:
.annotate 'line', 1724
    get_hll_global $P5784, "GLOBAL"
    nqp_get_package_through_who $P5785, $P5784, "PAST"
    get_who $P5786, $P5785
    set $P5787, $P5786["Val"]
    find_lex $P5788, "$cpast"
    unless_null $P5788, vivify_2459
    new $P5788, "Undef"
  vivify_2459:
    $P5789 = $P5787."ACCEPTS"($P5788)
    if $P5789, unless_5783_end
.annotate 'line', 1723
    find_lex $P5790, "$/"
    unless_null $P5790, vivify_2460
    new $P5790, "Undef"
  vivify_2460:
    $P5791 = $P5790."CURSOR"()
    $P5791."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5783_end:
.annotate 'line', 1725
    find_lex $P5792, "$/"
    .const 'Sub' $P5794 = "524_1303857440.612" 
    newclosure $P5832, $P5794
    $P5833 = $P5792."!make"($P5832)
.annotate 'line', 1721
    set $P5777, $P5833
  if_5778_end:
.annotate 'line', 1719
    .return ($P5777)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5793"  :anon :subid("524_1303857440.612") :outer("523_1303857440.612")
    .param pmc param_5795
.annotate 'line', 1725
    .lex "$match", param_5795
.annotate 'line', 1726
    new $P5796, "Undef"
    .lex "$meth", $P5796
    find_lex $P5797, "$match"
    unless_null $P5797, vivify_2461
    new $P5797, "Undef"
  vivify_2461:
    $P5798 = $P5797."ast"()
    set $P5799, $P5798["block_past"]
    unless_null $P5799, vivify_2462
    new $P5799, "Undef"
  vivify_2462:
    store_lex "$meth", $P5799
.annotate 'line', 1727
    find_dynamic_lex $P5804, "$*PACKAGE-SETUP"
    unless_null $P5804, vivify_2463
    get_hll_global $P5802, "GLOBAL"
    get_who $P5803, $P5802
    set $P5804, $P5803["$PACKAGE-SETUP"]
    unless_null $P5804, vivify_2464
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2464:
  vivify_2463:
    defined $I5805, $P5804
    if $I5805, if_5801
    new $P5800, 'Integer'
    set $P5800, $I5805
    goto if_5801_end
  if_5801:
.annotate 'line', 1728
    find_dynamic_lex $P5808, "$*PACKAGE-SETUP"
    unless_null $P5808, vivify_2465
    get_hll_global $P5806, "GLOBAL"
    get_who $P5807, $P5806
    set $P5808, $P5807["$PACKAGE-SETUP"]
    unless_null $P5808, vivify_2466
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2466:
  vivify_2465:
    get_hll_global $P5809, "GLOBAL"
    nqp_get_package_through_who $P5810, $P5809, "PAST"
    get_who $P5811, $P5810
    set $P5812, $P5811["Op"]
.annotate 'line', 1730
    get_hll_global $P5813, "GLOBAL"
    nqp_get_package_through_who $P5814, $P5813, "PAST"
    get_who $P5815, $P5814
    set $P5816, $P5815["Op"]
.annotate 'line', 1733
    get_hll_global $P5817, "GLOBAL"
    nqp_get_package_through_who $P5818, $P5817, "PAST"
    get_who $P5819, $P5818
    set $P5820, $P5819["Var"]
    $P5821 = $P5820."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5822 = $P5816."new"($P5821, "get_how PP" :named("pirop"))
.annotate 'line', 1735
    get_hll_global $P5823, "GLOBAL"
    nqp_get_package_through_who $P5824, $P5823, "PAST"
    get_who $P5825, $P5824
    set $P5826, $P5825["Var"]
    $P5827 = $P5826."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P5828, "$cpast"
    unless_null $P5828, vivify_2467
    new $P5828, "Undef"
  vivify_2467:
    find_lex $P5829, "$meth"
    unless_null $P5829, vivify_2468
    new $P5829, "Undef"
  vivify_2468:
    $P5830 = $P5812."new"($P5822, $P5827, $P5828, $P5829, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1728
    $P5831 = $P5808."push"($P5830)
.annotate 'line', 1727
    set $P5800, $P5831
  if_5801_end:
.annotate 'line', 1725
    .return ($P5800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("525_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_5854
    .param pmc param_5855
    .param pmc param_5856 :optional
    .param int has_param_5856 :opt_flag
.annotate 'line', 1749
    .const 'Sub' $P6010 = "528_1303857440.612" 
    capture_lex $P6010
    .const 'Sub' $P5972 = "527_1303857440.612" 
    capture_lex $P5972
    .const 'Sub' $P5925 = "526_1303857440.612" 
    capture_lex $P5925
    new $P5853, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5853, control_5852
    push_eh $P5853
    .lex "self", param_5854
    .lex "$/", param_5855
    if has_param_5856, optparam_2469
    new $P5857, "Undef"
    set param_5856, $P5857
  optparam_2469:
    .lex "$key", param_5856
.annotate 'line', 1750
    $P5858 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5858
.annotate 'line', 1751
    new $P5859, "Undef"
    .lex "$name", $P5859
.annotate 'line', 1752
    new $P5860, "Undef"
    .lex "$past", $P5860
.annotate 'line', 1750
    get_hll_global $P5861, "GLOBAL"
    nqp_get_package_through_who $P5862, $P5861, "Regex"
    nqp_get_package_through_who $P5863, $P5862, "P6Regex"
    nqp_get_package_through_who $P5864, $P5863, "Actions"
    get_who $P5865, $P5864
    set $P5866, $P5865["@MODIFIERS"]
    unless_null $P5866, vivify_2470
    $P5866 = root_new ['parrot';'ResizablePMCArray']
  vivify_2470:
    store_lex "@MODIFIERS", $P5866
.annotate 'line', 1751
    find_lex $P5867, "$/"
    unless_null $P5867, vivify_2471
    $P5867 = root_new ['parrot';'Hash']
  vivify_2471:
    set $P5868, $P5867["deflongname"]
    unless_null $P5868, vivify_2472
    new $P5868, "Undef"
  vivify_2472:
    $P5869 = $P5868."ast"()
    set $S5870, $P5869
    new $P5871, 'String'
    set $P5871, $S5870
    store_lex "$name", $P5871
    find_lex $P5872, "$past"
    unless_null $P5872, vivify_2473
    new $P5872, "Undef"
  vivify_2473:
.annotate 'line', 1753
    find_lex $P5874, "$/"
    unless_null $P5874, vivify_2474
    $P5874 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P5875, $P5874["proto"]
    unless_null $P5875, vivify_2475
    new $P5875, "Undef"
  vivify_2475:
    if $P5875, if_5873
.annotate 'line', 1792
    find_lex $P5968, "$key"
    unless_null $P5968, vivify_2476
    new $P5968, "Undef"
  vivify_2476:
    set $S5969, $P5968
    iseq $I5970, $S5969, "open"
    if $I5970, if_5967
.annotate 'line', 1802
    .const 'Sub' $P6010 = "528_1303857440.612" 
    capture_lex $P6010
    $P6010()
    goto if_5967_end
  if_5967:
.annotate 'line', 1792
    .const 'Sub' $P5972 = "527_1303857440.612" 
    capture_lex $P5972
    $P5972()
  if_5967_end:
    goto if_5873_end
  if_5873:
.annotate 'line', 1755
    get_hll_global $P5876, "GLOBAL"
    nqp_get_package_through_who $P5877, $P5876, "PAST"
    get_who $P5878, $P5877
    set $P5879, $P5878["Stmts"]
.annotate 'line', 1756
    get_hll_global $P5880, "GLOBAL"
    nqp_get_package_through_who $P5881, $P5880, "PAST"
    get_who $P5882, $P5881
    set $P5883, $P5882["Block"]
    find_lex $P5884, "$name"
    unless_null $P5884, vivify_2511
    new $P5884, "Undef"
  vivify_2511:
.annotate 'line', 1757
    get_hll_global $P5885, "GLOBAL"
    nqp_get_package_through_who $P5886, $P5885, "PAST"
    get_who $P5887, $P5886
    set $P5888, $P5887["Op"]
.annotate 'line', 1758
    get_hll_global $P5889, "GLOBAL"
    nqp_get_package_through_who $P5890, $P5889, "PAST"
    get_who $P5891, $P5890
    set $P5892, $P5891["Var"]
    $P5893 = $P5892."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5894, "$name"
    unless_null $P5894, vivify_2512
    new $P5894, "Undef"
  vivify_2512:
    $P5895 = $P5888."new"($P5893, $P5894, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1757
    find_lex $P5896, "$/"
    unless_null $P5896, vivify_2513
    new $P5896, "Undef"
  vivify_2513:
    $P5897 = $P5883."new"($P5895, $P5884 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5896 :named("node"))
.annotate 'line', 1767
    get_hll_global $P5898, "GLOBAL"
    nqp_get_package_through_who $P5899, $P5898, "PAST"
    get_who $P5900, $P5899
    set $P5901, $P5900["Block"]
    new $P5902, "String"
    assign $P5902, "!PREFIX__"
    find_lex $P5903, "$name"
    unless_null $P5903, vivify_2514
    new $P5903, "Undef"
  vivify_2514:
    concat $P5904, $P5902, $P5903
.annotate 'line', 1768
    get_hll_global $P5905, "GLOBAL"
    nqp_get_package_through_who $P5906, $P5905, "PAST"
    get_who $P5907, $P5906
    set $P5908, $P5907["Op"]
.annotate 'line', 1769
    get_hll_global $P5909, "GLOBAL"
    nqp_get_package_through_who $P5910, $P5909, "PAST"
    get_who $P5911, $P5910
    set $P5912, $P5911["Var"]
    $P5913 = $P5912."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5914, "$name"
    unless_null $P5914, vivify_2515
    new $P5914, "Undef"
  vivify_2515:
    $P5915 = $P5908."new"($P5913, $P5914, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1768
    find_lex $P5916, "$/"
    unless_null $P5916, vivify_2516
    new $P5916, "Undef"
  vivify_2516:
    $P5917 = $P5901."new"($P5915, $P5904 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5916 :named("node"))
.annotate 'line', 1767
    $P5918 = $P5879."new"($P5897, $P5917)
.annotate 'line', 1755
    store_lex "$past", $P5918
.annotate 'line', 1779
    find_lex $P5920, "$past"
    unless_null $P5920, vivify_2517
    new $P5920, "Undef"
  vivify_2517:
    $P5921 = $P5920."list"()
    defined $I5922, $P5921
    unless $I5922, for_undef_2518
    iter $P5919, $P5921
    new $P5965, 'ExceptionHandler'
    set_label $P5965, loop5964_handler
    $P5965."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5965
  loop5964_test:
    unless $P5919, loop5964_done
    shift $P5923, $P5919
  loop5964_redo:
    .const 'Sub' $P5925 = "526_1303857440.612" 
    capture_lex $P5925
    $P5925($P5923)
  loop5964_next:
    goto loop5964_test
  loop5964_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5966, exception, 'type'
    eq $P5966, .CONTROL_LOOP_NEXT, loop5964_next
    eq $P5966, .CONTROL_LOOP_REDO, loop5964_redo
  loop5964_done:
    pop_eh 
  for_undef_2518:
  if_5873_end:
.annotate 'line', 1838
    find_lex $P6123, "$/"
    find_lex $P6124, "$past"
    unless_null $P6124, vivify_2523
    new $P6124, "Undef"
  vivify_2523:
    $P6125 = $P6123."!make"($P6124)
.annotate 'line', 1749
    .return ($P6125)
  control_5852:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6126, exception, "payload"
    .return ($P6126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6009"  :anon :subid("528_1303857440.612") :outer("525_1303857440.612")
.annotate 'line', 1803
    new $P6011, "Undef"
    .lex "$regex", $P6011
.annotate 'line', 1804
    get_hll_global $P6012, "GLOBAL"
    nqp_get_package_through_who $P6013, $P6012, "Regex"
    nqp_get_package_through_who $P6014, $P6013, "P6Regex"
    nqp_get_package_through_who $P6015, $P6014, "Actions"
    get_who $P6016, $P6015
    set $P6017, $P6016["buildsub"]
    find_lex $P6018, "$/"
    unless_null $P6018, vivify_2477
    $P6018 = root_new ['parrot';'Hash']
  vivify_2477:
    set $P6019, $P6018["p6regex"]
    unless_null $P6019, vivify_2478
    new $P6019, "Undef"
  vivify_2478:
    $P6020 = $P6019."ast"()
    find_lex $P6021, "$?PACKAGE"
    get_who $P6022, $P6021
    set $P6023, $P6022["@BLOCK"]
    unless_null $P6023, vivify_2479
    $P6023 = root_new ['parrot';'ResizablePMCArray']
  vivify_2479:
    $P6024 = $P6023."shift"()
    $P6025 = $P6017($P6020, $P6024)
    store_lex "$regex", $P6025
.annotate 'line', 1805
    find_lex $P6026, "$regex"
    unless_null $P6026, vivify_2480
    new $P6026, "Undef"
  vivify_2480:
    find_lex $P6027, "$name"
    unless_null $P6027, vivify_2481
    new $P6027, "Undef"
  vivify_2481:
    $P6026."name"($P6027)
.annotate 'line', 1807
    get_hll_global $P6028, "GLOBAL"
    nqp_get_package_through_who $P6029, $P6028, "PAST"
    get_who $P6030, $P6029
    set $P6031, $P6030["Op"]
.annotate 'line', 1809
    get_hll_global $P6032, "GLOBAL"
    nqp_get_package_through_who $P6033, $P6032, "PAST"
    get_who $P6034, $P6033
    set $P6035, $P6034["Var"]
    new $P6036, "ResizablePMCArray"
    push $P6036, "Regex"
    $P6037 = $P6035."new"("Method" :named("name"), $P6036 :named("namespace"), "package" :named("scope"))
    find_lex $P6038, "$regex"
    unless_null $P6038, vivify_2482
    new $P6038, "Undef"
  vivify_2482:
    $P6039 = $P6031."new"($P6037, $P6038, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1807
    store_lex "$past", $P6039
.annotate 'line', 1812
    find_dynamic_lex $P6043, "$*PACKAGE-SETUP"
    unless_null $P6043, vivify_2483
    get_hll_global $P6041, "GLOBAL"
    get_who $P6042, $P6041
    set $P6043, $P6042["$PACKAGE-SETUP"]
    unless_null $P6043, vivify_2484
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2484:
  vivify_2483:
    defined $I6044, $P6043
    unless $I6044, if_6040_end
.annotate 'line', 1813
    find_dynamic_lex $P6047, "$*PACKAGE-SETUP"
    unless_null $P6047, vivify_2485
    get_hll_global $P6045, "GLOBAL"
    get_who $P6046, $P6045
    set $P6047, $P6046["$PACKAGE-SETUP"]
    unless_null $P6047, vivify_2486
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2486:
  vivify_2485:
    get_hll_global $P6048, "GLOBAL"
    nqp_get_package_through_who $P6049, $P6048, "PAST"
    get_who $P6050, $P6049
    set $P6051, $P6050["Op"]
.annotate 'line', 1815
    get_hll_global $P6052, "GLOBAL"
    nqp_get_package_through_who $P6053, $P6052, "PAST"
    get_who $P6054, $P6053
    set $P6055, $P6054["Op"]
.annotate 'line', 1817
    get_hll_global $P6056, "GLOBAL"
    nqp_get_package_through_who $P6057, $P6056, "PAST"
    get_who $P6058, $P6057
    set $P6059, $P6058["Var"]
    $P6060 = $P6059."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6061 = $P6055."new"($P6060, "get_how PP" :named("pirop"))
.annotate 'line', 1819
    get_hll_global $P6062, "GLOBAL"
    nqp_get_package_through_who $P6063, $P6062, "PAST"
    get_who $P6064, $P6063
    set $P6065, $P6064["Var"]
    $P6066 = $P6065."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1820
    get_hll_global $P6067, "GLOBAL"
    nqp_get_package_through_who $P6068, $P6067, "PAST"
    get_who $P6069, $P6068
    set $P6070, $P6069["Val"]
    find_lex $P6071, "$name"
    unless_null $P6071, vivify_2487
    new $P6071, "Undef"
  vivify_2487:
    $P6072 = $P6070."new"($P6071 :named("value"))
.annotate 'line', 1821
    get_hll_global $P6073, "GLOBAL"
    nqp_get_package_through_who $P6074, $P6073, "PAST"
    get_who $P6075, $P6074
    set $P6076, $P6075["Val"]
    find_lex $P6077, "$regex"
    unless_null $P6077, vivify_2488
    new $P6077, "Undef"
  vivify_2488:
    $P6078 = $P6076."new"($P6077 :named("value"))
    $P6079 = $P6051."new"($P6061, $P6066, $P6072, $P6078, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1813
    $P6047."push"($P6079)
.annotate 'line', 1823
    find_dynamic_lex $P6082, "$*PACKAGE-SETUP"
    unless_null $P6082, vivify_2489
    get_hll_global $P6080, "GLOBAL"
    get_who $P6081, $P6080
    set $P6082, $P6081["$PACKAGE-SETUP"]
    unless_null $P6082, vivify_2490
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2490:
  vivify_2489:
    get_hll_global $P6083, "GLOBAL"
    nqp_get_package_through_who $P6084, $P6083, "PAST"
    get_who $P6085, $P6084
    set $P6086, $P6085["Op"]
.annotate 'line', 1825
    get_hll_global $P6087, "GLOBAL"
    nqp_get_package_through_who $P6088, $P6087, "PAST"
    get_who $P6089, $P6088
    set $P6090, $P6089["Op"]
.annotate 'line', 1827
    get_hll_global $P6091, "GLOBAL"
    nqp_get_package_through_who $P6092, $P6091, "PAST"
    get_who $P6093, $P6092
    set $P6094, $P6093["Var"]
    $P6095 = $P6094."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6096 = $P6090."new"($P6095, "get_how PP" :named("pirop"))
.annotate 'line', 1829
    get_hll_global $P6097, "GLOBAL"
    nqp_get_package_through_who $P6098, $P6097, "PAST"
    get_who $P6099, $P6098
    set $P6100, $P6099["Var"]
    $P6101 = $P6100."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1830
    get_hll_global $P6102, "GLOBAL"
    nqp_get_package_through_who $P6103, $P6102, "PAST"
    get_who $P6104, $P6103
    set $P6105, $P6104["Val"]
    new $P6106, "String"
    assign $P6106, "!PREFIX__"
    find_lex $P6107, "$name"
    unless_null $P6107, vivify_2491
    new $P6107, "Undef"
  vivify_2491:
    concat $P6108, $P6106, $P6107
    $P6109 = $P6105."new"($P6108 :named("value"))
.annotate 'line', 1831
    get_hll_global $P6110, "GLOBAL"
    nqp_get_package_through_who $P6111, $P6110, "PAST"
    get_who $P6112, $P6111
    set $P6113, $P6112["Var"]
    new $P6114, "String"
    assign $P6114, "!PREFIX__"
    find_lex $P6115, "$name"
    unless_null $P6115, vivify_2492
    new $P6115, "Undef"
  vivify_2492:
    concat $P6116, $P6114, $P6115
    $P6117 = $P6113."new"($P6116 :named("name"), "package" :named("scope"))
    $P6118 = $P6086."new"($P6096, $P6101, $P6109, $P6117, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1823
    $P6082."push"($P6118)
  if_6040_end:
.annotate 'line', 1835
    find_lex $P6119, "$regex"
    unless_null $P6119, vivify_2493
    new $P6119, "Undef"
  vivify_2493:
    find_lex $P6120, "$past"
    unless_null $P6120, vivify_2494
    $P6120 = root_new ['parrot';'Hash']
    store_lex "$past", $P6120
  vivify_2494:
    set $P6120["sink"], $P6119
.annotate 'line', 1836
    find_lex $P6121, "@MODIFIERS"
    unless_null $P6121, vivify_2495
    $P6121 = root_new ['parrot';'ResizablePMCArray']
  vivify_2495:
    $P6122 = $P6121."shift"()
.annotate 'line', 1802
    .return ($P6122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5971"  :anon :subid("527_1303857440.612") :outer("525_1303857440.612")
.annotate 'line', 1793
    $P5973 = root_new ['parrot';'Hash']
    .lex "%h", $P5973
.annotate 'line', 1792
    find_lex $P5974, "%h"
    unless_null $P5974, vivify_2496
    $P5974 = root_new ['parrot';'Hash']
  vivify_2496:
.annotate 'line', 1794
    find_lex $P5976, "$/"
    unless_null $P5976, vivify_2497
    $P5976 = root_new ['parrot';'Hash']
  vivify_2497:
    set $P5977, $P5976["sym"]
    unless_null $P5977, vivify_2498
    new $P5977, "Undef"
  vivify_2498:
    set $S5978, $P5977
    iseq $I5979, $S5978, "token"
    unless $I5979, if_5975_end
    new $P5980, "Integer"
    assign $P5980, 1
    find_lex $P5981, "%h"
    unless_null $P5981, vivify_2499
    $P5981 = root_new ['parrot';'Hash']
    store_lex "%h", $P5981
  vivify_2499:
    set $P5981["r"], $P5980
  if_5975_end:
.annotate 'line', 1795
    find_lex $P5983, "$/"
    unless_null $P5983, vivify_2500
    $P5983 = root_new ['parrot';'Hash']
  vivify_2500:
    set $P5984, $P5983["sym"]
    unless_null $P5984, vivify_2501
    new $P5984, "Undef"
  vivify_2501:
    set $S5985, $P5984
    iseq $I5986, $S5985, "rule"
    unless $I5986, if_5982_end
    new $P5987, "Integer"
    assign $P5987, 1
    find_lex $P5988, "%h"
    unless_null $P5988, vivify_2502
    $P5988 = root_new ['parrot';'Hash']
    store_lex "%h", $P5988
  vivify_2502:
    set $P5988["r"], $P5987
    new $P5989, "Integer"
    assign $P5989, 1
    find_lex $P5990, "%h"
    unless_null $P5990, vivify_2503
    $P5990 = root_new ['parrot';'Hash']
    store_lex "%h", $P5990
  vivify_2503:
    set $P5990["s"], $P5989
  if_5982_end:
.annotate 'line', 1796
    find_lex $P5991, "@MODIFIERS"
    unless_null $P5991, vivify_2504
    $P5991 = root_new ['parrot';'ResizablePMCArray']
  vivify_2504:
    find_lex $P5992, "%h"
    unless_null $P5992, vivify_2505
    $P5992 = root_new ['parrot';'Hash']
  vivify_2505:
    $P5991."unshift"($P5992)
.annotate 'line', 1797
    find_lex $P5993, "$name"
    unless_null $P5993, vivify_2506
    new $P5993, "Undef"
  vivify_2506:
    get_hll_global $P5994, "GLOBAL"
    nqp_get_package_through_who $P5995, $P5994, "Regex"
    nqp_get_package_through_who $P5996, $P5995, "P6Regex"
    nqp_get_package_through_who $P5997, $P5996, "Actions"
    get_who $P5998, $P5997
    set $P5998["$REGEXNAME"], $P5993
.annotate 'line', 1798
    find_lex $P5999, "$?PACKAGE"
    get_who $P6000, $P5999
    set $P6001, $P6000["@BLOCK"]
    unless_null $P6001, vivify_2507
    $P6001 = root_new ['parrot';'ResizablePMCArray']
  vivify_2507:
    set $P6002, $P6001[0]
    unless_null $P6002, vivify_2508
    new $P6002, "Undef"
  vivify_2508:
    $P6002."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1799
    find_lex $P6003, "$?PACKAGE"
    get_who $P6004, $P6003
    set $P6005, $P6004["@BLOCK"]
    unless_null $P6005, vivify_2509
    $P6005 = root_new ['parrot';'ResizablePMCArray']
  vivify_2509:
    set $P6006, $P6005[0]
    unless_null $P6006, vivify_2510
    new $P6006, "Undef"
  vivify_2510:
    $P6006."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1800
    new $P6007, "Exception"
    set $P6007['type'], .CONTROL_RETURN
    new $P6008, "Integer"
    assign $P6008, 0
    setattribute $P6007, 'payload', $P6008
    throw $P6007
.annotate 'line', 1792
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5924"  :anon :subid("526_1303857440.612") :outer("525_1303857440.612")
    .param pmc param_5926
.annotate 'line', 1779
    .lex "$_", param_5926
.annotate 'line', 1780
    find_dynamic_lex $P5929, "$*PACKAGE-SETUP"
    unless_null $P5929, vivify_2519
    get_hll_global $P5927, "GLOBAL"
    get_who $P5928, $P5927
    set $P5929, $P5928["$PACKAGE-SETUP"]
    unless_null $P5929, vivify_2520
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2520:
  vivify_2519:
    get_hll_global $P5930, "GLOBAL"
    nqp_get_package_through_who $P5931, $P5930, "PAST"
    get_who $P5932, $P5931
    set $P5933, $P5932["Op"]
.annotate 'line', 1782
    get_hll_global $P5934, "GLOBAL"
    nqp_get_package_through_who $P5935, $P5934, "PAST"
    get_who $P5936, $P5935
    set $P5937, $P5936["Op"]
.annotate 'line', 1784
    get_hll_global $P5938, "GLOBAL"
    nqp_get_package_through_who $P5939, $P5938, "PAST"
    get_who $P5940, $P5939
    set $P5941, $P5940["Var"]
    $P5942 = $P5941."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5943 = $P5937."new"($P5942, "get_how PP" :named("pirop"))
.annotate 'line', 1786
    get_hll_global $P5944, "GLOBAL"
    nqp_get_package_through_who $P5945, $P5944, "PAST"
    get_who $P5946, $P5945
    set $P5947, $P5946["Var"]
    $P5948 = $P5947."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1787
    get_hll_global $P5949, "GLOBAL"
    nqp_get_package_through_who $P5950, $P5949, "PAST"
    get_who $P5951, $P5950
    set $P5952, $P5951["Val"]
    find_lex $P5953, "$_"
    unless_null $P5953, vivify_2521
    new $P5953, "Undef"
  vivify_2521:
    $P5954 = $P5953."name"()
    $P5955 = $P5952."new"($P5954 :named("value"))
.annotate 'line', 1788
    get_hll_global $P5956, "GLOBAL"
    nqp_get_package_through_who $P5957, $P5956, "PAST"
    get_who $P5958, $P5957
    set $P5959, $P5958["Val"]
    find_lex $P5960, "$_"
    unless_null $P5960, vivify_2522
    new $P5960, "Undef"
  vivify_2522:
    $P5961 = $P5959."new"($P5960 :named("value"))
    $P5962 = $P5933."new"($P5943, $P5948, $P5955, $P5961, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1780
    $P5963 = $P5929."push"($P5962)
.annotate 'line', 1779
    .return ($P5963)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("529_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6128
    .param pmc param_6129
.annotate 'line', 1842
    .lex "self", param_6128
    .lex "$/", param_6129
.annotate 'line', 1843
    new $P6130, "Undef"
    .lex "$past", $P6130
    find_lex $P6133, "$/"
    unless_null $P6133, vivify_2524
    $P6133 = root_new ['parrot';'Hash']
  vivify_2524:
    set $P6134, $P6133["args"]
    unless_null $P6134, vivify_2525
    new $P6134, "Undef"
  vivify_2525:
    if $P6134, if_6132
    get_hll_global $P6139, "GLOBAL"
    nqp_get_package_through_who $P6140, $P6139, "PAST"
    get_who $P6141, $P6140
    set $P6142, $P6141["Op"]
    find_lex $P6143, "$/"
    unless_null $P6143, vivify_2526
    new $P6143, "Undef"
  vivify_2526:
    $P6144 = $P6142."new"($P6143 :named("node"))
    set $P6131, $P6144
    goto if_6132_end
  if_6132:
    find_lex $P6135, "$/"
    unless_null $P6135, vivify_2527
    $P6135 = root_new ['parrot';'Hash']
  vivify_2527:
    set $P6136, $P6135["args"]
    unless_null $P6136, vivify_2528
    $P6136 = root_new ['parrot';'ResizablePMCArray']
  vivify_2528:
    set $P6137, $P6136[0]
    unless_null $P6137, vivify_2529
    new $P6137, "Undef"
  vivify_2529:
    $P6138 = $P6137."ast"()
    set $P6131, $P6138
  if_6132_end:
    store_lex "$past", $P6131
.annotate 'line', 1844
    find_lex $P6146, "$/"
    unless_null $P6146, vivify_2530
    $P6146 = root_new ['parrot';'Hash']
  vivify_2530:
    set $P6147, $P6146["quote"]
    unless_null $P6147, vivify_2531
    new $P6147, "Undef"
  vivify_2531:
    if $P6147, if_6145
.annotate 'line', 1848
    find_lex $P6154, "$/"
    unless_null $P6154, vivify_2532
    $P6154 = root_new ['parrot';'Hash']
  vivify_2532:
    set $P6155, $P6154["longname"]
    unless_null $P6155, vivify_2533
    new $P6155, "Undef"
  vivify_2533:
    set $S6156, $P6155
    iseq $I6157, $S6156, "HOW"
    if $I6157, if_6153
.annotate 'line', 1851
    find_lex $P6160, "$/"
    unless_null $P6160, vivify_2534
    $P6160 = root_new ['parrot';'Hash']
  vivify_2534:
    set $P6161, $P6160["longname"]
    unless_null $P6161, vivify_2535
    new $P6161, "Undef"
  vivify_2535:
    set $S6162, $P6161
    iseq $I6163, $S6162, "WHAT"
    if $I6163, if_6159
.annotate 'line', 1854
    find_lex $P6166, "$/"
    unless_null $P6166, vivify_2536
    $P6166 = root_new ['parrot';'Hash']
  vivify_2536:
    set $P6167, $P6166["longname"]
    unless_null $P6167, vivify_2537
    new $P6167, "Undef"
  vivify_2537:
    set $S6168, $P6167
    iseq $I6169, $S6168, "WHO"
    if $I6169, if_6165
.annotate 'line', 1858
    find_lex $P6171, "$past"
    unless_null $P6171, vivify_2538
    new $P6171, "Undef"
  vivify_2538:
    find_lex $P6172, "$/"
    unless_null $P6172, vivify_2539
    $P6172 = root_new ['parrot';'Hash']
  vivify_2539:
    set $P6173, $P6172["longname"]
    unless_null $P6173, vivify_2540
    new $P6173, "Undef"
  vivify_2540:
    set $S6174, $P6173
    $P6171."name"($S6174)
.annotate 'line', 1859
    find_lex $P6175, "$past"
    unless_null $P6175, vivify_2541
    new $P6175, "Undef"
  vivify_2541:
    $P6175."pasttype"("callmethod")
.annotate 'line', 1857
    goto if_6165_end
  if_6165:
.annotate 'line', 1855
    find_lex $P6170, "$past"
    unless_null $P6170, vivify_2542
    new $P6170, "Undef"
  vivify_2542:
    $P6170."pirop"("get_who PP")
  if_6165_end:
.annotate 'line', 1854
    goto if_6159_end
  if_6159:
.annotate 'line', 1852
    find_lex $P6164, "$past"
    unless_null $P6164, vivify_2543
    new $P6164, "Undef"
  vivify_2543:
    $P6164."pirop"("get_what PP")
  if_6159_end:
.annotate 'line', 1851
    goto if_6153_end
  if_6153:
.annotate 'line', 1849
    find_lex $P6158, "$past"
    unless_null $P6158, vivify_2544
    new $P6158, "Undef"
  vivify_2544:
    $P6158."pirop"("get_how PP")
  if_6153_end:
.annotate 'line', 1848
    goto if_6145_end
  if_6145:
.annotate 'line', 1845
    find_lex $P6148, "$past"
    unless_null $P6148, vivify_2545
    new $P6148, "Undef"
  vivify_2545:
    find_lex $P6149, "$/"
    unless_null $P6149, vivify_2546
    $P6149 = root_new ['parrot';'Hash']
  vivify_2546:
    set $P6150, $P6149["quote"]
    unless_null $P6150, vivify_2547
    new $P6150, "Undef"
  vivify_2547:
    $P6151 = $P6150."ast"()
    $P6148."name"($P6151)
.annotate 'line', 1846
    find_lex $P6152, "$past"
    unless_null $P6152, vivify_2548
    new $P6152, "Undef"
  vivify_2548:
    $P6152."pasttype"("callmethod")
  if_6145_end:
.annotate 'line', 1861
    find_lex $P6176, "$/"
    find_lex $P6177, "$past"
    unless_null $P6177, vivify_2549
    new $P6177, "Undef"
  vivify_2549:
    $P6178 = $P6176."!make"($P6177)
.annotate 'line', 1842
    .return ($P6178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("530_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6180
    .param pmc param_6181
.annotate 'line', 1866
    .lex "self", param_6180
    .lex "$/", param_6181
.annotate 'line', 1867
    find_lex $P6182, "$/"
    get_hll_global $P6183, "GLOBAL"
    nqp_get_package_through_who $P6184, $P6183, "PAST"
    get_who $P6185, $P6184
    set $P6186, $P6185["Var"]
    $P6187 = $P6186."new"("self" :named("name"))
    $P6188 = $P6182."!make"($P6187)
.annotate 'line', 1866
    .return ($P6188)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("531_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6190
    .param pmc param_6191
.annotate 'line', 1870
    .lex "self", param_6190
    .lex "$/", param_6191
.annotate 'line', 1871
    new $P6192, "Undef"
    .lex "$past", $P6192
    find_lex $P6193, "$/"
    unless_null $P6193, vivify_2550
    $P6193 = root_new ['parrot';'Hash']
  vivify_2550:
    set $P6194, $P6193["args"]
    unless_null $P6194, vivify_2551
    new $P6194, "Undef"
  vivify_2551:
    $P6195 = $P6194."ast"()
    store_lex "$past", $P6195
.annotate 'line', 1872
    find_lex $P6196, "$past"
    unless_null $P6196, vivify_2552
    new $P6196, "Undef"
  vivify_2552:
    find_lex $P6197, "$/"
    unless_null $P6197, vivify_2553
    $P6197 = root_new ['parrot';'Hash']
  vivify_2553:
    set $P6198, $P6197["deflongname"]
    unless_null $P6198, vivify_2554
    new $P6198, "Undef"
  vivify_2554:
    set $S6199, $P6198
    $P6196."name"($S6199)
.annotate 'line', 1873
    find_lex $P6200, "$/"
    find_lex $P6201, "$past"
    unless_null $P6201, vivify_2555
    new $P6201, "Undef"
  vivify_2555:
    $P6202 = $P6200."!make"($P6201)
.annotate 'line', 1870
    .return ($P6202)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("532_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6204
    .param pmc param_6205
.annotate 'line', 1876
    .const 'Sub' $P6223 = "533_1303857440.612" 
    capture_lex $P6223
    .lex "self", param_6204
    .lex "$/", param_6205
.annotate 'line', 1878
    new $P6206, "Undef"
    .lex "$var", $P6206
.annotate 'line', 1888
    new $P6207, "Undef"
    .lex "$past", $P6207
.annotate 'line', 1876
    find_lex $P6208, "$var"
    unless_null $P6208, vivify_2556
    new $P6208, "Undef"
  vivify_2556:
.annotate 'line', 1879
    find_lex $P6210, "$/"
    unless_null $P6210, vivify_2557
    $P6210 = root_new ['parrot';'Hash']
  vivify_2557:
    set $P6211, $P6210["name"]
    unless_null $P6211, vivify_2558
    new $P6211, "Undef"
  vivify_2558:
    set $S6212, $P6211
    $P6213 = "is_lexical"($S6212)
    if $P6213, if_6209
.annotate 'line', 1882
    .const 'Sub' $P6223 = "533_1303857440.612" 
    capture_lex $P6223
    $P6223()
    goto if_6209_end
  if_6209:
.annotate 'line', 1880
    get_hll_global $P6214, "GLOBAL"
    nqp_get_package_through_who $P6215, $P6214, "PAST"
    get_who $P6216, $P6215
    set $P6217, $P6216["Var"]
    find_lex $P6218, "$/"
    unless_null $P6218, vivify_2564
    $P6218 = root_new ['parrot';'Hash']
  vivify_2564:
    set $P6219, $P6218["name"]
    unless_null $P6219, vivify_2565
    new $P6219, "Undef"
  vivify_2565:
    set $S6220, $P6219
    $P6221 = $P6217."new"($S6220 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6221
  if_6209_end:
.annotate 'line', 1888
    find_lex $P6232, "$var"
    unless_null $P6232, vivify_2566
    new $P6232, "Undef"
  vivify_2566:
    store_lex "$past", $P6232
.annotate 'line', 1889
    find_lex $P6234, "$/"
    unless_null $P6234, vivify_2567
    $P6234 = root_new ['parrot';'Hash']
  vivify_2567:
    set $P6235, $P6234["args"]
    unless_null $P6235, vivify_2568
    new $P6235, "Undef"
  vivify_2568:
    unless $P6235, if_6233_end
.annotate 'line', 1890
    find_lex $P6236, "$/"
    unless_null $P6236, vivify_2569
    $P6236 = root_new ['parrot';'Hash']
  vivify_2569:
    set $P6237, $P6236["args"]
    unless_null $P6237, vivify_2570
    $P6237 = root_new ['parrot';'ResizablePMCArray']
  vivify_2570:
    set $P6238, $P6237[0]
    unless_null $P6238, vivify_2571
    new $P6238, "Undef"
  vivify_2571:
    $P6239 = $P6238."ast"()
    store_lex "$past", $P6239
.annotate 'line', 1891
    find_lex $P6240, "$past"
    unless_null $P6240, vivify_2572
    new $P6240, "Undef"
  vivify_2572:
    find_lex $P6241, "$var"
    unless_null $P6241, vivify_2573
    new $P6241, "Undef"
  vivify_2573:
    $P6240."unshift"($P6241)
  if_6233_end:
.annotate 'line', 1893
    find_lex $P6242, "$/"
    find_lex $P6243, "$past"
    unless_null $P6243, vivify_2574
    new $P6243, "Undef"
  vivify_2574:
    $P6244 = $P6242."!make"($P6243)
.annotate 'line', 1876
    .return ($P6244)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6222"  :anon :subid("533_1303857440.612") :outer("532_1303857440.612")
.annotate 'line', 1883
    $P6224 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6224
    find_lex $P6225, "$/"
    unless_null $P6225, vivify_2559
    $P6225 = root_new ['parrot';'Hash']
  vivify_2559:
    set $P6226, $P6225["name"]
    unless_null $P6226, vivify_2560
    $P6226 = root_new ['parrot';'Hash']
  vivify_2560:
    set $P6227, $P6226["identifier"]
    unless_null $P6227, vivify_2561
    new $P6227, "Undef"
  vivify_2561:
    clone $P6228, $P6227
    store_lex "@ns", $P6228
.annotate 'line', 1884
    find_lex $P6229, "@ns"
    unless_null $P6229, vivify_2562
    $P6229 = root_new ['parrot';'ResizablePMCArray']
  vivify_2562:
    find_lex $P6230, "$/"
    unless_null $P6230, vivify_2563
    new $P6230, "Undef"
  vivify_2563:
    $P6231 = "lexical_package_lookup"($P6229, $P6230)
    store_lex "$var", $P6231
.annotate 'line', 1882
    .return ($P6231)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("534_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6246
    .param pmc param_6247
.annotate 'line', 1896
    .lex "self", param_6246
    .lex "$/", param_6247
.annotate 'line', 1897
    new $P6248, "Undef"
    .lex "$past", $P6248
.annotate 'line', 1898
    new $P6249, "Undef"
    .lex "$pirop", $P6249
.annotate 'line', 1897
    find_lex $P6252, "$/"
    unless_null $P6252, vivify_2575
    $P6252 = root_new ['parrot';'Hash']
  vivify_2575:
    set $P6253, $P6252["args"]
    unless_null $P6253, vivify_2576
    new $P6253, "Undef"
  vivify_2576:
    if $P6253, if_6251
    get_hll_global $P6258, "GLOBAL"
    nqp_get_package_through_who $P6259, $P6258, "PAST"
    get_who $P6260, $P6259
    set $P6261, $P6260["Op"]
    find_lex $P6262, "$/"
    unless_null $P6262, vivify_2577
    new $P6262, "Undef"
  vivify_2577:
    $P6263 = $P6261."new"($P6262 :named("node"))
    set $P6250, $P6263
    goto if_6251_end
  if_6251:
    find_lex $P6254, "$/"
    unless_null $P6254, vivify_2578
    $P6254 = root_new ['parrot';'Hash']
  vivify_2578:
    set $P6255, $P6254["args"]
    unless_null $P6255, vivify_2579
    $P6255 = root_new ['parrot';'ResizablePMCArray']
  vivify_2579:
    set $P6256, $P6255[0]
    unless_null $P6256, vivify_2580
    new $P6256, "Undef"
  vivify_2580:
    $P6257 = $P6256."ast"()
    set $P6250, $P6257
  if_6251_end:
    store_lex "$past", $P6250
.annotate 'line', 1898
    find_lex $P6264, "$/"
    unless_null $P6264, vivify_2581
    $P6264 = root_new ['parrot';'Hash']
  vivify_2581:
    set $P6265, $P6264["op"]
    unless_null $P6265, vivify_2582
    new $P6265, "Undef"
  vivify_2582:
    set $S6266, $P6265
    new $P6267, 'String'
    set $P6267, $S6266
    store_lex "$pirop", $P6267
.annotate 'line', 1899
    find_lex $P6268, "$pirop"
    unless_null $P6268, vivify_2583
    new $P6268, "Undef"
  vivify_2583:
    set $S6269, $P6268
    split $P6270, "__", $S6269
    join $S6271, " ", $P6270
    new $P6272, 'String'
    set $P6272, $S6271
    store_lex "$pirop", $P6272
.annotate 'line', 1900
    find_lex $P6273, "$past"
    unless_null $P6273, vivify_2584
    new $P6273, "Undef"
  vivify_2584:
    find_lex $P6274, "$pirop"
    unless_null $P6274, vivify_2585
    new $P6274, "Undef"
  vivify_2585:
    $P6273."pirop"($P6274)
.annotate 'line', 1901
    find_lex $P6275, "$past"
    unless_null $P6275, vivify_2586
    new $P6275, "Undef"
  vivify_2586:
    $P6275."pasttype"("pirop")
.annotate 'line', 1902
    find_lex $P6276, "$/"
    find_lex $P6277, "$past"
    unless_null $P6277, vivify_2587
    new $P6277, "Undef"
  vivify_2587:
    $P6278 = $P6276."!make"($P6277)
.annotate 'line', 1896
    .return ($P6278)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("535_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6280
    .param pmc param_6281
.annotate 'line', 1905
    .lex "self", param_6280
    .lex "$/", param_6281
.annotate 'line', 1906
    find_lex $P6282, "$/"
    get_hll_global $P6283, "GLOBAL"
    nqp_get_package_through_who $P6284, $P6283, "PAST"
    get_who $P6285, $P6284
    set $P6286, $P6285["Op"]
    $P6287 = $P6286."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6288 = $P6282."!make"($P6287)
.annotate 'line', 1905
    .return ($P6288)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("536_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6290
    .param pmc param_6291
.annotate 'line', 1911
    .lex "self", param_6290
    .lex "$/", param_6291
    find_lex $P6292, "$/"
    find_lex $P6293, "$/"
    unless_null $P6293, vivify_2588
    $P6293 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P6294, $P6293["arglist"]
    unless_null $P6294, vivify_2589
    new $P6294, "Undef"
  vivify_2589:
    $P6295 = $P6294."ast"()
    $P6296 = $P6292."!make"($P6295)
    .return ($P6296)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("537_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6298
    .param pmc param_6299
.annotate 'line', 1913
    .const 'Sub' $P6313 = "538_1303857440.612" 
    capture_lex $P6313
    .lex "self", param_6298
    .lex "$/", param_6299
.annotate 'line', 1914
    new $P6300, "Undef"
    .lex "$past", $P6300
.annotate 'line', 1922
    new $P6301, "Undef"
    .lex "$i", $P6301
.annotate 'line', 1923
    new $P6302, "Undef"
    .lex "$n", $P6302
.annotate 'line', 1914
    get_hll_global $P6303, "GLOBAL"
    nqp_get_package_through_who $P6304, $P6303, "PAST"
    get_who $P6305, $P6304
    set $P6306, $P6305["Op"]
    find_lex $P6307, "$/"
    unless_null $P6307, vivify_2590
    new $P6307, "Undef"
  vivify_2590:
    $P6308 = $P6306."new"("call" :named("pasttype"), $P6307 :named("node"))
    store_lex "$past", $P6308
.annotate 'line', 1915
    find_lex $P6310, "$/"
    unless_null $P6310, vivify_2591
    $P6310 = root_new ['parrot';'Hash']
  vivify_2591:
    set $P6311, $P6310["EXPR"]
    unless_null $P6311, vivify_2592
    new $P6311, "Undef"
  vivify_2592:
    unless $P6311, if_6309_end
    .const 'Sub' $P6313 = "538_1303857440.612" 
    capture_lex $P6313
    $P6313()
  if_6309_end:
.annotate 'line', 1922
    new $P6345, "Integer"
    assign $P6345, 0
    store_lex "$i", $P6345
.annotate 'line', 1923
    find_lex $P6346, "$past"
    unless_null $P6346, vivify_2603
    new $P6346, "Undef"
  vivify_2603:
    $P6347 = $P6346."list"()
    set $N6348, $P6347
    new $P6349, 'Float'
    set $P6349, $N6348
    store_lex "$n", $P6349
.annotate 'line', 1924
    new $P6400, 'ExceptionHandler'
    set_label $P6400, loop6399_handler
    $P6400."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6400
  loop6399_test:
    find_lex $P6350, "$i"
    unless_null $P6350, vivify_2604
    new $P6350, "Undef"
  vivify_2604:
    set $N6351, $P6350
    find_lex $P6352, "$n"
    unless_null $P6352, vivify_2605
    new $P6352, "Undef"
  vivify_2605:
    set $N6353, $P6352
    islt $I6354, $N6351, $N6353
    unless $I6354, loop6399_done
  loop6399_redo:
.annotate 'line', 1925
    find_lex $P6356, "$i"
    unless_null $P6356, vivify_2606
    new $P6356, "Undef"
  vivify_2606:
    set $I6357, $P6356
    find_lex $P6358, "$past"
    unless_null $P6358, vivify_2607
    $P6358 = root_new ['parrot';'ResizablePMCArray']
  vivify_2607:
    set $P6359, $P6358[$I6357]
    unless_null $P6359, vivify_2608
    new $P6359, "Undef"
  vivify_2608:
    $S6360 = $P6359."name"()
    iseq $I6361, $S6360, "&prefix:<|>"
    unless $I6361, if_6355_end
.annotate 'line', 1926
    find_lex $P6362, "$i"
    unless_null $P6362, vivify_2609
    new $P6362, "Undef"
  vivify_2609:
    set $I6363, $P6362
    find_lex $P6364, "$past"
    unless_null $P6364, vivify_2610
    $P6364 = root_new ['parrot';'ResizablePMCArray']
  vivify_2610:
    set $P6365, $P6364[$I6363]
    unless_null $P6365, vivify_2611
    $P6365 = root_new ['parrot';'ResizablePMCArray']
  vivify_2611:
    set $P6366, $P6365[0]
    unless_null $P6366, vivify_2612
    new $P6366, "Undef"
  vivify_2612:
    find_lex $P6367, "$i"
    unless_null $P6367, vivify_2613
    new $P6367, "Undef"
  vivify_2613:
    set $I6368, $P6367
    find_lex $P6369, "$past"
    unless_null $P6369, vivify_2614
    $P6369 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6369
  vivify_2614:
    set $P6369[$I6368], $P6366
.annotate 'line', 1927
    find_lex $P6370, "$i"
    unless_null $P6370, vivify_2615
    new $P6370, "Undef"
  vivify_2615:
    set $I6371, $P6370
    find_lex $P6372, "$past"
    unless_null $P6372, vivify_2616
    $P6372 = root_new ['parrot';'ResizablePMCArray']
  vivify_2616:
    set $P6373, $P6372[$I6371]
    unless_null $P6373, vivify_2617
    new $P6373, "Undef"
  vivify_2617:
    $P6373."flat"(1)
.annotate 'line', 1928
    find_lex $P6377, "$i"
    unless_null $P6377, vivify_2618
    new $P6377, "Undef"
  vivify_2618:
    set $I6378, $P6377
    find_lex $P6379, "$past"
    unless_null $P6379, vivify_2619
    $P6379 = root_new ['parrot';'ResizablePMCArray']
  vivify_2619:
    set $P6380, $P6379[$I6378]
    unless_null $P6380, vivify_2620
    new $P6380, "Undef"
  vivify_2620:
    get_hll_global $P6381, "GLOBAL"
    nqp_get_package_through_who $P6382, $P6381, "PAST"
    get_who $P6383, $P6382
    set $P6384, $P6383["Val"]
    $P6385 = $P6380."isa"($P6384)
    if $P6385, if_6376
    set $P6375, $P6385
    goto if_6376_end
  if_6376:
.annotate 'line', 1929
    find_lex $P6386, "$i"
    unless_null $P6386, vivify_2621
    new $P6386, "Undef"
  vivify_2621:
    set $I6387, $P6386
    find_lex $P6388, "$past"
    unless_null $P6388, vivify_2622
    $P6388 = root_new ['parrot';'ResizablePMCArray']
  vivify_2622:
    set $P6389, $P6388[$I6387]
    unless_null $P6389, vivify_2623
    new $P6389, "Undef"
  vivify_2623:
    $S6390 = $P6389."name"()
    substr $S6391, $S6390, 0, 1
    iseq $I6392, $S6391, "%"
    new $P6375, 'Integer'
    set $P6375, $I6392
  if_6376_end:
    unless $P6375, if_6374_end
.annotate 'line', 1930
    find_lex $P6393, "$i"
    unless_null $P6393, vivify_2624
    new $P6393, "Undef"
  vivify_2624:
    set $I6394, $P6393
    find_lex $P6395, "$past"
    unless_null $P6395, vivify_2625
    $P6395 = root_new ['parrot';'ResizablePMCArray']
  vivify_2625:
    set $P6396, $P6395[$I6394]
    unless_null $P6396, vivify_2626
    new $P6396, "Undef"
  vivify_2626:
    $P6396."named"(1)
  if_6374_end:
  if_6355_end:
.annotate 'line', 1925
    find_lex $P6397, "$i"
    unless_null $P6397, vivify_2627
    new $P6397, "Undef"
  vivify_2627:
    clone $P6398, $P6397
    inc $P6397
  loop6399_next:
.annotate 'line', 1924
    goto loop6399_test
  loop6399_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6401, exception, 'type'
    eq $P6401, .CONTROL_LOOP_NEXT, loop6399_next
    eq $P6401, .CONTROL_LOOP_REDO, loop6399_redo
  loop6399_done:
    pop_eh 
.annotate 'line', 1935
    find_lex $P6402, "$/"
    find_lex $P6403, "$past"
    unless_null $P6403, vivify_2628
    new $P6403, "Undef"
  vivify_2628:
    $P6404 = $P6402."!make"($P6403)
.annotate 'line', 1913
    .return ($P6404)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6312"  :anon :subid("538_1303857440.612") :outer("537_1303857440.612")
.annotate 'line', 1915
    .const 'Sub' $P6334 = "539_1303857440.612" 
    capture_lex $P6334
.annotate 'line', 1916
    new $P6314, "Undef"
    .lex "$expr", $P6314
    find_lex $P6315, "$/"
    unless_null $P6315, vivify_2593
    $P6315 = root_new ['parrot';'Hash']
  vivify_2593:
    set $P6316, $P6315["EXPR"]
    unless_null $P6316, vivify_2594
    new $P6316, "Undef"
  vivify_2594:
    $P6317 = $P6316."ast"()
    store_lex "$expr", $P6317
.annotate 'line', 1917
    find_lex $P6322, "$expr"
    unless_null $P6322, vivify_2595
    new $P6322, "Undef"
  vivify_2595:
    $S6323 = $P6322."name"()
    iseq $I6324, $S6323, "&infix:<,>"
    if $I6324, if_6321
    new $P6320, 'Integer'
    set $P6320, $I6324
    goto if_6321_end
  if_6321:
    find_lex $P6325, "$expr"
    unless_null $P6325, vivify_2596
    new $P6325, "Undef"
  vivify_2596:
    $P6326 = $P6325."named"()
    isfalse $I6327, $P6326
    new $P6320, 'Integer'
    set $P6320, $I6327
  if_6321_end:
    if $P6320, if_6319
.annotate 'line', 1920
    find_lex $P6342, "$past"
    unless_null $P6342, vivify_2597
    new $P6342, "Undef"
  vivify_2597:
    find_lex $P6343, "$expr"
    unless_null $P6343, vivify_2598
    new $P6343, "Undef"
  vivify_2598:
    $P6344 = $P6342."push"($P6343)
    set $P6318, $P6344
.annotate 'line', 1917
    goto if_6319_end
  if_6319:
.annotate 'line', 1918
    find_lex $P6329, "$expr"
    unless_null $P6329, vivify_2599
    new $P6329, "Undef"
  vivify_2599:
    $P6330 = $P6329."list"()
    defined $I6331, $P6330
    unless $I6331, for_undef_2600
    iter $P6328, $P6330
    new $P6340, 'ExceptionHandler'
    set_label $P6340, loop6339_handler
    $P6340."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6340
  loop6339_test:
    unless $P6328, loop6339_done
    shift $P6332, $P6328
  loop6339_redo:
    .const 'Sub' $P6334 = "539_1303857440.612" 
    capture_lex $P6334
    $P6334($P6332)
  loop6339_next:
    goto loop6339_test
  loop6339_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6341, exception, 'type'
    eq $P6341, .CONTROL_LOOP_NEXT, loop6339_next
    eq $P6341, .CONTROL_LOOP_REDO, loop6339_redo
  loop6339_done:
    pop_eh 
  for_undef_2600:
.annotate 'line', 1917
    set $P6318, $P6328
  if_6319_end:
.annotate 'line', 1915
    .return ($P6318)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6333"  :anon :subid("539_1303857440.612") :outer("538_1303857440.612")
    .param pmc param_6335
.annotate 'line', 1918
    .lex "$_", param_6335
    find_lex $P6336, "$past"
    unless_null $P6336, vivify_2601
    new $P6336, "Undef"
  vivify_2601:
    find_lex $P6337, "$_"
    unless_null $P6337, vivify_2602
    new $P6337, "Undef"
  vivify_2602:
    $P6338 = $P6336."push"($P6337)
    .return ($P6338)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("540_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6406
    .param pmc param_6407
.annotate 'line', 1938
    .lex "self", param_6406
    .lex "$/", param_6407
    find_lex $P6408, "$/"
    find_lex $P6409, "$/"
    unless_null $P6409, vivify_2629
    $P6409 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P6410, $P6409["multi_declarator"]
    unless_null $P6410, vivify_2630
    new $P6410, "Undef"
  vivify_2630:
    $P6411 = $P6410."ast"()
    $P6412 = $P6408."!make"($P6411)
    .return ($P6412)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("541_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6414
    .param pmc param_6415
.annotate 'line', 1940
    .lex "self", param_6414
    .lex "$/", param_6415
    find_lex $P6416, "$/"
    find_lex $P6417, "$/"
    unless_null $P6417, vivify_2631
    $P6417 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P6418, $P6417["value"]
    unless_null $P6418, vivify_2632
    new $P6418, "Undef"
  vivify_2632:
    $P6419 = $P6418."ast"()
    $P6420 = $P6416."!make"($P6419)
    .return ($P6420)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("542_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6422
    .param pmc param_6423
.annotate 'line', 1942
    .lex "self", param_6422
    .lex "$/", param_6423
.annotate 'line', 1943
    find_lex $P6424, "$/"
.annotate 'line', 1944
    find_lex $P6427, "$/"
    unless_null $P6427, vivify_2633
    $P6427 = root_new ['parrot';'Hash']
  vivify_2633:
    set $P6428, $P6427["EXPR"]
    unless_null $P6428, vivify_2634
    new $P6428, "Undef"
  vivify_2634:
    if $P6428, if_6426
.annotate 'line', 1945
    get_hll_global $P6433, "GLOBAL"
    nqp_get_package_through_who $P6434, $P6433, "PAST"
    get_who $P6435, $P6434
    set $P6436, $P6435["Op"]
    find_lex $P6437, "$/"
    unless_null $P6437, vivify_2635
    new $P6437, "Undef"
  vivify_2635:
    $P6438 = $P6436."new"("list" :named("pasttype"), $P6437 :named("node"))
    set $P6425, $P6438
.annotate 'line', 1944
    goto if_6426_end
  if_6426:
    find_lex $P6429, "$/"
    unless_null $P6429, vivify_2636
    $P6429 = root_new ['parrot';'Hash']
  vivify_2636:
    set $P6430, $P6429["EXPR"]
    unless_null $P6430, vivify_2637
    $P6430 = root_new ['parrot';'ResizablePMCArray']
  vivify_2637:
    set $P6431, $P6430[0]
    unless_null $P6431, vivify_2638
    new $P6431, "Undef"
  vivify_2638:
    $P6432 = $P6431."ast"()
    set $P6425, $P6432
  if_6426_end:
    $P6439 = $P6424."!make"($P6425)
.annotate 'line', 1942
    .return ($P6439)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("543_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6441
    .param pmc param_6442
.annotate 'line', 1948
    .lex "self", param_6441
    .lex "$/", param_6442
.annotate 'line', 1949
    new $P6443, "Undef"
    .lex "$past", $P6443
.annotate 'line', 1948
    find_lex $P6444, "$past"
    unless_null $P6444, vivify_2639
    new $P6444, "Undef"
  vivify_2639:
.annotate 'line', 1950
    find_lex $P6446, "$/"
    unless_null $P6446, vivify_2640
    $P6446 = root_new ['parrot';'Hash']
  vivify_2640:
    set $P6447, $P6446["EXPR"]
    unless_null $P6447, vivify_2641
    new $P6447, "Undef"
  vivify_2641:
    if $P6447, if_6445
.annotate 'line', 1957
    get_hll_global $P6462, "GLOBAL"
    nqp_get_package_through_who $P6463, $P6462, "PAST"
    get_who $P6464, $P6463
    set $P6465, $P6464["Op"]
    $P6466 = $P6465."new"("list" :named("pasttype"))
    store_lex "$past", $P6466
.annotate 'line', 1956
    goto if_6445_end
  if_6445:
.annotate 'line', 1951
    find_lex $P6448, "$/"
    unless_null $P6448, vivify_2642
    $P6448 = root_new ['parrot';'Hash']
  vivify_2642:
    set $P6449, $P6448["EXPR"]
    unless_null $P6449, vivify_2643
    $P6449 = root_new ['parrot';'ResizablePMCArray']
  vivify_2643:
    set $P6450, $P6449[0]
    unless_null $P6450, vivify_2644
    new $P6450, "Undef"
  vivify_2644:
    $P6451 = $P6450."ast"()
    store_lex "$past", $P6451
.annotate 'line', 1952
    find_lex $P6453, "$past"
    unless_null $P6453, vivify_2645
    new $P6453, "Undef"
  vivify_2645:
    $S6454 = $P6453."name"()
    isne $I6455, $S6454, "&infix:<,>"
    unless $I6455, if_6452_end
.annotate 'line', 1953
    get_hll_global $P6456, "GLOBAL"
    nqp_get_package_through_who $P6457, $P6456, "PAST"
    get_who $P6458, $P6457
    set $P6459, $P6458["Op"]
    find_lex $P6460, "$past"
    unless_null $P6460, vivify_2646
    new $P6460, "Undef"
  vivify_2646:
    $P6461 = $P6459."new"($P6460, "list" :named("pasttype"))
    store_lex "$past", $P6461
  if_6452_end:
  if_6445_end:
.annotate 'line', 1959
    find_lex $P6467, "$past"
    unless_null $P6467, vivify_2647
    new $P6467, "Undef"
  vivify_2647:
    $P6467."name"("&circumfix:<[ ]>")
.annotate 'line', 1960
    find_lex $P6468, "$/"
    find_lex $P6469, "$past"
    unless_null $P6469, vivify_2648
    new $P6469, "Undef"
  vivify_2648:
    $P6470 = $P6468."!make"($P6469)
.annotate 'line', 1948
    .return ($P6470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("544_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6472
    .param pmc param_6473
.annotate 'line', 1963
    .lex "self", param_6472
    .lex "$/", param_6473
    find_lex $P6474, "$/"
    find_lex $P6475, "$/"
    unless_null $P6475, vivify_2649
    $P6475 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P6476, $P6475["quote_EXPR"]
    unless_null $P6476, vivify_2650
    new $P6476, "Undef"
  vivify_2650:
    $P6477 = $P6476."ast"()
    $P6478 = $P6474."!make"($P6477)
    .return ($P6478)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("545_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6480
    .param pmc param_6481
.annotate 'line', 1964
    .lex "self", param_6480
    .lex "$/", param_6481
    find_lex $P6482, "$/"
    find_lex $P6483, "$/"
    unless_null $P6483, vivify_2651
    $P6483 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P6484, $P6483["quote_EXPR"]
    unless_null $P6484, vivify_2652
    new $P6484, "Undef"
  vivify_2652:
    $P6485 = $P6484."ast"()
    $P6486 = $P6482."!make"($P6485)
    .return ($P6486)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("546_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6488
    .param pmc param_6489
.annotate 'line', 1966
    .const 'Sub' $P6500 = "547_1303857440.612" 
    capture_lex $P6500
    .lex "self", param_6488
    .lex "$/", param_6489
.annotate 'line', 1967
    find_lex $P6492, "$/"
    unless_null $P6492, vivify_2653
    $P6492 = root_new ['parrot';'Hash']
  vivify_2653:
    set $P6493, $P6492["pblock"]
    unless_null $P6493, vivify_2654
    $P6493 = root_new ['parrot';'Hash']
  vivify_2654:
    set $P6494, $P6493["blockoid"]
    unless_null $P6494, vivify_2655
    $P6494 = root_new ['parrot';'Hash']
  vivify_2655:
    set $P6495, $P6494["statementlist"]
    unless_null $P6495, vivify_2656
    $P6495 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P6496, $P6495["statement"]
    unless_null $P6496, vivify_2657
    new $P6496, "Undef"
  vivify_2657:
    set $N6497, $P6496
    isgt $I6498, $N6497, 0.0
    if $I6498, if_6491
.annotate 'line', 1972
    find_lex $P6513, "$/"
    unless_null $P6513, vivify_2658
    $P6513 = root_new ['parrot';'Hash']
  vivify_2658:
    set $P6514, $P6513["pblock"]
    unless_null $P6514, vivify_2659
    $P6514 = root_new ['parrot';'Hash']
  vivify_2659:
    set $P6515, $P6514["blockoid"]
    unless_null $P6515, vivify_2660
    $P6515 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P6516, $P6515["you_are_here"]
    unless_null $P6516, vivify_2661
    new $P6516, "Undef"
  vivify_2661:
    if $P6516, if_6512
.annotate 'line', 1976
    find_lex $P6522, "$/"
    $P6523 = "vivitype"("%")
    $P6524 = $P6522."!make"($P6523)
.annotate 'line', 1975
    set $P6511, $P6524
.annotate 'line', 1972
    goto if_6512_end
  if_6512:
.annotate 'line', 1973
    find_lex $P6517, "$/"
    find_lex $P6518, "$/"
    unless_null $P6518, vivify_2662
    $P6518 = root_new ['parrot';'Hash']
  vivify_2662:
    set $P6519, $P6518["pblock"]
    unless_null $P6519, vivify_2663
    new $P6519, "Undef"
  vivify_2663:
    $P6520 = $P6519."ast"()
    $P6521 = $P6517."!make"($P6520)
.annotate 'line', 1972
    set $P6511, $P6521
  if_6512_end:
    set $P6490, $P6511
.annotate 'line', 1967
    goto if_6491_end
  if_6491:
    .const 'Sub' $P6500 = "547_1303857440.612" 
    capture_lex $P6500
    $P6510 = $P6500()
    set $P6490, $P6510
  if_6491_end:
.annotate 'line', 1966
    .return ($P6490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6499"  :anon :subid("547_1303857440.612") :outer("546_1303857440.612")
.annotate 'line', 1968
    new $P6501, "Undef"
    .lex "$past", $P6501
    find_lex $P6502, "$/"
    unless_null $P6502, vivify_2664
    $P6502 = root_new ['parrot';'Hash']
  vivify_2664:
    set $P6503, $P6502["pblock"]
    unless_null $P6503, vivify_2665
    new $P6503, "Undef"
  vivify_2665:
    $P6504 = $P6503."ast"()
    store_lex "$past", $P6504
.annotate 'line', 1969
    new $P6505, "Integer"
    assign $P6505, 1
    find_lex $P6506, "$past"
    unless_null $P6506, vivify_2666
    $P6506 = root_new ['parrot';'Hash']
    store_lex "$past", $P6506
  vivify_2666:
    set $P6506["bareblock"], $P6505
.annotate 'line', 1970
    find_dynamic_lex $P6507, "$/"
    find_lex $P6508, "$past"
    unless_null $P6508, vivify_2667
    new $P6508, "Undef"
  vivify_2667:
    $P6509 = $P6507."!make"($P6508)
.annotate 'line', 1967
    .return ($P6509)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("548_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6526
    .param pmc param_6527
.annotate 'line', 1980
    .lex "self", param_6526
    .lex "$/", param_6527
.annotate 'line', 1981
    new $P6528, "Undef"
    .lex "$name", $P6528
    find_lex $P6531, "$/"
    unless_null $P6531, vivify_2668
    $P6531 = root_new ['parrot';'Hash']
  vivify_2668:
    set $P6532, $P6531["sigil"]
    unless_null $P6532, vivify_2669
    new $P6532, "Undef"
  vivify_2669:
    set $S6533, $P6532
    iseq $I6534, $S6533, "@"
    if $I6534, if_6530
.annotate 'line', 1982
    find_lex $P6538, "$/"
    unless_null $P6538, vivify_2670
    $P6538 = root_new ['parrot';'Hash']
  vivify_2670:
    set $P6539, $P6538["sigil"]
    unless_null $P6539, vivify_2671
    new $P6539, "Undef"
  vivify_2671:
    set $S6540, $P6539
    iseq $I6541, $S6540, "%"
    if $I6541, if_6537
    new $P6543, "String"
    assign $P6543, "item"
    set $P6536, $P6543
    goto if_6537_end
  if_6537:
    new $P6542, "String"
    assign $P6542, "hash"
    set $P6536, $P6542
  if_6537_end:
    set $P6529, $P6536
.annotate 'line', 1981
    goto if_6530_end
  if_6530:
    new $P6535, "String"
    assign $P6535, "list"
    set $P6529, $P6535
  if_6530_end:
    store_lex "$name", $P6529
.annotate 'line', 1984
    find_lex $P6544, "$/"
    get_hll_global $P6545, "GLOBAL"
    nqp_get_package_through_who $P6546, $P6545, "PAST"
    get_who $P6547, $P6546
    set $P6548, $P6547["Op"]
    find_lex $P6549, "$name"
    unless_null $P6549, vivify_2672
    new $P6549, "Undef"
  vivify_2672:
    find_lex $P6550, "$/"
    unless_null $P6550, vivify_2673
    $P6550 = root_new ['parrot';'Hash']
  vivify_2673:
    set $P6551, $P6550["semilist"]
    unless_null $P6551, vivify_2674
    new $P6551, "Undef"
  vivify_2674:
    $P6552 = $P6551."ast"()
    $P6553 = $P6548."new"($P6552, "callmethod" :named("pasttype"), $P6549 :named("name"))
    $P6554 = $P6544."!make"($P6553)
.annotate 'line', 1980
    .return ($P6554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("549_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6556
    .param pmc param_6557
.annotate 'line', 1987
    .lex "self", param_6556
    .lex "$/", param_6557
    find_lex $P6558, "$/"
    find_lex $P6559, "$/"
    unless_null $P6559, vivify_2675
    $P6559 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P6560, $P6559["statement"]
    unless_null $P6560, vivify_2676
    new $P6560, "Undef"
  vivify_2676:
    $P6561 = $P6560."ast"()
    $P6562 = $P6558."!make"($P6561)
    .return ($P6562)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("550_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6564
    .param pmc param_6565
.annotate 'line', 1989
    .lex "self", param_6564
    .lex "$/", param_6565
.annotate 'line', 1990
    find_lex $P6566, "$/"
    get_hll_global $P6567, "GLOBAL"
    nqp_get_package_through_who $P6568, $P6567, "PAST"
    get_who $P6569, $P6568
    set $P6570, $P6569["Var"]
    find_lex $P6571, "$/"
    unless_null $P6571, vivify_2677
    $P6571 = root_new ['parrot';'Hash']
  vivify_2677:
    set $P6572, $P6571["EXPR"]
    unless_null $P6572, vivify_2678
    new $P6572, "Undef"
  vivify_2678:
    $P6573 = $P6572."ast"()
.annotate 'line', 1992
    $P6574 = "vivitype"("@")
    $P6575 = $P6570."new"($P6573, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6574 :named("vivibase"))
.annotate 'line', 1990
    $P6576 = $P6566."!make"($P6575)
.annotate 'line', 1989
    .return ($P6576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("551_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6578
    .param pmc param_6579
.annotate 'line', 1995
    .lex "self", param_6578
    .lex "$/", param_6579
.annotate 'line', 1996
    find_lex $P6580, "$/"
    get_hll_global $P6581, "GLOBAL"
    nqp_get_package_through_who $P6582, $P6581, "PAST"
    get_who $P6583, $P6582
    set $P6584, $P6583["Var"]
    find_lex $P6585, "$/"
    unless_null $P6585, vivify_2679
    $P6585 = root_new ['parrot';'Hash']
  vivify_2679:
    set $P6586, $P6585["EXPR"]
    unless_null $P6586, vivify_2680
    new $P6586, "Undef"
  vivify_2680:
    $P6587 = $P6586."ast"()
.annotate 'line', 1998
    $P6588 = "vivitype"("%")
    $P6589 = $P6584."new"($P6587, "keyed" :named("scope"), "Undef" :named("viviself"), $P6588 :named("vivibase"))
.annotate 'line', 1996
    $P6590 = $P6580."!make"($P6589)
.annotate 'line', 1995
    .return ($P6590)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("552_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6592
    .param pmc param_6593
.annotate 'line', 2001
    .lex "self", param_6592
    .lex "$/", param_6593
.annotate 'line', 2002
    find_lex $P6594, "$/"
    get_hll_global $P6595, "GLOBAL"
    nqp_get_package_through_who $P6596, $P6595, "PAST"
    get_who $P6597, $P6596
    set $P6598, $P6597["Var"]
    find_lex $P6599, "$/"
    unless_null $P6599, vivify_2681
    $P6599 = root_new ['parrot';'Hash']
  vivify_2681:
    set $P6600, $P6599["quote_EXPR"]
    unless_null $P6600, vivify_2682
    new $P6600, "Undef"
  vivify_2682:
    $P6601 = $P6600."ast"()
.annotate 'line', 2004
    $P6602 = "vivitype"("%")
    $P6603 = $P6598."new"($P6601, "keyed" :named("scope"), "Undef" :named("viviself"), $P6602 :named("vivibase"))
.annotate 'line', 2002
    $P6604 = $P6594."!make"($P6603)
.annotate 'line', 2001
    .return ($P6604)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("553_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6606
    .param pmc param_6607
.annotate 'line', 2007
    .lex "self", param_6606
    .lex "$/", param_6607
.annotate 'line', 2008
    find_lex $P6608, "$/"
    find_lex $P6609, "$/"
    unless_null $P6609, vivify_2683
    $P6609 = root_new ['parrot';'Hash']
  vivify_2683:
    set $P6610, $P6609["arglist"]
    unless_null $P6610, vivify_2684
    new $P6610, "Undef"
  vivify_2684:
    $P6611 = $P6610."ast"()
    $P6612 = $P6608."!make"($P6611)
.annotate 'line', 2007
    .return ($P6612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("554_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6614
    .param pmc param_6615
.annotate 'line', 2011
    .lex "self", param_6614
    .lex "$/", param_6615
.annotate 'line', 2012
    find_lex $P6616, "$/"
    find_lex $P6619, "$/"
    unless_null $P6619, vivify_2685
    $P6619 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P6620, $P6619["quote"]
    unless_null $P6620, vivify_2686
    new $P6620, "Undef"
  vivify_2686:
    if $P6620, if_6618
    find_lex $P6624, "$/"
    unless_null $P6624, vivify_2687
    $P6624 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P6625, $P6624["number"]
    unless_null $P6625, vivify_2688
    new $P6625, "Undef"
  vivify_2688:
    $P6626 = $P6625."ast"()
    set $P6617, $P6626
    goto if_6618_end
  if_6618:
    find_lex $P6621, "$/"
    unless_null $P6621, vivify_2689
    $P6621 = root_new ['parrot';'Hash']
  vivify_2689:
    set $P6622, $P6621["quote"]
    unless_null $P6622, vivify_2690
    new $P6622, "Undef"
  vivify_2690:
    $P6623 = $P6622."ast"()
    set $P6617, $P6623
  if_6618_end:
    $P6627 = $P6616."!make"($P6617)
.annotate 'line', 2011
    .return ($P6627)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("555_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6629
    .param pmc param_6630
.annotate 'line', 2015
    .lex "self", param_6629
    .lex "$/", param_6630
.annotate 'line', 2016
    new $P6631, "Undef"
    .lex "$value", $P6631
    find_lex $P6634, "$/"
    unless_null $P6634, vivify_2691
    $P6634 = root_new ['parrot';'Hash']
  vivify_2691:
    set $P6635, $P6634["dec_number"]
    unless_null $P6635, vivify_2692
    new $P6635, "Undef"
  vivify_2692:
    if $P6635, if_6633
    find_lex $P6639, "$/"
    unless_null $P6639, vivify_2693
    $P6639 = root_new ['parrot';'Hash']
  vivify_2693:
    set $P6640, $P6639["integer"]
    unless_null $P6640, vivify_2694
    new $P6640, "Undef"
  vivify_2694:
    $P6641 = $P6640."ast"()
    set $P6632, $P6641
    goto if_6633_end
  if_6633:
    find_lex $P6636, "$/"
    unless_null $P6636, vivify_2695
    $P6636 = root_new ['parrot';'Hash']
  vivify_2695:
    set $P6637, $P6636["dec_number"]
    unless_null $P6637, vivify_2696
    new $P6637, "Undef"
  vivify_2696:
    $P6638 = $P6637."ast"()
    set $P6632, $P6638
  if_6633_end:
    store_lex "$value", $P6632
.annotate 'line', 2017
    find_lex $P6643, "$/"
    unless_null $P6643, vivify_2697
    $P6643 = root_new ['parrot';'Hash']
  vivify_2697:
    set $P6644, $P6643["sign"]
    unless_null $P6644, vivify_2698
    new $P6644, "Undef"
  vivify_2698:
    set $S6645, $P6644
    iseq $I6646, $S6645, "-"
    unless $I6646, if_6642_end
    find_lex $P6647, "$value"
    unless_null $P6647, vivify_2699
    new $P6647, "Undef"
  vivify_2699:
    neg $P6648, $P6647
    store_lex "$value", $P6648
  if_6642_end:
.annotate 'line', 2018
    find_lex $P6649, "$/"
    get_hll_global $P6650, "GLOBAL"
    nqp_get_package_through_who $P6651, $P6650, "PAST"
    get_who $P6652, $P6651
    set $P6653, $P6652["Val"]
    find_lex $P6654, "$value"
    unless_null $P6654, vivify_2700
    new $P6654, "Undef"
  vivify_2700:
    $P6655 = $P6653."new"($P6654 :named("value"))
    $P6656 = $P6649."!make"($P6655)
.annotate 'line', 2015
    .return ($P6656)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("556_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6658
    .param pmc param_6659
.annotate 'line', 2021
    .lex "self", param_6658
    .lex "$/", param_6659
    find_lex $P6660, "$/"
    find_lex $P6661, "$/"
    unless_null $P6661, vivify_2701
    $P6661 = root_new ['parrot';'Hash']
  vivify_2701:
    set $P6662, $P6661["quote_EXPR"]
    unless_null $P6662, vivify_2702
    new $P6662, "Undef"
  vivify_2702:
    $P6663 = $P6662."ast"()
    $P6664 = $P6660."!make"($P6663)
    .return ($P6664)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("557_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6666
    .param pmc param_6667
.annotate 'line', 2022
    .lex "self", param_6666
    .lex "$/", param_6667
    find_lex $P6668, "$/"
    find_lex $P6669, "$/"
    unless_null $P6669, vivify_2703
    $P6669 = root_new ['parrot';'Hash']
  vivify_2703:
    set $P6670, $P6669["quote_EXPR"]
    unless_null $P6670, vivify_2704
    new $P6670, "Undef"
  vivify_2704:
    $P6671 = $P6670."ast"()
    $P6672 = $P6668."!make"($P6671)
    .return ($P6672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("558_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6674
    .param pmc param_6675
.annotate 'line', 2023
    .lex "self", param_6674
    .lex "$/", param_6675
    find_lex $P6676, "$/"
    find_lex $P6677, "$/"
    unless_null $P6677, vivify_2705
    $P6677 = root_new ['parrot';'Hash']
  vivify_2705:
    set $P6678, $P6677["quote_EXPR"]
    unless_null $P6678, vivify_2706
    new $P6678, "Undef"
  vivify_2706:
    $P6679 = $P6678."ast"()
    $P6680 = $P6676."!make"($P6679)
    .return ($P6680)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("559_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6682
    .param pmc param_6683
.annotate 'line', 2024
    .lex "self", param_6682
    .lex "$/", param_6683
    find_lex $P6684, "$/"
    find_lex $P6685, "$/"
    unless_null $P6685, vivify_2707
    $P6685 = root_new ['parrot';'Hash']
  vivify_2707:
    set $P6686, $P6685["quote_EXPR"]
    unless_null $P6686, vivify_2708
    new $P6686, "Undef"
  vivify_2708:
    $P6687 = $P6686."ast"()
    $P6688 = $P6684."!make"($P6687)
    .return ($P6688)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("560_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6690
    .param pmc param_6691
.annotate 'line', 2025
    .lex "self", param_6690
    .lex "$/", param_6691
    find_lex $P6692, "$/"
    find_lex $P6693, "$/"
    unless_null $P6693, vivify_2709
    $P6693 = root_new ['parrot';'Hash']
  vivify_2709:
    set $P6694, $P6693["quote_EXPR"]
    unless_null $P6694, vivify_2710
    new $P6694, "Undef"
  vivify_2710:
    $P6695 = $P6694."ast"()
    $P6696 = $P6692."!make"($P6695)
    .return ($P6696)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("561_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6698
    .param pmc param_6699
.annotate 'line', 2026
    .lex "self", param_6698
    .lex "$/", param_6699
.annotate 'line', 2027
    find_lex $P6700, "$/"
    get_hll_global $P6701, "GLOBAL"
    nqp_get_package_through_who $P6702, $P6701, "PAST"
    get_who $P6703, $P6702
    set $P6704, $P6703["Op"]
    find_lex $P6705, "$/"
    unless_null $P6705, vivify_2711
    $P6705 = root_new ['parrot';'Hash']
  vivify_2711:
    set $P6706, $P6705["quote_EXPR"]
    unless_null $P6706, vivify_2712
    new $P6706, "Undef"
  vivify_2712:
    $P6707 = $P6706."ast"()
    $P6708 = $P6707."value"()
    find_lex $P6709, "$/"
    unless_null $P6709, vivify_2713
    new $P6709, "Undef"
  vivify_2713:
    $P6710 = $P6704."new"($P6708 :named("inline"), "inline" :named("pasttype"), $P6709 :named("node"))
    $P6711 = $P6700."!make"($P6710)
.annotate 'line', 2026
    .return ($P6711)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("562_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6715
    .param pmc param_6716
    .param pmc param_6717 :optional
    .param int has_param_6717 :opt_flag
.annotate 'line', 2032
    new $P6714, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6714, control_6713
    push_eh $P6714
    .lex "self", param_6715
    .lex "$/", param_6716
    if has_param_6717, optparam_2714
    new $P6718, "Undef"
    set param_6717, $P6718
  optparam_2714:
    .lex "$key", param_6717
.annotate 'line', 2039
    new $P6719, "Undef"
    .lex "$regex", $P6719
.annotate 'line', 2041
    new $P6720, "Undef"
    .lex "$past", $P6720
.annotate 'line', 2033
    find_lex $P6722, "$key"
    unless_null $P6722, vivify_2715
    new $P6722, "Undef"
  vivify_2715:
    set $S6723, $P6722
    iseq $I6724, $S6723, "open"
    unless $I6724, if_6721_end
.annotate 'line', 2034
    null $P6725
    get_hll_global $P6726, "GLOBAL"
    nqp_get_package_through_who $P6727, $P6726, "Regex"
    nqp_get_package_through_who $P6728, $P6727, "P6Regex"
    nqp_get_package_through_who $P6729, $P6728, "Actions"
    get_who $P6730, $P6729
    set $P6730["$REGEXNAME"], $P6725
.annotate 'line', 2035
    find_lex $P6731, "$?PACKAGE"
    get_who $P6732, $P6731
    set $P6733, $P6732["@BLOCK"]
    unless_null $P6733, vivify_2716
    $P6733 = root_new ['parrot';'ResizablePMCArray']
  vivify_2716:
    set $P6734, $P6733[0]
    unless_null $P6734, vivify_2717
    new $P6734, "Undef"
  vivify_2717:
    $P6734."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2036
    find_lex $P6735, "$?PACKAGE"
    get_who $P6736, $P6735
    set $P6737, $P6736["@BLOCK"]
    unless_null $P6737, vivify_2718
    $P6737 = root_new ['parrot';'ResizablePMCArray']
  vivify_2718:
    set $P6738, $P6737[0]
    unless_null $P6738, vivify_2719
    new $P6738, "Undef"
  vivify_2719:
    $P6738."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2037
    new $P6739, "Exception"
    set $P6739['type'], .CONTROL_RETURN
    new $P6740, "Integer"
    assign $P6740, 0
    setattribute $P6739, 'payload', $P6740
    throw $P6739
  if_6721_end:
.annotate 'line', 2040
    get_hll_global $P6741, "GLOBAL"
    nqp_get_package_through_who $P6742, $P6741, "Regex"
    nqp_get_package_through_who $P6743, $P6742, "P6Regex"
    nqp_get_package_through_who $P6744, $P6743, "Actions"
    get_who $P6745, $P6744
    set $P6746, $P6745["buildsub"]
    find_lex $P6747, "$/"
    unless_null $P6747, vivify_2720
    $P6747 = root_new ['parrot';'Hash']
  vivify_2720:
    set $P6748, $P6747["p6regex"]
    unless_null $P6748, vivify_2721
    new $P6748, "Undef"
  vivify_2721:
    $P6749 = $P6748."ast"()
    find_lex $P6750, "$?PACKAGE"
    get_who $P6751, $P6750
    set $P6752, $P6751["@BLOCK"]
    unless_null $P6752, vivify_2722
    $P6752 = root_new ['parrot';'ResizablePMCArray']
  vivify_2722:
    $P6753 = $P6752."shift"()
    $P6754 = $P6746($P6749, $P6753)
    store_lex "$regex", $P6754
.annotate 'line', 2042
    get_hll_global $P6755, "GLOBAL"
    nqp_get_package_through_who $P6756, $P6755, "PAST"
    get_who $P6757, $P6756
    set $P6758, $P6757["Op"]
.annotate 'line', 2044
    get_hll_global $P6759, "GLOBAL"
    nqp_get_package_through_who $P6760, $P6759, "PAST"
    get_who $P6761, $P6760
    set $P6762, $P6761["Var"]
    new $P6763, "ResizablePMCArray"
    push $P6763, "Regex"
    $P6764 = $P6762."new"("Regex" :named("name"), $P6763 :named("namespace"), "package" :named("scope"))
    find_lex $P6765, "$regex"
    unless_null $P6765, vivify_2723
    new $P6765, "Undef"
  vivify_2723:
    $P6766 = $P6758."new"($P6764, $P6765, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2042
    store_lex "$past", $P6766
.annotate 'line', 2048
    find_lex $P6767, "$regex"
    unless_null $P6767, vivify_2724
    new $P6767, "Undef"
  vivify_2724:
    find_lex $P6768, "$past"
    unless_null $P6768, vivify_2725
    $P6768 = root_new ['parrot';'Hash']
    store_lex "$past", $P6768
  vivify_2725:
    set $P6768["sink"], $P6767
.annotate 'line', 2049
    find_lex $P6769, "$/"
    find_lex $P6770, "$past"
    unless_null $P6770, vivify_2726
    new $P6770, "Undef"
  vivify_2726:
    $P6771 = $P6769."!make"($P6770)
.annotate 'line', 2032
    .return ($P6771)
  control_6713:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6772, exception, "payload"
    .return ($P6772)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("563_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6774
    .param pmc param_6775
.annotate 'line', 2052
    .lex "self", param_6774
    .lex "$/", param_6775
    find_lex $P6776, "$/"
    find_lex $P6777, "$/"
    unless_null $P6777, vivify_2727
    $P6777 = root_new ['parrot';'Hash']
  vivify_2727:
    set $P6778, $P6777["variable"]
    unless_null $P6778, vivify_2728
    new $P6778, "Undef"
  vivify_2728:
    $P6779 = $P6778."ast"()
    $P6780 = $P6776."!make"($P6779)
    .return ($P6780)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("564_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6782
    .param pmc param_6783
.annotate 'line', 2053
    .lex "self", param_6782
    .lex "$/", param_6783
.annotate 'line', 2054
    find_lex $P6784, "$/"
    get_hll_global $P6785, "GLOBAL"
    nqp_get_package_through_who $P6786, $P6785, "PAST"
    get_who $P6787, $P6786
    set $P6788, $P6787["Op"]
.annotate 'line', 2055
    find_lex $P6789, "$/"
    unless_null $P6789, vivify_2729
    $P6789 = root_new ['parrot';'Hash']
  vivify_2729:
    set $P6790, $P6789["block"]
    unless_null $P6790, vivify_2730
    new $P6790, "Undef"
  vivify_2730:
    $P6791 = $P6790."ast"()
    $P6792 = "block_immediate"($P6791)
    find_lex $P6793, "$/"
    unless_null $P6793, vivify_2731
    new $P6793, "Undef"
  vivify_2731:
    $P6794 = $P6788."new"($P6792, "set S*" :named("pirop"), $P6793 :named("node"))
.annotate 'line', 2054
    $P6795 = $P6784."!make"($P6794)
.annotate 'line', 2053
    .return ($P6795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("565_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6797
    .param pmc param_6798
.annotate 'line', 2058
    .lex "self", param_6797
    .lex "$/", param_6798
    find_lex $P6799, "$/"
    $P6800 = $P6799."!make"("\e")
    .return ($P6800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("566_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6802
    .param pmc param_6803
.annotate 'line', 2062
    .lex "self", param_6802
    .lex "$/", param_6803
    find_lex $P6804, "$/"
    find_lex $P6805, "$/"
    unless_null $P6805, vivify_2732
    $P6805 = root_new ['parrot';'Hash']
  vivify_2732:
    set $P6806, $P6805["dotty"]
    unless_null $P6806, vivify_2733
    new $P6806, "Undef"
  vivify_2733:
    $P6807 = $P6806."ast"()
    $P6808 = $P6804."!make"($P6807)
    .return ($P6808)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("567_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6810
    .param pmc param_6811
.annotate 'line', 2064
    .lex "self", param_6810
    .lex "$/", param_6811
.annotate 'line', 2065
    find_lex $P6812, "$/"
    get_hll_global $P6813, "GLOBAL"
    nqp_get_package_through_who $P6814, $P6813, "PAST"
    get_who $P6815, $P6814
    set $P6816, $P6815["Op"]
.annotate 'line', 2066
    new $P6817, "ResizablePMCArray"
    push $P6817, "    clone %r, %0"
    push $P6817, "    inc %0"
    $P6818 = $P6816."new"("postfix:<++>" :named("name"), $P6817 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2065
    $P6819 = $P6812."!make"($P6818)
.annotate 'line', 2064
    .return ($P6819)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("568_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6821
    .param pmc param_6822
.annotate 'line', 2070
    .lex "self", param_6821
    .lex "$/", param_6822
.annotate 'line', 2071
    find_lex $P6823, "$/"
    get_hll_global $P6824, "GLOBAL"
    nqp_get_package_through_who $P6825, $P6824, "PAST"
    get_who $P6826, $P6825
    set $P6827, $P6826["Op"]
.annotate 'line', 2072
    new $P6828, "ResizablePMCArray"
    push $P6828, "    clone %r, %0"
    push $P6828, "    dec %0"
    $P6829 = $P6827."new"("postfix:<-->" :named("name"), $P6828 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2071
    $P6830 = $P6823."!make"($P6829)
.annotate 'line', 2070
    .return ($P6830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("569_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6832
    .param pmc param_6833
.annotate 'line', 2076
    .lex "self", param_6832
    .lex "$/", param_6833
.annotate 'line', 2077
    find_lex $P6834, "$/"
    get_hll_global $P6835, "GLOBAL"
    nqp_get_package_through_who $P6836, $P6835, "PAST"
    get_who $P6837, $P6836
    set $P6838, $P6837["Op"]
.annotate 'line', 2078
    get_hll_global $P6839, "GLOBAL"
    nqp_get_package_through_who $P6840, $P6839, "PAST"
    get_who $P6841, $P6840
    set $P6842, $P6841["Var"]
    $P6843 = $P6842."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6844, "$/"
    unless_null $P6844, vivify_2734
    new $P6844, "Undef"
  vivify_2734:
    $P6845 = $P6838."new"($P6843, "callmethod" :named("pasttype"), "!make" :named("name"), $P6844 :named("node"))
.annotate 'line', 2077
    $P6846 = $P6834."!make"($P6845)
.annotate 'line', 2076
    .return ($P6846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("570_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6849
    .param pmc param_6850
.annotate 'line', 2094
    .lex "self", param_6849
    .lex "$/", param_6850
    find_lex $P6851, "$/"
    unless_null $P6851, vivify_2735
    new $P6851, "Undef"
  vivify_2735:
    $P6852 = "control"($P6851, "CONTROL_LOOP_NEXT")
    .return ($P6852)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("571_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6854
    .param pmc param_6855
.annotate 'line', 2095
    .lex "self", param_6854
    .lex "$/", param_6855
    find_lex $P6856, "$/"
    unless_null $P6856, vivify_2736
    new $P6856, "Undef"
  vivify_2736:
    $P6857 = "control"($P6856, "CONTROL_LOOP_LAST")
    .return ($P6857)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("572_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6859
    .param pmc param_6860
.annotate 'line', 2096
    .lex "self", param_6859
    .lex "$/", param_6860
    find_lex $P6861, "$/"
    unless_null $P6861, vivify_2737
    new $P6861, "Undef"
  vivify_2737:
    $P6862 = "control"($P6861, "CONTROL_LOOP_REDO")
    .return ($P6862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("573_1303857440.612") :outer("406_1303857440.612")
    .param pmc param_6864
    .param pmc param_6865
.annotate 'line', 2098
    .lex "self", param_6864
    .lex "$/", param_6865
.annotate 'line', 2099
    find_lex $P6866, "$/"
    get_hll_global $P6867, "GLOBAL"
    nqp_get_package_through_who $P6868, $P6867, "PAST"
    get_who $P6869, $P6868
    set $P6870, $P6869["Op"]
    find_lex $P6871, "$/"
    unless_null $P6871, vivify_2738
    new $P6871, "Undef"
  vivify_2738:
    $P6872 = $P6870."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6871 :named("node"))
    $P6873 = $P6866."!make"($P6872)
.annotate 'line', 2098
    .return ($P6873)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7102"  :subid("575_1303857440.612") :outer("10_1303857440.612")
.annotate 'line', 2235
    .const 'Sub' $P7236 = "583_1303857440.612" 
    capture_lex $P7236
    .const 'Sub' $P7196 = "582_1303857440.612" 
    capture_lex $P7196
    .const 'Sub' $P7182 = "581_1303857440.612" 
    capture_lex $P7182
    .const 'Sub' $P7164 = "580_1303857440.612" 
    capture_lex $P7164
    .const 'Sub' $P7150 = "579_1303857440.612" 
    capture_lex $P7150
    .const 'Sub' $P7136 = "578_1303857440.612" 
    capture_lex $P7136
    .const 'Sub' $P7122 = "577_1303857440.612" 
    capture_lex $P7122
    .const 'Sub' $P7106 = "576_1303857440.612" 
    capture_lex $P7106
    .lex "$?PACKAGE", $P7104
    .lex "$?CLASS", $P7105
.annotate 'line', 2269
    .const 'Sub' $P7196 = "582_1303857440.612" 
    newclosure $P7234, $P7196
.annotate 'line', 2235
    .return ($P7234)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2739") :outer("575_1303857440.612")
.annotate 'line', 2235
    .const 'Sub' $P7103 = "575_1303857440.612" 
    .local pmc block
    set block, $P7103
    .const 'Sub' $P7236 = "583_1303857440.612" 
    capture_lex $P7236
    $P7236()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7235"  :anon :subid("583_1303857440.612") :outer("575_1303857440.612")
.annotate 'line', 2235
    nqp_get_sc_object $P7237, "1303857428.33", 4
    .local pmc type_obj
    set type_obj, $P7237
    get_how $P7238, type_obj
    .const 'Sub' $P7239 = "576_1303857440.612" 
    $P7238."add_method"(type_obj, "metachar:sym<:my>", $P7239)
    get_how $P7240, type_obj
    .const 'Sub' $P7241 = "577_1303857440.612" 
    $P7240."add_method"(type_obj, "metachar:sym<{ }>", $P7241)
    get_how $P7242, type_obj
    .const 'Sub' $P7243 = "578_1303857440.612" 
    $P7242."add_method"(type_obj, "metachar:sym<nqpvar>", $P7243)
    get_how $P7244, type_obj
    .const 'Sub' $P7245 = "579_1303857440.612" 
    $P7244."add_method"(type_obj, "assertion:sym<{ }>", $P7245)
    get_how $P7246, type_obj
    .const 'Sub' $P7247 = "580_1303857440.612" 
    $P7246."add_method"(type_obj, "assertion:sym<?{ }>", $P7247)
    get_how $P7248, type_obj
    .const 'Sub' $P7249 = "581_1303857440.612" 
    $P7248."add_method"(type_obj, "assertion:sym<var>", $P7249)
    get_how $P7250, type_obj
    .const 'Sub' $P7251 = "582_1303857440.612" 
    $P7250."add_method"(type_obj, "codeblock", $P7251)
    get_how $P7252, type_obj
    $P7253 = $P7252."compose"(type_obj)
    .return ($P7253)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("576_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7107
    .param pmc param_7108
.annotate 'line', 2237
    .lex "self", param_7107
    .lex "$/", param_7108
.annotate 'line', 2238
    new $P7109, "Undef"
    .lex "$past", $P7109
    find_lex $P7110, "$/"
    unless_null $P7110, vivify_2740
    $P7110 = root_new ['parrot';'Hash']
  vivify_2740:
    set $P7111, $P7110["statement"]
    unless_null $P7111, vivify_2741
    new $P7111, "Undef"
  vivify_2741:
    $P7112 = $P7111."ast"()
    store_lex "$past", $P7112
.annotate 'line', 2239
    find_lex $P7113, "$/"
    get_hll_global $P7114, "GLOBAL"
    nqp_get_package_through_who $P7115, $P7114, "PAST"
    get_who $P7116, $P7115
    set $P7117, $P7116["Regex"]
    find_lex $P7118, "$past"
    unless_null $P7118, vivify_2742
    new $P7118, "Undef"
  vivify_2742:
    find_lex $P7119, "$/"
    unless_null $P7119, vivify_2743
    new $P7119, "Undef"
  vivify_2743:
    $P7120 = $P7117."new"($P7118, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7119 :named("node"))
    $P7121 = $P7113."!make"($P7120)
.annotate 'line', 2237
    .return ($P7121)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("577_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7123
    .param pmc param_7124
.annotate 'line', 2243
    .lex "self", param_7123
    .lex "$/", param_7124
.annotate 'line', 2244
    find_lex $P7125, "$/"
    get_hll_global $P7126, "GLOBAL"
    nqp_get_package_through_who $P7127, $P7126, "PAST"
    get_who $P7128, $P7127
    set $P7129, $P7128["Regex"]
    find_lex $P7130, "$/"
    unless_null $P7130, vivify_2744
    $P7130 = root_new ['parrot';'Hash']
  vivify_2744:
    set $P7131, $P7130["codeblock"]
    unless_null $P7131, vivify_2745
    new $P7131, "Undef"
  vivify_2745:
    $P7132 = $P7131."ast"()
    find_lex $P7133, "$/"
    unless_null $P7133, vivify_2746
    new $P7133, "Undef"
  vivify_2746:
    $P7134 = $P7129."new"($P7132, "pastnode" :named("pasttype"), $P7133 :named("node"))
    $P7135 = $P7125."!make"($P7134)
.annotate 'line', 2243
    .return ($P7135)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("578_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7137
    .param pmc param_7138
.annotate 'line', 2248
    .lex "self", param_7137
    .lex "$/", param_7138
.annotate 'line', 2249
    find_lex $P7139, "$/"
    get_hll_global $P7140, "GLOBAL"
    nqp_get_package_through_who $P7141, $P7140, "PAST"
    get_who $P7142, $P7141
    set $P7143, $P7142["Regex"]
    find_lex $P7144, "$/"
    unless_null $P7144, vivify_2747
    $P7144 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P7145, $P7144["var"]
    unless_null $P7145, vivify_2748
    new $P7145, "Undef"
  vivify_2748:
    $P7146 = $P7145."ast"()
    find_lex $P7147, "$/"
    unless_null $P7147, vivify_2749
    new $P7147, "Undef"
  vivify_2749:
    $P7148 = $P7143."new"("!INTERPOLATE", $P7146, "subrule" :named("pasttype"), "method" :named("subtype"), $P7147 :named("node"))
    $P7149 = $P7139."!make"($P7148)
.annotate 'line', 2248
    .return ($P7149)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("579_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7151
    .param pmc param_7152
.annotate 'line', 2253
    .lex "self", param_7151
    .lex "$/", param_7152
.annotate 'line', 2254
    find_lex $P7153, "$/"
    get_hll_global $P7154, "GLOBAL"
    nqp_get_package_through_who $P7155, $P7154, "PAST"
    get_who $P7156, $P7155
    set $P7157, $P7156["Regex"]
    find_lex $P7158, "$/"
    unless_null $P7158, vivify_2750
    $P7158 = root_new ['parrot';'Hash']
  vivify_2750:
    set $P7159, $P7158["codeblock"]
    unless_null $P7159, vivify_2751
    new $P7159, "Undef"
  vivify_2751:
    $P7160 = $P7159."ast"()
    find_lex $P7161, "$/"
    unless_null $P7161, vivify_2752
    new $P7161, "Undef"
  vivify_2752:
    $P7162 = $P7157."new"("!INTERPOLATE_REGEX", $P7160, "subrule" :named("pasttype"), "method" :named("subtype"), $P7161 :named("node"))
    $P7163 = $P7153."!make"($P7162)
.annotate 'line', 2253
    .return ($P7163)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("580_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7165
    .param pmc param_7166
.annotate 'line', 2258
    .lex "self", param_7165
    .lex "$/", param_7166
.annotate 'line', 2259
    find_lex $P7167, "$/"
    get_hll_global $P7168, "GLOBAL"
    nqp_get_package_through_who $P7169, $P7168, "PAST"
    get_who $P7170, $P7169
    set $P7171, $P7170["Regex"]
    find_lex $P7172, "$/"
    unless_null $P7172, vivify_2753
    $P7172 = root_new ['parrot';'Hash']
  vivify_2753:
    set $P7173, $P7172["codeblock"]
    unless_null $P7173, vivify_2754
    new $P7173, "Undef"
  vivify_2754:
    $P7174 = $P7173."ast"()
.annotate 'line', 2260
    find_lex $P7175, "$/"
    unless_null $P7175, vivify_2755
    $P7175 = root_new ['parrot';'Hash']
  vivify_2755:
    set $P7176, $P7175["zw"]
    unless_null $P7176, vivify_2756
    new $P7176, "Undef"
  vivify_2756:
    set $S7177, $P7176
    iseq $I7178, $S7177, "!"
    find_lex $P7179, "$/"
    unless_null $P7179, vivify_2757
    new $P7179, "Undef"
  vivify_2757:
    $P7180 = $P7171."new"($P7174, "zerowidth" :named("subtype"), $I7178 :named("negate"), "pastnode" :named("pasttype"), $P7179 :named("node"))
.annotate 'line', 2259
    $P7181 = $P7167."!make"($P7180)
.annotate 'line', 2258
    .return ($P7181)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("581_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7183
    .param pmc param_7184
.annotate 'line', 2264
    .lex "self", param_7183
    .lex "$/", param_7184
.annotate 'line', 2265
    find_lex $P7185, "$/"
    get_hll_global $P7186, "GLOBAL"
    nqp_get_package_through_who $P7187, $P7186, "PAST"
    get_who $P7188, $P7187
    set $P7189, $P7188["Regex"]
    find_lex $P7190, "$/"
    unless_null $P7190, vivify_2758
    $P7190 = root_new ['parrot';'Hash']
  vivify_2758:
    set $P7191, $P7190["var"]
    unless_null $P7191, vivify_2759
    new $P7191, "Undef"
  vivify_2759:
    $P7192 = $P7191."ast"()
    find_lex $P7193, "$/"
    unless_null $P7193, vivify_2760
    new $P7193, "Undef"
  vivify_2760:
    $P7194 = $P7189."new"("!INTERPOLATE_REGEX", $P7192, "subrule" :named("pasttype"), "method" :named("subtype"), $P7193 :named("node"))
    $P7195 = $P7185."!make"($P7194)
.annotate 'line', 2264
    .return ($P7195)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("582_1303857440.612") :outer("575_1303857440.612")
    .param pmc param_7197
    .param pmc param_7198
.annotate 'line', 2269
    .lex "self", param_7197
    .lex "$/", param_7198
.annotate 'line', 2270
    new $P7199, "Undef"
    .lex "$block", $P7199
.annotate 'line', 2272
    new $P7200, "Undef"
    .lex "$past", $P7200
.annotate 'line', 2270
    find_lex $P7201, "$/"
    unless_null $P7201, vivify_2761
    $P7201 = root_new ['parrot';'Hash']
  vivify_2761:
    set $P7202, $P7201["block"]
    unless_null $P7202, vivify_2762
    new $P7202, "Undef"
  vivify_2762:
    $P7203 = $P7202."ast"()
    store_lex "$block", $P7203
.annotate 'line', 2271
    find_lex $P7204, "$block"
    unless_null $P7204, vivify_2763
    new $P7204, "Undef"
  vivify_2763:
    $P7204."blocktype"("immediate")
.annotate 'line', 2273
    get_hll_global $P7205, "GLOBAL"
    nqp_get_package_through_who $P7206, $P7205, "PAST"
    get_who $P7207, $P7206
    set $P7208, $P7207["Stmts"]
.annotate 'line', 2274
    get_hll_global $P7209, "GLOBAL"
    nqp_get_package_through_who $P7210, $P7209, "PAST"
    get_who $P7211, $P7210
    set $P7212, $P7211["Op"]
.annotate 'line', 2275
    get_hll_global $P7213, "GLOBAL"
    nqp_get_package_through_who $P7214, $P7213, "PAST"
    get_who $P7215, $P7214
    set $P7216, $P7215["Var"]
    $P7217 = $P7216."new"("$/" :named("name"))
.annotate 'line', 2276
    get_hll_global $P7218, "GLOBAL"
    nqp_get_package_through_who $P7219, $P7218, "PAST"
    get_who $P7220, $P7219
    set $P7221, $P7220["Op"]
.annotate 'line', 2277
    get_hll_global $P7222, "GLOBAL"
    nqp_get_package_through_who $P7223, $P7222, "PAST"
    get_who $P7224, $P7223
    set $P7225, $P7224["Var"]
    $P7226 = $P7225."new"(unicode:"$\x{a2}" :named("name"))
    $P7227 = $P7221."new"($P7226, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2276
    $P7228 = $P7212."new"($P7217, $P7227, "bind" :named("pasttype"))
.annotate 'line', 2274
    find_lex $P7229, "$block"
    unless_null $P7229, vivify_2764
    new $P7229, "Undef"
  vivify_2764:
    $P7230 = $P7208."new"($P7228, $P7229)
.annotate 'line', 2273
    store_lex "$past", $P7230
.annotate 'line', 2285
    find_lex $P7231, "$/"
    find_lex $P7232, "$past"
    unless_null $P7232, vivify_2765
    new $P7232, "Undef"
  vivify_2765:
    $P7233 = $P7231."!make"($P7232)
.annotate 'line', 2269
    .return ($P7233)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7254"  :subid("584_1303857440.612") :outer("10_1303857440.612")
.annotate 'line', 2290
    .const 'Sub' $P7259 = "585_1303857440.612" 
    capture_lex $P7259
    .lex "$?PACKAGE", $P7256
    .lex "$?CLASS", $P7257
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2766") :outer("584_1303857440.612")
.annotate 'line', 2290
    .const 'Sub' $P7255 = "584_1303857440.612" 
    .local pmc block
    set block, $P7255
    .const 'Sub' $P7259 = "585_1303857440.612" 
    capture_lex $P7259
    $P7259()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7258"  :anon :subid("585_1303857440.612") :outer("584_1303857440.612")
.annotate 'line', 2290
    nqp_get_sc_object $P7260, "1303857428.33", 5
    .local pmc type_obj
    set type_obj, $P7260
    get_how $P7261, type_obj
    $P7262 = $P7261."compose"(type_obj)
    .return ($P7262)
.end


.HLL "nqp"

.namespace []
.sub "_block7270" :load :anon :subid("586_1303857440.612")
.annotate 'line', 1
    .const 'Sub' $P7272 = "10_1303857440.612" 
    $P7273 = $P7272()
    .return ($P7273)
.end

