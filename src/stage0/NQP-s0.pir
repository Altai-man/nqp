.include 'cclass.pasm'
.include 'except_severity.pasm'
.include 'except_types.pasm'
.include 'iglobals.pasm'
.include 'interpinfo.pasm'
.include 'iterator.pasm'
.include 'sysinfo.pasm'
.include 'stat.pasm'
.include 'datatypes.pasm'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.loadlib "nqp_bigint_ops"

.loadlib "trans_ops"

.loadlib "io_ops"

.namespace []
.sub "_block1000"  :anon :subid("10_1321350766.1143")
    .param pmc param_1002 :slurpy
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P3773 = "636_1321350766.1143" 
    capture_lex $P3773
    .const 'Sub' $P3736 = "628_1321350766.1143" 
    capture_lex $P3736
    .const 'Sub' $P2399 = "446_1321350766.1143" 
    capture_lex $P2399
    .const 'Sub' $P2344 = "425_1321350766.1143" 
    capture_lex $P2344
    .const 'Sub' $P1239 = "46_1321350766.1143" 
    capture_lex $P1239
    .const 'Sub' $P1025 = "13_1321350766.1143" 
    capture_lex $P1025
    .const 'Sub' $P1019 = "12_1321350766.1143" 
    capture_lex $P1019
    .const 'Sub' $P1006 = "11_1321350766.1143" 
    capture_lex $P1006
.annotate 'line', 1
    .lex "@ARGS", param_1002
    .lex "GLOBALish", $P1003
    .lex "$?PACKAGE", $P1004
.annotate 'line', 2820
    .const 'Sub' $P1006 = "11_1321350766.1143" 
    newclosure $P1017, $P1006
    set $P1005, $P1017
    .lex "MAIN", $P1005
.annotate 'line', 2843
    .const 'Sub' $P1019 = "12_1321350766.1143" 
    newclosure $P1023, $P1019
    set $P1018, $P1023
    .lex "hll-config", $P1018
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P1025 = "13_1321350766.1143" 
    capture_lex $P1025
    $P1025()
.annotate 'line', 469
    .const 'Sub' $P1239 = "46_1321350766.1143" 
    capture_lex $P1239
    $P1239()
.annotate 'line', 1201
    .const 'Sub' $P2344 = "425_1321350766.1143" 
    capture_lex $P2344
    $P2344()
.annotate 'line', 1244
    .const 'Sub' $P2399 = "446_1321350766.1143" 
    capture_lex $P2399
    $P2399()
.annotate 'line', 2762
    .const 'Sub' $P3736 = "628_1321350766.1143" 
    capture_lex $P3736
    $P3736()
.annotate 'line', 2817
    .const 'Sub' $P3773 = "636_1321350766.1143" 
    capture_lex $P3773
    $P3773()
.annotate 'line', 1
    find_lex $P103, "MAIN"
    find_lex $P103, "hll-config"
    find_lex $P104, "@ARGS"
    if $P104, if_3776
    set $P103, $P104
    goto if_3776_end
  if_3776:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P105, "ModuleLoader"
    getinterp $P106
    set $P107, $P106["context"]
    $P105."set_mainline_module"($P107)
    .const 'Sub' $P3777 = "11_1321350766.1143" 
    find_lex $P108, "@ARGS"
    $P109 = $P3777($P108 :flat)
    set $P103, $P109
  if_3776_end:
    .return ($P103)
    .const 'Sub' $P3779 = "637_1321350766.1143" 
    .return ($P3779)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post638") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P1001 = "10_1321350766.1143" 
    .local pmc block
    set block, $P1001
    nqp_get_sc $P111, "1321350753.10949"
    isnull $I100, $P111
    if $I100, if_3781
    goto if_3781_end
  if_3781:
    nqp_dynop_setup 
    nqp_bigint_setup 
    getinterp $P112
    get_class $P113, "LexPad"
    get_class $P114, "NQPLexPad"
    $P112."hll_map"($P113, $P114)
    nqp_create_sc $P115, "1321350753.10949"
    .local pmc cur_sc
    set cur_sc, $P115
    cur_sc."set_description"("src/stage2/gen/NQP.pm")
    nqp_get_sc $P116, "__6MODEL_CORE__"
    isnull $I101, $P116
    unless $I101, if_3782_end
    set $S100, "Incorrect pre-compiled version of <unknown> loaded"
    die $S100
  if_3782_end:
    nqp_get_sc_object $P116, "__6MODEL_CORE__", 0
    $P117 = $P116."new_type"("GLOBALish" :named("name"))
    nqp_add_object_to_sc cur_sc, 0, $P117
    .const 'Sub' $P3783 = "10_1321350766.1143" 
    $P116 = $P3783."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 0
    $P116."set_static_lexpad_value"("GLOBALish", $P117)
    .const 'Sub' $P3784 = "10_1321350766.1143" 
    $P118 = $P3784."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P3785 = "10_1321350766.1143" 
    $P116 = $P3785."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 0
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P3786 = "10_1321350766.1143" 
    $P118 = $P3786."get_lexinfo"()
    $P118."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    $P117 = $P116."load_setting"("NQPCORE")
    block."set_outer_ctx"($P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "1321350753.10949", 0
    $P116."load_module"("NQPRegex", $P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "1321350753.10949", 0
    $P116."load_module"("NQPP6Regex", $P117)
    nqp_get_sc $P116, "1321350728.68316"
    isnull $I101, $P116
    unless $I101, if_3787_end
    set $S100, "Incorrect pre-compiled version of src/stage2/gen/nqp-mo.pm loaded"
    die $S100
  if_3787_end:
    nqp_get_sc_object $P116, "1321350728.68316", 55
    $P117 = $P116."new_type"("NQP::SymbolTable" :named("name"))
    nqp_add_object_to_sc cur_sc, 1, $P117
    nqp_get_sc_object $P116, "1321350753.10949", 1
    nqp_get_sc_object $P117, "1321350753.10949", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["SymbolTable"], $P116
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3788 = "14_1321350766.1143" 
    $P117."add_method"($P118, "load_setting", $P3788)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3789 = "16_1321350766.1143" 
    $P117."add_method"($P118, "load_module", $P3789)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3790 = "17_1321350766.1143" 
    $P117."add_method"($P118, "install_package_symbol", $P3790)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3791 = "21_1321350766.1143" 
    $P117."add_method"($P118, "install_lexical_symbol", $P3791)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3792 = "22_1321350766.1143" 
    $P117."add_method"($P118, "install_package_routine", $P3792)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3793 = "23_1321350766.1143" 
    $P117."add_method"($P118, "pkg_create_mo", $P3793)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3794 = "25_1321350766.1143" 
    $P117."add_method"($P118, "pkg_add_attribute", $P3794)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3795 = "29_1321350766.1143" 
    $P117."add_method"($P118, "pkg_add_method", $P3795)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3796 = "32_1321350766.1143" 
    $P117."add_method"($P118, "set_routine_signature", $P3796)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3797 = "33_1321350766.1143" 
    $P117."add_method"($P118, "pkg_set_body_block", $P3797)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3798 = "38_1321350766.1143" 
    $P117."add_method"($P118, "pkg_add_parent_or_role", $P3798)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3799 = "40_1321350766.1143" 
    $P117."add_method"($P118, "pkg_add_parrot_vtable_handler_mapping", $P3799)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3800 = "42_1321350766.1143" 
    $P117."add_method"($P118, "pkg_compose", $P3800)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    .const 'Sub' $P3801 = "44_1321350766.1143" 
    $P117."add_method"($P118, "to_past", $P3801)
    .const 'Sub' $P3802 = "13_1321350766.1143" 
    $P116 = $P3802."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 1
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P3803 = "13_1321350766.1143" 
    $P118 = $P3803."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P3804 = "13_1321350766.1143" 
    $P116 = $P3804."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 1
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P3805 = "13_1321350766.1143" 
    $P118 = $P3805."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc $P116, "1321350735.99463"
    isnull $I101, $P116
    unless $I101, if_3806_end
    set $S100, "Incorrect pre-compiled version of src/stage2/gen/NQPHLL.pm loaded"
    die $S100
  if_3806_end:
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    nqp_get_sc_object $P119, "1321350735.99463", 198
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1321350753.10949", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 1
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1321350728.68316", 55
    $P117 = $P116."new_type"("NQP::Grammar" :named("name"))
    nqp_add_object_to_sc cur_sc, 16, $P117
    nqp_get_sc_object $P116, "1321350753.10949", 16
    nqp_get_sc_object $P117, "1321350753.10949", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Grammar"], $P116
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3807 = "47_1321350766.1143" 
    $P117."add_method"($P118, "TOP", $P3807)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3808 = "48_1321350766.1143" 
    $P117."add_method"($P118, "identifier", $P3808)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3809 = "49_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__identifier", $P3809)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3810 = "50_1321350766.1143" 
    $P117."add_method"($P118, "name", $P3810)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3811 = "51_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__name", $P3811)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3812 = "52_1321350766.1143" 
    $P117."add_method"($P118, "deflongname", $P3812)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3813 = "53_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__deflongname", $P3813)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3814 = "54_1321350766.1143" 
    $P117."add_method"($P118, "ENDSTMT", $P3814)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3815 = "55_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__ENDSTMT", $P3815)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3816 = "56_1321350766.1143" 
    $P117."add_method"($P118, "ws", $P3816)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3817 = "57_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__ws", $P3817)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3818 = "58_1321350766.1143" 
    $P117."add_method"($P118, "unv", $P3818)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3819 = "60_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__unv", $P3819)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3820 = "61_1321350766.1143" 
    $P117."add_method"($P118, "pod_comment", $P3820)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3821 = "63_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__pod_comment", $P3821)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3822 = "64_1321350766.1143" 
    $P117."add_method"($P118, "comp_unit", $P3822)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3823 = "65_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__comp_unit", $P3823)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3824 = "66_1321350766.1143" 
    $P117."add_method"($P118, "statementlist", $P3824)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3825 = "67_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statementlist", $P3825)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3826 = "68_1321350766.1143" 
    $P117."add_method"($P118, "statement", $P3826)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3827 = "70_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement", $P3827)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3828 = "71_1321350766.1143" 
    $P117."add_method"($P118, "eat_terminator", $P3828)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3829 = "72_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__eat_terminator", $P3829)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3830 = "73_1321350766.1143" 
    $P117."add_method"($P118, "xblock", $P3830)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3831 = "74_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__xblock", $P3831)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3832 = "75_1321350766.1143" 
    $P117."add_method"($P118, "pblock", $P3832)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3833 = "76_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__pblock", $P3833)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3834 = "77_1321350766.1143" 
    $P117."add_method"($P118, "lambda", $P3834)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3835 = "78_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__lambda", $P3835)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3836 = "79_1321350766.1143" 
    $P117."add_method"($P118, "block", $P3836)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3837 = "80_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__block", $P3837)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3838 = "81_1321350766.1143" 
    $P117."add_method"($P118, "blockoid", $P3838)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3839 = "82_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__blockoid", $P3839)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3840 = "83_1321350766.1143" 
    $P117."add_method"($P118, "newpad", $P3840)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3841 = "84_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__newpad", $P3841)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3842 = "85_1321350766.1143" 
    $P117."add_method"($P118, "outerctx", $P3842)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3843 = "86_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__outerctx", $P3843)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3844 = "87_1321350766.1143" 
    $P117."add_method"($P118, "GLOBALish", $P3844)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3845 = "88_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__GLOBALish", $P3845)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3846 = "89_1321350766.1143" 
    $P117."add_method"($P118, "finishpad", $P3846)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3847 = "90_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__finishpad", $P3847)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3848 = "91_1321350766.1143" 
    $P117."add_method"($P118, "you_are_here", $P3848)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3849 = "92_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__you_are_here", $P3849)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3850 = "93_1321350766.1143" 
    $P117."add_method"($P118, "terminator", $P3850)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3851 = "94_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__terminator", $P3851)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3852 = "95_1321350766.1143" 
    $P117."add_method"($P118, "terminator:sym<;>", $P3852)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3853 = "96_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<;>", $P3853)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3854 = "97_1321350766.1143" 
    $P117."add_method"($P118, "terminator:sym<}>", $P3854)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3855 = "98_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<}>", $P3855)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3856 = "99_1321350766.1143" 
    $P117."add_method"($P118, "statement_control", $P3856)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3857 = "100_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control", $P3857)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3858 = "101_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P3858)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3859 = "102_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<use>", $P3859)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3860 = "103_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P3860)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3861 = "104_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<if>", $P3861)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3862 = "105_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P3862)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3863 = "107_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<unless>", $P3863)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3864 = "108_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P3864)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3865 = "109_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<while>", $P3865)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3866 = "110_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P3866)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3867 = "111_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<repeat>", $P3867)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3868 = "112_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P3868)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3869 = "113_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<for>", $P3869)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3870 = "114_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P3870)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3871 = "115_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CATCH>", $P3871)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3872 = "116_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P3872)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3873 = "117_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CONTROL>", $P3873)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3874 = "118_1321350766.1143" 
    $P117."add_method"($P118, "statement_prefix", $P3874)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3875 = "119_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix", $P3875)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3876 = "120_1321350766.1143" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P3876)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3877 = "121_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<INIT>", $P3877)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3878 = "122_1321350766.1143" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P3878)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3879 = "123_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<try>", $P3879)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3880 = "124_1321350766.1143" 
    $P117."add_method"($P118, "blorst", $P3880)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3881 = "125_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__blorst", $P3881)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3882 = "126_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_cond", $P3882)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3883 = "127_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond", $P3883)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3884 = "128_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P3884)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3885 = "129_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<if>", $P3885)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3886 = "130_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P3886)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3887 = "131_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<unless>", $P3887)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3888 = "132_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_loop", $P3888)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3889 = "133_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop", $P3889)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3890 = "134_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P3890)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3891 = "135_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<while>", $P3891)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3892 = "136_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P3892)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3893 = "137_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<until>", $P3893)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3894 = "138_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_loop:sym<for>", $P3894)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3895 = "139_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<for>", $P3895)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3896 = "140_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P3896)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3897 = "141_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<fatarrow>", $P3897)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3898 = "142_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P3898)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3899 = "143_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<colonpair>", $P3899)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3900 = "144_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<variable>", $P3900)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3901 = "145_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<variable>", $P3901)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3902 = "146_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P3902)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3903 = "147_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<package_declarator>", $P3903)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3904 = "148_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P3904)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3905 = "149_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<scope_declarator>", $P3905)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3906 = "150_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P3906)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3907 = "151_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<routine_declarator>", $P3907)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3908 = "152_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P3908)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3909 = "155_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<multi_declarator>", $P3909)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3910 = "156_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P3910)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3911 = "157_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<regex_declarator>", $P3911)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3912 = "158_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P3912)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3913 = "159_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<statement_prefix>", $P3913)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3914 = "160_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<lambda>", $P3914)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3915 = "161_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<lambda>", $P3915)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3916 = "162_1321350766.1143" 
    $P117."add_method"($P118, "fatarrow", $P3916)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3917 = "163_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__fatarrow", $P3917)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3918 = "164_1321350766.1143" 
    $P117."add_method"($P118, "colonpair", $P3918)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3919 = "165_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__colonpair", $P3919)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3920 = "166_1321350766.1143" 
    $P117."add_method"($P118, "variable", $P3920)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3921 = "167_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__variable", $P3921)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3922 = "168_1321350766.1143" 
    $P117."add_method"($P118, "sigil", $P3922)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3923 = "169_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__sigil", $P3923)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3924 = "170_1321350766.1143" 
    $P117."add_method"($P118, "twigil", $P3924)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3925 = "171_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__twigil", $P3925)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3926 = "172_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator", $P3926)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3927 = "173_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator", $P3927)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3928 = "174_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P3928)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3929 = "175_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<module>", $P3929)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3930 = "176_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P3930)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3931 = "177_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<knowhow>", $P3931)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3932 = "178_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P3932)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3933 = "179_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<class>", $P3933)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3934 = "180_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P3934)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3935 = "181_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<grammar>", $P3935)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3936 = "182_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P3936)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3937 = "183_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<role>", $P3937)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3938 = "184_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P3938)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3939 = "185_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<native>", $P3939)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3940 = "186_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P3940)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3941 = "187_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<stub>", $P3941)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3942 = "188_1321350766.1143" 
    $P117."add_method"($P118, "package_def", $P3942)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3943 = "190_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__package_def", $P3943)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3944 = "191_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator", $P3944)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3945 = "192_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator", $P3945)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3946 = "193_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P3946)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3947 = "194_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<my>", $P3947)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3948 = "195_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P3948)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3949 = "196_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<our>", $P3949)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3950 = "197_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P3950)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3951 = "198_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<has>", $P3951)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3952 = "199_1321350766.1143" 
    $P117."add_method"($P118, "scoped", $P3952)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3953 = "200_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__scoped", $P3953)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3954 = "201_1321350766.1143" 
    $P117."add_method"($P118, "typename", $P3954)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3955 = "203_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__typename", $P3955)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3956 = "204_1321350766.1143" 
    $P117."add_method"($P118, "declarator", $P3956)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3957 = "205_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__declarator", $P3957)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3958 = "206_1321350766.1143" 
    $P117."add_method"($P118, "variable_declarator", $P3958)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3959 = "208_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__variable_declarator", $P3959)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3960 = "209_1321350766.1143" 
    $P117."add_method"($P118, "routine_declarator", $P3960)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3961 = "210_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator", $P3961)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3962 = "211_1321350766.1143" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P3962)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3963 = "212_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<sub>", $P3963)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3964 = "213_1321350766.1143" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P3964)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3965 = "214_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<method>", $P3965)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3966 = "215_1321350766.1143" 
    $P117."add_method"($P118, "routine_def", $P3966)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3967 = "216_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__routine_def", $P3967)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3968 = "217_1321350766.1143" 
    $P117."add_method"($P118, "method_def", $P3968)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3969 = "219_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__method_def", $P3969)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3970 = "220_1321350766.1143" 
    $P117."add_method"($P118, "onlystar", $P3970)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3971 = "222_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__onlystar", $P3971)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3972 = "223_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator", $P3972)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3973 = "224_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator", $P3973)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3974 = "225_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P3974)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3975 = "226_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<multi>", $P3975)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3976 = "227_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P3976)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3977 = "228_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<proto>", $P3977)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3978 = "229_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P3978)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3979 = "230_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<null>", $P3979)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3980 = "231_1321350766.1143" 
    $P117."add_method"($P118, "signature", $P3980)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3981 = "233_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__signature", $P3981)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3982 = "234_1321350766.1143" 
    $P117."add_method"($P118, "parameter", $P3982)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3983 = "235_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__parameter", $P3983)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3984 = "236_1321350766.1143" 
    $P117."add_method"($P118, "param_var", $P3984)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3985 = "237_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__param_var", $P3985)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3986 = "238_1321350766.1143" 
    $P117."add_method"($P118, "named_param", $P3986)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3987 = "239_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__named_param", $P3987)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3988 = "240_1321350766.1143" 
    $P117."add_method"($P118, "default_value", $P3988)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3989 = "241_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__default_value", $P3989)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3990 = "242_1321350766.1143" 
    $P117."add_method"($P118, "trait", $P3990)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3991 = "243_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__trait", $P3991)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3992 = "244_1321350766.1143" 
    $P117."add_method"($P118, "trait_mod", $P3992)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3993 = "245_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__trait_mod", $P3993)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3994 = "246_1321350766.1143" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P3994)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3995 = "247_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__trait_mod:sym<is>", $P3995)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3996 = "248_1321350766.1143" 
    $P117."add_method"($P118, "regex_declarator", $P3996)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3997 = "249_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__regex_declarator", $P3997)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3998 = "250_1321350766.1143" 
    $P117."add_method"($P118, "dotty", $P3998)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P3999 = "251_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__dotty", $P3999)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4000 = "252_1321350766.1143" 
    $P117."add_method"($P118, "term", $P4000)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4001 = "253_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term", $P4001)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4002 = "254_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<self>", $P4002)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4003 = "255_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<self>", $P4003)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4004 = "256_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<identifier>", $P4004)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4005 = "257_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<identifier>", $P4005)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4006 = "258_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<name>", $P4006)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4007 = "259_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<name>", $P4007)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4008 = "260_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P4008)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4009 = "261_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::op>", $P4009)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4010 = "262_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P4010)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4011 = "263_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::const>", $P4011)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4012 = "264_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P4012)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4013 = "265_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<nqp::op>", $P4013)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4014 = "266_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P4014)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4015 = "268_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<onlystar>", $P4015)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4016 = "269_1321350766.1143" 
    $P117."add_method"($P118, "args", $P4016)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4017 = "270_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__args", $P4017)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4018 = "271_1321350766.1143" 
    $P117."add_method"($P118, "arglist", $P4018)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4019 = "272_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__arglist", $P4019)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4020 = "273_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<value>", $P4020)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4021 = "274_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<value>", $P4021)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4022 = "275_1321350766.1143" 
    $P117."add_method"($P118, "value", $P4022)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4023 = "276_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__value", $P4023)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4024 = "277_1321350766.1143" 
    $P117."add_method"($P118, "number", $P4024)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4025 = "278_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__number", $P4025)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4026 = "279_1321350766.1143" 
    $P117."add_method"($P118, "quote", $P4026)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4027 = "280_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote", $P4027)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4028 = "281_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4028)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4029 = "282_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<apos>", $P4029)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4030 = "283_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4030)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4031 = "284_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<dblq>", $P4031)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4032 = "285_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<q>", $P4032)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4033 = "286_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<q>", $P4033)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4034 = "287_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4034)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4035 = "288_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<qq>", $P4035)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4036 = "289_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4036)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4037 = "290_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q>", $P4037)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4038 = "291_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4038)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4039 = "292_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q:PIR>", $P4039)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4040 = "293_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym</ />", $P4040)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4041 = "294_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote:sym</ />", $P4041)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4042 = "295_1321350766.1143" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4042)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4043 = "296_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<$>", $P4043)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4044 = "297_1321350766.1143" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4044)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4045 = "298_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<{ }>", $P4045)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4046 = "299_1321350766.1143" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4046)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4047 = "300_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<esc>", $P4047)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4048 = "301_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4048)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4049 = "302_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<( )>", $P4049)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4050 = "303_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4050)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4051 = "304_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<[ ]>", $P4051)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4052 = "305_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4052)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4053 = "306_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<ang>", $P4053)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4054 = "307_1321350766.1143" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4054)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4055 = "308_1321350766.1143" 
    $P117."add_method"($P118, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P4055)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4056 = "309_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4056)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4057 = "310_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<{ }>", $P4057)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4058 = "311_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4058)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4059 = "312_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<sigil>", $P4059)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4060 = "313_1321350766.1143" 
    $P117."add_method"($P118, "semilist", $P4060)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4061 = "314_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__semilist", $P4061)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4062 = "315_1321350766.1143" 
    $P117."add_method"($P118, "infixish", $P4062)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4063 = "316_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infixish", $P4063)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4064 = "317_1321350766.1143" 
    $P117."add_method"($P118, "infixstopper", $P4064)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4065 = "318_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infixstopper", $P4065)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4066 = "319_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4066)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4067 = "320_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<[ ]>", $P4067)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4068 = "321_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4068)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4069 = "322_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<{ }>", $P4069)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4070 = "323_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4070)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4071 = "324_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<ang>", $P4071)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4072 = "325_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4072)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4073 = "326_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<( )>", $P4073)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4074 = "327_1321350766.1143" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4074)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4075 = "328_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<.>", $P4075)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4076 = "329_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<++>", $P4076)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4077 = "330_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<++>", $P4077)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4078 = "331_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<-->", $P4078)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4079 = "332_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<-->", $P4079)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4080 = "333_1321350766.1143" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4080)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4081 = "334_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<++>", $P4081)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4082 = "335_1321350766.1143" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4082)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4083 = "336_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<-->", $P4083)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4084 = "337_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<**>", $P4084)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4085 = "338_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<**>", $P4085)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4086 = "339_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<+>", $P4086)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4087 = "340_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<+>", $P4087)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4088 = "341_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<~>", $P4088)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4089 = "342_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<~>", $P4089)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4090 = "343_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<->", $P4090)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4091 = "344_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<->", $P4091)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4092 = "345_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<?>", $P4092)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4093 = "346_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<?>", $P4093)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4094 = "347_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<!>", $P4094)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4095 = "348_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<!>", $P4095)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4096 = "349_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<|>", $P4096)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4097 = "350_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<|>", $P4097)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4098 = "351_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<*>", $P4098)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4099 = "352_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<*>", $P4099)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4100 = "353_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym</>", $P4100)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4101 = "354_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym</>", $P4101)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4102 = "355_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<%>", $P4102)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4103 = "356_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<%>", $P4103)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4104 = "357_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<+&>", $P4104)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4105 = "358_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+&>", $P4105)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4106 = "359_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<+>", $P4106)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4107 = "360_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+>", $P4107)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4108 = "361_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<->", $P4108)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4109 = "362_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<->", $P4109)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4110 = "363_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<+|>", $P4110)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4111 = "364_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+|>", $P4111)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4112 = "365_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<+^>", $P4112)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4113 = "366_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+^>", $P4113)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4114 = "367_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<~>", $P4114)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4115 = "368_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~>", $P4115)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4116 = "369_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<==>", $P4116)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4117 = "370_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<==>", $P4117)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4118 = "371_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<!=>", $P4118)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4119 = "372_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<!=>", $P4119)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4120 = "373_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<<=>", $P4120)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4121 = "374_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<=>", $P4121)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4122 = "375_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<>=>", $P4122)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4123 = "376_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>=>", $P4123)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4124 = "377_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<<>", $P4124)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4125 = "378_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<>", $P4125)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4126 = "379_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<>>", $P4126)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4127 = "380_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>>", $P4127)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4128 = "381_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<eq>", $P4128)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4129 = "382_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<eq>", $P4129)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4130 = "383_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<ne>", $P4130)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4131 = "384_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ne>", $P4131)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4132 = "385_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<le>", $P4132)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4133 = "386_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<le>", $P4133)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4134 = "387_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<ge>", $P4134)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4135 = "388_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ge>", $P4135)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4136 = "389_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<lt>", $P4136)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4137 = "390_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<lt>", $P4137)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4138 = "391_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<gt>", $P4138)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4139 = "392_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<gt>", $P4139)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4140 = "393_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<=:=>", $P4140)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4141 = "394_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=:=>", $P4141)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4142 = "395_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4142)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4143 = "396_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~~>", $P4143)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4144 = "397_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<&&>", $P4144)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4145 = "398_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<&&>", $P4145)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4146 = "399_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<||>", $P4146)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4147 = "400_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<||>", $P4147)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4148 = "401_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<//>", $P4148)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4149 = "402_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<//>", $P4149)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4150 = "403_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<?? !!>", $P4150)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4151 = "404_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<?? !!>", $P4151)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4152 = "405_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<=>", $P4152)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4153 = "406_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=>", $P4153)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4154 = "407_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<:=>", $P4154)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4155 = "408_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<:=>", $P4155)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4156 = "409_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<::=>", $P4156)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4157 = "410_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<::=>", $P4157)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4158 = "411_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<,>", $P4158)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4159 = "412_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<,>", $P4159)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4160 = "413_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<return>", $P4160)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4161 = "415_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<return>", $P4161)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4162 = "416_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4162)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4163 = "417_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<make>", $P4163)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4164 = "418_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<last>", $P4164)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4165 = "419_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<last>", $P4165)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4166 = "420_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<next>", $P4166)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4167 = "421_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<next>", $P4167)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4168 = "422_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<redo>", $P4168)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4169 = "423_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__term:sym<redo>", $P4169)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    .const 'Sub' $P4170 = "424_1321350766.1143" 
    $P117."add_method"($P118, "smartmatch", $P4170)
    .const 'Sub' $P4171 = "46_1321350766.1143" 
    $P116 = $P4171."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 16
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4172 = "46_1321350766.1143" 
    $P118 = $P4172."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4173 = "46_1321350766.1143" 
    $P116 = $P4173."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 16
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4174 = "46_1321350766.1143" 
    $P118 = $P4174."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    nqp_get_sc_object $P119, "1321350735.99463", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1321350753.10949", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 16
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1321350728.68316", 55
    $P117 = $P116."new_type"("NQP::Regex" :named("name"))
    nqp_add_object_to_sc cur_sc, 381, $P117
    nqp_get_sc_object $P116, "1321350753.10949", 381
    nqp_get_sc_object $P117, "1321350753.10949", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Regex"], $P116
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4175 = "426_1321350766.1143" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4175)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4176 = "428_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<:my>", $P4176)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4177 = "429_1321350766.1143" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4177)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4178 = "430_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<{ }>", $P4178)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4179 = "431_1321350766.1143" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4179)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4180 = "433_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<nqpvar>", $P4180)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4181 = "434_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4181)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4182 = "435_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<{ }>", $P4182)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4183 = "436_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4183)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4184 = "438_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<?{ }>", $P4184)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4185 = "439_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<name>", $P4185)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4186 = "441_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<name>", $P4186)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4187 = "442_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4187)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4188 = "443_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<var>", $P4188)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4189 = "444_1321350766.1143" 
    $P117."add_method"($P118, "codeblock", $P4189)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    .const 'Sub' $P4190 = "445_1321350766.1143" 
    $P117."add_method"($P118, "!PREFIX__codeblock", $P4190)
    .const 'Sub' $P4191 = "425_1321350766.1143" 
    $P116 = $P4191."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 381
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4192 = "425_1321350766.1143" 
    $P118 = $P4192."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4193 = "425_1321350766.1143" 
    $P116 = $P4193."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 381
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4194 = "425_1321350766.1143" 
    $P118 = $P4194."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc $P116, "1321350746.2706"
    isnull $I101, $P116
    unless $I101, if_4195_end
    set $S100, "Incorrect pre-compiled version of src/stage2/gen/NQPP6Regex.pm loaded"
    die $S100
  if_4195_end:
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    nqp_get_sc_object $P119, "1321350746.2706", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1321350753.10949", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 381
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1321350728.68316", 55
    $P117 = $P116."new_type"("NQP::Actions" :named("name"))
    nqp_add_object_to_sc cur_sc, 398, $P117
    nqp_get_sc_object $P116, "1321350753.10949", 398
    nqp_get_sc_object $P117, "1321350753.10949", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Actions"], $P116
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4196 = "473_1321350766.1143" 
    $P117."add_method"($P118, "TOP", $P4196)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4197 = "474_1321350766.1143" 
    $P117."add_method"($P118, "deflongname", $P4197)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4198 = "475_1321350766.1143" 
    $P117."add_method"($P118, "comp_unit", $P4198)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4199 = "477_1321350766.1143" 
    $P117."add_method"($P118, "statementlist", $P4199)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4200 = "479_1321350766.1143" 
    $P117."add_method"($P118, "statement", $P4200)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4201 = "481_1321350766.1143" 
    $P117."add_method"($P118, "xblock", $P4201)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4202 = "482_1321350766.1143" 
    $P117."add_method"($P118, "pblock", $P4202)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4203 = "483_1321350766.1143" 
    $P117."add_method"($P118, "block", $P4203)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4204 = "484_1321350766.1143" 
    $P117."add_method"($P118, "blockoid", $P4204)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4205 = "486_1321350766.1143" 
    $P117."add_method"($P118, "newpad", $P4205)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4206 = "487_1321350766.1143" 
    $P117."add_method"($P118, "outerctx", $P4206)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4207 = "489_1321350766.1143" 
    $P117."add_method"($P118, "GLOBALish", $P4207)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4208 = "490_1321350766.1143" 
    $P117."add_method"($P118, "you_are_here", $P4208)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4209 = "491_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P4209)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4210 = "492_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P4210)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4211 = "494_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P4211)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4212 = "495_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P4212)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4213 = "496_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P4213)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4214 = "497_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P4214)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4215 = "498_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P4215)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4216 = "499_1321350766.1143" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P4216)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4217 = "500_1321350766.1143" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P4217)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4218 = "501_1321350766.1143" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P4218)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4219 = "502_1321350766.1143" 
    $P117."add_method"($P118, "blorst", $P4219)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4220 = "503_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P4220)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4221 = "504_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P4221)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4222 = "505_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P4222)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4223 = "506_1321350766.1143" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P4223)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4224 = "507_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P4224)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4225 = "508_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P4225)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4226 = "509_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<variable>", $P4226)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4227 = "510_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P4227)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4228 = "511_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P4228)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4229 = "512_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P4229)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4230 = "513_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P4230)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4231 = "514_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P4231)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4232 = "515_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<lambda>", $P4232)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4233 = "516_1321350766.1143" 
    $P117."add_method"($P118, "fatarrow", $P4233)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4234 = "517_1321350766.1143" 
    $P117."add_method"($P118, "colonpair", $P4234)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4235 = "518_1321350766.1143" 
    $P117."add_method"($P118, "variable", $P4235)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4236 = "524_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P4236)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4237 = "525_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P4237)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4238 = "526_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P4238)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4239 = "527_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P4239)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4240 = "528_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P4240)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4241 = "529_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P4241)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4242 = "530_1321350766.1143" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P4242)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4243 = "531_1321350766.1143" 
    $P117."add_method"($P118, "package_def", $P4243)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4244 = "537_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P4244)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4245 = "538_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P4245)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4246 = "539_1321350766.1143" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P4246)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4247 = "540_1321350766.1143" 
    $P117."add_method"($P118, "scoped", $P4247)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4248 = "541_1321350766.1143" 
    $P117."add_method"($P118, "declarator", $P4248)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4249 = "542_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P4249)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4250 = "543_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P4250)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4251 = "544_1321350766.1143" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P4251)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4252 = "545_1321350766.1143" 
    $P117."add_method"($P118, "variable_declarator", $P4252)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4253 = "548_1321350766.1143" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P4253)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4254 = "549_1321350766.1143" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P4254)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4255 = "550_1321350766.1143" 
    $P117."add_method"($P118, "routine_def", $P4255)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4256 = "557_1321350766.1143" 
    $P117."add_method"($P118, "method_def", $P4256)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4257 = "560_1321350766.1143" 
    $P117."add_method"($P118, "signature", $P4257)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4258 = "563_1321350766.1143" 
    $P117."add_method"($P118, "parameter", $P4258)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4259 = "564_1321350766.1143" 
    $P117."add_method"($P118, "param_var", $P4259)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4260 = "565_1321350766.1143" 
    $P117."add_method"($P118, "named_param", $P4260)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4261 = "566_1321350766.1143" 
    $P117."add_method"($P118, "typename", $P4261)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4262 = "568_1321350766.1143" 
    $P117."add_method"($P118, "trait", $P4262)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4263 = "569_1321350766.1143" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P4263)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4264 = "574_1321350766.1143" 
    $P117."add_method"($P118, "regex_declarator", $P4264)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4265 = "579_1321350766.1143" 
    $P117."add_method"($P118, "dotty", $P4265)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4266 = "580_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<self>", $P4266)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4267 = "581_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<identifier>", $P4267)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4268 = "582_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<name>", $P4268)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4269 = "584_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P4269)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4270 = "585_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P4270)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4271 = "586_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P4271)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4272 = "587_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P4272)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4273 = "588_1321350766.1143" 
    $P117."add_method"($P118, "args", $P4273)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4274 = "589_1321350766.1143" 
    $P117."add_method"($P118, "arglist", $P4274)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4275 = "592_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P4275)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4276 = "593_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<value>", $P4276)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4277 = "594_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4277)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4278 = "595_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4278)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4279 = "596_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4279)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4280 = "597_1321350766.1143" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4280)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4281 = "598_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4281)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4282 = "600_1321350766.1143" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4282)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4283 = "601_1321350766.1143" 
    $P117."add_method"($P118, "semilist", $P4283)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4284 = "602_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4284)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4285 = "603_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4285)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4286 = "604_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4286)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4287 = "605_1321350766.1143" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4287)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4288 = "606_1321350766.1143" 
    $P117."add_method"($P118, "value", $P4288)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4289 = "607_1321350766.1143" 
    $P117."add_method"($P118, "number", $P4289)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4290 = "608_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4290)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4291 = "609_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4291)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4292 = "610_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4292)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4293 = "611_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<q>", $P4293)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4294 = "612_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4294)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4295 = "613_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4295)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4296 = "614_1321350766.1143" 
    $P117."add_method"($P118, "quote:sym</ />", $P4296)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4297 = "615_1321350766.1143" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4297)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4298 = "616_1321350766.1143" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4298)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4299 = "617_1321350766.1143" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4299)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4300 = "618_1321350766.1143" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4300)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4301 = "619_1321350766.1143" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4301)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4302 = "620_1321350766.1143" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4302)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4303 = "621_1321350766.1143" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4303)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4304 = "622_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<next>", $P4304)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4305 = "623_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<last>", $P4305)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4306 = "624_1321350766.1143" 
    $P117."add_method"($P118, "term:sym<redo>", $P4306)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4307 = "625_1321350766.1143" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4307)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    .const 'Sub' $P4308 = "626_1321350766.1143" 
    $P117."add_method"($P118, "known_sym", $P4308)
    .const 'Sub' $P4309 = "446_1321350766.1143" 
    $P116 = $P4309."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 398
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4310 = "446_1321350766.1143" 
    $P118 = $P4310."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4311 = "446_1321350766.1143" 
    $P116 = $P4311."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 398
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4312 = "446_1321350766.1143" 
    $P118 = $P4312."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    nqp_get_sc_object $P119, "1321350735.99463", 105
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1321350753.10949", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 398
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1321350728.68316", 55
    $P117 = $P116."new_type"("NQP::RegexActions" :named("name"))
    nqp_add_object_to_sc cur_sc, 512, $P117
    nqp_get_sc_object $P116, "1321350753.10949", 512
    nqp_get_sc_object $P117, "1321350753.10949", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["RegexActions"], $P116
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4313 = "629_1321350766.1143" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4313)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4314 = "630_1321350766.1143" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4314)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4315 = "631_1321350766.1143" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4315)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4316 = "632_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4316)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4317 = "633_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4317)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4318 = "634_1321350766.1143" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4318)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    .const 'Sub' $P4319 = "635_1321350766.1143" 
    $P117."add_method"($P118, "codeblock", $P4319)
    .const 'Sub' $P4320 = "628_1321350766.1143" 
    $P116 = $P4320."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 512
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4321 = "628_1321350766.1143" 
    $P118 = $P4321."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4322 = "628_1321350766.1143" 
    $P116 = $P4322."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 512
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4323 = "628_1321350766.1143" 
    $P118 = $P4323."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    nqp_get_sc_object $P119, "1321350746.2706", 145
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1321350753.10949", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 512
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "1321350728.68316", 55
    $P117 = $P116."new_type"("NQP::Compiler" :named("name"))
    nqp_add_object_to_sc cur_sc, 520, $P117
    nqp_get_sc_object $P116, "1321350753.10949", 520
    nqp_get_sc_object $P117, "1321350753.10949", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Compiler"], $P116
    .const 'Sub' $P4324 = "636_1321350766.1143" 
    $P116 = $P4324."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 520
    $P116."set_static_lexpad_value"("$?PACKAGE", $P117)
    .const 'Sub' $P4325 = "636_1321350766.1143" 
    $P118 = $P4325."get_lexinfo"()
    $P118."finish_static_lexpad"()
    .const 'Sub' $P4326 = "636_1321350766.1143" 
    $P116 = $P4326."get_lexinfo"()
    nqp_get_sc_object $P117, "1321350753.10949", 520
    $P116."set_static_lexpad_value"("$?CLASS", $P117)
    .const 'Sub' $P4327 = "636_1321350766.1143" 
    $P118 = $P4327."get_lexinfo"()
    $P118."finish_static_lexpad"()
    nqp_get_sc_object $P116, "1321350753.10949", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 520
    nqp_get_sc_object $P119, "1321350735.99463", 139
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "1321350753.10949", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "1321350753.10949", 520
    $P117."compose"($P118)
  if_3781_end:
    nqp_get_sc_object $P116, "1321350753.10949", 0
    set_hll_global "GLOBAL", $P116
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1321350766.1143") :outer("10_1321350766.1143")
    .param pmc param_1007
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2820
    .lex "@ARGS", param_1007
.annotate 'line', 2822
    new $P100, "Undef"
    set $P1008, $P100
    .lex "$nqpcomp", $P1008
.annotate 'line', 2829
    $P1010 = root_new ['parrot';'ResizablePMCArray']
    set $P1009, $P1010
    .lex "@clo", $P1009
.annotate 'line', 2822
    get_hll_global $P101, "GLOBAL"
    nqp_get_package_through_who $P102, $P101, "NQP"
    get_who $P103, $P102
    set $P104, $P103["Compiler"]
    $P105 = $P104."new"()
    store_lex "$nqpcomp", $P105
.annotate 'line', 2823
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_639
    new $P101, "Undef"
  vivify_639:
    $P101."language"("nqp")
.annotate 'line', 2824
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_640
    new $P101, "Undef"
  vivify_640:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P101."parsegrammar"($P105)
.annotate 'line', 2825
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_641
    new $P101, "Undef"
  vivify_641:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Actions"]
    $P101."parseactions"($P105)
.annotate 'line', 2826
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_642
    new $P101, "Undef"
  vivify_642:
    $P102 = $P101."config"()
    "hll-config"($P102)
.annotate 'line', 2829
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_643
    new $P101, "Undef"
  vivify_643:
    $P102 = $P101."commandline_options"()
    store_lex "@clo", $P102
.annotate 'line', 2830
    find_lex $P1011, "@clo"
    unless_null $P1011, vivify_644
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_644:
    $P1011."push"("parsetrace")
.annotate 'line', 2831
    find_lex $P1012, "@clo"
    unless_null $P1012, vivify_645
    $P1012 = root_new ['parrot';'ResizablePMCArray']
  vivify_645:
    $P1012."push"("setting=s")
.annotate 'line', 2832
    find_lex $P1013, "@clo"
    unless_null $P1013, vivify_646
    $P1013 = root_new ['parrot';'ResizablePMCArray']
  vivify_646:
    $P1013."push"("setting-path=s")
.annotate 'line', 2833
    find_lex $P1014, "@clo"
    unless_null $P1014, vivify_647
    $P1014 = root_new ['parrot';'ResizablePMCArray']
  vivify_647:
    $P1014."push"("module-path=s")
.annotate 'line', 2834
    find_lex $P1015, "@clo"
    unless_null $P1015, vivify_648
    $P1015 = root_new ['parrot';'ResizablePMCArray']
  vivify_648:
    $P1015."push"("vmlibs=s")
.annotate 'line', 2837
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_649
    new $P101, "Undef"
  vivify_649:
    find_lex $P1016, "@ARGS"
    unless_null $P1016, vivify_650
    $P1016 = root_new ['parrot';'ResizablePMCArray']
  vivify_650:
    $P101."command_line"($P1016, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2839
    find_lex $P101, "$nqpcomp"
    unless_null $P101, vivify_651
    new $P101, "Undef"
  vivify_651:
    $P102 = $P101."nqpevent"()
.annotate 'line', 2820
    .return ($P102)
.end


.HLL "nqp"

.namespace []
.sub "hll-config"  :subid("12_1321350766.1143") :outer("10_1321350766.1143")
    .param pmc param_1020
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2843
    .lex "$config", param_1020
.annotate 'line', 2844
    new $P101, "String"
    assign $P101, "2011.10-121-gd554f1d"
    find_lex $P1021, "$config"
    unless_null $P1021, vivify_652
    $P1021 = root_new ['parrot';'Hash']
    store_lex "$config", $P1021
  vivify_652:
    set $P1021["version"], $P101
.annotate 'line', 2845
    new $P101, "String"
    assign $P101, "2011-11-15T09:52:32Z"
    find_lex $P1022, "$config"
    unless_null $P1022, vivify_653
    $P1022 = root_new ['parrot';'Hash']
    store_lex "$config", $P1022
  vivify_653:
    set $P1022["build-date"], $P101
.annotate 'line', 2843
    .return ($P101)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1024"  :subid("13_1321350766.1143") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 9
    .const 'Sub' $P1227 = "44_1321350766.1143" 
    capture_lex $P1227
    .const 'Sub' $P1220 = "42_1321350766.1143" 
    capture_lex $P1220
    .const 'Sub' $P1211 = "40_1321350766.1143" 
    capture_lex $P1211
    .const 'Sub' $P1202 = "38_1321350766.1143" 
    capture_lex $P1202
    .const 'Sub' $P1175 = "33_1321350766.1143" 
    capture_lex $P1175
    .const 'Sub' $P1165 = "32_1321350766.1143" 
    capture_lex $P1165
    .const 'Sub' $P1136 = "29_1321350766.1143" 
    capture_lex $P1136
    .const 'Sub' $P1111 = "25_1321350766.1143" 
    capture_lex $P1111
    .const 'Sub' $P1084 = "23_1321350766.1143" 
    capture_lex $P1084
    .const 'Sub' $P1078 = "22_1321350766.1143" 
    capture_lex $P1078
    .const 'Sub' $P1071 = "21_1321350766.1143" 
    capture_lex $P1071
    .const 'Sub' $P1048 = "17_1321350766.1143" 
    capture_lex $P1048
    .const 'Sub' $P1040 = "16_1321350766.1143" 
    capture_lex $P1040
    .const 'Sub' $P1029 = "14_1321350766.1143" 
    capture_lex $P1029
.annotate 'line', 14
    new $P103, "Undef"
    set $P1026, $P103
    .lex "$loader", $P1026
    .lex "$?PACKAGE", $P1027
    .lex "$?CLASS", $P1028
    get_hll_global $P104, "ModuleLoader"
    store_lex "$loader", $P104
.annotate 'line', 429
    .const 'Sub' $P1227 = "44_1321350766.1143" 
    newclosure $P1237, $P1227
.annotate 'line', 9
    .return ($P1237)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("14_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1032
    .param pmc param_1033
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 17
    .const 'Sub' $P1036 = "15_1321350766.1143" 
    capture_lex $P1036
    new $P1031, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1031, control_1030
    push_eh $P1031
    .lex "self", param_1032
    .lex "$setting_name", param_1033
.annotate 'line', 19
    find_lex $P105, "$setting_name"
    unless_null $P105, vivify_654
    new $P105, "Undef"
  vivify_654:
    set $S100, $P105
    isne $I100, $S100, "NULL"
    if $I100, if_1034
    new $P104, 'Integer'
    set $P104, $I100
    goto if_1034_end
  if_1034:
    .const 'Sub' $P1036 = "15_1321350766.1143" 
    capture_lex $P1036
    $P107 = $P1036()
    set $P104, $P107
  if_1034_end:
.annotate 'line', 17
    .return ($P104)
  control_1030:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1035"  :anon :subid("15_1321350766.1143") :outer("14_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 23
    new $P106, "Undef"
    set $P1037, $P106
    .lex "$setting", $P1037
.annotate 'line', 24
    find_lex $P107, "$loader"
    unless_null $P107, vivify_655
    new $P107, "Undef"
  vivify_655:
    find_lex $P108, "$setting_name"
    unless_null $P108, vivify_656
    new $P108, "Undef"
  vivify_656:
    $P109 = $P107."load_setting"($P108)
    find_dynamic_lex $P112, "%*COMPILING"
    unless_null $P112, vivify_657
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%COMPILING"]
    unless_null $P112, vivify_658
    die "Contextual %*COMPILING not found"
  vivify_658:
    store_dynamic_lex "%*COMPILING", $P112
  vivify_657:
    set $P1038, $P112["%?OPTIONS"]
    unless_null $P1038, vivify_659
    $P1038 = root_new ['parrot';'Hash']
    set $P112["%?OPTIONS"], $P1038
  vivify_659:
    set $P1038["outer_ctx"], $P109
    store_lex "$setting", $P109
.annotate 'line', 27
    find_lex $P107, "self"
    $P108 = $P107."is_precompilation_mode"()
    if $P108, if_1039
.annotate 'line', 45
    find_lex $P109, "self"
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
.annotate 'line', 47
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Var"]
    $P118 = $P117."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 48
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Op"]
.annotate 'line', 50
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Var"]
    new $P127, "ResizablePMCArray"
    $P128 = $P126."new"("ModuleLoader" :named("name"), $P127 :named("namespace"), "package" :named("scope"))
    find_lex $P129, "$setting_name"
    unless_null $P129, vivify_660
    new $P129, "Undef"
  vivify_660:
    $P130 = $P122."new"($P128, $P129, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 48
    $P131 = $P113."new"($P118, $P130, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 45
    $P109."add_event"($P131 :named("fixup_past"))
.annotate 'line', 43
    goto if_1039_end
  if_1039:
.annotate 'line', 28
    find_lex $P109, "self"
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Stmts"]
.annotate 'line', 29
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    $P118 = $P117."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 32
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Op"]
.annotate 'line', 34
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Var"]
    $P127 = $P126."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 35
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
.annotate 'line', 37
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    new $P136, "ResizablePMCArray"
    $P137 = $P135."new"("ModuleLoader" :named("name"), $P136 :named("namespace"), "package" :named("scope"))
    find_lex $P138, "$setting_name"
    unless_null $P138, vivify_661
    new $P138, "Undef"
  vivify_661:
    $P139 = $P131."new"($P137, $P138, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 35
    $P140 = $P122."new"($P127, $P139, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 32
    $P141 = $P113."new"($P118, $P140)
.annotate 'line', 28
    $P109."add_event"($P141 :named("deserialize_past"))
  if_1039_end:
.annotate 'line', 56
    new $P107, "Exception"
    set $P107['type'], .CONTROL_RETURN
    find_lex $P108, "$setting"
    unless_null $P108, vivify_662
    new $P108, "Undef"
  vivify_662:
    getattribute $P109, $P108, "lex_pad"
    setattribute $P107, 'payload', $P109
    throw $P107
.annotate 'line', 19
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("16_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1043
    .param pmc param_1044
    .param pmc param_1045
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 62
    new $P1042, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1042, control_1041
    push_eh $P1042
    .lex "self", param_1043
    .lex "$module_name", param_1044
    .lex "$cur_GLOBALish", param_1045
.annotate 'line', 64
    new $P104, "Undef"
    set $P1046, $P104
    .lex "$module", $P1046
    find_lex $P105, "$loader"
    unless_null $P105, vivify_663
    new $P105, "Undef"
  vivify_663:
    find_lex $P106, "$module_name"
    unless_null $P106, vivify_664
    new $P106, "Undef"
  vivify_664:
    find_lex $P107, "$cur_GLOBALish"
    unless_null $P107, vivify_665
    new $P107, "Undef"
  vivify_665:
    $P108 = $P105."load_module"($P106, $P107)
    store_lex "$module", $P108
.annotate 'line', 67
    find_lex $P105, "self"
    $P106 = $P105."is_precompilation_mode"()
    unless $P106, if_1047_end
.annotate 'line', 68
    find_lex $P107, "self"
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
.annotate 'line', 69
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 72
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Op"]
.annotate 'line', 74
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Var"]
    new $P125, "ResizablePMCArray"
    $P126 = $P124."new"("ModuleLoader" :named("name"), $P125 :named("namespace"), "package" :named("scope"))
    find_lex $P127, "$module_name"
    unless_null $P127, vivify_666
    new $P127, "Undef"
  vivify_666:
.annotate 'line', 76
    find_lex $P128, "self"
    find_lex $P129, "$cur_GLOBALish"
    unless_null $P129, vivify_667
    new $P129, "Undef"
  vivify_667:
    $P130 = $P128."get_slot_past_for_object"($P129)
    $P131 = $P120."new"($P126, $P127, $P130, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 72
    $P132 = $P111."new"($P116, $P131)
.annotate 'line', 68
    $P107."add_event"($P132 :named("deserialize_past"))
  if_1047_end:
.annotate 'line', 80
    new $P105, "Exception"
    set $P105['type'], .CONTROL_RETURN
    find_lex $P106, "$module"
    unless_null $P106, vivify_668
    new $P106, "Undef"
  vivify_668:
    getattribute $P107, $P106, "lex_pad"
    setattribute $P105, 'payload', $P107
    throw $P105
.annotate 'line', 62
    .return ()
  control_1041:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("17_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1049
    .param pmc param_1050
    .param pmc param_1051
    .param pmc param_1052
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 85
    .const 'Sub' $P1064 = "19_1321350766.1143" 
    capture_lex $P1064
    .const 'Sub' $P1059 = "18_1321350766.1143" 
    capture_lex $P1059
    .lex "self", param_1049
    .lex "$package", param_1050
    .lex "@sym", param_1051
    .lex "$obj", param_1052
.annotate 'line', 87
    new $P104, "Undef"
    set $P1053, $P104
    .lex "$name", $P1053
.annotate 'line', 90
    new $P105, "Undef"
    set $P1054, $P105
    .lex "$target", $P1054
.annotate 'line', 86
    find_lex $P1055, "@sym"
    unless_null $P1055, vivify_669
    $P1055 = root_new ['parrot';'ResizablePMCArray']
  vivify_669:
    clone $P106, $P1055
    store_lex "@sym", $P106
.annotate 'line', 87
    find_lex $P1056, "@sym"
    unless_null $P1056, vivify_670
    $P1056 = root_new ['parrot';'ResizablePMCArray']
  vivify_670:
    $P106 = $P1056."pop"()
    set $S100, $P106
    new $P107, 'String'
    set $P107, $S100
    store_lex "$name", $P107
.annotate 'line', 90
    find_lex $P106, "$package"
    unless_null $P106, vivify_671
    new $P106, "Undef"
  vivify_671:
    store_lex "$target", $P106
.annotate 'line', 91
    find_lex $P1057, "@sym"
    unless_null $P1057, vivify_672
    $P1057 = root_new ['parrot';'ResizablePMCArray']
  vivify_672:
    defined $I100, $P1057
    unless $I100, for_undef_673
    iter $P106, $P1057
    new $P108, 'ExceptionHandler'
    set_label $P108, loop1061_handler
    $P108."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P108
  loop1061_test:
    unless $P106, loop1061_done
    shift $P107, $P106
  loop1061_redo:
    .const 'Sub' $P1059 = "18_1321350766.1143" 
    capture_lex $P1059
    $P1059($P107)
  loop1061_next:
    goto loop1061_test
  loop1061_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P109, exception, 'type'
    eq $P109, .CONTROL_LOOP_NEXT, loop1061_next
    eq $P109, .CONTROL_LOOP_REDO, loop1061_redo
  loop1061_done:
    pop_eh 
  for_undef_673:
.annotate 'line', 94
    find_lex $P106, "$obj"
    unless_null $P106, vivify_676
    new $P106, "Undef"
  vivify_676:
    find_lex $P107, "$name"
    unless_null $P107, vivify_677
    new $P107, "Undef"
  vivify_677:
    find_lex $P108, "$target"
    unless_null $P108, vivify_678
    new $P108, "Undef"
    store_lex "$target", $P108
  vivify_678:
    get_who $P109, $P108
    set $P109[$P107], $P106
.annotate 'line', 97
    find_lex $P107, "self"
    $P108 = $P107."is_precompilation_mode"()
    if $P108, if_1062
    set $P106, $P108
    goto if_1062_end
  if_1062:
    .const 'Sub' $P1064 = "19_1321350766.1143" 
    capture_lex $P1064
    $P110 = $P1064()
    set $P106, $P110
  if_1062_end:
.annotate 'line', 85
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1058"  :anon :subid("18_1321350766.1143") :outer("17_1321350766.1143")
    .param pmc param_1060
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 91
    .lex "$_", param_1060
.annotate 'line', 92
    find_lex $P108, "$target"
    unless_null $P108, vivify_674
    new $P108, "Undef"
  vivify_674:
    find_lex $P109, "$_"
    unless_null $P109, vivify_675
    new $P109, "Undef"
  vivify_675:
    set $S100, $P109
    nqp_get_package_through_who $P110, $P108, $S100
    store_lex "$target", $P110
.annotate 'line', 91
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1063"  :anon :subid("19_1321350766.1143") :outer("17_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 97
    .const 'Sub' $P1068 = "20_1321350766.1143" 
    capture_lex $P1068
.annotate 'line', 98
    new $P109, "Undef"
    set $P1065, $P109
    .lex "$path", $P1065
    find_lex $P110, "self"
    find_lex $P111, "$package"
    unless_null $P111, vivify_679
    new $P111, "Undef"
  vivify_679:
    $P112 = $P110."get_slot_past_for_object"($P111)
    store_lex "$path", $P112
.annotate 'line', 99
    find_lex $P1066, "@sym"
    unless_null $P1066, vivify_680
    $P1066 = root_new ['parrot';'ResizablePMCArray']
  vivify_680:
    defined $I100, $P1066
    unless $I100, for_undef_681
    iter $P110, $P1066
    new $P112, 'ExceptionHandler'
    set_label $P112, loop1070_handler
    $P112."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P112
  loop1070_test:
    unless $P110, loop1070_done
    shift $P111, $P110
  loop1070_redo:
    .const 'Sub' $P1068 = "20_1321350766.1143" 
    capture_lex $P1068
    $P1068($P111)
  loop1070_next:
    goto loop1070_test
  loop1070_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P113, exception, 'type'
    eq $P113, .CONTROL_LOOP_NEXT, loop1070_next
    eq $P113, .CONTROL_LOOP_REDO, loop1070_redo
  loop1070_done:
    pop_eh 
  for_undef_681:
.annotate 'line', 102
    find_lex $P110, "self"
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 104
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Var"]
.annotate 'line', 106
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Op"]
    find_lex $P123, "$path"
    unless_null $P123, vivify_684
    new $P123, "Undef"
  vivify_684:
    $P124 = $P122."new"($P123, "get_who PP" :named("pirop"))
    find_lex $P125, "$name"
    unless_null $P125, vivify_685
    new $P125, "Undef"
  vivify_685:
    $P126 = $P118."new"($P124, $P125, "keyed" :named("scope"))
.annotate 'line', 109
    find_lex $P127, "self"
    find_lex $P128, "$obj"
    unless_null $P128, vivify_686
    new $P128, "Undef"
  vivify_686:
    $P129 = $P127."get_slot_past_for_object"($P128)
    $P130 = $P114."new"($P126, $P129, "bind_6model" :named("pasttype"))
.annotate 'line', 102
    $P131 = $P110."add_event"($P130 :named("deserialize_past"))
.annotate 'line', 97
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1067"  :anon :subid("20_1321350766.1143") :outer("19_1321350766.1143")
    .param pmc param_1069
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 99
    .lex "$_", param_1069
.annotate 'line', 100
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    find_lex $P116, "$path"
    unless_null $P116, vivify_682
    new $P116, "Undef"
  vivify_682:
    find_lex $P117, "$_"
    unless_null $P117, vivify_683
    new $P117, "Undef"
  vivify_683:
    set $S100, $P117
    $P118 = $P115."new"($P116, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P118
.annotate 'line', 99
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol" :anon :subid("21_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1072
    .param pmc param_1073
    .param pmc param_1074
    .param pmc param_1075
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 118
    .lex "self", param_1072
    .lex "$block", param_1073
    .lex "$name", param_1074
    .lex "$obj", param_1075
.annotate 'line', 124
    new $P104, "Undef"
    set $P1076, $P104
    .lex "$fixup", $P1076
.annotate 'line', 120
    find_lex $P105, "$block"
    unless_null $P105, vivify_687
    new $P105, "Undef"
  vivify_687:
    find_lex $P106, "$name"
    unless_null $P106, vivify_688
    new $P106, "Undef"
  vivify_688:
    find_lex $P107, "$obj"
    unless_null $P107, vivify_689
    new $P107, "Undef"
  vivify_689:
    $P105."symbol"($P106, "lexical" :named("scope"), $P107 :named("value"))
.annotate 'line', 121
    new $P105, "Float"
    assign $P105, 0
    set $I100, $P105
    find_lex $P1077, "$block"
    unless_null $P1077, vivify_690
    $P1077 = root_new ['parrot';'ResizablePMCArray']
  vivify_690:
    set $P106, $P1077[$I100]
    unless_null $P106, vivify_691
    new $P106, "Undef"
  vivify_691:
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Var"]
    find_lex $P111, "$name"
    unless_null $P111, vivify_692
    new $P111, "Undef"
  vivify_692:
    $P112 = $P110."new"("lexical" :named("scope"), $P111 :named("name"), 1 :named("isdecl"))
    $P106."push"($P112)
.annotate 'line', 124
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 125
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 127
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
.annotate 'line', 129
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Val"]
    find_lex $P121, "$block"
    unless_null $P121, vivify_693
    new $P121, "Undef"
  vivify_693:
    $P122 = $P120."new"($P121 :named("value"))
    $P123 = $P116."new"($P122, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 131
    find_lex $P124, "$name"
    unless_null $P124, vivify_694
    new $P124, "Undef"
  vivify_694:
    set $S100, $P124
    find_lex $P125, "self"
    find_lex $P126, "$obj"
    unless_null $P126, vivify_695
    new $P126, "Undef"
  vivify_695:
    $P127 = $P125."get_slot_past_for_object"($P126)
    $P128 = $P112."new"($P123, $S100, $P127, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 135
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
.annotate 'line', 137
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
.annotate 'line', 139
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Val"]
    find_lex $P141, "$block"
    unless_null $P141, vivify_696
    new $P141, "Undef"
  vivify_696:
    $P142 = $P140."new"($P141 :named("value"))
    $P143 = $P136."new"($P142, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 137
    $P144 = $P132."new"($P143, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 135
    $P145 = $P108."new"($P128, $P144)
.annotate 'line', 124
    store_lex "$fixup", $P145
.annotate 'line', 143
    find_lex $P105, "self"
    find_lex $P106, "$fixup"
    unless_null $P106, vivify_697
    new $P106, "Undef"
  vivify_697:
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_698
    new $P107, "Undef"
  vivify_698:
    $P108 = $P105."add_event"($P106 :named("deserialize_past"), $P107 :named("fixup_past"))
.annotate 'line', 118
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine" :anon :subid("22_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1079
    .param pmc param_1080
    .param pmc param_1081
    .param pmc param_1082
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 148
    .lex "self", param_1079
    .lex "$package", param_1080
    .lex "$name", param_1081
    .lex "$past_block", param_1082
.annotate 'line', 149
    new $P104, "Undef"
    set $P1083, $P104
    .lex "$fixup", $P1083
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Op"]
.annotate 'line', 151
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Var"]
.annotate 'line', 153
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "self"
    find_lex $P118, "$package"
    unless_null $P118, vivify_699
    new $P118, "Undef"
  vivify_699:
    $P119 = $P117."get_slot_past_for_object"($P118)
    $P120 = $P116."new"($P119, "get_who PP" :named("pirop"))
.annotate 'line', 154
    find_lex $P121, "$name"
    unless_null $P121, vivify_700
    new $P121, "Undef"
  vivify_700:
    set $S100, $P121
    $P122 = $P112."new"($P120, $S100, "keyed" :named("scope"))
.annotate 'line', 156
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Val"]
    find_lex $P127, "$past_block"
    unless_null $P127, vivify_701
    new $P127, "Undef"
  vivify_701:
    $P128 = $P126."new"($P127 :named("value"))
    $P129 = $P108."new"($P122, $P128, "bind_6model" :named("pasttype"))
.annotate 'line', 149
    store_lex "$fixup", $P129
.annotate 'line', 158
    find_lex $P105, "self"
    find_lex $P106, "$fixup"
    unless_null $P106, vivify_702
    new $P106, "Undef"
  vivify_702:
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_703
    new $P107, "Undef"
  vivify_703:
    $P108 = $P105."add_event"($P106 :named("deserialize_past"), $P107 :named("fixup_past"))
.annotate 'line', 148
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("23_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1087
    .param pmc param_1088
    .param pmc param_1089 :optional :named("name")
    .param int has_param_1089 :opt_flag
    .param pmc param_1090 :optional :named("repr")
    .param int has_param_1090 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 163
    .const 'Sub' $P1103 = "24_1321350766.1143" 
    capture_lex $P1103
    new $P1086, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1086, control_1085
    push_eh $P1086
    .lex "self", param_1087
    .lex "$how", param_1088
    if has_param_1089, optparam_704
    new $P104, "Undef"
    set param_1089, $P104
  optparam_704:
    .lex "$name", param_1089
    if has_param_1090, optparam_705
    new $P105, "Undef"
    set param_1090, $P105
  optparam_705:
    .lex "$repr", param_1090
.annotate 'line', 165
    $P1092 = root_new ['parrot';'Hash']
    set $P1091, $P1092
    .lex "%args", $P1091
.annotate 'line', 168
    new $P106, "Undef"
    set $P1093, $P106
    .lex "$mo", $P1093
.annotate 'line', 169
    new $P107, "Undef"
    set $P1094, $P107
    .lex "$slot", $P1094
.annotate 'line', 163
    find_lex $P1095, "%args"
    unless_null $P1095, vivify_706
    $P1095 = root_new ['parrot';'Hash']
  vivify_706:
.annotate 'line', 166
    find_lex $P108, "$name"
    unless_null $P108, vivify_707
    new $P108, "Undef"
  vivify_707:
    defined $I100, $P108
    unless $I100, if_1096_end
    find_lex $P109, "$name"
    unless_null $P109, vivify_708
    new $P109, "Undef"
  vivify_708:
    find_lex $P1097, "%args"
    unless_null $P1097, vivify_709
    $P1097 = root_new ['parrot';'Hash']
    store_lex "%args", $P1097
  vivify_709:
    set $P1097["name"], $P109
  if_1096_end:
.annotate 'line', 167
    find_lex $P108, "$repr"
    unless_null $P108, vivify_710
    new $P108, "Undef"
  vivify_710:
    defined $I100, $P108
    unless $I100, if_1098_end
    find_lex $P109, "$repr"
    unless_null $P109, vivify_711
    new $P109, "Undef"
  vivify_711:
    find_lex $P1099, "%args"
    unless_null $P1099, vivify_712
    $P1099 = root_new ['parrot';'Hash']
    store_lex "%args", $P1099
  vivify_712:
    set $P1099["repr"], $P109
  if_1098_end:
.annotate 'line', 168
    find_lex $P108, "$how"
    unless_null $P108, vivify_713
    new $P108, "Undef"
  vivify_713:
    find_lex $P1100, "%args"
    unless_null $P1100, vivify_714
    $P1100 = root_new ['parrot';'Hash']
  vivify_714:
    $P109 = $P108."new_type"($P1100 :flat)
    store_lex "$mo", $P109
.annotate 'line', 169
    find_lex $P108, "self"
    find_lex $P109, "$mo"
    unless_null $P109, vivify_715
    new $P109, "Undef"
  vivify_715:
    $P110 = $P108."add_object"($P109)
    store_lex "$slot", $P110
.annotate 'line', 173
    find_lex $P108, "self"
    $P109 = $P108."is_precompilation_mode"()
    unless $P109, if_1101_end
    .const 'Sub' $P1103 = "24_1321350766.1143" 
    capture_lex $P1103
    $P1103()
  if_1101_end:
.annotate 'line', 191
    new $P108, "Exception"
    set $P108['type'], .CONTROL_RETURN
    find_lex $P109, "$mo"
    unless_null $P109, vivify_728
    new $P109, "Undef"
  vivify_728:
    setattribute $P108, 'payload', $P109
    throw $P108
.annotate 'line', 163
    .return ()
  control_1085:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P108, exception, "payload"
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1102"  :anon :subid("24_1321350766.1143") :outer("23_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 174
    $P1105 = root_new ['parrot';'ResizablePMCArray']
    set $P1104, $P1105
    .lex "@how_ns", $P1104
.annotate 'line', 175
    new $P110, "Undef"
    set $P1106, $P110
    .lex "$how_name", $P1106
.annotate 'line', 176
    new $P111, "Undef"
    set $P1107, $P111
    .lex "$setup_call", $P1107
.annotate 'line', 174
    find_lex $P112, "$how"
    unless_null $P112, vivify_716
    new $P112, "Undef"
  vivify_716:
    get_how $P113, $P112
    find_lex $P114, "$how"
    unless_null $P114, vivify_717
    new $P114, "Undef"
  vivify_717:
    $S100 = $P113."name"($P114)
    split $P115, "::", $S100
    store_lex "@how_ns", $P115
.annotate 'line', 175
    find_lex $P1108, "@how_ns"
    unless_null $P1108, vivify_718
    $P1108 = root_new ['parrot';'ResizablePMCArray']
  vivify_718:
    $P112 = $P1108."pop"()
    store_lex "$how_name", $P112
.annotate 'line', 176
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
.annotate 'line', 178
    find_lex $P116, "self"
    find_lex $P117, "$how"
    unless_null $P117, vivify_719
    new $P117, "Undef"
  vivify_719:
    $P118 = $P116."get_object_sc_ref_past"($P117)
    $P119 = $P115."new"($P118, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 176
    store_lex "$setup_call", $P119
.annotate 'line', 180
    find_lex $P112, "$name"
    unless_null $P112, vivify_720
    new $P112, "Undef"
  vivify_720:
    defined $I100, $P112
    unless $I100, if_1109_end
.annotate 'line', 181
    find_lex $P113, "$setup_call"
    unless_null $P113, vivify_721
    new $P113, "Undef"
  vivify_721:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Val"]
    find_lex $P118, "$name"
    unless_null $P118, vivify_722
    new $P118, "Undef"
  vivify_722:
    $P119 = $P117."new"($P118 :named("value"), "name" :named("named"))
    $P113."push"($P119)
  if_1109_end:
.annotate 'line', 183
    find_lex $P112, "$repr"
    unless_null $P112, vivify_723
    new $P112, "Undef"
  vivify_723:
    defined $I100, $P112
    unless $I100, if_1110_end
.annotate 'line', 184
    find_lex $P113, "$setup_call"
    unless_null $P113, vivify_724
    new $P113, "Undef"
  vivify_724:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Val"]
    find_lex $P118, "$repr"
    unless_null $P118, vivify_725
    new $P118, "Undef"
  vivify_725:
    $P119 = $P117."new"($P118 :named("value"), "repr" :named("named"))
    $P113."push"($P119)
  if_1110_end:
.annotate 'line', 186
    find_lex $P112, "self"
.annotate 'line', 187
    find_lex $P113, "self"
    find_lex $P114, "$slot"
    unless_null $P114, vivify_726
    new $P114, "Undef"
  vivify_726:
    find_lex $P115, "$setup_call"
    unless_null $P115, vivify_727
    new $P115, "Undef"
  vivify_727:
    $P116 = $P113."add_object_to_cur_sc_past"($P114, $P115)
.annotate 'line', 186
    $P117 = $P112."add_event"($P116 :named("deserialize_past"))
.annotate 'line', 173
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_attribute" :anon :subid("25_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1112
    .param pmc param_1113
    .param pmc param_1114
    .param pmc param_1115
    .param pmc param_1116
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 199
    .const 'Sub' $P1122 = "26_1321350766.1143" 
    capture_lex $P1122
    .lex "self", param_1112
    .lex "$obj", param_1113
    .lex "$meta_attr", param_1114
    .lex "%lit_args", param_1115
    .lex "%obj_args", param_1116
.annotate 'line', 201
    new $P104, "Undef"
    set $P1117, $P104
    .lex "$attr", $P1117
    find_lex $P105, "$meta_attr"
    unless_null $P105, vivify_729
    new $P105, "Undef"
  vivify_729:
    find_lex $P1118, "%lit_args"
    unless_null $P1118, vivify_730
    $P1118 = root_new ['parrot';'Hash']
  vivify_730:
    find_lex $P1119, "%obj_args"
    unless_null $P1119, vivify_731
    $P1119 = root_new ['parrot';'Hash']
  vivify_731:
    $P106 = $P105."new"($P1118 :flat, $P1119 :flat)
    store_lex "$attr", $P106
.annotate 'line', 202
    find_lex $P105, "$obj"
    unless_null $P105, vivify_732
    new $P105, "Undef"
  vivify_732:
    get_how $P106, $P105
    find_lex $P107, "$obj"
    unless_null $P107, vivify_733
    new $P107, "Undef"
  vivify_733:
    find_lex $P108, "$attr"
    unless_null $P108, vivify_734
    new $P108, "Undef"
  vivify_734:
    $P106."add_attribute"($P107, $P108)
.annotate 'line', 205
    find_lex $P106, "self"
    $P107 = $P106."is_precompilation_mode"()
    if $P107, if_1120
    set $P105, $P107
    goto if_1120_end
  if_1120:
    .const 'Sub' $P1122 = "26_1321350766.1143" 
    capture_lex $P1122
    $P110 = $P1122()
    set $P105, $P110
  if_1120_end:
.annotate 'line', 199
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1121"  :anon :subid("26_1321350766.1143") :outer("25_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 205
    .const 'Sub' $P1132 = "28_1321350766.1143" 
    capture_lex $P1132
    .const 'Sub' $P1127 = "27_1321350766.1143" 
    capture_lex $P1127
.annotate 'line', 206
    new $P108, "Undef"
    set $P1123, $P108
    .lex "$create_call", $P1123
.annotate 'line', 218
    new $P109, "Undef"
    set $P1124, $P109
    .lex "$obj_slot_past", $P1124
.annotate 'line', 206
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
.annotate 'line', 208
    find_lex $P114, "self"
    find_lex $P115, "$meta_attr"
    unless_null $P115, vivify_735
    new $P115, "Undef"
  vivify_735:
    $P116 = $P114."get_object_sc_ref_past"($P115)
    $P117 = $P113."new"($P116, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 206
    store_lex "$create_call", $P117
.annotate 'line', 210
    find_lex $P1125, "%lit_args"
    unless_null $P1125, vivify_736
    $P1125 = root_new ['parrot';'Hash']
  vivify_736:
    defined $I100, $P1125
    unless $I100, for_undef_737
    iter $P110, $P1125
    new $P112, 'ExceptionHandler'
    set_label $P112, loop1129_handler
    $P112."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P112
  loop1129_test:
    unless $P110, loop1129_done
    shift $P111, $P110
  loop1129_redo:
    .const 'Sub' $P1127 = "27_1321350766.1143" 
    capture_lex $P1127
    $P1127($P111)
  loop1129_next:
    goto loop1129_test
  loop1129_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P113, exception, 'type'
    eq $P113, .CONTROL_LOOP_NEXT, loop1129_next
    eq $P113, .CONTROL_LOOP_REDO, loop1129_redo
  loop1129_done:
    pop_eh 
  for_undef_737:
.annotate 'line', 213
    find_lex $P1130, "%obj_args"
    unless_null $P1130, vivify_741
    $P1130 = root_new ['parrot';'Hash']
  vivify_741:
    defined $I100, $P1130
    unless $I100, for_undef_742
    iter $P110, $P1130
    new $P113, 'ExceptionHandler'
    set_label $P113, loop1135_handler
    $P113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P113
  loop1135_test:
    unless $P110, loop1135_done
    shift $P111, $P110
  loop1135_redo:
    .const 'Sub' $P1132 = "28_1321350766.1143" 
    capture_lex $P1132
    $P1132($P111)
  loop1135_next:
    goto loop1135_test
  loop1135_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P114, exception, 'type'
    eq $P114, .CONTROL_LOOP_NEXT, loop1135_next
    eq $P114, .CONTROL_LOOP_REDO, loop1135_redo
  loop1135_done:
    pop_eh 
  for_undef_742:
.annotate 'line', 218
    find_lex $P110, "self"
    find_lex $P111, "$obj"
    unless_null $P111, vivify_748
    new $P111, "Undef"
  vivify_748:
    $P112 = $P110."get_slot_past_for_object"($P111)
    store_lex "$obj_slot_past", $P112
.annotate 'line', 219
    find_lex $P110, "self"
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 221
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    find_lex $P119, "$obj_slot_past"
    unless_null $P119, vivify_749
    new $P119, "Undef"
  vivify_749:
    $P120 = $P118."new"($P119, "get_how PP" :named("pirop"))
    find_lex $P121, "$obj_slot_past"
    unless_null $P121, vivify_750
    new $P121, "Undef"
  vivify_750:
    find_lex $P122, "$create_call"
    unless_null $P122, vivify_751
    new $P122, "Undef"
  vivify_751:
    $P123 = $P114."new"($P120, $P121, $P122, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 219
    $P124 = $P110."add_event"($P123 :named("deserialize_past"))
.annotate 'line', 205
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1126"  :anon :subid("27_1321350766.1143") :outer("26_1321350766.1143")
    .param pmc param_1128
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 210
    .lex "$_", param_1128
.annotate 'line', 211
    find_lex $P112, "$create_call"
    unless_null $P112, vivify_738
    new $P112, "Undef"
  vivify_738:
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Val"]
    find_lex $P117, "$_"
    unless_null $P117, vivify_739
    new $P117, "Undef"
  vivify_739:
    $P118 = $P117."value"()
    find_lex $P119, "$_"
    unless_null $P119, vivify_740
    new $P119, "Undef"
  vivify_740:
    $P120 = $P119."key"()
    $P121 = $P116."new"($P118 :named("value"), $P120 :named("named"))
    $P122 = $P112."push"($P121)
.annotate 'line', 210
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1131"  :anon :subid("28_1321350766.1143") :outer("26_1321350766.1143")
    .param pmc param_1134
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 214
    new $P112, "Undef"
    set $P1133, $P112
    .lex "$lookup", $P1133
    .lex "$_", param_1134
    find_lex $P113, "self"
    find_lex $P114, "$_"
    unless_null $P114, vivify_743
    new $P114, "Undef"
  vivify_743:
    $P115 = $P114."value"()
    $P116 = $P113."get_object_sc_ref_past"($P115)
    store_lex "$lookup", $P116
.annotate 'line', 215
    find_lex $P113, "$lookup"
    unless_null $P113, vivify_744
    new $P113, "Undef"
  vivify_744:
    find_lex $P114, "$_"
    unless_null $P114, vivify_745
    new $P114, "Undef"
  vivify_745:
    $P115 = $P114."key"()
    $P113."named"($P115)
.annotate 'line', 216
    find_lex $P113, "$create_call"
    unless_null $P113, vivify_746
    new $P113, "Undef"
  vivify_746:
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_747
    new $P114, "Undef"
  vivify_747:
    $P115 = $P113."push"($P114)
.annotate 'line', 213
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method" :anon :subid("29_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1137
    .param pmc param_1138
    .param pmc param_1139
    .param pmc param_1140
    .param pmc param_1141
    .param pmc param_1142
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 231
    .const 'Sub' $P1160 = "31_1321350766.1143" 
    capture_lex $P1160
    .const 'Sub' $P1148 = "30_1321350766.1143" 
    capture_lex $P1148
    .lex "self", param_1137
    .lex "$obj", param_1138
    .lex "$meta_method_name", param_1139
    .lex "$name", param_1140
    .lex "$method_past", param_1141
    .lex "$is_dispatcher", param_1142
.annotate 'line', 237
    new $P104, "Undef"
    set $P1143, $P104
    .lex "$stub_code", $P1143
.annotate 'line', 243
    new $P105, "Undef"
    set $P1144, $P105
    .lex "$fixups", $P1144
.annotate 'line', 244
    new $P106, "Undef"
    set $P1145, $P106
    .lex "$dummy", $P1145
.annotate 'line', 289
    new $P107, "Undef"
    set $P1146, $P107
    .lex "$slot_past", $P1146
.annotate 'line', 237
    .const 'Sub' $P1148 = "30_1321350766.1143" 
    newclosure $P1154, $P1148
    store_lex "$stub_code", $P1154
.annotate 'line', 243
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    store_lex "$fixups", $P112
.annotate 'line', 231
    find_lex $P108, "$dummy"
    unless_null $P108, vivify_756
    new $P108, "Undef"
  vivify_756:
.annotate 'line', 245
    find_lex $P1156, "$method_past"
    unless_null $P1156, vivify_757
    $P1156 = root_new ['parrot';'Hash']
  vivify_757:
    set $P108, $P1156["compile_time_dummy"]
    unless_null $P108, vivify_758
    new $P108, "Undef"
  vivify_758:
    defined $I100, $P108
    if $I100, if_1155
.annotate 'line', 252
    find_lex $P109, "$is_dispatcher"
    unless_null $P109, vivify_759
    new $P109, "Undef"
  vivify_759:
    if $P109, if_1158
.annotate 'line', 268
    find_lex $P110, "$stub_code"
    unless_null $P110, vivify_760
    new $P110, "Undef"
  vivify_760:
    clone $P111, $P110
    store_lex "$dummy", $P111
.annotate 'line', 267
    goto if_1158_end
  if_1158:
.annotate 'line', 253
    find_lex $P110, "$method_past"
    unless_null $P110, vivify_761
    new $P110, "Undef"
  vivify_761:
    $P110."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 254
    new $P110, "DispatcherSub"
    find_lex $P111, "$stub_code"
    unless_null $P111, vivify_762
    new $P111, "Undef"
  vivify_762:
    assign $P110, $P111
    store_lex "$dummy", $P110
.annotate 'line', 258
    find_lex $P110, "$dummy"
    unless_null $P110, vivify_763
    new $P110, "Undef"
  vivify_763:
    .const 'Sub' $P1160 = "31_1321350766.1143" 
    newclosure $P1163, $P1160
    setprop $P110, "CLONE_CALLBACK", $P1163
  if_1158_end:
.annotate 'line', 270
    find_lex $P109, "$dummy"
    unless_null $P109, vivify_768
    new $P109, "Undef"
  vivify_768:
    find_lex $P110, "$name"
    unless_null $P110, vivify_769
    new $P110, "Undef"
  vivify_769:
    set $S100, $P110
    assign $P109, $S100
.annotate 'line', 271
    find_lex $P109, "self"
    find_lex $P110, "$dummy"
    unless_null $P110, vivify_770
    new $P110, "Undef"
  vivify_770:
    $P109."add_code"($P110)
.annotate 'line', 272
    find_lex $P109, "$dummy"
    unless_null $P109, vivify_771
    new $P109, "Undef"
  vivify_771:
    find_lex $P1164, "$method_past"
    unless_null $P1164, vivify_772
    $P1164 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P1164
  vivify_772:
    set $P1164["compile_time_dummy"], $P109
.annotate 'line', 248
    goto if_1155_end
  if_1155:
.annotate 'line', 246
    find_lex $P1157, "$method_past"
    unless_null $P1157, vivify_773
    $P1157 = root_new ['parrot';'Hash']
  vivify_773:
    set $P109, $P1157["compile_time_dummy"]
    unless_null $P109, vivify_774
    new $P109, "Undef"
  vivify_774:
    store_lex "$dummy", $P109
  if_1155_end:
.annotate 'line', 276
    find_lex $P108, "$dummy"
    unless_null $P108, vivify_775
    new $P108, "Undef"
  vivify_775:
    find_lex $P109, "$method_past"
    unless_null $P109, vivify_776
    new $P109, "Undef"
  vivify_776:
    setprop $P108, "PAST", $P109
.annotate 'line', 279
    find_lex $P108, "$obj"
    unless_null $P108, vivify_777
    new $P108, "Undef"
  vivify_777:
    get_how $P109, $P108
    find_lex $P110, "$obj"
    unless_null $P110, vivify_778
    new $P110, "Undef"
  vivify_778:
    find_lex $P111, "$name"
    unless_null $P111, vivify_779
    new $P111, "Undef"
  vivify_779:
    find_lex $P112, "$dummy"
    unless_null $P112, vivify_780
    new $P112, "Undef"
  vivify_780:
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_781
    new $P113, "Undef"
  vivify_781:
    set $S100, $P113
    $P109.$S100($P110, $P111, $P112)
.annotate 'line', 284
    find_lex $P108, "$fixups"
    unless_null $P108, vivify_782
    new $P108, "Undef"
  vivify_782:
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 286
    find_lex $P113, "self"
    find_lex $P114, "$dummy"
    unless_null $P114, vivify_783
    new $P114, "Undef"
  vivify_783:
    $P115 = $P113."get_slot_past_for_object"($P114)
.annotate 'line', 287
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Val"]
    find_lex $P120, "$method_past"
    unless_null $P120, vivify_784
    new $P120, "Undef"
  vivify_784:
    $P121 = $P119."new"($P120 :named("value"))
    $P122 = $P112."new"($P115, $P121, "assign vPP" :named("pirop"))
.annotate 'line', 284
    $P108."push"($P122)
.annotate 'line', 289
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_785
    new $P109, "Undef"
  vivify_785:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 290
    find_lex $P108, "self"
.annotate 'line', 291
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_786
    new $P113, "Undef"
  vivify_786:
.annotate 'line', 293
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_787
    new $P118, "Undef"
  vivify_787:
    $P119 = $P117."new"($P118, "get_how PP" :named("pirop"))
    find_lex $P120, "$slot_past"
    unless_null $P120, vivify_788
    new $P120, "Undef"
  vivify_788:
    find_lex $P121, "$name"
    unless_null $P121, vivify_789
    new $P121, "Undef"
  vivify_789:
.annotate 'line', 296
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Val"]
    find_lex $P126, "$method_past"
    unless_null $P126, vivify_790
    new $P126, "Undef"
  vivify_790:
    $P127 = $P125."new"($P126 :named("value"))
    $P128 = $P112."new"($P119, $P120, $P121, $P127, "callmethod" :named("pasttype"), $P113 :named("name"))
.annotate 'line', 290
    find_lex $P129, "$fixups"
    unless_null $P129, vivify_791
    new $P129, "Undef"
  vivify_791:
    $P130 = $P108."add_event"($P128 :named("deserialize_past"), $P129 :named("fixup_past"))
.annotate 'line', 231
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1147"  :anon :subid("30_1321350766.1143") :outer("29_1321350766.1143")
    .param pmc param_1149 :slurpy
    .param pmc param_1150 :slurpy :named
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 237
    .lex "@args", param_1149
    .lex "%named", param_1150
.annotate 'line', 238
    new $P108, "Undef"
    set $P1151, $P108
    .lex "$compiled", $P1151
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Compiler"]
    find_lex $P113, "$method_past"
    unless_null $P113, vivify_752
    new $P113, "Undef"
  vivify_752:
    $P114 = $P112."compile"($P113)
    store_lex "$compiled", $P114
.annotate 'line', 239
    find_lex $P109, "$compiled"
    unless_null $P109, vivify_753
    new $P109, "Undef"
  vivify_753:
    find_lex $P1152, "@args"
    unless_null $P1152, vivify_754
    $P1152 = root_new ['parrot';'ResizablePMCArray']
  vivify_754:
    find_lex $P1153, "%named"
    unless_null $P1153, vivify_755
    $P1153 = root_new ['parrot';'Hash']
  vivify_755:
    $P110 = $P109($P1152 :flat, $P1153 :flat)
.annotate 'line', 237
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1159"  :anon :subid("31_1321350766.1143") :outer("29_1321350766.1143")
    .param pmc param_1161
    .param pmc param_1162
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 258
    .lex "$orig", param_1161
    .lex "$clone", param_1162
.annotate 'line', 259
    find_lex $P111, "self"
    find_lex $P112, "$clone"
    unless_null $P112, vivify_764
    new $P112, "Undef"
  vivify_764:
    $P111."add_code"($P112)
.annotate 'line', 260
    find_lex $P111, "$fixups"
    unless_null $P111, vivify_765
    new $P111, "Undef"
  vivify_765:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
.annotate 'line', 262
    find_lex $P116, "self"
    find_lex $P117, "$clone"
    unless_null $P117, vivify_766
    new $P117, "Undef"
  vivify_766:
    $P118 = $P116."get_slot_past_for_object"($P117)
.annotate 'line', 263
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$orig"
    unless_null $P123, vivify_767
    new $P123, "Undef"
  vivify_767:
    getprop $P124, "PAST", $P123
    $P125 = $P122."new"($P124 :named("value"))
    $P126 = $P115."new"($P118, $P125, "assign vPP" :named("pirop"))
.annotate 'line', 260
    $P127 = $P111."push"($P126)
.annotate 'line', 258
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature" :anon :subid("32_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1166
    .param pmc param_1167
    .param pmc param_1168
    .param pmc param_1169
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 302
    .lex "self", param_1166
    .lex "$routine", param_1167
    .lex "$types", param_1168
    .lex "$definednesses", param_1169
.annotate 'line', 305
    new $P104, "Undef"
    set $P1170, $P104
    .lex "$fixup", $P1170
.annotate 'line', 312
    new $P105, "Undef"
    set $P1171, $P105
    .lex "$des", $P1171
.annotate 'line', 305
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
    find_lex $P110, "$types"
    unless_null $P110, vivify_792
    new $P110, "Undef"
  vivify_792:
    find_lex $P111, "$definednesses"
    unless_null $P111, vivify_793
    new $P111, "Undef"
  vivify_793:
    $P112 = $P109."new"($P110, $P111, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P112
.annotate 'line', 306
    find_lex $P1173, "$routine"
    unless_null $P1173, vivify_794
    $P1173 = root_new ['parrot';'Hash']
  vivify_794:
    set $P106, $P1173["compile_time_dummy"]
    unless_null $P106, vivify_795
    new $P106, "Undef"
  vivify_795:
    defined $I100, $P106
    if $I100, if_1172
.annotate 'line', 310
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_796
    new $P107, "Undef"
  vivify_796:
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Val"]
    find_lex $P112, "$routine"
    unless_null $P112, vivify_797
    new $P112, "Undef"
  vivify_797:
    $P113 = $P111."new"($P112 :named("value"))
    $P107."unshift"($P113)
.annotate 'line', 309
    goto if_1172_end
  if_1172:
.annotate 'line', 307
    find_lex $P107, "$fixup"
    unless_null $P107, vivify_798
    new $P107, "Undef"
  vivify_798:
    find_lex $P108, "self"
    find_lex $P1174, "$routine"
    unless_null $P1174, vivify_799
    $P1174 = root_new ['parrot';'Hash']
  vivify_799:
    set $P109, $P1174["compile_time_dummy"]
    unless_null $P109, vivify_800
    new $P109, "Undef"
  vivify_800:
    $P110 = $P108."get_slot_past_for_object"($P109)
    $P107."unshift"($P110)
  if_1172_end:
.annotate 'line', 312
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 313
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Val"]
    find_lex $P114, "$routine"
    unless_null $P114, vivify_801
    new $P114, "Undef"
  vivify_801:
    $P115 = $P113."new"($P114 :named("value"))
    find_lex $P116, "$types"
    unless_null $P116, vivify_802
    new $P116, "Undef"
  vivify_802:
    find_lex $P117, "$definednesses"
    unless_null $P117, vivify_803
    new $P117, "Undef"
  vivify_803:
    $P118 = $P109."new"($P115, $P116, $P117, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 312
    store_lex "$des", $P118
.annotate 'line', 315
    find_lex $P106, "self"
    find_lex $P107, "$des"
    unless_null $P107, vivify_804
    new $P107, "Undef"
  vivify_804:
    find_lex $P108, "$fixup"
    unless_null $P108, vivify_805
    new $P108, "Undef"
  vivify_805:
    $P109 = $P106."add_event"($P107 :named("deserialize_past"), $P108 :named("fixup_past"))
.annotate 'line', 302
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block" :anon :subid("33_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1176
    .param pmc param_1177
    .param pmc param_1178
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 319
    .const 'Sub' $P1184 = "34_1321350766.1143" 
    capture_lex $P1184
    .lex "self", param_1176
    .lex "$obj", param_1177
    .lex "$body_past", param_1178
.annotate 'line', 330
    new $P104, "Undef"
    set $P1179, $P104
    .lex "$fixups", $P1179
.annotate 'line', 331
    new $P105, "Undef"
    set $P1180, $P105
    .lex "$dummy", $P1180
.annotate 'line', 366
    new $P106, "Undef"
    set $P1181, $P106
    .lex "$slot_past", $P1181
.annotate 'line', 367
    new $P107, "Undef"
    set $P1182, $P107
    .lex "$des", $P1182
.annotate 'line', 330
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    store_lex "$fixups", $P112
.annotate 'line', 331
    .const 'Sub' $P1184 = "34_1321350766.1143" 
    newclosure $P1201, $P1184
    store_lex "$dummy", $P1201
.annotate 'line', 363
    find_lex $P108, "$obj"
    unless_null $P108, vivify_823
    new $P108, "Undef"
  vivify_823:
    get_how $P109, $P108
    find_lex $P110, "$obj"
    unless_null $P110, vivify_824
    new $P110, "Undef"
  vivify_824:
    find_lex $P111, "$dummy"
    unless_null $P111, vivify_825
    new $P111, "Undef"
  vivify_825:
    $P109."set_body_block"($P110, $P111)
.annotate 'line', 366
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_826
    new $P109, "Undef"
  vivify_826:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 367
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 369
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    find_lex $P116, "$slot_past"
    unless_null $P116, vivify_827
    new $P116, "Undef"
  vivify_827:
    $P117 = $P115."new"($P116, "get_how PP" :named("pirop"))
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_828
    new $P118, "Undef"
  vivify_828:
.annotate 'line', 371
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$body_past"
    unless_null $P123, vivify_829
    new $P123, "Undef"
  vivify_829:
    $P124 = $P122."new"($P123 :named("value"))
    $P125 = $P111."new"($P117, $P118, $P124, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 367
    store_lex "$des", $P125
.annotate 'line', 374
    find_lex $P108, "self"
    find_lex $P109, "$des"
    unless_null $P109, vivify_830
    new $P109, "Undef"
  vivify_830:
    find_lex $P110, "$fixups"
    unless_null $P110, vivify_831
    new $P110, "Undef"
  vivify_831:
    $P111 = $P108."add_event"($P109 :named("deserialize_past"), $P110 :named("fixup_past"))
.annotate 'line', 319
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block1183"  :anon :subid("34_1321350766.1143") :outer("33_1321350766.1143")
    .param pmc param_1185 :slurpy
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 331
    .const 'Sub' $P1193 = "36_1321350766.1143" 
    capture_lex $P1193
    .const 'Sub' $P1189 = "35_1321350766.1143" 
    capture_lex $P1189
    .lex "@type_args", param_1185
.annotate 'line', 333
    new $P108, "Undef"
    set $P1186, $P108
    .lex "$invoke_body", $P1186
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 335
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Val"]
    find_lex $P117, "$body_past"
    unless_null $P117, vivify_806
    new $P117, "Undef"
  vivify_806:
    $P118 = $P116."new"($P117 :named("value"))
    $P119 = $P112."new"($P118, "call" :named("pasttype"))
.annotate 'line', 333
    store_lex "$invoke_body", $P119
.annotate 'line', 337
    find_lex $P1187, "@type_args"
    unless_null $P1187, vivify_807
    $P1187 = root_new ['parrot';'ResizablePMCArray']
  vivify_807:
    defined $I100, $P1187
    unless $I100, for_undef_808
    iter $P109, $P1187
    new $P111, 'ExceptionHandler'
    set_label $P111, loop1191_handler
    $P111."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P111
  loop1191_test:
    unless $P109, loop1191_done
    shift $P110, $P109
  loop1191_redo:
    .const 'Sub' $P1189 = "35_1321350766.1143" 
    capture_lex $P1189
    $P1189($P110)
  loop1191_next:
    goto loop1191_test
  loop1191_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1191_next
    eq $P112, .CONTROL_LOOP_REDO, loop1191_redo
  loop1191_done:
    pop_eh 
  for_undef_808:
.annotate 'line', 340
    find_lex $P109, "$fixups"
    unless_null $P109, vivify_811
    new $P109, "Undef"
  vivify_811:
    find_lex $P110, "$invoke_body"
    unless_null $P110, vivify_812
    new $P110, "Undef"
  vivify_812:
    $P109."push"($P110)
.annotate 'line', 343
    find_lex $P110, "$obj"
    unless_null $P110, vivify_813
    new $P110, "Undef"
  vivify_813:
    get_how $P111, $P110
    find_lex $P112, "$obj"
    unless_null $P112, vivify_814
    new $P112, "Undef"
  vivify_814:
    $P113 = $P111."methods"($P112, 1 :named("local"))
    defined $I100, $P113
    unless $I100, for_undef_815
    iter $P109, $P113
    new $P115, 'ExceptionHandler'
    set_label $P115, loop1200_handler
    $P115."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P115
  loop1200_test:
    unless $P109, loop1200_done
    shift $P114, $P109
  loop1200_redo:
    .const 'Sub' $P1193 = "36_1321350766.1143" 
    capture_lex $P1193
    $P1193($P114)
  loop1200_next:
    goto loop1200_test
  loop1200_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P116, exception, 'type'
    eq $P116, .CONTROL_LOOP_NEXT, loop1200_next
    eq $P116, .CONTROL_LOOP_REDO, loop1200_redo
  loop1200_done:
    pop_eh 
  for_undef_815:
.annotate 'line', 331
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1188"  :anon :subid("35_1321350766.1143") :outer("34_1321350766.1143")
    .param pmc param_1190
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 337
    .lex "$_", param_1190
.annotate 'line', 338
    find_lex $P111, "$invoke_body"
    unless_null $P111, vivify_809
    new $P111, "Undef"
  vivify_809:
    find_lex $P112, "self"
    find_lex $P113, "$_"
    unless_null $P113, vivify_810
    new $P113, "Undef"
  vivify_810:
    $P114 = $P112."get_slot_past_for_object"($P113)
    $P115 = $P111."push"($P114)
.annotate 'line', 337
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1192"  :anon :subid("36_1321350766.1143") :outer("34_1321350766.1143")
    .param pmc param_1194
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 343
    .const 'Sub' $P1196 = "37_1321350766.1143" 
    capture_lex $P1196
    .lex "$_", param_1194
.annotate 'line', 344
    find_lex $P115, "$_"
    unless_null $P115, vivify_816
    new $P115, "Undef"
  vivify_816:
    .const 'Sub' $P1196 = "37_1321350766.1143" 
    newclosure $P1199, $P1196
    setprop $P115, "REIFY_CALLBACK", $P1199
.annotate 'line', 343
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1195"  :anon :subid("37_1321350766.1143") :outer("36_1321350766.1143")
    .param pmc param_1197
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 344
    .lex "$meth", param_1197
.annotate 'line', 346
    new $P116, "Undef"
    set $P1198, $P116
    .lex "$clone", $P1198
    find_lex $P117, "$meth"
    unless_null $P117, vivify_817
    new $P117, "Undef"
  vivify_817:
    clone $P118, $P117
    store_lex "$clone", $P118
.annotate 'line', 347
    find_lex $P117, "self"
    find_lex $P118, "$clone"
    unless_null $P118, vivify_818
    new $P118, "Undef"
  vivify_818:
    $P117."add_code"($P118)
.annotate 'line', 350
    find_lex $P117, "$fixups"
    unless_null $P117, vivify_819
    new $P117, "Undef"
  vivify_819:
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 352
    find_lex $P122, "self"
    find_lex $P123, "$clone"
    unless_null $P123, vivify_820
    new $P123, "Undef"
  vivify_820:
    $P124 = $P122."get_slot_past_for_object"($P123)
.annotate 'line', 353
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "PAST"
    get_who $P127, $P126
    set $P128, $P127["Val"]
    find_lex $P129, "$meth"
    unless_null $P129, vivify_821
    new $P129, "Undef"
  vivify_821:
    getprop $P130, "PAST", $P129
    $P131 = $P128."new"($P130 :named("value"))
    $P132 = $P121."new"($P124, $P131, "assign vPP" :named("pirop"))
.annotate 'line', 350
    $P117."push"($P132)
.annotate 'line', 344
    find_lex $P117, "$clone"
    unless_null $P117, vivify_822
    new $P117, "Undef"
  vivify_822:
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role" :anon :subid("38_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1203
    .param pmc param_1204
    .param pmc param_1205
    .param pmc param_1206
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 379
    .const 'Sub' $P1209 = "39_1321350766.1143" 
    capture_lex $P1209
    .lex "self", param_1203
    .lex "$obj", param_1204
    .lex "$meta_method_name", param_1205
    .lex "$to_add", param_1206
.annotate 'line', 381
    find_lex $P104, "$obj"
    unless_null $P104, vivify_832
    new $P104, "Undef"
  vivify_832:
    get_how $P105, $P104
    find_lex $P106, "$obj"
    unless_null $P106, vivify_833
    new $P106, "Undef"
  vivify_833:
    find_lex $P107, "$to_add"
    unless_null $P107, vivify_834
    new $P107, "Undef"
  vivify_834:
    find_lex $P108, "$meta_method_name"
    unless_null $P108, vivify_835
    new $P108, "Undef"
  vivify_835:
    set $S100, $P108
    $P105.$S100($P106, $P107)
.annotate 'line', 384
    find_lex $P105, "self"
    $P106 = $P105."is_precompilation_mode"()
    if $P106, if_1207
    set $P104, $P106
    goto if_1207_end
  if_1207:
    .const 'Sub' $P1209 = "39_1321350766.1143" 
    capture_lex $P1209
    $P108 = $P1209()
    set $P104, $P108
  if_1207_end:
.annotate 'line', 379
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1208"  :anon :subid("39_1321350766.1143") :outer("38_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 385
    new $P107, "Undef"
    set $P1210, $P107
    .lex "$slot_past", $P1210
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_836
    new $P109, "Undef"
  vivify_836:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 386
    find_lex $P108, "self"
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
    find_lex $P113, "$meta_method_name"
    unless_null $P113, vivify_837
    new $P113, "Undef"
  vivify_837:
.annotate 'line', 388
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    find_lex $P118, "$slot_past"
    unless_null $P118, vivify_838
    new $P118, "Undef"
  vivify_838:
    $P119 = $P117."new"($P118, "get_how PP" :named("pirop"))
    find_lex $P120, "$slot_past"
    unless_null $P120, vivify_839
    new $P120, "Undef"
  vivify_839:
.annotate 'line', 390
    find_lex $P121, "self"
    find_lex $P122, "$to_add"
    unless_null $P122, vivify_840
    new $P122, "Undef"
  vivify_840:
    $P123 = $P121."get_object_sc_ref_past"($P122)
    $P124 = $P112."new"($P119, $P120, $P123, "callmethod" :named("pasttype"), $P113 :named("name"))
.annotate 'line', 386
    $P125 = $P108."add_event"($P124 :named("deserialize_past"))
.annotate 'line', 384
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("40_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1212
    .param pmc param_1213
    .param pmc param_1214
    .param pmc param_1215
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 395
    .const 'Sub' $P1218 = "41_1321350766.1143" 
    capture_lex $P1218
    .lex "self", param_1212
    .lex "$obj", param_1213
    .lex "$name", param_1214
    .lex "$att_name", param_1215
.annotate 'line', 397
    find_lex $P104, "$obj"
    unless_null $P104, vivify_841
    new $P104, "Undef"
  vivify_841:
    get_how $P105, $P104
    find_lex $P106, "$obj"
    unless_null $P106, vivify_842
    new $P106, "Undef"
  vivify_842:
    find_lex $P107, "$name"
    unless_null $P107, vivify_843
    new $P107, "Undef"
  vivify_843:
    find_lex $P108, "$att_name"
    unless_null $P108, vivify_844
    new $P108, "Undef"
  vivify_844:
    $P105."add_parrot_vtable_handler_mapping"($P106, $P107, $P108)
.annotate 'line', 400
    find_lex $P105, "self"
    $P106 = $P105."is_precompilation_mode"()
    if $P106, if_1216
    set $P104, $P106
    goto if_1216_end
  if_1216:
    .const 'Sub' $P1218 = "41_1321350766.1143" 
    capture_lex $P1218
    $P108 = $P1218()
    set $P104, $P108
  if_1216_end:
.annotate 'line', 395
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1217"  :anon :subid("41_1321350766.1143") :outer("40_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 401
    new $P107, "Undef"
    set $P1219, $P107
    .lex "$slot_past", $P1219
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_845
    new $P109, "Undef"
  vivify_845:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 402
    find_lex $P108, "self"
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 404
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "$slot_past"
    unless_null $P117, vivify_846
    new $P117, "Undef"
  vivify_846:
    $P118 = $P116."new"($P117, "get_how PP" :named("pirop"))
    find_lex $P119, "$slot_past"
    unless_null $P119, vivify_847
    new $P119, "Undef"
  vivify_847:
    find_lex $P120, "$name"
    unless_null $P120, vivify_848
    new $P120, "Undef"
  vivify_848:
    find_lex $P121, "$att_name"
    unless_null $P121, vivify_849
    new $P121, "Undef"
  vivify_849:
    $P122 = $P112."new"($P118, $P119, $P120, $P121, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 402
    $P123 = $P108."add_event"($P122 :named("deserialize_past"))
.annotate 'line', 400
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose" :anon :subid("42_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1221
    .param pmc param_1222
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 412
    .const 'Sub' $P1225 = "43_1321350766.1143" 
    capture_lex $P1225
    .lex "self", param_1221
    .lex "$obj", param_1222
.annotate 'line', 414
    find_lex $P104, "$obj"
    unless_null $P104, vivify_850
    new $P104, "Undef"
  vivify_850:
    get_how $P105, $P104
    find_lex $P106, "$obj"
    unless_null $P106, vivify_851
    new $P106, "Undef"
  vivify_851:
    $P105."compose"($P106)
.annotate 'line', 417
    find_lex $P105, "self"
    $P106 = $P105."is_precompilation_mode"()
    if $P106, if_1223
    set $P104, $P106
    goto if_1223_end
  if_1223:
    .const 'Sub' $P1225 = "43_1321350766.1143" 
    capture_lex $P1225
    $P108 = $P1225()
    set $P104, $P108
  if_1223_end:
.annotate 'line', 412
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1224"  :anon :subid("43_1321350766.1143") :outer("42_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 418
    new $P107, "Undef"
    set $P1226, $P107
    .lex "$slot_past", $P1226
    find_lex $P108, "self"
    find_lex $P109, "$obj"
    unless_null $P109, vivify_852
    new $P109, "Undef"
  vivify_852:
    $P110 = $P108."get_slot_past_for_object"($P109)
    store_lex "$slot_past", $P110
.annotate 'line', 419
    find_lex $P108, "self"
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 421
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "$slot_past"
    unless_null $P117, vivify_853
    new $P117, "Undef"
  vivify_853:
    $P118 = $P116."new"($P117, "get_how PP" :named("pirop"))
    find_lex $P119, "$slot_past"
    unless_null $P119, vivify_854
    new $P119, "Undef"
  vivify_854:
    $P120 = $P112."new"($P118, $P119, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 419
    $P121 = $P108."add_event"($P120 :named("deserialize_past"))
.annotate 'line', 417
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("44_1321350766.1143") :outer("13_1321350766.1143")
    .param pmc param_1228
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 429
    .const 'Sub' $P1232 = "45_1321350766.1143" 
    capture_lex $P1232
    .lex "self", param_1228
.annotate 'line', 430
    new $P104, "Undef"
    set $P1229, $P104
    .lex "$des", $P1229
.annotate 'line', 431
    new $P105, "Undef"
    set $P1230, $P105
    .lex "$fix", $P1230
.annotate 'line', 430
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    store_lex "$des", $P110
.annotate 'line', 431
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    store_lex "$fix", $P110
.annotate 'line', 432
    find_lex $P107, "self"
    $P108 = $P107."event_stream"()
    defined $I100, $P108
    unless $I100, for_undef_855
    iter $P106, $P108
    new $P111, 'ExceptionHandler'
    set_label $P111, loop1236_handler
    $P111."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P111
  loop1236_test:
    unless $P106, loop1236_done
    shift $P109, $P106
  loop1236_redo:
    .const 'Sub' $P1232 = "45_1321350766.1143" 
    capture_lex $P1232
    $P1232($P109)
  loop1236_next:
    goto loop1236_test
  loop1236_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1236_next
    eq $P112, .CONTROL_LOOP_REDO, loop1236_redo
  loop1236_done:
    pop_eh 
  for_undef_855:
.annotate 'line', 436
    find_dynamic_lex $P106, "$/"
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
.annotate 'line', 438
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 440
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    find_lex $P119, "self"
    $P120 = $P119."handle"()
    $P121 = $P118."new"($P120, "nqp_get_sc Ps" :named("pirop"))
    $P122 = $P114."new"($P121, "isnull IP" :named("pirop"))
.annotate 'line', 442
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Stmts"]
.annotate 'line', 443
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    $P131 = $P130."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 444
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    $P136 = $P135."new"("nqp_bigint_setup v" :named("pirop"))
.annotate 'line', 445
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Op"]
.annotate 'line', 447
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Op"]
    $P145 = $P144."new"("getinterp P" :named("pirop"))
.annotate 'line', 448
    get_hll_global $P146, "GLOBAL"
    nqp_get_package_through_who $P147, $P146, "PAST"
    get_who $P148, $P147
    set $P149, $P148["Op"]
    $P150 = $P149."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 449
    get_hll_global $P151, "GLOBAL"
    nqp_get_package_through_who $P152, $P151, "PAST"
    get_who $P153, $P152
    set $P154, $P153["Op"]
    $P155 = $P154."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P156 = $P140."new"($P145, $P150, $P155, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 451
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 453
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Var"]
    $P165 = $P164."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 454
    get_hll_global $P166, "GLOBAL"
    nqp_get_package_through_who $P167, $P166, "PAST"
    get_who $P168, $P167
    set $P169, $P168["Op"]
    find_lex $P170, "self"
    $P171 = $P170."handle"()
    $P172 = $P169."new"($P171, "nqp_create_sc Ps" :named("pirop"))
    $P173 = $P160."new"($P165, $P172, "bind_6model" :named("pasttype"))
.annotate 'line', 456
    get_hll_global $P174, "GLOBAL"
    nqp_get_package_through_who $P175, $P174, "PAST"
    get_who $P176, $P175
    set $P177, $P176["Op"]
.annotate 'line', 458
    get_hll_global $P178, "GLOBAL"
    nqp_get_package_through_who $P179, $P178, "PAST"
    get_who $P180, $P179
    set $P181, $P180["Var"]
    $P182 = $P181."new"("cur_sc" :named("name"), "register" :named("scope"))
.annotate 'line', 459
    find_lex $P183, "self"
    $P184 = $P183."sc"()
    $P185 = $P184."description"()
    $P186 = $P177."new"($P182, $P185, "callmethod" :named("pasttype"), "set_description" :named("name"))
.annotate 'line', 456
    find_lex $P187, "$des"
    unless_null $P187, vivify_862
    new $P187, "Undef"
  vivify_862:
    $P188 = $P126."new"($P131, $P136, $P156, $P173, $P186, $P187)
.annotate 'line', 442
    find_lex $P189, "$fix"
    unless_null $P189, vivify_863
    new $P189, "Undef"
  vivify_863:
    $P190 = $P110."new"($P122, $P188, $P189, "if" :named("pasttype"))
.annotate 'line', 436
    $P191 = $P106."!make"($P190)
.annotate 'line', 429
    .return ($P191)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block1231"  :anon :subid("45_1321350766.1143") :outer("44_1321350766.1143")
    .param pmc param_1233
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 432
    .lex "$_", param_1233
.annotate 'line', 433
    find_lex $P110, "$_"
    unless_null $P110, vivify_856
    new $P110, "Undef"
  vivify_856:
    $P111 = $P110."deserialize_past"()
    defined $I101, $P111
    unless $I101, if_1234_end
    find_lex $P112, "$des"
    unless_null $P112, vivify_857
    new $P112, "Undef"
  vivify_857:
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Stmt"]
    find_lex $P117, "$_"
    unless_null $P117, vivify_858
    new $P117, "Undef"
  vivify_858:
    $P118 = $P117."deserialize_past"()
    $P119 = $P116."new"($P118)
    $P112."push"($P119)
  if_1234_end:
.annotate 'line', 434
    find_lex $P111, "$_"
    unless_null $P111, vivify_859
    new $P111, "Undef"
  vivify_859:
    $P112 = $P111."fixup_past"()
    defined $I101, $P112
    if $I101, if_1235
    new $P110, 'Integer'
    set $P110, $I101
    goto if_1235_end
  if_1235:
    find_lex $P113, "$fix"
    unless_null $P113, vivify_860
    new $P113, "Undef"
  vivify_860:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Stmt"]
    find_lex $P118, "$_"
    unless_null $P118, vivify_861
    new $P118, "Undef"
  vivify_861:
    $P119 = $P118."fixup_past"()
    $P120 = $P117."new"($P119)
    $P121 = $P113."push"($P120)
    set $P110, $P121
  if_1235_end:
.annotate 'line', 432
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1238"  :subid("46_1321350766.1143") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P2334 = "424_1321350766.1143" 
    capture_lex $P2334
    .const 'Sub' $P2333 = "423_1321350766.1143" 
    capture_lex $P2333
    .const 'Sub' $P2329 = "422_1321350766.1143" 
    capture_lex $P2329
    .const 'Sub' $P2328 = "421_1321350766.1143" 
    capture_lex $P2328
    .const 'Sub' $P2324 = "420_1321350766.1143" 
    capture_lex $P2324
    .const 'Sub' $P2323 = "419_1321350766.1143" 
    capture_lex $P2323
    .const 'Sub' $P2319 = "418_1321350766.1143" 
    capture_lex $P2319
    .const 'Sub' $P2318 = "417_1321350766.1143" 
    capture_lex $P2318
    .const 'Sub' $P2314 = "416_1321350766.1143" 
    capture_lex $P2314
    .const 'Sub' $P2313 = "415_1321350766.1143" 
    capture_lex $P2313
    .const 'Sub' $P2307 = "413_1321350766.1143" 
    capture_lex $P2307
    .const 'Sub' $P2306 = "412_1321350766.1143" 
    capture_lex $P2306
    .const 'Sub' $P2302 = "411_1321350766.1143" 
    capture_lex $P2302
    .const 'Sub' $P2301 = "410_1321350766.1143" 
    capture_lex $P2301
    .const 'Sub' $P2297 = "409_1321350766.1143" 
    capture_lex $P2297
    .const 'Sub' $P2296 = "408_1321350766.1143" 
    capture_lex $P2296
    .const 'Sub' $P2292 = "407_1321350766.1143" 
    capture_lex $P2292
    .const 'Sub' $P2291 = "406_1321350766.1143" 
    capture_lex $P2291
    .const 'Sub' $P2287 = "405_1321350766.1143" 
    capture_lex $P2287
    .const 'Sub' $P2286 = "404_1321350766.1143" 
    capture_lex $P2286
    .const 'Sub' $P2283 = "403_1321350766.1143" 
    capture_lex $P2283
    .const 'Sub' $P2282 = "402_1321350766.1143" 
    capture_lex $P2282
    .const 'Sub' $P2278 = "401_1321350766.1143" 
    capture_lex $P2278
    .const 'Sub' $P2277 = "400_1321350766.1143" 
    capture_lex $P2277
    .const 'Sub' $P2273 = "399_1321350766.1143" 
    capture_lex $P2273
    .const 'Sub' $P2272 = "398_1321350766.1143" 
    capture_lex $P2272
    .const 'Sub' $P2268 = "397_1321350766.1143" 
    capture_lex $P2268
    .const 'Sub' $P2267 = "396_1321350766.1143" 
    capture_lex $P2267
    .const 'Sub' $P2263 = "395_1321350766.1143" 
    capture_lex $P2263
    .const 'Sub' $P2262 = "394_1321350766.1143" 
    capture_lex $P2262
    .const 'Sub' $P2258 = "393_1321350766.1143" 
    capture_lex $P2258
    .const 'Sub' $P2257 = "392_1321350766.1143" 
    capture_lex $P2257
    .const 'Sub' $P2253 = "391_1321350766.1143" 
    capture_lex $P2253
    .const 'Sub' $P2252 = "390_1321350766.1143" 
    capture_lex $P2252
    .const 'Sub' $P2248 = "389_1321350766.1143" 
    capture_lex $P2248
    .const 'Sub' $P2247 = "388_1321350766.1143" 
    capture_lex $P2247
    .const 'Sub' $P2243 = "387_1321350766.1143" 
    capture_lex $P2243
    .const 'Sub' $P2242 = "386_1321350766.1143" 
    capture_lex $P2242
    .const 'Sub' $P2238 = "385_1321350766.1143" 
    capture_lex $P2238
    .const 'Sub' $P2237 = "384_1321350766.1143" 
    capture_lex $P2237
    .const 'Sub' $P2233 = "383_1321350766.1143" 
    capture_lex $P2233
    .const 'Sub' $P2232 = "382_1321350766.1143" 
    capture_lex $P2232
    .const 'Sub' $P2228 = "381_1321350766.1143" 
    capture_lex $P2228
    .const 'Sub' $P2227 = "380_1321350766.1143" 
    capture_lex $P2227
    .const 'Sub' $P2223 = "379_1321350766.1143" 
    capture_lex $P2223
    .const 'Sub' $P2222 = "378_1321350766.1143" 
    capture_lex $P2222
    .const 'Sub' $P2218 = "377_1321350766.1143" 
    capture_lex $P2218
    .const 'Sub' $P2217 = "376_1321350766.1143" 
    capture_lex $P2217
    .const 'Sub' $P2213 = "375_1321350766.1143" 
    capture_lex $P2213
    .const 'Sub' $P2212 = "374_1321350766.1143" 
    capture_lex $P2212
    .const 'Sub' $P2208 = "373_1321350766.1143" 
    capture_lex $P2208
    .const 'Sub' $P2207 = "372_1321350766.1143" 
    capture_lex $P2207
    .const 'Sub' $P2203 = "371_1321350766.1143" 
    capture_lex $P2203
    .const 'Sub' $P2202 = "370_1321350766.1143" 
    capture_lex $P2202
    .const 'Sub' $P2198 = "369_1321350766.1143" 
    capture_lex $P2198
    .const 'Sub' $P2197 = "368_1321350766.1143" 
    capture_lex $P2197
    .const 'Sub' $P2193 = "367_1321350766.1143" 
    capture_lex $P2193
    .const 'Sub' $P2192 = "366_1321350766.1143" 
    capture_lex $P2192
    .const 'Sub' $P2188 = "365_1321350766.1143" 
    capture_lex $P2188
    .const 'Sub' $P2187 = "364_1321350766.1143" 
    capture_lex $P2187
    .const 'Sub' $P2183 = "363_1321350766.1143" 
    capture_lex $P2183
    .const 'Sub' $P2182 = "362_1321350766.1143" 
    capture_lex $P2182
    .const 'Sub' $P2178 = "361_1321350766.1143" 
    capture_lex $P2178
    .const 'Sub' $P2177 = "360_1321350766.1143" 
    capture_lex $P2177
    .const 'Sub' $P2173 = "359_1321350766.1143" 
    capture_lex $P2173
    .const 'Sub' $P2172 = "358_1321350766.1143" 
    capture_lex $P2172
    .const 'Sub' $P2168 = "357_1321350766.1143" 
    capture_lex $P2168
    .const 'Sub' $P2167 = "356_1321350766.1143" 
    capture_lex $P2167
    .const 'Sub' $P2163 = "355_1321350766.1143" 
    capture_lex $P2163
    .const 'Sub' $P2162 = "354_1321350766.1143" 
    capture_lex $P2162
    .const 'Sub' $P2158 = "353_1321350766.1143" 
    capture_lex $P2158
    .const 'Sub' $P2157 = "352_1321350766.1143" 
    capture_lex $P2157
    .const 'Sub' $P2153 = "351_1321350766.1143" 
    capture_lex $P2153
    .const 'Sub' $P2152 = "350_1321350766.1143" 
    capture_lex $P2152
    .const 'Sub' $P2148 = "349_1321350766.1143" 
    capture_lex $P2148
    .const 'Sub' $P2147 = "348_1321350766.1143" 
    capture_lex $P2147
    .const 'Sub' $P2143 = "347_1321350766.1143" 
    capture_lex $P2143
    .const 'Sub' $P2142 = "346_1321350766.1143" 
    capture_lex $P2142
    .const 'Sub' $P2138 = "345_1321350766.1143" 
    capture_lex $P2138
    .const 'Sub' $P2137 = "344_1321350766.1143" 
    capture_lex $P2137
    .const 'Sub' $P2133 = "343_1321350766.1143" 
    capture_lex $P2133
    .const 'Sub' $P2132 = "342_1321350766.1143" 
    capture_lex $P2132
    .const 'Sub' $P2128 = "341_1321350766.1143" 
    capture_lex $P2128
    .const 'Sub' $P2127 = "340_1321350766.1143" 
    capture_lex $P2127
    .const 'Sub' $P2123 = "339_1321350766.1143" 
    capture_lex $P2123
    .const 'Sub' $P2122 = "338_1321350766.1143" 
    capture_lex $P2122
    .const 'Sub' $P2118 = "337_1321350766.1143" 
    capture_lex $P2118
    .const 'Sub' $P2117 = "336_1321350766.1143" 
    capture_lex $P2117
    .const 'Sub' $P2113 = "335_1321350766.1143" 
    capture_lex $P2113
    .const 'Sub' $P2112 = "334_1321350766.1143" 
    capture_lex $P2112
    .const 'Sub' $P2108 = "333_1321350766.1143" 
    capture_lex $P2108
    .const 'Sub' $P2107 = "332_1321350766.1143" 
    capture_lex $P2107
    .const 'Sub' $P2103 = "331_1321350766.1143" 
    capture_lex $P2103
    .const 'Sub' $P2102 = "330_1321350766.1143" 
    capture_lex $P2102
    .const 'Sub' $P2098 = "329_1321350766.1143" 
    capture_lex $P2098
    .const 'Sub' $P2097 = "328_1321350766.1143" 
    capture_lex $P2097
    .const 'Sub' $P2094 = "327_1321350766.1143" 
    capture_lex $P2094
    .const 'Sub' $P2093 = "326_1321350766.1143" 
    capture_lex $P2093
    .const 'Sub' $P2090 = "325_1321350766.1143" 
    capture_lex $P2090
    .const 'Sub' $P2089 = "324_1321350766.1143" 
    capture_lex $P2089
    .const 'Sub' $P2086 = "323_1321350766.1143" 
    capture_lex $P2086
    .const 'Sub' $P2085 = "322_1321350766.1143" 
    capture_lex $P2085
    .const 'Sub' $P2082 = "321_1321350766.1143" 
    capture_lex $P2082
    .const 'Sub' $P2081 = "320_1321350766.1143" 
    capture_lex $P2081
    .const 'Sub' $P2078 = "319_1321350766.1143" 
    capture_lex $P2078
    .const 'Sub' $P2077 = "318_1321350766.1143" 
    capture_lex $P2077
    .const 'Sub' $P2074 = "317_1321350766.1143" 
    capture_lex $P2074
    .const 'Sub' $P2073 = "316_1321350766.1143" 
    capture_lex $P2073
    .const 'Sub' $P2070 = "315_1321350766.1143" 
    capture_lex $P2070
    .const 'Sub' $P2069 = "314_1321350766.1143" 
    capture_lex $P2069
    .const 'Sub' $P2066 = "313_1321350766.1143" 
    capture_lex $P2066
    .const 'Sub' $P2065 = "312_1321350766.1143" 
    capture_lex $P2065
    .const 'Sub' $P2060 = "311_1321350766.1143" 
    capture_lex $P2060
    .const 'Sub' $P2059 = "310_1321350766.1143" 
    capture_lex $P2059
    .const 'Sub' $P2056 = "309_1321350766.1143" 
    capture_lex $P2056
    .const 'Sub' $P2055 = "308_1321350766.1143" 
    capture_lex $P2055
    .const 'Sub' $P2052 = "307_1321350766.1143" 
    capture_lex $P2052
    .const 'Sub' $P2051 = "306_1321350766.1143" 
    capture_lex $P2051
    .const 'Sub' $P2048 = "305_1321350766.1143" 
    capture_lex $P2048
    .const 'Sub' $P2047 = "304_1321350766.1143" 
    capture_lex $P2047
    .const 'Sub' $P2042 = "303_1321350766.1143" 
    capture_lex $P2042
    .const 'Sub' $P2041 = "302_1321350766.1143" 
    capture_lex $P2041
    .const 'Sub' $P2036 = "301_1321350766.1143" 
    capture_lex $P2036
    .const 'Sub' $P2035 = "300_1321350766.1143" 
    capture_lex $P2035
    .const 'Sub' $P2032 = "299_1321350766.1143" 
    capture_lex $P2032
    .const 'Sub' $P2031 = "298_1321350766.1143" 
    capture_lex $P2031
    .const 'Sub' $P2028 = "297_1321350766.1143" 
    capture_lex $P2028
    .const 'Sub' $P2027 = "296_1321350766.1143" 
    capture_lex $P2027
    .const 'Sub' $P2024 = "295_1321350766.1143" 
    capture_lex $P2024
    .const 'Sub' $P2023 = "294_1321350766.1143" 
    capture_lex $P2023
    .const 'Sub' $P2020 = "293_1321350766.1143" 
    capture_lex $P2020
    .const 'Sub' $P2019 = "292_1321350766.1143" 
    capture_lex $P2019
    .const 'Sub' $P2015 = "291_1321350766.1143" 
    capture_lex $P2015
    .const 'Sub' $P2014 = "290_1321350766.1143" 
    capture_lex $P2014
    .const 'Sub' $P2010 = "289_1321350766.1143" 
    capture_lex $P2010
    .const 'Sub' $P2009 = "288_1321350766.1143" 
    capture_lex $P2009
    .const 'Sub' $P2005 = "287_1321350766.1143" 
    capture_lex $P2005
    .const 'Sub' $P2004 = "286_1321350766.1143" 
    capture_lex $P2004
    .const 'Sub' $P2000 = "285_1321350766.1143" 
    capture_lex $P2000
    .const 'Sub' $P1999 = "284_1321350766.1143" 
    capture_lex $P1999
    .const 'Sub' $P1996 = "283_1321350766.1143" 
    capture_lex $P1996
    .const 'Sub' $P1995 = "282_1321350766.1143" 
    capture_lex $P1995
    .const 'Sub' $P1992 = "281_1321350766.1143" 
    capture_lex $P1992
    .const 'Sub' $P1987 = "278_1321350766.1143" 
    capture_lex $P1987
    .const 'Sub' $P1981 = "277_1321350766.1143" 
    capture_lex $P1981
    .const 'Sub' $P1980 = "276_1321350766.1143" 
    capture_lex $P1980
    .const 'Sub' $P1976 = "275_1321350766.1143" 
    capture_lex $P1976
    .const 'Sub' $P1975 = "274_1321350766.1143" 
    capture_lex $P1975
    .const 'Sub' $P1972 = "273_1321350766.1143" 
    capture_lex $P1972
    .const 'Sub' $P1971 = "272_1321350766.1143" 
    capture_lex $P1971
    .const 'Sub' $P1967 = "271_1321350766.1143" 
    capture_lex $P1967
    .const 'Sub' $P1966 = "270_1321350766.1143" 
    capture_lex $P1966
    .const 'Sub' $P1963 = "269_1321350766.1143" 
    capture_lex $P1963
    .const 'Sub' $P1962 = "268_1321350766.1143" 
    capture_lex $P1962
    .const 'Sub' $P1956 = "266_1321350766.1143" 
    capture_lex $P1956
    .const 'Sub' $P1955 = "265_1321350766.1143" 
    capture_lex $P1955
    .const 'Sub' $P1949 = "264_1321350766.1143" 
    capture_lex $P1949
    .const 'Sub' $P1948 = "263_1321350766.1143" 
    capture_lex $P1948
    .const 'Sub' $P1944 = "262_1321350766.1143" 
    capture_lex $P1944
    .const 'Sub' $P1943 = "261_1321350766.1143" 
    capture_lex $P1943
    .const 'Sub' $P1937 = "260_1321350766.1143" 
    capture_lex $P1937
    .const 'Sub' $P1936 = "259_1321350766.1143" 
    capture_lex $P1936
    .const 'Sub' $P1931 = "258_1321350766.1143" 
    capture_lex $P1931
    .const 'Sub' $P1930 = "257_1321350766.1143" 
    capture_lex $P1930
    .const 'Sub' $P1927 = "256_1321350766.1143" 
    capture_lex $P1927
    .const 'Sub' $P1926 = "255_1321350766.1143" 
    capture_lex $P1926
    .const 'Sub' $P1922 = "254_1321350766.1143" 
    capture_lex $P1922
    .const 'Sub' $P1917 = "251_1321350766.1143" 
    capture_lex $P1917
    .const 'Sub' $P1910 = "250_1321350766.1143" 
    capture_lex $P1910
    .const 'Sub' $P1909 = "249_1321350766.1143" 
    capture_lex $P1909
    .const 'Sub' $P1899 = "248_1321350766.1143" 
    capture_lex $P1899
    .const 'Sub' $P1898 = "247_1321350766.1143" 
    capture_lex $P1898
    .const 'Sub' $P1892 = "246_1321350766.1143" 
    capture_lex $P1892
    .const 'Sub' $P1887 = "243_1321350766.1143" 
    capture_lex $P1887
    .const 'Sub' $P1884 = "242_1321350766.1143" 
    capture_lex $P1884
    .const 'Sub' $P1883 = "241_1321350766.1143" 
    capture_lex $P1883
    .const 'Sub' $P1880 = "240_1321350766.1143" 
    capture_lex $P1880
    .const 'Sub' $P1879 = "239_1321350766.1143" 
    capture_lex $P1879
    .const 'Sub' $P1876 = "238_1321350766.1143" 
    capture_lex $P1876
    .const 'Sub' $P1875 = "237_1321350766.1143" 
    capture_lex $P1875
    .const 'Sub' $P1868 = "236_1321350766.1143" 
    capture_lex $P1868
    .const 'Sub' $P1867 = "235_1321350766.1143" 
    capture_lex $P1867
    .const 'Sub' $P1854 = "234_1321350766.1143" 
    capture_lex $P1854
    .const 'Sub' $P1853 = "233_1321350766.1143" 
    capture_lex $P1853
    .const 'Sub' $P1845 = "231_1321350766.1143" 
    capture_lex $P1845
    .const 'Sub' $P1844 = "230_1321350766.1143" 
    capture_lex $P1844
    .const 'Sub' $P1840 = "229_1321350766.1143" 
    capture_lex $P1840
    .const 'Sub' $P1839 = "228_1321350766.1143" 
    capture_lex $P1839
    .const 'Sub' $P1833 = "227_1321350766.1143" 
    capture_lex $P1833
    .const 'Sub' $P1832 = "226_1321350766.1143" 
    capture_lex $P1832
    .const 'Sub' $P1826 = "225_1321350766.1143" 
    capture_lex $P1826
    .const 'Sub' $P1821 = "222_1321350766.1143" 
    capture_lex $P1821
    .const 'Sub' $P1816 = "220_1321350766.1143" 
    capture_lex $P1816
    .const 'Sub' $P1815 = "219_1321350766.1143" 
    capture_lex $P1815
    .const 'Sub' $P1800 = "217_1321350766.1143" 
    capture_lex $P1800
    .const 'Sub' $P1799 = "216_1321350766.1143" 
    capture_lex $P1799
    .const 'Sub' $P1788 = "215_1321350766.1143" 
    capture_lex $P1788
    .const 'Sub' $P1787 = "214_1321350766.1143" 
    capture_lex $P1787
    .const 'Sub' $P1783 = "213_1321350766.1143" 
    capture_lex $P1783
    .const 'Sub' $P1782 = "212_1321350766.1143" 
    capture_lex $P1782
    .const 'Sub' $P1778 = "211_1321350766.1143" 
    capture_lex $P1778
    .const 'Sub' $P1773 = "208_1321350766.1143" 
    capture_lex $P1773
    .const 'Sub' $P1763 = "206_1321350766.1143" 
    capture_lex $P1763
    .const 'Sub' $P1762 = "205_1321350766.1143" 
    capture_lex $P1762
    .const 'Sub' $P1758 = "204_1321350766.1143" 
    capture_lex $P1758
    .const 'Sub' $P1757 = "203_1321350766.1143" 
    capture_lex $P1757
    .const 'Sub' $P1750 = "201_1321350766.1143" 
    capture_lex $P1750
    .const 'Sub' $P1749 = "200_1321350766.1143" 
    capture_lex $P1749
    .const 'Sub' $P1744 = "199_1321350766.1143" 
    capture_lex $P1744
    .const 'Sub' $P1743 = "198_1321350766.1143" 
    capture_lex $P1743
    .const 'Sub' $P1739 = "197_1321350766.1143" 
    capture_lex $P1739
    .const 'Sub' $P1738 = "196_1321350766.1143" 
    capture_lex $P1738
    .const 'Sub' $P1734 = "195_1321350766.1143" 
    capture_lex $P1734
    .const 'Sub' $P1733 = "194_1321350766.1143" 
    capture_lex $P1733
    .const 'Sub' $P1729 = "193_1321350766.1143" 
    capture_lex $P1729
    .const 'Sub' $P1724 = "190_1321350766.1143" 
    capture_lex $P1724
    .const 'Sub' $P1680 = "188_1321350766.1143" 
    capture_lex $P1680
    .const 'Sub' $P1679 = "187_1321350766.1143" 
    capture_lex $P1679
    .const 'Sub' $P1673 = "186_1321350766.1143" 
    capture_lex $P1673
    .const 'Sub' $P1672 = "185_1321350766.1143" 
    capture_lex $P1672
    .const 'Sub' $P1666 = "184_1321350766.1143" 
    capture_lex $P1666
    .const 'Sub' $P1665 = "183_1321350766.1143" 
    capture_lex $P1665
    .const 'Sub' $P1659 = "182_1321350766.1143" 
    capture_lex $P1659
    .const 'Sub' $P1658 = "181_1321350766.1143" 
    capture_lex $P1658
    .const 'Sub' $P1652 = "180_1321350766.1143" 
    capture_lex $P1652
    .const 'Sub' $P1651 = "179_1321350766.1143" 
    capture_lex $P1651
    .const 'Sub' $P1645 = "178_1321350766.1143" 
    capture_lex $P1645
    .const 'Sub' $P1644 = "177_1321350766.1143" 
    capture_lex $P1644
    .const 'Sub' $P1638 = "176_1321350766.1143" 
    capture_lex $P1638
    .const 'Sub' $P1637 = "175_1321350766.1143" 
    capture_lex $P1637
    .const 'Sub' $P1631 = "174_1321350766.1143" 
    capture_lex $P1631
    .const 'Sub' $P1626 = "171_1321350766.1143" 
    capture_lex $P1626
    .const 'Sub' $P1623 = "170_1321350766.1143" 
    capture_lex $P1623
    .const 'Sub' $P1622 = "169_1321350766.1143" 
    capture_lex $P1622
    .const 'Sub' $P1619 = "168_1321350766.1143" 
    capture_lex $P1619
    .const 'Sub' $P1618 = "167_1321350766.1143" 
    capture_lex $P1618
    .const 'Sub' $P1610 = "166_1321350766.1143" 
    capture_lex $P1610
    .const 'Sub' $P1609 = "165_1321350766.1143" 
    capture_lex $P1609
    .const 'Sub' $P1602 = "164_1321350766.1143" 
    capture_lex $P1602
    .const 'Sub' $P1601 = "163_1321350766.1143" 
    capture_lex $P1601
    .const 'Sub' $P1597 = "162_1321350766.1143" 
    capture_lex $P1597
    .const 'Sub' $P1596 = "161_1321350766.1143" 
    capture_lex $P1596
    .const 'Sub' $P1593 = "160_1321350766.1143" 
    capture_lex $P1593
    .const 'Sub' $P1592 = "159_1321350766.1143" 
    capture_lex $P1592
    .const 'Sub' $P1589 = "158_1321350766.1143" 
    capture_lex $P1589
    .const 'Sub' $P1588 = "157_1321350766.1143" 
    capture_lex $P1588
    .const 'Sub' $P1585 = "156_1321350766.1143" 
    capture_lex $P1585
    .const 'Sub' $P1584 = "155_1321350766.1143" 
    capture_lex $P1584
    .const 'Sub' $P1571 = "152_1321350766.1143" 
    capture_lex $P1571
    .const 'Sub' $P1570 = "151_1321350766.1143" 
    capture_lex $P1570
    .const 'Sub' $P1567 = "150_1321350766.1143" 
    capture_lex $P1567
    .const 'Sub' $P1566 = "149_1321350766.1143" 
    capture_lex $P1566
    .const 'Sub' $P1563 = "148_1321350766.1143" 
    capture_lex $P1563
    .const 'Sub' $P1562 = "147_1321350766.1143" 
    capture_lex $P1562
    .const 'Sub' $P1559 = "146_1321350766.1143" 
    capture_lex $P1559
    .const 'Sub' $P1558 = "145_1321350766.1143" 
    capture_lex $P1558
    .const 'Sub' $P1555 = "144_1321350766.1143" 
    capture_lex $P1555
    .const 'Sub' $P1554 = "143_1321350766.1143" 
    capture_lex $P1554
    .const 'Sub' $P1551 = "142_1321350766.1143" 
    capture_lex $P1551
    .const 'Sub' $P1550 = "141_1321350766.1143" 
    capture_lex $P1550
    .const 'Sub' $P1547 = "140_1321350766.1143" 
    capture_lex $P1547
    .const 'Sub' $P1546 = "139_1321350766.1143" 
    capture_lex $P1546
    .const 'Sub' $P1542 = "138_1321350766.1143" 
    capture_lex $P1542
    .const 'Sub' $P1541 = "137_1321350766.1143" 
    capture_lex $P1541
    .const 'Sub' $P1537 = "136_1321350766.1143" 
    capture_lex $P1537
    .const 'Sub' $P1536 = "135_1321350766.1143" 
    capture_lex $P1536
    .const 'Sub' $P1532 = "134_1321350766.1143" 
    capture_lex $P1532
    .const 'Sub' $P1527 = "131_1321350766.1143" 
    capture_lex $P1527
    .const 'Sub' $P1523 = "130_1321350766.1143" 
    capture_lex $P1523
    .const 'Sub' $P1522 = "129_1321350766.1143" 
    capture_lex $P1522
    .const 'Sub' $P1518 = "128_1321350766.1143" 
    capture_lex $P1518
    .const 'Sub' $P1513 = "125_1321350766.1143" 
    capture_lex $P1513
    .const 'Sub' $P1509 = "124_1321350766.1143" 
    capture_lex $P1509
    .const 'Sub' $P1508 = "123_1321350766.1143" 
    capture_lex $P1508
    .const 'Sub' $P1504 = "122_1321350766.1143" 
    capture_lex $P1504
    .const 'Sub' $P1503 = "121_1321350766.1143" 
    capture_lex $P1503
    .const 'Sub' $P1499 = "120_1321350766.1143" 
    capture_lex $P1499
    .const 'Sub' $P1494 = "117_1321350766.1143" 
    capture_lex $P1494
    .const 'Sub' $P1490 = "116_1321350766.1143" 
    capture_lex $P1490
    .const 'Sub' $P1489 = "115_1321350766.1143" 
    capture_lex $P1489
    .const 'Sub' $P1485 = "114_1321350766.1143" 
    capture_lex $P1485
    .const 'Sub' $P1484 = "113_1321350766.1143" 
    capture_lex $P1484
    .const 'Sub' $P1480 = "112_1321350766.1143" 
    capture_lex $P1480
    .const 'Sub' $P1479 = "111_1321350766.1143" 
    capture_lex $P1479
    .const 'Sub' $P1470 = "110_1321350766.1143" 
    capture_lex $P1470
    .const 'Sub' $P1469 = "109_1321350766.1143" 
    capture_lex $P1469
    .const 'Sub' $P1464 = "108_1321350766.1143" 
    capture_lex $P1464
    .const 'Sub' $P1463 = "107_1321350766.1143" 
    capture_lex $P1463
    .const 'Sub' $P1454 = "105_1321350766.1143" 
    capture_lex $P1454
    .const 'Sub' $P1453 = "104_1321350766.1143" 
    capture_lex $P1453
    .const 'Sub' $P1447 = "103_1321350766.1143" 
    capture_lex $P1447
    .const 'Sub' $P1446 = "102_1321350766.1143" 
    capture_lex $P1446
    .const 'Sub' $P1442 = "101_1321350766.1143" 
    capture_lex $P1442
    .const 'Sub' $P1437 = "98_1321350766.1143" 
    capture_lex $P1437
    .const 'Sub' $P1434 = "97_1321350766.1143" 
    capture_lex $P1434
    .const 'Sub' $P1433 = "96_1321350766.1143" 
    capture_lex $P1433
    .const 'Sub' $P1430 = "95_1321350766.1143" 
    capture_lex $P1430
    .const 'Sub' $P1425 = "92_1321350766.1143" 
    capture_lex $P1425
    .const 'Sub' $P1422 = "91_1321350766.1143" 
    capture_lex $P1422
    .const 'Sub' $P1421 = "90_1321350766.1143" 
    capture_lex $P1421
    .const 'Sub' $P1418 = "89_1321350766.1143" 
    capture_lex $P1418
    .const 'Sub' $P1417 = "88_1321350766.1143" 
    capture_lex $P1417
    .const 'Sub' $P1414 = "87_1321350766.1143" 
    capture_lex $P1414
    .const 'Sub' $P1413 = "86_1321350766.1143" 
    capture_lex $P1413
    .const 'Sub' $P1410 = "85_1321350766.1143" 
    capture_lex $P1410
    .const 'Sub' $P1409 = "84_1321350766.1143" 
    capture_lex $P1409
    .const 'Sub' $P1406 = "83_1321350766.1143" 
    capture_lex $P1406
    .const 'Sub' $P1405 = "82_1321350766.1143" 
    capture_lex $P1405
    .const 'Sub' $P1399 = "81_1321350766.1143" 
    capture_lex $P1399
    .const 'Sub' $P1398 = "80_1321350766.1143" 
    capture_lex $P1398
    .const 'Sub' $P1394 = "79_1321350766.1143" 
    capture_lex $P1394
    .const 'Sub' $P1393 = "78_1321350766.1143" 
    capture_lex $P1393
    .const 'Sub' $P1389 = "77_1321350766.1143" 
    capture_lex $P1389
    .const 'Sub' $P1388 = "76_1321350766.1143" 
    capture_lex $P1388
    .const 'Sub' $P1384 = "75_1321350766.1143" 
    capture_lex $P1384
    .const 'Sub' $P1383 = "74_1321350766.1143" 
    capture_lex $P1383
    .const 'Sub' $P1380 = "73_1321350766.1143" 
    capture_lex $P1380
    .const 'Sub' $P1379 = "72_1321350766.1143" 
    capture_lex $P1379
    .const 'Sub' $P1375 = "71_1321350766.1143" 
    capture_lex $P1375
    .const 'Sub' $P1374 = "70_1321350766.1143" 
    capture_lex $P1374
    .const 'Sub' $P1361 = "68_1321350766.1143" 
    capture_lex $P1361
    .const 'Sub' $P1360 = "67_1321350766.1143" 
    capture_lex $P1360
    .const 'Sub' $P1355 = "66_1321350766.1143" 
    capture_lex $P1355
    .const 'Sub' $P1354 = "65_1321350766.1143" 
    capture_lex $P1354
    .const 'Sub' $P1345 = "64_1321350766.1143" 
    capture_lex $P1345
    .const 'Sub' $P1344 = "63_1321350766.1143" 
    capture_lex $P1344
    .const 'Sub' $P1308 = "61_1321350766.1143" 
    capture_lex $P1308
    .const 'Sub' $P1307 = "60_1321350766.1143" 
    capture_lex $P1307
    .const 'Sub' $P1294 = "58_1321350766.1143" 
    capture_lex $P1294
    .const 'Sub' $P1293 = "57_1321350766.1143" 
    capture_lex $P1293
    .const 'Sub' $P1284 = "56_1321350766.1143" 
    capture_lex $P1284
    .const 'Sub' $P1283 = "55_1321350766.1143" 
    capture_lex $P1283
    .const 'Sub' $P1273 = "54_1321350766.1143" 
    capture_lex $P1273
    .const 'Sub' $P1272 = "53_1321350766.1143" 
    capture_lex $P1272
    .const 'Sub' $P1267 = "52_1321350766.1143" 
    capture_lex $P1267
    .const 'Sub' $P1266 = "51_1321350766.1143" 
    capture_lex $P1266
    .const 'Sub' $P1261 = "50_1321350766.1143" 
    capture_lex $P1261
    .const 'Sub' $P1260 = "49_1321350766.1143" 
    capture_lex $P1260
    .const 'Sub' $P1256 = "48_1321350766.1143" 
    capture_lex $P1256
    .const 'Sub' $P1242 = "47_1321350766.1143" 
    capture_lex $P1242
    .lex "$?PACKAGE", $P1240
    .lex "$?CLASS", $P1241
.annotate 'line', 1082
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1083
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1084
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1085
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1086
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1087
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1088
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1089
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1090
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1091
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1092
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1093
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1094
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1095
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1096
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1195
    .const 'Sub' $P2334 = "424_1321350766.1143" 
    newclosure $P2342, $P2334
.annotate 'line', 469
    .return ($P2342)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("47_1321350766.1143") :outer("46_1321350766.1143")
    .param pmc param_1243
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 470
    .lex "self", param_1243
.annotate 'line', 472
    $P1245 = root_new ['parrot';'Hash']
    set $P1244, $P1245
    .lex "%*LANG", $P1244
.annotate 'line', 481
    $P1247 = root_new ['parrot';'Hash']
    set $P1246, $P1247
    .lex "%*HOW", $P1246
.annotate 'line', 488
    new $P103, "Undef"
    set $P1248, $P103
    .lex "$file", $P1248
.annotate 'line', 489
    new $P104, "Undef"
    set $P1249, $P104
    .lex "$*SC", $P1249
.annotate 'line', 493
    new $P105, "Undef"
    set $P1250, $P105
    .lex "$*SCOPE", $P1250
.annotate 'line', 494
    new $P106, "Undef"
    set $P1251, $P106
    .lex "$*MULTINESS", $P1251
.annotate 'line', 495
    new $P107, "Undef"
    set $P1252, $P107
    .lex "$*PKGDECL", $P1252
.annotate 'line', 496
    new $P108, "Undef"
    set $P1253, $P108
    .lex "$*INVOCANT_OK", $P1253
.annotate 'line', 497
    new $P109, "Undef"
    set $P1254, $P109
    .lex "$*RETURN_USED", $P1254
.annotate 'line', 470
    find_lex $P112, "%*LANG"
    unless_null $P112, vivify_864
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%LANG"]
    unless_null $P112, vivify_865
    die "Contextual %*LANG not found"
  vivify_865:
  vivify_864:
.annotate 'line', 473
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["Regex"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_866
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_867
    die "Contextual %*LANG not found"
  vivify_867:
    store_lex "%*LANG", $P116
  vivify_866:
    set $P116["Regex"], $P113
.annotate 'line', 474
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["RegexActions"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_868
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_869
    die "Contextual %*LANG not found"
  vivify_869:
    store_lex "%*LANG", $P116
  vivify_868:
    set $P116["Regex-actions"], $P113
.annotate 'line', 475
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["Grammar"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_870
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_871
    die "Contextual %*LANG not found"
  vivify_871:
    store_lex "%*LANG", $P116
  vivify_870:
    set $P116["MAIN"], $P113
.annotate 'line', 476
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "NQP"
    get_who $P112, $P111
    set $P113, $P112["Actions"]
    find_lex $P116, "%*LANG"
    unless_null $P116, vivify_872
    get_hll_global $P114, "GLOBAL"
    get_who $P115, $P114
    set $P116, $P115["%LANG"]
    unless_null $P116, vivify_873
    die "Contextual %*LANG not found"
  vivify_873:
    store_lex "%*LANG", $P116
  vivify_872:
    set $P116["MAIN-actions"], $P113
.annotate 'line', 470
    find_lex $P112, "%*HOW"
    unless_null $P112, vivify_874
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%HOW"]
    unless_null $P112, vivify_875
    die "Contextual %*HOW not found"
  vivify_875:
  vivify_874:
.annotate 'line', 482
    get_knowhow $P110
    find_lex $P113, "%*HOW"
    unless_null $P113, vivify_876
    get_hll_global $P111, "GLOBAL"
    get_who $P112, $P111
    set $P113, $P112["%HOW"]
    unless_null $P113, vivify_877
    die "Contextual %*HOW not found"
  vivify_877:
    store_lex "%*HOW", $P113
  vivify_876:
    set $P113["knowhow"], $P110
.annotate 'line', 483
    get_knowhow_attribute $P110
    find_lex $P113, "%*HOW"
    unless_null $P113, vivify_878
    get_hll_global $P111, "GLOBAL"
    get_who $P112, $P111
    set $P113, $P112["%HOW"]
    unless_null $P113, vivify_879
    die "Contextual %*HOW not found"
  vivify_879:
    store_lex "%*HOW", $P113
  vivify_878:
    set $P113["knowhow-attr"], $P110
.annotate 'line', 488
    find_caller_lex $P110, "$?FILES"
    store_lex "$file", $P110
.annotate 'line', 489
    find_lex $P111, "$file"
    unless_null $P111, vivify_880
    new $P111, "Undef"
  vivify_880:
    isnull $I100, $P111
    if $I100, if_1255
.annotate 'line', 491
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P120, $P119["SymbolTable"]
    time $N101
    set $S101, $N101
    find_lex $P121, "$file"
    unless_null $P121, vivify_881
    new $P121, "Undef"
  vivify_881:
    $P122 = $P120."new"($S101 :named("handle"), $P121 :named("description"))
    set $P110, $P122
.annotate 'line', 489
    goto if_1255_end
  if_1255:
.annotate 'line', 490
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "NQP"
    get_who $P114, $P113
    set $P115, $P114["SymbolTable"]
    time $N100
    set $S100, $N100
    $P116 = $P115."new"($S100 :named("handle"))
    set $P110, $P116
  if_1255_end:
.annotate 'line', 489
    store_lex "$*SC", $P110
.annotate 'line', 493
    new $P110, "String"
    assign $P110, ""
    store_lex "$*SCOPE", $P110
.annotate 'line', 494
    new $P110, "String"
    assign $P110, ""
    store_lex "$*MULTINESS", $P110
.annotate 'line', 495
    new $P110, "String"
    assign $P110, ""
    store_lex "$*PKGDECL", $P110
.annotate 'line', 496
    new $P110, "Float"
    assign $P110, 0
    store_lex "$*INVOCANT_OK", $P110
.annotate 'line', 497
    new $P110, "Float"
    assign $P110, 0
    store_lex "$*RETURN_USED", $P110
.annotate 'line', 498
    find_lex $P110, "self"
    $P111 = $P110."comp_unit"()
.annotate 'line', 470
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("48_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_882
    rx1257_cur."!cursor_debug"("START", "identifier")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1258_done
    goto rxscan1258_scan
  rxscan1258_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1258_done
  rxscan1258_scan:
    set_addr $I10, rxscan1258_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1258_done:
.annotate 'line', 503
  # rx subrule "ident" subtype=method negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."ident"()
    unless $P10, rx1257_fail
    rx1257_pos = $P10."pos"()
  # rx rxquantr1259 ** 0..*
    set_addr $I10, rxquantr1259_done
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxquantr1259_loop:
  # rx enumcharlist negate=0 
    ge rx1257_pos, rx1257_eos, rx1257_fail
    sub $I10, rx1257_pos, rx1257_off
    substr $S10, rx1257_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1257_fail
    inc rx1257_pos
  # rx subrule "ident" subtype=method negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."ident"()
    unless $P10, rx1257_fail
    rx1257_pos = $P10."pos"()
    set_addr $I10, rxquantr1259_done
    (rx1257_rep) = rx1257_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1259_done
    rx1257_cur."!mark_push"(rx1257_rep, rx1257_pos, $I10)
    goto rxquantr1259_loop
  rxquantr1259_done:
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, "identifier")
    if_null rx1257_debug, debug_883
    rx1257_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1257_pos)
  debug_883:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 469
    if_null rx1257_debug, debug_884
    rx1257_cur."!cursor_debug"("NEXT", "identifier")
  debug_884:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_885
    rx1257_cur."!cursor_debug"("FAIL", "identifier")
  debug_885:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("49_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ident", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("50_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    rx1262_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_886
    rx1262_cur."!cursor_debug"("START", "name")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1263_done
    goto rxscan1263_scan
  rxscan1263_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1263_done
  rxscan1263_scan:
    set_addr $I10, rxscan1263_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1263_done:
.annotate 'line', 505
  # rx rxquantr1264 ** 1..*
    set_addr $I10, rxquantr1264_done
    rx1262_cur."!mark_push"(0, -1, $I10)
  rxquantr1264_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."identifier"()
    unless $P10, rx1262_fail
    goto rxsubrule1265_pass
  rxsubrule1265_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1262_fail
  rxsubrule1265_pass:
    set_addr $I10, rxsubrule1265_back
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1262_pos = $P10."pos"()
    set_addr $I10, rxquantr1264_done
    (rx1262_rep) = rx1262_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1264_done
    rx1262_cur."!mark_push"(rx1262_rep, rx1262_pos, $I10)
  # rx literal  "::"
    add $I11, rx1262_pos, 2
    gt $I11, rx1262_eos, rx1262_fail
    sub $I11, rx1262_pos, rx1262_off
    substr $S10, rx1262_tgt, $I11, 2
    ne $S10, "::", rx1262_fail
    add rx1262_pos, 2
    goto rxquantr1264_loop
  rxquantr1264_done:
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "name")
    if_null rx1262_debug, debug_887
    rx1262_cur."!cursor_debug"("PASS", "name", " at pos=", rx1262_pos)
  debug_887:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 469
    if_null rx1262_debug, debug_888
    rx1262_cur."!cursor_debug"("NEXT", "name")
  debug_888:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_889
    rx1262_cur."!cursor_debug"("FAIL", "name")
  debug_889:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("51_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("52_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1268_tgt
    .local int rx1268_pos
    .local int rx1268_off
    .local int rx1268_eos
    .local int rx1268_rep
    .local pmc rx1268_cur
    .local pmc rx1268_debug
    (rx1268_cur, rx1268_pos, rx1268_tgt, $I10) = self."!cursor_start"()
    rx1268_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1268_cur
    .local pmc match
    .lex "$/", match
    length rx1268_eos, rx1268_tgt
    gt rx1268_pos, rx1268_eos, rx1268_done
    set rx1268_off, 0
    lt rx1268_pos, 2, rx1268_start
    sub rx1268_off, rx1268_pos, 1
    substr rx1268_tgt, rx1268_tgt, rx1268_off
  rx1268_start:
    eq $I10, 1, rx1268_restart
    if_null rx1268_debug, debug_890
    rx1268_cur."!cursor_debug"("START", "deflongname")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1269_done
    goto rxscan1269_scan
  rxscan1269_loop:
    (rx1268_pos) = rx1268_cur."from"()
    inc rx1268_pos
    rx1268_cur."!cursor_from"(rx1268_pos)
    ge rx1268_pos, rx1268_eos, rxscan1269_done
  rxscan1269_scan:
    set_addr $I10, rxscan1269_loop
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10)
  rxscan1269_done:
.annotate 'line', 508
  # rx subrule "identifier" subtype=capture negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."identifier"()
    unless $P10, rx1268_fail
    rx1268_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1268_pos = $P10."pos"()
  # rx rxquantr1270 ** 0..1
    set_addr $I10, rxquantr1270_done
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10)
  rxquantr1270_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."colonpair"()
    unless $P10, rx1268_fail
    goto rxsubrule1271_pass
  rxsubrule1271_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1268_fail
  rxsubrule1271_pass:
    set_addr $I10, rxsubrule1271_back
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1268_pos = $P10."pos"()
    set_addr $I10, rxquantr1270_done
    (rx1268_rep) = rx1268_cur."!mark_commit"($I10)
  rxquantr1270_done:
.annotate 'line', 507
  # rx pass
    rx1268_cur."!cursor_pass"(rx1268_pos, "deflongname")
    if_null rx1268_debug, debug_891
    rx1268_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1268_pos)
  debug_891:
    .return (rx1268_cur)
  rx1268_restart:
.annotate 'line', 469
    if_null rx1268_debug, debug_892
    rx1268_cur."!cursor_debug"("NEXT", "deflongname")
  debug_892:
  rx1268_fail:
    (rx1268_rep, rx1268_pos, $I10, $P10) = rx1268_cur."!mark_fail"(0)
    lt rx1268_pos, -1, rx1268_done
    eq rx1268_pos, -1, rx1268_fail
    jump $I10
  rx1268_done:
    rx1268_cur."!cursor_fail"()
    if_null rx1268_debug, debug_893
    rx1268_cur."!cursor_debug"("FAIL", "deflongname")
  debug_893:
    .return (rx1268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("53_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("54_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1274_tgt
    .local int rx1274_pos
    .local int rx1274_off
    .local int rx1274_eos
    .local int rx1274_rep
    .local pmc rx1274_cur
    .local pmc rx1274_debug
    (rx1274_cur, rx1274_pos, rx1274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1274_cur
    .local pmc match
    .lex "$/", match
    length rx1274_eos, rx1274_tgt
    gt rx1274_pos, rx1274_eos, rx1274_done
    set rx1274_off, 0
    lt rx1274_pos, 2, rx1274_start
    sub rx1274_off, rx1274_pos, 1
    substr rx1274_tgt, rx1274_tgt, rx1274_off
  rx1274_start:
    eq $I10, 1, rx1274_restart
    if_null rx1274_debug, debug_894
    rx1274_cur."!cursor_debug"("START", "ENDSTMT")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1275_done
    goto rxscan1275_scan
  rxscan1275_loop:
    (rx1274_pos) = rx1274_cur."from"()
    inc rx1274_pos
    rx1274_cur."!cursor_from"(rx1274_pos)
    ge rx1274_pos, rx1274_eos, rxscan1275_done
  rxscan1275_scan:
    set_addr $I10, rxscan1275_loop
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxscan1275_done:
.annotate 'line', 515
  # rx rxquantr1276 ** 0..1
    set_addr $I10, rxquantr1276_done
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxquantr1276_loop:
  alt1277_0:
.annotate 'line', 512
    set_addr $I10, alt1277_1
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
.annotate 'line', 513
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1274_pos, rx1274_off
    set rx1274_rep, 0
    sub $I12, rx1274_eos, rx1274_pos
  rxenumcharlistq1278_loop:
    le $I12, 0, rxenumcharlistq1278_done
    substr $S10, rx1274_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1278_done
    inc rx1274_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1278_loop
  rxenumcharlistq1278_done:
    add rx1274_pos, rx1274_pos, rx1274_rep
  # rxanchor eol
    sub $I10, rx1274_pos, rx1274_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1274_tgt, $I10
    if $I11, rxanchor1279_done
    ne rx1274_pos, rx1274_eos, rx1274_fail
    eq rx1274_pos, 0, rxanchor1279_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1274_tgt, $I10
    if $I11, rx1274_fail
  rxanchor1279_done:
  # rx subrule "ws" subtype=method negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."ws"()
    unless $P10, rx1274_fail
    rx1274_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."MARKER"("endstmt")
    unless $P10, rx1274_fail
    goto alt1277_end
  alt1277_1:
.annotate 'line', 514
  # rx rxquantr1280 ** 0..1
    set_addr $I10, rxquantr1280_done
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxquantr1280_loop:
  # rx subrule "unv" subtype=method negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."unv"()
    unless $P10, rx1274_fail
    goto rxsubrule1281_pass
  rxsubrule1281_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1274_fail
  rxsubrule1281_pass:
    set_addr $I10, rxsubrule1281_back
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10, $P10)
    rx1274_pos = $P10."pos"()
    set_addr $I10, rxquantr1280_done
    (rx1274_rep) = rx1274_cur."!mark_commit"($I10)
  rxquantr1280_done:
  # rxanchor eol
    sub $I10, rx1274_pos, rx1274_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1274_tgt, $I10
    if $I11, rxanchor1282_done
    ne rx1274_pos, rx1274_eos, rx1274_fail
    eq rx1274_pos, 0, rxanchor1282_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1274_tgt, $I10
    if $I11, rx1274_fail
  rxanchor1282_done:
  # rx subrule "ws" subtype=method negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."ws"()
    unless $P10, rx1274_fail
    rx1274_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."MARKER"("endstmt")
    unless $P10, rx1274_fail
  alt1277_end:
.annotate 'line', 515
    set_addr $I10, rxquantr1276_done
    (rx1274_rep) = rx1274_cur."!mark_commit"($I10)
  rxquantr1276_done:
.annotate 'line', 511
  # rx pass
    rx1274_cur."!cursor_pass"(rx1274_pos, "ENDSTMT")
    if_null rx1274_debug, debug_895
    rx1274_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1274_pos)
  debug_895:
    .return (rx1274_cur)
  rx1274_restart:
.annotate 'line', 469
    if_null rx1274_debug, debug_896
    rx1274_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_896:
  rx1274_fail:
    (rx1274_rep, rx1274_pos, $I10, $P10) = rx1274_cur."!mark_fail"(0)
    lt rx1274_pos, -1, rx1274_done
    eq rx1274_pos, -1, rx1274_fail
    jump $I10
  rx1274_done:
    rx1274_cur."!cursor_fail"()
    if_null rx1274_debug, debug_897
    rx1274_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_897:
    .return (rx1274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("55_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("56_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1285_tgt
    .local int rx1285_pos
    .local int rx1285_off
    .local int rx1285_eos
    .local int rx1285_rep
    .local pmc rx1285_cur
    .local pmc rx1285_debug
    (rx1285_cur, rx1285_pos, rx1285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1285_cur
    .local pmc match
    .lex "$/", match
    length rx1285_eos, rx1285_tgt
    gt rx1285_pos, rx1285_eos, rx1285_done
    set rx1285_off, 0
    lt rx1285_pos, 2, rx1285_start
    sub rx1285_off, rx1285_pos, 1
    substr rx1285_tgt, rx1285_tgt, rx1285_off
  rx1285_start:
    eq $I10, 1, rx1285_restart
    if_null rx1285_debug, debug_898
    rx1285_cur."!cursor_debug"("START", "ws")
  debug_898:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1286_done
    goto rxscan1286_scan
  rxscan1286_loop:
    (rx1285_pos) = rx1285_cur."from"()
    inc rx1285_pos
    rx1285_cur."!cursor_from"(rx1285_pos)
    ge rx1285_pos, rx1285_eos, rxscan1286_done
  rxscan1286_scan:
    set_addr $I10, rxscan1286_loop
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxscan1286_done:
  alt1287_0:
.annotate 'line', 518
    set_addr $I10, alt1287_1
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
.annotate 'line', 519
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."MARKED"("ws")
    unless $P10, rx1285_fail
    goto alt1287_end
  alt1287_1:
.annotate 'line', 520
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."ww"()
    if $P10, rx1285_fail
.annotate 'line', 525
  # rx rxquantr1288 ** 0..*
    set_addr $I10, rxquantr1288_done
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxquantr1288_loop:
  alt1289_0:
.annotate 'line', 521
    set_addr $I10, alt1289_1
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1285_pos, rx1285_off
    set rx1285_rep, 0
    sub $I12, rx1285_eos, rx1285_pos
  rxenumcharlistq1290_loop:
    le $I12, 0, rxenumcharlistq1290_done
    substr $S10, rx1285_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1290_done
    inc rx1285_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1290_loop
  rxenumcharlistq1290_done:
    lt rx1285_rep, 1, rx1285_fail
    add rx1285_pos, rx1285_pos, rx1285_rep
    goto alt1289_end
  alt1289_1:
    set_addr $I10, alt1289_2
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
.annotate 'line', 522
  # rx literal  "#"
    add $I11, rx1285_pos, 1
    gt $I11, rx1285_eos, rx1285_fail
    sub $I11, rx1285_pos, rx1285_off
    ord $I11, rx1285_tgt, $I11
    ne $I11, 35, rx1285_fail
    add rx1285_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1285_pos, rx1285_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1285_tgt, $I10, rx1285_eos
    add rx1285_pos, rx1285_off, $I11
    goto alt1289_end
  alt1289_2:
    set_addr $I10, alt1289_3
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
.annotate 'line', 523
  # rxanchor bol
    eq rx1285_pos, 0, rxanchor1291_done
    ge rx1285_pos, rx1285_eos, rx1285_fail
    sub $I10, rx1285_pos, rx1285_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1285_tgt, $I10
    unless $I11, rx1285_fail
  rxanchor1291_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."pod_comment"()
    unless $P10, rx1285_fail
    rx1285_pos = $P10."pos"()
    goto alt1289_end
  alt1289_3:
.annotate 'line', 524
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1285_pos, rx1285_off
    set rx1285_rep, 0
    sub $I12, rx1285_eos, rx1285_pos
  rxenumcharlistq1292_loop:
    le $I12, 0, rxenumcharlistq1292_done
    substr $S10, rx1285_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1292_done
    inc rx1285_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1292_loop
  rxenumcharlistq1292_done:
    lt rx1285_rep, 1, rx1285_fail
    add rx1285_pos, rx1285_pos, rx1285_rep
  alt1289_end:
.annotate 'line', 525
    set_addr $I10, rxquantr1288_done
    (rx1285_rep) = rx1285_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1288_done
    rx1285_cur."!mark_push"(rx1285_rep, rx1285_pos, $I10)
    goto rxquantr1288_loop
  rxquantr1288_done:
.annotate 'line', 526
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."MARKER"("ws")
    unless $P10, rx1285_fail
  alt1287_end:
.annotate 'line', 518
  # rx pass
    rx1285_cur."!cursor_pass"(rx1285_pos, "ws")
    if_null rx1285_debug, debug_899
    rx1285_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1285_pos)
  debug_899:
    .return (rx1285_cur)
  rx1285_restart:
.annotate 'line', 469
    if_null rx1285_debug, debug_900
    rx1285_cur."!cursor_debug"("NEXT", "ws")
  debug_900:
  rx1285_fail:
    (rx1285_rep, rx1285_pos, $I10, $P10) = rx1285_cur."!mark_fail"(0)
    lt rx1285_pos, -1, rx1285_done
    eq rx1285_pos, -1, rx1285_fail
    jump $I10
  rx1285_done:
    rx1285_cur."!cursor_fail"()
    if_null rx1285_debug, debug_901
    rx1285_cur."!cursor_debug"("FAIL", "ws")
  debug_901:
    .return (rx1285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("57_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("58_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1300 = "59_1321350766.1143" 
    capture_lex $P1300
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_902
    rx1295_cur."!cursor_debug"("START", "unv")
  debug_902:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1296_done
    goto rxscan1296_scan
  rxscan1296_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1296_done
  rxscan1296_scan:
    set_addr $I10, rxscan1296_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1296_done:
  alt1297_0:
.annotate 'line', 531
    set_addr $I10, alt1297_1
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
.annotate 'line', 532
  # rxanchor bol
    eq rx1295_pos, 0, rxanchor1298_done
    ge rx1295_pos, rx1295_eos, rx1295_fail
    sub $I10, rx1295_pos, rx1295_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1295_tgt, $I10
    unless $I11, rx1295_fail
  rxanchor1298_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    .const 'Sub' $P1300 = "59_1321350766.1143" 
    capture_lex $P1300
    $P10 = rx1295_cur."before"($P1300)
    unless $P10, rx1295_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."pod_comment"()
    unless $P10, rx1295_fail
    rx1295_pos = $P10."pos"()
    goto alt1297_end
  alt1297_1:
    set_addr $I10, alt1297_2
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
.annotate 'line', 533
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1295_pos, rx1295_off
    set rx1295_rep, 0
    sub $I12, rx1295_eos, rx1295_pos
  rxenumcharlistq1305_loop:
    le $I12, 0, rxenumcharlistq1305_done
    substr $S10, rx1295_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1305_done
    inc rx1295_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1305_loop
  rxenumcharlistq1305_done:
    add rx1295_pos, rx1295_pos, rx1295_rep
  # rx literal  "#"
    add $I11, rx1295_pos, 1
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    ord $I11, rx1295_tgt, $I11
    ne $I11, 35, rx1295_fail
    add rx1295_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1295_pos, rx1295_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1295_tgt, $I10, rx1295_eos
    add rx1295_pos, rx1295_off, $I11
    goto alt1297_end
  alt1297_2:
.annotate 'line', 534
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1295_pos, rx1295_off
    set rx1295_rep, 0
    sub $I12, rx1295_eos, rx1295_pos
  rxenumcharlistq1306_loop:
    le $I12, 0, rxenumcharlistq1306_done
    substr $S10, rx1295_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1306_done
    inc rx1295_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1306_loop
  rxenumcharlistq1306_done:
    lt rx1295_rep, 1, rx1295_fail
    add rx1295_pos, rx1295_pos, rx1295_rep
  alt1297_end:
.annotate 'line', 529
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "unv")
    if_null rx1295_debug, debug_907
    rx1295_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1295_pos)
  debug_907:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 469
    if_null rx1295_debug, debug_908
    rx1295_cur."!cursor_debug"("NEXT", "unv")
  debug_908:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_909
    rx1295_cur."!cursor_debug"("FAIL", "unv")
  debug_909:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1299"  :anon :subid("59_1321350766.1143") :method :outer("58_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 532
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_903
    rx1301_cur."!cursor_debug"("START", "")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1302_done
    goto rxscan1302_scan
  rxscan1302_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1302_done
  rxscan1302_scan:
    set_addr $I10, rxscan1302_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1302_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1301_pos, rx1301_off
    set rx1301_rep, 0
    sub $I12, rx1301_eos, rx1301_pos
  rxenumcharlistq1303_loop:
    le $I12, 0, rxenumcharlistq1303_done
    substr $S10, rx1301_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1303_done
    inc rx1301_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1303_loop
  rxenumcharlistq1303_done:
    add rx1301_pos, rx1301_pos, rx1301_rep
  # rx literal  "="
    add $I11, rx1301_pos, 1
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    ord $I11, rx1301_tgt, $I11
    ne $I11, 61, rx1301_fail
    add rx1301_pos, 1
  alt1304_0:
    set_addr $I10, alt1304_1
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  # rx charclass w
    ge rx1301_pos, rx1301_eos, rx1301_fail
    sub $I10, rx1301_pos, rx1301_off
    is_cclass $I11, .CCLASS_WORD, rx1301_tgt, $I10
    unless $I11, rx1301_fail
    inc rx1301_pos
    goto alt1304_end
  alt1304_1:
  # rx literal  "\\"
    add $I11, rx1301_pos, 1
    gt $I11, rx1301_eos, rx1301_fail
    sub $I11, rx1301_pos, rx1301_off
    ord $I11, rx1301_tgt, $I11
    ne $I11, 92, rx1301_fail
    add rx1301_pos, 1
  alt1304_end:
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "")
    if_null rx1301_debug, debug_904
    rx1301_cur."!cursor_debug"("PASS", "", " at pos=", rx1301_pos)
  debug_904:
    .return (rx1301_cur)
  rx1301_restart:
    if_null rx1301_debug, debug_905
    rx1301_cur."!cursor_debug"("NEXT", "")
  debug_905:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_906
    rx1301_cur."!cursor_debug"("FAIL", "")
  debug_906:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("60_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("61_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1337 = "62_1321350766.1143" 
    capture_lex $P1337
    .local string rx1309_tgt
    .local int rx1309_pos
    .local int rx1309_off
    .local int rx1309_eos
    .local int rx1309_rep
    .local pmc rx1309_cur
    .local pmc rx1309_debug
    (rx1309_cur, rx1309_pos, rx1309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1309_cur
    .local pmc match
    .lex "$/", match
    length rx1309_eos, rx1309_tgt
    gt rx1309_pos, rx1309_eos, rx1309_done
    set rx1309_off, 0
    lt rx1309_pos, 2, rx1309_start
    sub rx1309_off, rx1309_pos, 1
    substr rx1309_tgt, rx1309_tgt, rx1309_off
  rx1309_start:
    eq $I10, 1, rx1309_restart
    if_null rx1309_debug, debug_910
    rx1309_cur."!cursor_debug"("START", "pod_comment")
  debug_910:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1310_done
    goto rxscan1310_scan
  rxscan1310_loop:
    (rx1309_pos) = rx1309_cur."from"()
    inc rx1309_pos
    rx1309_cur."!cursor_from"(rx1309_pos)
    ge rx1309_pos, rx1309_eos, rxscan1310_done
  rxscan1310_scan:
    set_addr $I10, rxscan1310_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  rxscan1310_done:
.annotate 'line', 539
  # rxanchor bol
    eq rx1309_pos, 0, rxanchor1311_done
    ge rx1309_pos, rx1309_eos, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  rxanchor1311_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1312_loop:
    le $I12, 0, rxenumcharlistq1312_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1312_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1312_loop
  rxenumcharlistq1312_done:
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx literal  "="
    add $I11, rx1309_pos, 1
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    ord $I11, rx1309_tgt, $I11
    ne $I11, 61, rx1309_fail
    add rx1309_pos, 1
  alt1313_0:
.annotate 'line', 540
    set_addr $I10, alt1313_1
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
.annotate 'line', 541
  # rx literal  "begin"
    add $I11, rx1309_pos, 5
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 5
    ne $S10, "begin", rx1309_fail
    add rx1309_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1314_loop:
    le $I12, 0, rxenumcharlistq1314_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1314_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1314_loop
  rxenumcharlistq1314_done:
    lt rx1309_rep, 1, rx1309_fail
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx literal  "END"
    add $I11, rx1309_pos, 3
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 3
    ne $S10, "END", rx1309_fail
    add rx1309_pos, 3
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  alt1315_0:
.annotate 'line', 542
    set_addr $I10, alt1315_1
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx rxquantf1316 ** 0..*
    set_addr $I10, rxquantf1316_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
    goto rxquantf1316_done
  rxquantf1316_loop:
  # rx charclass .
    ge rx1309_pos, rx1309_eos, rx1309_fail
    inc rx1309_pos
    set_addr $I10, rxquantf1316_loop
    rx1309_cur."!mark_push"(rx1309_rep, rx1309_pos, $I10)
  rxquantf1316_done:
  # rx charclass nl
    ge rx1309_pos, rx1309_eos, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    unless $I11, rx1309_fail
    substr $S10, rx1309_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1309_pos, $I11
    inc rx1309_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1318_loop:
    le $I12, 0, rxenumcharlistq1318_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1318_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1318_loop
  rxenumcharlistq1318_done:
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx literal  "=end"
    add $I11, rx1309_pos, 4
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 4
    ne $S10, "=end", rx1309_fail
    add rx1309_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1319_loop:
    le $I12, 0, rxenumcharlistq1319_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1319_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1319_loop
  rxenumcharlistq1319_done:
    lt rx1309_rep, 1, rx1309_fail
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx literal  "END"
    add $I11, rx1309_pos, 3
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 3
    ne $S10, "END", rx1309_fail
    add rx1309_pos, 3
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10, rx1309_eos
    add rx1309_pos, rx1309_off, $I11
    goto alt1315_end
  alt1315_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    find_not_cclass $I11, .CCLASS_ANY, rx1309_tgt, $I10, rx1309_eos
    add rx1309_pos, rx1309_off, $I11
  alt1315_end:
.annotate 'line', 541
    goto alt1313_end
  alt1313_1:
    set_addr $I10, alt1313_2
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
.annotate 'line', 543
  # rx literal  "begin"
    add $I11, rx1309_pos, 5
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 5
    ne $S10, "begin", rx1309_fail
    add rx1309_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1320_loop:
    le $I12, 0, rxenumcharlistq1320_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1320_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1320_loop
  rxenumcharlistq1320_done:
    lt rx1309_rep, 1, rx1309_fail
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."identifier"()
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1309_pos = $P10."pos"()
  alt1321_0:
.annotate 'line', 544
    set_addr $I10, alt1321_1
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
.annotate 'line', 545
  # rx rxquantf1322 ** 0..*
    set_addr $I10, rxquantf1322_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
    goto rxquantf1322_done
  rxquantf1322_loop:
  # rx charclass .
    ge rx1309_pos, rx1309_eos, rx1309_fail
    inc rx1309_pos
    set_addr $I10, rxquantf1322_loop
    rx1309_cur."!mark_push"(rx1309_rep, rx1309_pos, $I10)
  rxquantf1322_done:
  # rx charclass nl
    ge rx1309_pos, rx1309_eos, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    unless $I11, rx1309_fail
    substr $S10, rx1309_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1309_pos, $I11
    inc rx1309_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1324_loop:
    le $I12, 0, rxenumcharlistq1324_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1324_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1324_loop
  rxenumcharlistq1324_done:
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx literal  "=end"
    add $I11, rx1309_pos, 4
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 4
    ne $S10, "=end", rx1309_fail
    add rx1309_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1325_loop:
    le $I12, 0, rxenumcharlistq1325_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1325_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1325_loop
  rxenumcharlistq1325_done:
    lt rx1309_rep, 1, rx1309_fail
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."!BACKREF"("identifier")
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10, rx1309_eos
    add rx1309_pos, rx1309_off, $I11
    goto alt1321_end
  alt1321_1:
.annotate 'line', 546
  # rx subrule "panic" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."panic"("=begin without matching =end")
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  alt1321_end:
.annotate 'line', 543
    goto alt1313_end
  alt1313_2:
    set_addr $I10, alt1313_3
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
.annotate 'line', 548
  # rx literal  "begin"
    add $I11, rx1309_pos, 5
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 5
    ne $S10, "begin", rx1309_fail
    add rx1309_pos, 5
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1326_loop:
    le $I12, 0, rxenumcharlistq1326_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1326_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1326_loop
  rxenumcharlistq1326_done:
    add rx1309_pos, rx1309_pos, rx1309_rep
  alt1327_0:
.annotate 'line', 549
    set_addr $I10, alt1327_1
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rxanchor eol
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    if $I11, rxanchor1328_done
    ne rx1309_pos, rx1309_eos, rx1309_fail
    eq rx1309_pos, 0, rxanchor1328_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    if $I11, rx1309_fail
  rxanchor1328_done:
    goto alt1327_end
  alt1327_1:
    set_addr $I10, alt1327_2
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx literal  "#"
    add $I11, rx1309_pos, 1
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    ord $I11, rx1309_tgt, $I11
    ne $I11, 35, rx1309_fail
    add rx1309_pos, 1
    goto alt1327_end
  alt1327_2:
  # rx subrule "panic" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  alt1327_end:
  alt1329_0:
.annotate 'line', 550
    set_addr $I10, alt1329_1
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
.annotate 'line', 551
  # rx rxquantf1330 ** 0..*
    set_addr $I10, rxquantf1330_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
    goto rxquantf1330_done
  rxquantf1330_loop:
  # rx charclass .
    ge rx1309_pos, rx1309_eos, rx1309_fail
    inc rx1309_pos
    set_addr $I10, rxquantf1330_loop
    rx1309_cur."!mark_push"(rx1309_rep, rx1309_pos, $I10)
  rxquantf1330_done:
  # rx charclass nl
    ge rx1309_pos, rx1309_eos, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    unless $I11, rx1309_fail
    substr $S10, rx1309_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1309_pos, $I11
    inc rx1309_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    set rx1309_rep, 0
    sub $I12, rx1309_eos, rx1309_pos
  rxenumcharlistq1332_loop:
    le $I12, 0, rxenumcharlistq1332_done
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1332_done
    inc rx1309_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1332_loop
  rxenumcharlistq1332_done:
    add rx1309_pos, rx1309_pos, rx1309_rep
  # rx literal  "=end"
    add $I11, rx1309_pos, 4
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I11, 4
    ne $S10, "=end", rx1309_fail
    add rx1309_pos, 4
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10, rx1309_eos
    add rx1309_pos, rx1309_off, $I11
    goto alt1329_end
  alt1329_1:
.annotate 'line', 552
  # rx subrule "panic" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."panic"("=begin without matching =end")
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  alt1329_end:
.annotate 'line', 548
    goto alt1313_end
  alt1313_3:
    set_addr $I10, alt1313_4
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
.annotate 'line', 554
  # rx subrule "identifier" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."identifier"()
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1309_pos = $P10."pos"()
.annotate 'line', 555
  # rx rxquantf1333 ** 0..*
    set_addr $I10, rxquantf1333_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
    goto rxquantf1333_done
  rxquantf1333_loop:
  # rx charclass .
    ge rx1309_pos, rx1309_eos, rx1309_fail
    inc rx1309_pos
    set_addr $I10, rxquantf1333_loop
    rx1309_cur."!mark_push"(rx1309_rep, rx1309_pos, $I10)
  rxquantf1333_done:
  # rxanchor bol
    eq rx1309_pos, 0, rxanchor1335_done
    ge rx1309_pos, rx1309_eos, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  rxanchor1335_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    .const 'Sub' $P1337 = "62_1321350766.1143" 
    capture_lex $P1337
    $P10 = rx1309_cur."before"($P1337)
    unless $P10, rx1309_fail
.annotate 'line', 554
    goto alt1313_end
  alt1313_4:
  alt1343_0:
.annotate 'line', 561
    set_addr $I10, alt1343_1
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx charclass s
    ge rx1309_pos, rx1309_eos, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1309_tgt, $I10
    unless $I11, rx1309_fail
    inc rx1309_pos
    goto alt1343_end
  alt1343_1:
  # rx subrule "panic" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."panic"("Illegal pod directive")
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  alt1343_end:
.annotate 'line', 562
  # rx charclass_q N r 0..-1
    sub $I10, rx1309_pos, rx1309_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1309_tgt, $I10, rx1309_eos
    add rx1309_pos, rx1309_off, $I11
  alt1313_end:
.annotate 'line', 538
  # rx pass
    rx1309_cur."!cursor_pass"(rx1309_pos, "pod_comment")
    if_null rx1309_debug, debug_915
    rx1309_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1309_pos)
  debug_915:
    .return (rx1309_cur)
  rx1309_restart:
.annotate 'line', 469
    if_null rx1309_debug, debug_916
    rx1309_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_916:
  rx1309_fail:
    (rx1309_rep, rx1309_pos, $I10, $P10) = rx1309_cur."!mark_fail"(0)
    lt rx1309_pos, -1, rx1309_done
    eq rx1309_pos, -1, rx1309_fail
    jump $I10
  rx1309_done:
    rx1309_cur."!cursor_fail"()
    if_null rx1309_debug, debug_917
    rx1309_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_917:
    .return (rx1309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1336"  :anon :subid("62_1321350766.1143") :method :outer("61_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 555
    .local string rx1338_tgt
    .local int rx1338_pos
    .local int rx1338_off
    .local int rx1338_eos
    .local int rx1338_rep
    .local pmc rx1338_cur
    .local pmc rx1338_debug
    (rx1338_cur, rx1338_pos, rx1338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1338_cur
    .local pmc match
    .lex "$/", match
    length rx1338_eos, rx1338_tgt
    gt rx1338_pos, rx1338_eos, rx1338_done
    set rx1338_off, 0
    lt rx1338_pos, 2, rx1338_start
    sub rx1338_off, rx1338_pos, 1
    substr rx1338_tgt, rx1338_tgt, rx1338_off
  rx1338_start:
    eq $I10, 1, rx1338_restart
    if_null rx1338_debug, debug_911
    rx1338_cur."!cursor_debug"("START", "")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1339_done
    goto rxscan1339_scan
  rxscan1339_loop:
    (rx1338_pos) = rx1338_cur."from"()
    inc rx1338_pos
    rx1338_cur."!cursor_from"(rx1338_pos)
    ge rx1338_pos, rx1338_eos, rxscan1339_done
  rxscan1339_scan:
    set_addr $I10, rxscan1339_loop
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  rxscan1339_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1338_pos, rx1338_off
    set rx1338_rep, 0
    sub $I12, rx1338_eos, rx1338_pos
  rxenumcharlistq1340_loop:
    le $I12, 0, rxenumcharlistq1340_done
    substr $S10, rx1338_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1340_done
    inc rx1338_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1340_loop
  rxenumcharlistq1340_done:
    add rx1338_pos, rx1338_pos, rx1338_rep
  alt1341_0:
    set_addr $I10, alt1341_1
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
.annotate 'line', 556
  # rx literal  "="
    add $I11, rx1338_pos, 1
    gt $I11, rx1338_eos, rx1338_fail
    sub $I11, rx1338_pos, rx1338_off
    ord $I11, rx1338_tgt, $I11
    ne $I11, 61, rx1338_fail
    add rx1338_pos, 1
.annotate 'line', 558
  # rx rxquantr1342 ** 0..1
    set_addr $I10, rxquantr1342_done
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  rxquantr1342_loop:
.annotate 'line', 557
  # rx literal  "cut"
    add $I11, rx1338_pos, 3
    gt $I11, rx1338_eos, rx1338_fail
    sub $I11, rx1338_pos, rx1338_off
    substr $S10, rx1338_tgt, $I11, 3
    ne $S10, "cut", rx1338_fail
    add rx1338_pos, 3
  # rxanchor rwb
    le rx1338_pos, 0, rx1338_fail
    sub $I10, rx1338_pos, rx1338_off
    is_cclass $I11, .CCLASS_WORD, rx1338_tgt, $I10
    if $I11, rx1338_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1338_tgt, $I10
    unless $I11, rx1338_fail
.annotate 'line', 558
  # rx subrule "panic" subtype=method negate=
    rx1338_cur."!cursor_pos"(rx1338_pos)
    $P10 = rx1338_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1338_fail
    rx1338_pos = $P10."pos"()
    set_addr $I10, rxquantr1342_done
    (rx1338_rep) = rx1338_cur."!mark_commit"($I10)
  rxquantr1342_done:
.annotate 'line', 555
    goto alt1341_end
  alt1341_1:
.annotate 'line', 559
  # rx charclass nl
    ge rx1338_pos, rx1338_eos, rx1338_fail
    sub $I10, rx1338_pos, rx1338_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1338_tgt, $I10
    unless $I11, rx1338_fail
    substr $S10, rx1338_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1338_pos, $I11
    inc rx1338_pos
  alt1341_end:
.annotate 'line', 555
  # rx pass
    rx1338_cur."!cursor_pass"(rx1338_pos, "")
    if_null rx1338_debug, debug_912
    rx1338_cur."!cursor_debug"("PASS", "", " at pos=", rx1338_pos)
  debug_912:
    .return (rx1338_cur)
  rx1338_restart:
    if_null rx1338_debug, debug_913
    rx1338_cur."!cursor_debug"("NEXT", "")
  debug_913:
  rx1338_fail:
    (rx1338_rep, rx1338_pos, $I10, $P10) = rx1338_cur."!mark_fail"(0)
    lt rx1338_pos, -1, rx1338_done
    eq rx1338_pos, -1, rx1338_fail
    jump $I10
  rx1338_done:
    rx1338_cur."!cursor_fail"()
    if_null rx1338_debug, debug_914
    rx1338_cur."!cursor_debug"("FAIL", "")
  debug_914:
    .return (rx1338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("63_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P104, "ResizablePMCArray"
    push $P104, ""
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("64_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 570
    new $P103, "Undef"
    set $P1346, $P103
    .lex "$*IN_DECL", $P1346
.annotate 'line', 572
    new $P104, "Undef"
    set $P1347, $P104
    .lex "$*HAS_YOU_ARE_HERE", $P1347
.annotate 'line', 573
    new $P105, "Undef"
    set $P1348, $P105
    .lex "$*MAIN_SUB", $P1348
.annotate 'line', 576
    new $P106, "Undef"
    set $P1349, $P106
    .lex "$*PACKAGE", $P1349
.annotate 'line', 577
    new $P107, "Undef"
    set $P1350, $P107
    .lex "$*GLOBALish", $P1350
.annotate 'line', 469
    .local string rx1351_tgt
    .local int rx1351_pos
    .local int rx1351_off
    .local int rx1351_eos
    .local int rx1351_rep
    .local pmc rx1351_cur
    .local pmc rx1351_debug
    (rx1351_cur, rx1351_pos, rx1351_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1351_cur
    .local pmc match
    .lex "$/", match
    length rx1351_eos, rx1351_tgt
    gt rx1351_pos, rx1351_eos, rx1351_done
    set rx1351_off, 0
    lt rx1351_pos, 2, rx1351_start
    sub rx1351_off, rx1351_pos, 1
    substr rx1351_tgt, rx1351_tgt, rx1351_off
  rx1351_start:
    eq $I10, 1, rx1351_restart
    if_null rx1351_debug, debug_918
    rx1351_cur."!cursor_debug"("START", "comp_unit")
  debug_918:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1352_done
    goto rxscan1352_scan
  rxscan1352_loop:
    (rx1351_pos) = rx1351_cur."from"()
    inc rx1351_pos
    rx1351_cur."!cursor_from"(rx1351_pos)
    ge rx1351_pos, rx1351_eos, rxscan1352_done
  rxscan1352_scan:
    set_addr $I10, rxscan1352_loop
    rx1351_cur."!mark_push"(0, rx1351_pos, $I10)
  rxscan1352_done:
.annotate 'line', 570
    rx1351_cur."!cursor_pos"(rx1351_pos)
    new $P108, "String"
    assign $P108, ""
    store_lex "$*IN_DECL", $P108
.annotate 'line', 572
    rx1351_cur."!cursor_pos"(rx1351_pos)
    new $P109, "Float"
    assign $P109, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P109
.annotate 'line', 573
    rx1351_cur."!cursor_pos"(rx1351_pos)
    find_lex $P112, "$*MAIN_SUB"
    unless_null $P112, vivify_919
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["$MAIN_SUB"]
    unless_null $P112, vivify_920
    die "Contextual $*MAIN_SUB not found"
  vivify_920:
  vivify_919:
.annotate 'line', 574
  # rx subrule "newpad" subtype=method negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."newpad"()
    unless $P10, rx1351_fail
    rx1351_pos = $P10."pos"()
.annotate 'line', 576
    rx1351_cur."!cursor_pos"(rx1351_pos)
    find_lex $P115, "$*PACKAGE"
    unless_null $P115, vivify_921
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["$PACKAGE"]
    unless_null $P115, vivify_922
    die "Contextual $*PACKAGE not found"
  vivify_922:
  vivify_921:
.annotate 'line', 577
    rx1351_cur."!cursor_pos"(rx1351_pos)
    find_lex $P118, "$*GLOBALish"
    unless_null $P118, vivify_923
    get_hll_global $P116, "GLOBAL"
    get_who $P117, $P116
    set $P118, $P117["$GLOBALish"]
    unless_null $P118, vivify_924
    die "Contextual $*GLOBALish not found"
  vivify_924:
  vivify_923:
.annotate 'line', 578
  # rx subrule "GLOBALish" subtype=method negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."GLOBALish"()
    unless $P10, rx1351_fail
    rx1351_pos = $P10."pos"()
.annotate 'line', 580
  # rx subrule "outerctx" subtype=method negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."outerctx"()
    unless $P10, rx1351_fail
    rx1351_pos = $P10."pos"()
.annotate 'line', 582
  # rx subrule "statementlist" subtype=capture negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."statementlist"()
    unless $P10, rx1351_fail
    rx1351_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1351_pos = $P10."pos"()
  alt1353_0:
.annotate 'line', 583
    set_addr $I10, alt1353_1
    rx1351_cur."!mark_push"(0, rx1351_pos, $I10)
  # rxanchor eos
    ne rx1351_pos, rx1351_eos, rx1351_fail
    goto alt1353_end
  alt1353_1:
  # rx subrule "panic" subtype=method negate=
    rx1351_cur."!cursor_pos"(rx1351_pos)
    $P10 = rx1351_cur."panic"("Confused")
    unless $P10, rx1351_fail
    rx1351_pos = $P10."pos"()
  alt1353_end:
.annotate 'line', 569
  # rx pass
    rx1351_cur."!cursor_pass"(rx1351_pos, "comp_unit")
    if_null rx1351_debug, debug_925
    rx1351_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1351_pos)
  debug_925:
    .return (rx1351_cur)
  rx1351_restart:
.annotate 'line', 469
    if_null rx1351_debug, debug_926
    rx1351_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_926:
  rx1351_fail:
    (rx1351_rep, rx1351_pos, $I10, $P10) = rx1351_cur."!mark_fail"(0)
    lt rx1351_pos, -1, rx1351_done
    eq rx1351_pos, -1, rx1351_fail
    jump $I10
  rx1351_done:
    rx1351_cur."!cursor_fail"()
    if_null rx1351_debug, debug_927
    rx1351_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_927:
    .return (rx1351_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("65_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P119 = self."!PREFIX__!subrule"("newpad", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("66_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    rx1356_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_928
    rx1356_cur."!cursor_debug"("START", "statementlist")
  debug_928:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1357_done
    goto rxscan1357_scan
  rxscan1357_loop:
    (rx1356_pos) = rx1356_cur."from"()
    inc rx1356_pos
    rx1356_cur."!cursor_from"(rx1356_pos)
    ge rx1356_pos, rx1356_eos, rxscan1357_done
  rxscan1357_scan:
    set_addr $I10, rxscan1357_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1357_done:
  alt1358_0:
.annotate 'line', 586
    set_addr $I10, alt1358_1
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
.annotate 'line', 587
  # rx subrule "ws" subtype=method negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."ws"()
    unless $P10, rx1356_fail
    rx1356_pos = $P10."pos"()
  # rxanchor eos
    ne rx1356_pos, rx1356_eos, rx1356_fail
  # rx subrule "ws" subtype=method negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."ws"()
    unless $P10, rx1356_fail
    rx1356_pos = $P10."pos"()
    goto alt1358_end
  alt1358_1:
.annotate 'line', 588
  # rx subrule "ws" subtype=method negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."ws"()
    unless $P10, rx1356_fail
    rx1356_pos = $P10."pos"()
  # rx rxquantr1359 ** 0..*
    set_addr $I10, rxquantr1359_done
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxquantr1359_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."statement"()
    unless $P10, rx1356_fail
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1356_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."eat_terminator"()
    unless $P10, rx1356_fail
    rx1356_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."ws"()
    unless $P10, rx1356_fail
    rx1356_pos = $P10."pos"()
    set_addr $I10, rxquantr1359_done
    (rx1356_rep) = rx1356_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1359_done
    rx1356_cur."!mark_push"(rx1356_rep, rx1356_pos, $I10)
    goto rxquantr1359_loop
  rxquantr1359_done:
  # rx subrule "ws" subtype=method negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."ws"()
    unless $P10, rx1356_fail
    rx1356_pos = $P10."pos"()
  alt1358_end:
.annotate 'line', 586
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "statementlist")
    if_null rx1356_debug, debug_929
    rx1356_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1356_pos)
  debug_929:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 469
    if_null rx1356_debug, debug_930
    rx1356_cur."!cursor_debug"("NEXT", "statementlist")
  debug_930:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_931
    rx1356_cur."!cursor_debug"("FAIL", "statementlist")
  debug_931:
    .return (rx1356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("67_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P108 = self."!PREFIX__!subrule"("ws", "")
    $P109 = self."!PREFIX__!subrule"("ws", "")
    new $P110, "ResizablePMCArray"
    push $P110, $P108
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("68_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1365 = "69_1321350766.1143" 
    capture_lex $P1365
    .local string rx1362_tgt
    .local int rx1362_pos
    .local int rx1362_off
    .local int rx1362_eos
    .local int rx1362_rep
    .local pmc rx1362_cur
    .local pmc rx1362_debug
    (rx1362_cur, rx1362_pos, rx1362_tgt, $I10) = self."!cursor_start"()
    rx1362_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1362_cur
    .local pmc match
    .lex "$/", match
    length rx1362_eos, rx1362_tgt
    gt rx1362_pos, rx1362_eos, rx1362_done
    set rx1362_off, 0
    lt rx1362_pos, 2, rx1362_start
    sub rx1362_off, rx1362_pos, 1
    substr rx1362_tgt, rx1362_tgt, rx1362_off
  rx1362_start:
    eq $I10, 1, rx1362_restart
    if_null rx1362_debug, debug_932
    rx1362_cur."!cursor_debug"("START", "statement")
  debug_932:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1363_done
    goto rxscan1363_scan
  rxscan1363_loop:
    (rx1362_pos) = rx1362_cur."from"()
    inc rx1362_pos
    rx1362_cur."!cursor_from"(rx1362_pos)
    ge rx1362_pos, rx1362_eos, rxscan1363_done
  rxscan1363_scan:
    set_addr $I10, rxscan1363_loop
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxscan1363_done:
.annotate 'line', 592
  # rx subrule "before" subtype=zerowidth negate=1
    rx1362_cur."!cursor_pos"(rx1362_pos)
    .const 'Sub' $P1365 = "69_1321350766.1143" 
    capture_lex $P1365
    $P10 = rx1362_cur."before"($P1365)
    if $P10, rx1362_fail
  alt1369_0:
.annotate 'line', 593
    set_addr $I10, alt1369_1
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
.annotate 'line', 594
  # rx subrule "statement_control" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."statement_control"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1362_pos = $P10."pos"()
    goto alt1369_end
  alt1369_1:
.annotate 'line', 595
  # rx subrule "EXPR" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."EXPR"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1362_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."ws"()
    unless $P10, rx1362_fail
    rx1362_pos = $P10."pos"()
.annotate 'line', 600
  # rx rxquantr1370 ** 0..1
    set_addr $I10, rxquantr1370_done
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxquantr1370_loop:
  alt1371_0:
.annotate 'line', 596
    set_addr $I10, alt1371_1
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
.annotate 'line', 597
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."MARKED"("endstmt")
    unless $P10, rx1362_fail
    goto alt1371_end
  alt1371_1:
    set_addr $I10, alt1371_2
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
.annotate 'line', 598
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."statement_mod_cond"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1362_pos = $P10."pos"()
  # rx rxquantr1372 ** 0..1
    set_addr $I10, rxquantr1372_done
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxquantr1372_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."statement_mod_loop"()
    unless $P10, rx1362_fail
    goto rxsubrule1373_pass
  rxsubrule1373_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1362_fail
  rxsubrule1373_pass:
    set_addr $I10, rxsubrule1373_back
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1362_pos = $P10."pos"()
    set_addr $I10, rxquantr1372_done
    (rx1362_rep) = rx1362_cur."!mark_commit"($I10)
  rxquantr1372_done:
    goto alt1371_end
  alt1371_2:
.annotate 'line', 599
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."statement_mod_loop"()
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1362_pos = $P10."pos"()
  alt1371_end:
.annotate 'line', 600
    set_addr $I10, rxquantr1370_done
    (rx1362_rep) = rx1362_cur."!mark_commit"($I10)
  rxquantr1370_done:
  alt1369_end:
.annotate 'line', 591
  # rx pass
    rx1362_cur."!cursor_pass"(rx1362_pos, "statement")
    if_null rx1362_debug, debug_937
    rx1362_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1362_pos)
  debug_937:
    .return (rx1362_cur)
  rx1362_restart:
.annotate 'line', 469
    if_null rx1362_debug, debug_938
    rx1362_cur."!cursor_debug"("NEXT", "statement")
  debug_938:
  rx1362_fail:
    (rx1362_rep, rx1362_pos, $I10, $P10) = rx1362_cur."!mark_fail"(0)
    lt rx1362_pos, -1, rx1362_done
    eq rx1362_pos, -1, rx1362_fail
    jump $I10
  rx1362_done:
    rx1362_cur."!cursor_fail"()
    if_null rx1362_debug, debug_939
    rx1362_cur."!cursor_debug"("FAIL", "statement")
  debug_939:
    .return (rx1362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1364"  :anon :subid("69_1321350766.1143") :method :outer("68_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 592
    .local string rx1366_tgt
    .local int rx1366_pos
    .local int rx1366_off
    .local int rx1366_eos
    .local int rx1366_rep
    .local pmc rx1366_cur
    .local pmc rx1366_debug
    (rx1366_cur, rx1366_pos, rx1366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1366_cur
    .local pmc match
    .lex "$/", match
    length rx1366_eos, rx1366_tgt
    gt rx1366_pos, rx1366_eos, rx1366_done
    set rx1366_off, 0
    lt rx1366_pos, 2, rx1366_start
    sub rx1366_off, rx1366_pos, 1
    substr rx1366_tgt, rx1366_tgt, rx1366_off
  rx1366_start:
    eq $I10, 1, rx1366_restart
    if_null rx1366_debug, debug_933
    rx1366_cur."!cursor_debug"("START", "")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    (rx1366_pos) = rx1366_cur."from"()
    inc rx1366_pos
    rx1366_cur."!cursor_from"(rx1366_pos)
    ge rx1366_pos, rx1366_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  rxscan1367_done:
  alt1368_0:
    set_addr $I10, alt1368_1
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1366_pos, rx1366_eos, rx1366_fail
    sub $I10, rx1366_pos, rx1366_off
    substr $S10, rx1366_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1366_fail
    inc rx1366_pos
    goto alt1368_end
  alt1368_1:
  # rxanchor eos
    ne rx1366_pos, rx1366_eos, rx1366_fail
  alt1368_end:
  # rx pass
    rx1366_cur."!cursor_pass"(rx1366_pos, "")
    if_null rx1366_debug, debug_934
    rx1366_cur."!cursor_debug"("PASS", "", " at pos=", rx1366_pos)
  debug_934:
    .return (rx1366_cur)
  rx1366_restart:
    if_null rx1366_debug, debug_935
    rx1366_cur."!cursor_debug"("NEXT", "")
  debug_935:
  rx1366_fail:
    (rx1366_rep, rx1366_pos, $I10, $P10) = rx1366_cur."!mark_fail"(0)
    lt rx1366_pos, -1, rx1366_done
    eq rx1366_pos, -1, rx1366_fail
    jump $I10
  rx1366_done:
    rx1366_cur."!cursor_fail"()
    if_null rx1366_debug, debug_936
    rx1366_cur."!cursor_debug"("FAIL", "")
  debug_936:
    .return (rx1366_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("70_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("71_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1376_tgt
    .local int rx1376_pos
    .local int rx1376_off
    .local int rx1376_eos
    .local int rx1376_rep
    .local pmc rx1376_cur
    .local pmc rx1376_debug
    (rx1376_cur, rx1376_pos, rx1376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1376_cur
    .local pmc match
    .lex "$/", match
    length rx1376_eos, rx1376_tgt
    gt rx1376_pos, rx1376_eos, rx1376_done
    set rx1376_off, 0
    lt rx1376_pos, 2, rx1376_start
    sub rx1376_off, rx1376_pos, 1
    substr rx1376_tgt, rx1376_tgt, rx1376_off
  rx1376_start:
    eq $I10, 1, rx1376_restart
    if_null rx1376_debug, debug_940
    rx1376_cur."!cursor_debug"("START", "eat_terminator")
  debug_940:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1377_done
    goto rxscan1377_scan
  rxscan1377_loop:
    (rx1376_pos) = rx1376_cur."from"()
    inc rx1376_pos
    rx1376_cur."!cursor_from"(rx1376_pos)
    ge rx1376_pos, rx1376_eos, rxscan1377_done
  rxscan1377_scan:
    set_addr $I10, rxscan1377_loop
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
  rxscan1377_done:
  alt1378_0:
.annotate 'line', 604
    set_addr $I10, alt1378_1
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
.annotate 'line', 605
  # rx literal  ";"
    add $I11, rx1376_pos, 1
    gt $I11, rx1376_eos, rx1376_fail
    sub $I11, rx1376_pos, rx1376_off
    ord $I11, rx1376_tgt, $I11
    ne $I11, 59, rx1376_fail
    add rx1376_pos, 1
    goto alt1378_end
  alt1378_1:
    set_addr $I10, alt1378_2
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
.annotate 'line', 606
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1376_cur."!cursor_pos"(rx1376_pos)
    $P10 = rx1376_cur."MARKED"("endstmt")
    unless $P10, rx1376_fail
    goto alt1378_end
  alt1378_2:
    set_addr $I10, alt1378_3
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
.annotate 'line', 607
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1376_cur."!cursor_pos"(rx1376_pos)
    $P10 = rx1376_cur."terminator"()
    unless $P10, rx1376_fail
    goto alt1378_end
  alt1378_3:
.annotate 'line', 608
  # rxanchor eos
    ne rx1376_pos, rx1376_eos, rx1376_fail
  alt1378_end:
.annotate 'line', 604
  # rx pass
    rx1376_cur."!cursor_pass"(rx1376_pos, "eat_terminator")
    if_null rx1376_debug, debug_941
    rx1376_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1376_pos)
  debug_941:
    .return (rx1376_cur)
  rx1376_restart:
.annotate 'line', 469
    if_null rx1376_debug, debug_942
    rx1376_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_942:
  rx1376_fail:
    (rx1376_rep, rx1376_pos, $I10, $P10) = rx1376_cur."!mark_fail"(0)
    lt rx1376_pos, -1, rx1376_done
    eq rx1376_pos, -1, rx1376_fail
    jump $I10
  rx1376_done:
    rx1376_cur."!cursor_fail"()
    if_null rx1376_debug, debug_943
    rx1376_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_943:
    .return (rx1376_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("72_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("73_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1381_tgt
    .local int rx1381_pos
    .local int rx1381_off
    .local int rx1381_eos
    .local int rx1381_rep
    .local pmc rx1381_cur
    .local pmc rx1381_debug
    (rx1381_cur, rx1381_pos, rx1381_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1381_cur
    .local pmc match
    .lex "$/", match
    length rx1381_eos, rx1381_tgt
    gt rx1381_pos, rx1381_eos, rx1381_done
    set rx1381_off, 0
    lt rx1381_pos, 2, rx1381_start
    sub rx1381_off, rx1381_pos, 1
    substr rx1381_tgt, rx1381_tgt, rx1381_off
  rx1381_start:
    eq $I10, 1, rx1381_restart
    if_null rx1381_debug, debug_944
    rx1381_cur."!cursor_debug"("START", "xblock")
  debug_944:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1382_done
    goto rxscan1382_scan
  rxscan1382_loop:
    (rx1381_pos) = rx1381_cur."from"()
    inc rx1381_pos
    rx1381_cur."!cursor_from"(rx1381_pos)
    ge rx1381_pos, rx1381_eos, rxscan1382_done
  rxscan1382_scan:
    set_addr $I10, rxscan1382_loop
    rx1381_cur."!mark_push"(0, rx1381_pos, $I10)
  rxscan1382_done:
.annotate 'line', 612
  # rx subrule "EXPR" subtype=capture negate=
    rx1381_cur."!cursor_pos"(rx1381_pos)
    $P10 = rx1381_cur."EXPR"()
    unless $P10, rx1381_fail
    rx1381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1381_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1381_cur."!cursor_pos"(rx1381_pos)
    $P10 = rx1381_cur."ws"()
    unless $P10, rx1381_fail
    rx1381_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1381_cur."!cursor_pos"(rx1381_pos)
    $P10 = rx1381_cur."pblock"()
    unless $P10, rx1381_fail
    rx1381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1381_pos = $P10."pos"()
.annotate 'line', 611
  # rx pass
    rx1381_cur."!cursor_pass"(rx1381_pos, "xblock")
    if_null rx1381_debug, debug_945
    rx1381_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1381_pos)
  debug_945:
    .return (rx1381_cur)
  rx1381_restart:
.annotate 'line', 469
    if_null rx1381_debug, debug_946
    rx1381_cur."!cursor_debug"("NEXT", "xblock")
  debug_946:
  rx1381_fail:
    (rx1381_rep, rx1381_pos, $I10, $P10) = rx1381_cur."!mark_fail"(0)
    lt rx1381_pos, -1, rx1381_done
    eq rx1381_pos, -1, rx1381_fail
    jump $I10
  rx1381_done:
    rx1381_cur."!cursor_fail"()
    if_null rx1381_debug, debug_947
    rx1381_cur."!cursor_debug"("FAIL", "xblock")
  debug_947:
    .return (rx1381_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("74_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("EXPR", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("75_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1385_tgt
    .local int rx1385_pos
    .local int rx1385_off
    .local int rx1385_eos
    .local int rx1385_rep
    .local pmc rx1385_cur
    .local pmc rx1385_debug
    (rx1385_cur, rx1385_pos, rx1385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1385_cur
    .local pmc match
    .lex "$/", match
    length rx1385_eos, rx1385_tgt
    gt rx1385_pos, rx1385_eos, rx1385_done
    set rx1385_off, 0
    lt rx1385_pos, 2, rx1385_start
    sub rx1385_off, rx1385_pos, 1
    substr rx1385_tgt, rx1385_tgt, rx1385_off
  rx1385_start:
    eq $I10, 1, rx1385_restart
    if_null rx1385_debug, debug_948
    rx1385_cur."!cursor_debug"("START", "pblock")
  debug_948:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1385_pos) = rx1385_cur."from"()
    inc rx1385_pos
    rx1385_cur."!cursor_from"(rx1385_pos)
    ge rx1385_pos, rx1385_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxscan1386_done:
  alt1387_0:
.annotate 'line', 615
    set_addr $I10, alt1387_1
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
.annotate 'line', 616
  # rx subrule "lambda" subtype=method negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."lambda"()
    unless $P10, rx1385_fail
    rx1385_pos = $P10."pos"()
.annotate 'line', 617
  # rx subrule "newpad" subtype=method negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."newpad"()
    unless $P10, rx1385_fail
    rx1385_pos = $P10."pos"()
.annotate 'line', 618
  # rx subrule "signature" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."signature"()
    unless $P10, rx1385_fail
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1385_pos = $P10."pos"()
.annotate 'line', 619
  # rx subrule "blockoid" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."blockoid"()
    unless $P10, rx1385_fail
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1385_pos = $P10."pos"()
.annotate 'line', 616
    goto alt1387_end
  alt1387_1:
    set_addr $I10, alt1387_2
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
.annotate 'line', 620
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1385_pos, rx1385_off
    substr $S10, rx1385_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1385_fail
.annotate 'line', 621
  # rx subrule "newpad" subtype=method negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."newpad"()
    unless $P10, rx1385_fail
    rx1385_pos = $P10."pos"()
.annotate 'line', 622
  # rx subrule "blockoid" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."blockoid"()
    unless $P10, rx1385_fail
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1385_pos = $P10."pos"()
.annotate 'line', 620
    goto alt1387_end
  alt1387_2:
.annotate 'line', 623
  # rx subrule "panic" subtype=method negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."panic"("Missing block")
    unless $P10, rx1385_fail
    rx1385_pos = $P10."pos"()
  alt1387_end:
.annotate 'line', 615
  # rx pass
    rx1385_cur."!cursor_pass"(rx1385_pos, "pblock")
    if_null rx1385_debug, debug_949
    rx1385_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1385_pos)
  debug_949:
    .return (rx1385_cur)
  rx1385_restart:
.annotate 'line', 469
    if_null rx1385_debug, debug_950
    rx1385_cur."!cursor_debug"("NEXT", "pblock")
  debug_950:
  rx1385_fail:
    (rx1385_rep, rx1385_pos, $I10, $P10) = rx1385_cur."!mark_fail"(0)
    lt rx1385_pos, -1, rx1385_done
    eq rx1385_pos, -1, rx1385_fail
    jump $I10
  rx1385_done:
    rx1385_cur."!cursor_fail"()
    if_null rx1385_debug, debug_951
    rx1385_cur."!cursor_debug"("FAIL", "pblock")
  debug_951:
    .return (rx1385_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("76_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("panic", "")
    $P104 = self."!PREFIX__!subrule"("lambda", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, "{"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("77_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1390_tgt
    .local int rx1390_pos
    .local int rx1390_off
    .local int rx1390_eos
    .local int rx1390_rep
    .local pmc rx1390_cur
    .local pmc rx1390_debug
    (rx1390_cur, rx1390_pos, rx1390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1390_cur
    .local pmc match
    .lex "$/", match
    length rx1390_eos, rx1390_tgt
    gt rx1390_pos, rx1390_eos, rx1390_done
    set rx1390_off, 0
    lt rx1390_pos, 2, rx1390_start
    sub rx1390_off, rx1390_pos, 1
    substr rx1390_tgt, rx1390_tgt, rx1390_off
  rx1390_start:
    eq $I10, 1, rx1390_restart
    if_null rx1390_debug, debug_952
    rx1390_cur."!cursor_debug"("START", "lambda")
  debug_952:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1391_done
    goto rxscan1391_scan
  rxscan1391_loop:
    (rx1390_pos) = rx1390_cur."from"()
    inc rx1390_pos
    rx1390_cur."!cursor_from"(rx1390_pos)
    ge rx1390_pos, rx1390_eos, rxscan1391_done
  rxscan1391_scan:
    set_addr $I10, rxscan1391_loop
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  rxscan1391_done:
  alt1392_0:
.annotate 'line', 626
    set_addr $I10, alt1392_1
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  # rx literal  "->"
    add $I11, rx1390_pos, 2
    gt $I11, rx1390_eos, rx1390_fail
    sub $I11, rx1390_pos, rx1390_off
    substr $S10, rx1390_tgt, $I11, 2
    ne $S10, "->", rx1390_fail
    add rx1390_pos, 2
    goto alt1392_end
  alt1392_1:
  # rx literal  "<->"
    add $I11, rx1390_pos, 3
    gt $I11, rx1390_eos, rx1390_fail
    sub $I11, rx1390_pos, rx1390_off
    substr $S10, rx1390_tgt, $I11, 3
    ne $S10, "<->", rx1390_fail
    add rx1390_pos, 3
  alt1392_end:
  # rx pass
    rx1390_cur."!cursor_pass"(rx1390_pos, "lambda")
    if_null rx1390_debug, debug_953
    rx1390_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1390_pos)
  debug_953:
    .return (rx1390_cur)
  rx1390_restart:
.annotate 'line', 469
    if_null rx1390_debug, debug_954
    rx1390_cur."!cursor_debug"("NEXT", "lambda")
  debug_954:
  rx1390_fail:
    (rx1390_rep, rx1390_pos, $I10, $P10) = rx1390_cur."!mark_fail"(0)
    lt rx1390_pos, -1, rx1390_done
    eq rx1390_pos, -1, rx1390_fail
    jump $I10
  rx1390_done:
    rx1390_cur."!cursor_fail"()
    if_null rx1390_debug, debug_955
    rx1390_cur."!cursor_debug"("FAIL", "lambda")
  debug_955:
    .return (rx1390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("78_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "<->"
    push $P103, "->"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("79_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1395_tgt
    .local int rx1395_pos
    .local int rx1395_off
    .local int rx1395_eos
    .local int rx1395_rep
    .local pmc rx1395_cur
    .local pmc rx1395_debug
    (rx1395_cur, rx1395_pos, rx1395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1395_cur
    .local pmc match
    .lex "$/", match
    length rx1395_eos, rx1395_tgt
    gt rx1395_pos, rx1395_eos, rx1395_done
    set rx1395_off, 0
    lt rx1395_pos, 2, rx1395_start
    sub rx1395_off, rx1395_pos, 1
    substr rx1395_tgt, rx1395_tgt, rx1395_off
  rx1395_start:
    eq $I10, 1, rx1395_restart
    if_null rx1395_debug, debug_956
    rx1395_cur."!cursor_debug"("START", "block")
  debug_956:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1395_pos) = rx1395_cur."from"()
    inc rx1395_pos
    rx1395_cur."!cursor_from"(rx1395_pos)
    ge rx1395_pos, rx1395_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  rxscan1396_done:
  alt1397_0:
.annotate 'line', 629
    set_addr $I10, alt1397_1
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1395_pos, rx1395_off
    substr $S10, rx1395_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1395_fail
    goto alt1397_end
  alt1397_1:
  # rx subrule "panic" subtype=method negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."panic"("Missing block")
    unless $P10, rx1395_fail
    rx1395_pos = $P10."pos"()
  alt1397_end:
.annotate 'line', 630
  # rx subrule "newpad" subtype=method negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."newpad"()
    unless $P10, rx1395_fail
    rx1395_pos = $P10."pos"()
.annotate 'line', 631
  # rx subrule "blockoid" subtype=capture negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."blockoid"()
    unless $P10, rx1395_fail
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1395_pos = $P10."pos"()
.annotate 'line', 628
  # rx pass
    rx1395_cur."!cursor_pass"(rx1395_pos, "block")
    if_null rx1395_debug, debug_957
    rx1395_cur."!cursor_debug"("PASS", "block", " at pos=", rx1395_pos)
  debug_957:
    .return (rx1395_cur)
  rx1395_restart:
.annotate 'line', 469
    if_null rx1395_debug, debug_958
    rx1395_cur."!cursor_debug"("NEXT", "block")
  debug_958:
  rx1395_fail:
    (rx1395_rep, rx1395_pos, $I10, $P10) = rx1395_cur."!mark_fail"(0)
    lt rx1395_pos, -1, rx1395_done
    eq rx1395_pos, -1, rx1395_fail
    jump $I10
  rx1395_done:
    rx1395_cur."!cursor_fail"()
    if_null rx1395_debug, debug_959
    rx1395_cur."!cursor_debug"("FAIL", "block")
  debug_959:
    .return (rx1395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("80_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("panic", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    push $P104, "{"
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("81_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1400_tgt
    .local int rx1400_pos
    .local int rx1400_off
    .local int rx1400_eos
    .local int rx1400_rep
    .local pmc rx1400_cur
    .local pmc rx1400_debug
    (rx1400_cur, rx1400_pos, rx1400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1400_cur
    .local pmc match
    .lex "$/", match
    length rx1400_eos, rx1400_tgt
    gt rx1400_pos, rx1400_eos, rx1400_done
    set rx1400_off, 0
    lt rx1400_pos, 2, rx1400_start
    sub rx1400_off, rx1400_pos, 1
    substr rx1400_tgt, rx1400_tgt, rx1400_off
  rx1400_start:
    eq $I10, 1, rx1400_restart
    if_null rx1400_debug, debug_960
    rx1400_cur."!cursor_debug"("START", "blockoid")
  debug_960:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1401_done
    goto rxscan1401_scan
  rxscan1401_loop:
    (rx1400_pos) = rx1400_cur."from"()
    inc rx1400_pos
    rx1400_cur."!cursor_from"(rx1400_pos)
    ge rx1400_pos, rx1400_eos, rxscan1401_done
  rxscan1401_scan:
    set_addr $I10, rxscan1401_loop
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  rxscan1401_done:
.annotate 'line', 635
  # rx subrule "finishpad" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."finishpad"()
    unless $P10, rx1400_fail
    rx1400_pos = $P10."pos"()
  alt1402_0:
.annotate 'line', 636
    set_addr $I10, alt1402_1
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
.annotate 'line', 637
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1400_pos, 14
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    substr $S10, rx1400_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1400_fail
    add rx1400_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."you_are_here"()
    unless $P10, rx1400_fail
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1400_pos = $P10."pos"()
    goto alt1402_end
  alt1402_1:
.annotate 'line', 638
  # rx literal  "{"
    add $I11, rx1400_pos, 1
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    ord $I11, rx1400_tgt, $I11
    ne $I11, 123, rx1400_fail
    add rx1400_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."statementlist"()
    unless $P10, rx1400_fail
    rx1400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1400_pos = $P10."pos"()
  alt1403_0:
    set_addr $I10, alt1403_1
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10)
  # rx literal  "}"
    add $I11, rx1400_pos, 1
    gt $I11, rx1400_eos, rx1400_fail
    sub $I11, rx1400_pos, rx1400_off
    ord $I11, rx1400_tgt, $I11
    ne $I11, 125, rx1400_fail
    add rx1400_pos, 1
    goto alt1403_end
  alt1403_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."FAILGOAL"("'}'")
    unless $P10, rx1400_fail
    goto rxsubrule1404_pass
  rxsubrule1404_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1400_fail
  rxsubrule1404_pass:
    set_addr $I10, rxsubrule1404_back
    rx1400_cur."!mark_push"(0, rx1400_pos, $I10, $P10)
    rx1400_pos = $P10."pos"()
  alt1403_end:
  alt1402_end:
.annotate 'line', 640
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1400_cur."!cursor_pos"(rx1400_pos)
    $P10 = rx1400_cur."ENDSTMT"()
    unless $P10, rx1400_fail
.annotate 'line', 634
  # rx pass
    rx1400_cur."!cursor_pass"(rx1400_pos, "blockoid")
    if_null rx1400_debug, debug_961
    rx1400_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1400_pos)
  debug_961:
    .return (rx1400_cur)
  rx1400_restart:
.annotate 'line', 469
    if_null rx1400_debug, debug_962
    rx1400_cur."!cursor_debug"("NEXT", "blockoid")
  debug_962:
  rx1400_fail:
    (rx1400_rep, rx1400_pos, $I10, $P10) = rx1400_cur."!mark_fail"(0)
    lt rx1400_pos, -1, rx1400_done
    eq rx1400_pos, -1, rx1400_fail
    jump $I10
  rx1400_done:
    rx1400_cur."!cursor_fail"()
    if_null rx1400_debug, debug_963
    rx1400_cur."!cursor_debug"("FAIL", "blockoid")
  debug_963:
    .return (rx1400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("82_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P104 = self."!PREFIX__!subrule"("finishpad", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("83_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1407_tgt
    .local int rx1407_pos
    .local int rx1407_off
    .local int rx1407_eos
    .local int rx1407_rep
    .local pmc rx1407_cur
    .local pmc rx1407_debug
    (rx1407_cur, rx1407_pos, rx1407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1407_cur
    .local pmc match
    .lex "$/", match
    length rx1407_eos, rx1407_tgt
    gt rx1407_pos, rx1407_eos, rx1407_done
    set rx1407_off, 0
    lt rx1407_pos, 2, rx1407_start
    sub rx1407_off, rx1407_pos, 1
    substr rx1407_tgt, rx1407_tgt, rx1407_off
  rx1407_start:
    eq $I10, 1, rx1407_restart
    if_null rx1407_debug, debug_964
    rx1407_cur."!cursor_debug"("START", "newpad")
  debug_964:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1408_done
    goto rxscan1408_scan
  rxscan1408_loop:
    (rx1407_pos) = rx1407_cur."from"()
    inc rx1407_pos
    rx1407_cur."!cursor_from"(rx1407_pos)
    ge rx1407_pos, rx1407_eos, rxscan1408_done
  rxscan1408_scan:
    set_addr $I10, rxscan1408_loop
    rx1407_cur."!mark_push"(0, rx1407_pos, $I10)
  rxscan1408_done:
.annotate 'line', 643
  # rx pass
    rx1407_cur."!cursor_pass"(rx1407_pos, "newpad")
    if_null rx1407_debug, debug_965
    rx1407_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1407_pos)
  debug_965:
    .return (rx1407_cur)
  rx1407_restart:
.annotate 'line', 469
    if_null rx1407_debug, debug_966
    rx1407_cur."!cursor_debug"("NEXT", "newpad")
  debug_966:
  rx1407_fail:
    (rx1407_rep, rx1407_pos, $I10, $P10) = rx1407_cur."!mark_fail"(0)
    lt rx1407_pos, -1, rx1407_done
    eq rx1407_pos, -1, rx1407_fail
    jump $I10
  rx1407_done:
    rx1407_cur."!cursor_fail"()
    if_null rx1407_debug, debug_967
    rx1407_cur."!cursor_debug"("FAIL", "newpad")
  debug_967:
    .return (rx1407_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("84_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("85_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_968
    rx1411_cur."!cursor_debug"("START", "outerctx")
  debug_968:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1412_done:
.annotate 'line', 644
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "outerctx")
    if_null rx1411_debug, debug_969
    rx1411_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1411_pos)
  debug_969:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 469
    if_null rx1411_debug, debug_970
    rx1411_cur."!cursor_debug"("NEXT", "outerctx")
  debug_970:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_971
    rx1411_cur."!cursor_debug"("FAIL", "outerctx")
  debug_971:
    .return (rx1411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("86_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("87_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1415_tgt
    .local int rx1415_pos
    .local int rx1415_off
    .local int rx1415_eos
    .local int rx1415_rep
    .local pmc rx1415_cur
    .local pmc rx1415_debug
    (rx1415_cur, rx1415_pos, rx1415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1415_cur
    .local pmc match
    .lex "$/", match
    length rx1415_eos, rx1415_tgt
    gt rx1415_pos, rx1415_eos, rx1415_done
    set rx1415_off, 0
    lt rx1415_pos, 2, rx1415_start
    sub rx1415_off, rx1415_pos, 1
    substr rx1415_tgt, rx1415_tgt, rx1415_off
  rx1415_start:
    eq $I10, 1, rx1415_restart
    if_null rx1415_debug, debug_972
    rx1415_cur."!cursor_debug"("START", "GLOBALish")
  debug_972:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    (rx1415_pos) = rx1415_cur."from"()
    inc rx1415_pos
    rx1415_cur."!cursor_from"(rx1415_pos)
    ge rx1415_pos, rx1415_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  rxscan1416_done:
.annotate 'line', 645
  # rx pass
    rx1415_cur."!cursor_pass"(rx1415_pos, "GLOBALish")
    if_null rx1415_debug, debug_973
    rx1415_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1415_pos)
  debug_973:
    .return (rx1415_cur)
  rx1415_restart:
.annotate 'line', 469
    if_null rx1415_debug, debug_974
    rx1415_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_974:
  rx1415_fail:
    (rx1415_rep, rx1415_pos, $I10, $P10) = rx1415_cur."!mark_fail"(0)
    lt rx1415_pos, -1, rx1415_done
    eq rx1415_pos, -1, rx1415_fail
    jump $I10
  rx1415_done:
    rx1415_cur."!cursor_fail"()
    if_null rx1415_debug, debug_975
    rx1415_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_975:
    .return (rx1415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("88_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("89_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_976
    rx1419_cur."!cursor_debug"("START", "finishpad")
  debug_976:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1419_pos) = rx1419_cur."from"()
    inc rx1419_pos
    rx1419_cur."!cursor_from"(rx1419_pos)
    ge rx1419_pos, rx1419_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1420_done:
.annotate 'line', 646
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "finishpad")
    if_null rx1419_debug, debug_977
    rx1419_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1419_pos)
  debug_977:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 469
    if_null rx1419_debug, debug_978
    rx1419_cur."!cursor_debug"("NEXT", "finishpad")
  debug_978:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_979
    rx1419_cur."!cursor_debug"("FAIL", "finishpad")
  debug_979:
    .return (rx1419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("90_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("91_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1423_tgt
    .local int rx1423_pos
    .local int rx1423_off
    .local int rx1423_eos
    .local int rx1423_rep
    .local pmc rx1423_cur
    .local pmc rx1423_debug
    (rx1423_cur, rx1423_pos, rx1423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1423_cur
    .local pmc match
    .lex "$/", match
    length rx1423_eos, rx1423_tgt
    gt rx1423_pos, rx1423_eos, rx1423_done
    set rx1423_off, 0
    lt rx1423_pos, 2, rx1423_start
    sub rx1423_off, rx1423_pos, 1
    substr rx1423_tgt, rx1423_tgt, rx1423_off
  rx1423_start:
    eq $I10, 1, rx1423_restart
    if_null rx1423_debug, debug_980
    rx1423_cur."!cursor_debug"("START", "you_are_here")
  debug_980:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1424_done
    goto rxscan1424_scan
  rxscan1424_loop:
    (rx1423_pos) = rx1423_cur."from"()
    inc rx1423_pos
    rx1423_cur."!cursor_from"(rx1423_pos)
    ge rx1423_pos, rx1423_eos, rxscan1424_done
  rxscan1424_scan:
    set_addr $I10, rxscan1424_loop
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  rxscan1424_done:
.annotate 'line', 647
  # rx pass
    rx1423_cur."!cursor_pass"(rx1423_pos, "you_are_here")
    if_null rx1423_debug, debug_981
    rx1423_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1423_pos)
  debug_981:
    .return (rx1423_cur)
  rx1423_restart:
.annotate 'line', 469
    if_null rx1423_debug, debug_982
    rx1423_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_982:
  rx1423_fail:
    (rx1423_rep, rx1423_pos, $I10, $P10) = rx1423_cur."!mark_fail"(0)
    lt rx1423_pos, -1, rx1423_done
    eq rx1423_pos, -1, rx1423_fail
    jump $I10
  rx1423_done:
    rx1423_cur."!cursor_fail"()
    if_null rx1423_debug, debug_983
    rx1423_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_983:
    .return (rx1423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("92_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("93_1321350766.1143")
    .param pmc param_1427
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 649
    .lex "self", param_1427
    $P103 = param_1427."!protoregex"("terminator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("94_1321350766.1143")
    .param pmc param_1429
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 649
    .lex "self", param_1429
    $P104 = param_1429."!PREFIX__!protoregex"("terminator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("95_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1431_tgt
    .local int rx1431_pos
    .local int rx1431_off
    .local int rx1431_eos
    .local int rx1431_rep
    .local pmc rx1431_cur
    .local pmc rx1431_debug
    (rx1431_cur, rx1431_pos, rx1431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1431_cur
    .local pmc match
    .lex "$/", match
    length rx1431_eos, rx1431_tgt
    gt rx1431_pos, rx1431_eos, rx1431_done
    set rx1431_off, 0
    lt rx1431_pos, 2, rx1431_start
    sub rx1431_off, rx1431_pos, 1
    substr rx1431_tgt, rx1431_tgt, rx1431_off
  rx1431_start:
    eq $I10, 1, rx1431_restart
    if_null rx1431_debug, debug_984
    rx1431_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_984:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1432_done
    goto rxscan1432_scan
  rxscan1432_loop:
    (rx1431_pos) = rx1431_cur."from"()
    inc rx1431_pos
    rx1431_cur."!cursor_from"(rx1431_pos)
    ge rx1431_pos, rx1431_eos, rxscan1432_done
  rxscan1432_scan:
    set_addr $I10, rxscan1432_loop
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  rxscan1432_done:
.annotate 'line', 651
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1431_pos, rx1431_off
    substr $S10, rx1431_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1431_fail
  # rx pass
    rx1431_cur."!cursor_pass"(rx1431_pos, "terminator:sym<;>")
    if_null rx1431_debug, debug_985
    rx1431_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1431_pos)
  debug_985:
    .return (rx1431_cur)
  rx1431_restart:
.annotate 'line', 469
    if_null rx1431_debug, debug_986
    rx1431_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_986:
  rx1431_fail:
    (rx1431_rep, rx1431_pos, $I10, $P10) = rx1431_cur."!mark_fail"(0)
    lt rx1431_pos, -1, rx1431_done
    eq rx1431_pos, -1, rx1431_fail
    jump $I10
  rx1431_done:
    rx1431_cur."!cursor_fail"()
    if_null rx1431_debug, debug_987
    rx1431_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_987:
    .return (rx1431_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("96_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("97_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_988
    rx1435_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_988:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1436_done:
.annotate 'line', 652
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1435_pos, rx1435_off
    substr $S10, rx1435_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1435_fail
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "terminator:sym<}>")
    if_null rx1435_debug, debug_989
    rx1435_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1435_pos)
  debug_989:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 469
    if_null rx1435_debug, debug_990
    rx1435_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_990:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_991
    rx1435_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_991:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("98_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("99_1321350766.1143")
    .param pmc param_1439
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 656
    .lex "self", param_1439
    $P103 = param_1439."!protoregex"("statement_control")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("100_1321350766.1143")
    .param pmc param_1441
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 656
    .lex "self", param_1441
    $P104 = param_1441."!PREFIX__!protoregex"("statement_control")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("101_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1443_tgt
    .local int rx1443_pos
    .local int rx1443_off
    .local int rx1443_eos
    .local int rx1443_rep
    .local pmc rx1443_cur
    .local pmc rx1443_debug
    (rx1443_cur, rx1443_pos, rx1443_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1443_cur
    .local pmc match
    .lex "$/", match
    length rx1443_eos, rx1443_tgt
    gt rx1443_pos, rx1443_eos, rx1443_done
    set rx1443_off, 0
    lt rx1443_pos, 2, rx1443_start
    sub rx1443_off, rx1443_pos, 1
    substr rx1443_tgt, rx1443_tgt, rx1443_off
  rx1443_start:
    eq $I10, 1, rx1443_restart
    if_null rx1443_debug, debug_992
    rx1443_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_992:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1444_done
    goto rxscan1444_scan
  rxscan1444_loop:
    (rx1443_pos) = rx1443_cur."from"()
    inc rx1443_pos
    rx1443_cur."!cursor_from"(rx1443_pos)
    ge rx1443_pos, rx1443_eos, rxscan1444_done
  rxscan1444_scan:
    set_addr $I10, rxscan1444_loop
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  rxscan1444_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1445_fail
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  # rx literal  "use"
    add $I11, rx1443_pos, 3
    gt $I11, rx1443_eos, rx1443_fail
    sub $I11, rx1443_pos, rx1443_off
    substr $S10, rx1443_tgt, $I11, 3
    ne $S10, "use", rx1443_fail
    add rx1443_pos, 3
    set_addr $I10, rxcap_1445_fail
    ($I12, $I11) = rx1443_cur."!mark_peek"($I10)
    rx1443_cur."!cursor_pos"($I11)
    ($P10) = rx1443_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1443_pos, "")
    rx1443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1445_done
  rxcap_1445_fail:
    goto rx1443_fail
  rxcap_1445_done:
  # rx charclass s
    ge rx1443_pos, rx1443_eos, rx1443_fail
    sub $I10, rx1443_pos, rx1443_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1443_tgt, $I10
    unless $I11, rx1443_fail
    inc rx1443_pos
  # rx subrule "ws" subtype=method negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."ws"()
    unless $P10, rx1443_fail
    rx1443_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."name"()
    unless $P10, rx1443_fail
    rx1443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1443_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."ws"()
    unless $P10, rx1443_fail
    rx1443_pos = $P10."pos"()
.annotate 'line', 658
  # rx pass
    rx1443_cur."!cursor_pass"(rx1443_pos, "statement_control:sym<use>")
    if_null rx1443_debug, debug_993
    rx1443_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1443_pos)
  debug_993:
    .return (rx1443_cur)
  rx1443_restart:
.annotate 'line', 469
    if_null rx1443_debug, debug_994
    rx1443_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_994:
  rx1443_fail:
    (rx1443_rep, rx1443_pos, $I10, $P10) = rx1443_cur."!mark_fail"(0)
    lt rx1443_pos, -1, rx1443_done
    eq rx1443_pos, -1, rx1443_fail
    jump $I10
  rx1443_done:
    rx1443_cur."!cursor_fail"()
    if_null rx1443_debug, debug_995
    rx1443_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_995:
    .return (rx1443_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("102_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P105, "ResizablePMCArray"
    push $P105, "use"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("103_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1448_tgt
    .local int rx1448_pos
    .local int rx1448_off
    .local int rx1448_eos
    .local int rx1448_rep
    .local pmc rx1448_cur
    .local pmc rx1448_debug
    (rx1448_cur, rx1448_pos, rx1448_tgt, $I10) = self."!cursor_start"()
    rx1448_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1448_cur
    .local pmc match
    .lex "$/", match
    length rx1448_eos, rx1448_tgt
    gt rx1448_pos, rx1448_eos, rx1448_done
    set rx1448_off, 0
    lt rx1448_pos, 2, rx1448_start
    sub rx1448_off, rx1448_pos, 1
    substr rx1448_tgt, rx1448_tgt, rx1448_off
  rx1448_start:
    eq $I10, 1, rx1448_restart
    if_null rx1448_debug, debug_996
    rx1448_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_996:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1449_done
    goto rxscan1449_scan
  rxscan1449_loop:
    (rx1448_pos) = rx1448_cur."from"()
    inc rx1448_pos
    rx1448_cur."!cursor_from"(rx1448_pos)
    ge rx1448_pos, rx1448_eos, rxscan1449_done
  rxscan1449_scan:
    set_addr $I10, rxscan1449_loop
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  rxscan1449_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1450_fail
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  # rx literal  "if"
    add $I11, rx1448_pos, 2
    gt $I11, rx1448_eos, rx1448_fail
    sub $I11, rx1448_pos, rx1448_off
    substr $S10, rx1448_tgt, $I11, 2
    ne $S10, "if", rx1448_fail
    add rx1448_pos, 2
    set_addr $I10, rxcap_1450_fail
    ($I12, $I11) = rx1448_cur."!mark_peek"($I10)
    rx1448_cur."!cursor_pos"($I11)
    ($P10) = rx1448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1448_pos, "")
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1450_done
  rxcap_1450_fail:
    goto rx1448_fail
  rxcap_1450_done:
  # rx charclass s
    ge rx1448_pos, rx1448_eos, rx1448_fail
    sub $I10, rx1448_pos, rx1448_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1448_tgt, $I10
    unless $I11, rx1448_fail
    inc rx1448_pos
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
.annotate 'line', 664
  # rx subrule "xblock" subtype=capture negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."xblock"()
    unless $P10, rx1448_fail
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
.annotate 'line', 665
  # rx rxquantr1451 ** 0..*
    set_addr $I10, rxquantr1451_done
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  rxquantr1451_loop:
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1448_pos, 5
    gt $I11, rx1448_eos, rx1448_fail
    sub $I11, rx1448_pos, rx1448_off
    substr $S10, rx1448_tgt, $I11, 5
    ne $S10, "elsif", rx1448_fail
    add rx1448_pos, 5
  # rx charclass s
    ge rx1448_pos, rx1448_eos, rx1448_fail
    sub $I10, rx1448_pos, rx1448_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1448_tgt, $I10
    unless $I11, rx1448_fail
    inc rx1448_pos
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."xblock"()
    unless $P10, rx1448_fail
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
    set_addr $I10, rxquantr1451_done
    (rx1448_rep) = rx1448_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1451_done
    rx1448_cur."!mark_push"(rx1448_rep, rx1448_pos, $I10)
    goto rxquantr1451_loop
  rxquantr1451_done:
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
.annotate 'line', 666
  # rx rxquantr1452 ** 0..1
    set_addr $I10, rxquantr1452_done
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  rxquantr1452_loop:
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1448_pos, 4
    gt $I11, rx1448_eos, rx1448_fail
    sub $I11, rx1448_pos, rx1448_off
    substr $S10, rx1448_tgt, $I11, 4
    ne $S10, "else", rx1448_fail
    add rx1448_pos, 4
  # rx charclass s
    ge rx1448_pos, rx1448_eos, rx1448_fail
    sub $I10, rx1448_pos, rx1448_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1448_tgt, $I10
    unless $I11, rx1448_fail
    inc rx1448_pos
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."pblock"()
    unless $P10, rx1448_fail
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
    set_addr $I10, rxquantr1452_done
    (rx1448_rep) = rx1448_cur."!mark_commit"($I10)
  rxquantr1452_done:
  # rx subrule "ws" subtype=method negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."ws"()
    unless $P10, rx1448_fail
    rx1448_pos = $P10."pos"()
.annotate 'line', 662
  # rx pass
    rx1448_cur."!cursor_pass"(rx1448_pos, "statement_control:sym<if>")
    if_null rx1448_debug, debug_997
    rx1448_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1448_pos)
  debug_997:
    .return (rx1448_cur)
  rx1448_restart:
.annotate 'line', 469
    if_null rx1448_debug, debug_998
    rx1448_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_998:
  rx1448_fail:
    (rx1448_rep, rx1448_pos, $I10, $P10) = rx1448_cur."!mark_fail"(0)
    lt rx1448_pos, -1, rx1448_done
    eq rx1448_pos, -1, rx1448_fail
    jump $I10
  rx1448_done:
    rx1448_cur."!cursor_fail"()
    if_null rx1448_debug, debug_999
    rx1448_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_999:
    .return (rx1448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("104_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P113, "ResizablePMCArray"
    push $P113, "if"
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("105_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1460 = "106_1321350766.1143" 
    capture_lex $P1460
    .local string rx1455_tgt
    .local int rx1455_pos
    .local int rx1455_off
    .local int rx1455_eos
    .local int rx1455_rep
    .local pmc rx1455_cur
    .local pmc rx1455_debug
    (rx1455_cur, rx1455_pos, rx1455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1455_cur
    .local pmc match
    .lex "$/", match
    length rx1455_eos, rx1455_tgt
    gt rx1455_pos, rx1455_eos, rx1455_done
    set rx1455_off, 0
    lt rx1455_pos, 2, rx1455_start
    sub rx1455_off, rx1455_pos, 1
    substr rx1455_tgt, rx1455_tgt, rx1455_off
  rx1455_start:
    eq $I10, 1, rx1455_restart
    if_null rx1455_debug, debug_1000
    rx1455_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_1000:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1456_done
    goto rxscan1456_scan
  rxscan1456_loop:
    (rx1455_pos) = rx1455_cur."from"()
    inc rx1455_pos
    rx1455_cur."!cursor_from"(rx1455_pos)
    ge rx1455_pos, rx1455_eos, rxscan1456_done
  rxscan1456_scan:
    set_addr $I10, rxscan1456_loop
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  rxscan1456_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1457_fail
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1455_pos, 6
    gt $I11, rx1455_eos, rx1455_fail
    sub $I11, rx1455_pos, rx1455_off
    substr $S10, rx1455_tgt, $I11, 6
    ne $S10, "unless", rx1455_fail
    add rx1455_pos, 6
    set_addr $I10, rxcap_1457_fail
    ($I12, $I11) = rx1455_cur."!mark_peek"($I10)
    rx1455_cur."!cursor_pos"($I11)
    ($P10) = rx1455_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1455_pos, "")
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1457_done
  rxcap_1457_fail:
    goto rx1455_fail
  rxcap_1457_done:
  # rx charclass s
    ge rx1455_pos, rx1455_eos, rx1455_fail
    sub $I10, rx1455_pos, rx1455_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1455_tgt, $I10
    unless $I11, rx1455_fail
    inc rx1455_pos
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
.annotate 'line', 671
  # rx subrule "xblock" subtype=capture negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."xblock"()
    unless $P10, rx1455_fail
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1455_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
  alt1458_0:
.annotate 'line', 672
    set_addr $I10, alt1458_1
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1455_cur."!cursor_pos"(rx1455_pos)
    .const 'Sub' $P1460 = "106_1321350766.1143" 
    capture_lex $P1460
    $P10 = rx1455_cur."before"($P1460)
    if $P10, rx1455_fail
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
    goto alt1458_end
  alt1458_1:
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
  alt1458_end:
  # rx subrule "ws" subtype=method negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."ws"()
    unless $P10, rx1455_fail
    rx1455_pos = $P10."pos"()
.annotate 'line', 669
  # rx pass
    rx1455_cur."!cursor_pass"(rx1455_pos, "statement_control:sym<unless>")
    if_null rx1455_debug, debug_1005
    rx1455_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1455_pos)
  debug_1005:
    .return (rx1455_cur)
  rx1455_restart:
.annotate 'line', 469
    if_null rx1455_debug, debug_1006
    rx1455_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_1006:
  rx1455_fail:
    (rx1455_rep, rx1455_pos, $I10, $P10) = rx1455_cur."!mark_fail"(0)
    lt rx1455_pos, -1, rx1455_done
    eq rx1455_pos, -1, rx1455_fail
    jump $I10
  rx1455_done:
    rx1455_cur."!cursor_fail"()
    if_null rx1455_debug, debug_1007
    rx1455_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_1007:
    .return (rx1455_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1459"  :anon :subid("106_1321350766.1143") :method :outer("105_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 672
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1001
    rx1461_cur."!cursor_debug"("START", "")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1462_done
    goto rxscan1462_scan
  rxscan1462_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1462_done
  rxscan1462_scan:
    set_addr $I10, rxscan1462_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1462_done:
  # rx literal  "else"
    add $I11, rx1461_pos, 4
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 4
    ne $S10, "else", rx1461_fail
    add rx1461_pos, 4
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "")
    if_null rx1461_debug, debug_1002
    rx1461_cur."!cursor_debug"("PASS", "", " at pos=", rx1461_pos)
  debug_1002:
    .return (rx1461_cur)
  rx1461_restart:
    if_null rx1461_debug, debug_1003
    rx1461_cur."!cursor_debug"("NEXT", "")
  debug_1003:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1004
    rx1461_cur."!cursor_debug"("FAIL", "")
  debug_1004:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("107_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P110, "ResizablePMCArray"
    push $P110, "unless"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("108_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1465_tgt
    .local int rx1465_pos
    .local int rx1465_off
    .local int rx1465_eos
    .local int rx1465_rep
    .local pmc rx1465_cur
    .local pmc rx1465_debug
    (rx1465_cur, rx1465_pos, rx1465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1465_cur
    .local pmc match
    .lex "$/", match
    length rx1465_eos, rx1465_tgt
    gt rx1465_pos, rx1465_eos, rx1465_done
    set rx1465_off, 0
    lt rx1465_pos, 2, rx1465_start
    sub rx1465_off, rx1465_pos, 1
    substr rx1465_tgt, rx1465_tgt, rx1465_off
  rx1465_start:
    eq $I10, 1, rx1465_restart
    if_null rx1465_debug, debug_1008
    rx1465_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_1008:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1466_done
    goto rxscan1466_scan
  rxscan1466_loop:
    (rx1465_pos) = rx1465_cur."from"()
    inc rx1465_pos
    rx1465_cur."!cursor_from"(rx1465_pos)
    ge rx1465_pos, rx1465_eos, rxscan1466_done
  rxscan1466_scan:
    set_addr $I10, rxscan1466_loop
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxscan1466_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1468_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  alt1467_0:
    set_addr $I10, alt1467_1
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "while"
    add $I11, rx1465_pos, 5
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    substr $S10, rx1465_tgt, $I11, 5
    ne $S10, "while", rx1465_fail
    add rx1465_pos, 5
    goto alt1467_end
  alt1467_1:
  # rx literal  "until"
    add $I11, rx1465_pos, 5
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    substr $S10, rx1465_tgt, $I11, 5
    ne $S10, "until", rx1465_fail
    add rx1465_pos, 5
  alt1467_end:
    set_addr $I10, rxcap_1468_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1468_done
  rxcap_1468_fail:
    goto rx1465_fail
  rxcap_1468_done:
  # rx charclass s
    ge rx1465_pos, rx1465_eos, rx1465_fail
    sub $I10, rx1465_pos, rx1465_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1465_tgt, $I10
    unless $I11, rx1465_fail
    inc rx1465_pos
  # rx subrule "ws" subtype=method negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."ws"()
    unless $P10, rx1465_fail
    rx1465_pos = $P10."pos"()
.annotate 'line', 677
  # rx subrule "xblock" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."xblock"()
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1465_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."ws"()
    unless $P10, rx1465_fail
    rx1465_pos = $P10."pos"()
.annotate 'line', 675
  # rx pass
    rx1465_cur."!cursor_pass"(rx1465_pos, "statement_control:sym<while>")
    if_null rx1465_debug, debug_1009
    rx1465_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1465_pos)
  debug_1009:
    .return (rx1465_cur)
  rx1465_restart:
.annotate 'line', 469
    if_null rx1465_debug, debug_1010
    rx1465_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_1010:
  rx1465_fail:
    (rx1465_rep, rx1465_pos, $I10, $P10) = rx1465_cur."!mark_fail"(0)
    lt rx1465_pos, -1, rx1465_done
    eq rx1465_pos, -1, rx1465_fail
    jump $I10
  rx1465_done:
    rx1465_cur."!cursor_fail"()
    if_null rx1465_debug, debug_1011
    rx1465_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_1011:
    .return (rx1465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("109_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P105, "ResizablePMCArray"
    push $P105, "until"
    push $P105, "while"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("110_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1471_tgt
    .local int rx1471_pos
    .local int rx1471_off
    .local int rx1471_eos
    .local int rx1471_rep
    .local pmc rx1471_cur
    .local pmc rx1471_debug
    (rx1471_cur, rx1471_pos, rx1471_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1471_cur
    .local pmc match
    .lex "$/", match
    length rx1471_eos, rx1471_tgt
    gt rx1471_pos, rx1471_eos, rx1471_done
    set rx1471_off, 0
    lt rx1471_pos, 2, rx1471_start
    sub rx1471_off, rx1471_pos, 1
    substr rx1471_tgt, rx1471_tgt, rx1471_off
  rx1471_start:
    eq $I10, 1, rx1471_restart
    if_null rx1471_debug, debug_1012
    rx1471_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_1012:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1471_pos) = rx1471_cur."from"()
    inc rx1471_pos
    rx1471_cur."!cursor_from"(rx1471_pos)
    ge rx1471_pos, rx1471_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  rxscan1472_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1471_pos, 6
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 6
    ne $S10, "repeat", rx1471_fail
    add rx1471_pos, 6
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1471_cur."!mark_peek"($I10)
    rx1471_cur."!cursor_pos"($I11)
    ($P10) = rx1471_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1471_pos, "")
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1471_fail
  rxcap_1473_done:
  # rx charclass s
    ge rx1471_pos, rx1471_eos, rx1471_fail
    sub $I10, rx1471_pos, rx1471_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1471_tgt, $I10
    unless $I11, rx1471_fail
    inc rx1471_pos
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  alt1474_0:
.annotate 'line', 682
    set_addr $I10, alt1474_1
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
.annotate 'line', 683
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1476_fail
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  alt1475_0:
    set_addr $I10, alt1475_1
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  # rx literal  "while"
    add $I11, rx1471_pos, 5
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 5
    ne $S10, "while", rx1471_fail
    add rx1471_pos, 5
    goto alt1475_end
  alt1475_1:
  # rx literal  "until"
    add $I11, rx1471_pos, 5
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 5
    ne $S10, "until", rx1471_fail
    add rx1471_pos, 5
  alt1475_end:
    set_addr $I10, rxcap_1476_fail
    ($I12, $I11) = rx1471_cur."!mark_peek"($I10)
    rx1471_cur."!cursor_pos"($I11)
    ($P10) = rx1471_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1471_pos, "")
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1476_done
  rxcap_1476_fail:
    goto rx1471_fail
  rxcap_1476_done:
  # rx charclass s
    ge rx1471_pos, rx1471_eos, rx1471_fail
    sub $I10, rx1471_pos, rx1471_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1471_tgt, $I10
    unless $I11, rx1471_fail
    inc rx1471_pos
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."xblock"()
    unless $P10, rx1471_fail
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1471_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
    goto alt1474_end
  alt1474_1:
.annotate 'line', 684
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."pblock"()
    unless $P10, rx1471_fail
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1471_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1478_fail
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  alt1477_0:
    set_addr $I10, alt1477_1
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  # rx literal  "while"
    add $I11, rx1471_pos, 5
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 5
    ne $S10, "while", rx1471_fail
    add rx1471_pos, 5
    goto alt1477_end
  alt1477_1:
  # rx literal  "until"
    add $I11, rx1471_pos, 5
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 5
    ne $S10, "until", rx1471_fail
    add rx1471_pos, 5
  alt1477_end:
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1471_cur."!mark_peek"($I10)
    rx1471_cur."!cursor_pos"($I11)
    ($P10) = rx1471_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1471_pos, "")
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1471_fail
  rxcap_1478_done:
  # rx charclass s
    ge rx1471_pos, rx1471_eos, rx1471_fail
    sub $I10, rx1471_pos, rx1471_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1471_tgt, $I10
    unless $I11, rx1471_fail
    inc rx1471_pos
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."EXPR"()
    unless $P10, rx1471_fail
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1471_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
  alt1474_end:
.annotate 'line', 685
  # rx subrule "ws" subtype=method negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."ws"()
    unless $P10, rx1471_fail
    rx1471_pos = $P10."pos"()
.annotate 'line', 680
  # rx pass
    rx1471_cur."!cursor_pass"(rx1471_pos, "statement_control:sym<repeat>")
    if_null rx1471_debug, debug_1013
    rx1471_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1471_pos)
  debug_1013:
    .return (rx1471_cur)
  rx1471_restart:
.annotate 'line', 469
    if_null rx1471_debug, debug_1014
    rx1471_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_1014:
  rx1471_fail:
    (rx1471_rep, rx1471_pos, $I10, $P10) = rx1471_cur."!mark_fail"(0)
    lt rx1471_pos, -1, rx1471_done
    eq rx1471_pos, -1, rx1471_fail
    jump $I10
  rx1471_done:
    rx1471_cur."!cursor_fail"()
    if_null rx1471_debug, debug_1015
    rx1471_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_1015:
    .return (rx1471_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("111_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P112, "ResizablePMCArray"
    push $P112, "repeat"
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("112_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1481_tgt
    .local int rx1481_pos
    .local int rx1481_off
    .local int rx1481_eos
    .local int rx1481_rep
    .local pmc rx1481_cur
    .local pmc rx1481_debug
    (rx1481_cur, rx1481_pos, rx1481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1481_cur
    .local pmc match
    .lex "$/", match
    length rx1481_eos, rx1481_tgt
    gt rx1481_pos, rx1481_eos, rx1481_done
    set rx1481_off, 0
    lt rx1481_pos, 2, rx1481_start
    sub rx1481_off, rx1481_pos, 1
    substr rx1481_tgt, rx1481_tgt, rx1481_off
  rx1481_start:
    eq $I10, 1, rx1481_restart
    if_null rx1481_debug, debug_1016
    rx1481_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_1016:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1482_done
    goto rxscan1482_scan
  rxscan1482_loop:
    (rx1481_pos) = rx1481_cur."from"()
    inc rx1481_pos
    rx1481_cur."!cursor_from"(rx1481_pos)
    ge rx1481_pos, rx1481_eos, rxscan1482_done
  rxscan1482_scan:
    set_addr $I10, rxscan1482_loop
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  rxscan1482_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1483_fail
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  # rx literal  "for"
    add $I11, rx1481_pos, 3
    gt $I11, rx1481_eos, rx1481_fail
    sub $I11, rx1481_pos, rx1481_off
    substr $S10, rx1481_tgt, $I11, 3
    ne $S10, "for", rx1481_fail
    add rx1481_pos, 3
    set_addr $I10, rxcap_1483_fail
    ($I12, $I11) = rx1481_cur."!mark_peek"($I10)
    rx1481_cur."!cursor_pos"($I11)
    ($P10) = rx1481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1481_pos, "")
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1483_done
  rxcap_1483_fail:
    goto rx1481_fail
  rxcap_1483_done:
  # rx charclass s
    ge rx1481_pos, rx1481_eos, rx1481_fail
    sub $I10, rx1481_pos, rx1481_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1481_tgt, $I10
    unless $I11, rx1481_fail
    inc rx1481_pos
  # rx subrule "ws" subtype=method negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."ws"()
    unless $P10, rx1481_fail
    rx1481_pos = $P10."pos"()
.annotate 'line', 690
  # rx subrule "xblock" subtype=capture negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."xblock"()
    unless $P10, rx1481_fail
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1481_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."ws"()
    unless $P10, rx1481_fail
    rx1481_pos = $P10."pos"()
.annotate 'line', 688
  # rx pass
    rx1481_cur."!cursor_pass"(rx1481_pos, "statement_control:sym<for>")
    if_null rx1481_debug, debug_1017
    rx1481_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1481_pos)
  debug_1017:
    .return (rx1481_cur)
  rx1481_restart:
.annotate 'line', 469
    if_null rx1481_debug, debug_1018
    rx1481_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_1018:
  rx1481_fail:
    (rx1481_rep, rx1481_pos, $I10, $P10) = rx1481_cur."!mark_fail"(0)
    lt rx1481_pos, -1, rx1481_done
    eq rx1481_pos, -1, rx1481_fail
    jump $I10
  rx1481_done:
    rx1481_cur."!cursor_fail"()
    if_null rx1481_debug, debug_1019
    rx1481_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_1019:
    .return (rx1481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("113_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P105, "ResizablePMCArray"
    push $P105, "for"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("114_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1020
    rx1486_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_1020:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1487_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1488_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1486_pos, 5
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    substr $S10, rx1486_tgt, $I11, 5
    ne $S10, "CATCH", rx1486_fail
    add rx1486_pos, 5
    set_addr $I10, rxcap_1488_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1488_done
  rxcap_1488_fail:
    goto rx1486_fail
  rxcap_1488_done:
  # rx charclass s
    ge rx1486_pos, rx1486_eos, rx1486_fail
    sub $I10, rx1486_pos, rx1486_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1486_tgt, $I10
    unless $I11, rx1486_fail
    inc rx1486_pos
  # rx subrule "ws" subtype=method negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."ws"()
    unless $P10, rx1486_fail
    rx1486_pos = $P10."pos"()
.annotate 'line', 695
  # rx subrule "block" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."block"()
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1486_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."ws"()
    unless $P10, rx1486_fail
    rx1486_pos = $P10."pos"()
.annotate 'line', 693
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "statement_control:sym<CATCH>")
    if_null rx1486_debug, debug_1021
    rx1486_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1486_pos)
  debug_1021:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 469
    if_null rx1486_debug, debug_1022
    rx1486_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1022:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1023
    rx1486_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1023:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("115_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P105, "ResizablePMCArray"
    push $P105, "CATCH"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("116_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1491_tgt
    .local int rx1491_pos
    .local int rx1491_off
    .local int rx1491_eos
    .local int rx1491_rep
    .local pmc rx1491_cur
    .local pmc rx1491_debug
    (rx1491_cur, rx1491_pos, rx1491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1491_cur
    .local pmc match
    .lex "$/", match
    length rx1491_eos, rx1491_tgt
    gt rx1491_pos, rx1491_eos, rx1491_done
    set rx1491_off, 0
    lt rx1491_pos, 2, rx1491_start
    sub rx1491_off, rx1491_pos, 1
    substr rx1491_tgt, rx1491_tgt, rx1491_off
  rx1491_start:
    eq $I10, 1, rx1491_restart
    if_null rx1491_debug, debug_1024
    rx1491_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1492_done
    goto rxscan1492_scan
  rxscan1492_loop:
    (rx1491_pos) = rx1491_cur."from"()
    inc rx1491_pos
    rx1491_cur."!cursor_from"(rx1491_pos)
    ge rx1491_pos, rx1491_eos, rxscan1492_done
  rxscan1492_scan:
    set_addr $I10, rxscan1492_loop
    rx1491_cur."!mark_push"(0, rx1491_pos, $I10)
  rxscan1492_done:
.annotate 'line', 699
  # rx subcapture "sym"
    set_addr $I10, rxcap_1493_fail
    rx1491_cur."!mark_push"(0, rx1491_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1491_pos, 7
    gt $I11, rx1491_eos, rx1491_fail
    sub $I11, rx1491_pos, rx1491_off
    substr $S10, rx1491_tgt, $I11, 7
    ne $S10, "CONTROL", rx1491_fail
    add rx1491_pos, 7
    set_addr $I10, rxcap_1493_fail
    ($I12, $I11) = rx1491_cur."!mark_peek"($I10)
    rx1491_cur."!cursor_pos"($I11)
    ($P10) = rx1491_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1491_pos, "")
    rx1491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1493_done
  rxcap_1493_fail:
    goto rx1491_fail
  rxcap_1493_done:
  # rx charclass s
    ge rx1491_pos, rx1491_eos, rx1491_fail
    sub $I10, rx1491_pos, rx1491_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1491_tgt, $I10
    unless $I11, rx1491_fail
    inc rx1491_pos
  # rx subrule "ws" subtype=method negate=
    rx1491_cur."!cursor_pos"(rx1491_pos)
    $P10 = rx1491_cur."ws"()
    unless $P10, rx1491_fail
    rx1491_pos = $P10."pos"()
.annotate 'line', 700
  # rx subrule "block" subtype=capture negate=
    rx1491_cur."!cursor_pos"(rx1491_pos)
    $P10 = rx1491_cur."block"()
    unless $P10, rx1491_fail
    rx1491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1491_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1491_cur."!cursor_pos"(rx1491_pos)
    $P10 = rx1491_cur."ws"()
    unless $P10, rx1491_fail
    rx1491_pos = $P10."pos"()
.annotate 'line', 698
  # rx pass
    rx1491_cur."!cursor_pass"(rx1491_pos, "statement_control:sym<CONTROL>")
    if_null rx1491_debug, debug_1025
    rx1491_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1491_pos)
  debug_1025:
    .return (rx1491_cur)
  rx1491_restart:
.annotate 'line', 469
    if_null rx1491_debug, debug_1026
    rx1491_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1026:
  rx1491_fail:
    (rx1491_rep, rx1491_pos, $I10, $P10) = rx1491_cur."!mark_fail"(0)
    lt rx1491_pos, -1, rx1491_done
    eq rx1491_pos, -1, rx1491_fail
    jump $I10
  rx1491_done:
    rx1491_cur."!cursor_fail"()
    if_null rx1491_debug, debug_1027
    rx1491_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1027:
    .return (rx1491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("117_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P105, "ResizablePMCArray"
    push $P105, "CONTROL"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("118_1321350766.1143")
    .param pmc param_1496
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 703
    .lex "self", param_1496
    $P103 = param_1496."!protoregex"("statement_prefix")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("119_1321350766.1143")
    .param pmc param_1498
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 703
    .lex "self", param_1498
    $P104 = param_1498."!PREFIX__!protoregex"("statement_prefix")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("120_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1028
    rx1500_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1501_done:
.annotate 'line', 704
  # rx subcapture "sym"
    set_addr $I10, rxcap_1502_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1500_pos, 4
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I11, 4
    ne $S10, "INIT", rx1500_fail
    add rx1500_pos, 4
    set_addr $I10, rxcap_1502_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1502_done
  rxcap_1502_fail:
    goto rx1500_fail
  rxcap_1502_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."blorst"()
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "statement_prefix:sym<INIT>")
    if_null rx1500_debug, debug_1029
    rx1500_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1500_pos)
  debug_1029:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 469
    if_null rx1500_debug, debug_1030
    rx1500_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1030:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1031
    rx1500_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1031:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("121_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("122_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1505_tgt
    .local int rx1505_pos
    .local int rx1505_off
    .local int rx1505_eos
    .local int rx1505_rep
    .local pmc rx1505_cur
    .local pmc rx1505_debug
    (rx1505_cur, rx1505_pos, rx1505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1505_cur
    .local pmc match
    .lex "$/", match
    length rx1505_eos, rx1505_tgt
    gt rx1505_pos, rx1505_eos, rx1505_done
    set rx1505_off, 0
    lt rx1505_pos, 2, rx1505_start
    sub rx1505_off, rx1505_pos, 1
    substr rx1505_tgt, rx1505_tgt, rx1505_off
  rx1505_start:
    eq $I10, 1, rx1505_restart
    if_null rx1505_debug, debug_1032
    rx1505_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1506_done
    goto rxscan1506_scan
  rxscan1506_loop:
    (rx1505_pos) = rx1505_cur."from"()
    inc rx1505_pos
    rx1505_cur."!cursor_from"(rx1505_pos)
    ge rx1505_pos, rx1505_eos, rxscan1506_done
  rxscan1506_scan:
    set_addr $I10, rxscan1506_loop
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  rxscan1506_done:
.annotate 'line', 707
  # rx subcapture "sym"
    set_addr $I10, rxcap_1507_fail
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  # rx literal  "try"
    add $I11, rx1505_pos, 3
    gt $I11, rx1505_eos, rx1505_fail
    sub $I11, rx1505_pos, rx1505_off
    substr $S10, rx1505_tgt, $I11, 3
    ne $S10, "try", rx1505_fail
    add rx1505_pos, 3
    set_addr $I10, rxcap_1507_fail
    ($I12, $I11) = rx1505_cur."!mark_peek"($I10)
    rx1505_cur."!cursor_pos"($I11)
    ($P10) = rx1505_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1505_pos, "")
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1507_done
  rxcap_1507_fail:
    goto rx1505_fail
  rxcap_1507_done:
.annotate 'line', 708
  # rx subrule "blorst" subtype=capture negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."blorst"()
    unless $P10, rx1505_fail
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1505_pos = $P10."pos"()
.annotate 'line', 706
  # rx pass
    rx1505_cur."!cursor_pass"(rx1505_pos, "statement_prefix:sym<try>")
    if_null rx1505_debug, debug_1033
    rx1505_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1505_pos)
  debug_1033:
    .return (rx1505_cur)
  rx1505_restart:
.annotate 'line', 469
    if_null rx1505_debug, debug_1034
    rx1505_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1034:
  rx1505_fail:
    (rx1505_rep, rx1505_pos, $I10, $P10) = rx1505_cur."!mark_fail"(0)
    lt rx1505_pos, -1, rx1505_done
    eq rx1505_pos, -1, rx1505_fail
    jump $I10
  rx1505_done:
    rx1505_cur."!cursor_fail"()
    if_null rx1505_debug, debug_1035
    rx1505_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1035:
    .return (rx1505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("123_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("blorst", "try")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("124_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1036
    rx1510_cur."!cursor_debug"("START", "blorst")
  debug_1036:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1511_done:
.annotate 'line', 712
  # rx charclass s
    ge rx1510_pos, rx1510_eos, rx1510_fail
    sub $I10, rx1510_pos, rx1510_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1510_tgt, $I10
    unless $I11, rx1510_fail
    inc rx1510_pos
  # rx subrule "ws" subtype=method negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."ws"()
    unless $P10, rx1510_fail
    rx1510_pos = $P10."pos"()
  alt1512_0:
    set_addr $I10, alt1512_1
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1510_fail
  # rx subrule "block" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."block"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1510_pos = $P10."pos"()
    goto alt1512_end
  alt1512_1:
  # rx subrule "statement" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."statement"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1510_pos = $P10."pos"()
  alt1512_end:
.annotate 'line', 711
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "blorst")
    if_null rx1510_debug, debug_1037
    rx1510_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1510_pos)
  debug_1037:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 469
    if_null rx1510_debug, debug_1038
    rx1510_cur."!cursor_debug"("NEXT", "blorst")
  debug_1038:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1039
    rx1510_cur."!cursor_debug"("FAIL", "blorst")
  debug_1039:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("125_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("126_1321350766.1143")
    .param pmc param_1515
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 717
    .lex "self", param_1515
    $P103 = param_1515."!protoregex"("statement_mod_cond")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("127_1321350766.1143")
    .param pmc param_1517
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 717
    .lex "self", param_1517
    $P104 = param_1517."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("128_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1040
    rx1519_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1040:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1520_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1521_fail
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  # rx literal  "if"
    add $I11, rx1519_pos, 2
    gt $I11, rx1519_eos, rx1519_fail
    sub $I11, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I11, 2
    ne $S10, "if", rx1519_fail
    add rx1519_pos, 2
    set_addr $I10, rxcap_1521_fail
    ($I12, $I11) = rx1519_cur."!mark_peek"($I10)
    rx1519_cur."!cursor_pos"($I11)
    ($P10) = rx1519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1519_pos, "")
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1521_done
  rxcap_1521_fail:
    goto rx1519_fail
  rxcap_1521_done:
  # rx subrule "ws" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."ws"()
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."EXPR"()
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1519_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."ws"()
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "statement_mod_cond:sym<if>")
    if_null rx1519_debug, debug_1041
    rx1519_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1519_pos)
  debug_1041:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 469
    if_null rx1519_debug, debug_1042
    rx1519_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1042:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1043
    rx1519_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1043:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("129_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "if")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("130_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1044
    rx1524_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1044:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1525_done:
.annotate 'line', 720
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1524_pos, 6
    gt $I11, rx1524_eos, rx1524_fail
    sub $I11, rx1524_pos, rx1524_off
    substr $S10, rx1524_tgt, $I11, 6
    ne $S10, "unless", rx1524_fail
    add rx1524_pos, 6
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1524_cur."!mark_peek"($I10)
    rx1524_cur."!cursor_pos"($I11)
    ($P10) = rx1524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1524_pos, "")
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1524_fail
  rxcap_1526_done:
  # rx subrule "ws" subtype=method negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."ws"()
    unless $P10, rx1524_fail
    rx1524_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."EXPR"()
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1524_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."ws"()
    unless $P10, rx1524_fail
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, "statement_mod_cond:sym<unless>")
    if_null rx1524_debug, debug_1045
    rx1524_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1524_pos)
  debug_1045:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 469
    if_null rx1524_debug, debug_1046
    rx1524_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1046:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1047
    rx1524_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1047:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("131_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "unless")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("132_1321350766.1143")
    .param pmc param_1529
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 722
    .lex "self", param_1529
    $P103 = param_1529."!protoregex"("statement_mod_loop")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("133_1321350766.1143")
    .param pmc param_1531
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 722
    .lex "self", param_1531
    $P104 = param_1531."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("134_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1048
    rx1533_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1048:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1534_done
    goto rxscan1534_scan
  rxscan1534_loop:
    (rx1533_pos) = rx1533_cur."from"()
    inc rx1533_pos
    rx1533_cur."!cursor_from"(rx1533_pos)
    ge rx1533_pos, rx1533_eos, rxscan1534_done
  rxscan1534_scan:
    set_addr $I10, rxscan1534_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1534_done:
.annotate 'line', 724
  # rx subcapture "sym"
    set_addr $I10, rxcap_1535_fail
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  # rx literal  "while"
    add $I11, rx1533_pos, 5
    gt $I11, rx1533_eos, rx1533_fail
    sub $I11, rx1533_pos, rx1533_off
    substr $S10, rx1533_tgt, $I11, 5
    ne $S10, "while", rx1533_fail
    add rx1533_pos, 5
    set_addr $I10, rxcap_1535_fail
    ($I12, $I11) = rx1533_cur."!mark_peek"($I10)
    rx1533_cur."!cursor_pos"($I11)
    ($P10) = rx1533_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1533_pos, "")
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1535_done
  rxcap_1535_fail:
    goto rx1533_fail
  rxcap_1535_done:
  # rx subrule "ws" subtype=method negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."ws"()
    unless $P10, rx1533_fail
    rx1533_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."EXPR"()
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1533_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."ws"()
    unless $P10, rx1533_fail
    rx1533_pos = $P10."pos"()
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "statement_mod_loop:sym<while>")
    if_null rx1533_debug, debug_1049
    rx1533_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1533_pos)
  debug_1049:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 469
    if_null rx1533_debug, debug_1050
    rx1533_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1050:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1051
    rx1533_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1051:
    .return (rx1533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("135_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "while")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("136_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1538_tgt
    .local int rx1538_pos
    .local int rx1538_off
    .local int rx1538_eos
    .local int rx1538_rep
    .local pmc rx1538_cur
    .local pmc rx1538_debug
    (rx1538_cur, rx1538_pos, rx1538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1538_cur
    .local pmc match
    .lex "$/", match
    length rx1538_eos, rx1538_tgt
    gt rx1538_pos, rx1538_eos, rx1538_done
    set rx1538_off, 0
    lt rx1538_pos, 2, rx1538_start
    sub rx1538_off, rx1538_pos, 1
    substr rx1538_tgt, rx1538_tgt, rx1538_off
  rx1538_start:
    eq $I10, 1, rx1538_restart
    if_null rx1538_debug, debug_1052
    rx1538_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1052:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1538_pos) = rx1538_cur."from"()
    inc rx1538_pos
    rx1538_cur."!cursor_from"(rx1538_pos)
    ge rx1538_pos, rx1538_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  rxscan1539_done:
.annotate 'line', 725
  # rx subcapture "sym"
    set_addr $I10, rxcap_1540_fail
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  # rx literal  "until"
    add $I11, rx1538_pos, 5
    gt $I11, rx1538_eos, rx1538_fail
    sub $I11, rx1538_pos, rx1538_off
    substr $S10, rx1538_tgt, $I11, 5
    ne $S10, "until", rx1538_fail
    add rx1538_pos, 5
    set_addr $I10, rxcap_1540_fail
    ($I12, $I11) = rx1538_cur."!mark_peek"($I10)
    rx1538_cur."!cursor_pos"($I11)
    ($P10) = rx1538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1538_pos, "")
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1540_done
  rxcap_1540_fail:
    goto rx1538_fail
  rxcap_1540_done:
  # rx subrule "ws" subtype=method negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."ws"()
    unless $P10, rx1538_fail
    rx1538_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."EXPR"()
    unless $P10, rx1538_fail
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1538_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."ws"()
    unless $P10, rx1538_fail
    rx1538_pos = $P10."pos"()
  # rx pass
    rx1538_cur."!cursor_pass"(rx1538_pos, "statement_mod_loop:sym<until>")
    if_null rx1538_debug, debug_1053
    rx1538_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1538_pos)
  debug_1053:
    .return (rx1538_cur)
  rx1538_restart:
.annotate 'line', 469
    if_null rx1538_debug, debug_1054
    rx1538_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1054:
  rx1538_fail:
    (rx1538_rep, rx1538_pos, $I10, $P10) = rx1538_cur."!mark_fail"(0)
    lt rx1538_pos, -1, rx1538_done
    eq rx1538_pos, -1, rx1538_fail
    jump $I10
  rx1538_done:
    rx1538_cur."!cursor_fail"()
    if_null rx1538_debug, debug_1055
    rx1538_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1055:
    .return (rx1538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("137_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "until")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("138_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1056
    rx1543_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1056:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1544_done:
.annotate 'line', 726
  # rx subcapture "sym"
    set_addr $I10, rxcap_1545_fail
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  # rx literal  "for"
    add $I11, rx1543_pos, 3
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    substr $S10, rx1543_tgt, $I11, 3
    ne $S10, "for", rx1543_fail
    add rx1543_pos, 3
    set_addr $I10, rxcap_1545_fail
    ($I12, $I11) = rx1543_cur."!mark_peek"($I10)
    rx1543_cur."!cursor_pos"($I11)
    ($P10) = rx1543_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1543_pos, "")
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1545_done
  rxcap_1545_fail:
    goto rx1543_fail
  rxcap_1545_done:
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."EXPR"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1543_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "statement_mod_loop:sym<for>")
    if_null rx1543_debug, debug_1057
    rx1543_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1543_pos)
  debug_1057:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 469
    if_null rx1543_debug, debug_1058
    rx1543_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1058:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1059
    rx1543_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1059:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("139_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "for")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("140_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1548_tgt
    .local int rx1548_pos
    .local int rx1548_off
    .local int rx1548_eos
    .local int rx1548_rep
    .local pmc rx1548_cur
    .local pmc rx1548_debug
    (rx1548_cur, rx1548_pos, rx1548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1548_cur
    .local pmc match
    .lex "$/", match
    length rx1548_eos, rx1548_tgt
    gt rx1548_pos, rx1548_eos, rx1548_done
    set rx1548_off, 0
    lt rx1548_pos, 2, rx1548_start
    sub rx1548_off, rx1548_pos, 1
    substr rx1548_tgt, rx1548_tgt, rx1548_off
  rx1548_start:
    eq $I10, 1, rx1548_restart
    if_null rx1548_debug, debug_1060
    rx1548_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1060:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1548_pos) = rx1548_cur."from"()
    inc rx1548_pos
    rx1548_cur."!cursor_from"(rx1548_pos)
    ge rx1548_pos, rx1548_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  rxscan1549_done:
.annotate 'line', 730
  # rx subrule "fatarrow" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."fatarrow"()
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1548_pos = $P10."pos"()
  # rx pass
    rx1548_cur."!cursor_pass"(rx1548_pos, "term:sym<fatarrow>")
    if_null rx1548_debug, debug_1061
    rx1548_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1548_pos)
  debug_1061:
    .return (rx1548_cur)
  rx1548_restart:
.annotate 'line', 469
    if_null rx1548_debug, debug_1062
    rx1548_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1062:
  rx1548_fail:
    (rx1548_rep, rx1548_pos, $I10, $P10) = rx1548_cur."!mark_fail"(0)
    lt rx1548_pos, -1, rx1548_done
    eq rx1548_pos, -1, rx1548_fail
    jump $I10
  rx1548_done:
    rx1548_cur."!cursor_fail"()
    if_null rx1548_debug, debug_1063
    rx1548_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1063:
    .return (rx1548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("141_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("142_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1552_tgt
    .local int rx1552_pos
    .local int rx1552_off
    .local int rx1552_eos
    .local int rx1552_rep
    .local pmc rx1552_cur
    .local pmc rx1552_debug
    (rx1552_cur, rx1552_pos, rx1552_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1552_cur
    .local pmc match
    .lex "$/", match
    length rx1552_eos, rx1552_tgt
    gt rx1552_pos, rx1552_eos, rx1552_done
    set rx1552_off, 0
    lt rx1552_pos, 2, rx1552_start
    sub rx1552_off, rx1552_pos, 1
    substr rx1552_tgt, rx1552_tgt, rx1552_off
  rx1552_start:
    eq $I10, 1, rx1552_restart
    if_null rx1552_debug, debug_1064
    rx1552_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1064:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1552_pos) = rx1552_cur."from"()
    inc rx1552_pos
    rx1552_cur."!cursor_from"(rx1552_pos)
    ge rx1552_pos, rx1552_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  rxscan1553_done:
.annotate 'line', 731
  # rx subrule "colonpair" subtype=capture negate=
    rx1552_cur."!cursor_pos"(rx1552_pos)
    $P10 = rx1552_cur."colonpair"()
    unless $P10, rx1552_fail
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1552_pos = $P10."pos"()
  # rx pass
    rx1552_cur."!cursor_pass"(rx1552_pos, "term:sym<colonpair>")
    if_null rx1552_debug, debug_1065
    rx1552_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1552_pos)
  debug_1065:
    .return (rx1552_cur)
  rx1552_restart:
.annotate 'line', 469
    if_null rx1552_debug, debug_1066
    rx1552_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1066:
  rx1552_fail:
    (rx1552_rep, rx1552_pos, $I10, $P10) = rx1552_cur."!mark_fail"(0)
    lt rx1552_pos, -1, rx1552_done
    eq rx1552_pos, -1, rx1552_fail
    jump $I10
  rx1552_done:
    rx1552_cur."!cursor_fail"()
    if_null rx1552_debug, debug_1067
    rx1552_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1067:
    .return (rx1552_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("143_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("colonpair", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("144_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1068
    rx1556_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1068:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1557_done
    goto rxscan1557_scan
  rxscan1557_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1557_done
  rxscan1557_scan:
    set_addr $I10, rxscan1557_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1557_done:
.annotate 'line', 732
  # rx subrule "variable" subtype=capture negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."variable"()
    unless $P10, rx1556_fail
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1556_pos = $P10."pos"()
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "term:sym<variable>")
    if_null rx1556_debug, debug_1069
    rx1556_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1556_pos)
  debug_1069:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 469
    if_null rx1556_debug, debug_1070
    rx1556_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1070:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1071
    rx1556_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1071:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("145_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("variable", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("146_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1560_tgt
    .local int rx1560_pos
    .local int rx1560_off
    .local int rx1560_eos
    .local int rx1560_rep
    .local pmc rx1560_cur
    .local pmc rx1560_debug
    (rx1560_cur, rx1560_pos, rx1560_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1560_cur
    .local pmc match
    .lex "$/", match
    length rx1560_eos, rx1560_tgt
    gt rx1560_pos, rx1560_eos, rx1560_done
    set rx1560_off, 0
    lt rx1560_pos, 2, rx1560_start
    sub rx1560_off, rx1560_pos, 1
    substr rx1560_tgt, rx1560_tgt, rx1560_off
  rx1560_start:
    eq $I10, 1, rx1560_restart
    if_null rx1560_debug, debug_1072
    rx1560_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1072:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1561_done
    goto rxscan1561_scan
  rxscan1561_loop:
    (rx1560_pos) = rx1560_cur."from"()
    inc rx1560_pos
    rx1560_cur."!cursor_from"(rx1560_pos)
    ge rx1560_pos, rx1560_eos, rxscan1561_done
  rxscan1561_scan:
    set_addr $I10, rxscan1561_loop
    rx1560_cur."!mark_push"(0, rx1560_pos, $I10)
  rxscan1561_done:
.annotate 'line', 733
  # rx subrule "package_declarator" subtype=capture negate=
    rx1560_cur."!cursor_pos"(rx1560_pos)
    $P10 = rx1560_cur."package_declarator"()
    unless $P10, rx1560_fail
    rx1560_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1560_pos = $P10."pos"()
  # rx pass
    rx1560_cur."!cursor_pass"(rx1560_pos, "term:sym<package_declarator>")
    if_null rx1560_debug, debug_1073
    rx1560_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1560_pos)
  debug_1073:
    .return (rx1560_cur)
  rx1560_restart:
.annotate 'line', 469
    if_null rx1560_debug, debug_1074
    rx1560_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1074:
  rx1560_fail:
    (rx1560_rep, rx1560_pos, $I10, $P10) = rx1560_cur."!mark_fail"(0)
    lt rx1560_pos, -1, rx1560_done
    eq rx1560_pos, -1, rx1560_fail
    jump $I10
  rx1560_done:
    rx1560_cur."!cursor_fail"()
    if_null rx1560_debug, debug_1075
    rx1560_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1075:
    .return (rx1560_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("147_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("148_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1564_tgt
    .local int rx1564_pos
    .local int rx1564_off
    .local int rx1564_eos
    .local int rx1564_rep
    .local pmc rx1564_cur
    .local pmc rx1564_debug
    (rx1564_cur, rx1564_pos, rx1564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1564_cur
    .local pmc match
    .lex "$/", match
    length rx1564_eos, rx1564_tgt
    gt rx1564_pos, rx1564_eos, rx1564_done
    set rx1564_off, 0
    lt rx1564_pos, 2, rx1564_start
    sub rx1564_off, rx1564_pos, 1
    substr rx1564_tgt, rx1564_tgt, rx1564_off
  rx1564_start:
    eq $I10, 1, rx1564_restart
    if_null rx1564_debug, debug_1076
    rx1564_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1076:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1564_pos) = rx1564_cur."from"()
    inc rx1564_pos
    rx1564_cur."!cursor_from"(rx1564_pos)
    ge rx1564_pos, rx1564_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1564_cur."!mark_push"(0, rx1564_pos, $I10)
  rxscan1565_done:
.annotate 'line', 734
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1564_cur."!cursor_pos"(rx1564_pos)
    $P10 = rx1564_cur."scope_declarator"()
    unless $P10, rx1564_fail
    rx1564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1564_pos = $P10."pos"()
  # rx pass
    rx1564_cur."!cursor_pass"(rx1564_pos, "term:sym<scope_declarator>")
    if_null rx1564_debug, debug_1077
    rx1564_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1564_pos)
  debug_1077:
    .return (rx1564_cur)
  rx1564_restart:
.annotate 'line', 469
    if_null rx1564_debug, debug_1078
    rx1564_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1078:
  rx1564_fail:
    (rx1564_rep, rx1564_pos, $I10, $P10) = rx1564_cur."!mark_fail"(0)
    lt rx1564_pos, -1, rx1564_done
    eq rx1564_pos, -1, rx1564_fail
    jump $I10
  rx1564_done:
    rx1564_cur."!cursor_fail"()
    if_null rx1564_debug, debug_1079
    rx1564_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1079:
    .return (rx1564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("149_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("150_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1568_tgt
    .local int rx1568_pos
    .local int rx1568_off
    .local int rx1568_eos
    .local int rx1568_rep
    .local pmc rx1568_cur
    .local pmc rx1568_debug
    (rx1568_cur, rx1568_pos, rx1568_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1568_cur
    .local pmc match
    .lex "$/", match
    length rx1568_eos, rx1568_tgt
    gt rx1568_pos, rx1568_eos, rx1568_done
    set rx1568_off, 0
    lt rx1568_pos, 2, rx1568_start
    sub rx1568_off, rx1568_pos, 1
    substr rx1568_tgt, rx1568_tgt, rx1568_off
  rx1568_start:
    eq $I10, 1, rx1568_restart
    if_null rx1568_debug, debug_1080
    rx1568_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1080:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1569_done
    goto rxscan1569_scan
  rxscan1569_loop:
    (rx1568_pos) = rx1568_cur."from"()
    inc rx1568_pos
    rx1568_cur."!cursor_from"(rx1568_pos)
    ge rx1568_pos, rx1568_eos, rxscan1569_done
  rxscan1569_scan:
    set_addr $I10, rxscan1569_loop
    rx1568_cur."!mark_push"(0, rx1568_pos, $I10)
  rxscan1569_done:
.annotate 'line', 735
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1568_cur."!cursor_pos"(rx1568_pos)
    $P10 = rx1568_cur."routine_declarator"()
    unless $P10, rx1568_fail
    rx1568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1568_pos = $P10."pos"()
  # rx pass
    rx1568_cur."!cursor_pass"(rx1568_pos, "term:sym<routine_declarator>")
    if_null rx1568_debug, debug_1081
    rx1568_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1568_pos)
  debug_1081:
    .return (rx1568_cur)
  rx1568_restart:
.annotate 'line', 469
    if_null rx1568_debug, debug_1082
    rx1568_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1082:
  rx1568_fail:
    (rx1568_rep, rx1568_pos, $I10, $P10) = rx1568_cur."!mark_fail"(0)
    lt rx1568_pos, -1, rx1568_done
    eq rx1568_pos, -1, rx1568_fail
    jump $I10
  rx1568_done:
    rx1568_cur."!cursor_fail"()
    if_null rx1568_debug, debug_1083
    rx1568_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1083:
    .return (rx1568_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("151_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("152_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1580 = "154_1321350766.1143" 
    capture_lex $P1580
    .const 'Sub' $P1575 = "153_1321350766.1143" 
    capture_lex $P1575
    .local string rx1572_tgt
    .local int rx1572_pos
    .local int rx1572_off
    .local int rx1572_eos
    .local int rx1572_rep
    .local pmc rx1572_cur
    .local pmc rx1572_debug
    (rx1572_cur, rx1572_pos, rx1572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1572_cur
    .local pmc match
    .lex "$/", match
    length rx1572_eos, rx1572_tgt
    gt rx1572_pos, rx1572_eos, rx1572_done
    set rx1572_off, 0
    lt rx1572_pos, 2, rx1572_start
    sub rx1572_off, rx1572_pos, 1
    substr rx1572_tgt, rx1572_tgt, rx1572_off
  rx1572_start:
    eq $I10, 1, rx1572_restart
    if_null rx1572_debug, debug_1084
    rx1572_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1084:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1573_done
    goto rxscan1573_scan
  rxscan1573_loop:
    (rx1572_pos) = rx1572_cur."from"()
    inc rx1572_pos
    rx1572_cur."!cursor_from"(rx1572_pos)
    ge rx1572_pos, rx1572_eos, rxscan1573_done
  rxscan1573_scan:
    set_addr $I10, rxscan1573_loop
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  rxscan1573_done:
.annotate 'line', 737
  # rx subrule "before" subtype=zerowidth negate=
    rx1572_cur."!cursor_pos"(rx1572_pos)
    .const 'Sub' $P1575 = "153_1321350766.1143" 
    capture_lex $P1575
    $P10 = rx1572_cur."before"($P1575)
    unless $P10, rx1572_fail
.annotate 'line', 738
  # rx subrule "before" subtype=zerowidth negate=1
    rx1572_cur."!cursor_pos"(rx1572_pos)
    .const 'Sub' $P1580 = "154_1321350766.1143" 
    capture_lex $P1580
    $P10 = rx1572_cur."before"($P1580)
    if $P10, rx1572_fail
.annotate 'line', 739
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1572_cur."!cursor_pos"(rx1572_pos)
    $P10 = rx1572_cur."multi_declarator"()
    unless $P10, rx1572_fail
    rx1572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1572_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx1572_cur."!cursor_pass"(rx1572_pos, "term:sym<multi_declarator>")
    if_null rx1572_debug, debug_1093
    rx1572_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1572_pos)
  debug_1093:
    .return (rx1572_cur)
  rx1572_restart:
.annotate 'line', 469
    if_null rx1572_debug, debug_1094
    rx1572_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1094:
  rx1572_fail:
    (rx1572_rep, rx1572_pos, $I10, $P10) = rx1572_cur."!mark_fail"(0)
    lt rx1572_pos, -1, rx1572_done
    eq rx1572_pos, -1, rx1572_fail
    jump $I10
  rx1572_done:
    rx1572_cur."!cursor_fail"()
    if_null rx1572_debug, debug_1095
    rx1572_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1095:
    .return (rx1572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1574"  :anon :subid("153_1321350766.1143") :method :outer("152_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 737
    .local string rx1576_tgt
    .local int rx1576_pos
    .local int rx1576_off
    .local int rx1576_eos
    .local int rx1576_rep
    .local pmc rx1576_cur
    .local pmc rx1576_debug
    (rx1576_cur, rx1576_pos, rx1576_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1576_cur
    .local pmc match
    .lex "$/", match
    length rx1576_eos, rx1576_tgt
    gt rx1576_pos, rx1576_eos, rx1576_done
    set rx1576_off, 0
    lt rx1576_pos, 2, rx1576_start
    sub rx1576_off, rx1576_pos, 1
    substr rx1576_tgt, rx1576_tgt, rx1576_off
  rx1576_start:
    eq $I10, 1, rx1576_restart
    if_null rx1576_debug, debug_1085
    rx1576_cur."!cursor_debug"("START", "")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1577_done
    goto rxscan1577_scan
  rxscan1577_loop:
    (rx1576_pos) = rx1576_cur."from"()
    inc rx1576_pos
    rx1576_cur."!cursor_from"(rx1576_pos)
    ge rx1576_pos, rx1576_eos, rxscan1577_done
  rxscan1577_scan:
    set_addr $I10, rxscan1577_loop
    rx1576_cur."!mark_push"(0, rx1576_pos, $I10)
  rxscan1577_done:
  alt1578_0:
    set_addr $I10, alt1578_1
    rx1576_cur."!mark_push"(0, rx1576_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1576_pos, 5
    gt $I11, rx1576_eos, rx1576_fail
    sub $I11, rx1576_pos, rx1576_off
    substr $S10, rx1576_tgt, $I11, 5
    ne $S10, "multi", rx1576_fail
    add rx1576_pos, 5
    goto alt1578_end
  alt1578_1:
    set_addr $I10, alt1578_2
    rx1576_cur."!mark_push"(0, rx1576_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1576_pos, 5
    gt $I11, rx1576_eos, rx1576_fail
    sub $I11, rx1576_pos, rx1576_off
    substr $S10, rx1576_tgt, $I11, 5
    ne $S10, "proto", rx1576_fail
    add rx1576_pos, 5
    goto alt1578_end
  alt1578_2:
  # rx literal  "only"
    add $I11, rx1576_pos, 4
    gt $I11, rx1576_eos, rx1576_fail
    sub $I11, rx1576_pos, rx1576_off
    substr $S10, rx1576_tgt, $I11, 4
    ne $S10, "only", rx1576_fail
    add rx1576_pos, 4
  alt1578_end:
  # rx pass
    rx1576_cur."!cursor_pass"(rx1576_pos, "")
    if_null rx1576_debug, debug_1086
    rx1576_cur."!cursor_debug"("PASS", "", " at pos=", rx1576_pos)
  debug_1086:
    .return (rx1576_cur)
  rx1576_restart:
    if_null rx1576_debug, debug_1087
    rx1576_cur."!cursor_debug"("NEXT", "")
  debug_1087:
  rx1576_fail:
    (rx1576_rep, rx1576_pos, $I10, $P10) = rx1576_cur."!mark_fail"(0)
    lt rx1576_pos, -1, rx1576_done
    eq rx1576_pos, -1, rx1576_fail
    jump $I10
  rx1576_done:
    rx1576_cur."!cursor_fail"()
    if_null rx1576_debug, debug_1088
    rx1576_cur."!cursor_debug"("FAIL", "")
  debug_1088:
    .return (rx1576_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1579"  :anon :subid("154_1321350766.1143") :method :outer("152_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 738
    .local string rx1581_tgt
    .local int rx1581_pos
    .local int rx1581_off
    .local int rx1581_eos
    .local int rx1581_rep
    .local pmc rx1581_cur
    .local pmc rx1581_debug
    (rx1581_cur, rx1581_pos, rx1581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1581_cur
    .local pmc match
    .lex "$/", match
    length rx1581_eos, rx1581_tgt
    gt rx1581_pos, rx1581_eos, rx1581_done
    set rx1581_off, 0
    lt rx1581_pos, 2, rx1581_start
    sub rx1581_off, rx1581_pos, 1
    substr rx1581_tgt, rx1581_tgt, rx1581_off
  rx1581_start:
    eq $I10, 1, rx1581_restart
    if_null rx1581_debug, debug_1089
    rx1581_cur."!cursor_debug"("START", "")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1581_pos) = rx1581_cur."from"()
    inc rx1581_pos
    rx1581_cur."!cursor_from"(rx1581_pos)
    ge rx1581_pos, rx1581_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  rxscan1582_done:
  # rx literal  "proto"
    add $I11, rx1581_pos, 5
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    substr $S10, rx1581_tgt, $I11, 5
    ne $S10, "proto", rx1581_fail
    add rx1581_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1581_cur."!cursor_pos"(rx1581_pos)
    $P10 = rx1581_cur."ws"()
    unless $P10, rx1581_fail
    rx1581_pos = $P10."pos"()
  alt1583_0:
    set_addr $I10, alt1583_1
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1581_pos, 5
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    substr $S10, rx1581_tgt, $I11, 5
    ne $S10, "regex", rx1581_fail
    add rx1581_pos, 5
    goto alt1583_end
  alt1583_1:
    set_addr $I10, alt1583_2
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  # rx literal  "token"
    add $I11, rx1581_pos, 5
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    substr $S10, rx1581_tgt, $I11, 5
    ne $S10, "token", rx1581_fail
    add rx1581_pos, 5
    goto alt1583_end
  alt1583_2:
  # rx literal  "rule"
    add $I11, rx1581_pos, 4
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    substr $S10, rx1581_tgt, $I11, 4
    ne $S10, "rule", rx1581_fail
    add rx1581_pos, 4
  alt1583_end:
  # rx pass
    rx1581_cur."!cursor_pass"(rx1581_pos, "")
    if_null rx1581_debug, debug_1090
    rx1581_cur."!cursor_debug"("PASS", "", " at pos=", rx1581_pos)
  debug_1090:
    .return (rx1581_cur)
  rx1581_restart:
    if_null rx1581_debug, debug_1091
    rx1581_cur."!cursor_debug"("NEXT", "")
  debug_1091:
  rx1581_fail:
    (rx1581_rep, rx1581_pos, $I10, $P10) = rx1581_cur."!mark_fail"(0)
    lt rx1581_pos, -1, rx1581_done
    eq rx1581_pos, -1, rx1581_fail
    jump $I10
  rx1581_done:
    rx1581_cur."!cursor_fail"()
    if_null rx1581_debug, debug_1092
    rx1581_cur."!cursor_debug"("FAIL", "")
  debug_1092:
    .return (rx1581_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("155_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("156_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1586_tgt
    .local int rx1586_pos
    .local int rx1586_off
    .local int rx1586_eos
    .local int rx1586_rep
    .local pmc rx1586_cur
    .local pmc rx1586_debug
    (rx1586_cur, rx1586_pos, rx1586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1586_cur
    .local pmc match
    .lex "$/", match
    length rx1586_eos, rx1586_tgt
    gt rx1586_pos, rx1586_eos, rx1586_done
    set rx1586_off, 0
    lt rx1586_pos, 2, rx1586_start
    sub rx1586_off, rx1586_pos, 1
    substr rx1586_tgt, rx1586_tgt, rx1586_off
  rx1586_start:
    eq $I10, 1, rx1586_restart
    if_null rx1586_debug, debug_1096
    rx1586_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1587_done
    goto rxscan1587_scan
  rxscan1587_loop:
    (rx1586_pos) = rx1586_cur."from"()
    inc rx1586_pos
    rx1586_cur."!cursor_from"(rx1586_pos)
    ge rx1586_pos, rx1586_eos, rxscan1587_done
  rxscan1587_scan:
    set_addr $I10, rxscan1587_loop
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  rxscan1587_done:
.annotate 'line', 741
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1586_cur."!cursor_pos"(rx1586_pos)
    $P10 = rx1586_cur."regex_declarator"()
    unless $P10, rx1586_fail
    rx1586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1586_pos = $P10."pos"()
  # rx pass
    rx1586_cur."!cursor_pass"(rx1586_pos, "term:sym<regex_declarator>")
    if_null rx1586_debug, debug_1097
    rx1586_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1586_pos)
  debug_1097:
    .return (rx1586_cur)
  rx1586_restart:
.annotate 'line', 469
    if_null rx1586_debug, debug_1098
    rx1586_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1098:
  rx1586_fail:
    (rx1586_rep, rx1586_pos, $I10, $P10) = rx1586_cur."!mark_fail"(0)
    lt rx1586_pos, -1, rx1586_done
    eq rx1586_pos, -1, rx1586_fail
    jump $I10
  rx1586_done:
    rx1586_cur."!cursor_fail"()
    if_null rx1586_debug, debug_1099
    rx1586_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1099:
    .return (rx1586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("157_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("158_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1100
    rx1590_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1591_done
    goto rxscan1591_scan
  rxscan1591_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1591_done
  rxscan1591_scan:
    set_addr $I10, rxscan1591_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1591_done:
.annotate 'line', 742
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."statement_prefix"()
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "term:sym<statement_prefix>")
    if_null rx1590_debug, debug_1101
    rx1590_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1590_pos)
  debug_1101:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 469
    if_null rx1590_debug, debug_1102
    rx1590_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1102:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1103
    rx1590_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1103:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("159_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("160_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1594_tgt
    .local int rx1594_pos
    .local int rx1594_off
    .local int rx1594_eos
    .local int rx1594_rep
    .local pmc rx1594_cur
    .local pmc rx1594_debug
    (rx1594_cur, rx1594_pos, rx1594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1594_cur
    .local pmc match
    .lex "$/", match
    length rx1594_eos, rx1594_tgt
    gt rx1594_pos, rx1594_eos, rx1594_done
    set rx1594_off, 0
    lt rx1594_pos, 2, rx1594_start
    sub rx1594_off, rx1594_pos, 1
    substr rx1594_tgt, rx1594_tgt, rx1594_off
  rx1594_start:
    eq $I10, 1, rx1594_restart
    if_null rx1594_debug, debug_1104
    rx1594_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1594_pos) = rx1594_cur."from"()
    inc rx1594_pos
    rx1594_cur."!cursor_from"(rx1594_pos)
    ge rx1594_pos, rx1594_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1594_cur."!mark_push"(0, rx1594_pos, $I10)
  rxscan1595_done:
.annotate 'line', 743
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    $P10 = rx1594_cur."lambda"()
    unless $P10, rx1594_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    $P10 = rx1594_cur."pblock"()
    unless $P10, rx1594_fail
    rx1594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1594_pos = $P10."pos"()
  # rx pass
    rx1594_cur."!cursor_pass"(rx1594_pos, "term:sym<lambda>")
    if_null rx1594_debug, debug_1105
    rx1594_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1594_pos)
  debug_1105:
    .return (rx1594_cur)
  rx1594_restart:
.annotate 'line', 469
    if_null rx1594_debug, debug_1106
    rx1594_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1106:
  rx1594_fail:
    (rx1594_rep, rx1594_pos, $I10, $P10) = rx1594_cur."!mark_fail"(0)
    lt rx1594_pos, -1, rx1594_done
    eq rx1594_pos, -1, rx1594_fail
    jump $I10
  rx1594_done:
    rx1594_cur."!cursor_fail"()
    if_null rx1594_debug, debug_1107
    rx1594_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1107:
    .return (rx1594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("161_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("162_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1108
    rx1598_cur."!cursor_debug"("START", "fatarrow")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1599_done
    goto rxscan1599_scan
  rxscan1599_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1599_done
  rxscan1599_scan:
    set_addr $I10, rxscan1599_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1599_done:
.annotate 'line', 746
  # rx subrule "identifier" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."identifier"()
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1598_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1598_pos, rx1598_off
    set rx1598_rep, 0
    sub $I12, rx1598_eos, rx1598_pos
  rxenumcharlistq1600_loop:
    le $I12, 0, rxenumcharlistq1600_done
    substr $S10, rx1598_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1600_done
    inc rx1598_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1600_loop
  rxenumcharlistq1600_done:
    add rx1598_pos, rx1598_pos, rx1598_rep
  # rx literal  "=>"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "=>", rx1598_fail
    add rx1598_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."ws"()
    unless $P10, rx1598_fail
    rx1598_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."EXPR"("i=")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1598_pos = $P10."pos"()
.annotate 'line', 745
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "fatarrow")
    if_null rx1598_debug, debug_1109
    rx1598_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1598_pos)
  debug_1109:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 469
    if_null rx1598_debug, debug_1110
    rx1598_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1110:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1111
    rx1598_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1111:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("163_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("164_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1603_tgt
    .local int rx1603_pos
    .local int rx1603_off
    .local int rx1603_eos
    .local int rx1603_rep
    .local pmc rx1603_cur
    .local pmc rx1603_debug
    (rx1603_cur, rx1603_pos, rx1603_tgt, $I10) = self."!cursor_start"()
    rx1603_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1603_cur
    .local pmc match
    .lex "$/", match
    length rx1603_eos, rx1603_tgt
    gt rx1603_pos, rx1603_eos, rx1603_done
    set rx1603_off, 0
    lt rx1603_pos, 2, rx1603_start
    sub rx1603_off, rx1603_pos, 1
    substr rx1603_tgt, rx1603_tgt, rx1603_off
  rx1603_start:
    eq $I10, 1, rx1603_restart
    if_null rx1603_debug, debug_1112
    rx1603_cur."!cursor_debug"("START", "colonpair")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1604_done
    goto rxscan1604_scan
  rxscan1604_loop:
    (rx1603_pos) = rx1603_cur."from"()
    inc rx1603_pos
    rx1603_cur."!cursor_from"(rx1603_pos)
    ge rx1603_pos, rx1603_eos, rxscan1604_done
  rxscan1604_scan:
    set_addr $I10, rxscan1604_loop
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxscan1604_done:
.annotate 'line', 750
  # rx literal  ":"
    add $I11, rx1603_pos, 1
    gt $I11, rx1603_eos, rx1603_fail
    sub $I11, rx1603_pos, rx1603_off
    ord $I11, rx1603_tgt, $I11
    ne $I11, 58, rx1603_fail
    add rx1603_pos, 1
  alt1605_0:
.annotate 'line', 751
    set_addr $I10, alt1605_1
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
.annotate 'line', 752
  # rx subcapture "not"
    set_addr $I10, rxcap_1606_fail
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  # rx literal  "!"
    add $I11, rx1603_pos, 1
    gt $I11, rx1603_eos, rx1603_fail
    sub $I11, rx1603_pos, rx1603_off
    ord $I11, rx1603_tgt, $I11
    ne $I11, 33, rx1603_fail
    add rx1603_pos, 1
    set_addr $I10, rxcap_1606_fail
    ($I12, $I11) = rx1603_cur."!mark_peek"($I10)
    rx1603_cur."!cursor_pos"($I11)
    ($P10) = rx1603_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1603_pos, "")
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1606_done
  rxcap_1606_fail:
    goto rx1603_fail
  rxcap_1606_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."identifier"()
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1603_pos = $P10."pos"()
    goto alt1605_end
  alt1605_1:
    set_addr $I10, alt1605_2
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
.annotate 'line', 753
  # rx subrule "identifier" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."identifier"()
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1603_pos = $P10."pos"()
  # rx rxquantr1607 ** 0..1
    set_addr $I10, rxquantr1607_done
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxquantr1607_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."circumfix"()
    unless $P10, rx1603_fail
    goto rxsubrule1608_pass
  rxsubrule1608_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1603_fail
  rxsubrule1608_pass:
    set_addr $I10, rxsubrule1608_back
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1603_pos = $P10."pos"()
    set_addr $I10, rxquantr1607_done
    (rx1603_rep) = rx1603_cur."!mark_commit"($I10)
  rxquantr1607_done:
    goto alt1605_end
  alt1605_2:
.annotate 'line', 754
  # rx subrule "circumfix" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."circumfix"()
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1603_pos = $P10."pos"()
  alt1605_end:
.annotate 'line', 749
  # rx pass
    rx1603_cur."!cursor_pass"(rx1603_pos, "colonpair")
    if_null rx1603_debug, debug_1113
    rx1603_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1603_pos)
  debug_1113:
    .return (rx1603_cur)
  rx1603_restart:
.annotate 'line', 469
    if_null rx1603_debug, debug_1114
    rx1603_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1114:
  rx1603_fail:
    (rx1603_rep, rx1603_pos, $I10, $P10) = rx1603_cur."!mark_fail"(0)
    lt rx1603_pos, -1, rx1603_done
    eq rx1603_pos, -1, rx1603_fail
    jump $I10
  rx1603_done:
    rx1603_cur."!cursor_fail"()
    if_null rx1603_debug, debug_1115
    rx1603_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1115:
    .return (rx1603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("165_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("circumfix", ":")
    $P104 = self."!PREFIX__!subrule"("identifier", ":")
    $P105 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P106, "ResizablePMCArray"
    push $P106, $P103
    push $P106, $P104
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("166_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    rx1611_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1116
    rx1611_cur."!cursor_debug"("START", "variable")
  debug_1116:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1612_done
    goto rxscan1612_scan
  rxscan1612_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1612_done
  rxscan1612_scan:
    set_addr $I10, rxscan1612_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1612_done:
  alt1613_0:
.annotate 'line', 758
    set_addr $I10, alt1613_1
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
.annotate 'line', 759
  # rx subrule "sigil" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."sigil"()
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1611_pos = $P10."pos"()
  # rx rxquantr1614 ** 0..1
    set_addr $I10, rxquantr1614_done
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxquantr1614_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."twigil"()
    unless $P10, rx1611_fail
    goto rxsubrule1615_pass
  rxsubrule1615_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1611_fail
  rxsubrule1615_pass:
    set_addr $I10, rxsubrule1615_back
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1611_pos = $P10."pos"()
    set_addr $I10, rxquantr1614_done
    (rx1611_rep) = rx1611_cur."!mark_commit"($I10)
  rxquantr1614_done:
  # rx subrule "name" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."name"()
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1611_pos = $P10."pos"()
    goto alt1613_end
  alt1613_1:
    set_addr $I10, alt1613_2
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
.annotate 'line', 760
  # rx subrule "sigil" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."sigil"()
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1611_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1611_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."postcircumfix"()
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1611_pos = $P10."pos"()
    goto alt1613_end
  alt1613_2:
.annotate 'line', 761
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  "$"
    add $I11, rx1611_pos, 1
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    ord $I11, rx1611_tgt, $I11
    ne $I11, 36, rx1611_fail
    add rx1611_pos, 1
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1617_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1611_pos, rx1611_eos, rx1611_fail
    sub $I10, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1611_fail
    inc rx1611_pos
    set_addr $I10, rxcap_1617_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1617_done
  rxcap_1617_fail:
    goto rx1611_fail
  rxcap_1617_done:
  alt1613_end:
.annotate 'line', 758
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "variable")
    if_null rx1611_debug, debug_1117
    rx1611_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1611_pos)
  debug_1117:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 469
    if_null rx1611_debug, debug_1118
    rx1611_cur."!cursor_debug"("NEXT", "variable")
  debug_1118:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1119
    rx1611_cur."!cursor_debug"("FAIL", "variable")
  debug_1119:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("167_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, "/"
    push $P105, "_"
    push $P105, "!"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("168_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1620_tgt
    .local int rx1620_pos
    .local int rx1620_off
    .local int rx1620_eos
    .local int rx1620_rep
    .local pmc rx1620_cur
    .local pmc rx1620_debug
    (rx1620_cur, rx1620_pos, rx1620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1620_cur
    .local pmc match
    .lex "$/", match
    length rx1620_eos, rx1620_tgt
    gt rx1620_pos, rx1620_eos, rx1620_done
    set rx1620_off, 0
    lt rx1620_pos, 2, rx1620_start
    sub rx1620_off, rx1620_pos, 1
    substr rx1620_tgt, rx1620_tgt, rx1620_off
  rx1620_start:
    eq $I10, 1, rx1620_restart
    if_null rx1620_debug, debug_1120
    rx1620_cur."!cursor_debug"("START", "sigil")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1620_pos) = rx1620_cur."from"()
    inc rx1620_pos
    rx1620_cur."!cursor_from"(rx1620_pos)
    ge rx1620_pos, rx1620_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  rxscan1621_done:
.annotate 'line', 764
  # rx enumcharlist negate=0 
    ge rx1620_pos, rx1620_eos, rx1620_fail
    sub $I10, rx1620_pos, rx1620_off
    substr $S10, rx1620_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1620_fail
    inc rx1620_pos
  # rx pass
    rx1620_cur."!cursor_pass"(rx1620_pos, "sigil")
    if_null rx1620_debug, debug_1121
    rx1620_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1620_pos)
  debug_1121:
    .return (rx1620_cur)
  rx1620_restart:
.annotate 'line', 469
    if_null rx1620_debug, debug_1122
    rx1620_cur."!cursor_debug"("NEXT", "sigil")
  debug_1122:
  rx1620_fail:
    (rx1620_rep, rx1620_pos, $I10, $P10) = rx1620_cur."!mark_fail"(0)
    lt rx1620_pos, -1, rx1620_done
    eq rx1620_pos, -1, rx1620_fail
    jump $I10
  rx1620_done:
    rx1620_cur."!cursor_fail"()
    if_null rx1620_debug, debug_1123
    rx1620_cur."!cursor_debug"("FAIL", "sigil")
  debug_1123:
    .return (rx1620_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("169_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    push $P103, "%"
    push $P103, "&"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("170_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1124
    rx1624_cur."!cursor_debug"("START", "twigil")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1625_done
    goto rxscan1625_scan
  rxscan1625_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1625_done
  rxscan1625_scan:
    set_addr $I10, rxscan1625_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1625_done:
.annotate 'line', 766
  # rx enumcharlist negate=0 
    ge rx1624_pos, rx1624_eos, rx1624_fail
    sub $I10, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1624_fail
    inc rx1624_pos
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "twigil")
    if_null rx1624_debug, debug_1125
    rx1624_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1624_pos)
  debug_1125:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 469
    if_null rx1624_debug, debug_1126
    rx1624_cur."!cursor_debug"("NEXT", "twigil")
  debug_1126:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1127
    rx1624_cur."!cursor_debug"("FAIL", "twigil")
  debug_1127:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("171_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "*"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("172_1321350766.1143")
    .param pmc param_1628
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 768
    .lex "self", param_1628
    $P103 = param_1628."!protoregex"("package_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("173_1321350766.1143")
    .param pmc param_1630
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 768
    .lex "self", param_1630
    $P104 = param_1630."!PREFIX__!protoregex"("package_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("174_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 770
    new $P103, "Undef"
    set $P1632, $P103
    .lex "$*OUTERPACKAGE", $P1632
.annotate 'line', 771
    new $P104, "Undef"
    set $P1633, $P104
    .lex "$*PKGDECL", $P1633
.annotate 'line', 469
    .local string rx1634_tgt
    .local int rx1634_pos
    .local int rx1634_off
    .local int rx1634_eos
    .local int rx1634_rep
    .local pmc rx1634_cur
    .local pmc rx1634_debug
    (rx1634_cur, rx1634_pos, rx1634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1634_cur
    .local pmc match
    .lex "$/", match
    length rx1634_eos, rx1634_tgt
    gt rx1634_pos, rx1634_eos, rx1634_done
    set rx1634_off, 0
    lt rx1634_pos, 2, rx1634_start
    sub rx1634_off, rx1634_pos, 1
    substr rx1634_tgt, rx1634_tgt, rx1634_off
  rx1634_start:
    eq $I10, 1, rx1634_restart
    if_null rx1634_debug, debug_1128
    rx1634_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1634_pos) = rx1634_cur."from"()
    inc rx1634_pos
    rx1634_cur."!cursor_from"(rx1634_pos)
    ge rx1634_pos, rx1634_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  rxscan1635_done:
.annotate 'line', 770
    rx1634_cur."!cursor_pos"(rx1634_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1129
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1130
    die "Contextual $*PACKAGE not found"
  vivify_1130:
  vivify_1129:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 771
    rx1634_cur."!cursor_pos"(rx1634_pos)
    new $P108, "String"
    assign $P108, "module"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 772
  # rx subcapture "sym"
    set_addr $I10, rxcap_1636_fail
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  # rx literal  "module"
    add $I11, rx1634_pos, 6
    gt $I11, rx1634_eos, rx1634_fail
    sub $I11, rx1634_pos, rx1634_off
    substr $S10, rx1634_tgt, $I11, 6
    ne $S10, "module", rx1634_fail
    add rx1634_pos, 6
    set_addr $I10, rxcap_1636_fail
    ($I12, $I11) = rx1634_cur."!mark_peek"($I10)
    rx1634_cur."!cursor_pos"($I11)
    ($P10) = rx1634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1634_pos, "")
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1636_done
  rxcap_1636_fail:
    goto rx1634_fail
  rxcap_1636_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1634_cur."!cursor_pos"(rx1634_pos)
    $P10 = rx1634_cur."package_def"()
    unless $P10, rx1634_fail
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1634_pos = $P10."pos"()
.annotate 'line', 769
  # rx pass
    rx1634_cur."!cursor_pass"(rx1634_pos, "package_declarator:sym<module>")
    if_null rx1634_debug, debug_1131
    rx1634_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1634_pos)
  debug_1131:
    .return (rx1634_cur)
  rx1634_restart:
.annotate 'line', 469
    if_null rx1634_debug, debug_1132
    rx1634_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1132:
  rx1634_fail:
    (rx1634_rep, rx1634_pos, $I10, $P10) = rx1634_cur."!mark_fail"(0)
    lt rx1634_pos, -1, rx1634_done
    eq rx1634_pos, -1, rx1634_fail
    jump $I10
  rx1634_done:
    rx1634_cur."!cursor_fail"()
    if_null rx1634_debug, debug_1133
    rx1634_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1133:
    .return (rx1634_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("175_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("package_def", "module")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("176_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 775
    new $P103, "Undef"
    set $P1639, $P103
    .lex "$*OUTERPACKAGE", $P1639
.annotate 'line', 776
    new $P104, "Undef"
    set $P1640, $P104
    .lex "$*PKGDECL", $P1640
.annotate 'line', 469
    .local string rx1641_tgt
    .local int rx1641_pos
    .local int rx1641_off
    .local int rx1641_eos
    .local int rx1641_rep
    .local pmc rx1641_cur
    .local pmc rx1641_debug
    (rx1641_cur, rx1641_pos, rx1641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1641_cur
    .local pmc match
    .lex "$/", match
    length rx1641_eos, rx1641_tgt
    gt rx1641_pos, rx1641_eos, rx1641_done
    set rx1641_off, 0
    lt rx1641_pos, 2, rx1641_start
    sub rx1641_off, rx1641_pos, 1
    substr rx1641_tgt, rx1641_tgt, rx1641_off
  rx1641_start:
    eq $I10, 1, rx1641_restart
    if_null rx1641_debug, debug_1134
    rx1641_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1641_pos) = rx1641_cur."from"()
    inc rx1641_pos
    rx1641_cur."!cursor_from"(rx1641_pos)
    ge rx1641_pos, rx1641_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  rxscan1642_done:
.annotate 'line', 775
    rx1641_cur."!cursor_pos"(rx1641_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1135
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1136
    die "Contextual $*PACKAGE not found"
  vivify_1136:
  vivify_1135:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 776
    rx1641_cur."!cursor_pos"(rx1641_pos)
    new $P108, "String"
    assign $P108, "knowhow"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 777
  # rx subcapture "sym"
    set_addr $I10, rxcap_1643_fail
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1641_pos, 7
    gt $I11, rx1641_eos, rx1641_fail
    sub $I11, rx1641_pos, rx1641_off
    substr $S10, rx1641_tgt, $I11, 7
    ne $S10, "knowhow", rx1641_fail
    add rx1641_pos, 7
    set_addr $I10, rxcap_1643_fail
    ($I12, $I11) = rx1641_cur."!mark_peek"($I10)
    rx1641_cur."!cursor_pos"($I11)
    ($P10) = rx1641_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1641_pos, "")
    rx1641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1643_done
  rxcap_1643_fail:
    goto rx1641_fail
  rxcap_1643_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1641_cur."!cursor_pos"(rx1641_pos)
    $P10 = rx1641_cur."package_def"()
    unless $P10, rx1641_fail
    rx1641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1641_pos = $P10."pos"()
.annotate 'line', 774
  # rx pass
    rx1641_cur."!cursor_pass"(rx1641_pos, "package_declarator:sym<knowhow>")
    if_null rx1641_debug, debug_1137
    rx1641_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1641_pos)
  debug_1137:
    .return (rx1641_cur)
  rx1641_restart:
.annotate 'line', 469
    if_null rx1641_debug, debug_1138
    rx1641_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1138:
  rx1641_fail:
    (rx1641_rep, rx1641_pos, $I10, $P10) = rx1641_cur."!mark_fail"(0)
    lt rx1641_pos, -1, rx1641_done
    eq rx1641_pos, -1, rx1641_fail
    jump $I10
  rx1641_done:
    rx1641_cur."!cursor_fail"()
    if_null rx1641_debug, debug_1139
    rx1641_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1139:
    .return (rx1641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("177_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("178_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 780
    new $P103, "Undef"
    set $P1646, $P103
    .lex "$*OUTERPACKAGE", $P1646
.annotate 'line', 781
    new $P104, "Undef"
    set $P1647, $P104
    .lex "$*PKGDECL", $P1647
.annotate 'line', 469
    .local string rx1648_tgt
    .local int rx1648_pos
    .local int rx1648_off
    .local int rx1648_eos
    .local int rx1648_rep
    .local pmc rx1648_cur
    .local pmc rx1648_debug
    (rx1648_cur, rx1648_pos, rx1648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1648_cur
    .local pmc match
    .lex "$/", match
    length rx1648_eos, rx1648_tgt
    gt rx1648_pos, rx1648_eos, rx1648_done
    set rx1648_off, 0
    lt rx1648_pos, 2, rx1648_start
    sub rx1648_off, rx1648_pos, 1
    substr rx1648_tgt, rx1648_tgt, rx1648_off
  rx1648_start:
    eq $I10, 1, rx1648_restart
    if_null rx1648_debug, debug_1140
    rx1648_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1648_pos) = rx1648_cur."from"()
    inc rx1648_pos
    rx1648_cur."!cursor_from"(rx1648_pos)
    ge rx1648_pos, rx1648_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
  rxscan1649_done:
.annotate 'line', 780
    rx1648_cur."!cursor_pos"(rx1648_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1141
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1142
    die "Contextual $*PACKAGE not found"
  vivify_1142:
  vivify_1141:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 781
    rx1648_cur."!cursor_pos"(rx1648_pos)
    new $P108, "String"
    assign $P108, "class"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 782
  # rx subcapture "sym"
    set_addr $I10, rxcap_1650_fail
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
  # rx literal  "class"
    add $I11, rx1648_pos, 5
    gt $I11, rx1648_eos, rx1648_fail
    sub $I11, rx1648_pos, rx1648_off
    substr $S10, rx1648_tgt, $I11, 5
    ne $S10, "class", rx1648_fail
    add rx1648_pos, 5
    set_addr $I10, rxcap_1650_fail
    ($I12, $I11) = rx1648_cur."!mark_peek"($I10)
    rx1648_cur."!cursor_pos"($I11)
    ($P10) = rx1648_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1648_pos, "")
    rx1648_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1650_done
  rxcap_1650_fail:
    goto rx1648_fail
  rxcap_1650_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1648_cur."!cursor_pos"(rx1648_pos)
    $P10 = rx1648_cur."package_def"()
    unless $P10, rx1648_fail
    rx1648_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1648_pos = $P10."pos"()
.annotate 'line', 779
  # rx pass
    rx1648_cur."!cursor_pass"(rx1648_pos, "package_declarator:sym<class>")
    if_null rx1648_debug, debug_1143
    rx1648_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1648_pos)
  debug_1143:
    .return (rx1648_cur)
  rx1648_restart:
.annotate 'line', 469
    if_null rx1648_debug, debug_1144
    rx1648_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1144:
  rx1648_fail:
    (rx1648_rep, rx1648_pos, $I10, $P10) = rx1648_cur."!mark_fail"(0)
    lt rx1648_pos, -1, rx1648_done
    eq rx1648_pos, -1, rx1648_fail
    jump $I10
  rx1648_done:
    rx1648_cur."!cursor_fail"()
    if_null rx1648_debug, debug_1145
    rx1648_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1145:
    .return (rx1648_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("179_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("package_def", "class")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("180_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 785
    new $P103, "Undef"
    set $P1653, $P103
    .lex "$*OUTERPACKAGE", $P1653
.annotate 'line', 786
    new $P104, "Undef"
    set $P1654, $P104
    .lex "$*PKGDECL", $P1654
.annotate 'line', 469
    .local string rx1655_tgt
    .local int rx1655_pos
    .local int rx1655_off
    .local int rx1655_eos
    .local int rx1655_rep
    .local pmc rx1655_cur
    .local pmc rx1655_debug
    (rx1655_cur, rx1655_pos, rx1655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1655_cur
    .local pmc match
    .lex "$/", match
    length rx1655_eos, rx1655_tgt
    gt rx1655_pos, rx1655_eos, rx1655_done
    set rx1655_off, 0
    lt rx1655_pos, 2, rx1655_start
    sub rx1655_off, rx1655_pos, 1
    substr rx1655_tgt, rx1655_tgt, rx1655_off
  rx1655_start:
    eq $I10, 1, rx1655_restart
    if_null rx1655_debug, debug_1146
    rx1655_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1655_pos) = rx1655_cur."from"()
    inc rx1655_pos
    rx1655_cur."!cursor_from"(rx1655_pos)
    ge rx1655_pos, rx1655_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1655_cur."!mark_push"(0, rx1655_pos, $I10)
  rxscan1656_done:
.annotate 'line', 785
    rx1655_cur."!cursor_pos"(rx1655_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1147
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1148
    die "Contextual $*PACKAGE not found"
  vivify_1148:
  vivify_1147:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 786
    rx1655_cur."!cursor_pos"(rx1655_pos)
    new $P108, "String"
    assign $P108, "grammar"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 787
  # rx subcapture "sym"
    set_addr $I10, rxcap_1657_fail
    rx1655_cur."!mark_push"(0, rx1655_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1655_pos, 7
    gt $I11, rx1655_eos, rx1655_fail
    sub $I11, rx1655_pos, rx1655_off
    substr $S10, rx1655_tgt, $I11, 7
    ne $S10, "grammar", rx1655_fail
    add rx1655_pos, 7
    set_addr $I10, rxcap_1657_fail
    ($I12, $I11) = rx1655_cur."!mark_peek"($I10)
    rx1655_cur."!cursor_pos"($I11)
    ($P10) = rx1655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1655_pos, "")
    rx1655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1657_done
  rxcap_1657_fail:
    goto rx1655_fail
  rxcap_1657_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1655_cur."!cursor_pos"(rx1655_pos)
    $P10 = rx1655_cur."package_def"()
    unless $P10, rx1655_fail
    rx1655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1655_pos = $P10."pos"()
.annotate 'line', 784
  # rx pass
    rx1655_cur."!cursor_pass"(rx1655_pos, "package_declarator:sym<grammar>")
    if_null rx1655_debug, debug_1149
    rx1655_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1655_pos)
  debug_1149:
    .return (rx1655_cur)
  rx1655_restart:
.annotate 'line', 469
    if_null rx1655_debug, debug_1150
    rx1655_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1150:
  rx1655_fail:
    (rx1655_rep, rx1655_pos, $I10, $P10) = rx1655_cur."!mark_fail"(0)
    lt rx1655_pos, -1, rx1655_done
    eq rx1655_pos, -1, rx1655_fail
    jump $I10
  rx1655_done:
    rx1655_cur."!cursor_fail"()
    if_null rx1655_debug, debug_1151
    rx1655_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1151:
    .return (rx1655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("181_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("182_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 790
    new $P103, "Undef"
    set $P1660, $P103
    .lex "$*OUTERPACKAGE", $P1660
.annotate 'line', 791
    new $P104, "Undef"
    set $P1661, $P104
    .lex "$*PKGDECL", $P1661
.annotate 'line', 469
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1152
    rx1662_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1663_done
    goto rxscan1663_scan
  rxscan1663_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1663_done
  rxscan1663_scan:
    set_addr $I10, rxscan1663_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1663_done:
.annotate 'line', 790
    rx1662_cur."!cursor_pos"(rx1662_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1153
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1154
    die "Contextual $*PACKAGE not found"
  vivify_1154:
  vivify_1153:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 791
    rx1662_cur."!cursor_pos"(rx1662_pos)
    new $P108, "String"
    assign $P108, "role"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 792
  # rx subcapture "sym"
    set_addr $I10, rxcap_1664_fail
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  # rx literal  "role"
    add $I11, rx1662_pos, 4
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 4
    ne $S10, "role", rx1662_fail
    add rx1662_pos, 4
    set_addr $I10, rxcap_1664_fail
    ($I12, $I11) = rx1662_cur."!mark_peek"($I10)
    rx1662_cur."!cursor_pos"($I11)
    ($P10) = rx1662_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1662_pos, "")
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1664_done
  rxcap_1664_fail:
    goto rx1662_fail
  rxcap_1664_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."package_def"()
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1662_pos = $P10."pos"()
.annotate 'line', 789
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "package_declarator:sym<role>")
    if_null rx1662_debug, debug_1155
    rx1662_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1662_pos)
  debug_1155:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 469
    if_null rx1662_debug, debug_1156
    rx1662_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1156:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1157
    rx1662_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1157:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("183_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("package_def", "role")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("184_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 795
    new $P103, "Undef"
    set $P1667, $P103
    .lex "$*OUTERPACKAGE", $P1667
.annotate 'line', 796
    new $P104, "Undef"
    set $P1668, $P104
    .lex "$*PKGDECL", $P1668
.annotate 'line', 469
    .local string rx1669_tgt
    .local int rx1669_pos
    .local int rx1669_off
    .local int rx1669_eos
    .local int rx1669_rep
    .local pmc rx1669_cur
    .local pmc rx1669_debug
    (rx1669_cur, rx1669_pos, rx1669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1669_cur
    .local pmc match
    .lex "$/", match
    length rx1669_eos, rx1669_tgt
    gt rx1669_pos, rx1669_eos, rx1669_done
    set rx1669_off, 0
    lt rx1669_pos, 2, rx1669_start
    sub rx1669_off, rx1669_pos, 1
    substr rx1669_tgt, rx1669_tgt, rx1669_off
  rx1669_start:
    eq $I10, 1, rx1669_restart
    if_null rx1669_debug, debug_1158
    rx1669_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1158:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1670_done
    goto rxscan1670_scan
  rxscan1670_loop:
    (rx1669_pos) = rx1669_cur."from"()
    inc rx1669_pos
    rx1669_cur."!cursor_from"(rx1669_pos)
    ge rx1669_pos, rx1669_eos, rxscan1670_done
  rxscan1670_scan:
    set_addr $I10, rxscan1670_loop
    rx1669_cur."!mark_push"(0, rx1669_pos, $I10)
  rxscan1670_done:
.annotate 'line', 795
    rx1669_cur."!cursor_pos"(rx1669_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1159
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1160
    die "Contextual $*PACKAGE not found"
  vivify_1160:
  vivify_1159:
    store_lex "$*OUTERPACKAGE", $P107
.annotate 'line', 796
    rx1669_cur."!cursor_pos"(rx1669_pos)
    new $P108, "String"
    assign $P108, "native"
    store_lex "$*PKGDECL", $P108
.annotate 'line', 797
  # rx subcapture "sym"
    set_addr $I10, rxcap_1671_fail
    rx1669_cur."!mark_push"(0, rx1669_pos, $I10)
  # rx literal  "native"
    add $I11, rx1669_pos, 6
    gt $I11, rx1669_eos, rx1669_fail
    sub $I11, rx1669_pos, rx1669_off
    substr $S10, rx1669_tgt, $I11, 6
    ne $S10, "native", rx1669_fail
    add rx1669_pos, 6
    set_addr $I10, rxcap_1671_fail
    ($I12, $I11) = rx1669_cur."!mark_peek"($I10)
    rx1669_cur."!cursor_pos"($I11)
    ($P10) = rx1669_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1669_pos, "")
    rx1669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1671_done
  rxcap_1671_fail:
    goto rx1669_fail
  rxcap_1671_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1669_cur."!cursor_pos"(rx1669_pos)
    $P10 = rx1669_cur."package_def"()
    unless $P10, rx1669_fail
    rx1669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1669_pos = $P10."pos"()
.annotate 'line', 794
  # rx pass
    rx1669_cur."!cursor_pass"(rx1669_pos, "package_declarator:sym<native>")
    if_null rx1669_debug, debug_1161
    rx1669_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1669_pos)
  debug_1161:
    .return (rx1669_cur)
  rx1669_restart:
.annotate 'line', 469
    if_null rx1669_debug, debug_1162
    rx1669_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1162:
  rx1669_fail:
    (rx1669_rep, rx1669_pos, $I10, $P10) = rx1669_cur."!mark_fail"(0)
    lt rx1669_pos, -1, rx1669_done
    eq rx1669_pos, -1, rx1669_fail
    jump $I10
  rx1669_done:
    rx1669_cur."!cursor_fail"()
    if_null rx1669_debug, debug_1163
    rx1669_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1163:
    .return (rx1669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("185_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("package_def", "native")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("186_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 800
    new $P103, "Undef"
    set $P1674, $P103
    .lex "$*OUTERPACKAGE", $P1674
.annotate 'line', 801
    new $P104, "Undef"
    set $P1675, $P104
    .lex "$*PKGDECL", $P1675
.annotate 'line', 469
    .local string rx1676_tgt
    .local int rx1676_pos
    .local int rx1676_off
    .local int rx1676_eos
    .local int rx1676_rep
    .local pmc rx1676_cur
    .local pmc rx1676_debug
    (rx1676_cur, rx1676_pos, rx1676_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1676_cur
    .local pmc match
    .lex "$/", match
    length rx1676_eos, rx1676_tgt
    gt rx1676_pos, rx1676_eos, rx1676_done
    set rx1676_off, 0
    lt rx1676_pos, 2, rx1676_start
    sub rx1676_off, rx1676_pos, 1
    substr rx1676_tgt, rx1676_tgt, rx1676_off
  rx1676_start:
    eq $I10, 1, rx1676_restart
    if_null rx1676_debug, debug_1164
    rx1676_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1164:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1677_done
    goto rxscan1677_scan
  rxscan1677_loop:
    (rx1676_pos) = rx1676_cur."from"()
    inc rx1676_pos
    rx1676_cur."!cursor_from"(rx1676_pos)
    ge rx1676_pos, rx1676_eos, rxscan1677_done
  rxscan1677_scan:
    set_addr $I10, rxscan1677_loop
    rx1676_cur."!mark_push"(0, rx1676_pos, $I10)
  rxscan1677_done:
.annotate 'line', 799
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
.annotate 'line', 800
    rx1676_cur."!cursor_pos"(rx1676_pos)
    find_dynamic_lex $P108, "$*PACKAGE"
    unless_null $P108, vivify_1165
    get_hll_global $P106, "GLOBAL"
    get_who $P107, $P106
    set $P108, $P107["$PACKAGE"]
    unless_null $P108, vivify_1166
    die "Contextual $*PACKAGE not found"
  vivify_1166:
  vivify_1165:
    store_lex "$*OUTERPACKAGE", $P108
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
.annotate 'line', 801
    rx1676_cur."!cursor_pos"(rx1676_pos)
    new $P110, "String"
    assign $P110, "stub"
    store_lex "$*PKGDECL", $P110
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
.annotate 'line', 802
  # rx subcapture "sym"
    set_addr $I10, rxcap_1678_fail
    rx1676_cur."!mark_push"(0, rx1676_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1676_pos, 4
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    substr $S10, rx1676_tgt, $I11, 4
    ne $S10, "stub", rx1676_fail
    add rx1676_pos, 4
    set_addr $I10, rxcap_1678_fail
    ($I12, $I11) = rx1676_cur."!mark_peek"($I10)
    rx1676_cur."!cursor_pos"($I11)
    ($P10) = rx1676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1676_pos, "")
    rx1676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1678_done
  rxcap_1678_fail:
    goto rx1676_fail
  rxcap_1678_done:
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."name"()
    unless $P10, rx1676_fail
    rx1676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1676_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
.annotate 'line', 803
  # rx literal  "metaclass"
    add $I11, rx1676_pos, 9
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    substr $S10, rx1676_tgt, $I11, 9
    ne $S10, "metaclass", rx1676_fail
    add rx1676_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."name"()
    unless $P10, rx1676_fail
    rx1676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1676_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
.annotate 'line', 804
  # rx literal  "{"
    add $I11, rx1676_pos, 1
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    ord $I11, rx1676_tgt, $I11
    ne $I11, 123, rx1676_fail
    add rx1676_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1676_pos, 3
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    substr $S10, rx1676_tgt, $I11, 3
    ne $S10, "...", rx1676_fail
    add rx1676_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1676_pos, 1
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    ord $I11, rx1676_tgt, $I11
    ne $I11, 125, rx1676_fail
    add rx1676_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."ws"()
    unless $P10, rx1676_fail
    rx1676_pos = $P10."pos"()
.annotate 'line', 799
  # rx pass
    rx1676_cur."!cursor_pass"(rx1676_pos, "package_declarator:sym<stub>")
    if_null rx1676_debug, debug_1167
    rx1676_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1676_pos)
  debug_1167:
    .return (rx1676_cur)
  rx1676_restart:
.annotate 'line', 469
    if_null rx1676_debug, debug_1168
    rx1676_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1168:
  rx1676_fail:
    (rx1676_rep, rx1676_pos, $I10, $P10) = rx1676_cur."!mark_fail"(0)
    lt rx1676_pos, -1, rx1676_done
    eq rx1676_pos, -1, rx1676_fail
    jump $I10
  rx1676_done:
    rx1676_cur."!cursor_fail"()
    if_null rx1676_debug, debug_1169
    rx1676_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1169:
    .return (rx1676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("187_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P119 = self."!PREFIX__!subrule"("ws", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("188_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1686 = "189_1321350766.1143" 
    capture_lex $P1686
.annotate 'line', 808
    new $P103, "Undef"
    set $P1681, $P103
    .lex "$*PACKAGE", $P1681
.annotate 'line', 469
    .local string rx1682_tgt
    .local int rx1682_pos
    .local int rx1682_off
    .local int rx1682_eos
    .local int rx1682_rep
    .local pmc rx1682_cur
    .local pmc rx1682_debug
    (rx1682_cur, rx1682_pos, rx1682_tgt, $I10) = self."!cursor_start"()
    rx1682_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1682_cur
    .local pmc match
    .lex "$/", match
    length rx1682_eos, rx1682_tgt
    gt rx1682_pos, rx1682_eos, rx1682_done
    set rx1682_off, 0
    lt rx1682_pos, 2, rx1682_start
    sub rx1682_off, rx1682_pos, 1
    substr rx1682_tgt, rx1682_tgt, rx1682_off
  rx1682_start:
    eq $I10, 1, rx1682_restart
    if_null rx1682_debug, debug_1170
    rx1682_cur."!cursor_debug"("START", "package_def")
  debug_1170:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1683_done
    goto rxscan1683_scan
  rxscan1683_loop:
    (rx1682_pos) = rx1682_cur."from"()
    inc rx1682_pos
    rx1682_cur."!cursor_from"(rx1682_pos)
    ge rx1682_pos, rx1682_eos, rxscan1683_done
  rxscan1683_scan:
    set_addr $I10, rxscan1683_loop
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxscan1683_done:
.annotate 'line', 807
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 808
    rx1682_cur."!cursor_pos"(rx1682_pos)
    find_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1171
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1172
    die "Contextual $*PACKAGE not found"
  vivify_1172:
  vivify_1171:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 810
  # rx subrule "name" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."name"()
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 811
  # rx rxquantr1684 ** 0..1
    set_addr $I10, rxquantr1684_done
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxquantr1684_loop:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1682_pos, 2
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 2
    ne $S10, "is", rx1682_fail
    add rx1682_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1682_pos, 5
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 5
    ne $S10, "repr(", rx1682_fail
    add rx1682_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."quote_EXPR"()
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1682_pos, 1
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    ord $I11, rx1682_tgt, $I11
    ne $I11, 41, rx1682_fail
    add rx1682_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
    set_addr $I10, rxquantr1684_done
    (rx1682_rep) = rx1682_cur."!mark_commit"($I10)
  rxquantr1684_done:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 813
    rx1682_cur."!cursor_pos"(rx1682_pos)
    find_lex $P116, unicode:"$\x{a2}"
    $P117 = $P116."MATCH"()
    store_lex "$/", $P117
    .const 'Sub' $P1686 = "189_1321350766.1143" 
    capture_lex $P1686
    $P119 = $P1686()
.annotate 'line', 839
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 841
  # rx rxquantr1721 ** 0..1
    set_addr $I10, rxquantr1721_done
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxquantr1721_loop:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1682_pos, 2
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 2
    ne $S10, "is", rx1682_fail
    add rx1682_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."name"()
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
    set_addr $I10, rxquantr1721_done
    (rx1682_rep) = rx1682_cur."!mark_commit"($I10)
  rxquantr1721_done:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 842
  # rx rxquantr1722 ** 0..*
    set_addr $I10, rxquantr1722_done
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxquantr1722_loop:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1682_pos, 4
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 4
    ne $S10, "does", rx1682_fail
    add rx1682_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."name"()
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
    set_addr $I10, rxquantr1722_done
    (rx1682_rep) = rx1682_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1722_done
    rx1682_cur."!mark_push"(rx1682_rep, rx1682_pos, $I10)
    goto rxquantr1722_loop
  rxquantr1722_done:
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  alt1723_0:
.annotate 'line', 843
    set_addr $I10, alt1723_1
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
.annotate 'line', 844
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1682_pos, 1
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    ord $I11, rx1682_tgt, $I11
    ne $I11, 59, rx1682_fail
    add rx1682_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."comp_unit"()
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
    goto alt1723_end
  alt1723_1:
    set_addr $I10, alt1723_2
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
.annotate 'line', 845
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1682_fail
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."block"()
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
    goto alt1723_end
  alt1723_2:
.annotate 'line', 846
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."panic"("Malformed package declaration")
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
  alt1723_end:
.annotate 'line', 847
  # rx subrule "ws" subtype=method negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."ws"()
    unless $P10, rx1682_fail
    rx1682_pos = $P10."pos"()
.annotate 'line', 807
  # rx pass
    rx1682_cur."!cursor_pass"(rx1682_pos, "package_def")
    if_null rx1682_debug, debug_1240
    rx1682_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1682_pos)
  debug_1240:
    .return (rx1682_cur)
  rx1682_restart:
.annotate 'line', 469
    if_null rx1682_debug, debug_1241
    rx1682_cur."!cursor_debug"("NEXT", "package_def")
  debug_1241:
  rx1682_fail:
    (rx1682_rep, rx1682_pos, $I10, $P10) = rx1682_cur."!mark_fail"(0)
    lt rx1682_pos, -1, rx1682_done
    eq rx1682_pos, -1, rx1682_fail
    jump $I10
  rx1682_done:
    rx1682_cur."!cursor_fail"()
    if_null rx1682_debug, debug_1242
    rx1682_cur."!cursor_debug"("FAIL", "package_def")
  debug_1242:
    .return (rx1682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1685"  :anon :subid("189_1321350766.1143") :outer("188_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 816
    $P1688 = root_new ['parrot';'Hash']
    set $P1687, $P1688
    .lex "%args", $P1687
.annotate 'line', 813
    find_lex $P1689, "%args"
    unless_null $P1689, vivify_1173
    $P1689 = root_new ['parrot';'Hash']
  vivify_1173:
.annotate 'line', 817
    find_lex $P1690, "$/"
    unless_null $P1690, vivify_1174
    $P1690 = root_new ['parrot';'Hash']
  vivify_1174:
    set $P118, $P1690["name"]
    unless_null $P118, vivify_1175
    new $P118, "Undef"
  vivify_1175:
    set $S100, $P118
    new $P119, 'String'
    set $P119, $S100
    find_lex $P1691, "%args"
    unless_null $P1691, vivify_1176
    $P1691 = root_new ['parrot';'Hash']
    store_lex "%args", $P1691
  vivify_1176:
    set $P1691["name"], $P119
.annotate 'line', 818
    find_lex $P1693, "$/"
    unless_null $P1693, vivify_1177
    $P1693 = root_new ['parrot';'Hash']
  vivify_1177:
    set $P118, $P1693["repr"]
    unless_null $P118, vivify_1178
    new $P118, "Undef"
  vivify_1178:
    unless $P118, if_1692_end
.annotate 'line', 819
    new $P119, "Float"
    assign $P119, 0
    set $I100, $P119
    new $P120, "Float"
    assign $P120, 0
    set $I101, $P120
    find_lex $P1694, "$/"
    unless_null $P1694, vivify_1179
    $P1694 = root_new ['parrot';'Hash']
  vivify_1179:
    set $P1695, $P1694["repr"]
    unless_null $P1695, vivify_1180
    $P1695 = root_new ['parrot';'ResizablePMCArray']
  vivify_1180:
    set $P1696, $P1695[$I101]
    unless_null $P1696, vivify_1181
    $P1696 = root_new ['parrot';'Hash']
  vivify_1181:
    set $P1697, $P1696["quote_delimited"]
    unless_null $P1697, vivify_1182
    $P1697 = root_new ['parrot';'Hash']
  vivify_1182:
    set $P1698, $P1697["quote_atom"]
    unless_null $P1698, vivify_1183
    $P1698 = root_new ['parrot';'ResizablePMCArray']
  vivify_1183:
    set $P121, $P1698[$I100]
    unless_null $P121, vivify_1184
    new $P121, "Undef"
  vivify_1184:
    set $S100, $P121
    new $P122, 'String'
    set $P122, $S100
    find_lex $P1699, "%args"
    unless_null $P1699, vivify_1185
    $P1699 = root_new ['parrot';'Hash']
    store_lex "%args", $P1699
  vivify_1185:
    set $P1699["repr"], $P122
  if_1692_end:
.annotate 'line', 821
    find_dynamic_lex $P120, "$*SC"
    unless_null $P120, vivify_1186
    get_hll_global $P118, "GLOBAL"
    get_who $P119, $P118
    set $P120, $P119["$SC"]
    unless_null $P120, vivify_1187
    die "Contextual $*SC not found"
  vivify_1187:
  vivify_1186:
    find_dynamic_lex $P123, "$*PKGDECL"
    unless_null $P123, vivify_1188
    get_hll_global $P121, "GLOBAL"
    get_who $P122, $P121
    set $P123, $P122["$PKGDECL"]
    unless_null $P123, vivify_1189
    die "Contextual $*PKGDECL not found"
  vivify_1189:
  vivify_1188:
    find_dynamic_lex $P126, "%*HOW"
    unless_null $P126, vivify_1190
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P126, $P125["%HOW"]
    unless_null $P126, vivify_1191
    die "Contextual %*HOW not found"
  vivify_1191:
  vivify_1190:
    set $P127, $P126[$P123]
    unless_null $P127, vivify_1192
    new $P127, "Undef"
  vivify_1192:
    find_lex $P1700, "%args"
    unless_null $P1700, vivify_1193
    $P1700 = root_new ['parrot';'Hash']
  vivify_1193:
    $P128 = $P120."pkg_create_mo"($P127, $P1700 :flat)
    store_dynamic_lex "$*PACKAGE", $P128
.annotate 'line', 824
    find_dynamic_lex $P122, "$*SCOPE"
    unless_null $P122, vivify_1194
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$SCOPE"]
    unless_null $P122, vivify_1195
    die "Contextual $*SCOPE not found"
  vivify_1195:
  vivify_1194:
    set $S100, $P122
    iseq $I100, $S100, "our"
    unless $I100, unless_1702
    new $P119, 'Integer'
    set $P119, $I100
    goto unless_1702_end
  unless_1702:
    find_dynamic_lex $P125, "$*SCOPE"
    unless_null $P125, vivify_1196
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SCOPE"]
    unless_null $P125, vivify_1197
    die "Contextual $*SCOPE not found"
  vivify_1197:
  vivify_1196:
    set $S101, $P125
    iseq $I101, $S101, ""
    new $P119, 'Integer'
    set $P119, $I101
  unless_1702_end:
    if $P119, if_1701
.annotate 'line', 830
    find_dynamic_lex $P130, "$*SCOPE"
    unless_null $P130, vivify_1198
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SCOPE"]
    unless_null $P130, vivify_1199
    die "Contextual $*SCOPE not found"
  vivify_1199:
  vivify_1198:
    set $S102, $P130
    iseq $I102, $S102, "my"
    if $I102, if_1712
.annotate 'line', 837
    find_lex $P131, "$/"
    unless_null $P131, vivify_1200
    new $P131, "Undef"
  vivify_1200:
    $P132 = $P131."CURSOR"()
    find_dynamic_lex $P135, "$*SCOPE"
    unless_null $P135, vivify_1201
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SCOPE"]
    unless_null $P135, vivify_1202
    die "Contextual $*SCOPE not found"
  vivify_1202:
  vivify_1201:
    concat $P136, $P135, " scoped packages are not supported"
    $P137 = $P132."panic"($P136)
.annotate 'line', 836
    set $P127, $P137
.annotate 'line', 830
    goto if_1712_end
  if_1712:
.annotate 'line', 831
    find_lex $P1714, "$/"
    unless_null $P1714, vivify_1203
    $P1714 = root_new ['parrot';'Hash']
  vivify_1203:
    set $P1715, $P1714["name"]
    unless_null $P1715, vivify_1204
    $P1715 = root_new ['parrot';'Hash']
  vivify_1204:
    set $P131, $P1715["identifier"]
    unless_null $P131, vivify_1205
    new $P131, "Undef"
  vivify_1205:
    set $N100, $P131
    set $N101, 1
    isne $I103, $N100, $N101
    unless $I103, if_1713_end
.annotate 'line', 832
    find_lex $P1716, "$/"
    unless_null $P1716, vivify_1206
    $P1716 = root_new ['parrot';'Hash']
  vivify_1206:
    set $P132, $P1716["name"]
    unless_null $P132, vivify_1207
    new $P132, "Undef"
  vivify_1207:
    $P133 = $P132."CURSOR"()
    $P133."panic"("A my scoped package cannot have a multi-part name yet")
  if_1713_end:
.annotate 'line', 834
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_1208
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_1209
    die "Contextual $*SC not found"
  vivify_1209:
  vivify_1208:
    new $P134, "Float"
    assign $P134, 0
    set $I103, $P134
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "NQP"
    nqp_get_package_through_who $P137, $P136, "Actions"
    get_who $P138, $P137
    set $P1717, $P138["@BLOCK"]
    unless_null $P1717, vivify_1210
    $P1717 = root_new ['parrot';'ResizablePMCArray']
  vivify_1210:
    set $P139, $P1717[$I103]
    unless_null $P139, vivify_1211
    new $P139, "Undef"
  vivify_1211:
    new $P140, "Float"
    assign $P140, 0
    set $I104, $P140
    find_lex $P1718, "$/"
    unless_null $P1718, vivify_1212
    $P1718 = root_new ['parrot';'Hash']
  vivify_1212:
    set $P1719, $P1718["name"]
    unless_null $P1719, vivify_1213
    $P1719 = root_new ['parrot';'Hash']
  vivify_1213:
    set $P1720, $P1719["identifier"]
    unless_null $P1720, vivify_1214
    $P1720 = root_new ['parrot';'ResizablePMCArray']
  vivify_1214:
    set $P141, $P1720[$I104]
    unless_null $P141, vivify_1215
    new $P141, "Undef"
  vivify_1215:
    find_dynamic_lex $P144, "$*PACKAGE"
    unless_null $P144, vivify_1216
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$PACKAGE"]
    unless_null $P144, vivify_1217
    die "Contextual $*PACKAGE not found"
  vivify_1217:
  vivify_1216:
    $P145 = $P133."install_lexical_symbol"($P139, $P141, $P144)
.annotate 'line', 830
    set $P127, $P145
  if_1712_end:
    set $P118, $P127
.annotate 'line', 824
    goto if_1701_end
  if_1701:
.annotate 'line', 825
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_1218
    get_hll_global $P126, "GLOBAL"
    get_who $P127, $P126
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_1219
    die "Contextual $*SC not found"
  vivify_1219:
  vivify_1218:
    find_dynamic_lex $P131, "$*OUTERPACKAGE"
    unless_null $P131, vivify_1220
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$OUTERPACKAGE"]
    unless_null $P131, vivify_1221
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1221:
  vivify_1220:
    find_lex $P1703, "$/"
    unless_null $P1703, vivify_1222
    $P1703 = root_new ['parrot';'Hash']
  vivify_1222:
    set $P1704, $P1703["name"]
    unless_null $P1704, vivify_1223
    $P1704 = root_new ['parrot';'Hash']
  vivify_1223:
    set $P132, $P1704["identifier"]
    unless_null $P132, vivify_1224
    new $P132, "Undef"
  vivify_1224:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_1225
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_1226
    die "Contextual $*PACKAGE not found"
  vivify_1226:
  vivify_1225:
    $P128."install_package_symbol"($P131, $P132, $P135)
.annotate 'line', 826
    find_lex $P1706, "$/"
    unless_null $P1706, vivify_1227
    $P1706 = root_new ['parrot';'Hash']
  vivify_1227:
    set $P1707, $P1706["name"]
    unless_null $P1707, vivify_1228
    $P1707 = root_new ['parrot';'Hash']
  vivify_1228:
    set $P127, $P1707["identifier"]
    unless_null $P127, vivify_1229
    new $P127, "Undef"
  vivify_1229:
    set $N100, $P127
    set $N101, 1
    iseq $I102, $N100, $N101
    if $I102, if_1705
    new $P126, 'Integer'
    set $P126, $I102
    goto if_1705_end
  if_1705:
.annotate 'line', 827
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_1230
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_1231
    die "Contextual $*SC not found"
  vivify_1231:
  vivify_1230:
    new $P131, "Float"
    assign $P131, 0
    set $I103, $P131
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "NQP"
    nqp_get_package_through_who $P134, $P133, "Actions"
    get_who $P135, $P134
    set $P1708, $P135["@BLOCK"]
    unless_null $P1708, vivify_1232
    $P1708 = root_new ['parrot';'ResizablePMCArray']
  vivify_1232:
    set $P136, $P1708[$I103]
    unless_null $P136, vivify_1233
    new $P136, "Undef"
  vivify_1233:
    new $P137, "Float"
    assign $P137, 0
    set $I104, $P137
    find_lex $P1709, "$/"
    unless_null $P1709, vivify_1234
    $P1709 = root_new ['parrot';'Hash']
  vivify_1234:
    set $P1710, $P1709["name"]
    unless_null $P1710, vivify_1235
    $P1710 = root_new ['parrot';'Hash']
  vivify_1235:
    set $P1711, $P1710["identifier"]
    unless_null $P1711, vivify_1236
    $P1711 = root_new ['parrot';'ResizablePMCArray']
  vivify_1236:
    set $P138, $P1711[$I104]
    unless_null $P138, vivify_1237
    new $P138, "Undef"
  vivify_1237:
    find_dynamic_lex $P141, "$*PACKAGE"
    unless_null $P141, vivify_1238
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PACKAGE"]
    unless_null $P141, vivify_1239
    die "Contextual $*PACKAGE not found"
  vivify_1239:
  vivify_1238:
    $P142 = $P130."install_lexical_symbol"($P136, $P138, $P141)
.annotate 'line', 826
    set $P126, $P142
  if_1705_end:
.annotate 'line', 824
    set $P118, $P126
  if_1701_end:
.annotate 'line', 813
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("190_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P138 = self."!PREFIX__!subrule"("ws", "")
    new $P139, "ResizablePMCArray"
    push $P139, $P138
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("191_1321350766.1143")
    .param pmc param_1726
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 850
    .lex "self", param_1726
    $P103 = param_1726."!protoregex"("scope_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("192_1321350766.1143")
    .param pmc param_1728
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 850
    .lex "self", param_1728
    $P104 = param_1728."!PREFIX__!protoregex"("scope_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("193_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1730_tgt
    .local int rx1730_pos
    .local int rx1730_off
    .local int rx1730_eos
    .local int rx1730_rep
    .local pmc rx1730_cur
    .local pmc rx1730_debug
    (rx1730_cur, rx1730_pos, rx1730_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1730_cur
    .local pmc match
    .lex "$/", match
    length rx1730_eos, rx1730_tgt
    gt rx1730_pos, rx1730_eos, rx1730_done
    set rx1730_off, 0
    lt rx1730_pos, 2, rx1730_start
    sub rx1730_off, rx1730_pos, 1
    substr rx1730_tgt, rx1730_tgt, rx1730_off
  rx1730_start:
    eq $I10, 1, rx1730_restart
    if_null rx1730_debug, debug_1243
    rx1730_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1731_done
    goto rxscan1731_scan
  rxscan1731_loop:
    (rx1730_pos) = rx1730_cur."from"()
    inc rx1730_pos
    rx1730_cur."!cursor_from"(rx1730_pos)
    ge rx1730_pos, rx1730_eos, rxscan1731_done
  rxscan1731_scan:
    set_addr $I10, rxscan1731_loop
    rx1730_cur."!mark_push"(0, rx1730_pos, $I10)
  rxscan1731_done:
.annotate 'line', 851
  # rx subcapture "sym"
    set_addr $I10, rxcap_1732_fail
    rx1730_cur."!mark_push"(0, rx1730_pos, $I10)
  # rx literal  "my"
    add $I11, rx1730_pos, 2
    gt $I11, rx1730_eos, rx1730_fail
    sub $I11, rx1730_pos, rx1730_off
    substr $S10, rx1730_tgt, $I11, 2
    ne $S10, "my", rx1730_fail
    add rx1730_pos, 2
    set_addr $I10, rxcap_1732_fail
    ($I12, $I11) = rx1730_cur."!mark_peek"($I10)
    rx1730_cur."!cursor_pos"($I11)
    ($P10) = rx1730_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1730_pos, "")
    rx1730_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1732_done
  rxcap_1732_fail:
    goto rx1730_fail
  rxcap_1732_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1730_cur."!cursor_pos"(rx1730_pos)
    $P10 = rx1730_cur."scoped"("my")
    unless $P10, rx1730_fail
    rx1730_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1730_pos = $P10."pos"()
  # rx pass
    rx1730_cur."!cursor_pass"(rx1730_pos, "scope_declarator:sym<my>")
    if_null rx1730_debug, debug_1244
    rx1730_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1730_pos)
  debug_1244:
    .return (rx1730_cur)
  rx1730_restart:
.annotate 'line', 469
    if_null rx1730_debug, debug_1245
    rx1730_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1245:
  rx1730_fail:
    (rx1730_rep, rx1730_pos, $I10, $P10) = rx1730_cur."!mark_fail"(0)
    lt rx1730_pos, -1, rx1730_done
    eq rx1730_pos, -1, rx1730_fail
    jump $I10
  rx1730_done:
    rx1730_cur."!cursor_fail"()
    if_null rx1730_debug, debug_1246
    rx1730_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1246:
    .return (rx1730_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("194_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("scoped", "my")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("195_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1735_tgt
    .local int rx1735_pos
    .local int rx1735_off
    .local int rx1735_eos
    .local int rx1735_rep
    .local pmc rx1735_cur
    .local pmc rx1735_debug
    (rx1735_cur, rx1735_pos, rx1735_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1735_cur
    .local pmc match
    .lex "$/", match
    length rx1735_eos, rx1735_tgt
    gt rx1735_pos, rx1735_eos, rx1735_done
    set rx1735_off, 0
    lt rx1735_pos, 2, rx1735_start
    sub rx1735_off, rx1735_pos, 1
    substr rx1735_tgt, rx1735_tgt, rx1735_off
  rx1735_start:
    eq $I10, 1, rx1735_restart
    if_null rx1735_debug, debug_1247
    rx1735_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1736_done
    goto rxscan1736_scan
  rxscan1736_loop:
    (rx1735_pos) = rx1735_cur."from"()
    inc rx1735_pos
    rx1735_cur."!cursor_from"(rx1735_pos)
    ge rx1735_pos, rx1735_eos, rxscan1736_done
  rxscan1736_scan:
    set_addr $I10, rxscan1736_loop
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  rxscan1736_done:
.annotate 'line', 852
  # rx subcapture "sym"
    set_addr $I10, rxcap_1737_fail
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  # rx literal  "our"
    add $I11, rx1735_pos, 3
    gt $I11, rx1735_eos, rx1735_fail
    sub $I11, rx1735_pos, rx1735_off
    substr $S10, rx1735_tgt, $I11, 3
    ne $S10, "our", rx1735_fail
    add rx1735_pos, 3
    set_addr $I10, rxcap_1737_fail
    ($I12, $I11) = rx1735_cur."!mark_peek"($I10)
    rx1735_cur."!cursor_pos"($I11)
    ($P10) = rx1735_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1735_pos, "")
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1737_done
  rxcap_1737_fail:
    goto rx1735_fail
  rxcap_1737_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1735_cur."!cursor_pos"(rx1735_pos)
    $P10 = rx1735_cur."scoped"("our")
    unless $P10, rx1735_fail
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1735_pos = $P10."pos"()
  # rx pass
    rx1735_cur."!cursor_pass"(rx1735_pos, "scope_declarator:sym<our>")
    if_null rx1735_debug, debug_1248
    rx1735_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1735_pos)
  debug_1248:
    .return (rx1735_cur)
  rx1735_restart:
.annotate 'line', 469
    if_null rx1735_debug, debug_1249
    rx1735_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1249:
  rx1735_fail:
    (rx1735_rep, rx1735_pos, $I10, $P10) = rx1735_cur."!mark_fail"(0)
    lt rx1735_pos, -1, rx1735_done
    eq rx1735_pos, -1, rx1735_fail
    jump $I10
  rx1735_done:
    rx1735_cur."!cursor_fail"()
    if_null rx1735_debug, debug_1250
    rx1735_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1250:
    .return (rx1735_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("196_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("scoped", "our")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("197_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1740_tgt
    .local int rx1740_pos
    .local int rx1740_off
    .local int rx1740_eos
    .local int rx1740_rep
    .local pmc rx1740_cur
    .local pmc rx1740_debug
    (rx1740_cur, rx1740_pos, rx1740_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1740_cur
    .local pmc match
    .lex "$/", match
    length rx1740_eos, rx1740_tgt
    gt rx1740_pos, rx1740_eos, rx1740_done
    set rx1740_off, 0
    lt rx1740_pos, 2, rx1740_start
    sub rx1740_off, rx1740_pos, 1
    substr rx1740_tgt, rx1740_tgt, rx1740_off
  rx1740_start:
    eq $I10, 1, rx1740_restart
    if_null rx1740_debug, debug_1251
    rx1740_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1741_done
    goto rxscan1741_scan
  rxscan1741_loop:
    (rx1740_pos) = rx1740_cur."from"()
    inc rx1740_pos
    rx1740_cur."!cursor_from"(rx1740_pos)
    ge rx1740_pos, rx1740_eos, rxscan1741_done
  rxscan1741_scan:
    set_addr $I10, rxscan1741_loop
    rx1740_cur."!mark_push"(0, rx1740_pos, $I10)
  rxscan1741_done:
.annotate 'line', 853
  # rx subcapture "sym"
    set_addr $I10, rxcap_1742_fail
    rx1740_cur."!mark_push"(0, rx1740_pos, $I10)
  # rx literal  "has"
    add $I11, rx1740_pos, 3
    gt $I11, rx1740_eos, rx1740_fail
    sub $I11, rx1740_pos, rx1740_off
    substr $S10, rx1740_tgt, $I11, 3
    ne $S10, "has", rx1740_fail
    add rx1740_pos, 3
    set_addr $I10, rxcap_1742_fail
    ($I12, $I11) = rx1740_cur."!mark_peek"($I10)
    rx1740_cur."!cursor_pos"($I11)
    ($P10) = rx1740_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1740_pos, "")
    rx1740_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1742_done
  rxcap_1742_fail:
    goto rx1740_fail
  rxcap_1742_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1740_cur."!cursor_pos"(rx1740_pos)
    $P10 = rx1740_cur."scoped"("has")
    unless $P10, rx1740_fail
    rx1740_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1740_pos = $P10."pos"()
  # rx pass
    rx1740_cur."!cursor_pass"(rx1740_pos, "scope_declarator:sym<has>")
    if_null rx1740_debug, debug_1252
    rx1740_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1740_pos)
  debug_1252:
    .return (rx1740_cur)
  rx1740_restart:
.annotate 'line', 469
    if_null rx1740_debug, debug_1253
    rx1740_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1253:
  rx1740_fail:
    (rx1740_rep, rx1740_pos, $I10, $P10) = rx1740_cur."!mark_fail"(0)
    lt rx1740_pos, -1, rx1740_done
    eq rx1740_pos, -1, rx1740_fail
    jump $I10
  rx1740_done:
    rx1740_cur."!cursor_fail"()
    if_null rx1740_debug, debug_1254
    rx1740_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1254:
    .return (rx1740_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("198_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("scoped", "has")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("199_1321350766.1143") :method :outer("46_1321350766.1143")
    .param pmc param_1745
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 855
    .lex "$*SCOPE", param_1745
.annotate 'line', 469
    .local string rx1746_tgt
    .local int rx1746_pos
    .local int rx1746_off
    .local int rx1746_eos
    .local int rx1746_rep
    .local pmc rx1746_cur
    .local pmc rx1746_debug
    (rx1746_cur, rx1746_pos, rx1746_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1746_cur
    .local pmc match
    .lex "$/", match
    length rx1746_eos, rx1746_tgt
    gt rx1746_pos, rx1746_eos, rx1746_done
    set rx1746_off, 0
    lt rx1746_pos, 2, rx1746_start
    sub rx1746_off, rx1746_pos, 1
    substr rx1746_tgt, rx1746_tgt, rx1746_off
  rx1746_start:
    eq $I10, 1, rx1746_restart
    if_null rx1746_debug, debug_1255
    rx1746_cur."!cursor_debug"("START", "scoped")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1747_done
    goto rxscan1747_scan
  rxscan1747_loop:
    (rx1746_pos) = rx1746_cur."from"()
    inc rx1746_pos
    rx1746_cur."!cursor_from"(rx1746_pos)
    ge rx1746_pos, rx1746_eos, rxscan1747_done
  rxscan1747_scan:
    set_addr $I10, rxscan1747_loop
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
  rxscan1747_done:
  alt1748_0:
.annotate 'line', 855
    set_addr $I10, alt1748_1
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
.annotate 'line', 856
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."declarator"()
    unless $P10, rx1746_fail
    rx1746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1746_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
    goto alt1748_end
  alt1748_1:
    set_addr $I10, alt1748_2
    rx1746_cur."!mark_push"(0, rx1746_pos, $I10)
.annotate 'line', 857
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."multi_declarator"()
    unless $P10, rx1746_fail
    rx1746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1746_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
    goto alt1748_end
  alt1748_2:
.annotate 'line', 858
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."package_declarator"()
    unless $P10, rx1746_fail
    rx1746_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1746_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1746_cur."!cursor_pos"(rx1746_pos)
    $P10 = rx1746_cur."ws"()
    unless $P10, rx1746_fail
    rx1746_pos = $P10."pos"()
  alt1748_end:
.annotate 'line', 855
  # rx pass
    rx1746_cur."!cursor_pass"(rx1746_pos, "scoped")
    if_null rx1746_debug, debug_1256
    rx1746_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1746_pos)
  debug_1256:
    .return (rx1746_cur)
  rx1746_restart:
.annotate 'line', 469
    if_null rx1746_debug, debug_1257
    rx1746_cur."!cursor_debug"("NEXT", "scoped")
  debug_1257:
  rx1746_fail:
    (rx1746_rep, rx1746_pos, $I10, $P10) = rx1746_cur."!mark_fail"(0)
    lt rx1746_pos, -1, rx1746_done
    eq rx1746_pos, -1, rx1746_fail
    jump $I10
  rx1746_done:
    rx1746_cur."!cursor_fail"()
    if_null rx1746_debug, debug_1258
    rx1746_cur."!cursor_debug"("FAIL", "scoped")
  debug_1258:
    .return (rx1746_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("200_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P109 = self."!PREFIX__!subrule"("ws", "")
    $P110 = self."!PREFIX__!subrule"("ws", "")
    $P111 = self."!PREFIX__!subrule"("ws", "")
    new $P112, "ResizablePMCArray"
    push $P112, $P109
    push $P112, $P110
    push $P112, $P111
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("201_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1754 = "202_1321350766.1143" 
    capture_lex $P1754
    .local string rx1751_tgt
    .local int rx1751_pos
    .local int rx1751_off
    .local int rx1751_eos
    .local int rx1751_rep
    .local pmc rx1751_cur
    .local pmc rx1751_debug
    (rx1751_cur, rx1751_pos, rx1751_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1751_cur
    .local pmc match
    .lex "$/", match
    length rx1751_eos, rx1751_tgt
    gt rx1751_pos, rx1751_eos, rx1751_done
    set rx1751_off, 0
    lt rx1751_pos, 2, rx1751_start
    sub rx1751_off, rx1751_pos, 1
    substr rx1751_tgt, rx1751_tgt, rx1751_off
  rx1751_start:
    eq $I10, 1, rx1751_restart
    if_null rx1751_debug, debug_1259
    rx1751_cur."!cursor_debug"("START", "typename")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1752_done
    goto rxscan1752_scan
  rxscan1752_loop:
    (rx1751_pos) = rx1751_cur."from"()
    inc rx1751_pos
    rx1751_cur."!cursor_from"(rx1751_pos)
    ge rx1751_pos, rx1751_eos, rxscan1752_done
  rxscan1752_scan:
    set_addr $I10, rxscan1752_loop
    rx1751_cur."!mark_push"(0, rx1751_pos, $I10)
  rxscan1752_done:
.annotate 'line', 862
  # rx subrule "name" subtype=capture negate=
    rx1751_cur."!cursor_pos"(rx1751_pos)
    $P10 = rx1751_cur."name"()
    unless $P10, rx1751_fail
    rx1751_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1751_pos = $P10."pos"()
.annotate 'line', 863
    rx1751_cur."!cursor_pos"(rx1751_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1754 = "202_1321350766.1143" 
    capture_lex $P1754
    $P105 = $P1754()
    unless $P105, rx1751_fail
.annotate 'line', 861
  # rx pass
    rx1751_cur."!cursor_pass"(rx1751_pos, "typename")
    if_null rx1751_debug, debug_1266
    rx1751_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1751_pos)
  debug_1266:
    .return (rx1751_cur)
  rx1751_restart:
.annotate 'line', 469
    if_null rx1751_debug, debug_1267
    rx1751_cur."!cursor_debug"("NEXT", "typename")
  debug_1267:
  rx1751_fail:
    (rx1751_rep, rx1751_pos, $I10, $P10) = rx1751_cur."!mark_fail"(0)
    lt rx1751_pos, -1, rx1751_done
    eq rx1751_pos, -1, rx1751_fail
    jump $I10
  rx1751_done:
    rx1751_cur."!cursor_fail"()
    if_null rx1751_debug, debug_1268
    rx1751_cur."!cursor_debug"("FAIL", "typename")
  debug_1268:
    .return (rx1751_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1753"  :anon :subid("202_1321350766.1143") :outer("201_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 863
    find_dynamic_lex $P107, "$*ACTIONS"
    unless_null $P107, vivify_1260
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$ACTIONS"]
    unless_null $P107, vivify_1261
    die "Contextual $*ACTIONS not found"
  vivify_1261:
  vivify_1260:
    find_lex $P108, "$/"
    unless_null $P108, vivify_1262
    new $P108, "Undef"
  vivify_1262:
    find_lex $P1755, "$/"
    unless_null $P1755, vivify_1263
    $P1755 = root_new ['parrot';'Hash']
  vivify_1263:
    set $P1756, $P1755["name"]
    unless_null $P1756, vivify_1264
    $P1756 = root_new ['parrot';'Hash']
  vivify_1264:
    set $P109, $P1756["identifier"]
    unless_null $P109, vivify_1265
    new $P109, "Undef"
  vivify_1265:
    $P110 = $P107."known_sym"($P108, $P109)
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("203_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P106 = self."!PREFIX__!subrule"("name", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("204_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1759_tgt
    .local int rx1759_pos
    .local int rx1759_off
    .local int rx1759_eos
    .local int rx1759_rep
    .local pmc rx1759_cur
    .local pmc rx1759_debug
    (rx1759_cur, rx1759_pos, rx1759_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1759_cur
    .local pmc match
    .lex "$/", match
    length rx1759_eos, rx1759_tgt
    gt rx1759_pos, rx1759_eos, rx1759_done
    set rx1759_off, 0
    lt rx1759_pos, 2, rx1759_start
    sub rx1759_off, rx1759_pos, 1
    substr rx1759_tgt, rx1759_tgt, rx1759_off
  rx1759_start:
    eq $I10, 1, rx1759_restart
    if_null rx1759_debug, debug_1269
    rx1759_cur."!cursor_debug"("START", "declarator")
  debug_1269:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1760_done
    goto rxscan1760_scan
  rxscan1760_loop:
    (rx1759_pos) = rx1759_cur."from"()
    inc rx1759_pos
    rx1759_cur."!cursor_from"(rx1759_pos)
    ge rx1759_pos, rx1759_eos, rxscan1760_done
  rxscan1760_scan:
    set_addr $I10, rxscan1760_loop
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  rxscan1760_done:
  alt1761_0:
.annotate 'line', 866
    set_addr $I10, alt1761_1
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
.annotate 'line', 867
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1759_cur."!cursor_pos"(rx1759_pos)
    $P10 = rx1759_cur."variable_declarator"()
    unless $P10, rx1759_fail
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1759_pos = $P10."pos"()
    goto alt1761_end
  alt1761_1:
.annotate 'line', 868
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1759_cur."!cursor_pos"(rx1759_pos)
    $P10 = rx1759_cur."routine_declarator"()
    unless $P10, rx1759_fail
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1759_pos = $P10."pos"()
  alt1761_end:
.annotate 'line', 866
  # rx pass
    rx1759_cur."!cursor_pass"(rx1759_pos, "declarator")
    if_null rx1759_debug, debug_1270
    rx1759_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1759_pos)
  debug_1270:
    .return (rx1759_cur)
  rx1759_restart:
.annotate 'line', 469
    if_null rx1759_debug, debug_1271
    rx1759_cur."!cursor_debug"("NEXT", "declarator")
  debug_1271:
  rx1759_fail:
    (rx1759_rep, rx1759_pos, $I10, $P10) = rx1759_cur."!mark_fail"(0)
    lt rx1759_pos, -1, rx1759_done
    eq rx1759_pos, -1, rx1759_fail
    jump $I10
  rx1759_done:
    rx1759_cur."!cursor_fail"()
    if_null rx1759_debug, debug_1272
    rx1759_cur."!cursor_debug"("FAIL", "declarator")
  debug_1272:
    .return (rx1759_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("205_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P104 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("206_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1770 = "207_1321350766.1143" 
    capture_lex $P1770
.annotate 'line', 873
    new $P103, "Undef"
    set $P1764, $P103
    .lex "$*IN_DECL", $P1764
.annotate 'line', 469
    .local string rx1765_tgt
    .local int rx1765_pos
    .local int rx1765_off
    .local int rx1765_eos
    .local int rx1765_rep
    .local pmc rx1765_cur
    .local pmc rx1765_debug
    (rx1765_cur, rx1765_pos, rx1765_tgt, $I10) = self."!cursor_start"()
    rx1765_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1765_cur
    .local pmc match
    .lex "$/", match
    length rx1765_eos, rx1765_tgt
    gt rx1765_pos, rx1765_eos, rx1765_done
    set rx1765_off, 0
    lt rx1765_pos, 2, rx1765_start
    sub rx1765_off, rx1765_pos, 1
    substr rx1765_tgt, rx1765_tgt, rx1765_off
  rx1765_start:
    eq $I10, 1, rx1765_restart
    if_null rx1765_debug, debug_1273
    rx1765_cur."!cursor_debug"("START", "variable_declarator")
  debug_1273:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1766_done
    goto rxscan1766_scan
  rxscan1766_loop:
    (rx1765_pos) = rx1765_cur."from"()
    inc rx1765_pos
    rx1765_cur."!cursor_from"(rx1765_pos)
    ge rx1765_pos, rx1765_eos, rxscan1766_done
  rxscan1766_scan:
    set_addr $I10, rxscan1766_loop
    rx1765_cur."!mark_push"(0, rx1765_pos, $I10)
  rxscan1766_done:
.annotate 'line', 871
  # rx subrule "ws" subtype=method negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."ws"()
    unless $P10, rx1765_fail
    rx1765_pos = $P10."pos"()
.annotate 'line', 872
  # rx rxquantr1767 ** 0..1
    set_addr $I10, rxquantr1767_done
    rx1765_cur."!mark_push"(0, rx1765_pos, $I10)
  rxquantr1767_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."typename"()
    unless $P10, rx1765_fail
    goto rxsubrule1768_pass
  rxsubrule1768_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1765_fail
  rxsubrule1768_pass:
    set_addr $I10, rxsubrule1768_back
    rx1765_cur."!mark_push"(0, rx1765_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1765_pos = $P10."pos"()
    set_addr $I10, rxquantr1767_done
    (rx1765_rep) = rx1765_cur."!mark_commit"($I10)
  rxquantr1767_done:
  # rx subrule "ws" subtype=method negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."ws"()
    unless $P10, rx1765_fail
    rx1765_pos = $P10."pos"()
.annotate 'line', 873
    rx1765_cur."!cursor_pos"(rx1765_pos)
    new $P106, "String"
    assign $P106, "variable"
    store_lex "$*IN_DECL", $P106
  # rx subrule "ws" subtype=method negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."ws"()
    unless $P10, rx1765_fail
    rx1765_pos = $P10."pos"()
.annotate 'line', 874
  # rx subrule "variable" subtype=capture negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."variable"()
    unless $P10, rx1765_fail
    rx1765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."ws"()
    unless $P10, rx1765_fail
    rx1765_pos = $P10."pos"()
.annotate 'line', 875
    rx1765_cur."!cursor_pos"(rx1765_pos)
    find_lex $P109, unicode:"$\x{a2}"
    $P110 = $P109."MATCH"()
    store_lex "$/", $P110
    .const 'Sub' $P1770 = "207_1321350766.1143" 
    capture_lex $P1770
    $P112 = $P1770()
  # rx subrule "ws" subtype=method negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."ws"()
    unless $P10, rx1765_fail
    rx1765_pos = $P10."pos"()
.annotate 'line', 876
  # rx rxquantr1771 ** 0..*
    set_addr $I10, rxquantr1771_done
    rx1765_cur."!mark_push"(0, rx1765_pos, $I10)
  rxquantr1771_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."trait"()
    unless $P10, rx1765_fail
    goto rxsubrule1772_pass
  rxsubrule1772_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1765_fail
  rxsubrule1772_pass:
    set_addr $I10, rxsubrule1772_back
    rx1765_cur."!mark_push"(0, rx1765_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1765_pos = $P10."pos"()
    set_addr $I10, rxquantr1771_done
    (rx1765_rep) = rx1765_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1771_done
    rx1765_cur."!mark_push"(rx1765_rep, rx1765_pos, $I10)
    goto rxquantr1771_loop
  rxquantr1771_done:
  # rx subrule "ws" subtype=method negate=
    rx1765_cur."!cursor_pos"(rx1765_pos)
    $P10 = rx1765_cur."ws"()
    unless $P10, rx1765_fail
    rx1765_pos = $P10."pos"()
.annotate 'line', 871
  # rx pass
    rx1765_cur."!cursor_pass"(rx1765_pos, "variable_declarator")
    if_null rx1765_debug, debug_1274
    rx1765_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1765_pos)
  debug_1274:
    .return (rx1765_cur)
  rx1765_restart:
.annotate 'line', 469
    if_null rx1765_debug, debug_1275
    rx1765_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1275:
  rx1765_fail:
    (rx1765_rep, rx1765_pos, $I10, $P10) = rx1765_cur."!mark_fail"(0)
    lt rx1765_pos, -1, rx1765_done
    eq rx1765_pos, -1, rx1765_fail
    jump $I10
  rx1765_done:
    rx1765_cur."!cursor_fail"()
    if_null rx1765_debug, debug_1276
    rx1765_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1276:
    .return (rx1765_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1769"  :anon :subid("207_1321350766.1143") :outer("206_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 875
    new $P111, "Float"
    assign $P111, 0
    store_dynamic_lex "$*IN_DECL", $P111
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("208_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P115 = self."!PREFIX__!subrule"("ws", "")
    new $P116, "ResizablePMCArray"
    push $P116, $P115
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("209_1321350766.1143")
    .param pmc param_1775
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 879
    .lex "self", param_1775
    $P103 = param_1775."!protoregex"("routine_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("210_1321350766.1143")
    .param pmc param_1777
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 879
    .lex "self", param_1777
    $P104 = param_1777."!PREFIX__!protoregex"("routine_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("211_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1779_tgt
    .local int rx1779_pos
    .local int rx1779_off
    .local int rx1779_eos
    .local int rx1779_rep
    .local pmc rx1779_cur
    .local pmc rx1779_debug
    (rx1779_cur, rx1779_pos, rx1779_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1779_cur
    .local pmc match
    .lex "$/", match
    length rx1779_eos, rx1779_tgt
    gt rx1779_pos, rx1779_eos, rx1779_done
    set rx1779_off, 0
    lt rx1779_pos, 2, rx1779_start
    sub rx1779_off, rx1779_pos, 1
    substr rx1779_tgt, rx1779_tgt, rx1779_off
  rx1779_start:
    eq $I10, 1, rx1779_restart
    if_null rx1779_debug, debug_1277
    rx1779_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1277:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1780_done
    goto rxscan1780_scan
  rxscan1780_loop:
    (rx1779_pos) = rx1779_cur."from"()
    inc rx1779_pos
    rx1779_cur."!cursor_from"(rx1779_pos)
    ge rx1779_pos, rx1779_eos, rxscan1780_done
  rxscan1780_scan:
    set_addr $I10, rxscan1780_loop
    rx1779_cur."!mark_push"(0, rx1779_pos, $I10)
  rxscan1780_done:
.annotate 'line', 880
  # rx subcapture "sym"
    set_addr $I10, rxcap_1781_fail
    rx1779_cur."!mark_push"(0, rx1779_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1779_pos, 3
    gt $I11, rx1779_eos, rx1779_fail
    sub $I11, rx1779_pos, rx1779_off
    substr $S10, rx1779_tgt, $I11, 3
    ne $S10, "sub", rx1779_fail
    add rx1779_pos, 3
    set_addr $I10, rxcap_1781_fail
    ($I12, $I11) = rx1779_cur."!mark_peek"($I10)
    rx1779_cur."!cursor_pos"($I11)
    ($P10) = rx1779_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1779_pos, "")
    rx1779_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1781_done
  rxcap_1781_fail:
    goto rx1779_fail
  rxcap_1781_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1779_cur."!cursor_pos"(rx1779_pos)
    $P10 = rx1779_cur."routine_def"()
    unless $P10, rx1779_fail
    rx1779_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1779_pos = $P10."pos"()
  # rx pass
    rx1779_cur."!cursor_pass"(rx1779_pos, "routine_declarator:sym<sub>")
    if_null rx1779_debug, debug_1278
    rx1779_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1779_pos)
  debug_1278:
    .return (rx1779_cur)
  rx1779_restart:
.annotate 'line', 469
    if_null rx1779_debug, debug_1279
    rx1779_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1279:
  rx1779_fail:
    (rx1779_rep, rx1779_pos, $I10, $P10) = rx1779_cur."!mark_fail"(0)
    lt rx1779_pos, -1, rx1779_done
    eq rx1779_pos, -1, rx1779_fail
    jump $I10
  rx1779_done:
    rx1779_cur."!cursor_fail"()
    if_null rx1779_debug, debug_1280
    rx1779_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1280:
    .return (rx1779_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("212_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("213_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1784_tgt
    .local int rx1784_pos
    .local int rx1784_off
    .local int rx1784_eos
    .local int rx1784_rep
    .local pmc rx1784_cur
    .local pmc rx1784_debug
    (rx1784_cur, rx1784_pos, rx1784_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1784_cur
    .local pmc match
    .lex "$/", match
    length rx1784_eos, rx1784_tgt
    gt rx1784_pos, rx1784_eos, rx1784_done
    set rx1784_off, 0
    lt rx1784_pos, 2, rx1784_start
    sub rx1784_off, rx1784_pos, 1
    substr rx1784_tgt, rx1784_tgt, rx1784_off
  rx1784_start:
    eq $I10, 1, rx1784_restart
    if_null rx1784_debug, debug_1281
    rx1784_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1281:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1785_done
    goto rxscan1785_scan
  rxscan1785_loop:
    (rx1784_pos) = rx1784_cur."from"()
    inc rx1784_pos
    rx1784_cur."!cursor_from"(rx1784_pos)
    ge rx1784_pos, rx1784_eos, rxscan1785_done
  rxscan1785_scan:
    set_addr $I10, rxscan1785_loop
    rx1784_cur."!mark_push"(0, rx1784_pos, $I10)
  rxscan1785_done:
.annotate 'line', 881
  # rx subcapture "sym"
    set_addr $I10, rxcap_1786_fail
    rx1784_cur."!mark_push"(0, rx1784_pos, $I10)
  # rx literal  "method"
    add $I11, rx1784_pos, 6
    gt $I11, rx1784_eos, rx1784_fail
    sub $I11, rx1784_pos, rx1784_off
    substr $S10, rx1784_tgt, $I11, 6
    ne $S10, "method", rx1784_fail
    add rx1784_pos, 6
    set_addr $I10, rxcap_1786_fail
    ($I12, $I11) = rx1784_cur."!mark_peek"($I10)
    rx1784_cur."!cursor_pos"($I11)
    ($P10) = rx1784_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1784_pos, "")
    rx1784_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1786_done
  rxcap_1786_fail:
    goto rx1784_fail
  rxcap_1786_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1784_cur."!cursor_pos"(rx1784_pos)
    $P10 = rx1784_cur."method_def"()
    unless $P10, rx1784_fail
    rx1784_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1784_pos = $P10."pos"()
  # rx pass
    rx1784_cur."!cursor_pass"(rx1784_pos, "routine_declarator:sym<method>")
    if_null rx1784_debug, debug_1282
    rx1784_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1784_pos)
  debug_1282:
    .return (rx1784_cur)
  rx1784_restart:
.annotate 'line', 469
    if_null rx1784_debug, debug_1283
    rx1784_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1283:
  rx1784_fail:
    (rx1784_rep, rx1784_pos, $I10, $P10) = rx1784_cur."!mark_fail"(0)
    lt rx1784_pos, -1, rx1784_done
    eq rx1784_pos, -1, rx1784_fail
    jump $I10
  rx1784_done:
    rx1784_cur."!cursor_fail"()
    if_null rx1784_debug, debug_1284
    rx1784_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1284:
    .return (rx1784_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("214_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("method_def", "method")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("215_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 884
    new $P103, "Undef"
    set $P1789, $P103
    .lex "$*RETURN_USED", $P1789
.annotate 'line', 469
    .local string rx1790_tgt
    .local int rx1790_pos
    .local int rx1790_off
    .local int rx1790_eos
    .local int rx1790_rep
    .local pmc rx1790_cur
    .local pmc rx1790_debug
    (rx1790_cur, rx1790_pos, rx1790_tgt, $I10) = self."!cursor_start"()
    rx1790_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1790_cur
    .local pmc match
    .lex "$/", match
    length rx1790_eos, rx1790_tgt
    gt rx1790_pos, rx1790_eos, rx1790_done
    set rx1790_off, 0
    lt rx1790_pos, 2, rx1790_start
    sub rx1790_off, rx1790_pos, 1
    substr rx1790_tgt, rx1790_tgt, rx1790_off
  rx1790_start:
    eq $I10, 1, rx1790_restart
    if_null rx1790_debug, debug_1285
    rx1790_cur."!cursor_debug"("START", "routine_def")
  debug_1285:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1791_done
    goto rxscan1791_scan
  rxscan1791_loop:
    (rx1790_pos) = rx1790_cur."from"()
    inc rx1790_pos
    rx1790_cur."!cursor_from"(rx1790_pos)
    ge rx1790_pos, rx1790_eos, rxscan1791_done
  rxscan1791_scan:
    set_addr $I10, rxscan1791_loop
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  rxscan1791_done:
.annotate 'line', 883
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
.annotate 'line', 884
    rx1790_cur."!cursor_pos"(rx1790_pos)
    new $P105, "Float"
    assign $P105, 0
    store_lex "$*RETURN_USED", $P105
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
.annotate 'line', 885
  # rx rxquantr1792 ** 0..1
    set_addr $I10, rxquantr1792_done
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  rxquantr1792_loop:
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1794_fail
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  # rx rxquantr1793 ** 0..1
    set_addr $I10, rxquantr1793_done
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  rxquantr1793_loop:
  # rx literal  "&"
    add $I11, rx1790_pos, 1
    gt $I11, rx1790_eos, rx1790_fail
    sub $I11, rx1790_pos, rx1790_off
    ord $I11, rx1790_tgt, $I11
    ne $I11, 38, rx1790_fail
    add rx1790_pos, 1
    set_addr $I10, rxquantr1793_done
    (rx1790_rep) = rx1790_cur."!mark_commit"($I10)
  rxquantr1793_done:
    set_addr $I10, rxcap_1794_fail
    ($I12, $I11) = rx1790_cur."!mark_peek"($I10)
    rx1790_cur."!cursor_pos"($I11)
    ($P10) = rx1790_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1790_pos, "")
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1794_done
  rxcap_1794_fail:
    goto rx1790_fail
  rxcap_1794_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."deflongname"()
    unless $P10, rx1790_fail
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
    set_addr $I10, rxquantr1792_done
    (rx1790_rep) = rx1790_cur."!mark_commit"($I10)
  rxquantr1792_done:
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
.annotate 'line', 886
  # rx subrule "newpad" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."newpad"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  alt1795_0:
.annotate 'line', 887
    set_addr $I10, alt1795_1
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1790_pos, 1
    gt $I11, rx1790_eos, rx1790_fail
    sub $I11, rx1790_pos, rx1790_off
    ord $I11, rx1790_tgt, $I11
    ne $I11, 40, rx1790_fail
    add rx1790_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."signature"()
    unless $P10, rx1790_fail
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1790_pos, 1
    gt $I11, rx1790_eos, rx1790_fail
    sub $I11, rx1790_pos, rx1790_off
    ord $I11, rx1790_tgt, $I11
    ne $I11, 41, rx1790_fail
    add rx1790_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
    goto alt1795_end
  alt1795_1:
.annotate 'line', 888
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  alt1795_end:
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
.annotate 'line', 889
  # rx rxquantr1796 ** 0..*
    set_addr $I10, rxquantr1796_done
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
  rxquantr1796_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."trait"()
    unless $P10, rx1790_fail
    goto rxsubrule1797_pass
  rxsubrule1797_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1790_fail
  rxsubrule1797_pass:
    set_addr $I10, rxsubrule1797_back
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1790_pos = $P10."pos"()
    set_addr $I10, rxquantr1796_done
    (rx1790_rep) = rx1790_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1796_done
    rx1790_cur."!mark_push"(rx1790_rep, rx1790_pos, $I10)
    goto rxquantr1796_loop
  rxquantr1796_done:
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  alt1798_0:
.annotate 'line', 890
    set_addr $I10, alt1798_1
    rx1790_cur."!mark_push"(0, rx1790_pos, $I10)
.annotate 'line', 891
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."onlystar"()
    unless $P10, rx1790_fail
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
    goto alt1798_end
  alt1798_1:
.annotate 'line', 892
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."blockoid"()
    unless $P10, rx1790_fail
    rx1790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1790_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
  alt1798_end:
.annotate 'line', 893
  # rx subrule "ws" subtype=method negate=
    rx1790_cur."!cursor_pos"(rx1790_pos)
    $P10 = rx1790_cur."ws"()
    unless $P10, rx1790_fail
    rx1790_pos = $P10."pos"()
.annotate 'line', 883
  # rx pass
    rx1790_cur."!cursor_pass"(rx1790_pos, "routine_def")
    if_null rx1790_debug, debug_1286
    rx1790_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1790_pos)
  debug_1286:
    .return (rx1790_cur)
  rx1790_restart:
.annotate 'line', 469
    if_null rx1790_debug, debug_1287
    rx1790_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1287:
  rx1790_fail:
    (rx1790_rep, rx1790_pos, $I10, $P10) = rx1790_cur."!mark_fail"(0)
    lt rx1790_pos, -1, rx1790_done
    eq rx1790_pos, -1, rx1790_fail
    jump $I10
  rx1790_done:
    rx1790_cur."!cursor_fail"()
    if_null rx1790_debug, debug_1288
    rx1790_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1288:
    .return (rx1790_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("216_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P124 = self."!PREFIX__!subrule"("ws", "")
    new $P125, "ResizablePMCArray"
    push $P125, $P124
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("217_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1811 = "218_1321350766.1143" 
    capture_lex $P1811
.annotate 'line', 897
    new $P103, "Undef"
    set $P1801, $P103
    .lex "$*RETURN_USED", $P1801
.annotate 'line', 898
    new $P104, "Undef"
    set $P1802, $P104
    .lex "$*INVOCANT_OK", $P1802
.annotate 'line', 469
    .local string rx1803_tgt
    .local int rx1803_pos
    .local int rx1803_off
    .local int rx1803_eos
    .local int rx1803_rep
    .local pmc rx1803_cur
    .local pmc rx1803_debug
    (rx1803_cur, rx1803_pos, rx1803_tgt, $I10) = self."!cursor_start"()
    rx1803_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1803_cur
    .local pmc match
    .lex "$/", match
    length rx1803_eos, rx1803_tgt
    gt rx1803_pos, rx1803_eos, rx1803_done
    set rx1803_off, 0
    lt rx1803_pos, 2, rx1803_start
    sub rx1803_off, rx1803_pos, 1
    substr rx1803_tgt, rx1803_tgt, rx1803_off
  rx1803_start:
    eq $I10, 1, rx1803_restart
    if_null rx1803_debug, debug_1289
    rx1803_cur."!cursor_debug"("START", "method_def")
  debug_1289:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1804_done
    goto rxscan1804_scan
  rxscan1804_loop:
    (rx1803_pos) = rx1803_cur."from"()
    inc rx1803_pos
    rx1803_cur."!cursor_from"(rx1803_pos)
    ge rx1803_pos, rx1803_eos, rxscan1804_done
  rxscan1804_scan:
    set_addr $I10, rxscan1804_loop
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
  rxscan1804_done:
.annotate 'line', 896
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 897
    rx1803_cur."!cursor_pos"(rx1803_pos)
    new $P106, "Float"
    assign $P106, 0
    store_lex "$*RETURN_USED", $P106
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 898
    rx1803_cur."!cursor_pos"(rx1803_pos)
    new $P108, "Float"
    assign $P108, 1
    store_lex "$*INVOCANT_OK", $P108
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 899
  # rx subcapture "private"
    set_addr $I10, rxcap_1806_fail
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
  # rx rxquantr1805 ** 0..1
    set_addr $I10, rxquantr1805_done
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
  rxquantr1805_loop:
  # rx literal  "!"
    add $I11, rx1803_pos, 1
    gt $I11, rx1803_eos, rx1803_fail
    sub $I11, rx1803_pos, rx1803_off
    ord $I11, rx1803_tgt, $I11
    ne $I11, 33, rx1803_fail
    add rx1803_pos, 1
    set_addr $I10, rxquantr1805_done
    (rx1803_rep) = rx1803_cur."!mark_commit"($I10)
  rxquantr1805_done:
    set_addr $I10, rxcap_1806_fail
    ($I12, $I11) = rx1803_cur."!mark_peek"($I10)
    rx1803_cur."!cursor_pos"($I11)
    ($P10) = rx1803_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1803_pos, "")
    rx1803_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1806_done
  rxcap_1806_fail:
    goto rx1803_fail
  rxcap_1806_done:
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 900
  # rx rxquantr1807 ** 0..1
    set_addr $I10, rxquantr1807_done
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
  rxquantr1807_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."deflongname"()
    unless $P10, rx1803_fail
    goto rxsubrule1808_pass
  rxsubrule1808_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1803_fail
  rxsubrule1808_pass:
    set_addr $I10, rxsubrule1808_back
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1803_pos = $P10."pos"()
    set_addr $I10, rxquantr1807_done
    (rx1803_rep) = rx1803_cur."!mark_commit"($I10)
  rxquantr1807_done:
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 901
  # rx subrule "newpad" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."newpad"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  alt1809_0:
.annotate 'line', 902
    set_addr $I10, alt1809_1
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1803_pos, 1
    gt $I11, rx1803_eos, rx1803_fail
    sub $I11, rx1803_pos, rx1803_off
    ord $I11, rx1803_tgt, $I11
    ne $I11, 40, rx1803_fail
    add rx1803_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."signature"()
    unless $P10, rx1803_fail
    rx1803_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1803_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1803_pos, 1
    gt $I11, rx1803_eos, rx1803_fail
    sub $I11, rx1803_pos, rx1803_off
    ord $I11, rx1803_tgt, $I11
    ne $I11, 41, rx1803_fail
    add rx1803_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
    goto alt1809_end
  alt1809_1:
.annotate 'line', 903
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  alt1809_end:
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 904
    rx1803_cur."!cursor_pos"(rx1803_pos)
    find_lex $P120, unicode:"$\x{a2}"
    $P121 = $P120."MATCH"()
    store_lex "$/", $P121
    .const 'Sub' $P1811 = "218_1321350766.1143" 
    capture_lex $P1811
    $P123 = $P1811()
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 905
  # rx rxquantr1812 ** 0..*
    set_addr $I10, rxquantr1812_done
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
  rxquantr1812_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."trait"()
    unless $P10, rx1803_fail
    goto rxsubrule1813_pass
  rxsubrule1813_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1803_fail
  rxsubrule1813_pass:
    set_addr $I10, rxsubrule1813_back
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1803_pos = $P10."pos"()
    set_addr $I10, rxquantr1812_done
    (rx1803_rep) = rx1803_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1812_done
    rx1803_cur."!mark_push"(rx1803_rep, rx1803_pos, $I10)
    goto rxquantr1812_loop
  rxquantr1812_done:
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  alt1814_0:
.annotate 'line', 906
    set_addr $I10, alt1814_1
    rx1803_cur."!mark_push"(0, rx1803_pos, $I10)
.annotate 'line', 907
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."onlystar"()
    unless $P10, rx1803_fail
    rx1803_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1803_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
    goto alt1814_end
  alt1814_1:
.annotate 'line', 908
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."blockoid"()
    unless $P10, rx1803_fail
    rx1803_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1803_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
  alt1814_end:
.annotate 'line', 909
  # rx subrule "ws" subtype=method negate=
    rx1803_cur."!cursor_pos"(rx1803_pos)
    $P10 = rx1803_cur."ws"()
    unless $P10, rx1803_fail
    rx1803_pos = $P10."pos"()
.annotate 'line', 896
  # rx pass
    rx1803_cur."!cursor_pass"(rx1803_pos, "method_def")
    if_null rx1803_debug, debug_1290
    rx1803_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1803_pos)
  debug_1290:
    .return (rx1803_cur)
  rx1803_restart:
.annotate 'line', 469
    if_null rx1803_debug, debug_1291
    rx1803_cur."!cursor_debug"("NEXT", "method_def")
  debug_1291:
  rx1803_fail:
    (rx1803_rep, rx1803_pos, $I10, $P10) = rx1803_cur."!mark_fail"(0)
    lt rx1803_pos, -1, rx1803_done
    eq rx1803_pos, -1, rx1803_fail
    jump $I10
  rx1803_done:
    rx1803_cur."!cursor_fail"()
    if_null rx1803_debug, debug_1292
    rx1803_cur."!cursor_debug"("FAIL", "method_def")
  debug_1292:
    .return (rx1803_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1810"  :anon :subid("218_1321350766.1143") :outer("217_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 904
    new $P122, "Float"
    assign $P122, 0
    store_dynamic_lex "$*INVOCANT_OK", $P122
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("219_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("220_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1820 = "221_1321350766.1143" 
    capture_lex $P1820
    .local string rx1817_tgt
    .local int rx1817_pos
    .local int rx1817_off
    .local int rx1817_eos
    .local int rx1817_rep
    .local pmc rx1817_cur
    .local pmc rx1817_debug
    (rx1817_cur, rx1817_pos, rx1817_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1817_cur
    .local pmc match
    .lex "$/", match
    length rx1817_eos, rx1817_tgt
    gt rx1817_pos, rx1817_eos, rx1817_done
    set rx1817_off, 0
    lt rx1817_pos, 2, rx1817_start
    sub rx1817_off, rx1817_pos, 1
    substr rx1817_tgt, rx1817_tgt, rx1817_off
  rx1817_start:
    eq $I10, 1, rx1817_restart
    if_null rx1817_debug, debug_1293
    rx1817_cur."!cursor_debug"("START", "onlystar")
  debug_1293:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1818_done
    goto rxscan1818_scan
  rxscan1818_loop:
    (rx1817_pos) = rx1817_cur."from"()
    inc rx1817_pos
    rx1817_cur."!cursor_from"(rx1817_pos)
    ge rx1817_pos, rx1817_eos, rxscan1818_done
  rxscan1818_scan:
    set_addr $I10, rxscan1818_loop
    rx1817_cur."!mark_push"(0, rx1817_pos, $I10)
  rxscan1818_done:
.annotate 'line', 913
    rx1817_cur."!cursor_pos"(rx1817_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1820 = "221_1321350766.1143" 
    capture_lex $P1820
    $P105 = $P1820()
    unless $P105, rx1817_fail
.annotate 'line', 914
  # rx literal  "{"
    add $I11, rx1817_pos, 1
    gt $I11, rx1817_eos, rx1817_fail
    sub $I11, rx1817_pos, rx1817_off
    ord $I11, rx1817_tgt, $I11
    ne $I11, 123, rx1817_fail
    add rx1817_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1817_cur."!cursor_pos"(rx1817_pos)
    $P10 = rx1817_cur."ws"()
    unless $P10, rx1817_fail
    rx1817_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1817_pos, 1
    gt $I11, rx1817_eos, rx1817_fail
    sub $I11, rx1817_pos, rx1817_off
    ord $I11, rx1817_tgt, $I11
    ne $I11, 42, rx1817_fail
    add rx1817_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1817_cur."!cursor_pos"(rx1817_pos)
    $P10 = rx1817_cur."ws"()
    unless $P10, rx1817_fail
    rx1817_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1817_pos, 1
    gt $I11, rx1817_eos, rx1817_fail
    sub $I11, rx1817_pos, rx1817_off
    ord $I11, rx1817_tgt, $I11
    ne $I11, 125, rx1817_fail
    add rx1817_pos, 1
.annotate 'line', 915
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1817_cur."!cursor_pos"(rx1817_pos)
    $P10 = rx1817_cur."ENDSTMT"()
    unless $P10, rx1817_fail
.annotate 'line', 916
  # rx subrule "finishpad" subtype=method negate=
    rx1817_cur."!cursor_pos"(rx1817_pos)
    $P10 = rx1817_cur."finishpad"()
    unless $P10, rx1817_fail
    rx1817_pos = $P10."pos"()
.annotate 'line', 912
  # rx pass
    rx1817_cur."!cursor_pass"(rx1817_pos, "onlystar")
    if_null rx1817_debug, debug_1296
    rx1817_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1817_pos)
  debug_1296:
    .return (rx1817_cur)
  rx1817_restart:
.annotate 'line', 469
    if_null rx1817_debug, debug_1297
    rx1817_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1297:
  rx1817_fail:
    (rx1817_rep, rx1817_pos, $I10, $P10) = rx1817_cur."!mark_fail"(0)
    lt rx1817_pos, -1, rx1817_done
    eq rx1817_pos, -1, rx1817_fail
    jump $I10
  rx1817_done:
    rx1817_cur."!cursor_fail"()
    if_null rx1817_debug, debug_1298
    rx1817_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1298:
    .return (rx1817_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1819"  :anon :subid("221_1321350766.1143") :outer("220_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 913
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1294
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1295
    die "Contextual $*MULTINESS not found"
  vivify_1295:
  vivify_1294:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("222_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("223_1321350766.1143")
    .param pmc param_1823
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 919
    .lex "self", param_1823
    $P103 = param_1823."!protoregex"("multi_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("224_1321350766.1143")
    .param pmc param_1825
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 919
    .lex "self", param_1825
    $P104 = param_1825."!PREFIX__!protoregex"("multi_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("225_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 921
    new $P103, "Undef"
    set $P1827, $P103
    .lex "$*MULTINESS", $P1827
.annotate 'line', 469
    .local string rx1828_tgt
    .local int rx1828_pos
    .local int rx1828_off
    .local int rx1828_eos
    .local int rx1828_rep
    .local pmc rx1828_cur
    .local pmc rx1828_debug
    (rx1828_cur, rx1828_pos, rx1828_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1828_cur
    .local pmc match
    .lex "$/", match
    length rx1828_eos, rx1828_tgt
    gt rx1828_pos, rx1828_eos, rx1828_done
    set rx1828_off, 0
    lt rx1828_pos, 2, rx1828_start
    sub rx1828_off, rx1828_pos, 1
    substr rx1828_tgt, rx1828_tgt, rx1828_off
  rx1828_start:
    eq $I10, 1, rx1828_restart
    if_null rx1828_debug, debug_1299
    rx1828_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1829_done
    goto rxscan1829_scan
  rxscan1829_loop:
    (rx1828_pos) = rx1828_cur."from"()
    inc rx1828_pos
    rx1828_cur."!cursor_from"(rx1828_pos)
    ge rx1828_pos, rx1828_eos, rxscan1829_done
  rxscan1829_scan:
    set_addr $I10, rxscan1829_loop
    rx1828_cur."!mark_push"(0, rx1828_pos, $I10)
  rxscan1829_done:
.annotate 'line', 921
    rx1828_cur."!cursor_pos"(rx1828_pos)
    new $P104, "String"
    assign $P104, "multi"
    store_lex "$*MULTINESS", $P104
.annotate 'line', 922
  # rx subcapture "sym"
    set_addr $I10, rxcap_1830_fail
    rx1828_cur."!mark_push"(0, rx1828_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1828_pos, 5
    gt $I11, rx1828_eos, rx1828_fail
    sub $I11, rx1828_pos, rx1828_off
    substr $S10, rx1828_tgt, $I11, 5
    ne $S10, "multi", rx1828_fail
    add rx1828_pos, 5
    set_addr $I10, rxcap_1830_fail
    ($I12, $I11) = rx1828_cur."!mark_peek"($I10)
    rx1828_cur."!cursor_pos"($I11)
    ($P10) = rx1828_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1828_pos, "")
    rx1828_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1830_done
  rxcap_1830_fail:
    goto rx1828_fail
  rxcap_1830_done:
.annotate 'line', 923
  # rx subrule "ws" subtype=method negate=
    rx1828_cur."!cursor_pos"(rx1828_pos)
    $P10 = rx1828_cur."ws"()
    unless $P10, rx1828_fail
    rx1828_pos = $P10."pos"()
  alt1831_0:
    set_addr $I10, alt1831_1
    rx1828_cur."!mark_push"(0, rx1828_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1828_cur."!cursor_pos"(rx1828_pos)
    $P10 = rx1828_cur."declarator"()
    unless $P10, rx1828_fail
    rx1828_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1828_pos = $P10."pos"()
    goto alt1831_end
  alt1831_1:
    set_addr $I10, alt1831_2
    rx1828_cur."!mark_push"(0, rx1828_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1828_cur."!cursor_pos"(rx1828_pos)
    $P10 = rx1828_cur."routine_def"()
    unless $P10, rx1828_fail
    rx1828_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1828_pos = $P10."pos"()
    goto alt1831_end
  alt1831_2:
  # rx subrule "panic" subtype=method negate=
    rx1828_cur."!cursor_pos"(rx1828_pos)
    $P10 = rx1828_cur."panic"("Malformed multi")
    unless $P10, rx1828_fail
    rx1828_pos = $P10."pos"()
  alt1831_end:
.annotate 'line', 920
  # rx pass
    rx1828_cur."!cursor_pass"(rx1828_pos, "multi_declarator:sym<multi>")
    if_null rx1828_debug, debug_1300
    rx1828_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1828_pos)
  debug_1300:
    .return (rx1828_cur)
  rx1828_restart:
.annotate 'line', 469
    if_null rx1828_debug, debug_1301
    rx1828_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1301:
  rx1828_fail:
    (rx1828_rep, rx1828_pos, $I10, $P10) = rx1828_cur."!mark_fail"(0)
    lt rx1828_pos, -1, rx1828_done
    eq rx1828_pos, -1, rx1828_fail
    jump $I10
  rx1828_done:
    rx1828_cur."!cursor_fail"()
    if_null rx1828_debug, debug_1302
    rx1828_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1302:
    .return (rx1828_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("226_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "multi")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("227_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 926
    new $P103, "Undef"
    set $P1834, $P103
    .lex "$*MULTINESS", $P1834
.annotate 'line', 469
    .local string rx1835_tgt
    .local int rx1835_pos
    .local int rx1835_off
    .local int rx1835_eos
    .local int rx1835_rep
    .local pmc rx1835_cur
    .local pmc rx1835_debug
    (rx1835_cur, rx1835_pos, rx1835_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1835_cur
    .local pmc match
    .lex "$/", match
    length rx1835_eos, rx1835_tgt
    gt rx1835_pos, rx1835_eos, rx1835_done
    set rx1835_off, 0
    lt rx1835_pos, 2, rx1835_start
    sub rx1835_off, rx1835_pos, 1
    substr rx1835_tgt, rx1835_tgt, rx1835_off
  rx1835_start:
    eq $I10, 1, rx1835_restart
    if_null rx1835_debug, debug_1303
    rx1835_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1836_done
    goto rxscan1836_scan
  rxscan1836_loop:
    (rx1835_pos) = rx1835_cur."from"()
    inc rx1835_pos
    rx1835_cur."!cursor_from"(rx1835_pos)
    ge rx1835_pos, rx1835_eos, rxscan1836_done
  rxscan1836_scan:
    set_addr $I10, rxscan1836_loop
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxscan1836_done:
.annotate 'line', 926
    rx1835_cur."!cursor_pos"(rx1835_pos)
    new $P104, "String"
    assign $P104, "proto"
    store_lex "$*MULTINESS", $P104
.annotate 'line', 927
  # rx subcapture "sym"
    set_addr $I10, rxcap_1837_fail
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1835_pos, 5
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    substr $S10, rx1835_tgt, $I11, 5
    ne $S10, "proto", rx1835_fail
    add rx1835_pos, 5
    set_addr $I10, rxcap_1837_fail
    ($I12, $I11) = rx1835_cur."!mark_peek"($I10)
    rx1835_cur."!cursor_pos"($I11)
    ($P10) = rx1835_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1835_pos, "")
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1837_done
  rxcap_1837_fail:
    goto rx1835_fail
  rxcap_1837_done:
.annotate 'line', 928
  # rx subrule "ws" subtype=method negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."ws"()
    unless $P10, rx1835_fail
    rx1835_pos = $P10."pos"()
  alt1838_0:
    set_addr $I10, alt1838_1
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."declarator"()
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1835_pos = $P10."pos"()
    goto alt1838_end
  alt1838_1:
    set_addr $I10, alt1838_2
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."routine_def"()
    unless $P10, rx1835_fail
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1835_pos = $P10."pos"()
    goto alt1838_end
  alt1838_2:
  # rx subrule "panic" subtype=method negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."panic"("Malformed proto")
    unless $P10, rx1835_fail
    rx1835_pos = $P10."pos"()
  alt1838_end:
.annotate 'line', 925
  # rx pass
    rx1835_cur."!cursor_pass"(rx1835_pos, "multi_declarator:sym<proto>")
    if_null rx1835_debug, debug_1304
    rx1835_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1835_pos)
  debug_1304:
    .return (rx1835_cur)
  rx1835_restart:
.annotate 'line', 469
    if_null rx1835_debug, debug_1305
    rx1835_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1305:
  rx1835_fail:
    (rx1835_rep, rx1835_pos, $I10, $P10) = rx1835_cur."!mark_fail"(0)
    lt rx1835_pos, -1, rx1835_done
    eq rx1835_pos, -1, rx1835_fail
    jump $I10
  rx1835_done:
    rx1835_cur."!cursor_fail"()
    if_null rx1835_debug, debug_1306
    rx1835_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1306:
    .return (rx1835_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("228_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "proto")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("229_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 931
    new $P103, "Undef"
    set $P1841, $P103
    .lex "$*MULTINESS", $P1841
.annotate 'line', 469
    .local string rx1842_tgt
    .local int rx1842_pos
    .local int rx1842_off
    .local int rx1842_eos
    .local int rx1842_rep
    .local pmc rx1842_cur
    .local pmc rx1842_debug
    (rx1842_cur, rx1842_pos, rx1842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1842_cur
    .local pmc match
    .lex "$/", match
    length rx1842_eos, rx1842_tgt
    gt rx1842_pos, rx1842_eos, rx1842_done
    set rx1842_off, 0
    lt rx1842_pos, 2, rx1842_start
    sub rx1842_off, rx1842_pos, 1
    substr rx1842_tgt, rx1842_tgt, rx1842_off
  rx1842_start:
    eq $I10, 1, rx1842_restart
    if_null rx1842_debug, debug_1307
    rx1842_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1843_done
    goto rxscan1843_scan
  rxscan1843_loop:
    (rx1842_pos) = rx1842_cur."from"()
    inc rx1842_pos
    rx1842_cur."!cursor_from"(rx1842_pos)
    ge rx1842_pos, rx1842_eos, rxscan1843_done
  rxscan1843_scan:
    set_addr $I10, rxscan1843_loop
    rx1842_cur."!mark_push"(0, rx1842_pos, $I10)
  rxscan1843_done:
.annotate 'line', 931
    rx1842_cur."!cursor_pos"(rx1842_pos)
    new $P104, "String"
    assign $P104, ""
    store_lex "$*MULTINESS", $P104
.annotate 'line', 932
  # rx subrule "declarator" subtype=capture negate=
    rx1842_cur."!cursor_pos"(rx1842_pos)
    $P10 = rx1842_cur."declarator"()
    unless $P10, rx1842_fail
    rx1842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1842_pos = $P10."pos"()
.annotate 'line', 930
  # rx pass
    rx1842_cur."!cursor_pass"(rx1842_pos, "multi_declarator:sym<null>")
    if_null rx1842_debug, debug_1308
    rx1842_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1842_pos)
  debug_1308:
    .return (rx1842_cur)
  rx1842_restart:
.annotate 'line', 469
    if_null rx1842_debug, debug_1309
    rx1842_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1309:
  rx1842_fail:
    (rx1842_rep, rx1842_pos, $I10, $P10) = rx1842_cur."!mark_fail"(0)
    lt rx1842_pos, -1, rx1842_done
    eq rx1842_pos, -1, rx1842_fail
    jump $I10
  rx1842_done:
    rx1842_cur."!cursor_fail"()
    if_null rx1842_debug, debug_1310
    rx1842_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1310:
    .return (rx1842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("230_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("declarator", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("231_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1850 = "232_1321350766.1143" 
    capture_lex $P1850
    .local string rx1846_tgt
    .local int rx1846_pos
    .local int rx1846_off
    .local int rx1846_eos
    .local int rx1846_rep
    .local pmc rx1846_cur
    .local pmc rx1846_debug
    (rx1846_cur, rx1846_pos, rx1846_tgt, $I10) = self."!cursor_start"()
    rx1846_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1846_cur
    .local pmc match
    .lex "$/", match
    length rx1846_eos, rx1846_tgt
    gt rx1846_pos, rx1846_eos, rx1846_done
    set rx1846_off, 0
    lt rx1846_pos, 2, rx1846_start
    sub rx1846_off, rx1846_pos, 1
    substr rx1846_tgt, rx1846_tgt, rx1846_off
  rx1846_start:
    eq $I10, 1, rx1846_restart
    if_null rx1846_debug, debug_1311
    rx1846_cur."!cursor_debug"("START", "signature")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1847_done
    goto rxscan1847_scan
  rxscan1847_loop:
    (rx1846_pos) = rx1846_cur."from"()
    inc rx1846_pos
    rx1846_cur."!cursor_from"(rx1846_pos)
    ge rx1846_pos, rx1846_eos, rxscan1847_done
  rxscan1847_scan:
    set_addr $I10, rxscan1847_loop
    rx1846_cur."!mark_push"(0, rx1846_pos, $I10)
  rxscan1847_done:
.annotate 'line', 936
  # rx rxquantr1848 ** 0..1
    set_addr $I10, rxquantr1848_done
    rx1846_cur."!mark_push"(0, rx1846_pos, $I10)
  rxquantr1848_loop:
    rx1846_cur."!cursor_pos"(rx1846_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1850 = "232_1321350766.1143" 
    capture_lex $P1850
    $P105 = $P1850()
    unless $P105, rx1846_fail
  # rx subrule "ws" subtype=method negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."ws"()
    unless $P10, rx1846_fail
    rx1846_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."parameter"()
    unless $P10, rx1846_fail
    rx1846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1846_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."ws"()
    unless $P10, rx1846_fail
    rx1846_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1846_pos, 1
    gt $I11, rx1846_eos, rx1846_fail
    sub $I11, rx1846_pos, rx1846_off
    ord $I11, rx1846_tgt, $I11
    ne $I11, 58, rx1846_fail
    add rx1846_pos, 1
    set_addr $I10, rxquantr1848_done
    (rx1846_rep) = rx1846_cur."!mark_commit"($I10)
  rxquantr1848_done:
.annotate 'line', 937
  # rx rxquantr1851 ** 0..1
    set_addr $I10, rxquantr1851_done
    rx1846_cur."!mark_push"(0, rx1846_pos, $I10)
  rxquantr1851_loop:
  # rx rxquantr1852 ** 1..*
    set_addr $I10, rxquantr1852_done
    rx1846_cur."!mark_push"(0, -1, $I10)
  rxquantr1852_loop:
  # rx subrule "ws" subtype=method negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."ws"()
    unless $P10, rx1846_fail
    rx1846_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."parameter"()
    unless $P10, rx1846_fail
    rx1846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1846_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1846_cur."!cursor_pos"(rx1846_pos)
    $P10 = rx1846_cur."ws"()
    unless $P10, rx1846_fail
    rx1846_pos = $P10."pos"()
    set_addr $I10, rxquantr1852_done
    (rx1846_rep) = rx1846_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1852_done
    rx1846_cur."!mark_push"(rx1846_rep, rx1846_pos, $I10)
  # rx literal  ","
    add $I11, rx1846_pos, 1
    gt $I11, rx1846_eos, rx1846_fail
    sub $I11, rx1846_pos, rx1846_off
    ord $I11, rx1846_tgt, $I11
    ne $I11, 44, rx1846_fail
    add rx1846_pos, 1
    goto rxquantr1852_loop
  rxquantr1852_done:
    set_addr $I10, rxquantr1851_done
    (rx1846_rep) = rx1846_cur."!mark_commit"($I10)
  rxquantr1851_done:
.annotate 'line', 935
  # rx pass
    rx1846_cur."!cursor_pass"(rx1846_pos, "signature")
    if_null rx1846_debug, debug_1314
    rx1846_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1846_pos)
  debug_1314:
    .return (rx1846_cur)
  rx1846_restart:
.annotate 'line', 469
    if_null rx1846_debug, debug_1315
    rx1846_cur."!cursor_debug"("NEXT", "signature")
  debug_1315:
  rx1846_fail:
    (rx1846_rep, rx1846_pos, $I10, $P10) = rx1846_cur."!mark_fail"(0)
    lt rx1846_pos, -1, rx1846_done
    eq rx1846_pos, -1, rx1846_fail
    jump $I10
  rx1846_done:
    rx1846_cur."!cursor_fail"()
    if_null rx1846_debug, debug_1316
    rx1846_cur."!cursor_debug"("FAIL", "signature")
  debug_1316:
    .return (rx1846_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1849"  :anon :subid("232_1321350766.1143") :outer("231_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 936
    find_dynamic_lex $P107, "$*INVOCANT_OK"
    unless_null $P107, vivify_1312
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$INVOCANT_OK"]
    unless_null $P107, vivify_1313
    die "Contextual $*INVOCANT_OK not found"
  vivify_1313:
  vivify_1312:
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("233_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("234_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1855_tgt
    .local int rx1855_pos
    .local int rx1855_off
    .local int rx1855_eos
    .local int rx1855_rep
    .local pmc rx1855_cur
    .local pmc rx1855_debug
    (rx1855_cur, rx1855_pos, rx1855_tgt, $I10) = self."!cursor_start"()
    rx1855_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1855_cur
    .local pmc match
    .lex "$/", match
    length rx1855_eos, rx1855_tgt
    gt rx1855_pos, rx1855_eos, rx1855_done
    set rx1855_off, 0
    lt rx1855_pos, 2, rx1855_start
    sub rx1855_off, rx1855_pos, 1
    substr rx1855_tgt, rx1855_tgt, rx1855_off
  rx1855_start:
    eq $I10, 1, rx1855_restart
    if_null rx1855_debug, debug_1317
    rx1855_cur."!cursor_debug"("START", "parameter")
  debug_1317:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1856_done
    goto rxscan1856_scan
  rxscan1856_loop:
    (rx1855_pos) = rx1855_cur."from"()
    inc rx1855_pos
    rx1855_cur."!cursor_from"(rx1855_pos)
    ge rx1855_pos, rx1855_eos, rxscan1856_done
  rxscan1856_scan:
    set_addr $I10, rxscan1856_loop
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  rxscan1856_done:
.annotate 'line', 941
  # rx rxquantr1857 ** 0..*
    set_addr $I10, rxquantr1857_done
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  rxquantr1857_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."typename"()
    unless $P10, rx1855_fail
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1855_pos = $P10."pos"()
  # rx rxquantr1858 ** 0..1
    set_addr $I10, rxquantr1858_done
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  rxquantr1858_loop:
  # rx literal  ":"
    add $I11, rx1855_pos, 1
    gt $I11, rx1855_eos, rx1855_fail
    sub $I11, rx1855_pos, rx1855_off
    ord $I11, rx1855_tgt, $I11
    ne $I11, 58, rx1855_fail
    add rx1855_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1859_fail
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1855_pos, rx1855_eos, rx1855_fail
    sub $I10, rx1855_pos, rx1855_off
    substr $S10, rx1855_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1855_fail
    inc rx1855_pos
    set_addr $I10, rxcap_1859_fail
    ($I12, $I11) = rx1855_cur."!mark_peek"($I10)
    rx1855_cur."!cursor_pos"($I11)
    ($P10) = rx1855_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1855_pos, "")
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1859_done
  rxcap_1859_fail:
    goto rx1855_fail
  rxcap_1859_done:
    set_addr $I10, rxquantr1858_done
    (rx1855_rep) = rx1855_cur."!mark_commit"($I10)
  rxquantr1858_done:
  # rx subrule "ws" subtype=method negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."ws"()
    unless $P10, rx1855_fail
    rx1855_pos = $P10."pos"()
    set_addr $I10, rxquantr1857_done
    (rx1855_rep) = rx1855_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1857_done
    rx1855_cur."!mark_push"(rx1855_rep, rx1855_pos, $I10)
    goto rxquantr1857_loop
  rxquantr1857_done:
  alt1860_0:
.annotate 'line', 942
    set_addr $I10, alt1860_1
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
.annotate 'line', 943
  # rx subcapture "quant"
    set_addr $I10, rxcap_1861_fail
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  # rx literal  "*"
    add $I11, rx1855_pos, 1
    gt $I11, rx1855_eos, rx1855_fail
    sub $I11, rx1855_pos, rx1855_off
    ord $I11, rx1855_tgt, $I11
    ne $I11, 42, rx1855_fail
    add rx1855_pos, 1
    set_addr $I10, rxcap_1861_fail
    ($I12, $I11) = rx1855_cur."!mark_peek"($I10)
    rx1855_cur."!cursor_pos"($I11)
    ($P10) = rx1855_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1855_pos, "")
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1861_done
  rxcap_1861_fail:
    goto rx1855_fail
  rxcap_1861_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."param_var"()
    unless $P10, rx1855_fail
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1855_pos = $P10."pos"()
    goto alt1860_end
  alt1860_1:
  alt1862_0:
.annotate 'line', 944
    set_addr $I10, alt1862_1
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."param_var"()
    unless $P10, rx1855_fail
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1855_pos = $P10."pos"()
    goto alt1862_end
  alt1862_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."named_param"()
    unless $P10, rx1855_fail
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1855_pos = $P10."pos"()
  alt1862_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1864_fail
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  alt1863_0:
    set_addr $I10, alt1863_1
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  # rx literal  "?"
    add $I11, rx1855_pos, 1
    gt $I11, rx1855_eos, rx1855_fail
    sub $I11, rx1855_pos, rx1855_off
    ord $I11, rx1855_tgt, $I11
    ne $I11, 63, rx1855_fail
    add rx1855_pos, 1
    goto alt1863_end
  alt1863_1:
    set_addr $I10, alt1863_2
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  # rx literal  "!"
    add $I11, rx1855_pos, 1
    gt $I11, rx1855_eos, rx1855_fail
    sub $I11, rx1855_pos, rx1855_off
    ord $I11, rx1855_tgt, $I11
    ne $I11, 33, rx1855_fail
    add rx1855_pos, 1
    goto alt1863_end
  alt1863_2:
  alt1863_end:
    set_addr $I10, rxcap_1864_fail
    ($I12, $I11) = rx1855_cur."!mark_peek"($I10)
    rx1855_cur."!cursor_pos"($I11)
    ($P10) = rx1855_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1855_pos, "")
    rx1855_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1864_done
  rxcap_1864_fail:
    goto rx1855_fail
  rxcap_1864_done:
  alt1860_end:
.annotate 'line', 946
  # rx rxquantr1865 ** 0..1
    set_addr $I10, rxquantr1865_done
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10)
  rxquantr1865_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1855_cur."!cursor_pos"(rx1855_pos)
    $P10 = rx1855_cur."default_value"()
    unless $P10, rx1855_fail
    goto rxsubrule1866_pass
  rxsubrule1866_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1855_fail
  rxsubrule1866_pass:
    set_addr $I10, rxsubrule1866_back
    rx1855_cur."!mark_push"(0, rx1855_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1855_pos = $P10."pos"()
    set_addr $I10, rxquantr1865_done
    (rx1855_rep) = rx1855_cur."!mark_commit"($I10)
  rxquantr1865_done:
.annotate 'line', 940
  # rx pass
    rx1855_cur."!cursor_pass"(rx1855_pos, "parameter")
    if_null rx1855_debug, debug_1318
    rx1855_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1855_pos)
  debug_1318:
    .return (rx1855_cur)
  rx1855_restart:
.annotate 'line', 469
    if_null rx1855_debug, debug_1319
    rx1855_cur."!cursor_debug"("NEXT", "parameter")
  debug_1319:
  rx1855_fail:
    (rx1855_rep, rx1855_pos, $I10, $P10) = rx1855_cur."!mark_fail"(0)
    lt rx1855_pos, -1, rx1855_done
    eq rx1855_pos, -1, rx1855_fail
    jump $I10
  rx1855_done:
    rx1855_cur."!cursor_fail"()
    if_null rx1855_debug, debug_1320
    rx1855_cur."!cursor_debug"("FAIL", "parameter")
  debug_1320:
    .return (rx1855_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("235_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("236_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1869_tgt
    .local int rx1869_pos
    .local int rx1869_off
    .local int rx1869_eos
    .local int rx1869_rep
    .local pmc rx1869_cur
    .local pmc rx1869_debug
    (rx1869_cur, rx1869_pos, rx1869_tgt, $I10) = self."!cursor_start"()
    rx1869_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1869_cur
    .local pmc match
    .lex "$/", match
    length rx1869_eos, rx1869_tgt
    gt rx1869_pos, rx1869_eos, rx1869_done
    set rx1869_off, 0
    lt rx1869_pos, 2, rx1869_start
    sub rx1869_off, rx1869_pos, 1
    substr rx1869_tgt, rx1869_tgt, rx1869_off
  rx1869_start:
    eq $I10, 1, rx1869_restart
    if_null rx1869_debug, debug_1321
    rx1869_cur."!cursor_debug"("START", "param_var")
  debug_1321:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1870_done
    goto rxscan1870_scan
  rxscan1870_loop:
    (rx1869_pos) = rx1869_cur."from"()
    inc rx1869_pos
    rx1869_cur."!cursor_from"(rx1869_pos)
    ge rx1869_pos, rx1869_eos, rxscan1870_done
  rxscan1870_scan:
    set_addr $I10, rxscan1870_loop
    rx1869_cur."!mark_push"(0, rx1869_pos, $I10)
  rxscan1870_done:
.annotate 'line', 950
  # rx subrule "sigil" subtype=capture negate=
    rx1869_cur."!cursor_pos"(rx1869_pos)
    $P10 = rx1869_cur."sigil"()
    unless $P10, rx1869_fail
    rx1869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1869_pos = $P10."pos"()
  # rx rxquantr1871 ** 0..1
    set_addr $I10, rxquantr1871_done
    rx1869_cur."!mark_push"(0, rx1869_pos, $I10)
  rxquantr1871_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1869_cur."!cursor_pos"(rx1869_pos)
    $P10 = rx1869_cur."twigil"()
    unless $P10, rx1869_fail
    goto rxsubrule1872_pass
  rxsubrule1872_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1869_fail
  rxsubrule1872_pass:
    set_addr $I10, rxsubrule1872_back
    rx1869_cur."!mark_push"(0, rx1869_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1869_pos = $P10."pos"()
    set_addr $I10, rxquantr1871_done
    (rx1869_rep) = rx1869_cur."!mark_commit"($I10)
  rxquantr1871_done:
  alt1873_0:
.annotate 'line', 951
    set_addr $I10, alt1873_1
    rx1869_cur."!mark_push"(0, rx1869_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1869_cur."!cursor_pos"(rx1869_pos)
    $P10 = rx1869_cur."ident"()
    unless $P10, rx1869_fail
    rx1869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1869_pos = $P10."pos"()
    goto alt1873_end
  alt1873_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1874_fail
    rx1869_cur."!mark_push"(0, rx1869_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1869_pos, rx1869_eos, rx1869_fail
    sub $I10, rx1869_pos, rx1869_off
    substr $S10, rx1869_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1869_fail
    inc rx1869_pos
    set_addr $I10, rxcap_1874_fail
    ($I12, $I11) = rx1869_cur."!mark_peek"($I10)
    rx1869_cur."!cursor_pos"($I11)
    ($P10) = rx1869_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1869_pos, "")
    rx1869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1874_done
  rxcap_1874_fail:
    goto rx1869_fail
  rxcap_1874_done:
  alt1873_end:
.annotate 'line', 949
  # rx pass
    rx1869_cur."!cursor_pass"(rx1869_pos, "param_var")
    if_null rx1869_debug, debug_1322
    rx1869_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1869_pos)
  debug_1322:
    .return (rx1869_cur)
  rx1869_restart:
.annotate 'line', 469
    if_null rx1869_debug, debug_1323
    rx1869_cur."!cursor_debug"("NEXT", "param_var")
  debug_1323:
  rx1869_fail:
    (rx1869_rep, rx1869_pos, $I10, $P10) = rx1869_cur."!mark_fail"(0)
    lt rx1869_pos, -1, rx1869_done
    eq rx1869_pos, -1, rx1869_fail
    jump $I10
  rx1869_done:
    rx1869_cur."!cursor_fail"()
    if_null rx1869_debug, debug_1324
    rx1869_cur."!cursor_debug"("FAIL", "param_var")
  debug_1324:
    .return (rx1869_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("237_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("238_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1877_tgt
    .local int rx1877_pos
    .local int rx1877_off
    .local int rx1877_eos
    .local int rx1877_rep
    .local pmc rx1877_cur
    .local pmc rx1877_debug
    (rx1877_cur, rx1877_pos, rx1877_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1877_cur
    .local pmc match
    .lex "$/", match
    length rx1877_eos, rx1877_tgt
    gt rx1877_pos, rx1877_eos, rx1877_done
    set rx1877_off, 0
    lt rx1877_pos, 2, rx1877_start
    sub rx1877_off, rx1877_pos, 1
    substr rx1877_tgt, rx1877_tgt, rx1877_off
  rx1877_start:
    eq $I10, 1, rx1877_restart
    if_null rx1877_debug, debug_1325
    rx1877_cur."!cursor_debug"("START", "named_param")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1878_done
    goto rxscan1878_scan
  rxscan1878_loop:
    (rx1877_pos) = rx1877_cur."from"()
    inc rx1877_pos
    rx1877_cur."!cursor_from"(rx1877_pos)
    ge rx1877_pos, rx1877_eos, rxscan1878_done
  rxscan1878_scan:
    set_addr $I10, rxscan1878_loop
    rx1877_cur."!mark_push"(0, rx1877_pos, $I10)
  rxscan1878_done:
.annotate 'line', 955
  # rx literal  ":"
    add $I11, rx1877_pos, 1
    gt $I11, rx1877_eos, rx1877_fail
    sub $I11, rx1877_pos, rx1877_off
    ord $I11, rx1877_tgt, $I11
    ne $I11, 58, rx1877_fail
    add rx1877_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1877_cur."!cursor_pos"(rx1877_pos)
    $P10 = rx1877_cur."param_var"()
    unless $P10, rx1877_fail
    rx1877_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1877_pos = $P10."pos"()
.annotate 'line', 954
  # rx pass
    rx1877_cur."!cursor_pass"(rx1877_pos, "named_param")
    if_null rx1877_debug, debug_1326
    rx1877_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1877_pos)
  debug_1326:
    .return (rx1877_cur)
  rx1877_restart:
.annotate 'line', 469
    if_null rx1877_debug, debug_1327
    rx1877_cur."!cursor_debug"("NEXT", "named_param")
  debug_1327:
  rx1877_fail:
    (rx1877_rep, rx1877_pos, $I10, $P10) = rx1877_cur."!mark_fail"(0)
    lt rx1877_pos, -1, rx1877_done
    eq rx1877_pos, -1, rx1877_fail
    jump $I10
  rx1877_done:
    rx1877_cur."!cursor_fail"()
    if_null rx1877_debug, debug_1328
    rx1877_cur."!cursor_debug"("FAIL", "named_param")
  debug_1328:
    .return (rx1877_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("239_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("param_var", ":")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("240_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1881_tgt
    .local int rx1881_pos
    .local int rx1881_off
    .local int rx1881_eos
    .local int rx1881_rep
    .local pmc rx1881_cur
    .local pmc rx1881_debug
    (rx1881_cur, rx1881_pos, rx1881_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1881_cur
    .local pmc match
    .lex "$/", match
    length rx1881_eos, rx1881_tgt
    gt rx1881_pos, rx1881_eos, rx1881_done
    set rx1881_off, 0
    lt rx1881_pos, 2, rx1881_start
    sub rx1881_off, rx1881_pos, 1
    substr rx1881_tgt, rx1881_tgt, rx1881_off
  rx1881_start:
    eq $I10, 1, rx1881_restart
    if_null rx1881_debug, debug_1329
    rx1881_cur."!cursor_debug"("START", "default_value")
  debug_1329:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1882_done
    goto rxscan1882_scan
  rxscan1882_loop:
    (rx1881_pos) = rx1881_cur."from"()
    inc rx1881_pos
    rx1881_cur."!cursor_from"(rx1881_pos)
    ge rx1881_pos, rx1881_eos, rxscan1882_done
  rxscan1882_scan:
    set_addr $I10, rxscan1882_loop
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  rxscan1882_done:
.annotate 'line', 958
  # rx subrule "ws" subtype=method negate=
    rx1881_cur."!cursor_pos"(rx1881_pos)
    $P10 = rx1881_cur."ws"()
    unless $P10, rx1881_fail
    rx1881_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1881_pos, 1
    gt $I11, rx1881_eos, rx1881_fail
    sub $I11, rx1881_pos, rx1881_off
    ord $I11, rx1881_tgt, $I11
    ne $I11, 61, rx1881_fail
    add rx1881_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1881_cur."!cursor_pos"(rx1881_pos)
    $P10 = rx1881_cur."ws"()
    unless $P10, rx1881_fail
    rx1881_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1881_cur."!cursor_pos"(rx1881_pos)
    $P10 = rx1881_cur."EXPR"("i=")
    unless $P10, rx1881_fail
    rx1881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1881_cur."!cursor_pos"(rx1881_pos)
    $P10 = rx1881_cur."ws"()
    unless $P10, rx1881_fail
    rx1881_pos = $P10."pos"()
  # rx pass
    rx1881_cur."!cursor_pass"(rx1881_pos, "default_value")
    if_null rx1881_debug, debug_1330
    rx1881_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1881_pos)
  debug_1330:
    .return (rx1881_cur)
  rx1881_restart:
.annotate 'line', 469
    if_null rx1881_debug, debug_1331
    rx1881_cur."!cursor_debug"("NEXT", "default_value")
  debug_1331:
  rx1881_fail:
    (rx1881_rep, rx1881_pos, $I10, $P10) = rx1881_cur."!mark_fail"(0)
    lt rx1881_pos, -1, rx1881_done
    eq rx1881_pos, -1, rx1881_fail
    jump $I10
  rx1881_done:
    rx1881_cur."!cursor_fail"()
    if_null rx1881_debug, debug_1332
    rx1881_cur."!cursor_debug"("FAIL", "default_value")
  debug_1332:
    .return (rx1881_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("241_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P106 = self."!PREFIX__!subrule"("ws", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("242_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1885_tgt
    .local int rx1885_pos
    .local int rx1885_off
    .local int rx1885_eos
    .local int rx1885_rep
    .local pmc rx1885_cur
    .local pmc rx1885_debug
    (rx1885_cur, rx1885_pos, rx1885_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1885_cur
    .local pmc match
    .lex "$/", match
    length rx1885_eos, rx1885_tgt
    gt rx1885_pos, rx1885_eos, rx1885_done
    set rx1885_off, 0
    lt rx1885_pos, 2, rx1885_start
    sub rx1885_off, rx1885_pos, 1
    substr rx1885_tgt, rx1885_tgt, rx1885_off
  rx1885_start:
    eq $I10, 1, rx1885_restart
    if_null rx1885_debug, debug_1333
    rx1885_cur."!cursor_debug"("START", "trait")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1886_done
    goto rxscan1886_scan
  rxscan1886_loop:
    (rx1885_pos) = rx1885_cur."from"()
    inc rx1885_pos
    rx1885_cur."!cursor_from"(rx1885_pos)
    ge rx1885_pos, rx1885_eos, rxscan1886_done
  rxscan1886_scan:
    set_addr $I10, rxscan1886_loop
    rx1885_cur."!mark_push"(0, rx1885_pos, $I10)
  rxscan1886_done:
.annotate 'line', 960
  # rx subrule "ws" subtype=method negate=
    rx1885_cur."!cursor_pos"(rx1885_pos)
    $P10 = rx1885_cur."ws"()
    unless $P10, rx1885_fail
    rx1885_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1885_cur."!cursor_pos"(rx1885_pos)
    $P10 = rx1885_cur."trait_mod"()
    unless $P10, rx1885_fail
    rx1885_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1885_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1885_cur."!cursor_pos"(rx1885_pos)
    $P10 = rx1885_cur."ws"()
    unless $P10, rx1885_fail
    rx1885_pos = $P10."pos"()
  # rx pass
    rx1885_cur."!cursor_pass"(rx1885_pos, "trait")
    if_null rx1885_debug, debug_1334
    rx1885_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1885_pos)
  debug_1334:
    .return (rx1885_cur)
  rx1885_restart:
.annotate 'line', 469
    if_null rx1885_debug, debug_1335
    rx1885_cur."!cursor_debug"("NEXT", "trait")
  debug_1335:
  rx1885_fail:
    (rx1885_rep, rx1885_pos, $I10, $P10) = rx1885_cur."!mark_fail"(0)
    lt rx1885_pos, -1, rx1885_done
    eq rx1885_pos, -1, rx1885_fail
    jump $I10
  rx1885_done:
    rx1885_cur."!cursor_fail"()
    if_null rx1885_debug, debug_1336
    rx1885_cur."!cursor_debug"("FAIL", "trait")
  debug_1336:
    .return (rx1885_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("243_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("244_1321350766.1143")
    .param pmc param_1889
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 962
    .lex "self", param_1889
    $P103 = param_1889."!protoregex"("trait_mod")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("245_1321350766.1143")
    .param pmc param_1891
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 962
    .lex "self", param_1891
    $P104 = param_1891."!PREFIX__!protoregex"("trait_mod")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("246_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1893_tgt
    .local int rx1893_pos
    .local int rx1893_off
    .local int rx1893_eos
    .local int rx1893_rep
    .local pmc rx1893_cur
    .local pmc rx1893_debug
    (rx1893_cur, rx1893_pos, rx1893_tgt, $I10) = self."!cursor_start"()
    rx1893_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1893_cur
    .local pmc match
    .lex "$/", match
    length rx1893_eos, rx1893_tgt
    gt rx1893_pos, rx1893_eos, rx1893_done
    set rx1893_off, 0
    lt rx1893_pos, 2, rx1893_start
    sub rx1893_off, rx1893_pos, 1
    substr rx1893_tgt, rx1893_tgt, rx1893_off
  rx1893_start:
    eq $I10, 1, rx1893_restart
    if_null rx1893_debug, debug_1337
    rx1893_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1894_done
    goto rxscan1894_scan
  rxscan1894_loop:
    (rx1893_pos) = rx1893_cur."from"()
    inc rx1893_pos
    rx1893_cur."!cursor_from"(rx1893_pos)
    ge rx1893_pos, rx1893_eos, rxscan1894_done
  rxscan1894_scan:
    set_addr $I10, rxscan1894_loop
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  rxscan1894_done:
.annotate 'line', 963
  # rx subcapture "sym"
    set_addr $I10, rxcap_1895_fail
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  # rx literal  "is"
    add $I11, rx1893_pos, 2
    gt $I11, rx1893_eos, rx1893_fail
    sub $I11, rx1893_pos, rx1893_off
    substr $S10, rx1893_tgt, $I11, 2
    ne $S10, "is", rx1893_fail
    add rx1893_pos, 2
    set_addr $I10, rxcap_1895_fail
    ($I12, $I11) = rx1893_cur."!mark_peek"($I10)
    rx1893_cur."!cursor_pos"($I11)
    ($P10) = rx1893_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1893_pos, "")
    rx1893_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1895_done
  rxcap_1895_fail:
    goto rx1893_fail
  rxcap_1895_done:
  # rx subrule "ws" subtype=method negate=
    rx1893_cur."!cursor_pos"(rx1893_pos)
    $P10 = rx1893_cur."ws"()
    unless $P10, rx1893_fail
    rx1893_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1893_cur."!cursor_pos"(rx1893_pos)
    $P10 = rx1893_cur."deflongname"()
    unless $P10, rx1893_fail
    rx1893_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1893_pos = $P10."pos"()
  # rx rxquantr1896 ** 0..1
    set_addr $I10, rxquantr1896_done
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  rxquantr1896_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1893_cur."!cursor_pos"(rx1893_pos)
    $P10 = rx1893_cur."circumfix"()
    unless $P10, rx1893_fail
    goto rxsubrule1897_pass
  rxsubrule1897_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1893_fail
  rxsubrule1897_pass:
    set_addr $I10, rxsubrule1897_back
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1893_pos = $P10."pos"()
    set_addr $I10, rxquantr1896_done
    (rx1893_rep) = rx1893_cur."!mark_commit"($I10)
  rxquantr1896_done:
  # rx subrule "ws" subtype=method negate=
    rx1893_cur."!cursor_pos"(rx1893_pos)
    $P10 = rx1893_cur."ws"()
    unless $P10, rx1893_fail
    rx1893_pos = $P10."pos"()
  # rx pass
    rx1893_cur."!cursor_pass"(rx1893_pos, "trait_mod:sym<is>")
    if_null rx1893_debug, debug_1338
    rx1893_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1893_pos)
  debug_1338:
    .return (rx1893_cur)
  rx1893_restart:
.annotate 'line', 469
    if_null rx1893_debug, debug_1339
    rx1893_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1339:
  rx1893_fail:
    (rx1893_rep, rx1893_pos, $I10, $P10) = rx1893_cur."!mark_fail"(0)
    lt rx1893_pos, -1, rx1893_done
    eq rx1893_pos, -1, rx1893_fail
    jump $I10
  rx1893_done:
    rx1893_cur."!cursor_fail"()
    if_null rx1893_debug, debug_1340
    rx1893_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1340:
    .return (rx1893_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("247_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "is")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("248_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1900_tgt
    .local int rx1900_pos
    .local int rx1900_off
    .local int rx1900_eos
    .local int rx1900_rep
    .local pmc rx1900_cur
    .local pmc rx1900_debug
    (rx1900_cur, rx1900_pos, rx1900_tgt, $I10) = self."!cursor_start"()
    rx1900_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1900_cur
    .local pmc match
    .lex "$/", match
    length rx1900_eos, rx1900_tgt
    gt rx1900_pos, rx1900_eos, rx1900_done
    set rx1900_off, 0
    lt rx1900_pos, 2, rx1900_start
    sub rx1900_off, rx1900_pos, 1
    substr rx1900_tgt, rx1900_tgt, rx1900_off
  rx1900_start:
    eq $I10, 1, rx1900_restart
    if_null rx1900_debug, debug_1341
    rx1900_cur."!cursor_debug"("START", "regex_declarator")
  debug_1341:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1901_done
    goto rxscan1901_scan
  rxscan1901_loop:
    (rx1900_pos) = rx1900_cur."from"()
    inc rx1900_pos
    rx1900_cur."!cursor_from"(rx1900_pos)
    ge rx1900_pos, rx1900_eos, rxscan1901_done
  rxscan1901_scan:
    set_addr $I10, rxscan1901_loop
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  rxscan1901_done:
.annotate 'line', 965
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  alt1902_0:
.annotate 'line', 966
    set_addr $I10, alt1902_1
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
.annotate 'line', 967
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1903_fail
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1900_pos, 5
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 5
    ne $S10, "proto", rx1900_fail
    add rx1900_pos, 5
    set_addr $I10, rxcap_1903_fail
    ($I12, $I11) = rx1900_cur."!mark_peek"($I10)
    rx1900_cur."!cursor_pos"($I11)
    ($P10) = rx1900_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1900_pos, "")
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1903_done
  rxcap_1903_fail:
    goto rx1900_fail
  rxcap_1903_done:
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  alt1904_0:
    set_addr $I10, alt1904_1
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1900_pos, 5
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 5
    ne $S10, "regex", rx1900_fail
    add rx1900_pos, 5
    goto alt1904_end
  alt1904_1:
    set_addr $I10, alt1904_2
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "token"
    add $I11, rx1900_pos, 5
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 5
    ne $S10, "token", rx1900_fail
    add rx1900_pos, 5
    goto alt1904_end
  alt1904_2:
  # rx literal  "rule"
    add $I11, rx1900_pos, 4
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 4
    ne $S10, "rule", rx1900_fail
    add rx1900_pos, 4
  alt1904_end:
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 968
  # rx subrule "deflongname" subtype=capture negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."deflongname"()
    unless $P10, rx1900_fail
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1900_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  alt1905_0:
.annotate 'line', 969
    set_addr $I10, alt1905_1
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
.annotate 'line', 970
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 123, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1900_pos, 5
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 5
    ne $S10, "<...>", rx1900_fail
    add rx1900_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 125, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ENDSTMT"()
    unless $P10, rx1900_fail
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
    goto alt1905_end
  alt1905_1:
    set_addr $I10, alt1905_2
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
.annotate 'line', 971
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 123, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1900_pos, 3
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 3
    ne $S10, "<*>", rx1900_fail
    add rx1900_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 125, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ENDSTMT"()
    unless $P10, rx1900_fail
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
    goto alt1905_end
  alt1905_2:
.annotate 'line', 972
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  alt1905_end:
.annotate 'line', 973
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 967
    goto alt1902_end
  alt1902_1:
.annotate 'line', 974
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1907_fail
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  alt1906_0:
    set_addr $I10, alt1906_1
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1900_pos, 5
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 5
    ne $S10, "regex", rx1900_fail
    add rx1900_pos, 5
    goto alt1906_end
  alt1906_1:
    set_addr $I10, alt1906_2
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "token"
    add $I11, rx1900_pos, 5
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 5
    ne $S10, "token", rx1900_fail
    add rx1900_pos, 5
    goto alt1906_end
  alt1906_2:
  # rx literal  "rule"
    add $I11, rx1900_pos, 4
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 4
    ne $S10, "rule", rx1900_fail
    add rx1900_pos, 4
  alt1906_end:
    set_addr $I10, rxcap_1907_fail
    ($I12, $I11) = rx1900_cur."!mark_peek"($I10)
    rx1900_cur."!cursor_pos"($I11)
    ($P10) = rx1900_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1900_pos, "")
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1907_done
  rxcap_1907_fail:
    goto rx1900_fail
  rxcap_1907_done:
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 975
  # rx subrule "deflongname" subtype=capture negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."deflongname"()
    unless $P10, rx1900_fail
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1900_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 976
  # rx subrule "newpad" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."newpad"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 977
  # rx rxquantr1908 ** 0..1
    set_addr $I10, rxquantr1908_done
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  rxquantr1908_loop:
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 40, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."signature"()
    unless $P10, rx1900_fail
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1900_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 41, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
    set_addr $I10, rxquantr1908_done
    (rx1900_rep) = rx1900_cur."!mark_commit"($I10)
  rxquantr1908_done:
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 978
  # rx reduce name="regex_declarator" key="open"
    rx1900_cur."!cursor_pos"(rx1900_pos)
    rx1900_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 979
  # rx literal  "{"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 123, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1900_fail
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1900_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1900_pos, 1
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    ord $I11, rx1900_tgt, $I11
    ne $I11, 125, rx1900_fail
    add rx1900_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ENDSTMT"()
    unless $P10, rx1900_fail
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
  alt1902_end:
.annotate 'line', 980
  # rx subrule "ws" subtype=method negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."ws"()
    unless $P10, rx1900_fail
    rx1900_pos = $P10."pos"()
.annotate 'line', 965
  # rx pass
    rx1900_cur."!cursor_pass"(rx1900_pos, "regex_declarator")
    if_null rx1900_debug, debug_1342
    rx1900_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1900_pos)
  debug_1342:
    .return (rx1900_cur)
  rx1900_restart:
.annotate 'line', 469
    if_null rx1900_debug, debug_1343
    rx1900_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1343:
  rx1900_fail:
    (rx1900_rep, rx1900_pos, $I10, $P10) = rx1900_cur."!mark_fail"(0)
    lt rx1900_pos, -1, rx1900_done
    eq rx1900_pos, -1, rx1900_fail
    jump $I10
  rx1900_done:
    rx1900_cur."!cursor_fail"()
    if_null rx1900_debug, debug_1344
    rx1900_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1344:
    .return (rx1900_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("249_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("250_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1911_tgt
    .local int rx1911_pos
    .local int rx1911_off
    .local int rx1911_eos
    .local int rx1911_rep
    .local pmc rx1911_cur
    .local pmc rx1911_debug
    (rx1911_cur, rx1911_pos, rx1911_tgt, $I10) = self."!cursor_start"()
    rx1911_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1911_cur
    .local pmc match
    .lex "$/", match
    length rx1911_eos, rx1911_tgt
    gt rx1911_pos, rx1911_eos, rx1911_done
    set rx1911_off, 0
    lt rx1911_pos, 2, rx1911_start
    sub rx1911_off, rx1911_pos, 1
    substr rx1911_tgt, rx1911_tgt, rx1911_off
  rx1911_start:
    eq $I10, 1, rx1911_restart
    if_null rx1911_debug, debug_1345
    rx1911_cur."!cursor_debug"("START", "dotty")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1912_done
    goto rxscan1912_scan
  rxscan1912_loop:
    (rx1911_pos) = rx1911_cur."from"()
    inc rx1911_pos
    rx1911_cur."!cursor_from"(rx1911_pos)
    ge rx1911_pos, rx1911_eos, rxscan1912_done
  rxscan1912_scan:
    set_addr $I10, rxscan1912_loop
    rx1911_cur."!mark_push"(0, rx1911_pos, $I10)
  rxscan1912_done:
.annotate 'line', 984
  # rx literal  "."
    add $I11, rx1911_pos, 1
    gt $I11, rx1911_eos, rx1911_fail
    sub $I11, rx1911_pos, rx1911_off
    ord $I11, rx1911_tgt, $I11
    ne $I11, 46, rx1911_fail
    add rx1911_pos, 1
  alt1913_0:
.annotate 'line', 985
    set_addr $I10, alt1913_1
    rx1911_cur."!mark_push"(0, rx1911_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."deflongname"()
    unless $P10, rx1911_fail
    rx1911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1911_pos = $P10."pos"()
    goto alt1913_end
  alt1913_1:
.annotate 'line', 986
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1911_pos, rx1911_off
    substr $S10, rx1911_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1911_fail
  # rx subrule "quote" subtype=capture negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."quote"()
    unless $P10, rx1911_fail
    rx1911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1911_pos = $P10."pos"()
  alt1914_0:
.annotate 'line', 987
    set_addr $I10, alt1914_1
    rx1911_cur."!mark_push"(0, rx1911_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1911_pos, rx1911_off
    substr $S10, rx1911_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1911_fail
    goto alt1914_end
  alt1914_1:
  # rx subrule "panic" subtype=method negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1911_fail
    rx1911_pos = $P10."pos"()
  alt1914_end:
  alt1913_end:
.annotate 'line', 993
  # rx rxquantr1915 ** 0..1
    set_addr $I10, rxquantr1915_done
    rx1911_cur."!mark_push"(0, rx1911_pos, $I10)
  rxquantr1915_loop:
  alt1916_0:
.annotate 'line', 990
    set_addr $I10, alt1916_1
    rx1911_cur."!mark_push"(0, rx1911_pos, $I10)
.annotate 'line', 991
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1911_pos, rx1911_off
    substr $S10, rx1911_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1911_fail
  # rx subrule "args" subtype=capture negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."args"()
    unless $P10, rx1911_fail
    rx1911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1911_pos = $P10."pos"()
    goto alt1916_end
  alt1916_1:
.annotate 'line', 992
  # rx literal  ":"
    add $I11, rx1911_pos, 1
    gt $I11, rx1911_eos, rx1911_fail
    sub $I11, rx1911_pos, rx1911_off
    ord $I11, rx1911_tgt, $I11
    ne $I11, 58, rx1911_fail
    add rx1911_pos, 1
  # rx charclass s
    ge rx1911_pos, rx1911_eos, rx1911_fail
    sub $I10, rx1911_pos, rx1911_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1911_tgt, $I10
    unless $I11, rx1911_fail
    inc rx1911_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1911_cur."!cursor_pos"(rx1911_pos)
    $P10 = rx1911_cur."arglist"()
    unless $P10, rx1911_fail
    rx1911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1911_pos = $P10."pos"()
  alt1916_end:
.annotate 'line', 993
    set_addr $I10, rxquantr1915_done
    (rx1911_rep) = rx1911_cur."!mark_commit"($I10)
  rxquantr1915_done:
.annotate 'line', 983
  # rx pass
    rx1911_cur."!cursor_pass"(rx1911_pos, "dotty")
    if_null rx1911_debug, debug_1346
    rx1911_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1911_pos)
  debug_1346:
    .return (rx1911_cur)
  rx1911_restart:
.annotate 'line', 469
    if_null rx1911_debug, debug_1347
    rx1911_cur."!cursor_debug"("NEXT", "dotty")
  debug_1347:
  rx1911_fail:
    (rx1911_rep, rx1911_pos, $I10, $P10) = rx1911_cur."!mark_fail"(0)
    lt rx1911_pos, -1, rx1911_done
    eq rx1911_pos, -1, rx1911_fail
    jump $I10
  rx1911_done:
    rx1911_cur."!cursor_fail"()
    if_null rx1911_debug, debug_1348
    rx1911_cur."!cursor_debug"("FAIL", "dotty")
  debug_1348:
    .return (rx1911_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("251_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P104, "ResizablePMCArray"
    push $P104, "'"
    push $P104, "\""
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("252_1321350766.1143")
    .param pmc param_1919
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 997
    .lex "self", param_1919
    $P103 = param_1919."!protoregex"("term")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("253_1321350766.1143")
    .param pmc param_1921
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 997
    .lex "self", param_1921
    $P104 = param_1921."!PREFIX__!protoregex"("term")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("254_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1923_tgt
    .local int rx1923_pos
    .local int rx1923_off
    .local int rx1923_eos
    .local int rx1923_rep
    .local pmc rx1923_cur
    .local pmc rx1923_debug
    (rx1923_cur, rx1923_pos, rx1923_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1923_cur
    .local pmc match
    .lex "$/", match
    length rx1923_eos, rx1923_tgt
    gt rx1923_pos, rx1923_eos, rx1923_done
    set rx1923_off, 0
    lt rx1923_pos, 2, rx1923_start
    sub rx1923_off, rx1923_pos, 1
    substr rx1923_tgt, rx1923_tgt, rx1923_off
  rx1923_start:
    eq $I10, 1, rx1923_restart
    if_null rx1923_debug, debug_1349
    rx1923_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1924_done
    goto rxscan1924_scan
  rxscan1924_loop:
    (rx1923_pos) = rx1923_cur."from"()
    inc rx1923_pos
    rx1923_cur."!cursor_from"(rx1923_pos)
    ge rx1923_pos, rx1923_eos, rxscan1924_done
  rxscan1924_scan:
    set_addr $I10, rxscan1924_loop
    rx1923_cur."!mark_push"(0, rx1923_pos, $I10)
  rxscan1924_done:
.annotate 'line', 999
  # rx subcapture "sym"
    set_addr $I10, rxcap_1925_fail
    rx1923_cur."!mark_push"(0, rx1923_pos, $I10)
  # rx literal  "self"
    add $I11, rx1923_pos, 4
    gt $I11, rx1923_eos, rx1923_fail
    sub $I11, rx1923_pos, rx1923_off
    substr $S10, rx1923_tgt, $I11, 4
    ne $S10, "self", rx1923_fail
    add rx1923_pos, 4
    set_addr $I10, rxcap_1925_fail
    ($I12, $I11) = rx1923_cur."!mark_peek"($I10)
    rx1923_cur."!cursor_pos"($I11)
    ($P10) = rx1923_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1923_pos, "")
    rx1923_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1925_done
  rxcap_1925_fail:
    goto rx1923_fail
  rxcap_1925_done:
  # rxanchor rwb
    le rx1923_pos, 0, rx1923_fail
    sub $I10, rx1923_pos, rx1923_off
    is_cclass $I11, .CCLASS_WORD, rx1923_tgt, $I10
    if $I11, rx1923_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1923_tgt, $I10
    unless $I11, rx1923_fail
  # rx pass
    rx1923_cur."!cursor_pass"(rx1923_pos, "term:sym<self>")
    if_null rx1923_debug, debug_1350
    rx1923_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1923_pos)
  debug_1350:
    .return (rx1923_cur)
  rx1923_restart:
.annotate 'line', 469
    if_null rx1923_debug, debug_1351
    rx1923_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1351:
  rx1923_fail:
    (rx1923_rep, rx1923_pos, $I10, $P10) = rx1923_cur."!mark_fail"(0)
    lt rx1923_pos, -1, rx1923_done
    eq rx1923_pos, -1, rx1923_fail
    jump $I10
  rx1923_done:
    rx1923_cur."!cursor_fail"()
    if_null rx1923_debug, debug_1352
    rx1923_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1352:
    .return (rx1923_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("255_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "self"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("256_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1928_tgt
    .local int rx1928_pos
    .local int rx1928_off
    .local int rx1928_eos
    .local int rx1928_rep
    .local pmc rx1928_cur
    .local pmc rx1928_debug
    (rx1928_cur, rx1928_pos, rx1928_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1928_cur
    .local pmc match
    .lex "$/", match
    length rx1928_eos, rx1928_tgt
    gt rx1928_pos, rx1928_eos, rx1928_done
    set rx1928_off, 0
    lt rx1928_pos, 2, rx1928_start
    sub rx1928_off, rx1928_pos, 1
    substr rx1928_tgt, rx1928_tgt, rx1928_off
  rx1928_start:
    eq $I10, 1, rx1928_restart
    if_null rx1928_debug, debug_1353
    rx1928_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1353:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1929_done
    goto rxscan1929_scan
  rxscan1929_loop:
    (rx1928_pos) = rx1928_cur."from"()
    inc rx1928_pos
    rx1928_cur."!cursor_from"(rx1928_pos)
    ge rx1928_pos, rx1928_eos, rxscan1929_done
  rxscan1929_scan:
    set_addr $I10, rxscan1929_loop
    rx1928_cur."!mark_push"(0, rx1928_pos, $I10)
  rxscan1929_done:
.annotate 'line', 1002
  # rx subrule "deflongname" subtype=capture negate=
    rx1928_cur."!cursor_pos"(rx1928_pos)
    $P10 = rx1928_cur."deflongname"()
    unless $P10, rx1928_fail
    rx1928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1928_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1928_pos, rx1928_off
    substr $S10, rx1928_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1928_fail
  # rx subrule "args" subtype=capture negate=
    rx1928_cur."!cursor_pos"(rx1928_pos)
    $P10 = rx1928_cur."args"()
    unless $P10, rx1928_fail
    rx1928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1928_pos = $P10."pos"()
.annotate 'line', 1001
  # rx pass
    rx1928_cur."!cursor_pass"(rx1928_pos, "term:sym<identifier>")
    if_null rx1928_debug, debug_1354
    rx1928_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1928_pos)
  debug_1354:
    .return (rx1928_cur)
  rx1928_restart:
.annotate 'line', 469
    if_null rx1928_debug, debug_1355
    rx1928_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1355:
  rx1928_fail:
    (rx1928_rep, rx1928_pos, $I10, $P10) = rx1928_cur."!mark_fail"(0)
    lt rx1928_pos, -1, rx1928_done
    eq rx1928_pos, -1, rx1928_fail
    jump $I10
  rx1928_done:
    rx1928_cur."!cursor_fail"()
    if_null rx1928_debug, debug_1356
    rx1928_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1356:
    .return (rx1928_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("257_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("deflongname", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("258_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1932_tgt
    .local int rx1932_pos
    .local int rx1932_off
    .local int rx1932_eos
    .local int rx1932_rep
    .local pmc rx1932_cur
    .local pmc rx1932_debug
    (rx1932_cur, rx1932_pos, rx1932_tgt, $I10) = self."!cursor_start"()
    rx1932_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1932_cur
    .local pmc match
    .lex "$/", match
    length rx1932_eos, rx1932_tgt
    gt rx1932_pos, rx1932_eos, rx1932_done
    set rx1932_off, 0
    lt rx1932_pos, 2, rx1932_start
    sub rx1932_off, rx1932_pos, 1
    substr rx1932_tgt, rx1932_tgt, rx1932_off
  rx1932_start:
    eq $I10, 1, rx1932_restart
    if_null rx1932_debug, debug_1357
    rx1932_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1933_done
    goto rxscan1933_scan
  rxscan1933_loop:
    (rx1932_pos) = rx1932_cur."from"()
    inc rx1932_pos
    rx1932_cur."!cursor_from"(rx1932_pos)
    ge rx1932_pos, rx1932_eos, rxscan1933_done
  rxscan1933_scan:
    set_addr $I10, rxscan1933_loop
    rx1932_cur."!mark_push"(0, rx1932_pos, $I10)
  rxscan1933_done:
.annotate 'line', 1006
  # rx subrule "name" subtype=capture negate=
    rx1932_cur."!cursor_pos"(rx1932_pos)
    $P10 = rx1932_cur."name"()
    unless $P10, rx1932_fail
    rx1932_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1932_pos = $P10."pos"()
  # rx rxquantr1934 ** 0..1
    set_addr $I10, rxquantr1934_done
    rx1932_cur."!mark_push"(0, rx1932_pos, $I10)
  rxquantr1934_loop:
  # rx subrule "args" subtype=capture negate=
    rx1932_cur."!cursor_pos"(rx1932_pos)
    $P10 = rx1932_cur."args"()
    unless $P10, rx1932_fail
    goto rxsubrule1935_pass
  rxsubrule1935_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1932_fail
  rxsubrule1935_pass:
    set_addr $I10, rxsubrule1935_back
    rx1932_cur."!mark_push"(0, rx1932_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1932_pos = $P10."pos"()
    set_addr $I10, rxquantr1934_done
    (rx1932_rep) = rx1932_cur."!mark_commit"($I10)
  rxquantr1934_done:
.annotate 'line', 1005
  # rx pass
    rx1932_cur."!cursor_pass"(rx1932_pos, "term:sym<name>")
    if_null rx1932_debug, debug_1358
    rx1932_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1932_pos)
  debug_1358:
    .return (rx1932_cur)
  rx1932_restart:
.annotate 'line', 469
    if_null rx1932_debug, debug_1359
    rx1932_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1359:
  rx1932_fail:
    (rx1932_rep, rx1932_pos, $I10, $P10) = rx1932_cur."!mark_fail"(0)
    lt rx1932_pos, -1, rx1932_done
    eq rx1932_pos, -1, rx1932_fail
    jump $I10
  rx1932_done:
    rx1932_cur."!cursor_fail"()
    if_null rx1932_debug, debug_1360
    rx1932_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1360:
    .return (rx1932_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("259_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("name", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("260_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1938_tgt
    .local int rx1938_pos
    .local int rx1938_off
    .local int rx1938_eos
    .local int rx1938_rep
    .local pmc rx1938_cur
    .local pmc rx1938_debug
    (rx1938_cur, rx1938_pos, rx1938_tgt, $I10) = self."!cursor_start"()
    rx1938_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1938_cur
    .local pmc match
    .lex "$/", match
    length rx1938_eos, rx1938_tgt
    gt rx1938_pos, rx1938_eos, rx1938_done
    set rx1938_off, 0
    lt rx1938_pos, 2, rx1938_start
    sub rx1938_off, rx1938_pos, 1
    substr rx1938_tgt, rx1938_tgt, rx1938_off
  rx1938_start:
    eq $I10, 1, rx1938_restart
    if_null rx1938_debug, debug_1361
    rx1938_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1361:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1939_done
    goto rxscan1939_scan
  rxscan1939_loop:
    (rx1938_pos) = rx1938_cur."from"()
    inc rx1938_pos
    rx1938_cur."!cursor_from"(rx1938_pos)
    ge rx1938_pos, rx1938_eos, rxscan1939_done
  rxscan1939_scan:
    set_addr $I10, rxscan1939_loop
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
  rxscan1939_done:
.annotate 'line', 1010
  # rx literal  "pir::"
    add $I11, rx1938_pos, 5
    gt $I11, rx1938_eos, rx1938_fail
    sub $I11, rx1938_pos, rx1938_off
    substr $S10, rx1938_tgt, $I11, 5
    ne $S10, "pir::", rx1938_fail
    add rx1938_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1940_fail
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1938_pos, rx1938_off
    find_not_cclass $I11, .CCLASS_WORD, rx1938_tgt, $I10, rx1938_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1938_fail
    add rx1938_pos, rx1938_off, $I11
    set_addr $I10, rxcap_1940_fail
    ($I12, $I11) = rx1938_cur."!mark_peek"($I10)
    rx1938_cur."!cursor_pos"($I11)
    ($P10) = rx1938_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1938_pos, "")
    rx1938_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1940_done
  rxcap_1940_fail:
    goto rx1938_fail
  rxcap_1940_done:
  # rx rxquantr1941 ** 0..1
    set_addr $I10, rxquantr1941_done
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
  rxquantr1941_loop:
  # rx subrule "args" subtype=capture negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."args"()
    unless $P10, rx1938_fail
    goto rxsubrule1942_pass
  rxsubrule1942_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1938_fail
  rxsubrule1942_pass:
    set_addr $I10, rxsubrule1942_back
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1938_pos = $P10."pos"()
    set_addr $I10, rxquantr1941_done
    (rx1938_rep) = rx1938_cur."!mark_commit"($I10)
  rxquantr1941_done:
.annotate 'line', 1009
  # rx pass
    rx1938_cur."!cursor_pass"(rx1938_pos, "term:sym<pir::op>")
    if_null rx1938_debug, debug_1362
    rx1938_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1938_pos)
  debug_1362:
    .return (rx1938_cur)
  rx1938_restart:
.annotate 'line', 469
    if_null rx1938_debug, debug_1363
    rx1938_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1363:
  rx1938_fail:
    (rx1938_rep, rx1938_pos, $I10, $P10) = rx1938_cur."!mark_fail"(0)
    lt rx1938_pos, -1, rx1938_done
    eq rx1938_pos, -1, rx1938_fail
    jump $I10
  rx1938_done:
    rx1938_cur."!cursor_fail"()
    if_null rx1938_debug, debug_1364
    rx1938_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1364:
    .return (rx1938_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("261_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "pir::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::const>"  :subid("262_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1945_tgt
    .local int rx1945_pos
    .local int rx1945_off
    .local int rx1945_eos
    .local int rx1945_rep
    .local pmc rx1945_cur
    .local pmc rx1945_debug
    (rx1945_cur, rx1945_pos, rx1945_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1945_cur
    .local pmc match
    .lex "$/", match
    length rx1945_eos, rx1945_tgt
    gt rx1945_pos, rx1945_eos, rx1945_done
    set rx1945_off, 0
    lt rx1945_pos, 2, rx1945_start
    sub rx1945_off, rx1945_pos, 1
    substr rx1945_tgt, rx1945_tgt, rx1945_off
  rx1945_start:
    eq $I10, 1, rx1945_restart
    if_null rx1945_debug, debug_1365
    rx1945_cur."!cursor_debug"("START", "term:sym<pir::const>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1946_done
    goto rxscan1946_scan
  rxscan1946_loop:
    (rx1945_pos) = rx1945_cur."from"()
    inc rx1945_pos
    rx1945_cur."!cursor_from"(rx1945_pos)
    ge rx1945_pos, rx1945_eos, rxscan1946_done
  rxscan1946_scan:
    set_addr $I10, rxscan1946_loop
    rx1945_cur."!mark_push"(0, rx1945_pos, $I10)
  rxscan1946_done:
.annotate 'line', 1014
  # rx literal  "pir::const::"
    add $I11, rx1945_pos, 12
    gt $I11, rx1945_eos, rx1945_fail
    sub $I11, rx1945_pos, rx1945_off
    substr $S10, rx1945_tgt, $I11, 12
    ne $S10, "pir::const::", rx1945_fail
    add rx1945_pos, 12
  # rx subcapture "const"
    set_addr $I10, rxcap_1947_fail
    rx1945_cur."!mark_push"(0, rx1945_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1945_pos, rx1945_off
    find_not_cclass $I11, .CCLASS_WORD, rx1945_tgt, $I10, rx1945_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1945_fail
    add rx1945_pos, rx1945_off, $I11
    set_addr $I10, rxcap_1947_fail
    ($I12, $I11) = rx1945_cur."!mark_peek"($I10)
    rx1945_cur."!cursor_pos"($I11)
    ($P10) = rx1945_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1945_pos, "")
    rx1945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("const")
    goto rxcap_1947_done
  rxcap_1947_fail:
    goto rx1945_fail
  rxcap_1947_done:
.annotate 'line', 1013
  # rx pass
    rx1945_cur."!cursor_pass"(rx1945_pos, "term:sym<pir::const>")
    if_null rx1945_debug, debug_1366
    rx1945_cur."!cursor_debug"("PASS", "term:sym<pir::const>", " at pos=", rx1945_pos)
  debug_1366:
    .return (rx1945_cur)
  rx1945_restart:
.annotate 'line', 469
    if_null rx1945_debug, debug_1367
    rx1945_cur."!cursor_debug"("NEXT", "term:sym<pir::const>")
  debug_1367:
  rx1945_fail:
    (rx1945_rep, rx1945_pos, $I10, $P10) = rx1945_cur."!mark_fail"(0)
    lt rx1945_pos, -1, rx1945_done
    eq rx1945_pos, -1, rx1945_fail
    jump $I10
  rx1945_done:
    rx1945_cur."!cursor_fail"()
    if_null rx1945_debug, debug_1368
    rx1945_cur."!cursor_debug"("FAIL", "term:sym<pir::const>")
  debug_1368:
    .return (rx1945_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::const>"  :subid("263_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "pir::const::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<nqp::op>"  :subid("264_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1950_tgt
    .local int rx1950_pos
    .local int rx1950_off
    .local int rx1950_eos
    .local int rx1950_rep
    .local pmc rx1950_cur
    .local pmc rx1950_debug
    (rx1950_cur, rx1950_pos, rx1950_tgt, $I10) = self."!cursor_start"()
    rx1950_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1950_cur
    .local pmc match
    .lex "$/", match
    length rx1950_eos, rx1950_tgt
    gt rx1950_pos, rx1950_eos, rx1950_done
    set rx1950_off, 0
    lt rx1950_pos, 2, rx1950_start
    sub rx1950_off, rx1950_pos, 1
    substr rx1950_tgt, rx1950_tgt, rx1950_off
  rx1950_start:
    eq $I10, 1, rx1950_restart
    if_null rx1950_debug, debug_1369
    rx1950_cur."!cursor_debug"("START", "term:sym<nqp::op>")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1951_done
    goto rxscan1951_scan
  rxscan1951_loop:
    (rx1950_pos) = rx1950_cur."from"()
    inc rx1950_pos
    rx1950_cur."!cursor_from"(rx1950_pos)
    ge rx1950_pos, rx1950_eos, rxscan1951_done
  rxscan1951_scan:
    set_addr $I10, rxscan1951_loop
    rx1950_cur."!mark_push"(0, rx1950_pos, $I10)
  rxscan1951_done:
.annotate 'line', 1018
  # rx literal  "nqp::"
    add $I11, rx1950_pos, 5
    gt $I11, rx1950_eos, rx1950_fail
    sub $I11, rx1950_pos, rx1950_off
    substr $S10, rx1950_tgt, $I11, 5
    ne $S10, "nqp::", rx1950_fail
    add rx1950_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1952_fail
    rx1950_cur."!mark_push"(0, rx1950_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1950_pos, rx1950_off
    find_not_cclass $I11, .CCLASS_WORD, rx1950_tgt, $I10, rx1950_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1950_fail
    add rx1950_pos, rx1950_off, $I11
    set_addr $I10, rxcap_1952_fail
    ($I12, $I11) = rx1950_cur."!mark_peek"($I10)
    rx1950_cur."!cursor_pos"($I11)
    ($P10) = rx1950_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1950_pos, "")
    rx1950_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1952_done
  rxcap_1952_fail:
    goto rx1950_fail
  rxcap_1952_done:
  # rx rxquantr1953 ** 0..1
    set_addr $I10, rxquantr1953_done
    rx1950_cur."!mark_push"(0, rx1950_pos, $I10)
  rxquantr1953_loop:
  # rx subrule "args" subtype=capture negate=
    rx1950_cur."!cursor_pos"(rx1950_pos)
    $P10 = rx1950_cur."args"()
    unless $P10, rx1950_fail
    goto rxsubrule1954_pass
  rxsubrule1954_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1950_fail
  rxsubrule1954_pass:
    set_addr $I10, rxsubrule1954_back
    rx1950_cur."!mark_push"(0, rx1950_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1950_pos = $P10."pos"()
    set_addr $I10, rxquantr1953_done
    (rx1950_rep) = rx1950_cur."!mark_commit"($I10)
  rxquantr1953_done:
.annotate 'line', 1017
  # rx pass
    rx1950_cur."!cursor_pass"(rx1950_pos, "term:sym<nqp::op>")
    if_null rx1950_debug, debug_1370
    rx1950_cur."!cursor_debug"("PASS", "term:sym<nqp::op>", " at pos=", rx1950_pos)
  debug_1370:
    .return (rx1950_cur)
  rx1950_restart:
.annotate 'line', 469
    if_null rx1950_debug, debug_1371
    rx1950_cur."!cursor_debug"("NEXT", "term:sym<nqp::op>")
  debug_1371:
  rx1950_fail:
    (rx1950_rep, rx1950_pos, $I10, $P10) = rx1950_cur."!mark_fail"(0)
    lt rx1950_pos, -1, rx1950_done
    eq rx1950_pos, -1, rx1950_fail
    jump $I10
  rx1950_done:
    rx1950_cur."!cursor_fail"()
    if_null rx1950_debug, debug_1372
    rx1950_cur."!cursor_debug"("FAIL", "term:sym<nqp::op>")
  debug_1372:
    .return (rx1950_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<nqp::op>"  :subid("265_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "nqp::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("266_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P1961 = "267_1321350766.1143" 
    capture_lex $P1961
    .local string rx1957_tgt
    .local int rx1957_pos
    .local int rx1957_off
    .local int rx1957_eos
    .local int rx1957_rep
    .local pmc rx1957_cur
    .local pmc rx1957_debug
    (rx1957_cur, rx1957_pos, rx1957_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1957_cur
    .local pmc match
    .lex "$/", match
    length rx1957_eos, rx1957_tgt
    gt rx1957_pos, rx1957_eos, rx1957_done
    set rx1957_off, 0
    lt rx1957_pos, 2, rx1957_start
    sub rx1957_off, rx1957_pos, 1
    substr rx1957_tgt, rx1957_tgt, rx1957_off
  rx1957_start:
    eq $I10, 1, rx1957_restart
    if_null rx1957_debug, debug_1373
    rx1957_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1373:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1958_done
    goto rxscan1958_scan
  rxscan1958_loop:
    (rx1957_pos) = rx1957_cur."from"()
    inc rx1957_pos
    rx1957_cur."!cursor_from"(rx1957_pos)
    ge rx1957_pos, rx1957_eos, rxscan1958_done
  rxscan1958_scan:
    set_addr $I10, rxscan1958_loop
    rx1957_cur."!mark_push"(0, rx1957_pos, $I10)
  rxscan1958_done:
.annotate 'line', 1022
  # rx literal  "{*}"
    add $I11, rx1957_pos, 3
    gt $I11, rx1957_eos, rx1957_fail
    sub $I11, rx1957_pos, rx1957_off
    substr $S10, rx1957_tgt, $I11, 3
    ne $S10, "{*}", rx1957_fail
    add rx1957_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1957_cur."!cursor_pos"(rx1957_pos)
    $P10 = rx1957_cur."ENDSTMT"()
    unless $P10, rx1957_fail
  alt1959_0:
.annotate 'line', 1023
    set_addr $I10, alt1959_1
    rx1957_cur."!mark_push"(0, rx1957_pos, $I10)
    rx1957_cur."!cursor_pos"(rx1957_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1961 = "267_1321350766.1143" 
    capture_lex $P1961
    $P105 = $P1961()
    unless $P105, rx1957_fail
    goto alt1959_end
  alt1959_1:
  # rx subrule "panic" subtype=method negate=
    rx1957_cur."!cursor_pos"(rx1957_pos)
    $P10 = rx1957_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1957_fail
    rx1957_pos = $P10."pos"()
  alt1959_end:
.annotate 'line', 1021
  # rx pass
    rx1957_cur."!cursor_pass"(rx1957_pos, "term:sym<onlystar>")
    if_null rx1957_debug, debug_1376
    rx1957_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1957_pos)
  debug_1376:
    .return (rx1957_cur)
  rx1957_restart:
.annotate 'line', 469
    if_null rx1957_debug, debug_1377
    rx1957_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1377:
  rx1957_fail:
    (rx1957_rep, rx1957_pos, $I10, $P10) = rx1957_cur."!mark_fail"(0)
    lt rx1957_pos, -1, rx1957_done
    eq rx1957_pos, -1, rx1957_fail
    jump $I10
  rx1957_done:
    rx1957_cur."!cursor_fail"()
    if_null rx1957_debug, debug_1378
    rx1957_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1378:
    .return (rx1957_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1960"  :anon :subid("267_1321350766.1143") :outer("266_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1023
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1374
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1375
    die "Contextual $*MULTINESS not found"
  vivify_1375:
  vivify_1374:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("268_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P106, "ResizablePMCArray"
    push $P106, "{*}"
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("269_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1964_tgt
    .local int rx1964_pos
    .local int rx1964_off
    .local int rx1964_eos
    .local int rx1964_rep
    .local pmc rx1964_cur
    .local pmc rx1964_debug
    (rx1964_cur, rx1964_pos, rx1964_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1964_cur
    .local pmc match
    .lex "$/", match
    length rx1964_eos, rx1964_tgt
    gt rx1964_pos, rx1964_eos, rx1964_done
    set rx1964_off, 0
    lt rx1964_pos, 2, rx1964_start
    sub rx1964_off, rx1964_pos, 1
    substr rx1964_tgt, rx1964_tgt, rx1964_off
  rx1964_start:
    eq $I10, 1, rx1964_restart
    if_null rx1964_debug, debug_1379
    rx1964_cur."!cursor_debug"("START", "args")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1965_done
    goto rxscan1965_scan
  rxscan1965_loop:
    (rx1964_pos) = rx1964_cur."from"()
    inc rx1964_pos
    rx1964_cur."!cursor_from"(rx1964_pos)
    ge rx1964_pos, rx1964_eos, rxscan1965_done
  rxscan1965_scan:
    set_addr $I10, rxscan1965_loop
    rx1964_cur."!mark_push"(0, rx1964_pos, $I10)
  rxscan1965_done:
.annotate 'line', 1027
  # rx literal  "("
    add $I11, rx1964_pos, 1
    gt $I11, rx1964_eos, rx1964_fail
    sub $I11, rx1964_pos, rx1964_off
    ord $I11, rx1964_tgt, $I11
    ne $I11, 40, rx1964_fail
    add rx1964_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1964_cur."!cursor_pos"(rx1964_pos)
    $P10 = rx1964_cur."arglist"()
    unless $P10, rx1964_fail
    rx1964_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1964_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1964_pos, 1
    gt $I11, rx1964_eos, rx1964_fail
    sub $I11, rx1964_pos, rx1964_off
    ord $I11, rx1964_tgt, $I11
    ne $I11, 41, rx1964_fail
    add rx1964_pos, 1
  # rx pass
    rx1964_cur."!cursor_pass"(rx1964_pos, "args")
    if_null rx1964_debug, debug_1380
    rx1964_cur."!cursor_debug"("PASS", "args", " at pos=", rx1964_pos)
  debug_1380:
    .return (rx1964_cur)
  rx1964_restart:
.annotate 'line', 469
    if_null rx1964_debug, debug_1381
    rx1964_cur."!cursor_debug"("NEXT", "args")
  debug_1381:
  rx1964_fail:
    (rx1964_rep, rx1964_pos, $I10, $P10) = rx1964_cur."!mark_fail"(0)
    lt rx1964_pos, -1, rx1964_done
    eq rx1964_pos, -1, rx1964_fail
    jump $I10
  rx1964_done:
    rx1964_cur."!cursor_fail"()
    if_null rx1964_debug, debug_1382
    rx1964_cur."!cursor_debug"("FAIL", "args")
  debug_1382:
    .return (rx1964_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("270_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("arglist", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("271_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1968_tgt
    .local int rx1968_pos
    .local int rx1968_off
    .local int rx1968_eos
    .local int rx1968_rep
    .local pmc rx1968_cur
    .local pmc rx1968_debug
    (rx1968_cur, rx1968_pos, rx1968_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1968_cur
    .local pmc match
    .lex "$/", match
    length rx1968_eos, rx1968_tgt
    gt rx1968_pos, rx1968_eos, rx1968_done
    set rx1968_off, 0
    lt rx1968_pos, 2, rx1968_start
    sub rx1968_off, rx1968_pos, 1
    substr rx1968_tgt, rx1968_tgt, rx1968_off
  rx1968_start:
    eq $I10, 1, rx1968_restart
    if_null rx1968_debug, debug_1383
    rx1968_cur."!cursor_debug"("START", "arglist")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1969_done
    goto rxscan1969_scan
  rxscan1969_loop:
    (rx1968_pos) = rx1968_cur."from"()
    inc rx1968_pos
    rx1968_cur."!cursor_from"(rx1968_pos)
    ge rx1968_pos, rx1968_eos, rxscan1969_done
  rxscan1969_scan:
    set_addr $I10, rxscan1969_loop
    rx1968_cur."!mark_push"(0, rx1968_pos, $I10)
  rxscan1969_done:
.annotate 'line', 1031
  # rx subrule "ws" subtype=method negate=
    rx1968_cur."!cursor_pos"(rx1968_pos)
    $P10 = rx1968_cur."ws"()
    unless $P10, rx1968_fail
    rx1968_pos = $P10."pos"()
  alt1970_0:
.annotate 'line', 1032
    set_addr $I10, alt1970_1
    rx1968_cur."!mark_push"(0, rx1968_pos, $I10)
.annotate 'line', 1033
  # rx subrule "EXPR" subtype=capture negate=
    rx1968_cur."!cursor_pos"(rx1968_pos)
    $P10 = rx1968_cur."EXPR"("f=")
    unless $P10, rx1968_fail
    rx1968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1968_pos = $P10."pos"()
    goto alt1970_end
  alt1970_1:
  alt1970_end:
.annotate 'line', 1030
  # rx pass
    rx1968_cur."!cursor_pass"(rx1968_pos, "arglist")
    if_null rx1968_debug, debug_1384
    rx1968_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1968_pos)
  debug_1384:
    .return (rx1968_cur)
  rx1968_restart:
.annotate 'line', 469
    if_null rx1968_debug, debug_1385
    rx1968_cur."!cursor_debug"("NEXT", "arglist")
  debug_1385:
  rx1968_fail:
    (rx1968_rep, rx1968_pos, $I10, $P10) = rx1968_cur."!mark_fail"(0)
    lt rx1968_pos, -1, rx1968_done
    eq rx1968_pos, -1, rx1968_fail
    jump $I10
  rx1968_done:
    rx1968_cur."!cursor_fail"()
    if_null rx1968_debug, debug_1386
    rx1968_cur."!cursor_debug"("FAIL", "arglist")
  debug_1386:
    .return (rx1968_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("272_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("273_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1973_tgt
    .local int rx1973_pos
    .local int rx1973_off
    .local int rx1973_eos
    .local int rx1973_rep
    .local pmc rx1973_cur
    .local pmc rx1973_debug
    (rx1973_cur, rx1973_pos, rx1973_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1973_cur
    .local pmc match
    .lex "$/", match
    length rx1973_eos, rx1973_tgt
    gt rx1973_pos, rx1973_eos, rx1973_done
    set rx1973_off, 0
    lt rx1973_pos, 2, rx1973_start
    sub rx1973_off, rx1973_pos, 1
    substr rx1973_tgt, rx1973_tgt, rx1973_off
  rx1973_start:
    eq $I10, 1, rx1973_restart
    if_null rx1973_debug, debug_1387
    rx1973_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1974_done
    goto rxscan1974_scan
  rxscan1974_loop:
    (rx1973_pos) = rx1973_cur."from"()
    inc rx1973_pos
    rx1973_cur."!cursor_from"(rx1973_pos)
    ge rx1973_pos, rx1973_eos, rxscan1974_done
  rxscan1974_scan:
    set_addr $I10, rxscan1974_loop
    rx1973_cur."!mark_push"(0, rx1973_pos, $I10)
  rxscan1974_done:
.annotate 'line', 1039
  # rx subrule "value" subtype=capture negate=
    rx1973_cur."!cursor_pos"(rx1973_pos)
    $P10 = rx1973_cur."value"()
    unless $P10, rx1973_fail
    rx1973_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1973_pos = $P10."pos"()
  # rx pass
    rx1973_cur."!cursor_pass"(rx1973_pos, "term:sym<value>")
    if_null rx1973_debug, debug_1388
    rx1973_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1973_pos)
  debug_1388:
    .return (rx1973_cur)
  rx1973_restart:
.annotate 'line', 469
    if_null rx1973_debug, debug_1389
    rx1973_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1389:
  rx1973_fail:
    (rx1973_rep, rx1973_pos, $I10, $P10) = rx1973_cur."!mark_fail"(0)
    lt rx1973_pos, -1, rx1973_done
    eq rx1973_pos, -1, rx1973_fail
    jump $I10
  rx1973_done:
    rx1973_cur."!cursor_fail"()
    if_null rx1973_debug, debug_1390
    rx1973_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1390:
    .return (rx1973_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("274_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("value", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("275_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1977_tgt
    .local int rx1977_pos
    .local int rx1977_off
    .local int rx1977_eos
    .local int rx1977_rep
    .local pmc rx1977_cur
    .local pmc rx1977_debug
    (rx1977_cur, rx1977_pos, rx1977_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1977_cur
    .local pmc match
    .lex "$/", match
    length rx1977_eos, rx1977_tgt
    gt rx1977_pos, rx1977_eos, rx1977_done
    set rx1977_off, 0
    lt rx1977_pos, 2, rx1977_start
    sub rx1977_off, rx1977_pos, 1
    substr rx1977_tgt, rx1977_tgt, rx1977_off
  rx1977_start:
    eq $I10, 1, rx1977_restart
    if_null rx1977_debug, debug_1391
    rx1977_cur."!cursor_debug"("START", "value")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1978_done
    goto rxscan1978_scan
  rxscan1978_loop:
    (rx1977_pos) = rx1977_cur."from"()
    inc rx1977_pos
    rx1977_cur."!cursor_from"(rx1977_pos)
    ge rx1977_pos, rx1977_eos, rxscan1978_done
  rxscan1978_scan:
    set_addr $I10, rxscan1978_loop
    rx1977_cur."!mark_push"(0, rx1977_pos, $I10)
  rxscan1978_done:
  alt1979_0:
.annotate 'line', 1041
    set_addr $I10, alt1979_1
    rx1977_cur."!mark_push"(0, rx1977_pos, $I10)
.annotate 'line', 1042
  # rx subrule "quote" subtype=capture negate=
    rx1977_cur."!cursor_pos"(rx1977_pos)
    $P10 = rx1977_cur."quote"()
    unless $P10, rx1977_fail
    rx1977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1977_pos = $P10."pos"()
    goto alt1979_end
  alt1979_1:
.annotate 'line', 1043
  # rx subrule "number" subtype=capture negate=
    rx1977_cur."!cursor_pos"(rx1977_pos)
    $P10 = rx1977_cur."number"()
    unless $P10, rx1977_fail
    rx1977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1977_pos = $P10."pos"()
  alt1979_end:
.annotate 'line', 1041
  # rx pass
    rx1977_cur."!cursor_pass"(rx1977_pos, "value")
    if_null rx1977_debug, debug_1392
    rx1977_cur."!cursor_debug"("PASS", "value", " at pos=", rx1977_pos)
  debug_1392:
    .return (rx1977_cur)
  rx1977_restart:
.annotate 'line', 469
    if_null rx1977_debug, debug_1393
    rx1977_cur."!cursor_debug"("NEXT", "value")
  debug_1393:
  rx1977_fail:
    (rx1977_rep, rx1977_pos, $I10, $P10) = rx1977_cur."!mark_fail"(0)
    lt rx1977_pos, -1, rx1977_done
    eq rx1977_pos, -1, rx1977_fail
    jump $I10
  rx1977_done:
    rx1977_cur."!cursor_fail"()
    if_null rx1977_debug, debug_1394
    rx1977_cur."!cursor_debug"("FAIL", "value")
  debug_1394:
    .return (rx1977_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("276_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("number", "")
    $P104 = self."!PREFIX__!subrule"("quote", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("277_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1982_tgt
    .local int rx1982_pos
    .local int rx1982_off
    .local int rx1982_eos
    .local int rx1982_rep
    .local pmc rx1982_cur
    .local pmc rx1982_debug
    (rx1982_cur, rx1982_pos, rx1982_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1982_cur
    .local pmc match
    .lex "$/", match
    length rx1982_eos, rx1982_tgt
    gt rx1982_pos, rx1982_eos, rx1982_done
    set rx1982_off, 0
    lt rx1982_pos, 2, rx1982_start
    sub rx1982_off, rx1982_pos, 1
    substr rx1982_tgt, rx1982_tgt, rx1982_off
  rx1982_start:
    eq $I10, 1, rx1982_restart
    if_null rx1982_debug, debug_1395
    rx1982_cur."!cursor_debug"("START", "number")
  debug_1395:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1983_done
    goto rxscan1983_scan
  rxscan1983_loop:
    (rx1982_pos) = rx1982_cur."from"()
    inc rx1982_pos
    rx1982_cur."!cursor_from"(rx1982_pos)
    ge rx1982_pos, rx1982_eos, rxscan1983_done
  rxscan1983_scan:
    set_addr $I10, rxscan1983_loop
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
  rxscan1983_done:
.annotate 'line', 1047
  # rx subcapture "sign"
    set_addr $I10, rxcap_1985_fail
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1982_pos, rx1982_off
    set rx1982_rep, 0
    sub $I12, rx1982_eos, rx1982_pos
    le $I12, 1, rxenumcharlistq1984_loop
    set $I12, 1
  rxenumcharlistq1984_loop:
    le $I12, 0, rxenumcharlistq1984_done
    substr $S10, rx1982_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1984_done
    inc rx1982_rep
  rxenumcharlistq1984_done:
    add rx1982_pos, rx1982_pos, rx1982_rep
    set_addr $I10, rxcap_1985_fail
    ($I12, $I11) = rx1982_cur."!mark_peek"($I10)
    rx1982_cur."!cursor_pos"($I11)
    ($P10) = rx1982_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1982_pos, "")
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1985_done
  rxcap_1985_fail:
    goto rx1982_fail
  rxcap_1985_done:
  alt1986_0:
.annotate 'line', 1048
    set_addr $I10, alt1986_1
    rx1982_cur."!mark_push"(0, rx1982_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1982_cur."!cursor_pos"(rx1982_pos)
    $P10 = rx1982_cur."dec_number"()
    unless $P10, rx1982_fail
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1982_pos = $P10."pos"()
    goto alt1986_end
  alt1986_1:
  # rx subrule "integer" subtype=capture negate=
    rx1982_cur."!cursor_pos"(rx1982_pos)
    $P10 = rx1982_cur."integer"()
    unless $P10, rx1982_fail
    rx1982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1982_pos = $P10."pos"()
  alt1986_end:
.annotate 'line', 1046
  # rx pass
    rx1982_cur."!cursor_pass"(rx1982_pos, "number")
    if_null rx1982_debug, debug_1396
    rx1982_cur."!cursor_debug"("PASS", "number", " at pos=", rx1982_pos)
  debug_1396:
    .return (rx1982_cur)
  rx1982_restart:
.annotate 'line', 469
    if_null rx1982_debug, debug_1397
    rx1982_cur."!cursor_debug"("NEXT", "number")
  debug_1397:
  rx1982_fail:
    (rx1982_rep, rx1982_pos, $I10, $P10) = rx1982_cur."!mark_fail"(0)
    lt rx1982_pos, -1, rx1982_done
    eq rx1982_pos, -1, rx1982_fail
    jump $I10
  rx1982_done:
    rx1982_cur."!cursor_fail"()
    if_null rx1982_debug, debug_1398
    rx1982_cur."!cursor_debug"("FAIL", "number")
  debug_1398:
    .return (rx1982_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("278_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("279_1321350766.1143")
    .param pmc param_1989
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1051
    .lex "self", param_1989
    $P103 = param_1989."!protoregex"("quote")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("280_1321350766.1143")
    .param pmc param_1991
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1051
    .lex "self", param_1991
    $P104 = param_1991."!PREFIX__!protoregex"("quote")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("281_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1993_tgt
    .local int rx1993_pos
    .local int rx1993_off
    .local int rx1993_eos
    .local int rx1993_rep
    .local pmc rx1993_cur
    .local pmc rx1993_debug
    (rx1993_cur, rx1993_pos, rx1993_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1993_cur
    .local pmc match
    .lex "$/", match
    length rx1993_eos, rx1993_tgt
    gt rx1993_pos, rx1993_eos, rx1993_done
    set rx1993_off, 0
    lt rx1993_pos, 2, rx1993_start
    sub rx1993_off, rx1993_pos, 1
    substr rx1993_tgt, rx1993_tgt, rx1993_off
  rx1993_start:
    eq $I10, 1, rx1993_restart
    if_null rx1993_debug, debug_1399
    rx1993_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1399:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1994_done
    goto rxscan1994_scan
  rxscan1994_loop:
    (rx1993_pos) = rx1993_cur."from"()
    inc rx1993_pos
    rx1993_cur."!cursor_from"(rx1993_pos)
    ge rx1993_pos, rx1993_eos, rxscan1994_done
  rxscan1994_scan:
    set_addr $I10, rxscan1994_loop
    rx1993_cur."!mark_push"(0, rx1993_pos, $I10)
  rxscan1994_done:
.annotate 'line', 1052
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1993_pos, rx1993_off
    substr $S10, rx1993_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1993_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1993_cur."!cursor_pos"(rx1993_pos)
    $P10 = rx1993_cur."quote_EXPR"(":q")
    unless $P10, rx1993_fail
    rx1993_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1993_pos = $P10."pos"()
  # rx pass
    rx1993_cur."!cursor_pass"(rx1993_pos, "quote:sym<apos>")
    if_null rx1993_debug, debug_1400
    rx1993_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1993_pos)
  debug_1400:
    .return (rx1993_cur)
  rx1993_restart:
.annotate 'line', 469
    if_null rx1993_debug, debug_1401
    rx1993_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1401:
  rx1993_fail:
    (rx1993_rep, rx1993_pos, $I10, $P10) = rx1993_cur."!mark_fail"(0)
    lt rx1993_pos, -1, rx1993_done
    eq rx1993_pos, -1, rx1993_fail
    jump $I10
  rx1993_done:
    rx1993_cur."!cursor_fail"()
    if_null rx1993_debug, debug_1402
    rx1993_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1402:
    .return (rx1993_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("282_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "'"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("283_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx1997_tgt
    .local int rx1997_pos
    .local int rx1997_off
    .local int rx1997_eos
    .local int rx1997_rep
    .local pmc rx1997_cur
    .local pmc rx1997_debug
    (rx1997_cur, rx1997_pos, rx1997_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1997_cur
    .local pmc match
    .lex "$/", match
    length rx1997_eos, rx1997_tgt
    gt rx1997_pos, rx1997_eos, rx1997_done
    set rx1997_off, 0
    lt rx1997_pos, 2, rx1997_start
    sub rx1997_off, rx1997_pos, 1
    substr rx1997_tgt, rx1997_tgt, rx1997_off
  rx1997_start:
    eq $I10, 1, rx1997_restart
    if_null rx1997_debug, debug_1403
    rx1997_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1403:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1998_done
    goto rxscan1998_scan
  rxscan1998_loop:
    (rx1997_pos) = rx1997_cur."from"()
    inc rx1997_pos
    rx1997_cur."!cursor_from"(rx1997_pos)
    ge rx1997_pos, rx1997_eos, rxscan1998_done
  rxscan1998_scan:
    set_addr $I10, rxscan1998_loop
    rx1997_cur."!mark_push"(0, rx1997_pos, $I10)
  rxscan1998_done:
.annotate 'line', 1053
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1997_pos, rx1997_off
    substr $S10, rx1997_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1997_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1997_cur."!cursor_pos"(rx1997_pos)
    $P10 = rx1997_cur."quote_EXPR"(":qq")
    unless $P10, rx1997_fail
    rx1997_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1997_pos = $P10."pos"()
  # rx pass
    rx1997_cur."!cursor_pass"(rx1997_pos, "quote:sym<dblq>")
    if_null rx1997_debug, debug_1404
    rx1997_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1997_pos)
  debug_1404:
    .return (rx1997_cur)
  rx1997_restart:
.annotate 'line', 469
    if_null rx1997_debug, debug_1405
    rx1997_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1405:
  rx1997_fail:
    (rx1997_rep, rx1997_pos, $I10, $P10) = rx1997_cur."!mark_fail"(0)
    lt rx1997_pos, -1, rx1997_done
    eq rx1997_pos, -1, rx1997_fail
    jump $I10
  rx1997_done:
    rx1997_cur."!cursor_fail"()
    if_null rx1997_debug, debug_1406
    rx1997_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1406:
    .return (rx1997_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("284_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "\""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("285_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2001_tgt
    .local int rx2001_pos
    .local int rx2001_off
    .local int rx2001_eos
    .local int rx2001_rep
    .local pmc rx2001_cur
    .local pmc rx2001_debug
    (rx2001_cur, rx2001_pos, rx2001_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2001_cur
    .local pmc match
    .lex "$/", match
    length rx2001_eos, rx2001_tgt
    gt rx2001_pos, rx2001_eos, rx2001_done
    set rx2001_off, 0
    lt rx2001_pos, 2, rx2001_start
    sub rx2001_off, rx2001_pos, 1
    substr rx2001_tgt, rx2001_tgt, rx2001_off
  rx2001_start:
    eq $I10, 1, rx2001_restart
    if_null rx2001_debug, debug_1407
    rx2001_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1407:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2002_done
    goto rxscan2002_scan
  rxscan2002_loop:
    (rx2001_pos) = rx2001_cur."from"()
    inc rx2001_pos
    rx2001_cur."!cursor_from"(rx2001_pos)
    ge rx2001_pos, rx2001_eos, rxscan2002_done
  rxscan2002_scan:
    set_addr $I10, rxscan2002_loop
    rx2001_cur."!mark_push"(0, rx2001_pos, $I10)
  rxscan2002_done:
.annotate 'line', 1054
  # rx subcapture "sym"
    set_addr $I10, rxcap_2003_fail
    rx2001_cur."!mark_push"(0, rx2001_pos, $I10)
  # rx literal  "q"
    add $I11, rx2001_pos, 1
    gt $I11, rx2001_eos, rx2001_fail
    sub $I11, rx2001_pos, rx2001_off
    ord $I11, rx2001_tgt, $I11
    ne $I11, 113, rx2001_fail
    add rx2001_pos, 1
    set_addr $I10, rxcap_2003_fail
    ($I12, $I11) = rx2001_cur."!mark_peek"($I10)
    rx2001_cur."!cursor_pos"($I11)
    ($P10) = rx2001_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2001_pos, "")
    rx2001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2003_done
  rxcap_2003_fail:
    goto rx2001_fail
  rxcap_2003_done:
  # rxanchor rwb
    le rx2001_pos, 0, rx2001_fail
    sub $I10, rx2001_pos, rx2001_off
    is_cclass $I11, .CCLASS_WORD, rx2001_tgt, $I10
    if $I11, rx2001_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2001_tgt, $I10
    unless $I11, rx2001_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2001_pos, rx2001_off
    substr $S10, rx2001_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2001_fail
  # rx subrule "ws" subtype=method negate=
    rx2001_cur."!cursor_pos"(rx2001_pos)
    $P10 = rx2001_cur."ws"()
    unless $P10, rx2001_fail
    rx2001_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2001_cur."!cursor_pos"(rx2001_pos)
    $P10 = rx2001_cur."quote_EXPR"(":q")
    unless $P10, rx2001_fail
    rx2001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2001_pos = $P10."pos"()
  # rx pass
    rx2001_cur."!cursor_pass"(rx2001_pos, "quote:sym<q>")
    if_null rx2001_debug, debug_1408
    rx2001_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx2001_pos)
  debug_1408:
    .return (rx2001_cur)
  rx2001_restart:
.annotate 'line', 469
    if_null rx2001_debug, debug_1409
    rx2001_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1409:
  rx2001_fail:
    (rx2001_rep, rx2001_pos, $I10, $P10) = rx2001_cur."!mark_fail"(0)
    lt rx2001_pos, -1, rx2001_done
    eq rx2001_pos, -1, rx2001_fail
    jump $I10
  rx2001_done:
    rx2001_cur."!cursor_fail"()
    if_null rx2001_debug, debug_1410
    rx2001_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1410:
    .return (rx2001_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("286_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("287_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2006_tgt
    .local int rx2006_pos
    .local int rx2006_off
    .local int rx2006_eos
    .local int rx2006_rep
    .local pmc rx2006_cur
    .local pmc rx2006_debug
    (rx2006_cur, rx2006_pos, rx2006_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2006_cur
    .local pmc match
    .lex "$/", match
    length rx2006_eos, rx2006_tgt
    gt rx2006_pos, rx2006_eos, rx2006_done
    set rx2006_off, 0
    lt rx2006_pos, 2, rx2006_start
    sub rx2006_off, rx2006_pos, 1
    substr rx2006_tgt, rx2006_tgt, rx2006_off
  rx2006_start:
    eq $I10, 1, rx2006_restart
    if_null rx2006_debug, debug_1411
    rx2006_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1411:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2007_done
    goto rxscan2007_scan
  rxscan2007_loop:
    (rx2006_pos) = rx2006_cur."from"()
    inc rx2006_pos
    rx2006_cur."!cursor_from"(rx2006_pos)
    ge rx2006_pos, rx2006_eos, rxscan2007_done
  rxscan2007_scan:
    set_addr $I10, rxscan2007_loop
    rx2006_cur."!mark_push"(0, rx2006_pos, $I10)
  rxscan2007_done:
.annotate 'line', 1055
  # rx subcapture "sym"
    set_addr $I10, rxcap_2008_fail
    rx2006_cur."!mark_push"(0, rx2006_pos, $I10)
  # rx literal  "qq"
    add $I11, rx2006_pos, 2
    gt $I11, rx2006_eos, rx2006_fail
    sub $I11, rx2006_pos, rx2006_off
    substr $S10, rx2006_tgt, $I11, 2
    ne $S10, "qq", rx2006_fail
    add rx2006_pos, 2
    set_addr $I10, rxcap_2008_fail
    ($I12, $I11) = rx2006_cur."!mark_peek"($I10)
    rx2006_cur."!cursor_pos"($I11)
    ($P10) = rx2006_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2006_pos, "")
    rx2006_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2008_done
  rxcap_2008_fail:
    goto rx2006_fail
  rxcap_2008_done:
  # rxanchor rwb
    le rx2006_pos, 0, rx2006_fail
    sub $I10, rx2006_pos, rx2006_off
    is_cclass $I11, .CCLASS_WORD, rx2006_tgt, $I10
    if $I11, rx2006_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2006_tgt, $I10
    unless $I11, rx2006_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2006_pos, rx2006_off
    substr $S10, rx2006_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2006_fail
  # rx subrule "ws" subtype=method negate=
    rx2006_cur."!cursor_pos"(rx2006_pos)
    $P10 = rx2006_cur."ws"()
    unless $P10, rx2006_fail
    rx2006_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2006_cur."!cursor_pos"(rx2006_pos)
    $P10 = rx2006_cur."quote_EXPR"(":qq")
    unless $P10, rx2006_fail
    rx2006_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2006_pos = $P10."pos"()
  # rx pass
    rx2006_cur."!cursor_pass"(rx2006_pos, "quote:sym<qq>")
    if_null rx2006_debug, debug_1412
    rx2006_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx2006_pos)
  debug_1412:
    .return (rx2006_cur)
  rx2006_restart:
.annotate 'line', 469
    if_null rx2006_debug, debug_1413
    rx2006_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1413:
  rx2006_fail:
    (rx2006_rep, rx2006_pos, $I10, $P10) = rx2006_cur."!mark_fail"(0)
    lt rx2006_pos, -1, rx2006_done
    eq rx2006_pos, -1, rx2006_fail
    jump $I10
  rx2006_done:
    rx2006_cur."!cursor_fail"()
    if_null rx2006_debug, debug_1414
    rx2006_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1414:
    .return (rx2006_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("288_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "qq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("289_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2011_tgt
    .local int rx2011_pos
    .local int rx2011_off
    .local int rx2011_eos
    .local int rx2011_rep
    .local pmc rx2011_cur
    .local pmc rx2011_debug
    (rx2011_cur, rx2011_pos, rx2011_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2011_cur
    .local pmc match
    .lex "$/", match
    length rx2011_eos, rx2011_tgt
    gt rx2011_pos, rx2011_eos, rx2011_done
    set rx2011_off, 0
    lt rx2011_pos, 2, rx2011_start
    sub rx2011_off, rx2011_pos, 1
    substr rx2011_tgt, rx2011_tgt, rx2011_off
  rx2011_start:
    eq $I10, 1, rx2011_restart
    if_null rx2011_debug, debug_1415
    rx2011_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1415:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2012_done
    goto rxscan2012_scan
  rxscan2012_loop:
    (rx2011_pos) = rx2011_cur."from"()
    inc rx2011_pos
    rx2011_cur."!cursor_from"(rx2011_pos)
    ge rx2011_pos, rx2011_eos, rxscan2012_done
  rxscan2012_scan:
    set_addr $I10, rxscan2012_loop
    rx2011_cur."!mark_push"(0, rx2011_pos, $I10)
  rxscan2012_done:
.annotate 'line', 1056
  # rx subcapture "sym"
    set_addr $I10, rxcap_2013_fail
    rx2011_cur."!mark_push"(0, rx2011_pos, $I10)
  # rx literal  "Q"
    add $I11, rx2011_pos, 1
    gt $I11, rx2011_eos, rx2011_fail
    sub $I11, rx2011_pos, rx2011_off
    ord $I11, rx2011_tgt, $I11
    ne $I11, 81, rx2011_fail
    add rx2011_pos, 1
    set_addr $I10, rxcap_2013_fail
    ($I12, $I11) = rx2011_cur."!mark_peek"($I10)
    rx2011_cur."!cursor_pos"($I11)
    ($P10) = rx2011_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2011_pos, "")
    rx2011_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2013_done
  rxcap_2013_fail:
    goto rx2011_fail
  rxcap_2013_done:
  # rxanchor rwb
    le rx2011_pos, 0, rx2011_fail
    sub $I10, rx2011_pos, rx2011_off
    is_cclass $I11, .CCLASS_WORD, rx2011_tgt, $I10
    if $I11, rx2011_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2011_tgt, $I10
    unless $I11, rx2011_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2011_pos, rx2011_off
    substr $S10, rx2011_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2011_fail
  # rx subrule "ws" subtype=method negate=
    rx2011_cur."!cursor_pos"(rx2011_pos)
    $P10 = rx2011_cur."ws"()
    unless $P10, rx2011_fail
    rx2011_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2011_cur."!cursor_pos"(rx2011_pos)
    $P10 = rx2011_cur."quote_EXPR"()
    unless $P10, rx2011_fail
    rx2011_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2011_pos = $P10."pos"()
  # rx pass
    rx2011_cur."!cursor_pass"(rx2011_pos, "quote:sym<Q>")
    if_null rx2011_debug, debug_1416
    rx2011_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx2011_pos)
  debug_1416:
    .return (rx2011_cur)
  rx2011_restart:
.annotate 'line', 469
    if_null rx2011_debug, debug_1417
    rx2011_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1417:
  rx2011_fail:
    (rx2011_rep, rx2011_pos, $I10, $P10) = rx2011_cur."!mark_fail"(0)
    lt rx2011_pos, -1, rx2011_done
    eq rx2011_pos, -1, rx2011_fail
    jump $I10
  rx2011_done:
    rx2011_cur."!cursor_fail"()
    if_null rx2011_debug, debug_1418
    rx2011_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1418:
    .return (rx2011_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("290_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "Q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("291_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2016_tgt
    .local int rx2016_pos
    .local int rx2016_off
    .local int rx2016_eos
    .local int rx2016_rep
    .local pmc rx2016_cur
    .local pmc rx2016_debug
    (rx2016_cur, rx2016_pos, rx2016_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2016_cur
    .local pmc match
    .lex "$/", match
    length rx2016_eos, rx2016_tgt
    gt rx2016_pos, rx2016_eos, rx2016_done
    set rx2016_off, 0
    lt rx2016_pos, 2, rx2016_start
    sub rx2016_off, rx2016_pos, 1
    substr rx2016_tgt, rx2016_tgt, rx2016_off
  rx2016_start:
    eq $I10, 1, rx2016_restart
    if_null rx2016_debug, debug_1419
    rx2016_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1419:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2017_done
    goto rxscan2017_scan
  rxscan2017_loop:
    (rx2016_pos) = rx2016_cur."from"()
    inc rx2016_pos
    rx2016_cur."!cursor_from"(rx2016_pos)
    ge rx2016_pos, rx2016_eos, rxscan2017_done
  rxscan2017_scan:
    set_addr $I10, rxscan2017_loop
    rx2016_cur."!mark_push"(0, rx2016_pos, $I10)
  rxscan2017_done:
.annotate 'line', 1057
  # rx subcapture "sym"
    set_addr $I10, rxcap_2018_fail
    rx2016_cur."!mark_push"(0, rx2016_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx2016_pos, 5
    gt $I11, rx2016_eos, rx2016_fail
    sub $I11, rx2016_pos, rx2016_off
    substr $S10, rx2016_tgt, $I11, 5
    ne $S10, "Q:PIR", rx2016_fail
    add rx2016_pos, 5
    set_addr $I10, rxcap_2018_fail
    ($I12, $I11) = rx2016_cur."!mark_peek"($I10)
    rx2016_cur."!cursor_pos"($I11)
    ($P10) = rx2016_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2016_pos, "")
    rx2016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2018_done
  rxcap_2018_fail:
    goto rx2016_fail
  rxcap_2018_done:
  # rx subrule "ws" subtype=method negate=
    rx2016_cur."!cursor_pos"(rx2016_pos)
    $P10 = rx2016_cur."ws"()
    unless $P10, rx2016_fail
    rx2016_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2016_cur."!cursor_pos"(rx2016_pos)
    $P10 = rx2016_cur."quote_EXPR"()
    unless $P10, rx2016_fail
    rx2016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2016_pos = $P10."pos"()
  # rx pass
    rx2016_cur."!cursor_pass"(rx2016_pos, "quote:sym<Q:PIR>")
    if_null rx2016_debug, debug_1420
    rx2016_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx2016_pos)
  debug_1420:
    .return (rx2016_cur)
  rx2016_restart:
.annotate 'line', 469
    if_null rx2016_debug, debug_1421
    rx2016_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1421:
  rx2016_fail:
    (rx2016_rep, rx2016_pos, $I10, $P10) = rx2016_cur."!mark_fail"(0)
    lt rx2016_pos, -1, rx2016_done
    eq rx2016_pos, -1, rx2016_fail
    jump $I10
  rx2016_done:
    rx2016_cur."!cursor_fail"()
    if_null rx2016_debug, debug_1422
    rx2016_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1422:
    .return (rx2016_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("292_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("293_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2021_tgt
    .local int rx2021_pos
    .local int rx2021_off
    .local int rx2021_eos
    .local int rx2021_rep
    .local pmc rx2021_cur
    .local pmc rx2021_debug
    (rx2021_cur, rx2021_pos, rx2021_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2021_cur
    .local pmc match
    .lex "$/", match
    length rx2021_eos, rx2021_tgt
    gt rx2021_pos, rx2021_eos, rx2021_done
    set rx2021_off, 0
    lt rx2021_pos, 2, rx2021_start
    sub rx2021_off, rx2021_pos, 1
    substr rx2021_tgt, rx2021_tgt, rx2021_off
  rx2021_start:
    eq $I10, 1, rx2021_restart
    if_null rx2021_debug, debug_1423
    rx2021_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1423:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2022_done
    goto rxscan2022_scan
  rxscan2022_loop:
    (rx2021_pos) = rx2021_cur."from"()
    inc rx2021_pos
    rx2021_cur."!cursor_from"(rx2021_pos)
    ge rx2021_pos, rx2021_eos, rxscan2022_done
  rxscan2022_scan:
    set_addr $I10, rxscan2022_loop
    rx2021_cur."!mark_push"(0, rx2021_pos, $I10)
  rxscan2022_done:
.annotate 'line', 1059
  # rx literal  "/"
    add $I11, rx2021_pos, 1
    gt $I11, rx2021_eos, rx2021_fail
    sub $I11, rx2021_pos, rx2021_off
    ord $I11, rx2021_tgt, $I11
    ne $I11, 47, rx2021_fail
    add rx2021_pos, 1
.annotate 'line', 1060
  # rx subrule "newpad" subtype=method negate=
    rx2021_cur."!cursor_pos"(rx2021_pos)
    $P10 = rx2021_cur."newpad"()
    unless $P10, rx2021_fail
    rx2021_pos = $P10."pos"()
.annotate 'line', 1061
  # rx reduce name="quote:sym</ />" key="open"
    rx2021_cur."!cursor_pos"(rx2021_pos)
    rx2021_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1062
  # rx subrule "LANG" subtype=capture negate=
    rx2021_cur."!cursor_pos"(rx2021_pos)
    $P10 = rx2021_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2021_fail
    rx2021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2021_pos = $P10."pos"()
.annotate 'line', 1063
  # rx literal  "/"
    add $I11, rx2021_pos, 1
    gt $I11, rx2021_eos, rx2021_fail
    sub $I11, rx2021_pos, rx2021_off
    ord $I11, rx2021_tgt, $I11
    ne $I11, 47, rx2021_fail
    add rx2021_pos, 1
.annotate 'line', 1058
  # rx pass
    rx2021_cur."!cursor_pass"(rx2021_pos, "quote:sym</ />")
    if_null rx2021_debug, debug_1424
    rx2021_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2021_pos)
  debug_1424:
    .return (rx2021_cur)
  rx2021_restart:
.annotate 'line', 469
    if_null rx2021_debug, debug_1425
    rx2021_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1425:
  rx2021_fail:
    (rx2021_rep, rx2021_pos, $I10, $P10) = rx2021_cur."!mark_fail"(0)
    lt rx2021_pos, -1, rx2021_done
    eq rx2021_pos, -1, rx2021_fail
    jump $I10
  rx2021_done:
    rx2021_cur."!cursor_fail"()
    if_null rx2021_debug, debug_1426
    rx2021_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1426:
    .return (rx2021_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("294_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("newpad", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("295_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2025_tgt
    .local int rx2025_pos
    .local int rx2025_off
    .local int rx2025_eos
    .local int rx2025_rep
    .local pmc rx2025_cur
    .local pmc rx2025_debug
    (rx2025_cur, rx2025_pos, rx2025_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2025_cur
    .local pmc match
    .lex "$/", match
    length rx2025_eos, rx2025_tgt
    gt rx2025_pos, rx2025_eos, rx2025_done
    set rx2025_off, 0
    lt rx2025_pos, 2, rx2025_start
    sub rx2025_off, rx2025_pos, 1
    substr rx2025_tgt, rx2025_tgt, rx2025_off
  rx2025_start:
    eq $I10, 1, rx2025_restart
    if_null rx2025_debug, debug_1427
    rx2025_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1427:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2026_done
    goto rxscan2026_scan
  rxscan2026_loop:
    (rx2025_pos) = rx2025_cur."from"()
    inc rx2025_pos
    rx2025_cur."!cursor_from"(rx2025_pos)
    ge rx2025_pos, rx2025_eos, rxscan2026_done
  rxscan2026_scan:
    set_addr $I10, rxscan2026_loop
    rx2025_cur."!mark_push"(0, rx2025_pos, $I10)
  rxscan2026_done:
.annotate 'line', 1066
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2025_pos, rx2025_off
    substr $S10, rx2025_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2025_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."quotemod_check"("s")
    unless $P10, rx2025_fail
  # rx subrule "variable" subtype=capture negate=
    rx2025_cur."!cursor_pos"(rx2025_pos)
    $P10 = rx2025_cur."variable"()
    unless $P10, rx2025_fail
    rx2025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2025_pos = $P10."pos"()
  # rx pass
    rx2025_cur."!cursor_pass"(rx2025_pos, "quote_escape:sym<$>")
    if_null rx2025_debug, debug_1428
    rx2025_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2025_pos)
  debug_1428:
    .return (rx2025_cur)
  rx2025_restart:
.annotate 'line', 469
    if_null rx2025_debug, debug_1429
    rx2025_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1429:
  rx2025_fail:
    (rx2025_rep, rx2025_pos, $I10, $P10) = rx2025_cur."!mark_fail"(0)
    lt rx2025_pos, -1, rx2025_done
    eq rx2025_pos, -1, rx2025_fail
    jump $I10
  rx2025_done:
    rx2025_cur."!cursor_fail"()
    if_null rx2025_debug, debug_1430
    rx2025_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1430:
    .return (rx2025_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("296_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("297_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2029_tgt
    .local int rx2029_pos
    .local int rx2029_off
    .local int rx2029_eos
    .local int rx2029_rep
    .local pmc rx2029_cur
    .local pmc rx2029_debug
    (rx2029_cur, rx2029_pos, rx2029_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2029_cur
    .local pmc match
    .lex "$/", match
    length rx2029_eos, rx2029_tgt
    gt rx2029_pos, rx2029_eos, rx2029_done
    set rx2029_off, 0
    lt rx2029_pos, 2, rx2029_start
    sub rx2029_off, rx2029_pos, 1
    substr rx2029_tgt, rx2029_tgt, rx2029_off
  rx2029_start:
    eq $I10, 1, rx2029_restart
    if_null rx2029_debug, debug_1431
    rx2029_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1431:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2030_done
    goto rxscan2030_scan
  rxscan2030_loop:
    (rx2029_pos) = rx2029_cur."from"()
    inc rx2029_pos
    rx2029_cur."!cursor_from"(rx2029_pos)
    ge rx2029_pos, rx2029_eos, rxscan2030_done
  rxscan2030_scan:
    set_addr $I10, rxscan2030_loop
    rx2029_cur."!mark_push"(0, rx2029_pos, $I10)
  rxscan2030_done:
.annotate 'line', 1067
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2029_pos, rx2029_off
    substr $S10, rx2029_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2029_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2029_cur."!cursor_pos"(rx2029_pos)
    $P10 = rx2029_cur."quotemod_check"("c")
    unless $P10, rx2029_fail
  # rx subrule "block" subtype=capture negate=
    rx2029_cur."!cursor_pos"(rx2029_pos)
    $P10 = rx2029_cur."block"()
    unless $P10, rx2029_fail
    rx2029_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2029_pos = $P10."pos"()
  # rx pass
    rx2029_cur."!cursor_pass"(rx2029_pos, "quote_escape:sym<{ }>")
    if_null rx2029_debug, debug_1432
    rx2029_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2029_pos)
  debug_1432:
    .return (rx2029_cur)
  rx2029_restart:
.annotate 'line', 469
    if_null rx2029_debug, debug_1433
    rx2029_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1433:
  rx2029_fail:
    (rx2029_rep, rx2029_pos, $I10, $P10) = rx2029_cur."!mark_fail"(0)
    lt rx2029_pos, -1, rx2029_done
    eq rx2029_pos, -1, rx2029_fail
    jump $I10
  rx2029_done:
    rx2029_cur."!cursor_fail"()
    if_null rx2029_debug, debug_1434
    rx2029_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1434:
    .return (rx2029_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("298_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("299_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2033_tgt
    .local int rx2033_pos
    .local int rx2033_off
    .local int rx2033_eos
    .local int rx2033_rep
    .local pmc rx2033_cur
    .local pmc rx2033_debug
    (rx2033_cur, rx2033_pos, rx2033_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2033_cur
    .local pmc match
    .lex "$/", match
    length rx2033_eos, rx2033_tgt
    gt rx2033_pos, rx2033_eos, rx2033_done
    set rx2033_off, 0
    lt rx2033_pos, 2, rx2033_start
    sub rx2033_off, rx2033_pos, 1
    substr rx2033_tgt, rx2033_tgt, rx2033_off
  rx2033_start:
    eq $I10, 1, rx2033_restart
    if_null rx2033_debug, debug_1435
    rx2033_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1435:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2034_done
    goto rxscan2034_scan
  rxscan2034_loop:
    (rx2033_pos) = rx2033_cur."from"()
    inc rx2033_pos
    rx2033_cur."!cursor_from"(rx2033_pos)
    ge rx2033_pos, rx2033_eos, rxscan2034_done
  rxscan2034_scan:
    set_addr $I10, rxscan2034_loop
    rx2033_cur."!mark_push"(0, rx2033_pos, $I10)
  rxscan2034_done:
.annotate 'line', 1068
  # rx literal  "\\e"
    add $I11, rx2033_pos, 2
    gt $I11, rx2033_eos, rx2033_fail
    sub $I11, rx2033_pos, rx2033_off
    substr $S10, rx2033_tgt, $I11, 2
    ne $S10, "\\e", rx2033_fail
    add rx2033_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2033_cur."!cursor_pos"(rx2033_pos)
    $P10 = rx2033_cur."quotemod_check"("b")
    unless $P10, rx2033_fail
  # rx pass
    rx2033_cur."!cursor_pass"(rx2033_pos, "quote_escape:sym<esc>")
    if_null rx2033_debug, debug_1436
    rx2033_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2033_pos)
  debug_1436:
    .return (rx2033_cur)
  rx2033_restart:
.annotate 'line', 469
    if_null rx2033_debug, debug_1437
    rx2033_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1437:
  rx2033_fail:
    (rx2033_rep, rx2033_pos, $I10, $P10) = rx2033_cur."!mark_fail"(0)
    lt rx2033_pos, -1, rx2033_done
    eq rx2033_pos, -1, rx2033_fail
    jump $I10
  rx2033_done:
    rx2033_cur."!cursor_fail"()
    if_null rx2033_debug, debug_1438
    rx2033_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1438:
    .return (rx2033_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("300_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "\\e"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("301_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2037_tgt
    .local int rx2037_pos
    .local int rx2037_off
    .local int rx2037_eos
    .local int rx2037_rep
    .local pmc rx2037_cur
    .local pmc rx2037_debug
    (rx2037_cur, rx2037_pos, rx2037_tgt, $I10) = self."!cursor_start"()
    rx2037_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2037_cur
    .local pmc match
    .lex "$/", match
    length rx2037_eos, rx2037_tgt
    gt rx2037_pos, rx2037_eos, rx2037_done
    set rx2037_off, 0
    lt rx2037_pos, 2, rx2037_start
    sub rx2037_off, rx2037_pos, 1
    substr rx2037_tgt, rx2037_tgt, rx2037_off
  rx2037_start:
    eq $I10, 1, rx2037_restart
    if_null rx2037_debug, debug_1439
    rx2037_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1439:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2038_done
    goto rxscan2038_scan
  rxscan2038_loop:
    (rx2037_pos) = rx2037_cur."from"()
    inc rx2037_pos
    rx2037_cur."!cursor_from"(rx2037_pos)
    ge rx2037_pos, rx2037_eos, rxscan2038_done
  rxscan2038_scan:
    set_addr $I10, rxscan2038_loop
    rx2037_cur."!mark_push"(0, rx2037_pos, $I10)
  rxscan2038_done:
.annotate 'line', 1070
  # rx literal  "("
    add $I11, rx2037_pos, 1
    gt $I11, rx2037_eos, rx2037_fail
    sub $I11, rx2037_pos, rx2037_off
    ord $I11, rx2037_tgt, $I11
    ne $I11, 40, rx2037_fail
    add rx2037_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2037_cur."!cursor_pos"(rx2037_pos)
    $P10 = rx2037_cur."ws"()
    unless $P10, rx2037_fail
    rx2037_pos = $P10."pos"()
  # rx rxquantr2039 ** 0..1
    set_addr $I10, rxquantr2039_done
    rx2037_cur."!mark_push"(0, rx2037_pos, $I10)
  rxquantr2039_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2037_cur."!cursor_pos"(rx2037_pos)
    $P10 = rx2037_cur."EXPR"()
    unless $P10, rx2037_fail
    goto rxsubrule2040_pass
  rxsubrule2040_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2037_fail
  rxsubrule2040_pass:
    set_addr $I10, rxsubrule2040_back
    rx2037_cur."!mark_push"(0, rx2037_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2037_pos = $P10."pos"()
    set_addr $I10, rxquantr2039_done
    (rx2037_rep) = rx2037_cur."!mark_commit"($I10)
  rxquantr2039_done:
  # rx literal  ")"
    add $I11, rx2037_pos, 1
    gt $I11, rx2037_eos, rx2037_fail
    sub $I11, rx2037_pos, rx2037_off
    ord $I11, rx2037_tgt, $I11
    ne $I11, 41, rx2037_fail
    add rx2037_pos, 1
  # rx pass
    rx2037_cur."!cursor_pass"(rx2037_pos, "circumfix:sym<( )>")
    if_null rx2037_debug, debug_1440
    rx2037_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2037_pos)
  debug_1440:
    .return (rx2037_cur)
  rx2037_restart:
.annotate 'line', 469
    if_null rx2037_debug, debug_1441
    rx2037_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1441:
  rx2037_fail:
    (rx2037_rep, rx2037_pos, $I10, $P10) = rx2037_cur."!mark_fail"(0)
    lt rx2037_pos, -1, rx2037_done
    eq rx2037_pos, -1, rx2037_fail
    jump $I10
  rx2037_done:
    rx2037_cur."!cursor_fail"()
    if_null rx2037_debug, debug_1442
    rx2037_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1442:
    .return (rx2037_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("302_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("303_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2043_tgt
    .local int rx2043_pos
    .local int rx2043_off
    .local int rx2043_eos
    .local int rx2043_rep
    .local pmc rx2043_cur
    .local pmc rx2043_debug
    (rx2043_cur, rx2043_pos, rx2043_tgt, $I10) = self."!cursor_start"()
    rx2043_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2043_cur
    .local pmc match
    .lex "$/", match
    length rx2043_eos, rx2043_tgt
    gt rx2043_pos, rx2043_eos, rx2043_done
    set rx2043_off, 0
    lt rx2043_pos, 2, rx2043_start
    sub rx2043_off, rx2043_pos, 1
    substr rx2043_tgt, rx2043_tgt, rx2043_off
  rx2043_start:
    eq $I10, 1, rx2043_restart
    if_null rx2043_debug, debug_1443
    rx2043_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1443:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2044_done
    goto rxscan2044_scan
  rxscan2044_loop:
    (rx2043_pos) = rx2043_cur."from"()
    inc rx2043_pos
    rx2043_cur."!cursor_from"(rx2043_pos)
    ge rx2043_pos, rx2043_eos, rxscan2044_done
  rxscan2044_scan:
    set_addr $I10, rxscan2044_loop
    rx2043_cur."!mark_push"(0, rx2043_pos, $I10)
  rxscan2044_done:
.annotate 'line', 1071
  # rx literal  "["
    add $I11, rx2043_pos, 1
    gt $I11, rx2043_eos, rx2043_fail
    sub $I11, rx2043_pos, rx2043_off
    ord $I11, rx2043_tgt, $I11
    ne $I11, 91, rx2043_fail
    add rx2043_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2043_cur."!cursor_pos"(rx2043_pos)
    $P10 = rx2043_cur."ws"()
    unless $P10, rx2043_fail
    rx2043_pos = $P10."pos"()
  # rx rxquantr2045 ** 0..1
    set_addr $I10, rxquantr2045_done
    rx2043_cur."!mark_push"(0, rx2043_pos, $I10)
  rxquantr2045_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2043_cur."!cursor_pos"(rx2043_pos)
    $P10 = rx2043_cur."EXPR"()
    unless $P10, rx2043_fail
    goto rxsubrule2046_pass
  rxsubrule2046_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2043_fail
  rxsubrule2046_pass:
    set_addr $I10, rxsubrule2046_back
    rx2043_cur."!mark_push"(0, rx2043_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2043_pos = $P10."pos"()
    set_addr $I10, rxquantr2045_done
    (rx2043_rep) = rx2043_cur."!mark_commit"($I10)
  rxquantr2045_done:
  # rx literal  "]"
    add $I11, rx2043_pos, 1
    gt $I11, rx2043_eos, rx2043_fail
    sub $I11, rx2043_pos, rx2043_off
    ord $I11, rx2043_tgt, $I11
    ne $I11, 93, rx2043_fail
    add rx2043_pos, 1
  # rx pass
    rx2043_cur."!cursor_pass"(rx2043_pos, "circumfix:sym<[ ]>")
    if_null rx2043_debug, debug_1444
    rx2043_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2043_pos)
  debug_1444:
    .return (rx2043_cur)
  rx2043_restart:
.annotate 'line', 469
    if_null rx2043_debug, debug_1445
    rx2043_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1445:
  rx2043_fail:
    (rx2043_rep, rx2043_pos, $I10, $P10) = rx2043_cur."!mark_fail"(0)
    lt rx2043_pos, -1, rx2043_done
    eq rx2043_pos, -1, rx2043_fail
    jump $I10
  rx2043_done:
    rx2043_cur."!cursor_fail"()
    if_null rx2043_debug, debug_1446
    rx2043_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1446:
    .return (rx2043_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("304_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("305_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2049_tgt
    .local int rx2049_pos
    .local int rx2049_off
    .local int rx2049_eos
    .local int rx2049_rep
    .local pmc rx2049_cur
    .local pmc rx2049_debug
    (rx2049_cur, rx2049_pos, rx2049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2049_cur
    .local pmc match
    .lex "$/", match
    length rx2049_eos, rx2049_tgt
    gt rx2049_pos, rx2049_eos, rx2049_done
    set rx2049_off, 0
    lt rx2049_pos, 2, rx2049_start
    sub rx2049_off, rx2049_pos, 1
    substr rx2049_tgt, rx2049_tgt, rx2049_off
  rx2049_start:
    eq $I10, 1, rx2049_restart
    if_null rx2049_debug, debug_1447
    rx2049_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2050_done
    goto rxscan2050_scan
  rxscan2050_loop:
    (rx2049_pos) = rx2049_cur."from"()
    inc rx2049_pos
    rx2049_cur."!cursor_from"(rx2049_pos)
    ge rx2049_pos, rx2049_eos, rxscan2050_done
  rxscan2050_scan:
    set_addr $I10, rxscan2050_loop
    rx2049_cur."!mark_push"(0, rx2049_pos, $I10)
  rxscan2050_done:
.annotate 'line', 1072
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2049_pos, rx2049_off
    substr $S10, rx2049_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2049_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2049_cur."!cursor_pos"(rx2049_pos)
    $P10 = rx2049_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2049_fail
    rx2049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2049_pos = $P10."pos"()
  # rx pass
    rx2049_cur."!cursor_pass"(rx2049_pos, "circumfix:sym<ang>")
    if_null rx2049_debug, debug_1448
    rx2049_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2049_pos)
  debug_1448:
    .return (rx2049_cur)
  rx2049_restart:
.annotate 'line', 469
    if_null rx2049_debug, debug_1449
    rx2049_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1449:
  rx2049_fail:
    (rx2049_rep, rx2049_pos, $I10, $P10) = rx2049_cur."!mark_fail"(0)
    lt rx2049_pos, -1, rx2049_done
    eq rx2049_pos, -1, rx2049_fail
    jump $I10
  rx2049_done:
    rx2049_cur."!cursor_fail"()
    if_null rx2049_debug, debug_1450
    rx2049_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1450:
    .return (rx2049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("306_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("307_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2053_tgt
    .local int rx2053_pos
    .local int rx2053_off
    .local int rx2053_eos
    .local int rx2053_rep
    .local pmc rx2053_cur
    .local pmc rx2053_debug
    (rx2053_cur, rx2053_pos, rx2053_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2053_cur
    .local pmc match
    .lex "$/", match
    length rx2053_eos, rx2053_tgt
    gt rx2053_pos, rx2053_eos, rx2053_done
    set rx2053_off, 0
    lt rx2053_pos, 2, rx2053_start
    sub rx2053_off, rx2053_pos, 1
    substr rx2053_tgt, rx2053_tgt, rx2053_off
  rx2053_start:
    eq $I10, 1, rx2053_restart
    if_null rx2053_debug, debug_1451
    rx2053_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1451:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2054_done
    goto rxscan2054_scan
  rxscan2054_loop:
    (rx2053_pos) = rx2053_cur."from"()
    inc rx2053_pos
    rx2053_cur."!cursor_from"(rx2053_pos)
    ge rx2053_pos, rx2053_eos, rxscan2054_done
  rxscan2054_scan:
    set_addr $I10, rxscan2054_loop
    rx2053_cur."!mark_push"(0, rx2053_pos, $I10)
  rxscan2054_done:
.annotate 'line', 1073
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2053_pos, rx2053_off
    substr $S10, rx2053_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2053_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2053_cur."!cursor_pos"(rx2053_pos)
    $P10 = rx2053_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2053_fail
    rx2053_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2053_pos = $P10."pos"()
  # rx pass
    rx2053_cur."!cursor_pass"(rx2053_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2053_debug, debug_1452
    rx2053_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2053_pos)
  debug_1452:
    .return (rx2053_cur)
  rx2053_restart:
.annotate 'line', 469
    if_null rx2053_debug, debug_1453
    rx2053_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1453:
  rx2053_fail:
    (rx2053_rep, rx2053_pos, $I10, $P10) = rx2053_cur."!mark_fail"(0)
    lt rx2053_pos, -1, rx2053_done
    eq rx2053_pos, -1, rx2053_fail
    jump $I10
  rx2053_done:
    rx2053_cur."!cursor_fail"()
    if_null rx2053_debug, debug_1454
    rx2053_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1454:
    .return (rx2053_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("308_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, unicode:"\x{ab}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("309_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2057_tgt
    .local int rx2057_pos
    .local int rx2057_off
    .local int rx2057_eos
    .local int rx2057_rep
    .local pmc rx2057_cur
    .local pmc rx2057_debug
    (rx2057_cur, rx2057_pos, rx2057_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2057_cur
    .local pmc match
    .lex "$/", match
    length rx2057_eos, rx2057_tgt
    gt rx2057_pos, rx2057_eos, rx2057_done
    set rx2057_off, 0
    lt rx2057_pos, 2, rx2057_start
    sub rx2057_off, rx2057_pos, 1
    substr rx2057_tgt, rx2057_tgt, rx2057_off
  rx2057_start:
    eq $I10, 1, rx2057_restart
    if_null rx2057_debug, debug_1455
    rx2057_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2058_done
    goto rxscan2058_scan
  rxscan2058_loop:
    (rx2057_pos) = rx2057_cur."from"()
    inc rx2057_pos
    rx2057_cur."!cursor_from"(rx2057_pos)
    ge rx2057_pos, rx2057_eos, rxscan2058_done
  rxscan2058_scan:
    set_addr $I10, rxscan2058_loop
    rx2057_cur."!mark_push"(0, rx2057_pos, $I10)
  rxscan2058_done:
.annotate 'line', 1074
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2057_pos, rx2057_off
    substr $S10, rx2057_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2057_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2057_cur."!cursor_pos"(rx2057_pos)
    $P10 = rx2057_cur."pblock"()
    unless $P10, rx2057_fail
    rx2057_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2057_pos = $P10."pos"()
  # rx pass
    rx2057_cur."!cursor_pass"(rx2057_pos, "circumfix:sym<{ }>")
    if_null rx2057_debug, debug_1456
    rx2057_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2057_pos)
  debug_1456:
    .return (rx2057_cur)
  rx2057_restart:
.annotate 'line', 469
    if_null rx2057_debug, debug_1457
    rx2057_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1457:
  rx2057_fail:
    (rx2057_rep, rx2057_pos, $I10, $P10) = rx2057_cur."!mark_fail"(0)
    lt rx2057_pos, -1, rx2057_done
    eq rx2057_pos, -1, rx2057_fail
    jump $I10
  rx2057_done:
    rx2057_cur."!cursor_fail"()
    if_null rx2057_debug, debug_1458
    rx2057_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1458:
    .return (rx2057_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("310_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("311_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2061_tgt
    .local int rx2061_pos
    .local int rx2061_off
    .local int rx2061_eos
    .local int rx2061_rep
    .local pmc rx2061_cur
    .local pmc rx2061_debug
    (rx2061_cur, rx2061_pos, rx2061_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2061_cur
    .local pmc match
    .lex "$/", match
    length rx2061_eos, rx2061_tgt
    gt rx2061_pos, rx2061_eos, rx2061_done
    set rx2061_off, 0
    lt rx2061_pos, 2, rx2061_start
    sub rx2061_off, rx2061_pos, 1
    substr rx2061_tgt, rx2061_tgt, rx2061_off
  rx2061_start:
    eq $I10, 1, rx2061_restart
    if_null rx2061_debug, debug_1459
    rx2061_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1459:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2062_done
    goto rxscan2062_scan
  rxscan2062_loop:
    (rx2061_pos) = rx2061_cur."from"()
    inc rx2061_pos
    rx2061_cur."!cursor_from"(rx2061_pos)
    ge rx2061_pos, rx2061_eos, rxscan2062_done
  rxscan2062_scan:
    set_addr $I10, rxscan2062_loop
    rx2061_cur."!mark_push"(0, rx2061_pos, $I10)
  rxscan2062_done:
.annotate 'line', 1075
  # rx subrule "sigil" subtype=capture negate=
    rx2061_cur."!cursor_pos"(rx2061_pos)
    $P10 = rx2061_cur."sigil"()
    unless $P10, rx2061_fail
    rx2061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2061_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2061_pos, 1
    gt $I11, rx2061_eos, rx2061_fail
    sub $I11, rx2061_pos, rx2061_off
    ord $I11, rx2061_tgt, $I11
    ne $I11, 40, rx2061_fail
    add rx2061_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2061_cur."!cursor_pos"(rx2061_pos)
    $P10 = rx2061_cur."semilist"()
    unless $P10, rx2061_fail
    rx2061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2061_pos = $P10."pos"()
  alt2063_0:
    set_addr $I10, alt2063_1
    rx2061_cur."!mark_push"(0, rx2061_pos, $I10)
  # rx literal  ")"
    add $I11, rx2061_pos, 1
    gt $I11, rx2061_eos, rx2061_fail
    sub $I11, rx2061_pos, rx2061_off
    ord $I11, rx2061_tgt, $I11
    ne $I11, 41, rx2061_fail
    add rx2061_pos, 1
    goto alt2063_end
  alt2063_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2061_cur."!cursor_pos"(rx2061_pos)
    $P10 = rx2061_cur."FAILGOAL"("')'")
    unless $P10, rx2061_fail
    goto rxsubrule2064_pass
  rxsubrule2064_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2061_fail
  rxsubrule2064_pass:
    set_addr $I10, rxsubrule2064_back
    rx2061_cur."!mark_push"(0, rx2061_pos, $I10, $P10)
    rx2061_pos = $P10."pos"()
  alt2063_end:
  # rx pass
    rx2061_cur."!cursor_pass"(rx2061_pos, "circumfix:sym<sigil>")
    if_null rx2061_debug, debug_1460
    rx2061_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2061_pos)
  debug_1460:
    .return (rx2061_cur)
  rx2061_restart:
.annotate 'line', 469
    if_null rx2061_debug, debug_1461
    rx2061_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1461:
  rx2061_fail:
    (rx2061_rep, rx2061_pos, $I10, $P10) = rx2061_cur."!mark_fail"(0)
    lt rx2061_pos, -1, rx2061_done
    eq rx2061_pos, -1, rx2061_fail
    jump $I10
  rx2061_done:
    rx2061_cur."!cursor_fail"()
    if_null rx2061_debug, debug_1462
    rx2061_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1462:
    .return (rx2061_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("312_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("313_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2067_tgt
    .local int rx2067_pos
    .local int rx2067_off
    .local int rx2067_eos
    .local int rx2067_rep
    .local pmc rx2067_cur
    .local pmc rx2067_debug
    (rx2067_cur, rx2067_pos, rx2067_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2067_cur
    .local pmc match
    .lex "$/", match
    length rx2067_eos, rx2067_tgt
    gt rx2067_pos, rx2067_eos, rx2067_done
    set rx2067_off, 0
    lt rx2067_pos, 2, rx2067_start
    sub rx2067_off, rx2067_pos, 1
    substr rx2067_tgt, rx2067_tgt, rx2067_off
  rx2067_start:
    eq $I10, 1, rx2067_restart
    if_null rx2067_debug, debug_1463
    rx2067_cur."!cursor_debug"("START", "semilist")
  debug_1463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2068_done
    goto rxscan2068_scan
  rxscan2068_loop:
    (rx2067_pos) = rx2067_cur."from"()
    inc rx2067_pos
    rx2067_cur."!cursor_from"(rx2067_pos)
    ge rx2067_pos, rx2067_eos, rxscan2068_done
  rxscan2068_scan:
    set_addr $I10, rxscan2068_loop
    rx2067_cur."!mark_push"(0, rx2067_pos, $I10)
  rxscan2068_done:
.annotate 'line', 1077
  # rx subrule "ws" subtype=method negate=
    rx2067_cur."!cursor_pos"(rx2067_pos)
    $P10 = rx2067_cur."ws"()
    unless $P10, rx2067_fail
    rx2067_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2067_cur."!cursor_pos"(rx2067_pos)
    $P10 = rx2067_cur."statement"()
    unless $P10, rx2067_fail
    rx2067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2067_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2067_cur."!cursor_pos"(rx2067_pos)
    $P10 = rx2067_cur."ws"()
    unless $P10, rx2067_fail
    rx2067_pos = $P10."pos"()
  # rx pass
    rx2067_cur."!cursor_pass"(rx2067_pos, "semilist")
    if_null rx2067_debug, debug_1464
    rx2067_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2067_pos)
  debug_1464:
    .return (rx2067_cur)
  rx2067_restart:
.annotate 'line', 469
    if_null rx2067_debug, debug_1465
    rx2067_cur."!cursor_debug"("NEXT", "semilist")
  debug_1465:
  rx2067_fail:
    (rx2067_rep, rx2067_pos, $I10, $P10) = rx2067_cur."!mark_fail"(0)
    lt rx2067_pos, -1, rx2067_done
    eq rx2067_pos, -1, rx2067_fail
    jump $I10
  rx2067_done:
    rx2067_cur."!cursor_fail"()
    if_null rx2067_debug, debug_1466
    rx2067_cur."!cursor_debug"("FAIL", "semilist")
  debug_1466:
    .return (rx2067_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("314_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("315_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2071_tgt
    .local int rx2071_pos
    .local int rx2071_off
    .local int rx2071_eos
    .local int rx2071_rep
    .local pmc rx2071_cur
    .local pmc rx2071_debug
    (rx2071_cur, rx2071_pos, rx2071_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2071_cur
    .local pmc match
    .lex "$/", match
    length rx2071_eos, rx2071_tgt
    gt rx2071_pos, rx2071_eos, rx2071_done
    set rx2071_off, 0
    lt rx2071_pos, 2, rx2071_start
    sub rx2071_off, rx2071_pos, 1
    substr rx2071_tgt, rx2071_tgt, rx2071_off
  rx2071_start:
    eq $I10, 1, rx2071_restart
    if_null rx2071_debug, debug_1467
    rx2071_cur."!cursor_debug"("START", "infixish")
  debug_1467:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2072_done
    goto rxscan2072_scan
  rxscan2072_loop:
    (rx2071_pos) = rx2071_cur."from"()
    inc rx2071_pos
    rx2071_cur."!cursor_from"(rx2071_pos)
    ge rx2071_pos, rx2071_eos, rxscan2072_done
  rxscan2072_scan:
    set_addr $I10, rxscan2072_loop
    rx2071_cur."!mark_push"(0, rx2071_pos, $I10)
  rxscan2072_done:
.annotate 'line', 1100
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2071_cur."!cursor_pos"(rx2071_pos)
    $P10 = rx2071_cur."infixstopper"()
    if $P10, rx2071_fail
  # rx subrule "infix" subtype=capture negate=
    rx2071_cur."!cursor_pos"(rx2071_pos)
    $P10 = rx2071_cur."infix"()
    unless $P10, rx2071_fail
    rx2071_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2071_pos = $P10."pos"()
  # rx pass
    rx2071_cur."!cursor_pass"(rx2071_pos, "infixish")
    if_null rx2071_debug, debug_1468
    rx2071_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2071_pos)
  debug_1468:
    .return (rx2071_cur)
  rx2071_restart:
.annotate 'line', 469
    if_null rx2071_debug, debug_1469
    rx2071_cur."!cursor_debug"("NEXT", "infixish")
  debug_1469:
  rx2071_fail:
    (rx2071_rep, rx2071_pos, $I10, $P10) = rx2071_cur."!mark_fail"(0)
    lt rx2071_pos, -1, rx2071_done
    eq rx2071_pos, -1, rx2071_fail
    jump $I10
  rx2071_done:
    rx2071_cur."!cursor_fail"()
    if_null rx2071_debug, debug_1470
    rx2071_cur."!cursor_debug"("FAIL", "infixish")
  debug_1470:
    .return (rx2071_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("316_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("317_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2075_tgt
    .local int rx2075_pos
    .local int rx2075_off
    .local int rx2075_eos
    .local int rx2075_rep
    .local pmc rx2075_cur
    .local pmc rx2075_debug
    (rx2075_cur, rx2075_pos, rx2075_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2075_cur
    .local pmc match
    .lex "$/", match
    length rx2075_eos, rx2075_tgt
    gt rx2075_pos, rx2075_eos, rx2075_done
    set rx2075_off, 0
    lt rx2075_pos, 2, rx2075_start
    sub rx2075_off, rx2075_pos, 1
    substr rx2075_tgt, rx2075_tgt, rx2075_off
  rx2075_start:
    eq $I10, 1, rx2075_restart
    if_null rx2075_debug, debug_1471
    rx2075_cur."!cursor_debug"("START", "infixstopper")
  debug_1471:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2076_done
    goto rxscan2076_scan
  rxscan2076_loop:
    (rx2075_pos) = rx2075_cur."from"()
    inc rx2075_pos
    rx2075_cur."!cursor_from"(rx2075_pos)
    ge rx2075_pos, rx2075_eos, rxscan2076_done
  rxscan2076_scan:
    set_addr $I10, rxscan2076_loop
    rx2075_cur."!mark_push"(0, rx2075_pos, $I10)
  rxscan2076_done:
.annotate 'line', 1101
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2075_cur."!cursor_pos"(rx2075_pos)
    $P10 = rx2075_cur."lambda"()
    unless $P10, rx2075_fail
  # rx pass
    rx2075_cur."!cursor_pass"(rx2075_pos, "infixstopper")
    if_null rx2075_debug, debug_1472
    rx2075_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2075_pos)
  debug_1472:
    .return (rx2075_cur)
  rx2075_restart:
.annotate 'line', 469
    if_null rx2075_debug, debug_1473
    rx2075_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1473:
  rx2075_fail:
    (rx2075_rep, rx2075_pos, $I10, $P10) = rx2075_cur."!mark_fail"(0)
    lt rx2075_pos, -1, rx2075_done
    eq rx2075_pos, -1, rx2075_fail
    jump $I10
  rx2075_done:
    rx2075_cur."!cursor_fail"()
    if_null rx2075_debug, debug_1474
    rx2075_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1474:
    .return (rx2075_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("318_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("319_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2079_tgt
    .local int rx2079_pos
    .local int rx2079_off
    .local int rx2079_eos
    .local int rx2079_rep
    .local pmc rx2079_cur
    .local pmc rx2079_debug
    (rx2079_cur, rx2079_pos, rx2079_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2079_cur
    .local pmc match
    .lex "$/", match
    length rx2079_eos, rx2079_tgt
    gt rx2079_pos, rx2079_eos, rx2079_done
    set rx2079_off, 0
    lt rx2079_pos, 2, rx2079_start
    sub rx2079_off, rx2079_pos, 1
    substr rx2079_tgt, rx2079_tgt, rx2079_off
  rx2079_start:
    eq $I10, 1, rx2079_restart
    if_null rx2079_debug, debug_1475
    rx2079_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1475:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2080_done
    goto rxscan2080_scan
  rxscan2080_loop:
    (rx2079_pos) = rx2079_cur."from"()
    inc rx2079_pos
    rx2079_cur."!cursor_from"(rx2079_pos)
    ge rx2079_pos, rx2079_eos, rxscan2080_done
  rxscan2080_scan:
    set_addr $I10, rxscan2080_loop
    rx2079_cur."!mark_push"(0, rx2079_pos, $I10)
  rxscan2080_done:
.annotate 'line', 1104
  # rx literal  "["
    add $I11, rx2079_pos, 1
    gt $I11, rx2079_eos, rx2079_fail
    sub $I11, rx2079_pos, rx2079_off
    ord $I11, rx2079_tgt, $I11
    ne $I11, 91, rx2079_fail
    add rx2079_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2079_cur."!cursor_pos"(rx2079_pos)
    $P10 = rx2079_cur."ws"()
    unless $P10, rx2079_fail
    rx2079_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2079_cur."!cursor_pos"(rx2079_pos)
    $P10 = rx2079_cur."EXPR"()
    unless $P10, rx2079_fail
    rx2079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2079_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2079_pos, 1
    gt $I11, rx2079_eos, rx2079_fail
    sub $I11, rx2079_pos, rx2079_off
    ord $I11, rx2079_tgt, $I11
    ne $I11, 93, rx2079_fail
    add rx2079_pos, 1
.annotate 'line', 1105
  # rx subrule "O" subtype=capture negate=
    rx2079_cur."!cursor_pos"(rx2079_pos)
    $P10 = rx2079_cur."O"("%methodop")
    unless $P10, rx2079_fail
    rx2079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2079_pos = $P10."pos"()
.annotate 'line', 1103
  # rx pass
    rx2079_cur."!cursor_pass"(rx2079_pos, "postcircumfix:sym<[ ]>")
    if_null rx2079_debug, debug_1476
    rx2079_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2079_pos)
  debug_1476:
    .return (rx2079_cur)
  rx2079_restart:
.annotate 'line', 469
    if_null rx2079_debug, debug_1477
    rx2079_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1477:
  rx2079_fail:
    (rx2079_rep, rx2079_pos, $I10, $P10) = rx2079_cur."!mark_fail"(0)
    lt rx2079_pos, -1, rx2079_done
    eq rx2079_pos, -1, rx2079_fail
    jump $I10
  rx2079_done:
    rx2079_cur."!cursor_fail"()
    if_null rx2079_debug, debug_1478
    rx2079_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1478:
    .return (rx2079_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("320_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("321_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2083_tgt
    .local int rx2083_pos
    .local int rx2083_off
    .local int rx2083_eos
    .local int rx2083_rep
    .local pmc rx2083_cur
    .local pmc rx2083_debug
    (rx2083_cur, rx2083_pos, rx2083_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2083_cur
    .local pmc match
    .lex "$/", match
    length rx2083_eos, rx2083_tgt
    gt rx2083_pos, rx2083_eos, rx2083_done
    set rx2083_off, 0
    lt rx2083_pos, 2, rx2083_start
    sub rx2083_off, rx2083_pos, 1
    substr rx2083_tgt, rx2083_tgt, rx2083_off
  rx2083_start:
    eq $I10, 1, rx2083_restart
    if_null rx2083_debug, debug_1479
    rx2083_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2084_done
    goto rxscan2084_scan
  rxscan2084_loop:
    (rx2083_pos) = rx2083_cur."from"()
    inc rx2083_pos
    rx2083_cur."!cursor_from"(rx2083_pos)
    ge rx2083_pos, rx2083_eos, rxscan2084_done
  rxscan2084_scan:
    set_addr $I10, rxscan2084_loop
    rx2083_cur."!mark_push"(0, rx2083_pos, $I10)
  rxscan2084_done:
.annotate 'line', 1109
  # rx literal  "{"
    add $I11, rx2083_pos, 1
    gt $I11, rx2083_eos, rx2083_fail
    sub $I11, rx2083_pos, rx2083_off
    ord $I11, rx2083_tgt, $I11
    ne $I11, 123, rx2083_fail
    add rx2083_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2083_cur."!cursor_pos"(rx2083_pos)
    $P10 = rx2083_cur."ws"()
    unless $P10, rx2083_fail
    rx2083_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2083_cur."!cursor_pos"(rx2083_pos)
    $P10 = rx2083_cur."EXPR"()
    unless $P10, rx2083_fail
    rx2083_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2083_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2083_pos, 1
    gt $I11, rx2083_eos, rx2083_fail
    sub $I11, rx2083_pos, rx2083_off
    ord $I11, rx2083_tgt, $I11
    ne $I11, 125, rx2083_fail
    add rx2083_pos, 1
.annotate 'line', 1110
  # rx subrule "O" subtype=capture negate=
    rx2083_cur."!cursor_pos"(rx2083_pos)
    $P10 = rx2083_cur."O"("%methodop")
    unless $P10, rx2083_fail
    rx2083_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2083_pos = $P10."pos"()
.annotate 'line', 1108
  # rx pass
    rx2083_cur."!cursor_pass"(rx2083_pos, "postcircumfix:sym<{ }>")
    if_null rx2083_debug, debug_1480
    rx2083_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2083_pos)
  debug_1480:
    .return (rx2083_cur)
  rx2083_restart:
.annotate 'line', 469
    if_null rx2083_debug, debug_1481
    rx2083_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1481:
  rx2083_fail:
    (rx2083_rep, rx2083_pos, $I10, $P10) = rx2083_cur."!mark_fail"(0)
    lt rx2083_pos, -1, rx2083_done
    eq rx2083_pos, -1, rx2083_fail
    jump $I10
  rx2083_done:
    rx2083_cur."!cursor_fail"()
    if_null rx2083_debug, debug_1482
    rx2083_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1482:
    .return (rx2083_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("322_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "{")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("323_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2087_tgt
    .local int rx2087_pos
    .local int rx2087_off
    .local int rx2087_eos
    .local int rx2087_rep
    .local pmc rx2087_cur
    .local pmc rx2087_debug
    (rx2087_cur, rx2087_pos, rx2087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2087_cur
    .local pmc match
    .lex "$/", match
    length rx2087_eos, rx2087_tgt
    gt rx2087_pos, rx2087_eos, rx2087_done
    set rx2087_off, 0
    lt rx2087_pos, 2, rx2087_start
    sub rx2087_off, rx2087_pos, 1
    substr rx2087_tgt, rx2087_tgt, rx2087_off
  rx2087_start:
    eq $I10, 1, rx2087_restart
    if_null rx2087_debug, debug_1483
    rx2087_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1483:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2088_done
    goto rxscan2088_scan
  rxscan2088_loop:
    (rx2087_pos) = rx2087_cur."from"()
    inc rx2087_pos
    rx2087_cur."!cursor_from"(rx2087_pos)
    ge rx2087_pos, rx2087_eos, rxscan2088_done
  rxscan2088_scan:
    set_addr $I10, rxscan2088_loop
    rx2087_cur."!mark_push"(0, rx2087_pos, $I10)
  rxscan2088_done:
.annotate 'line', 1114
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2087_pos, rx2087_off
    substr $S10, rx2087_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2087_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2087_cur."!cursor_pos"(rx2087_pos)
    $P10 = rx2087_cur."quote_EXPR"(":q")
    unless $P10, rx2087_fail
    rx2087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2087_pos = $P10."pos"()
.annotate 'line', 1115
  # rx subrule "O" subtype=capture negate=
    rx2087_cur."!cursor_pos"(rx2087_pos)
    $P10 = rx2087_cur."O"("%methodop")
    unless $P10, rx2087_fail
    rx2087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2087_pos = $P10."pos"()
.annotate 'line', 1113
  # rx pass
    rx2087_cur."!cursor_pass"(rx2087_pos, "postcircumfix:sym<ang>")
    if_null rx2087_debug, debug_1484
    rx2087_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2087_pos)
  debug_1484:
    .return (rx2087_cur)
  rx2087_restart:
.annotate 'line', 469
    if_null rx2087_debug, debug_1485
    rx2087_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1485:
  rx2087_fail:
    (rx2087_rep, rx2087_pos, $I10, $P10) = rx2087_cur."!mark_fail"(0)
    lt rx2087_pos, -1, rx2087_done
    eq rx2087_pos, -1, rx2087_fail
    jump $I10
  rx2087_done:
    rx2087_cur."!cursor_fail"()
    if_null rx2087_debug, debug_1486
    rx2087_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1486:
    .return (rx2087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("324_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("325_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2091_tgt
    .local int rx2091_pos
    .local int rx2091_off
    .local int rx2091_eos
    .local int rx2091_rep
    .local pmc rx2091_cur
    .local pmc rx2091_debug
    (rx2091_cur, rx2091_pos, rx2091_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2091_cur
    .local pmc match
    .lex "$/", match
    length rx2091_eos, rx2091_tgt
    gt rx2091_pos, rx2091_eos, rx2091_done
    set rx2091_off, 0
    lt rx2091_pos, 2, rx2091_start
    sub rx2091_off, rx2091_pos, 1
    substr rx2091_tgt, rx2091_tgt, rx2091_off
  rx2091_start:
    eq $I10, 1, rx2091_restart
    if_null rx2091_debug, debug_1487
    rx2091_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1487:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2092_done
    goto rxscan2092_scan
  rxscan2092_loop:
    (rx2091_pos) = rx2091_cur."from"()
    inc rx2091_pos
    rx2091_cur."!cursor_from"(rx2091_pos)
    ge rx2091_pos, rx2091_eos, rxscan2092_done
  rxscan2092_scan:
    set_addr $I10, rxscan2092_loop
    rx2091_cur."!mark_push"(0, rx2091_pos, $I10)
  rxscan2092_done:
.annotate 'line', 1119
  # rx literal  "("
    add $I11, rx2091_pos, 1
    gt $I11, rx2091_eos, rx2091_fail
    sub $I11, rx2091_pos, rx2091_off
    ord $I11, rx2091_tgt, $I11
    ne $I11, 40, rx2091_fail
    add rx2091_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2091_cur."!cursor_pos"(rx2091_pos)
    $P10 = rx2091_cur."ws"()
    unless $P10, rx2091_fail
    rx2091_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2091_cur."!cursor_pos"(rx2091_pos)
    $P10 = rx2091_cur."arglist"()
    unless $P10, rx2091_fail
    rx2091_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2091_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2091_pos, 1
    gt $I11, rx2091_eos, rx2091_fail
    sub $I11, rx2091_pos, rx2091_off
    ord $I11, rx2091_tgt, $I11
    ne $I11, 41, rx2091_fail
    add rx2091_pos, 1
.annotate 'line', 1120
  # rx subrule "O" subtype=capture negate=
    rx2091_cur."!cursor_pos"(rx2091_pos)
    $P10 = rx2091_cur."O"("%methodop")
    unless $P10, rx2091_fail
    rx2091_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2091_pos = $P10."pos"()
.annotate 'line', 1118
  # rx pass
    rx2091_cur."!cursor_pass"(rx2091_pos, "postcircumfix:sym<( )>")
    if_null rx2091_debug, debug_1488
    rx2091_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2091_pos)
  debug_1488:
    .return (rx2091_cur)
  rx2091_restart:
.annotate 'line', 469
    if_null rx2091_debug, debug_1489
    rx2091_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1489:
  rx2091_fail:
    (rx2091_rep, rx2091_pos, $I10, $P10) = rx2091_cur."!mark_fail"(0)
    lt rx2091_pos, -1, rx2091_done
    eq rx2091_pos, -1, rx2091_fail
    jump $I10
  rx2091_done:
    rx2091_cur."!cursor_fail"()
    if_null rx2091_debug, debug_1490
    rx2091_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1490:
    .return (rx2091_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("326_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("327_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2095_tgt
    .local int rx2095_pos
    .local int rx2095_off
    .local int rx2095_eos
    .local int rx2095_rep
    .local pmc rx2095_cur
    .local pmc rx2095_debug
    (rx2095_cur, rx2095_pos, rx2095_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2095_cur
    .local pmc match
    .lex "$/", match
    length rx2095_eos, rx2095_tgt
    gt rx2095_pos, rx2095_eos, rx2095_done
    set rx2095_off, 0
    lt rx2095_pos, 2, rx2095_start
    sub rx2095_off, rx2095_pos, 1
    substr rx2095_tgt, rx2095_tgt, rx2095_off
  rx2095_start:
    eq $I10, 1, rx2095_restart
    if_null rx2095_debug, debug_1491
    rx2095_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1491:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2096_done
    goto rxscan2096_scan
  rxscan2096_loop:
    (rx2095_pos) = rx2095_cur."from"()
    inc rx2095_pos
    rx2095_cur."!cursor_from"(rx2095_pos)
    ge rx2095_pos, rx2095_eos, rxscan2096_done
  rxscan2096_scan:
    set_addr $I10, rxscan2096_loop
    rx2095_cur."!mark_push"(0, rx2095_pos, $I10)
  rxscan2096_done:
.annotate 'line', 1123
  # rx subrule "dotty" subtype=capture negate=
    rx2095_cur."!cursor_pos"(rx2095_pos)
    $P10 = rx2095_cur."dotty"()
    unless $P10, rx2095_fail
    rx2095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2095_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2095_cur."!cursor_pos"(rx2095_pos)
    $P10 = rx2095_cur."O"("%methodop")
    unless $P10, rx2095_fail
    rx2095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2095_pos = $P10."pos"()
  # rx pass
    rx2095_cur."!cursor_pass"(rx2095_pos, "postfix:sym<.>")
    if_null rx2095_debug, debug_1492
    rx2095_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2095_pos)
  debug_1492:
    .return (rx2095_cur)
  rx2095_restart:
.annotate 'line', 469
    if_null rx2095_debug, debug_1493
    rx2095_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1493:
  rx2095_fail:
    (rx2095_rep, rx2095_pos, $I10, $P10) = rx2095_cur."!mark_fail"(0)
    lt rx2095_pos, -1, rx2095_done
    eq rx2095_pos, -1, rx2095_fail
    jump $I10
  rx2095_done:
    rx2095_cur."!cursor_fail"()
    if_null rx2095_debug, debug_1494
    rx2095_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1494:
    .return (rx2095_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("328_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("dotty", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("329_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2099_tgt
    .local int rx2099_pos
    .local int rx2099_off
    .local int rx2099_eos
    .local int rx2099_rep
    .local pmc rx2099_cur
    .local pmc rx2099_debug
    (rx2099_cur, rx2099_pos, rx2099_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2099_cur
    .local pmc match
    .lex "$/", match
    length rx2099_eos, rx2099_tgt
    gt rx2099_pos, rx2099_eos, rx2099_done
    set rx2099_off, 0
    lt rx2099_pos, 2, rx2099_start
    sub rx2099_off, rx2099_pos, 1
    substr rx2099_tgt, rx2099_tgt, rx2099_off
  rx2099_start:
    eq $I10, 1, rx2099_restart
    if_null rx2099_debug, debug_1495
    rx2099_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1495:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2100_done
    goto rxscan2100_scan
  rxscan2100_loop:
    (rx2099_pos) = rx2099_cur."from"()
    inc rx2099_pos
    rx2099_cur."!cursor_from"(rx2099_pos)
    ge rx2099_pos, rx2099_eos, rxscan2100_done
  rxscan2100_scan:
    set_addr $I10, rxscan2100_loop
    rx2099_cur."!mark_push"(0, rx2099_pos, $I10)
  rxscan2100_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2101_fail
    rx2099_cur."!mark_push"(0, rx2099_pos, $I10)
  # rx literal  "++"
    add $I11, rx2099_pos, 2
    gt $I11, rx2099_eos, rx2099_fail
    sub $I11, rx2099_pos, rx2099_off
    substr $S10, rx2099_tgt, $I11, 2
    ne $S10, "++", rx2099_fail
    add rx2099_pos, 2
    set_addr $I10, rxcap_2101_fail
    ($I12, $I11) = rx2099_cur."!mark_peek"($I10)
    rx2099_cur."!cursor_pos"($I11)
    ($P10) = rx2099_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2099_pos, "")
    rx2099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2101_done
  rxcap_2101_fail:
    goto rx2099_fail
  rxcap_2101_done:
  # rx subrule "O" subtype=capture negate=
    rx2099_cur."!cursor_pos"(rx2099_pos)
    $P10 = rx2099_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2099_fail
    rx2099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2099_pos = $P10."pos"()
  # rx pass
    rx2099_cur."!cursor_pass"(rx2099_pos, "prefix:sym<++>")
    if_null rx2099_debug, debug_1496
    rx2099_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2099_pos)
  debug_1496:
    .return (rx2099_cur)
  rx2099_restart:
.annotate 'line', 469
    if_null rx2099_debug, debug_1497
    rx2099_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1497:
  rx2099_fail:
    (rx2099_rep, rx2099_pos, $I10, $P10) = rx2099_cur."!mark_fail"(0)
    lt rx2099_pos, -1, rx2099_done
    eq rx2099_pos, -1, rx2099_fail
    jump $I10
  rx2099_done:
    rx2099_cur."!cursor_fail"()
    if_null rx2099_debug, debug_1498
    rx2099_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1498:
    .return (rx2099_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("330_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("331_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2104_tgt
    .local int rx2104_pos
    .local int rx2104_off
    .local int rx2104_eos
    .local int rx2104_rep
    .local pmc rx2104_cur
    .local pmc rx2104_debug
    (rx2104_cur, rx2104_pos, rx2104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2104_cur
    .local pmc match
    .lex "$/", match
    length rx2104_eos, rx2104_tgt
    gt rx2104_pos, rx2104_eos, rx2104_done
    set rx2104_off, 0
    lt rx2104_pos, 2, rx2104_start
    sub rx2104_off, rx2104_pos, 1
    substr rx2104_tgt, rx2104_tgt, rx2104_off
  rx2104_start:
    eq $I10, 1, rx2104_restart
    if_null rx2104_debug, debug_1499
    rx2104_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1499:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2105_done
    goto rxscan2105_scan
  rxscan2105_loop:
    (rx2104_pos) = rx2104_cur."from"()
    inc rx2104_pos
    rx2104_cur."!cursor_from"(rx2104_pos)
    ge rx2104_pos, rx2104_eos, rxscan2105_done
  rxscan2105_scan:
    set_addr $I10, rxscan2105_loop
    rx2104_cur."!mark_push"(0, rx2104_pos, $I10)
  rxscan2105_done:
.annotate 'line', 1126
  # rx subcapture "sym"
    set_addr $I10, rxcap_2106_fail
    rx2104_cur."!mark_push"(0, rx2104_pos, $I10)
  # rx literal  "--"
    add $I11, rx2104_pos, 2
    gt $I11, rx2104_eos, rx2104_fail
    sub $I11, rx2104_pos, rx2104_off
    substr $S10, rx2104_tgt, $I11, 2
    ne $S10, "--", rx2104_fail
    add rx2104_pos, 2
    set_addr $I10, rxcap_2106_fail
    ($I12, $I11) = rx2104_cur."!mark_peek"($I10)
    rx2104_cur."!cursor_pos"($I11)
    ($P10) = rx2104_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2104_pos, "")
    rx2104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2106_done
  rxcap_2106_fail:
    goto rx2104_fail
  rxcap_2106_done:
  # rx subrule "O" subtype=capture negate=
    rx2104_cur."!cursor_pos"(rx2104_pos)
    $P10 = rx2104_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2104_fail
    rx2104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2104_pos = $P10."pos"()
  # rx pass
    rx2104_cur."!cursor_pass"(rx2104_pos, "prefix:sym<-->")
    if_null rx2104_debug, debug_1500
    rx2104_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2104_pos)
  debug_1500:
    .return (rx2104_cur)
  rx2104_restart:
.annotate 'line', 469
    if_null rx2104_debug, debug_1501
    rx2104_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1501:
  rx2104_fail:
    (rx2104_rep, rx2104_pos, $I10, $P10) = rx2104_cur."!mark_fail"(0)
    lt rx2104_pos, -1, rx2104_done
    eq rx2104_pos, -1, rx2104_fail
    jump $I10
  rx2104_done:
    rx2104_cur."!cursor_fail"()
    if_null rx2104_debug, debug_1502
    rx2104_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1502:
    .return (rx2104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("332_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("333_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2109_tgt
    .local int rx2109_pos
    .local int rx2109_off
    .local int rx2109_eos
    .local int rx2109_rep
    .local pmc rx2109_cur
    .local pmc rx2109_debug
    (rx2109_cur, rx2109_pos, rx2109_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2109_cur
    .local pmc match
    .lex "$/", match
    length rx2109_eos, rx2109_tgt
    gt rx2109_pos, rx2109_eos, rx2109_done
    set rx2109_off, 0
    lt rx2109_pos, 2, rx2109_start
    sub rx2109_off, rx2109_pos, 1
    substr rx2109_tgt, rx2109_tgt, rx2109_off
  rx2109_start:
    eq $I10, 1, rx2109_restart
    if_null rx2109_debug, debug_1503
    rx2109_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1503:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2110_done
    goto rxscan2110_scan
  rxscan2110_loop:
    (rx2109_pos) = rx2109_cur."from"()
    inc rx2109_pos
    rx2109_cur."!cursor_from"(rx2109_pos)
    ge rx2109_pos, rx2109_eos, rxscan2110_done
  rxscan2110_scan:
    set_addr $I10, rxscan2110_loop
    rx2109_cur."!mark_push"(0, rx2109_pos, $I10)
  rxscan2110_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2111_fail
    rx2109_cur."!mark_push"(0, rx2109_pos, $I10)
  # rx literal  "++"
    add $I11, rx2109_pos, 2
    gt $I11, rx2109_eos, rx2109_fail
    sub $I11, rx2109_pos, rx2109_off
    substr $S10, rx2109_tgt, $I11, 2
    ne $S10, "++", rx2109_fail
    add rx2109_pos, 2
    set_addr $I10, rxcap_2111_fail
    ($I12, $I11) = rx2109_cur."!mark_peek"($I10)
    rx2109_cur."!cursor_pos"($I11)
    ($P10) = rx2109_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2109_pos, "")
    rx2109_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2111_done
  rxcap_2111_fail:
    goto rx2109_fail
  rxcap_2111_done:
  # rx subrule "O" subtype=capture negate=
    rx2109_cur."!cursor_pos"(rx2109_pos)
    $P10 = rx2109_cur."O"("%autoincrement")
    unless $P10, rx2109_fail
    rx2109_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2109_pos = $P10."pos"()
  # rx pass
    rx2109_cur."!cursor_pass"(rx2109_pos, "postfix:sym<++>")
    if_null rx2109_debug, debug_1504
    rx2109_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2109_pos)
  debug_1504:
    .return (rx2109_cur)
  rx2109_restart:
.annotate 'line', 469
    if_null rx2109_debug, debug_1505
    rx2109_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1505:
  rx2109_fail:
    (rx2109_rep, rx2109_pos, $I10, $P10) = rx2109_cur."!mark_fail"(0)
    lt rx2109_pos, -1, rx2109_done
    eq rx2109_pos, -1, rx2109_fail
    jump $I10
  rx2109_done:
    rx2109_cur."!cursor_fail"()
    if_null rx2109_debug, debug_1506
    rx2109_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1506:
    .return (rx2109_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("334_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("335_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2114_tgt
    .local int rx2114_pos
    .local int rx2114_off
    .local int rx2114_eos
    .local int rx2114_rep
    .local pmc rx2114_cur
    .local pmc rx2114_debug
    (rx2114_cur, rx2114_pos, rx2114_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2114_cur
    .local pmc match
    .lex "$/", match
    length rx2114_eos, rx2114_tgt
    gt rx2114_pos, rx2114_eos, rx2114_done
    set rx2114_off, 0
    lt rx2114_pos, 2, rx2114_start
    sub rx2114_off, rx2114_pos, 1
    substr rx2114_tgt, rx2114_tgt, rx2114_off
  rx2114_start:
    eq $I10, 1, rx2114_restart
    if_null rx2114_debug, debug_1507
    rx2114_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1507:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2115_done
    goto rxscan2115_scan
  rxscan2115_loop:
    (rx2114_pos) = rx2114_cur."from"()
    inc rx2114_pos
    rx2114_cur."!cursor_from"(rx2114_pos)
    ge rx2114_pos, rx2114_eos, rxscan2115_done
  rxscan2115_scan:
    set_addr $I10, rxscan2115_loop
    rx2114_cur."!mark_push"(0, rx2114_pos, $I10)
  rxscan2115_done:
.annotate 'line', 1130
  # rx subcapture "sym"
    set_addr $I10, rxcap_2116_fail
    rx2114_cur."!mark_push"(0, rx2114_pos, $I10)
  # rx literal  "--"
    add $I11, rx2114_pos, 2
    gt $I11, rx2114_eos, rx2114_fail
    sub $I11, rx2114_pos, rx2114_off
    substr $S10, rx2114_tgt, $I11, 2
    ne $S10, "--", rx2114_fail
    add rx2114_pos, 2
    set_addr $I10, rxcap_2116_fail
    ($I12, $I11) = rx2114_cur."!mark_peek"($I10)
    rx2114_cur."!cursor_pos"($I11)
    ($P10) = rx2114_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2114_pos, "")
    rx2114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2116_done
  rxcap_2116_fail:
    goto rx2114_fail
  rxcap_2116_done:
  # rx subrule "O" subtype=capture negate=
    rx2114_cur."!cursor_pos"(rx2114_pos)
    $P10 = rx2114_cur."O"("%autoincrement")
    unless $P10, rx2114_fail
    rx2114_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2114_pos = $P10."pos"()
  # rx pass
    rx2114_cur."!cursor_pass"(rx2114_pos, "postfix:sym<-->")
    if_null rx2114_debug, debug_1508
    rx2114_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2114_pos)
  debug_1508:
    .return (rx2114_cur)
  rx2114_restart:
.annotate 'line', 469
    if_null rx2114_debug, debug_1509
    rx2114_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1509:
  rx2114_fail:
    (rx2114_rep, rx2114_pos, $I10, $P10) = rx2114_cur."!mark_fail"(0)
    lt rx2114_pos, -1, rx2114_done
    eq rx2114_pos, -1, rx2114_fail
    jump $I10
  rx2114_done:
    rx2114_cur."!cursor_fail"()
    if_null rx2114_debug, debug_1510
    rx2114_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1510:
    .return (rx2114_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("336_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("337_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2119_tgt
    .local int rx2119_pos
    .local int rx2119_off
    .local int rx2119_eos
    .local int rx2119_rep
    .local pmc rx2119_cur
    .local pmc rx2119_debug
    (rx2119_cur, rx2119_pos, rx2119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2119_cur
    .local pmc match
    .lex "$/", match
    length rx2119_eos, rx2119_tgt
    gt rx2119_pos, rx2119_eos, rx2119_done
    set rx2119_off, 0
    lt rx2119_pos, 2, rx2119_start
    sub rx2119_off, rx2119_pos, 1
    substr rx2119_tgt, rx2119_tgt, rx2119_off
  rx2119_start:
    eq $I10, 1, rx2119_restart
    if_null rx2119_debug, debug_1511
    rx2119_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1511:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2120_done
    goto rxscan2120_scan
  rxscan2120_loop:
    (rx2119_pos) = rx2119_cur."from"()
    inc rx2119_pos
    rx2119_cur."!cursor_from"(rx2119_pos)
    ge rx2119_pos, rx2119_eos, rxscan2120_done
  rxscan2120_scan:
    set_addr $I10, rxscan2120_loop
    rx2119_cur."!mark_push"(0, rx2119_pos, $I10)
  rxscan2120_done:
.annotate 'line', 1132
  # rx subcapture "sym"
    set_addr $I10, rxcap_2121_fail
    rx2119_cur."!mark_push"(0, rx2119_pos, $I10)
  # rx literal  "**"
    add $I11, rx2119_pos, 2
    gt $I11, rx2119_eos, rx2119_fail
    sub $I11, rx2119_pos, rx2119_off
    substr $S10, rx2119_tgt, $I11, 2
    ne $S10, "**", rx2119_fail
    add rx2119_pos, 2
    set_addr $I10, rxcap_2121_fail
    ($I12, $I11) = rx2119_cur."!mark_peek"($I10)
    rx2119_cur."!cursor_pos"($I11)
    ($P10) = rx2119_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2119_pos, "")
    rx2119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2121_done
  rxcap_2121_fail:
    goto rx2119_fail
  rxcap_2121_done:
  # rx subrule "O" subtype=capture negate=
    rx2119_cur."!cursor_pos"(rx2119_pos)
    $P10 = rx2119_cur."O"("%exponentiation, :pirop<pow__NNN>")
    unless $P10, rx2119_fail
    rx2119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2119_pos = $P10."pos"()
  # rx pass
    rx2119_cur."!cursor_pass"(rx2119_pos, "infix:sym<**>")
    if_null rx2119_debug, debug_1512
    rx2119_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2119_pos)
  debug_1512:
    .return (rx2119_cur)
  rx2119_restart:
.annotate 'line', 469
    if_null rx2119_debug, debug_1513
    rx2119_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1513:
  rx2119_fail:
    (rx2119_rep, rx2119_pos, $I10, $P10) = rx2119_cur."!mark_fail"(0)
    lt rx2119_pos, -1, rx2119_done
    eq rx2119_pos, -1, rx2119_fail
    jump $I10
  rx2119_done:
    rx2119_cur."!cursor_fail"()
    if_null rx2119_debug, debug_1514
    rx2119_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1514:
    .return (rx2119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("338_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "**")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("339_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2124_tgt
    .local int rx2124_pos
    .local int rx2124_off
    .local int rx2124_eos
    .local int rx2124_rep
    .local pmc rx2124_cur
    .local pmc rx2124_debug
    (rx2124_cur, rx2124_pos, rx2124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2124_cur
    .local pmc match
    .lex "$/", match
    length rx2124_eos, rx2124_tgt
    gt rx2124_pos, rx2124_eos, rx2124_done
    set rx2124_off, 0
    lt rx2124_pos, 2, rx2124_start
    sub rx2124_off, rx2124_pos, 1
    substr rx2124_tgt, rx2124_tgt, rx2124_off
  rx2124_start:
    eq $I10, 1, rx2124_restart
    if_null rx2124_debug, debug_1515
    rx2124_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1515:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2125_done
    goto rxscan2125_scan
  rxscan2125_loop:
    (rx2124_pos) = rx2124_cur."from"()
    inc rx2124_pos
    rx2124_cur."!cursor_from"(rx2124_pos)
    ge rx2124_pos, rx2124_eos, rxscan2125_done
  rxscan2125_scan:
    set_addr $I10, rxscan2125_loop
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  rxscan2125_done:
.annotate 'line', 1134
  # rx subcapture "sym"
    set_addr $I10, rxcap_2126_fail
    rx2124_cur."!mark_push"(0, rx2124_pos, $I10)
  # rx literal  "+"
    add $I11, rx2124_pos, 1
    gt $I11, rx2124_eos, rx2124_fail
    sub $I11, rx2124_pos, rx2124_off
    ord $I11, rx2124_tgt, $I11
    ne $I11, 43, rx2124_fail
    add rx2124_pos, 1
    set_addr $I10, rxcap_2126_fail
    ($I12, $I11) = rx2124_cur."!mark_peek"($I10)
    rx2124_cur."!cursor_pos"($I11)
    ($P10) = rx2124_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2124_pos, "")
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2126_done
  rxcap_2126_fail:
    goto rx2124_fail
  rxcap_2126_done:
  # rx subrule "O" subtype=capture negate=
    rx2124_cur."!cursor_pos"(rx2124_pos)
    $P10 = rx2124_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2124_fail
    rx2124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2124_pos = $P10."pos"()
  # rx pass
    rx2124_cur."!cursor_pass"(rx2124_pos, "prefix:sym<+>")
    if_null rx2124_debug, debug_1516
    rx2124_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2124_pos)
  debug_1516:
    .return (rx2124_cur)
  rx2124_restart:
.annotate 'line', 469
    if_null rx2124_debug, debug_1517
    rx2124_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1517:
  rx2124_fail:
    (rx2124_rep, rx2124_pos, $I10, $P10) = rx2124_cur."!mark_fail"(0)
    lt rx2124_pos, -1, rx2124_done
    eq rx2124_pos, -1, rx2124_fail
    jump $I10
  rx2124_done:
    rx2124_cur."!cursor_fail"()
    if_null rx2124_debug, debug_1518
    rx2124_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1518:
    .return (rx2124_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("340_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("341_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2129_tgt
    .local int rx2129_pos
    .local int rx2129_off
    .local int rx2129_eos
    .local int rx2129_rep
    .local pmc rx2129_cur
    .local pmc rx2129_debug
    (rx2129_cur, rx2129_pos, rx2129_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2129_cur
    .local pmc match
    .lex "$/", match
    length rx2129_eos, rx2129_tgt
    gt rx2129_pos, rx2129_eos, rx2129_done
    set rx2129_off, 0
    lt rx2129_pos, 2, rx2129_start
    sub rx2129_off, rx2129_pos, 1
    substr rx2129_tgt, rx2129_tgt, rx2129_off
  rx2129_start:
    eq $I10, 1, rx2129_restart
    if_null rx2129_debug, debug_1519
    rx2129_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1519:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2130_done
    goto rxscan2130_scan
  rxscan2130_loop:
    (rx2129_pos) = rx2129_cur."from"()
    inc rx2129_pos
    rx2129_cur."!cursor_from"(rx2129_pos)
    ge rx2129_pos, rx2129_eos, rxscan2130_done
  rxscan2130_scan:
    set_addr $I10, rxscan2130_loop
    rx2129_cur."!mark_push"(0, rx2129_pos, $I10)
  rxscan2130_done:
.annotate 'line', 1135
  # rx subcapture "sym"
    set_addr $I10, rxcap_2131_fail
    rx2129_cur."!mark_push"(0, rx2129_pos, $I10)
  # rx literal  "~"
    add $I11, rx2129_pos, 1
    gt $I11, rx2129_eos, rx2129_fail
    sub $I11, rx2129_pos, rx2129_off
    ord $I11, rx2129_tgt, $I11
    ne $I11, 126, rx2129_fail
    add rx2129_pos, 1
    set_addr $I10, rxcap_2131_fail
    ($I12, $I11) = rx2129_cur."!mark_peek"($I10)
    rx2129_cur."!cursor_pos"($I11)
    ($P10) = rx2129_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2129_pos, "")
    rx2129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2131_done
  rxcap_2131_fail:
    goto rx2129_fail
  rxcap_2131_done:
  # rx subrule "O" subtype=capture negate=
    rx2129_cur."!cursor_pos"(rx2129_pos)
    $P10 = rx2129_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2129_fail
    rx2129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2129_pos = $P10."pos"()
  # rx pass
    rx2129_cur."!cursor_pass"(rx2129_pos, "prefix:sym<~>")
    if_null rx2129_debug, debug_1520
    rx2129_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2129_pos)
  debug_1520:
    .return (rx2129_cur)
  rx2129_restart:
.annotate 'line', 469
    if_null rx2129_debug, debug_1521
    rx2129_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1521:
  rx2129_fail:
    (rx2129_rep, rx2129_pos, $I10, $P10) = rx2129_cur."!mark_fail"(0)
    lt rx2129_pos, -1, rx2129_done
    eq rx2129_pos, -1, rx2129_fail
    jump $I10
  rx2129_done:
    rx2129_cur."!cursor_fail"()
    if_null rx2129_debug, debug_1522
    rx2129_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1522:
    .return (rx2129_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("342_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("343_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2134_tgt
    .local int rx2134_pos
    .local int rx2134_off
    .local int rx2134_eos
    .local int rx2134_rep
    .local pmc rx2134_cur
    .local pmc rx2134_debug
    (rx2134_cur, rx2134_pos, rx2134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2134_cur
    .local pmc match
    .lex "$/", match
    length rx2134_eos, rx2134_tgt
    gt rx2134_pos, rx2134_eos, rx2134_done
    set rx2134_off, 0
    lt rx2134_pos, 2, rx2134_start
    sub rx2134_off, rx2134_pos, 1
    substr rx2134_tgt, rx2134_tgt, rx2134_off
  rx2134_start:
    eq $I10, 1, rx2134_restart
    if_null rx2134_debug, debug_1523
    rx2134_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1523:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2135_done
    goto rxscan2135_scan
  rxscan2135_loop:
    (rx2134_pos) = rx2134_cur."from"()
    inc rx2134_pos
    rx2134_cur."!cursor_from"(rx2134_pos)
    ge rx2134_pos, rx2134_eos, rxscan2135_done
  rxscan2135_scan:
    set_addr $I10, rxscan2135_loop
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  rxscan2135_done:
.annotate 'line', 1136
  # rx subcapture "sym"
    set_addr $I10, rxcap_2136_fail
    rx2134_cur."!mark_push"(0, rx2134_pos, $I10)
  # rx literal  "-"
    add $I11, rx2134_pos, 1
    gt $I11, rx2134_eos, rx2134_fail
    sub $I11, rx2134_pos, rx2134_off
    ord $I11, rx2134_tgt, $I11
    ne $I11, 45, rx2134_fail
    add rx2134_pos, 1
    set_addr $I10, rxcap_2136_fail
    ($I12, $I11) = rx2134_cur."!mark_peek"($I10)
    rx2134_cur."!cursor_pos"($I11)
    ($P10) = rx2134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2134_pos, "")
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2136_done
  rxcap_2136_fail:
    goto rx2134_fail
  rxcap_2136_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2134_pos, rx2134_off
    substr $S10, rx2134_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2134_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."number"()
    if $P10, rx2134_fail
  # rx subrule "O" subtype=capture negate=
    rx2134_cur."!cursor_pos"(rx2134_pos)
    $P10 = rx2134_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2134_fail
    rx2134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2134_pos = $P10."pos"()
  # rx pass
    rx2134_cur."!cursor_pass"(rx2134_pos, "prefix:sym<->")
    if_null rx2134_debug, debug_1524
    rx2134_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2134_pos)
  debug_1524:
    .return (rx2134_cur)
  rx2134_restart:
.annotate 'line', 469
    if_null rx2134_debug, debug_1525
    rx2134_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1525:
  rx2134_fail:
    (rx2134_rep, rx2134_pos, $I10, $P10) = rx2134_cur."!mark_fail"(0)
    lt rx2134_pos, -1, rx2134_done
    eq rx2134_pos, -1, rx2134_fail
    jump $I10
  rx2134_done:
    rx2134_cur."!cursor_fail"()
    if_null rx2134_debug, debug_1526
    rx2134_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1526:
    .return (rx2134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("344_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "-"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("345_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2139_tgt
    .local int rx2139_pos
    .local int rx2139_off
    .local int rx2139_eos
    .local int rx2139_rep
    .local pmc rx2139_cur
    .local pmc rx2139_debug
    (rx2139_cur, rx2139_pos, rx2139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2139_cur
    .local pmc match
    .lex "$/", match
    length rx2139_eos, rx2139_tgt
    gt rx2139_pos, rx2139_eos, rx2139_done
    set rx2139_off, 0
    lt rx2139_pos, 2, rx2139_start
    sub rx2139_off, rx2139_pos, 1
    substr rx2139_tgt, rx2139_tgt, rx2139_off
  rx2139_start:
    eq $I10, 1, rx2139_restart
    if_null rx2139_debug, debug_1527
    rx2139_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1527:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2140_done
    goto rxscan2140_scan
  rxscan2140_loop:
    (rx2139_pos) = rx2139_cur."from"()
    inc rx2139_pos
    rx2139_cur."!cursor_from"(rx2139_pos)
    ge rx2139_pos, rx2139_eos, rxscan2140_done
  rxscan2140_scan:
    set_addr $I10, rxscan2140_loop
    rx2139_cur."!mark_push"(0, rx2139_pos, $I10)
  rxscan2140_done:
.annotate 'line', 1137
  # rx subcapture "sym"
    set_addr $I10, rxcap_2141_fail
    rx2139_cur."!mark_push"(0, rx2139_pos, $I10)
  # rx literal  "?"
    add $I11, rx2139_pos, 1
    gt $I11, rx2139_eos, rx2139_fail
    sub $I11, rx2139_pos, rx2139_off
    ord $I11, rx2139_tgt, $I11
    ne $I11, 63, rx2139_fail
    add rx2139_pos, 1
    set_addr $I10, rxcap_2141_fail
    ($I12, $I11) = rx2139_cur."!mark_peek"($I10)
    rx2139_cur."!cursor_pos"($I11)
    ($P10) = rx2139_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2139_pos, "")
    rx2139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2141_done
  rxcap_2141_fail:
    goto rx2139_fail
  rxcap_2141_done:
  # rx subrule "O" subtype=capture negate=
    rx2139_cur."!cursor_pos"(rx2139_pos)
    $P10 = rx2139_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2139_fail
    rx2139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2139_pos = $P10."pos"()
  # rx pass
    rx2139_cur."!cursor_pass"(rx2139_pos, "prefix:sym<?>")
    if_null rx2139_debug, debug_1528
    rx2139_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2139_pos)
  debug_1528:
    .return (rx2139_cur)
  rx2139_restart:
.annotate 'line', 469
    if_null rx2139_debug, debug_1529
    rx2139_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1529:
  rx2139_fail:
    (rx2139_rep, rx2139_pos, $I10, $P10) = rx2139_cur."!mark_fail"(0)
    lt rx2139_pos, -1, rx2139_done
    eq rx2139_pos, -1, rx2139_fail
    jump $I10
  rx2139_done:
    rx2139_cur."!cursor_fail"()
    if_null rx2139_debug, debug_1530
    rx2139_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1530:
    .return (rx2139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("346_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "?")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("347_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2144_tgt
    .local int rx2144_pos
    .local int rx2144_off
    .local int rx2144_eos
    .local int rx2144_rep
    .local pmc rx2144_cur
    .local pmc rx2144_debug
    (rx2144_cur, rx2144_pos, rx2144_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2144_cur
    .local pmc match
    .lex "$/", match
    length rx2144_eos, rx2144_tgt
    gt rx2144_pos, rx2144_eos, rx2144_done
    set rx2144_off, 0
    lt rx2144_pos, 2, rx2144_start
    sub rx2144_off, rx2144_pos, 1
    substr rx2144_tgt, rx2144_tgt, rx2144_off
  rx2144_start:
    eq $I10, 1, rx2144_restart
    if_null rx2144_debug, debug_1531
    rx2144_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1531:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2145_done
    goto rxscan2145_scan
  rxscan2145_loop:
    (rx2144_pos) = rx2144_cur."from"()
    inc rx2144_pos
    rx2144_cur."!cursor_from"(rx2144_pos)
    ge rx2144_pos, rx2144_eos, rxscan2145_done
  rxscan2145_scan:
    set_addr $I10, rxscan2145_loop
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  rxscan2145_done:
.annotate 'line', 1138
  # rx subcapture "sym"
    set_addr $I10, rxcap_2146_fail
    rx2144_cur."!mark_push"(0, rx2144_pos, $I10)
  # rx literal  "!"
    add $I11, rx2144_pos, 1
    gt $I11, rx2144_eos, rx2144_fail
    sub $I11, rx2144_pos, rx2144_off
    ord $I11, rx2144_tgt, $I11
    ne $I11, 33, rx2144_fail
    add rx2144_pos, 1
    set_addr $I10, rxcap_2146_fail
    ($I12, $I11) = rx2144_cur."!mark_peek"($I10)
    rx2144_cur."!cursor_pos"($I11)
    ($P10) = rx2144_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2144_pos, "")
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2146_done
  rxcap_2146_fail:
    goto rx2144_fail
  rxcap_2146_done:
  # rx subrule "O" subtype=capture negate=
    rx2144_cur."!cursor_pos"(rx2144_pos)
    $P10 = rx2144_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2144_fail
    rx2144_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2144_pos = $P10."pos"()
  # rx pass
    rx2144_cur."!cursor_pass"(rx2144_pos, "prefix:sym<!>")
    if_null rx2144_debug, debug_1532
    rx2144_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2144_pos)
  debug_1532:
    .return (rx2144_cur)
  rx2144_restart:
.annotate 'line', 469
    if_null rx2144_debug, debug_1533
    rx2144_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1533:
  rx2144_fail:
    (rx2144_rep, rx2144_pos, $I10, $P10) = rx2144_cur."!mark_fail"(0)
    lt rx2144_pos, -1, rx2144_done
    eq rx2144_pos, -1, rx2144_fail
    jump $I10
  rx2144_done:
    rx2144_cur."!cursor_fail"()
    if_null rx2144_debug, debug_1534
    rx2144_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1534:
    .return (rx2144_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("348_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "!")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("349_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2149_tgt
    .local int rx2149_pos
    .local int rx2149_off
    .local int rx2149_eos
    .local int rx2149_rep
    .local pmc rx2149_cur
    .local pmc rx2149_debug
    (rx2149_cur, rx2149_pos, rx2149_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2149_cur
    .local pmc match
    .lex "$/", match
    length rx2149_eos, rx2149_tgt
    gt rx2149_pos, rx2149_eos, rx2149_done
    set rx2149_off, 0
    lt rx2149_pos, 2, rx2149_start
    sub rx2149_off, rx2149_pos, 1
    substr rx2149_tgt, rx2149_tgt, rx2149_off
  rx2149_start:
    eq $I10, 1, rx2149_restart
    if_null rx2149_debug, debug_1535
    rx2149_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1535:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2150_done
    goto rxscan2150_scan
  rxscan2150_loop:
    (rx2149_pos) = rx2149_cur."from"()
    inc rx2149_pos
    rx2149_cur."!cursor_from"(rx2149_pos)
    ge rx2149_pos, rx2149_eos, rxscan2150_done
  rxscan2150_scan:
    set_addr $I10, rxscan2150_loop
    rx2149_cur."!mark_push"(0, rx2149_pos, $I10)
  rxscan2150_done:
.annotate 'line', 1139
  # rx subcapture "sym"
    set_addr $I10, rxcap_2151_fail
    rx2149_cur."!mark_push"(0, rx2149_pos, $I10)
  # rx literal  "|"
    add $I11, rx2149_pos, 1
    gt $I11, rx2149_eos, rx2149_fail
    sub $I11, rx2149_pos, rx2149_off
    ord $I11, rx2149_tgt, $I11
    ne $I11, 124, rx2149_fail
    add rx2149_pos, 1
    set_addr $I10, rxcap_2151_fail
    ($I12, $I11) = rx2149_cur."!mark_peek"($I10)
    rx2149_cur."!cursor_pos"($I11)
    ($P10) = rx2149_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2149_pos, "")
    rx2149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2151_done
  rxcap_2151_fail:
    goto rx2149_fail
  rxcap_2151_done:
  # rx subrule "O" subtype=capture negate=
    rx2149_cur."!cursor_pos"(rx2149_pos)
    $P10 = rx2149_cur."O"("%symbolic_unary")
    unless $P10, rx2149_fail
    rx2149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2149_pos = $P10."pos"()
  # rx pass
    rx2149_cur."!cursor_pass"(rx2149_pos, "prefix:sym<|>")
    if_null rx2149_debug, debug_1536
    rx2149_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2149_pos)
  debug_1536:
    .return (rx2149_cur)
  rx2149_restart:
.annotate 'line', 469
    if_null rx2149_debug, debug_1537
    rx2149_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1537:
  rx2149_fail:
    (rx2149_rep, rx2149_pos, $I10, $P10) = rx2149_cur."!mark_fail"(0)
    lt rx2149_pos, -1, rx2149_done
    eq rx2149_pos, -1, rx2149_fail
    jump $I10
  rx2149_done:
    rx2149_cur."!cursor_fail"()
    if_null rx2149_debug, debug_1538
    rx2149_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1538:
    .return (rx2149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("350_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("351_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2154_tgt
    .local int rx2154_pos
    .local int rx2154_off
    .local int rx2154_eos
    .local int rx2154_rep
    .local pmc rx2154_cur
    .local pmc rx2154_debug
    (rx2154_cur, rx2154_pos, rx2154_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2154_cur
    .local pmc match
    .lex "$/", match
    length rx2154_eos, rx2154_tgt
    gt rx2154_pos, rx2154_eos, rx2154_done
    set rx2154_off, 0
    lt rx2154_pos, 2, rx2154_start
    sub rx2154_off, rx2154_pos, 1
    substr rx2154_tgt, rx2154_tgt, rx2154_off
  rx2154_start:
    eq $I10, 1, rx2154_restart
    if_null rx2154_debug, debug_1539
    rx2154_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2155_done
    goto rxscan2155_scan
  rxscan2155_loop:
    (rx2154_pos) = rx2154_cur."from"()
    inc rx2154_pos
    rx2154_cur."!cursor_from"(rx2154_pos)
    ge rx2154_pos, rx2154_eos, rxscan2155_done
  rxscan2155_scan:
    set_addr $I10, rxscan2155_loop
    rx2154_cur."!mark_push"(0, rx2154_pos, $I10)
  rxscan2155_done:
.annotate 'line', 1141
  # rx subcapture "sym"
    set_addr $I10, rxcap_2156_fail
    rx2154_cur."!mark_push"(0, rx2154_pos, $I10)
  # rx literal  "*"
    add $I11, rx2154_pos, 1
    gt $I11, rx2154_eos, rx2154_fail
    sub $I11, rx2154_pos, rx2154_off
    ord $I11, rx2154_tgt, $I11
    ne $I11, 42, rx2154_fail
    add rx2154_pos, 1
    set_addr $I10, rxcap_2156_fail
    ($I12, $I11) = rx2154_cur."!mark_peek"($I10)
    rx2154_cur."!cursor_pos"($I11)
    ($P10) = rx2154_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2154_pos, "")
    rx2154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2156_done
  rxcap_2156_fail:
    goto rx2154_fail
  rxcap_2156_done:
  # rx subrule "O" subtype=capture negate=
    rx2154_cur."!cursor_pos"(rx2154_pos)
    $P10 = rx2154_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2154_fail
    rx2154_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2154_pos = $P10."pos"()
  # rx pass
    rx2154_cur."!cursor_pass"(rx2154_pos, "infix:sym<*>")
    if_null rx2154_debug, debug_1540
    rx2154_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2154_pos)
  debug_1540:
    .return (rx2154_cur)
  rx2154_restart:
.annotate 'line', 469
    if_null rx2154_debug, debug_1541
    rx2154_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1541:
  rx2154_fail:
    (rx2154_rep, rx2154_pos, $I10, $P10) = rx2154_cur."!mark_fail"(0)
    lt rx2154_pos, -1, rx2154_done
    eq rx2154_pos, -1, rx2154_fail
    jump $I10
  rx2154_done:
    rx2154_cur."!cursor_fail"()
    if_null rx2154_debug, debug_1542
    rx2154_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1542:
    .return (rx2154_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("352_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "*")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("353_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2159_tgt
    .local int rx2159_pos
    .local int rx2159_off
    .local int rx2159_eos
    .local int rx2159_rep
    .local pmc rx2159_cur
    .local pmc rx2159_debug
    (rx2159_cur, rx2159_pos, rx2159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2159_cur
    .local pmc match
    .lex "$/", match
    length rx2159_eos, rx2159_tgt
    gt rx2159_pos, rx2159_eos, rx2159_done
    set rx2159_off, 0
    lt rx2159_pos, 2, rx2159_start
    sub rx2159_off, rx2159_pos, 1
    substr rx2159_tgt, rx2159_tgt, rx2159_off
  rx2159_start:
    eq $I10, 1, rx2159_restart
    if_null rx2159_debug, debug_1543
    rx2159_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1543:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2160_done
    goto rxscan2160_scan
  rxscan2160_loop:
    (rx2159_pos) = rx2159_cur."from"()
    inc rx2159_pos
    rx2159_cur."!cursor_from"(rx2159_pos)
    ge rx2159_pos, rx2159_eos, rxscan2160_done
  rxscan2160_scan:
    set_addr $I10, rxscan2160_loop
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  rxscan2160_done:
.annotate 'line', 1142
  # rx subcapture "sym"
    set_addr $I10, rxcap_2161_fail
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  # rx literal  "/"
    add $I11, rx2159_pos, 1
    gt $I11, rx2159_eos, rx2159_fail
    sub $I11, rx2159_pos, rx2159_off
    ord $I11, rx2159_tgt, $I11
    ne $I11, 47, rx2159_fail
    add rx2159_pos, 1
    set_addr $I10, rxcap_2161_fail
    ($I12, $I11) = rx2159_cur."!mark_peek"($I10)
    rx2159_cur."!cursor_pos"($I11)
    ($P10) = rx2159_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2159_pos, "")
    rx2159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2161_done
  rxcap_2161_fail:
    goto rx2159_fail
  rxcap_2161_done:
  # rx subrule "O" subtype=capture negate=
    rx2159_cur."!cursor_pos"(rx2159_pos)
    $P10 = rx2159_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2159_fail
    rx2159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2159_pos = $P10."pos"()
  # rx pass
    rx2159_cur."!cursor_pass"(rx2159_pos, "infix:sym</>")
    if_null rx2159_debug, debug_1544
    rx2159_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2159_pos)
  debug_1544:
    .return (rx2159_cur)
  rx2159_restart:
.annotate 'line', 469
    if_null rx2159_debug, debug_1545
    rx2159_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1545:
  rx2159_fail:
    (rx2159_rep, rx2159_pos, $I10, $P10) = rx2159_cur."!mark_fail"(0)
    lt rx2159_pos, -1, rx2159_done
    eq rx2159_pos, -1, rx2159_fail
    jump $I10
  rx2159_done:
    rx2159_cur."!cursor_fail"()
    if_null rx2159_debug, debug_1546
    rx2159_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1546:
    .return (rx2159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("354_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("355_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2164_tgt
    .local int rx2164_pos
    .local int rx2164_off
    .local int rx2164_eos
    .local int rx2164_rep
    .local pmc rx2164_cur
    .local pmc rx2164_debug
    (rx2164_cur, rx2164_pos, rx2164_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2164_cur
    .local pmc match
    .lex "$/", match
    length rx2164_eos, rx2164_tgt
    gt rx2164_pos, rx2164_eos, rx2164_done
    set rx2164_off, 0
    lt rx2164_pos, 2, rx2164_start
    sub rx2164_off, rx2164_pos, 1
    substr rx2164_tgt, rx2164_tgt, rx2164_off
  rx2164_start:
    eq $I10, 1, rx2164_restart
    if_null rx2164_debug, debug_1547
    rx2164_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1547:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2165_done
    goto rxscan2165_scan
  rxscan2165_loop:
    (rx2164_pos) = rx2164_cur."from"()
    inc rx2164_pos
    rx2164_cur."!cursor_from"(rx2164_pos)
    ge rx2164_pos, rx2164_eos, rxscan2165_done
  rxscan2165_scan:
    set_addr $I10, rxscan2165_loop
    rx2164_cur."!mark_push"(0, rx2164_pos, $I10)
  rxscan2165_done:
.annotate 'line', 1143
  # rx subcapture "sym"
    set_addr $I10, rxcap_2166_fail
    rx2164_cur."!mark_push"(0, rx2164_pos, $I10)
  # rx literal  "%"
    add $I11, rx2164_pos, 1
    gt $I11, rx2164_eos, rx2164_fail
    sub $I11, rx2164_pos, rx2164_off
    ord $I11, rx2164_tgt, $I11
    ne $I11, 37, rx2164_fail
    add rx2164_pos, 1
    set_addr $I10, rxcap_2166_fail
    ($I12, $I11) = rx2164_cur."!mark_peek"($I10)
    rx2164_cur."!cursor_pos"($I11)
    ($P10) = rx2164_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2164_pos, "")
    rx2164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2166_done
  rxcap_2166_fail:
    goto rx2164_fail
  rxcap_2166_done:
  # rx subrule "O" subtype=capture negate=
    rx2164_cur."!cursor_pos"(rx2164_pos)
    $P10 = rx2164_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2164_fail
    rx2164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2164_pos = $P10."pos"()
  # rx pass
    rx2164_cur."!cursor_pass"(rx2164_pos, "infix:sym<%>")
    if_null rx2164_debug, debug_1548
    rx2164_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2164_pos)
  debug_1548:
    .return (rx2164_cur)
  rx2164_restart:
.annotate 'line', 469
    if_null rx2164_debug, debug_1549
    rx2164_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1549:
  rx2164_fail:
    (rx2164_rep, rx2164_pos, $I10, $P10) = rx2164_cur."!mark_fail"(0)
    lt rx2164_pos, -1, rx2164_done
    eq rx2164_pos, -1, rx2164_fail
    jump $I10
  rx2164_done:
    rx2164_cur."!cursor_fail"()
    if_null rx2164_debug, debug_1550
    rx2164_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1550:
    .return (rx2164_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("356_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "%")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("357_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2169_tgt
    .local int rx2169_pos
    .local int rx2169_off
    .local int rx2169_eos
    .local int rx2169_rep
    .local pmc rx2169_cur
    .local pmc rx2169_debug
    (rx2169_cur, rx2169_pos, rx2169_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2169_cur
    .local pmc match
    .lex "$/", match
    length rx2169_eos, rx2169_tgt
    gt rx2169_pos, rx2169_eos, rx2169_done
    set rx2169_off, 0
    lt rx2169_pos, 2, rx2169_start
    sub rx2169_off, rx2169_pos, 1
    substr rx2169_tgt, rx2169_tgt, rx2169_off
  rx2169_start:
    eq $I10, 1, rx2169_restart
    if_null rx2169_debug, debug_1551
    rx2169_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1551:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2170_done
    goto rxscan2170_scan
  rxscan2170_loop:
    (rx2169_pos) = rx2169_cur."from"()
    inc rx2169_pos
    rx2169_cur."!cursor_from"(rx2169_pos)
    ge rx2169_pos, rx2169_eos, rxscan2170_done
  rxscan2170_scan:
    set_addr $I10, rxscan2170_loop
    rx2169_cur."!mark_push"(0, rx2169_pos, $I10)
  rxscan2170_done:
.annotate 'line', 1144
  # rx subcapture "sym"
    set_addr $I10, rxcap_2171_fail
    rx2169_cur."!mark_push"(0, rx2169_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2169_pos, 2
    gt $I11, rx2169_eos, rx2169_fail
    sub $I11, rx2169_pos, rx2169_off
    substr $S10, rx2169_tgt, $I11, 2
    ne $S10, "+&", rx2169_fail
    add rx2169_pos, 2
    set_addr $I10, rxcap_2171_fail
    ($I12, $I11) = rx2169_cur."!mark_peek"($I10)
    rx2169_cur."!cursor_pos"($I11)
    ($P10) = rx2169_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2169_pos, "")
    rx2169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2171_done
  rxcap_2171_fail:
    goto rx2169_fail
  rxcap_2171_done:
  # rx subrule "O" subtype=capture negate=
    rx2169_cur."!cursor_pos"(rx2169_pos)
    $P10 = rx2169_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2169_fail
    rx2169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2169_pos = $P10."pos"()
  # rx pass
    rx2169_cur."!cursor_pass"(rx2169_pos, "infix:sym<+&>")
    if_null rx2169_debug, debug_1552
    rx2169_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2169_pos)
  debug_1552:
    .return (rx2169_cur)
  rx2169_restart:
.annotate 'line', 469
    if_null rx2169_debug, debug_1553
    rx2169_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1553:
  rx2169_fail:
    (rx2169_rep, rx2169_pos, $I10, $P10) = rx2169_cur."!mark_fail"(0)
    lt rx2169_pos, -1, rx2169_done
    eq rx2169_pos, -1, rx2169_fail
    jump $I10
  rx2169_done:
    rx2169_cur."!cursor_fail"()
    if_null rx2169_debug, debug_1554
    rx2169_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1554:
    .return (rx2169_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("358_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "+&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("359_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2174_tgt
    .local int rx2174_pos
    .local int rx2174_off
    .local int rx2174_eos
    .local int rx2174_rep
    .local pmc rx2174_cur
    .local pmc rx2174_debug
    (rx2174_cur, rx2174_pos, rx2174_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2174_cur
    .local pmc match
    .lex "$/", match
    length rx2174_eos, rx2174_tgt
    gt rx2174_pos, rx2174_eos, rx2174_done
    set rx2174_off, 0
    lt rx2174_pos, 2, rx2174_start
    sub rx2174_off, rx2174_pos, 1
    substr rx2174_tgt, rx2174_tgt, rx2174_off
  rx2174_start:
    eq $I10, 1, rx2174_restart
    if_null rx2174_debug, debug_1555
    rx2174_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1555:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2175_done
    goto rxscan2175_scan
  rxscan2175_loop:
    (rx2174_pos) = rx2174_cur."from"()
    inc rx2174_pos
    rx2174_cur."!cursor_from"(rx2174_pos)
    ge rx2174_pos, rx2174_eos, rxscan2175_done
  rxscan2175_scan:
    set_addr $I10, rxscan2175_loop
    rx2174_cur."!mark_push"(0, rx2174_pos, $I10)
  rxscan2175_done:
.annotate 'line', 1146
  # rx subcapture "sym"
    set_addr $I10, rxcap_2176_fail
    rx2174_cur."!mark_push"(0, rx2174_pos, $I10)
  # rx literal  "+"
    add $I11, rx2174_pos, 1
    gt $I11, rx2174_eos, rx2174_fail
    sub $I11, rx2174_pos, rx2174_off
    ord $I11, rx2174_tgt, $I11
    ne $I11, 43, rx2174_fail
    add rx2174_pos, 1
    set_addr $I10, rxcap_2176_fail
    ($I12, $I11) = rx2174_cur."!mark_peek"($I10)
    rx2174_cur."!cursor_pos"($I11)
    ($P10) = rx2174_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2174_pos, "")
    rx2174_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2176_done
  rxcap_2176_fail:
    goto rx2174_fail
  rxcap_2176_done:
  # rx subrule "O" subtype=capture negate=
    rx2174_cur."!cursor_pos"(rx2174_pos)
    $P10 = rx2174_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2174_fail
    rx2174_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2174_pos = $P10."pos"()
  # rx pass
    rx2174_cur."!cursor_pass"(rx2174_pos, "infix:sym<+>")
    if_null rx2174_debug, debug_1556
    rx2174_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2174_pos)
  debug_1556:
    .return (rx2174_cur)
  rx2174_restart:
.annotate 'line', 469
    if_null rx2174_debug, debug_1557
    rx2174_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1557:
  rx2174_fail:
    (rx2174_rep, rx2174_pos, $I10, $P10) = rx2174_cur."!mark_fail"(0)
    lt rx2174_pos, -1, rx2174_done
    eq rx2174_pos, -1, rx2174_fail
    jump $I10
  rx2174_done:
    rx2174_cur."!cursor_fail"()
    if_null rx2174_debug, debug_1558
    rx2174_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1558:
    .return (rx2174_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("360_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("361_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2179_tgt
    .local int rx2179_pos
    .local int rx2179_off
    .local int rx2179_eos
    .local int rx2179_rep
    .local pmc rx2179_cur
    .local pmc rx2179_debug
    (rx2179_cur, rx2179_pos, rx2179_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2179_cur
    .local pmc match
    .lex "$/", match
    length rx2179_eos, rx2179_tgt
    gt rx2179_pos, rx2179_eos, rx2179_done
    set rx2179_off, 0
    lt rx2179_pos, 2, rx2179_start
    sub rx2179_off, rx2179_pos, 1
    substr rx2179_tgt, rx2179_tgt, rx2179_off
  rx2179_start:
    eq $I10, 1, rx2179_restart
    if_null rx2179_debug, debug_1559
    rx2179_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1559:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2180_done
    goto rxscan2180_scan
  rxscan2180_loop:
    (rx2179_pos) = rx2179_cur."from"()
    inc rx2179_pos
    rx2179_cur."!cursor_from"(rx2179_pos)
    ge rx2179_pos, rx2179_eos, rxscan2180_done
  rxscan2180_scan:
    set_addr $I10, rxscan2180_loop
    rx2179_cur."!mark_push"(0, rx2179_pos, $I10)
  rxscan2180_done:
.annotate 'line', 1147
  # rx subcapture "sym"
    set_addr $I10, rxcap_2181_fail
    rx2179_cur."!mark_push"(0, rx2179_pos, $I10)
  # rx literal  "-"
    add $I11, rx2179_pos, 1
    gt $I11, rx2179_eos, rx2179_fail
    sub $I11, rx2179_pos, rx2179_off
    ord $I11, rx2179_tgt, $I11
    ne $I11, 45, rx2179_fail
    add rx2179_pos, 1
    set_addr $I10, rxcap_2181_fail
    ($I12, $I11) = rx2179_cur."!mark_peek"($I10)
    rx2179_cur."!cursor_pos"($I11)
    ($P10) = rx2179_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2179_pos, "")
    rx2179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2181_done
  rxcap_2181_fail:
    goto rx2179_fail
  rxcap_2181_done:
  # rx subrule "O" subtype=capture negate=
    rx2179_cur."!cursor_pos"(rx2179_pos)
    $P10 = rx2179_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2179_fail
    rx2179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2179_pos = $P10."pos"()
  # rx pass
    rx2179_cur."!cursor_pass"(rx2179_pos, "infix:sym<->")
    if_null rx2179_debug, debug_1560
    rx2179_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2179_pos)
  debug_1560:
    .return (rx2179_cur)
  rx2179_restart:
.annotate 'line', 469
    if_null rx2179_debug, debug_1561
    rx2179_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1561:
  rx2179_fail:
    (rx2179_rep, rx2179_pos, $I10, $P10) = rx2179_cur."!mark_fail"(0)
    lt rx2179_pos, -1, rx2179_done
    eq rx2179_pos, -1, rx2179_fail
    jump $I10
  rx2179_done:
    rx2179_cur."!cursor_fail"()
    if_null rx2179_debug, debug_1562
    rx2179_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1562:
    .return (rx2179_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("362_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "-")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("363_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2184_tgt
    .local int rx2184_pos
    .local int rx2184_off
    .local int rx2184_eos
    .local int rx2184_rep
    .local pmc rx2184_cur
    .local pmc rx2184_debug
    (rx2184_cur, rx2184_pos, rx2184_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2184_cur
    .local pmc match
    .lex "$/", match
    length rx2184_eos, rx2184_tgt
    gt rx2184_pos, rx2184_eos, rx2184_done
    set rx2184_off, 0
    lt rx2184_pos, 2, rx2184_start
    sub rx2184_off, rx2184_pos, 1
    substr rx2184_tgt, rx2184_tgt, rx2184_off
  rx2184_start:
    eq $I10, 1, rx2184_restart
    if_null rx2184_debug, debug_1563
    rx2184_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1563:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2185_done
    goto rxscan2185_scan
  rxscan2185_loop:
    (rx2184_pos) = rx2184_cur."from"()
    inc rx2184_pos
    rx2184_cur."!cursor_from"(rx2184_pos)
    ge rx2184_pos, rx2184_eos, rxscan2185_done
  rxscan2185_scan:
    set_addr $I10, rxscan2185_loop
    rx2184_cur."!mark_push"(0, rx2184_pos, $I10)
  rxscan2185_done:
.annotate 'line', 1148
  # rx subcapture "sym"
    set_addr $I10, rxcap_2186_fail
    rx2184_cur."!mark_push"(0, rx2184_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2184_pos, 2
    gt $I11, rx2184_eos, rx2184_fail
    sub $I11, rx2184_pos, rx2184_off
    substr $S10, rx2184_tgt, $I11, 2
    ne $S10, "+|", rx2184_fail
    add rx2184_pos, 2
    set_addr $I10, rxcap_2186_fail
    ($I12, $I11) = rx2184_cur."!mark_peek"($I10)
    rx2184_cur."!cursor_pos"($I11)
    ($P10) = rx2184_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2184_pos, "")
    rx2184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2186_done
  rxcap_2186_fail:
    goto rx2184_fail
  rxcap_2186_done:
  # rx subrule "O" subtype=capture negate=
    rx2184_cur."!cursor_pos"(rx2184_pos)
    $P10 = rx2184_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2184_fail
    rx2184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2184_pos = $P10."pos"()
  # rx pass
    rx2184_cur."!cursor_pass"(rx2184_pos, "infix:sym<+|>")
    if_null rx2184_debug, debug_1564
    rx2184_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2184_pos)
  debug_1564:
    .return (rx2184_cur)
  rx2184_restart:
.annotate 'line', 469
    if_null rx2184_debug, debug_1565
    rx2184_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1565:
  rx2184_fail:
    (rx2184_rep, rx2184_pos, $I10, $P10) = rx2184_cur."!mark_fail"(0)
    lt rx2184_pos, -1, rx2184_done
    eq rx2184_pos, -1, rx2184_fail
    jump $I10
  rx2184_done:
    rx2184_cur."!cursor_fail"()
    if_null rx2184_debug, debug_1566
    rx2184_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1566:
    .return (rx2184_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("364_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "+|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("365_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2189_tgt
    .local int rx2189_pos
    .local int rx2189_off
    .local int rx2189_eos
    .local int rx2189_rep
    .local pmc rx2189_cur
    .local pmc rx2189_debug
    (rx2189_cur, rx2189_pos, rx2189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2189_cur
    .local pmc match
    .lex "$/", match
    length rx2189_eos, rx2189_tgt
    gt rx2189_pos, rx2189_eos, rx2189_done
    set rx2189_off, 0
    lt rx2189_pos, 2, rx2189_start
    sub rx2189_off, rx2189_pos, 1
    substr rx2189_tgt, rx2189_tgt, rx2189_off
  rx2189_start:
    eq $I10, 1, rx2189_restart
    if_null rx2189_debug, debug_1567
    rx2189_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1567:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2190_done
    goto rxscan2190_scan
  rxscan2190_loop:
    (rx2189_pos) = rx2189_cur."from"()
    inc rx2189_pos
    rx2189_cur."!cursor_from"(rx2189_pos)
    ge rx2189_pos, rx2189_eos, rxscan2190_done
  rxscan2190_scan:
    set_addr $I10, rxscan2190_loop
    rx2189_cur."!mark_push"(0, rx2189_pos, $I10)
  rxscan2190_done:
.annotate 'line', 1149
  # rx subcapture "sym"
    set_addr $I10, rxcap_2191_fail
    rx2189_cur."!mark_push"(0, rx2189_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2189_pos, 2
    gt $I11, rx2189_eos, rx2189_fail
    sub $I11, rx2189_pos, rx2189_off
    substr $S10, rx2189_tgt, $I11, 2
    ne $S10, "+^", rx2189_fail
    add rx2189_pos, 2
    set_addr $I10, rxcap_2191_fail
    ($I12, $I11) = rx2189_cur."!mark_peek"($I10)
    rx2189_cur."!cursor_pos"($I11)
    ($P10) = rx2189_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2189_pos, "")
    rx2189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2191_done
  rxcap_2191_fail:
    goto rx2189_fail
  rxcap_2191_done:
  # rx subrule "O" subtype=capture negate=
    rx2189_cur."!cursor_pos"(rx2189_pos)
    $P10 = rx2189_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2189_fail
    rx2189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2189_pos = $P10."pos"()
  # rx pass
    rx2189_cur."!cursor_pass"(rx2189_pos, "infix:sym<+^>")
    if_null rx2189_debug, debug_1568
    rx2189_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2189_pos)
  debug_1568:
    .return (rx2189_cur)
  rx2189_restart:
.annotate 'line', 469
    if_null rx2189_debug, debug_1569
    rx2189_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1569:
  rx2189_fail:
    (rx2189_rep, rx2189_pos, $I10, $P10) = rx2189_cur."!mark_fail"(0)
    lt rx2189_pos, -1, rx2189_done
    eq rx2189_pos, -1, rx2189_fail
    jump $I10
  rx2189_done:
    rx2189_cur."!cursor_fail"()
    if_null rx2189_debug, debug_1570
    rx2189_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1570:
    .return (rx2189_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("366_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "+^")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("367_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2194_tgt
    .local int rx2194_pos
    .local int rx2194_off
    .local int rx2194_eos
    .local int rx2194_rep
    .local pmc rx2194_cur
    .local pmc rx2194_debug
    (rx2194_cur, rx2194_pos, rx2194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2194_cur
    .local pmc match
    .lex "$/", match
    length rx2194_eos, rx2194_tgt
    gt rx2194_pos, rx2194_eos, rx2194_done
    set rx2194_off, 0
    lt rx2194_pos, 2, rx2194_start
    sub rx2194_off, rx2194_pos, 1
    substr rx2194_tgt, rx2194_tgt, rx2194_off
  rx2194_start:
    eq $I10, 1, rx2194_restart
    if_null rx2194_debug, debug_1571
    rx2194_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1571:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2195_done
    goto rxscan2195_scan
  rxscan2195_loop:
    (rx2194_pos) = rx2194_cur."from"()
    inc rx2194_pos
    rx2194_cur."!cursor_from"(rx2194_pos)
    ge rx2194_pos, rx2194_eos, rxscan2195_done
  rxscan2195_scan:
    set_addr $I10, rxscan2195_loop
    rx2194_cur."!mark_push"(0, rx2194_pos, $I10)
  rxscan2195_done:
.annotate 'line', 1151
  # rx subcapture "sym"
    set_addr $I10, rxcap_2196_fail
    rx2194_cur."!mark_push"(0, rx2194_pos, $I10)
  # rx literal  "~"
    add $I11, rx2194_pos, 1
    gt $I11, rx2194_eos, rx2194_fail
    sub $I11, rx2194_pos, rx2194_off
    ord $I11, rx2194_tgt, $I11
    ne $I11, 126, rx2194_fail
    add rx2194_pos, 1
    set_addr $I10, rxcap_2196_fail
    ($I12, $I11) = rx2194_cur."!mark_peek"($I10)
    rx2194_cur."!cursor_pos"($I11)
    ($P10) = rx2194_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2194_pos, "")
    rx2194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2196_done
  rxcap_2196_fail:
    goto rx2194_fail
  rxcap_2196_done:
  # rx subrule "O" subtype=capture negate=
    rx2194_cur."!cursor_pos"(rx2194_pos)
    $P10 = rx2194_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2194_fail
    rx2194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2194_pos = $P10."pos"()
  # rx pass
    rx2194_cur."!cursor_pass"(rx2194_pos, "infix:sym<~>")
    if_null rx2194_debug, debug_1572
    rx2194_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2194_pos)
  debug_1572:
    .return (rx2194_cur)
  rx2194_restart:
.annotate 'line', 469
    if_null rx2194_debug, debug_1573
    rx2194_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1573:
  rx2194_fail:
    (rx2194_rep, rx2194_pos, $I10, $P10) = rx2194_cur."!mark_fail"(0)
    lt rx2194_pos, -1, rx2194_done
    eq rx2194_pos, -1, rx2194_fail
    jump $I10
  rx2194_done:
    rx2194_cur."!cursor_fail"()
    if_null rx2194_debug, debug_1574
    rx2194_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1574:
    .return (rx2194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("368_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("369_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2199_tgt
    .local int rx2199_pos
    .local int rx2199_off
    .local int rx2199_eos
    .local int rx2199_rep
    .local pmc rx2199_cur
    .local pmc rx2199_debug
    (rx2199_cur, rx2199_pos, rx2199_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2199_cur
    .local pmc match
    .lex "$/", match
    length rx2199_eos, rx2199_tgt
    gt rx2199_pos, rx2199_eos, rx2199_done
    set rx2199_off, 0
    lt rx2199_pos, 2, rx2199_start
    sub rx2199_off, rx2199_pos, 1
    substr rx2199_tgt, rx2199_tgt, rx2199_off
  rx2199_start:
    eq $I10, 1, rx2199_restart
    if_null rx2199_debug, debug_1575
    rx2199_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1575:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2200_done
    goto rxscan2200_scan
  rxscan2200_loop:
    (rx2199_pos) = rx2199_cur."from"()
    inc rx2199_pos
    rx2199_cur."!cursor_from"(rx2199_pos)
    ge rx2199_pos, rx2199_eos, rxscan2200_done
  rxscan2200_scan:
    set_addr $I10, rxscan2200_loop
    rx2199_cur."!mark_push"(0, rx2199_pos, $I10)
  rxscan2200_done:
.annotate 'line', 1153
  # rx subcapture "sym"
    set_addr $I10, rxcap_2201_fail
    rx2199_cur."!mark_push"(0, rx2199_pos, $I10)
  # rx literal  "=="
    add $I11, rx2199_pos, 2
    gt $I11, rx2199_eos, rx2199_fail
    sub $I11, rx2199_pos, rx2199_off
    substr $S10, rx2199_tgt, $I11, 2
    ne $S10, "==", rx2199_fail
    add rx2199_pos, 2
    set_addr $I10, rxcap_2201_fail
    ($I12, $I11) = rx2199_cur."!mark_peek"($I10)
    rx2199_cur."!cursor_pos"($I11)
    ($P10) = rx2199_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2199_pos, "")
    rx2199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2201_done
  rxcap_2201_fail:
    goto rx2199_fail
  rxcap_2201_done:
  # rx subrule "O" subtype=capture negate=
    rx2199_cur."!cursor_pos"(rx2199_pos)
    $P10 = rx2199_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2199_fail
    rx2199_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2199_pos = $P10."pos"()
  # rx pass
    rx2199_cur."!cursor_pass"(rx2199_pos, "infix:sym<==>")
    if_null rx2199_debug, debug_1576
    rx2199_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2199_pos)
  debug_1576:
    .return (rx2199_cur)
  rx2199_restart:
.annotate 'line', 469
    if_null rx2199_debug, debug_1577
    rx2199_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1577:
  rx2199_fail:
    (rx2199_rep, rx2199_pos, $I10, $P10) = rx2199_cur."!mark_fail"(0)
    lt rx2199_pos, -1, rx2199_done
    eq rx2199_pos, -1, rx2199_fail
    jump $I10
  rx2199_done:
    rx2199_cur."!cursor_fail"()
    if_null rx2199_debug, debug_1578
    rx2199_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1578:
    .return (rx2199_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("370_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "==")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("371_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2204_tgt
    .local int rx2204_pos
    .local int rx2204_off
    .local int rx2204_eos
    .local int rx2204_rep
    .local pmc rx2204_cur
    .local pmc rx2204_debug
    (rx2204_cur, rx2204_pos, rx2204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2204_cur
    .local pmc match
    .lex "$/", match
    length rx2204_eos, rx2204_tgt
    gt rx2204_pos, rx2204_eos, rx2204_done
    set rx2204_off, 0
    lt rx2204_pos, 2, rx2204_start
    sub rx2204_off, rx2204_pos, 1
    substr rx2204_tgt, rx2204_tgt, rx2204_off
  rx2204_start:
    eq $I10, 1, rx2204_restart
    if_null rx2204_debug, debug_1579
    rx2204_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1579:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2205_done
    goto rxscan2205_scan
  rxscan2205_loop:
    (rx2204_pos) = rx2204_cur."from"()
    inc rx2204_pos
    rx2204_cur."!cursor_from"(rx2204_pos)
    ge rx2204_pos, rx2204_eos, rxscan2205_done
  rxscan2205_scan:
    set_addr $I10, rxscan2205_loop
    rx2204_cur."!mark_push"(0, rx2204_pos, $I10)
  rxscan2205_done:
.annotate 'line', 1154
  # rx subcapture "sym"
    set_addr $I10, rxcap_2206_fail
    rx2204_cur."!mark_push"(0, rx2204_pos, $I10)
  # rx literal  "!="
    add $I11, rx2204_pos, 2
    gt $I11, rx2204_eos, rx2204_fail
    sub $I11, rx2204_pos, rx2204_off
    substr $S10, rx2204_tgt, $I11, 2
    ne $S10, "!=", rx2204_fail
    add rx2204_pos, 2
    set_addr $I10, rxcap_2206_fail
    ($I12, $I11) = rx2204_cur."!mark_peek"($I10)
    rx2204_cur."!cursor_pos"($I11)
    ($P10) = rx2204_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2204_pos, "")
    rx2204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2206_done
  rxcap_2206_fail:
    goto rx2204_fail
  rxcap_2206_done:
  # rx subrule "O" subtype=capture negate=
    rx2204_cur."!cursor_pos"(rx2204_pos)
    $P10 = rx2204_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2204_fail
    rx2204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2204_pos = $P10."pos"()
  # rx pass
    rx2204_cur."!cursor_pass"(rx2204_pos, "infix:sym<!=>")
    if_null rx2204_debug, debug_1580
    rx2204_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2204_pos)
  debug_1580:
    .return (rx2204_cur)
  rx2204_restart:
.annotate 'line', 469
    if_null rx2204_debug, debug_1581
    rx2204_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1581:
  rx2204_fail:
    (rx2204_rep, rx2204_pos, $I10, $P10) = rx2204_cur."!mark_fail"(0)
    lt rx2204_pos, -1, rx2204_done
    eq rx2204_pos, -1, rx2204_fail
    jump $I10
  rx2204_done:
    rx2204_cur."!cursor_fail"()
    if_null rx2204_debug, debug_1582
    rx2204_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1582:
    .return (rx2204_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("372_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "!=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("373_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2209_tgt
    .local int rx2209_pos
    .local int rx2209_off
    .local int rx2209_eos
    .local int rx2209_rep
    .local pmc rx2209_cur
    .local pmc rx2209_debug
    (rx2209_cur, rx2209_pos, rx2209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2209_cur
    .local pmc match
    .lex "$/", match
    length rx2209_eos, rx2209_tgt
    gt rx2209_pos, rx2209_eos, rx2209_done
    set rx2209_off, 0
    lt rx2209_pos, 2, rx2209_start
    sub rx2209_off, rx2209_pos, 1
    substr rx2209_tgt, rx2209_tgt, rx2209_off
  rx2209_start:
    eq $I10, 1, rx2209_restart
    if_null rx2209_debug, debug_1583
    rx2209_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1583:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2210_done
    goto rxscan2210_scan
  rxscan2210_loop:
    (rx2209_pos) = rx2209_cur."from"()
    inc rx2209_pos
    rx2209_cur."!cursor_from"(rx2209_pos)
    ge rx2209_pos, rx2209_eos, rxscan2210_done
  rxscan2210_scan:
    set_addr $I10, rxscan2210_loop
    rx2209_cur."!mark_push"(0, rx2209_pos, $I10)
  rxscan2210_done:
.annotate 'line', 1155
  # rx subcapture "sym"
    set_addr $I10, rxcap_2211_fail
    rx2209_cur."!mark_push"(0, rx2209_pos, $I10)
  # rx literal  "<="
    add $I11, rx2209_pos, 2
    gt $I11, rx2209_eos, rx2209_fail
    sub $I11, rx2209_pos, rx2209_off
    substr $S10, rx2209_tgt, $I11, 2
    ne $S10, "<=", rx2209_fail
    add rx2209_pos, 2
    set_addr $I10, rxcap_2211_fail
    ($I12, $I11) = rx2209_cur."!mark_peek"($I10)
    rx2209_cur."!cursor_pos"($I11)
    ($P10) = rx2209_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2209_pos, "")
    rx2209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2211_done
  rxcap_2211_fail:
    goto rx2209_fail
  rxcap_2211_done:
  # rx subrule "O" subtype=capture negate=
    rx2209_cur."!cursor_pos"(rx2209_pos)
    $P10 = rx2209_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2209_fail
    rx2209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2209_pos = $P10."pos"()
  # rx pass
    rx2209_cur."!cursor_pass"(rx2209_pos, "infix:sym<<=>")
    if_null rx2209_debug, debug_1584
    rx2209_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2209_pos)
  debug_1584:
    .return (rx2209_cur)
  rx2209_restart:
.annotate 'line', 469
    if_null rx2209_debug, debug_1585
    rx2209_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1585:
  rx2209_fail:
    (rx2209_rep, rx2209_pos, $I10, $P10) = rx2209_cur."!mark_fail"(0)
    lt rx2209_pos, -1, rx2209_done
    eq rx2209_pos, -1, rx2209_fail
    jump $I10
  rx2209_done:
    rx2209_cur."!cursor_fail"()
    if_null rx2209_debug, debug_1586
    rx2209_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1586:
    .return (rx2209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("374_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "<=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("375_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2214_tgt
    .local int rx2214_pos
    .local int rx2214_off
    .local int rx2214_eos
    .local int rx2214_rep
    .local pmc rx2214_cur
    .local pmc rx2214_debug
    (rx2214_cur, rx2214_pos, rx2214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2214_cur
    .local pmc match
    .lex "$/", match
    length rx2214_eos, rx2214_tgt
    gt rx2214_pos, rx2214_eos, rx2214_done
    set rx2214_off, 0
    lt rx2214_pos, 2, rx2214_start
    sub rx2214_off, rx2214_pos, 1
    substr rx2214_tgt, rx2214_tgt, rx2214_off
  rx2214_start:
    eq $I10, 1, rx2214_restart
    if_null rx2214_debug, debug_1587
    rx2214_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1587:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2215_done
    goto rxscan2215_scan
  rxscan2215_loop:
    (rx2214_pos) = rx2214_cur."from"()
    inc rx2214_pos
    rx2214_cur."!cursor_from"(rx2214_pos)
    ge rx2214_pos, rx2214_eos, rxscan2215_done
  rxscan2215_scan:
    set_addr $I10, rxscan2215_loop
    rx2214_cur."!mark_push"(0, rx2214_pos, $I10)
  rxscan2215_done:
.annotate 'line', 1156
  # rx subcapture "sym"
    set_addr $I10, rxcap_2216_fail
    rx2214_cur."!mark_push"(0, rx2214_pos, $I10)
  # rx literal  ">="
    add $I11, rx2214_pos, 2
    gt $I11, rx2214_eos, rx2214_fail
    sub $I11, rx2214_pos, rx2214_off
    substr $S10, rx2214_tgt, $I11, 2
    ne $S10, ">=", rx2214_fail
    add rx2214_pos, 2
    set_addr $I10, rxcap_2216_fail
    ($I12, $I11) = rx2214_cur."!mark_peek"($I10)
    rx2214_cur."!cursor_pos"($I11)
    ($P10) = rx2214_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2214_pos, "")
    rx2214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2216_done
  rxcap_2216_fail:
    goto rx2214_fail
  rxcap_2216_done:
  # rx subrule "O" subtype=capture negate=
    rx2214_cur."!cursor_pos"(rx2214_pos)
    $P10 = rx2214_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2214_fail
    rx2214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2214_pos = $P10."pos"()
  # rx pass
    rx2214_cur."!cursor_pass"(rx2214_pos, "infix:sym<>=>")
    if_null rx2214_debug, debug_1588
    rx2214_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2214_pos)
  debug_1588:
    .return (rx2214_cur)
  rx2214_restart:
.annotate 'line', 469
    if_null rx2214_debug, debug_1589
    rx2214_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1589:
  rx2214_fail:
    (rx2214_rep, rx2214_pos, $I10, $P10) = rx2214_cur."!mark_fail"(0)
    lt rx2214_pos, -1, rx2214_done
    eq rx2214_pos, -1, rx2214_fail
    jump $I10
  rx2214_done:
    rx2214_cur."!cursor_fail"()
    if_null rx2214_debug, debug_1590
    rx2214_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1590:
    .return (rx2214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("376_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", ">=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("377_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2219_tgt
    .local int rx2219_pos
    .local int rx2219_off
    .local int rx2219_eos
    .local int rx2219_rep
    .local pmc rx2219_cur
    .local pmc rx2219_debug
    (rx2219_cur, rx2219_pos, rx2219_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2219_cur
    .local pmc match
    .lex "$/", match
    length rx2219_eos, rx2219_tgt
    gt rx2219_pos, rx2219_eos, rx2219_done
    set rx2219_off, 0
    lt rx2219_pos, 2, rx2219_start
    sub rx2219_off, rx2219_pos, 1
    substr rx2219_tgt, rx2219_tgt, rx2219_off
  rx2219_start:
    eq $I10, 1, rx2219_restart
    if_null rx2219_debug, debug_1591
    rx2219_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1591:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2220_done
    goto rxscan2220_scan
  rxscan2220_loop:
    (rx2219_pos) = rx2219_cur."from"()
    inc rx2219_pos
    rx2219_cur."!cursor_from"(rx2219_pos)
    ge rx2219_pos, rx2219_eos, rxscan2220_done
  rxscan2220_scan:
    set_addr $I10, rxscan2220_loop
    rx2219_cur."!mark_push"(0, rx2219_pos, $I10)
  rxscan2220_done:
.annotate 'line', 1157
  # rx subcapture "sym"
    set_addr $I10, rxcap_2221_fail
    rx2219_cur."!mark_push"(0, rx2219_pos, $I10)
  # rx literal  "<"
    add $I11, rx2219_pos, 1
    gt $I11, rx2219_eos, rx2219_fail
    sub $I11, rx2219_pos, rx2219_off
    ord $I11, rx2219_tgt, $I11
    ne $I11, 60, rx2219_fail
    add rx2219_pos, 1
    set_addr $I10, rxcap_2221_fail
    ($I12, $I11) = rx2219_cur."!mark_peek"($I10)
    rx2219_cur."!cursor_pos"($I11)
    ($P10) = rx2219_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2219_pos, "")
    rx2219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2221_done
  rxcap_2221_fail:
    goto rx2219_fail
  rxcap_2221_done:
  # rx subrule "O" subtype=capture negate=
    rx2219_cur."!cursor_pos"(rx2219_pos)
    $P10 = rx2219_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2219_fail
    rx2219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2219_pos = $P10."pos"()
  # rx pass
    rx2219_cur."!cursor_pass"(rx2219_pos, "infix:sym<<>")
    if_null rx2219_debug, debug_1592
    rx2219_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2219_pos)
  debug_1592:
    .return (rx2219_cur)
  rx2219_restart:
.annotate 'line', 469
    if_null rx2219_debug, debug_1593
    rx2219_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1593:
  rx2219_fail:
    (rx2219_rep, rx2219_pos, $I10, $P10) = rx2219_cur."!mark_fail"(0)
    lt rx2219_pos, -1, rx2219_done
    eq rx2219_pos, -1, rx2219_fail
    jump $I10
  rx2219_done:
    rx2219_cur."!cursor_fail"()
    if_null rx2219_debug, debug_1594
    rx2219_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1594:
    .return (rx2219_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("378_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "<")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("379_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2224_tgt
    .local int rx2224_pos
    .local int rx2224_off
    .local int rx2224_eos
    .local int rx2224_rep
    .local pmc rx2224_cur
    .local pmc rx2224_debug
    (rx2224_cur, rx2224_pos, rx2224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2224_cur
    .local pmc match
    .lex "$/", match
    length rx2224_eos, rx2224_tgt
    gt rx2224_pos, rx2224_eos, rx2224_done
    set rx2224_off, 0
    lt rx2224_pos, 2, rx2224_start
    sub rx2224_off, rx2224_pos, 1
    substr rx2224_tgt, rx2224_tgt, rx2224_off
  rx2224_start:
    eq $I10, 1, rx2224_restart
    if_null rx2224_debug, debug_1595
    rx2224_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1595:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2225_done
    goto rxscan2225_scan
  rxscan2225_loop:
    (rx2224_pos) = rx2224_cur."from"()
    inc rx2224_pos
    rx2224_cur."!cursor_from"(rx2224_pos)
    ge rx2224_pos, rx2224_eos, rxscan2225_done
  rxscan2225_scan:
    set_addr $I10, rxscan2225_loop
    rx2224_cur."!mark_push"(0, rx2224_pos, $I10)
  rxscan2225_done:
.annotate 'line', 1158
  # rx subcapture "sym"
    set_addr $I10, rxcap_2226_fail
    rx2224_cur."!mark_push"(0, rx2224_pos, $I10)
  # rx literal  ">"
    add $I11, rx2224_pos, 1
    gt $I11, rx2224_eos, rx2224_fail
    sub $I11, rx2224_pos, rx2224_off
    ord $I11, rx2224_tgt, $I11
    ne $I11, 62, rx2224_fail
    add rx2224_pos, 1
    set_addr $I10, rxcap_2226_fail
    ($I12, $I11) = rx2224_cur."!mark_peek"($I10)
    rx2224_cur."!cursor_pos"($I11)
    ($P10) = rx2224_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2224_pos, "")
    rx2224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2226_done
  rxcap_2226_fail:
    goto rx2224_fail
  rxcap_2226_done:
  # rx subrule "O" subtype=capture negate=
    rx2224_cur."!cursor_pos"(rx2224_pos)
    $P10 = rx2224_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2224_fail
    rx2224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2224_pos = $P10."pos"()
  # rx pass
    rx2224_cur."!cursor_pass"(rx2224_pos, "infix:sym<>>")
    if_null rx2224_debug, debug_1596
    rx2224_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2224_pos)
  debug_1596:
    .return (rx2224_cur)
  rx2224_restart:
.annotate 'line', 469
    if_null rx2224_debug, debug_1597
    rx2224_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1597:
  rx2224_fail:
    (rx2224_rep, rx2224_pos, $I10, $P10) = rx2224_cur."!mark_fail"(0)
    lt rx2224_pos, -1, rx2224_done
    eq rx2224_pos, -1, rx2224_fail
    jump $I10
  rx2224_done:
    rx2224_cur."!cursor_fail"()
    if_null rx2224_debug, debug_1598
    rx2224_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1598:
    .return (rx2224_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("380_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", ">")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("381_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2229_tgt
    .local int rx2229_pos
    .local int rx2229_off
    .local int rx2229_eos
    .local int rx2229_rep
    .local pmc rx2229_cur
    .local pmc rx2229_debug
    (rx2229_cur, rx2229_pos, rx2229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2229_cur
    .local pmc match
    .lex "$/", match
    length rx2229_eos, rx2229_tgt
    gt rx2229_pos, rx2229_eos, rx2229_done
    set rx2229_off, 0
    lt rx2229_pos, 2, rx2229_start
    sub rx2229_off, rx2229_pos, 1
    substr rx2229_tgt, rx2229_tgt, rx2229_off
  rx2229_start:
    eq $I10, 1, rx2229_restart
    if_null rx2229_debug, debug_1599
    rx2229_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1599:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2230_done
    goto rxscan2230_scan
  rxscan2230_loop:
    (rx2229_pos) = rx2229_cur."from"()
    inc rx2229_pos
    rx2229_cur."!cursor_from"(rx2229_pos)
    ge rx2229_pos, rx2229_eos, rxscan2230_done
  rxscan2230_scan:
    set_addr $I10, rxscan2230_loop
    rx2229_cur."!mark_push"(0, rx2229_pos, $I10)
  rxscan2230_done:
.annotate 'line', 1159
  # rx subcapture "sym"
    set_addr $I10, rxcap_2231_fail
    rx2229_cur."!mark_push"(0, rx2229_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2229_pos, 2
    gt $I11, rx2229_eos, rx2229_fail
    sub $I11, rx2229_pos, rx2229_off
    substr $S10, rx2229_tgt, $I11, 2
    ne $S10, "eq", rx2229_fail
    add rx2229_pos, 2
    set_addr $I10, rxcap_2231_fail
    ($I12, $I11) = rx2229_cur."!mark_peek"($I10)
    rx2229_cur."!cursor_pos"($I11)
    ($P10) = rx2229_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2229_pos, "")
    rx2229_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2231_done
  rxcap_2231_fail:
    goto rx2229_fail
  rxcap_2231_done:
  # rx subrule "O" subtype=capture negate=
    rx2229_cur."!cursor_pos"(rx2229_pos)
    $P10 = rx2229_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2229_fail
    rx2229_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2229_pos = $P10."pos"()
  # rx pass
    rx2229_cur."!cursor_pass"(rx2229_pos, "infix:sym<eq>")
    if_null rx2229_debug, debug_1600
    rx2229_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2229_pos)
  debug_1600:
    .return (rx2229_cur)
  rx2229_restart:
.annotate 'line', 469
    if_null rx2229_debug, debug_1601
    rx2229_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1601:
  rx2229_fail:
    (rx2229_rep, rx2229_pos, $I10, $P10) = rx2229_cur."!mark_fail"(0)
    lt rx2229_pos, -1, rx2229_done
    eq rx2229_pos, -1, rx2229_fail
    jump $I10
  rx2229_done:
    rx2229_cur."!cursor_fail"()
    if_null rx2229_debug, debug_1602
    rx2229_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1602:
    .return (rx2229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("382_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "eq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("383_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2234_tgt
    .local int rx2234_pos
    .local int rx2234_off
    .local int rx2234_eos
    .local int rx2234_rep
    .local pmc rx2234_cur
    .local pmc rx2234_debug
    (rx2234_cur, rx2234_pos, rx2234_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2234_cur
    .local pmc match
    .lex "$/", match
    length rx2234_eos, rx2234_tgt
    gt rx2234_pos, rx2234_eos, rx2234_done
    set rx2234_off, 0
    lt rx2234_pos, 2, rx2234_start
    sub rx2234_off, rx2234_pos, 1
    substr rx2234_tgt, rx2234_tgt, rx2234_off
  rx2234_start:
    eq $I10, 1, rx2234_restart
    if_null rx2234_debug, debug_1603
    rx2234_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1603:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2235_done
    goto rxscan2235_scan
  rxscan2235_loop:
    (rx2234_pos) = rx2234_cur."from"()
    inc rx2234_pos
    rx2234_cur."!cursor_from"(rx2234_pos)
    ge rx2234_pos, rx2234_eos, rxscan2235_done
  rxscan2235_scan:
    set_addr $I10, rxscan2235_loop
    rx2234_cur."!mark_push"(0, rx2234_pos, $I10)
  rxscan2235_done:
.annotate 'line', 1160
  # rx subcapture "sym"
    set_addr $I10, rxcap_2236_fail
    rx2234_cur."!mark_push"(0, rx2234_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2234_pos, 2
    gt $I11, rx2234_eos, rx2234_fail
    sub $I11, rx2234_pos, rx2234_off
    substr $S10, rx2234_tgt, $I11, 2
    ne $S10, "ne", rx2234_fail
    add rx2234_pos, 2
    set_addr $I10, rxcap_2236_fail
    ($I12, $I11) = rx2234_cur."!mark_peek"($I10)
    rx2234_cur."!cursor_pos"($I11)
    ($P10) = rx2234_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2234_pos, "")
    rx2234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2236_done
  rxcap_2236_fail:
    goto rx2234_fail
  rxcap_2236_done:
  # rx subrule "O" subtype=capture negate=
    rx2234_cur."!cursor_pos"(rx2234_pos)
    $P10 = rx2234_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2234_fail
    rx2234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2234_pos = $P10."pos"()
  # rx pass
    rx2234_cur."!cursor_pass"(rx2234_pos, "infix:sym<ne>")
    if_null rx2234_debug, debug_1604
    rx2234_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2234_pos)
  debug_1604:
    .return (rx2234_cur)
  rx2234_restart:
.annotate 'line', 469
    if_null rx2234_debug, debug_1605
    rx2234_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1605:
  rx2234_fail:
    (rx2234_rep, rx2234_pos, $I10, $P10) = rx2234_cur."!mark_fail"(0)
    lt rx2234_pos, -1, rx2234_done
    eq rx2234_pos, -1, rx2234_fail
    jump $I10
  rx2234_done:
    rx2234_cur."!cursor_fail"()
    if_null rx2234_debug, debug_1606
    rx2234_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1606:
    .return (rx2234_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("384_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "ne")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("385_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2239_tgt
    .local int rx2239_pos
    .local int rx2239_off
    .local int rx2239_eos
    .local int rx2239_rep
    .local pmc rx2239_cur
    .local pmc rx2239_debug
    (rx2239_cur, rx2239_pos, rx2239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2239_cur
    .local pmc match
    .lex "$/", match
    length rx2239_eos, rx2239_tgt
    gt rx2239_pos, rx2239_eos, rx2239_done
    set rx2239_off, 0
    lt rx2239_pos, 2, rx2239_start
    sub rx2239_off, rx2239_pos, 1
    substr rx2239_tgt, rx2239_tgt, rx2239_off
  rx2239_start:
    eq $I10, 1, rx2239_restart
    if_null rx2239_debug, debug_1607
    rx2239_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1607:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2240_done
    goto rxscan2240_scan
  rxscan2240_loop:
    (rx2239_pos) = rx2239_cur."from"()
    inc rx2239_pos
    rx2239_cur."!cursor_from"(rx2239_pos)
    ge rx2239_pos, rx2239_eos, rxscan2240_done
  rxscan2240_scan:
    set_addr $I10, rxscan2240_loop
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10)
  rxscan2240_done:
.annotate 'line', 1161
  # rx subcapture "sym"
    set_addr $I10, rxcap_2241_fail
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10)
  # rx literal  "le"
    add $I11, rx2239_pos, 2
    gt $I11, rx2239_eos, rx2239_fail
    sub $I11, rx2239_pos, rx2239_off
    substr $S10, rx2239_tgt, $I11, 2
    ne $S10, "le", rx2239_fail
    add rx2239_pos, 2
    set_addr $I10, rxcap_2241_fail
    ($I12, $I11) = rx2239_cur."!mark_peek"($I10)
    rx2239_cur."!cursor_pos"($I11)
    ($P10) = rx2239_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2239_pos, "")
    rx2239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2241_done
  rxcap_2241_fail:
    goto rx2239_fail
  rxcap_2241_done:
  # rx subrule "O" subtype=capture negate=
    rx2239_cur."!cursor_pos"(rx2239_pos)
    $P10 = rx2239_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2239_fail
    rx2239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2239_pos = $P10."pos"()
  # rx pass
    rx2239_cur."!cursor_pass"(rx2239_pos, "infix:sym<le>")
    if_null rx2239_debug, debug_1608
    rx2239_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2239_pos)
  debug_1608:
    .return (rx2239_cur)
  rx2239_restart:
.annotate 'line', 469
    if_null rx2239_debug, debug_1609
    rx2239_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1609:
  rx2239_fail:
    (rx2239_rep, rx2239_pos, $I10, $P10) = rx2239_cur."!mark_fail"(0)
    lt rx2239_pos, -1, rx2239_done
    eq rx2239_pos, -1, rx2239_fail
    jump $I10
  rx2239_done:
    rx2239_cur."!cursor_fail"()
    if_null rx2239_debug, debug_1610
    rx2239_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1610:
    .return (rx2239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("386_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "le")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("387_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2244_tgt
    .local int rx2244_pos
    .local int rx2244_off
    .local int rx2244_eos
    .local int rx2244_rep
    .local pmc rx2244_cur
    .local pmc rx2244_debug
    (rx2244_cur, rx2244_pos, rx2244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2244_cur
    .local pmc match
    .lex "$/", match
    length rx2244_eos, rx2244_tgt
    gt rx2244_pos, rx2244_eos, rx2244_done
    set rx2244_off, 0
    lt rx2244_pos, 2, rx2244_start
    sub rx2244_off, rx2244_pos, 1
    substr rx2244_tgt, rx2244_tgt, rx2244_off
  rx2244_start:
    eq $I10, 1, rx2244_restart
    if_null rx2244_debug, debug_1611
    rx2244_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1611:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2245_done
    goto rxscan2245_scan
  rxscan2245_loop:
    (rx2244_pos) = rx2244_cur."from"()
    inc rx2244_pos
    rx2244_cur."!cursor_from"(rx2244_pos)
    ge rx2244_pos, rx2244_eos, rxscan2245_done
  rxscan2245_scan:
    set_addr $I10, rxscan2245_loop
    rx2244_cur."!mark_push"(0, rx2244_pos, $I10)
  rxscan2245_done:
.annotate 'line', 1162
  # rx subcapture "sym"
    set_addr $I10, rxcap_2246_fail
    rx2244_cur."!mark_push"(0, rx2244_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2244_pos, 2
    gt $I11, rx2244_eos, rx2244_fail
    sub $I11, rx2244_pos, rx2244_off
    substr $S10, rx2244_tgt, $I11, 2
    ne $S10, "ge", rx2244_fail
    add rx2244_pos, 2
    set_addr $I10, rxcap_2246_fail
    ($I12, $I11) = rx2244_cur."!mark_peek"($I10)
    rx2244_cur."!cursor_pos"($I11)
    ($P10) = rx2244_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2244_pos, "")
    rx2244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2246_done
  rxcap_2246_fail:
    goto rx2244_fail
  rxcap_2246_done:
  # rx subrule "O" subtype=capture negate=
    rx2244_cur."!cursor_pos"(rx2244_pos)
    $P10 = rx2244_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2244_fail
    rx2244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2244_pos = $P10."pos"()
  # rx pass
    rx2244_cur."!cursor_pass"(rx2244_pos, "infix:sym<ge>")
    if_null rx2244_debug, debug_1612
    rx2244_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2244_pos)
  debug_1612:
    .return (rx2244_cur)
  rx2244_restart:
.annotate 'line', 469
    if_null rx2244_debug, debug_1613
    rx2244_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1613:
  rx2244_fail:
    (rx2244_rep, rx2244_pos, $I10, $P10) = rx2244_cur."!mark_fail"(0)
    lt rx2244_pos, -1, rx2244_done
    eq rx2244_pos, -1, rx2244_fail
    jump $I10
  rx2244_done:
    rx2244_cur."!cursor_fail"()
    if_null rx2244_debug, debug_1614
    rx2244_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1614:
    .return (rx2244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("388_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "ge")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("389_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2249_tgt
    .local int rx2249_pos
    .local int rx2249_off
    .local int rx2249_eos
    .local int rx2249_rep
    .local pmc rx2249_cur
    .local pmc rx2249_debug
    (rx2249_cur, rx2249_pos, rx2249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2249_cur
    .local pmc match
    .lex "$/", match
    length rx2249_eos, rx2249_tgt
    gt rx2249_pos, rx2249_eos, rx2249_done
    set rx2249_off, 0
    lt rx2249_pos, 2, rx2249_start
    sub rx2249_off, rx2249_pos, 1
    substr rx2249_tgt, rx2249_tgt, rx2249_off
  rx2249_start:
    eq $I10, 1, rx2249_restart
    if_null rx2249_debug, debug_1615
    rx2249_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1615:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2250_done
    goto rxscan2250_scan
  rxscan2250_loop:
    (rx2249_pos) = rx2249_cur."from"()
    inc rx2249_pos
    rx2249_cur."!cursor_from"(rx2249_pos)
    ge rx2249_pos, rx2249_eos, rxscan2250_done
  rxscan2250_scan:
    set_addr $I10, rxscan2250_loop
    rx2249_cur."!mark_push"(0, rx2249_pos, $I10)
  rxscan2250_done:
.annotate 'line', 1163
  # rx subcapture "sym"
    set_addr $I10, rxcap_2251_fail
    rx2249_cur."!mark_push"(0, rx2249_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2249_pos, 2
    gt $I11, rx2249_eos, rx2249_fail
    sub $I11, rx2249_pos, rx2249_off
    substr $S10, rx2249_tgt, $I11, 2
    ne $S10, "lt", rx2249_fail
    add rx2249_pos, 2
    set_addr $I10, rxcap_2251_fail
    ($I12, $I11) = rx2249_cur."!mark_peek"($I10)
    rx2249_cur."!cursor_pos"($I11)
    ($P10) = rx2249_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2249_pos, "")
    rx2249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2251_done
  rxcap_2251_fail:
    goto rx2249_fail
  rxcap_2251_done:
  # rx subrule "O" subtype=capture negate=
    rx2249_cur."!cursor_pos"(rx2249_pos)
    $P10 = rx2249_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2249_fail
    rx2249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2249_pos = $P10."pos"()
  # rx pass
    rx2249_cur."!cursor_pass"(rx2249_pos, "infix:sym<lt>")
    if_null rx2249_debug, debug_1616
    rx2249_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2249_pos)
  debug_1616:
    .return (rx2249_cur)
  rx2249_restart:
.annotate 'line', 469
    if_null rx2249_debug, debug_1617
    rx2249_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1617:
  rx2249_fail:
    (rx2249_rep, rx2249_pos, $I10, $P10) = rx2249_cur."!mark_fail"(0)
    lt rx2249_pos, -1, rx2249_done
    eq rx2249_pos, -1, rx2249_fail
    jump $I10
  rx2249_done:
    rx2249_cur."!cursor_fail"()
    if_null rx2249_debug, debug_1618
    rx2249_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1618:
    .return (rx2249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("390_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "lt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("391_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2254_tgt
    .local int rx2254_pos
    .local int rx2254_off
    .local int rx2254_eos
    .local int rx2254_rep
    .local pmc rx2254_cur
    .local pmc rx2254_debug
    (rx2254_cur, rx2254_pos, rx2254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2254_cur
    .local pmc match
    .lex "$/", match
    length rx2254_eos, rx2254_tgt
    gt rx2254_pos, rx2254_eos, rx2254_done
    set rx2254_off, 0
    lt rx2254_pos, 2, rx2254_start
    sub rx2254_off, rx2254_pos, 1
    substr rx2254_tgt, rx2254_tgt, rx2254_off
  rx2254_start:
    eq $I10, 1, rx2254_restart
    if_null rx2254_debug, debug_1619
    rx2254_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2255_done
    goto rxscan2255_scan
  rxscan2255_loop:
    (rx2254_pos) = rx2254_cur."from"()
    inc rx2254_pos
    rx2254_cur."!cursor_from"(rx2254_pos)
    ge rx2254_pos, rx2254_eos, rxscan2255_done
  rxscan2255_scan:
    set_addr $I10, rxscan2255_loop
    rx2254_cur."!mark_push"(0, rx2254_pos, $I10)
  rxscan2255_done:
.annotate 'line', 1164
  # rx subcapture "sym"
    set_addr $I10, rxcap_2256_fail
    rx2254_cur."!mark_push"(0, rx2254_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2254_pos, 2
    gt $I11, rx2254_eos, rx2254_fail
    sub $I11, rx2254_pos, rx2254_off
    substr $S10, rx2254_tgt, $I11, 2
    ne $S10, "gt", rx2254_fail
    add rx2254_pos, 2
    set_addr $I10, rxcap_2256_fail
    ($I12, $I11) = rx2254_cur."!mark_peek"($I10)
    rx2254_cur."!cursor_pos"($I11)
    ($P10) = rx2254_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2254_pos, "")
    rx2254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2256_done
  rxcap_2256_fail:
    goto rx2254_fail
  rxcap_2256_done:
  # rx subrule "O" subtype=capture negate=
    rx2254_cur."!cursor_pos"(rx2254_pos)
    $P10 = rx2254_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2254_fail
    rx2254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2254_pos = $P10."pos"()
  # rx pass
    rx2254_cur."!cursor_pass"(rx2254_pos, "infix:sym<gt>")
    if_null rx2254_debug, debug_1620
    rx2254_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2254_pos)
  debug_1620:
    .return (rx2254_cur)
  rx2254_restart:
.annotate 'line', 469
    if_null rx2254_debug, debug_1621
    rx2254_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1621:
  rx2254_fail:
    (rx2254_rep, rx2254_pos, $I10, $P10) = rx2254_cur."!mark_fail"(0)
    lt rx2254_pos, -1, rx2254_done
    eq rx2254_pos, -1, rx2254_fail
    jump $I10
  rx2254_done:
    rx2254_cur."!cursor_fail"()
    if_null rx2254_debug, debug_1622
    rx2254_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1622:
    .return (rx2254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("392_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "gt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("393_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2259_tgt
    .local int rx2259_pos
    .local int rx2259_off
    .local int rx2259_eos
    .local int rx2259_rep
    .local pmc rx2259_cur
    .local pmc rx2259_debug
    (rx2259_cur, rx2259_pos, rx2259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2259_cur
    .local pmc match
    .lex "$/", match
    length rx2259_eos, rx2259_tgt
    gt rx2259_pos, rx2259_eos, rx2259_done
    set rx2259_off, 0
    lt rx2259_pos, 2, rx2259_start
    sub rx2259_off, rx2259_pos, 1
    substr rx2259_tgt, rx2259_tgt, rx2259_off
  rx2259_start:
    eq $I10, 1, rx2259_restart
    if_null rx2259_debug, debug_1623
    rx2259_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2260_done
    goto rxscan2260_scan
  rxscan2260_loop:
    (rx2259_pos) = rx2259_cur."from"()
    inc rx2259_pos
    rx2259_cur."!cursor_from"(rx2259_pos)
    ge rx2259_pos, rx2259_eos, rxscan2260_done
  rxscan2260_scan:
    set_addr $I10, rxscan2260_loop
    rx2259_cur."!mark_push"(0, rx2259_pos, $I10)
  rxscan2260_done:
.annotate 'line', 1165
  # rx subcapture "sym"
    set_addr $I10, rxcap_2261_fail
    rx2259_cur."!mark_push"(0, rx2259_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2259_pos, 3
    gt $I11, rx2259_eos, rx2259_fail
    sub $I11, rx2259_pos, rx2259_off
    substr $S10, rx2259_tgt, $I11, 3
    ne $S10, "=:=", rx2259_fail
    add rx2259_pos, 3
    set_addr $I10, rxcap_2261_fail
    ($I12, $I11) = rx2259_cur."!mark_peek"($I10)
    rx2259_cur."!cursor_pos"($I11)
    ($P10) = rx2259_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2259_pos, "")
    rx2259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2261_done
  rxcap_2261_fail:
    goto rx2259_fail
  rxcap_2261_done:
  # rx subrule "O" subtype=capture negate=
    rx2259_cur."!cursor_pos"(rx2259_pos)
    $P10 = rx2259_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2259_fail
    rx2259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2259_pos = $P10."pos"()
  # rx pass
    rx2259_cur."!cursor_pass"(rx2259_pos, "infix:sym<=:=>")
    if_null rx2259_debug, debug_1624
    rx2259_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2259_pos)
  debug_1624:
    .return (rx2259_cur)
  rx2259_restart:
.annotate 'line', 469
    if_null rx2259_debug, debug_1625
    rx2259_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1625:
  rx2259_fail:
    (rx2259_rep, rx2259_pos, $I10, $P10) = rx2259_cur."!mark_fail"(0)
    lt rx2259_pos, -1, rx2259_done
    eq rx2259_pos, -1, rx2259_fail
    jump $I10
  rx2259_done:
    rx2259_cur."!cursor_fail"()
    if_null rx2259_debug, debug_1626
    rx2259_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1626:
    .return (rx2259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("394_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "=:=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("395_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2264_tgt
    .local int rx2264_pos
    .local int rx2264_off
    .local int rx2264_eos
    .local int rx2264_rep
    .local pmc rx2264_cur
    .local pmc rx2264_debug
    (rx2264_cur, rx2264_pos, rx2264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2264_cur
    .local pmc match
    .lex "$/", match
    length rx2264_eos, rx2264_tgt
    gt rx2264_pos, rx2264_eos, rx2264_done
    set rx2264_off, 0
    lt rx2264_pos, 2, rx2264_start
    sub rx2264_off, rx2264_pos, 1
    substr rx2264_tgt, rx2264_tgt, rx2264_off
  rx2264_start:
    eq $I10, 1, rx2264_restart
    if_null rx2264_debug, debug_1627
    rx2264_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2265_done
    goto rxscan2265_scan
  rxscan2265_loop:
    (rx2264_pos) = rx2264_cur."from"()
    inc rx2264_pos
    rx2264_cur."!cursor_from"(rx2264_pos)
    ge rx2264_pos, rx2264_eos, rxscan2265_done
  rxscan2265_scan:
    set_addr $I10, rxscan2265_loop
    rx2264_cur."!mark_push"(0, rx2264_pos, $I10)
  rxscan2265_done:
.annotate 'line', 1166
  # rx subcapture "sym"
    set_addr $I10, rxcap_2266_fail
    rx2264_cur."!mark_push"(0, rx2264_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2264_pos, 2
    gt $I11, rx2264_eos, rx2264_fail
    sub $I11, rx2264_pos, rx2264_off
    substr $S10, rx2264_tgt, $I11, 2
    ne $S10, "~~", rx2264_fail
    add rx2264_pos, 2
    set_addr $I10, rxcap_2266_fail
    ($I12, $I11) = rx2264_cur."!mark_peek"($I10)
    rx2264_cur."!cursor_pos"($I11)
    ($P10) = rx2264_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2264_pos, "")
    rx2264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2266_done
  rxcap_2266_fail:
    goto rx2264_fail
  rxcap_2266_done:
  # rx subrule "O" subtype=capture negate=
    rx2264_cur."!cursor_pos"(rx2264_pos)
    $P10 = rx2264_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2264_fail
    rx2264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2264_pos = $P10."pos"()
  # rx pass
    rx2264_cur."!cursor_pass"(rx2264_pos, "infix:sym<~~>")
    if_null rx2264_debug, debug_1628
    rx2264_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2264_pos)
  debug_1628:
    .return (rx2264_cur)
  rx2264_restart:
.annotate 'line', 469
    if_null rx2264_debug, debug_1629
    rx2264_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1629:
  rx2264_fail:
    (rx2264_rep, rx2264_pos, $I10, $P10) = rx2264_cur."!mark_fail"(0)
    lt rx2264_pos, -1, rx2264_done
    eq rx2264_pos, -1, rx2264_fail
    jump $I10
  rx2264_done:
    rx2264_cur."!cursor_fail"()
    if_null rx2264_debug, debug_1630
    rx2264_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1630:
    .return (rx2264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("396_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "~~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("397_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2269_tgt
    .local int rx2269_pos
    .local int rx2269_off
    .local int rx2269_eos
    .local int rx2269_rep
    .local pmc rx2269_cur
    .local pmc rx2269_debug
    (rx2269_cur, rx2269_pos, rx2269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2269_cur
    .local pmc match
    .lex "$/", match
    length rx2269_eos, rx2269_tgt
    gt rx2269_pos, rx2269_eos, rx2269_done
    set rx2269_off, 0
    lt rx2269_pos, 2, rx2269_start
    sub rx2269_off, rx2269_pos, 1
    substr rx2269_tgt, rx2269_tgt, rx2269_off
  rx2269_start:
    eq $I10, 1, rx2269_restart
    if_null rx2269_debug, debug_1631
    rx2269_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2270_done
    goto rxscan2270_scan
  rxscan2270_loop:
    (rx2269_pos) = rx2269_cur."from"()
    inc rx2269_pos
    rx2269_cur."!cursor_from"(rx2269_pos)
    ge rx2269_pos, rx2269_eos, rxscan2270_done
  rxscan2270_scan:
    set_addr $I10, rxscan2270_loop
    rx2269_cur."!mark_push"(0, rx2269_pos, $I10)
  rxscan2270_done:
.annotate 'line', 1168
  # rx subcapture "sym"
    set_addr $I10, rxcap_2271_fail
    rx2269_cur."!mark_push"(0, rx2269_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2269_pos, 2
    gt $I11, rx2269_eos, rx2269_fail
    sub $I11, rx2269_pos, rx2269_off
    substr $S10, rx2269_tgt, $I11, 2
    ne $S10, "&&", rx2269_fail
    add rx2269_pos, 2
    set_addr $I10, rxcap_2271_fail
    ($I12, $I11) = rx2269_cur."!mark_peek"($I10)
    rx2269_cur."!cursor_pos"($I11)
    ($P10) = rx2269_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2269_pos, "")
    rx2269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2271_done
  rxcap_2271_fail:
    goto rx2269_fail
  rxcap_2271_done:
  # rx subrule "O" subtype=capture negate=
    rx2269_cur."!cursor_pos"(rx2269_pos)
    $P10 = rx2269_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2269_fail
    rx2269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2269_pos = $P10."pos"()
  # rx pass
    rx2269_cur."!cursor_pass"(rx2269_pos, "infix:sym<&&>")
    if_null rx2269_debug, debug_1632
    rx2269_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2269_pos)
  debug_1632:
    .return (rx2269_cur)
  rx2269_restart:
.annotate 'line', 469
    if_null rx2269_debug, debug_1633
    rx2269_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1633:
  rx2269_fail:
    (rx2269_rep, rx2269_pos, $I10, $P10) = rx2269_cur."!mark_fail"(0)
    lt rx2269_pos, -1, rx2269_done
    eq rx2269_pos, -1, rx2269_fail
    jump $I10
  rx2269_done:
    rx2269_cur."!cursor_fail"()
    if_null rx2269_debug, debug_1634
    rx2269_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1634:
    .return (rx2269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("398_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "&&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("399_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2274_tgt
    .local int rx2274_pos
    .local int rx2274_off
    .local int rx2274_eos
    .local int rx2274_rep
    .local pmc rx2274_cur
    .local pmc rx2274_debug
    (rx2274_cur, rx2274_pos, rx2274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2274_cur
    .local pmc match
    .lex "$/", match
    length rx2274_eos, rx2274_tgt
    gt rx2274_pos, rx2274_eos, rx2274_done
    set rx2274_off, 0
    lt rx2274_pos, 2, rx2274_start
    sub rx2274_off, rx2274_pos, 1
    substr rx2274_tgt, rx2274_tgt, rx2274_off
  rx2274_start:
    eq $I10, 1, rx2274_restart
    if_null rx2274_debug, debug_1635
    rx2274_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2275_done
    goto rxscan2275_scan
  rxscan2275_loop:
    (rx2274_pos) = rx2274_cur."from"()
    inc rx2274_pos
    rx2274_cur."!cursor_from"(rx2274_pos)
    ge rx2274_pos, rx2274_eos, rxscan2275_done
  rxscan2275_scan:
    set_addr $I10, rxscan2275_loop
    rx2274_cur."!mark_push"(0, rx2274_pos, $I10)
  rxscan2275_done:
.annotate 'line', 1170
  # rx subcapture "sym"
    set_addr $I10, rxcap_2276_fail
    rx2274_cur."!mark_push"(0, rx2274_pos, $I10)
  # rx literal  "||"
    add $I11, rx2274_pos, 2
    gt $I11, rx2274_eos, rx2274_fail
    sub $I11, rx2274_pos, rx2274_off
    substr $S10, rx2274_tgt, $I11, 2
    ne $S10, "||", rx2274_fail
    add rx2274_pos, 2
    set_addr $I10, rxcap_2276_fail
    ($I12, $I11) = rx2274_cur."!mark_peek"($I10)
    rx2274_cur."!cursor_pos"($I11)
    ($P10) = rx2274_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2274_pos, "")
    rx2274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2276_done
  rxcap_2276_fail:
    goto rx2274_fail
  rxcap_2276_done:
  # rx subrule "O" subtype=capture negate=
    rx2274_cur."!cursor_pos"(rx2274_pos)
    $P10 = rx2274_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2274_fail
    rx2274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2274_pos = $P10."pos"()
  # rx pass
    rx2274_cur."!cursor_pass"(rx2274_pos, "infix:sym<||>")
    if_null rx2274_debug, debug_1636
    rx2274_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2274_pos)
  debug_1636:
    .return (rx2274_cur)
  rx2274_restart:
.annotate 'line', 469
    if_null rx2274_debug, debug_1637
    rx2274_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1637:
  rx2274_fail:
    (rx2274_rep, rx2274_pos, $I10, $P10) = rx2274_cur."!mark_fail"(0)
    lt rx2274_pos, -1, rx2274_done
    eq rx2274_pos, -1, rx2274_fail
    jump $I10
  rx2274_done:
    rx2274_cur."!cursor_fail"()
    if_null rx2274_debug, debug_1638
    rx2274_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1638:
    .return (rx2274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("400_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "||")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("401_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2279_tgt
    .local int rx2279_pos
    .local int rx2279_off
    .local int rx2279_eos
    .local int rx2279_rep
    .local pmc rx2279_cur
    .local pmc rx2279_debug
    (rx2279_cur, rx2279_pos, rx2279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2279_cur
    .local pmc match
    .lex "$/", match
    length rx2279_eos, rx2279_tgt
    gt rx2279_pos, rx2279_eos, rx2279_done
    set rx2279_off, 0
    lt rx2279_pos, 2, rx2279_start
    sub rx2279_off, rx2279_pos, 1
    substr rx2279_tgt, rx2279_tgt, rx2279_off
  rx2279_start:
    eq $I10, 1, rx2279_restart
    if_null rx2279_debug, debug_1639
    rx2279_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1639:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2280_done
    goto rxscan2280_scan
  rxscan2280_loop:
    (rx2279_pos) = rx2279_cur."from"()
    inc rx2279_pos
    rx2279_cur."!cursor_from"(rx2279_pos)
    ge rx2279_pos, rx2279_eos, rxscan2280_done
  rxscan2280_scan:
    set_addr $I10, rxscan2280_loop
    rx2279_cur."!mark_push"(0, rx2279_pos, $I10)
  rxscan2280_done:
.annotate 'line', 1171
  # rx subcapture "sym"
    set_addr $I10, rxcap_2281_fail
    rx2279_cur."!mark_push"(0, rx2279_pos, $I10)
  # rx literal  "//"
    add $I11, rx2279_pos, 2
    gt $I11, rx2279_eos, rx2279_fail
    sub $I11, rx2279_pos, rx2279_off
    substr $S10, rx2279_tgt, $I11, 2
    ne $S10, "//", rx2279_fail
    add rx2279_pos, 2
    set_addr $I10, rxcap_2281_fail
    ($I12, $I11) = rx2279_cur."!mark_peek"($I10)
    rx2279_cur."!cursor_pos"($I11)
    ($P10) = rx2279_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2279_pos, "")
    rx2279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2281_done
  rxcap_2281_fail:
    goto rx2279_fail
  rxcap_2281_done:
  # rx subrule "O" subtype=capture negate=
    rx2279_cur."!cursor_pos"(rx2279_pos)
    $P10 = rx2279_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2279_fail
    rx2279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2279_pos = $P10."pos"()
  # rx pass
    rx2279_cur."!cursor_pass"(rx2279_pos, "infix:sym<//>")
    if_null rx2279_debug, debug_1640
    rx2279_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2279_pos)
  debug_1640:
    .return (rx2279_cur)
  rx2279_restart:
.annotate 'line', 469
    if_null rx2279_debug, debug_1641
    rx2279_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1641:
  rx2279_fail:
    (rx2279_rep, rx2279_pos, $I10, $P10) = rx2279_cur."!mark_fail"(0)
    lt rx2279_pos, -1, rx2279_done
    eq rx2279_pos, -1, rx2279_fail
    jump $I10
  rx2279_done:
    rx2279_cur."!cursor_fail"()
    if_null rx2279_debug, debug_1642
    rx2279_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1642:
    .return (rx2279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("402_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "//")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("403_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2284_tgt
    .local int rx2284_pos
    .local int rx2284_off
    .local int rx2284_eos
    .local int rx2284_rep
    .local pmc rx2284_cur
    .local pmc rx2284_debug
    (rx2284_cur, rx2284_pos, rx2284_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2284_cur
    .local pmc match
    .lex "$/", match
    length rx2284_eos, rx2284_tgt
    gt rx2284_pos, rx2284_eos, rx2284_done
    set rx2284_off, 0
    lt rx2284_pos, 2, rx2284_start
    sub rx2284_off, rx2284_pos, 1
    substr rx2284_tgt, rx2284_tgt, rx2284_off
  rx2284_start:
    eq $I10, 1, rx2284_restart
    if_null rx2284_debug, debug_1643
    rx2284_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2285_done
    goto rxscan2285_scan
  rxscan2285_loop:
    (rx2284_pos) = rx2284_cur."from"()
    inc rx2284_pos
    rx2284_cur."!cursor_from"(rx2284_pos)
    ge rx2284_pos, rx2284_eos, rxscan2285_done
  rxscan2285_scan:
    set_addr $I10, rxscan2285_loop
    rx2284_cur."!mark_push"(0, rx2284_pos, $I10)
  rxscan2285_done:
.annotate 'line', 1174
  # rx literal  "??"
    add $I11, rx2284_pos, 2
    gt $I11, rx2284_eos, rx2284_fail
    sub $I11, rx2284_pos, rx2284_off
    substr $S10, rx2284_tgt, $I11, 2
    ne $S10, "??", rx2284_fail
    add rx2284_pos, 2
.annotate 'line', 1175
  # rx subrule "ws" subtype=method negate=
    rx2284_cur."!cursor_pos"(rx2284_pos)
    $P10 = rx2284_cur."ws"()
    unless $P10, rx2284_fail
    rx2284_pos = $P10."pos"()
.annotate 'line', 1176
  # rx subrule "EXPR" subtype=capture negate=
    rx2284_cur."!cursor_pos"(rx2284_pos)
    $P10 = rx2284_cur."EXPR"("i=")
    unless $P10, rx2284_fail
    rx2284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2284_pos = $P10."pos"()
.annotate 'line', 1177
  # rx literal  "!!"
    add $I11, rx2284_pos, 2
    gt $I11, rx2284_eos, rx2284_fail
    sub $I11, rx2284_pos, rx2284_off
    substr $S10, rx2284_tgt, $I11, 2
    ne $S10, "!!", rx2284_fail
    add rx2284_pos, 2
.annotate 'line', 1178
  # rx subrule "O" subtype=capture negate=
    rx2284_cur."!cursor_pos"(rx2284_pos)
    $P10 = rx2284_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2284_fail
    rx2284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2284_pos = $P10."pos"()
.annotate 'line', 1173
  # rx pass
    rx2284_cur."!cursor_pass"(rx2284_pos, "infix:sym<?? !!>")
    if_null rx2284_debug, debug_1644
    rx2284_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2284_pos)
  debug_1644:
    .return (rx2284_cur)
  rx2284_restart:
.annotate 'line', 469
    if_null rx2284_debug, debug_1645
    rx2284_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1645:
  rx2284_fail:
    (rx2284_rep, rx2284_pos, $I10, $P10) = rx2284_cur."!mark_fail"(0)
    lt rx2284_pos, -1, rx2284_done
    eq rx2284_pos, -1, rx2284_fail
    jump $I10
  rx2284_done:
    rx2284_cur."!cursor_fail"()
    if_null rx2284_debug, debug_1646
    rx2284_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1646:
    .return (rx2284_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("404_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("ws", "??")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("405_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2288_tgt
    .local int rx2288_pos
    .local int rx2288_off
    .local int rx2288_eos
    .local int rx2288_rep
    .local pmc rx2288_cur
    .local pmc rx2288_debug
    (rx2288_cur, rx2288_pos, rx2288_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2288_cur
    .local pmc match
    .lex "$/", match
    length rx2288_eos, rx2288_tgt
    gt rx2288_pos, rx2288_eos, rx2288_done
    set rx2288_off, 0
    lt rx2288_pos, 2, rx2288_start
    sub rx2288_off, rx2288_pos, 1
    substr rx2288_tgt, rx2288_tgt, rx2288_off
  rx2288_start:
    eq $I10, 1, rx2288_restart
    if_null rx2288_debug, debug_1647
    rx2288_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2289_done
    goto rxscan2289_scan
  rxscan2289_loop:
    (rx2288_pos) = rx2288_cur."from"()
    inc rx2288_pos
    rx2288_cur."!cursor_from"(rx2288_pos)
    ge rx2288_pos, rx2288_eos, rxscan2289_done
  rxscan2289_scan:
    set_addr $I10, rxscan2289_loop
    rx2288_cur."!mark_push"(0, rx2288_pos, $I10)
  rxscan2289_done:
.annotate 'line', 1182
  # rx subcapture "sym"
    set_addr $I10, rxcap_2290_fail
    rx2288_cur."!mark_push"(0, rx2288_pos, $I10)
  # rx literal  "="
    add $I11, rx2288_pos, 1
    gt $I11, rx2288_eos, rx2288_fail
    sub $I11, rx2288_pos, rx2288_off
    ord $I11, rx2288_tgt, $I11
    ne $I11, 61, rx2288_fail
    add rx2288_pos, 1
    set_addr $I10, rxcap_2290_fail
    ($I12, $I11) = rx2288_cur."!mark_peek"($I10)
    rx2288_cur."!cursor_pos"($I11)
    ($P10) = rx2288_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2288_pos, "")
    rx2288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2290_done
  rxcap_2290_fail:
    goto rx2288_fail
  rxcap_2290_done:
  # rx subrule "panic" subtype=method negate=
    rx2288_cur."!cursor_pos"(rx2288_pos)
    $P10 = rx2288_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2288_fail
    rx2288_pos = $P10."pos"()
.annotate 'line', 1181
  # rx pass
    rx2288_cur."!cursor_pass"(rx2288_pos, "infix:sym<=>")
    if_null rx2288_debug, debug_1648
    rx2288_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2288_pos)
  debug_1648:
    .return (rx2288_cur)
  rx2288_restart:
.annotate 'line', 469
    if_null rx2288_debug, debug_1649
    rx2288_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1649:
  rx2288_fail:
    (rx2288_rep, rx2288_pos, $I10, $P10) = rx2288_cur."!mark_fail"(0)
    lt rx2288_pos, -1, rx2288_done
    eq rx2288_pos, -1, rx2288_fail
    jump $I10
  rx2288_done:
    rx2288_cur."!cursor_fail"()
    if_null rx2288_debug, debug_1650
    rx2288_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1650:
    .return (rx2288_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("406_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("panic", "=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("407_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2293_tgt
    .local int rx2293_pos
    .local int rx2293_off
    .local int rx2293_eos
    .local int rx2293_rep
    .local pmc rx2293_cur
    .local pmc rx2293_debug
    (rx2293_cur, rx2293_pos, rx2293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2293_cur
    .local pmc match
    .lex "$/", match
    length rx2293_eos, rx2293_tgt
    gt rx2293_pos, rx2293_eos, rx2293_done
    set rx2293_off, 0
    lt rx2293_pos, 2, rx2293_start
    sub rx2293_off, rx2293_pos, 1
    substr rx2293_tgt, rx2293_tgt, rx2293_off
  rx2293_start:
    eq $I10, 1, rx2293_restart
    if_null rx2293_debug, debug_1651
    rx2293_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1651:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2294_done
    goto rxscan2294_scan
  rxscan2294_loop:
    (rx2293_pos) = rx2293_cur."from"()
    inc rx2293_pos
    rx2293_cur."!cursor_from"(rx2293_pos)
    ge rx2293_pos, rx2293_eos, rxscan2294_done
  rxscan2294_scan:
    set_addr $I10, rxscan2294_loop
    rx2293_cur."!mark_push"(0, rx2293_pos, $I10)
  rxscan2294_done:
.annotate 'line', 1184
  # rx subcapture "sym"
    set_addr $I10, rxcap_2295_fail
    rx2293_cur."!mark_push"(0, rx2293_pos, $I10)
  # rx literal  ":="
    add $I11, rx2293_pos, 2
    gt $I11, rx2293_eos, rx2293_fail
    sub $I11, rx2293_pos, rx2293_off
    substr $S10, rx2293_tgt, $I11, 2
    ne $S10, ":=", rx2293_fail
    add rx2293_pos, 2
    set_addr $I10, rxcap_2295_fail
    ($I12, $I11) = rx2293_cur."!mark_peek"($I10)
    rx2293_cur."!cursor_pos"($I11)
    ($P10) = rx2293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2293_pos, "")
    rx2293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2295_done
  rxcap_2295_fail:
    goto rx2293_fail
  rxcap_2295_done:
  # rx subrule "O" subtype=capture negate=
    rx2293_cur."!cursor_pos"(rx2293_pos)
    $P10 = rx2293_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2293_fail
    rx2293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2293_pos = $P10."pos"()
  # rx pass
    rx2293_cur."!cursor_pass"(rx2293_pos, "infix:sym<:=>")
    if_null rx2293_debug, debug_1652
    rx2293_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2293_pos)
  debug_1652:
    .return (rx2293_cur)
  rx2293_restart:
.annotate 'line', 469
    if_null rx2293_debug, debug_1653
    rx2293_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1653:
  rx2293_fail:
    (rx2293_rep, rx2293_pos, $I10, $P10) = rx2293_cur."!mark_fail"(0)
    lt rx2293_pos, -1, rx2293_done
    eq rx2293_pos, -1, rx2293_fail
    jump $I10
  rx2293_done:
    rx2293_cur."!cursor_fail"()
    if_null rx2293_debug, debug_1654
    rx2293_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1654:
    .return (rx2293_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("408_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", ":=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("409_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2298_tgt
    .local int rx2298_pos
    .local int rx2298_off
    .local int rx2298_eos
    .local int rx2298_rep
    .local pmc rx2298_cur
    .local pmc rx2298_debug
    (rx2298_cur, rx2298_pos, rx2298_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2298_cur
    .local pmc match
    .lex "$/", match
    length rx2298_eos, rx2298_tgt
    gt rx2298_pos, rx2298_eos, rx2298_done
    set rx2298_off, 0
    lt rx2298_pos, 2, rx2298_start
    sub rx2298_off, rx2298_pos, 1
    substr rx2298_tgt, rx2298_tgt, rx2298_off
  rx2298_start:
    eq $I10, 1, rx2298_restart
    if_null rx2298_debug, debug_1655
    rx2298_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1655:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2299_done
    goto rxscan2299_scan
  rxscan2299_loop:
    (rx2298_pos) = rx2298_cur."from"()
    inc rx2298_pos
    rx2298_cur."!cursor_from"(rx2298_pos)
    ge rx2298_pos, rx2298_eos, rxscan2299_done
  rxscan2299_scan:
    set_addr $I10, rxscan2299_loop
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  rxscan2299_done:
.annotate 'line', 1185
  # rx subcapture "sym"
    set_addr $I10, rxcap_2300_fail
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  # rx literal  "::="
    add $I11, rx2298_pos, 3
    gt $I11, rx2298_eos, rx2298_fail
    sub $I11, rx2298_pos, rx2298_off
    substr $S10, rx2298_tgt, $I11, 3
    ne $S10, "::=", rx2298_fail
    add rx2298_pos, 3
    set_addr $I10, rxcap_2300_fail
    ($I12, $I11) = rx2298_cur."!mark_peek"($I10)
    rx2298_cur."!cursor_pos"($I11)
    ($P10) = rx2298_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2298_pos, "")
    rx2298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2300_done
  rxcap_2300_fail:
    goto rx2298_fail
  rxcap_2300_done:
  # rx subrule "O" subtype=capture negate=
    rx2298_cur."!cursor_pos"(rx2298_pos)
    $P10 = rx2298_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2298_fail
    rx2298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2298_pos = $P10."pos"()
  # rx pass
    rx2298_cur."!cursor_pass"(rx2298_pos, "infix:sym<::=>")
    if_null rx2298_debug, debug_1656
    rx2298_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2298_pos)
  debug_1656:
    .return (rx2298_cur)
  rx2298_restart:
.annotate 'line', 469
    if_null rx2298_debug, debug_1657
    rx2298_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1657:
  rx2298_fail:
    (rx2298_rep, rx2298_pos, $I10, $P10) = rx2298_cur."!mark_fail"(0)
    lt rx2298_pos, -1, rx2298_done
    eq rx2298_pos, -1, rx2298_fail
    jump $I10
  rx2298_done:
    rx2298_cur."!cursor_fail"()
    if_null rx2298_debug, debug_1658
    rx2298_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1658:
    .return (rx2298_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("410_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", "::=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("411_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2303_tgt
    .local int rx2303_pos
    .local int rx2303_off
    .local int rx2303_eos
    .local int rx2303_rep
    .local pmc rx2303_cur
    .local pmc rx2303_debug
    (rx2303_cur, rx2303_pos, rx2303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2303_cur
    .local pmc match
    .lex "$/", match
    length rx2303_eos, rx2303_tgt
    gt rx2303_pos, rx2303_eos, rx2303_done
    set rx2303_off, 0
    lt rx2303_pos, 2, rx2303_start
    sub rx2303_off, rx2303_pos, 1
    substr rx2303_tgt, rx2303_tgt, rx2303_off
  rx2303_start:
    eq $I10, 1, rx2303_restart
    if_null rx2303_debug, debug_1659
    rx2303_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1659:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2304_done
    goto rxscan2304_scan
  rxscan2304_loop:
    (rx2303_pos) = rx2303_cur."from"()
    inc rx2303_pos
    rx2303_cur."!cursor_from"(rx2303_pos)
    ge rx2303_pos, rx2303_eos, rxscan2304_done
  rxscan2304_scan:
    set_addr $I10, rxscan2304_loop
    rx2303_cur."!mark_push"(0, rx2303_pos, $I10)
  rxscan2304_done:
.annotate 'line', 1187
  # rx subcapture "sym"
    set_addr $I10, rxcap_2305_fail
    rx2303_cur."!mark_push"(0, rx2303_pos, $I10)
  # rx literal  ","
    add $I11, rx2303_pos, 1
    gt $I11, rx2303_eos, rx2303_fail
    sub $I11, rx2303_pos, rx2303_off
    ord $I11, rx2303_tgt, $I11
    ne $I11, 44, rx2303_fail
    add rx2303_pos, 1
    set_addr $I10, rxcap_2305_fail
    ($I12, $I11) = rx2303_cur."!mark_peek"($I10)
    rx2303_cur."!cursor_pos"($I11)
    ($P10) = rx2303_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2303_pos, "")
    rx2303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2305_done
  rxcap_2305_fail:
    goto rx2303_fail
  rxcap_2305_done:
  # rx subrule "O" subtype=capture negate=
    rx2303_cur."!cursor_pos"(rx2303_pos)
    $P10 = rx2303_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2303_fail
    rx2303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2303_pos = $P10."pos"()
  # rx pass
    rx2303_cur."!cursor_pass"(rx2303_pos, "infix:sym<,>")
    if_null rx2303_debug, debug_1660
    rx2303_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2303_pos)
  debug_1660:
    .return (rx2303_cur)
  rx2303_restart:
.annotate 'line', 469
    if_null rx2303_debug, debug_1661
    rx2303_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1661:
  rx2303_fail:
    (rx2303_rep, rx2303_pos, $I10, $P10) = rx2303_cur."!mark_fail"(0)
    lt rx2303_pos, -1, rx2303_done
    eq rx2303_pos, -1, rx2303_fail
    jump $I10
  rx2303_done:
    rx2303_cur."!cursor_fail"()
    if_null rx2303_debug, debug_1662
    rx2303_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1662:
    .return (rx2303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("412_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    $P103 = self."!PREFIX__!subrule"("O", ",")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("413_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .const 'Sub' $P2312 = "414_1321350766.1143" 
    capture_lex $P2312
    .local string rx2308_tgt
    .local int rx2308_pos
    .local int rx2308_off
    .local int rx2308_eos
    .local int rx2308_rep
    .local pmc rx2308_cur
    .local pmc rx2308_debug
    (rx2308_cur, rx2308_pos, rx2308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2308_cur
    .local pmc match
    .lex "$/", match
    length rx2308_eos, rx2308_tgt
    gt rx2308_pos, rx2308_eos, rx2308_done
    set rx2308_off, 0
    lt rx2308_pos, 2, rx2308_start
    sub rx2308_off, rx2308_pos, 1
    substr rx2308_tgt, rx2308_tgt, rx2308_off
  rx2308_start:
    eq $I10, 1, rx2308_restart
    if_null rx2308_debug, debug_1663
    rx2308_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2309_done
    goto rxscan2309_scan
  rxscan2309_loop:
    (rx2308_pos) = rx2308_cur."from"()
    inc rx2308_pos
    rx2308_cur."!cursor_from"(rx2308_pos)
    ge rx2308_pos, rx2308_eos, rxscan2309_done
  rxscan2309_scan:
    set_addr $I10, rxscan2309_loop
    rx2308_cur."!mark_push"(0, rx2308_pos, $I10)
  rxscan2309_done:
.annotate 'line', 1189
  # rx subcapture "sym"
    set_addr $I10, rxcap_2310_fail
    rx2308_cur."!mark_push"(0, rx2308_pos, $I10)
  # rx literal  "return"
    add $I11, rx2308_pos, 6
    gt $I11, rx2308_eos, rx2308_fail
    sub $I11, rx2308_pos, rx2308_off
    substr $S10, rx2308_tgt, $I11, 6
    ne $S10, "return", rx2308_fail
    add rx2308_pos, 6
    set_addr $I10, rxcap_2310_fail
    ($I12, $I11) = rx2308_cur."!mark_peek"($I10)
    rx2308_cur."!cursor_pos"($I11)
    ($P10) = rx2308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2308_pos, "")
    rx2308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2310_done
  rxcap_2310_fail:
    goto rx2308_fail
  rxcap_2310_done:
  # rx charclass s
    ge rx2308_pos, rx2308_eos, rx2308_fail
    sub $I10, rx2308_pos, rx2308_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2308_tgt, $I10
    unless $I11, rx2308_fail
    inc rx2308_pos
  # rx subrule "O" subtype=capture negate=
    rx2308_cur."!cursor_pos"(rx2308_pos)
    $P10 = rx2308_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2308_fail
    rx2308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2308_pos = $P10."pos"()
    rx2308_cur."!cursor_pos"(rx2308_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P2312 = "414_1321350766.1143" 
    capture_lex $P2312
    $P106 = $P2312()
  # rx pass
    rx2308_cur."!cursor_pass"(rx2308_pos, "prefix:sym<return>")
    if_null rx2308_debug, debug_1664
    rx2308_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2308_pos)
  debug_1664:
    .return (rx2308_cur)
  rx2308_restart:
.annotate 'line', 469
    if_null rx2308_debug, debug_1665
    rx2308_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1665:
  rx2308_fail:
    (rx2308_rep, rx2308_pos, $I10, $P10) = rx2308_cur."!mark_fail"(0)
    lt rx2308_pos, -1, rx2308_done
    eq rx2308_pos, -1, rx2308_fail
    jump $I10
  rx2308_done:
    rx2308_cur."!cursor_fail"()
    if_null rx2308_debug, debug_1666
    rx2308_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1666:
    .return (rx2308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2311"  :anon :subid("414_1321350766.1143") :outer("413_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1189
    new $P105, "Float"
    assign $P105, 1
    store_dynamic_lex "$*RETURN_USED", $P105
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("415_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P107, "ResizablePMCArray"
    push $P107, "return"
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("416_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2315_tgt
    .local int rx2315_pos
    .local int rx2315_off
    .local int rx2315_eos
    .local int rx2315_rep
    .local pmc rx2315_cur
    .local pmc rx2315_debug
    (rx2315_cur, rx2315_pos, rx2315_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2315_cur
    .local pmc match
    .lex "$/", match
    length rx2315_eos, rx2315_tgt
    gt rx2315_pos, rx2315_eos, rx2315_done
    set rx2315_off, 0
    lt rx2315_pos, 2, rx2315_start
    sub rx2315_off, rx2315_pos, 1
    substr rx2315_tgt, rx2315_tgt, rx2315_off
  rx2315_start:
    eq $I10, 1, rx2315_restart
    if_null rx2315_debug, debug_1667
    rx2315_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2316_done
    goto rxscan2316_scan
  rxscan2316_loop:
    (rx2315_pos) = rx2315_cur."from"()
    inc rx2315_pos
    rx2315_cur."!cursor_from"(rx2315_pos)
    ge rx2315_pos, rx2315_eos, rxscan2316_done
  rxscan2316_scan:
    set_addr $I10, rxscan2316_loop
    rx2315_cur."!mark_push"(0, rx2315_pos, $I10)
  rxscan2316_done:
.annotate 'line', 1190
  # rx subcapture "sym"
    set_addr $I10, rxcap_2317_fail
    rx2315_cur."!mark_push"(0, rx2315_pos, $I10)
  # rx literal  "make"
    add $I11, rx2315_pos, 4
    gt $I11, rx2315_eos, rx2315_fail
    sub $I11, rx2315_pos, rx2315_off
    substr $S10, rx2315_tgt, $I11, 4
    ne $S10, "make", rx2315_fail
    add rx2315_pos, 4
    set_addr $I10, rxcap_2317_fail
    ($I12, $I11) = rx2315_cur."!mark_peek"($I10)
    rx2315_cur."!cursor_pos"($I11)
    ($P10) = rx2315_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2315_pos, "")
    rx2315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2317_done
  rxcap_2317_fail:
    goto rx2315_fail
  rxcap_2317_done:
  # rx charclass s
    ge rx2315_pos, rx2315_eos, rx2315_fail
    sub $I10, rx2315_pos, rx2315_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2315_tgt, $I10
    unless $I11, rx2315_fail
    inc rx2315_pos
  # rx subrule "O" subtype=capture negate=
    rx2315_cur."!cursor_pos"(rx2315_pos)
    $P10 = rx2315_cur."O"("%list_prefix")
    unless $P10, rx2315_fail
    rx2315_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2315_pos = $P10."pos"()
  # rx pass
    rx2315_cur."!cursor_pass"(rx2315_pos, "prefix:sym<make>")
    if_null rx2315_debug, debug_1668
    rx2315_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2315_pos)
  debug_1668:
    .return (rx2315_cur)
  rx2315_restart:
.annotate 'line', 469
    if_null rx2315_debug, debug_1669
    rx2315_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1669:
  rx2315_fail:
    (rx2315_rep, rx2315_pos, $I10, $P10) = rx2315_cur."!mark_fail"(0)
    lt rx2315_pos, -1, rx2315_done
    eq rx2315_pos, -1, rx2315_fail
    jump $I10
  rx2315_done:
    rx2315_cur."!cursor_fail"()
    if_null rx2315_debug, debug_1670
    rx2315_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1670:
    .return (rx2315_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("417_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "make"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("418_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2320_tgt
    .local int rx2320_pos
    .local int rx2320_off
    .local int rx2320_eos
    .local int rx2320_rep
    .local pmc rx2320_cur
    .local pmc rx2320_debug
    (rx2320_cur, rx2320_pos, rx2320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2320_cur
    .local pmc match
    .lex "$/", match
    length rx2320_eos, rx2320_tgt
    gt rx2320_pos, rx2320_eos, rx2320_done
    set rx2320_off, 0
    lt rx2320_pos, 2, rx2320_start
    sub rx2320_off, rx2320_pos, 1
    substr rx2320_tgt, rx2320_tgt, rx2320_off
  rx2320_start:
    eq $I10, 1, rx2320_restart
    if_null rx2320_debug, debug_1671
    rx2320_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1671:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2321_done
    goto rxscan2321_scan
  rxscan2321_loop:
    (rx2320_pos) = rx2320_cur."from"()
    inc rx2320_pos
    rx2320_cur."!cursor_from"(rx2320_pos)
    ge rx2320_pos, rx2320_eos, rxscan2321_done
  rxscan2321_scan:
    set_addr $I10, rxscan2321_loop
    rx2320_cur."!mark_push"(0, rx2320_pos, $I10)
  rxscan2321_done:
.annotate 'line', 1191
  # rx subcapture "sym"
    set_addr $I10, rxcap_2322_fail
    rx2320_cur."!mark_push"(0, rx2320_pos, $I10)
  # rx literal  "last"
    add $I11, rx2320_pos, 4
    gt $I11, rx2320_eos, rx2320_fail
    sub $I11, rx2320_pos, rx2320_off
    substr $S10, rx2320_tgt, $I11, 4
    ne $S10, "last", rx2320_fail
    add rx2320_pos, 4
    set_addr $I10, rxcap_2322_fail
    ($I12, $I11) = rx2320_cur."!mark_peek"($I10)
    rx2320_cur."!cursor_pos"($I11)
    ($P10) = rx2320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2320_pos, "")
    rx2320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2322_done
  rxcap_2322_fail:
    goto rx2320_fail
  rxcap_2322_done:
  # rx pass
    rx2320_cur."!cursor_pass"(rx2320_pos, "term:sym<last>")
    if_null rx2320_debug, debug_1672
    rx2320_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2320_pos)
  debug_1672:
    .return (rx2320_cur)
  rx2320_restart:
.annotate 'line', 469
    if_null rx2320_debug, debug_1673
    rx2320_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1673:
  rx2320_fail:
    (rx2320_rep, rx2320_pos, $I10, $P10) = rx2320_cur."!mark_fail"(0)
    lt rx2320_pos, -1, rx2320_done
    eq rx2320_pos, -1, rx2320_fail
    jump $I10
  rx2320_done:
    rx2320_cur."!cursor_fail"()
    if_null rx2320_debug, debug_1674
    rx2320_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1674:
    .return (rx2320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("419_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "last"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("420_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2325_tgt
    .local int rx2325_pos
    .local int rx2325_off
    .local int rx2325_eos
    .local int rx2325_rep
    .local pmc rx2325_cur
    .local pmc rx2325_debug
    (rx2325_cur, rx2325_pos, rx2325_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2325_cur
    .local pmc match
    .lex "$/", match
    length rx2325_eos, rx2325_tgt
    gt rx2325_pos, rx2325_eos, rx2325_done
    set rx2325_off, 0
    lt rx2325_pos, 2, rx2325_start
    sub rx2325_off, rx2325_pos, 1
    substr rx2325_tgt, rx2325_tgt, rx2325_off
  rx2325_start:
    eq $I10, 1, rx2325_restart
    if_null rx2325_debug, debug_1675
    rx2325_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2326_done
    goto rxscan2326_scan
  rxscan2326_loop:
    (rx2325_pos) = rx2325_cur."from"()
    inc rx2325_pos
    rx2325_cur."!cursor_from"(rx2325_pos)
    ge rx2325_pos, rx2325_eos, rxscan2326_done
  rxscan2326_scan:
    set_addr $I10, rxscan2326_loop
    rx2325_cur."!mark_push"(0, rx2325_pos, $I10)
  rxscan2326_done:
.annotate 'line', 1192
  # rx subcapture "sym"
    set_addr $I10, rxcap_2327_fail
    rx2325_cur."!mark_push"(0, rx2325_pos, $I10)
  # rx literal  "next"
    add $I11, rx2325_pos, 4
    gt $I11, rx2325_eos, rx2325_fail
    sub $I11, rx2325_pos, rx2325_off
    substr $S10, rx2325_tgt, $I11, 4
    ne $S10, "next", rx2325_fail
    add rx2325_pos, 4
    set_addr $I10, rxcap_2327_fail
    ($I12, $I11) = rx2325_cur."!mark_peek"($I10)
    rx2325_cur."!cursor_pos"($I11)
    ($P10) = rx2325_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2325_pos, "")
    rx2325_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2327_done
  rxcap_2327_fail:
    goto rx2325_fail
  rxcap_2327_done:
  # rx pass
    rx2325_cur."!cursor_pass"(rx2325_pos, "term:sym<next>")
    if_null rx2325_debug, debug_1676
    rx2325_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2325_pos)
  debug_1676:
    .return (rx2325_cur)
  rx2325_restart:
.annotate 'line', 469
    if_null rx2325_debug, debug_1677
    rx2325_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1677:
  rx2325_fail:
    (rx2325_rep, rx2325_pos, $I10, $P10) = rx2325_cur."!mark_fail"(0)
    lt rx2325_pos, -1, rx2325_done
    eq rx2325_pos, -1, rx2325_fail
    jump $I10
  rx2325_done:
    rx2325_cur."!cursor_fail"()
    if_null rx2325_debug, debug_1678
    rx2325_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1678:
    .return (rx2325_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("421_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "next"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("422_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    .local string rx2330_tgt
    .local int rx2330_pos
    .local int rx2330_off
    .local int rx2330_eos
    .local int rx2330_rep
    .local pmc rx2330_cur
    .local pmc rx2330_debug
    (rx2330_cur, rx2330_pos, rx2330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2330_cur
    .local pmc match
    .lex "$/", match
    length rx2330_eos, rx2330_tgt
    gt rx2330_pos, rx2330_eos, rx2330_done
    set rx2330_off, 0
    lt rx2330_pos, 2, rx2330_start
    sub rx2330_off, rx2330_pos, 1
    substr rx2330_tgt, rx2330_tgt, rx2330_off
  rx2330_start:
    eq $I10, 1, rx2330_restart
    if_null rx2330_debug, debug_1679
    rx2330_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2331_done
    goto rxscan2331_scan
  rxscan2331_loop:
    (rx2330_pos) = rx2330_cur."from"()
    inc rx2330_pos
    rx2330_cur."!cursor_from"(rx2330_pos)
    ge rx2330_pos, rx2330_eos, rxscan2331_done
  rxscan2331_scan:
    set_addr $I10, rxscan2331_loop
    rx2330_cur."!mark_push"(0, rx2330_pos, $I10)
  rxscan2331_done:
.annotate 'line', 1193
  # rx subcapture "sym"
    set_addr $I10, rxcap_2332_fail
    rx2330_cur."!mark_push"(0, rx2330_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2330_pos, 4
    gt $I11, rx2330_eos, rx2330_fail
    sub $I11, rx2330_pos, rx2330_off
    substr $S10, rx2330_tgt, $I11, 4
    ne $S10, "redo", rx2330_fail
    add rx2330_pos, 4
    set_addr $I10, rxcap_2332_fail
    ($I12, $I11) = rx2330_cur."!mark_peek"($I10)
    rx2330_cur."!cursor_pos"($I11)
    ($P10) = rx2330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2330_pos, "")
    rx2330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2332_done
  rxcap_2332_fail:
    goto rx2330_fail
  rxcap_2332_done:
  # rx pass
    rx2330_cur."!cursor_pass"(rx2330_pos, "term:sym<redo>")
    if_null rx2330_debug, debug_1680
    rx2330_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2330_pos)
  debug_1680:
    .return (rx2330_cur)
  rx2330_restart:
.annotate 'line', 469
    if_null rx2330_debug, debug_1681
    rx2330_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1681:
  rx2330_fail:
    (rx2330_rep, rx2330_pos, $I10, $P10) = rx2330_cur."!mark_fail"(0)
    lt rx2330_pos, -1, rx2330_done
    eq rx2330_pos, -1, rx2330_fail
    jump $I10
  rx2330_done:
    rx2330_cur."!cursor_fail"()
    if_null rx2330_debug, debug_1682
    rx2330_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1682:
    .return (rx2330_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("423_1321350766.1143") :method :outer("46_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 469
    new $P103, "ResizablePMCArray"
    push $P103, "redo"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("424_1321350766.1143") :outer("46_1321350766.1143")
    .param pmc param_2335
    .param pmc param_2336
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1195
    .lex "self", param_2335
    .lex "$/", param_2336
.annotate 'line', 1197
    new $P103, "Undef"
    set $P2337, $P103
    .lex "$t", $P2337
    new $P104, "Float"
    assign $P104, 0
    set $I100, $P104
    find_lex $P2338, "$/"
    unless_null $P2338, vivify_1683
    $P2338 = root_new ['parrot';'ResizablePMCArray']
  vivify_1683:
    set $P105, $P2338[$I100]
    unless_null $P105, vivify_1684
    new $P105, "Undef"
  vivify_1684:
    store_lex "$t", $P105
    new $P104, "Float"
    assign $P104, 1
    set $I100, $P104
    find_lex $P2339, "$/"
    unless_null $P2339, vivify_1685
    $P2339 = root_new ['parrot';'ResizablePMCArray']
  vivify_1685:
    set $P105, $P2339[$I100]
    unless_null $P105, vivify_1686
    new $P105, "Undef"
  vivify_1686:
    new $P106, "Float"
    assign $P106, 0
    set $I101, $P106
    find_lex $P2340, "$/"
    unless_null $P2340, vivify_1687
    $P2340 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2340
  vivify_1687:
    set $P2340[$I101], $P105
    find_lex $P104, "$t"
    unless_null $P104, vivify_1688
    new $P104, "Undef"
  vivify_1688:
    new $P105, "Float"
    assign $P105, 1
    set $I100, $P105
    find_lex $P2341, "$/"
    unless_null $P2341, vivify_1689
    $P2341 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2341
  vivify_1689:
    set $P2341[$I100], $P104
.annotate 'line', 1195
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2343"  :subid("425_1321350766.1143") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .const 'Sub' $P2397 = "445_1321350766.1143" 
    capture_lex $P2397
    .const 'Sub' $P2394 = "444_1321350766.1143" 
    capture_lex $P2394
    .const 'Sub' $P2393 = "443_1321350766.1143" 
    capture_lex $P2393
    .const 'Sub' $P2390 = "442_1321350766.1143" 
    capture_lex $P2390
    .const 'Sub' $P2389 = "441_1321350766.1143" 
    capture_lex $P2389
    .const 'Sub' $P2380 = "439_1321350766.1143" 
    capture_lex $P2380
    .const 'Sub' $P2379 = "438_1321350766.1143" 
    capture_lex $P2379
    .const 'Sub' $P2371 = "436_1321350766.1143" 
    capture_lex $P2371
    .const 'Sub' $P2370 = "435_1321350766.1143" 
    capture_lex $P2370
    .const 'Sub' $P2367 = "434_1321350766.1143" 
    capture_lex $P2367
    .const 'Sub' $P2366 = "433_1321350766.1143" 
    capture_lex $P2366
    .const 'Sub' $P2359 = "431_1321350766.1143" 
    capture_lex $P2359
    .const 'Sub' $P2358 = "430_1321350766.1143" 
    capture_lex $P2358
    .const 'Sub' $P2355 = "429_1321350766.1143" 
    capture_lex $P2355
    .const 'Sub' $P2354 = "428_1321350766.1143" 
    capture_lex $P2354
    .const 'Sub' $P2347 = "426_1321350766.1143" 
    capture_lex $P2347
    .lex "$?PACKAGE", $P2345
    .lex "$?CLASS", $P2346
    .const 'Sub' $P2397 = "445_1321350766.1143" 
    capture_lex $P2397
    .return ($P2397)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("426_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .const 'Sub' $P2351 = "427_1321350766.1143" 
    capture_lex $P2351
    .local string rx2348_tgt
    .local int rx2348_pos
    .local int rx2348_off
    .local int rx2348_eos
    .local int rx2348_rep
    .local pmc rx2348_cur
    .local pmc rx2348_debug
    (rx2348_cur, rx2348_pos, rx2348_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2348_cur
    .local pmc match
    .lex "$/", match
    length rx2348_eos, rx2348_tgt
    gt rx2348_pos, rx2348_eos, rx2348_done
    set rx2348_off, 0
    lt rx2348_pos, 2, rx2348_start
    sub rx2348_off, rx2348_pos, 1
    substr rx2348_tgt, rx2348_tgt, rx2348_off
  rx2348_start:
    eq $I10, 1, rx2348_restart
    if_null rx2348_debug, debug_1690
    rx2348_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2349_done
    goto rxscan2349_scan
  rxscan2349_loop:
    (rx2348_pos) = rx2348_cur."from"()
    inc rx2348_pos
    rx2348_cur."!cursor_from"(rx2348_pos)
    ge rx2348_pos, rx2348_eos, rxscan2349_done
  rxscan2349_scan:
    set_addr $I10, rxscan2349_loop
    rx2348_cur."!mark_push"(0, rx2348_pos, $I10)
  rxscan2349_done:
.annotate 'line', 1203
  # rx literal  ":"
    add $I11, rx2348_pos, 1
    gt $I11, rx2348_eos, rx2348_fail
    sub $I11, rx2348_pos, rx2348_off
    ord $I11, rx2348_tgt, $I11
    ne $I11, 58, rx2348_fail
    add rx2348_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2348_cur."!cursor_pos"(rx2348_pos)
    .const 'Sub' $P2351 = "427_1321350766.1143" 
    capture_lex $P2351
    $P10 = rx2348_cur."before"($P2351)
    unless $P10, rx2348_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2348_cur."!cursor_pos"(rx2348_pos)
    $P10 = rx2348_cur."LANG"("MAIN", "statement")
    unless $P10, rx2348_fail
    rx2348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2348_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2348_cur."!cursor_pos"(rx2348_pos)
    $P10 = rx2348_cur."ws"()
    unless $P10, rx2348_fail
    rx2348_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2348_pos, 1
    gt $I11, rx2348_eos, rx2348_fail
    sub $I11, rx2348_pos, rx2348_off
    ord $I11, rx2348_tgt, $I11
    ne $I11, 59, rx2348_fail
    add rx2348_pos, 1
.annotate 'line', 1202
  # rx pass
    rx2348_cur."!cursor_pass"(rx2348_pos, "metachar:sym<:my>")
    if_null rx2348_debug, debug_1695
    rx2348_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2348_pos)
  debug_1695:
    .return (rx2348_cur)
  rx2348_restart:
.annotate 'line', 1201
    if_null rx2348_debug, debug_1696
    rx2348_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1696:
  rx2348_fail:
    (rx2348_rep, rx2348_pos, $I10, $P10) = rx2348_cur."!mark_fail"(0)
    lt rx2348_pos, -1, rx2348_done
    eq rx2348_pos, -1, rx2348_fail
    jump $I10
  rx2348_done:
    rx2348_cur."!cursor_fail"()
    if_null rx2348_debug, debug_1697
    rx2348_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1697:
    .return (rx2348_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2350"  :anon :subid("427_1321350766.1143") :method :outer("426_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1203
    .local string rx2352_tgt
    .local int rx2352_pos
    .local int rx2352_off
    .local int rx2352_eos
    .local int rx2352_rep
    .local pmc rx2352_cur
    .local pmc rx2352_debug
    (rx2352_cur, rx2352_pos, rx2352_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2352_cur
    .local pmc match
    .lex "$/", match
    length rx2352_eos, rx2352_tgt
    gt rx2352_pos, rx2352_eos, rx2352_done
    set rx2352_off, 0
    lt rx2352_pos, 2, rx2352_start
    sub rx2352_off, rx2352_pos, 1
    substr rx2352_tgt, rx2352_tgt, rx2352_off
  rx2352_start:
    eq $I10, 1, rx2352_restart
    if_null rx2352_debug, debug_1691
    rx2352_cur."!cursor_debug"("START", "")
  debug_1691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2353_done
    goto rxscan2353_scan
  rxscan2353_loop:
    (rx2352_pos) = rx2352_cur."from"()
    inc rx2352_pos
    rx2352_cur."!cursor_from"(rx2352_pos)
    ge rx2352_pos, rx2352_eos, rxscan2353_done
  rxscan2353_scan:
    set_addr $I10, rxscan2353_loop
    rx2352_cur."!mark_push"(0, rx2352_pos, $I10)
  rxscan2353_done:
  # rx literal  "my"
    add $I11, rx2352_pos, 2
    gt $I11, rx2352_eos, rx2352_fail
    sub $I11, rx2352_pos, rx2352_off
    substr $S10, rx2352_tgt, $I11, 2
    ne $S10, "my", rx2352_fail
    add rx2352_pos, 2
  # rx pass
    rx2352_cur."!cursor_pass"(rx2352_pos, "")
    if_null rx2352_debug, debug_1692
    rx2352_cur."!cursor_debug"("PASS", "", " at pos=", rx2352_pos)
  debug_1692:
    .return (rx2352_cur)
  rx2352_restart:
    if_null rx2352_debug, debug_1693
    rx2352_cur."!cursor_debug"("NEXT", "")
  debug_1693:
  rx2352_fail:
    (rx2352_rep, rx2352_pos, $I10, $P10) = rx2352_cur."!mark_fail"(0)
    lt rx2352_pos, -1, rx2352_done
    eq rx2352_pos, -1, rx2352_fail
    jump $I10
  rx2352_done:
    rx2352_cur."!cursor_fail"()
    if_null rx2352_debug, debug_1694
    rx2352_cur."!cursor_debug"("FAIL", "")
  debug_1694:
    .return (rx2352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("428_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    new $P103, "ResizablePMCArray"
    push $P103, ":"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("429_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .local string rx2356_tgt
    .local int rx2356_pos
    .local int rx2356_off
    .local int rx2356_eos
    .local int rx2356_rep
    .local pmc rx2356_cur
    .local pmc rx2356_debug
    (rx2356_cur, rx2356_pos, rx2356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2356_cur
    .local pmc match
    .lex "$/", match
    length rx2356_eos, rx2356_tgt
    gt rx2356_pos, rx2356_eos, rx2356_done
    set rx2356_off, 0
    lt rx2356_pos, 2, rx2356_start
    sub rx2356_off, rx2356_pos, 1
    substr rx2356_tgt, rx2356_tgt, rx2356_off
  rx2356_start:
    eq $I10, 1, rx2356_restart
    if_null rx2356_debug, debug_1698
    rx2356_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2357_done
    goto rxscan2357_scan
  rxscan2357_loop:
    (rx2356_pos) = rx2356_cur."from"()
    inc rx2356_pos
    rx2356_cur."!cursor_from"(rx2356_pos)
    ge rx2356_pos, rx2356_eos, rxscan2357_done
  rxscan2357_scan:
    set_addr $I10, rxscan2357_loop
    rx2356_cur."!mark_push"(0, rx2356_pos, $I10)
  rxscan2357_done:
.annotate 'line', 1207
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2356_pos, rx2356_off
    substr $S10, rx2356_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2356_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2356_cur."!cursor_pos"(rx2356_pos)
    $P10 = rx2356_cur."codeblock"()
    unless $P10, rx2356_fail
    rx2356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2356_pos = $P10."pos"()
.annotate 'line', 1206
  # rx pass
    rx2356_cur."!cursor_pass"(rx2356_pos, "metachar:sym<{ }>")
    if_null rx2356_debug, debug_1699
    rx2356_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2356_pos)
  debug_1699:
    .return (rx2356_cur)
  rx2356_restart:
.annotate 'line', 1201
    if_null rx2356_debug, debug_1700
    rx2356_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1700:
  rx2356_fail:
    (rx2356_rep, rx2356_pos, $I10, $P10) = rx2356_cur."!mark_fail"(0)
    lt rx2356_pos, -1, rx2356_done
    eq rx2356_pos, -1, rx2356_fail
    jump $I10
  rx2356_done:
    rx2356_cur."!cursor_fail"()
    if_null rx2356_debug, debug_1701
    rx2356_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1701:
    .return (rx2356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("430_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("431_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .const 'Sub' $P2363 = "432_1321350766.1143" 
    capture_lex $P2363
    .local string rx2360_tgt
    .local int rx2360_pos
    .local int rx2360_off
    .local int rx2360_eos
    .local int rx2360_rep
    .local pmc rx2360_cur
    .local pmc rx2360_debug
    (rx2360_cur, rx2360_pos, rx2360_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2360_cur
    .local pmc match
    .lex "$/", match
    length rx2360_eos, rx2360_tgt
    gt rx2360_pos, rx2360_eos, rx2360_done
    set rx2360_off, 0
    lt rx2360_pos, 2, rx2360_start
    sub rx2360_off, rx2360_pos, 1
    substr rx2360_tgt, rx2360_tgt, rx2360_off
  rx2360_start:
    eq $I10, 1, rx2360_restart
    if_null rx2360_debug, debug_1702
    rx2360_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2361_done
    goto rxscan2361_scan
  rxscan2361_loop:
    (rx2360_pos) = rx2360_cur."from"()
    inc rx2360_pos
    rx2360_cur."!cursor_from"(rx2360_pos)
    ge rx2360_pos, rx2360_eos, rxscan2361_done
  rxscan2361_scan:
    set_addr $I10, rxscan2361_loop
    rx2360_cur."!mark_push"(0, rx2360_pos, $I10)
  rxscan2361_done:
.annotate 'line', 1211
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2360_pos, rx2360_off
    substr $S10, rx2360_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2360_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2360_cur."!cursor_pos"(rx2360_pos)
    .const 'Sub' $P2363 = "432_1321350766.1143" 
    capture_lex $P2363
    $P10 = rx2360_cur."before"($P2363)
    unless $P10, rx2360_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2360_cur."!cursor_pos"(rx2360_pos)
    $P10 = rx2360_cur."LANG"("MAIN", "variable")
    unless $P10, rx2360_fail
    rx2360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2360_pos = $P10."pos"()
.annotate 'line', 1210
  # rx pass
    rx2360_cur."!cursor_pass"(rx2360_pos, "metachar:sym<nqpvar>")
    if_null rx2360_debug, debug_1707
    rx2360_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2360_pos)
  debug_1707:
    .return (rx2360_cur)
  rx2360_restart:
.annotate 'line', 1201
    if_null rx2360_debug, debug_1708
    rx2360_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1708:
  rx2360_fail:
    (rx2360_rep, rx2360_pos, $I10, $P10) = rx2360_cur."!mark_fail"(0)
    lt rx2360_pos, -1, rx2360_done
    eq rx2360_pos, -1, rx2360_fail
    jump $I10
  rx2360_done:
    rx2360_cur."!cursor_fail"()
    if_null rx2360_debug, debug_1709
    rx2360_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1709:
    .return (rx2360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2362"  :anon :subid("432_1321350766.1143") :method :outer("431_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1211
    .local string rx2364_tgt
    .local int rx2364_pos
    .local int rx2364_off
    .local int rx2364_eos
    .local int rx2364_rep
    .local pmc rx2364_cur
    .local pmc rx2364_debug
    (rx2364_cur, rx2364_pos, rx2364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2364_cur
    .local pmc match
    .lex "$/", match
    length rx2364_eos, rx2364_tgt
    gt rx2364_pos, rx2364_eos, rx2364_done
    set rx2364_off, 0
    lt rx2364_pos, 2, rx2364_start
    sub rx2364_off, rx2364_pos, 1
    substr rx2364_tgt, rx2364_tgt, rx2364_off
  rx2364_start:
    eq $I10, 1, rx2364_restart
    if_null rx2364_debug, debug_1703
    rx2364_cur."!cursor_debug"("START", "")
  debug_1703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2365_done
    goto rxscan2365_scan
  rxscan2365_loop:
    (rx2364_pos) = rx2364_cur."from"()
    inc rx2364_pos
    rx2364_cur."!cursor_from"(rx2364_pos)
    ge rx2364_pos, rx2364_eos, rxscan2365_done
  rxscan2365_scan:
    set_addr $I10, rxscan2365_loop
    rx2364_cur."!mark_push"(0, rx2364_pos, $I10)
  rxscan2365_done:
  # rx charclass .
    ge rx2364_pos, rx2364_eos, rx2364_fail
    inc rx2364_pos
  # rx charclass w
    ge rx2364_pos, rx2364_eos, rx2364_fail
    sub $I10, rx2364_pos, rx2364_off
    is_cclass $I11, .CCLASS_WORD, rx2364_tgt, $I10
    unless $I11, rx2364_fail
    inc rx2364_pos
  # rx pass
    rx2364_cur."!cursor_pass"(rx2364_pos, "")
    if_null rx2364_debug, debug_1704
    rx2364_cur."!cursor_debug"("PASS", "", " at pos=", rx2364_pos)
  debug_1704:
    .return (rx2364_cur)
  rx2364_restart:
    if_null rx2364_debug, debug_1705
    rx2364_cur."!cursor_debug"("NEXT", "")
  debug_1705:
  rx2364_fail:
    (rx2364_rep, rx2364_pos, $I10, $P10) = rx2364_cur."!mark_fail"(0)
    lt rx2364_pos, -1, rx2364_done
    eq rx2364_pos, -1, rx2364_fail
    jump $I10
  rx2364_done:
    rx2364_cur."!cursor_fail"()
    if_null rx2364_debug, debug_1706
    rx2364_cur."!cursor_debug"("FAIL", "")
  debug_1706:
    .return (rx2364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("433_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("434_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .local string rx2368_tgt
    .local int rx2368_pos
    .local int rx2368_off
    .local int rx2368_eos
    .local int rx2368_rep
    .local pmc rx2368_cur
    .local pmc rx2368_debug
    (rx2368_cur, rx2368_pos, rx2368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2368_cur
    .local pmc match
    .lex "$/", match
    length rx2368_eos, rx2368_tgt
    gt rx2368_pos, rx2368_eos, rx2368_done
    set rx2368_off, 0
    lt rx2368_pos, 2, rx2368_start
    sub rx2368_off, rx2368_pos, 1
    substr rx2368_tgt, rx2368_tgt, rx2368_off
  rx2368_start:
    eq $I10, 1, rx2368_restart
    if_null rx2368_debug, debug_1710
    rx2368_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2369_done
    goto rxscan2369_scan
  rxscan2369_loop:
    (rx2368_pos) = rx2368_cur."from"()
    inc rx2368_pos
    rx2368_cur."!cursor_from"(rx2368_pos)
    ge rx2368_pos, rx2368_eos, rxscan2369_done
  rxscan2369_scan:
    set_addr $I10, rxscan2369_loop
    rx2368_cur."!mark_push"(0, rx2368_pos, $I10)
  rxscan2369_done:
.annotate 'line', 1215
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2368_pos, rx2368_off
    substr $S10, rx2368_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2368_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2368_cur."!cursor_pos"(rx2368_pos)
    $P10 = rx2368_cur."codeblock"()
    unless $P10, rx2368_fail
    rx2368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2368_pos = $P10."pos"()
.annotate 'line', 1214
  # rx pass
    rx2368_cur."!cursor_pass"(rx2368_pos, "assertion:sym<{ }>")
    if_null rx2368_debug, debug_1711
    rx2368_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2368_pos)
  debug_1711:
    .return (rx2368_cur)
  rx2368_restart:
.annotate 'line', 1201
    if_null rx2368_debug, debug_1712
    rx2368_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1712:
  rx2368_fail:
    (rx2368_rep, rx2368_pos, $I10, $P10) = rx2368_cur."!mark_fail"(0)
    lt rx2368_pos, -1, rx2368_done
    eq rx2368_pos, -1, rx2368_fail
    jump $I10
  rx2368_done:
    rx2368_cur."!cursor_fail"()
    if_null rx2368_debug, debug_1713
    rx2368_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1713:
    .return (rx2368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("435_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("436_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .const 'Sub' $P2375 = "437_1321350766.1143" 
    capture_lex $P2375
    .local string rx2372_tgt
    .local int rx2372_pos
    .local int rx2372_off
    .local int rx2372_eos
    .local int rx2372_rep
    .local pmc rx2372_cur
    .local pmc rx2372_debug
    (rx2372_cur, rx2372_pos, rx2372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2372_cur
    .local pmc match
    .lex "$/", match
    length rx2372_eos, rx2372_tgt
    gt rx2372_pos, rx2372_eos, rx2372_done
    set rx2372_off, 0
    lt rx2372_pos, 2, rx2372_start
    sub rx2372_off, rx2372_pos, 1
    substr rx2372_tgt, rx2372_tgt, rx2372_off
  rx2372_start:
    eq $I10, 1, rx2372_restart
    if_null rx2372_debug, debug_1714
    rx2372_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2373_done
    goto rxscan2373_scan
  rxscan2373_loop:
    (rx2372_pos) = rx2372_cur."from"()
    inc rx2372_pos
    rx2372_cur."!cursor_from"(rx2372_pos)
    ge rx2372_pos, rx2372_eos, rxscan2373_done
  rxscan2373_scan:
    set_addr $I10, rxscan2373_loop
    rx2372_cur."!mark_push"(0, rx2372_pos, $I10)
  rxscan2373_done:
.annotate 'line', 1219
  # rx subcapture "zw"
    set_addr $I10, rxcap_2378_fail
    rx2372_cur."!mark_push"(0, rx2372_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2372_pos, rx2372_eos, rx2372_fail
    sub $I10, rx2372_pos, rx2372_off
    substr $S10, rx2372_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2372_fail
    inc rx2372_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2372_cur."!cursor_pos"(rx2372_pos)
    .const 'Sub' $P2375 = "437_1321350766.1143" 
    capture_lex $P2375
    $P10 = rx2372_cur."before"($P2375)
    unless $P10, rx2372_fail
    set_addr $I10, rxcap_2378_fail
    ($I12, $I11) = rx2372_cur."!mark_peek"($I10)
    rx2372_cur."!cursor_pos"($I11)
    ($P10) = rx2372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2372_pos, "")
    rx2372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2378_done
  rxcap_2378_fail:
    goto rx2372_fail
  rxcap_2378_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2372_cur."!cursor_pos"(rx2372_pos)
    $P10 = rx2372_cur."codeblock"()
    unless $P10, rx2372_fail
    rx2372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2372_pos = $P10."pos"()
.annotate 'line', 1218
  # rx pass
    rx2372_cur."!cursor_pass"(rx2372_pos, "assertion:sym<?{ }>")
    if_null rx2372_debug, debug_1719
    rx2372_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2372_pos)
  debug_1719:
    .return (rx2372_cur)
  rx2372_restart:
.annotate 'line', 1201
    if_null rx2372_debug, debug_1720
    rx2372_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1720:
  rx2372_fail:
    (rx2372_rep, rx2372_pos, $I10, $P10) = rx2372_cur."!mark_fail"(0)
    lt rx2372_pos, -1, rx2372_done
    eq rx2372_pos, -1, rx2372_fail
    jump $I10
  rx2372_done:
    rx2372_cur."!cursor_fail"()
    if_null rx2372_debug, debug_1721
    rx2372_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1721:
    .return (rx2372_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2374"  :anon :subid("437_1321350766.1143") :method :outer("436_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1219
    .local string rx2376_tgt
    .local int rx2376_pos
    .local int rx2376_off
    .local int rx2376_eos
    .local int rx2376_rep
    .local pmc rx2376_cur
    .local pmc rx2376_debug
    (rx2376_cur, rx2376_pos, rx2376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2376_cur
    .local pmc match
    .lex "$/", match
    length rx2376_eos, rx2376_tgt
    gt rx2376_pos, rx2376_eos, rx2376_done
    set rx2376_off, 0
    lt rx2376_pos, 2, rx2376_start
    sub rx2376_off, rx2376_pos, 1
    substr rx2376_tgt, rx2376_tgt, rx2376_off
  rx2376_start:
    eq $I10, 1, rx2376_restart
    if_null rx2376_debug, debug_1715
    rx2376_cur."!cursor_debug"("START", "")
  debug_1715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2377_done
    goto rxscan2377_scan
  rxscan2377_loop:
    (rx2376_pos) = rx2376_cur."from"()
    inc rx2376_pos
    rx2376_cur."!cursor_from"(rx2376_pos)
    ge rx2376_pos, rx2376_eos, rxscan2377_done
  rxscan2377_scan:
    set_addr $I10, rxscan2377_loop
    rx2376_cur."!mark_push"(0, rx2376_pos, $I10)
  rxscan2377_done:
  # rx literal  "{"
    add $I11, rx2376_pos, 1
    gt $I11, rx2376_eos, rx2376_fail
    sub $I11, rx2376_pos, rx2376_off
    ord $I11, rx2376_tgt, $I11
    ne $I11, 123, rx2376_fail
    add rx2376_pos, 1
  # rx pass
    rx2376_cur."!cursor_pass"(rx2376_pos, "")
    if_null rx2376_debug, debug_1716
    rx2376_cur."!cursor_debug"("PASS", "", " at pos=", rx2376_pos)
  debug_1716:
    .return (rx2376_cur)
  rx2376_restart:
    if_null rx2376_debug, debug_1717
    rx2376_cur."!cursor_debug"("NEXT", "")
  debug_1717:
  rx2376_fail:
    (rx2376_rep, rx2376_pos, $I10, $P10) = rx2376_cur."!mark_fail"(0)
    lt rx2376_pos, -1, rx2376_done
    eq rx2376_pos, -1, rx2376_fail
    jump $I10
  rx2376_done:
    rx2376_cur."!cursor_fail"()
    if_null rx2376_debug, debug_1718
    rx2376_cur."!cursor_debug"("FAIL", "")
  debug_1718:
    .return (rx2376_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("438_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    new $P103, "ResizablePMCArray"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("439_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .const 'Sub' $P2386 = "440_1321350766.1143" 
    capture_lex $P2386
    .local string rx2381_tgt
    .local int rx2381_pos
    .local int rx2381_off
    .local int rx2381_eos
    .local int rx2381_rep
    .local pmc rx2381_cur
    .local pmc rx2381_debug
    (rx2381_cur, rx2381_pos, rx2381_tgt, $I10) = self."!cursor_start"()
    rx2381_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2381_cur
    .local pmc match
    .lex "$/", match
    length rx2381_eos, rx2381_tgt
    gt rx2381_pos, rx2381_eos, rx2381_done
    set rx2381_off, 0
    lt rx2381_pos, 2, rx2381_start
    sub rx2381_off, rx2381_pos, 1
    substr rx2381_tgt, rx2381_tgt, rx2381_off
  rx2381_start:
    eq $I10, 1, rx2381_restart
    if_null rx2381_debug, debug_1722
    rx2381_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2382_done
    goto rxscan2382_scan
  rxscan2382_loop:
    (rx2381_pos) = rx2381_cur."from"()
    inc rx2381_pos
    rx2381_cur."!cursor_from"(rx2381_pos)
    ge rx2381_pos, rx2381_eos, rxscan2382_done
  rxscan2382_scan:
    set_addr $I10, rxscan2382_loop
    rx2381_cur."!mark_push"(0, rx2381_pos, $I10)
  rxscan2382_done:
.annotate 'line', 1223
  # rx subrule "identifier" subtype=capture negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    $P10 = rx2381_cur."identifier"()
    unless $P10, rx2381_fail
    rx2381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2381_pos = $P10."pos"()
.annotate 'line', 1230
  # rx rxquantr2383 ** 0..1
    set_addr $I10, rxquantr2383_done
    rx2381_cur."!mark_push"(0, rx2381_pos, $I10)
  rxquantr2383_loop:
  alt2384_0:
.annotate 'line', 1224
    set_addr $I10, alt2384_1
    rx2381_cur."!mark_push"(0, rx2381_pos, $I10)
.annotate 'line', 1225
  # rx subrule "before" subtype=zerowidth negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    .const 'Sub' $P2386 = "440_1321350766.1143" 
    capture_lex $P2386
    $P10 = rx2381_cur."before"($P2386)
    unless $P10, rx2381_fail
    goto alt2384_end
  alt2384_1:
    set_addr $I10, alt2384_2
    rx2381_cur."!mark_push"(0, rx2381_pos, $I10)
.annotate 'line', 1226
  # rx literal  "="
    add $I11, rx2381_pos, 1
    gt $I11, rx2381_eos, rx2381_fail
    sub $I11, rx2381_pos, rx2381_off
    ord $I11, rx2381_tgt, $I11
    ne $I11, 61, rx2381_fail
    add rx2381_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    $P10 = rx2381_cur."assertion"()
    unless $P10, rx2381_fail
    rx2381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2381_pos = $P10."pos"()
    goto alt2384_end
  alt2384_2:
    set_addr $I10, alt2384_3
    rx2381_cur."!mark_push"(0, rx2381_pos, $I10)
.annotate 'line', 1227
  # rx literal  ":"
    add $I11, rx2381_pos, 1
    gt $I11, rx2381_eos, rx2381_fail
    sub $I11, rx2381_pos, rx2381_off
    ord $I11, rx2381_tgt, $I11
    ne $I11, 58, rx2381_fail
    add rx2381_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    $P10 = rx2381_cur."arglist"()
    unless $P10, rx2381_fail
    rx2381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2381_pos = $P10."pos"()
    goto alt2384_end
  alt2384_3:
    set_addr $I10, alt2384_4
    rx2381_cur."!mark_push"(0, rx2381_pos, $I10)
.annotate 'line', 1228
  # rx literal  "("
    add $I11, rx2381_pos, 1
    gt $I11, rx2381_eos, rx2381_fail
    sub $I11, rx2381_pos, rx2381_off
    ord $I11, rx2381_tgt, $I11
    ne $I11, 40, rx2381_fail
    add rx2381_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    $P10 = rx2381_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2381_fail
    rx2381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2381_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2381_pos, 1
    gt $I11, rx2381_eos, rx2381_fail
    sub $I11, rx2381_pos, rx2381_off
    ord $I11, rx2381_tgt, $I11
    ne $I11, 41, rx2381_fail
    add rx2381_pos, 1
    goto alt2384_end
  alt2384_4:
.annotate 'line', 1229
  # rx subrule "normspace" subtype=method negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    $P10 = rx2381_cur."normspace"()
    unless $P10, rx2381_fail
    rx2381_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2381_cur."!cursor_pos"(rx2381_pos)
    $P10 = rx2381_cur."nibbler"()
    unless $P10, rx2381_fail
    rx2381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2381_pos = $P10."pos"()
  alt2384_end:
.annotate 'line', 1230
    set_addr $I10, rxquantr2383_done
    (rx2381_rep) = rx2381_cur."!mark_commit"($I10)
  rxquantr2383_done:
.annotate 'line', 1222
  # rx pass
    rx2381_cur."!cursor_pass"(rx2381_pos, "assertion:sym<name>")
    if_null rx2381_debug, debug_1727
    rx2381_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2381_pos)
  debug_1727:
    .return (rx2381_cur)
  rx2381_restart:
.annotate 'line', 1201
    if_null rx2381_debug, debug_1728
    rx2381_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1728:
  rx2381_fail:
    (rx2381_rep, rx2381_pos, $I10, $P10) = rx2381_cur."!mark_fail"(0)
    lt rx2381_pos, -1, rx2381_done
    eq rx2381_pos, -1, rx2381_fail
    jump $I10
  rx2381_done:
    rx2381_cur."!cursor_fail"()
    if_null rx2381_debug, debug_1729
    rx2381_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1729:
    .return (rx2381_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2385"  :anon :subid("440_1321350766.1143") :method :outer("439_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1225
    .local string rx2387_tgt
    .local int rx2387_pos
    .local int rx2387_off
    .local int rx2387_eos
    .local int rx2387_rep
    .local pmc rx2387_cur
    .local pmc rx2387_debug
    (rx2387_cur, rx2387_pos, rx2387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2387_cur
    .local pmc match
    .lex "$/", match
    length rx2387_eos, rx2387_tgt
    gt rx2387_pos, rx2387_eos, rx2387_done
    set rx2387_off, 0
    lt rx2387_pos, 2, rx2387_start
    sub rx2387_off, rx2387_pos, 1
    substr rx2387_tgt, rx2387_tgt, rx2387_off
  rx2387_start:
    eq $I10, 1, rx2387_restart
    if_null rx2387_debug, debug_1723
    rx2387_cur."!cursor_debug"("START", "")
  debug_1723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2388_done
    goto rxscan2388_scan
  rxscan2388_loop:
    (rx2387_pos) = rx2387_cur."from"()
    inc rx2387_pos
    rx2387_cur."!cursor_from"(rx2387_pos)
    ge rx2387_pos, rx2387_eos, rxscan2388_done
  rxscan2388_scan:
    set_addr $I10, rxscan2388_loop
    rx2387_cur."!mark_push"(0, rx2387_pos, $I10)
  rxscan2388_done:
  # rx literal  ">"
    add $I11, rx2387_pos, 1
    gt $I11, rx2387_eos, rx2387_fail
    sub $I11, rx2387_pos, rx2387_off
    ord $I11, rx2387_tgt, $I11
    ne $I11, 62, rx2387_fail
    add rx2387_pos, 1
  # rx pass
    rx2387_cur."!cursor_pass"(rx2387_pos, "")
    if_null rx2387_debug, debug_1724
    rx2387_cur."!cursor_debug"("PASS", "", " at pos=", rx2387_pos)
  debug_1724:
    .return (rx2387_cur)
  rx2387_restart:
    if_null rx2387_debug, debug_1725
    rx2387_cur."!cursor_debug"("NEXT", "")
  debug_1725:
  rx2387_fail:
    (rx2387_rep, rx2387_pos, $I10, $P10) = rx2387_cur."!mark_fail"(0)
    lt rx2387_pos, -1, rx2387_done
    eq rx2387_pos, -1, rx2387_fail
    jump $I10
  rx2387_done:
    rx2387_cur."!cursor_fail"()
    if_null rx2387_debug, debug_1726
    rx2387_cur."!cursor_debug"("FAIL", "")
  debug_1726:
    .return (rx2387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("441_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("442_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .local string rx2391_tgt
    .local int rx2391_pos
    .local int rx2391_off
    .local int rx2391_eos
    .local int rx2391_rep
    .local pmc rx2391_cur
    .local pmc rx2391_debug
    (rx2391_cur, rx2391_pos, rx2391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2391_cur
    .local pmc match
    .lex "$/", match
    length rx2391_eos, rx2391_tgt
    gt rx2391_pos, rx2391_eos, rx2391_done
    set rx2391_off, 0
    lt rx2391_pos, 2, rx2391_start
    sub rx2391_off, rx2391_pos, 1
    substr rx2391_tgt, rx2391_tgt, rx2391_off
  rx2391_start:
    eq $I10, 1, rx2391_restart
    if_null rx2391_debug, debug_1730
    rx2391_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2392_done
    goto rxscan2392_scan
  rxscan2392_loop:
    (rx2391_pos) = rx2391_cur."from"()
    inc rx2391_pos
    rx2391_cur."!cursor_from"(rx2391_pos)
    ge rx2391_pos, rx2391_eos, rxscan2392_done
  rxscan2392_scan:
    set_addr $I10, rxscan2392_loop
    rx2391_cur."!mark_push"(0, rx2391_pos, $I10)
  rxscan2392_done:
.annotate 'line', 1234
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2391_pos, rx2391_off
    substr $S10, rx2391_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2391_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2391_cur."!cursor_pos"(rx2391_pos)
    $P10 = rx2391_cur."LANG"("MAIN", "variable")
    unless $P10, rx2391_fail
    rx2391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2391_pos = $P10."pos"()
.annotate 'line', 1233
  # rx pass
    rx2391_cur."!cursor_pass"(rx2391_pos, "assertion:sym<var>")
    if_null rx2391_debug, debug_1731
    rx2391_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2391_pos)
  debug_1731:
    .return (rx2391_cur)
  rx2391_restart:
.annotate 'line', 1201
    if_null rx2391_debug, debug_1732
    rx2391_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1732:
  rx2391_fail:
    (rx2391_rep, rx2391_pos, $I10, $P10) = rx2391_cur."!mark_fail"(0)
    lt rx2391_pos, -1, rx2391_done
    eq rx2391_pos, -1, rx2391_fail
    jump $I10
  rx2391_done:
    rx2391_cur."!cursor_fail"()
    if_null rx2391_debug, debug_1733
    rx2391_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1733:
    .return (rx2391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("443_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("444_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    .local string rx2395_tgt
    .local int rx2395_pos
    .local int rx2395_off
    .local int rx2395_eos
    .local int rx2395_rep
    .local pmc rx2395_cur
    .local pmc rx2395_debug
    (rx2395_cur, rx2395_pos, rx2395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2395_cur
    .local pmc match
    .lex "$/", match
    length rx2395_eos, rx2395_tgt
    gt rx2395_pos, rx2395_eos, rx2395_done
    set rx2395_off, 0
    lt rx2395_pos, 2, rx2395_start
    sub rx2395_off, rx2395_pos, 1
    substr rx2395_tgt, rx2395_tgt, rx2395_off
  rx2395_start:
    eq $I10, 1, rx2395_restart
    if_null rx2395_debug, debug_1734
    rx2395_cur."!cursor_debug"("START", "codeblock")
  debug_1734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2396_done
    goto rxscan2396_scan
  rxscan2396_loop:
    (rx2395_pos) = rx2395_cur."from"()
    inc rx2395_pos
    rx2395_cur."!cursor_from"(rx2395_pos)
    ge rx2395_pos, rx2395_eos, rxscan2396_done
  rxscan2396_scan:
    set_addr $I10, rxscan2396_loop
    rx2395_cur."!mark_push"(0, rx2395_pos, $I10)
  rxscan2396_done:
.annotate 'line', 1238
  # rx subrule "LANG" subtype=capture negate=
    rx2395_cur."!cursor_pos"(rx2395_pos)
    $P10 = rx2395_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2395_fail
    rx2395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2395_pos = $P10."pos"()
.annotate 'line', 1237
  # rx pass
    rx2395_cur."!cursor_pass"(rx2395_pos, "codeblock")
    if_null rx2395_debug, debug_1735
    rx2395_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2395_pos)
  debug_1735:
    .return (rx2395_cur)
  rx2395_restart:
.annotate 'line', 1201
    if_null rx2395_debug, debug_1736
    rx2395_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1736:
  rx2395_fail:
    (rx2395_rep, rx2395_pos, $I10, $P10) = rx2395_cur."!mark_fail"(0)
    lt rx2395_pos, -1, rx2395_done
    eq rx2395_pos, -1, rx2395_fail
    jump $I10
  rx2395_done:
    rx2395_cur."!cursor_fail"()
    if_null rx2395_debug, debug_1737
    rx2395_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1737:
    .return (rx2395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("445_1321350766.1143") :method :outer("425_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1201
    $P103 = self."!PREFIX__!subrule"("LANG", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2398"  :subid("446_1321350766.1143") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1244
    .const 'Sub' $P3721 = "626_1321350766.1143" 
    capture_lex $P3721
    .const 'Sub' $P3718 = "625_1321350766.1143" 
    capture_lex $P3718
    .const 'Sub' $P3715 = "624_1321350766.1143" 
    capture_lex $P3715
    .const 'Sub' $P3712 = "623_1321350766.1143" 
    capture_lex $P3712
    .const 'Sub' $P3709 = "622_1321350766.1143" 
    capture_lex $P3709
    .const 'Sub' $P3706 = "621_1321350766.1143" 
    capture_lex $P3706
    .const 'Sub' $P3703 = "620_1321350766.1143" 
    capture_lex $P3703
    .const 'Sub' $P3700 = "619_1321350766.1143" 
    capture_lex $P3700
    .const 'Sub' $P3696 = "618_1321350766.1143" 
    capture_lex $P3696
    .const 'Sub' $P3693 = "617_1321350766.1143" 
    capture_lex $P3693
    .const 'Sub' $P3689 = "616_1321350766.1143" 
    capture_lex $P3689
    .const 'Sub' $P3685 = "615_1321350766.1143" 
    capture_lex $P3685
    .const 'Sub' $P3671 = "614_1321350766.1143" 
    capture_lex $P3671
    .const 'Sub' $P3667 = "613_1321350766.1143" 
    capture_lex $P3667
    .const 'Sub' $P3663 = "612_1321350766.1143" 
    capture_lex $P3663
    .const 'Sub' $P3659 = "611_1321350766.1143" 
    capture_lex $P3659
    .const 'Sub' $P3655 = "610_1321350766.1143" 
    capture_lex $P3655
    .const 'Sub' $P3651 = "609_1321350766.1143" 
    capture_lex $P3651
    .const 'Sub' $P3647 = "608_1321350766.1143" 
    capture_lex $P3647
    .const 'Sub' $P3637 = "607_1321350766.1143" 
    capture_lex $P3637
    .const 'Sub' $P3630 = "606_1321350766.1143" 
    capture_lex $P3630
    .const 'Sub' $P3626 = "605_1321350766.1143" 
    capture_lex $P3626
    .const 'Sub' $P3622 = "604_1321350766.1143" 
    capture_lex $P3622
    .const 'Sub' $P3618 = "603_1321350766.1143" 
    capture_lex $P3618
    .const 'Sub' $P3614 = "602_1321350766.1143" 
    capture_lex $P3614
    .const 'Sub' $P3610 = "601_1321350766.1143" 
    capture_lex $P3610
    .const 'Sub' $P3601 = "600_1321350766.1143" 
    capture_lex $P3601
    .const 'Sub' $P3583 = "598_1321350766.1143" 
    capture_lex $P3583
    .const 'Sub' $P3579 = "597_1321350766.1143" 
    capture_lex $P3579
    .const 'Sub' $P3575 = "596_1321350766.1143" 
    capture_lex $P3575
    .const 'Sub' $P3566 = "595_1321350766.1143" 
    capture_lex $P3566
    .const 'Sub' $P3559 = "594_1321350766.1143" 
    capture_lex $P3559
    .const 'Sub' $P3555 = "593_1321350766.1143" 
    capture_lex $P3555
    .const 'Sub' $P3551 = "592_1321350766.1143" 
    capture_lex $P3551
    .const 'Sub' $P3520 = "589_1321350766.1143" 
    capture_lex $P3520
    .const 'Sub' $P3516 = "588_1321350766.1143" 
    capture_lex $P3516
    .const 'Sub' $P3513 = "587_1321350766.1143" 
    capture_lex $P3513
    .const 'Sub' $P3501 = "586_1321350766.1143" 
    capture_lex $P3501
    .const 'Sub' $P3497 = "585_1321350766.1143" 
    capture_lex $P3497
    .const 'Sub' $P3487 = "584_1321350766.1143" 
    capture_lex $P3487
    .const 'Sub' $P3468 = "582_1321350766.1143" 
    capture_lex $P3468
    .const 'Sub' $P3462 = "581_1321350766.1143" 
    capture_lex $P3462
    .const 'Sub' $P3459 = "580_1321350766.1143" 
    capture_lex $P3459
    .const 'Sub' $P3441 = "579_1321350766.1143" 
    capture_lex $P3441
    .const 'Sub' $P3389 = "574_1321350766.1143" 
    capture_lex $P3389
    .const 'Sub' $P3353 = "569_1321350766.1143" 
    capture_lex $P3353
    .const 'Sub' $P3349 = "568_1321350766.1143" 
    capture_lex $P3349
    .const 'Sub' $P3332 = "566_1321350766.1143" 
    capture_lex $P3332
    .const 'Sub' $P3325 = "565_1321350766.1143" 
    capture_lex $P3325
    .const 'Sub' $P3319 = "564_1321350766.1143" 
    capture_lex $P3319
    .const 'Sub' $P3280 = "563_1321350766.1143" 
    capture_lex $P3280
    .const 'Sub' $P3260 = "560_1321350766.1143" 
    capture_lex $P3260
    .const 'Sub' $P3227 = "557_1321350766.1143" 
    capture_lex $P3227
    .const 'Sub' $P3146 = "550_1321350766.1143" 
    capture_lex $P3146
    .const 'Sub' $P3142 = "549_1321350766.1143" 
    capture_lex $P3142
    .const 'Sub' $P3138 = "548_1321350766.1143" 
    capture_lex $P3138
    .const 'Sub' $P3097 = "545_1321350766.1143" 
    capture_lex $P3097
    .const 'Sub' $P3093 = "544_1321350766.1143" 
    capture_lex $P3093
    .const 'Sub' $P3086 = "543_1321350766.1143" 
    capture_lex $P3086
    .const 'Sub' $P3079 = "542_1321350766.1143" 
    capture_lex $P3079
    .const 'Sub' $P3072 = "541_1321350766.1143" 
    capture_lex $P3072
    .const 'Sub' $P3062 = "540_1321350766.1143" 
    capture_lex $P3062
    .const 'Sub' $P3058 = "539_1321350766.1143" 
    capture_lex $P3058
    .const 'Sub' $P3054 = "538_1321350766.1143" 
    capture_lex $P3054
    .const 'Sub' $P3050 = "537_1321350766.1143" 
    capture_lex $P3050
    .const 'Sub' $P2985 = "531_1321350766.1143" 
    capture_lex $P2985
    .const 'Sub' $P2957 = "530_1321350766.1143" 
    capture_lex $P2957
    .const 'Sub' $P2953 = "529_1321350766.1143" 
    capture_lex $P2953
    .const 'Sub' $P2949 = "528_1321350766.1143" 
    capture_lex $P2949
    .const 'Sub' $P2945 = "527_1321350766.1143" 
    capture_lex $P2945
    .const 'Sub' $P2941 = "526_1321350766.1143" 
    capture_lex $P2941
    .const 'Sub' $P2937 = "525_1321350766.1143" 
    capture_lex $P2937
    .const 'Sub' $P2933 = "524_1321350766.1143" 
    capture_lex $P2933
    .const 'Sub' $P2879 = "518_1321350766.1143" 
    capture_lex $P2879
    .const 'Sub' $P2869 = "517_1321350766.1143" 
    capture_lex $P2869
    .const 'Sub' $P2863 = "516_1321350766.1143" 
    capture_lex $P2863
    .const 'Sub' $P2859 = "515_1321350766.1143" 
    capture_lex $P2859
    .const 'Sub' $P2855 = "514_1321350766.1143" 
    capture_lex $P2855
    .const 'Sub' $P2851 = "513_1321350766.1143" 
    capture_lex $P2851
    .const 'Sub' $P2847 = "512_1321350766.1143" 
    capture_lex $P2847
    .const 'Sub' $P2843 = "511_1321350766.1143" 
    capture_lex $P2843
    .const 'Sub' $P2839 = "510_1321350766.1143" 
    capture_lex $P2839
    .const 'Sub' $P2835 = "509_1321350766.1143" 
    capture_lex $P2835
    .const 'Sub' $P2831 = "508_1321350766.1143" 
    capture_lex $P2831
    .const 'Sub' $P2827 = "507_1321350766.1143" 
    capture_lex $P2827
    .const 'Sub' $P2823 = "506_1321350766.1143" 
    capture_lex $P2823
    .const 'Sub' $P2819 = "505_1321350766.1143" 
    capture_lex $P2819
    .const 'Sub' $P2815 = "504_1321350766.1143" 
    capture_lex $P2815
    .const 'Sub' $P2811 = "503_1321350766.1143" 
    capture_lex $P2811
    .const 'Sub' $P2804 = "502_1321350766.1143" 
    capture_lex $P2804
    .const 'Sub' $P2797 = "501_1321350766.1143" 
    capture_lex $P2797
    .const 'Sub' $P2792 = "500_1321350766.1143" 
    capture_lex $P2792
    .const 'Sub' $P2786 = "499_1321350766.1143" 
    capture_lex $P2786
    .const 'Sub' $P2780 = "498_1321350766.1143" 
    capture_lex $P2780
    .const 'Sub' $P2771 = "497_1321350766.1143" 
    capture_lex $P2771
    .const 'Sub' $P2760 = "496_1321350766.1143" 
    capture_lex $P2760
    .const 'Sub' $P2754 = "495_1321350766.1143" 
    capture_lex $P2754
    .const 'Sub' $P2749 = "494_1321350766.1143" 
    capture_lex $P2749
    .const 'Sub' $P2730 = "492_1321350766.1143" 
    capture_lex $P2730
    .const 'Sub' $P2724 = "491_1321350766.1143" 
    capture_lex $P2724
    .const 'Sub' $P2721 = "490_1321350766.1143" 
    capture_lex $P2721
    .const 'Sub' $P2716 = "489_1321350766.1143" 
    capture_lex $P2716
    .const 'Sub' $P2701 = "487_1321350766.1143" 
    capture_lex $P2701
    .const 'Sub' $P2697 = "486_1321350766.1143" 
    capture_lex $P2697
    .const 'Sub' $P2684 = "484_1321350766.1143" 
    capture_lex $P2684
    .const 'Sub' $P2680 = "483_1321350766.1143" 
    capture_lex $P2680
    .const 'Sub' $P2676 = "482_1321350766.1143" 
    capture_lex $P2676
    .const 'Sub' $P2671 = "481_1321350766.1143" 
    capture_lex $P2671
    .const 'Sub' $P2642 = "479_1321350766.1143" 
    capture_lex $P2642
    .const 'Sub' $P2624 = "477_1321350766.1143" 
    capture_lex $P2624
    .const 'Sub' $P2603 = "475_1321350766.1143" 
    capture_lex $P2603
    .const 'Sub' $P2593 = "474_1321350766.1143" 
    capture_lex $P2593
    .const 'Sub' $P2589 = "473_1321350766.1143" 
    capture_lex $P2589
    .const 'Sub' $P2534 = "467_1321350766.1143" 
    capture_lex $P2534
    .const 'Sub' $P2517 = "465_1321350766.1143" 
    capture_lex $P2517
    .const 'Sub' $P2513 = "464_1321350766.1143" 
    capture_lex $P2513
    .const 'Sub' $P2509 = "463_1321350766.1143" 
    capture_lex $P2509
    .const 'Sub' $P2481 = "460_1321350766.1143" 
    capture_lex $P2481
    .const 'Sub' $P2476 = "459_1321350766.1143" 
    capture_lex $P2476
    .const 'Sub' $P2456 = "457_1321350766.1143" 
    capture_lex $P2456
    .const 'Sub' $P2451 = "456_1321350766.1143" 
    capture_lex $P2451
    .const 'Sub' $P2441 = "455_1321350766.1143" 
    capture_lex $P2441
    .const 'Sub' $P2431 = "453_1321350766.1143" 
    capture_lex $P2431
    .const 'Sub' $P2426 = "452_1321350766.1143" 
    capture_lex $P2426
    .const 'Sub' $P2420 = "451_1321350766.1143" 
    capture_lex $P2420
    .const 'Sub' $P2407 = "448_1321350766.1143" 
    capture_lex $P2407
    .const 'Sub' $P2401 = "447_1321350766.1143" 
    capture_lex $P2401
.annotate 'line', 1248
    .const 'Sub' $P2401 = "447_1321350766.1143" 
    newclosure $P2405, $P2401
    set $P2400, $P2405
    .lex "xblock_immediate", $P2400
.annotate 'line', 1253
    .const 'Sub' $P2407 = "448_1321350766.1143" 
    newclosure $P2418, $P2407
    set $P2406, $P2418
    .lex "block_immediate", $P2406
.annotate 'line', 1263
    .const 'Sub' $P2420 = "451_1321350766.1143" 
    newclosure $P2424, $P2420
    set $P2419, $P2424
    .lex "vivitype", $P2419
.annotate 'line', 1282
    .const 'Sub' $P2426 = "452_1321350766.1143" 
    newclosure $P2429, $P2426
    set $P2425, $P2429
    .lex "colonpair_str", $P2425
.annotate 'line', 1462
    .const 'Sub' $P2431 = "453_1321350766.1143" 
    newclosure $P2439, $P2431
    set $P2430, $P2439
    .lex "import_HOW_exports", $P2430
.annotate 'line', 1567
    .const 'Sub' $P2441 = "455_1321350766.1143" 
    newclosure $P2449, $P2441
    set $P2440, $P2449
    .lex "push_block_handler", $P2440
.annotate 'line', 2115
    .const 'Sub' $P2451 = "456_1321350766.1143" 
    newclosure $P2454, $P2451
    set $P2450, $P2454
    .lex "only_star_block", $P2450
.annotate 'line', 2124
    .const 'Sub' $P2456 = "457_1321350766.1143" 
    newclosure $P2474, $P2456
    set $P2455, $P2474
    .lex "attach_multi_signature", $P2455
.annotate 'line', 2602
    .const 'Sub' $P2476 = "459_1321350766.1143" 
    newclosure $P2479, $P2476
    set $P2475, $P2479
    .lex "control", $P2475
.annotate 'line', 2621
    .const 'Sub' $P2481 = "460_1321350766.1143" 
    newclosure $P2507, $P2481
    set $P2480, $P2507
    .lex "lexical_package_lookup", $P2480
.annotate 'line', 2670
    .const 'Sub' $P2509 = "463_1321350766.1143" 
    newclosure $P2511, $P2509
    set $P2508, $P2511
    .lex "is_lexical", $P2508
.annotate 'line', 2676
    .const 'Sub' $P2513 = "464_1321350766.1143" 
    newclosure $P2515, $P2513
    set $P2512, $P2515
    .lex "is_package", $P2512
.annotate 'line', 2682
    .const 'Sub' $P2517 = "465_1321350766.1143" 
    newclosure $P2532, $P2517
    set $P2516, $P2532
    .lex "is_scope", $P2516
.annotate 'line', 2705
    .const 'Sub' $P2534 = "467_1321350766.1143" 
    newclosure $P2586, $P2534
    set $P2533, $P2586
    .lex "find_sym", $P2533
.annotate 'line', 1244
    .lex "$?PACKAGE", $P2587
    .lex "$?CLASS", $P2588
.annotate 'line', 1246
    new $P122, "ResizablePMCArray"
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P124["@BLOCK"], $P122
.annotate 'line', 1244
    find_lex $P122, "xblock_immediate"
    find_lex $P122, "block_immediate"
    find_lex $P122, "vivitype"
    find_lex $P122, "colonpair_str"
    find_lex $P122, "import_HOW_exports"
    find_lex $P122, "push_block_handler"
    find_lex $P122, "only_star_block"
    find_lex $P122, "attach_multi_signature"
    find_lex $P122, "control"
    find_lex $P122, "lexical_package_lookup"
    find_lex $P122, "is_lexical"
    find_lex $P122, "is_package"
    find_lex $P122, "is_scope"
    find_lex $P122, "find_sym"
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("447_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2402
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1248
    .lex "$xblock", param_2402
.annotate 'line', 1249
    new $P103, "Float"
    assign $P103, 1
    set $I100, $P103
    find_lex $P2403, "$xblock"
    unless_null $P2403, vivify_1738
    $P2403 = root_new ['parrot';'ResizablePMCArray']
  vivify_1738:
    set $P104, $P2403[$I100]
    unless_null $P104, vivify_1739
    new $P104, "Undef"
  vivify_1739:
    $P105 = "block_immediate"($P104)
    new $P106, "Float"
    assign $P106, 1
    set $I101, $P106
    find_lex $P2404, "$xblock"
    unless_null $P2404, vivify_1740
    $P2404 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2404
  vivify_1740:
    set $P2404[$I101], $P105
.annotate 'line', 1248
    find_lex $P103, "$xblock"
    unless_null $P103, vivify_1741
    new $P103, "Undef"
  vivify_1741:
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("448_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2408
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1253
    .const 'Sub' $P2412 = "449_1321350766.1143" 
    capture_lex $P2412
    .lex "$block", param_2408
.annotate 'line', 1254
    find_lex $P104, "$block"
    unless_null $P104, vivify_1742
    new $P104, "Undef"
  vivify_1742:
    $P104."blocktype"("immediate")
.annotate 'line', 1255
    find_lex $P105, "$block"
    unless_null $P105, vivify_1743
    new $P105, "Undef"
  vivify_1743:
    $P106 = $P105."symtable"()
    unless $P106, unless_2410
    set $P104, $P106
    goto unless_2410_end
  unless_2410:
    find_lex $P107, "$block"
    unless_null $P107, vivify_1744
    new $P107, "Undef"
  vivify_1744:
    $P108 = $P107."handlers"()
    set $P104, $P108
  unless_2410_end:
    if $P104, unless_2409_end
    .const 'Sub' $P2412 = "449_1321350766.1143" 
    capture_lex $P2412
    $P2412()
  unless_2409_end:
.annotate 'line', 1253
    find_lex $P104, "$block"
    unless_null $P104, vivify_1751
    new $P104, "Undef"
  vivify_1751:
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2411"  :anon :subid("449_1321350766.1143") :outer("448_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1255
    .const 'Sub' $P2415 = "450_1321350766.1143" 
    capture_lex $P2415
.annotate 'line', 1256
    new $P109, "Undef"
    set $P2413, $P109
    .lex "$stmts", $P2413
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Stmts"]
    find_lex $P114, "$block"
    unless_null $P114, vivify_1745
    new $P114, "Undef"
  vivify_1745:
    $P115 = $P113."new"($P114 :named("node"))
    store_lex "$stmts", $P115
.annotate 'line', 1257
    find_lex $P111, "$block"
    unless_null $P111, vivify_1746
    new $P111, "Undef"
  vivify_1746:
    $P112 = $P111."list"()
    defined $I100, $P112
    unless $I100, for_undef_1747
    iter $P110, $P112
    new $P114, 'ExceptionHandler'
    set_label $P114, loop2417_handler
    $P114."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P114
  loop2417_test:
    unless $P110, loop2417_done
    shift $P113, $P110
  loop2417_redo:
    .const 'Sub' $P2415 = "450_1321350766.1143" 
    capture_lex $P2415
    $P2415($P113)
  loop2417_next:
    goto loop2417_test
  loop2417_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2417_next
    eq $P115, .CONTROL_LOOP_REDO, loop2417_redo
  loop2417_done:
    pop_eh 
  for_undef_1747:
.annotate 'line', 1258
    find_lex $P110, "$stmts"
    unless_null $P110, vivify_1750
    new $P110, "Undef"
  vivify_1750:
    store_lex "$block", $P110
.annotate 'line', 1255
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2414"  :anon :subid("450_1321350766.1143") :outer("449_1321350766.1143")
    .param pmc param_2416
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1257
    .lex "$_", param_2416
    find_lex $P114, "$stmts"
    unless_null $P114, vivify_1748
    new $P114, "Undef"
  vivify_1748:
    find_lex $P115, "$_"
    unless_null $P115, vivify_1749
    new $P115, "Undef"
  vivify_1749:
    $P116 = $P114."push"($P115)
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("451_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2421
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1263
    .lex "$sigil", param_2421
.annotate 'line', 1264
    find_lex $P106, "$sigil"
    unless_null $P106, vivify_1752
    new $P106, "Undef"
  vivify_1752:
    set $S100, $P106
    iseq $I100, $S100, "%"
    if $I100, if_2422
.annotate 'line', 1266
    find_lex $P113, "$sigil"
    unless_null $P113, vivify_1753
    new $P113, "Undef"
  vivify_1753:
    set $S101, $P113
    iseq $I101, $S101, "@"
    if $I101, if_2423
    new $P119, "String"
    assign $P119, "Undef"
    set $P112, $P119
    goto if_2423_end
  if_2423:
.annotate 'line', 1267
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    $P118 = $P117."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P112, $P118
  if_2423_end:
    set $P105, $P112
.annotate 'line', 1264
    goto if_2422_end
  if_2422:
.annotate 'line', 1265
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    $P111 = $P110."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P105, $P111
  if_2422_end:
.annotate 'line', 1263
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("452_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2427
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1282
    .lex "$ast", param_2427
.annotate 'line', 1283
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    find_lex $P111, "$ast"
    unless_null $P111, vivify_1754
    new $P111, "Undef"
  vivify_1754:
    $P112 = $P110."ACCEPTS"($P111)
    if $P112, if_2428
.annotate 'line', 1285
    find_lex $P115, "$ast"
    unless_null $P115, vivify_1755
    new $P115, "Undef"
  vivify_1755:
    $P116 = $P115."value"()
    set $P106, $P116
.annotate 'line', 1283
    goto if_2428_end
  if_2428:
.annotate 'line', 1284
    find_lex $P113, "$ast"
    unless_null $P113, vivify_1756
    new $P113, "Undef"
  vivify_1756:
    $P114 = $P113."list"()
    join $S100, " ", $P114
    new $P106, 'String'
    set $P106, $S100
  if_2428_end:
.annotate 'line', 1282
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("453_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2432
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1462
    .const 'Sub' $P2436 = "454_1321350766.1143" 
    capture_lex $P2436
    .lex "$UNIT", param_2432
.annotate 'line', 1464
    find_lex $P108, "$UNIT"
    unless_null $P108, vivify_1757
    new $P108, "Undef"
  vivify_1757:
    exists $I100, $P108["EXPORTHOW"]
    if $I100, if_2433
    new $P107, 'Integer'
    set $P107, $I100
    goto if_2433_end
  if_2433:
.annotate 'line', 1465
    find_lex $P2434, "$UNIT"
    unless_null $P2434, vivify_1758
    $P2434 = root_new ['parrot';'Hash']
  vivify_1758:
    set $P110, $P2434["EXPORTHOW"]
    unless_null $P110, vivify_1759
    new $P110, "Undef"
  vivify_1759:
    get_who $P111, $P110
    defined $I101, $P111
    unless $I101, for_undef_1760
    iter $P109, $P111
    new $P113, 'ExceptionHandler'
    set_label $P113, loop2438_handler
    $P113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P113
  loop2438_test:
    unless $P109, loop2438_done
    shift $P112, $P109
  loop2438_redo:
    .const 'Sub' $P2436 = "454_1321350766.1143" 
    capture_lex $P2436
    $P2436($P112)
  loop2438_next:
    goto loop2438_test
  loop2438_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2438_next
    eq $P115, .CONTROL_LOOP_REDO, loop2438_redo
  loop2438_done:
    pop_eh 
  for_undef_1760:
.annotate 'line', 1464
    set $P107, $P109
  if_2433_end:
.annotate 'line', 1462
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2435"  :anon :subid("454_1321350766.1143") :outer("453_1321350766.1143")
    .param pmc param_2437
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1465
    .lex "$_", param_2437
.annotate 'line', 1466
    find_lex $P113, "$_"
    unless_null $P113, vivify_1761
    new $P113, "Undef"
  vivify_1761:
    $P114 = $P113."value"()
    find_lex $P115, "$_"
    unless_null $P115, vivify_1762
    new $P115, "Undef"
  vivify_1762:
    $P116 = $P115."key"()
    find_dynamic_lex $P119, "%*HOW"
    unless_null $P119, vivify_1763
    get_hll_global $P117, "GLOBAL"
    get_who $P118, $P117
    set $P119, $P118["%HOW"]
    unless_null $P119, vivify_1764
    die "Contextual %*HOW not found"
  vivify_1764:
    store_dynamic_lex "%*HOW", $P119
  vivify_1763:
    set $P119[$P116], $P114
.annotate 'line', 1465
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("455_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2442
    .param pmc param_2443
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1567
    .lex "$/", param_2442
    .lex "$block", param_2443
.annotate 'line', 1568
    new $P108, "Float"
    assign $P108, 0
    set $I100, $P108
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2445, $P110["@BLOCK"]
    unless_null $P2445, vivify_1765
    $P2445 = root_new ['parrot';'ResizablePMCArray']
  vivify_1765:
    set $P111, $P2445[$I100]
    unless_null $P111, vivify_1766
    new $P111, "Undef"
  vivify_1766:
    $P112 = $P111."handlers"()
    if $P112, unless_2444_end
.annotate 'line', 1569
    new $P113, "Float"
    assign $P113, 0
    set $I101, $P113
    find_lex $P114, "$?PACKAGE"
    get_who $P115, $P114
    set $P2446, $P115["@BLOCK"]
    unless_null $P2446, vivify_1767
    $P2446 = root_new ['parrot';'ResizablePMCArray']
  vivify_1767:
    set $P116, $P2446[$I101]
    unless_null $P116, vivify_1768
    new $P116, "Undef"
  vivify_1768:
    new $P117, "ResizablePMCArray"
    $P116."handlers"($P117)
  unless_2444_end:
.annotate 'line', 1571
    find_lex $P108, "$block"
    unless_null $P108, vivify_1769
    new $P108, "Undef"
  vivify_1769:
    $P109 = $P108."arity"()
    if $P109, unless_2447_end
.annotate 'line', 1572
    find_lex $P110, "$block"
    unless_null $P110, vivify_1770
    new $P110, "Undef"
  vivify_1770:
.annotate 'line', 1573
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 1574
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Var"]
    $P119 = $P118."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1575
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("lexical" :named("scope"), "$_" :named("name"))
    $P125 = $P114."new"($P119, $P124, "bind_6model" :named("pasttype"))
.annotate 'line', 1573
    $P110."unshift"($P125)
.annotate 'line', 1578
    find_lex $P110, "$block"
    unless_null $P110, vivify_1771
    new $P110, "Undef"
  vivify_1771:
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Var"]
    $P115 = $P114."new"("$_" :named("name"), "parameter" :named("scope"))
    $P110."unshift"($P115)
.annotate 'line', 1579
    find_lex $P110, "$block"
    unless_null $P110, vivify_1772
    new $P110, "Undef"
  vivify_1772:
    $P110."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1580
    find_lex $P110, "$block"
    unless_null $P110, vivify_1773
    new $P110, "Undef"
  vivify_1773:
    $P110."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1581
    find_lex $P110, "$block"
    unless_null $P110, vivify_1774
    new $P110, "Undef"
  vivify_1774:
    $P110."arity"(1)
  unless_2447_end:
.annotate 'line', 1583
    find_lex $P108, "$block"
    unless_null $P108, vivify_1775
    new $P108, "Undef"
  vivify_1775:
    $P108."blocktype"("declaration")
.annotate 'line', 1584
    new $P108, "Float"
    assign $P108, 0
    set $I100, $P108
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2448, $P110["@BLOCK"]
    unless_null $P2448, vivify_1776
    $P2448 = root_new ['parrot';'ResizablePMCArray']
  vivify_1776:
    set $P111, $P2448[$I100]
    unless_null $P111, vivify_1777
    new $P111, "Undef"
  vivify_1777:
    $P112 = $P111."handlers"()
.annotate 'line', 1585
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Control"]
    find_lex $P117, "$/"
    unless_null $P117, vivify_1778
    new $P117, "Undef"
  vivify_1778:
.annotate 'line', 1587
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Stmts"]
.annotate 'line', 1588
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Op"]
    find_lex $P126, "$block"
    unless_null $P126, vivify_1779
    new $P126, "Undef"
  vivify_1779:
.annotate 'line', 1590
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("register" :named("scope"), "exception" :named("name"))
    $P132 = $P125."new"($P126, $P131, "call" :named("pasttype"))
.annotate 'line', 1592
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
.annotate 'line', 1593
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Var"]
.annotate 'line', 1594
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Var"]
    $P145 = $P144."new"("register" :named("scope"), "exception" :named("name"))
    $P146 = $P140."new"($P145, "handled", "keyed" :named("scope"))
.annotate 'line', 1593
    $P147 = $P136."new"($P146, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1592
    $P148 = $P121."new"($P132, $P147)
.annotate 'line', 1587
    $P149 = $P116."new"($P148, $P117 :named("node"))
.annotate 'line', 1585
    $P150 = $P112."unshift"($P149)
.annotate 'line', 1567
    .return ($P150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("456_1321350766.1143") :outer("446_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2116
    new $P108, "Undef"
    set $P2452, $P108
    .lex "$past", $P2452
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2453, $P110["@BLOCK"]
    unless_null $P2453, vivify_1780
    $P2453 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    $P111 = $P2453."shift"()
    store_lex "$past", $P111
.annotate 'line', 2117
    find_lex $P109, "$past"
    unless_null $P109, vivify_1781
    new $P109, "Undef"
  vivify_1781:
    $P109."closure"(1)
.annotate 'line', 2118
    find_lex $P109, "$past"
    unless_null $P109, vivify_1782
    new $P109, "Undef"
  vivify_1782:
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    $P114 = $P113."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P109."push"($P114)
.annotate 'line', 2115
    find_lex $P109, "$past"
    unless_null $P109, vivify_1783
    new $P109, "Undef"
  vivify_1783:
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("457_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2457
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2124
    .const 'Sub' $P2462 = "458_1321350766.1143" 
    capture_lex $P2462
    .lex "$routine", param_2457
.annotate 'line', 2128
    new $P110, "Undef"
    set $P2458, $P110
    .lex "$types", $P2458
.annotate 'line', 2129
    new $P111, "Undef"
    set $P2459, $P111
    .lex "$definednesses", $P2459
.annotate 'line', 2128
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    store_lex "$types", $P116
.annotate 'line', 2129
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P116
.annotate 'line', 2130
    new $P113, "Float"
    assign $P113, 0
    set $I100, $P113
    find_lex $P2460, "$routine"
    unless_null $P2460, vivify_1784
    $P2460 = root_new ['parrot';'ResizablePMCArray']
  vivify_1784:
    set $P114, $P2460[$I100]
    unless_null $P114, vivify_1785
    new $P114, "Undef"
  vivify_1785:
    $P115 = $P114."list"()
    defined $I101, $P115
    unless $I101, for_undef_1786
    iter $P112, $P115
    new $P118, 'ExceptionHandler'
    set_label $P118, loop2473_handler
    $P118."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P118
  loop2473_test:
    unless $P112, loop2473_done
    shift $P116, $P112
  loop2473_redo:
    .const 'Sub' $P2462 = "458_1321350766.1143" 
    capture_lex $P2462
    $P2462($P116)
  loop2473_next:
    goto loop2473_test
  loop2473_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2473_next
    eq $P119, .CONTROL_LOOP_REDO, loop2473_redo
  loop2473_done:
    pop_eh 
  for_undef_1786:
.annotate 'line', 2137
    find_dynamic_lex $P114, "$*SC"
    unless_null $P114, vivify_1796
    get_hll_global $P112, "GLOBAL"
    get_who $P113, $P112
    set $P114, $P113["$SC"]
    unless_null $P114, vivify_1797
    die "Contextual $*SC not found"
  vivify_1797:
  vivify_1796:
    find_lex $P115, "$routine"
    unless_null $P115, vivify_1798
    new $P115, "Undef"
  vivify_1798:
    find_lex $P116, "$types"
    unless_null $P116, vivify_1799
    new $P116, "Undef"
  vivify_1799:
    find_lex $P117, "$definednesses"
    unless_null $P117, vivify_1800
    new $P117, "Undef"
  vivify_1800:
    $P118 = $P114."set_routine_signature"($P115, $P116, $P117)
.annotate 'line', 2124
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2461"  :anon :subid("458_1321350766.1143") :outer("457_1321350766.1143")
    .param pmc param_2463
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2130
    .lex "$_", param_2463
.annotate 'line', 2131
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Var"]
    find_lex $P123, "$_"
    unless_null $P123, vivify_1787
    new $P123, "Undef"
  vivify_1787:
    $P124 = $P122."ACCEPTS"($P123)
    if $P124, if_2465
    set $P118, $P124
    goto if_2465_end
  if_2465:
    find_lex $P125, "$_"
    unless_null $P125, vivify_1788
    new $P125, "Undef"
  vivify_1788:
    $S100 = $P125."scope"()
    iseq $I102, $S100, "parameter"
    new $P118, 'Integer'
    set $P118, $I102
  if_2465_end:
    if $P118, if_2464
    set $P117, $P118
    goto if_2464_end
  if_2464:
.annotate 'line', 2132
    find_lex $P126, "$types"
    unless_null $P126, vivify_1789
    new $P126, "Undef"
  vivify_1789:
    find_lex $P127, "$_"
    unless_null $P127, vivify_1790
    new $P127, "Undef"
  vivify_1790:
    $P128 = $P127."multitype"()
    set $P2466, $P128
    defined $I2468, $P2466
    if $I2468, default_2467
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    $P133 = $P132."new"("null P" :named("pirop"))
    set $P2466, $P133
  default_2467:
    $P126."push"($P2466)
.annotate 'line', 2133
    find_lex $P126, "$definednesses"
    unless_null $P126, vivify_1791
    new $P126, "Undef"
  vivify_1791:
    find_lex $P2470, "$_"
    unless_null $P2470, vivify_1792
    $P2470 = root_new ['parrot';'Hash']
  vivify_1792:
    set $P128, $P2470["definedness"]
    unless_null $P128, vivify_1793
    new $P128, "Undef"
  vivify_1793:
    set $S101, $P128
    iseq $I103, $S101, "D"
    if $I103, if_2469
.annotate 'line', 2134
    find_lex $P2472, "$_"
    unless_null $P2472, vivify_1794
    $P2472 = root_new ['parrot';'Hash']
  vivify_1794:
    set $P131, $P2472["definedness"]
    unless_null $P131, vivify_1795
    new $P131, "Undef"
  vivify_1795:
    set $S102, $P131
    iseq $I104, $S102, "U"
    if $I104, if_2471
    new $P133, "Float"
    assign $P133, 0
    set $P130, $P133
    goto if_2471_end
  if_2471:
    new $P132, "Float"
    assign $P132, 2
    set $P130, $P132
  if_2471_end:
    set $P127, $P130
.annotate 'line', 2133
    goto if_2469_end
  if_2469:
    new $P129, "Float"
    assign $P129, 1
    set $P127, $P129
  if_2469_end:
    $P134 = $P126."push"($P127)
.annotate 'line', 2131
    set $P117, $P134
  if_2464_end:
.annotate 'line', 2130
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("459_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2477
    .param pmc param_2478
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2602
    .lex "$/", param_2477
    .lex "$type", param_2478
.annotate 'line', 2603
    find_lex $P112, "$/"
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "$/"
    unless_null $P117, vivify_1801
    new $P117, "Undef"
  vivify_1801:
.annotate 'line', 2607
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    find_lex $P123, "$type"
    unless_null $P123, vivify_1802
    new $P123, "Undef"
  vivify_1802:
    $P124 = $P122."new"($P123 :named("value"), "!macro_const" :named("returns"))
    $P125 = $P116."new"(0, $P124, $P117 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2603
    $P126 = $P112."!make"($P125)
.annotate 'line', 2602
    .return ($P126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("460_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2484
    .param pmc param_2485
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2621
    .const 'Sub' $P2494 = "461_1321350766.1143" 
    capture_lex $P2494
    new $P2483, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2483, control_2482
    push_eh $P2483
    .lex "@name", param_2484
    .lex "$/", param_2485
.annotate 'line', 2627
    new $P112, "Undef"
    set $P2486, $P112
    .lex "$final_name", $P2486
.annotate 'line', 2628
    new $P113, "Undef"
    set $P2487, $P113
    .lex "$lookup", $P2487
.annotate 'line', 2623
    find_lex $P2489, "@name"
    unless_null $P2489, vivify_1803
    $P2489 = root_new ['parrot';'ResizablePMCArray']
  vivify_1803:
    set $N100, $P2489
    set $N101, 0
    iseq $I100, $N100, $N101
    unless $I100, if_2488_end
    find_lex $P114, "$/"
    unless_null $P114, vivify_1804
    new $P114, "Undef"
  vivify_1804:
    $P115 = $P114."CURSOR"()
    $P115."panic"("Cannot compile empty name")
  if_2488_end:
.annotate 'line', 2627
    find_lex $P2490, "@name"
    unless_null $P2490, vivify_1805
    $P2490 = root_new ['parrot';'ResizablePMCArray']
  vivify_1805:
    $P114 = $P2490."pop"()
    store_lex "$final_name", $P114
.annotate 'line', 2628
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Var"]
    find_lex $P119, "$final_name"
    unless_null $P119, vivify_1806
    new $P119, "Undef"
  vivify_1806:
    set $S100, $P119
    $P120 = $P117."new"($S100, "keyed" :named("scope"))
    store_lex "$lookup", $P120
.annotate 'line', 2632
    find_lex $P2492, "@name"
    unless_null $P2492, vivify_1807
    $P2492 = root_new ['parrot';'ResizablePMCArray']
  vivify_1807:
    set $N100, $P2492
    set $N101, 0
    iseq $I100, $N100, $N101
    if $I100, if_2491
.annotate 'line', 2650
    .const 'Sub' $P2494 = "461_1321350766.1143" 
    capture_lex $P2494
    $P2494()
    goto if_2491_end
  if_2491:
.annotate 'line', 2633
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_1820
    new $P114, "Undef"
  vivify_1820:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Op"]
.annotate 'line', 2635
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P125 = $P119."new"($P124, "get_who PP" :named("pirop"))
.annotate 'line', 2633
    $P114."unshift"($P125)
.annotate 'line', 2637
    find_lex $P114, "$lookup"
    unless_null $P114, vivify_1821
    new $P114, "Undef"
  vivify_1821:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Var"]
.annotate 'line', 2639
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Op"]
.annotate 'line', 2641
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    new $P129, "ResizablePMCArray"
    $P130 = $P128."new"("GLOBAL" :named("name"), $P129 :named("namespace"), "package" :named("scope"))
    $P131 = $P123."new"($P130, "get_who PP" :named("pirop"))
.annotate 'line', 2643
    find_lex $P132, "$final_name"
    unless_null $P132, vivify_1822
    new $P132, "Undef"
  vivify_1822:
    set $S100, $P132
    $P133 = $P119."new"($P131, $S100, "keyed" :named("scope"))
.annotate 'line', 2637
    $P114."viviself"($P133)
  if_2491_end:
.annotate 'line', 2665
    new $P114, "Exception"
    set $P114['type'], .CONTROL_RETURN
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1823
    new $P115, "Undef"
  vivify_1823:
    setattribute $P114, 'payload', $P115
    throw $P114
.annotate 'line', 2621
    .return ()
  control_2482:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P114, exception, "payload"
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2493"  :anon :subid("461_1321350766.1143") :outer("460_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2650
    .const 'Sub' $P2504 = "462_1321350766.1143" 
    capture_lex $P2504
.annotate 'line', 2651
    new $P114, "Undef"
    set $P2495, $P114
    .lex "$path", $P2495
    new $P116, "Float"
    assign $P116, 0
    set $I101, $P116
    find_lex $P2497, "@name"
    unless_null $P2497, vivify_1808
    $P2497 = root_new ['parrot';'ResizablePMCArray']
  vivify_1808:
    set $P117, $P2497[$I101]
    unless_null $P117, vivify_1809
    new $P117, "Undef"
  vivify_1809:
    $P119 = "is_lexical"($P117)
    if $P119, if_2496
.annotate 'line', 2653
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    new $P131, "ResizablePMCArray"
    $P132 = $P130."new"("GLOBAL" :named("name"), $P131 :named("namespace"), "package" :named("scope"))
    set $P115, $P132
.annotate 'line', 2651
    goto if_2496_end
  if_2496:
.annotate 'line', 2652
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    find_lex $P2498, "@name"
    unless_null $P2498, vivify_1810
    $P2498 = root_new ['parrot';'ResizablePMCArray']
  vivify_1810:
    $P124 = $P2498."shift"()
    $P125 = $P123."new"($P124 :named("name"), "lexical" :named("scope"))
    set $P115, $P125
  if_2496_end:
.annotate 'line', 2651
    store_lex "$path", $P115
.annotate 'line', 2654
    new $P115, "Float"
    assign $P115, 0
    set $I101, $P115
    find_lex $P2500, "@name"
    unless_null $P2500, vivify_1811
    $P2500 = root_new ['parrot';'ResizablePMCArray']
  vivify_1811:
    set $P116, $P2500[$I101]
    unless_null $P116, vivify_1812
    new $P116, "Undef"
  vivify_1812:
    set $S100, $P116
    iseq $I102, $S100, "GLOBAL"
    unless $I102, if_2499_end
.annotate 'line', 2655
    find_lex $P2501, "@name"
    unless_null $P2501, vivify_1813
    $P2501 = root_new ['parrot';'ResizablePMCArray']
  vivify_1813:
    $P2501."shift"()
  if_2499_end:
.annotate 'line', 2657
    find_lex $P2502, "@name"
    unless_null $P2502, vivify_1814
    $P2502 = root_new ['parrot';'ResizablePMCArray']
  vivify_1814:
    defined $I101, $P2502
    unless $I101, for_undef_1815
    iter $P115, $P2502
    new $P117, 'ExceptionHandler'
    set_label $P117, loop2506_handler
    $P117."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P117
  loop2506_test:
    unless $P115, loop2506_done
    shift $P116, $P115
  loop2506_redo:
    .const 'Sub' $P2504 = "462_1321350766.1143" 
    capture_lex $P2504
    $P2504($P116)
  loop2506_next:
    goto loop2506_test
  loop2506_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2506_next
    eq $P119, .CONTROL_LOOP_REDO, loop2506_redo
  loop2506_done:
    pop_eh 
  for_undef_1815:
.annotate 'line', 2662
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1818
    new $P115, "Undef"
  vivify_1818:
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P119, $P117
    set $P120, $P119["Op"]
    find_lex $P121, "$path"
    unless_null $P121, vivify_1819
    new $P121, "Undef"
  vivify_1819:
    $P122 = $P120."new"($P121, "get_who PP" :named("pirop"))
    $P123 = $P115."unshift"($P122)
.annotate 'line', 2650
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2503"  :anon :subid("462_1321350766.1143") :outer("461_1321350766.1143")
    .param pmc param_2505
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2657
    .lex "$_", param_2505
.annotate 'line', 2658
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P119, $P117, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
    find_lex $P122, "$path"
    unless_null $P122, vivify_1816
    new $P122, "Undef"
  vivify_1816:
.annotate 'line', 2660
    find_lex $P123, "$_"
    unless_null $P123, vivify_1817
    new $P123, "Undef"
  vivify_1817:
    set $S100, $P123
    $P124 = $P121."new"($P122, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2658
    store_lex "$path", $P124
.annotate 'line', 2657
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("463_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2510
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2670
    .lex "$name", param_2510
.annotate 'line', 2671
    find_lex $P115, "$name"
    unless_null $P115, vivify_1824
    new $P115, "Undef"
  vivify_1824:
    $P116 = "is_scope"($P115, "lexical")
.annotate 'line', 2670
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("464_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2514
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2676
    .lex "$name", param_2514
.annotate 'line', 2677
    find_lex $P115, "$name"
    unless_null $P115, vivify_1825
    new $P115, "Undef"
  vivify_1825:
    $P117 = "is_scope"($P115, "package")
.annotate 'line', 2676
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("465_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2520
    .param pmc param_2521
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2682
    .const 'Sub' $P2524 = "466_1321350766.1143" 
    capture_lex $P2524
    new $P2519, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2519, control_2518
    push_eh $P2519
    .lex "$name", param_2520
    .lex "$wanted_scope", param_2521
.annotate 'line', 2683
    find_lex $P119, "$?PACKAGE"
    get_who $P120, $P119
    set $P2522, $P120["@BLOCK"]
    unless_null $P2522, vivify_1826
    $P2522 = root_new ['parrot';'ResizablePMCArray']
  vivify_1826:
    defined $I100, $P2522
    unless $I100, for_undef_1827
    iter $P115, $P2522
    new $P123, 'ExceptionHandler'
    set_label $P123, loop2531_handler
    $P123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P123
  loop2531_test:
    unless $P115, loop2531_done
    shift $P121, $P115
  loop2531_redo:
    .const 'Sub' $P2524 = "466_1321350766.1143" 
    capture_lex $P2524
    $P2524($P121)
  loop2531_next:
    goto loop2531_test
  loop2531_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2531_next
    eq $P124, .CONTROL_LOOP_REDO, loop2531_redo
  loop2531_done:
    pop_eh 
  for_undef_1827:
.annotate 'line', 2682
    .return (0)
  control_2518:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, "payload"
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2523"  :anon :subid("466_1321350766.1143") :outer("465_1321350766.1143")
    .param pmc param_2527
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2684
    $P2526 = root_new ['parrot';'Hash']
    set $P2525, $P2526
    .lex "%sym", $P2525
    .lex "$_", param_2527
    find_lex $P122, "$_"
    unless_null $P122, vivify_1828
    new $P122, "Undef"
  vivify_1828:
    find_lex $P123, "$name"
    unless_null $P123, vivify_1829
    new $P123, "Undef"
  vivify_1829:
    $P124 = $P122."symbol"($P123)
    store_lex "%sym", $P124
.annotate 'line', 2685
    find_lex $P2529, "%sym"
    unless_null $P2529, vivify_1830
    $P2529 = root_new ['parrot';'Hash']
  vivify_1830:
    set $N100, $P2529
    if $N100, if_2528
    new $P122, 'Float'
    set $P122, $N100
    goto if_2528_end
  if_2528:
.annotate 'line', 2686
    new $P123, "Exception"
    set $P123['type'], .CONTROL_RETURN
    find_lex $P2530, "%sym"
    unless_null $P2530, vivify_1831
    $P2530 = root_new ['parrot';'Hash']
  vivify_1831:
    set $P124, $P2530["scope"]
    unless_null $P124, vivify_1832
    new $P124, "Undef"
  vivify_1832:
    set $S100, $P124
    find_lex $P125, "$wanted_scope"
    unless_null $P125, vivify_1833
    new $P125, "Undef"
  vivify_1833:
    set $S101, $P125
    iseq $I101, $S100, $S101
    new $P127, 'Integer'
    set $P127, $I101
    setattribute $P123, 'payload', $P127
    throw $P123
  if_2528_end:
.annotate 'line', 2683
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("467_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2537
    .param pmc param_2538
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2705
    .const 'Sub' $P2581 = "472_1321350766.1143" 
    capture_lex $P2581
    .const 'Sub' $P2563 = "470_1321350766.1143" 
    capture_lex $P2563
    .const 'Sub' $P2545 = "468_1321350766.1143" 
    capture_lex $P2545
    new $P2536, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2536, control_2535
    push_eh $P2536
    .lex "@name", param_2537
    .lex "$/", param_2538
.annotate 'line', 2729
    new $P119, "Undef"
    set $P2539, $P119
    .lex "$result", $P2539
.annotate 'line', 2707
    find_lex $P2541, "@name"
    unless_null $P2541, vivify_1834
    $P2541 = root_new ['parrot';'ResizablePMCArray']
  vivify_1834:
    set $N100, $P2541
    if $N100, unless_2540_end
    find_lex $P120, "$/"
    unless_null $P120, vivify_1835
    new $P120, "Undef"
  vivify_1835:
    $P121 = $P120."CURSOR"()
    $P121."panic"("Cannot look up empty name")
  unless_2540_end:
.annotate 'line', 2711
    find_lex $P2543, "@name"
    unless_null $P2543, vivify_1836
    $P2543 = root_new ['parrot';'ResizablePMCArray']
  vivify_1836:
    set $N100, $P2543
    set $N101, 1
    iseq $I100, $N100, $N101
    unless $I100, if_2542_end
    .const 'Sub' $P2545 = "468_1321350766.1143" 
    capture_lex $P2545
    $P2545()
  if_2542_end:
.annotate 'line', 2729
    find_dynamic_lex $P122, "$*GLOBALish"
    unless_null $P122, vivify_1848
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$GLOBALish"]
    unless_null $P122, vivify_1849
    die "Contextual $*GLOBALish not found"
  vivify_1849:
  vivify_1848:
    store_lex "$result", $P122
.annotate 'line', 2730
    find_lex $P2561, "@name"
    unless_null $P2561, vivify_1850
    $P2561 = root_new ['parrot';'ResizablePMCArray']
  vivify_1850:
    set $N100, $P2561
    set $N101, 2
    isge $I100, $N100, $N101
    unless $I100, if_2560_end
    .const 'Sub' $P2563 = "470_1321350766.1143" 
    capture_lex $P2563
    $P2563()
  if_2560_end:
.annotate 'line', 2748
    find_lex $P2579, "@name"
    unless_null $P2579, vivify_1863
    $P2579 = root_new ['parrot';'ResizablePMCArray']
  vivify_1863:
    defined $I100, $P2579
    unless $I100, for_undef_1864
    iter $P120, $P2579
    new $P123, 'ExceptionHandler'
    set_label $P123, loop2585_handler
    $P123."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P123
  loop2585_test:
    unless $P120, loop2585_done
    shift $P121, $P120
  loop2585_redo:
    .const 'Sub' $P2581 = "472_1321350766.1143" 
    capture_lex $P2581
    $P2581($P121)
  loop2585_next:
    goto loop2585_test
  loop2585_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2585_next
    eq $P124, .CONTROL_LOOP_REDO, loop2585_redo
  loop2585_done:
    pop_eh 
  for_undef_1864:
.annotate 'line', 2705
    find_lex $P120, "$result"
    unless_null $P120, vivify_1871
    new $P120, "Undef"
  vivify_1871:
    .return ($P120)
  control_2535:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P121, exception, "payload"
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2544"  :anon :subid("468_1321350766.1143") :outer("467_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2711
    .const 'Sub' $P2550 = "469_1321350766.1143" 
    capture_lex $P2550
.annotate 'line', 2712
    new $P120, "Undef"
    set $P2546, $P120
    .lex "$final_name", $P2546
    new $P121, "Float"
    assign $P121, 0
    set $I101, $P121
    find_lex $P2547, "@name"
    unless_null $P2547, vivify_1837
    $P2547 = root_new ['parrot';'ResizablePMCArray']
  vivify_1837:
    set $P122, $P2547[$I101]
    unless_null $P122, vivify_1838
    new $P122, "Undef"
  vivify_1838:
    store_lex "$final_name", $P122
.annotate 'line', 2713
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2548, $P123["@BLOCK"]
    unless_null $P2548, vivify_1839
    $P2548 = root_new ['parrot';'ResizablePMCArray']
  vivify_1839:
    defined $I101, $P2548
    unless $I101, for_undef_1840
    iter $P121, $P2548
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2559_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2559_test:
    unless $P121, loop2559_done
    shift $P124, $P121
  loop2559_redo:
    .const 'Sub' $P2550 = "469_1321350766.1143" 
    capture_lex $P2550
    $P2550($P124)
  loop2559_next:
    goto loop2559_test
  loop2559_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2559_next
    eq $P128, .CONTROL_LOOP_REDO, loop2559_redo
  loop2559_done:
    pop_eh 
  for_undef_1840:
.annotate 'line', 2711
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2549"  :anon :subid("469_1321350766.1143") :outer("468_1321350766.1143")
    .param pmc param_2553
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2714
    $P2552 = root_new ['parrot';'Hash']
    set $P2551, $P2552
    .lex "%sym", $P2551
    .lex "$_", param_2553
    find_lex $P125, "$_"
    unless_null $P125, vivify_1841
    new $P125, "Undef"
  vivify_1841:
    find_lex $P127, "$final_name"
    unless_null $P127, vivify_1842
    new $P127, "Undef"
  vivify_1842:
    $P128 = $P125."symbol"($P127)
    store_lex "%sym", $P128
.annotate 'line', 2715
    find_lex $P2555, "%sym"
    unless_null $P2555, vivify_1843
    $P2555 = root_new ['parrot';'Hash']
  vivify_1843:
    set $N102, $P2555
    if $N102, if_2554
    new $P125, 'Float'
    set $P125, $N102
    goto if_2554_end
  if_2554:
.annotate 'line', 2716
    find_lex $P2557, "%sym"
    unless_null $P2557, vivify_1844
    $P2557 = root_new ['parrot';'Hash']
  vivify_1844:
    exists $I102, $P2557["value"]
    if $I102, if_2556
.annotate 'line', 2720
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$final_name"
    unless_null $P129, vivify_1845
    new $P129, "Undef"
  vivify_1845:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2719
    goto if_2556_end
  if_2556:
.annotate 'line', 2717
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    find_lex $P2558, "%sym"
    unless_null $P2558, vivify_1846
    $P2558 = root_new ['parrot';'Hash']
  vivify_1846:
    set $P129, $P2558["value"]
    unless_null $P129, vivify_1847
    new $P129, "Undef"
  vivify_1847:
    setattribute $P128, 'payload', $P129
    throw $P128
  if_2556_end:
.annotate 'line', 2715
    set $P125, $P127
  if_2554_end:
.annotate 'line', 2713
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2562"  :anon :subid("470_1321350766.1143") :outer("467_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2730
    .const 'Sub' $P2568 = "471_1321350766.1143" 
    capture_lex $P2568
.annotate 'line', 2731
    new $P120, "Undef"
    set $P2564, $P120
    .lex "$first", $P2564
    new $P121, "Float"
    assign $P121, 0
    set $I101, $P121
    find_lex $P2565, "@name"
    unless_null $P2565, vivify_1851
    $P2565 = root_new ['parrot';'ResizablePMCArray']
  vivify_1851:
    set $P122, $P2565[$I101]
    unless_null $P122, vivify_1852
    new $P122, "Undef"
  vivify_1852:
    store_lex "$first", $P122
.annotate 'line', 2732
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2566, $P123["@BLOCK"]
    unless_null $P2566, vivify_1853
    $P2566 = root_new ['parrot';'ResizablePMCArray']
  vivify_1853:
    defined $I101, $P2566
    unless $I101, for_undef_1854
    iter $P121, $P2566
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2578_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2578_test:
    unless $P121, loop2578_done
    shift $P124, $P121
  loop2578_redo:
    .const 'Sub' $P2568 = "471_1321350766.1143" 
    capture_lex $P2568
    $P2568($P124)
  loop2578_next:
    goto loop2578_test
  loop2578_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2578_next
    eq $P128, .CONTROL_LOOP_REDO, loop2578_redo
  loop2578_done:
    pop_eh 
  for_undef_1854:
.annotate 'line', 2730
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2567"  :anon :subid("471_1321350766.1143") :outer("470_1321350766.1143")
    .param pmc param_2571
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2733
    $P2570 = root_new ['parrot';'Hash']
    set $P2569, $P2570
    .lex "%sym", $P2569
    .lex "$_", param_2571
    find_lex $P125, "$_"
    unless_null $P125, vivify_1855
    new $P125, "Undef"
  vivify_1855:
    find_lex $P127, "$first"
    unless_null $P127, vivify_1856
    new $P127, "Undef"
  vivify_1856:
    $P128 = $P125."symbol"($P127)
    store_lex "%sym", $P128
.annotate 'line', 2734
    find_lex $P2573, "%sym"
    unless_null $P2573, vivify_1857
    $P2573 = root_new ['parrot';'Hash']
  vivify_1857:
    set $N102, $P2573
    if $N102, if_2572
    new $P125, 'Float'
    set $P125, $N102
    goto if_2572_end
  if_2572:
.annotate 'line', 2735
    find_lex $P2575, "%sym"
    unless_null $P2575, vivify_1858
    $P2575 = root_new ['parrot';'Hash']
  vivify_1858:
    exists $I102, $P2575["value"]
    if $I102, if_2574
.annotate 'line', 2741
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$first"
    unless_null $P129, vivify_1859
    new $P129, "Undef"
  vivify_1859:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2740
    goto if_2574_end
  if_2574:
.annotate 'line', 2736
    find_lex $P2576, "%sym"
    unless_null $P2576, vivify_1860
    $P2576 = root_new ['parrot';'Hash']
  vivify_1860:
    set $P128, $P2576["value"]
    unless_null $P128, vivify_1861
    new $P128, "Undef"
  vivify_1861:
    store_lex "$result", $P128
.annotate 'line', 2737
    find_lex $P2577, "@name"
    unless_null $P2577, vivify_1862
    $P2577 = root_new ['parrot';'ResizablePMCArray']
  vivify_1862:
    $P2577."shift"()
.annotate 'line', 2738
    die 0, .CONTROL_LOOP_LAST
  if_2574_end:
.annotate 'line', 2734
    set $P125, $P127
  if_2572_end:
.annotate 'line', 2732
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2580"  :anon :subid("472_1321350766.1143") :outer("467_1321350766.1143")
    .param pmc param_2582
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2748
    .lex "$_", param_2582
.annotate 'line', 2749
    find_lex $P125, "$_"
    unless_null $P125, vivify_1865
    new $P125, "Undef"
  vivify_1865:
    set $S100, $P125
    find_lex $P123, "$result"
    unless_null $P123, vivify_1866
    new $P123, "Undef"
  vivify_1866:
    get_who $P124, $P123
    exists $I101, $P124[$S100]
    if $I101, if_2583
.annotate 'line', 2753
    new $P127, "String"
    assign $P127, "Could not locate compile-time value for symbol "
.annotate 'line', 2754
    find_lex $P2584, "@name"
    unless_null $P2584, vivify_1867
    $P2584 = root_new ['parrot';'ResizablePMCArray']
  vivify_1867:
    join $S101, "::", $P2584
    concat $P128, $P127, $S101
.annotate 'line', 2753
    die $P128
.annotate 'line', 2752
    goto if_2583_end
  if_2583:
.annotate 'line', 2750
    find_lex $P127, "$_"
    unless_null $P127, vivify_1868
    new $P127, "Undef"
  vivify_1868:
    find_lex $P128, "$result"
    unless_null $P128, vivify_1869
    new $P128, "Undef"
  vivify_1869:
    get_who $P129, $P128
    set $P130, $P129[$P127]
    unless_null $P130, vivify_1870
    new $P130, "Undef"
  vivify_1870:
    store_lex "$result", $P130
.annotate 'line', 2749
    set $P122, $P130
  if_2583_end:
.annotate 'line', 2748
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("473_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2590
    .param pmc param_2591
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1272
    .lex "self", param_2590
    .lex "$/", param_2591
    find_lex $P122, "$/"
    find_lex $P2592, "$/"
    unless_null $P2592, vivify_1872
    $P2592 = root_new ['parrot';'Hash']
  vivify_1872:
    set $P123, $P2592["comp_unit"]
    unless_null $P123, vivify_1873
    new $P123, "Undef"
  vivify_1873:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("474_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2594
    .param pmc param_2595
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1274
    .lex "self", param_2594
    .lex "$/", param_2595
.annotate 'line', 1275
    find_lex $P122, "$/"
.annotate 'line', 1276
    find_lex $P2597, "$/"
    unless_null $P2597, vivify_1874
    $P2597 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P124, $P2597["colonpair"]
    unless_null $P124, vivify_1875
    new $P124, "Undef"
  vivify_1875:
    if $P124, if_2596
.annotate 'line', 1278
    find_lex $P139, "$/"
    unless_null $P139, vivify_1876
    new $P139, "Undef"
  vivify_1876:
    set $S103, $P139
    new $P123, 'String'
    set $P123, $S103
.annotate 'line', 1276
    goto if_2596_end
  if_2596:
    find_lex $P2598, "$/"
    unless_null $P2598, vivify_1877
    $P2598 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P125, $P2598["identifier"]
    unless_null $P125, vivify_1878
    new $P125, "Undef"
  vivify_1878:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    concat $P128, $P127, ":"
    new $P129, "Float"
    assign $P129, 0
    set $I100, $P129
    find_lex $P2599, "$/"
    unless_null $P2599, vivify_1879
    $P2599 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P2600, $P2599["colonpair"]
    unless_null $P2600, vivify_1880
    $P2600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1880:
    set $P130, $P2600[$I100]
    unless_null $P130, vivify_1881
    new $P130, "Undef"
  vivify_1881:
    $P131 = $P130."ast"()
    $S101 = $P131."named"()
    concat $P132, $P128, $S101
    concat $P133, $P132, "<"
.annotate 'line', 1277
    new $P134, "Float"
    assign $P134, 0
    set $I101, $P134
    find_lex $P2601, "$/"
    unless_null $P2601, vivify_1882
    $P2601 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P2602, $P2601["colonpair"]
    unless_null $P2602, vivify_1883
    $P2602 = root_new ['parrot';'ResizablePMCArray']
  vivify_1883:
    set $P135, $P2602[$I101]
    unless_null $P135, vivify_1884
    new $P135, "Undef"
  vivify_1884:
    $P136 = $P135."ast"()
    $S102 = "colonpair_str"($P136)
    concat $P137, $P133, $S102
    concat $P138, $P137, ">"
    set $P123, $P138
  if_2596_end:
.annotate 'line', 1276
    $P140 = $P122."!make"($P123)
.annotate 'line', 1274
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit" :anon :subid("475_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2604
    .param pmc param_2605
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1288
    .const 'Sub' $P2618 = "476_1321350766.1143" 
    capture_lex $P2618
    .lex "self", param_2604
    .lex "$/", param_2605
.annotate 'line', 1289
    new $P122, "Undef"
    set $P2606, $P122
    .lex "$mainline", $P2606
.annotate 'line', 1290
    new $P123, "Undef"
    set $P2607, $P123
    .lex "$unit", $P2607
.annotate 'line', 1313
    $P2609 = root_new ['parrot';'ResizablePMCArray']
    set $P2608, $P2609
    .lex "@loadlibs", $P2608
.annotate 'line', 1326
    new $P124, "Undef"
    set $P2610, $P124
    .lex "$main_tasks", $P2610
.annotate 'line', 1289
    find_lex $P2611, "$/"
    unless_null $P2611, vivify_1885
    $P2611 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P125, $P2611["statementlist"]
    unless_null $P125, vivify_1886
    new $P125, "Undef"
  vivify_1886:
    $P127 = $P125."ast"()
    store_lex "$mainline", $P127
.annotate 'line', 1290
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2612, $P127["@BLOCK"]
    unless_null $P2612, vivify_1887
    $P2612 = root_new ['parrot';'ResizablePMCArray']
  vivify_1887:
    $P128 = $P2612."shift"()
    store_lex "$unit", $P128
.annotate 'line', 1294
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1888
    new $P125, "Undef"
  vivify_1888:
    $P127 = $P125."loadinit"()
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_1889
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_1890
    die "Contextual $*SC not found"
  vivify_1890:
  vivify_1889:
    $P131 = $P130."to_past"()
    $P127."push"($P131)
.annotate 'line', 1299
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1891
    new $P125, "Undef"
  vivify_1891:
    $P127 = $P125."loadinit"()
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
.annotate 'line', 1301
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    new $P136, "ResizablePMCArray"
    $P137 = $P135."new"("GLOBAL" :named("name"), $P136 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1302
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_1892
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_1893
    die "Contextual $*SC not found"
  vivify_1893:
  vivify_1892:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_1894
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_1895
    die "Contextual $*PACKAGE not found"
  vivify_1895:
  vivify_1894:
    $P144 = $P140."get_slot_past_for_object"($P143)
    $P145 = $P131."new"($P137, $P144, "bind_6model" :named("pasttype"))
.annotate 'line', 1299
    $P127."push"($P145)
.annotate 'line', 1308
    find_dynamic_lex $P128, "$*HAS_YOU_ARE_HERE"
    unless_null $P128, vivify_1896
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$HAS_YOU_ARE_HERE"]
    unless_null $P128, vivify_1897
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1897:
  vivify_1896:
    if $P128, unless_2613_end
.annotate 'line', 1309
    find_lex $P129, "$unit"
    unless_null $P129, vivify_1898
    new $P129, "Undef"
  vivify_1898:
    find_lex $P130, "self"
    $P131 = $P130."CTXSAVE"()
    $P129."push"($P131)
  unless_2613_end:
.annotate 'line', 1313
    new $P125, "ResizablePMCArray"
    push $P125, "nqp_group"
    push $P125, "nqp_ops"
    push $P125, "nqp_bigint_ops"
    push $P125, "trans_ops"
    push $P125, "io_ops"
    store_lex "@loadlibs", $P125
.annotate 'line', 1314
    find_dynamic_lex $P128, "%*COMPILING"
    unless_null $P128, vivify_1899
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%COMPILING"]
    unless_null $P128, vivify_1900
    die "Contextual %*COMPILING not found"
  vivify_1900:
  vivify_1899:
    set $P2615, $P128["%?OPTIONS"]
    unless_null $P2615, vivify_1901
    $P2615 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P129, $P2615["vmlibs"]
    unless_null $P129, vivify_1902
    new $P129, "Undef"
  vivify_1902:
    unless $P129, if_2614_end
.annotate 'line', 1315
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_1903
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_1904
    die "Contextual %*COMPILING not found"
  vivify_1904:
  vivify_1903:
    set $P2616, $P133["%?OPTIONS"]
    unless_null $P2616, vivify_1905
    $P2616 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P134, $P2616["vmlibs"]
    unless_null $P134, vivify_1906
    new $P134, "Undef"
  vivify_1906:
    set $S100, $P134
    split $P135, ",", $S100
    defined $I100, $P135
    unless $I100, for_undef_1907
    iter $P130, $P135
    new $P137, 'ExceptionHandler'
    set_label $P137, loop2621_handler
    $P137."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P137
  loop2621_test:
    unless $P130, loop2621_done
    shift $P136, $P130
  loop2621_redo:
    .const 'Sub' $P2618 = "476_1321350766.1143" 
    capture_lex $P2618
    $P2618($P136)
  loop2621_next:
    goto loop2621_test
  loop2621_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P139, exception, 'type'
    eq $P139, .CONTROL_LOOP_NEXT, loop2621_next
    eq $P139, .CONTROL_LOOP_REDO, loop2621_redo
  loop2621_done:
    pop_eh 
  for_undef_1907:
  if_2614_end:
.annotate 'line', 1319
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1910
    new $P125, "Undef"
  vivify_1910:
    find_lex $P2622, "@loadlibs"
    unless_null $P2622, vivify_1911
    $P2622 = root_new ['parrot';'ResizablePMCArray']
  vivify_1911:
    $P125."loadlibs"($P2622 :flat)
.annotate 'line', 1325
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1912
    new $P125, "Undef"
  vivify_1912:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P125."unshift"($P131)
.annotate 'line', 1326
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
.annotate 'line', 1327
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    $P134 = $P133."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1328
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1330
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
    new $P143, "ResizablePMCArray"
    $P144 = $P142."new"("ModuleLoader" :named("name"), $P143 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1331
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Var"]
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Op"]
    $P154 = $P153."new"("getinterp P" :named("pirop"))
    $P155 = $P148."new"($P154, "context", "keyed" :named("scope"))
    $P156 = $P138."new"($P144, $P155, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1328
    $P157 = $P129."new"($P134, $P156)
.annotate 'line', 1326
    store_lex "$main_tasks", $P157
.annotate 'line', 1334
    find_dynamic_lex $P128, "$*MAIN_SUB"
    unless_null $P128, vivify_1913
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$MAIN_SUB"]
    unless_null $P128, vivify_1914
    die "Contextual $*MAIN_SUB not found"
  vivify_1914:
  vivify_1913:
    unless $P128, if_2623_end
.annotate 'line', 1335
    find_lex $P129, "$main_tasks"
    unless_null $P129, vivify_1915
    new $P129, "Undef"
  vivify_1915:
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 1336
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "PAST"
    get_who $P136, $P135
    set $P137, $P136["Val"]
    find_dynamic_lex $P140, "$*MAIN_SUB"
    unless_null $P140, vivify_1916
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MAIN_SUB"]
    unless_null $P140, vivify_1917
    die "Contextual $*MAIN_SUB not found"
  vivify_1917:
  vivify_1916:
    $P141 = $P137."new"($P140 :named("value"))
.annotate 'line', 1337
    get_hll_global $P142, "GLOBAL"
    nqp_get_package_through_who $P143, $P142, "PAST"
    get_who $P144, $P143
    set $P145, $P144["Var"]
    $P146 = $P145."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P147 = $P133."new"($P141, $P146, "call" :named("pasttype"))
.annotate 'line', 1335
    $P129."push"($P147)
  if_2623_end:
.annotate 'line', 1340
    find_lex $P125, "$mainline"
    unless_null $P125, vivify_1918
    new $P125, "Undef"
  vivify_1918:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
.annotate 'line', 1342
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    $P135 = $P134."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P136, "$main_tasks"
    unless_null $P136, vivify_1919
    new $P136, "Undef"
  vivify_1919:
    $P137 = $P130."new"($P135, $P136, "if" :named("pasttype"))
.annotate 'line', 1340
    $P125."push"($P137)
.annotate 'line', 1349
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1920
    new $P125, "Undef"
  vivify_1920:
.annotate 'line', 1350
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    find_lex $P131, "$mainline"
    unless_null $P131, vivify_1921
    new $P131, "Undef"
  vivify_1921:
    $P132 = $P130."new"($P131, "return" :named("pirop"))
    $P125."push"($P132)
.annotate 'line', 1355
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1922
    new $P125, "Undef"
  vivify_1922:
.annotate 'line', 1356
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Block"]
.annotate 'line', 1358
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Op"]
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Val"]
    find_lex $P139, "$unit"
    unless_null $P139, vivify_1923
    new $P139, "Undef"
  vivify_1923:
    $P140 = $P138."new"($P139 :named("value"))
    $P141 = $P134."new"($P140, "call" :named("pasttype"))
    $P142 = $P130."new"($P141, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1356
    $P125."push"($P142)
.annotate 'line', 1361
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1924
    new $P125, "Undef"
  vivify_1924:
    find_lex $P127, "$/"
    unless_null $P127, vivify_1925
    new $P127, "Undef"
  vivify_1925:
    $P125."node"($P127)
.annotate 'line', 1364
    find_lex $P125, "$unit"
    unless_null $P125, vivify_1926
    new $P125, "Undef"
  vivify_1926:
    $P125."hll"("nqp")
.annotate 'line', 1366
    find_lex $P125, "$/"
    find_lex $P127, "$unit"
    unless_null $P127, vivify_1927
    new $P127, "Undef"
  vivify_1927:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1288
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2617"  :anon :subid("476_1321350766.1143") :outer("475_1321350766.1143")
    .param pmc param_2619
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1315
    .lex "$_", param_2619
.annotate 'line', 1316
    find_lex $P2620, "@loadlibs"
    unless_null $P2620, vivify_1908
    $P2620 = root_new ['parrot';'ResizablePMCArray']
  vivify_1908:
    find_lex $P137, "$_"
    unless_null $P137, vivify_1909
    new $P137, "Undef"
  vivify_1909:
    $P138 = $P2620."push"($P137)
.annotate 'line', 1315
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("477_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2625
    .param pmc param_2626
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1369
    .const 'Sub' $P2632 = "478_1321350766.1143" 
    capture_lex $P2632
    .lex "self", param_2625
    .lex "$/", param_2626
.annotate 'line', 1370
    new $P122, "Undef"
    set $P2627, $P122
    .lex "$past", $P2627
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_1928
    new $P128, "Undef"
  vivify_1928:
    $P129 = $P127."new"($P128 :named("node"))
    store_lex "$past", $P129
.annotate 'line', 1371
    find_lex $P2629, "$/"
    unless_null $P2629, vivify_1929
    $P2629 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P123, $P2629["statement"]
    unless_null $P123, vivify_1930
    new $P123, "Undef"
  vivify_1930:
    unless $P123, if_2628_end
.annotate 'line', 1372
    find_lex $P2630, "$/"
    unless_null $P2630, vivify_1931
    $P2630 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P125, $P2630["statement"]
    unless_null $P125, vivify_1932
    new $P125, "Undef"
  vivify_1932:
    defined $I100, $P125
    unless $I100, for_undef_1933
    iter $P124, $P125
    new $P129, 'ExceptionHandler'
    set_label $P129, loop2641_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop2641_test:
    unless $P124, loop2641_done
    shift $P127, $P124
  loop2641_redo:
    .const 'Sub' $P2632 = "478_1321350766.1143" 
    capture_lex $P2632
    $P2632($P127)
  loop2641_next:
    goto loop2641_test
  loop2641_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop2641_next
    eq $P130, .CONTROL_LOOP_REDO, loop2641_redo
  loop2641_done:
    pop_eh 
  for_undef_1933:
  if_2628_end:
.annotate 'line', 1380
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_1946
    new $P124, "Undef"
  vivify_1946:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1369
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2631"  :anon :subid("478_1321350766.1143") :outer("477_1321350766.1143")
    .param pmc param_2634
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1373
    new $P128, "Undef"
    set $P2633, $P128
    .lex "$ast", $P2633
    .lex "$_", param_2634
    find_lex $P129, "$_"
    unless_null $P129, vivify_1934
    new $P129, "Undef"
  vivify_1934:
    $P130 = $P129."ast"()
    store_lex "$ast", $P130
.annotate 'line', 1374
    find_lex $P2636, "$ast"
    unless_null $P2636, vivify_1935
    $P2636 = root_new ['parrot';'Hash']
  vivify_1935:
    set $P129, $P2636["sink"]
    unless_null $P129, vivify_1936
    new $P129, "Undef"
  vivify_1936:
    defined $I101, $P129
    unless $I101, if_2635_end
    find_lex $P2637, "$ast"
    unless_null $P2637, vivify_1937
    $P2637 = root_new ['parrot';'Hash']
  vivify_1937:
    set $P130, $P2637["sink"]
    unless_null $P130, vivify_1938
    new $P130, "Undef"
  vivify_1938:
    store_lex "$ast", $P130
  if_2635_end:
.annotate 'line', 1375
    find_lex $P2639, "$ast"
    unless_null $P2639, vivify_1939
    $P2639 = root_new ['parrot';'Hash']
  vivify_1939:
    set $P129, $P2639["bareblock"]
    unless_null $P129, vivify_1940
    new $P129, "Undef"
  vivify_1940:
    unless $P129, if_2638_end
    find_lex $P130, "$ast"
    unless_null $P130, vivify_1941
    new $P130, "Undef"
  vivify_1941:
    $P131 = "block_immediate"($P130)
    store_lex "$ast", $P131
  if_2638_end:
.annotate 'line', 1376
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Node"]
    find_lex $P133, "$ast"
    unless_null $P133, vivify_1942
    new $P133, "Undef"
  vivify_1942:
    $P134 = $P132."ACCEPTS"($P133)
    unless $P134, if_2640_end
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Stmt"]
    find_lex $P139, "$ast"
    unless_null $P139, vivify_1943
    new $P139, "Undef"
  vivify_1943:
    $P140 = $P138."new"($P139)
    store_lex "$ast", $P140
  if_2640_end:
.annotate 'line', 1377
    find_lex $P129, "$past"
    unless_null $P129, vivify_1944
    new $P129, "Undef"
  vivify_1944:
    find_lex $P130, "$ast"
    unless_null $P130, vivify_1945
    new $P130, "Undef"
  vivify_1945:
    $P131 = $P129."push"($P130)
.annotate 'line', 1372
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("479_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2643
    .param pmc param_2644
    .param pmc param_2645 :optional
    .param int has_param_2645 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1383
    .const 'Sub' $P2650 = "480_1321350766.1143" 
    capture_lex $P2650
    .lex "self", param_2643
    .lex "$/", param_2644
    if has_param_2645, optparam_1947
    new $P122, "Undef"
    set param_2645, $P122
  optparam_1947:
    .lex "$key", param_2645
.annotate 'line', 1384
    new $P123, "Undef"
    set $P2646, $P123
    .lex "$past", $P2646
.annotate 'line', 1383
    find_lex $P124, "$past"
    unless_null $P124, vivify_1948
    new $P124, "Undef"
  vivify_1948:
.annotate 'line', 1385
    find_lex $P2648, "$/"
    unless_null $P2648, vivify_1949
    $P2648 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P124, $P2648["EXPR"]
    unless_null $P124, vivify_1950
    new $P124, "Undef"
  vivify_1950:
    if $P124, if_2647
.annotate 'line', 1406
    find_lex $P2669, "$/"
    unless_null $P2669, vivify_1951
    $P2669 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P129, $P2669["statement_control"]
    unless_null $P129, vivify_1952
    new $P129, "Undef"
  vivify_1952:
    if $P129, if_2668
.annotate 'line', 1407
    new $P130, "Float"
    assign $P130, 0
    store_lex "$past", $P130
    goto if_2668_end
  if_2668:
.annotate 'line', 1406
    find_lex $P2670, "$/"
    unless_null $P2670, vivify_1953
    $P2670 = root_new ['parrot';'Hash']
  vivify_1953:
    set $P130, $P2670["statement_control"]
    unless_null $P130, vivify_1954
    new $P130, "Undef"
  vivify_1954:
    $P131 = $P130."ast"()
    store_lex "$past", $P131
  if_2668_end:
    goto if_2647_end
  if_2647:
.annotate 'line', 1385
    .const 'Sub' $P2650 = "480_1321350766.1143" 
    capture_lex $P2650
    $P2650()
  if_2647_end:
.annotate 'line', 1408
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_1988
    new $P125, "Undef"
  vivify_1988:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1383
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2649"  :anon :subid("480_1321350766.1143") :outer("479_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1386
    new $P125, "Undef"
    set $P2651, $P125
    .lex "$mc", $P2651
.annotate 'line', 1387
    new $P127, "Undef"
    set $P2652, $P127
    .lex "$ml", $P2652
.annotate 'line', 1386
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P2653, "$/"
    unless_null $P2653, vivify_1955
    $P2653 = root_new ['parrot';'Hash']
  vivify_1955:
    set $P2654, $P2653["statement_mod_cond"]
    unless_null $P2654, vivify_1956
    $P2654 = root_new ['parrot';'ResizablePMCArray']
  vivify_1956:
    set $P129, $P2654[$I100]
    unless_null $P129, vivify_1957
    new $P129, "Undef"
  vivify_1957:
    store_lex "$mc", $P129
.annotate 'line', 1387
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P2655, "$/"
    unless_null $P2655, vivify_1958
    $P2655 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P2656, $P2655["statement_mod_loop"]
    unless_null $P2656, vivify_1959
    $P2656 = root_new ['parrot';'ResizablePMCArray']
  vivify_1959:
    set $P129, $P2656[$I100]
    unless_null $P129, vivify_1960
    new $P129, "Undef"
  vivify_1960:
    store_lex "$ml", $P129
.annotate 'line', 1388
    find_lex $P2657, "$/"
    unless_null $P2657, vivify_1961
    $P2657 = root_new ['parrot';'Hash']
  vivify_1961:
    set $P128, $P2657["EXPR"]
    unless_null $P128, vivify_1962
    new $P128, "Undef"
  vivify_1962:
    $P129 = $P128."ast"()
    store_lex "$past", $P129
.annotate 'line', 1389
    find_lex $P128, "$mc"
    unless_null $P128, vivify_1963
    new $P128, "Undef"
  vivify_1963:
    unless $P128, if_2658_end
.annotate 'line', 1390
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P2659, "$mc"
    unless_null $P2659, vivify_1964
    $P2659 = root_new ['parrot';'Hash']
  vivify_1964:
    set $P133, $P2659["cond"]
    unless_null $P133, vivify_1965
    new $P133, "Undef"
  vivify_1965:
    $P134 = $P133."ast"()
    find_lex $P135, "$past"
    unless_null $P135, vivify_1966
    new $P135, "Undef"
  vivify_1966:
    find_lex $P2660, "$mc"
    unless_null $P2660, vivify_1967
    $P2660 = root_new ['parrot';'Hash']
  vivify_1967:
    set $P136, $P2660["sym"]
    unless_null $P136, vivify_1968
    new $P136, "Undef"
  vivify_1968:
    set $S100, $P136
    find_lex $P137, "$/"
    unless_null $P137, vivify_1969
    new $P137, "Undef"
  vivify_1969:
    $P138 = $P132."new"($P134, $P135, $S100 :named("pasttype"), $P137 :named("node"))
    store_lex "$past", $P138
  if_2658_end:
.annotate 'line', 1392
    find_lex $P129, "$ml"
    unless_null $P129, vivify_1970
    new $P129, "Undef"
  vivify_1970:
    if $P129, if_2661
    set $P128, $P129
    goto if_2661_end
  if_2661:
.annotate 'line', 1393
    find_lex $P2663, "$ml"
    unless_null $P2663, vivify_1971
    $P2663 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P131, $P2663["sym"]
    unless_null $P131, vivify_1972
    new $P131, "Undef"
  vivify_1972:
    set $S100, $P131
    iseq $I100, $S100, "for"
    if $I100, if_2662
.annotate 'line', 1402
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    find_lex $P2666, "$ml"
    unless_null $P2666, vivify_1973
    $P2666 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P136, $P2666["cond"]
    unless_null $P136, vivify_1974
    new $P136, "Undef"
  vivify_1974:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1975
    new $P138, "Undef"
  vivify_1975:
    find_lex $P2667, "$ml"
    unless_null $P2667, vivify_1976
    $P2667 = root_new ['parrot';'Hash']
  vivify_1976:
    set $P139, $P2667["sym"]
    unless_null $P139, vivify_1977
    new $P139, "Undef"
  vivify_1977:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1978
    new $P140, "Undef"
  vivify_1978:
    $P142 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P142
.annotate 'line', 1401
    set $P130, $P142
.annotate 'line', 1393
    goto if_2662_end
  if_2662:
.annotate 'line', 1394
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Block"]
.annotate 'line', 1395
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    $P140 = $P139."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P141, "$past"
    unless_null $P141, vivify_1979
    new $P141, "Undef"
  vivify_1979:
    $P142 = $P135."new"($P140, $P141, "immediate" :named("blocktype"))
.annotate 'line', 1394
    store_lex "$past", $P142
.annotate 'line', 1397
    find_lex $P132, "$past"
    unless_null $P132, vivify_1980
    new $P132, "Undef"
  vivify_1980:
    $P132."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1398
    find_lex $P132, "$past"
    unless_null $P132, vivify_1981
    new $P132, "Undef"
  vivify_1981:
    $P132."arity"(1)
.annotate 'line', 1399
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    find_lex $P2664, "$ml"
    unless_null $P2664, vivify_1982
    $P2664 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P136, $P2664["cond"]
    unless_null $P136, vivify_1983
    new $P136, "Undef"
  vivify_1983:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1984
    new $P138, "Undef"
  vivify_1984:
    find_lex $P2665, "$ml"
    unless_null $P2665, vivify_1985
    $P2665 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P139, $P2665["sym"]
    unless_null $P139, vivify_1986
    new $P139, "Undef"
  vivify_1986:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1987
    new $P140, "Undef"
  vivify_1987:
    $P141 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P141
.annotate 'line', 1393
    set $P130, $P141
  if_2662_end:
.annotate 'line', 1392
    set $P128, $P130
  if_2661_end:
.annotate 'line', 1385
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("481_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2672
    .param pmc param_2673
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1411
    .lex "self", param_2672
    .lex "$/", param_2673
.annotate 'line', 1412
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P2674, "$/"
    unless_null $P2674, vivify_1989
    $P2674 = root_new ['parrot';'Hash']
  vivify_1989:
    set $P128, $P2674["EXPR"]
    unless_null $P128, vivify_1990
    new $P128, "Undef"
  vivify_1990:
    $P129 = $P128."ast"()
    find_lex $P2675, "$/"
    unless_null $P2675, vivify_1991
    $P2675 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P130, $P2675["pblock"]
    unless_null $P130, vivify_1992
    new $P130, "Undef"
  vivify_1992:
    $P131 = $P130."ast"()
    find_lex $P132, "$/"
    unless_null $P132, vivify_1993
    new $P132, "Undef"
  vivify_1993:
    $P133 = $P127."new"($P129, $P131, "if" :named("pasttype"), $P132 :named("node"))
    $P134 = $P122."!make"($P133)
.annotate 'line', 1411
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("482_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2677
    .param pmc param_2678
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1415
    .lex "self", param_2677
    .lex "$/", param_2678
.annotate 'line', 1416
    find_lex $P122, "$/"
    find_lex $P2679, "$/"
    unless_null $P2679, vivify_1994
    $P2679 = root_new ['parrot';'Hash']
  vivify_1994:
    set $P123, $P2679["blockoid"]
    unless_null $P123, vivify_1995
    new $P123, "Undef"
  vivify_1995:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1415
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("483_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2681
    .param pmc param_2682
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1419
    .lex "self", param_2681
    .lex "$/", param_2682
.annotate 'line', 1420
    find_lex $P122, "$/"
    find_lex $P2683, "$/"
    unless_null $P2683, vivify_1996
    $P2683 = root_new ['parrot';'Hash']
  vivify_1996:
    set $P123, $P2683["blockoid"]
    unless_null $P123, vivify_1997
    new $P123, "Undef"
  vivify_1997:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1419
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("484_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2685
    .param pmc param_2686
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1423
    .const 'Sub' $P2692 = "485_1321350766.1143" 
    capture_lex $P2692
    .lex "self", param_2685
    .lex "$/", param_2686
.annotate 'line', 1424
    new $P122, "Undef"
    set $P2687, $P122
    .lex "$BLOCK", $P2687
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2688, $P124["@BLOCK"]
    unless_null $P2688, vivify_1998
    $P2688 = root_new ['parrot';'ResizablePMCArray']
  vivify_1998:
    $P125 = $P2688."shift"()
    store_lex "$BLOCK", $P125
.annotate 'line', 1425
    find_lex $P2690, "$/"
    unless_null $P2690, vivify_1999
    $P2690 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P124, $P2690["statementlist"]
    unless_null $P124, vivify_2000
    new $P124, "Undef"
  vivify_2000:
    if $P124, if_2689
.annotate 'line', 1433
    find_dynamic_lex $P131, "$*HAS_YOU_ARE_HERE"
    unless_null $P131, vivify_2001
    get_hll_global $P128, "GLOBAL"
    get_who $P130, $P128
    set $P131, $P130["$HAS_YOU_ARE_HERE"]
    unless_null $P131, vivify_2002
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_2002:
  vivify_2001:
    unless $P131, if_2695_end
.annotate 'line', 1434
    find_lex $P132, "$/"
    unless_null $P132, vivify_2003
    new $P132, "Undef"
  vivify_2003:
    $P133 = $P132."CURSOR"()
    $P133."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_2695_end:
.annotate 'line', 1436
    new $P128, "Float"
    assign $P128, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P128
.annotate 'line', 1437
    find_lex $P128, "$/"
    find_lex $P2696, "$/"
    unless_null $P2696, vivify_2004
    $P2696 = root_new ['parrot';'Hash']
  vivify_2004:
    set $P130, $P2696["you_are_here"]
    unless_null $P130, vivify_2005
    new $P130, "Undef"
  vivify_2005:
    $P131 = $P130."ast"()
    $P132 = $P128."!make"($P131)
.annotate 'line', 1432
    set $P123, $P132
.annotate 'line', 1425
    goto if_2689_end
  if_2689:
    .const 'Sub' $P2692 = "485_1321350766.1143" 
    capture_lex $P2692
    $P127 = $P2692()
    set $P123, $P127
  if_2689_end:
.annotate 'line', 1423
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2691"  :anon :subid("485_1321350766.1143") :outer("484_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1426
    new $P125, "Undef"
    set $P2693, $P125
    .lex "$past", $P2693
    find_lex $P2694, "$/"
    unless_null $P2694, vivify_2006
    $P2694 = root_new ['parrot';'Hash']
  vivify_2006:
    set $P127, $P2694["statementlist"]
    unless_null $P127, vivify_2007
    new $P127, "Undef"
  vivify_2007:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 1427
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2008
    new $P127, "Undef"
  vivify_2008:
    find_lex $P128, "$past"
    unless_null $P128, vivify_2009
    new $P128, "Undef"
  vivify_2009:
    $P127."push"($P128)
.annotate 'line', 1428
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2010
    new $P127, "Undef"
  vivify_2010:
    find_lex $P128, "$/"
    unless_null $P128, vivify_2011
    new $P128, "Undef"
  vivify_2011:
    $P127."node"($P128)
.annotate 'line', 1429
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2012
    new $P127, "Undef"
  vivify_2012:
    $P127."closure"(1)
.annotate 'line', 1430
    find_dynamic_lex $P127, "$/"
    find_lex $P128, "$BLOCK"
    unless_null $P128, vivify_2013
    new $P128, "Undef"
  vivify_2013:
    $P129 = $P127."!make"($P128)
.annotate 'line', 1425
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("486_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2698
    .param pmc param_2699
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1441
    .lex "self", param_2698
    .lex "$/", param_2699
.annotate 'line', 1442
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2700, $P123["@BLOCK"]
    unless_null $P2700, vivify_2014
    $P2700 = root_new ['parrot';'ResizablePMCArray']
  vivify_2014:
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Block"]
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Stmts"]
    $P133 = $P132."new"()
    $P134 = $P128."new"($P133)
    $P135 = $P2700."unshift"($P134)
.annotate 'line', 1441
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("487_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2702
    .param pmc param_2703
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1445
    .const 'Sub' $P2707 = "488_1321350766.1143" 
    capture_lex $P2707
    .lex "self", param_2702
    .lex "$/", param_2703
.annotate 'line', 1446
    find_dynamic_lex $P124, "%*COMPILING"
    unless_null $P124, vivify_2015
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%COMPILING"]
    unless_null $P124, vivify_2016
    die "Contextual %*COMPILING not found"
  vivify_2016:
  vivify_2015:
    set $P2705, $P124["%?OPTIONS"]
    unless_null $P2705, vivify_2017
    $P2705 = root_new ['parrot';'Hash']
  vivify_2017:
    set $P125, $P2705["outer_ctx"]
    unless_null $P125, vivify_2018
    new $P125, "Undef"
  vivify_2018:
    defined $I100, $P125
    if $I100, unless_2704_end
    .const 'Sub' $P2707 = "488_1321350766.1143" 
    capture_lex $P2707
    $P2707()
  unless_2704_end:
.annotate 'line', 1459
    find_lex $P122, "self"
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    find_lex $P124, "$?PACKAGE"
    get_who $P125, $P124
    set $P2715, $P125["@BLOCK"]
    unless_null $P2715, vivify_2034
    $P2715 = root_new ['parrot';'ResizablePMCArray']
  vivify_2034:
    set $P127, $P2715[$I100]
    unless_null $P127, vivify_2035
    new $P127, "Undef"
  vivify_2035:
    $P128 = $P122."SET_BLOCK_OUTER_CTX"($P127)
.annotate 'line', 1445
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2706"  :anon :subid("488_1321350766.1143") :outer("487_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1449
    new $P127, "Undef"
    set $P2708, $P127
    .lex "$SETTING", $P2708
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_2019
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_2020
    die "Contextual $*SC not found"
  vivify_2020:
  vivify_2019:
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_2021
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_2022
    die "Contextual %*COMPILING not found"
  vivify_2022:
  vivify_2021:
    set $P2710, $P133["%?OPTIONS"]
    unless_null $P2710, vivify_2023
    $P2710 = root_new ['parrot';'Hash']
  vivify_2023:
    set $P134, $P2710["setting"]
    unless_null $P134, vivify_2024
    new $P134, "Undef"
  vivify_2024:
    set $P2709, $P134
    defined $I2712, $P2709
    if $I2712, default_2711
    new $P135, "String"
    assign $P135, "NQPCORE"
    set $P2709, $P135
  default_2711:
    $P136 = $P130."load_setting"($P2709)
    store_lex "$SETTING", $P136
.annotate 'line', 1454
    find_dynamic_lex $P131, "%*COMPILING"
    unless_null $P131, vivify_2025
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%COMPILING"]
    unless_null $P131, vivify_2026
    die "Contextual %*COMPILING not found"
  vivify_2026:
  vivify_2025:
    set $P2714, $P131["%?OPTIONS"]
    unless_null $P2714, vivify_2027
    $P2714 = root_new ['parrot';'Hash']
  vivify_2027:
    set $P132, $P2714["setting"]
    unless_null $P132, vivify_2028
    new $P132, "Undef"
  vivify_2028:
    set $S100, $P132
    iseq $I101, $S100, "NULL"
    unless $I101, unless_2713
    new $P128, 'Integer'
    set $P128, $I101
    goto unless_2713_end
  unless_2713:
.annotate 'line', 1455
    find_lex $P133, "$SETTING"
    unless_null $P133, vivify_2029
    new $P133, "Undef"
  vivify_2029:
    "import_HOW_exports"($P133)
.annotate 'line', 1456
    find_dynamic_lex $P135, "$*SC"
    unless_null $P135, vivify_2030
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SC"]
    unless_null $P135, vivify_2031
    die "Contextual $*SC not found"
  vivify_2031:
  vivify_2030:
    find_dynamic_lex $P138, "$*GLOBALish"
    unless_null $P138, vivify_2032
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$GLOBALish"]
    unless_null $P138, vivify_2033
    die "Contextual $*GLOBALish not found"
  vivify_2033:
  vivify_2032:
    $P139 = $P135."load_module"("NQPRegex", $P138)
.annotate 'line', 1454
    set $P128, $P139
  unless_2713_end:
.annotate 'line', 1446
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("489_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2717
    .param pmc param_2718
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1471
    .lex "self", param_2717
    .lex "$/", param_2718
.annotate 'line', 1475
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2036
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2037
    die "Contextual $*SC not found"
  vivify_2037:
  vivify_2036:
    find_dynamic_lex $P128, "%*HOW"
    unless_null $P128, vivify_2038
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%HOW"]
    unless_null $P128, vivify_2039
    die "Contextual %*HOW not found"
  vivify_2039:
  vivify_2038:
    set $P129, $P128["knowhow"]
    unless_null $P129, vivify_2040
    new $P129, "Undef"
  vivify_2040:
    $P130 = $P124."pkg_create_mo"($P129, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P130
.annotate 'line', 1476
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2041
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2042
    die "Contextual $*GLOBALish not found"
  vivify_2042:
  vivify_2041:
    get_how $P125, $P124
    find_dynamic_lex $P129, "$*GLOBALish"
    unless_null $P129, vivify_2043
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$GLOBALish"]
    unless_null $P129, vivify_2044
    die "Contextual $*GLOBALish not found"
  vivify_2044:
  vivify_2043:
    $P125."compose"($P129)
.annotate 'line', 1477
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2045
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2046
    die "Contextual $*SC not found"
  vivify_2046:
  vivify_2045:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P2719, $P128["@BLOCK"]
    unless_null $P2719, vivify_2047
    $P2719 = root_new ['parrot';'ResizablePMCArray']
  vivify_2047:
    set $P129, $P2719[$I100]
    unless_null $P129, vivify_2048
    new $P129, "Undef"
  vivify_2048:
    find_dynamic_lex $P132, "$*GLOBALish"
    unless_null $P132, vivify_2049
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$GLOBALish"]
    unless_null $P132, vivify_2050
    die "Contextual $*GLOBALish not found"
  vivify_2050:
  vivify_2049:
    $P124."install_lexical_symbol"($P129, "GLOBALish", $P132)
.annotate 'line', 1480
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2051
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2052
    die "Contextual $*GLOBALish not found"
  vivify_2052:
  vivify_2051:
    store_dynamic_lex "$*PACKAGE", $P124
.annotate 'line', 1481
    find_dynamic_lex $P124, "$*SC"
    unless_null $P124, vivify_2053
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$SC"]
    unless_null $P124, vivify_2054
    die "Contextual $*SC not found"
  vivify_2054:
  vivify_2053:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P2720, $P128["@BLOCK"]
    unless_null $P2720, vivify_2055
    $P2720 = root_new ['parrot';'ResizablePMCArray']
  vivify_2055:
    set $P129, $P2720[$I100]
    unless_null $P129, vivify_2056
    new $P129, "Undef"
  vivify_2056:
    find_dynamic_lex $P132, "$*PACKAGE"
    unless_null $P132, vivify_2057
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$PACKAGE"]
    unless_null $P132, vivify_2058
    die "Contextual $*PACKAGE not found"
  vivify_2058:
  vivify_2057:
    $P133 = $P124."install_lexical_symbol"($P129, "$?PACKAGE", $P132)
.annotate 'line', 1471
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("490_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2722
    .param pmc param_2723
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1484
    .lex "self", param_2722
    .lex "$/", param_2723
.annotate 'line', 1485
    find_lex $P122, "$/"
    find_lex $P123, "self"
    $P124 = $P123."CTXSAVE"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1484
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("491_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2725
    .param pmc param_2726
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1490
    .lex "self", param_2725
    .lex "$/", param_2726
.annotate 'line', 1491
    new $P122, "Undef"
    set $P2727, $P122
    .lex "$module", $P2727
    find_dynamic_lex $P125, "$*SC"
    unless_null $P125, vivify_2059
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SC"]
    unless_null $P125, vivify_2060
    die "Contextual $*SC not found"
  vivify_2060:
  vivify_2059:
    find_lex $P2728, "$/"
    unless_null $P2728, vivify_2061
    $P2728 = root_new ['parrot';'Hash']
  vivify_2061:
    set $P127, $P2728["name"]
    unless_null $P127, vivify_2062
    new $P127, "Undef"
  vivify_2062:
    set $S100, $P127
    find_dynamic_lex $P130, "$*GLOBALish"
    unless_null $P130, vivify_2063
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$GLOBALish"]
    unless_null $P130, vivify_2064
    die "Contextual $*GLOBALish not found"
  vivify_2064:
  vivify_2063:
    $P131 = $P125."load_module"($S100, $P130)
    store_lex "$module", $P131
.annotate 'line', 1492
    find_lex $P123, "$module"
    unless_null $P123, vivify_2065
    new $P123, "Undef"
  vivify_2065:
    defined $I100, $P123
    unless $I100, if_2729_end
.annotate 'line', 1493
    find_lex $P124, "$module"
    unless_null $P124, vivify_2066
    new $P124, "Undef"
  vivify_2066:
    "import_HOW_exports"($P124)
  if_2729_end:
.annotate 'line', 1495
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    $P129 = $P128."new"()
    $P130 = $P123."!make"($P129)
.annotate 'line', 1490
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("492_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2731
    .param pmc param_2732
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1498
    .const 'Sub' $P2743 = "493_1321350766.1143" 
    capture_lex $P2743
    .lex "self", param_2731
    .lex "$/", param_2732
.annotate 'line', 1499
    new $P122, "Undef"
    set $P2733, $P122
    .lex "$count", $P2733
.annotate 'line', 1500
    new $P123, "Undef"
    set $P2734, $P123
    .lex "$past", $P2734
.annotate 'line', 1499
    find_lex $P2735, "$/"
    unless_null $P2735, vivify_2067
    $P2735 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P124, $P2735["xblock"]
    unless_null $P124, vivify_2068
    new $P124, "Undef"
  vivify_2068:
    set $N100, $P124
    new $P125, 'Float'
    set $P125, $N100
    sub $P127, $P125, 1
    store_lex "$count", $P127
.annotate 'line', 1500
    find_lex $P124, "$count"
    unless_null $P124, vivify_2069
    new $P124, "Undef"
  vivify_2069:
    set $I100, $P124
    find_lex $P2736, "$/"
    unless_null $P2736, vivify_2070
    $P2736 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P2737, $P2736["xblock"]
    unless_null $P2737, vivify_2071
    $P2737 = root_new ['parrot';'ResizablePMCArray']
  vivify_2071:
    set $P125, $P2737[$I100]
    unless_null $P125, vivify_2072
    new $P125, "Undef"
  vivify_2072:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    store_lex "$past", $P128
.annotate 'line', 1501
    find_lex $P2739, "$/"
    unless_null $P2739, vivify_2073
    $P2739 = root_new ['parrot';'Hash']
  vivify_2073:
    set $P124, $P2739["else"]
    unless_null $P124, vivify_2074
    new $P124, "Undef"
  vivify_2074:
    unless $P124, if_2738_end
.annotate 'line', 1502
    find_lex $P125, "$past"
    unless_null $P125, vivify_2075
    new $P125, "Undef"
  vivify_2075:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P2740, "$/"
    unless_null $P2740, vivify_2076
    $P2740 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P2741, $P2740["else"]
    unless_null $P2741, vivify_2077
    $P2741 = root_new ['parrot';'ResizablePMCArray']
  vivify_2077:
    set $P128, $P2741[$I100]
    unless_null $P128, vivify_2078
    new $P128, "Undef"
  vivify_2078:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    $P125."push"($P130)
  if_2738_end:
.annotate 'line', 1505
    new $P127, 'ExceptionHandler'
    set_label $P127, loop2748_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop2748_test:
    find_lex $P124, "$count"
    unless_null $P124, vivify_2079
    new $P124, "Undef"
  vivify_2079:
    set $N100, $P124
    set $N101, 0
    isgt $I100, $N100, $N101
    unless $I100, loop2748_done
  loop2748_redo:
    .const 'Sub' $P2743 = "493_1321350766.1143" 
    capture_lex $P2743
    $P2743()
  loop2748_next:
    goto loop2748_test
  loop2748_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2748_next
    eq $P128, .CONTROL_LOOP_REDO, loop2748_redo
  loop2748_done:
    pop_eh 
.annotate 'line', 1511
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2088
    new $P125, "Undef"
  vivify_2088:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1498
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2742"  :anon :subid("493_1321350766.1143") :outer("492_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1507
    new $P125, "Undef"
    set $P2744, $P125
    .lex "$else", $P2744
.annotate 'line', 1505
    find_lex $P127, "$count"
    unless_null $P127, vivify_2080
    new $P127, "Undef"
  vivify_2080:
    clone $P2745, $P127
    dec $P127
.annotate 'line', 1507
    find_lex $P127, "$past"
    unless_null $P127, vivify_2081
    new $P127, "Undef"
  vivify_2081:
    store_lex "$else", $P127
.annotate 'line', 1508
    find_lex $P127, "$count"
    unless_null $P127, vivify_2082
    new $P127, "Undef"
  vivify_2082:
    set $I101, $P127
    find_lex $P2746, "$/"
    unless_null $P2746, vivify_2083
    $P2746 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P2747, $P2746["xblock"]
    unless_null $P2747, vivify_2084
    $P2747 = root_new ['parrot';'ResizablePMCArray']
  vivify_2084:
    set $P128, $P2747[$I101]
    unless_null $P128, vivify_2085
    new $P128, "Undef"
  vivify_2085:
    $P129 = $P128."ast"()
    $P130 = "xblock_immediate"($P129)
    store_lex "$past", $P130
.annotate 'line', 1509
    find_lex $P127, "$past"
    unless_null $P127, vivify_2086
    new $P127, "Undef"
  vivify_2086:
    find_lex $P128, "$else"
    unless_null $P128, vivify_2087
    new $P128, "Undef"
  vivify_2087:
    $P129 = $P127."push"($P128)
.annotate 'line', 1505
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("494_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2750
    .param pmc param_2751
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1514
    .lex "self", param_2750
    .lex "$/", param_2751
.annotate 'line', 1515
    new $P122, "Undef"
    set $P2752, $P122
    .lex "$past", $P2752
    find_lex $P2753, "$/"
    unless_null $P2753, vivify_2089
    $P2753 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P123, $P2753["xblock"]
    unless_null $P123, vivify_2090
    new $P123, "Undef"
  vivify_2090:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    store_lex "$past", $P125
.annotate 'line', 1516
    find_lex $P123, "$past"
    unless_null $P123, vivify_2091
    new $P123, "Undef"
  vivify_2091:
    $P123."pasttype"("unless")
.annotate 'line', 1517
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2092
    new $P124, "Undef"
  vivify_2092:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1514
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("495_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2755
    .param pmc param_2756
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1520
    .lex "self", param_2755
    .lex "$/", param_2756
.annotate 'line', 1521
    new $P122, "Undef"
    set $P2757, $P122
    .lex "$past", $P2757
    find_lex $P2758, "$/"
    unless_null $P2758, vivify_2093
    $P2758 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P123, $P2758["xblock"]
    unless_null $P123, vivify_2094
    new $P123, "Undef"
  vivify_2094:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    store_lex "$past", $P125
.annotate 'line', 1522
    find_lex $P123, "$past"
    unless_null $P123, vivify_2095
    new $P123, "Undef"
  vivify_2095:
    find_lex $P2759, "$/"
    unless_null $P2759, vivify_2096
    $P2759 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P124, $P2759["sym"]
    unless_null $P124, vivify_2097
    new $P124, "Undef"
  vivify_2097:
    set $S100, $P124
    $P123."pasttype"($S100)
.annotate 'line', 1523
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2098
    new $P124, "Undef"
  vivify_2098:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1520
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("496_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2761
    .param pmc param_2762
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1526
    .lex "self", param_2761
    .lex "$/", param_2762
.annotate 'line', 1527
    new $P122, "Undef"
    set $P2763, $P122
    .lex "$pasttype", $P2763
.annotate 'line', 1528
    new $P123, "Undef"
    set $P2764, $P123
    .lex "$past", $P2764
.annotate 'line', 1527
    new $P124, "String"
    assign $P124, "repeat_"
    find_lex $P2765, "$/"
    unless_null $P2765, vivify_2099
    $P2765 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P125, $P2765["wu"]
    unless_null $P125, vivify_2100
    new $P125, "Undef"
  vivify_2100:
    set $S100, $P125
    concat $P127, $P124, $S100
    store_lex "$pasttype", $P127
.annotate 'line', 1526
    find_lex $P124, "$past"
    unless_null $P124, vivify_2101
    new $P124, "Undef"
  vivify_2101:
.annotate 'line', 1529
    find_lex $P2767, "$/"
    unless_null $P2767, vivify_2102
    $P2767 = root_new ['parrot';'Hash']
  vivify_2102:
    set $P124, $P2767["xblock"]
    unless_null $P124, vivify_2103
    new $P124, "Undef"
  vivify_2103:
    if $P124, if_2766
.annotate 'line', 1534
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P2769, "$/"
    unless_null $P2769, vivify_2104
    $P2769 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P130, $P2769["EXPR"]
    unless_null $P130, vivify_2105
    new $P130, "Undef"
  vivify_2105:
    $P131 = $P130."ast"()
    find_lex $P2770, "$/"
    unless_null $P2770, vivify_2106
    $P2770 = root_new ['parrot';'Hash']
  vivify_2106:
    set $P132, $P2770["pblock"]
    unless_null $P132, vivify_2107
    new $P132, "Undef"
  vivify_2107:
    $P133 = $P132."ast"()
    $P134 = "block_immediate"($P133)
    find_lex $P135, "$pasttype"
    unless_null $P135, vivify_2108
    new $P135, "Undef"
  vivify_2108:
    find_lex $P136, "$/"
    unless_null $P136, vivify_2109
    new $P136, "Undef"
  vivify_2109:
    $P137 = $P129."new"($P131, $P134, $P135 :named("pasttype"), $P136 :named("node"))
    store_lex "$past", $P137
.annotate 'line', 1533
    goto if_2766_end
  if_2766:
.annotate 'line', 1530
    find_lex $P2768, "$/"
    unless_null $P2768, vivify_2110
    $P2768 = root_new ['parrot';'Hash']
  vivify_2110:
    set $P125, $P2768["xblock"]
    unless_null $P125, vivify_2111
    new $P125, "Undef"
  vivify_2111:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    store_lex "$past", $P128
.annotate 'line', 1531
    find_lex $P125, "$past"
    unless_null $P125, vivify_2112
    new $P125, "Undef"
  vivify_2112:
    find_lex $P127, "$pasttype"
    unless_null $P127, vivify_2113
    new $P127, "Undef"
  vivify_2113:
    $P125."pasttype"($P127)
  if_2766_end:
.annotate 'line', 1537
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2114
    new $P125, "Undef"
  vivify_2114:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1526
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("497_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2772
    .param pmc param_2773
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1540
    .lex "self", param_2772
    .lex "$/", param_2773
.annotate 'line', 1541
    new $P122, "Undef"
    set $P2774, $P122
    .lex "$past", $P2774
.annotate 'line', 1543
    new $P123, "Undef"
    set $P2775, $P123
    .lex "$block", $P2775
.annotate 'line', 1541
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_2115
    $P2776 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P124, $P2776["xblock"]
    unless_null $P124, vivify_2116
    new $P124, "Undef"
  vivify_2116:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 1542
    find_lex $P124, "$past"
    unless_null $P124, vivify_2117
    new $P124, "Undef"
  vivify_2117:
    $P124."pasttype"("for")
.annotate 'line', 1543
    new $P124, "Float"
    assign $P124, 1
    set $I100, $P124
    find_lex $P2777, "$past"
    unless_null $P2777, vivify_2118
    $P2777 = root_new ['parrot';'ResizablePMCArray']
  vivify_2118:
    set $P125, $P2777[$I100]
    unless_null $P125, vivify_2119
    new $P125, "Undef"
  vivify_2119:
    store_lex "$block", $P125
.annotate 'line', 1544
    find_lex $P124, "$block"
    unless_null $P124, vivify_2120
    new $P124, "Undef"
  vivify_2120:
    $P125 = $P124."arity"()
    if $P125, unless_2778_end
.annotate 'line', 1545
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P2779, "$block"
    unless_null $P2779, vivify_2121
    $P2779 = root_new ['parrot';'ResizablePMCArray']
  vivify_2121:
    set $P128, $P2779[$I100]
    unless_null $P128, vivify_2122
    new $P128, "Undef"
  vivify_2122:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Var"]
    $P133 = $P132."new"("$_" :named("name"), "parameter" :named("scope"))
    $P128."push"($P133)
.annotate 'line', 1546
    find_lex $P127, "$block"
    unless_null $P127, vivify_2123
    new $P127, "Undef"
  vivify_2123:
    $P127."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1547
    find_lex $P127, "$block"
    unless_null $P127, vivify_2124
    new $P127, "Undef"
  vivify_2124:
    $P127."arity"(1)
  unless_2778_end:
.annotate 'line', 1549
    find_lex $P124, "$block"
    unless_null $P124, vivify_2125
    new $P124, "Undef"
  vivify_2125:
    $P124."blocktype"("immediate")
.annotate 'line', 1550
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2126
    new $P125, "Undef"
  vivify_2126:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1540
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("498_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2781
    .param pmc param_2782
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1553
    .lex "self", param_2781
    .lex "$/", param_2782
.annotate 'line', 1554
    new $P122, "Undef"
    set $P2783, $P122
    .lex "$block", $P2783
    find_lex $P2784, "$/"
    unless_null $P2784, vivify_2127
    $P2784 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P123, $P2784["block"]
    unless_null $P123, vivify_2128
    new $P123, "Undef"
  vivify_2128:
    $P124 = $P123."ast"()
    store_lex "$block", $P124
.annotate 'line', 1555
    find_lex $P123, "$/"
    unless_null $P123, vivify_2129
    new $P123, "Undef"
  vivify_2129:
    find_lex $P124, "$block"
    unless_null $P124, vivify_2130
    new $P124, "Undef"
  vivify_2130:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1556
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2785, $P127["@BLOCK"]
    unless_null $P2785, vivify_2131
    $P2785 = root_new ['parrot';'ResizablePMCArray']
  vivify_2131:
    set $P128, $P2785[$I101]
    unless_null $P128, vivify_2132
    new $P128, "Undef"
  vivify_2132:
    $P129 = $P128."handlers"()
    set $P130, $P129[$I100]
    unless_null $P130, vivify_2133
    new $P130, "Undef"
  vivify_2133:
    $P130."handle_types_except"("CONTROL")
.annotate 'line', 1557
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2134
    new $P129, "Undef"
  vivify_2134:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1553
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("499_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2787
    .param pmc param_2788
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1560
    .lex "self", param_2787
    .lex "$/", param_2788
.annotate 'line', 1561
    new $P122, "Undef"
    set $P2789, $P122
    .lex "$block", $P2789
    find_lex $P2790, "$/"
    unless_null $P2790, vivify_2135
    $P2790 = root_new ['parrot';'Hash']
  vivify_2135:
    set $P123, $P2790["block"]
    unless_null $P123, vivify_2136
    new $P123, "Undef"
  vivify_2136:
    $P124 = $P123."ast"()
    store_lex "$block", $P124
.annotate 'line', 1562
    find_lex $P123, "$/"
    unless_null $P123, vivify_2137
    new $P123, "Undef"
  vivify_2137:
    find_lex $P124, "$block"
    unless_null $P124, vivify_2138
    new $P124, "Undef"
  vivify_2138:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1563
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2791, $P127["@BLOCK"]
    unless_null $P2791, vivify_2139
    $P2791 = root_new ['parrot';'ResizablePMCArray']
  vivify_2139:
    set $P128, $P2791[$I101]
    unless_null $P128, vivify_2140
    new $P128, "Undef"
  vivify_2140:
    $P129 = $P128."handlers"()
    set $P130, $P129[$I100]
    unless_null $P130, vivify_2141
    new $P130, "Undef"
  vivify_2141:
    $P130."handle_types"("CONTROL")
.annotate 'line', 1564
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2142
    new $P129, "Undef"
  vivify_2142:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1560
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("500_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2793
    .param pmc param_2794
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1604
    .lex "self", param_2793
    .lex "$/", param_2794
.annotate 'line', 1605
    new $P122, "Float"
    assign $P122, 0
    set $I100, $P122
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2795, $P124["@BLOCK"]
    unless_null $P2795, vivify_2143
    $P2795 = root_new ['parrot';'ResizablePMCArray']
  vivify_2143:
    set $P125, $P2795[$I100]
    unless_null $P125, vivify_2144
    new $P125, "Undef"
  vivify_2144:
    find_lex $P2796, "$/"
    unless_null $P2796, vivify_2145
    $P2796 = root_new ['parrot';'Hash']
  vivify_2145:
    set $P127, $P2796["blorst"]
    unless_null $P127, vivify_2146
    new $P127, "Undef"
  vivify_2146:
    $P128 = $P127."ast"()
    $P125."push"($P128)
.annotate 'line', 1606
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    $P128 = $P127."new"()
    $P129 = $P122."!make"($P128)
.annotate 'line', 1604
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("501_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2798
    .param pmc param_2799
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1609
    .lex "self", param_2798
    .lex "$/", param_2799
.annotate 'line', 1610
    new $P122, "Undef"
    set $P2800, $P122
    .lex "$past", $P2800
    find_lex $P2801, "$/"
    unless_null $P2801, vivify_2147
    $P2801 = root_new ['parrot';'Hash']
  vivify_2147:
    set $P123, $P2801["blorst"]
    unless_null $P123, vivify_2148
    new $P123, "Undef"
  vivify_2148:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 1611
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Block"]
    find_lex $P128, "$past"
    unless_null $P128, vivify_2149
    new $P128, "Undef"
  vivify_2149:
    $P129 = $P127."ACCEPTS"($P128)
    if $P129, unless_2802_end
.annotate 'line', 1612
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Block"]
    find_lex $P134, "$past"
    unless_null $P134, vivify_2150
    new $P134, "Undef"
  vivify_2150:
    find_lex $P135, "$/"
    unless_null $P135, vivify_2151
    new $P135, "Undef"
  vivify_2151:
    $P136 = $P133."new"($P134, "immediate" :named("blocktype"), $P135 :named("node"))
    store_lex "$past", $P136
  unless_2802_end:
.annotate 'line', 1614
    find_lex $P123, "$past"
    unless_null $P123, vivify_2152
    new $P123, "Undef"
  vivify_2152:
    $P124 = $P123."handlers"()
    if $P124, unless_2803_end
.annotate 'line', 1615
    find_lex $P125, "$past"
    unless_null $P125, vivify_2153
    new $P125, "Undef"
  vivify_2153:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Control"]
.annotate 'line', 1617
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Stmts"]
.annotate 'line', 1618
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1619
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
.annotate 'line', 1620
    get_hll_global $P143, "GLOBAL"
    nqp_get_package_through_who $P144, $P143, "PAST"
    get_who $P145, $P144
    set $P146, $P145["Var"]
    $P147 = $P146."new"("register" :named("scope"), "exception" :named("name"))
    $P148 = $P142."new"($P147, "handled", "keyed" :named("scope"))
.annotate 'line', 1619
    $P149 = $P138."new"($P148, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1618
    $P151 = $P134."new"($P149)
.annotate 'line', 1617
    $P152 = $P130."new"($P151, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1615
    new $P153, "ResizablePMCArray"
    push $P153, $P152
    $P125."handlers"($P153)
  unless_2803_end:
.annotate 'line', 1629
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2154
    new $P124, "Undef"
  vivify_2154:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1609
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("502_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2805
    .param pmc param_2806
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1632
    .lex "self", param_2805
    .lex "$/", param_2806
.annotate 'line', 1633
    find_lex $P122, "$/"
.annotate 'line', 1634
    find_lex $P2808, "$/"
    unless_null $P2808, vivify_2155
    $P2808 = root_new ['parrot';'Hash']
  vivify_2155:
    set $P124, $P2808["block"]
    unless_null $P124, vivify_2156
    new $P124, "Undef"
  vivify_2156:
    if $P124, if_2807
.annotate 'line', 1635
    find_lex $P2810, "$/"
    unless_null $P2810, vivify_2157
    $P2810 = root_new ['parrot';'Hash']
  vivify_2157:
    set $P129, $P2810["statement"]
    unless_null $P129, vivify_2158
    new $P129, "Undef"
  vivify_2158:
    $P130 = $P129."ast"()
    set $P123, $P130
.annotate 'line', 1634
    goto if_2807_end
  if_2807:
    find_lex $P2809, "$/"
    unless_null $P2809, vivify_2159
    $P2809 = root_new ['parrot';'Hash']
  vivify_2159:
    set $P125, $P2809["block"]
    unless_null $P125, vivify_2160
    new $P125, "Undef"
  vivify_2160:
    $P127 = $P125."ast"()
    $P128 = "block_immediate"($P127)
    set $P123, $P128
  if_2807_end:
    $P131 = $P122."!make"($P123)
.annotate 'line', 1632
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("503_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2812
    .param pmc param_2813
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1640
    .lex "self", param_2812
    .lex "$/", param_2813
    find_lex $P122, "$/"
    find_lex $P2814, "$/"
    unless_null $P2814, vivify_2161
    $P2814 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P123, $P2814["cond"]
    unless_null $P123, vivify_2162
    new $P123, "Undef"
  vivify_2162:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("504_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2816
    .param pmc param_2817
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1641
    .lex "self", param_2816
    .lex "$/", param_2817
    find_lex $P122, "$/"
    find_lex $P2818, "$/"
    unless_null $P2818, vivify_2163
    $P2818 = root_new ['parrot';'Hash']
  vivify_2163:
    set $P123, $P2818["cond"]
    unless_null $P123, vivify_2164
    new $P123, "Undef"
  vivify_2164:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("505_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2820
    .param pmc param_2821
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1643
    .lex "self", param_2820
    .lex "$/", param_2821
    find_lex $P122, "$/"
    find_lex $P2822, "$/"
    unless_null $P2822, vivify_2165
    $P2822 = root_new ['parrot';'Hash']
  vivify_2165:
    set $P123, $P2822["cond"]
    unless_null $P123, vivify_2166
    new $P123, "Undef"
  vivify_2166:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("506_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2824
    .param pmc param_2825
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1644
    .lex "self", param_2824
    .lex "$/", param_2825
    find_lex $P122, "$/"
    find_lex $P2826, "$/"
    unless_null $P2826, vivify_2167
    $P2826 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P123, $P2826["cond"]
    unless_null $P123, vivify_2168
    new $P123, "Undef"
  vivify_2168:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("507_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2828
    .param pmc param_2829
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1648
    .lex "self", param_2828
    .lex "$/", param_2829
    find_lex $P122, "$/"
    find_lex $P2830, "$/"
    unless_null $P2830, vivify_2169
    $P2830 = root_new ['parrot';'Hash']
  vivify_2169:
    set $P123, $P2830["fatarrow"]
    unless_null $P123, vivify_2170
    new $P123, "Undef"
  vivify_2170:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("508_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2832
    .param pmc param_2833
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1649
    .lex "self", param_2832
    .lex "$/", param_2833
    find_lex $P122, "$/"
    find_lex $P2834, "$/"
    unless_null $P2834, vivify_2171
    $P2834 = root_new ['parrot';'Hash']
  vivify_2171:
    set $P123, $P2834["colonpair"]
    unless_null $P123, vivify_2172
    new $P123, "Undef"
  vivify_2172:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("509_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2836
    .param pmc param_2837
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1650
    .lex "self", param_2836
    .lex "$/", param_2837
    find_lex $P122, "$/"
    find_lex $P2838, "$/"
    unless_null $P2838, vivify_2173
    $P2838 = root_new ['parrot';'Hash']
  vivify_2173:
    set $P123, $P2838["variable"]
    unless_null $P123, vivify_2174
    new $P123, "Undef"
  vivify_2174:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("510_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2840
    .param pmc param_2841
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1651
    .lex "self", param_2840
    .lex "$/", param_2841
    find_lex $P122, "$/"
    find_lex $P2842, "$/"
    unless_null $P2842, vivify_2175
    $P2842 = root_new ['parrot';'Hash']
  vivify_2175:
    set $P123, $P2842["package_declarator"]
    unless_null $P123, vivify_2176
    new $P123, "Undef"
  vivify_2176:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("511_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2844
    .param pmc param_2845
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1652
    .lex "self", param_2844
    .lex "$/", param_2845
    find_lex $P122, "$/"
    find_lex $P2846, "$/"
    unless_null $P2846, vivify_2177
    $P2846 = root_new ['parrot';'Hash']
  vivify_2177:
    set $P123, $P2846["scope_declarator"]
    unless_null $P123, vivify_2178
    new $P123, "Undef"
  vivify_2178:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("512_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2848
    .param pmc param_2849
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1653
    .lex "self", param_2848
    .lex "$/", param_2849
    find_lex $P122, "$/"
    find_lex $P2850, "$/"
    unless_null $P2850, vivify_2179
    $P2850 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P123, $P2850["routine_declarator"]
    unless_null $P123, vivify_2180
    new $P123, "Undef"
  vivify_2180:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("513_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2852
    .param pmc param_2853
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1654
    .lex "self", param_2852
    .lex "$/", param_2853
    find_lex $P122, "$/"
    find_lex $P2854, "$/"
    unless_null $P2854, vivify_2181
    $P2854 = root_new ['parrot';'Hash']
  vivify_2181:
    set $P123, $P2854["regex_declarator"]
    unless_null $P123, vivify_2182
    new $P123, "Undef"
  vivify_2182:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("514_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2856
    .param pmc param_2857
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1655
    .lex "self", param_2856
    .lex "$/", param_2857
    find_lex $P122, "$/"
    find_lex $P2858, "$/"
    unless_null $P2858, vivify_2183
    $P2858 = root_new ['parrot';'Hash']
  vivify_2183:
    set $P123, $P2858["statement_prefix"]
    unless_null $P123, vivify_2184
    new $P123, "Undef"
  vivify_2184:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("515_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2860
    .param pmc param_2861
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1656
    .lex "self", param_2860
    .lex "$/", param_2861
    find_lex $P122, "$/"
    find_lex $P2862, "$/"
    unless_null $P2862, vivify_2185
    $P2862 = root_new ['parrot';'Hash']
  vivify_2185:
    set $P123, $P2862["pblock"]
    unless_null $P123, vivify_2186
    new $P123, "Undef"
  vivify_2186:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("516_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2864
    .param pmc param_2865
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1658
    .lex "self", param_2864
    .lex "$/", param_2865
.annotate 'line', 1659
    new $P122, "Undef"
    set $P2866, $P122
    .lex "$past", $P2866
    find_lex $P2867, "$/"
    unless_null $P2867, vivify_2187
    $P2867 = root_new ['parrot';'Hash']
  vivify_2187:
    set $P123, $P2867["val"]
    unless_null $P123, vivify_2188
    new $P123, "Undef"
  vivify_2188:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 1660
    find_lex $P123, "$past"
    unless_null $P123, vivify_2189
    new $P123, "Undef"
  vivify_2189:
    find_lex $P2868, "$/"
    unless_null $P2868, vivify_2190
    $P2868 = root_new ['parrot';'Hash']
  vivify_2190:
    set $P124, $P2868["key"]
    unless_null $P124, vivify_2191
    new $P124, "Undef"
  vivify_2191:
    $P125 = $P124."Str"()
    $P123."named"($P125)
.annotate 'line', 1661
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2192
    new $P124, "Undef"
  vivify_2192:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1658
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("517_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2870
    .param pmc param_2871
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1664
    .lex "self", param_2870
    .lex "$/", param_2871
.annotate 'line', 1665
    new $P122, "Undef"
    set $P2872, $P122
    .lex "$past", $P2872
.annotate 'line', 1666
    find_lex $P2874, "$/"
    unless_null $P2874, vivify_2193
    $P2874 = root_new ['parrot';'Hash']
  vivify_2193:
    set $P124, $P2874["circumfix"]
    unless_null $P124, vivify_2194
    new $P124, "Undef"
  vivify_2194:
    if $P124, if_2873
.annotate 'line', 1667
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    find_lex $P2877, "$/"
    unless_null $P2877, vivify_2195
    $P2877 = root_new ['parrot';'Hash']
  vivify_2195:
    set $P133, $P2877["not"]
    unless_null $P133, vivify_2196
    new $P133, "Undef"
  vivify_2196:
    isfalse $I101, $P133
    $P134 = $P132."new"($I101 :named("value"))
    set $P123, $P134
.annotate 'line', 1666
    goto if_2873_end
  if_2873:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P2875, "$/"
    unless_null $P2875, vivify_2197
    $P2875 = root_new ['parrot';'Hash']
  vivify_2197:
    set $P2876, $P2875["circumfix"]
    unless_null $P2876, vivify_2198
    $P2876 = root_new ['parrot';'ResizablePMCArray']
  vivify_2198:
    set $P127, $P2876[$I100]
    unless_null $P127, vivify_2199
    new $P127, "Undef"
  vivify_2199:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_2873_end:
    store_lex "$past", $P123
.annotate 'line', 1668
    find_lex $P123, "$past"
    unless_null $P123, vivify_2200
    new $P123, "Undef"
  vivify_2200:
    find_lex $P2878, "$/"
    unless_null $P2878, vivify_2201
    $P2878 = root_new ['parrot';'Hash']
  vivify_2201:
    set $P124, $P2878["identifier"]
    unless_null $P124, vivify_2202
    new $P124, "Undef"
  vivify_2202:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 1669
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2203
    new $P124, "Undef"
  vivify_2203:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1664
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("518_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2880
    .param pmc param_2881
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1672
    .const 'Sub' $P2887 = "519_1321350766.1143" 
    capture_lex $P2887
    .lex "self", param_2880
    .lex "$/", param_2881
.annotate 'line', 1673
    new $P122, "Undef"
    set $P2882, $P122
    .lex "$past", $P2882
.annotate 'line', 1672
    find_lex $P123, "$past"
    unless_null $P123, vivify_2204
    new $P123, "Undef"
  vivify_2204:
.annotate 'line', 1674
    find_lex $P2884, "$/"
    unless_null $P2884, vivify_2205
    $P2884 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P123, $P2884["postcircumfix"]
    unless_null $P123, vivify_2206
    new $P123, "Undef"
  vivify_2206:
    if $P123, if_2883
.annotate 'line', 1678
    .const 'Sub' $P2887 = "519_1321350766.1143" 
    capture_lex $P2887
    $P2887()
    goto if_2883_end
  if_2883:
.annotate 'line', 1675
    find_lex $P2885, "$/"
    unless_null $P2885, vivify_2268
    $P2885 = root_new ['parrot';'Hash']
  vivify_2268:
    set $P124, $P2885["postcircumfix"]
    unless_null $P124, vivify_2269
    new $P124, "Undef"
  vivify_2269:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 1676
    find_lex $P124, "$past"
    unless_null $P124, vivify_2270
    new $P124, "Undef"
  vivify_2270:
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
    $P130 = $P129."new"("$/" :named("name"))
    $P124."unshift"($P130)
  if_2883_end:
.annotate 'line', 1740
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2271
    new $P124, "Undef"
  vivify_2271:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1672
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2886"  :anon :subid("519_1321350766.1143") :outer("518_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1678
    .const 'Sub' $P2909 = "521_1321350766.1143" 
    capture_lex $P2909
    .const 'Sub' $P2900 = "520_1321350766.1143" 
    capture_lex $P2900
.annotate 'line', 1679
    $P2889 = root_new ['parrot';'ResizablePMCArray']
    set $P2888, $P2889
    .lex "@name", $P2888
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "NQP"
    get_who $P127, $P125
    set $P128, $P127["Compiler"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2207
    new $P129, "Undef"
  vivify_2207:
    set $S100, $P129
    $P130 = $P128."parse_name"($S100)
    store_lex "@name", $P130
.annotate 'line', 1680
    find_lex $P2891, "@name"
    unless_null $P2891, vivify_2208
    $P2891 = root_new ['parrot';'ResizablePMCArray']
  vivify_2208:
    set $N100, $P2891
    set $N101, 1
    isgt $I100, $N100, $N101
    if $I100, if_2890
.annotate 'line', 1687
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P2897, "$/"
    unless_null $P2897, vivify_2209
    $P2897 = root_new ['parrot';'Hash']
  vivify_2209:
    set $P2898, $P2897["twigil"]
    unless_null $P2898, vivify_2210
    $P2898 = root_new ['parrot';'ResizablePMCArray']
  vivify_2210:
    set $P128, $P2898[$I101]
    unless_null $P128, vivify_2211
    new $P128, "Undef"
  vivify_2211:
    set $S100, $P128
    iseq $I102, $S100, "*"
    if $I102, if_2896
.annotate 'line', 1698
    new $P133, "Float"
    assign $P133, 0
    set $I103, $P133
    find_lex $P2906, "$/"
    unless_null $P2906, vivify_2212
    $P2906 = root_new ['parrot';'Hash']
  vivify_2212:
    set $P2907, $P2906["twigil"]
    unless_null $P2907, vivify_2213
    $P2907 = root_new ['parrot';'ResizablePMCArray']
  vivify_2213:
    set $P134, $P2907[$I103]
    unless_null $P134, vivify_2214
    new $P134, "Undef"
  vivify_2214:
    set $S101, $P134
    iseq $I104, $S101, "!"
    if $I104, if_2905
.annotate 'line', 1730
    new $P141, "Float"
    assign $P141, 0
    set $I105, $P141
    find_lex $P2928, "@name"
    unless_null $P2928, vivify_2215
    $P2928 = root_new ['parrot';'ResizablePMCArray']
  vivify_2215:
    set $P142, $P2928[$I105]
    unless_null $P142, vivify_2216
    new $P142, "Undef"
  vivify_2216:
    set $S102, $P142
    $P143 = "is_package"($S102)
    if $P143, if_2927
.annotate 'line', 1735
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "PAST"
    get_who $P146, $P145
    set $P148, $P146["Var"]
.annotate 'line', 1736
    find_lex $P2931, "@name"
    unless_null $P2931, vivify_2217
    $P2931 = root_new ['parrot';'ResizablePMCArray']
  vivify_2217:
    $P149 = $P2931."pop"()
    set $S103, $P149
    find_lex $P2932, "$/"
    unless_null $P2932, vivify_2218
    $P2932 = root_new ['parrot';'Hash']
  vivify_2218:
    set $P151, $P2932["sigil"]
    unless_null $P151, vivify_2219
    new $P151, "Undef"
  vivify_2219:
    $P152 = "vivitype"($P151)
.annotate 'line', 1735
    $P153 = $P148."new"($S103 :named("name"), $P152 :named("viviself"))
    store_lex "$past", $P153
.annotate 'line', 1734
    set $P140, $P153
.annotate 'line', 1730
    goto if_2927_end
  if_2927:
.annotate 'line', 1731
    find_lex $P2929, "@name"
    unless_null $P2929, vivify_2220
    $P2929 = root_new ['parrot';'ResizablePMCArray']
  vivify_2220:
    find_lex $P144, "$/"
    unless_null $P144, vivify_2221
    new $P144, "Undef"
  vivify_2221:
    $P145 = "lexical_package_lookup"($P2929, $P144)
    store_lex "$past", $P145
.annotate 'line', 1732
    find_lex $P144, "$past"
    unless_null $P144, vivify_2222
    new $P144, "Undef"
  vivify_2222:
    find_lex $P2930, "$/"
    unless_null $P2930, vivify_2223
    $P2930 = root_new ['parrot';'Hash']
  vivify_2223:
    set $P145, $P2930["sigil"]
    unless_null $P145, vivify_2224
    new $P145, "Undef"
  vivify_2224:
    $P146 = "vivitype"($P145)
    $P147 = $P144."viviself"($P146)
.annotate 'line', 1730
    set $P140, $P147
  if_2927_end:
    set $P132, $P140
.annotate 'line', 1698
    goto if_2905_end
  if_2905:
    .const 'Sub' $P2909 = "521_1321350766.1143" 
    capture_lex $P2909
    $P139 = $P2909()
    set $P132, $P139
  if_2905_end:
    set $P125, $P132
.annotate 'line', 1687
    goto if_2896_end
  if_2896:
    .const 'Sub' $P2900 = "520_1321350766.1143" 
    capture_lex $P2900
    $P131 = $P2900()
    set $P125, $P131
  if_2896_end:
    set $P124, $P125
.annotate 'line', 1680
    goto if_2890_end
  if_2890:
.annotate 'line', 1681
    find_lex $P2893, "$/"
    unless_null $P2893, vivify_2260
    $P2893 = root_new ['parrot';'Hash']
  vivify_2260:
    set $P125, $P2893["twigil"]
    unless_null $P125, vivify_2261
    new $P125, "Undef"
  vivify_2261:
    unless $P125, if_2892_end
.annotate 'line', 1682
    find_lex $P127, "$/"
    unless_null $P127, vivify_2262
    new $P127, "Undef"
  vivify_2262:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Twigil not allowed on multi-part name")
  if_2892_end:
.annotate 'line', 1684
    find_lex $P2894, "@name"
    unless_null $P2894, vivify_2263
    $P2894 = root_new ['parrot';'ResizablePMCArray']
  vivify_2263:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2264
    new $P125, "Undef"
  vivify_2264:
    $P127 = "lexical_package_lookup"($P2894, $P125)
    store_lex "$past", $P127
.annotate 'line', 1685
    find_lex $P125, "$past"
    unless_null $P125, vivify_2265
    new $P125, "Undef"
  vivify_2265:
    find_lex $P2895, "$/"
    unless_null $P2895, vivify_2266
    $P2895 = root_new ['parrot';'Hash']
  vivify_2266:
    set $P127, $P2895["sigil"]
    unless_null $P127, vivify_2267
    new $P127, "Undef"
  vivify_2267:
    $P128 = "vivitype"($P127)
    $P129 = $P125."viviself"($P128)
.annotate 'line', 1680
    set $P124, $P129
  if_2890_end:
.annotate 'line', 1678
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2908"  :anon :subid("521_1321350766.1143") :outer("519_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1698
    .const 'Sub' $P2918 = "522_1321350766.1143" 
    capture_lex $P2918
.annotate 'line', 1700
    new $P135, "Undef"
    set $P2910, $P135
    .lex "$name", $P2910
.annotate 'line', 1701
    new $P136, "Undef"
    set $P2911, $P136
    .lex "$ch", $P2911
.annotate 'line', 1700
    find_lex $P2912, "@name"
    unless_null $P2912, vivify_2225
    $P2912 = root_new ['parrot';'ResizablePMCArray']
  vivify_2225:
    $P138 = $P2912."pop"()
    set $S102, $P138
    new $P139, 'String'
    set $P139, $S102
    store_lex "$name", $P139
.annotate 'line', 1701
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    $P142 = $P141."new"("$?CLASS" :named("name"))
    store_lex "$ch", $P142
.annotate 'line', 1702
    new $P138, "Float"
    assign $P138, 1
    find_lex $P2913, "$ch"
    unless_null $P2913, vivify_2226
    $P2913 = root_new ['parrot';'Hash']
    store_lex "$ch", $P2913
  vivify_2226:
    set $P2913["has_compile_time_value"], $P138
.annotate 'line', 1703
    find_dynamic_lex $P140, "$*PACKAGE"
    unless_null $P140, vivify_2227
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$PACKAGE"]
    unless_null $P140, vivify_2228
    die "Contextual $*PACKAGE not found"
  vivify_2228:
  vivify_2227:
    find_lex $P2914, "$ch"
    unless_null $P2914, vivify_2229
    $P2914 = root_new ['parrot';'Hash']
    store_lex "$ch", $P2914
  vivify_2229:
    set $P2914["compile_time_value"], $P140
.annotate 'line', 1704
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    find_lex $P142, "$name"
    unless_null $P142, vivify_2230
    new $P142, "Undef"
  vivify_2230:
.annotate 'line', 1706
    find_lex $P2915, "$/"
    unless_null $P2915, vivify_2231
    $P2915 = root_new ['parrot';'Hash']
  vivify_2231:
    set $P143, $P2915["sigil"]
    unless_null $P143, vivify_2232
    new $P143, "Undef"
  vivify_2232:
    $P144 = "vivitype"($P143)
.annotate 'line', 1707
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Var"]
    $P154 = $P153."new"("self" :named("name"))
    $P155 = $P148."new"($P154, "nqp_decontainerize PP" :named("pirop"))
    find_lex $P156, "$ch"
    unless_null $P156, vivify_2233
    new $P156, "Undef"
  vivify_2233:
    $P157 = $P141."new"($P155, $P156, $P142 :named("name"), "attribute_6model" :named("scope"), $P144 :named("viviself"))
.annotate 'line', 1704
    store_lex "$past", $P157
.annotate 'line', 1712
    find_dynamic_lex $P141, "$*IN_DECL"
    unless_null $P141, vivify_2234
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$IN_DECL"]
    unless_null $P141, vivify_2235
    die "Contextual $*IN_DECL not found"
  vivify_2235:
  vivify_2234:
    unless $P141, unless_2916
    set $P138, $P141
    goto unless_2916_end
  unless_2916:
    .const 'Sub' $P2918 = "522_1321350766.1143" 
    capture_lex $P2918
    $P144 = $P2918()
    set $P138, $P144
  unless_2916_end:
.annotate 'line', 1698
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2917"  :anon :subid("522_1321350766.1143") :outer("521_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1712
    .const 'Sub' $P2921 = "523_1321350766.1143" 
    capture_lex $P2921
.annotate 'line', 1713
    new $P142, "Undef"
    set $P2919, $P142
    .lex "$attr", $P2919
.annotate 'line', 1712
    find_lex $P143, "$attr"
    unless_null $P143, vivify_2236
    new $P143, "Undef"
  vivify_2236:
.annotate 'line', 1714
    find_dynamic_lex $P146, "$*PACKAGE"
    unless_null $P146, vivify_2237
    get_hll_global $P144, "GLOBAL"
    get_who $P145, $P144
    set $P146, $P145["$PACKAGE"]
    unless_null $P146, vivify_2238
    die "Contextual $*PACKAGE not found"
  vivify_2238:
  vivify_2237:
    get_how $P147, $P146
    find_dynamic_lex $P151, "$*PACKAGE"
    unless_null $P151, vivify_2239
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P151, $P149["$PACKAGE"]
    unless_null $P151, vivify_2240
    die "Contextual $*PACKAGE not found"
  vivify_2240:
  vivify_2239:
    $P152 = $P147."attributes"($P151, 1 :named("local"))
    defined $I105, $P152
    unless $I105, for_undef_2241
    iter $P143, $P152
    new $P155, 'ExceptionHandler'
    set_label $P155, loop2924_handler
    $P155."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P155
  loop2924_test:
    unless $P143, loop2924_done
    shift $P153, $P143
  loop2924_redo:
    .const 'Sub' $P2921 = "523_1321350766.1143" 
    capture_lex $P2921
    $P2921($P153)
  loop2924_next:
    goto loop2924_test
  loop2924_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P156, exception, 'type'
    eq $P156, .CONTROL_LOOP_NEXT, loop2924_next
    eq $P156, .CONTROL_LOOP_REDO, loop2924_redo
  loop2924_done:
    pop_eh 
  for_undef_2241:
.annotate 'line', 1720
    find_lex $P144, "$attr"
    unless_null $P144, vivify_2245
    new $P144, "Undef"
  vivify_2245:
    defined $I105, $P144
    if $I105, if_2925
.annotate 'line', 1726
    find_lex $P146, "$/"
    unless_null $P146, vivify_2246
    new $P146, "Undef"
  vivify_2246:
    $P147 = $P146."CURSOR"()
    new $P148, 'String'
    set $P148, "Attribute '"
    find_lex $P149, "$name"
    unless_null $P149, vivify_2247
    new $P149, "Undef"
  vivify_2247:
    concat $P151, $P148, $P149
    concat $P152, $P151, "' not declared"
    $P153 = $P147."panic"($P152)
.annotate 'line', 1725
    set $P143, $P153
.annotate 'line', 1720
    goto if_2925_end
  if_2925:
.annotate 'line', 1721
    find_lex $P146, "$attr"
    unless_null $P146, vivify_2248
    new $P146, "Undef"
  vivify_2248:
    can $I106, $P146, "type"
    if $I106, if_2926
    new $P145, 'Integer'
    set $P145, $I106
    goto if_2926_end
  if_2926:
.annotate 'line', 1722
    find_lex $P147, "$past"
    unless_null $P147, vivify_2249
    new $P147, "Undef"
  vivify_2249:
    find_lex $P148, "$attr"
    unless_null $P148, vivify_2250
    new $P148, "Undef"
  vivify_2250:
    $P149 = $P148."type"()
    $P151 = $P147."type"($P149)
.annotate 'line', 1721
    set $P145, $P151
  if_2926_end:
.annotate 'line', 1720
    set $P143, $P145
  if_2925_end:
.annotate 'line', 1712
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2920"  :anon :subid("523_1321350766.1143") :outer("522_1321350766.1143")
    .param pmc param_2922
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1714
    .lex "$_", param_2922
.annotate 'line', 1715
    find_lex $P155, "$_"
    unless_null $P155, vivify_2242
    new $P155, "Undef"
  vivify_2242:
    $S102 = $P155."name"()
    find_lex $P156, "$name"
    unless_null $P156, vivify_2243
    new $P156, "Undef"
  vivify_2243:
    set $S103, $P156
    iseq $I106, $S102, $S103
    if $I106, if_2923
    new $P154, 'Integer'
    set $P154, $I106
    goto if_2923_end
  if_2923:
.annotate 'line', 1716
    find_lex $P157, "$_"
    unless_null $P157, vivify_2244
    new $P157, "Undef"
  vivify_2244:
    store_lex "$attr", $P157
.annotate 'line', 1717
    die 0, .CONTROL_LOOP_LAST
  if_2923_end:
.annotate 'line', 1714
    .return ($P154)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2899"  :anon :subid("520_1321350766.1143") :outer("519_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1688
    new $P130, "Undef"
    set $P2901, $P130
    .lex "$global_fallback", $P2901
    find_lex $P2902, "$/"
    unless_null $P2902, vivify_2251
    $P2902 = root_new ['parrot';'Hash']
  vivify_2251:
    set $P131, $P2902["sigil"]
    unless_null $P131, vivify_2252
    new $P131, "Undef"
  vivify_2252:
    set $S101, $P131
    new $P132, 'String'
    set $P132, $S101
    find_lex $P2903, "$/"
    unless_null $P2903, vivify_2253
    $P2903 = root_new ['parrot';'Hash']
  vivify_2253:
    set $P133, $P2903["desigilname"]
    unless_null $P133, vivify_2254
    new $P133, "Undef"
  vivify_2254:
    concat $P134, $P132, $P133
    new $P135, "ResizablePMCArray"
    push $P135, "GLOBAL"
    push $P135, $P134
    find_lex $P136, "$/"
    unless_null $P136, vivify_2255
    new $P136, "Undef"
  vivify_2255:
    $P137 = "lexical_package_lookup"($P135, $P136)
    store_lex "$global_fallback", $P137
.annotate 'line', 1689
    find_lex $P131, "$global_fallback"
    unless_null $P131, vivify_2256
    new $P131, "Undef"
  vivify_2256:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 1690
    new $P136, "String"
    assign $P136, "Contextual "
    find_lex $P137, "$/"
    unless_null $P137, vivify_2257
    new $P137, "Undef"
  vivify_2257:
    set $S101, $P137
    concat $P138, $P136, $S101
    concat $P139, $P138, " not found"
    $P140 = $P135."new"($P139, "die" :named("pirop"))
.annotate 'line', 1689
    $P131."viviself"($P140)
.annotate 'line', 1693
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
.annotate 'line', 1694
    find_lex $P2904, "@name"
    unless_null $P2904, vivify_2258
    $P2904 = root_new ['parrot';'ResizablePMCArray']
  vivify_2258:
    $P135 = $P2904."pop"()
    set $S101, $P135
.annotate 'line', 1693
    find_lex $P136, "$global_fallback"
    unless_null $P136, vivify_2259
    new $P136, "Undef"
  vivify_2259:
    $P137 = $P134."new"($S101 :named("name"), "contextual" :named("scope"), $P136 :named("viviself"))
    store_lex "$past", $P137
.annotate 'line', 1687
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("524_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2934
    .param pmc param_2935
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1743
    .lex "self", param_2934
    .lex "$/", param_2935
    find_lex $P122, "$/"
    find_lex $P2936, "$/"
    unless_null $P2936, vivify_2272
    $P2936 = root_new ['parrot';'Hash']
  vivify_2272:
    set $P123, $P2936["package_def"]
    unless_null $P123, vivify_2273
    new $P123, "Undef"
  vivify_2273:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("525_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2938
    .param pmc param_2939
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1744
    .lex "self", param_2938
    .lex "$/", param_2939
    find_lex $P122, "$/"
    find_lex $P2940, "$/"
    unless_null $P2940, vivify_2274
    $P2940 = root_new ['parrot';'Hash']
  vivify_2274:
    set $P123, $P2940["package_def"]
    unless_null $P123, vivify_2275
    new $P123, "Undef"
  vivify_2275:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("526_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2942
    .param pmc param_2943
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1745
    .lex "self", param_2942
    .lex "$/", param_2943
    find_lex $P122, "$/"
    find_lex $P2944, "$/"
    unless_null $P2944, vivify_2276
    $P2944 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P123, $P2944["package_def"]
    unless_null $P123, vivify_2277
    new $P123, "Undef"
  vivify_2277:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("527_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2946
    .param pmc param_2947
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1746
    .lex "self", param_2946
    .lex "$/", param_2947
    find_lex $P122, "$/"
    find_lex $P2948, "$/"
    unless_null $P2948, vivify_2278
    $P2948 = root_new ['parrot';'Hash']
  vivify_2278:
    set $P123, $P2948["package_def"]
    unless_null $P123, vivify_2279
    new $P123, "Undef"
  vivify_2279:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("528_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2950
    .param pmc param_2951
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1747
    .lex "self", param_2950
    .lex "$/", param_2951
    find_lex $P122, "$/"
    find_lex $P2952, "$/"
    unless_null $P2952, vivify_2280
    $P2952 = root_new ['parrot';'Hash']
  vivify_2280:
    set $P123, $P2952["package_def"]
    unless_null $P123, vivify_2281
    new $P123, "Undef"
  vivify_2281:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("529_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2954
    .param pmc param_2955
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1748
    .lex "self", param_2954
    .lex "$/", param_2955
    find_lex $P122, "$/"
    find_lex $P2956, "$/"
    unless_null $P2956, vivify_2282
    $P2956 = root_new ['parrot';'Hash']
  vivify_2282:
    set $P123, $P2956["package_def"]
    unless_null $P123, vivify_2283
    new $P123, "Undef"
  vivify_2283:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("530_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2958
    .param pmc param_2959
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1750
    .lex "self", param_2958
    .lex "$/", param_2959
.annotate 'line', 1753
    new $P122, "Undef"
    set $P2960, $P122
    .lex "$HOW", $P2960
.annotate 'line', 1754
    new $P123, "Undef"
    set $P2961, $P123
    .lex "$PACKAGE", $P2961
.annotate 'line', 1753
    find_lex $P2962, "$/"
    unless_null $P2962, vivify_2284
    $P2962 = root_new ['parrot';'Hash']
  vivify_2284:
    set $P2963, $P2962["metaclass"]
    unless_null $P2963, vivify_2285
    $P2963 = root_new ['parrot';'Hash']
  vivify_2285:
    set $P124, $P2963["identifier"]
    unless_null $P124, vivify_2286
    new $P124, "Undef"
  vivify_2286:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2287
    new $P125, "Undef"
  vivify_2287:
    $P127 = "find_sym"($P124, $P125)
    store_lex "$HOW", $P127
.annotate 'line', 1754
    find_dynamic_lex $P127, "$*SC"
    unless_null $P127, vivify_2288
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$SC"]
    unless_null $P127, vivify_2289
    die "Contextual $*SC not found"
  vivify_2289:
  vivify_2288:
    find_lex $P128, "$HOW"
    unless_null $P128, vivify_2290
    new $P128, "Undef"
  vivify_2290:
    find_lex $P2964, "$/"
    unless_null $P2964, vivify_2291
    $P2964 = root_new ['parrot';'Hash']
  vivify_2291:
    set $P129, $P2964["name"]
    unless_null $P129, vivify_2292
    new $P129, "Undef"
  vivify_2292:
    set $S100, $P129
    $P130 = $P127."pkg_create_mo"($P128, $S100 :named("name"))
    store_lex "$PACKAGE", $P130
.annotate 'line', 1757
    find_dynamic_lex $P128, "$*SCOPE"
    unless_null $P128, vivify_2293
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SCOPE"]
    unless_null $P128, vivify_2294
    die "Contextual $*SCOPE not found"
  vivify_2294:
  vivify_2293:
    set $S100, $P128
    iseq $I100, $S100, "our"
    unless $I100, unless_2966
    new $P124, 'Integer'
    set $P124, $I100
    goto unless_2966_end
  unless_2966:
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2295
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2296
    die "Contextual $*SCOPE not found"
  vivify_2296:
  vivify_2295:
    set $S101, $P131
    iseq $I101, $S101, ""
    new $P124, 'Integer'
    set $P124, $I101
  unless_2966_end:
    if $P124, if_2965
.annotate 'line', 1763
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2297
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2298
    die "Contextual $*SCOPE not found"
  vivify_2298:
  vivify_2297:
    set $S102, $P134
    iseq $I102, $S102, "my"
    if $I102, if_2976
.annotate 'line', 1770
    find_lex $P135, "$/"
    unless_null $P135, vivify_2299
    new $P135, "Undef"
  vivify_2299:
    $P136 = $P135."CURSOR"()
    find_dynamic_lex $P139, "$*SCOPE"
    unless_null $P139, vivify_2300
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SCOPE"]
    unless_null $P139, vivify_2301
    die "Contextual $*SCOPE not found"
  vivify_2301:
  vivify_2300:
    concat $P140, $P139, " scoped packages are not supported"
    $P136."panic"($P140)
.annotate 'line', 1769
    goto if_2976_end
  if_2976:
.annotate 'line', 1764
    find_lex $P2978, "$/"
    unless_null $P2978, vivify_2302
    $P2978 = root_new ['parrot';'Hash']
  vivify_2302:
    set $P2979, $P2978["name"]
    unless_null $P2979, vivify_2303
    $P2979 = root_new ['parrot';'Hash']
  vivify_2303:
    set $P135, $P2979["identifier"]
    unless_null $P135, vivify_2304
    new $P135, "Undef"
  vivify_2304:
    set $N100, $P135
    set $N101, 1
    isne $I103, $N100, $N101
    unless $I103, if_2977_end
.annotate 'line', 1765
    find_lex $P2980, "$/"
    unless_null $P2980, vivify_2305
    $P2980 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P136, $P2980["name"]
    unless_null $P136, vivify_2306
    new $P136, "Undef"
  vivify_2306:
    $P137 = $P136."CURSOR"()
    $P137."panic"("A my scoped package cannot have a multi-part name yet")
  if_2977_end:
.annotate 'line', 1767
    find_dynamic_lex $P137, "$*SC"
    unless_null $P137, vivify_2307
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SC"]
    unless_null $P137, vivify_2308
    die "Contextual $*SC not found"
  vivify_2308:
  vivify_2307:
    new $P138, "Float"
    assign $P138, 0
    set $I103, $P138
    find_lex $P139, "$?PACKAGE"
    get_who $P140, $P139
    set $P2981, $P140["@BLOCK"]
    unless_null $P2981, vivify_2309
    $P2981 = root_new ['parrot';'ResizablePMCArray']
  vivify_2309:
    set $P141, $P2981[$I103]
    unless_null $P141, vivify_2310
    new $P141, "Undef"
  vivify_2310:
    new $P142, "Float"
    assign $P142, 0
    set $I104, $P142
    find_lex $P2982, "$/"
    unless_null $P2982, vivify_2311
    $P2982 = root_new ['parrot';'Hash']
  vivify_2311:
    set $P2983, $P2982["name"]
    unless_null $P2983, vivify_2312
    $P2983 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P2984, $P2983["identifier"]
    unless_null $P2984, vivify_2313
    $P2984 = root_new ['parrot';'ResizablePMCArray']
  vivify_2313:
    set $P143, $P2984[$I104]
    unless_null $P143, vivify_2314
    new $P143, "Undef"
  vivify_2314:
    find_lex $P144, "$PACKAGE"
    unless_null $P144, vivify_2315
    new $P144, "Undef"
  vivify_2315:
    $P137."install_lexical_symbol"($P141, $P143, $P144)
  if_2976_end:
.annotate 'line', 1763
    goto if_2965_end
  if_2965:
.annotate 'line', 1758
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2316
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2317
    die "Contextual $*SC not found"
  vivify_2317:
  vivify_2316:
    find_dynamic_lex $P137, "$*OUTERPACKAGE"
    unless_null $P137, vivify_2318
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$OUTERPACKAGE"]
    unless_null $P137, vivify_2319
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2319:
  vivify_2318:
    find_lex $P2967, "$/"
    unless_null $P2967, vivify_2320
    $P2967 = root_new ['parrot';'Hash']
  vivify_2320:
    set $P2968, $P2967["name"]
    unless_null $P2968, vivify_2321
    $P2968 = root_new ['parrot';'Hash']
  vivify_2321:
    set $P138, $P2968["identifier"]
    unless_null $P138, vivify_2322
    new $P138, "Undef"
  vivify_2322:
    find_lex $P139, "$PACKAGE"
    unless_null $P139, vivify_2323
    new $P139, "Undef"
  vivify_2323:
    $P134."install_package_symbol"($P137, $P138, $P139)
.annotate 'line', 1759
    find_lex $P2970, "$/"
    unless_null $P2970, vivify_2324
    $P2970 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P2971, $P2970["name"]
    unless_null $P2971, vivify_2325
    $P2971 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P132, $P2971["identifier"]
    unless_null $P132, vivify_2326
    new $P132, "Undef"
  vivify_2326:
    set $N100, $P132
    set $N101, 1
    iseq $I102, $N100, $N101
    unless $I102, if_2969_end
.annotate 'line', 1760
    find_dynamic_lex $P135, "$*SC"
    unless_null $P135, vivify_2327
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SC"]
    unless_null $P135, vivify_2328
    die "Contextual $*SC not found"
  vivify_2328:
  vivify_2327:
    new $P136, "Float"
    assign $P136, 0
    set $I103, $P136
    find_lex $P137, "$?PACKAGE"
    get_who $P138, $P137
    set $P2972, $P138["@BLOCK"]
    unless_null $P2972, vivify_2329
    $P2972 = root_new ['parrot';'ResizablePMCArray']
  vivify_2329:
    set $P139, $P2972[$I103]
    unless_null $P139, vivify_2330
    new $P139, "Undef"
  vivify_2330:
    new $P140, "Float"
    assign $P140, 0
    set $I104, $P140
    find_lex $P2973, "$/"
    unless_null $P2973, vivify_2331
    $P2973 = root_new ['parrot';'Hash']
  vivify_2331:
    set $P2974, $P2973["name"]
    unless_null $P2974, vivify_2332
    $P2974 = root_new ['parrot';'Hash']
  vivify_2332:
    set $P2975, $P2974["identifier"]
    unless_null $P2975, vivify_2333
    $P2975 = root_new ['parrot';'ResizablePMCArray']
  vivify_2333:
    set $P141, $P2975[$I104]
    unless_null $P141, vivify_2334
    new $P141, "Undef"
  vivify_2334:
    find_lex $P142, "$PACKAGE"
    unless_null $P142, vivify_2335
    new $P142, "Undef"
  vivify_2335:
    $P135."install_lexical_symbol"($P139, $P141, $P142)
  if_2969_end:
  if_2965_end:
.annotate 'line', 1773
    find_lex $P124, "$/"
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
    $P130 = $P129."new"()
    $P131 = $P124."!make"($P130)
.annotate 'line', 1750
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("531_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_2986
    .param pmc param_2987
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1776
    .const 'Sub' $P3035 = "535_1321350766.1143" 
    capture_lex $P3035
    .const 'Sub' $P3028 = "534_1321350766.1143" 
    capture_lex $P3028
    .const 'Sub' $P3009 = "532_1321350766.1143" 
    capture_lex $P3009
    .lex "self", param_2986
    .lex "$/", param_2987
.annotate 'line', 1778
    $P2989 = root_new ['parrot';'ResizablePMCArray']
    set $P2988, $P2989
    .lex "@ns", $P2988
.annotate 'line', 1779
    new $P122, "Undef"
    set $P2990, $P122
    .lex "$name", $P2990
.annotate 'line', 1780
    new $P123, "Undef"
    set $P2991, $P123
    .lex "$how", $P2991
.annotate 'line', 1783
    new $P124, "Undef"
    set $P2992, $P124
    .lex "$past", $P2992
.annotate 'line', 1778
    find_lex $P2993, "$/"
    unless_null $P2993, vivify_2336
    $P2993 = root_new ['parrot';'Hash']
  vivify_2336:
    set $P2994, $P2993["name"]
    unless_null $P2994, vivify_2337
    $P2994 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P125, $P2994["identifier"]
    unless_null $P125, vivify_2338
    new $P125, "Undef"
  vivify_2338:
    clone $P127, $P125
    store_lex "@ns", $P127
.annotate 'line', 1779
    find_lex $P2995, "@ns"
    unless_null $P2995, vivify_2339
    $P2995 = root_new ['parrot';'ResizablePMCArray']
  vivify_2339:
    $P125 = $P2995."pop"()
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    store_lex "$name", $P127
.annotate 'line', 1780
    find_dynamic_lex $P128, "$*PKGDECL"
    unless_null $P128, vivify_2340
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$PKGDECL"]
    unless_null $P128, vivify_2341
    die "Contextual $*PKGDECL not found"
  vivify_2341:
  vivify_2340:
    find_dynamic_lex $P131, "%*HOW"
    unless_null $P131, vivify_2342
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%HOW"]
    unless_null $P131, vivify_2343
    die "Contextual %*HOW not found"
  vivify_2343:
  vivify_2342:
    set $P132, $P131[$P128]
    unless_null $P132, vivify_2344
    new $P132, "Undef"
  vivify_2344:
    store_lex "$how", $P132
.annotate 'line', 1783
    find_lex $P2997, "$/"
    unless_null $P2997, vivify_2345
    $P2997 = root_new ['parrot';'Hash']
  vivify_2345:
    set $P127, $P2997["block"]
    unless_null $P127, vivify_2346
    new $P127, "Undef"
  vivify_2346:
    if $P127, if_2996
    find_lex $P2999, "$/"
    unless_null $P2999, vivify_2347
    $P2999 = root_new ['parrot';'Hash']
  vivify_2347:
    set $P130, $P2999["comp_unit"]
    unless_null $P130, vivify_2348
    new $P130, "Undef"
  vivify_2348:
    $P131 = $P130."ast"()
    set $P125, $P131
    goto if_2996_end
  if_2996:
    find_lex $P2998, "$/"
    unless_null $P2998, vivify_2349
    $P2998 = root_new ['parrot';'Hash']
  vivify_2349:
    set $P128, $P2998["block"]
    unless_null $P128, vivify_2350
    new $P128, "Undef"
  vivify_2350:
    $P129 = $P128."ast"()
    set $P125, $P129
  if_2996_end:
    store_lex "$past", $P125
.annotate 'line', 1784
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2351
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2352
    die "Contextual $*SCOPE not found"
  vivify_2352:
  vivify_2351:
    set $S100, $P129
    iseq $I100, $S100, "our"
    unless $I100, unless_3001
    new $P125, 'Integer'
    set $P125, $I100
    goto unless_3001_end
  unless_3001:
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2353
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2354
    die "Contextual $*SCOPE not found"
  vivify_2354:
  vivify_2353:
    set $S101, $P132
    iseq $I101, $S101, ""
    new $P125, 'Integer'
    set $P125, $I101
  unless_3001_end:
    unless $P125, if_3000_end
.annotate 'line', 1785
    find_lex $P133, "$past"
    unless_null $P133, vivify_2355
    new $P133, "Undef"
  vivify_2355:
    find_lex $P3002, "$/"
    unless_null $P3002, vivify_2356
    $P3002 = root_new ['parrot';'Hash']
  vivify_2356:
    set $P3003, $P3002["name"]
    unless_null $P3003, vivify_2357
    $P3003 = root_new ['parrot';'Hash']
  vivify_2357:
    set $P134, $P3003["identifier"]
    unless_null $P134, vivify_2358
    new $P134, "Undef"
  vivify_2358:
    $P133."namespace"($P134)
  if_3000_end:
.annotate 'line', 1792
    find_lex $P127, "$how"
    unless_null $P127, vivify_2359
    new $P127, "Undef"
  vivify_2359:
    can $I100, $P127, "parametric"
    if $I100, if_3005
    new $P125, 'Integer'
    set $P125, $I100
    goto if_3005_end
  if_3005:
    find_lex $P128, "$how"
    unless_null $P128, vivify_2360
    new $P128, "Undef"
  vivify_2360:
    find_lex $P129, "$how"
    unless_null $P129, vivify_2361
    new $P129, "Undef"
  vivify_2361:
    $P130 = $P128."parametric"($P129)
    set $P125, $P130
  if_3005_end:
    if $P125, if_3004
.annotate 'line', 1801
    find_lex $P131, "$past"
    unless_null $P131, vivify_2362
    new $P131, "Undef"
  vivify_2362:
    $P131."blocktype"("immediate")
.annotate 'line', 1802
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2363
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2364
    die "Contextual $*SC not found"
  vivify_2364:
  vivify_2363:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2365
    new $P134, "Undef"
  vivify_2365:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2366
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2367
    die "Contextual $*PACKAGE not found"
  vivify_2367:
  vivify_2366:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1803
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2368
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2369
    die "Contextual $*SC not found"
  vivify_2369:
  vivify_2368:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2370
    new $P134, "Undef"
  vivify_2370:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2371
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2372
    die "Contextual $*PACKAGE not found"
  vivify_2372:
  vivify_2371:
    $P133."install_lexical_symbol"($P134, "$?CLASS", $P137)
.annotate 'line', 1800
    goto if_3004_end
  if_3004:
.annotate 'line', 1793
    find_lex $P131, "$past"
    unless_null $P131, vivify_2373
    new $P131, "Undef"
  vivify_2373:
    $P131."blocktype"("declaration")
.annotate 'line', 1794
    find_lex $P131, "$past"
    unless_null $P131, vivify_2374
    new $P131, "Undef"
  vivify_2374:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    $P136 = $P135."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P131."unshift"($P136)
.annotate 'line', 1795
    find_lex $P131, "$past"
    unless_null $P131, vivify_2375
    new $P131, "Undef"
  vivify_2375:
    $P131."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1796
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2376
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2377
    die "Contextual $*SC not found"
  vivify_2377:
  vivify_2376:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2378
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2379
    die "Contextual $*PACKAGE not found"
  vivify_2379:
  vivify_2378:
    find_lex $P137, "$past"
    unless_null $P137, vivify_2380
    new $P137, "Undef"
  vivify_2380:
    $P133."pkg_set_body_block"($P136, $P137)
.annotate 'line', 1797
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2381
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2382
    die "Contextual $*SC not found"
  vivify_2382:
  vivify_2381:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2383
    new $P134, "Undef"
  vivify_2383:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2384
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2385
    die "Contextual $*PACKAGE not found"
  vivify_2385:
  vivify_2384:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1798
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2386
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2387
    die "Contextual $*SC not found"
  vivify_2387:
  vivify_2386:
    find_lex $P134, "$past"
    unless_null $P134, vivify_2388
    new $P134, "Undef"
  vivify_2388:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2389
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2390
    die "Contextual $*PACKAGE not found"
  vivify_2390:
  vivify_2389:
    $P133."install_lexical_symbol"($P134, "$?ROLE", $P137)
  if_3004_end:
.annotate 'line', 1807
    find_lex $P3007, "$/"
    unless_null $P3007, vivify_2391
    $P3007 = root_new ['parrot';'Hash']
  vivify_2391:
    set $P125, $P3007["parent"]
    unless_null $P125, vivify_2392
    new $P125, "Undef"
  vivify_2392:
    if $P125, if_3006
.annotate 'line', 1821
    find_lex $P130, "$how"
    unless_null $P130, vivify_2393
    new $P130, "Undef"
  vivify_2393:
    can $I100, $P130, "set_default_parent"
    unless $I100, if_3026_end
    .const 'Sub' $P3028 = "534_1321350766.1143" 
    capture_lex $P3028
    $P3028()
  if_3026_end:
    goto if_3006_end
  if_3006:
.annotate 'line', 1807
    .const 'Sub' $P3009 = "532_1321350766.1143" 
    capture_lex $P3009
    $P3009()
  if_3006_end:
.annotate 'line', 1828
    find_lex $P3032, "$/"
    unless_null $P3032, vivify_2419
    $P3032 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P125, $P3032["role"]
    unless_null $P125, vivify_2420
    new $P125, "Undef"
  vivify_2420:
    unless $P125, if_3031_end
.annotate 'line', 1829
    find_lex $P3033, "$/"
    unless_null $P3033, vivify_2421
    $P3033 = root_new ['parrot';'Hash']
  vivify_2421:
    set $P128, $P3033["role"]
    unless_null $P128, vivify_2422
    new $P128, "Undef"
  vivify_2422:
    defined $I100, $P128
    unless $I100, for_undef_2423
    iter $P127, $P128
    new $P133, 'ExceptionHandler'
    set_label $P133, loop3049_handler
    $P133."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P133
  loop3049_test:
    unless $P127, loop3049_done
    shift $P129, $P127
  loop3049_redo:
    .const 'Sub' $P3035 = "535_1321350766.1143" 
    capture_lex $P3035
    $P3035($P129)
  loop3049_next:
    goto loop3049_test
  loop3049_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P134, exception, 'type'
    eq $P134, .CONTROL_LOOP_NEXT, loop3049_next
    eq $P134, .CONTROL_LOOP_REDO, loop3049_redo
  loop3049_done:
    pop_eh 
  for_undef_2423:
  if_3031_end:
.annotate 'line', 1846
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_2437
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_2438
    die "Contextual $*SC not found"
  vivify_2438:
  vivify_2437:
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2439
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2440
    die "Contextual $*PACKAGE not found"
  vivify_2440:
  vivify_2439:
    $P128."pkg_compose"($P131)
.annotate 'line', 1848
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_2441
    new $P127, "Undef"
  vivify_2441:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1776
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3027"  :anon :subid("534_1321350766.1143") :outer("531_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1822
    new $P131, "Undef"
    set $P3029, $P131
    .lex "$default", $P3029
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2394
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2395
    die "Contextual $*PKGDECL not found"
  vivify_2395:
  vivify_2394:
    set $S100, $P135
    iseq $I101, $S100, "grammar"
    if $I101, if_3030
    new $P137, "ResizablePMCArray"
    push $P137, "NQPMu"
    set $P132, $P137
    goto if_3030_end
  if_3030:
    new $P136, "ResizablePMCArray"
    push $P136, "Regex"
    push $P136, "Cursor"
    set $P132, $P136
  if_3030_end:
    store_lex "$default", $P132
.annotate 'line', 1823
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2396
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2397
    die "Contextual $*SC not found"
  vivify_2397:
  vivify_2396:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2398
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2399
    die "Contextual $*PACKAGE not found"
  vivify_2399:
  vivify_2398:
.annotate 'line', 1824
    find_lex $P138, "$default"
    unless_null $P138, vivify_2400
    new $P138, "Undef"
  vivify_2400:
    find_lex $P139, "$/"
    unless_null $P139, vivify_2401
    new $P139, "Undef"
  vivify_2401:
    $P140 = "find_sym"($P138, $P139)
    $P141 = $P134."pkg_add_parent_or_role"($P137, "set_default_parent", $P140)
.annotate 'line', 1821
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3008"  :anon :subid("532_1321350766.1143") :outer("531_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1807
    .const 'Sub' $P3013 = "533_1321350766.1143" 
    capture_lex $P3013
.annotate 'line', 1808
    new $P127, "Undef"
    set $P3010, $P127
    .lex "$parent", $P3010
.annotate 'line', 1809
    new $P128, "Undef"
    set $P3011, $P128
    .lex "$parent_found", $P3011
.annotate 'line', 1807
    find_lex $P129, "$parent"
    unless_null $P129, vivify_2402
    new $P129, "Undef"
  vivify_2402:
    find_lex $P129, "$parent_found"
    unless_null $P129, vivify_2403
    new $P129, "Undef"
  vivify_2403:
.annotate 'line', 1810
    .const 'Sub' $P3013 = "533_1321350766.1143" 
    capture_lex $P3013
    $P3013()
.annotate 'line', 1814
    find_lex $P130, "$parent_found"
    unless_null $P130, vivify_2409
    new $P130, "Undef"
  vivify_2409:
    if $P130, if_3023
.annotate 'line', 1818
    find_lex $P131, "$/"
    unless_null $P131, vivify_2410
    new $P131, "Undef"
  vivify_2410:
    $P132 = $P131."CURSOR"()
    new $P133, "String"
    assign $P133, "Could not find parent class '"
    new $P134, "Float"
    assign $P134, 0
    set $I100, $P134
    find_lex $P3024, "$/"
    unless_null $P3024, vivify_2411
    $P3024 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P3025, $P3024["parent"]
    unless_null $P3025, vivify_2412
    $P3025 = root_new ['parrot';'ResizablePMCArray']
  vivify_2412:
    set $P135, $P3025[$I100]
    unless_null $P135, vivify_2413
    new $P135, "Undef"
  vivify_2413:
    set $S100, $P135
    concat $P136, $P133, $S100
    concat $P137, $P136, "'"
    $P139 = $P132."panic"($P137)
.annotate 'line', 1817
    set $P129, $P139
.annotate 'line', 1814
    goto if_3023_end
  if_3023:
.annotate 'line', 1815
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2414
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2415
    die "Contextual $*SC not found"
  vivify_2415:
  vivify_2414:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2416
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2417
    die "Contextual $*PACKAGE not found"
  vivify_2417:
  vivify_2416:
    find_lex $P137, "$parent"
    unless_null $P137, vivify_2418
    new $P137, "Undef"
  vivify_2418:
    $P138 = $P133."pkg_add_parent_or_role"($P136, "add_parent", $P137)
.annotate 'line', 1814
    set $P129, $P138
  if_3023_end:
.annotate 'line', 1807
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3012"  :anon :subid("533_1321350766.1143") :outer("532_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1810
    new $P3019, 'ExceptionHandler'
    set_label $P3019, control_3018
    $P3019."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3019
.annotate 'line', 1811
    new $P129, "Float"
    assign $P129, 0
    set $I100, $P129
    find_lex $P3014, "$/"
    unless_null $P3014, vivify_2404
    $P3014 = root_new ['parrot';'Hash']
  vivify_2404:
    set $P3015, $P3014["parent"]
    unless_null $P3015, vivify_2405
    $P3015 = root_new ['parrot';'ResizablePMCArray']
  vivify_2405:
    set $P3016, $P3015[$I100]
    unless_null $P3016, vivify_2406
    $P3016 = root_new ['parrot';'Hash']
  vivify_2406:
    set $P130, $P3016["identifier"]
    unless_null $P130, vivify_2407
    new $P130, "Undef"
  vivify_2407:
    clone $P131, $P130
    find_lex $P132, "$/"
    unless_null $P132, vivify_2408
    new $P132, "Undef"
  vivify_2408:
    $P133 = "find_sym"($P131, $P132)
    store_lex "$parent", $P133
.annotate 'line', 1812
    new $P129, "Float"
    assign $P129, 1
    store_lex "$parent_found", $P129
.annotate 'line', 1810
    pop_eh 
    goto skip_handler_3017
  control_3018:
    .local pmc exception 
    .get_results (exception) 
    new $P3021, 'Integer'
    set $P3021, 1
    set exception["handled"], $P3021
    set $I3022, exception["handled"]
    eq $I3022, 1, handled_3020
    rethrow exception
  handled_3020:
    .return (exception)
  skip_handler_3017:
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3034"  :anon :subid("535_1321350766.1143") :outer("531_1321350766.1143")
    .param pmc param_3038
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1829
    .const 'Sub' $P3040 = "536_1321350766.1143" 
    capture_lex $P3040
.annotate 'line', 1830
    new $P130, "Undef"
    set $P3036, $P130
    .lex "$role", $P3036
.annotate 'line', 1831
    new $P131, "Undef"
    set $P3037, $P131
    .lex "$role_found", $P3037
    .lex "$_", param_3038
.annotate 'line', 1829
    find_lex $P132, "$role"
    unless_null $P132, vivify_2424
    new $P132, "Undef"
  vivify_2424:
    find_lex $P132, "$role_found"
    unless_null $P132, vivify_2425
    new $P132, "Undef"
  vivify_2425:
.annotate 'line', 1832
    .const 'Sub' $P3040 = "536_1321350766.1143" 
    capture_lex $P3040
    $P3040()
.annotate 'line', 1836
    find_lex $P133, "$role_found"
    unless_null $P133, vivify_2429
    new $P133, "Undef"
  vivify_2429:
    if $P133, if_3048
.annotate 'line', 1840
    find_lex $P134, "$/"
    unless_null $P134, vivify_2430
    new $P134, "Undef"
  vivify_2430:
    $P135 = $P134."CURSOR"()
    new $P136, "String"
    assign $P136, "Could not find role '"
    find_lex $P137, "$_"
    unless_null $P137, vivify_2431
    new $P137, "Undef"
  vivify_2431:
    set $S100, $P137
    concat $P138, $P136, $S100
    concat $P139, $P138, "'"
    $P140 = $P135."panic"($P139)
.annotate 'line', 1839
    set $P132, $P140
.annotate 'line', 1836
    goto if_3048_end
  if_3048:
.annotate 'line', 1837
    find_dynamic_lex $P136, "$*SC"
    unless_null $P136, vivify_2432
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$SC"]
    unless_null $P136, vivify_2433
    die "Contextual $*SC not found"
  vivify_2433:
  vivify_2432:
    find_dynamic_lex $P139, "$*PACKAGE"
    unless_null $P139, vivify_2434
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$PACKAGE"]
    unless_null $P139, vivify_2435
    die "Contextual $*PACKAGE not found"
  vivify_2435:
  vivify_2434:
    find_lex $P140, "$role"
    unless_null $P140, vivify_2436
    new $P140, "Undef"
  vivify_2436:
    $P141 = $P136."pkg_add_parent_or_role"($P139, "add_role", $P140)
.annotate 'line', 1836
    set $P132, $P141
  if_3048_end:
.annotate 'line', 1829
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3039"  :anon :subid("536_1321350766.1143") :outer("535_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1832
    new $P3044, 'ExceptionHandler'
    set_label $P3044, control_3043
    $P3044."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3044
.annotate 'line', 1833
    find_lex $P3041, "$_"
    unless_null $P3041, vivify_2426
    $P3041 = root_new ['parrot';'Hash']
  vivify_2426:
    set $P132, $P3041["identifier"]
    unless_null $P132, vivify_2427
    new $P132, "Undef"
  vivify_2427:
    clone $P133, $P132
    find_lex $P134, "$/"
    unless_null $P134, vivify_2428
    new $P134, "Undef"
  vivify_2428:
    $P135 = "find_sym"($P133, $P134)
    store_lex "$role", $P135
.annotate 'line', 1834
    new $P132, "Float"
    assign $P132, 1
    store_lex "$role_found", $P132
.annotate 'line', 1832
    pop_eh 
    goto skip_handler_3042
  control_3043:
    .local pmc exception 
    .get_results (exception) 
    new $P3046, 'Integer'
    set $P3046, 1
    set exception["handled"], $P3046
    set $I3047, exception["handled"]
    eq $I3047, 1, handled_3045
    rethrow exception
  handled_3045:
    .return (exception)
  skip_handler_3042:
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("537_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3051
    .param pmc param_3052
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1851
    .lex "self", param_3051
    .lex "$/", param_3052
    find_lex $P122, "$/"
    find_lex $P3053, "$/"
    unless_null $P3053, vivify_2442
    $P3053 = root_new ['parrot';'Hash']
  vivify_2442:
    set $P123, $P3053["scoped"]
    unless_null $P123, vivify_2443
    new $P123, "Undef"
  vivify_2443:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("538_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3055
    .param pmc param_3056
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1852
    .lex "self", param_3055
    .lex "$/", param_3056
    find_lex $P122, "$/"
    find_lex $P3057, "$/"
    unless_null $P3057, vivify_2444
    $P3057 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P123, $P3057["scoped"]
    unless_null $P123, vivify_2445
    new $P123, "Undef"
  vivify_2445:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("539_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3059
    .param pmc param_3060
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1853
    .lex "self", param_3059
    .lex "$/", param_3060
    find_lex $P122, "$/"
    find_lex $P3061, "$/"
    unless_null $P3061, vivify_2446
    $P3061 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P123, $P3061["scoped"]
    unless_null $P123, vivify_2447
    new $P123, "Undef"
  vivify_2447:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("540_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3063
    .param pmc param_3064
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1855
    .lex "self", param_3063
    .lex "$/", param_3064
.annotate 'line', 1856
    find_lex $P122, "$/"
    find_lex $P3066, "$/"
    unless_null $P3066, vivify_2448
    $P3066 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P124, $P3066["declarator"]
    unless_null $P124, vivify_2449
    new $P124, "Undef"
  vivify_2449:
    if $P124, if_3065
.annotate 'line', 1857
    find_lex $P3069, "$/"
    unless_null $P3069, vivify_2450
    $P3069 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P129, $P3069["multi_declarator"]
    unless_null $P129, vivify_2451
    new $P129, "Undef"
  vivify_2451:
    if $P129, if_3068
.annotate 'line', 1858
    find_lex $P3071, "$/"
    unless_null $P3071, vivify_2452
    $P3071 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P132, $P3071["package_declarator"]
    unless_null $P132, vivify_2453
    new $P132, "Undef"
  vivify_2453:
    $P133 = $P132."ast"()
    set $P128, $P133
.annotate 'line', 1857
    goto if_3068_end
  if_3068:
    find_lex $P3070, "$/"
    unless_null $P3070, vivify_2454
    $P3070 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P130, $P3070["multi_declarator"]
    unless_null $P130, vivify_2455
    new $P130, "Undef"
  vivify_2455:
    $P131 = $P130."ast"()
    set $P128, $P131
  if_3068_end:
    set $P123, $P128
.annotate 'line', 1856
    goto if_3065_end
  if_3065:
    find_lex $P3067, "$/"
    unless_null $P3067, vivify_2456
    $P3067 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P125, $P3067["declarator"]
    unless_null $P125, vivify_2457
    new $P125, "Undef"
  vivify_2457:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3065_end:
    $P134 = $P122."!make"($P123)
.annotate 'line', 1855
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("541_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3073
    .param pmc param_3074
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1861
    .lex "self", param_3073
    .lex "$/", param_3074
.annotate 'line', 1862
    find_lex $P122, "$/"
.annotate 'line', 1863
    find_lex $P3076, "$/"
    unless_null $P3076, vivify_2458
    $P3076 = root_new ['parrot';'Hash']
  vivify_2458:
    set $P124, $P3076["routine_declarator"]
    unless_null $P124, vivify_2459
    new $P124, "Undef"
  vivify_2459:
    if $P124, if_3075
.annotate 'line', 1864
    find_lex $P3078, "$/"
    unless_null $P3078, vivify_2460
    $P3078 = root_new ['parrot';'Hash']
  vivify_2460:
    set $P128, $P3078["variable_declarator"]
    unless_null $P128, vivify_2461
    new $P128, "Undef"
  vivify_2461:
    $P129 = $P128."ast"()
    set $P123, $P129
.annotate 'line', 1863
    goto if_3075_end
  if_3075:
    find_lex $P3077, "$/"
    unless_null $P3077, vivify_2462
    $P3077 = root_new ['parrot';'Hash']
  vivify_2462:
    set $P125, $P3077["routine_declarator"]
    unless_null $P125, vivify_2463
    new $P125, "Undef"
  vivify_2463:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3075_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 1861
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("542_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3080
    .param pmc param_3081
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1867
    .lex "self", param_3080
    .lex "$/", param_3081
    find_lex $P122, "$/"
    find_lex $P3083, "$/"
    unless_null $P3083, vivify_2464
    $P3083 = root_new ['parrot';'Hash']
  vivify_2464:
    set $P124, $P3083["declarator"]
    unless_null $P124, vivify_2465
    new $P124, "Undef"
  vivify_2465:
    if $P124, if_3082
    find_lex $P3085, "$/"
    unless_null $P3085, vivify_2466
    $P3085 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P128, $P3085["routine_def"]
    unless_null $P128, vivify_2467
    new $P128, "Undef"
  vivify_2467:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3082_end
  if_3082:
    find_lex $P3084, "$/"
    unless_null $P3084, vivify_2468
    $P3084 = root_new ['parrot';'Hash']
  vivify_2468:
    set $P125, $P3084["declarator"]
    unless_null $P125, vivify_2469
    new $P125, "Undef"
  vivify_2469:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3082_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("543_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3087
    .param pmc param_3088
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1868
    .lex "self", param_3087
    .lex "$/", param_3088
    find_lex $P122, "$/"
    find_lex $P3090, "$/"
    unless_null $P3090, vivify_2470
    $P3090 = root_new ['parrot';'Hash']
  vivify_2470:
    set $P124, $P3090["declarator"]
    unless_null $P124, vivify_2471
    new $P124, "Undef"
  vivify_2471:
    if $P124, if_3089
    find_lex $P3092, "$/"
    unless_null $P3092, vivify_2472
    $P3092 = root_new ['parrot';'Hash']
  vivify_2472:
    set $P128, $P3092["routine_def"]
    unless_null $P128, vivify_2473
    new $P128, "Undef"
  vivify_2473:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3089_end
  if_3089:
    find_lex $P3091, "$/"
    unless_null $P3091, vivify_2474
    $P3091 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P125, $P3091["declarator"]
    unless_null $P125, vivify_2475
    new $P125, "Undef"
  vivify_2475:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3089_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("544_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3094
    .param pmc param_3095
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1869
    .lex "self", param_3094
    .lex "$/", param_3095
    find_lex $P122, "$/"
    find_lex $P3096, "$/"
    unless_null $P3096, vivify_2476
    $P3096 = root_new ['parrot';'Hash']
  vivify_2476:
    set $P123, $P3096["declarator"]
    unless_null $P123, vivify_2477
    new $P123, "Undef"
  vivify_2477:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("545_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3098
    .param pmc param_3099
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1872
    .const 'Sub' $P3135 = "547_1321350766.1143" 
    capture_lex $P3135
    .const 'Sub' $P3112 = "546_1321350766.1143" 
    capture_lex $P3112
    .lex "self", param_3098
    .lex "$/", param_3099
.annotate 'line', 1873
    new $P122, "Undef"
    set $P3100, $P122
    .lex "$past", $P3100
.annotate 'line', 1874
    new $P123, "Undef"
    set $P3101, $P123
    .lex "$sigil", $P3101
.annotate 'line', 1875
    new $P124, "Undef"
    set $P3102, $P124
    .lex "$name", $P3102
.annotate 'line', 1876
    new $P125, "Undef"
    set $P3103, $P125
    .lex "$BLOCK", $P3103
.annotate 'line', 1873
    find_lex $P3104, "$/"
    unless_null $P3104, vivify_2478
    $P3104 = root_new ['parrot';'Hash']
  vivify_2478:
    set $P127, $P3104["variable"]
    unless_null $P127, vivify_2479
    new $P127, "Undef"
  vivify_2479:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 1874
    find_lex $P3105, "$/"
    unless_null $P3105, vivify_2480
    $P3105 = root_new ['parrot';'Hash']
  vivify_2480:
    set $P3106, $P3105["variable"]
    unless_null $P3106, vivify_2481
    $P3106 = root_new ['parrot';'Hash']
  vivify_2481:
    set $P127, $P3106["sigil"]
    unless_null $P127, vivify_2482
    new $P127, "Undef"
  vivify_2482:
    store_lex "$sigil", $P127
.annotate 'line', 1875
    find_lex $P127, "$past"
    unless_null $P127, vivify_2483
    new $P127, "Undef"
  vivify_2483:
    $P128 = $P127."name"()
    store_lex "$name", $P128
.annotate 'line', 1876
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3107, $P129["@BLOCK"]
    unless_null $P3107, vivify_2484
    $P3107 = root_new ['parrot';'ResizablePMCArray']
  vivify_2484:
    set $P130, $P3107[$I100]
    unless_null $P130, vivify_2485
    new $P130, "Undef"
  vivify_2485:
    store_lex "$BLOCK", $P130
.annotate 'line', 1877
    find_lex $P128, "$name"
    unless_null $P128, vivify_2486
    new $P128, "Undef"
  vivify_2486:
    if $P128, if_3109
    set $P127, $P128
    goto if_3109_end
  if_3109:
    find_lex $P129, "$BLOCK"
    unless_null $P129, vivify_2487
    new $P129, "Undef"
  vivify_2487:
    find_lex $P130, "$name"
    unless_null $P130, vivify_2488
    new $P130, "Undef"
  vivify_2488:
    $P131 = $P129."symbol"($P130)
    set $P127, $P131
  if_3109_end:
    unless $P127, if_3108_end
.annotate 'line', 1878
    find_lex $P132, "$/"
    unless_null $P132, vivify_2489
    new $P132, "Undef"
  vivify_2489:
    $P133 = $P132."CURSOR"()
    find_lex $P134, "$name"
    unless_null $P134, vivify_2490
    new $P134, "Undef"
  vivify_2490:
    $P133."panic"("Redeclaration of symbol ", $P134)
  if_3108_end:
.annotate 'line', 1880
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2491
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2492
    die "Contextual $*SCOPE not found"
  vivify_2492:
  vivify_2491:
    set $S100, $P129
    iseq $I100, $S100, "has"
    if $I100, if_3110
.annotate 'line', 1900
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2493
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2494
    die "Contextual $*SCOPE not found"
  vivify_2494:
  vivify_2493:
    set $S101, $P132
    iseq $I101, $S101, "our"
    if $I101, if_3128
.annotate 'line', 1910
    new $P133, "Float"
    assign $P133, 0
    set $I102, $P133
    find_lex $P3130, "$BLOCK"
    unless_null $P3130, vivify_2495
    $P3130 = root_new ['parrot';'ResizablePMCArray']
  vivify_2495:
    set $P135, $P3130[$I102]
    unless_null $P135, vivify_2496
    new $P135, "Undef"
  vivify_2496:
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    find_lex $P140, "$name"
    unless_null $P140, vivify_2497
    new $P140, "Undef"
  vivify_2497:
.annotate 'line', 1912
    find_lex $P141, "$sigil"
    unless_null $P141, vivify_2498
    new $P141, "Undef"
  vivify_2498:
    $P142 = "vivitype"($P141)
.annotate 'line', 1910
    find_lex $P143, "$/"
    unless_null $P143, vivify_2499
    new $P143, "Undef"
  vivify_2499:
    $P144 = $P139."new"($P140 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P142 :named("viviself"), $P143 :named("node"))
    $P135."push"($P144)
.annotate 'line', 1915
    find_lex $P133, "$BLOCK"
    unless_null $P133, vivify_2500
    new $P133, "Undef"
  vivify_2500:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2501
    new $P135, "Undef"
  vivify_2501:
    $P133."symbol"($P135, "lexical" :named("scope"))
.annotate 'line', 1909
    goto if_3128_end
  if_3128:
.annotate 'line', 1904
    find_lex $P3129, "$/"
    unless_null $P3129, vivify_2502
    $P3129 = root_new ['parrot';'Hash']
  vivify_2502:
    set $P133, $P3129["variable"]
    unless_null $P133, vivify_2503
    new $P133, "Undef"
  vivify_2503:
    set $S102, $P133
    new $P135, 'String'
    set $P135, $S102
    store_lex "$name", $P135
.annotate 'line', 1905
    find_lex $P133, "$name"
    unless_null $P133, vivify_2504
    new $P133, "Undef"
  vivify_2504:
    new $P135, "ResizablePMCArray"
    push $P135, $P133
    find_lex $P136, "$/"
    unless_null $P136, vivify_2505
    new $P136, "Undef"
  vivify_2505:
    $P137 = "lexical_package_lookup"($P135, $P136)
    store_lex "$past", $P137
.annotate 'line', 1906
    find_lex $P133, "$past"
    unless_null $P133, vivify_2506
    new $P133, "Undef"
  vivify_2506:
    find_lex $P135, "$sigil"
    unless_null $P135, vivify_2507
    new $P135, "Undef"
  vivify_2507:
    $P136 = "vivitype"($P135)
    $P133."viviself"($P136)
.annotate 'line', 1907
    find_lex $P133, "$BLOCK"
    unless_null $P133, vivify_2508
    new $P133, "Undef"
  vivify_2508:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2509
    new $P135, "Undef"
  vivify_2509:
    $P133."symbol"($P135, "package" :named("scope"))
  if_3128_end:
.annotate 'line', 1900
    goto if_3110_end
  if_3110:
.annotate 'line', 1880
    .const 'Sub' $P3112 = "546_1321350766.1143" 
    capture_lex $P3112
    $P3112()
  if_3110_end:
.annotate 'line', 1919
    find_lex $P127, "$/"
    find_lex $P128, "$past"
    unless_null $P128, vivify_2539
    new $P128, "Undef"
  vivify_2539:
    $P127."!make"($P128)
.annotate 'line', 1921
    find_lex $P3132, "$/"
    unless_null $P3132, vivify_2540
    $P3132 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P128, $P3132["trait"]
    unless_null $P128, vivify_2541
    new $P128, "Undef"
  vivify_2541:
    if $P128, if_3131
    set $P127, $P128
    goto if_3131_end
  if_3131:
.annotate 'line', 1922
    find_lex $P3133, "$/"
    unless_null $P3133, vivify_2542
    $P3133 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P130, $P3133["trait"]
    unless_null $P130, vivify_2543
    new $P130, "Undef"
  vivify_2543:
    defined $I100, $P130
    unless $I100, for_undef_2544
    iter $P129, $P130
    new $P132, 'ExceptionHandler'
    set_label $P132, loop3137_handler
    $P132."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P132
  loop3137_test:
    unless $P129, loop3137_done
    shift $P131, $P129
  loop3137_redo:
    .const 'Sub' $P3135 = "547_1321350766.1143" 
    capture_lex $P3135
    $P3135($P131)
  loop3137_next:
    goto loop3137_test
  loop3137_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P133, exception, 'type'
    eq $P133, .CONTROL_LOOP_NEXT, loop3137_next
    eq $P133, .CONTROL_LOOP_REDO, loop3137_redo
  loop3137_done:
    pop_eh 
  for_undef_2544:
.annotate 'line', 1921
    set $P127, $P129
  if_3131_end:
.annotate 'line', 1872
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3111"  :anon :subid("546_1321350766.1143") :outer("545_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1887
    $P3114 = root_new ['parrot';'Hash']
    set $P3113, $P3114
    .lex "%lit_args", $P3113
.annotate 'line', 1888
    $P3116 = root_new ['parrot';'Hash']
    set $P3115, $P3116
    .lex "%obj_args", $P3115
.annotate 'line', 1882
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2510
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2511
    die "Contextual $*PKGDECL not found"
  vivify_2511:
  vivify_2510:
    concat $P136, $P135, "-attr"
    find_dynamic_lex $P132, "%*HOW"
    unless_null $P132, vivify_2512
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["%HOW"]
    unless_null $P132, vivify_2513
    die "Contextual %*HOW not found"
  vivify_2513:
  vivify_2512:
    exists $I101, $P132[$P136]
    if $I101, unless_3117_end
.annotate 'line', 1883
    find_lex $P137, "$/"
    unless_null $P137, vivify_2514
    new $P137, "Undef"
  vivify_2514:
    $P138 = $P137."CURSOR"()
    find_dynamic_lex $P141, "$*PKGDECL"
    unless_null $P141, vivify_2515
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PKGDECL"]
    unless_null $P141, vivify_2516
    die "Contextual $*PKGDECL not found"
  vivify_2516:
  vivify_2515:
    concat $P142, $P141, " packages do not support attributes"
    $P138."panic"($P142)
  unless_3117_end:
.annotate 'line', 1880
    find_lex $P3118, "%lit_args"
    unless_null $P3118, vivify_2517
    $P3118 = root_new ['parrot';'Hash']
  vivify_2517:
    find_lex $P3119, "%obj_args"
    unless_null $P3119, vivify_2518
    $P3119 = root_new ['parrot';'Hash']
  vivify_2518:
.annotate 'line', 1889
    find_lex $P130, "$name"
    unless_null $P130, vivify_2519
    new $P130, "Undef"
  vivify_2519:
    find_lex $P3120, "%lit_args"
    unless_null $P3120, vivify_2520
    $P3120 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P3120
  vivify_2520:
    set $P3120["name"], $P130
.annotate 'line', 1890
    find_lex $P3122, "$/"
    unless_null $P3122, vivify_2521
    $P3122 = root_new ['parrot';'Hash']
  vivify_2521:
    set $P130, $P3122["typename"]
    unless_null $P130, vivify_2522
    new $P130, "Undef"
  vivify_2522:
    unless $P130, if_3121_end
.annotate 'line', 1891
    new $P131, "Float"
    assign $P131, 0
    set $I101, $P131
    find_lex $P3123, "$/"
    unless_null $P3123, vivify_2523
    $P3123 = root_new ['parrot';'Hash']
  vivify_2523:
    set $P3124, $P3123["typename"]
    unless_null $P3124, vivify_2524
    $P3124 = root_new ['parrot';'ResizablePMCArray']
  vivify_2524:
    set $P132, $P3124[$I101]
    unless_null $P132, vivify_2525
    new $P132, "Undef"
  vivify_2525:
    set $S101, $P132
    new $P133, "ResizablePMCArray"
    push $P133, $S101
    find_lex $P134, "$/"
    unless_null $P134, vivify_2526
    new $P134, "Undef"
  vivify_2526:
    $P135 = "find_sym"($P133, $P134)
    find_lex $P3125, "%obj_args"
    unless_null $P3125, vivify_2527
    $P3125 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P3125
  vivify_2527:
    set $P3125["type"], $P135
  if_3121_end:
.annotate 'line', 1895
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2528
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2529
    die "Contextual $*SC not found"
  vivify_2529:
  vivify_2528:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_2530
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_2531
    die "Contextual $*PACKAGE not found"
  vivify_2531:
  vivify_2530:
    find_dynamic_lex $P138, "$*PKGDECL"
    unless_null $P138, vivify_2532
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PKGDECL"]
    unless_null $P138, vivify_2533
    die "Contextual $*PKGDECL not found"
  vivify_2533:
  vivify_2532:
    concat $P139, $P138, "-attr"
    find_dynamic_lex $P142, "%*HOW"
    unless_null $P142, vivify_2534
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["%HOW"]
    unless_null $P142, vivify_2535
    die "Contextual %*HOW not found"
  vivify_2535:
  vivify_2534:
    set $P143, $P142[$P139]
    unless_null $P143, vivify_2536
    new $P143, "Undef"
  vivify_2536:
    find_lex $P3126, "%lit_args"
    unless_null $P3126, vivify_2537
    $P3126 = root_new ['parrot';'Hash']
  vivify_2537:
    find_lex $P3127, "%obj_args"
    unless_null $P3127, vivify_2538
    $P3127 = root_new ['parrot';'Hash']
  vivify_2538:
    $P132."pkg_add_attribute"($P135, $P143, $P3126, $P3127)
.annotate 'line', 1898
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Stmts"]
    $P134 = $P133."new"()
    store_lex "$past", $P134
.annotate 'line', 1880
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3134"  :anon :subid("547_1321350766.1143") :outer("545_1321350766.1143")
    .param pmc param_3136
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1922
    .lex "$_", param_3136
    find_lex $P132, "$_"
    unless_null $P132, vivify_2545
    new $P132, "Undef"
  vivify_2545:
    $P133 = $P132."ast"()
    find_lex $P134, "$/"
    unless_null $P134, vivify_2546
    new $P134, "Undef"
  vivify_2546:
    $P135 = $P133($P134)
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("548_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3139
    .param pmc param_3140
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1927
    .lex "self", param_3139
    .lex "$/", param_3140
    find_lex $P122, "$/"
    find_lex $P3141, "$/"
    unless_null $P3141, vivify_2547
    $P3141 = root_new ['parrot';'Hash']
  vivify_2547:
    set $P123, $P3141["routine_def"]
    unless_null $P123, vivify_2548
    new $P123, "Undef"
  vivify_2548:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("549_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3143
    .param pmc param_3144
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1928
    .lex "self", param_3143
    .lex "$/", param_3144
    find_lex $P122, "$/"
    find_lex $P3145, "$/"
    unless_null $P3145, vivify_2549
    $P3145 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P123, $P3145["method_def"]
    unless_null $P123, vivify_2550
    new $P123, "Undef"
  vivify_2550:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("550_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3147
    .param pmc param_3148
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1930
    .const 'Sub' $P3224 = "556_1321350766.1143" 
    capture_lex $P3224
    .const 'Sub' $P3158 = "551_1321350766.1143" 
    capture_lex $P3158
    .lex "self", param_3147
    .lex "$/", param_3148
.annotate 'line', 1933
    new $P122, "Undef"
    set $P3149, $P122
    .lex "$past", $P3149
.annotate 'line', 1944
    new $P123, "Undef"
    set $P3150, $P123
    .lex "$block", $P3150
.annotate 'line', 1930
    find_lex $P124, "$past"
    unless_null $P124, vivify_2551
    new $P124, "Undef"
  vivify_2551:
.annotate 'line', 1934
    find_lex $P3152, "$/"
    unless_null $P3152, vivify_2552
    $P3152 = root_new ['parrot';'Hash']
  vivify_2552:
    set $P124, $P3152["onlystar"]
    unless_null $P124, vivify_2553
    new $P124, "Undef"
  vivify_2553:
    if $P124, if_3151
.annotate 'line', 1938
    find_lex $P3153, "$/"
    unless_null $P3153, vivify_2554
    $P3153 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P125, $P3153["blockoid"]
    unless_null $P125, vivify_2555
    new $P125, "Undef"
  vivify_2555:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 1939
    find_lex $P125, "$past"
    unless_null $P125, vivify_2556
    new $P125, "Undef"
  vivify_2556:
    $P125."blocktype"("declaration")
.annotate 'line', 1940
    find_dynamic_lex $P128, "$*RETURN_USED"
    unless_null $P128, vivify_2557
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$RETURN_USED"]
    unless_null $P128, vivify_2558
    die "Contextual $*RETURN_USED not found"
  vivify_2558:
  vivify_2557:
    unless $P128, if_3154_end
.annotate 'line', 1941
    find_lex $P129, "$past"
    unless_null $P129, vivify_2559
    new $P129, "Undef"
  vivify_2559:
    $P129."control"("return_pir")
  if_3154_end:
.annotate 'line', 1937
    goto if_3151_end
  if_3151:
.annotate 'line', 1935
    $P125 = "only_star_block"()
    store_lex "$past", $P125
  if_3151_end:
.annotate 'line', 1944
    find_lex $P124, "$past"
    unless_null $P124, vivify_2560
    new $P124, "Undef"
  vivify_2560:
    store_lex "$block", $P124
.annotate 'line', 1946
    find_lex $P3156, "$/"
    unless_null $P3156, vivify_2561
    $P3156 = root_new ['parrot';'Hash']
  vivify_2561:
    set $P124, $P3156["deflongname"]
    unless_null $P124, vivify_2562
    new $P124, "Undef"
  vivify_2562:
    unless $P124, if_3155_end
    .const 'Sub' $P3158 = "551_1321350766.1143" 
    capture_lex $P3158
    $P3158()
  if_3155_end:
.annotate 'line', 2047
    find_lex $P124, "$block"
    unless_null $P124, vivify_2668
    new $P124, "Undef"
  vivify_2668:
    find_lex $P3219, "$past"
    unless_null $P3219, vivify_2669
    $P3219 = root_new ['parrot';'Hash']
    store_lex "$past", $P3219
  vivify_2669:
    set $P3219["block_past"], $P124
.annotate 'line', 2048
    find_lex $P3221, "$/"
    unless_null $P3221, vivify_2670
    $P3221 = root_new ['parrot';'Hash']
  vivify_2670:
    set $P124, $P3221["trait"]
    unless_null $P124, vivify_2671
    new $P124, "Undef"
  vivify_2671:
    unless $P124, if_3220_end
.annotate 'line', 2049
    find_lex $P3222, "$/"
    unless_null $P3222, vivify_2672
    $P3222 = root_new ['parrot';'Hash']
  vivify_2672:
    set $P127, $P3222["trait"]
    unless_null $P127, vivify_2673
    new $P127, "Undef"
  vivify_2673:
    defined $I100, $P127
    unless $I100, for_undef_2674
    iter $P125, $P127
    new $P129, 'ExceptionHandler'
    set_label $P129, loop3226_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop3226_test:
    unless $P125, loop3226_done
    shift $P128, $P125
  loop3226_redo:
    .const 'Sub' $P3224 = "556_1321350766.1143" 
    capture_lex $P3224
    $P3224($P128)
  loop3226_next:
    goto loop3226_test
  loop3226_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3226_next
    eq $P130, .CONTROL_LOOP_REDO, loop3226_redo
  loop3226_done:
    pop_eh 
  for_undef_2674:
  if_3220_end:
.annotate 'line', 2052
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2677
    new $P125, "Undef"
  vivify_2677:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1930
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3157"  :anon :subid("551_1321350766.1143") :outer("550_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1946
    .const 'Sub' $P3203 = "555_1321350766.1143" 
    capture_lex $P3203
    .const 'Sub' $P3169 = "552_1321350766.1143" 
    capture_lex $P3169
.annotate 'line', 1947
    new $P125, "Undef"
    set $P3159, $P125
    .lex "$name", $P3159
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3160, "$/"
    unless_null $P3160, vivify_2563
    $P3160 = root_new ['parrot';'Hash']
  vivify_2563:
    set $P3161, $P3160["sigil"]
    unless_null $P3161, vivify_2564
    $P3161 = root_new ['parrot';'ResizablePMCArray']
  vivify_2564:
    set $P128, $P3161[$I100]
    unless_null $P128, vivify_2565
    new $P128, "Undef"
  vivify_2565:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    new $P130, "Float"
    assign $P130, 0
    set $I101, $P130
    find_lex $P3162, "$/"
    unless_null $P3162, vivify_2566
    $P3162 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P3163, $P3162["deflongname"]
    unless_null $P3163, vivify_2567
    $P3163 = root_new ['parrot';'ResizablePMCArray']
  vivify_2567:
    set $P131, $P3163[$I101]
    unless_null $P131, vivify_2568
    new $P131, "Undef"
  vivify_2568:
    $S101 = $P131."ast"()
    concat $P132, $P129, $S101
    store_lex "$name", $P132
.annotate 'line', 1948
    find_lex $P127, "$past"
    unless_null $P127, vivify_2569
    new $P127, "Undef"
  vivify_2569:
    find_lex $P128, "$name"
    unless_null $P128, vivify_2570
    new $P128, "Undef"
  vivify_2570:
    $P127."name"($P128)
.annotate 'line', 1949
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2571
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2572
    die "Contextual $*SCOPE not found"
  vivify_2572:
  vivify_2571:
    set $S100, $P131
    iseq $I100, $S100, ""
    unless $I100, unless_3166
    new $P128, 'Integer'
    set $P128, $I100
    goto unless_3166_end
  unless_3166:
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2573
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2574
    die "Contextual $*SCOPE not found"
  vivify_2574:
  vivify_2573:
    set $S101, $P134
    iseq $I101, $S101, "my"
    new $P128, 'Integer'
    set $P128, $I101
  unless_3166_end:
    unless $P128, unless_3165
    set $P127, $P128
    goto unless_3165_end
  unless_3165:
    find_dynamic_lex $P137, "$*SCOPE"
    unless_null $P137, vivify_2575
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SCOPE"]
    unless_null $P137, vivify_2576
    die "Contextual $*SCOPE not found"
  vivify_2576:
  vivify_2575:
    set $S102, $P137
    iseq $I102, $S102, "our"
    new $P127, 'Integer'
    set $P127, $I102
  unless_3165_end:
    if $P127, if_3164
.annotate 'line', 2037
    find_lex $P138, "$/"
    unless_null $P138, vivify_2577
    new $P138, "Undef"
  vivify_2577:
    $P139 = $P138."CURSOR"()
    find_dynamic_lex $P142, "$*SCOPE"
    unless_null $P142, vivify_2578
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["$SCOPE"]
    unless_null $P142, vivify_2579
    die "Contextual $*SCOPE not found"
  vivify_2579:
  vivify_2578:
    concat $P143, $P142, " scoped routines are not supported yet"
    $P139."panic"($P143)
.annotate 'line', 2036
    goto if_3164_end
  if_3164:
.annotate 'line', 1950
    find_dynamic_lex $P140, "$*MULTINESS"
    unless_null $P140, vivify_2580
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MULTINESS"]
    unless_null $P140, vivify_2581
    die "Contextual $*MULTINESS not found"
  vivify_2581:
  vivify_2580:
    set $S103, $P140
    iseq $I103, $S103, "multi"
    if $I103, if_3167
.annotate 'line', 2001
    find_dynamic_lex $P145, "$*MULTINESS"
    unless_null $P145, vivify_2582
    get_hll_global $P142, "GLOBAL"
    get_who $P144, $P142
    set $P145, $P144["$MULTINESS"]
    unless_null $P145, vivify_2583
    die "Contextual $*MULTINESS not found"
  vivify_2583:
  vivify_2582:
    set $S104, $P145
    iseq $I104, $S104, "proto"
    if $I104, if_3201
.annotate 'line', 2020
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P149, "Float"
    assign $P149, 0
    set $I106, $P149
    find_lex $P151, "$?PACKAGE"
    get_who $P152, $P151
    set $P3211, $P152["@BLOCK"]
    unless_null $P3211, vivify_2584
    $P3211 = root_new ['parrot';'ResizablePMCArray']
  vivify_2584:
    set $P3212, $P3211[$I106]
    unless_null $P3212, vivify_2585
    $P3212 = root_new ['parrot';'ResizablePMCArray']
  vivify_2585:
    set $P153, $P3212[$I105]
    unless_null $P153, vivify_2586
    new $P153, "Undef"
  vivify_2586:
    get_hll_global $P154, "GLOBAL"
    nqp_get_package_through_who $P155, $P154, "PAST"
    get_who $P156, $P155
    set $P157, $P156["Var"]
    find_lex $P158, "$name"
    unless_null $P158, vivify_2587
    new $P158, "Undef"
  vivify_2587:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2588
    new $P159, "Undef"
  vivify_2588:
    $P160 = $P157."new"($P158 :named("name"), 1 :named("isdecl"), $P159 :named("viviself"), "lexical" :named("scope"))
    $P153."push"($P160)
.annotate 'line', 2022
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3213, $P151["@BLOCK"]
    unless_null $P3213, vivify_2589
    $P3213 = root_new ['parrot';'ResizablePMCArray']
  vivify_2589:
    set $P152, $P3213[$I105]
    unless_null $P152, vivify_2590
    new $P152, "Undef"
  vivify_2590:
    find_lex $P153, "$name"
    unless_null $P153, vivify_2591
    new $P153, "Undef"
  vivify_2591:
    $P152."symbol"($P153, "lexical" :named("scope"))
.annotate 'line', 2023
    find_dynamic_lex $P151, "$*SCOPE"
    unless_null $P151, vivify_2592
    get_hll_global $P147, "GLOBAL"
    get_who $P149, $P147
    set $P151, $P149["$SCOPE"]
    unless_null $P151, vivify_2593
    die "Contextual $*SCOPE not found"
  vivify_2593:
  vivify_2592:
    set $S105, $P151
    iseq $I105, $S105, "our"
    unless $I105, if_3214_end
.annotate 'line', 2026
    find_dynamic_lex $P154, "$*SC"
    unless_null $P154, vivify_2594
    get_hll_global $P152, "GLOBAL"
    get_who $P153, $P152
    set $P154, $P153["$SC"]
    unless_null $P154, vivify_2595
    die "Contextual $*SC not found"
  vivify_2595:
  vivify_2594:
    find_dynamic_lex $P157, "$*PACKAGE"
    unless_null $P157, vivify_2596
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["$PACKAGE"]
    unless_null $P157, vivify_2597
    die "Contextual $*PACKAGE not found"
  vivify_2597:
  vivify_2596:
    find_lex $P158, "$name"
    unless_null $P158, vivify_2598
    new $P158, "Undef"
  vivify_2598:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2599
    new $P159, "Undef"
  vivify_2599:
    $P154."install_package_routine"($P157, $P158, $P159)
.annotate 'line', 2027
    new $P152, "Float"
    assign $P152, 0
    set $I106, $P152
    new $P153, "Float"
    assign $P153, 0
    set $I107, $P153
    find_lex $P154, "$?PACKAGE"
    get_who $P155, $P154
    set $P3215, $P155["@BLOCK"]
    unless_null $P3215, vivify_2600
    $P3215 = root_new ['parrot';'ResizablePMCArray']
  vivify_2600:
    set $P3216, $P3215[$I107]
    unless_null $P3216, vivify_2601
    $P3216 = root_new ['parrot';'ResizablePMCArray']
  vivify_2601:
    set $P156, $P3216[$I106]
    unless_null $P156, vivify_2602
    new $P156, "Undef"
  vivify_2602:
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 2029
    find_lex $P161, "$name"
    unless_null $P161, vivify_2603
    new $P161, "Undef"
  vivify_2603:
    new $P162, "ResizablePMCArray"
    push $P162, $P161
    find_lex $P163, "$/"
    unless_null $P163, vivify_2604
    new $P163, "Undef"
  vivify_2604:
    $P164 = "lexical_package_lookup"($P162, $P163)
.annotate 'line', 2030
    get_hll_global $P165, "GLOBAL"
    nqp_get_package_through_who $P166, $P165, "PAST"
    get_who $P167, $P166
    set $P168, $P167["Var"]
    find_lex $P169, "$name"
    unless_null $P169, vivify_2605
    new $P169, "Undef"
  vivify_2605:
    $P170 = $P168."new"($P169 :named("name"), "lexical" :named("scope"))
    $P171 = $P160."new"($P164, $P170, "bind_6model" :named("pasttype"))
.annotate 'line', 2027
    $P156."push"($P171)
  if_3214_end:
.annotate 'line', 2019
    goto if_3201_end
  if_3201:
.annotate 'line', 2001
    .const 'Sub' $P3203 = "555_1321350766.1143" 
    capture_lex $P3203
    $P3203()
  if_3201_end:
    goto if_3167_end
  if_3167:
.annotate 'line', 1950
    .const 'Sub' $P3169 = "552_1321350766.1143" 
    capture_lex $P3169
    $P3169()
  if_3167_end:
.annotate 'line', 2034
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    find_lex $P142, "$name"
    unless_null $P142, vivify_2663
    new $P142, "Undef"
  vivify_2663:
    $P143 = $P141."new"($P142 :named("name"))
    store_lex "$past", $P143
  if_3164_end:
.annotate 'line', 2041
    find_lex $P129, "$name"
    unless_null $P129, vivify_2664
    new $P129, "Undef"
  vivify_2664:
    set $S100, $P129
    iseq $I100, $S100, "MAIN"
    if $I100, if_3218
    new $P128, 'Integer'
    set $P128, $I100
    goto if_3218_end
  if_3218:
    find_dynamic_lex $P132, "$*MULTINESS"
    unless_null $P132, vivify_2665
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$MULTINESS"]
    unless_null $P132, vivify_2666
    die "Contextual $*MULTINESS not found"
  vivify_2666:
  vivify_2665:
    set $S101, $P132
    isne $I101, $S101, "multi"
    new $P128, 'Integer'
    set $P128, $I101
  if_3218_end:
    if $P128, if_3217
    set $P127, $P128
    goto if_3217_end
  if_3217:
.annotate 'line', 2042
    find_lex $P133, "$block"
    unless_null $P133, vivify_2667
    new $P133, "Undef"
  vivify_2667:
    store_dynamic_lex "$*MAIN_SUB", $P133
.annotate 'line', 2041
    set $P127, $P133
  if_3217_end:
.annotate 'line', 1946
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3202"  :anon :subid("555_1321350766.1143") :outer("551_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2006
    new $P146, "Undef"
    set $P3204, $P146
    .lex "$cholder", $P3204
.annotate 'line', 2005
    find_dynamic_lex $P149, "$*SCOPE"
    unless_null $P149, vivify_2606
    get_hll_global $P147, "GLOBAL"
    get_who $P148, $P147
    set $P149, $P148["$SCOPE"]
    unless_null $P149, vivify_2607
    die "Contextual $*SCOPE not found"
  vivify_2607:
  vivify_2606:
    set $S105, $P149
    iseq $I105, $S105, "our"
    unless $I105, if_3205_end
    die "our-scoped protos not yet implemented"
  if_3205_end:
.annotate 'line', 2006
    get_hll_global $P147, "GLOBAL"
    nqp_get_package_through_who $P148, $P147, "PAST"
    get_who $P149, $P148
    set $P151, $P149["Op"]
    $P152 = $P151."new"("list" :named("pasttype"))
    store_lex "$cholder", $P152
.annotate 'line', 2007
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P148, "Float"
    assign $P148, 0
    set $I106, $P148
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3206, $P151["@BLOCK"]
    unless_null $P3206, vivify_2608
    $P3206 = root_new ['parrot';'ResizablePMCArray']
  vivify_2608:
    set $P3207, $P3206[$I106]
    unless_null $P3207, vivify_2609
    $P3207 = root_new ['parrot';'ResizablePMCArray']
  vivify_2609:
    set $P152, $P3207[$I105]
    unless_null $P152, vivify_2610
    new $P152, "Undef"
  vivify_2610:
    get_hll_global $P153, "GLOBAL"
    nqp_get_package_through_who $P154, $P153, "PAST"
    get_who $P155, $P154
    set $P156, $P155["Var"]
    find_lex $P157, "$name"
    unless_null $P157, vivify_2611
    new $P157, "Undef"
  vivify_2611:
    find_lex $P158, "$past"
    unless_null $P158, vivify_2612
    new $P158, "Undef"
  vivify_2612:
    $P159 = $P156."new"($P157 :named("name"), 1 :named("isdecl"), $P158 :named("viviself"), "lexical" :named("scope"))
    $P152."push"($P159)
.annotate 'line', 2009
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P148, "Float"
    assign $P148, 0
    set $I106, $P148
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3208, $P151["@BLOCK"]
    unless_null $P3208, vivify_2613
    $P3208 = root_new ['parrot';'ResizablePMCArray']
  vivify_2613:
    set $P3209, $P3208[$I106]
    unless_null $P3209, vivify_2614
    $P3209 = root_new ['parrot';'ResizablePMCArray']
  vivify_2614:
    set $P152, $P3209[$I105]
    unless_null $P152, vivify_2615
    new $P152, "Undef"
  vivify_2615:
    get_hll_global $P153, "GLOBAL"
    nqp_get_package_through_who $P154, $P153, "PAST"
    get_who $P155, $P154
    set $P156, $P155["Op"]
.annotate 'line', 2011
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Var"]
    find_lex $P161, "$name"
    unless_null $P161, vivify_2616
    new $P161, "Undef"
  vivify_2616:
    $P162 = $P160."new"($P161 :named("name"))
    find_lex $P163, "$cholder"
    unless_null $P163, vivify_2617
    new $P163, "Undef"
  vivify_2617:
    $P164 = $P156."new"($P162, $P163, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 2009
    $P152."push"($P164)
.annotate 'line', 2014
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    find_lex $P148, "$?PACKAGE"
    get_who $P149, $P148
    set $P3210, $P149["@BLOCK"]
    unless_null $P3210, vivify_2618
    $P3210 = root_new ['parrot';'ResizablePMCArray']
  vivify_2618:
    set $P151, $P3210[$I105]
    unless_null $P151, vivify_2619
    new $P151, "Undef"
  vivify_2619:
    find_lex $P152, "$name"
    unless_null $P152, vivify_2620
    new $P152, "Undef"
  vivify_2620:
    find_lex $P153, "$cholder"
    unless_null $P153, vivify_2621
    new $P153, "Undef"
  vivify_2621:
    $P151."symbol"($P152, "lexical" :named("scope"), 1 :named("proto"), $P153 :named("cholder"))
.annotate 'line', 2017
    find_lex $P147, "$past"
    unless_null $P147, vivify_2622
    new $P147, "Undef"
  vivify_2622:
    $P148 = $P147."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 2001
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3168"  :anon :subid("552_1321350766.1143") :outer("551_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1950
    .const 'Sub' $P3179 = "553_1321350766.1143" 
    capture_lex $P3179
.annotate 'line', 1953
    new $P141, "Undef"
    set $P3170, $P141
    .lex "$cholder", $P3170
.annotate 'line', 1954
    $P3172 = root_new ['parrot';'Hash']
    set $P3171, $P3172
    .lex "%sym", $P3171
.annotate 'line', 1952
    find_dynamic_lex $P144, "$*SCOPE"
    unless_null $P144, vivify_2623
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$SCOPE"]
    unless_null $P144, vivify_2624
    die "Contextual $*SCOPE not found"
  vivify_2624:
  vivify_2623:
    set $S104, $P144
    iseq $I104, $S104, "our"
    unless $I104, if_3173_end
    die "our-scoped multis not yet implemented"
  if_3173_end:
.annotate 'line', 1950
    find_lex $P142, "$cholder"
    unless_null $P142, vivify_2625
    new $P142, "Undef"
  vivify_2625:
.annotate 'line', 1954
    new $P142, "Float"
    assign $P142, 0
    set $I104, $P142
    find_lex $P143, "$?PACKAGE"
    get_who $P144, $P143
    set $P3174, $P144["@BLOCK"]
    unless_null $P3174, vivify_2626
    $P3174 = root_new ['parrot';'ResizablePMCArray']
  vivify_2626:
    set $P145, $P3174[$I104]
    unless_null $P145, vivify_2627
    new $P145, "Undef"
  vivify_2627:
    find_lex $P146, "$name"
    unless_null $P146, vivify_2628
    new $P146, "Undef"
  vivify_2628:
    $P147 = $P145."symbol"($P146)
    store_lex "%sym", $P147
.annotate 'line', 1955
    find_lex $P3176, "%sym"
    unless_null $P3176, vivify_2629
    $P3176 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P142, $P3176["cholder"]
    unless_null $P142, vivify_2630
    new $P142, "Undef"
  vivify_2630:
    if $P142, if_3175
.annotate 'line', 1960
    .const 'Sub' $P3179 = "553_1321350766.1143" 
    capture_lex $P3179
    $P3179()
    goto if_3175_end
  if_3175:
.annotate 'line', 1956
    find_lex $P3177, "%sym"
    unless_null $P3177, vivify_2658
    $P3177 = root_new ['parrot';'Hash']
  vivify_2658:
    set $P143, $P3177["cholder"]
    unless_null $P143, vivify_2659
    new $P143, "Undef"
  vivify_2659:
    store_lex "$cholder", $P143
  if_3175_end:
.annotate 'line', 1996
    find_lex $P142, "$cholder"
    unless_null $P142, vivify_2660
    new $P142, "Undef"
  vivify_2660:
    find_lex $P143, "$past"
    unless_null $P143, vivify_2661
    new $P143, "Undef"
  vivify_2661:
    $P142."push"($P143)
.annotate 'line', 1999
    find_lex $P142, "$past"
    unless_null $P142, vivify_2662
    new $P142, "Undef"
  vivify_2662:
    $P143 = "attach_multi_signature"($P142)
.annotate 'line', 1950
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3178"  :anon :subid("553_1321350766.1143") :outer("552_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1960
    .const 'Sub' $P3186 = "554_1321350766.1143" 
    capture_lex $P3186
.annotate 'line', 1967
    new $P143, "Undef"
    set $P3180, $P143
    .lex "$found_proto", $P3180
.annotate 'line', 1985
    new $P144, "Undef"
    set $P3181, $P144
    .lex "$dispatch_setup", $P3181
.annotate 'line', 1962
    find_lex $P3183, "%sym"
    unless_null $P3183, vivify_2631
    $P3183 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P145, $P3183["proto"]
    unless_null $P145, vivify_2632
    new $P145, "Undef"
  vivify_2632:
    unless $P145, if_3182_end
.annotate 'line', 1965
    find_lex $P146, "$/"
    unless_null $P146, vivify_2633
    new $P146, "Undef"
  vivify_2633:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_3182_end:
.annotate 'line', 1960
    find_lex $P145, "$found_proto"
    unless_null $P145, vivify_2634
    new $P145, "Undef"
  vivify_2634:
.annotate 'line', 1968
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3184, $P147["@BLOCK"]
    unless_null $P3184, vivify_2635
    $P3184 = root_new ['parrot';'ResizablePMCArray']
  vivify_2635:
    defined $I104, $P3184
    unless $I104, for_undef_2636
    iter $P145, $P3184
    new $P151, 'ExceptionHandler'
    set_label $P151, loop3196_handler
    $P151."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P151
  loop3196_test:
    unless $P145, loop3196_done
    shift $P148, $P145
  loop3196_redo:
    .const 'Sub' $P3186 = "554_1321350766.1143" 
    capture_lex $P3186
    $P3186($P148)
  loop3196_next:
    goto loop3196_test
  loop3196_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P152, exception, 'type'
    eq $P152, .CONTROL_LOOP_NEXT, loop3196_next
    eq $P152, .CONTROL_LOOP_REDO, loop3196_redo
  loop3196_done:
    pop_eh 
  for_undef_2636:
.annotate 'line', 1979
    find_lex $P145, "$found_proto"
    unless_null $P145, vivify_2645
    new $P145, "Undef"
  vivify_2645:
    if $P145, unless_3197_end
.annotate 'line', 1980
    find_lex $P146, "$/"
    unless_null $P146, vivify_2646
    new $P146, "Undef"
  vivify_2646:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_3197_end:
.annotate 'line', 1984
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    $P149 = $P148."new"("list" :named("pasttype"))
    store_lex "$cholder", $P149
.annotate 'line', 1985
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
.annotate 'line', 1987
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Var"]
    find_lex $P154, "$name"
    unless_null $P154, vivify_2647
    new $P154, "Undef"
  vivify_2647:
    $P155 = $P153."new"($P154 :named("name"), "outer" :named("scope"))
    find_lex $P156, "$cholder"
    unless_null $P156, vivify_2648
    new $P156, "Undef"
  vivify_2648:
    $P157 = $P148."new"($P155, $P156, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1985
    store_lex "$dispatch_setup", $P157
.annotate 'line', 1990
    new $P145, "Float"
    assign $P145, 0
    set $I104, $P145
    new $P146, "Float"
    assign $P146, 0
    set $I105, $P146
    find_lex $P147, "$?PACKAGE"
    get_who $P148, $P147
    set $P3198, $P148["@BLOCK"]
    unless_null $P3198, vivify_2649
    $P3198 = root_new ['parrot';'ResizablePMCArray']
  vivify_2649:
    set $P3199, $P3198[$I105]
    unless_null $P3199, vivify_2650
    $P3199 = root_new ['parrot';'ResizablePMCArray']
  vivify_2650:
    set $P149, $P3199[$I104]
    unless_null $P149, vivify_2651
    new $P149, "Undef"
  vivify_2651:
    get_hll_global $P151, "GLOBAL"
    nqp_get_package_through_who $P152, $P151, "PAST"
    get_who $P153, $P152
    set $P154, $P153["Var"]
    find_lex $P155, "$name"
    unless_null $P155, vivify_2652
    new $P155, "Undef"
  vivify_2652:
    find_lex $P156, "$dispatch_setup"
    unless_null $P156, vivify_2653
    new $P156, "Undef"
  vivify_2653:
    $P157 = $P154."new"($P155 :named("name"), 1 :named("isdecl"), $P156 :named("viviself"), "lexical" :named("scope"))
    $P149."push"($P157)
.annotate 'line', 1992
    new $P145, "Float"
    assign $P145, 0
    set $I104, $P145
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3200, $P147["@BLOCK"]
    unless_null $P3200, vivify_2654
    $P3200 = root_new ['parrot';'ResizablePMCArray']
  vivify_2654:
    set $P148, $P3200[$I104]
    unless_null $P148, vivify_2655
    new $P148, "Undef"
  vivify_2655:
    find_lex $P149, "$name"
    unless_null $P149, vivify_2656
    new $P149, "Undef"
  vivify_2656:
    find_lex $P151, "$cholder"
    unless_null $P151, vivify_2657
    new $P151, "Undef"
  vivify_2657:
    $P152 = $P148."symbol"($P149, "lexical" :named("scope"), $P151 :named("cholder"))
.annotate 'line', 1960
    .return ($P152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3185"  :anon :subid("554_1321350766.1143") :outer("553_1321350766.1143")
    .param pmc param_3189
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1969
    $P3188 = root_new ['parrot';'Hash']
    set $P3187, $P3188
    .lex "%sym", $P3187
    .lex "$_", param_3189
    find_lex $P149, "$_"
    unless_null $P149, vivify_2637
    new $P149, "Undef"
  vivify_2637:
    find_lex $P151, "$name"
    unless_null $P151, vivify_2638
    new $P151, "Undef"
  vivify_2638:
    $P152 = $P149."symbol"($P151)
    store_lex "%sym", $P152
.annotate 'line', 1970
    find_lex $P3192, "%sym"
    unless_null $P3192, vivify_2639
    $P3192 = root_new ['parrot';'Hash']
  vivify_2639:
    set $P152, $P3192["proto"]
    unless_null $P152, vivify_2640
    new $P152, "Undef"
  vivify_2640:
    unless $P152, unless_3191
    set $P151, $P152
    goto unless_3191_end
  unless_3191:
    find_lex $P3193, "%sym"
    unless_null $P3193, vivify_2641
    $P3193 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P153, $P3193["cholder"]
    unless_null $P153, vivify_2642
    new $P153, "Undef"
  vivify_2642:
    set $P151, $P153
  unless_3191_end:
    if $P151, if_3190
.annotate 'line', 1973
    find_lex $P3195, "%sym"
    unless_null $P3195, vivify_2643
    $P3195 = root_new ['parrot';'Hash']
  vivify_2643:
    if $P3195, if_3194
    set $P155, $P3195
    goto if_3194_end
  if_3194:
.annotate 'line', 1974
    find_lex $P156, "$/"
    unless_null $P156, vivify_2644
    new $P156, "Undef"
  vivify_2644:
    $P157 = $P156."CURSOR"()
    $P158 = $P157."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1973
    set $P155, $P158
  if_3194_end:
    set $P149, $P155
.annotate 'line', 1970
    goto if_3190_end
  if_3190:
.annotate 'line', 1971
    new $P154, "Float"
    assign $P154, 1
    store_lex "$found_proto", $P154
.annotate 'line', 1970
    set $P149, $P154
  if_3190_end:
.annotate 'line', 1968
    .return ($P149)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3223"  :anon :subid("556_1321350766.1143") :outer("550_1321350766.1143")
    .param pmc param_3225
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2049
    .lex "$_", param_3225
    find_lex $P129, "$_"
    unless_null $P129, vivify_2675
    new $P129, "Undef"
  vivify_2675:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2676
    new $P131, "Undef"
  vivify_2676:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("557_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3228
    .param pmc param_3229
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2056
    .const 'Sub' $P3257 = "559_1321350766.1143" 
    capture_lex $P3257
    .const 'Sub' $P3241 = "558_1321350766.1143" 
    capture_lex $P3241
    .lex "self", param_3228
    .lex "$/", param_3229
.annotate 'line', 2059
    new $P122, "Undef"
    set $P3230, $P122
    .lex "$past", $P3230
.annotate 'line', 2056
    find_lex $P123, "$past"
    unless_null $P123, vivify_2678
    new $P123, "Undef"
  vivify_2678:
.annotate 'line', 2060
    find_lex $P3232, "$/"
    unless_null $P3232, vivify_2679
    $P3232 = root_new ['parrot';'Hash']
  vivify_2679:
    set $P123, $P3232["onlystar"]
    unless_null $P123, vivify_2680
    new $P123, "Undef"
  vivify_2680:
    if $P123, if_3231
.annotate 'line', 2064
    find_lex $P3233, "$/"
    unless_null $P3233, vivify_2681
    $P3233 = root_new ['parrot';'Hash']
  vivify_2681:
    set $P124, $P3233["blockoid"]
    unless_null $P124, vivify_2682
    new $P124, "Undef"
  vivify_2682:
    $P125 = $P124."ast"()
    store_lex "$past", $P125
.annotate 'line', 2065
    find_lex $P124, "$past"
    unless_null $P124, vivify_2683
    new $P124, "Undef"
  vivify_2683:
    $P124."blocktype"("declaration")
.annotate 'line', 2066
    find_dynamic_lex $P127, "$*RETURN_USED"
    unless_null $P127, vivify_2684
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$RETURN_USED"]
    unless_null $P127, vivify_2685
    die "Contextual $*RETURN_USED not found"
  vivify_2685:
  vivify_2684:
    unless $P127, if_3234_end
.annotate 'line', 2067
    find_lex $P128, "$past"
    unless_null $P128, vivify_2686
    new $P128, "Undef"
  vivify_2686:
    $P128."control"("return_pir")
  if_3234_end:
.annotate 'line', 2063
    goto if_3231_end
  if_3231:
.annotate 'line', 2061
    $P124 = "only_star_block"()
    store_lex "$past", $P124
  if_3231_end:
.annotate 'line', 2072
    find_lex $P3236, "$past"
    unless_null $P3236, vivify_2687
    $P3236 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P123, $P3236["signature_has_invocant"]
    unless_null $P123, vivify_2688
    new $P123, "Undef"
  vivify_2688:
    if $P123, unless_3235_end
.annotate 'line', 2073
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P3237, "$past"
    unless_null $P3237, vivify_2689
    $P3237 = root_new ['parrot';'ResizablePMCArray']
  vivify_2689:
    set $P125, $P3237[$I100]
    unless_null $P125, vivify_2690
    new $P125, "Undef"
  vivify_2690:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2075
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2691
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2692
    die "Contextual $*SC not found"
  vivify_2692:
  vivify_2691:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2693
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2694
    die "Contextual $*PACKAGE not found"
  vivify_2694:
  vivify_2693:
    $P137 = $P133."get_object_sc_ref_past"($P136)
.annotate 'line', 2073
    $P138 = $P130."new"("self" :named("name"), "parameter" :named("scope"), $P137 :named("multitype"))
    $P125."unshift"($P138)
  unless_3235_end:
.annotate 'line', 2078
    find_lex $P123, "$past"
    unless_null $P123, vivify_2695
    new $P123, "Undef"
  vivify_2695:
    $P123."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2081
    find_lex $P3239, "$/"
    unless_null $P3239, vivify_2696
    $P3239 = root_new ['parrot';'Hash']
  vivify_2696:
    set $P123, $P3239["deflongname"]
    unless_null $P123, vivify_2697
    new $P123, "Undef"
  vivify_2697:
    unless $P123, if_3238_end
    .const 'Sub' $P3241 = "558_1321350766.1143" 
    capture_lex $P3241
    $P3241()
  if_3238_end:
.annotate 'line', 2108
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2732
    new $P124, "Undef"
  vivify_2732:
    $P123."!make"($P124)
.annotate 'line', 2109
    find_lex $P123, "$past"
    unless_null $P123, vivify_2733
    new $P123, "Undef"
  vivify_2733:
    find_lex $P3252, "$past"
    unless_null $P3252, vivify_2734
    $P3252 = root_new ['parrot';'Hash']
    store_lex "$past", $P3252
  vivify_2734:
    set $P3252["block_past"], $P123
.annotate 'line', 2110
    find_lex $P3254, "$/"
    unless_null $P3254, vivify_2735
    $P3254 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P124, $P3254["trait"]
    unless_null $P124, vivify_2736
    new $P124, "Undef"
  vivify_2736:
    if $P124, if_3253
    set $P123, $P124
    goto if_3253_end
  if_3253:
.annotate 'line', 2111
    find_lex $P3255, "$/"
    unless_null $P3255, vivify_2737
    $P3255 = root_new ['parrot';'Hash']
  vivify_2737:
    set $P127, $P3255["trait"]
    unless_null $P127, vivify_2738
    new $P127, "Undef"
  vivify_2738:
    defined $I100, $P127
    unless $I100, for_undef_2739
    iter $P125, $P127
    new $P129, 'ExceptionHandler'
    set_label $P129, loop3259_handler
    $P129."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P129
  loop3259_test:
    unless $P125, loop3259_done
    shift $P128, $P125
  loop3259_redo:
    .const 'Sub' $P3257 = "559_1321350766.1143" 
    capture_lex $P3257
    $P3257($P128)
  loop3259_next:
    goto loop3259_test
  loop3259_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3259_next
    eq $P130, .CONTROL_LOOP_REDO, loop3259_redo
  loop3259_done:
    pop_eh 
  for_undef_2739:
.annotate 'line', 2110
    set $P123, $P125
  if_3253_end:
.annotate 'line', 2056
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3240"  :anon :subid("558_1321350766.1143") :outer("557_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2083
    new $P124, "Undef"
    set $P3242, $P124
    .lex "$name", $P3242
.annotate 'line', 2091
    new $P125, "Undef"
    set $P3243, $P125
    .lex "$meta_meth", $P3243
.annotate 'line', 2092
    new $P127, "Undef"
    set $P3244, $P127
    .lex "$is_dispatcher", $P3244
.annotate 'line', 2083
    find_lex $P3245, "$/"
    unless_null $P3245, vivify_2698
    $P3245 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P128, $P3245["private"]
    unless_null $P128, vivify_2699
    new $P128, "Undef"
  vivify_2699:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    new $P130, "Float"
    assign $P130, 0
    set $I100, $P130
    find_lex $P3246, "$/"
    unless_null $P3246, vivify_2700
    $P3246 = root_new ['parrot';'Hash']
  vivify_2700:
    set $P3247, $P3246["deflongname"]
    unless_null $P3247, vivify_2701
    $P3247 = root_new ['parrot';'ResizablePMCArray']
  vivify_2701:
    set $P131, $P3247[$I100]
    unless_null $P131, vivify_2702
    new $P131, "Undef"
  vivify_2702:
    $P132 = $P131."ast"()
    set $S101, $P132
    concat $P133, $P129, $S101
    store_lex "$name", $P133
.annotate 'line', 2084
    find_lex $P128, "$past"
    unless_null $P128, vivify_2703
    new $P128, "Undef"
  vivify_2703:
    find_lex $P129, "$name"
    unless_null $P129, vivify_2704
    new $P129, "Undef"
  vivify_2704:
    $P128."name"($P129)
.annotate 'line', 2088
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2705
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2706
    die "Contextual $*MULTINESS not found"
  vivify_2706:
  vivify_2705:
    set $S100, $P130
    iseq $I100, $S100, "multi"
    unless $I100, if_3248_end
    find_lex $P131, "$past"
    unless_null $P131, vivify_2707
    new $P131, "Undef"
  vivify_2707:
    "attach_multi_signature"($P131)
  if_3248_end:
.annotate 'line', 2091
    find_dynamic_lex $P131, "$*MULTINESS"
    unless_null $P131, vivify_2708
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$MULTINESS"]
    unless_null $P131, vivify_2709
    die "Contextual $*MULTINESS not found"
  vivify_2709:
  vivify_2708:
    set $S100, $P131
    iseq $I100, $S100, "multi"
    if $I100, if_3249
    new $P133, "String"
    assign $P133, "add_method"
    set $P128, $P133
    goto if_3249_end
  if_3249:
    new $P132, "String"
    assign $P132, "add_multi_method"
    set $P128, $P132
  if_3249_end:
    store_lex "$meta_meth", $P128
.annotate 'line', 2092
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2710
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2711
    die "Contextual $*MULTINESS not found"
  vivify_2711:
  vivify_2710:
    set $S100, $P130
    iseq $I100, $S100, "proto"
    new $P131, 'Integer'
    set $P131, $I100
    store_lex "$is_dispatcher", $P131
.annotate 'line', 2093
    find_dynamic_lex $P130, "$*SC"
    unless_null $P130, vivify_2712
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SC"]
    unless_null $P130, vivify_2713
    die "Contextual $*SC not found"
  vivify_2713:
  vivify_2712:
    find_dynamic_lex $P133, "$*PACKAGE"
    unless_null $P133, vivify_2714
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PACKAGE"]
    unless_null $P133, vivify_2715
    die "Contextual $*PACKAGE not found"
  vivify_2715:
  vivify_2714:
    find_lex $P134, "$meta_meth"
    unless_null $P134, vivify_2716
    new $P134, "Undef"
  vivify_2716:
    find_lex $P135, "$name"
    unless_null $P135, vivify_2717
    new $P135, "Undef"
  vivify_2717:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2718
    new $P136, "Undef"
  vivify_2718:
    find_lex $P137, "$is_dispatcher"
    unless_null $P137, vivify_2719
    new $P137, "Undef"
  vivify_2719:
    $P130."pkg_add_method"($P133, $P134, $P135, $P136, $P137)
.annotate 'line', 2096
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2720
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2721
    die "Contextual $*SCOPE not found"
  vivify_2721:
  vivify_2720:
    set $S100, $P131
    iseq $I100, $S100, "our"
    if $I100, if_3250
.annotate 'line', 2099
    find_lex $P133, "$past"
    unless_null $P133, vivify_2722
    new $P133, "Undef"
  vivify_2722:
    $P134 = $P133."pirflags"()
    if $P134, if_3251
.annotate 'line', 2102
    find_lex $P135, "$past"
    unless_null $P135, vivify_2723
    new $P135, "Undef"
  vivify_2723:
    $P136 = $P135."pirflags"(":anon")
.annotate 'line', 2101
    set $P132, $P136
.annotate 'line', 2099
    goto if_3251_end
  if_3251:
.annotate 'line', 2100
    find_lex $P135, "$past"
    unless_null $P135, vivify_2724
    new $P135, "Undef"
  vivify_2724:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2725
    new $P136, "Undef"
  vivify_2725:
    $P137 = $P136."pirflags"()
    set $S101, $P137
    new $P138, 'String'
    set $P138, $S101
    concat $P139, $P138, ":anon"
    $P141 = $P135."pirflags"($P139)
.annotate 'line', 2099
    set $P132, $P141
  if_3251_end:
.annotate 'line', 2098
    set $P128, $P132
.annotate 'line', 2096
    goto if_3250_end
  if_3250:
.annotate 'line', 2097
    find_dynamic_lex $P134, "$*SC"
    unless_null $P134, vivify_2726
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SC"]
    unless_null $P134, vivify_2727
    die "Contextual $*SC not found"
  vivify_2727:
  vivify_2726:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2728
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2729
    die "Contextual $*PACKAGE not found"
  vivify_2729:
  vivify_2728:
    find_lex $P138, "$name"
    unless_null $P138, vivify_2730
    new $P138, "Undef"
  vivify_2730:
    find_lex $P139, "$past"
    unless_null $P139, vivify_2731
    new $P139, "Undef"
  vivify_2731:
    $P140 = $P134."install_package_routine"($P137, $P138, $P139)
.annotate 'line', 2096
    set $P128, $P140
  if_3250_end:
.annotate 'line', 2081
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3256"  :anon :subid("559_1321350766.1143") :outer("557_1321350766.1143")
    .param pmc param_3258
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2111
    .lex "$_", param_3258
    find_lex $P129, "$_"
    unless_null $P129, vivify_2740
    new $P129, "Undef"
  vivify_2740:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2741
    new $P131, "Undef"
  vivify_2741:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("560_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3261
    .param pmc param_3262
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2140
    .const 'Sub' $P3277 = "562_1321350766.1143" 
    capture_lex $P3277
    .const 'Sub' $P3269 = "561_1321350766.1143" 
    capture_lex $P3269
    .lex "self", param_3261
    .lex "$/", param_3262
.annotate 'line', 2141
    new $P122, "Undef"
    set $P3263, $P122
    .lex "$BLOCKINIT", $P3263
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P3264, $P127["@BLOCK"]
    unless_null $P3264, vivify_2742
    $P3264 = root_new ['parrot';'ResizablePMCArray']
  vivify_2742:
    set $P3265, $P3264[$I101]
    unless_null $P3265, vivify_2743
    $P3265 = root_new ['parrot';'ResizablePMCArray']
  vivify_2743:
    set $P128, $P3265[$I100]
    unless_null $P128, vivify_2744
    new $P128, "Undef"
  vivify_2744:
    store_lex "$BLOCKINIT", $P128
.annotate 'line', 2142
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_2745
    $P3267 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P123, $P3267["invocant"]
    unless_null $P123, vivify_2746
    new $P123, "Undef"
  vivify_2746:
    unless $P123, if_3266_end
    .const 'Sub' $P3269 = "561_1321350766.1143" 
    capture_lex $P3269
    $P3269()
  if_3266_end:
.annotate 'line', 2151
    find_lex $P3275, "$/"
    unless_null $P3275, vivify_2756
    $P3275 = root_new ['parrot';'Hash']
  vivify_2756:
    set $P124, $P3275["parameter"]
    unless_null $P124, vivify_2757
    new $P124, "Undef"
  vivify_2757:
    defined $I100, $P124
    unless $I100, for_undef_2758
    iter $P123, $P124
    new $P127, 'ExceptionHandler'
    set_label $P127, loop3279_handler
    $P127."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P127
  loop3279_test:
    unless $P123, loop3279_done
    shift $P125, $P123
  loop3279_redo:
    .const 'Sub' $P3277 = "562_1321350766.1143" 
    capture_lex $P3277
    $P3277($P125)
  loop3279_next:
    goto loop3279_test
  loop3279_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop3279_next
    eq $P128, .CONTROL_LOOP_REDO, loop3279_redo
  loop3279_done:
    pop_eh 
  for_undef_2758:
.annotate 'line', 2140
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3268"  :anon :subid("561_1321350766.1143") :outer("560_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2143
    new $P124, "Undef"
    set $P3270, $P124
    .lex "$inv", $P3270
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3271, "$/"
    unless_null $P3271, vivify_2747
    $P3271 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P3272, $P3271["invocant"]
    unless_null $P3272, vivify_2748
    $P3272 = root_new ['parrot';'ResizablePMCArray']
  vivify_2748:
    set $P127, $P3272[$I100]
    unless_null $P127, vivify_2749
    new $P127, "Undef"
  vivify_2749:
    $P128 = $P127."ast"()
    store_lex "$inv", $P128
.annotate 'line', 2144
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2750
    new $P125, "Undef"
  vivify_2750:
    find_lex $P127, "$inv"
    unless_null $P127, vivify_2751
    new $P127, "Undef"
  vivify_2751:
    $P125."push"($P127)
.annotate 'line', 2145
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2752
    new $P125, "Undef"
  vivify_2752:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2147
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    find_lex $P135, "$inv"
    unless_null $P135, vivify_2753
    new $P135, "Undef"
  vivify_2753:
    $P136 = $P135."name"()
    $P137 = $P134."new"("lexical" :named("scope"), $P136 :named("name"))
.annotate 'line', 2145
    $P138 = $P130."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P137 :named("viviself"))
    $P125."push"($P138)
.annotate 'line', 2149
    new $P125, "Float"
    assign $P125, 1
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3273, $P129["@BLOCK"]
    unless_null $P3273, vivify_2754
    $P3273 = root_new ['parrot';'ResizablePMCArray']
    set $P129["@BLOCK"], $P3273
  vivify_2754:
    set $P3274, $P3273[$I100]
    unless_null $P3274, vivify_2755
    $P3274 = root_new ['parrot';'Hash']
    set $P3273[$I100], $P3274
  vivify_2755:
    set $P3274["signature_has_invocant"], $P125
.annotate 'line', 2142
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3276"  :anon :subid("562_1321350766.1143") :outer("560_1321350766.1143")
    .param pmc param_3278
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2151
    .lex "$_", param_3278
    find_lex $P127, "$BLOCKINIT"
    unless_null $P127, vivify_2759
    new $P127, "Undef"
  vivify_2759:
    find_lex $P128, "$_"
    unless_null $P128, vivify_2760
    new $P128, "Undef"
  vivify_2760:
    $P129 = $P128."ast"()
    $P130 = $P127."push"($P129)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("563_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3281
    .param pmc param_3282
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2154
    .lex "self", param_3281
    .lex "$/", param_3282
.annotate 'line', 2155
    new $P122, "Undef"
    set $P3283, $P122
    .lex "$quant", $P3283
.annotate 'line', 2156
    new $P123, "Undef"
    set $P3284, $P123
    .lex "$past", $P3284
.annotate 'line', 2155
    find_lex $P3285, "$/"
    unless_null $P3285, vivify_2761
    $P3285 = root_new ['parrot';'Hash']
  vivify_2761:
    set $P124, $P3285["quant"]
    unless_null $P124, vivify_2762
    new $P124, "Undef"
  vivify_2762:
    store_lex "$quant", $P124
.annotate 'line', 2154
    find_lex $P124, "$past"
    unless_null $P124, vivify_2763
    new $P124, "Undef"
  vivify_2763:
.annotate 'line', 2157
    find_lex $P3287, "$/"
    unless_null $P3287, vivify_2764
    $P3287 = root_new ['parrot';'Hash']
  vivify_2764:
    set $P124, $P3287["named_param"]
    unless_null $P124, vivify_2765
    new $P124, "Undef"
  vivify_2765:
    if $P124, if_3286
.annotate 'line', 2164
    find_lex $P3293, "$/"
    unless_null $P3293, vivify_2766
    $P3293 = root_new ['parrot';'Hash']
  vivify_2766:
    set $P125, $P3293["param_var"]
    unless_null $P125, vivify_2767
    new $P125, "Undef"
  vivify_2767:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2165
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2768
    new $P125, "Undef"
  vivify_2768:
    set $S100, $P125
    iseq $I100, $S100, "*"
    if $I100, if_3294
.annotate 'line', 2169
    find_lex $P127, "$quant"
    unless_null $P127, vivify_2769
    new $P127, "Undef"
  vivify_2769:
    set $S101, $P127
    iseq $I101, $S101, "?"
    unless $I101, if_3297_end
.annotate 'line', 2170
    find_lex $P128, "$past"
    unless_null $P128, vivify_2770
    new $P128, "Undef"
  vivify_2770:
    find_lex $P3298, "$/"
    unless_null $P3298, vivify_2771
    $P3298 = root_new ['parrot';'Hash']
  vivify_2771:
    set $P3299, $P3298["param_var"]
    unless_null $P3299, vivify_2772
    $P3299 = root_new ['parrot';'Hash']
  vivify_2772:
    set $P129, $P3299["sigil"]
    unless_null $P129, vivify_2773
    new $P129, "Undef"
  vivify_2773:
    $P130 = "vivitype"($P129)
    $P128."viviself"($P130)
  if_3297_end:
.annotate 'line', 2169
    goto if_3294_end
  if_3294:
.annotate 'line', 2166
    find_lex $P127, "$past"
    unless_null $P127, vivify_2774
    new $P127, "Undef"
  vivify_2774:
    $P127."slurpy"(1)
.annotate 'line', 2167
    find_lex $P127, "$past"
    unless_null $P127, vivify_2775
    new $P127, "Undef"
  vivify_2775:
    find_lex $P3295, "$/"
    unless_null $P3295, vivify_2776
    $P3295 = root_new ['parrot';'Hash']
  vivify_2776:
    set $P3296, $P3295["param_var"]
    unless_null $P3296, vivify_2777
    $P3296 = root_new ['parrot';'Hash']
  vivify_2777:
    set $P128, $P3296["sigil"]
    unless_null $P128, vivify_2778
    new $P128, "Undef"
  vivify_2778:
    set $S101, $P128
    iseq $I101, $S101, "%"
    $P127."named"($I101)
  if_3294_end:
.annotate 'line', 2163
    goto if_3286_end
  if_3286:
.annotate 'line', 2158
    find_lex $P3288, "$/"
    unless_null $P3288, vivify_2779
    $P3288 = root_new ['parrot';'Hash']
  vivify_2779:
    set $P125, $P3288["named_param"]
    unless_null $P125, vivify_2780
    new $P125, "Undef"
  vivify_2780:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2159
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2781
    new $P125, "Undef"
  vivify_2781:
    set $S100, $P125
    isne $I100, $S100, "!"
    unless $I100, if_3289_end
.annotate 'line', 2160
    find_lex $P127, "$past"
    unless_null $P127, vivify_2782
    new $P127, "Undef"
  vivify_2782:
    find_lex $P3290, "$/"
    unless_null $P3290, vivify_2783
    $P3290 = root_new ['parrot';'Hash']
  vivify_2783:
    set $P3291, $P3290["named_param"]
    unless_null $P3291, vivify_2784
    $P3291 = root_new ['parrot';'Hash']
  vivify_2784:
    set $P3292, $P3291["param_var"]
    unless_null $P3292, vivify_2785
    $P3292 = root_new ['parrot';'Hash']
  vivify_2785:
    set $P128, $P3292["sigil"]
    unless_null $P128, vivify_2786
    new $P128, "Undef"
  vivify_2786:
    $P129 = "vivitype"($P128)
    $P127."viviself"($P129)
  if_3289_end:
  if_3286_end:
.annotate 'line', 2173
    find_lex $P3301, "$/"
    unless_null $P3301, vivify_2787
    $P3301 = root_new ['parrot';'Hash']
  vivify_2787:
    set $P124, $P3301["default_value"]
    unless_null $P124, vivify_2788
    new $P124, "Undef"
  vivify_2788:
    unless $P124, if_3300_end
.annotate 'line', 2174
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2789
    new $P125, "Undef"
  vivify_2789:
    set $S100, $P125
    iseq $I100, $S100, "*"
    unless $I100, if_3302_end
.annotate 'line', 2175
    find_lex $P127, "$/"
    unless_null $P127, vivify_2790
    new $P127, "Undef"
  vivify_2790:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on slurpy parameter")
  if_3302_end:
.annotate 'line', 2177
    find_lex $P125, "$quant"
    unless_null $P125, vivify_2791
    new $P125, "Undef"
  vivify_2791:
    set $S100, $P125
    iseq $I100, $S100, "!"
    unless $I100, if_3303_end
.annotate 'line', 2178
    find_lex $P127, "$/"
    unless_null $P127, vivify_2792
    new $P127, "Undef"
  vivify_2792:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on required parameter")
  if_3303_end:
.annotate 'line', 2180
    find_lex $P125, "$past"
    unless_null $P125, vivify_2793
    new $P125, "Undef"
  vivify_2793:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3304, "$/"
    unless_null $P3304, vivify_2794
    $P3304 = root_new ['parrot';'Hash']
  vivify_2794:
    set $P3305, $P3304["default_value"]
    unless_null $P3305, vivify_2795
    $P3305 = root_new ['parrot';'ResizablePMCArray']
  vivify_2795:
    set $P3306, $P3305[$I100]
    unless_null $P3306, vivify_2796
    $P3306 = root_new ['parrot';'Hash']
  vivify_2796:
    set $P128, $P3306["EXPR"]
    unless_null $P128, vivify_2797
    new $P128, "Undef"
  vivify_2797:
    $P129 = $P128."ast"()
    $P125."viviself"($P129)
  if_3300_end:
.annotate 'line', 2182
    find_lex $P124, "$past"
    unless_null $P124, vivify_2798
    new $P124, "Undef"
  vivify_2798:
    $P125 = $P124."viviself"()
    if $P125, unless_3307_end
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3308, $P129["@BLOCK"]
    unless_null $P3308, vivify_2799
    $P3308 = root_new ['parrot';'ResizablePMCArray']
  vivify_2799:
    set $P130, $P3308[$I100]
    unless_null $P130, vivify_2800
    new $P130, "Undef"
  vivify_2800:
    new $P131, "Float"
    assign $P131, 0
    set $I101, $P131
    find_lex $P132, "$?PACKAGE"
    get_who $P133, $P132
    set $P3309, $P133["@BLOCK"]
    unless_null $P3309, vivify_2801
    $P3309 = root_new ['parrot';'ResizablePMCArray']
  vivify_2801:
    set $P134, $P3309[$I101]
    unless_null $P134, vivify_2802
    new $P134, "Undef"
  vivify_2802:
    $P135 = $P134."arity"()
    set $N100, $P135
    new $P136, 'Float'
    set $P136, $N100
    add $P137, $P136, 1
    $P130."arity"($P137)
  unless_3307_end:
.annotate 'line', 2186
    find_lex $P3311, "$/"
    unless_null $P3311, vivify_2803
    $P3311 = root_new ['parrot';'Hash']
  vivify_2803:
    set $P124, $P3311["typename"]
    unless_null $P124, vivify_2804
    new $P124, "Undef"
  vivify_2804:
    unless $P124, if_3310_end
.annotate 'line', 2187
    find_lex $P125, "$past"
    unless_null $P125, vivify_2805
    new $P125, "Undef"
  vivify_2805:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3312, "$/"
    unless_null $P3312, vivify_2806
    $P3312 = root_new ['parrot';'Hash']
  vivify_2806:
    set $P3313, $P3312["typename"]
    unless_null $P3313, vivify_2807
    $P3313 = root_new ['parrot';'ResizablePMCArray']
  vivify_2807:
    set $P128, $P3313[$I100]
    unless_null $P128, vivify_2808
    new $P128, "Undef"
  vivify_2808:
    $P129 = $P128."ast"()
    $P125."multitype"($P129)
  if_3310_end:
.annotate 'line', 2191
    find_lex $P3315, "$/"
    unless_null $P3315, vivify_2809
    $P3315 = root_new ['parrot';'Hash']
  vivify_2809:
    set $P124, $P3315["definedness"]
    unless_null $P124, vivify_2810
    new $P124, "Undef"
  vivify_2810:
    unless $P124, if_3314_end
.annotate 'line', 2192
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3316, "$/"
    unless_null $P3316, vivify_2811
    $P3316 = root_new ['parrot';'Hash']
  vivify_2811:
    set $P3317, $P3316["definedness"]
    unless_null $P3317, vivify_2812
    $P3317 = root_new ['parrot';'ResizablePMCArray']
  vivify_2812:
    set $P127, $P3317[$I100]
    unless_null $P127, vivify_2813
    new $P127, "Undef"
  vivify_2813:
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    find_lex $P3318, "$past"
    unless_null $P3318, vivify_2814
    $P3318 = root_new ['parrot';'Hash']
    store_lex "$past", $P3318
  vivify_2814:
    set $P3318["definedness"], $P128
  if_3314_end:
.annotate 'line', 2195
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2815
    new $P125, "Undef"
  vivify_2815:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2154
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("564_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3320
    .param pmc param_3321
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2198
    .lex "self", param_3320
    .lex "$/", param_3321
.annotate 'line', 2199
    new $P122, "Undef"
    set $P3322, $P122
    .lex "$name", $P3322
.annotate 'line', 2200
    new $P123, "Undef"
    set $P3323, $P123
    .lex "$past", $P3323
.annotate 'line', 2199
    find_lex $P124, "$/"
    unless_null $P124, vivify_2816
    new $P124, "Undef"
  vivify_2816:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    store_lex "$name", $P125
.annotate 'line', 2200
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    find_lex $P129, "$name"
    unless_null $P129, vivify_2817
    new $P129, "Undef"
  vivify_2817:
    find_lex $P130, "$/"
    unless_null $P130, vivify_2818
    new $P130, "Undef"
  vivify_2818:
    $P131 = $P128."new"($P129 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P130 :named("node"))
    store_lex "$past", $P131
.annotate 'line', 2202
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P3324, $P127["@BLOCK"]
    unless_null $P3324, vivify_2819
    $P3324 = root_new ['parrot';'ResizablePMCArray']
  vivify_2819:
    set $P128, $P3324[$I100]
    unless_null $P128, vivify_2820
    new $P128, "Undef"
  vivify_2820:
    find_lex $P129, "$name"
    unless_null $P129, vivify_2821
    new $P129, "Undef"
  vivify_2821:
    $P128."symbol"($P129, "lexical" :named("scope"))
.annotate 'line', 2203
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_2822
    new $P125, "Undef"
  vivify_2822:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2198
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("565_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3326
    .param pmc param_3327
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2206
    .lex "self", param_3326
    .lex "$/", param_3327
.annotate 'line', 2207
    new $P122, "Undef"
    set $P3328, $P122
    .lex "$past", $P3328
    find_lex $P3329, "$/"
    unless_null $P3329, vivify_2823
    $P3329 = root_new ['parrot';'Hash']
  vivify_2823:
    set $P123, $P3329["param_var"]
    unless_null $P123, vivify_2824
    new $P123, "Undef"
  vivify_2824:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 2208
    find_lex $P123, "$past"
    unless_null $P123, vivify_2825
    new $P123, "Undef"
  vivify_2825:
    find_lex $P3330, "$/"
    unless_null $P3330, vivify_2826
    $P3330 = root_new ['parrot';'Hash']
  vivify_2826:
    set $P3331, $P3330["param_var"]
    unless_null $P3331, vivify_2827
    $P3331 = root_new ['parrot';'Hash']
  vivify_2827:
    set $P124, $P3331["name"]
    unless_null $P124, vivify_2828
    new $P124, "Undef"
  vivify_2828:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 2209
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2829
    new $P124, "Undef"
  vivify_2829:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2206
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("566_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3333
    .param pmc param_3334
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2212
    .const 'Sub' $P3339 = "567_1321350766.1143" 
    capture_lex $P3339
    .lex "self", param_3333
    .lex "$/", param_3334
.annotate 'line', 2216
    $P3336 = root_new ['parrot';'ResizablePMCArray']
    set $P3335, $P3336
    .lex "@name", $P3335
.annotate 'line', 2217
    new $P122, "Undef"
    set $P3337, $P122
    .lex "$found", $P3337
.annotate 'line', 2216
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "HLL"
    get_who $P125, $P124
    set $P127, $P125["Compiler"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_2830
    new $P128, "Undef"
  vivify_2830:
    set $S100, $P128
    $P129 = $P127."parse_name"($S100)
    store_lex "@name", $P129
.annotate 'line', 2217
    new $P123, "Float"
    assign $P123, 0
    store_lex "$found", $P123
.annotate 'line', 2218
    .const 'Sub' $P3339 = "567_1321350766.1143" 
    capture_lex $P3339
    $P3339()
.annotate 'line', 2223
    find_lex $P124, "$found"
    unless_null $P124, vivify_2836
    new $P124, "Undef"
  vivify_2836:
    unless $P124, unless_3348
    set $P123, $P124
    goto unless_3348_end
  unless_3348:
.annotate 'line', 2224
    find_lex $P125, "$/"
    unless_null $P125, vivify_2837
    new $P125, "Undef"
  vivify_2837:
    $P127 = $P125."CURSOR"()
    new $P128, "String"
    assign $P128, "Use of undeclared type '"
    find_lex $P129, "$/"
    unless_null $P129, vivify_2838
    new $P129, "Undef"
  vivify_2838:
    set $S100, $P129
    concat $P130, $P128, $S100
    concat $P131, $P130, "'"
    $P132 = $P127."panic"($P131)
.annotate 'line', 2223
    set $P123, $P132
  unless_3348_end:
.annotate 'line', 2212
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3338"  :anon :subid("567_1321350766.1143") :outer("566_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2218
    new $P3344, 'ExceptionHandler'
    set_label $P3344, control_3343
    $P3344."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3344
.annotate 'line', 2219
    new $P123, "Undef"
    set $P3340, $P123
    .lex "$sym", $P3340
    find_lex $P3341, "@name"
    unless_null $P3341, vivify_2831
    $P3341 = root_new ['parrot';'ResizablePMCArray']
  vivify_2831:
    find_lex $P124, "$/"
    unless_null $P124, vivify_2832
    new $P124, "Undef"
  vivify_2832:
    $P125 = "find_sym"($P3341, $P124)
    store_lex "$sym", $P125
.annotate 'line', 2220
    find_dynamic_lex $P124, "$/"
    find_dynamic_lex $P128, "$*SC"
    unless_null $P128, vivify_2833
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SC"]
    unless_null $P128, vivify_2834
    die "Contextual $*SC not found"
  vivify_2834:
  vivify_2833:
    find_lex $P129, "$sym"
    unless_null $P129, vivify_2835
    new $P129, "Undef"
  vivify_2835:
    $P130 = $P128."get_object_sc_ref_past"($P129)
    $P124."!make"($P130)
.annotate 'line', 2221
    new $P124, "Float"
    assign $P124, 1
    store_lex "$found", $P124
.annotate 'line', 2218
    pop_eh 
    goto skip_handler_3342
  control_3343:
    .local pmc exception 
    .get_results (exception) 
    new $P3346, 'Integer'
    set $P3346, 1
    set exception["handled"], $P3346
    set $I3347, exception["handled"]
    eq $I3347, 1, handled_3345
    rethrow exception
  handled_3345:
    .return (exception)
  skip_handler_3342:
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("568_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3350
    .param pmc param_3351
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2228
    .lex "self", param_3350
    .lex "$/", param_3351
.annotate 'line', 2229
    find_lex $P122, "$/"
    find_lex $P3352, "$/"
    unless_null $P3352, vivify_2839
    $P3352 = root_new ['parrot';'Hash']
  vivify_2839:
    set $P123, $P3352["trait_mod"]
    unless_null $P123, vivify_2840
    new $P123, "Undef"
  vivify_2840:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2228
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("569_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3354
    .param pmc param_3355
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2232
    .const 'Sub' $P3374 = "572_1321350766.1143" 
    capture_lex $P3374
    .const 'Sub' $P3359 = "570_1321350766.1143" 
    capture_lex $P3359
    .lex "self", param_3354
    .lex "$/", param_3355
.annotate 'line', 2233
    find_lex $P3357, "$/"
    unless_null $P3357, vivify_2841
    $P3357 = root_new ['parrot';'Hash']
  vivify_2841:
    set $P123, $P3357["longname"]
    unless_null $P123, vivify_2842
    new $P123, "Undef"
  vivify_2842:
    set $S100, $P123
    iseq $I100, $S100, "parrot_vtable"
    if $I100, if_3356
.annotate 'line', 2246
    find_lex $P3372, "$/"
    unless_null $P3372, vivify_2843
    $P3372 = root_new ['parrot';'Hash']
  vivify_2843:
    set $P132, $P3372["longname"]
    unless_null $P132, vivify_2844
    new $P132, "Undef"
  vivify_2844:
    set $S101, $P132
    iseq $I101, $S101, "parrot_vtable_handler"
    if $I101, if_3371
.annotate 'line', 2257
    find_lex $P3387, "$/"
    unless_null $P3387, vivify_2845
    $P3387 = root_new ['parrot';'Hash']
  vivify_2845:
    set $P139, $P3387["longname"]
    unless_null $P139, vivify_2846
    new $P139, "Undef"
  vivify_2846:
    set $S102, $P139
    iseq $I102, $S102, "pirflags"
    if $I102, if_3386
.annotate 'line', 2261
    find_lex $P140, "$/"
    unless_null $P140, vivify_2847
    new $P140, "Undef"
  vivify_2847:
    $P141 = $P140."CURSOR"()
    new $P143, 'String'
    set $P143, "Trait '"
    find_lex $P3388, "$/"
    unless_null $P3388, vivify_2848
    $P3388 = root_new ['parrot';'Hash']
  vivify_2848:
    set $P144, $P3388["longname"]
    unless_null $P144, vivify_2849
    new $P144, "Undef"
  vivify_2849:
    concat $P145, $P143, $P144
    concat $P146, $P145, "' not implemented"
    $P147 = $P141."panic"($P146)
.annotate 'line', 2260
    set $P138, $P147
.annotate 'line', 2257
    goto if_3386_end
  if_3386:
.annotate 'line', 2258
    find_lex $P140, "$/"
    unless_null $P140, vivify_2850
    new $P140, "Undef"
  vivify_2850:
    $P141 = $P140."CURSOR"()
    $P142 = $P141."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2257
    set $P138, $P142
  if_3386_end:
    set $P131, $P138
.annotate 'line', 2246
    goto if_3371_end
  if_3371:
    .const 'Sub' $P3374 = "572_1321350766.1143" 
    capture_lex $P3374
    $P136 = $P3374()
    set $P131, $P136
  if_3371_end:
    set $P122, $P131
.annotate 'line', 2233
    goto if_3356_end
  if_3356:
    .const 'Sub' $P3359 = "570_1321350766.1143" 
    capture_lex $P3359
    $P129 = $P3359()
    set $P122, $P129
  if_3356_end:
.annotate 'line', 2232
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3373"  :anon :subid("572_1321350766.1143") :outer("569_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2246
    .const 'Sub' $P3382 = "573_1321350766.1143" 
    capture_lex $P3382
.annotate 'line', 2248
    new $P133, "Undef"
    set $P3375, $P133
    .lex "$cpast", $P3375
.annotate 'line', 2251
    new $P134, "Undef"
    set $P3376, $P134
    .lex "$name", $P3376
.annotate 'line', 2252
    new $P135, "Undef"
    set $P3377, $P135
    .lex "$package", $P3377
.annotate 'line', 2248
    new $P136, "Float"
    assign $P136, 0
    set $I102, $P136
    find_lex $P3378, "$/"
    unless_null $P3378, vivify_2851
    $P3378 = root_new ['parrot';'Hash']
  vivify_2851:
    set $P3379, $P3378["circumfix"]
    unless_null $P3379, vivify_2852
    $P3379 = root_new ['parrot';'ResizablePMCArray']
  vivify_2852:
    set $P137, $P3379[$I102]
    unless_null $P137, vivify_2853
    new $P137, "Undef"
  vivify_2853:
    $P138 = $P137."ast"()
    store_lex "$cpast", $P138
.annotate 'line', 2250
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Val"]
    find_lex $P140, "$cpast"
    unless_null $P140, vivify_2854
    new $P140, "Undef"
  vivify_2854:
    $P141 = $P139."ACCEPTS"($P140)
    if $P141, unless_3380_end
.annotate 'line', 2249
    find_lex $P142, "$/"
    unless_null $P142, vivify_2855
    new $P142, "Undef"
  vivify_2855:
    $P143 = $P142."CURSOR"()
    $P143."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_3380_end:
.annotate 'line', 2251
    find_lex $P136, "$cpast"
    unless_null $P136, vivify_2856
    new $P136, "Undef"
  vivify_2856:
    $P137 = $P136."value"()
    store_lex "$name", $P137
.annotate 'line', 2252
    find_dynamic_lex $P138, "$*PACKAGE"
    unless_null $P138, vivify_2857
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PACKAGE"]
    unless_null $P138, vivify_2858
    die "Contextual $*PACKAGE not found"
  vivify_2858:
  vivify_2857:
    store_lex "$package", $P138
.annotate 'line', 2253
    find_dynamic_lex $P136, "$/"
    .const 'Sub' $P3382 = "573_1321350766.1143" 
    newclosure $P3385, $P3382
    $P137 = $P136."!make"($P3385)
.annotate 'line', 2246
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3381"  :anon :subid("573_1321350766.1143") :outer("572_1321350766.1143")
    .param pmc param_3383
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2253
    .lex "$match", param_3383
.annotate 'line', 2254
    find_dynamic_lex $P139, "$*SC"
    unless_null $P139, vivify_2859
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SC"]
    unless_null $P139, vivify_2860
    die "Contextual $*SC not found"
  vivify_2860:
  vivify_2859:
    find_lex $P140, "$package"
    unless_null $P140, vivify_2861
    new $P140, "Undef"
  vivify_2861:
    find_lex $P141, "$name"
    unless_null $P141, vivify_2862
    new $P141, "Undef"
  vivify_2862:
    find_lex $P3384, "$match"
    unless_null $P3384, vivify_2863
    $P3384 = root_new ['parrot';'Hash']
  vivify_2863:
    set $P142, $P3384["variable"]
    unless_null $P142, vivify_2864
    new $P142, "Undef"
  vivify_2864:
    set $S102, $P142
    $P143 = $P139."pkg_add_parrot_vtable_handler_mapping"($P140, $P141, $S102)
.annotate 'line', 2253
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3358"  :anon :subid("570_1321350766.1143") :outer("569_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2233
    .const 'Sub' $P3368 = "571_1321350766.1143" 
    capture_lex $P3368
.annotate 'line', 2235
    new $P124, "Undef"
    set $P3360, $P124
    .lex "$cpast", $P3360
.annotate 'line', 2238
    new $P125, "Undef"
    set $P3361, $P125
    .lex "$name", $P3361
.annotate 'line', 2239
    new $P127, "Undef"
    set $P3362, $P127
    .lex "$package", $P3362
.annotate 'line', 2240
    new $P128, "Undef"
    set $P3363, $P128
    .lex "$is_dispatcher", $P3363
.annotate 'line', 2235
    new $P129, "Float"
    assign $P129, 0
    set $I101, $P129
    find_lex $P3364, "$/"
    unless_null $P3364, vivify_2865
    $P3364 = root_new ['parrot';'Hash']
  vivify_2865:
    set $P3365, $P3364["circumfix"]
    unless_null $P3365, vivify_2866
    $P3365 = root_new ['parrot';'ResizablePMCArray']
  vivify_2866:
    set $P130, $P3365[$I101]
    unless_null $P130, vivify_2867
    new $P130, "Undef"
  vivify_2867:
    $P131 = $P130."ast"()
    store_lex "$cpast", $P131
.annotate 'line', 2237
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    find_lex $P133, "$cpast"
    unless_null $P133, vivify_2868
    new $P133, "Undef"
  vivify_2868:
    $P134 = $P132."ACCEPTS"($P133)
    if $P134, unless_3366_end
.annotate 'line', 2236
    find_lex $P135, "$/"
    unless_null $P135, vivify_2869
    new $P135, "Undef"
  vivify_2869:
    $P136 = $P135."CURSOR"()
    $P136."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_3366_end:
.annotate 'line', 2238
    find_lex $P129, "$cpast"
    unless_null $P129, vivify_2870
    new $P129, "Undef"
  vivify_2870:
    $P130 = $P129."value"()
    store_lex "$name", $P130
.annotate 'line', 2239
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2871
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2872
    die "Contextual $*PACKAGE not found"
  vivify_2872:
  vivify_2871:
    store_lex "$package", $P131
.annotate 'line', 2240
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2873
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2874
    die "Contextual $*SCOPE not found"
  vivify_2874:
  vivify_2873:
    set $S101, $P131
    iseq $I101, $S101, "proto"
    new $P132, 'Integer'
    set $P132, $I101
    store_lex "$is_dispatcher", $P132
.annotate 'line', 2241
    find_dynamic_lex $P129, "$/"
    .const 'Sub' $P3368 = "571_1321350766.1143" 
    newclosure $P3370, $P3368
    $P130 = $P129."!make"($P3370)
.annotate 'line', 2233
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3367"  :anon :subid("571_1321350766.1143") :outer("570_1321350766.1143")
    .param pmc param_3369
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2241
    .lex "$match", param_3369
.annotate 'line', 2242
    find_dynamic_lex $P132, "$*SC"
    unless_null $P132, vivify_2875
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SC"]
    unless_null $P132, vivify_2876
    die "Contextual $*SC not found"
  vivify_2876:
  vivify_2875:
    find_lex $P133, "$package"
    unless_null $P133, vivify_2877
    new $P133, "Undef"
  vivify_2877:
    find_lex $P134, "$name"
    unless_null $P134, vivify_2878
    new $P134, "Undef"
  vivify_2878:
.annotate 'line', 2243
    find_lex $P135, "$match"
    unless_null $P135, vivify_2879
    new $P135, "Undef"
  vivify_2879:
    $P136 = $P135."ast"()
    set $P137, $P136["block_past"]
    unless_null $P137, vivify_2880
    new $P137, "Undef"
  vivify_2880:
.annotate 'line', 2242
    find_lex $P138, "$is_dispatcher"
    unless_null $P138, vivify_2881
    new $P138, "Undef"
  vivify_2881:
    $P139 = $P132."pkg_add_method"($P133, "add_parrot_vtable_mapping", $P134, $P137, $P138)
.annotate 'line', 2241
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("574_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3392
    .param pmc param_3393
    .param pmc param_3394 :optional
    .param int has_param_3394 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2265
    .const 'Sub' $P3425 = "577_1321350766.1143" 
    capture_lex $P3425
    .const 'Sub' $P3409 = "576_1321350766.1143" 
    capture_lex $P3409
    .const 'Sub' $P3404 = "575_1321350766.1143" 
    capture_lex $P3404
    new $P3391, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3391, control_3390
    push_eh $P3391
    .lex "self", param_3392
    .lex "$/", param_3393
    if has_param_3394, optparam_2882
    new $P122, "Undef"
    set param_3394, $P122
  optparam_2882:
    .lex "$key", param_3394
.annotate 'line', 2266
    $P3396 = root_new ['parrot';'ResizablePMCArray']
    set $P3395, $P3396
    .lex "@MODIFIERS", $P3395
.annotate 'line', 2267
    new $P123, "Undef"
    set $P3397, $P123
    .lex "$name", $P3397
.annotate 'line', 2268
    new $P124, "Undef"
    set $P3398, $P124
    .lex "$past", $P3398
.annotate 'line', 2266
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P3399, $P130["@MODIFIERS"]
    unless_null $P3399, vivify_2883
    $P3399 = root_new ['parrot';'ResizablePMCArray']
  vivify_2883:
    store_lex "@MODIFIERS", $P3399
.annotate 'line', 2267
    find_lex $P3400, "$/"
    unless_null $P3400, vivify_2884
    $P3400 = root_new ['parrot';'Hash']
  vivify_2884:
    set $P125, $P3400["deflongname"]
    unless_null $P125, vivify_2885
    new $P125, "Undef"
  vivify_2885:
    $P127 = $P125."ast"()
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    store_lex "$name", $P128
.annotate 'line', 2265
    find_lex $P125, "$past"
    unless_null $P125, vivify_2886
    new $P125, "Undef"
  vivify_2886:
.annotate 'line', 2269
    find_lex $P3402, "$/"
    unless_null $P3402, vivify_2887
    $P3402 = root_new ['parrot';'Hash']
  vivify_2887:
    set $P125, $P3402["proto"]
    unless_null $P125, vivify_2888
    new $P125, "Undef"
  vivify_2888:
    if $P125, if_3401
.annotate 'line', 2299
    find_lex $P127, "$key"
    unless_null $P127, vivify_2889
    new $P127, "Undef"
  vivify_2889:
    set $S100, $P127
    iseq $I100, $S100, "open"
    if $I100, if_3407
.annotate 'line', 2309
    .const 'Sub' $P3425 = "577_1321350766.1143" 
    capture_lex $P3425
    $P3425()
    goto if_3407_end
  if_3407:
.annotate 'line', 2299
    .const 'Sub' $P3409 = "576_1321350766.1143" 
    capture_lex $P3409
    $P3409()
  if_3407_end:
    goto if_3401_end
  if_3401:
.annotate 'line', 2271
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Stmts"]
.annotate 'line', 2272
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Block"]
    find_lex $P135, "$name"
    unless_null $P135, vivify_2939
    new $P135, "Undef"
  vivify_2939:
.annotate 'line', 2273
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
.annotate 'line', 2274
    get_hll_global $P140, "GLOBAL"
    nqp_get_package_through_who $P141, $P140, "PAST"
    get_who $P142, $P141
    set $P143, $P142["Var"]
    $P144 = $P143."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P145, "$name"
    unless_null $P145, vivify_2940
    new $P145, "Undef"
  vivify_2940:
    $P146 = $P139."new"($P144, $P145, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2273
    find_lex $P147, "$/"
    unless_null $P147, vivify_2941
    new $P147, "Undef"
  vivify_2941:
    $P148 = $P134."new"($P146, $P135 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P147 :named("node"))
.annotate 'line', 2283
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Block"]
    new $P154, "String"
    assign $P154, "!PREFIX__"
    find_lex $P155, "$name"
    unless_null $P155, vivify_2942
    new $P155, "Undef"
  vivify_2942:
    concat $P156, $P154, $P155
.annotate 'line', 2284
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 2285
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Var"]
    $P165 = $P164."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P166, "$name"
    unless_null $P166, vivify_2943
    new $P166, "Undef"
  vivify_2943:
    $P167 = $P160."new"($P165, $P166, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2284
    find_lex $P168, "$/"
    unless_null $P168, vivify_2944
    new $P168, "Undef"
  vivify_2944:
    $P169 = $P153."new"($P167, $P156 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P168 :named("node"))
.annotate 'line', 2283
    $P170 = $P130."new"($P148, $P169)
.annotate 'line', 2271
    store_lex "$past", $P170
.annotate 'line', 2295
    find_lex $P128, "$past"
    unless_null $P128, vivify_2945
    new $P128, "Undef"
  vivify_2945:
    $P129 = $P128."list"()
    defined $I100, $P129
    unless $I100, for_undef_2946
    iter $P127, $P129
    new $P131, 'ExceptionHandler'
    set_label $P131, loop3406_handler
    $P131."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P131
  loop3406_test:
    unless $P127, loop3406_done
    shift $P130, $P127
  loop3406_redo:
    .const 'Sub' $P3404 = "575_1321350766.1143" 
    capture_lex $P3404
    $P3404($P130)
  loop3406_next:
    goto loop3406_test
  loop3406_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P132, exception, 'type'
    eq $P132, .CONTROL_LOOP_NEXT, loop3406_next
    eq $P132, .CONTROL_LOOP_REDO, loop3406_redo
  loop3406_done:
    pop_eh 
  for_undef_2946:
  if_3401_end:
.annotate 'line', 2340
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_2953
    new $P127, "Undef"
  vivify_2953:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2265
    .return ($P128)
  control_3390:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3424"  :anon :subid("577_1321350766.1143") :outer("574_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2309
    .const 'Sub' $P3433 = "578_1321350766.1143" 
    capture_lex $P3433
.annotate 'line', 2310
    new $P128, "Undef"
    set $P3426, $P128
    .lex "$regex", $P3426
.annotate 'line', 2313
    new $P129, "Undef"
    set $P3427, $P129
    .lex "$prefix_meth", $P3427
.annotate 'line', 2311
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "Regex"
    nqp_get_package_through_who $P132, $P131, "P6Regex"
    nqp_get_package_through_who $P133, $P132, "Actions"
    get_who $P134, $P133
    set $P135, $P134["buildsub"]
    find_lex $P3428, "$/"
    unless_null $P3428, vivify_2890
    $P3428 = root_new ['parrot';'Hash']
  vivify_2890:
    set $P136, $P3428["p6regex"]
    unless_null $P136, vivify_2891
    new $P136, "Undef"
  vivify_2891:
    $P137 = $P136."ast"()
    find_lex $P138, "$?PACKAGE"
    get_who $P139, $P138
    set $P3429, $P139["@BLOCK"]
    unless_null $P3429, vivify_2892
    $P3429 = root_new ['parrot';'ResizablePMCArray']
  vivify_2892:
    $P140 = $P3429."shift"()
    $P141 = $P135($P137, $P140)
    store_lex "$regex", $P141
.annotate 'line', 2312
    find_lex $P130, "$regex"
    unless_null $P130, vivify_2893
    new $P130, "Undef"
  vivify_2893:
    find_lex $P131, "$name"
    unless_null $P131, vivify_2894
    new $P131, "Undef"
  vivify_2894:
    $P130."name"($P131)
.annotate 'line', 2309
    find_lex $P130, "$prefix_meth"
    unless_null $P130, vivify_2895
    new $P130, "Undef"
  vivify_2895:
.annotate 'line', 2315
    find_dynamic_lex $P133, "$*PKGDECL"
    unless_null $P133, vivify_2896
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PKGDECL"]
    unless_null $P133, vivify_2897
    die "Contextual $*PKGDECL not found"
  vivify_2897:
  vivify_2896:
    if $P133, if_3431
    set $P130, $P133
    goto if_3431_end
  if_3431:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2898
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2899
    die "Contextual $*PACKAGE not found"
  vivify_2899:
  vivify_2898:
    get_how $P137, $P136
    can $I101, $P137, "add_method"
    new $P130, 'Integer'
    set $P130, $I101
  if_3431_end:
    unless $P130, if_3430_end
    .const 'Sub' $P3433 = "578_1321350766.1143" 
    capture_lex $P3433
    $P3433()
  if_3430_end:
.annotate 'line', 2330
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 2332
    new $P134, "ResizablePMCArray"
    push $P134, "Regex"
    push $P134, "Method"
    find_lex $P135, "$/"
    unless_null $P135, vivify_2916
    new $P135, "Undef"
  vivify_2916:
    $P136 = "lexical_package_lookup"($P134, $P135)
    find_lex $P137, "$regex"
    unless_null $P137, vivify_2917
    new $P137, "Undef"
  vivify_2917:
    $P138 = $P133."new"($P136, $P137, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2330
    store_lex "$past", $P138
.annotate 'line', 2335
    find_lex $P131, "$prefix_meth"
    unless_null $P131, vivify_2918
    new $P131, "Undef"
  vivify_2918:
    if $P131, if_3438
    find_lex $P139, "$regex"
    unless_null $P139, vivify_2919
    new $P139, "Undef"
  vivify_2919:
    set $P130, $P139
    goto if_3438_end
  if_3438:
.annotate 'line', 2336
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Stmts"]
    find_lex $P136, "$regex"
    unless_null $P136, vivify_2920
    new $P136, "Undef"
  vivify_2920:
    find_lex $P137, "$prefix_meth"
    unless_null $P137, vivify_2921
    new $P137, "Undef"
  vivify_2921:
    $P138 = $P135."new"($P136, $P137)
    set $P130, $P138
  if_3438_end:
.annotate 'line', 2335
    find_lex $P3439, "$past"
    unless_null $P3439, vivify_2922
    $P3439 = root_new ['parrot';'Hash']
    store_lex "$past", $P3439
  vivify_2922:
    set $P3439["sink"], $P130
.annotate 'line', 2338
    find_lex $P3440, "@MODIFIERS"
    unless_null $P3440, vivify_2923
    $P3440 = root_new ['parrot';'ResizablePMCArray']
  vivify_2923:
    $P130 = $P3440."shift"()
.annotate 'line', 2309
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3432"  :anon :subid("578_1321350766.1143") :outer("577_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2320
    $P3435 = root_new ['parrot';'ResizablePMCArray']
    set $P3434, $P3435
    .lex "@prefixes", $P3434
.annotate 'line', 2317
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_2900
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_2901
    die "Contextual $*SC not found"
  vivify_2901:
  vivify_2900:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2902
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2903
    die "Contextual $*PACKAGE not found"
  vivify_2903:
  vivify_2902:
    find_lex $P144, "$name"
    unless_null $P144, vivify_2904
    new $P144, "Undef"
  vivify_2904:
    find_lex $P145, "$regex"
    unless_null $P145, vivify_2905
    new $P145, "Undef"
  vivify_2905:
    $P140."pkg_add_method"($P143, "add_method", $P144, $P145, 0)
.annotate 'line', 2320
    find_lex $P3436, "$/"
    unless_null $P3436, vivify_2906
    $P3436 = root_new ['parrot';'Hash']
  vivify_2906:
    set $P138, $P3436["p6regex"]
    unless_null $P138, vivify_2907
    new $P138, "Undef"
  vivify_2907:
    $P139 = $P138."ast"()
    $P140 = $P139."prefix_list"()
    store_lex "@prefixes", $P140
.annotate 'line', 2321
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Block"]
.annotate 'line', 2322
    new $P142, "String"
    assign $P142, "!PREFIX__"
    find_lex $P143, "$name"
    unless_null $P143, vivify_2908
    new $P143, "Undef"
  vivify_2908:
    concat $P144, $P142, $P143
.annotate 'line', 2323
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    find_lex $P3437, "@prefixes"
    unless_null $P3437, vivify_2909
    $P3437 = root_new ['parrot';'ResizablePMCArray']
  vivify_2909:
    $P149 = $P148."new"($P3437 :flat, "list" :named("pasttype"))
    $P151 = $P141."new"($P149, $P144 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2321
    store_lex "$prefix_meth", $P151
.annotate 'line', 2325
    find_dynamic_lex $P140, "$*SC"
    unless_null $P140, vivify_2910
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$SC"]
    unless_null $P140, vivify_2911
    die "Contextual $*SC not found"
  vivify_2911:
  vivify_2910:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2912
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2913
    die "Contextual $*PACKAGE not found"
  vivify_2913:
  vivify_2912:
    find_lex $P144, "$prefix_meth"
    unless_null $P144, vivify_2914
    new $P144, "Undef"
  vivify_2914:
    $P145 = $P144."name"()
    find_lex $P146, "$prefix_meth"
    unless_null $P146, vivify_2915
    new $P146, "Undef"
  vivify_2915:
    $P147 = $P140."pkg_add_method"($P143, "add_method", $P145, $P146, 0)
.annotate 'line', 2315
    .return ($P147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3408"  :anon :subid("576_1321350766.1143") :outer("574_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2300
    $P3411 = root_new ['parrot';'Hash']
    set $P3410, $P3411
    .lex "%h", $P3410
.annotate 'line', 2299
    find_lex $P3412, "%h"
    unless_null $P3412, vivify_2924
    $P3412 = root_new ['parrot';'Hash']
  vivify_2924:
.annotate 'line', 2301
    find_lex $P3414, "$/"
    unless_null $P3414, vivify_2925
    $P3414 = root_new ['parrot';'Hash']
  vivify_2925:
    set $P128, $P3414["sym"]
    unless_null $P128, vivify_2926
    new $P128, "Undef"
  vivify_2926:
    set $S101, $P128
    iseq $I101, $S101, "token"
    unless $I101, if_3413_end
    new $P129, "Float"
    assign $P129, 1
    find_lex $P3415, "%h"
    unless_null $P3415, vivify_2927
    $P3415 = root_new ['parrot';'Hash']
    store_lex "%h", $P3415
  vivify_2927:
    set $P3415["r"], $P129
  if_3413_end:
.annotate 'line', 2302
    find_lex $P3417, "$/"
    unless_null $P3417, vivify_2928
    $P3417 = root_new ['parrot';'Hash']
  vivify_2928:
    set $P128, $P3417["sym"]
    unless_null $P128, vivify_2929
    new $P128, "Undef"
  vivify_2929:
    set $S101, $P128
    iseq $I101, $S101, "rule"
    unless $I101, if_3416_end
    new $P129, "Float"
    assign $P129, 1
    find_lex $P3418, "%h"
    unless_null $P3418, vivify_2930
    $P3418 = root_new ['parrot';'Hash']
    store_lex "%h", $P3418
  vivify_2930:
    set $P3418["r"], $P129
    new $P129, "Float"
    assign $P129, 1
    find_lex $P3419, "%h"
    unless_null $P3419, vivify_2931
    $P3419 = root_new ['parrot';'Hash']
    store_lex "%h", $P3419
  vivify_2931:
    set $P3419["s"], $P129
  if_3416_end:
.annotate 'line', 2303
    find_lex $P3420, "@MODIFIERS"
    unless_null $P3420, vivify_2932
    $P3420 = root_new ['parrot';'ResizablePMCArray']
  vivify_2932:
    find_lex $P3421, "%h"
    unless_null $P3421, vivify_2933
    $P3421 = root_new ['parrot';'Hash']
  vivify_2933:
    $P3420."unshift"($P3421)
.annotate 'line', 2304
    find_lex $P128, "$name"
    unless_null $P128, vivify_2934
    new $P128, "Undef"
  vivify_2934:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "Regex"
    nqp_get_package_through_who $P131, $P130, "P6Regex"
    nqp_get_package_through_who $P132, $P131, "Actions"
    get_who $P133, $P132
    set $P133["$REGEXNAME"], $P128
.annotate 'line', 2305
    new $P128, "Float"
    assign $P128, 0
    set $I101, $P128
    find_lex $P129, "$?PACKAGE"
    get_who $P130, $P129
    set $P3422, $P130["@BLOCK"]
    unless_null $P3422, vivify_2935
    $P3422 = root_new ['parrot';'ResizablePMCArray']
  vivify_2935:
    set $P131, $P3422[$I101]
    unless_null $P131, vivify_2936
    new $P131, "Undef"
  vivify_2936:
    $P131."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2306
    new $P128, "Float"
    assign $P128, 0
    set $I101, $P128
    find_lex $P129, "$?PACKAGE"
    get_who $P130, $P129
    set $P3423, $P130["@BLOCK"]
    unless_null $P3423, vivify_2937
    $P3423 = root_new ['parrot';'ResizablePMCArray']
  vivify_2937:
    set $P131, $P3423[$I101]
    unless_null $P131, vivify_2938
    new $P131, "Undef"
  vivify_2938:
    $P131."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2307
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    new $P129, "Float"
    assign $P129, 0
    setattribute $P128, 'payload', $P129
    throw $P128
.annotate 'line', 2299
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3403"  :anon :subid("575_1321350766.1143") :outer("574_1321350766.1143")
    .param pmc param_3405
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2295
    .lex "$_", param_3405
.annotate 'line', 2296
    find_dynamic_lex $P133, "$*SC"
    unless_null $P133, vivify_2947
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$SC"]
    unless_null $P133, vivify_2948
    die "Contextual $*SC not found"
  vivify_2948:
  vivify_2947:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2949
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2950
    die "Contextual $*PACKAGE not found"
  vivify_2950:
  vivify_2949:
    find_lex $P137, "$_"
    unless_null $P137, vivify_2951
    new $P137, "Undef"
  vivify_2951:
    $P138 = $P137."name"()
    find_lex $P139, "$_"
    unless_null $P139, vivify_2952
    new $P139, "Undef"
  vivify_2952:
    $P140 = $P133."pkg_add_method"($P136, "add_method", $P138, $P139, 0)
.annotate 'line', 2295
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("579_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3442
    .param pmc param_3443
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2344
    .lex "self", param_3442
    .lex "$/", param_3443
.annotate 'line', 2345
    new $P122, "Undef"
    set $P3444, $P122
    .lex "$past", $P3444
    find_lex $P3446, "$/"
    unless_null $P3446, vivify_2954
    $P3446 = root_new ['parrot';'Hash']
  vivify_2954:
    set $P124, $P3446["args"]
    unless_null $P124, vivify_2955
    new $P124, "Undef"
  vivify_2955:
    if $P124, if_3445
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P133, "$/"
    unless_null $P133, vivify_2956
    new $P133, "Undef"
  vivify_2956:
    $P134 = $P132."new"($P133 :named("node"))
    set $P123, $P134
    goto if_3445_end
  if_3445:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3447, "$/"
    unless_null $P3447, vivify_2957
    $P3447 = root_new ['parrot';'Hash']
  vivify_2957:
    set $P3448, $P3447["args"]
    unless_null $P3448, vivify_2958
    $P3448 = root_new ['parrot';'ResizablePMCArray']
  vivify_2958:
    set $P127, $P3448[$I100]
    unless_null $P127, vivify_2959
    new $P127, "Undef"
  vivify_2959:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_3445_end:
    store_lex "$past", $P123
.annotate 'line', 2346
    find_lex $P3450, "$/"
    unless_null $P3450, vivify_2960
    $P3450 = root_new ['parrot';'Hash']
  vivify_2960:
    set $P123, $P3450["quote"]
    unless_null $P123, vivify_2961
    new $P123, "Undef"
  vivify_2961:
    if $P123, if_3449
.annotate 'line', 2350
    find_lex $P3453, "$/"
    unless_null $P3453, vivify_2962
    $P3453 = root_new ['parrot';'Hash']
  vivify_2962:
    set $P124, $P3453["longname"]
    unless_null $P124, vivify_2963
    new $P124, "Undef"
  vivify_2963:
    set $S100, $P124
    iseq $I100, $S100, "HOW"
    if $I100, if_3452
.annotate 'line', 2353
    find_lex $P3455, "$/"
    unless_null $P3455, vivify_2964
    $P3455 = root_new ['parrot';'Hash']
  vivify_2964:
    set $P125, $P3455["longname"]
    unless_null $P125, vivify_2965
    new $P125, "Undef"
  vivify_2965:
    set $S101, $P125
    iseq $I101, $S101, "WHAT"
    if $I101, if_3454
.annotate 'line', 2356
    find_lex $P3457, "$/"
    unless_null $P3457, vivify_2966
    $P3457 = root_new ['parrot';'Hash']
  vivify_2966:
    set $P127, $P3457["longname"]
    unless_null $P127, vivify_2967
    new $P127, "Undef"
  vivify_2967:
    set $S102, $P127
    iseq $I102, $S102, "WHO"
    if $I102, if_3456
.annotate 'line', 2360
    find_lex $P128, "$past"
    unless_null $P128, vivify_2968
    new $P128, "Undef"
  vivify_2968:
    find_lex $P3458, "$/"
    unless_null $P3458, vivify_2969
    $P3458 = root_new ['parrot';'Hash']
  vivify_2969:
    set $P129, $P3458["longname"]
    unless_null $P129, vivify_2970
    new $P129, "Undef"
  vivify_2970:
    set $S103, $P129
    $P128."name"($S103)
.annotate 'line', 2361
    find_lex $P128, "$past"
    unless_null $P128, vivify_2971
    new $P128, "Undef"
  vivify_2971:
    $P128."pasttype"("callmethod")
.annotate 'line', 2359
    goto if_3456_end
  if_3456:
.annotate 'line', 2357
    find_lex $P128, "$past"
    unless_null $P128, vivify_2972
    new $P128, "Undef"
  vivify_2972:
    $P128."pirop"("get_who PP")
  if_3456_end:
.annotate 'line', 2356
    goto if_3454_end
  if_3454:
.annotate 'line', 2354
    find_lex $P127, "$past"
    unless_null $P127, vivify_2973
    new $P127, "Undef"
  vivify_2973:
    $P127."pirop"("get_what PP")
  if_3454_end:
.annotate 'line', 2353
    goto if_3452_end
  if_3452:
.annotate 'line', 2351
    find_lex $P125, "$past"
    unless_null $P125, vivify_2974
    new $P125, "Undef"
  vivify_2974:
    $P125."pirop"("get_how PP")
  if_3452_end:
.annotate 'line', 2350
    goto if_3449_end
  if_3449:
.annotate 'line', 2347
    find_lex $P124, "$past"
    unless_null $P124, vivify_2975
    new $P124, "Undef"
  vivify_2975:
    find_lex $P3451, "$/"
    unless_null $P3451, vivify_2976
    $P3451 = root_new ['parrot';'Hash']
  vivify_2976:
    set $P125, $P3451["quote"]
    unless_null $P125, vivify_2977
    new $P125, "Undef"
  vivify_2977:
    $P127 = $P125."ast"()
    $P124."name"($P127)
.annotate 'line', 2348
    find_lex $P124, "$past"
    unless_null $P124, vivify_2978
    new $P124, "Undef"
  vivify_2978:
    $P124."pasttype"("callmethod")
  if_3449_end:
.annotate 'line', 2363
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2979
    new $P124, "Undef"
  vivify_2979:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2344
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("580_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3460
    .param pmc param_3461
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2368
    .lex "self", param_3460
    .lex "$/", param_3461
.annotate 'line', 2369
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    $P128 = $P127."new"("self" :named("name"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2368
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("581_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3463
    .param pmc param_3464
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2372
    .lex "self", param_3463
    .lex "$/", param_3464
.annotate 'line', 2373
    new $P122, "Undef"
    set $P3465, $P122
    .lex "$past", $P3465
    find_lex $P3466, "$/"
    unless_null $P3466, vivify_2980
    $P3466 = root_new ['parrot';'Hash']
  vivify_2980:
    set $P123, $P3466["args"]
    unless_null $P123, vivify_2981
    new $P123, "Undef"
  vivify_2981:
    $P124 = $P123."ast"()
    store_lex "$past", $P124
.annotate 'line', 2374
    find_lex $P123, "$past"
    unless_null $P123, vivify_2982
    new $P123, "Undef"
  vivify_2982:
    find_lex $P3467, "$/"
    unless_null $P3467, vivify_2983
    $P3467 = root_new ['parrot';'Hash']
  vivify_2983:
    set $P124, $P3467["deflongname"]
    unless_null $P124, vivify_2984
    new $P124, "Undef"
  vivify_2984:
    set $S100, $P124
    $P123."name"($S100)
.annotate 'line', 2375
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_2985
    new $P124, "Undef"
  vivify_2985:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2372
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("582_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3469
    .param pmc param_3470
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2378
    .const 'Sub' $P3477 = "583_1321350766.1143" 
    capture_lex $P3477
    .lex "self", param_3469
    .lex "$/", param_3470
.annotate 'line', 2380
    new $P122, "Undef"
    set $P3471, $P122
    .lex "$var", $P3471
.annotate 'line', 2390
    new $P123, "Undef"
    set $P3472, $P123
    .lex "$past", $P3472
.annotate 'line', 2378
    find_lex $P124, "$var"
    unless_null $P124, vivify_2986
    new $P124, "Undef"
  vivify_2986:
.annotate 'line', 2381
    find_lex $P3474, "$/"
    unless_null $P3474, vivify_2987
    $P3474 = root_new ['parrot';'Hash']
  vivify_2987:
    set $P124, $P3474["name"]
    unless_null $P124, vivify_2988
    new $P124, "Undef"
  vivify_2988:
    set $S100, $P124
    $P125 = "is_lexical"($S100)
    if $P125, if_3473
.annotate 'line', 2384
    .const 'Sub' $P3477 = "583_1321350766.1143" 
    capture_lex $P3477
    $P3477()
    goto if_3473_end
  if_3473:
.annotate 'line', 2382
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    find_lex $P3475, "$/"
    unless_null $P3475, vivify_2994
    $P3475 = root_new ['parrot';'Hash']
  vivify_2994:
    set $P131, $P3475["name"]
    unless_null $P131, vivify_2995
    new $P131, "Undef"
  vivify_2995:
    set $S101, $P131
    $P132 = $P130."new"($S101 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P132
  if_3473_end:
.annotate 'line', 2390
    find_lex $P124, "$var"
    unless_null $P124, vivify_2996
    new $P124, "Undef"
  vivify_2996:
    store_lex "$past", $P124
.annotate 'line', 2391
    find_lex $P3484, "$/"
    unless_null $P3484, vivify_2997
    $P3484 = root_new ['parrot';'Hash']
  vivify_2997:
    set $P124, $P3484["args"]
    unless_null $P124, vivify_2998
    new $P124, "Undef"
  vivify_2998:
    unless $P124, if_3483_end
.annotate 'line', 2392
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3485, "$/"
    unless_null $P3485, vivify_2999
    $P3485 = root_new ['parrot';'Hash']
  vivify_2999:
    set $P3486, $P3485["args"]
    unless_null $P3486, vivify_3000
    $P3486 = root_new ['parrot';'ResizablePMCArray']
  vivify_3000:
    set $P127, $P3486[$I100]
    unless_null $P127, vivify_3001
    new $P127, "Undef"
  vivify_3001:
    $P128 = $P127."ast"()
    store_lex "$past", $P128
.annotate 'line', 2393
    find_lex $P125, "$past"
    unless_null $P125, vivify_3002
    new $P125, "Undef"
  vivify_3002:
    find_lex $P127, "$var"
    unless_null $P127, vivify_3003
    new $P127, "Undef"
  vivify_3003:
    $P125."unshift"($P127)
  if_3483_end:
.annotate 'line', 2395
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_3004
    new $P125, "Undef"
  vivify_3004:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2378
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3476"  :anon :subid("583_1321350766.1143") :outer("582_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2385
    $P3479 = root_new ['parrot';'ResizablePMCArray']
    set $P3478, $P3479
    .lex "@ns", $P3478
    find_lex $P3480, "$/"
    unless_null $P3480, vivify_2989
    $P3480 = root_new ['parrot';'Hash']
  vivify_2989:
    set $P3481, $P3480["name"]
    unless_null $P3481, vivify_2990
    $P3481 = root_new ['parrot';'Hash']
  vivify_2990:
    set $P127, $P3481["identifier"]
    unless_null $P127, vivify_2991
    new $P127, "Undef"
  vivify_2991:
    clone $P128, $P127
    store_lex "@ns", $P128
.annotate 'line', 2386
    find_lex $P3482, "@ns"
    unless_null $P3482, vivify_2992
    $P3482 = root_new ['parrot';'ResizablePMCArray']
  vivify_2992:
    find_lex $P127, "$/"
    unless_null $P127, vivify_2993
    new $P127, "Undef"
  vivify_2993:
    $P128 = "lexical_package_lookup"($P3482, $P127)
    store_lex "$var", $P128
.annotate 'line', 2384
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("584_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3488
    .param pmc param_3489
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2398
    .lex "self", param_3488
    .lex "$/", param_3489
.annotate 'line', 2399
    new $P122, "Undef"
    set $P3490, $P122
    .lex "$past", $P3490
.annotate 'line', 2400
    new $P123, "Undef"
    set $P3491, $P123
    .lex "$pirop", $P3491
.annotate 'line', 2399
    find_lex $P3493, "$/"
    unless_null $P3493, vivify_3005
    $P3493 = root_new ['parrot';'Hash']
  vivify_3005:
    set $P125, $P3493["args"]
    unless_null $P125, vivify_3006
    new $P125, "Undef"
  vivify_3006:
    if $P125, if_3492
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    find_lex $P134, "$/"
    unless_null $P134, vivify_3007
    new $P134, "Undef"
  vivify_3007:
    $P135 = $P133."new"($P134 :named("node"))
    set $P124, $P135
    goto if_3492_end
  if_3492:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3494, "$/"
    unless_null $P3494, vivify_3008
    $P3494 = root_new ['parrot';'Hash']
  vivify_3008:
    set $P3495, $P3494["args"]
    unless_null $P3495, vivify_3009
    $P3495 = root_new ['parrot';'ResizablePMCArray']
  vivify_3009:
    set $P128, $P3495[$I100]
    unless_null $P128, vivify_3010
    new $P128, "Undef"
  vivify_3010:
    $P129 = $P128."ast"()
    set $P124, $P129
  if_3492_end:
    store_lex "$past", $P124
.annotate 'line', 2400
    find_lex $P3496, "$/"
    unless_null $P3496, vivify_3011
    $P3496 = root_new ['parrot';'Hash']
  vivify_3011:
    set $P124, $P3496["op"]
    unless_null $P124, vivify_3012
    new $P124, "Undef"
  vivify_3012:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    store_lex "$pirop", $P125
.annotate 'line', 2401
    find_lex $P124, "$pirop"
    unless_null $P124, vivify_3013
    new $P124, "Undef"
  vivify_3013:
    set $S100, $P124
    split $P125, "__", $S100
    join $S101, " ", $P125
    new $P127, 'String'
    set $P127, $S101
    store_lex "$pirop", $P127
.annotate 'line', 2402
    find_lex $P124, "$past"
    unless_null $P124, vivify_3014
    new $P124, "Undef"
  vivify_3014:
    find_lex $P125, "$pirop"
    unless_null $P125, vivify_3015
    new $P125, "Undef"
  vivify_3015:
    $P124."pirop"($P125)
.annotate 'line', 2403
    find_lex $P124, "$past"
    unless_null $P124, vivify_3016
    new $P124, "Undef"
  vivify_3016:
    $P124."pasttype"("pirop")
.annotate 'line', 2404
    find_lex $P124, "$/"
    find_lex $P125, "$past"
    unless_null $P125, vivify_3017
    new $P125, "Undef"
  vivify_3017:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2398
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::const>" :anon :subid("585_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3498
    .param pmc param_3499
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2407
    .lex "self", param_3498
    .lex "$/", param_3499
.annotate 'line', 2408
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Val"]
    find_lex $P3500, "$/"
    unless_null $P3500, vivify_3018
    $P3500 = root_new ['parrot';'Hash']
  vivify_3018:
    set $P128, $P3500["const"]
    unless_null $P128, vivify_3019
    new $P128, "Undef"
  vivify_3019:
    set $S100, $P128
    find_lex $P129, "$/"
    unless_null $P129, vivify_3020
    new $P129, "Undef"
  vivify_3020:
    $P130 = $P127."new"($S100 :named("value"), "!macro_const" :named("returns"), $P129 :named("node"))
    $P131 = $P122."!make"($P130)
.annotate 'line', 2407
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<nqp::op>" :anon :subid("586_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3502
    .param pmc param_3503
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2411
    .lex "self", param_3502
    .lex "$/", param_3503
.annotate 'line', 2412
    new $P122, "Undef"
    set $P3504, $P122
    .lex "$op", $P3504
.annotate 'line', 2413
    new $P123, "Undef"
    set $P3505, $P123
    .lex "$args", $P3505
.annotate 'line', 2414
    new $P124, "Undef"
    set $P3506, $P124
    .lex "$past", $P3506
.annotate 'line', 2412
    find_lex $P3507, "$/"
    unless_null $P3507, vivify_3021
    $P3507 = root_new ['parrot';'Hash']
  vivify_3021:
    set $P125, $P3507["op"]
    unless_null $P125, vivify_3022
    new $P125, "Undef"
  vivify_3022:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    store_lex "$op", $P127
.annotate 'line', 2413
    find_lex $P3509, "$/"
    unless_null $P3509, vivify_3023
    $P3509 = root_new ['parrot';'Hash']
  vivify_3023:
    set $P127, $P3509["args"]
    unless_null $P127, vivify_3024
    new $P127, "Undef"
  vivify_3024:
    if $P127, if_3508
    new $P132, "ResizablePMCArray"
    set $P125, $P132
    goto if_3508_end
  if_3508:
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_3025
    $P3510 = root_new ['parrot';'Hash']
  vivify_3025:
    set $P3511, $P3510["args"]
    unless_null $P3511, vivify_3026
    $P3511 = root_new ['parrot';'ResizablePMCArray']
  vivify_3026:
    set $P129, $P3511[$I100]
    unless_null $P129, vivify_3027
    new $P129, "Undef"
  vivify_3027:
    $P130 = $P129."ast"()
    $P131 = $P130."list"()
    set $P125, $P131
  if_3508_end:
    store_lex "$args", $P125
.annotate 'line', 2414
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Node"]
    find_lex $P130, "$args"
    unless_null $P130, vivify_3028
    new $P130, "Undef"
  vivify_3028:
    find_lex $P131, "$op"
    unless_null $P131, vivify_3029
    new $P131, "Undef"
  vivify_3029:
    find_lex $P132, "$/"
    unless_null $P132, vivify_3030
    new $P132, "Undef"
  vivify_3030:
    $P133 = $P129."map_node"($P130 :flat, "nqp" :named("map"), $P131 :named("op"), $P132 :named("node"))
    store_lex "$past", $P133
.annotate 'line', 2417
    find_lex $P125, "$past"
    unless_null $P125, vivify_3031
    new $P125, "Undef"
  vivify_3031:
    defined $I100, $P125
    if $I100, unless_3512_end
.annotate 'line', 2418
    find_lex $P127, "$/"
    unless_null $P127, vivify_3032
    new $P127, "Undef"
  vivify_3032:
    $P128 = $P127."CURSOR"()
    new $P129, 'String'
    set $P129, "Unrecognized nqp:: opcode 'nqp::"
    find_lex $P130, "$op"
    unless_null $P130, vivify_3033
    new $P130, "Undef"
  vivify_3033:
    concat $P131, $P129, $P130
    concat $P132, $P131, "'"
    $P128."panic"($P132)
  unless_3512_end:
.annotate 'line', 2419
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3034
    new $P127, "Undef"
  vivify_3034:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2411
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("587_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3514
    .param pmc param_3515
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2422
    .lex "self", param_3514
    .lex "$/", param_3515
.annotate 'line', 2423
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    $P128 = $P127."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2422
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("588_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3517
    .param pmc param_3518
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2428
    .lex "self", param_3517
    .lex "$/", param_3518
    find_lex $P122, "$/"
    find_lex $P3519, "$/"
    unless_null $P3519, vivify_3035
    $P3519 = root_new ['parrot';'Hash']
  vivify_3035:
    set $P123, $P3519["arglist"]
    unless_null $P123, vivify_3036
    new $P123, "Undef"
  vivify_3036:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("589_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3521
    .param pmc param_3522
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2430
    .const 'Sub' $P3529 = "590_1321350766.1143" 
    capture_lex $P3529
    .lex "self", param_3521
    .lex "$/", param_3522
.annotate 'line', 2431
    new $P122, "Undef"
    set $P3523, $P122
    .lex "$past", $P3523
.annotate 'line', 2439
    new $P123, "Undef"
    set $P3524, $P123
    .lex "$i", $P3524
.annotate 'line', 2440
    new $P124, "Undef"
    set $P3525, $P124
    .lex "$n", $P3525
.annotate 'line', 2431
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P130, "$/"
    unless_null $P130, vivify_3037
    new $P130, "Undef"
  vivify_3037:
    $P131 = $P129."new"("call" :named("pasttype"), $P130 :named("node"))
    store_lex "$past", $P131
.annotate 'line', 2432
    find_lex $P3527, "$/"
    unless_null $P3527, vivify_3038
    $P3527 = root_new ['parrot';'Hash']
  vivify_3038:
    set $P125, $P3527["EXPR"]
    unless_null $P125, vivify_3039
    new $P125, "Undef"
  vivify_3039:
    unless $P125, if_3526_end
    .const 'Sub' $P3529 = "590_1321350766.1143" 
    capture_lex $P3529
    $P3529()
  if_3526_end:
.annotate 'line', 2439
    new $P125, "Float"
    assign $P125, 0
    store_lex "$i", $P125
.annotate 'line', 2440
    find_lex $P125, "$past"
    unless_null $P125, vivify_3050
    new $P125, "Undef"
  vivify_3050:
    $P127 = $P125."list"()
    set $N100, $P127
    new $P128, 'Float'
    set $P128, $N100
    store_lex "$n", $P128
.annotate 'line', 2441
    new $P128, 'ExceptionHandler'
    set_label $P128, loop3550_handler
    $P128."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P128
  loop3550_test:
    find_lex $P125, "$i"
    unless_null $P125, vivify_3051
    new $P125, "Undef"
  vivify_3051:
    set $N100, $P125
    find_lex $P127, "$n"
    unless_null $P127, vivify_3052
    new $P127, "Undef"
  vivify_3052:
    set $N101, $P127
    islt $I100, $N100, $N101
    unless $I100, loop3550_done
  loop3550_redo:
.annotate 'line', 2442
    find_lex $P128, "$i"
    unless_null $P128, vivify_3053
    new $P128, "Undef"
  vivify_3053:
    set $I101, $P128
    find_lex $P3539, "$past"
    unless_null $P3539, vivify_3054
    $P3539 = root_new ['parrot';'ResizablePMCArray']
  vivify_3054:
    set $P129, $P3539[$I101]
    unless_null $P129, vivify_3055
    new $P129, "Undef"
  vivify_3055:
    $S100 = $P129."name"()
    iseq $I102, $S100, "&prefix:<|>"
    unless $I102, if_3538_end
.annotate 'line', 2443
    new $P130, "Float"
    assign $P130, 0
    set $I103, $P130
    find_lex $P131, "$i"
    unless_null $P131, vivify_3056
    new $P131, "Undef"
  vivify_3056:
    set $I104, $P131
    find_lex $P3540, "$past"
    unless_null $P3540, vivify_3057
    $P3540 = root_new ['parrot';'ResizablePMCArray']
  vivify_3057:
    set $P3541, $P3540[$I104]
    unless_null $P3541, vivify_3058
    $P3541 = root_new ['parrot';'ResizablePMCArray']
  vivify_3058:
    set $P132, $P3541[$I103]
    unless_null $P132, vivify_3059
    new $P132, "Undef"
  vivify_3059:
    find_lex $P133, "$i"
    unless_null $P133, vivify_3060
    new $P133, "Undef"
  vivify_3060:
    set $I105, $P133
    find_lex $P3542, "$past"
    unless_null $P3542, vivify_3061
    $P3542 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P3542
  vivify_3061:
    set $P3542[$I105], $P132
.annotate 'line', 2444
    find_lex $P130, "$i"
    unless_null $P130, vivify_3062
    new $P130, "Undef"
  vivify_3062:
    set $I103, $P130
    find_lex $P3543, "$past"
    unless_null $P3543, vivify_3063
    $P3543 = root_new ['parrot';'ResizablePMCArray']
  vivify_3063:
    set $P131, $P3543[$I103]
    unless_null $P131, vivify_3064
    new $P131, "Undef"
  vivify_3064:
    $P131."flat"(1)
.annotate 'line', 2445
    find_lex $P131, "$i"
    unless_null $P131, vivify_3065
    new $P131, "Undef"
  vivify_3065:
    set $I103, $P131
    find_lex $P3546, "$past"
    unless_null $P3546, vivify_3066
    $P3546 = root_new ['parrot';'ResizablePMCArray']
  vivify_3066:
    set $P132, $P3546[$I103]
    unless_null $P132, vivify_3067
    new $P132, "Undef"
  vivify_3067:
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Val"]
    $P137 = $P132."isa"($P136)
    if $P137, if_3545
    set $P130, $P137
    goto if_3545_end
  if_3545:
.annotate 'line', 2446
    find_lex $P138, "$i"
    unless_null $P138, vivify_3068
    new $P138, "Undef"
  vivify_3068:
    set $I104, $P138
    find_lex $P3547, "$past"
    unless_null $P3547, vivify_3069
    $P3547 = root_new ['parrot';'ResizablePMCArray']
  vivify_3069:
    set $P139, $P3547[$I104]
    unless_null $P139, vivify_3070
    new $P139, "Undef"
  vivify_3070:
    $S101 = $P139."name"()
    new $P140, "Float"
    assign $P140, 0
    set $I105, $P140
    new $P141, "Float"
    assign $P141, 1
    set $I106, $P141
    substr $S102, $S101, $I105, $I106
    iseq $I107, $S102, "%"
    new $P130, 'Integer'
    set $P130, $I107
  if_3545_end:
    unless $P130, if_3544_end
.annotate 'line', 2447
    find_lex $P142, "$i"
    unless_null $P142, vivify_3071
    new $P142, "Undef"
  vivify_3071:
    set $I108, $P142
    find_lex $P3548, "$past"
    unless_null $P3548, vivify_3072
    $P3548 = root_new ['parrot';'ResizablePMCArray']
  vivify_3072:
    set $P143, $P3548[$I108]
    unless_null $P143, vivify_3073
    new $P143, "Undef"
  vivify_3073:
    $P143."named"(1)
  if_3544_end:
  if_3538_end:
.annotate 'line', 2441
    find_lex $P128, "$i"
    unless_null $P128, vivify_3074
    new $P128, "Undef"
  vivify_3074:
    clone $P3549, $P128
    inc $P128
  loop3550_next:
    goto loop3550_test
  loop3550_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P129, exception, 'type'
    eq $P129, .CONTROL_LOOP_NEXT, loop3550_next
    eq $P129, .CONTROL_LOOP_REDO, loop3550_redo
  loop3550_done:
    pop_eh 
.annotate 'line', 2452
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3075
    new $P127, "Undef"
  vivify_3075:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2430
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3528"  :anon :subid("590_1321350766.1143") :outer("589_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2432
    .const 'Sub' $P3535 = "591_1321350766.1143" 
    capture_lex $P3535
.annotate 'line', 2433
    new $P127, "Undef"
    set $P3530, $P127
    .lex "$expr", $P3530
    find_lex $P3531, "$/"
    unless_null $P3531, vivify_3040
    $P3531 = root_new ['parrot';'Hash']
  vivify_3040:
    set $P128, $P3531["EXPR"]
    unless_null $P128, vivify_3041
    new $P128, "Undef"
  vivify_3041:
    $P129 = $P128."ast"()
    store_lex "$expr", $P129
.annotate 'line', 2434
    find_lex $P130, "$expr"
    unless_null $P130, vivify_3042
    new $P130, "Undef"
  vivify_3042:
    $S100 = $P130."name"()
    iseq $I100, $S100, "&infix:<,>"
    if $I100, if_3533
    new $P129, 'Integer'
    set $P129, $I100
    goto if_3533_end
  if_3533:
    find_lex $P131, "$expr"
    unless_null $P131, vivify_3043
    new $P131, "Undef"
  vivify_3043:
    $P132 = $P131."named"()
    isfalse $I101, $P132
    new $P129, 'Integer'
    set $P129, $I101
  if_3533_end:
    if $P129, if_3532
.annotate 'line', 2437
    find_lex $P134, "$past"
    unless_null $P134, vivify_3044
    new $P134, "Undef"
  vivify_3044:
    find_lex $P135, "$expr"
    unless_null $P135, vivify_3045
    new $P135, "Undef"
  vivify_3045:
    $P136 = $P134."push"($P135)
    set $P128, $P136
.annotate 'line', 2434
    goto if_3532_end
  if_3532:
.annotate 'line', 2435
    find_lex $P134, "$expr"
    unless_null $P134, vivify_3046
    new $P134, "Undef"
  vivify_3046:
    $P135 = $P134."list"()
    defined $I102, $P135
    unless $I102, for_undef_3047
    iter $P133, $P135
    new $P137, 'ExceptionHandler'
    set_label $P137, loop3537_handler
    $P137."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P137
  loop3537_test:
    unless $P133, loop3537_done
    shift $P136, $P133
  loop3537_redo:
    .const 'Sub' $P3535 = "591_1321350766.1143" 
    capture_lex $P3535
    $P3535($P136)
  loop3537_next:
    goto loop3537_test
  loop3537_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P138, exception, 'type'
    eq $P138, .CONTROL_LOOP_NEXT, loop3537_next
    eq $P138, .CONTROL_LOOP_REDO, loop3537_redo
  loop3537_done:
    pop_eh 
  for_undef_3047:
.annotate 'line', 2434
    set $P128, $P133
  if_3532_end:
.annotate 'line', 2432
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3534"  :anon :subid("591_1321350766.1143") :outer("590_1321350766.1143")
    .param pmc param_3536
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2435
    .lex "$_", param_3536
    find_lex $P137, "$past"
    unless_null $P137, vivify_3048
    new $P137, "Undef"
  vivify_3048:
    find_lex $P138, "$_"
    unless_null $P138, vivify_3049
    new $P138, "Undef"
  vivify_3049:
    $P139 = $P137."push"($P138)
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("592_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3552
    .param pmc param_3553
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2455
    .lex "self", param_3552
    .lex "$/", param_3553
    find_lex $P122, "$/"
    find_lex $P3554, "$/"
    unless_null $P3554, vivify_3076
    $P3554 = root_new ['parrot';'Hash']
  vivify_3076:
    set $P123, $P3554["multi_declarator"]
    unless_null $P123, vivify_3077
    new $P123, "Undef"
  vivify_3077:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("593_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3556
    .param pmc param_3557
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2457
    .lex "self", param_3556
    .lex "$/", param_3557
    find_lex $P122, "$/"
    find_lex $P3558, "$/"
    unless_null $P3558, vivify_3078
    $P3558 = root_new ['parrot';'Hash']
  vivify_3078:
    set $P123, $P3558["value"]
    unless_null $P123, vivify_3079
    new $P123, "Undef"
  vivify_3079:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("594_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3560
    .param pmc param_3561
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2459
    .lex "self", param_3560
    .lex "$/", param_3561
.annotate 'line', 2460
    find_lex $P122, "$/"
.annotate 'line', 2461
    find_lex $P3563, "$/"
    unless_null $P3563, vivify_3080
    $P3563 = root_new ['parrot';'Hash']
  vivify_3080:
    set $P124, $P3563["EXPR"]
    unless_null $P124, vivify_3081
    new $P124, "Undef"
  vivify_3081:
    if $P124, if_3562
.annotate 'line', 2462
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    find_lex $P133, "$/"
    unless_null $P133, vivify_3082
    new $P133, "Undef"
  vivify_3082:
    $P134 = $P132."new"("list" :named("pasttype"), $P133 :named("node"))
    set $P123, $P134
.annotate 'line', 2461
    goto if_3562_end
  if_3562:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3564, "$/"
    unless_null $P3564, vivify_3083
    $P3564 = root_new ['parrot';'Hash']
  vivify_3083:
    set $P3565, $P3564["EXPR"]
    unless_null $P3565, vivify_3084
    $P3565 = root_new ['parrot';'ResizablePMCArray']
  vivify_3084:
    set $P127, $P3565[$I100]
    unless_null $P127, vivify_3085
    new $P127, "Undef"
  vivify_3085:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_3562_end:
    $P135 = $P122."!make"($P123)
.annotate 'line', 2459
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("595_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3567
    .param pmc param_3568
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2465
    .lex "self", param_3567
    .lex "$/", param_3568
.annotate 'line', 2466
    new $P122, "Undef"
    set $P3569, $P122
    .lex "$past", $P3569
.annotate 'line', 2465
    find_lex $P123, "$past"
    unless_null $P123, vivify_3086
    new $P123, "Undef"
  vivify_3086:
.annotate 'line', 2467
    find_lex $P3571, "$/"
    unless_null $P3571, vivify_3087
    $P3571 = root_new ['parrot';'Hash']
  vivify_3087:
    set $P123, $P3571["EXPR"]
    unless_null $P123, vivify_3088
    new $P123, "Undef"
  vivify_3088:
    if $P123, if_3570
.annotate 'line', 2474
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    $P129 = $P128."new"("list" :named("pasttype"))
    store_lex "$past", $P129
.annotate 'line', 2473
    goto if_3570_end
  if_3570:
.annotate 'line', 2468
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_3089
    $P3572 = root_new ['parrot';'Hash']
  vivify_3089:
    set $P3573, $P3572["EXPR"]
    unless_null $P3573, vivify_3090
    $P3573 = root_new ['parrot';'ResizablePMCArray']
  vivify_3090:
    set $P125, $P3573[$I100]
    unless_null $P125, vivify_3091
    new $P125, "Undef"
  vivify_3091:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2469
    find_lex $P124, "$past"
    unless_null $P124, vivify_3092
    new $P124, "Undef"
  vivify_3092:
    $S100 = $P124."name"()
    isne $I100, $S100, "&infix:<,>"
    unless $I100, if_3574_end
.annotate 'line', 2470
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    find_lex $P130, "$past"
    unless_null $P130, vivify_3093
    new $P130, "Undef"
  vivify_3093:
    $P131 = $P129."new"($P130, "list" :named("pasttype"))
    store_lex "$past", $P131
  if_3574_end:
  if_3570_end:
.annotate 'line', 2476
    find_lex $P123, "$past"
    unless_null $P123, vivify_3094
    new $P123, "Undef"
  vivify_3094:
    $P123."name"("&circumfix:<[ ]>")
.annotate 'line', 2477
    find_lex $P123, "$/"
    find_lex $P124, "$past"
    unless_null $P124, vivify_3095
    new $P124, "Undef"
  vivify_3095:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2465
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("596_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3576
    .param pmc param_3577
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2480
    .lex "self", param_3576
    .lex "$/", param_3577
    find_lex $P122, "$/"
    find_lex $P3578, "$/"
    unless_null $P3578, vivify_3096
    $P3578 = root_new ['parrot';'Hash']
  vivify_3096:
    set $P123, $P3578["quote_EXPR"]
    unless_null $P123, vivify_3097
    new $P123, "Undef"
  vivify_3097:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("597_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3580
    .param pmc param_3581
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2481
    .lex "self", param_3580
    .lex "$/", param_3581
    find_lex $P122, "$/"
    find_lex $P3582, "$/"
    unless_null $P3582, vivify_3098
    $P3582 = root_new ['parrot';'Hash']
  vivify_3098:
    set $P123, $P3582["quote_EXPR"]
    unless_null $P123, vivify_3099
    new $P123, "Undef"
  vivify_3099:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("598_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3584
    .param pmc param_3585
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2483
    .const 'Sub' $P3592 = "599_1321350766.1143" 
    capture_lex $P3592
    .lex "self", param_3584
    .lex "$/", param_3585
.annotate 'line', 2484
    find_lex $P3587, "$/"
    unless_null $P3587, vivify_3100
    $P3587 = root_new ['parrot';'Hash']
  vivify_3100:
    set $P3588, $P3587["pblock"]
    unless_null $P3588, vivify_3101
    $P3588 = root_new ['parrot';'Hash']
  vivify_3101:
    set $P3589, $P3588["blockoid"]
    unless_null $P3589, vivify_3102
    $P3589 = root_new ['parrot';'Hash']
  vivify_3102:
    set $P3590, $P3589["statementlist"]
    unless_null $P3590, vivify_3103
    $P3590 = root_new ['parrot';'Hash']
  vivify_3103:
    set $P123, $P3590["statement"]
    unless_null $P123, vivify_3104
    new $P123, "Undef"
  vivify_3104:
    set $N100, $P123
    set $N101, 0
    isgt $I100, $N100, $N101
    if $I100, if_3586
.annotate 'line', 2489
    find_lex $P3597, "$/"
    unless_null $P3597, vivify_3105
    $P3597 = root_new ['parrot';'Hash']
  vivify_3105:
    set $P3598, $P3597["pblock"]
    unless_null $P3598, vivify_3106
    $P3598 = root_new ['parrot';'Hash']
  vivify_3106:
    set $P3599, $P3598["blockoid"]
    unless_null $P3599, vivify_3107
    $P3599 = root_new ['parrot';'Hash']
  vivify_3107:
    set $P129, $P3599["you_are_here"]
    unless_null $P129, vivify_3108
    new $P129, "Undef"
  vivify_3108:
    if $P129, if_3596
.annotate 'line', 2493
    find_lex $P130, "$/"
    $P131 = "vivitype"("%")
    $P132 = $P130."!make"($P131)
.annotate 'line', 2492
    set $P127, $P132
.annotate 'line', 2489
    goto if_3596_end
  if_3596:
.annotate 'line', 2490
    find_lex $P130, "$/"
    find_lex $P3600, "$/"
    unless_null $P3600, vivify_3109
    $P3600 = root_new ['parrot';'Hash']
  vivify_3109:
    set $P131, $P3600["pblock"]
    unless_null $P131, vivify_3110
    new $P131, "Undef"
  vivify_3110:
    $P132 = $P131."ast"()
    $P133 = $P130."!make"($P132)
.annotate 'line', 2489
    set $P127, $P133
  if_3596_end:
    set $P122, $P127
.annotate 'line', 2484
    goto if_3586_end
  if_3586:
    .const 'Sub' $P3592 = "599_1321350766.1143" 
    capture_lex $P3592
    $P125 = $P3592()
    set $P122, $P125
  if_3586_end:
.annotate 'line', 2483
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3591"  :anon :subid("599_1321350766.1143") :outer("598_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2485
    new $P124, "Undef"
    set $P3593, $P124
    .lex "$past", $P3593
    find_lex $P3594, "$/"
    unless_null $P3594, vivify_3111
    $P3594 = root_new ['parrot';'Hash']
  vivify_3111:
    set $P125, $P3594["pblock"]
    unless_null $P125, vivify_3112
    new $P125, "Undef"
  vivify_3112:
    $P127 = $P125."ast"()
    store_lex "$past", $P127
.annotate 'line', 2486
    new $P125, "Float"
    assign $P125, 1
    find_lex $P3595, "$past"
    unless_null $P3595, vivify_3113
    $P3595 = root_new ['parrot';'Hash']
    store_lex "$past", $P3595
  vivify_3113:
    set $P3595["bareblock"], $P125
.annotate 'line', 2487
    find_dynamic_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3114
    new $P127, "Undef"
  vivify_3114:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2484
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("600_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3602
    .param pmc param_3603
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2497
    .lex "self", param_3602
    .lex "$/", param_3603
.annotate 'line', 2498
    new $P122, "Undef"
    set $P3604, $P122
    .lex "$name", $P3604
    find_lex $P3606, "$/"
    unless_null $P3606, vivify_3115
    $P3606 = root_new ['parrot';'Hash']
  vivify_3115:
    set $P124, $P3606["sigil"]
    unless_null $P124, vivify_3116
    new $P124, "Undef"
  vivify_3116:
    set $S100, $P124
    iseq $I100, $S100, "@"
    if $I100, if_3605
.annotate 'line', 2499
    find_lex $P3608, "$/"
    unless_null $P3608, vivify_3117
    $P3608 = root_new ['parrot';'Hash']
  vivify_3117:
    set $P128, $P3608["sigil"]
    unless_null $P128, vivify_3118
    new $P128, "Undef"
  vivify_3118:
    set $S101, $P128
    iseq $I101, $S101, "%"
    if $I101, if_3607
    new $P130, "String"
    assign $P130, "item"
    set $P127, $P130
    goto if_3607_end
  if_3607:
    new $P129, "String"
    assign $P129, "hash"
    set $P127, $P129
  if_3607_end:
    set $P123, $P127
.annotate 'line', 2498
    goto if_3605_end
  if_3605:
    new $P125, "String"
    assign $P125, "list"
    set $P123, $P125
  if_3605_end:
    store_lex "$name", $P123
.annotate 'line', 2501
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    find_lex $P129, "$name"
    unless_null $P129, vivify_3119
    new $P129, "Undef"
  vivify_3119:
    find_lex $P3609, "$/"
    unless_null $P3609, vivify_3120
    $P3609 = root_new ['parrot';'Hash']
  vivify_3120:
    set $P130, $P3609["semilist"]
    unless_null $P130, vivify_3121
    new $P130, "Undef"
  vivify_3121:
    $P131 = $P130."ast"()
    $P132 = $P128."new"($P131, "callmethod" :named("pasttype"), $P129 :named("name"))
    $P133 = $P123."!make"($P132)
.annotate 'line', 2497
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("601_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3611
    .param pmc param_3612
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2504
    .lex "self", param_3611
    .lex "$/", param_3612
    find_lex $P122, "$/"
    find_lex $P3613, "$/"
    unless_null $P3613, vivify_3122
    $P3613 = root_new ['parrot';'Hash']
  vivify_3122:
    set $P123, $P3613["statement"]
    unless_null $P123, vivify_3123
    new $P123, "Undef"
  vivify_3123:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("602_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3615
    .param pmc param_3616
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2506
    .lex "self", param_3615
    .lex "$/", param_3616
.annotate 'line', 2507
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3617, "$/"
    unless_null $P3617, vivify_3124
    $P3617 = root_new ['parrot';'Hash']
  vivify_3124:
    set $P128, $P3617["EXPR"]
    unless_null $P128, vivify_3125
    new $P128, "Undef"
  vivify_3125:
    $P129 = $P128."ast"()
.annotate 'line', 2509
    $P130 = "vivitype"("@")
.annotate 'line', 2507
    $P131 = $P127."new"($P129, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2506
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("603_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3619
    .param pmc param_3620
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2512
    .lex "self", param_3619
    .lex "$/", param_3620
.annotate 'line', 2513
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3621, "$/"
    unless_null $P3621, vivify_3126
    $P3621 = root_new ['parrot';'Hash']
  vivify_3126:
    set $P128, $P3621["EXPR"]
    unless_null $P128, vivify_3127
    new $P128, "Undef"
  vivify_3127:
    $P129 = $P128."ast"()
.annotate 'line', 2515
    $P130 = "vivitype"("%")
.annotate 'line', 2513
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2512
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("604_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3623
    .param pmc param_3624
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2518
    .lex "self", param_3623
    .lex "$/", param_3624
.annotate 'line', 2519
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    find_lex $P3625, "$/"
    unless_null $P3625, vivify_3128
    $P3625 = root_new ['parrot';'Hash']
  vivify_3128:
    set $P128, $P3625["quote_EXPR"]
    unless_null $P128, vivify_3129
    new $P128, "Undef"
  vivify_3129:
    $P129 = $P128."ast"()
.annotate 'line', 2521
    $P130 = "vivitype"("%")
.annotate 'line', 2519
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2518
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("605_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3627
    .param pmc param_3628
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2524
    .lex "self", param_3627
    .lex "$/", param_3628
.annotate 'line', 2525
    find_lex $P122, "$/"
    find_lex $P3629, "$/"
    unless_null $P3629, vivify_3130
    $P3629 = root_new ['parrot';'Hash']
  vivify_3130:
    set $P123, $P3629["arglist"]
    unless_null $P123, vivify_3131
    new $P123, "Undef"
  vivify_3131:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2524
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("606_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3631
    .param pmc param_3632
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2528
    .lex "self", param_3631
    .lex "$/", param_3632
.annotate 'line', 2529
    find_lex $P122, "$/"
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_3132
    $P3634 = root_new ['parrot';'Hash']
  vivify_3132:
    set $P124, $P3634["quote"]
    unless_null $P124, vivify_3133
    new $P124, "Undef"
  vivify_3133:
    if $P124, if_3633
    find_lex $P3636, "$/"
    unless_null $P3636, vivify_3134
    $P3636 = root_new ['parrot';'Hash']
  vivify_3134:
    set $P128, $P3636["number"]
    unless_null $P128, vivify_3135
    new $P128, "Undef"
  vivify_3135:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3633_end
  if_3633:
    find_lex $P3635, "$/"
    unless_null $P3635, vivify_3136
    $P3635 = root_new ['parrot';'Hash']
  vivify_3136:
    set $P125, $P3635["quote"]
    unless_null $P125, vivify_3137
    new $P125, "Undef"
  vivify_3137:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3633_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 2528
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("607_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3638
    .param pmc param_3639
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2532
    .lex "self", param_3638
    .lex "$/", param_3639
.annotate 'line', 2533
    new $P122, "Undef"
    set $P3640, $P122
    .lex "$value", $P3640
    find_lex $P3642, "$/"
    unless_null $P3642, vivify_3138
    $P3642 = root_new ['parrot';'Hash']
  vivify_3138:
    set $P124, $P3642["dec_number"]
    unless_null $P124, vivify_3139
    new $P124, "Undef"
  vivify_3139:
    if $P124, if_3641
    find_lex $P3644, "$/"
    unless_null $P3644, vivify_3140
    $P3644 = root_new ['parrot';'Hash']
  vivify_3140:
    set $P128, $P3644["integer"]
    unless_null $P128, vivify_3141
    new $P128, "Undef"
  vivify_3141:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3641_end
  if_3641:
    find_lex $P3643, "$/"
    unless_null $P3643, vivify_3142
    $P3643 = root_new ['parrot';'Hash']
  vivify_3142:
    set $P125, $P3643["dec_number"]
    unless_null $P125, vivify_3143
    new $P125, "Undef"
  vivify_3143:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3641_end:
    store_lex "$value", $P123
.annotate 'line', 2534
    find_lex $P3646, "$/"
    unless_null $P3646, vivify_3144
    $P3646 = root_new ['parrot';'Hash']
  vivify_3144:
    set $P123, $P3646["sign"]
    unless_null $P123, vivify_3145
    new $P123, "Undef"
  vivify_3145:
    set $S100, $P123
    iseq $I100, $S100, "-"
    unless $I100, if_3645_end
    find_lex $P124, "$value"
    unless_null $P124, vivify_3146
    new $P124, "Undef"
  vivify_3146:
    neg $P125, $P124
    store_lex "$value", $P125
  if_3645_end:
.annotate 'line', 2535
    find_lex $P123, "$/"
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Val"]
    find_lex $P129, "$value"
    unless_null $P129, vivify_3147
    new $P129, "Undef"
  vivify_3147:
    $P130 = $P128."new"($P129 :named("value"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 2532
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("608_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3648
    .param pmc param_3649
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2538
    .lex "self", param_3648
    .lex "$/", param_3649
    find_lex $P122, "$/"
    find_lex $P3650, "$/"
    unless_null $P3650, vivify_3148
    $P3650 = root_new ['parrot';'Hash']
  vivify_3148:
    set $P123, $P3650["quote_EXPR"]
    unless_null $P123, vivify_3149
    new $P123, "Undef"
  vivify_3149:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("609_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3652
    .param pmc param_3653
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2539
    .lex "self", param_3652
    .lex "$/", param_3653
    find_lex $P122, "$/"
    find_lex $P3654, "$/"
    unless_null $P3654, vivify_3150
    $P3654 = root_new ['parrot';'Hash']
  vivify_3150:
    set $P123, $P3654["quote_EXPR"]
    unless_null $P123, vivify_3151
    new $P123, "Undef"
  vivify_3151:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("610_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3656
    .param pmc param_3657
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2540
    .lex "self", param_3656
    .lex "$/", param_3657
    find_lex $P122, "$/"
    find_lex $P3658, "$/"
    unless_null $P3658, vivify_3152
    $P3658 = root_new ['parrot';'Hash']
  vivify_3152:
    set $P123, $P3658["quote_EXPR"]
    unless_null $P123, vivify_3153
    new $P123, "Undef"
  vivify_3153:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("611_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3660
    .param pmc param_3661
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2541
    .lex "self", param_3660
    .lex "$/", param_3661
    find_lex $P122, "$/"
    find_lex $P3662, "$/"
    unless_null $P3662, vivify_3154
    $P3662 = root_new ['parrot';'Hash']
  vivify_3154:
    set $P123, $P3662["quote_EXPR"]
    unless_null $P123, vivify_3155
    new $P123, "Undef"
  vivify_3155:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("612_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3664
    .param pmc param_3665
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2542
    .lex "self", param_3664
    .lex "$/", param_3665
    find_lex $P122, "$/"
    find_lex $P3666, "$/"
    unless_null $P3666, vivify_3156
    $P3666 = root_new ['parrot';'Hash']
  vivify_3156:
    set $P123, $P3666["quote_EXPR"]
    unless_null $P123, vivify_3157
    new $P123, "Undef"
  vivify_3157:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("613_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3668
    .param pmc param_3669
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2543
    .lex "self", param_3668
    .lex "$/", param_3669
.annotate 'line', 2544
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P3670, "$/"
    unless_null $P3670, vivify_3158
    $P3670 = root_new ['parrot';'Hash']
  vivify_3158:
    set $P128, $P3670["quote_EXPR"]
    unless_null $P128, vivify_3159
    new $P128, "Undef"
  vivify_3159:
    $P129 = $P128."ast"()
    $P130 = $P129."value"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_3160
    new $P131, "Undef"
  vivify_3160:
    $P132 = $P127."new"($P130 :named("inline"), "inline" :named("pasttype"), $P131 :named("node"))
    $P133 = $P122."!make"($P132)
.annotate 'line', 2543
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("614_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3674
    .param pmc param_3675
    .param pmc param_3676 :optional
    .param int has_param_3676 :opt_flag
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2549
    new $P3673, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3673, control_3672
    push_eh $P3673
    .lex "self", param_3674
    .lex "$/", param_3675
    if has_param_3676, optparam_3161
    new $P122, "Undef"
    set param_3676, $P122
  optparam_3161:
    .lex "$key", param_3676
.annotate 'line', 2556
    new $P123, "Undef"
    set $P3677, $P123
    .lex "$regex", $P3677
.annotate 'line', 2558
    new $P124, "Undef"
    set $P3678, $P124
    .lex "$past", $P3678
.annotate 'line', 2550
    find_lex $P125, "$key"
    unless_null $P125, vivify_3162
    new $P125, "Undef"
  vivify_3162:
    set $S100, $P125
    iseq $I100, $S100, "open"
    unless $I100, if_3679_end
.annotate 'line', 2551
    null $P127
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "Regex"
    nqp_get_package_through_who $P130, $P129, "P6Regex"
    nqp_get_package_through_who $P131, $P130, "Actions"
    get_who $P132, $P131
    set $P132["$REGEXNAME"], $P127
.annotate 'line', 2552
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3680, $P129["@BLOCK"]
    unless_null $P3680, vivify_3163
    $P3680 = root_new ['parrot';'ResizablePMCArray']
  vivify_3163:
    set $P130, $P3680[$I101]
    unless_null $P130, vivify_3164
    new $P130, "Undef"
  vivify_3164:
    $P130."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2553
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3681, $P129["@BLOCK"]
    unless_null $P3681, vivify_3165
    $P3681 = root_new ['parrot';'ResizablePMCArray']
  vivify_3165:
    set $P130, $P3681[$I101]
    unless_null $P130, vivify_3166
    new $P130, "Undef"
  vivify_3166:
    $P130."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2554
    new $P127, "Exception"
    set $P127['type'], .CONTROL_RETURN
    new $P128, "Float"
    assign $P128, 0
    setattribute $P127, 'payload', $P128
    throw $P127
  if_3679_end:
.annotate 'line', 2557
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P131, $P130["buildsub"]
    find_lex $P3682, "$/"
    unless_null $P3682, vivify_3167
    $P3682 = root_new ['parrot';'Hash']
  vivify_3167:
    set $P132, $P3682["p6regex"]
    unless_null $P132, vivify_3168
    new $P132, "Undef"
  vivify_3168:
    $P133 = $P132."ast"()
    find_lex $P134, "$?PACKAGE"
    get_who $P135, $P134
    set $P3683, $P135["@BLOCK"]
    unless_null $P3683, vivify_3169
    $P3683 = root_new ['parrot';'ResizablePMCArray']
  vivify_3169:
    $P136 = $P3683."shift"()
    $P137 = $P131($P133, $P136)
    store_lex "$regex", $P137
.annotate 'line', 2559
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
.annotate 'line', 2561
    new $P130, "ResizablePMCArray"
    push $P130, "Regex"
    push $P130, "Regex"
    find_lex $P131, "$/"
    unless_null $P131, vivify_3170
    new $P131, "Undef"
  vivify_3170:
    $P132 = "lexical_package_lookup"($P130, $P131)
    find_lex $P133, "$regex"
    unless_null $P133, vivify_3171
    new $P133, "Undef"
  vivify_3171:
    $P134 = $P129."new"($P132, $P133, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2559
    store_lex "$past", $P134
.annotate 'line', 2565
    find_lex $P125, "$regex"
    unless_null $P125, vivify_3172
    new $P125, "Undef"
  vivify_3172:
    find_lex $P3684, "$past"
    unless_null $P3684, vivify_3173
    $P3684 = root_new ['parrot';'Hash']
    store_lex "$past", $P3684
  vivify_3173:
    set $P3684["sink"], $P125
.annotate 'line', 2566
    find_lex $P125, "$/"
    find_lex $P127, "$past"
    unless_null $P127, vivify_3174
    new $P127, "Undef"
  vivify_3174:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2549
    .return ($P128)
  control_3672:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("615_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3686
    .param pmc param_3687
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2569
    .lex "self", param_3686
    .lex "$/", param_3687
    find_lex $P122, "$/"
    find_lex $P3688, "$/"
    unless_null $P3688, vivify_3175
    $P3688 = root_new ['parrot';'Hash']
  vivify_3175:
    set $P123, $P3688["variable"]
    unless_null $P123, vivify_3176
    new $P123, "Undef"
  vivify_3176:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("616_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3690
    .param pmc param_3691
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2570
    .lex "self", param_3690
    .lex "$/", param_3691
.annotate 'line', 2571
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2572
    find_lex $P3692, "$/"
    unless_null $P3692, vivify_3177
    $P3692 = root_new ['parrot';'Hash']
  vivify_3177:
    set $P128, $P3692["block"]
    unless_null $P128, vivify_3178
    new $P128, "Undef"
  vivify_3178:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    find_lex $P131, "$/"
    unless_null $P131, vivify_3179
    new $P131, "Undef"
  vivify_3179:
    $P132 = $P127."new"($P130, "set S*" :named("pirop"), $P131 :named("node"))
.annotate 'line', 2571
    $P133 = $P122."!make"($P132)
.annotate 'line', 2570
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("617_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3694
    .param pmc param_3695
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2575
    .lex "self", param_3694
    .lex "$/", param_3695
    find_lex $P122, "$/"
    $P123 = $P122."!make"("\e")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("618_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3697
    .param pmc param_3698
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2579
    .lex "self", param_3697
    .lex "$/", param_3698
    find_lex $P122, "$/"
    find_lex $P3699, "$/"
    unless_null $P3699, vivify_3180
    $P3699 = root_new ['parrot';'Hash']
  vivify_3180:
    set $P123, $P3699["dotty"]
    unless_null $P123, vivify_3181
    new $P123, "Undef"
  vivify_3181:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("619_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3701
    .param pmc param_3702
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2581
    .lex "self", param_3701
    .lex "$/", param_3702
.annotate 'line', 2582
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2583
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    inc %0"
.annotate 'line', 2582
    $P129 = $P127."new"("postfix:<++>" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2581
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("620_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3704
    .param pmc param_3705
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2587
    .lex "self", param_3704
    .lex "$/", param_3705
.annotate 'line', 2588
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2589
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    dec %0"
.annotate 'line', 2588
    $P129 = $P127."new"("postfix:<-->" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2587
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("621_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3707
    .param pmc param_3708
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2593
    .lex "self", param_3707
    .lex "$/", param_3708
.annotate 'line', 2594
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2595
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Var"]
    $P132 = $P131."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P133, "$/"
    unless_null $P133, vivify_3182
    new $P133, "Undef"
  vivify_3182:
    $P134 = $P127."new"($P132, "callmethod" :named("pasttype"), "!make" :named("name"), $P133 :named("node"))
.annotate 'line', 2594
    $P135 = $P122."!make"($P134)
.annotate 'line', 2593
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("622_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3710
    .param pmc param_3711
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2611
    .lex "self", param_3710
    .lex "$/", param_3711
    find_lex $P122, "$/"
    unless_null $P122, vivify_3183
    new $P122, "Undef"
  vivify_3183:
    $P123 = "control"($P122, "CONTROL_LOOP_NEXT")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("623_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3713
    .param pmc param_3714
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2612
    .lex "self", param_3713
    .lex "$/", param_3714
    find_lex $P122, "$/"
    unless_null $P122, vivify_3184
    new $P122, "Undef"
  vivify_3184:
    $P123 = "control"($P122, "CONTROL_LOOP_LAST")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("624_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3716
    .param pmc param_3717
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2613
    .lex "self", param_3716
    .lex "$/", param_3717
    find_lex $P122, "$/"
    unless_null $P122, vivify_3185
    new $P122, "Undef"
  vivify_3185:
    $P123 = "control"($P122, "CONTROL_LOOP_REDO")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("625_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3719
    .param pmc param_3720
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2615
    .lex "self", param_3719
    .lex "$/", param_3720
.annotate 'line', 2616
    find_lex $P122, "$/"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    find_lex $P128, "$/"
    unless_null $P128, vivify_3186
    new $P128, "Undef"
  vivify_3186:
    $P129 = $P127."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P128 :named("node"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2615
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("626_1321350766.1143") :outer("446_1321350766.1143")
    .param pmc param_3722
    .param pmc param_3723
    .param pmc param_3724
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2693
    .const 'Sub' $P3727 = "627_1321350766.1143" 
    capture_lex $P3727
    .lex "self", param_3722
    .lex "$/", param_3723
    .lex "@name", param_3724
.annotate 'line', 2694
    new $P122, "Undef"
    set $P3725, $P122
    .lex "$known", $P3725
    new $P123, "Float"
    assign $P123, 0
    store_lex "$known", $P123
.annotate 'line', 2695
    .const 'Sub' $P3727 = "627_1321350766.1143" 
    capture_lex $P3727
    $P3727()
.annotate 'line', 2693
    find_lex $P123, "$known"
    unless_null $P123, vivify_3189
    new $P123, "Undef"
  vivify_3189:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3726"  :anon :subid("627_1321350766.1143") :outer("626_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2695
    new $P3731, 'ExceptionHandler'
    set_label $P3731, control_3730
    $P3731."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3731
.annotate 'line', 2696
    find_lex $P3728, "@name"
    unless_null $P3728, vivify_3187
    $P3728 = root_new ['parrot';'ResizablePMCArray']
  vivify_3187:
    find_lex $P123, "$/"
    unless_null $P123, vivify_3188
    new $P123, "Undef"
  vivify_3188:
    "find_sym"($P3728, $P123)
.annotate 'line', 2697
    new $P123, "Float"
    assign $P123, 1
    store_lex "$known", $P123
.annotate 'line', 2695
    pop_eh 
    goto skip_handler_3729
  control_3730:
    .local pmc exception 
    .get_results (exception) 
    new $P3733, 'Integer'
    set $P3733, 1
    set exception["handled"], $P3733
    set $I3734, exception["handled"]
    eq $I3734, 1, handled_3732
    rethrow exception
  handled_3732:
    .return (exception)
  skip_handler_3729:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3735"  :subid("628_1321350766.1143") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2762
    .const 'Sub' $P3765 = "635_1321350766.1143" 
    capture_lex $P3765
    .const 'Sub' $P3761 = "634_1321350766.1143" 
    capture_lex $P3761
    .const 'Sub' $P3756 = "633_1321350766.1143" 
    capture_lex $P3756
    .const 'Sub' $P3752 = "632_1321350766.1143" 
    capture_lex $P3752
    .const 'Sub' $P3748 = "631_1321350766.1143" 
    capture_lex $P3748
    .const 'Sub' $P3744 = "630_1321350766.1143" 
    capture_lex $P3744
    .const 'Sub' $P3739 = "629_1321350766.1143" 
    capture_lex $P3739
    .lex "$?PACKAGE", $P3737
    .lex "$?CLASS", $P3738
.annotate 'line', 2796
    .const 'Sub' $P3765 = "635_1321350766.1143" 
    newclosure $P3771, $P3765
.annotate 'line', 2762
    .return ($P3771)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("629_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3740
    .param pmc param_3741
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2764
    .lex "self", param_3740
    .lex "$/", param_3741
.annotate 'line', 2765
    new $P103, "Undef"
    set $P3742, $P103
    .lex "$past", $P3742
    find_lex $P3743, "$/"
    unless_null $P3743, vivify_3190
    $P3743 = root_new ['parrot';'Hash']
  vivify_3190:
    set $P104, $P3743["statement"]
    unless_null $P104, vivify_3191
    new $P104, "Undef"
  vivify_3191:
    $P105 = $P104."ast"()
    store_lex "$past", $P105
.annotate 'line', 2766
    find_lex $P104, "$/"
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Regex"]
    find_lex $P109, "$past"
    unless_null $P109, vivify_3192
    new $P109, "Undef"
  vivify_3192:
    find_lex $P110, "$/"
    unless_null $P110, vivify_3193
    new $P110, "Undef"
  vivify_3193:
    $P111 = $P108."new"($P109, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P110 :named("node"))
    $P112 = $P104."!make"($P111)
.annotate 'line', 2764
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("630_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3745
    .param pmc param_3746
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2770
    .lex "self", param_3745
    .lex "$/", param_3746
.annotate 'line', 2771
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3747, "$/"
    unless_null $P3747, vivify_3194
    $P3747 = root_new ['parrot';'Hash']
  vivify_3194:
    set $P108, $P3747["codeblock"]
    unless_null $P108, vivify_3195
    new $P108, "Undef"
  vivify_3195:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3196
    new $P110, "Undef"
  vivify_3196:
    $P111 = $P107."new"($P109, "pastnode" :named("pasttype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2770
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("631_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3749
    .param pmc param_3750
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2775
    .lex "self", param_3749
    .lex "$/", param_3750
.annotate 'line', 2776
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3751, "$/"
    unless_null $P3751, vivify_3197
    $P3751 = root_new ['parrot';'Hash']
  vivify_3197:
    set $P108, $P3751["var"]
    unless_null $P108, vivify_3198
    new $P108, "Undef"
  vivify_3198:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3199
    new $P110, "Undef"
  vivify_3199:
    $P111 = $P107."new"("!INTERPOLATE", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2775
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("632_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3753
    .param pmc param_3754
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2780
    .lex "self", param_3753
    .lex "$/", param_3754
.annotate 'line', 2781
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3755, "$/"
    unless_null $P3755, vivify_3200
    $P3755 = root_new ['parrot';'Hash']
  vivify_3200:
    set $P108, $P3755["codeblock"]
    unless_null $P108, vivify_3201
    new $P108, "Undef"
  vivify_3201:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3202
    new $P110, "Undef"
  vivify_3202:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2780
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("633_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3757
    .param pmc param_3758
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2785
    .lex "self", param_3757
    .lex "$/", param_3758
.annotate 'line', 2786
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3759, "$/"
    unless_null $P3759, vivify_3203
    $P3759 = root_new ['parrot';'Hash']
  vivify_3203:
    set $P108, $P3759["codeblock"]
    unless_null $P108, vivify_3204
    new $P108, "Undef"
  vivify_3204:
    $P109 = $P108."ast"()
.annotate 'line', 2787
    find_lex $P3760, "$/"
    unless_null $P3760, vivify_3205
    $P3760 = root_new ['parrot';'Hash']
  vivify_3205:
    set $P110, $P3760["zw"]
    unless_null $P110, vivify_3206
    new $P110, "Undef"
  vivify_3206:
    set $S100, $P110
    iseq $I100, $S100, "!"
.annotate 'line', 2786
    find_lex $P111, "$/"
    unless_null $P111, vivify_3207
    new $P111, "Undef"
  vivify_3207:
    $P112 = $P107."new"($P109, "zerowidth" :named("subtype"), $I100 :named("negate"), "pastnode" :named("pasttype"), $P111 :named("node"))
    $P113 = $P103."!make"($P112)
.annotate 'line', 2785
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("634_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3762
    .param pmc param_3763
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2791
    .lex "self", param_3762
    .lex "$/", param_3763
.annotate 'line', 2792
    find_lex $P103, "$/"
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    find_lex $P3764, "$/"
    unless_null $P3764, vivify_3208
    $P3764 = root_new ['parrot';'Hash']
  vivify_3208:
    set $P108, $P3764["var"]
    unless_null $P108, vivify_3209
    new $P108, "Undef"
  vivify_3209:
    $P109 = $P108."ast"()
    find_lex $P110, "$/"
    unless_null $P110, vivify_3210
    new $P110, "Undef"
  vivify_3210:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2791
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("635_1321350766.1143") :outer("628_1321350766.1143")
    .param pmc param_3766
    .param pmc param_3767
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2796
    .lex "self", param_3766
    .lex "$/", param_3767
.annotate 'line', 2797
    new $P103, "Undef"
    set $P3768, $P103
    .lex "$block", $P3768
.annotate 'line', 2799
    new $P104, "Undef"
    set $P3769, $P104
    .lex "$past", $P3769
.annotate 'line', 2797
    find_lex $P3770, "$/"
    unless_null $P3770, vivify_3211
    $P3770 = root_new ['parrot';'Hash']
  vivify_3211:
    set $P105, $P3770["block"]
    unless_null $P105, vivify_3212
    new $P105, "Undef"
  vivify_3212:
    $P106 = $P105."ast"()
    store_lex "$block", $P106
.annotate 'line', 2798
    find_lex $P105, "$block"
    unless_null $P105, vivify_3213
    new $P105, "Undef"
  vivify_3213:
    $P105."blocktype"("immediate")
.annotate 'line', 2800
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 2801
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 2802
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Var"]
    $P117 = $P116."new"("$/" :named("name"))
.annotate 'line', 2803
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 2804
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Var"]
    $P126 = $P125."new"(unicode:"$\x{a2}" :named("name"))
    $P127 = $P121."new"($P126, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2803
    $P128 = $P112."new"($P117, $P127, "bind_6model" :named("pasttype"))
.annotate 'line', 2801
    find_lex $P129, "$block"
    unless_null $P129, vivify_3214
    new $P129, "Undef"
  vivify_3214:
    $P130 = $P108."new"($P128, $P129)
.annotate 'line', 2800
    store_lex "$past", $P130
.annotate 'line', 2812
    find_lex $P105, "$/"
    find_lex $P106, "$past"
    unless_null $P106, vivify_3215
    new $P106, "Undef"
  vivify_3215:
    $P107 = $P105."!make"($P106)
.annotate 'line', 2796
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block3772"  :subid("636_1321350766.1143") :outer("10_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 2817
    .lex "$?PACKAGE", $P3774
    .lex "$?CLASS", $P3775
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block3778" :load :anon :subid("637_1321350766.1143")
.annotate 'file', "src/stage2/gen/NQP.pm"
.annotate 'line', 1
    .const 'Sub' $P3780 = "10_1321350766.1143" 
    $P110 = $P3780()
    .return ($P110)
.end

