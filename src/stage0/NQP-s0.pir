
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303576195.699")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6181 = "573_1303576195.699" 
    capture_lex $P6181
    .const 'Sub' $P6060 = "564_1303576195.699" 
    capture_lex $P6060
    .const 'Sub' $P2598 = "406_1303576195.699" 
    capture_lex $P2598
    .const 'Sub' $P2494 = "384_1303576195.699" 
    capture_lex $P2494
    .const 'Sub' $P37 = "12_1303576195.699" 
    capture_lex $P37
    .const 'Sub' $P16 = "11_1303576195.699" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2252
    .const 'Sub' $P16 = "11_1303576195.699" 
    newclosure $P35, $P16
    .lex "MAIN", $P35
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P37 = "12_1303576195.699" 
    capture_lex $P37
    $P37()
.annotate 'line', 727
    .const 'Sub' $P2494 = "384_1303576195.699" 
    capture_lex $P2494
    $P2494()
.annotate 'line', 770
    .const 'Sub' $P2598 = "406_1303576195.699" 
    capture_lex $P2598
    $P2598()
.annotate 'line', 2194
    .const 'Sub' $P6060 = "564_1303576195.699" 
    capture_lex $P6060
    $P6060()
.annotate 'line', 2249
    .const 'Sub' $P6181 = "573_1303576195.699" 
    capture_lex $P6181
    $P6181()
    find_lex $P6191, "MAIN"
    find_lex $P6194, "@ARGS"
    if $P6194, if_6193
    set $P6192, $P6194
    goto if_6193_end
  if_6193:
    .const 'Sub' $P6195 = "11_1303576195.699" 
    find_lex $P6196, "@ARGS"
    $P6197 = $P6195($P6196 :flat)
    set $P6192, $P6197
  if_6193_end:
.annotate 'line', 1
    .return ($P6192)
    .const 'Sub' $P6199 = "575_1303576195.699" 
    .return ($P6199)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post576") :outer("10_1303576195.699")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303576195.699" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6203, "1303576184.274"
    isnull $I6204, $P6203
    if $I6204, if_6202
    .const 'Sub' $P6310 = "10_1303576195.699" 
    $P6311 = $P6310."get_lexinfo"()
    nqp_get_sc_object $P6312, "1303576184.274", 0
    $P6311."set_static_lexpad_value"("GLOBALish", $P6312)
    .const 'Sub' $P6313 = "10_1303576195.699" 
    $P6314 = $P6313."get_lexinfo"()
    $P6314."finish_static_lexpad"()
    .const 'Sub' $P6315 = "10_1303576195.699" 
    $P6316 = $P6315."get_lexinfo"()
    nqp_get_sc_object $P6317, "1303576184.274", 0
    $P6316."set_static_lexpad_value"("$?PACKAGE", $P6317)
    .const 'Sub' $P6318 = "10_1303576195.699" 
    $P6319 = $P6318."get_lexinfo"()
    $P6319."finish_static_lexpad"()
    nqp_get_sc_object $P6320, "1303576184.274", 1
    set_hll_global ["NQP"], "Grammar", $P6320
    .const 'Sub' $P6321 = "12_1303576195.699" 
    $P6322 = $P6321."get_lexinfo"()
    nqp_get_sc_object $P6323, "1303576184.274", 1
    $P6322."set_static_lexpad_value"("$?PACKAGE", $P6323)
    .const 'Sub' $P6324 = "12_1303576195.699" 
    $P6325 = $P6324."get_lexinfo"()
    $P6325."finish_static_lexpad"()
    .const 'Sub' $P6326 = "12_1303576195.699" 
    $P6327 = $P6326."get_lexinfo"()
    nqp_get_sc_object $P6328, "1303576184.274", 1
    $P6327."set_static_lexpad_value"("$?CLASS", $P6328)
    .const 'Sub' $P6329 = "12_1303576195.699" 
    $P6330 = $P6329."get_lexinfo"()
    $P6330."finish_static_lexpad"()
    nqp_get_sc_object $P6331, "1303576184.274", 2
    set_hll_global ["NQP"], "Regex", $P6331
    .const 'Sub' $P6332 = "384_1303576195.699" 
    $P6333 = $P6332."get_lexinfo"()
    nqp_get_sc_object $P6334, "1303576184.274", 2
    $P6333."set_static_lexpad_value"("$?PACKAGE", $P6334)
    .const 'Sub' $P6335 = "384_1303576195.699" 
    $P6336 = $P6335."get_lexinfo"()
    $P6336."finish_static_lexpad"()
    .const 'Sub' $P6337 = "384_1303576195.699" 
    $P6338 = $P6337."get_lexinfo"()
    nqp_get_sc_object $P6339, "1303576184.274", 2
    $P6338."set_static_lexpad_value"("$?CLASS", $P6339)
    .const 'Sub' $P6340 = "384_1303576195.699" 
    $P6341 = $P6340."get_lexinfo"()
    $P6341."finish_static_lexpad"()
    nqp_get_sc_object $P6342, "1303576184.274", 3
    set_hll_global ["NQP"], "Actions", $P6342
    .const 'Sub' $P6343 = "406_1303576195.699" 
    $P6344 = $P6343."get_lexinfo"()
    nqp_get_sc_object $P6345, "1303576184.274", 3
    $P6344."set_static_lexpad_value"("$?PACKAGE", $P6345)
    .const 'Sub' $P6346 = "406_1303576195.699" 
    $P6347 = $P6346."get_lexinfo"()
    $P6347."finish_static_lexpad"()
    .const 'Sub' $P6348 = "406_1303576195.699" 
    $P6349 = $P6348."get_lexinfo"()
    nqp_get_sc_object $P6350, "1303576184.274", 3
    $P6349."set_static_lexpad_value"("$?CLASS", $P6350)
    .const 'Sub' $P6351 = "406_1303576195.699" 
    $P6352 = $P6351."get_lexinfo"()
    $P6352."finish_static_lexpad"()
    nqp_get_sc_object $P6353, "1303576184.274", 4
    set_hll_global ["NQP"], "RegexActions", $P6353
    .const 'Sub' $P6354 = "564_1303576195.699" 
    $P6355 = $P6354."get_lexinfo"()
    nqp_get_sc_object $P6356, "1303576184.274", 4
    $P6355."set_static_lexpad_value"("$?PACKAGE", $P6356)
    .const 'Sub' $P6357 = "564_1303576195.699" 
    $P6358 = $P6357."get_lexinfo"()
    $P6358."finish_static_lexpad"()
    .const 'Sub' $P6359 = "564_1303576195.699" 
    $P6360 = $P6359."get_lexinfo"()
    nqp_get_sc_object $P6361, "1303576184.274", 4
    $P6360."set_static_lexpad_value"("$?CLASS", $P6361)
    .const 'Sub' $P6362 = "564_1303576195.699" 
    $P6363 = $P6362."get_lexinfo"()
    $P6363."finish_static_lexpad"()
    nqp_get_sc_object $P6364, "1303576184.274", 5
    set_hll_global ["NQP"], "Compiler", $P6364
    .const 'Sub' $P6365 = "573_1303576195.699" 
    $P6366 = $P6365."get_lexinfo"()
    nqp_get_sc_object $P6367, "1303576184.274", 5
    $P6366."set_static_lexpad_value"("$?PACKAGE", $P6367)
    .const 'Sub' $P6368 = "573_1303576195.699" 
    $P6369 = $P6368."get_lexinfo"()
    $P6369."finish_static_lexpad"()
    .const 'Sub' $P6370 = "573_1303576195.699" 
    $P6371 = $P6370."get_lexinfo"()
    nqp_get_sc_object $P6372, "1303576184.274", 5
    $P6371."set_static_lexpad_value"("$?CLASS", $P6372)
    .const 'Sub' $P6373 = "573_1303576195.699" 
    $P6374 = $P6373."get_lexinfo"()
    $P6374."finish_static_lexpad"()
    goto if_6202_end
  if_6202:
    nqp_dynop_setup 
    getinterp $P6205
    get_class $P6206, "LexPad"
    get_class $P6207, "NQPLexPad"
    $P6205."hll_map"($P6206, $P6207)
    nqp_create_sc $P6208, "1303576184.274"
    .local pmc cur_sc
    set cur_sc, $P6208
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6209, "ModuleLoader"
    $P6210 = $P6209."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6210)
    get_hll_global $P6211, "KnowHOW"
    $P6212 = $P6211."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6212, cur_sc
    nqp_set_sc_object "1303576184.274", 0, $P6212
    .const 'Sub' $P6213 = "10_1303576195.699" 
    $P6214 = $P6213."get_lexinfo"()
    nqp_get_sc_object $P6215, "1303576184.274", 0
    $P6214."set_static_lexpad_value"("GLOBALish", $P6215)
    .const 'Sub' $P6216 = "10_1303576195.699" 
    $P6217 = $P6216."get_lexinfo"()
    $P6217."finish_static_lexpad"()
    .const 'Sub' $P6218 = "10_1303576195.699" 
    $P6219 = $P6218."get_lexinfo"()
    nqp_get_sc_object $P6220, "1303576184.274", 0
    $P6219."set_static_lexpad_value"("$?PACKAGE", $P6220)
    .const 'Sub' $P6221 = "10_1303576195.699" 
    $P6222 = $P6221."get_lexinfo"()
    $P6222."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6223, "ModuleLoader"
    nqp_get_sc_object $P6224, "1303576184.274", 0
    $P6223."load_module"("P6Regex", $P6224)
    get_hll_global $P6225, "NQPClassHOW"
    $P6226 = $P6225."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6226, cur_sc
    nqp_set_sc_object "1303576184.274", 1, $P6226
    nqp_get_sc_object $P6227, "1303576184.274", 1
    nqp_get_sc_object $P6228, "1303576184.274", 0
    nqp_get_package_through_who $P6229, $P6228, "NQP"
    get_who $P6230, $P6229
    set $P6230["Grammar"], $P6227
    nqp_get_sc_object $P6231, "1303576184.274", 1
    set_hll_global ["NQP"], "Grammar", $P6231
    .const 'Sub' $P6232 = "12_1303576195.699" 
    $P6233 = $P6232."get_lexinfo"()
    nqp_get_sc_object $P6234, "1303576184.274", 1
    $P6233."set_static_lexpad_value"("$?PACKAGE", $P6234)
    .const 'Sub' $P6235 = "12_1303576195.699" 
    $P6236 = $P6235."get_lexinfo"()
    $P6236."finish_static_lexpad"()
    .const 'Sub' $P6237 = "12_1303576195.699" 
    $P6238 = $P6237."get_lexinfo"()
    nqp_get_sc_object $P6239, "1303576184.274", 1
    $P6238."set_static_lexpad_value"("$?CLASS", $P6239)
    .const 'Sub' $P6240 = "12_1303576195.699" 
    $P6241 = $P6240."get_lexinfo"()
    $P6241."finish_static_lexpad"()
    get_hll_global $P6242, "NQPClassHOW"
    $P6243 = $P6242."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P6243, cur_sc
    nqp_set_sc_object "1303576184.274", 2, $P6243
    nqp_get_sc_object $P6244, "1303576184.274", 2
    nqp_get_sc_object $P6245, "1303576184.274", 0
    nqp_get_package_through_who $P6246, $P6245, "NQP"
    get_who $P6247, $P6246
    set $P6247["Regex"], $P6244
    nqp_get_sc_object $P6248, "1303576184.274", 2
    set_hll_global ["NQP"], "Regex", $P6248
    .const 'Sub' $P6249 = "384_1303576195.699" 
    $P6250 = $P6249."get_lexinfo"()
    nqp_get_sc_object $P6251, "1303576184.274", 2
    $P6250."set_static_lexpad_value"("$?PACKAGE", $P6251)
    .const 'Sub' $P6252 = "384_1303576195.699" 
    $P6253 = $P6252."get_lexinfo"()
    $P6253."finish_static_lexpad"()
    .const 'Sub' $P6254 = "384_1303576195.699" 
    $P6255 = $P6254."get_lexinfo"()
    nqp_get_sc_object $P6256, "1303576184.274", 2
    $P6255."set_static_lexpad_value"("$?CLASS", $P6256)
    .const 'Sub' $P6257 = "384_1303576195.699" 
    $P6258 = $P6257."get_lexinfo"()
    $P6258."finish_static_lexpad"()
    get_hll_global $P6259, "NQPClassHOW"
    $P6260 = $P6259."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P6260, cur_sc
    nqp_set_sc_object "1303576184.274", 3, $P6260
    nqp_get_sc_object $P6261, "1303576184.274", 3
    nqp_get_sc_object $P6262, "1303576184.274", 0
    nqp_get_package_through_who $P6263, $P6262, "NQP"
    get_who $P6264, $P6263
    set $P6264["Actions"], $P6261
    nqp_get_sc_object $P6265, "1303576184.274", 3
    set_hll_global ["NQP"], "Actions", $P6265
    .const 'Sub' $P6266 = "406_1303576195.699" 
    $P6267 = $P6266."get_lexinfo"()
    nqp_get_sc_object $P6268, "1303576184.274", 3
    $P6267."set_static_lexpad_value"("$?PACKAGE", $P6268)
    .const 'Sub' $P6269 = "406_1303576195.699" 
    $P6270 = $P6269."get_lexinfo"()
    $P6270."finish_static_lexpad"()
    .const 'Sub' $P6271 = "406_1303576195.699" 
    $P6272 = $P6271."get_lexinfo"()
    nqp_get_sc_object $P6273, "1303576184.274", 3
    $P6272."set_static_lexpad_value"("$?CLASS", $P6273)
    .const 'Sub' $P6274 = "406_1303576195.699" 
    $P6275 = $P6274."get_lexinfo"()
    $P6275."finish_static_lexpad"()
    get_hll_global $P6276, "NQPClassHOW"
    $P6277 = $P6276."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P6277, cur_sc
    nqp_set_sc_object "1303576184.274", 4, $P6277
    nqp_get_sc_object $P6278, "1303576184.274", 4
    nqp_get_sc_object $P6279, "1303576184.274", 0
    nqp_get_package_through_who $P6280, $P6279, "NQP"
    get_who $P6281, $P6280
    set $P6281["RegexActions"], $P6278
    nqp_get_sc_object $P6282, "1303576184.274", 4
    set_hll_global ["NQP"], "RegexActions", $P6282
    .const 'Sub' $P6283 = "564_1303576195.699" 
    $P6284 = $P6283."get_lexinfo"()
    nqp_get_sc_object $P6285, "1303576184.274", 4
    $P6284."set_static_lexpad_value"("$?PACKAGE", $P6285)
    .const 'Sub' $P6286 = "564_1303576195.699" 
    $P6287 = $P6286."get_lexinfo"()
    $P6287."finish_static_lexpad"()
    .const 'Sub' $P6288 = "564_1303576195.699" 
    $P6289 = $P6288."get_lexinfo"()
    nqp_get_sc_object $P6290, "1303576184.274", 4
    $P6289."set_static_lexpad_value"("$?CLASS", $P6290)
    .const 'Sub' $P6291 = "564_1303576195.699" 
    $P6292 = $P6291."get_lexinfo"()
    $P6292."finish_static_lexpad"()
    get_hll_global $P6293, "NQPClassHOW"
    $P6294 = $P6293."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P6294, cur_sc
    nqp_set_sc_object "1303576184.274", 5, $P6294
    nqp_get_sc_object $P6295, "1303576184.274", 5
    nqp_get_sc_object $P6296, "1303576184.274", 0
    nqp_get_package_through_who $P6297, $P6296, "NQP"
    get_who $P6298, $P6297
    set $P6298["Compiler"], $P6295
    nqp_get_sc_object $P6299, "1303576184.274", 5
    set_hll_global ["NQP"], "Compiler", $P6299
    .const 'Sub' $P6300 = "573_1303576195.699" 
    $P6301 = $P6300."get_lexinfo"()
    nqp_get_sc_object $P6302, "1303576184.274", 5
    $P6301."set_static_lexpad_value"("$?PACKAGE", $P6302)
    .const 'Sub' $P6303 = "573_1303576195.699" 
    $P6304 = $P6303."get_lexinfo"()
    $P6304."finish_static_lexpad"()
    .const 'Sub' $P6305 = "573_1303576195.699" 
    $P6306 = $P6305."get_lexinfo"()
    nqp_get_sc_object $P6307, "1303576184.274", 5
    $P6306."set_static_lexpad_value"("$?CLASS", $P6307)
    .const 'Sub' $P6308 = "573_1303576195.699" 
    $P6309 = $P6308."get_lexinfo"()
    $P6309."finish_static_lexpad"()
  if_6202_end:
    nqp_get_sc_object $P6375, "1303576184.274", 0
    set_hll_global "GLOBAL", $P6375
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303576195.699") :outer("10_1303576195.699")
    .param pmc param_17
.annotate 'line', 2252
    .lex "@ARGS", param_17
.annotate 'line', 2254
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2260
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2254
    get_hll_global $P20, ["NQP"], "Compiler"
    $P21 = $P20."new"()
    store_lex "$nqpcomp", $P21
.annotate 'line', 2255
    find_lex $P22, "$nqpcomp"
    unless_null $P22, vivify_577
    new $P22, "Undef"
  vivify_577:
    $P22."language"("nqp")
.annotate 'line', 2256
    find_lex $P23, "$nqpcomp"
    unless_null $P23, vivify_578
    new $P23, "Undef"
  vivify_578:
    get_hll_global $P24, ["NQP"], "Grammar"
    $P23."parsegrammar"($P24)
.annotate 'line', 2257
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_579
    new $P25, "Undef"
  vivify_579:
    get_hll_global $P26, ["NQP"], "Actions"
    $P25."parseactions"($P26)
.annotate 'line', 2260
    find_lex $P27, "$nqpcomp"
    unless_null $P27, vivify_580
    new $P27, "Undef"
  vivify_580:
    $P28 = $P27."commandline_options"()
    store_lex "@clo", $P28
.annotate 'line', 2261
    find_lex $P29, "@clo"
    unless_null $P29, vivify_581
    $P29 = root_new ['parrot';'ResizablePMCArray']
  vivify_581:
    $P29."push"("parsetrace")
.annotate 'line', 2262
    find_lex $P30, "@clo"
    unless_null $P30, vivify_582
    $P30 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    $P30."push"("setting=s")
.annotate 'line', 2263
    find_lex $P31, "@clo"
    unless_null $P31, vivify_583
    $P31 = root_new ['parrot';'ResizablePMCArray']
  vivify_583:
    $P31."push"("setting-path=s")
.annotate 'line', 2266
    find_lex $P32, "$nqpcomp"
    unless_null $P32, vivify_584
    new $P32, "Undef"
  vivify_584:
    find_lex $P33, "@ARGS"
    unless_null $P33, vivify_585
    $P33 = root_new ['parrot';'ResizablePMCArray']
  vivify_585:
    $P34 = $P32."command_line"($P33, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2252
    .return ($P34)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block36"  :subid("12_1303576195.699") :outer("10_1303576195.699")
.annotate 'line', 9
    .const 'Sub' $P1771 = "383_1303576195.699" 
    capture_lex $P1771
    .const 'Sub' $P1758 = "382_1303576195.699" 
    capture_lex $P1758
    .const 'Sub' $P1752 = "380_1303576195.699" 
    capture_lex $P1752
    .const 'Sub' $P1746 = "378_1303576195.699" 
    capture_lex $P1746
    .const 'Sub' $P1740 = "376_1303576195.699" 
    capture_lex $P1740
    .const 'Sub' $P1734 = "374_1303576195.699" 
    capture_lex $P1734
    .const 'Sub' $P1722 = "371_1303576195.699" 
    capture_lex $P1722
    .const 'Sub' $P1715 = "369_1303576195.699" 
    capture_lex $P1715
    .const 'Sub' $P1708 = "367_1303576195.699" 
    capture_lex $P1708
    .const 'Sub' $P1701 = "365_1303576195.699" 
    capture_lex $P1701
    .const 'Sub' $P1694 = "363_1303576195.699" 
    capture_lex $P1694
    .const 'Sub' $P1688 = "361_1303576195.699" 
    capture_lex $P1688
    .const 'Sub' $P1681 = "359_1303576195.699" 
    capture_lex $P1681
    .const 'Sub' $P1674 = "357_1303576195.699" 
    capture_lex $P1674
    .const 'Sub' $P1667 = "355_1303576195.699" 
    capture_lex $P1667
    .const 'Sub' $P1660 = "353_1303576195.699" 
    capture_lex $P1660
    .const 'Sub' $P1653 = "351_1303576195.699" 
    capture_lex $P1653
    .const 'Sub' $P1646 = "349_1303576195.699" 
    capture_lex $P1646
    .const 'Sub' $P1639 = "347_1303576195.699" 
    capture_lex $P1639
    .const 'Sub' $P1632 = "345_1303576195.699" 
    capture_lex $P1632
    .const 'Sub' $P1625 = "343_1303576195.699" 
    capture_lex $P1625
    .const 'Sub' $P1618 = "341_1303576195.699" 
    capture_lex $P1618
    .const 'Sub' $P1611 = "339_1303576195.699" 
    capture_lex $P1611
    .const 'Sub' $P1604 = "337_1303576195.699" 
    capture_lex $P1604
    .const 'Sub' $P1597 = "335_1303576195.699" 
    capture_lex $P1597
    .const 'Sub' $P1590 = "333_1303576195.699" 
    capture_lex $P1590
    .const 'Sub' $P1583 = "331_1303576195.699" 
    capture_lex $P1583
    .const 'Sub' $P1576 = "329_1303576195.699" 
    capture_lex $P1576
    .const 'Sub' $P1569 = "327_1303576195.699" 
    capture_lex $P1569
    .const 'Sub' $P1562 = "325_1303576195.699" 
    capture_lex $P1562
    .const 'Sub' $P1555 = "323_1303576195.699" 
    capture_lex $P1555
    .const 'Sub' $P1548 = "321_1303576195.699" 
    capture_lex $P1548
    .const 'Sub' $P1541 = "319_1303576195.699" 
    capture_lex $P1541
    .const 'Sub' $P1534 = "317_1303576195.699" 
    capture_lex $P1534
    .const 'Sub' $P1527 = "315_1303576195.699" 
    capture_lex $P1527
    .const 'Sub' $P1520 = "313_1303576195.699" 
    capture_lex $P1520
    .const 'Sub' $P1513 = "311_1303576195.699" 
    capture_lex $P1513
    .const 'Sub' $P1506 = "309_1303576195.699" 
    capture_lex $P1506
    .const 'Sub' $P1499 = "307_1303576195.699" 
    capture_lex $P1499
    .const 'Sub' $P1492 = "305_1303576195.699" 
    capture_lex $P1492
    .const 'Sub' $P1485 = "303_1303576195.699" 
    capture_lex $P1485
    .const 'Sub' $P1479 = "301_1303576195.699" 
    capture_lex $P1479
    .const 'Sub' $P1472 = "299_1303576195.699" 
    capture_lex $P1472
    .const 'Sub' $P1465 = "297_1303576195.699" 
    capture_lex $P1465
    .const 'Sub' $P1458 = "295_1303576195.699" 
    capture_lex $P1458
    .const 'Sub' $P1451 = "293_1303576195.699" 
    capture_lex $P1451
    .const 'Sub' $P1444 = "291_1303576195.699" 
    capture_lex $P1444
    .const 'Sub' $P1437 = "289_1303576195.699" 
    capture_lex $P1437
    .const 'Sub' $P1430 = "287_1303576195.699" 
    capture_lex $P1430
    .const 'Sub' $P1424 = "285_1303576195.699" 
    capture_lex $P1424
    .const 'Sub' $P1418 = "283_1303576195.699" 
    capture_lex $P1418
    .const 'Sub' $P1413 = "281_1303576195.699" 
    capture_lex $P1413
    .const 'Sub' $P1407 = "279_1303576195.699" 
    capture_lex $P1407
    .const 'Sub' $P1401 = "277_1303576195.699" 
    capture_lex $P1401
    .const 'Sub' $P1396 = "275_1303576195.699" 
    capture_lex $P1396
    .const 'Sub' $P1391 = "273_1303576195.699" 
    capture_lex $P1391
    .const 'Sub' $P1383 = "271_1303576195.699" 
    capture_lex $P1383
    .const 'Sub' $P1374 = "269_1303576195.699" 
    capture_lex $P1374
    .const 'Sub' $P1369 = "267_1303576195.699" 
    capture_lex $P1369
    .const 'Sub' $P1364 = "265_1303576195.699" 
    capture_lex $P1364
    .const 'Sub' $P1359 = "263_1303576195.699" 
    capture_lex $P1359
    .const 'Sub' $P1351 = "261_1303576195.699" 
    capture_lex $P1351
    .const 'Sub' $P1343 = "259_1303576195.699" 
    capture_lex $P1343
    .const 'Sub' $P1338 = "257_1303576195.699" 
    capture_lex $P1338
    .const 'Sub' $P1333 = "255_1303576195.699" 
    capture_lex $P1333
    .const 'Sub' $P1328 = "253_1303576195.699" 
    capture_lex $P1328
    .const 'Sub' $P1322 = "251_1303576195.699" 
    capture_lex $P1322
    .const 'Sub' $P1315 = "249_1303576195.699" 
    capture_lex $P1315
    .const 'Sub' $P1308 = "247_1303576195.699" 
    capture_lex $P1308
    .const 'Sub' $P1301 = "245_1303576195.699" 
    capture_lex $P1301
    .const 'Sub' $P1294 = "243_1303576195.699" 
    capture_lex $P1294
    .const 'Sub' $P1289 = "241_1303576195.699" 
    capture_lex $P1289
    .const 'Sub' $P1284 = "239_1303576195.699" 
    capture_lex $P1284
    .const 'Sub' $P1270 = "235_1303576195.699" 
    capture_lex $P1270
    .const 'Sub' $P1262 = "233_1303576195.699" 
    capture_lex $P1262
    .const 'Sub' $P1256 = "231_1303576195.699" 
    capture_lex $P1256
    .const 'Sub' $P1249 = "229_1303576195.699" 
    capture_lex $P1249
    .const 'Sub' $P1243 = "227_1303576195.699" 
    capture_lex $P1243
    .const 'Sub' $P1229 = "224_1303576195.699" 
    capture_lex $P1229
    .const 'Sub' $P1221 = "222_1303576195.699" 
    capture_lex $P1221
    .const 'Sub' $P1213 = "220_1303576195.699" 
    capture_lex $P1213
    .const 'Sub' $P1207 = "218_1303576195.699" 
    capture_lex $P1207
    .const 'Sub' $P1201 = "216_1303576195.699" 
    capture_lex $P1201
    .const 'Sub' $P1185 = "212_1303576195.699" 
    capture_lex $P1185
    .const 'Sub' $P1144 = "210_1303576195.699" 
    capture_lex $P1144
    .const 'Sub' $P1133 = "208_1303576195.699" 
    capture_lex $P1133
    .const 'Sub' $P1119 = "204_1303576195.699" 
    capture_lex $P1119
    .const 'Sub' $P1110 = "202_1303576195.699" 
    capture_lex $P1110
    .const 'Sub' $P1104 = "200_1303576195.699" 
    capture_lex $P1104
    .const 'Sub' $P1094 = "198_1303576195.699" 
    capture_lex $P1094
    .const 'Sub' $P1079 = "196_1303576195.699" 
    capture_lex $P1079
    .const 'Sub' $P1065 = "193_1303576195.699" 
    capture_lex $P1065
    .const 'Sub' $P1057 = "191_1303576195.699" 
    capture_lex $P1057
    .const 'Sub' $P1047 = "189_1303576195.699" 
    capture_lex $P1047
    .const 'Sub' $P1037 = "187_1303576195.699" 
    capture_lex $P1037
    .const 'Sub' $P1018 = "182_1303576195.699" 
    capture_lex $P1018
    .const 'Sub' $P974 = "179_1303576195.699" 
    capture_lex $P974
    .const 'Sub' $P940 = "177_1303576195.699" 
    capture_lex $P940
    .const 'Sub' $P933 = "175_1303576195.699" 
    capture_lex $P933
    .const 'Sub' $P926 = "173_1303576195.699" 
    capture_lex $P926
    .const 'Sub' $P909 = "169_1303576195.699" 
    capture_lex $P909
    .const 'Sub' $P901 = "167_1303576195.699" 
    capture_lex $P901
    .const 'Sub' $P895 = "165_1303576195.699" 
    capture_lex $P895
    .const 'Sub' $P879 = "163_1303576195.699" 
    capture_lex $P879
    .const 'Sub' $P872 = "161_1303576195.699" 
    capture_lex $P872
    .const 'Sub' $P865 = "159_1303576195.699" 
    capture_lex $P865
    .const 'Sub' $P858 = "157_1303576195.699" 
    capture_lex $P858
    .const 'Sub' $P716 = "152_1303576195.699" 
    capture_lex $P716
    .const 'Sub' $P702 = "150_1303576195.699" 
    capture_lex $P702
    .const 'Sub' $P688 = "148_1303576195.699" 
    capture_lex $P688
    .const 'Sub' $P674 = "146_1303576195.699" 
    capture_lex $P674
    .const 'Sub' $P660 = "144_1303576195.699" 
    capture_lex $P660
    .const 'Sub' $P646 = "142_1303576195.699" 
    capture_lex $P646
    .const 'Sub' $P632 = "140_1303576195.699" 
    capture_lex $P632
    .const 'Sub' $P621 = "136_1303576195.699" 
    capture_lex $P621
    .const 'Sub' $P616 = "134_1303576195.699" 
    capture_lex $P616
    .const 'Sub' $P604 = "132_1303576195.699" 
    capture_lex $P604
    .const 'Sub' $P592 = "130_1303576195.699" 
    capture_lex $P592
    .const 'Sub' $P585 = "128_1303576195.699" 
    capture_lex $P585
    .const 'Sub' $P580 = "126_1303576195.699" 
    capture_lex $P580
    .const 'Sub' $P574 = "124_1303576195.699" 
    capture_lex $P574
    .const 'Sub' $P568 = "122_1303576195.699" 
    capture_lex $P568
    .const 'Sub' $P553 = "118_1303576195.699" 
    capture_lex $P553
    .const 'Sub' $P547 = "116_1303576195.699" 
    capture_lex $P547
    .const 'Sub' $P541 = "114_1303576195.699" 
    capture_lex $P541
    .const 'Sub' $P535 = "112_1303576195.699" 
    capture_lex $P535
    .const 'Sub' $P529 = "110_1303576195.699" 
    capture_lex $P529
    .const 'Sub' $P523 = "108_1303576195.699" 
    capture_lex $P523
    .const 'Sub' $P517 = "106_1303576195.699" 
    capture_lex $P517
    .const 'Sub' $P508 = "104_1303576195.699" 
    capture_lex $P508
    .const 'Sub' $P499 = "102_1303576195.699" 
    capture_lex $P499
    .const 'Sub' $P490 = "100_1303576195.699" 
    capture_lex $P490
    .const 'Sub' $P475 = "96_1303576195.699" 
    capture_lex $P475
    .const 'Sub' $P466 = "94_1303576195.699" 
    capture_lex $P466
    .const 'Sub' $P454 = "90_1303576195.699" 
    capture_lex $P454
    .const 'Sub' $P447 = "88_1303576195.699" 
    capture_lex $P447
    .const 'Sub' $P440 = "86_1303576195.699" 
    capture_lex $P440
    .const 'Sub' $P426 = "82_1303576195.699" 
    capture_lex $P426
    .const 'Sub' $P418 = "80_1303576195.699" 
    capture_lex $P418
    .const 'Sub' $P410 = "78_1303576195.699" 
    capture_lex $P410
    .const 'Sub' $P390 = "76_1303576195.699" 
    capture_lex $P390
    .const 'Sub' $P381 = "74_1303576195.699" 
    capture_lex $P381
    .const 'Sub' $P363 = "71_1303576195.699" 
    capture_lex $P363
    .const 'Sub' $P345 = "69_1303576195.699" 
    capture_lex $P345
    .const 'Sub' $P337 = "67_1303576195.699" 
    capture_lex $P337
    .const 'Sub' $P326 = "63_1303576195.699" 
    capture_lex $P326
    .const 'Sub' $P321 = "61_1303576195.699" 
    capture_lex $P321
    .const 'Sub' $P310 = "57_1303576195.699" 
    capture_lex $P310
    .const 'Sub' $P305 = "55_1303576195.699" 
    capture_lex $P305
    .const 'Sub' $P300 = "53_1303576195.699" 
    capture_lex $P300
    .const 'Sub' $P295 = "51_1303576195.699" 
    capture_lex $P295
    .const 'Sub' $P290 = "49_1303576195.699" 
    capture_lex $P290
    .const 'Sub' $P280 = "47_1303576195.699" 
    capture_lex $P280
    .const 'Sub' $P273 = "45_1303576195.699" 
    capture_lex $P273
    .const 'Sub' $P267 = "43_1303576195.699" 
    capture_lex $P267
    .const 'Sub' $P259 = "41_1303576195.699" 
    capture_lex $P259
    .const 'Sub' $P253 = "39_1303576195.699" 
    capture_lex $P253
    .const 'Sub' $P247 = "37_1303576195.699" 
    capture_lex $P247
    .const 'Sub' $P232 = "34_1303576195.699" 
    capture_lex $P232
    .const 'Sub' $P218 = "32_1303576195.699" 
    capture_lex $P218
    .const 'Sub' $P203 = "30_1303576195.699" 
    capture_lex $P203
    .const 'Sub' $P164 = "27_1303576195.699" 
    capture_lex $P164
    .const 'Sub' $P149 = "24_1303576195.699" 
    capture_lex $P149
    .const 'Sub' $P138 = "22_1303576195.699" 
    capture_lex $P138
    .const 'Sub' $P126 = "20_1303576195.699" 
    capture_lex $P126
    .const 'Sub' $P118 = "18_1303576195.699" 
    capture_lex $P118
    .const 'Sub' $P111 = "16_1303576195.699" 
    capture_lex $P111
    .const 'Sub' $P104 = "14_1303576195.699" 
    capture_lex $P104
    .const 'Sub' $P55 = "13_1303576195.699" 
    capture_lex $P55
    .lex "$?PACKAGE", $P38
    .lex "$?CLASS", $P39
.annotate 'line', 608
    get_hll_global $P40, ["NQP"], "Grammar"
    $P40."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 609
    get_hll_global $P41, ["NQP"], "Grammar"
    $P41."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 610
    get_hll_global $P42, ["NQP"], "Grammar"
    $P42."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 611
    get_hll_global $P43, ["NQP"], "Grammar"
    $P43."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 612
    get_hll_global $P44, ["NQP"], "Grammar"
    $P44."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 613
    get_hll_global $P45, ["NQP"], "Grammar"
    $P45."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 614
    get_hll_global $P46, ["NQP"], "Grammar"
    $P46."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 615
    get_hll_global $P47, ["NQP"], "Grammar"
    $P47."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 616
    get_hll_global $P48, ["NQP"], "Grammar"
    $P48."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 617
    get_hll_global $P49, ["NQP"], "Grammar"
    $P49."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 618
    get_hll_global $P50, ["NQP"], "Grammar"
    $P50."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 619
    get_hll_global $P51, ["NQP"], "Grammar"
    $P51."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 620
    get_hll_global $P52, ["NQP"], "Grammar"
    $P52."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 621
    get_hll_global $P53, ["NQP"], "Grammar"
    $P53."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 622
    get_hll_global $P54, ["NQP"], "Grammar"
    $P54."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 721
    .const 'Sub' $P1758 = "382_1303576195.699" 
    newclosure $P1769, $P1758
.annotate 'line', 9
    .return ($P1769)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post586") :outer("12_1303576195.699")
.annotate 'line', 9
    .const 'Sub' $P37 = "12_1303576195.699" 
    .local pmc block
    set block, $P37
    .const 'Sub' $P1771 = "383_1303576195.699" 
    capture_lex $P1771
    $P1771()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1770"  :anon :subid("383_1303576195.699") :outer("12_1303576195.699")
.annotate 'line', 9
    nqp_get_sc_object $P1772, "1303576184.274", 1
    .local pmc type_obj
    set type_obj, $P1772
    get_how $P1773, type_obj
    .const 'Sub' $P1774 = "13_1303576195.699" 
    $P1773."add_method"(type_obj, "TOP", $P1774)
    get_how $P1775, type_obj
    .const 'Sub' $P1776 = "14_1303576195.699" 
    $P1775."add_method"(type_obj, "identifier", $P1776)
    get_how $P1777, type_obj
    get_global $P1778, "!PREFIX__identifier"
    $P1777."add_method"(type_obj, "!PREFIX__identifier", $P1778)
    get_how $P1779, type_obj
    .const 'Sub' $P1780 = "16_1303576195.699" 
    $P1779."add_method"(type_obj, "name", $P1780)
    get_how $P1781, type_obj
    get_global $P1782, "!PREFIX__name"
    $P1781."add_method"(type_obj, "!PREFIX__name", $P1782)
    get_how $P1783, type_obj
    .const 'Sub' $P1784 = "18_1303576195.699" 
    $P1783."add_method"(type_obj, "deflongname", $P1784)
    get_how $P1785, type_obj
    get_global $P1786, "!PREFIX__deflongname"
    $P1785."add_method"(type_obj, "!PREFIX__deflongname", $P1786)
    get_how $P1787, type_obj
    .const 'Sub' $P1788 = "20_1303576195.699" 
    $P1787."add_method"(type_obj, "ENDSTMT", $P1788)
    get_how $P1789, type_obj
    get_global $P1790, "!PREFIX__ENDSTMT"
    $P1789."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1790)
    get_how $P1791, type_obj
    .const 'Sub' $P1792 = "22_1303576195.699" 
    $P1791."add_method"(type_obj, "ws", $P1792)
    get_how $P1793, type_obj
    get_global $P1794, "!PREFIX__ws"
    $P1793."add_method"(type_obj, "!PREFIX__ws", $P1794)
    get_how $P1795, type_obj
    .const 'Sub' $P1796 = "24_1303576195.699" 
    $P1795."add_method"(type_obj, "unv", $P1796)
    get_how $P1797, type_obj
    get_global $P1798, "!PREFIX__unv"
    $P1797."add_method"(type_obj, "!PREFIX__unv", $P1798)
    get_how $P1799, type_obj
    .const 'Sub' $P1800 = "27_1303576195.699" 
    $P1799."add_method"(type_obj, "pod_comment", $P1800)
    get_how $P1801, type_obj
    get_global $P1802, "!PREFIX__pod_comment"
    $P1801."add_method"(type_obj, "!PREFIX__pod_comment", $P1802)
    get_how $P1803, type_obj
    .const 'Sub' $P1804 = "30_1303576195.699" 
    $P1803."add_method"(type_obj, "comp_unit", $P1804)
    get_how $P1805, type_obj
    get_global $P1806, "!PREFIX__comp_unit"
    $P1805."add_method"(type_obj, "!PREFIX__comp_unit", $P1806)
    get_how $P1807, type_obj
    .const 'Sub' $P1808 = "32_1303576195.699" 
    $P1807."add_method"(type_obj, "statementlist", $P1808)
    get_how $P1809, type_obj
    get_global $P1810, "!PREFIX__statementlist"
    $P1809."add_method"(type_obj, "!PREFIX__statementlist", $P1810)
    get_how $P1811, type_obj
    .const 'Sub' $P1812 = "34_1303576195.699" 
    $P1811."add_method"(type_obj, "statement", $P1812)
    get_how $P1813, type_obj
    get_global $P1814, "!PREFIX__statement"
    $P1813."add_method"(type_obj, "!PREFIX__statement", $P1814)
    get_how $P1815, type_obj
    .const 'Sub' $P1816 = "37_1303576195.699" 
    $P1815."add_method"(type_obj, "eat_terminator", $P1816)
    get_how $P1817, type_obj
    get_global $P1818, "!PREFIX__eat_terminator"
    $P1817."add_method"(type_obj, "!PREFIX__eat_terminator", $P1818)
    get_how $P1819, type_obj
    .const 'Sub' $P1820 = "39_1303576195.699" 
    $P1819."add_method"(type_obj, "xblock", $P1820)
    get_how $P1821, type_obj
    get_global $P1822, "!PREFIX__xblock"
    $P1821."add_method"(type_obj, "!PREFIX__xblock", $P1822)
    get_how $P1823, type_obj
    .const 'Sub' $P1824 = "41_1303576195.699" 
    $P1823."add_method"(type_obj, "pblock", $P1824)
    get_how $P1825, type_obj
    get_global $P1826, "!PREFIX__pblock"
    $P1825."add_method"(type_obj, "!PREFIX__pblock", $P1826)
    get_how $P1827, type_obj
    .const 'Sub' $P1828 = "43_1303576195.699" 
    $P1827."add_method"(type_obj, "lambda", $P1828)
    get_how $P1829, type_obj
    get_global $P1830, "!PREFIX__lambda"
    $P1829."add_method"(type_obj, "!PREFIX__lambda", $P1830)
    get_how $P1831, type_obj
    .const 'Sub' $P1832 = "45_1303576195.699" 
    $P1831."add_method"(type_obj, "block", $P1832)
    get_how $P1833, type_obj
    get_global $P1834, "!PREFIX__block"
    $P1833."add_method"(type_obj, "!PREFIX__block", $P1834)
    get_how $P1835, type_obj
    .const 'Sub' $P1836 = "47_1303576195.699" 
    $P1835."add_method"(type_obj, "blockoid", $P1836)
    get_how $P1837, type_obj
    get_global $P1838, "!PREFIX__blockoid"
    $P1837."add_method"(type_obj, "!PREFIX__blockoid", $P1838)
    get_how $P1839, type_obj
    .const 'Sub' $P1840 = "49_1303576195.699" 
    $P1839."add_method"(type_obj, "newpad", $P1840)
    get_how $P1841, type_obj
    get_global $P1842, "!PREFIX__newpad"
    $P1841."add_method"(type_obj, "!PREFIX__newpad", $P1842)
    get_how $P1843, type_obj
    .const 'Sub' $P1844 = "51_1303576195.699" 
    $P1843."add_method"(type_obj, "outerctx", $P1844)
    get_how $P1845, type_obj
    get_global $P1846, "!PREFIX__outerctx"
    $P1845."add_method"(type_obj, "!PREFIX__outerctx", $P1846)
    get_how $P1847, type_obj
    .const 'Sub' $P1848 = "53_1303576195.699" 
    $P1847."add_method"(type_obj, "GLOBALish", $P1848)
    get_how $P1849, type_obj
    get_global $P1850, "!PREFIX__GLOBALish"
    $P1849."add_method"(type_obj, "!PREFIX__GLOBALish", $P1850)
    get_how $P1851, type_obj
    .const 'Sub' $P1852 = "55_1303576195.699" 
    $P1851."add_method"(type_obj, "finishpad", $P1852)
    get_how $P1853, type_obj
    get_global $P1854, "!PREFIX__finishpad"
    $P1853."add_method"(type_obj, "!PREFIX__finishpad", $P1854)
    get_how $P1855, type_obj
    .const 'Sub' $P1856 = "57_1303576195.699" 
    $P1855."add_method"(type_obj, "you_are_here", $P1856)
    get_how $P1857, type_obj
    get_global $P1858, "!PREFIX__you_are_here"
    $P1857."add_method"(type_obj, "!PREFIX__you_are_here", $P1858)
    get_how $P1859, type_obj
    .const 'Sub' $P1860 = "59_1303576195.699" 
    $P1859."add_method"(type_obj, "terminator", $P1860)
    get_how $P1861, type_obj
    .const 'Sub' $P1862 = "60_1303576195.699" 
    $P1861."add_method"(type_obj, "!PREFIX__terminator", $P1862)
    get_how $P1863, type_obj
    .const 'Sub' $P1864 = "61_1303576195.699" 
    $P1863."add_method"(type_obj, "terminator:sym<;>", $P1864)
    get_how $P1865, type_obj
    get_global $P1866, "!PREFIX__terminator:sym<;>"
    $P1865."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1866)
    get_how $P1867, type_obj
    .const 'Sub' $P1868 = "63_1303576195.699" 
    $P1867."add_method"(type_obj, "terminator:sym<}>", $P1868)
    get_how $P1869, type_obj
    get_global $P1870, "!PREFIX__terminator:sym<}>"
    $P1869."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1870)
    get_how $P1871, type_obj
    .const 'Sub' $P1872 = "65_1303576195.699" 
    $P1871."add_method"(type_obj, "statement_control", $P1872)
    get_how $P1873, type_obj
    .const 'Sub' $P1874 = "66_1303576195.699" 
    $P1873."add_method"(type_obj, "!PREFIX__statement_control", $P1874)
    get_how $P1875, type_obj
    .const 'Sub' $P1876 = "67_1303576195.699" 
    $P1875."add_method"(type_obj, "statement_control:sym<use>", $P1876)
    get_how $P1877, type_obj
    get_global $P1878, "!PREFIX__statement_control:sym<use>"
    $P1877."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1878)
    get_how $P1879, type_obj
    .const 'Sub' $P1880 = "69_1303576195.699" 
    $P1879."add_method"(type_obj, "statement_control:sym<if>", $P1880)
    get_how $P1881, type_obj
    get_global $P1882, "!PREFIX__statement_control:sym<if>"
    $P1881."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1882)
    get_how $P1883, type_obj
    .const 'Sub' $P1884 = "71_1303576195.699" 
    $P1883."add_method"(type_obj, "statement_control:sym<unless>", $P1884)
    get_how $P1885, type_obj
    get_global $P1886, "!PREFIX__statement_control:sym<unless>"
    $P1885."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1886)
    get_how $P1887, type_obj
    .const 'Sub' $P1888 = "74_1303576195.699" 
    $P1887."add_method"(type_obj, "statement_control:sym<while>", $P1888)
    get_how $P1889, type_obj
    get_global $P1890, "!PREFIX__statement_control:sym<while>"
    $P1889."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1890)
    get_how $P1891, type_obj
    .const 'Sub' $P1892 = "76_1303576195.699" 
    $P1891."add_method"(type_obj, "statement_control:sym<repeat>", $P1892)
    get_how $P1893, type_obj
    get_global $P1894, "!PREFIX__statement_control:sym<repeat>"
    $P1893."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1894)
    get_how $P1895, type_obj
    .const 'Sub' $P1896 = "78_1303576195.699" 
    $P1895."add_method"(type_obj, "statement_control:sym<for>", $P1896)
    get_how $P1897, type_obj
    get_global $P1898, "!PREFIX__statement_control:sym<for>"
    $P1897."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1898)
    get_how $P1899, type_obj
    .const 'Sub' $P1900 = "80_1303576195.699" 
    $P1899."add_method"(type_obj, "statement_control:sym<CATCH>", $P1900)
    get_how $P1901, type_obj
    get_global $P1902, "!PREFIX__statement_control:sym<CATCH>"
    $P1901."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1902)
    get_how $P1903, type_obj
    .const 'Sub' $P1904 = "82_1303576195.699" 
    $P1903."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1904)
    get_how $P1905, type_obj
    get_global $P1906, "!PREFIX__statement_control:sym<CONTROL>"
    $P1905."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1906)
    get_how $P1907, type_obj
    .const 'Sub' $P1908 = "84_1303576195.699" 
    $P1907."add_method"(type_obj, "statement_prefix", $P1908)
    get_how $P1909, type_obj
    .const 'Sub' $P1910 = "85_1303576195.699" 
    $P1909."add_method"(type_obj, "!PREFIX__statement_prefix", $P1910)
    get_how $P1911, type_obj
    .const 'Sub' $P1912 = "86_1303576195.699" 
    $P1911."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1912)
    get_how $P1913, type_obj
    get_global $P1914, "!PREFIX__statement_prefix:sym<INIT>"
    $P1913."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1914)
    get_how $P1915, type_obj
    .const 'Sub' $P1916 = "88_1303576195.699" 
    $P1915."add_method"(type_obj, "statement_prefix:sym<try>", $P1916)
    get_how $P1917, type_obj
    get_global $P1918, "!PREFIX__statement_prefix:sym<try>"
    $P1917."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1918)
    get_how $P1919, type_obj
    .const 'Sub' $P1920 = "90_1303576195.699" 
    $P1919."add_method"(type_obj, "blorst", $P1920)
    get_how $P1921, type_obj
    get_global $P1922, "!PREFIX__blorst"
    $P1921."add_method"(type_obj, "!PREFIX__blorst", $P1922)
    get_how $P1923, type_obj
    .const 'Sub' $P1924 = "92_1303576195.699" 
    $P1923."add_method"(type_obj, "statement_mod_cond", $P1924)
    get_how $P1925, type_obj
    .const 'Sub' $P1926 = "93_1303576195.699" 
    $P1925."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1926)
    get_how $P1927, type_obj
    .const 'Sub' $P1928 = "94_1303576195.699" 
    $P1927."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1928)
    get_how $P1929, type_obj
    get_global $P1930, "!PREFIX__statement_mod_cond:sym<if>"
    $P1929."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "96_1303576195.699" 
    $P1931."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1932)
    get_how $P1933, type_obj
    get_global $P1934, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1933."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1934)
    get_how $P1935, type_obj
    .const 'Sub' $P1936 = "98_1303576195.699" 
    $P1935."add_method"(type_obj, "statement_mod_loop", $P1936)
    get_how $P1937, type_obj
    .const 'Sub' $P1938 = "99_1303576195.699" 
    $P1937."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1938)
    get_how $P1939, type_obj
    .const 'Sub' $P1940 = "100_1303576195.699" 
    $P1939."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1940)
    get_how $P1941, type_obj
    get_global $P1942, "!PREFIX__statement_mod_loop:sym<while>"
    $P1941."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1942)
    get_how $P1943, type_obj
    .const 'Sub' $P1944 = "102_1303576195.699" 
    $P1943."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1944)
    get_how $P1945, type_obj
    get_global $P1946, "!PREFIX__statement_mod_loop:sym<until>"
    $P1945."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1946)
    get_how $P1947, type_obj
    .const 'Sub' $P1948 = "104_1303576195.699" 
    $P1947."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1948)
    get_how $P1949, type_obj
    get_global $P1950, "!PREFIX__statement_mod_loop:sym<for>"
    $P1949."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1950)
    get_how $P1951, type_obj
    .const 'Sub' $P1952 = "106_1303576195.699" 
    $P1951."add_method"(type_obj, "term:sym<fatarrow>", $P1952)
    get_how $P1953, type_obj
    get_global $P1954, "!PREFIX__term:sym<fatarrow>"
    $P1953."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1954)
    get_how $P1955, type_obj
    .const 'Sub' $P1956 = "108_1303576195.699" 
    $P1955."add_method"(type_obj, "term:sym<colonpair>", $P1956)
    get_how $P1957, type_obj
    get_global $P1958, "!PREFIX__term:sym<colonpair>"
    $P1957."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1958)
    get_how $P1959, type_obj
    .const 'Sub' $P1960 = "110_1303576195.699" 
    $P1959."add_method"(type_obj, "term:sym<variable>", $P1960)
    get_how $P1961, type_obj
    get_global $P1962, "!PREFIX__term:sym<variable>"
    $P1961."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1962)
    get_how $P1963, type_obj
    .const 'Sub' $P1964 = "112_1303576195.699" 
    $P1963."add_method"(type_obj, "term:sym<package_declarator>", $P1964)
    get_how $P1965, type_obj
    get_global $P1966, "!PREFIX__term:sym<package_declarator>"
    $P1965."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1966)
    get_how $P1967, type_obj
    .const 'Sub' $P1968 = "114_1303576195.699" 
    $P1967."add_method"(type_obj, "term:sym<scope_declarator>", $P1968)
    get_how $P1969, type_obj
    get_global $P1970, "!PREFIX__term:sym<scope_declarator>"
    $P1969."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1970)
    get_how $P1971, type_obj
    .const 'Sub' $P1972 = "116_1303576195.699" 
    $P1971."add_method"(type_obj, "term:sym<routine_declarator>", $P1972)
    get_how $P1973, type_obj
    get_global $P1974, "!PREFIX__term:sym<routine_declarator>"
    $P1973."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1974)
    get_how $P1975, type_obj
    .const 'Sub' $P1976 = "118_1303576195.699" 
    $P1975."add_method"(type_obj, "term:sym<multi_declarator>", $P1976)
    get_how $P1977, type_obj
    get_global $P1978, "!PREFIX__term:sym<multi_declarator>"
    $P1977."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1978)
    get_how $P1979, type_obj
    .const 'Sub' $P1980 = "122_1303576195.699" 
    $P1979."add_method"(type_obj, "term:sym<regex_declarator>", $P1980)
    get_how $P1981, type_obj
    get_global $P1982, "!PREFIX__term:sym<regex_declarator>"
    $P1981."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1982)
    get_how $P1983, type_obj
    .const 'Sub' $P1984 = "124_1303576195.699" 
    $P1983."add_method"(type_obj, "term:sym<statement_prefix>", $P1984)
    get_how $P1985, type_obj
    get_global $P1986, "!PREFIX__term:sym<statement_prefix>"
    $P1985."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1986)
    get_how $P1987, type_obj
    .const 'Sub' $P1988 = "126_1303576195.699" 
    $P1987."add_method"(type_obj, "term:sym<lambda>", $P1988)
    get_how $P1989, type_obj
    get_global $P1990, "!PREFIX__term:sym<lambda>"
    $P1989."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1990)
    get_how $P1991, type_obj
    .const 'Sub' $P1992 = "128_1303576195.699" 
    $P1991."add_method"(type_obj, "fatarrow", $P1992)
    get_how $P1993, type_obj
    get_global $P1994, "!PREFIX__fatarrow"
    $P1993."add_method"(type_obj, "!PREFIX__fatarrow", $P1994)
    get_how $P1995, type_obj
    .const 'Sub' $P1996 = "130_1303576195.699" 
    $P1995."add_method"(type_obj, "colonpair", $P1996)
    get_how $P1997, type_obj
    get_global $P1998, "!PREFIX__colonpair"
    $P1997."add_method"(type_obj, "!PREFIX__colonpair", $P1998)
    get_how $P1999, type_obj
    .const 'Sub' $P2000 = "132_1303576195.699" 
    $P1999."add_method"(type_obj, "variable", $P2000)
    get_how $P2001, type_obj
    get_global $P2002, "!PREFIX__variable"
    $P2001."add_method"(type_obj, "!PREFIX__variable", $P2002)
    get_how $P2003, type_obj
    .const 'Sub' $P2004 = "134_1303576195.699" 
    $P2003."add_method"(type_obj, "sigil", $P2004)
    get_how $P2005, type_obj
    get_global $P2006, "!PREFIX__sigil"
    $P2005."add_method"(type_obj, "!PREFIX__sigil", $P2006)
    get_how $P2007, type_obj
    .const 'Sub' $P2008 = "136_1303576195.699" 
    $P2007."add_method"(type_obj, "twigil", $P2008)
    get_how $P2009, type_obj
    get_global $P2010, "!PREFIX__twigil"
    $P2009."add_method"(type_obj, "!PREFIX__twigil", $P2010)
    get_how $P2011, type_obj
    .const 'Sub' $P2012 = "138_1303576195.699" 
    $P2011."add_method"(type_obj, "package_declarator", $P2012)
    get_how $P2013, type_obj
    .const 'Sub' $P2014 = "139_1303576195.699" 
    $P2013."add_method"(type_obj, "!PREFIX__package_declarator", $P2014)
    get_how $P2015, type_obj
    .const 'Sub' $P2016 = "140_1303576195.699" 
    $P2015."add_method"(type_obj, "package_declarator:sym<module>", $P2016)
    get_how $P2017, type_obj
    get_global $P2018, "!PREFIX__package_declarator:sym<module>"
    $P2017."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2018)
    get_how $P2019, type_obj
    .const 'Sub' $P2020 = "142_1303576195.699" 
    $P2019."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2020)
    get_how $P2021, type_obj
    get_global $P2022, "!PREFIX__package_declarator:sym<knowhow>"
    $P2021."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2022)
    get_how $P2023, type_obj
    .const 'Sub' $P2024 = "144_1303576195.699" 
    $P2023."add_method"(type_obj, "package_declarator:sym<class>", $P2024)
    get_how $P2025, type_obj
    get_global $P2026, "!PREFIX__package_declarator:sym<class>"
    $P2025."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2026)
    get_how $P2027, type_obj
    .const 'Sub' $P2028 = "146_1303576195.699" 
    $P2027."add_method"(type_obj, "package_declarator:sym<grammar>", $P2028)
    get_how $P2029, type_obj
    get_global $P2030, "!PREFIX__package_declarator:sym<grammar>"
    $P2029."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2030)
    get_how $P2031, type_obj
    .const 'Sub' $P2032 = "148_1303576195.699" 
    $P2031."add_method"(type_obj, "package_declarator:sym<role>", $P2032)
    get_how $P2033, type_obj
    get_global $P2034, "!PREFIX__package_declarator:sym<role>"
    $P2033."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2034)
    get_how $P2035, type_obj
    .const 'Sub' $P2036 = "150_1303576195.699" 
    $P2035."add_method"(type_obj, "package_declarator:sym<native>", $P2036)
    get_how $P2037, type_obj
    get_global $P2038, "!PREFIX__package_declarator:sym<native>"
    $P2037."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2038)
    get_how $P2039, type_obj
    .const 'Sub' $P2040 = "152_1303576195.699" 
    $P2039."add_method"(type_obj, "package_def", $P2040)
    get_how $P2041, type_obj
    get_global $P2042, "!PREFIX__package_def"
    $P2041."add_method"(type_obj, "!PREFIX__package_def", $P2042)
    get_how $P2043, type_obj
    .const 'Sub' $P2044 = "155_1303576195.699" 
    $P2043."add_method"(type_obj, "scope_declarator", $P2044)
    get_how $P2045, type_obj
    .const 'Sub' $P2046 = "156_1303576195.699" 
    $P2045."add_method"(type_obj, "!PREFIX__scope_declarator", $P2046)
    get_how $P2047, type_obj
    .const 'Sub' $P2048 = "157_1303576195.699" 
    $P2047."add_method"(type_obj, "scope_declarator:sym<my>", $P2048)
    get_how $P2049, type_obj
    get_global $P2050, "!PREFIX__scope_declarator:sym<my>"
    $P2049."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2050)
    get_how $P2051, type_obj
    .const 'Sub' $P2052 = "159_1303576195.699" 
    $P2051."add_method"(type_obj, "scope_declarator:sym<our>", $P2052)
    get_how $P2053, type_obj
    get_global $P2054, "!PREFIX__scope_declarator:sym<our>"
    $P2053."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2054)
    get_how $P2055, type_obj
    .const 'Sub' $P2056 = "161_1303576195.699" 
    $P2055."add_method"(type_obj, "scope_declarator:sym<has>", $P2056)
    get_how $P2057, type_obj
    get_global $P2058, "!PREFIX__scope_declarator:sym<has>"
    $P2057."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2058)
    get_how $P2059, type_obj
    .const 'Sub' $P2060 = "163_1303576195.699" 
    $P2059."add_method"(type_obj, "scoped", $P2060)
    get_how $P2061, type_obj
    get_global $P2062, "!PREFIX__scoped"
    $P2061."add_method"(type_obj, "!PREFIX__scoped", $P2062)
    get_how $P2063, type_obj
    .const 'Sub' $P2064 = "165_1303576195.699" 
    $P2063."add_method"(type_obj, "typename", $P2064)
    get_how $P2065, type_obj
    get_global $P2066, "!PREFIX__typename"
    $P2065."add_method"(type_obj, "!PREFIX__typename", $P2066)
    get_how $P2067, type_obj
    .const 'Sub' $P2068 = "167_1303576195.699" 
    $P2067."add_method"(type_obj, "declarator", $P2068)
    get_how $P2069, type_obj
    get_global $P2070, "!PREFIX__declarator"
    $P2069."add_method"(type_obj, "!PREFIX__declarator", $P2070)
    get_how $P2071, type_obj
    .const 'Sub' $P2072 = "169_1303576195.699" 
    $P2071."add_method"(type_obj, "variable_declarator", $P2072)
    get_how $P2073, type_obj
    get_global $P2074, "!PREFIX__variable_declarator"
    $P2073."add_method"(type_obj, "!PREFIX__variable_declarator", $P2074)
    get_how $P2075, type_obj
    .const 'Sub' $P2076 = "171_1303576195.699" 
    $P2075."add_method"(type_obj, "routine_declarator", $P2076)
    get_how $P2077, type_obj
    .const 'Sub' $P2078 = "172_1303576195.699" 
    $P2077."add_method"(type_obj, "!PREFIX__routine_declarator", $P2078)
    get_how $P2079, type_obj
    .const 'Sub' $P2080 = "173_1303576195.699" 
    $P2079."add_method"(type_obj, "routine_declarator:sym<sub>", $P2080)
    get_how $P2081, type_obj
    get_global $P2082, "!PREFIX__routine_declarator:sym<sub>"
    $P2081."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2082)
    get_how $P2083, type_obj
    .const 'Sub' $P2084 = "175_1303576195.699" 
    $P2083."add_method"(type_obj, "routine_declarator:sym<method>", $P2084)
    get_how $P2085, type_obj
    get_global $P2086, "!PREFIX__routine_declarator:sym<method>"
    $P2085."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2086)
    get_how $P2087, type_obj
    .const 'Sub' $P2088 = "177_1303576195.699" 
    $P2087."add_method"(type_obj, "routine_def", $P2088)
    get_how $P2089, type_obj
    get_global $P2090, "!PREFIX__routine_def"
    $P2089."add_method"(type_obj, "!PREFIX__routine_def", $P2090)
    get_how $P2091, type_obj
    .const 'Sub' $P2092 = "179_1303576195.699" 
    $P2091."add_method"(type_obj, "method_def", $P2092)
    get_how $P2093, type_obj
    get_global $P2094, "!PREFIX__method_def"
    $P2093."add_method"(type_obj, "!PREFIX__method_def", $P2094)
    get_how $P2095, type_obj
    .const 'Sub' $P2096 = "182_1303576195.699" 
    $P2095."add_method"(type_obj, "onlystar", $P2096)
    get_how $P2097, type_obj
    get_global $P2098, "!PREFIX__onlystar"
    $P2097."add_method"(type_obj, "!PREFIX__onlystar", $P2098)
    get_how $P2099, type_obj
    .const 'Sub' $P2100 = "185_1303576195.699" 
    $P2099."add_method"(type_obj, "multi_declarator", $P2100)
    get_how $P2101, type_obj
    .const 'Sub' $P2102 = "186_1303576195.699" 
    $P2101."add_method"(type_obj, "!PREFIX__multi_declarator", $P2102)
    get_how $P2103, type_obj
    .const 'Sub' $P2104 = "187_1303576195.699" 
    $P2103."add_method"(type_obj, "multi_declarator:sym<multi>", $P2104)
    get_how $P2105, type_obj
    get_global $P2106, "!PREFIX__multi_declarator:sym<multi>"
    $P2105."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2106)
    get_how $P2107, type_obj
    .const 'Sub' $P2108 = "189_1303576195.699" 
    $P2107."add_method"(type_obj, "multi_declarator:sym<proto>", $P2108)
    get_how $P2109, type_obj
    get_global $P2110, "!PREFIX__multi_declarator:sym<proto>"
    $P2109."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2110)
    get_how $P2111, type_obj
    .const 'Sub' $P2112 = "191_1303576195.699" 
    $P2111."add_method"(type_obj, "multi_declarator:sym<null>", $P2112)
    get_how $P2113, type_obj
    get_global $P2114, "!PREFIX__multi_declarator:sym<null>"
    $P2113."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2114)
    get_how $P2115, type_obj
    .const 'Sub' $P2116 = "193_1303576195.699" 
    $P2115."add_method"(type_obj, "signature", $P2116)
    get_how $P2117, type_obj
    get_global $P2118, "!PREFIX__signature"
    $P2117."add_method"(type_obj, "!PREFIX__signature", $P2118)
    get_how $P2119, type_obj
    .const 'Sub' $P2120 = "196_1303576195.699" 
    $P2119."add_method"(type_obj, "parameter", $P2120)
    get_how $P2121, type_obj
    get_global $P2122, "!PREFIX__parameter"
    $P2121."add_method"(type_obj, "!PREFIX__parameter", $P2122)
    get_how $P2123, type_obj
    .const 'Sub' $P2124 = "198_1303576195.699" 
    $P2123."add_method"(type_obj, "param_var", $P2124)
    get_how $P2125, type_obj
    get_global $P2126, "!PREFIX__param_var"
    $P2125."add_method"(type_obj, "!PREFIX__param_var", $P2126)
    get_how $P2127, type_obj
    .const 'Sub' $P2128 = "200_1303576195.699" 
    $P2127."add_method"(type_obj, "named_param", $P2128)
    get_how $P2129, type_obj
    get_global $P2130, "!PREFIX__named_param"
    $P2129."add_method"(type_obj, "!PREFIX__named_param", $P2130)
    get_how $P2131, type_obj
    .const 'Sub' $P2132 = "202_1303576195.699" 
    $P2131."add_method"(type_obj, "default_value", $P2132)
    get_how $P2133, type_obj
    get_global $P2134, "!PREFIX__default_value"
    $P2133."add_method"(type_obj, "!PREFIX__default_value", $P2134)
    get_how $P2135, type_obj
    .const 'Sub' $P2136 = "204_1303576195.699" 
    $P2135."add_method"(type_obj, "trait", $P2136)
    get_how $P2137, type_obj
    get_global $P2138, "!PREFIX__trait"
    $P2137."add_method"(type_obj, "!PREFIX__trait", $P2138)
    get_how $P2139, type_obj
    .const 'Sub' $P2140 = "206_1303576195.699" 
    $P2139."add_method"(type_obj, "trait_mod", $P2140)
    get_how $P2141, type_obj
    .const 'Sub' $P2142 = "207_1303576195.699" 
    $P2141."add_method"(type_obj, "!PREFIX__trait_mod", $P2142)
    get_how $P2143, type_obj
    .const 'Sub' $P2144 = "208_1303576195.699" 
    $P2143."add_method"(type_obj, "trait_mod:sym<is>", $P2144)
    get_how $P2145, type_obj
    get_global $P2146, "!PREFIX__trait_mod:sym<is>"
    $P2145."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2146)
    get_how $P2147, type_obj
    .const 'Sub' $P2148 = "210_1303576195.699" 
    $P2147."add_method"(type_obj, "regex_declarator", $P2148)
    get_how $P2149, type_obj
    get_global $P2150, "!PREFIX__regex_declarator"
    $P2149."add_method"(type_obj, "!PREFIX__regex_declarator", $P2150)
    get_how $P2151, type_obj
    .const 'Sub' $P2152 = "212_1303576195.699" 
    $P2151."add_method"(type_obj, "dotty", $P2152)
    get_how $P2153, type_obj
    get_global $P2154, "!PREFIX__dotty"
    $P2153."add_method"(type_obj, "!PREFIX__dotty", $P2154)
    get_how $P2155, type_obj
    .const 'Sub' $P2156 = "214_1303576195.699" 
    $P2155."add_method"(type_obj, "term", $P2156)
    get_how $P2157, type_obj
    .const 'Sub' $P2158 = "215_1303576195.699" 
    $P2157."add_method"(type_obj, "!PREFIX__term", $P2158)
    get_how $P2159, type_obj
    .const 'Sub' $P2160 = "216_1303576195.699" 
    $P2159."add_method"(type_obj, "term:sym<self>", $P2160)
    get_how $P2161, type_obj
    get_global $P2162, "!PREFIX__term:sym<self>"
    $P2161."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2162)
    get_how $P2163, type_obj
    .const 'Sub' $P2164 = "218_1303576195.699" 
    $P2163."add_method"(type_obj, "term:sym<identifier>", $P2164)
    get_how $P2165, type_obj
    get_global $P2166, "!PREFIX__term:sym<identifier>"
    $P2165."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2166)
    get_how $P2167, type_obj
    .const 'Sub' $P2168 = "220_1303576195.699" 
    $P2167."add_method"(type_obj, "term:sym<name>", $P2168)
    get_how $P2169, type_obj
    get_global $P2170, "!PREFIX__term:sym<name>"
    $P2169."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2170)
    get_how $P2171, type_obj
    .const 'Sub' $P2172 = "222_1303576195.699" 
    $P2171."add_method"(type_obj, "term:sym<pir::op>", $P2172)
    get_how $P2173, type_obj
    get_global $P2174, "!PREFIX__term:sym<pir::op>"
    $P2173."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2174)
    get_how $P2175, type_obj
    .const 'Sub' $P2176 = "224_1303576195.699" 
    $P2175."add_method"(type_obj, "term:sym<onlystar>", $P2176)
    get_how $P2177, type_obj
    get_global $P2178, "!PREFIX__term:sym<onlystar>"
    $P2177."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2178)
    get_how $P2179, type_obj
    .const 'Sub' $P2180 = "227_1303576195.699" 
    $P2179."add_method"(type_obj, "args", $P2180)
    get_how $P2181, type_obj
    get_global $P2182, "!PREFIX__args"
    $P2181."add_method"(type_obj, "!PREFIX__args", $P2182)
    get_how $P2183, type_obj
    .const 'Sub' $P2184 = "229_1303576195.699" 
    $P2183."add_method"(type_obj, "arglist", $P2184)
    get_how $P2185, type_obj
    get_global $P2186, "!PREFIX__arglist"
    $P2185."add_method"(type_obj, "!PREFIX__arglist", $P2186)
    get_how $P2187, type_obj
    .const 'Sub' $P2188 = "231_1303576195.699" 
    $P2187."add_method"(type_obj, "term:sym<value>", $P2188)
    get_how $P2189, type_obj
    get_global $P2190, "!PREFIX__term:sym<value>"
    $P2189."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2190)
    get_how $P2191, type_obj
    .const 'Sub' $P2192 = "233_1303576195.699" 
    $P2191."add_method"(type_obj, "value", $P2192)
    get_how $P2193, type_obj
    get_global $P2194, "!PREFIX__value"
    $P2193."add_method"(type_obj, "!PREFIX__value", $P2194)
    get_how $P2195, type_obj
    .const 'Sub' $P2196 = "235_1303576195.699" 
    $P2195."add_method"(type_obj, "number", $P2196)
    get_how $P2197, type_obj
    get_global $P2198, "!PREFIX__number"
    $P2197."add_method"(type_obj, "!PREFIX__number", $P2198)
    get_how $P2199, type_obj
    .const 'Sub' $P2200 = "237_1303576195.699" 
    $P2199."add_method"(type_obj, "quote", $P2200)
    get_how $P2201, type_obj
    .const 'Sub' $P2202 = "238_1303576195.699" 
    $P2201."add_method"(type_obj, "!PREFIX__quote", $P2202)
    get_how $P2203, type_obj
    .const 'Sub' $P2204 = "239_1303576195.699" 
    $P2203."add_method"(type_obj, "quote:sym<apos>", $P2204)
    get_how $P2205, type_obj
    get_global $P2206, "!PREFIX__quote:sym<apos>"
    $P2205."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2206)
    get_how $P2207, type_obj
    .const 'Sub' $P2208 = "241_1303576195.699" 
    $P2207."add_method"(type_obj, "quote:sym<dblq>", $P2208)
    get_how $P2209, type_obj
    get_global $P2210, "!PREFIX__quote:sym<dblq>"
    $P2209."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2210)
    get_how $P2211, type_obj
    .const 'Sub' $P2212 = "243_1303576195.699" 
    $P2211."add_method"(type_obj, "quote:sym<q>", $P2212)
    get_how $P2213, type_obj
    get_global $P2214, "!PREFIX__quote:sym<q>"
    $P2213."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2214)
    get_how $P2215, type_obj
    .const 'Sub' $P2216 = "245_1303576195.699" 
    $P2215."add_method"(type_obj, "quote:sym<qq>", $P2216)
    get_how $P2217, type_obj
    get_global $P2218, "!PREFIX__quote:sym<qq>"
    $P2217."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2218)
    get_how $P2219, type_obj
    .const 'Sub' $P2220 = "247_1303576195.699" 
    $P2219."add_method"(type_obj, "quote:sym<Q>", $P2220)
    get_how $P2221, type_obj
    get_global $P2222, "!PREFIX__quote:sym<Q>"
    $P2221."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2222)
    get_how $P2223, type_obj
    .const 'Sub' $P2224 = "249_1303576195.699" 
    $P2223."add_method"(type_obj, "quote:sym<Q:PIR>", $P2224)
    get_how $P2225, type_obj
    get_global $P2226, "!PREFIX__quote:sym<Q:PIR>"
    $P2225."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2226)
    get_how $P2227, type_obj
    .const 'Sub' $P2228 = "251_1303576195.699" 
    $P2227."add_method"(type_obj, "quote:sym</ />", $P2228)
    get_how $P2229, type_obj
    get_global $P2230, "!PREFIX__quote:sym</ />"
    $P2229."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2230)
    get_how $P2231, type_obj
    .const 'Sub' $P2232 = "253_1303576195.699" 
    $P2231."add_method"(type_obj, "quote_escape:sym<$>", $P2232)
    get_how $P2233, type_obj
    get_global $P2234, "!PREFIX__quote_escape:sym<$>"
    $P2233."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2234)
    get_how $P2235, type_obj
    .const 'Sub' $P2236 = "255_1303576195.699" 
    $P2235."add_method"(type_obj, "quote_escape:sym<{ }>", $P2236)
    get_how $P2237, type_obj
    get_global $P2238, "!PREFIX__quote_escape:sym<{ }>"
    $P2237."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2238)
    get_how $P2239, type_obj
    .const 'Sub' $P2240 = "257_1303576195.699" 
    $P2239."add_method"(type_obj, "quote_escape:sym<esc>", $P2240)
    get_how $P2241, type_obj
    get_global $P2242, "!PREFIX__quote_escape:sym<esc>"
    $P2241."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2242)
    get_how $P2243, type_obj
    .const 'Sub' $P2244 = "259_1303576195.699" 
    $P2243."add_method"(type_obj, "circumfix:sym<( )>", $P2244)
    get_how $P2245, type_obj
    get_global $P2246, "!PREFIX__circumfix:sym<( )>"
    $P2245."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2246)
    get_how $P2247, type_obj
    .const 'Sub' $P2248 = "261_1303576195.699" 
    $P2247."add_method"(type_obj, "circumfix:sym<[ ]>", $P2248)
    get_how $P2249, type_obj
    get_global $P2250, "!PREFIX__circumfix:sym<[ ]>"
    $P2249."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2250)
    get_how $P2251, type_obj
    .const 'Sub' $P2252 = "263_1303576195.699" 
    $P2251."add_method"(type_obj, "circumfix:sym<ang>", $P2252)
    get_how $P2253, type_obj
    get_global $P2254, "!PREFIX__circumfix:sym<ang>"
    $P2253."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2254)
    get_how $P2255, type_obj
    .const 'Sub' $P2256 = "265_1303576195.699" 
    $P2255."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2256)
    get_how $P2257, type_obj
    get_global $P2258, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2257."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2258)
    get_how $P2259, type_obj
    .const 'Sub' $P2260 = "267_1303576195.699" 
    $P2259."add_method"(type_obj, "circumfix:sym<{ }>", $P2260)
    get_how $P2261, type_obj
    get_global $P2262, "!PREFIX__circumfix:sym<{ }>"
    $P2261."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2262)
    get_how $P2263, type_obj
    .const 'Sub' $P2264 = "269_1303576195.699" 
    $P2263."add_method"(type_obj, "circumfix:sym<sigil>", $P2264)
    get_how $P2265, type_obj
    get_global $P2266, "!PREFIX__circumfix:sym<sigil>"
    $P2265."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2266)
    get_how $P2267, type_obj
    .const 'Sub' $P2268 = "271_1303576195.699" 
    $P2267."add_method"(type_obj, "semilist", $P2268)
    get_how $P2269, type_obj
    get_global $P2270, "!PREFIX__semilist"
    $P2269."add_method"(type_obj, "!PREFIX__semilist", $P2270)
    get_how $P2271, type_obj
    .const 'Sub' $P2272 = "273_1303576195.699" 
    $P2271."add_method"(type_obj, "infixish", $P2272)
    get_how $P2273, type_obj
    get_global $P2274, "!PREFIX__infixish"
    $P2273."add_method"(type_obj, "!PREFIX__infixish", $P2274)
    get_how $P2275, type_obj
    .const 'Sub' $P2276 = "275_1303576195.699" 
    $P2275."add_method"(type_obj, "infixstopper", $P2276)
    get_how $P2277, type_obj
    get_global $P2278, "!PREFIX__infixstopper"
    $P2277."add_method"(type_obj, "!PREFIX__infixstopper", $P2278)
    get_how $P2279, type_obj
    .const 'Sub' $P2280 = "277_1303576195.699" 
    $P2279."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2280)
    get_how $P2281, type_obj
    get_global $P2282, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2281."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2282)
    get_how $P2283, type_obj
    .const 'Sub' $P2284 = "279_1303576195.699" 
    $P2283."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2284)
    get_how $P2285, type_obj
    get_global $P2286, "!PREFIX__postcircumfix:sym<{ }>"
    $P2285."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2286)
    get_how $P2287, type_obj
    .const 'Sub' $P2288 = "281_1303576195.699" 
    $P2287."add_method"(type_obj, "postcircumfix:sym<ang>", $P2288)
    get_how $P2289, type_obj
    get_global $P2290, "!PREFIX__postcircumfix:sym<ang>"
    $P2289."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2290)
    get_how $P2291, type_obj
    .const 'Sub' $P2292 = "283_1303576195.699" 
    $P2291."add_method"(type_obj, "postcircumfix:sym<( )>", $P2292)
    get_how $P2293, type_obj
    get_global $P2294, "!PREFIX__postcircumfix:sym<( )>"
    $P2293."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2294)
    get_how $P2295, type_obj
    .const 'Sub' $P2296 = "285_1303576195.699" 
    $P2295."add_method"(type_obj, "postfix:sym<.>", $P2296)
    get_how $P2297, type_obj
    get_global $P2298, "!PREFIX__postfix:sym<.>"
    $P2297."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2298)
    get_how $P2299, type_obj
    .const 'Sub' $P2300 = "287_1303576195.699" 
    $P2299."add_method"(type_obj, "prefix:sym<++>", $P2300)
    get_how $P2301, type_obj
    get_global $P2302, "!PREFIX__prefix:sym<++>"
    $P2301."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2302)
    get_how $P2303, type_obj
    .const 'Sub' $P2304 = "289_1303576195.699" 
    $P2303."add_method"(type_obj, "prefix:sym<-->", $P2304)
    get_how $P2305, type_obj
    get_global $P2306, "!PREFIX__prefix:sym<-->"
    $P2305."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2306)
    get_how $P2307, type_obj
    .const 'Sub' $P2308 = "291_1303576195.699" 
    $P2307."add_method"(type_obj, "postfix:sym<++>", $P2308)
    get_how $P2309, type_obj
    get_global $P2310, "!PREFIX__postfix:sym<++>"
    $P2309."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2310)
    get_how $P2311, type_obj
    .const 'Sub' $P2312 = "293_1303576195.699" 
    $P2311."add_method"(type_obj, "postfix:sym<-->", $P2312)
    get_how $P2313, type_obj
    get_global $P2314, "!PREFIX__postfix:sym<-->"
    $P2313."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2314)
    get_how $P2315, type_obj
    .const 'Sub' $P2316 = "295_1303576195.699" 
    $P2315."add_method"(type_obj, "infix:sym<**>", $P2316)
    get_how $P2317, type_obj
    get_global $P2318, "!PREFIX__infix:sym<**>"
    $P2317."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2318)
    get_how $P2319, type_obj
    .const 'Sub' $P2320 = "297_1303576195.699" 
    $P2319."add_method"(type_obj, "prefix:sym<+>", $P2320)
    get_how $P2321, type_obj
    get_global $P2322, "!PREFIX__prefix:sym<+>"
    $P2321."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2322)
    get_how $P2323, type_obj
    .const 'Sub' $P2324 = "299_1303576195.699" 
    $P2323."add_method"(type_obj, "prefix:sym<~>", $P2324)
    get_how $P2325, type_obj
    get_global $P2326, "!PREFIX__prefix:sym<~>"
    $P2325."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2326)
    get_how $P2327, type_obj
    .const 'Sub' $P2328 = "301_1303576195.699" 
    $P2327."add_method"(type_obj, "prefix:sym<->", $P2328)
    get_how $P2329, type_obj
    get_global $P2330, "!PREFIX__prefix:sym<->"
    $P2329."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2330)
    get_how $P2331, type_obj
    .const 'Sub' $P2332 = "303_1303576195.699" 
    $P2331."add_method"(type_obj, "prefix:sym<?>", $P2332)
    get_how $P2333, type_obj
    get_global $P2334, "!PREFIX__prefix:sym<?>"
    $P2333."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2334)
    get_how $P2335, type_obj
    .const 'Sub' $P2336 = "305_1303576195.699" 
    $P2335."add_method"(type_obj, "prefix:sym<!>", $P2336)
    get_how $P2337, type_obj
    get_global $P2338, "!PREFIX__prefix:sym<!>"
    $P2337."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2338)
    get_how $P2339, type_obj
    .const 'Sub' $P2340 = "307_1303576195.699" 
    $P2339."add_method"(type_obj, "prefix:sym<|>", $P2340)
    get_how $P2341, type_obj
    get_global $P2342, "!PREFIX__prefix:sym<|>"
    $P2341."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2342)
    get_how $P2343, type_obj
    .const 'Sub' $P2344 = "309_1303576195.699" 
    $P2343."add_method"(type_obj, "infix:sym<*>", $P2344)
    get_how $P2345, type_obj
    get_global $P2346, "!PREFIX__infix:sym<*>"
    $P2345."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2346)
    get_how $P2347, type_obj
    .const 'Sub' $P2348 = "311_1303576195.699" 
    $P2347."add_method"(type_obj, "infix:sym</>", $P2348)
    get_how $P2349, type_obj
    get_global $P2350, "!PREFIX__infix:sym</>"
    $P2349."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2350)
    get_how $P2351, type_obj
    .const 'Sub' $P2352 = "313_1303576195.699" 
    $P2351."add_method"(type_obj, "infix:sym<%>", $P2352)
    get_how $P2353, type_obj
    get_global $P2354, "!PREFIX__infix:sym<%>"
    $P2353."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2354)
    get_how $P2355, type_obj
    .const 'Sub' $P2356 = "315_1303576195.699" 
    $P2355."add_method"(type_obj, "infix:sym<+&>", $P2356)
    get_how $P2357, type_obj
    get_global $P2358, "!PREFIX__infix:sym<+&>"
    $P2357."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2358)
    get_how $P2359, type_obj
    .const 'Sub' $P2360 = "317_1303576195.699" 
    $P2359."add_method"(type_obj, "infix:sym<+>", $P2360)
    get_how $P2361, type_obj
    get_global $P2362, "!PREFIX__infix:sym<+>"
    $P2361."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2362)
    get_how $P2363, type_obj
    .const 'Sub' $P2364 = "319_1303576195.699" 
    $P2363."add_method"(type_obj, "infix:sym<->", $P2364)
    get_how $P2365, type_obj
    get_global $P2366, "!PREFIX__infix:sym<->"
    $P2365."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2366)
    get_how $P2367, type_obj
    .const 'Sub' $P2368 = "321_1303576195.699" 
    $P2367."add_method"(type_obj, "infix:sym<+|>", $P2368)
    get_how $P2369, type_obj
    get_global $P2370, "!PREFIX__infix:sym<+|>"
    $P2369."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2370)
    get_how $P2371, type_obj
    .const 'Sub' $P2372 = "323_1303576195.699" 
    $P2371."add_method"(type_obj, "infix:sym<+^>", $P2372)
    get_how $P2373, type_obj
    get_global $P2374, "!PREFIX__infix:sym<+^>"
    $P2373."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2374)
    get_how $P2375, type_obj
    .const 'Sub' $P2376 = "325_1303576195.699" 
    $P2375."add_method"(type_obj, "infix:sym<~>", $P2376)
    get_how $P2377, type_obj
    get_global $P2378, "!PREFIX__infix:sym<~>"
    $P2377."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2378)
    get_how $P2379, type_obj
    .const 'Sub' $P2380 = "327_1303576195.699" 
    $P2379."add_method"(type_obj, "infix:sym<==>", $P2380)
    get_how $P2381, type_obj
    get_global $P2382, "!PREFIX__infix:sym<==>"
    $P2381."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2382)
    get_how $P2383, type_obj
    .const 'Sub' $P2384 = "329_1303576195.699" 
    $P2383."add_method"(type_obj, "infix:sym<!=>", $P2384)
    get_how $P2385, type_obj
    get_global $P2386, "!PREFIX__infix:sym<!=>"
    $P2385."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2386)
    get_how $P2387, type_obj
    .const 'Sub' $P2388 = "331_1303576195.699" 
    $P2387."add_method"(type_obj, "infix:sym<<=>", $P2388)
    get_how $P2389, type_obj
    get_global $P2390, "!PREFIX__infix:sym<<=>"
    $P2389."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2390)
    get_how $P2391, type_obj
    .const 'Sub' $P2392 = "333_1303576195.699" 
    $P2391."add_method"(type_obj, "infix:sym<>=>", $P2392)
    get_how $P2393, type_obj
    get_global $P2394, "!PREFIX__infix:sym<>=>"
    $P2393."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2394)
    get_how $P2395, type_obj
    .const 'Sub' $P2396 = "335_1303576195.699" 
    $P2395."add_method"(type_obj, "infix:sym<<>", $P2396)
    get_how $P2397, type_obj
    get_global $P2398, "!PREFIX__infix:sym<<>"
    $P2397."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2398)
    get_how $P2399, type_obj
    .const 'Sub' $P2400 = "337_1303576195.699" 
    $P2399."add_method"(type_obj, "infix:sym<>>", $P2400)
    get_how $P2401, type_obj
    get_global $P2402, "!PREFIX__infix:sym<>>"
    $P2401."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2402)
    get_how $P2403, type_obj
    .const 'Sub' $P2404 = "339_1303576195.699" 
    $P2403."add_method"(type_obj, "infix:sym<eq>", $P2404)
    get_how $P2405, type_obj
    get_global $P2406, "!PREFIX__infix:sym<eq>"
    $P2405."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2406)
    get_how $P2407, type_obj
    .const 'Sub' $P2408 = "341_1303576195.699" 
    $P2407."add_method"(type_obj, "infix:sym<ne>", $P2408)
    get_how $P2409, type_obj
    get_global $P2410, "!PREFIX__infix:sym<ne>"
    $P2409."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2410)
    get_how $P2411, type_obj
    .const 'Sub' $P2412 = "343_1303576195.699" 
    $P2411."add_method"(type_obj, "infix:sym<le>", $P2412)
    get_how $P2413, type_obj
    get_global $P2414, "!PREFIX__infix:sym<le>"
    $P2413."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2414)
    get_how $P2415, type_obj
    .const 'Sub' $P2416 = "345_1303576195.699" 
    $P2415."add_method"(type_obj, "infix:sym<ge>", $P2416)
    get_how $P2417, type_obj
    get_global $P2418, "!PREFIX__infix:sym<ge>"
    $P2417."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2418)
    get_how $P2419, type_obj
    .const 'Sub' $P2420 = "347_1303576195.699" 
    $P2419."add_method"(type_obj, "infix:sym<lt>", $P2420)
    get_how $P2421, type_obj
    get_global $P2422, "!PREFIX__infix:sym<lt>"
    $P2421."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2422)
    get_how $P2423, type_obj
    .const 'Sub' $P2424 = "349_1303576195.699" 
    $P2423."add_method"(type_obj, "infix:sym<gt>", $P2424)
    get_how $P2425, type_obj
    get_global $P2426, "!PREFIX__infix:sym<gt>"
    $P2425."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2426)
    get_how $P2427, type_obj
    .const 'Sub' $P2428 = "351_1303576195.699" 
    $P2427."add_method"(type_obj, "infix:sym<=:=>", $P2428)
    get_how $P2429, type_obj
    get_global $P2430, "!PREFIX__infix:sym<=:=>"
    $P2429."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2430)
    get_how $P2431, type_obj
    .const 'Sub' $P2432 = "353_1303576195.699" 
    $P2431."add_method"(type_obj, "infix:sym<~~>", $P2432)
    get_how $P2433, type_obj
    get_global $P2434, "!PREFIX__infix:sym<~~>"
    $P2433."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2434)
    get_how $P2435, type_obj
    .const 'Sub' $P2436 = "355_1303576195.699" 
    $P2435."add_method"(type_obj, "infix:sym<&&>", $P2436)
    get_how $P2437, type_obj
    get_global $P2438, "!PREFIX__infix:sym<&&>"
    $P2437."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2438)
    get_how $P2439, type_obj
    .const 'Sub' $P2440 = "357_1303576195.699" 
    $P2439."add_method"(type_obj, "infix:sym<||>", $P2440)
    get_how $P2441, type_obj
    get_global $P2442, "!PREFIX__infix:sym<||>"
    $P2441."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2442)
    get_how $P2443, type_obj
    .const 'Sub' $P2444 = "359_1303576195.699" 
    $P2443."add_method"(type_obj, "infix:sym<//>", $P2444)
    get_how $P2445, type_obj
    get_global $P2446, "!PREFIX__infix:sym<//>"
    $P2445."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2446)
    get_how $P2447, type_obj
    .const 'Sub' $P2448 = "361_1303576195.699" 
    $P2447."add_method"(type_obj, "infix:sym<?? !!>", $P2448)
    get_how $P2449, type_obj
    get_global $P2450, "!PREFIX__infix:sym<?? !!>"
    $P2449."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2450)
    get_how $P2451, type_obj
    .const 'Sub' $P2452 = "363_1303576195.699" 
    $P2451."add_method"(type_obj, "infix:sym<=>", $P2452)
    get_how $P2453, type_obj
    get_global $P2454, "!PREFIX__infix:sym<=>"
    $P2453."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2454)
    get_how $P2455, type_obj
    .const 'Sub' $P2456 = "365_1303576195.699" 
    $P2455."add_method"(type_obj, "infix:sym<:=>", $P2456)
    get_how $P2457, type_obj
    get_global $P2458, "!PREFIX__infix:sym<:=>"
    $P2457."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2458)
    get_how $P2459, type_obj
    .const 'Sub' $P2460 = "367_1303576195.699" 
    $P2459."add_method"(type_obj, "infix:sym<::=>", $P2460)
    get_how $P2461, type_obj
    get_global $P2462, "!PREFIX__infix:sym<::=>"
    $P2461."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2462)
    get_how $P2463, type_obj
    .const 'Sub' $P2464 = "369_1303576195.699" 
    $P2463."add_method"(type_obj, "infix:sym<,>", $P2464)
    get_how $P2465, type_obj
    get_global $P2466, "!PREFIX__infix:sym<,>"
    $P2465."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2466)
    get_how $P2467, type_obj
    .const 'Sub' $P2468 = "371_1303576195.699" 
    $P2467."add_method"(type_obj, "prefix:sym<return>", $P2468)
    get_how $P2469, type_obj
    get_global $P2470, "!PREFIX__prefix:sym<return>"
    $P2469."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2470)
    get_how $P2471, type_obj
    .const 'Sub' $P2472 = "374_1303576195.699" 
    $P2471."add_method"(type_obj, "prefix:sym<make>", $P2472)
    get_how $P2473, type_obj
    get_global $P2474, "!PREFIX__prefix:sym<make>"
    $P2473."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2474)
    get_how $P2475, type_obj
    .const 'Sub' $P2476 = "376_1303576195.699" 
    $P2475."add_method"(type_obj, "term:sym<last>", $P2476)
    get_how $P2477, type_obj
    get_global $P2478, "!PREFIX__term:sym<last>"
    $P2477."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2478)
    get_how $P2479, type_obj
    .const 'Sub' $P2480 = "378_1303576195.699" 
    $P2479."add_method"(type_obj, "term:sym<next>", $P2480)
    get_how $P2481, type_obj
    get_global $P2482, "!PREFIX__term:sym<next>"
    $P2481."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2482)
    get_how $P2483, type_obj
    .const 'Sub' $P2484 = "380_1303576195.699" 
    $P2483."add_method"(type_obj, "term:sym<redo>", $P2484)
    get_how $P2485, type_obj
    get_global $P2486, "!PREFIX__term:sym<redo>"
    $P2485."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2486)
    get_how $P2487, type_obj
    .const 'Sub' $P2488 = "382_1303576195.699" 
    $P2487."add_method"(type_obj, "smartmatch", $P2488)
    get_how $P2489, type_obj
    get_hll_global $P2490, ["HLL"], "Grammar"
    $P2489."add_parent"(type_obj, $P2490)
    get_how $P2491, type_obj
    $P2492 = $P2491."compose"(type_obj)
    .return ($P2492)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303576195.699") :outer("12_1303576195.699")
    .param pmc param_56
.annotate 'line', 10
    .lex "self", param_56
.annotate 'line', 12
    $P57 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P57
.annotate 'line', 19
    $P58 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P58
.annotate 'line', 28
    new $P59, "Undef"
    .lex "$*DEFAULT-METAATTR", $P59
.annotate 'line', 29
    $P60 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P60
.annotate 'line', 35
    new $P61, "Undef"
    .lex "$*SC", $P61
.annotate 'line', 39
    new $P62, "Undef"
    .lex "$*SCOPE", $P62
.annotate 'line', 40
    new $P63, "Undef"
    .lex "$*MULTINESS", $P63
.annotate 'line', 41
    new $P64, "Undef"
    .lex "$*INVOCANT_OK", $P64
.annotate 'line', 42
    new $P65, "Undef"
    .lex "$*RETURN_USED", $P65
.annotate 'line', 43
    new $P66, "Undef"
    .lex "$*PACKAGE-SETUP", $P66
.annotate 'line', 10
    find_lex $P67, "%*LANG"
    unless_null $P67, vivify_587
    get_hll_global $P67, "%LANG"
    unless_null $P67, vivify_588
    die "Contextual %*LANG not found"
  vivify_588:
  vivify_587:
.annotate 'line', 13
    get_hll_global $P68, ["NQP"], "Regex"
    find_lex $P69, "%*LANG"
    unless_null $P69, vivify_589
    get_hll_global $P69, "%LANG"
    unless_null $P69, vivify_590
    die "Contextual %*LANG not found"
  vivify_590:
    store_lex "%*LANG", $P69
  vivify_589:
    set $P69["Regex"], $P68
.annotate 'line', 14
    get_hll_global $P70, ["NQP"], "RegexActions"
    find_lex $P71, "%*LANG"
    unless_null $P71, vivify_591
    get_hll_global $P71, "%LANG"
    unless_null $P71, vivify_592
    die "Contextual %*LANG not found"
  vivify_592:
    store_lex "%*LANG", $P71
  vivify_591:
    set $P71["Regex-actions"], $P70
.annotate 'line', 15
    get_hll_global $P72, ["NQP"], "Grammar"
    find_lex $P73, "%*LANG"
    unless_null $P73, vivify_593
    get_hll_global $P73, "%LANG"
    unless_null $P73, vivify_594
    die "Contextual %*LANG not found"
  vivify_594:
    store_lex "%*LANG", $P73
  vivify_593:
    set $P73["MAIN"], $P72
.annotate 'line', 16
    get_hll_global $P74, ["NQP"], "Actions"
    find_lex $P75, "%*LANG"
    unless_null $P75, vivify_595
    get_hll_global $P75, "%LANG"
    unless_null $P75, vivify_596
    die "Contextual %*LANG not found"
  vivify_596:
    store_lex "%*LANG", $P75
  vivify_595:
    set $P75["MAIN-actions"], $P74
    find_lex $P76, "%*HOW"
    unless_null $P76, vivify_597
    get_hll_global $P76, "%HOW"
    unless_null $P76, vivify_598
    die "Contextual %*HOW not found"
  vivify_598:
  vivify_597:
.annotate 'line', 20
    get_hll_global $P77, "KnowHOW"
    find_lex $P78, "%*HOW"
    unless_null $P78, vivify_599
    get_hll_global $P78, "%HOW"
    unless_null $P78, vivify_600
    die "Contextual %*HOW not found"
  vivify_600:
    store_lex "%*HOW", $P78
  vivify_599:
    set $P78["knowhow"], $P77
.annotate 'line', 21
    get_hll_global $P79, "NQPModuleHOW"
    find_lex $P80, "%*HOW"
    unless_null $P80, vivify_601
    get_hll_global $P80, "%HOW"
    unless_null $P80, vivify_602
    die "Contextual %*HOW not found"
  vivify_602:
    store_lex "%*HOW", $P80
  vivify_601:
    set $P80["module"], $P79
.annotate 'line', 22
    get_hll_global $P81, "NQPClassHOW"
    find_lex $P82, "%*HOW"
    unless_null $P82, vivify_603
    get_hll_global $P82, "%HOW"
    unless_null $P82, vivify_604
    die "Contextual %*HOW not found"
  vivify_604:
    store_lex "%*HOW", $P82
  vivify_603:
    set $P82["class"], $P81
.annotate 'line', 23
    get_hll_global $P83, "NQPClassHOW"
    find_lex $P84, "%*HOW"
    unless_null $P84, vivify_605
    get_hll_global $P84, "%HOW"
    unless_null $P84, vivify_606
    die "Contextual %*HOW not found"
  vivify_606:
    store_lex "%*HOW", $P84
  vivify_605:
    set $P84["grammar"], $P83
.annotate 'line', 24
    get_hll_global $P85, "NQPParametricRoleHOW"
    find_lex $P86, "%*HOW"
    unless_null $P86, vivify_607
    get_hll_global $P86, "%HOW"
    unless_null $P86, vivify_608
    die "Contextual %*HOW not found"
  vivify_608:
    store_lex "%*HOW", $P86
  vivify_607:
    set $P86["role"], $P85
.annotate 'line', 25
    get_hll_global $P87, "NQPNativeHOW"
    find_lex $P88, "%*HOW"
    unless_null $P88, vivify_609
    get_hll_global $P88, "%HOW"
    unless_null $P88, vivify_610
    die "Contextual %*HOW not found"
  vivify_610:
    store_lex "%*HOW", $P88
  vivify_609:
    set $P88["native"], $P87
.annotate 'line', 28
    new $P89, "String"
    assign $P89, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P89
    find_lex $P90, "%*HOW-METAATTR"
    unless_null $P90, vivify_611
    get_hll_global $P90, "%HOW-METAATTR"
    unless_null $P90, vivify_612
    die "Contextual %*HOW-METAATTR not found"
  vivify_612:
  vivify_611:
.annotate 'line', 30
    new $P91, "String"
    assign $P91, "KnowHOWAttribute"
    find_lex $P92, "%*HOW-METAATTR"
    unless_null $P92, vivify_613
    get_hll_global $P92, "%HOW-METAATTR"
    unless_null $P92, vivify_614
    die "Contextual %*HOW-METAATTR not found"
  vivify_614:
    store_lex "%*HOW-METAATTR", $P92
  vivify_613:
    set $P92["knowhow"], $P91
.annotate 'line', 35
    get_hll_global $P93, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N94
    set $S95, $N94
    $P96 = $P93."new"($S95 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P96
.annotate 'line', 39
    new $P97, "String"
    assign $P97, ""
    store_lex "$*SCOPE", $P97
.annotate 'line', 40
    new $P98, "String"
    assign $P98, ""
    store_lex "$*MULTINESS", $P98
.annotate 'line', 41
    new $P99, "Integer"
    assign $P99, 0
    store_lex "$*INVOCANT_OK", $P99
.annotate 'line', 42
    new $P100, "Integer"
    assign $P100, 0
    store_lex "$*RETURN_USED", $P100
    find_lex $P101, "$*PACKAGE-SETUP"
    unless_null $P101, vivify_615
    get_hll_global $P101, "$PACKAGE-SETUP"
    unless_null $P101, vivify_616
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_616:
  vivify_615:
.annotate 'line', 44
    find_lex $P102, "self"
    $P103 = $P102."comp_unit"()
.annotate 'line', 10
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx105_tgt
    .local int rx105_pos
    .local int rx105_off
    .local int rx105_eos
    .local int rx105_rep
    .local pmc rx105_cur
    .local pmc rx105_debug
    (rx105_cur, rx105_pos, rx105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx105_cur
    .local pmc match
    .lex "$/", match
    length rx105_eos, rx105_tgt
    gt rx105_pos, rx105_eos, rx105_done
    set rx105_off, 0
    lt rx105_pos, 2, rx105_start
    sub rx105_off, rx105_pos, 1
    substr rx105_tgt, rx105_tgt, rx105_off
  rx105_start:
    eq $I10, 1, rx105_restart
    if_null rx105_debug, debug_617
    rx105_cur."!cursor_debug"("START", "identifier")
  debug_617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan109_done
    goto rxscan109_scan
  rxscan109_loop:
    (rx105_pos) = rx105_cur."from"()
    inc rx105_pos
    rx105_cur."!cursor_from"(rx105_pos)
    ge rx105_pos, rx105_eos, rxscan109_done
  rxscan109_scan:
    set_addr $I10, rxscan109_loop
    rx105_cur."!mark_push"(0, rx105_pos, $I10)
  rxscan109_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx105_cur."!cursor_pos"(rx105_pos)
    $P10 = rx105_cur."ident"()
    unless $P10, rx105_fail
    rx105_pos = $P10."pos"()
  # rx rxquantr110 ** 0..*
    set_addr $I10, rxquantr110_done
    rx105_cur."!mark_push"(0, rx105_pos, $I10)
  rxquantr110_loop:
  # rx enumcharlist negate=0 
    ge rx105_pos, rx105_eos, rx105_fail
    sub $I10, rx105_pos, rx105_off
    substr $S10, rx105_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx105_fail
    inc rx105_pos
  # rx subrule "ident" subtype=method negate=
    rx105_cur."!cursor_pos"(rx105_pos)
    $P10 = rx105_cur."ident"()
    unless $P10, rx105_fail
    rx105_pos = $P10."pos"()
    set_addr $I10, rxquantr110_done
    (rx105_rep) = rx105_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr110_done
    rx105_cur."!mark_push"(rx105_rep, rx105_pos, $I10)
    goto rxquantr110_loop
  rxquantr110_done:
  # rx pass
    rx105_cur."!cursor_pass"(rx105_pos, "identifier")
    if_null rx105_debug, debug_618
    rx105_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx105_pos)
  debug_618:
    .return (rx105_cur)
  rx105_restart:
.annotate 'line', 10
    if_null rx105_debug, debug_619
    rx105_cur."!cursor_debug"("NEXT", "identifier")
  debug_619:
  rx105_fail:
    (rx105_rep, rx105_pos, $I10, $P10) = rx105_cur."!mark_fail"(0)
    lt rx105_pos, -1, rx105_done
    eq rx105_pos, -1, rx105_fail
    jump $I10
  rx105_done:
    rx105_cur."!cursor_fail"()
    if_null rx105_debug, debug_620
    rx105_cur."!cursor_debug"("FAIL", "identifier")
  debug_620:
    .return (rx105_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303576195.699") :method
.annotate 'line', 10
    $P107 = self."!PREFIX__!subrule"("ident", "")
    new $P108, "ResizablePMCArray"
    push $P108, $P107
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx112_tgt
    .local int rx112_pos
    .local int rx112_off
    .local int rx112_eos
    .local int rx112_rep
    .local pmc rx112_cur
    .local pmc rx112_debug
    (rx112_cur, rx112_pos, rx112_tgt, $I10) = self."!cursor_start"()
    rx112_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx112_cur
    .local pmc match
    .lex "$/", match
    length rx112_eos, rx112_tgt
    gt rx112_pos, rx112_eos, rx112_done
    set rx112_off, 0
    lt rx112_pos, 2, rx112_start
    sub rx112_off, rx112_pos, 1
    substr rx112_tgt, rx112_tgt, rx112_off
  rx112_start:
    eq $I10, 1, rx112_restart
    if_null rx112_debug, debug_621
    rx112_cur."!cursor_debug"("START", "name")
  debug_621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan115_done
    goto rxscan115_scan
  rxscan115_loop:
    (rx112_pos) = rx112_cur."from"()
    inc rx112_pos
    rx112_cur."!cursor_from"(rx112_pos)
    ge rx112_pos, rx112_eos, rxscan115_done
  rxscan115_scan:
    set_addr $I10, rxscan115_loop
    rx112_cur."!mark_push"(0, rx112_pos, $I10)
  rxscan115_done:
.annotate 'line', 51
  # rx rxquantr116 ** 1..*
    set_addr $I10, rxquantr116_done
    rx112_cur."!mark_push"(0, -1, $I10)
  rxquantr116_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx112_cur."!cursor_pos"(rx112_pos)
    $P10 = rx112_cur."identifier"()
    unless $P10, rx112_fail
    goto rxsubrule117_pass
  rxsubrule117_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx112_fail
  rxsubrule117_pass:
    set_addr $I10, rxsubrule117_back
    rx112_cur."!mark_push"(0, rx112_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx112_pos = $P10."pos"()
    set_addr $I10, rxquantr116_done
    (rx112_rep) = rx112_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr116_done
    rx112_cur."!mark_push"(rx112_rep, rx112_pos, $I10)
  # rx literal  "::"
    add $I11, rx112_pos, 2
    gt $I11, rx112_eos, rx112_fail
    sub $I11, rx112_pos, rx112_off
    substr $S10, rx112_tgt, $I11, 2
    ne $S10, "::", rx112_fail
    add rx112_pos, 2
    goto rxquantr116_loop
  rxquantr116_done:
  # rx pass
    rx112_cur."!cursor_pass"(rx112_pos, "name")
    if_null rx112_debug, debug_622
    rx112_cur."!cursor_debug"("PASS", "name", " at pos=", rx112_pos)
  debug_622:
    .return (rx112_cur)
  rx112_restart:
.annotate 'line', 10
    if_null rx112_debug, debug_623
    rx112_cur."!cursor_debug"("NEXT", "name")
  debug_623:
  rx112_fail:
    (rx112_rep, rx112_pos, $I10, $P10) = rx112_cur."!mark_fail"(0)
    lt rx112_pos, -1, rx112_done
    eq rx112_pos, -1, rx112_fail
    jump $I10
  rx112_done:
    rx112_cur."!cursor_fail"()
    if_null rx112_debug, debug_624
    rx112_cur."!cursor_debug"("FAIL", "name")
  debug_624:
    .return (rx112_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303576195.699") :method
.annotate 'line', 10
    new $P114, "ResizablePMCArray"
    push $P114, ""
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx119_tgt
    .local int rx119_pos
    .local int rx119_off
    .local int rx119_eos
    .local int rx119_rep
    .local pmc rx119_cur
    .local pmc rx119_debug
    (rx119_cur, rx119_pos, rx119_tgt, $I10) = self."!cursor_start"()
    rx119_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx119_cur
    .local pmc match
    .lex "$/", match
    length rx119_eos, rx119_tgt
    gt rx119_pos, rx119_eos, rx119_done
    set rx119_off, 0
    lt rx119_pos, 2, rx119_start
    sub rx119_off, rx119_pos, 1
    substr rx119_tgt, rx119_tgt, rx119_off
  rx119_start:
    eq $I10, 1, rx119_restart
    if_null rx119_debug, debug_625
    rx119_cur."!cursor_debug"("START", "deflongname")
  debug_625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan123_done
    goto rxscan123_scan
  rxscan123_loop:
    (rx119_pos) = rx119_cur."from"()
    inc rx119_pos
    rx119_cur."!cursor_from"(rx119_pos)
    ge rx119_pos, rx119_eos, rxscan123_done
  rxscan123_scan:
    set_addr $I10, rxscan123_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxscan123_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."identifier"()
    unless $P10, rx119_fail
    rx119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx119_pos = $P10."pos"()
  # rx rxquantr124 ** 0..1
    set_addr $I10, rxquantr124_done
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxquantr124_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."colonpair"()
    unless $P10, rx119_fail
    goto rxsubrule125_pass
  rxsubrule125_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx119_fail
  rxsubrule125_pass:
    set_addr $I10, rxsubrule125_back
    rx119_cur."!mark_push"(0, rx119_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx119_pos = $P10."pos"()
    set_addr $I10, rxquantr124_done
    (rx119_rep) = rx119_cur."!mark_commit"($I10)
  rxquantr124_done:
.annotate 'line', 53
  # rx pass
    rx119_cur."!cursor_pass"(rx119_pos, "deflongname")
    if_null rx119_debug, debug_626
    rx119_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx119_pos)
  debug_626:
    .return (rx119_cur)
  rx119_restart:
.annotate 'line', 10
    if_null rx119_debug, debug_627
    rx119_cur."!cursor_debug"("NEXT", "deflongname")
  debug_627:
  rx119_fail:
    (rx119_rep, rx119_pos, $I10, $P10) = rx119_cur."!mark_fail"(0)
    lt rx119_pos, -1, rx119_done
    eq rx119_pos, -1, rx119_fail
    jump $I10
  rx119_done:
    rx119_cur."!cursor_fail"()
    if_null rx119_debug, debug_628
    rx119_cur."!cursor_debug"("FAIL", "deflongname")
  debug_628:
    .return (rx119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303576195.699") :method
.annotate 'line', 10
    $P121 = self."!PREFIX__!subrule"("identifier", "")
    new $P122, "ResizablePMCArray"
    push $P122, $P121
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx127_tgt
    .local int rx127_pos
    .local int rx127_off
    .local int rx127_eos
    .local int rx127_rep
    .local pmc rx127_cur
    .local pmc rx127_debug
    (rx127_cur, rx127_pos, rx127_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx127_cur
    .local pmc match
    .lex "$/", match
    length rx127_eos, rx127_tgt
    gt rx127_pos, rx127_eos, rx127_done
    set rx127_off, 0
    lt rx127_pos, 2, rx127_start
    sub rx127_off, rx127_pos, 1
    substr rx127_tgt, rx127_tgt, rx127_off
  rx127_start:
    eq $I10, 1, rx127_restart
    if_null rx127_debug, debug_629
    rx127_cur."!cursor_debug"("START", "ENDSTMT")
  debug_629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan130_done
    goto rxscan130_scan
  rxscan130_loop:
    (rx127_pos) = rx127_cur."from"()
    inc rx127_pos
    rx127_cur."!cursor_from"(rx127_pos)
    ge rx127_pos, rx127_eos, rxscan130_done
  rxscan130_scan:
    set_addr $I10, rxscan130_loop
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxscan130_done:
.annotate 'line', 61
  # rx rxquantr131 ** 0..1
    set_addr $I10, rxquantr131_done
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxquantr131_loop:
  alt132_0:
.annotate 'line', 58
    set_addr $I10, alt132_1
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx127_pos, rx127_off
    set rx127_rep, 0
    sub $I12, rx127_eos, rx127_pos
  rxenumcharlistq133_loop:
    le $I12, 0, rxenumcharlistq133_done
    substr $S10, rx127_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq133_done
    inc rx127_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq133_loop
  rxenumcharlistq133_done:
    add rx127_pos, rx127_pos, rx127_rep
  # rxanchor eol
    sub $I10, rx127_pos, rx127_off
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rxanchor134_done
    ne rx127_pos, rx127_eos, rx127_fail
    eq rx127_pos, 0, rxanchor134_done
    dec $I10
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rx127_fail
  rxanchor134_done:
  # rx subrule "ws" subtype=method negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."ws"()
    unless $P10, rx127_fail
    rx127_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."MARKER"("endstmt")
    unless $P10, rx127_fail
    goto alt132_end
  alt132_1:
.annotate 'line', 60
  # rx rxquantr135 ** 0..1
    set_addr $I10, rxquantr135_done
    rx127_cur."!mark_push"(0, rx127_pos, $I10)
  rxquantr135_loop:
  # rx subrule "unv" subtype=method negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."unv"()
    unless $P10, rx127_fail
    goto rxsubrule136_pass
  rxsubrule136_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx127_fail
  rxsubrule136_pass:
    set_addr $I10, rxsubrule136_back
    rx127_cur."!mark_push"(0, rx127_pos, $I10, $P10)
    rx127_pos = $P10."pos"()
    set_addr $I10, rxquantr135_done
    (rx127_rep) = rx127_cur."!mark_commit"($I10)
  rxquantr135_done:
  # rxanchor eol
    sub $I10, rx127_pos, rx127_off
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rxanchor137_done
    ne rx127_pos, rx127_eos, rx127_fail
    eq rx127_pos, 0, rxanchor137_done
    dec $I10
    is_cclass $I11, 4096, rx127_tgt, $I10
    if $I11, rx127_fail
  rxanchor137_done:
  # rx subrule "ws" subtype=method negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."ws"()
    unless $P10, rx127_fail
    rx127_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx127_cur."!cursor_pos"(rx127_pos)
    $P10 = rx127_cur."MARKER"("endstmt")
    unless $P10, rx127_fail
  alt132_end:
.annotate 'line', 61
    set_addr $I10, rxquantr131_done
    (rx127_rep) = rx127_cur."!mark_commit"($I10)
  rxquantr131_done:
.annotate 'line', 57
  # rx pass
    rx127_cur."!cursor_pass"(rx127_pos, "ENDSTMT")
    if_null rx127_debug, debug_630
    rx127_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx127_pos)
  debug_630:
    .return (rx127_cur)
  rx127_restart:
.annotate 'line', 10
    if_null rx127_debug, debug_631
    rx127_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_631:
  rx127_fail:
    (rx127_rep, rx127_pos, $I10, $P10) = rx127_cur."!mark_fail"(0)
    lt rx127_pos, -1, rx127_done
    eq rx127_pos, -1, rx127_fail
    jump $I10
  rx127_done:
    rx127_cur."!cursor_fail"()
    if_null rx127_debug, debug_632
    rx127_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_632:
    .return (rx127_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303576195.699") :method
.annotate 'line', 10
    new $P129, "ResizablePMCArray"
    push $P129, ""
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx139_tgt
    .local int rx139_pos
    .local int rx139_off
    .local int rx139_eos
    .local int rx139_rep
    .local pmc rx139_cur
    .local pmc rx139_debug
    (rx139_cur, rx139_pos, rx139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx139_cur
    .local pmc match
    .lex "$/", match
    length rx139_eos, rx139_tgt
    gt rx139_pos, rx139_eos, rx139_done
    set rx139_off, 0
    lt rx139_pos, 2, rx139_start
    sub rx139_off, rx139_pos, 1
    substr rx139_tgt, rx139_tgt, rx139_off
  rx139_start:
    eq $I10, 1, rx139_restart
    if_null rx139_debug, debug_633
    rx139_cur."!cursor_debug"("START", "ws")
  debug_633:
    $I10 = self.'from'()
    ne $I10, -1, rxscan142_done
    goto rxscan142_scan
  rxscan142_loop:
    (rx139_pos) = rx139_cur."from"()
    inc rx139_pos
    rx139_cur."!cursor_from"(rx139_pos)
    ge rx139_pos, rx139_eos, rxscan142_done
  rxscan142_scan:
    set_addr $I10, rxscan142_loop
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxscan142_done:
  alt143_0:
.annotate 'line', 64
    set_addr $I10, alt143_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."MARKED"("ws")
    unless $P10, rx139_fail
    goto alt143_end
  alt143_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."ww"()
    if $P10, rx139_fail
.annotate 'line', 71
  # rx rxquantr144 ** 0..*
    set_addr $I10, rxquantr144_done
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxquantr144_loop:
  alt145_0:
.annotate 'line', 67
    set_addr $I10, alt145_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq146_loop:
    le $I12, 0, rxenumcharlistq146_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq146_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq146_loop
  rxenumcharlistq146_done:
    lt rx139_rep, 1, rx139_fail
    add rx139_pos, rx139_pos, rx139_rep
    goto alt145_end
  alt145_1:
    set_addr $I10, alt145_2
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 35, rx139_fail
    add rx139_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx139_pos, rx139_off
    find_cclass $I11, 4096, rx139_tgt, $I10, rx139_eos
    add rx139_pos, rx139_off, $I11
    goto alt145_end
  alt145_2:
    set_addr $I10, alt145_3
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx139_pos, 0, rxanchor147_done
    ge rx139_pos, rx139_eos, rx139_fail
    sub $I10, rx139_pos, rx139_off
    dec $I10
    is_cclass $I11, 4096, rx139_tgt, $I10
    unless $I11, rx139_fail
  rxanchor147_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."pod_comment"()
    unless $P10, rx139_fail
    rx139_pos = $P10."pos"()
    goto alt145_end
  alt145_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq148_loop:
    le $I12, 0, rxenumcharlistq148_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq148_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq148_loop
  rxenumcharlistq148_done:
    lt rx139_rep, 1, rx139_fail
    add rx139_pos, rx139_pos, rx139_rep
  alt145_end:
.annotate 'line', 71
    set_addr $I10, rxquantr144_done
    (rx139_rep) = rx139_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr144_done
    rx139_cur."!mark_push"(rx139_rep, rx139_pos, $I10)
    goto rxquantr144_loop
  rxquantr144_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx139_cur."!cursor_pos"(rx139_pos)
    $P10 = rx139_cur."MARKER"("ws")
    unless $P10, rx139_fail
  alt143_end:
.annotate 'line', 64
  # rx pass
    rx139_cur."!cursor_pass"(rx139_pos, "ws")
    if_null rx139_debug, debug_634
    rx139_cur."!cursor_debug"("PASS", "ws", " at pos=", rx139_pos)
  debug_634:
    .return (rx139_cur)
  rx139_restart:
.annotate 'line', 10
    if_null rx139_debug, debug_635
    rx139_cur."!cursor_debug"("NEXT", "ws")
  debug_635:
  rx139_fail:
    (rx139_rep, rx139_pos, $I10, $P10) = rx139_cur."!mark_fail"(0)
    lt rx139_pos, -1, rx139_done
    eq rx139_pos, -1, rx139_fail
    jump $I10
  rx139_done:
    rx139_cur."!cursor_fail"()
    if_null rx139_debug, debug_636
    rx139_cur."!cursor_debug"("FAIL", "ws")
  debug_636:
    .return (rx139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303576195.699") :method
.annotate 'line', 10
    new $P141, "ResizablePMCArray"
    push $P141, ""
    push $P141, ""
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P157 = "26_1303576195.699" 
    capture_lex $P157
    .local string rx150_tgt
    .local int rx150_pos
    .local int rx150_off
    .local int rx150_eos
    .local int rx150_rep
    .local pmc rx150_cur
    .local pmc rx150_debug
    (rx150_cur, rx150_pos, rx150_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx150_cur
    .local pmc match
    .lex "$/", match
    length rx150_eos, rx150_tgt
    gt rx150_pos, rx150_eos, rx150_done
    set rx150_off, 0
    lt rx150_pos, 2, rx150_start
    sub rx150_off, rx150_pos, 1
    substr rx150_tgt, rx150_tgt, rx150_off
  rx150_start:
    eq $I10, 1, rx150_restart
    if_null rx150_debug, debug_637
    rx150_cur."!cursor_debug"("START", "unv")
  debug_637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan153_done
    goto rxscan153_scan
  rxscan153_loop:
    (rx150_pos) = rx150_cur."from"()
    inc rx150_pos
    rx150_cur."!cursor_from"(rx150_pos)
    ge rx150_pos, rx150_eos, rxscan153_done
  rxscan153_scan:
    set_addr $I10, rxscan153_loop
    rx150_cur."!mark_push"(0, rx150_pos, $I10)
  rxscan153_done:
  alt154_0:
.annotate 'line', 77
    set_addr $I10, alt154_1
    rx150_cur."!mark_push"(0, rx150_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx150_pos, 0, rxanchor155_done
    ge rx150_pos, rx150_eos, rx150_fail
    sub $I10, rx150_pos, rx150_off
    dec $I10
    is_cclass $I11, 4096, rx150_tgt, $I10
    unless $I11, rx150_fail
  rxanchor155_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx150_cur."!cursor_pos"(rx150_pos)
    .const 'Sub' $P157 = "26_1303576195.699" 
    capture_lex $P157
    $P10 = rx150_cur."before"($P157)
    unless $P10, rx150_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx150_cur."!cursor_pos"(rx150_pos)
    $P10 = rx150_cur."pod_comment"()
    unless $P10, rx150_fail
    rx150_pos = $P10."pos"()
    goto alt154_end
  alt154_1:
    set_addr $I10, alt154_2
    rx150_cur."!mark_push"(0, rx150_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx150_pos, rx150_off
    set rx150_rep, 0
    sub $I12, rx150_eos, rx150_pos
  rxenumcharlistq162_loop:
    le $I12, 0, rxenumcharlistq162_done
    substr $S10, rx150_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq162_done
    inc rx150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq162_loop
  rxenumcharlistq162_done:
    add rx150_pos, rx150_pos, rx150_rep
  # rx literal  "#"
    add $I11, rx150_pos, 1
    gt $I11, rx150_eos, rx150_fail
    sub $I11, rx150_pos, rx150_off
    ord $I11, rx150_tgt, $I11
    ne $I11, 35, rx150_fail
    add rx150_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx150_pos, rx150_off
    find_cclass $I11, 4096, rx150_tgt, $I10, rx150_eos
    add rx150_pos, rx150_off, $I11
    goto alt154_end
  alt154_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx150_pos, rx150_off
    set rx150_rep, 0
    sub $I12, rx150_eos, rx150_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx150_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx150_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    lt rx150_rep, 1, rx150_fail
    add rx150_pos, rx150_pos, rx150_rep
  alt154_end:
.annotate 'line', 75
  # rx pass
    rx150_cur."!cursor_pass"(rx150_pos, "unv")
    if_null rx150_debug, debug_642
    rx150_cur."!cursor_debug"("PASS", "unv", " at pos=", rx150_pos)
  debug_642:
    .return (rx150_cur)
  rx150_restart:
.annotate 'line', 10
    if_null rx150_debug, debug_643
    rx150_cur."!cursor_debug"("NEXT", "unv")
  debug_643:
  rx150_fail:
    (rx150_rep, rx150_pos, $I10, $P10) = rx150_cur."!mark_fail"(0)
    lt rx150_pos, -1, rx150_done
    eq rx150_pos, -1, rx150_fail
    jump $I10
  rx150_done:
    rx150_cur."!cursor_fail"()
    if_null rx150_debug, debug_644
    rx150_cur."!cursor_debug"("FAIL", "unv")
  debug_644:
    .return (rx150_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303576195.699") :method
.annotate 'line', 10
    new $P152, "ResizablePMCArray"
    push $P152, ""
    push $P152, ""
    push $P152, ""
    .return ($P152)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block156"  :anon :subid("26_1303576195.699") :method :outer("24_1303576195.699")
.annotate 'line', 78
    .local string rx158_tgt
    .local int rx158_pos
    .local int rx158_off
    .local int rx158_eos
    .local int rx158_rep
    .local pmc rx158_cur
    .local pmc rx158_debug
    (rx158_cur, rx158_pos, rx158_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx158_cur
    .local pmc match
    .lex "$/", match
    length rx158_eos, rx158_tgt
    gt rx158_pos, rx158_eos, rx158_done
    set rx158_off, 0
    lt rx158_pos, 2, rx158_start
    sub rx158_off, rx158_pos, 1
    substr rx158_tgt, rx158_tgt, rx158_off
  rx158_start:
    eq $I10, 1, rx158_restart
    if_null rx158_debug, debug_638
    rx158_cur."!cursor_debug"("START", "")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan159_done
    goto rxscan159_scan
  rxscan159_loop:
    (rx158_pos) = rx158_cur."from"()
    inc rx158_pos
    rx158_cur."!cursor_from"(rx158_pos)
    ge rx158_pos, rx158_eos, rxscan159_done
  rxscan159_scan:
    set_addr $I10, rxscan159_loop
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  rxscan159_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx158_pos, rx158_off
    set rx158_rep, 0
    sub $I12, rx158_eos, rx158_pos
  rxenumcharlistq160_loop:
    le $I12, 0, rxenumcharlistq160_done
    substr $S10, rx158_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq160_done
    inc rx158_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq160_loop
  rxenumcharlistq160_done:
    add rx158_pos, rx158_pos, rx158_rep
  # rx literal  "="
    add $I11, rx158_pos, 1
    gt $I11, rx158_eos, rx158_fail
    sub $I11, rx158_pos, rx158_off
    ord $I11, rx158_tgt, $I11
    ne $I11, 61, rx158_fail
    add rx158_pos, 1
  alt161_0:
    set_addr $I10, alt161_1
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  # rx charclass w
    ge rx158_pos, rx158_eos, rx158_fail
    sub $I10, rx158_pos, rx158_off
    is_cclass $I11, 8192, rx158_tgt, $I10
    unless $I11, rx158_fail
    inc rx158_pos
    goto alt161_end
  alt161_1:
  # rx literal  "\\"
    add $I11, rx158_pos, 1
    gt $I11, rx158_eos, rx158_fail
    sub $I11, rx158_pos, rx158_off
    ord $I11, rx158_tgt, $I11
    ne $I11, 92, rx158_fail
    add rx158_pos, 1
  alt161_end:
  # rx pass
    rx158_cur."!cursor_pass"(rx158_pos, "")
    if_null rx158_debug, debug_639
    rx158_cur."!cursor_debug"("PASS", "", " at pos=", rx158_pos)
  debug_639:
    .return (rx158_cur)
  rx158_restart:
    if_null rx158_debug, debug_640
    rx158_cur."!cursor_debug"("NEXT", "")
  debug_640:
  rx158_fail:
    (rx158_rep, rx158_pos, $I10, $P10) = rx158_cur."!mark_fail"(0)
    lt rx158_pos, -1, rx158_done
    eq rx158_pos, -1, rx158_fail
    jump $I10
  rx158_done:
    rx158_cur."!cursor_fail"()
    if_null rx158_debug, debug_641
    rx158_cur."!cursor_debug"("FAIL", "")
  debug_641:
    .return (rx158_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P196 = "29_1303576195.699" 
    capture_lex $P196
    .local string rx165_tgt
    .local int rx165_pos
    .local int rx165_off
    .local int rx165_eos
    .local int rx165_rep
    .local pmc rx165_cur
    .local pmc rx165_debug
    (rx165_cur, rx165_pos, rx165_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx165_cur
    .local pmc match
    .lex "$/", match
    length rx165_eos, rx165_tgt
    gt rx165_pos, rx165_eos, rx165_done
    set rx165_off, 0
    lt rx165_pos, 2, rx165_start
    sub rx165_off, rx165_pos, 1
    substr rx165_tgt, rx165_tgt, rx165_off
  rx165_start:
    eq $I10, 1, rx165_restart
    if_null rx165_debug, debug_645
    rx165_cur."!cursor_debug"("START", "pod_comment")
  debug_645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan168_done
    goto rxscan168_scan
  rxscan168_loop:
    (rx165_pos) = rx165_cur."from"()
    inc rx165_pos
    rx165_cur."!cursor_from"(rx165_pos)
    ge rx165_pos, rx165_eos, rxscan168_done
  rxscan168_scan:
    set_addr $I10, rxscan168_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  rxscan168_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx165_pos, 0, rxanchor169_done
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    dec $I10
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
  rxanchor169_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq170_loop:
    le $I12, 0, rxenumcharlistq170_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq170_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq170_loop
  rxenumcharlistq170_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "="
    add $I11, rx165_pos, 1
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    ord $I11, rx165_tgt, $I11
    ne $I11, 61, rx165_fail
    add rx165_pos, 1
  alt171_0:
.annotate 'line', 86
    set_addr $I10, alt171_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx165_pos, 5
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 5
    ne $S10, "begin", rx165_fail
    add rx165_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq172_loop:
    le $I12, 0, rxenumcharlistq172_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq172_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq172_loop
  rxenumcharlistq172_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "END"
    add $I11, rx165_pos, 3
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 3
    ne $S10, "END", rx165_fail
    add rx165_pos, 3
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  alt173_0:
.annotate 'line', 88
    set_addr $I10, alt173_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rx rxquantf174 ** 0..*
    set_addr $I10, rxquantf174_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf174_done
  rxquantf174_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf174_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf174_done:
  # rx charclass nl
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
    substr $S10, rx165_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx165_pos, $I11
    inc rx165_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq176_loop:
    le $I12, 0, rxenumcharlistq176_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq176_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq176_loop
  rxenumcharlistq176_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "=end"
    add $I11, rx165_pos, 4
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 4
    ne $S10, "=end", rx165_fail
    add rx165_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq177_loop:
    le $I12, 0, rxenumcharlistq177_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq177_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq177_loop
  rxenumcharlistq177_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "END"
    add $I11, rx165_pos, 3
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 3
    ne $S10, "END", rx165_fail
    add rx165_pos, 3
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
    goto alt173_end
  alt173_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_not_cclass $I11, 65535, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
  alt173_end:
.annotate 'line', 87
    goto alt171_end
  alt171_1:
    set_addr $I10, alt171_2
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx165_pos, 5
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 5
    ne $S10, "begin", rx165_fail
    add rx165_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq178_loop:
    le $I12, 0, rxenumcharlistq178_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq178_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq178_loop
  rxenumcharlistq178_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx subrule "identifier" subtype=capture negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."identifier"()
    unless $P10, rx165_fail
    rx165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx165_pos = $P10."pos"()
  alt179_0:
.annotate 'line', 90
    set_addr $I10, alt179_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 91
  # rx rxquantf180 ** 0..*
    set_addr $I10, rxquantf180_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf180_done
  rxquantf180_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf180_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf180_done:
  # rx charclass nl
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
    substr $S10, rx165_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx165_pos, $I11
    inc rx165_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq182_loop:
    le $I12, 0, rxenumcharlistq182_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq182_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq182_loop
  rxenumcharlistq182_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "=end"
    add $I11, rx165_pos, 4
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 4
    ne $S10, "=end", rx165_fail
    add rx165_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq183_loop:
    le $I12, 0, rxenumcharlistq183_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq183_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq183_loop
  rxenumcharlistq183_done:
    lt rx165_rep, 1, rx165_fail
    add rx165_pos, rx165_pos, rx165_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."!BACKREF"("identifier")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
    goto alt179_end
  alt179_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("=begin without matching =end")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt179_end:
.annotate 'line', 89
    goto alt171_end
  alt171_2:
    set_addr $I10, alt171_3
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx165_pos, 5
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 5
    ne $S10, "begin", rx165_fail
    add rx165_pos, 5
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq185_loop:
    le $I12, 0, rxenumcharlistq185_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq185_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq185_loop
  rxenumcharlistq185_done:
    add rx165_pos, rx165_pos, rx165_rep
  alt186_0:
.annotate 'line', 95
    set_addr $I10, alt186_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rxanchor eol
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    if $I11, rxanchor187_done
    ne rx165_pos, rx165_eos, rx165_fail
    eq rx165_pos, 0, rxanchor187_done
    dec $I10
    is_cclass $I11, 4096, rx165_tgt, $I10
    if $I11, rx165_fail
  rxanchor187_done:
    goto alt186_end
  alt186_1:
    set_addr $I10, alt186_2
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rx literal  "#"
    add $I11, rx165_pos, 1
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    ord $I11, rx165_tgt, $I11
    ne $I11, 35, rx165_fail
    add rx165_pos, 1
    goto alt186_end
  alt186_2:
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt186_end:
  alt188_0:
.annotate 'line', 96
    set_addr $I10, alt188_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 97
  # rx rxquantf189 ** 0..*
    set_addr $I10, rxquantf189_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf189_done
  rxquantf189_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf189_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf189_done:
  # rx charclass nl
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
    substr $S10, rx165_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx165_pos, $I11
    inc rx165_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx165_pos, rx165_off
    set rx165_rep, 0
    sub $I12, rx165_eos, rx165_pos
  rxenumcharlistq191_loop:
    le $I12, 0, rxenumcharlistq191_done
    substr $S10, rx165_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq191_done
    inc rx165_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq191_loop
  rxenumcharlistq191_done:
    add rx165_pos, rx165_pos, rx165_rep
  # rx literal  "=end"
    add $I11, rx165_pos, 4
    gt $I11, rx165_eos, rx165_fail
    sub $I11, rx165_pos, rx165_off
    substr $S10, rx165_tgt, $I11, 4
    ne $S10, "=end", rx165_fail
    add rx165_pos, 4
  # rxanchor rwb
    le rx165_pos, 0, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 8192, rx165_tgt, $I10
    if $I11, rx165_fail
    dec $I10
    is_cclass $I11, 8192, rx165_tgt, $I10
    unless $I11, rx165_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
    goto alt188_end
  alt188_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("=begin without matching =end")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt188_end:
.annotate 'line', 94
    goto alt171_end
  alt171_3:
    set_addr $I10, alt171_4
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."identifier"()
    unless $P10, rx165_fail
    rx165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx165_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf192 ** 0..*
    set_addr $I10, rxquantf192_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
    goto rxquantf192_done
  rxquantf192_loop:
  # rx charclass .
    ge rx165_pos, rx165_eos, rx165_fail
    inc rx165_pos
    set_addr $I10, rxquantf192_loop
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
  rxquantf192_done:
  # rxanchor bol
    eq rx165_pos, 0, rxanchor194_done
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    dec $I10
    is_cclass $I11, 4096, rx165_tgt, $I10
    unless $I11, rx165_fail
  rxanchor194_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    .const 'Sub' $P196 = "29_1303576195.699" 
    capture_lex $P196
    $P10 = rx165_cur."before"($P196)
    unless $P10, rx165_fail
.annotate 'line', 100
    goto alt171_end
  alt171_4:
  alt202_0:
.annotate 'line', 107
    set_addr $I10, alt202_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  # rx charclass s
    ge rx165_pos, rx165_eos, rx165_fail
    sub $I10, rx165_pos, rx165_off
    is_cclass $I11, 32, rx165_tgt, $I10
    unless $I11, rx165_fail
    inc rx165_pos
    goto alt202_end
  alt202_1:
  # rx subrule "panic" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."panic"("Illegal pod directive")
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt202_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx165_pos, rx165_off
    find_cclass $I11, 4096, rx165_tgt, $I10, rx165_eos
    add rx165_pos, rx165_off, $I11
  alt171_end:
.annotate 'line', 84
  # rx pass
    rx165_cur."!cursor_pass"(rx165_pos, "pod_comment")
    if_null rx165_debug, debug_650
    rx165_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx165_pos)
  debug_650:
    .return (rx165_cur)
  rx165_restart:
.annotate 'line', 10
    if_null rx165_debug, debug_651
    rx165_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_651:
  rx165_fail:
    (rx165_rep, rx165_pos, $I10, $P10) = rx165_cur."!mark_fail"(0)
    lt rx165_pos, -1, rx165_done
    eq rx165_pos, -1, rx165_fail
    jump $I10
  rx165_done:
    rx165_cur."!cursor_fail"()
    if_null rx165_debug, debug_652
    rx165_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_652:
    .return (rx165_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303576195.699") :method
.annotate 'line', 10
    new $P167, "ResizablePMCArray"
    push $P167, ""
    .return ($P167)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block195"  :anon :subid("29_1303576195.699") :method :outer("27_1303576195.699")
.annotate 'line', 101
    .local string rx197_tgt
    .local int rx197_pos
    .local int rx197_off
    .local int rx197_eos
    .local int rx197_rep
    .local pmc rx197_cur
    .local pmc rx197_debug
    (rx197_cur, rx197_pos, rx197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx197_cur
    .local pmc match
    .lex "$/", match
    length rx197_eos, rx197_tgt
    gt rx197_pos, rx197_eos, rx197_done
    set rx197_off, 0
    lt rx197_pos, 2, rx197_start
    sub rx197_off, rx197_pos, 1
    substr rx197_tgt, rx197_tgt, rx197_off
  rx197_start:
    eq $I10, 1, rx197_restart
    if_null rx197_debug, debug_646
    rx197_cur."!cursor_debug"("START", "")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan198_done
    goto rxscan198_scan
  rxscan198_loop:
    (rx197_pos) = rx197_cur."from"()
    inc rx197_pos
    rx197_cur."!cursor_from"(rx197_pos)
    ge rx197_pos, rx197_eos, rxscan198_done
  rxscan198_scan:
    set_addr $I10, rxscan198_loop
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  rxscan198_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx197_pos, rx197_off
    set rx197_rep, 0
    sub $I12, rx197_eos, rx197_pos
  rxenumcharlistq199_loop:
    le $I12, 0, rxenumcharlistq199_done
    substr $S10, rx197_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq199_done
    inc rx197_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq199_loop
  rxenumcharlistq199_done:
    add rx197_pos, rx197_pos, rx197_rep
  alt200_0:
    set_addr $I10, alt200_1
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx197_pos, 1
    gt $I11, rx197_eos, rx197_fail
    sub $I11, rx197_pos, rx197_off
    ord $I11, rx197_tgt, $I11
    ne $I11, 61, rx197_fail
    add rx197_pos, 1
.annotate 'line', 104
  # rx rxquantr201 ** 0..1
    set_addr $I10, rxquantr201_done
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  rxquantr201_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx197_pos, 3
    gt $I11, rx197_eos, rx197_fail
    sub $I11, rx197_pos, rx197_off
    substr $S10, rx197_tgt, $I11, 3
    ne $S10, "cut", rx197_fail
    add rx197_pos, 3
  # rxanchor rwb
    le rx197_pos, 0, rx197_fail
    sub $I10, rx197_pos, rx197_off
    is_cclass $I11, 8192, rx197_tgt, $I10
    if $I11, rx197_fail
    dec $I10
    is_cclass $I11, 8192, rx197_tgt, $I10
    unless $I11, rx197_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx197_cur."!cursor_pos"(rx197_pos)
    $P10 = rx197_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx197_fail
    rx197_pos = $P10."pos"()
    set_addr $I10, rxquantr201_done
    (rx197_rep) = rx197_cur."!mark_commit"($I10)
  rxquantr201_done:
.annotate 'line', 101
    goto alt200_end
  alt200_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx197_pos, rx197_eos, rx197_fail
    sub $I10, rx197_pos, rx197_off
    is_cclass $I11, 4096, rx197_tgt, $I10
    unless $I11, rx197_fail
    substr $S10, rx197_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx197_pos, $I11
    inc rx197_pos
  alt200_end:
.annotate 'line', 101
  # rx pass
    rx197_cur."!cursor_pass"(rx197_pos, "")
    if_null rx197_debug, debug_647
    rx197_cur."!cursor_debug"("PASS", "", " at pos=", rx197_pos)
  debug_647:
    .return (rx197_cur)
  rx197_restart:
    if_null rx197_debug, debug_648
    rx197_cur."!cursor_debug"("NEXT", "")
  debug_648:
  rx197_fail:
    (rx197_rep, rx197_pos, $I10, $P10) = rx197_cur."!mark_fail"(0)
    lt rx197_pos, -1, rx197_done
    eq rx197_pos, -1, rx197_fail
    jump $I10
  rx197_done:
    rx197_cur."!cursor_fail"()
    if_null rx197_debug, debug_649
    rx197_cur."!cursor_debug"("FAIL", "")
  debug_649:
    .return (rx197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 116
    new $P204, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P204
.annotate 'line', 117
    new $P205, "Undef"
    .lex "$*MAIN_SUB", $P205
.annotate 'line', 121
    new $P206, "Undef"
    .lex "$*PACKAGE", $P206
.annotate 'line', 122
    new $P207, "Undef"
    .lex "$*GLOBALish", $P207
.annotate 'line', 10
    .local string rx208_tgt
    .local int rx208_pos
    .local int rx208_off
    .local int rx208_eos
    .local int rx208_rep
    .local pmc rx208_cur
    .local pmc rx208_debug
    (rx208_cur, rx208_pos, rx208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx208_cur
    .local pmc match
    .lex "$/", match
    length rx208_eos, rx208_tgt
    gt rx208_pos, rx208_eos, rx208_done
    set rx208_off, 0
    lt rx208_pos, 2, rx208_start
    sub rx208_off, rx208_pos, 1
    substr rx208_tgt, rx208_tgt, rx208_off
  rx208_start:
    eq $I10, 1, rx208_restart
    if_null rx208_debug, debug_653
    rx208_cur."!cursor_debug"("START", "comp_unit")
  debug_653:
    $I10 = self.'from'()
    ne $I10, -1, rxscan212_done
    goto rxscan212_scan
  rxscan212_loop:
    (rx208_pos) = rx208_cur."from"()
    inc rx208_pos
    rx208_cur."!cursor_from"(rx208_pos)
    ge rx208_pos, rx208_eos, rxscan212_done
  rxscan212_scan:
    set_addr $I10, rxscan212_loop
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxscan212_done:
.annotate 'line', 116
    rx208_cur."!cursor_pos"(rx208_pos)
    new $P213, "Integer"
    assign $P213, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P213
.annotate 'line', 117
    rx208_cur."!cursor_pos"(rx208_pos)
    find_lex $P214, "$*MAIN_SUB"
    unless_null $P214, vivify_654
    get_hll_global $P214, "$MAIN_SUB"
    unless_null $P214, vivify_655
    die "Contextual $*MAIN_SUB not found"
  vivify_655:
  vivify_654:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."newpad"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."outerctx"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 121
    rx208_cur."!cursor_pos"(rx208_pos)
    find_lex $P215, "$*PACKAGE"
    unless_null $P215, vivify_656
    get_hll_global $P215, "$PACKAGE"
    unless_null $P215, vivify_657
    die "Contextual $*PACKAGE not found"
  vivify_657:
  vivify_656:
.annotate 'line', 122
    rx208_cur."!cursor_pos"(rx208_pos)
    find_lex $P216, "$*GLOBALish"
    unless_null $P216, vivify_658
    get_hll_global $P216, "$GLOBALish"
    unless_null $P216, vivify_659
    die "Contextual $*GLOBALish not found"
  vivify_659:
  vivify_658:
.annotate 'line', 123
  # rx subrule "GLOBALish" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."GLOBALish"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 125
  # rx subrule "statementlist" subtype=capture negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."statementlist"()
    unless $P10, rx208_fail
    rx208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx208_pos = $P10."pos"()
  alt217_0:
.annotate 'line', 126
    set_addr $I10, alt217_1
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  # rxanchor eos
    ne rx208_pos, rx208_eos, rx208_fail
    goto alt217_end
  alt217_1:
  # rx subrule "panic" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."panic"("Confused")
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  alt217_end:
.annotate 'line', 115
  # rx pass
    rx208_cur."!cursor_pass"(rx208_pos, "comp_unit")
    if_null rx208_debug, debug_660
    rx208_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx208_pos)
  debug_660:
    .return (rx208_cur)
  rx208_restart:
.annotate 'line', 10
    if_null rx208_debug, debug_661
    rx208_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_661:
  rx208_fail:
    (rx208_rep, rx208_pos, $I10, $P10) = rx208_cur."!mark_fail"(0)
    lt rx208_pos, -1, rx208_done
    eq rx208_pos, -1, rx208_fail
    jump $I10
  rx208_done:
    rx208_cur."!cursor_fail"()
    if_null rx208_debug, debug_662
    rx208_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_662:
    .return (rx208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303576195.699") :method
.annotate 'line', 10
    $P210 = self."!PREFIX__!subrule"("newpad", "")
    new $P211, "ResizablePMCArray"
    push $P211, $P210
    .return ($P211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx219_tgt
    .local int rx219_pos
    .local int rx219_off
    .local int rx219_eos
    .local int rx219_rep
    .local pmc rx219_cur
    .local pmc rx219_debug
    (rx219_cur, rx219_pos, rx219_tgt, $I10) = self."!cursor_start"()
    rx219_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx219_cur
    .local pmc match
    .lex "$/", match
    length rx219_eos, rx219_tgt
    gt rx219_pos, rx219_eos, rx219_done
    set rx219_off, 0
    lt rx219_pos, 2, rx219_start
    sub rx219_off, rx219_pos, 1
    substr rx219_tgt, rx219_tgt, rx219_off
  rx219_start:
    eq $I10, 1, rx219_restart
    if_null rx219_debug, debug_663
    rx219_cur."!cursor_debug"("START", "statementlist")
  debug_663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan224_done
    goto rxscan224_scan
  rxscan224_loop:
    (rx219_pos) = rx219_cur."from"()
    inc rx219_pos
    rx219_cur."!cursor_from"(rx219_pos)
    ge rx219_pos, rx219_eos, rxscan224_done
  rxscan224_scan:
    set_addr $I10, rxscan224_loop
    rx219_cur."!mark_push"(0, rx219_pos, $I10)
  rxscan224_done:
  alt225_0:
.annotate 'line', 129
    set_addr $I10, alt225_1
    rx219_cur."!mark_push"(0, rx219_pos, $I10)
.annotate 'line', 130
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  # rxanchor eos
    ne rx219_pos, rx219_eos, rx219_fail
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
    goto alt225_end
  alt225_1:
.annotate 'line', 131
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  # rx rxquantr229 ** 0..*
    set_addr $I10, rxquantr229_done
    rx219_cur."!mark_push"(0, rx219_pos, $I10)
  rxquantr229_loop:
  # rx subrule "statement" subtype=capture negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."statement"()
    unless $P10, rx219_fail
    rx219_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx219_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."eat_terminator"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
    set_addr $I10, rxquantr229_done
    (rx219_rep) = rx219_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr229_done
    rx219_cur."!mark_push"(rx219_rep, rx219_pos, $I10)
    goto rxquantr229_loop
  rxquantr229_done:
  # rx subrule "ws" subtype=method negate=
    rx219_cur."!cursor_pos"(rx219_pos)
    $P10 = rx219_cur."ws"()
    unless $P10, rx219_fail
    rx219_pos = $P10."pos"()
  alt225_end:
.annotate 'line', 129
  # rx pass
    rx219_cur."!cursor_pass"(rx219_pos, "statementlist")
    if_null rx219_debug, debug_664
    rx219_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx219_pos)
  debug_664:
    .return (rx219_cur)
  rx219_restart:
.annotate 'line', 10
    if_null rx219_debug, debug_665
    rx219_cur."!cursor_debug"("NEXT", "statementlist")
  debug_665:
  rx219_fail:
    (rx219_rep, rx219_pos, $I10, $P10) = rx219_cur."!mark_fail"(0)
    lt rx219_pos, -1, rx219_done
    eq rx219_pos, -1, rx219_fail
    jump $I10
  rx219_done:
    rx219_cur."!cursor_fail"()
    if_null rx219_debug, debug_666
    rx219_cur."!cursor_debug"("FAIL", "statementlist")
  debug_666:
    .return (rx219_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303576195.699") :method
.annotate 'line', 10
    $P221 = self."!PREFIX__!subrule"("ws", "")
    $P222 = self."!PREFIX__!subrule"("ws", "")
    new $P223, "ResizablePMCArray"
    push $P223, $P221
    push $P223, $P222
    .return ($P223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P238 = "36_1303576195.699" 
    capture_lex $P238
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    rx233_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_667
    rx233_cur."!cursor_debug"("START", "statement")
  debug_667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan236_done
    goto rxscan236_scan
  rxscan236_loop:
    (rx233_pos) = rx233_cur."from"()
    inc rx233_pos
    rx233_cur."!cursor_from"(rx233_pos)
    ge rx233_pos, rx233_eos, rxscan236_done
  rxscan236_scan:
    set_addr $I10, rxscan236_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan236_done:
.annotate 'line', 135
  # rx subrule "before" subtype=zerowidth negate=1
    rx233_cur."!cursor_pos"(rx233_pos)
    .const 'Sub' $P238 = "36_1303576195.699" 
    capture_lex $P238
    $P10 = rx233_cur."before"($P238)
    if $P10, rx233_fail
  alt242_0:
.annotate 'line', 136
    set_addr $I10, alt242_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_control" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_control"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx233_pos = $P10."pos"()
    goto alt242_end
  alt242_1:
.annotate 'line', 138
  # rx subrule "EXPR" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."EXPR"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx233_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."ws"()
    unless $P10, rx233_fail
    rx233_pos = $P10."pos"()
.annotate 'line', 143
  # rx rxquantr243 ** 0..1
    set_addr $I10, rxquantr243_done
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxquantr243_loop:
  alt244_0:
.annotate 'line', 139
    set_addr $I10, alt244_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 140
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."MARKED"("endstmt")
    unless $P10, rx233_fail
    goto alt244_end
  alt244_1:
    set_addr $I10, alt244_2
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 141
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_mod_cond"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx233_pos = $P10."pos"()
  # rx rxquantr245 ** 0..1
    set_addr $I10, rxquantr245_done
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxquantr245_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_mod_loop"()
    unless $P10, rx233_fail
    goto rxsubrule246_pass
  rxsubrule246_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx233_fail
  rxsubrule246_pass:
    set_addr $I10, rxsubrule246_back
    rx233_cur."!mark_push"(0, rx233_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx233_pos = $P10."pos"()
    set_addr $I10, rxquantr245_done
    (rx233_rep) = rx233_cur."!mark_commit"($I10)
  rxquantr245_done:
    goto alt244_end
  alt244_2:
.annotate 'line', 142
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statement_mod_loop"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx233_pos = $P10."pos"()
  alt244_end:
.annotate 'line', 143
    set_addr $I10, rxquantr243_done
    (rx233_rep) = rx233_cur."!mark_commit"($I10)
  rxquantr243_done:
  alt242_end:
.annotate 'line', 134
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "statement")
    if_null rx233_debug, debug_672
    rx233_cur."!cursor_debug"("PASS", "statement", " at pos=", rx233_pos)
  debug_672:
    .return (rx233_cur)
  rx233_restart:
.annotate 'line', 10
    if_null rx233_debug, debug_673
    rx233_cur."!cursor_debug"("NEXT", "statement")
  debug_673:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_674
    rx233_cur."!cursor_debug"("FAIL", "statement")
  debug_674:
    .return (rx233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303576195.699") :method
.annotate 'line', 10
    new $P235, "ResizablePMCArray"
    push $P235, ""
    .return ($P235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block237"  :anon :subid("36_1303576195.699") :method :outer("34_1303576195.699")
.annotate 'line', 135
    .local string rx239_tgt
    .local int rx239_pos
    .local int rx239_off
    .local int rx239_eos
    .local int rx239_rep
    .local pmc rx239_cur
    .local pmc rx239_debug
    (rx239_cur, rx239_pos, rx239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx239_cur
    .local pmc match
    .lex "$/", match
    length rx239_eos, rx239_tgt
    gt rx239_pos, rx239_eos, rx239_done
    set rx239_off, 0
    lt rx239_pos, 2, rx239_start
    sub rx239_off, rx239_pos, 1
    substr rx239_tgt, rx239_tgt, rx239_off
  rx239_start:
    eq $I10, 1, rx239_restart
    if_null rx239_debug, debug_668
    rx239_cur."!cursor_debug"("START", "")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan240_done
    goto rxscan240_scan
  rxscan240_loop:
    (rx239_pos) = rx239_cur."from"()
    inc rx239_pos
    rx239_cur."!cursor_from"(rx239_pos)
    ge rx239_pos, rx239_eos, rxscan240_done
  rxscan240_scan:
    set_addr $I10, rxscan240_loop
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  rxscan240_done:
  alt241_0:
    set_addr $I10, alt241_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx239_pos, rx239_eos, rx239_fail
    sub $I10, rx239_pos, rx239_off
    substr $S10, rx239_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx239_fail
    inc rx239_pos
    goto alt241_end
  alt241_1:
  # rxanchor eos
    ne rx239_pos, rx239_eos, rx239_fail
  alt241_end:
  # rx pass
    rx239_cur."!cursor_pass"(rx239_pos, "")
    if_null rx239_debug, debug_669
    rx239_cur."!cursor_debug"("PASS", "", " at pos=", rx239_pos)
  debug_669:
    .return (rx239_cur)
  rx239_restart:
    if_null rx239_debug, debug_670
    rx239_cur."!cursor_debug"("NEXT", "")
  debug_670:
  rx239_fail:
    (rx239_rep, rx239_pos, $I10, $P10) = rx239_cur."!mark_fail"(0)
    lt rx239_pos, -1, rx239_done
    eq rx239_pos, -1, rx239_fail
    jump $I10
  rx239_done:
    rx239_cur."!cursor_fail"()
    if_null rx239_debug, debug_671
    rx239_cur."!cursor_debug"("FAIL", "")
  debug_671:
    .return (rx239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx248_tgt
    .local int rx248_pos
    .local int rx248_off
    .local int rx248_eos
    .local int rx248_rep
    .local pmc rx248_cur
    .local pmc rx248_debug
    (rx248_cur, rx248_pos, rx248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx248_cur
    .local pmc match
    .lex "$/", match
    length rx248_eos, rx248_tgt
    gt rx248_pos, rx248_eos, rx248_done
    set rx248_off, 0
    lt rx248_pos, 2, rx248_start
    sub rx248_off, rx248_pos, 1
    substr rx248_tgt, rx248_tgt, rx248_off
  rx248_start:
    eq $I10, 1, rx248_restart
    if_null rx248_debug, debug_675
    rx248_cur."!cursor_debug"("START", "eat_terminator")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan251_done
    goto rxscan251_scan
  rxscan251_loop:
    (rx248_pos) = rx248_cur."from"()
    inc rx248_pos
    rx248_cur."!cursor_from"(rx248_pos)
    ge rx248_pos, rx248_eos, rxscan251_done
  rxscan251_scan:
    set_addr $I10, rxscan251_loop
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
  rxscan251_done:
  alt252_0:
.annotate 'line', 147
    set_addr $I10, alt252_1
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
.annotate 'line', 148
  # rx literal  ";"
    add $I11, rx248_pos, 1
    gt $I11, rx248_eos, rx248_fail
    sub $I11, rx248_pos, rx248_off
    ord $I11, rx248_tgt, $I11
    ne $I11, 59, rx248_fail
    add rx248_pos, 1
    goto alt252_end
  alt252_1:
    set_addr $I10, alt252_2
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
.annotate 'line', 149
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx248_cur."!cursor_pos"(rx248_pos)
    $P10 = rx248_cur."MARKED"("endstmt")
    unless $P10, rx248_fail
    goto alt252_end
  alt252_2:
    set_addr $I10, alt252_3
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
.annotate 'line', 150
  # rx subrule "terminator" subtype=zerowidth negate=
    rx248_cur."!cursor_pos"(rx248_pos)
    $P10 = rx248_cur."terminator"()
    unless $P10, rx248_fail
    goto alt252_end
  alt252_3:
.annotate 'line', 151
  # rxanchor eos
    ne rx248_pos, rx248_eos, rx248_fail
  alt252_end:
.annotate 'line', 147
  # rx pass
    rx248_cur."!cursor_pass"(rx248_pos, "eat_terminator")
    if_null rx248_debug, debug_676
    rx248_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx248_pos)
  debug_676:
    .return (rx248_cur)
  rx248_restart:
.annotate 'line', 10
    if_null rx248_debug, debug_677
    rx248_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_677:
  rx248_fail:
    (rx248_rep, rx248_pos, $I10, $P10) = rx248_cur."!mark_fail"(0)
    lt rx248_pos, -1, rx248_done
    eq rx248_pos, -1, rx248_fail
    jump $I10
  rx248_done:
    rx248_cur."!cursor_fail"()
    if_null rx248_debug, debug_678
    rx248_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_678:
    .return (rx248_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303576195.699") :method
.annotate 'line', 10
    new $P250, "ResizablePMCArray"
    push $P250, ""
    push $P250, ""
    push $P250, ""
    push $P250, ";"
    .return ($P250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx254_tgt
    .local int rx254_pos
    .local int rx254_off
    .local int rx254_eos
    .local int rx254_rep
    .local pmc rx254_cur
    .local pmc rx254_debug
    (rx254_cur, rx254_pos, rx254_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx254_cur
    .local pmc match
    .lex "$/", match
    length rx254_eos, rx254_tgt
    gt rx254_pos, rx254_eos, rx254_done
    set rx254_off, 0
    lt rx254_pos, 2, rx254_start
    sub rx254_off, rx254_pos, 1
    substr rx254_tgt, rx254_tgt, rx254_off
  rx254_start:
    eq $I10, 1, rx254_restart
    if_null rx254_debug, debug_679
    rx254_cur."!cursor_debug"("START", "xblock")
  debug_679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan258_done
    goto rxscan258_scan
  rxscan258_loop:
    (rx254_pos) = rx254_cur."from"()
    inc rx254_pos
    rx254_cur."!cursor_from"(rx254_pos)
    ge rx254_pos, rx254_eos, rxscan258_done
  rxscan258_scan:
    set_addr $I10, rxscan258_loop
    rx254_cur."!mark_push"(0, rx254_pos, $I10)
  rxscan258_done:
.annotate 'line', 155
  # rx subrule "EXPR" subtype=capture negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."EXPR"()
    unless $P10, rx254_fail
    rx254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx254_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."ws"()
    unless $P10, rx254_fail
    rx254_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx254_cur."!cursor_pos"(rx254_pos)
    $P10 = rx254_cur."pblock"()
    unless $P10, rx254_fail
    rx254_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx254_pos = $P10."pos"()
.annotate 'line', 154
  # rx pass
    rx254_cur."!cursor_pass"(rx254_pos, "xblock")
    if_null rx254_debug, debug_680
    rx254_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx254_pos)
  debug_680:
    .return (rx254_cur)
  rx254_restart:
.annotate 'line', 10
    if_null rx254_debug, debug_681
    rx254_cur."!cursor_debug"("NEXT", "xblock")
  debug_681:
  rx254_fail:
    (rx254_rep, rx254_pos, $I10, $P10) = rx254_cur."!mark_fail"(0)
    lt rx254_pos, -1, rx254_done
    eq rx254_pos, -1, rx254_fail
    jump $I10
  rx254_done:
    rx254_cur."!cursor_fail"()
    if_null rx254_debug, debug_682
    rx254_cur."!cursor_debug"("FAIL", "xblock")
  debug_682:
    .return (rx254_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303576195.699") :method
.annotate 'line', 10
    $P256 = self."!PREFIX__!subrule"("EXPR", "")
    new $P257, "ResizablePMCArray"
    push $P257, $P256
    .return ($P257)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx260_tgt
    .local int rx260_pos
    .local int rx260_off
    .local int rx260_eos
    .local int rx260_rep
    .local pmc rx260_cur
    .local pmc rx260_debug
    (rx260_cur, rx260_pos, rx260_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx260_cur
    .local pmc match
    .lex "$/", match
    length rx260_eos, rx260_tgt
    gt rx260_pos, rx260_eos, rx260_done
    set rx260_off, 0
    lt rx260_pos, 2, rx260_start
    sub rx260_off, rx260_pos, 1
    substr rx260_tgt, rx260_tgt, rx260_off
  rx260_start:
    eq $I10, 1, rx260_restart
    if_null rx260_debug, debug_683
    rx260_cur."!cursor_debug"("START", "pblock")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan265_done
    goto rxscan265_scan
  rxscan265_loop:
    (rx260_pos) = rx260_cur."from"()
    inc rx260_pos
    rx260_cur."!cursor_from"(rx260_pos)
    ge rx260_pos, rx260_eos, rxscan265_done
  rxscan265_scan:
    set_addr $I10, rxscan265_loop
    rx260_cur."!mark_push"(0, rx260_pos, $I10)
  rxscan265_done:
  alt266_0:
.annotate 'line', 158
    set_addr $I10, alt266_1
    rx260_cur."!mark_push"(0, rx260_pos, $I10)
.annotate 'line', 159
  # rx subrule "lambda" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."lambda"()
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."newpad"()
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "signature" subtype=capture negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."signature"()
    unless $P10, rx260_fail
    rx260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx260_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."blockoid"()
    unless $P10, rx260_fail
    rx260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx260_pos = $P10."pos"()
.annotate 'line', 159
    goto alt266_end
  alt266_1:
    set_addr $I10, alt266_2
    rx260_cur."!mark_push"(0, rx260_pos, $I10)
.annotate 'line', 163
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx260_pos, rx260_off
    substr $S10, rx260_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx260_fail
.annotate 'line', 164
  # rx subrule "newpad" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."newpad"()
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
.annotate 'line', 165
  # rx subrule "blockoid" subtype=capture negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."blockoid"()
    unless $P10, rx260_fail
    rx260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx260_pos = $P10."pos"()
.annotate 'line', 163
    goto alt266_end
  alt266_2:
.annotate 'line', 166
  # rx subrule "panic" subtype=method negate=
    rx260_cur."!cursor_pos"(rx260_pos)
    $P10 = rx260_cur."panic"("Missing block")
    unless $P10, rx260_fail
    rx260_pos = $P10."pos"()
  alt266_end:
.annotate 'line', 158
  # rx pass
    rx260_cur."!cursor_pass"(rx260_pos, "pblock")
    if_null rx260_debug, debug_684
    rx260_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx260_pos)
  debug_684:
    .return (rx260_cur)
  rx260_restart:
.annotate 'line', 10
    if_null rx260_debug, debug_685
    rx260_cur."!cursor_debug"("NEXT", "pblock")
  debug_685:
  rx260_fail:
    (rx260_rep, rx260_pos, $I10, $P10) = rx260_cur."!mark_fail"(0)
    lt rx260_pos, -1, rx260_done
    eq rx260_pos, -1, rx260_fail
    jump $I10
  rx260_done:
    rx260_cur."!cursor_fail"()
    if_null rx260_debug, debug_686
    rx260_cur."!cursor_debug"("FAIL", "pblock")
  debug_686:
    .return (rx260_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303576195.699") :method
.annotate 'line', 10
    $P262 = self."!PREFIX__!subrule"("panic", "")
    $P263 = self."!PREFIX__!subrule"("lambda", "")
    new $P264, "ResizablePMCArray"
    push $P264, $P262
    push $P264, "{"
    push $P264, $P263
    .return ($P264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_687
    rx268_cur."!cursor_debug"("START", "lambda")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan271_done
    goto rxscan271_scan
  rxscan271_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan271_done
  rxscan271_scan:
    set_addr $I10, rxscan271_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan271_done:
  alt272_0:
.annotate 'line', 169
    set_addr $I10, alt272_1
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  # rx literal  "->"
    add $I11, rx268_pos, 2
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    substr $S10, rx268_tgt, $I11, 2
    ne $S10, "->", rx268_fail
    add rx268_pos, 2
    goto alt272_end
  alt272_1:
  # rx literal  "<->"
    add $I11, rx268_pos, 3
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    substr $S10, rx268_tgt, $I11, 3
    ne $S10, "<->", rx268_fail
    add rx268_pos, 3
  alt272_end:
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "lambda")
    if_null rx268_debug, debug_688
    rx268_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx268_pos)
  debug_688:
    .return (rx268_cur)
  rx268_restart:
.annotate 'line', 10
    if_null rx268_debug, debug_689
    rx268_cur."!cursor_debug"("NEXT", "lambda")
  debug_689:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_690
    rx268_cur."!cursor_debug"("FAIL", "lambda")
  debug_690:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303576195.699") :method
.annotate 'line', 10
    new $P270, "ResizablePMCArray"
    push $P270, "<->"
    push $P270, "->"
    .return ($P270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx274_tgt
    .local int rx274_pos
    .local int rx274_off
    .local int rx274_eos
    .local int rx274_rep
    .local pmc rx274_cur
    .local pmc rx274_debug
    (rx274_cur, rx274_pos, rx274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx274_cur
    .local pmc match
    .lex "$/", match
    length rx274_eos, rx274_tgt
    gt rx274_pos, rx274_eos, rx274_done
    set rx274_off, 0
    lt rx274_pos, 2, rx274_start
    sub rx274_off, rx274_pos, 1
    substr rx274_tgt, rx274_tgt, rx274_off
  rx274_start:
    eq $I10, 1, rx274_restart
    if_null rx274_debug, debug_691
    rx274_cur."!cursor_debug"("START", "block")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan278_done
    goto rxscan278_scan
  rxscan278_loop:
    (rx274_pos) = rx274_cur."from"()
    inc rx274_pos
    rx274_cur."!cursor_from"(rx274_pos)
    ge rx274_pos, rx274_eos, rxscan278_done
  rxscan278_scan:
    set_addr $I10, rxscan278_loop
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  rxscan278_done:
  alt279_0:
.annotate 'line', 172
    set_addr $I10, alt279_1
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx274_pos, rx274_off
    substr $S10, rx274_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx274_fail
    goto alt279_end
  alt279_1:
  # rx subrule "panic" subtype=method negate=
    rx274_cur."!cursor_pos"(rx274_pos)
    $P10 = rx274_cur."panic"("Missing block")
    unless $P10, rx274_fail
    rx274_pos = $P10."pos"()
  alt279_end:
.annotate 'line', 173
  # rx subrule "newpad" subtype=method negate=
    rx274_cur."!cursor_pos"(rx274_pos)
    $P10 = rx274_cur."newpad"()
    unless $P10, rx274_fail
    rx274_pos = $P10."pos"()
.annotate 'line', 174
  # rx subrule "blockoid" subtype=capture negate=
    rx274_cur."!cursor_pos"(rx274_pos)
    $P10 = rx274_cur."blockoid"()
    unless $P10, rx274_fail
    rx274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx274_pos = $P10."pos"()
.annotate 'line', 171
  # rx pass
    rx274_cur."!cursor_pass"(rx274_pos, "block")
    if_null rx274_debug, debug_692
    rx274_cur."!cursor_debug"("PASS", "block", " at pos=", rx274_pos)
  debug_692:
    .return (rx274_cur)
  rx274_restart:
.annotate 'line', 10
    if_null rx274_debug, debug_693
    rx274_cur."!cursor_debug"("NEXT", "block")
  debug_693:
  rx274_fail:
    (rx274_rep, rx274_pos, $I10, $P10) = rx274_cur."!mark_fail"(0)
    lt rx274_pos, -1, rx274_done
    eq rx274_pos, -1, rx274_fail
    jump $I10
  rx274_done:
    rx274_cur."!cursor_fail"()
    if_null rx274_debug, debug_694
    rx274_cur."!cursor_debug"("FAIL", "block")
  debug_694:
    .return (rx274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303576195.699") :method
.annotate 'line', 10
    $P276 = self."!PREFIX__!subrule"("panic", "")
    new $P277, "ResizablePMCArray"
    push $P277, $P276
    push $P277, "{"
    .return ($P277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx281_tgt
    .local int rx281_pos
    .local int rx281_off
    .local int rx281_eos
    .local int rx281_rep
    .local pmc rx281_cur
    .local pmc rx281_debug
    (rx281_cur, rx281_pos, rx281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx281_cur
    .local pmc match
    .lex "$/", match
    length rx281_eos, rx281_tgt
    gt rx281_pos, rx281_eos, rx281_done
    set rx281_off, 0
    lt rx281_pos, 2, rx281_start
    sub rx281_off, rx281_pos, 1
    substr rx281_tgt, rx281_tgt, rx281_off
  rx281_start:
    eq $I10, 1, rx281_restart
    if_null rx281_debug, debug_695
    rx281_cur."!cursor_debug"("START", "blockoid")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan285_done
    goto rxscan285_scan
  rxscan285_loop:
    (rx281_pos) = rx281_cur."from"()
    inc rx281_pos
    rx281_cur."!cursor_from"(rx281_pos)
    ge rx281_pos, rx281_eos, rxscan285_done
  rxscan285_scan:
    set_addr $I10, rxscan285_loop
    rx281_cur."!mark_push"(0, rx281_pos, $I10)
  rxscan285_done:
.annotate 'line', 178
  # rx subrule "finishpad" subtype=method negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."finishpad"()
    unless $P10, rx281_fail
    rx281_pos = $P10."pos"()
  alt286_0:
.annotate 'line', 179
    set_addr $I10, alt286_1
    rx281_cur."!mark_push"(0, rx281_pos, $I10)
.annotate 'line', 180
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx281_pos, 14
    gt $I11, rx281_eos, rx281_fail
    sub $I11, rx281_pos, rx281_off
    substr $S10, rx281_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx281_fail
    add rx281_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."you_are_here"()
    unless $P10, rx281_fail
    rx281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx281_pos = $P10."pos"()
    goto alt286_end
  alt286_1:
.annotate 'line', 181
  # rx literal  "{"
    add $I11, rx281_pos, 1
    gt $I11, rx281_eos, rx281_fail
    sub $I11, rx281_pos, rx281_off
    ord $I11, rx281_tgt, $I11
    ne $I11, 123, rx281_fail
    add rx281_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."statementlist"()
    unless $P10, rx281_fail
    rx281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx281_pos = $P10."pos"()
  alt287_0:
    set_addr $I10, alt287_1
    rx281_cur."!mark_push"(0, rx281_pos, $I10)
  # rx literal  "}"
    add $I11, rx281_pos, 1
    gt $I11, rx281_eos, rx281_fail
    sub $I11, rx281_pos, rx281_off
    ord $I11, rx281_tgt, $I11
    ne $I11, 125, rx281_fail
    add rx281_pos, 1
    goto alt287_end
  alt287_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."FAILGOAL"("'}'")
    unless $P10, rx281_fail
    goto rxsubrule289_pass
  rxsubrule289_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx281_fail
  rxsubrule289_pass:
    set_addr $I10, rxsubrule289_back
    rx281_cur."!mark_push"(0, rx281_pos, $I10, $P10)
    rx281_pos = $P10."pos"()
  alt287_end:
  alt286_end:
.annotate 'line', 183
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx281_cur."!cursor_pos"(rx281_pos)
    $P10 = rx281_cur."ENDSTMT"()
    unless $P10, rx281_fail
.annotate 'line', 177
  # rx pass
    rx281_cur."!cursor_pass"(rx281_pos, "blockoid")
    if_null rx281_debug, debug_696
    rx281_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx281_pos)
  debug_696:
    .return (rx281_cur)
  rx281_restart:
.annotate 'line', 10
    if_null rx281_debug, debug_697
    rx281_cur."!cursor_debug"("NEXT", "blockoid")
  debug_697:
  rx281_fail:
    (rx281_rep, rx281_pos, $I10, $P10) = rx281_cur."!mark_fail"(0)
    lt rx281_pos, -1, rx281_done
    eq rx281_pos, -1, rx281_fail
    jump $I10
  rx281_done:
    rx281_cur."!cursor_fail"()
    if_null rx281_debug, debug_698
    rx281_cur."!cursor_debug"("FAIL", "blockoid")
  debug_698:
    .return (rx281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303576195.699") :method
.annotate 'line', 10
    $P283 = self."!PREFIX__!subrule"("finishpad", "")
    new $P284, "ResizablePMCArray"
    push $P284, $P283
    .return ($P284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx291_tgt
    .local int rx291_pos
    .local int rx291_off
    .local int rx291_eos
    .local int rx291_rep
    .local pmc rx291_cur
    .local pmc rx291_debug
    (rx291_cur, rx291_pos, rx291_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx291_cur
    .local pmc match
    .lex "$/", match
    length rx291_eos, rx291_tgt
    gt rx291_pos, rx291_eos, rx291_done
    set rx291_off, 0
    lt rx291_pos, 2, rx291_start
    sub rx291_off, rx291_pos, 1
    substr rx291_tgt, rx291_tgt, rx291_off
  rx291_start:
    eq $I10, 1, rx291_restart
    if_null rx291_debug, debug_699
    rx291_cur."!cursor_debug"("START", "newpad")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan294_done
    goto rxscan294_scan
  rxscan294_loop:
    (rx291_pos) = rx291_cur."from"()
    inc rx291_pos
    rx291_cur."!cursor_from"(rx291_pos)
    ge rx291_pos, rx291_eos, rxscan294_done
  rxscan294_scan:
    set_addr $I10, rxscan294_loop
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  rxscan294_done:
.annotate 'line', 186
  # rx pass
    rx291_cur."!cursor_pass"(rx291_pos, "newpad")
    if_null rx291_debug, debug_700
    rx291_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx291_pos)
  debug_700:
    .return (rx291_cur)
  rx291_restart:
.annotate 'line', 10
    if_null rx291_debug, debug_701
    rx291_cur."!cursor_debug"("NEXT", "newpad")
  debug_701:
  rx291_fail:
    (rx291_rep, rx291_pos, $I10, $P10) = rx291_cur."!mark_fail"(0)
    lt rx291_pos, -1, rx291_done
    eq rx291_pos, -1, rx291_fail
    jump $I10
  rx291_done:
    rx291_cur."!cursor_fail"()
    if_null rx291_debug, debug_702
    rx291_cur."!cursor_debug"("FAIL", "newpad")
  debug_702:
    .return (rx291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303576195.699") :method
.annotate 'line', 10
    new $P293, "ResizablePMCArray"
    push $P293, ""
    .return ($P293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx296_tgt
    .local int rx296_pos
    .local int rx296_off
    .local int rx296_eos
    .local int rx296_rep
    .local pmc rx296_cur
    .local pmc rx296_debug
    (rx296_cur, rx296_pos, rx296_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx296_cur
    .local pmc match
    .lex "$/", match
    length rx296_eos, rx296_tgt
    gt rx296_pos, rx296_eos, rx296_done
    set rx296_off, 0
    lt rx296_pos, 2, rx296_start
    sub rx296_off, rx296_pos, 1
    substr rx296_tgt, rx296_tgt, rx296_off
  rx296_start:
    eq $I10, 1, rx296_restart
    if_null rx296_debug, debug_703
    rx296_cur."!cursor_debug"("START", "outerctx")
  debug_703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan299_done
    goto rxscan299_scan
  rxscan299_loop:
    (rx296_pos) = rx296_cur."from"()
    inc rx296_pos
    rx296_cur."!cursor_from"(rx296_pos)
    ge rx296_pos, rx296_eos, rxscan299_done
  rxscan299_scan:
    set_addr $I10, rxscan299_loop
    rx296_cur."!mark_push"(0, rx296_pos, $I10)
  rxscan299_done:
.annotate 'line', 187
  # rx pass
    rx296_cur."!cursor_pass"(rx296_pos, "outerctx")
    if_null rx296_debug, debug_704
    rx296_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx296_pos)
  debug_704:
    .return (rx296_cur)
  rx296_restart:
.annotate 'line', 10
    if_null rx296_debug, debug_705
    rx296_cur."!cursor_debug"("NEXT", "outerctx")
  debug_705:
  rx296_fail:
    (rx296_rep, rx296_pos, $I10, $P10) = rx296_cur."!mark_fail"(0)
    lt rx296_pos, -1, rx296_done
    eq rx296_pos, -1, rx296_fail
    jump $I10
  rx296_done:
    rx296_cur."!cursor_fail"()
    if_null rx296_debug, debug_706
    rx296_cur."!cursor_debug"("FAIL", "outerctx")
  debug_706:
    .return (rx296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303576195.699") :method
.annotate 'line', 10
    new $P298, "ResizablePMCArray"
    push $P298, ""
    .return ($P298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx301_tgt
    .local int rx301_pos
    .local int rx301_off
    .local int rx301_eos
    .local int rx301_rep
    .local pmc rx301_cur
    .local pmc rx301_debug
    (rx301_cur, rx301_pos, rx301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx301_cur
    .local pmc match
    .lex "$/", match
    length rx301_eos, rx301_tgt
    gt rx301_pos, rx301_eos, rx301_done
    set rx301_off, 0
    lt rx301_pos, 2, rx301_start
    sub rx301_off, rx301_pos, 1
    substr rx301_tgt, rx301_tgt, rx301_off
  rx301_start:
    eq $I10, 1, rx301_restart
    if_null rx301_debug, debug_707
    rx301_cur."!cursor_debug"("START", "GLOBALish")
  debug_707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan304_done
    goto rxscan304_scan
  rxscan304_loop:
    (rx301_pos) = rx301_cur."from"()
    inc rx301_pos
    rx301_cur."!cursor_from"(rx301_pos)
    ge rx301_pos, rx301_eos, rxscan304_done
  rxscan304_scan:
    set_addr $I10, rxscan304_loop
    rx301_cur."!mark_push"(0, rx301_pos, $I10)
  rxscan304_done:
.annotate 'line', 188
  # rx pass
    rx301_cur."!cursor_pass"(rx301_pos, "GLOBALish")
    if_null rx301_debug, debug_708
    rx301_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx301_pos)
  debug_708:
    .return (rx301_cur)
  rx301_restart:
.annotate 'line', 10
    if_null rx301_debug, debug_709
    rx301_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_709:
  rx301_fail:
    (rx301_rep, rx301_pos, $I10, $P10) = rx301_cur."!mark_fail"(0)
    lt rx301_pos, -1, rx301_done
    eq rx301_pos, -1, rx301_fail
    jump $I10
  rx301_done:
    rx301_cur."!cursor_fail"()
    if_null rx301_debug, debug_710
    rx301_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_710:
    .return (rx301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303576195.699") :method
.annotate 'line', 10
    new $P303, "ResizablePMCArray"
    push $P303, ""
    .return ($P303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_711
    rx306_cur."!cursor_debug"("START", "finishpad")
  debug_711:
    $I10 = self.'from'()
    ne $I10, -1, rxscan309_done
    goto rxscan309_scan
  rxscan309_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan309_done
  rxscan309_scan:
    set_addr $I10, rxscan309_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan309_done:
.annotate 'line', 189
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "finishpad")
    if_null rx306_debug, debug_712
    rx306_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx306_pos)
  debug_712:
    .return (rx306_cur)
  rx306_restart:
.annotate 'line', 10
    if_null rx306_debug, debug_713
    rx306_cur."!cursor_debug"("NEXT", "finishpad")
  debug_713:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_714
    rx306_cur."!cursor_debug"("FAIL", "finishpad")
  debug_714:
    .return (rx306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303576195.699") :method
.annotate 'line', 10
    new $P308, "ResizablePMCArray"
    push $P308, ""
    .return ($P308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx311_tgt
    .local int rx311_pos
    .local int rx311_off
    .local int rx311_eos
    .local int rx311_rep
    .local pmc rx311_cur
    .local pmc rx311_debug
    (rx311_cur, rx311_pos, rx311_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx311_cur
    .local pmc match
    .lex "$/", match
    length rx311_eos, rx311_tgt
    gt rx311_pos, rx311_eos, rx311_done
    set rx311_off, 0
    lt rx311_pos, 2, rx311_start
    sub rx311_off, rx311_pos, 1
    substr rx311_tgt, rx311_tgt, rx311_off
  rx311_start:
    eq $I10, 1, rx311_restart
    if_null rx311_debug, debug_715
    rx311_cur."!cursor_debug"("START", "you_are_here")
  debug_715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan314_done
    goto rxscan314_scan
  rxscan314_loop:
    (rx311_pos) = rx311_cur."from"()
    inc rx311_pos
    rx311_cur."!cursor_from"(rx311_pos)
    ge rx311_pos, rx311_eos, rxscan314_done
  rxscan314_scan:
    set_addr $I10, rxscan314_loop
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  rxscan314_done:
.annotate 'line', 190
  # rx pass
    rx311_cur."!cursor_pass"(rx311_pos, "you_are_here")
    if_null rx311_debug, debug_716
    rx311_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx311_pos)
  debug_716:
    .return (rx311_cur)
  rx311_restart:
.annotate 'line', 10
    if_null rx311_debug, debug_717
    rx311_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_717:
  rx311_fail:
    (rx311_rep, rx311_pos, $I10, $P10) = rx311_cur."!mark_fail"(0)
    lt rx311_pos, -1, rx311_done
    eq rx311_pos, -1, rx311_fail
    jump $I10
  rx311_done:
    rx311_cur."!cursor_fail"()
    if_null rx311_debug, debug_718
    rx311_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_718:
    .return (rx311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303576195.699") :method
.annotate 'line', 10
    new $P313, "ResizablePMCArray"
    push $P313, ""
    .return ($P313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303576195.699")
    .param pmc param_316
.annotate 'line', 192
    .lex "self", param_316
    $P317 = param_316."!protoregex"("terminator")
    .return ($P317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303576195.699")
    .param pmc param_319
.annotate 'line', 192
    .lex "self", param_319
    $P320 = param_319."!PREFIX__!protoregex"("terminator")
    .return ($P320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx322_tgt
    .local int rx322_pos
    .local int rx322_off
    .local int rx322_eos
    .local int rx322_rep
    .local pmc rx322_cur
    .local pmc rx322_debug
    (rx322_cur, rx322_pos, rx322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx322_cur
    .local pmc match
    .lex "$/", match
    length rx322_eos, rx322_tgt
    gt rx322_pos, rx322_eos, rx322_done
    set rx322_off, 0
    lt rx322_pos, 2, rx322_start
    sub rx322_off, rx322_pos, 1
    substr rx322_tgt, rx322_tgt, rx322_off
  rx322_start:
    eq $I10, 1, rx322_restart
    if_null rx322_debug, debug_719
    rx322_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan325_done
    goto rxscan325_scan
  rxscan325_loop:
    (rx322_pos) = rx322_cur."from"()
    inc rx322_pos
    rx322_cur."!cursor_from"(rx322_pos)
    ge rx322_pos, rx322_eos, rxscan325_done
  rxscan325_scan:
    set_addr $I10, rxscan325_loop
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  rxscan325_done:
.annotate 'line', 194
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx322_fail
  # rx pass
    rx322_cur."!cursor_pass"(rx322_pos, "terminator:sym<;>")
    if_null rx322_debug, debug_720
    rx322_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx322_pos)
  debug_720:
    .return (rx322_cur)
  rx322_restart:
.annotate 'line', 10
    if_null rx322_debug, debug_721
    rx322_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_721:
  rx322_fail:
    (rx322_rep, rx322_pos, $I10, $P10) = rx322_cur."!mark_fail"(0)
    lt rx322_pos, -1, rx322_done
    eq rx322_pos, -1, rx322_fail
    jump $I10
  rx322_done:
    rx322_cur."!cursor_fail"()
    if_null rx322_debug, debug_722
    rx322_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_722:
    .return (rx322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303576195.699") :method
.annotate 'line', 10
    new $P324, "ResizablePMCArray"
    push $P324, ";"
    .return ($P324)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx327_tgt
    .local int rx327_pos
    .local int rx327_off
    .local int rx327_eos
    .local int rx327_rep
    .local pmc rx327_cur
    .local pmc rx327_debug
    (rx327_cur, rx327_pos, rx327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx327_cur
    .local pmc match
    .lex "$/", match
    length rx327_eos, rx327_tgt
    gt rx327_pos, rx327_eos, rx327_done
    set rx327_off, 0
    lt rx327_pos, 2, rx327_start
    sub rx327_off, rx327_pos, 1
    substr rx327_tgt, rx327_tgt, rx327_off
  rx327_start:
    eq $I10, 1, rx327_restart
    if_null rx327_debug, debug_723
    rx327_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan330_done
    goto rxscan330_scan
  rxscan330_loop:
    (rx327_pos) = rx327_cur."from"()
    inc rx327_pos
    rx327_cur."!cursor_from"(rx327_pos)
    ge rx327_pos, rx327_eos, rxscan330_done
  rxscan330_scan:
    set_addr $I10, rxscan330_loop
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxscan330_done:
.annotate 'line', 195
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx327_fail
  # rx pass
    rx327_cur."!cursor_pass"(rx327_pos, "terminator:sym<}>")
    if_null rx327_debug, debug_724
    rx327_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx327_pos)
  debug_724:
    .return (rx327_cur)
  rx327_restart:
.annotate 'line', 10
    if_null rx327_debug, debug_725
    rx327_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_725:
  rx327_fail:
    (rx327_rep, rx327_pos, $I10, $P10) = rx327_cur."!mark_fail"(0)
    lt rx327_pos, -1, rx327_done
    eq rx327_pos, -1, rx327_fail
    jump $I10
  rx327_done:
    rx327_cur."!cursor_fail"()
    if_null rx327_debug, debug_726
    rx327_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_726:
    .return (rx327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303576195.699") :method
.annotate 'line', 10
    new $P329, "ResizablePMCArray"
    push $P329, "}"
    .return ($P329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303576195.699")
    .param pmc param_332
.annotate 'line', 199
    .lex "self", param_332
    $P333 = param_332."!protoregex"("statement_control")
    .return ($P333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303576195.699")
    .param pmc param_335
.annotate 'line', 199
    .lex "self", param_335
    $P336 = param_335."!PREFIX__!protoregex"("statement_control")
    .return ($P336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx338_tgt
    .local int rx338_pos
    .local int rx338_off
    .local int rx338_eos
    .local int rx338_rep
    .local pmc rx338_cur
    .local pmc rx338_debug
    (rx338_cur, rx338_pos, rx338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx338_cur
    .local pmc match
    .lex "$/", match
    length rx338_eos, rx338_tgt
    gt rx338_pos, rx338_eos, rx338_done
    set rx338_off, 0
    lt rx338_pos, 2, rx338_start
    sub rx338_off, rx338_pos, 1
    substr rx338_tgt, rx338_tgt, rx338_off
  rx338_start:
    eq $I10, 1, rx338_restart
    if_null rx338_debug, debug_727
    rx338_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan341_done
    goto rxscan341_scan
  rxscan341_loop:
    (rx338_pos) = rx338_cur."from"()
    inc rx338_pos
    rx338_cur."!cursor_from"(rx338_pos)
    ge rx338_pos, rx338_eos, rxscan341_done
  rxscan341_scan:
    set_addr $I10, rxscan341_loop
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  rxscan341_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_342_fail
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  # rx literal  "use"
    add $I11, rx338_pos, 3
    gt $I11, rx338_eos, rx338_fail
    sub $I11, rx338_pos, rx338_off
    substr $S10, rx338_tgt, $I11, 3
    ne $S10, "use", rx338_fail
    add rx338_pos, 3
    set_addr $I10, rxcap_342_fail
    ($I12, $I11) = rx338_cur."!mark_peek"($I10)
    rx338_cur."!cursor_pos"($I11)
    ($P10) = rx338_cur."!cursor_start"()
    $P10."!cursor_pass"(rx338_pos, "")
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_342_done
  rxcap_342_fail:
    goto rx338_fail
  rxcap_342_done:
  # rx charclass s
    ge rx338_pos, rx338_eos, rx338_fail
    sub $I10, rx338_pos, rx338_off
    is_cclass $I11, 32, rx338_tgt, $I10
    unless $I11, rx338_fail
    inc rx338_pos
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."name"()
    unless $P10, rx338_fail
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx338_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx338_cur."!cursor_pass"(rx338_pos, "statement_control:sym<use>")
    if_null rx338_debug, debug_728
    rx338_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx338_pos)
  debug_728:
    .return (rx338_cur)
  rx338_restart:
.annotate 'line', 10
    if_null rx338_debug, debug_729
    rx338_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_729:
  rx338_fail:
    (rx338_rep, rx338_pos, $I10, $P10) = rx338_cur."!mark_fail"(0)
    lt rx338_pos, -1, rx338_done
    eq rx338_pos, -1, rx338_fail
    jump $I10
  rx338_done:
    rx338_cur."!cursor_fail"()
    if_null rx338_debug, debug_730
    rx338_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_730:
    .return (rx338_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303576195.699") :method
.annotate 'line', 10
    new $P340, "ResizablePMCArray"
    push $P340, "use"
    .return ($P340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx346_tgt
    .local int rx346_pos
    .local int rx346_off
    .local int rx346_eos
    .local int rx346_rep
    .local pmc rx346_cur
    .local pmc rx346_debug
    (rx346_cur, rx346_pos, rx346_tgt, $I10) = self."!cursor_start"()
    rx346_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx346_cur
    .local pmc match
    .lex "$/", match
    length rx346_eos, rx346_tgt
    gt rx346_pos, rx346_eos, rx346_done
    set rx346_off, 0
    lt rx346_pos, 2, rx346_start
    sub rx346_off, rx346_pos, 1
    substr rx346_tgt, rx346_tgt, rx346_off
  rx346_start:
    eq $I10, 1, rx346_restart
    if_null rx346_debug, debug_731
    rx346_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_731:
    $I10 = self.'from'()
    ne $I10, -1, rxscan349_done
    goto rxscan349_scan
  rxscan349_loop:
    (rx346_pos) = rx346_cur."from"()
    inc rx346_pos
    rx346_cur."!cursor_from"(rx346_pos)
    ge rx346_pos, rx346_eos, rxscan349_done
  rxscan349_scan:
    set_addr $I10, rxscan349_loop
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxscan349_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_350_fail
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  # rx literal  "if"
    add $I11, rx346_pos, 2
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 2
    ne $S10, "if", rx346_fail
    add rx346_pos, 2
    set_addr $I10, rxcap_350_fail
    ($I12, $I11) = rx346_cur."!mark_peek"($I10)
    rx346_cur."!cursor_pos"($I11)
    ($P10) = rx346_cur."!cursor_start"()
    $P10."!cursor_pass"(rx346_pos, "")
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_350_done
  rxcap_350_fail:
    goto rx346_fail
  rxcap_350_done:
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."xblock"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 208
  # rx rxquantr353 ** 0..*
    set_addr $I10, rxquantr353_done
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxquantr353_loop:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx346_pos, 5
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 5
    ne $S10, "elsif", rx346_fail
    add rx346_pos, 5
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."xblock"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
    set_addr $I10, rxquantr353_done
    (rx346_rep) = rx346_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr353_done
    rx346_cur."!mark_push"(rx346_rep, rx346_pos, $I10)
    goto rxquantr353_loop
  rxquantr353_done:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 209
  # rx rxquantr358 ** 0..1
    set_addr $I10, rxquantr358_done
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxquantr358_loop:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx346_pos, 4
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 4
    ne $S10, "else", rx346_fail
    add rx346_pos, 4
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."pblock"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
    set_addr $I10, rxquantr358_done
    (rx346_rep) = rx346_cur."!mark_commit"($I10)
  rxquantr358_done:
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx346_cur."!cursor_pass"(rx346_pos, "statement_control:sym<if>")
    if_null rx346_debug, debug_732
    rx346_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx346_pos)
  debug_732:
    .return (rx346_cur)
  rx346_restart:
.annotate 'line', 10
    if_null rx346_debug, debug_733
    rx346_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_733:
  rx346_fail:
    (rx346_rep, rx346_pos, $I10, $P10) = rx346_cur."!mark_fail"(0)
    lt rx346_pos, -1, rx346_done
    eq rx346_pos, -1, rx346_fail
    jump $I10
  rx346_done:
    rx346_cur."!cursor_fail"()
    if_null rx346_debug, debug_734
    rx346_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_734:
    .return (rx346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303576195.699") :method
.annotate 'line', 10
    new $P348, "ResizablePMCArray"
    push $P348, "if"
    .return ($P348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P374 = "73_1303576195.699" 
    capture_lex $P374
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_735
    rx364_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_735:
    $I10 = self.'from'()
    ne $I10, -1, rxscan367_done
    goto rxscan367_scan
  rxscan367_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan367_done
  rxscan367_scan:
    set_addr $I10, rxscan367_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan367_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_368_fail
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx literal  "unless"
    add $I11, rx364_pos, 6
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    substr $S10, rx364_tgt, $I11, 6
    ne $S10, "unless", rx364_fail
    add rx364_pos, 6
    set_addr $I10, rxcap_368_fail
    ($I12, $I11) = rx364_cur."!mark_peek"($I10)
    rx364_cur."!cursor_pos"($I11)
    ($P10) = rx364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx364_pos, "")
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_368_done
  rxcap_368_fail:
    goto rx364_fail
  rxcap_368_done:
  # rx charclass s
    ge rx364_pos, rx364_eos, rx364_fail
    sub $I10, rx364_pos, rx364_off
    is_cclass $I11, 32, rx364_tgt, $I10
    unless $I11, rx364_fail
    inc rx364_pos
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."xblock"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  alt371_0:
.annotate 'line', 215
    set_addr $I10, alt371_1
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx364_cur."!cursor_pos"(rx364_pos)
    .const 'Sub' $P374 = "73_1303576195.699" 
    capture_lex $P374
    $P10 = rx364_cur."before"($P374)
    if $P10, rx364_fail
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
    goto alt371_end
  alt371_1:
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  alt371_end:
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "statement_control:sym<unless>")
    if_null rx364_debug, debug_740
    rx364_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx364_pos)
  debug_740:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 10
    if_null rx364_debug, debug_741
    rx364_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_741:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_742
    rx364_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_742:
    .return (rx364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303576195.699") :method
.annotate 'line', 10
    new $P366, "ResizablePMCArray"
    push $P366, "unless"
    .return ($P366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block373"  :anon :subid("73_1303576195.699") :method :outer("71_1303576195.699")
.annotate 'line', 215
    .local string rx375_tgt
    .local int rx375_pos
    .local int rx375_off
    .local int rx375_eos
    .local int rx375_rep
    .local pmc rx375_cur
    .local pmc rx375_debug
    (rx375_cur, rx375_pos, rx375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx375_cur
    .local pmc match
    .lex "$/", match
    length rx375_eos, rx375_tgt
    gt rx375_pos, rx375_eos, rx375_done
    set rx375_off, 0
    lt rx375_pos, 2, rx375_start
    sub rx375_off, rx375_pos, 1
    substr rx375_tgt, rx375_tgt, rx375_off
  rx375_start:
    eq $I10, 1, rx375_restart
    if_null rx375_debug, debug_736
    rx375_cur."!cursor_debug"("START", "")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan376_done
    goto rxscan376_scan
  rxscan376_loop:
    (rx375_pos) = rx375_cur."from"()
    inc rx375_pos
    rx375_cur."!cursor_from"(rx375_pos)
    ge rx375_pos, rx375_eos, rxscan376_done
  rxscan376_scan:
    set_addr $I10, rxscan376_loop
    rx375_cur."!mark_push"(0, rx375_pos, $I10)
  rxscan376_done:
  # rx literal  "else"
    add $I11, rx375_pos, 4
    gt $I11, rx375_eos, rx375_fail
    sub $I11, rx375_pos, rx375_off
    substr $S10, rx375_tgt, $I11, 4
    ne $S10, "else", rx375_fail
    add rx375_pos, 4
  # rx pass
    rx375_cur."!cursor_pass"(rx375_pos, "")
    if_null rx375_debug, debug_737
    rx375_cur."!cursor_debug"("PASS", "", " at pos=", rx375_pos)
  debug_737:
    .return (rx375_cur)
  rx375_restart:
    if_null rx375_debug, debug_738
    rx375_cur."!cursor_debug"("NEXT", "")
  debug_738:
  rx375_fail:
    (rx375_rep, rx375_pos, $I10, $P10) = rx375_cur."!mark_fail"(0)
    lt rx375_pos, -1, rx375_done
    eq rx375_pos, -1, rx375_fail
    jump $I10
  rx375_done:
    rx375_cur."!cursor_fail"()
    if_null rx375_debug, debug_739
    rx375_cur."!cursor_debug"("FAIL", "")
  debug_739:
    .return (rx375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx382_tgt
    .local int rx382_pos
    .local int rx382_off
    .local int rx382_eos
    .local int rx382_rep
    .local pmc rx382_cur
    .local pmc rx382_debug
    (rx382_cur, rx382_pos, rx382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx382_cur
    .local pmc match
    .lex "$/", match
    length rx382_eos, rx382_tgt
    gt rx382_pos, rx382_eos, rx382_done
    set rx382_off, 0
    lt rx382_pos, 2, rx382_start
    sub rx382_off, rx382_pos, 1
    substr rx382_tgt, rx382_tgt, rx382_off
  rx382_start:
    eq $I10, 1, rx382_restart
    if_null rx382_debug, debug_743
    rx382_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan385_done
    goto rxscan385_scan
  rxscan385_loop:
    (rx382_pos) = rx382_cur."from"()
    inc rx382_pos
    rx382_cur."!cursor_from"(rx382_pos)
    ge rx382_pos, rx382_eos, rxscan385_done
  rxscan385_scan:
    set_addr $I10, rxscan385_loop
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  rxscan385_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_387_fail
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  alt386_0:
    set_addr $I10, alt386_1
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  # rx literal  "while"
    add $I11, rx382_pos, 5
    gt $I11, rx382_eos, rx382_fail
    sub $I11, rx382_pos, rx382_off
    substr $S10, rx382_tgt, $I11, 5
    ne $S10, "while", rx382_fail
    add rx382_pos, 5
    goto alt386_end
  alt386_1:
  # rx literal  "until"
    add $I11, rx382_pos, 5
    gt $I11, rx382_eos, rx382_fail
    sub $I11, rx382_pos, rx382_off
    substr $S10, rx382_tgt, $I11, 5
    ne $S10, "until", rx382_fail
    add rx382_pos, 5
  alt386_end:
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx382_cur."!mark_peek"($I10)
    rx382_cur."!cursor_pos"($I11)
    ($P10) = rx382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx382_pos, "")
    rx382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx382_fail
  rxcap_387_done:
  # rx charclass s
    ge rx382_pos, rx382_eos, rx382_fail
    sub $I10, rx382_pos, rx382_off
    is_cclass $I11, 32, rx382_tgt, $I10
    unless $I11, rx382_fail
    inc rx382_pos
  # rx subrule "ws" subtype=method negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."ws"()
    unless $P10, rx382_fail
    rx382_pos = $P10."pos"()
.annotate 'line', 220
  # rx subrule "xblock" subtype=capture negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."xblock"()
    unless $P10, rx382_fail
    rx382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx382_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."ws"()
    unless $P10, rx382_fail
    rx382_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx382_cur."!cursor_pass"(rx382_pos, "statement_control:sym<while>")
    if_null rx382_debug, debug_744
    rx382_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx382_pos)
  debug_744:
    .return (rx382_cur)
  rx382_restart:
.annotate 'line', 10
    if_null rx382_debug, debug_745
    rx382_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_745:
  rx382_fail:
    (rx382_rep, rx382_pos, $I10, $P10) = rx382_cur."!mark_fail"(0)
    lt rx382_pos, -1, rx382_done
    eq rx382_pos, -1, rx382_fail
    jump $I10
  rx382_done:
    rx382_cur."!cursor_fail"()
    if_null rx382_debug, debug_746
    rx382_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_746:
    .return (rx382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303576195.699") :method
.annotate 'line', 10
    new $P384, "ResizablePMCArray"
    push $P384, "until"
    push $P384, "while"
    .return ($P384)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx391_tgt
    .local int rx391_pos
    .local int rx391_off
    .local int rx391_eos
    .local int rx391_rep
    .local pmc rx391_cur
    .local pmc rx391_debug
    (rx391_cur, rx391_pos, rx391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx391_cur
    .local pmc match
    .lex "$/", match
    length rx391_eos, rx391_tgt
    gt rx391_pos, rx391_eos, rx391_done
    set rx391_off, 0
    lt rx391_pos, 2, rx391_start
    sub rx391_off, rx391_pos, 1
    substr rx391_tgt, rx391_tgt, rx391_off
  rx391_start:
    eq $I10, 1, rx391_restart
    if_null rx391_debug, debug_747
    rx391_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_747:
    $I10 = self.'from'()
    ne $I10, -1, rxscan394_done
    goto rxscan394_scan
  rxscan394_loop:
    (rx391_pos) = rx391_cur."from"()
    inc rx391_pos
    rx391_cur."!cursor_from"(rx391_pos)
    ge rx391_pos, rx391_eos, rxscan394_done
  rxscan394_scan:
    set_addr $I10, rxscan394_loop
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  rxscan394_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_395_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx391_pos, 6
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 6
    ne $S10, "repeat", rx391_fail
    add rx391_pos, 6
    set_addr $I10, rxcap_395_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_395_done
  rxcap_395_fail:
    goto rx391_fail
  rxcap_395_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  alt397_0:
.annotate 'line', 225
    set_addr $I10, alt397_1
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
.annotate 'line', 226
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_400_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  alt399_0:
    set_addr $I10, alt399_1
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "while"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "while", rx391_fail
    add rx391_pos, 5
    goto alt399_end
  alt399_1:
  # rx literal  "until"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "until", rx391_fail
    add rx391_pos, 5
  alt399_end:
    set_addr $I10, rxcap_400_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_400_done
  rxcap_400_fail:
    goto rx391_fail
  rxcap_400_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."xblock"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
    goto alt397_end
  alt397_1:
.annotate 'line', 227
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."pblock"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_406_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  alt405_0:
    set_addr $I10, alt405_1
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "while"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "while", rx391_fail
    add rx391_pos, 5
    goto alt405_end
  alt405_1:
  # rx literal  "until"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "until", rx391_fail
    add rx391_pos, 5
  alt405_end:
    set_addr $I10, rxcap_406_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_406_done
  rxcap_406_fail:
    goto rx391_fail
  rxcap_406_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."EXPR"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
  alt397_end:
.annotate 'line', 228
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx391_cur."!cursor_pass"(rx391_pos, "statement_control:sym<repeat>")
    if_null rx391_debug, debug_748
    rx391_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx391_pos)
  debug_748:
    .return (rx391_cur)
  rx391_restart:
.annotate 'line', 10
    if_null rx391_debug, debug_749
    rx391_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_749:
  rx391_fail:
    (rx391_rep, rx391_pos, $I10, $P10) = rx391_cur."!mark_fail"(0)
    lt rx391_pos, -1, rx391_done
    eq rx391_pos, -1, rx391_fail
    jump $I10
  rx391_done:
    rx391_cur."!cursor_fail"()
    if_null rx391_debug, debug_750
    rx391_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_750:
    .return (rx391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303576195.699") :method
.annotate 'line', 10
    new $P393, "ResizablePMCArray"
    push $P393, "repeat"
    .return ($P393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx411_tgt
    .local int rx411_pos
    .local int rx411_off
    .local int rx411_eos
    .local int rx411_rep
    .local pmc rx411_cur
    .local pmc rx411_debug
    (rx411_cur, rx411_pos, rx411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx411_cur
    .local pmc match
    .lex "$/", match
    length rx411_eos, rx411_tgt
    gt rx411_pos, rx411_eos, rx411_done
    set rx411_off, 0
    lt rx411_pos, 2, rx411_start
    sub rx411_off, rx411_pos, 1
    substr rx411_tgt, rx411_tgt, rx411_off
  rx411_start:
    eq $I10, 1, rx411_restart
    if_null rx411_debug, debug_751
    rx411_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan414_done
    goto rxscan414_scan
  rxscan414_loop:
    (rx411_pos) = rx411_cur."from"()
    inc rx411_pos
    rx411_cur."!cursor_from"(rx411_pos)
    ge rx411_pos, rx411_eos, rxscan414_done
  rxscan414_scan:
    set_addr $I10, rxscan414_loop
    rx411_cur."!mark_push"(0, rx411_pos, $I10)
  rxscan414_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_415_fail
    rx411_cur."!mark_push"(0, rx411_pos, $I10)
  # rx literal  "for"
    add $I11, rx411_pos, 3
    gt $I11, rx411_eos, rx411_fail
    sub $I11, rx411_pos, rx411_off
    substr $S10, rx411_tgt, $I11, 3
    ne $S10, "for", rx411_fail
    add rx411_pos, 3
    set_addr $I10, rxcap_415_fail
    ($I12, $I11) = rx411_cur."!mark_peek"($I10)
    rx411_cur."!cursor_pos"($I11)
    ($P10) = rx411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx411_pos, "")
    rx411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_415_done
  rxcap_415_fail:
    goto rx411_fail
  rxcap_415_done:
  # rx charclass s
    ge rx411_pos, rx411_eos, rx411_fail
    sub $I10, rx411_pos, rx411_off
    is_cclass $I11, 32, rx411_tgt, $I10
    unless $I11, rx411_fail
    inc rx411_pos
  # rx subrule "ws" subtype=method negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."ws"()
    unless $P10, rx411_fail
    rx411_pos = $P10."pos"()
.annotate 'line', 233
  # rx subrule "xblock" subtype=capture negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."xblock"()
    unless $P10, rx411_fail
    rx411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx411_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx411_cur."!cursor_pos"(rx411_pos)
    $P10 = rx411_cur."ws"()
    unless $P10, rx411_fail
    rx411_pos = $P10."pos"()
.annotate 'line', 231
  # rx pass
    rx411_cur."!cursor_pass"(rx411_pos, "statement_control:sym<for>")
    if_null rx411_debug, debug_752
    rx411_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx411_pos)
  debug_752:
    .return (rx411_cur)
  rx411_restart:
.annotate 'line', 10
    if_null rx411_debug, debug_753
    rx411_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_753:
  rx411_fail:
    (rx411_rep, rx411_pos, $I10, $P10) = rx411_cur."!mark_fail"(0)
    lt rx411_pos, -1, rx411_done
    eq rx411_pos, -1, rx411_fail
    jump $I10
  rx411_done:
    rx411_cur."!cursor_fail"()
    if_null rx411_debug, debug_754
    rx411_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_754:
    .return (rx411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303576195.699") :method
.annotate 'line', 10
    new $P413, "ResizablePMCArray"
    push $P413, "for"
    .return ($P413)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx419_tgt
    .local int rx419_pos
    .local int rx419_off
    .local int rx419_eos
    .local int rx419_rep
    .local pmc rx419_cur
    .local pmc rx419_debug
    (rx419_cur, rx419_pos, rx419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx419_cur
    .local pmc match
    .lex "$/", match
    length rx419_eos, rx419_tgt
    gt rx419_pos, rx419_eos, rx419_done
    set rx419_off, 0
    lt rx419_pos, 2, rx419_start
    sub rx419_off, rx419_pos, 1
    substr rx419_tgt, rx419_tgt, rx419_off
  rx419_start:
    eq $I10, 1, rx419_restart
    if_null rx419_debug, debug_755
    rx419_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan422_done
    goto rxscan422_scan
  rxscan422_loop:
    (rx419_pos) = rx419_cur."from"()
    inc rx419_pos
    rx419_cur."!cursor_from"(rx419_pos)
    ge rx419_pos, rx419_eos, rxscan422_done
  rxscan422_scan:
    set_addr $I10, rxscan422_loop
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  rxscan422_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_423_fail
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx419_pos, 5
    gt $I11, rx419_eos, rx419_fail
    sub $I11, rx419_pos, rx419_off
    substr $S10, rx419_tgt, $I11, 5
    ne $S10, "CATCH", rx419_fail
    add rx419_pos, 5
    set_addr $I10, rxcap_423_fail
    ($I12, $I11) = rx419_cur."!mark_peek"($I10)
    rx419_cur."!cursor_pos"($I11)
    ($P10) = rx419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx419_pos, "")
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_423_done
  rxcap_423_fail:
    goto rx419_fail
  rxcap_423_done:
  # rx charclass s
    ge rx419_pos, rx419_eos, rx419_fail
    sub $I10, rx419_pos, rx419_off
    is_cclass $I11, 32, rx419_tgt, $I10
    unless $I11, rx419_fail
    inc rx419_pos
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
.annotate 'line', 238
  # rx subrule "block" subtype=capture negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."block"()
    unless $P10, rx419_fail
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx419_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
.annotate 'line', 236
  # rx pass
    rx419_cur."!cursor_pass"(rx419_pos, "statement_control:sym<CATCH>")
    if_null rx419_debug, debug_756
    rx419_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx419_pos)
  debug_756:
    .return (rx419_cur)
  rx419_restart:
.annotate 'line', 10
    if_null rx419_debug, debug_757
    rx419_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_757:
  rx419_fail:
    (rx419_rep, rx419_pos, $I10, $P10) = rx419_cur."!mark_fail"(0)
    lt rx419_pos, -1, rx419_done
    eq rx419_pos, -1, rx419_fail
    jump $I10
  rx419_done:
    rx419_cur."!cursor_fail"()
    if_null rx419_debug, debug_758
    rx419_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_758:
    .return (rx419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303576195.699") :method
.annotate 'line', 10
    new $P421, "ResizablePMCArray"
    push $P421, "CATCH"
    .return ($P421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_759
    rx427_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan430_done
    goto rxscan430_scan
  rxscan430_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan430_done
  rxscan430_scan:
    set_addr $I10, rxscan430_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan430_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_431_fail
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx427_pos, 7
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 7
    ne $S10, "CONTROL", rx427_fail
    add rx427_pos, 7
    set_addr $I10, rxcap_431_fail
    ($I12, $I11) = rx427_cur."!mark_peek"($I10)
    rx427_cur."!cursor_pos"($I11)
    ($P10) = rx427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx427_pos, "")
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_431_done
  rxcap_431_fail:
    goto rx427_fail
  rxcap_431_done:
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 243
  # rx subrule "block" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."block"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 241
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "statement_control:sym<CONTROL>")
    if_null rx427_debug, debug_760
    rx427_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx427_pos)
  debug_760:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_761
    rx427_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_761:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_762
    rx427_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_762:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303576195.699") :method
.annotate 'line', 10
    new $P429, "ResizablePMCArray"
    push $P429, "CONTROL"
    .return ($P429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303576195.699")
    .param pmc param_435
.annotate 'line', 246
    .lex "self", param_435
    $P436 = param_435."!protoregex"("statement_prefix")
    .return ($P436)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303576195.699")
    .param pmc param_438
.annotate 'line', 246
    .lex "self", param_438
    $P439 = param_438."!PREFIX__!protoregex"("statement_prefix")
    .return ($P439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx441_tgt
    .local int rx441_pos
    .local int rx441_off
    .local int rx441_eos
    .local int rx441_rep
    .local pmc rx441_cur
    .local pmc rx441_debug
    (rx441_cur, rx441_pos, rx441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx441_cur
    .local pmc match
    .lex "$/", match
    length rx441_eos, rx441_tgt
    gt rx441_pos, rx441_eos, rx441_done
    set rx441_off, 0
    lt rx441_pos, 2, rx441_start
    sub rx441_off, rx441_pos, 1
    substr rx441_tgt, rx441_tgt, rx441_off
  rx441_start:
    eq $I10, 1, rx441_restart
    if_null rx441_debug, debug_763
    rx441_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan445_done
    goto rxscan445_scan
  rxscan445_loop:
    (rx441_pos) = rx441_cur."from"()
    inc rx441_pos
    rx441_cur."!cursor_from"(rx441_pos)
    ge rx441_pos, rx441_eos, rxscan445_done
  rxscan445_scan:
    set_addr $I10, rxscan445_loop
    rx441_cur."!mark_push"(0, rx441_pos, $I10)
  rxscan445_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_446_fail
    rx441_cur."!mark_push"(0, rx441_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx441_pos, 4
    gt $I11, rx441_eos, rx441_fail
    sub $I11, rx441_pos, rx441_off
    substr $S10, rx441_tgt, $I11, 4
    ne $S10, "INIT", rx441_fail
    add rx441_pos, 4
    set_addr $I10, rxcap_446_fail
    ($I12, $I11) = rx441_cur."!mark_peek"($I10)
    rx441_cur."!cursor_pos"($I11)
    ($P10) = rx441_cur."!cursor_start"()
    $P10."!cursor_pass"(rx441_pos, "")
    rx441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_446_done
  rxcap_446_fail:
    goto rx441_fail
  rxcap_446_done:
  # rx subrule "blorst" subtype=capture negate=
    rx441_cur."!cursor_pos"(rx441_pos)
    $P10 = rx441_cur."blorst"()
    unless $P10, rx441_fail
    rx441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx441_pos = $P10."pos"()
  # rx pass
    rx441_cur."!cursor_pass"(rx441_pos, "statement_prefix:sym<INIT>")
    if_null rx441_debug, debug_764
    rx441_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx441_pos)
  debug_764:
    .return (rx441_cur)
  rx441_restart:
.annotate 'line', 10
    if_null rx441_debug, debug_765
    rx441_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_765:
  rx441_fail:
    (rx441_rep, rx441_pos, $I10, $P10) = rx441_cur."!mark_fail"(0)
    lt rx441_pos, -1, rx441_done
    eq rx441_pos, -1, rx441_fail
    jump $I10
  rx441_done:
    rx441_cur."!cursor_fail"()
    if_null rx441_debug, debug_766
    rx441_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_766:
    .return (rx441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303576195.699") :method
.annotate 'line', 10
    $P443 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P444, "ResizablePMCArray"
    push $P444, $P443
    .return ($P444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_767
    rx448_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_767:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "try"
    add $I11, rx448_pos, 3
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 3
    ne $S10, "try", rx448_fail
    add rx448_pos, 3
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
.annotate 'line', 251
  # rx subrule "blorst" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."blorst"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx448_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_prefix:sym<try>")
    if_null rx448_debug, debug_768
    rx448_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx448_pos)
  debug_768:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 10
    if_null rx448_debug, debug_769
    rx448_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_769:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_770
    rx448_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_770:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303576195.699") :method
.annotate 'line', 10
    $P450 = self."!PREFIX__!subrule"("blorst", "try")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx455_tgt
    .local int rx455_pos
    .local int rx455_off
    .local int rx455_eos
    .local int rx455_rep
    .local pmc rx455_cur
    .local pmc rx455_debug
    (rx455_cur, rx455_pos, rx455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx455_cur
    .local pmc match
    .lex "$/", match
    length rx455_eos, rx455_tgt
    gt rx455_pos, rx455_eos, rx455_done
    set rx455_off, 0
    lt rx455_pos, 2, rx455_start
    sub rx455_off, rx455_pos, 1
    substr rx455_tgt, rx455_tgt, rx455_off
  rx455_start:
    eq $I10, 1, rx455_restart
    if_null rx455_debug, debug_771
    rx455_cur."!cursor_debug"("START", "blorst")
  debug_771:
    $I10 = self.'from'()
    ne $I10, -1, rxscan458_done
    goto rxscan458_scan
  rxscan458_loop:
    (rx455_pos) = rx455_cur."from"()
    inc rx455_pos
    rx455_cur."!cursor_from"(rx455_pos)
    ge rx455_pos, rx455_eos, rxscan458_done
  rxscan458_scan:
    set_addr $I10, rxscan458_loop
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  rxscan458_done:
.annotate 'line', 255
  # rx charclass s
    ge rx455_pos, rx455_eos, rx455_fail
    sub $I10, rx455_pos, rx455_off
    is_cclass $I11, 32, rx455_tgt, $I10
    unless $I11, rx455_fail
    inc rx455_pos
  # rx subrule "ws" subtype=method negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."ws"()
    unless $P10, rx455_fail
    rx455_pos = $P10."pos"()
  alt459_0:
    set_addr $I10, alt459_1
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx455_pos, rx455_off
    substr $S10, rx455_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx455_fail
  # rx subrule "block" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."block"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx455_pos = $P10."pos"()
    goto alt459_end
  alt459_1:
  # rx subrule "statement" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."statement"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx455_pos = $P10."pos"()
  alt459_end:
.annotate 'line', 254
  # rx pass
    rx455_cur."!cursor_pass"(rx455_pos, "blorst")
    if_null rx455_debug, debug_772
    rx455_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx455_pos)
  debug_772:
    .return (rx455_cur)
  rx455_restart:
.annotate 'line', 10
    if_null rx455_debug, debug_773
    rx455_cur."!cursor_debug"("NEXT", "blorst")
  debug_773:
  rx455_fail:
    (rx455_rep, rx455_pos, $I10, $P10) = rx455_cur."!mark_fail"(0)
    lt rx455_pos, -1, rx455_done
    eq rx455_pos, -1, rx455_fail
    jump $I10
  rx455_done:
    rx455_cur."!cursor_fail"()
    if_null rx455_debug, debug_774
    rx455_cur."!cursor_debug"("FAIL", "blorst")
  debug_774:
    .return (rx455_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303576195.699") :method
.annotate 'line', 10
    new $P457, "ResizablePMCArray"
    push $P457, ""
    .return ($P457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303576195.699")
    .param pmc param_461
.annotate 'line', 260
    .lex "self", param_461
    $P462 = param_461."!protoregex"("statement_mod_cond")
    .return ($P462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303576195.699")
    .param pmc param_464
.annotate 'line', 260
    .lex "self", param_464
    $P465 = param_464."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P465)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx467_tgt
    .local int rx467_pos
    .local int rx467_off
    .local int rx467_eos
    .local int rx467_rep
    .local pmc rx467_cur
    .local pmc rx467_debug
    (rx467_cur, rx467_pos, rx467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx467_cur
    .local pmc match
    .lex "$/", match
    length rx467_eos, rx467_tgt
    gt rx467_pos, rx467_eos, rx467_done
    set rx467_off, 0
    lt rx467_pos, 2, rx467_start
    sub rx467_off, rx467_pos, 1
    substr rx467_tgt, rx467_tgt, rx467_off
  rx467_start:
    eq $I10, 1, rx467_restart
    if_null rx467_debug, debug_775
    rx467_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan471_done
    goto rxscan471_scan
  rxscan471_loop:
    (rx467_pos) = rx467_cur."from"()
    inc rx467_pos
    rx467_cur."!cursor_from"(rx467_pos)
    ge rx467_pos, rx467_eos, rxscan471_done
  rxscan471_scan:
    set_addr $I10, rxscan471_loop
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  rxscan471_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_472_fail
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  # rx literal  "if"
    add $I11, rx467_pos, 2
    gt $I11, rx467_eos, rx467_fail
    sub $I11, rx467_pos, rx467_off
    substr $S10, rx467_tgt, $I11, 2
    ne $S10, "if", rx467_fail
    add rx467_pos, 2
    set_addr $I10, rxcap_472_fail
    ($I12, $I11) = rx467_cur."!mark_peek"($I10)
    rx467_cur."!cursor_pos"($I11)
    ($P10) = rx467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx467_pos, "")
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_472_done
  rxcap_472_fail:
    goto rx467_fail
  rxcap_472_done:
  # rx subrule "ws" subtype=method negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."ws"()
    unless $P10, rx467_fail
    rx467_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."EXPR"()
    unless $P10, rx467_fail
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx467_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."ws"()
    unless $P10, rx467_fail
    rx467_pos = $P10."pos"()
  # rx pass
    rx467_cur."!cursor_pass"(rx467_pos, "statement_mod_cond:sym<if>")
    if_null rx467_debug, debug_776
    rx467_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx467_pos)
  debug_776:
    .return (rx467_cur)
  rx467_restart:
.annotate 'line', 10
    if_null rx467_debug, debug_777
    rx467_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_777:
  rx467_fail:
    (rx467_rep, rx467_pos, $I10, $P10) = rx467_cur."!mark_fail"(0)
    lt rx467_pos, -1, rx467_done
    eq rx467_pos, -1, rx467_fail
    jump $I10
  rx467_done:
    rx467_cur."!cursor_fail"()
    if_null rx467_debug, debug_778
    rx467_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_778:
    .return (rx467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303576195.699") :method
.annotate 'line', 10
    $P469 = self."!PREFIX__!subrule"("ws", "if")
    new $P470, "ResizablePMCArray"
    push $P470, $P469
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx476_tgt
    .local int rx476_pos
    .local int rx476_off
    .local int rx476_eos
    .local int rx476_rep
    .local pmc rx476_cur
    .local pmc rx476_debug
    (rx476_cur, rx476_pos, rx476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx476_cur
    .local pmc match
    .lex "$/", match
    length rx476_eos, rx476_tgt
    gt rx476_pos, rx476_eos, rx476_done
    set rx476_off, 0
    lt rx476_pos, 2, rx476_start
    sub rx476_off, rx476_pos, 1
    substr rx476_tgt, rx476_tgt, rx476_off
  rx476_start:
    eq $I10, 1, rx476_restart
    if_null rx476_debug, debug_779
    rx476_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan480_done
    goto rxscan480_scan
  rxscan480_loop:
    (rx476_pos) = rx476_cur."from"()
    inc rx476_pos
    rx476_cur."!cursor_from"(rx476_pos)
    ge rx476_pos, rx476_eos, rxscan480_done
  rxscan480_scan:
    set_addr $I10, rxscan480_loop
    rx476_cur."!mark_push"(0, rx476_pos, $I10)
  rxscan480_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_481_fail
    rx476_cur."!mark_push"(0, rx476_pos, $I10)
  # rx literal  "unless"
    add $I11, rx476_pos, 6
    gt $I11, rx476_eos, rx476_fail
    sub $I11, rx476_pos, rx476_off
    substr $S10, rx476_tgt, $I11, 6
    ne $S10, "unless", rx476_fail
    add rx476_pos, 6
    set_addr $I10, rxcap_481_fail
    ($I12, $I11) = rx476_cur."!mark_peek"($I10)
    rx476_cur."!cursor_pos"($I11)
    ($P10) = rx476_cur."!cursor_start"()
    $P10."!cursor_pass"(rx476_pos, "")
    rx476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_481_done
  rxcap_481_fail:
    goto rx476_fail
  rxcap_481_done:
  # rx subrule "ws" subtype=method negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."ws"()
    unless $P10, rx476_fail
    rx476_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."EXPR"()
    unless $P10, rx476_fail
    rx476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx476_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."ws"()
    unless $P10, rx476_fail
    rx476_pos = $P10."pos"()
  # rx pass
    rx476_cur."!cursor_pass"(rx476_pos, "statement_mod_cond:sym<unless>")
    if_null rx476_debug, debug_780
    rx476_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx476_pos)
  debug_780:
    .return (rx476_cur)
  rx476_restart:
.annotate 'line', 10
    if_null rx476_debug, debug_781
    rx476_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_781:
  rx476_fail:
    (rx476_rep, rx476_pos, $I10, $P10) = rx476_cur."!mark_fail"(0)
    lt rx476_pos, -1, rx476_done
    eq rx476_pos, -1, rx476_fail
    jump $I10
  rx476_done:
    rx476_cur."!cursor_fail"()
    if_null rx476_debug, debug_782
    rx476_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_782:
    .return (rx476_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303576195.699") :method
.annotate 'line', 10
    $P478 = self."!PREFIX__!subrule"("ws", "unless")
    new $P479, "ResizablePMCArray"
    push $P479, $P478
    .return ($P479)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303576195.699")
    .param pmc param_485
.annotate 'line', 265
    .lex "self", param_485
    $P486 = param_485."!protoregex"("statement_mod_loop")
    .return ($P486)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303576195.699")
    .param pmc param_488
.annotate 'line', 265
    .lex "self", param_488
    $P489 = param_488."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx491_tgt
    .local int rx491_pos
    .local int rx491_off
    .local int rx491_eos
    .local int rx491_rep
    .local pmc rx491_cur
    .local pmc rx491_debug
    (rx491_cur, rx491_pos, rx491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx491_cur
    .local pmc match
    .lex "$/", match
    length rx491_eos, rx491_tgt
    gt rx491_pos, rx491_eos, rx491_done
    set rx491_off, 0
    lt rx491_pos, 2, rx491_start
    sub rx491_off, rx491_pos, 1
    substr rx491_tgt, rx491_tgt, rx491_off
  rx491_start:
    eq $I10, 1, rx491_restart
    if_null rx491_debug, debug_783
    rx491_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan495_done
    goto rxscan495_scan
  rxscan495_loop:
    (rx491_pos) = rx491_cur."from"()
    inc rx491_pos
    rx491_cur."!cursor_from"(rx491_pos)
    ge rx491_pos, rx491_eos, rxscan495_done
  rxscan495_scan:
    set_addr $I10, rxscan495_loop
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  rxscan495_done:
.annotate 'line', 267
  # rx subcapture "sym"
    set_addr $I10, rxcap_496_fail
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  # rx literal  "while"
    add $I11, rx491_pos, 5
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 5
    ne $S10, "while", rx491_fail
    add rx491_pos, 5
    set_addr $I10, rxcap_496_fail
    ($I12, $I11) = rx491_cur."!mark_peek"($I10)
    rx491_cur."!cursor_pos"($I11)
    ($P10) = rx491_cur."!cursor_start"()
    $P10."!cursor_pass"(rx491_pos, "")
    rx491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_496_done
  rxcap_496_fail:
    goto rx491_fail
  rxcap_496_done:
  # rx subrule "ws" subtype=method negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."ws"()
    unless $P10, rx491_fail
    rx491_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."EXPR"()
    unless $P10, rx491_fail
    rx491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx491_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."ws"()
    unless $P10, rx491_fail
    rx491_pos = $P10."pos"()
  # rx pass
    rx491_cur."!cursor_pass"(rx491_pos, "statement_mod_loop:sym<while>")
    if_null rx491_debug, debug_784
    rx491_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx491_pos)
  debug_784:
    .return (rx491_cur)
  rx491_restart:
.annotate 'line', 10
    if_null rx491_debug, debug_785
    rx491_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_785:
  rx491_fail:
    (rx491_rep, rx491_pos, $I10, $P10) = rx491_cur."!mark_fail"(0)
    lt rx491_pos, -1, rx491_done
    eq rx491_pos, -1, rx491_fail
    jump $I10
  rx491_done:
    rx491_cur."!cursor_fail"()
    if_null rx491_debug, debug_786
    rx491_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_786:
    .return (rx491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303576195.699") :method
.annotate 'line', 10
    $P493 = self."!PREFIX__!subrule"("ws", "while")
    new $P494, "ResizablePMCArray"
    push $P494, $P493
    .return ($P494)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_787
    rx500_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan504_done
    goto rxscan504_scan
  rxscan504_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan504_done
  rxscan504_scan:
    set_addr $I10, rxscan504_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan504_done:
.annotate 'line', 268
  # rx subcapture "sym"
    set_addr $I10, rxcap_505_fail
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  # rx literal  "until"
    add $I11, rx500_pos, 5
    gt $I11, rx500_eos, rx500_fail
    sub $I11, rx500_pos, rx500_off
    substr $S10, rx500_tgt, $I11, 5
    ne $S10, "until", rx500_fail
    add rx500_pos, 5
    set_addr $I10, rxcap_505_fail
    ($I12, $I11) = rx500_cur."!mark_peek"($I10)
    rx500_cur."!cursor_pos"($I11)
    ($P10) = rx500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx500_pos, "")
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_505_done
  rxcap_505_fail:
    goto rx500_fail
  rxcap_505_done:
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."EXPR"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx500_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "statement_mod_loop:sym<until>")
    if_null rx500_debug, debug_788
    rx500_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx500_pos)
  debug_788:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 10
    if_null rx500_debug, debug_789
    rx500_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_789:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_790
    rx500_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_790:
    .return (rx500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303576195.699") :method
.annotate 'line', 10
    $P502 = self."!PREFIX__!subrule"("ws", "until")
    new $P503, "ResizablePMCArray"
    push $P503, $P502
    .return ($P503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx509_tgt
    .local int rx509_pos
    .local int rx509_off
    .local int rx509_eos
    .local int rx509_rep
    .local pmc rx509_cur
    .local pmc rx509_debug
    (rx509_cur, rx509_pos, rx509_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx509_cur
    .local pmc match
    .lex "$/", match
    length rx509_eos, rx509_tgt
    gt rx509_pos, rx509_eos, rx509_done
    set rx509_off, 0
    lt rx509_pos, 2, rx509_start
    sub rx509_off, rx509_pos, 1
    substr rx509_tgt, rx509_tgt, rx509_off
  rx509_start:
    eq $I10, 1, rx509_restart
    if_null rx509_debug, debug_791
    rx509_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx509_pos) = rx509_cur."from"()
    inc rx509_pos
    rx509_cur."!cursor_from"(rx509_pos)
    ge rx509_pos, rx509_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx509_cur."!mark_push"(0, rx509_pos, $I10)
  rxscan513_done:
.annotate 'line', 269
  # rx subcapture "sym"
    set_addr $I10, rxcap_514_fail
    rx509_cur."!mark_push"(0, rx509_pos, $I10)
  # rx literal  "for"
    add $I11, rx509_pos, 3
    gt $I11, rx509_eos, rx509_fail
    sub $I11, rx509_pos, rx509_off
    substr $S10, rx509_tgt, $I11, 3
    ne $S10, "for", rx509_fail
    add rx509_pos, 3
    set_addr $I10, rxcap_514_fail
    ($I12, $I11) = rx509_cur."!mark_peek"($I10)
    rx509_cur."!cursor_pos"($I11)
    ($P10) = rx509_cur."!cursor_start"()
    $P10."!cursor_pass"(rx509_pos, "")
    rx509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_514_done
  rxcap_514_fail:
    goto rx509_fail
  rxcap_514_done:
  # rx subrule "ws" subtype=method negate=
    rx509_cur."!cursor_pos"(rx509_pos)
    $P10 = rx509_cur."ws"()
    unless $P10, rx509_fail
    rx509_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx509_cur."!cursor_pos"(rx509_pos)
    $P10 = rx509_cur."EXPR"()
    unless $P10, rx509_fail
    rx509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx509_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx509_cur."!cursor_pos"(rx509_pos)
    $P10 = rx509_cur."ws"()
    unless $P10, rx509_fail
    rx509_pos = $P10."pos"()
  # rx pass
    rx509_cur."!cursor_pass"(rx509_pos, "statement_mod_loop:sym<for>")
    if_null rx509_debug, debug_792
    rx509_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx509_pos)
  debug_792:
    .return (rx509_cur)
  rx509_restart:
.annotate 'line', 10
    if_null rx509_debug, debug_793
    rx509_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_793:
  rx509_fail:
    (rx509_rep, rx509_pos, $I10, $P10) = rx509_cur."!mark_fail"(0)
    lt rx509_pos, -1, rx509_done
    eq rx509_pos, -1, rx509_fail
    jump $I10
  rx509_done:
    rx509_cur."!cursor_fail"()
    if_null rx509_debug, debug_794
    rx509_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_794:
    .return (rx509_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303576195.699") :method
.annotate 'line', 10
    $P511 = self."!PREFIX__!subrule"("ws", "for")
    new $P512, "ResizablePMCArray"
    push $P512, $P511
    .return ($P512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx518_tgt
    .local int rx518_pos
    .local int rx518_off
    .local int rx518_eos
    .local int rx518_rep
    .local pmc rx518_cur
    .local pmc rx518_debug
    (rx518_cur, rx518_pos, rx518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx518_cur
    .local pmc match
    .lex "$/", match
    length rx518_eos, rx518_tgt
    gt rx518_pos, rx518_eos, rx518_done
    set rx518_off, 0
    lt rx518_pos, 2, rx518_start
    sub rx518_off, rx518_pos, 1
    substr rx518_tgt, rx518_tgt, rx518_off
  rx518_start:
    eq $I10, 1, rx518_restart
    if_null rx518_debug, debug_795
    rx518_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_795:
    $I10 = self.'from'()
    ne $I10, -1, rxscan522_done
    goto rxscan522_scan
  rxscan522_loop:
    (rx518_pos) = rx518_cur."from"()
    inc rx518_pos
    rx518_cur."!cursor_from"(rx518_pos)
    ge rx518_pos, rx518_eos, rxscan522_done
  rxscan522_scan:
    set_addr $I10, rxscan522_loop
    rx518_cur."!mark_push"(0, rx518_pos, $I10)
  rxscan522_done:
.annotate 'line', 273
  # rx subrule "fatarrow" subtype=capture negate=
    rx518_cur."!cursor_pos"(rx518_pos)
    $P10 = rx518_cur."fatarrow"()
    unless $P10, rx518_fail
    rx518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx518_pos = $P10."pos"()
  # rx pass
    rx518_cur."!cursor_pass"(rx518_pos, "term:sym<fatarrow>")
    if_null rx518_debug, debug_796
    rx518_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx518_pos)
  debug_796:
    .return (rx518_cur)
  rx518_restart:
.annotate 'line', 10
    if_null rx518_debug, debug_797
    rx518_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_797:
  rx518_fail:
    (rx518_rep, rx518_pos, $I10, $P10) = rx518_cur."!mark_fail"(0)
    lt rx518_pos, -1, rx518_done
    eq rx518_pos, -1, rx518_fail
    jump $I10
  rx518_done:
    rx518_cur."!cursor_fail"()
    if_null rx518_debug, debug_798
    rx518_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_798:
    .return (rx518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303576195.699") :method
.annotate 'line', 10
    $P520 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P521, "ResizablePMCArray"
    push $P521, $P520
    .return ($P521)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx524_tgt
    .local int rx524_pos
    .local int rx524_off
    .local int rx524_eos
    .local int rx524_rep
    .local pmc rx524_cur
    .local pmc rx524_debug
    (rx524_cur, rx524_pos, rx524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx524_cur
    .local pmc match
    .lex "$/", match
    length rx524_eos, rx524_tgt
    gt rx524_pos, rx524_eos, rx524_done
    set rx524_off, 0
    lt rx524_pos, 2, rx524_start
    sub rx524_off, rx524_pos, 1
    substr rx524_tgt, rx524_tgt, rx524_off
  rx524_start:
    eq $I10, 1, rx524_restart
    if_null rx524_debug, debug_799
    rx524_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_799:
    $I10 = self.'from'()
    ne $I10, -1, rxscan528_done
    goto rxscan528_scan
  rxscan528_loop:
    (rx524_pos) = rx524_cur."from"()
    inc rx524_pos
    rx524_cur."!cursor_from"(rx524_pos)
    ge rx524_pos, rx524_eos, rxscan528_done
  rxscan528_scan:
    set_addr $I10, rxscan528_loop
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxscan528_done:
.annotate 'line', 274
  # rx subrule "colonpair" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."colonpair"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx524_pos = $P10."pos"()
  # rx pass
    rx524_cur."!cursor_pass"(rx524_pos, "term:sym<colonpair>")
    if_null rx524_debug, debug_800
    rx524_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx524_pos)
  debug_800:
    .return (rx524_cur)
  rx524_restart:
.annotate 'line', 10
    if_null rx524_debug, debug_801
    rx524_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_801:
  rx524_fail:
    (rx524_rep, rx524_pos, $I10, $P10) = rx524_cur."!mark_fail"(0)
    lt rx524_pos, -1, rx524_done
    eq rx524_pos, -1, rx524_fail
    jump $I10
  rx524_done:
    rx524_cur."!cursor_fail"()
    if_null rx524_debug, debug_802
    rx524_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_802:
    .return (rx524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303576195.699") :method
.annotate 'line', 10
    $P526 = self."!PREFIX__!subrule"("colonpair", "")
    new $P527, "ResizablePMCArray"
    push $P527, $P526
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx530_tgt
    .local int rx530_pos
    .local int rx530_off
    .local int rx530_eos
    .local int rx530_rep
    .local pmc rx530_cur
    .local pmc rx530_debug
    (rx530_cur, rx530_pos, rx530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx530_cur
    .local pmc match
    .lex "$/", match
    length rx530_eos, rx530_tgt
    gt rx530_pos, rx530_eos, rx530_done
    set rx530_off, 0
    lt rx530_pos, 2, rx530_start
    sub rx530_off, rx530_pos, 1
    substr rx530_tgt, rx530_tgt, rx530_off
  rx530_start:
    eq $I10, 1, rx530_restart
    if_null rx530_debug, debug_803
    rx530_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_803:
    $I10 = self.'from'()
    ne $I10, -1, rxscan534_done
    goto rxscan534_scan
  rxscan534_loop:
    (rx530_pos) = rx530_cur."from"()
    inc rx530_pos
    rx530_cur."!cursor_from"(rx530_pos)
    ge rx530_pos, rx530_eos, rxscan534_done
  rxscan534_scan:
    set_addr $I10, rxscan534_loop
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
  rxscan534_done:
.annotate 'line', 275
  # rx subrule "variable" subtype=capture negate=
    rx530_cur."!cursor_pos"(rx530_pos)
    $P10 = rx530_cur."variable"()
    unless $P10, rx530_fail
    rx530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx530_pos = $P10."pos"()
  # rx pass
    rx530_cur."!cursor_pass"(rx530_pos, "term:sym<variable>")
    if_null rx530_debug, debug_804
    rx530_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx530_pos)
  debug_804:
    .return (rx530_cur)
  rx530_restart:
.annotate 'line', 10
    if_null rx530_debug, debug_805
    rx530_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_805:
  rx530_fail:
    (rx530_rep, rx530_pos, $I10, $P10) = rx530_cur."!mark_fail"(0)
    lt rx530_pos, -1, rx530_done
    eq rx530_pos, -1, rx530_fail
    jump $I10
  rx530_done:
    rx530_cur."!cursor_fail"()
    if_null rx530_debug, debug_806
    rx530_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_806:
    .return (rx530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303576195.699") :method
.annotate 'line', 10
    $P532 = self."!PREFIX__!subrule"("variable", "")
    new $P533, "ResizablePMCArray"
    push $P533, $P532
    .return ($P533)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_807
    rx536_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_807:
    $I10 = self.'from'()
    ne $I10, -1, rxscan540_done
    goto rxscan540_scan
  rxscan540_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan540_done
  rxscan540_scan:
    set_addr $I10, rxscan540_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan540_done:
.annotate 'line', 276
  # rx subrule "package_declarator" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."package_declarator"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx536_pos = $P10."pos"()
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "term:sym<package_declarator>")
    if_null rx536_debug, debug_808
    rx536_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx536_pos)
  debug_808:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 10
    if_null rx536_debug, debug_809
    rx536_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_809:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_810
    rx536_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_810:
    .return (rx536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303576195.699") :method
.annotate 'line', 10
    $P538 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P539, "ResizablePMCArray"
    push $P539, $P538
    .return ($P539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_811
    rx542_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_811:
    $I10 = self.'from'()
    ne $I10, -1, rxscan546_done
    goto rxscan546_scan
  rxscan546_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan546_done
  rxscan546_scan:
    set_addr $I10, rxscan546_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan546_done:
.annotate 'line', 277
  # rx subrule "scope_declarator" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."scope_declarator"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx542_pos = $P10."pos"()
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "term:sym<scope_declarator>")
    if_null rx542_debug, debug_812
    rx542_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx542_pos)
  debug_812:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 10
    if_null rx542_debug, debug_813
    rx542_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_813:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_814
    rx542_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_814:
    .return (rx542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303576195.699") :method
.annotate 'line', 10
    $P544 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P545, "ResizablePMCArray"
    push $P545, $P544
    .return ($P545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx548_tgt
    .local int rx548_pos
    .local int rx548_off
    .local int rx548_eos
    .local int rx548_rep
    .local pmc rx548_cur
    .local pmc rx548_debug
    (rx548_cur, rx548_pos, rx548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx548_cur
    .local pmc match
    .lex "$/", match
    length rx548_eos, rx548_tgt
    gt rx548_pos, rx548_eos, rx548_done
    set rx548_off, 0
    lt rx548_pos, 2, rx548_start
    sub rx548_off, rx548_pos, 1
    substr rx548_tgt, rx548_tgt, rx548_off
  rx548_start:
    eq $I10, 1, rx548_restart
    if_null rx548_debug, debug_815
    rx548_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_815:
    $I10 = self.'from'()
    ne $I10, -1, rxscan552_done
    goto rxscan552_scan
  rxscan552_loop:
    (rx548_pos) = rx548_cur."from"()
    inc rx548_pos
    rx548_cur."!cursor_from"(rx548_pos)
    ge rx548_pos, rx548_eos, rxscan552_done
  rxscan552_scan:
    set_addr $I10, rxscan552_loop
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  rxscan552_done:
.annotate 'line', 278
  # rx subrule "routine_declarator" subtype=capture negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."routine_declarator"()
    unless $P10, rx548_fail
    rx548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx548_pos = $P10."pos"()
  # rx pass
    rx548_cur."!cursor_pass"(rx548_pos, "term:sym<routine_declarator>")
    if_null rx548_debug, debug_816
    rx548_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx548_pos)
  debug_816:
    .return (rx548_cur)
  rx548_restart:
.annotate 'line', 10
    if_null rx548_debug, debug_817
    rx548_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_817:
  rx548_fail:
    (rx548_rep, rx548_pos, $I10, $P10) = rx548_cur."!mark_fail"(0)
    lt rx548_pos, -1, rx548_done
    eq rx548_pos, -1, rx548_fail
    jump $I10
  rx548_done:
    rx548_cur."!cursor_fail"()
    if_null rx548_debug, debug_818
    rx548_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_818:
    .return (rx548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303576195.699") :method
.annotate 'line', 10
    $P550 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P551, "ResizablePMCArray"
    push $P551, $P550
    .return ($P551)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P564 = "121_1303576195.699" 
    capture_lex $P564
    .const 'Sub' $P559 = "120_1303576195.699" 
    capture_lex $P559
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_819
    rx554_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_819:
    $I10 = self.'from'()
    ne $I10, -1, rxscan557_done
    goto rxscan557_scan
  rxscan557_loop:
    (rx554_pos) = rx554_cur."from"()
    inc rx554_pos
    rx554_cur."!cursor_from"(rx554_pos)
    ge rx554_pos, rx554_eos, rxscan557_done
  rxscan557_scan:
    set_addr $I10, rxscan557_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan557_done:
.annotate 'line', 280
  # rx subrule "before" subtype=zerowidth negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    .const 'Sub' $P559 = "120_1303576195.699" 
    capture_lex $P559
    $P10 = rx554_cur."before"($P559)
    unless $P10, rx554_fail
.annotate 'line', 281
  # rx subrule "before" subtype=zerowidth negate=1
    rx554_cur."!cursor_pos"(rx554_pos)
    .const 'Sub' $P564 = "121_1303576195.699" 
    capture_lex $P564
    $P10 = rx554_cur."before"($P564)
    if $P10, rx554_fail
.annotate 'line', 282
  # rx subrule "multi_declarator" subtype=capture negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."multi_declarator"()
    unless $P10, rx554_fail
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx554_pos = $P10."pos"()
.annotate 'line', 279
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "term:sym<multi_declarator>")
    if_null rx554_debug, debug_828
    rx554_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx554_pos)
  debug_828:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 10
    if_null rx554_debug, debug_829
    rx554_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_829:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_830
    rx554_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_830:
    .return (rx554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303576195.699") :method
.annotate 'line', 10
    new $P556, "ResizablePMCArray"
    push $P556, ""
    .return ($P556)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block558"  :anon :subid("120_1303576195.699") :method :outer("118_1303576195.699")
.annotate 'line', 280
    .local string rx560_tgt
    .local int rx560_pos
    .local int rx560_off
    .local int rx560_eos
    .local int rx560_rep
    .local pmc rx560_cur
    .local pmc rx560_debug
    (rx560_cur, rx560_pos, rx560_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx560_cur
    .local pmc match
    .lex "$/", match
    length rx560_eos, rx560_tgt
    gt rx560_pos, rx560_eos, rx560_done
    set rx560_off, 0
    lt rx560_pos, 2, rx560_start
    sub rx560_off, rx560_pos, 1
    substr rx560_tgt, rx560_tgt, rx560_off
  rx560_start:
    eq $I10, 1, rx560_restart
    if_null rx560_debug, debug_820
    rx560_cur."!cursor_debug"("START", "")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan561_done
    goto rxscan561_scan
  rxscan561_loop:
    (rx560_pos) = rx560_cur."from"()
    inc rx560_pos
    rx560_cur."!cursor_from"(rx560_pos)
    ge rx560_pos, rx560_eos, rxscan561_done
  rxscan561_scan:
    set_addr $I10, rxscan561_loop
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  rxscan561_done:
  alt562_0:
    set_addr $I10, alt562_1
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  # rx literal  "multi"
    add $I11, rx560_pos, 5
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 5
    ne $S10, "multi", rx560_fail
    add rx560_pos, 5
    goto alt562_end
  alt562_1:
    set_addr $I10, alt562_2
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  # rx literal  "proto"
    add $I11, rx560_pos, 5
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 5
    ne $S10, "proto", rx560_fail
    add rx560_pos, 5
    goto alt562_end
  alt562_2:
  # rx literal  "only"
    add $I11, rx560_pos, 4
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 4
    ne $S10, "only", rx560_fail
    add rx560_pos, 4
  alt562_end:
  # rx pass
    rx560_cur."!cursor_pass"(rx560_pos, "")
    if_null rx560_debug, debug_821
    rx560_cur."!cursor_debug"("PASS", "", " at pos=", rx560_pos)
  debug_821:
    .return (rx560_cur)
  rx560_restart:
    if_null rx560_debug, debug_822
    rx560_cur."!cursor_debug"("NEXT", "")
  debug_822:
  rx560_fail:
    (rx560_rep, rx560_pos, $I10, $P10) = rx560_cur."!mark_fail"(0)
    lt rx560_pos, -1, rx560_done
    eq rx560_pos, -1, rx560_fail
    jump $I10
  rx560_done:
    rx560_cur."!cursor_fail"()
    if_null rx560_debug, debug_823
    rx560_cur."!cursor_debug"("FAIL", "")
  debug_823:
    .return (rx560_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block563"  :anon :subid("121_1303576195.699") :method :outer("118_1303576195.699")
.annotate 'line', 281
    .local string rx565_tgt
    .local int rx565_pos
    .local int rx565_off
    .local int rx565_eos
    .local int rx565_rep
    .local pmc rx565_cur
    .local pmc rx565_debug
    (rx565_cur, rx565_pos, rx565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx565_cur
    .local pmc match
    .lex "$/", match
    length rx565_eos, rx565_tgt
    gt rx565_pos, rx565_eos, rx565_done
    set rx565_off, 0
    lt rx565_pos, 2, rx565_start
    sub rx565_off, rx565_pos, 1
    substr rx565_tgt, rx565_tgt, rx565_off
  rx565_start:
    eq $I10, 1, rx565_restart
    if_null rx565_debug, debug_824
    rx565_cur."!cursor_debug"("START", "")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan566_done
    goto rxscan566_scan
  rxscan566_loop:
    (rx565_pos) = rx565_cur."from"()
    inc rx565_pos
    rx565_cur."!cursor_from"(rx565_pos)
    ge rx565_pos, rx565_eos, rxscan566_done
  rxscan566_scan:
    set_addr $I10, rxscan566_loop
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxscan566_done:
  # rx literal  "proto"
    add $I11, rx565_pos, 5
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 5
    ne $S10, "proto", rx565_fail
    add rx565_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."ws"()
    unless $P10, rx565_fail
    rx565_pos = $P10."pos"()
  alt567_0:
    set_addr $I10, alt567_1
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "regex"
    add $I11, rx565_pos, 5
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 5
    ne $S10, "regex", rx565_fail
    add rx565_pos, 5
    goto alt567_end
  alt567_1:
    set_addr $I10, alt567_2
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "token"
    add $I11, rx565_pos, 5
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 5
    ne $S10, "token", rx565_fail
    add rx565_pos, 5
    goto alt567_end
  alt567_2:
  # rx literal  "rule"
    add $I11, rx565_pos, 4
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    substr $S10, rx565_tgt, $I11, 4
    ne $S10, "rule", rx565_fail
    add rx565_pos, 4
  alt567_end:
  # rx pass
    rx565_cur."!cursor_pass"(rx565_pos, "")
    if_null rx565_debug, debug_825
    rx565_cur."!cursor_debug"("PASS", "", " at pos=", rx565_pos)
  debug_825:
    .return (rx565_cur)
  rx565_restart:
    if_null rx565_debug, debug_826
    rx565_cur."!cursor_debug"("NEXT", "")
  debug_826:
  rx565_fail:
    (rx565_rep, rx565_pos, $I10, $P10) = rx565_cur."!mark_fail"(0)
    lt rx565_pos, -1, rx565_done
    eq rx565_pos, -1, rx565_fail
    jump $I10
  rx565_done:
    rx565_cur."!cursor_fail"()
    if_null rx565_debug, debug_827
    rx565_cur."!cursor_debug"("FAIL", "")
  debug_827:
    .return (rx565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx569_tgt
    .local int rx569_pos
    .local int rx569_off
    .local int rx569_eos
    .local int rx569_rep
    .local pmc rx569_cur
    .local pmc rx569_debug
    (rx569_cur, rx569_pos, rx569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx569_cur
    .local pmc match
    .lex "$/", match
    length rx569_eos, rx569_tgt
    gt rx569_pos, rx569_eos, rx569_done
    set rx569_off, 0
    lt rx569_pos, 2, rx569_start
    sub rx569_off, rx569_pos, 1
    substr rx569_tgt, rx569_tgt, rx569_off
  rx569_start:
    eq $I10, 1, rx569_restart
    if_null rx569_debug, debug_831
    rx569_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_831:
    $I10 = self.'from'()
    ne $I10, -1, rxscan573_done
    goto rxscan573_scan
  rxscan573_loop:
    (rx569_pos) = rx569_cur."from"()
    inc rx569_pos
    rx569_cur."!cursor_from"(rx569_pos)
    ge rx569_pos, rx569_eos, rxscan573_done
  rxscan573_scan:
    set_addr $I10, rxscan573_loop
    rx569_cur."!mark_push"(0, rx569_pos, $I10)
  rxscan573_done:
.annotate 'line', 284
  # rx subrule "regex_declarator" subtype=capture negate=
    rx569_cur."!cursor_pos"(rx569_pos)
    $P10 = rx569_cur."regex_declarator"()
    unless $P10, rx569_fail
    rx569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx569_pos = $P10."pos"()
  # rx pass
    rx569_cur."!cursor_pass"(rx569_pos, "term:sym<regex_declarator>")
    if_null rx569_debug, debug_832
    rx569_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx569_pos)
  debug_832:
    .return (rx569_cur)
  rx569_restart:
.annotate 'line', 10
    if_null rx569_debug, debug_833
    rx569_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_833:
  rx569_fail:
    (rx569_rep, rx569_pos, $I10, $P10) = rx569_cur."!mark_fail"(0)
    lt rx569_pos, -1, rx569_done
    eq rx569_pos, -1, rx569_fail
    jump $I10
  rx569_done:
    rx569_cur."!cursor_fail"()
    if_null rx569_debug, debug_834
    rx569_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_834:
    .return (rx569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303576195.699") :method
.annotate 'line', 10
    $P571 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P572, "ResizablePMCArray"
    push $P572, $P571
    .return ($P572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx575_tgt
    .local int rx575_pos
    .local int rx575_off
    .local int rx575_eos
    .local int rx575_rep
    .local pmc rx575_cur
    .local pmc rx575_debug
    (rx575_cur, rx575_pos, rx575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx575_cur
    .local pmc match
    .lex "$/", match
    length rx575_eos, rx575_tgt
    gt rx575_pos, rx575_eos, rx575_done
    set rx575_off, 0
    lt rx575_pos, 2, rx575_start
    sub rx575_off, rx575_pos, 1
    substr rx575_tgt, rx575_tgt, rx575_off
  rx575_start:
    eq $I10, 1, rx575_restart
    if_null rx575_debug, debug_835
    rx575_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_835:
    $I10 = self.'from'()
    ne $I10, -1, rxscan579_done
    goto rxscan579_scan
  rxscan579_loop:
    (rx575_pos) = rx575_cur."from"()
    inc rx575_pos
    rx575_cur."!cursor_from"(rx575_pos)
    ge rx575_pos, rx575_eos, rxscan579_done
  rxscan579_scan:
    set_addr $I10, rxscan579_loop
    rx575_cur."!mark_push"(0, rx575_pos, $I10)
  rxscan579_done:
.annotate 'line', 285
  # rx subrule "statement_prefix" subtype=capture negate=
    rx575_cur."!cursor_pos"(rx575_pos)
    $P10 = rx575_cur."statement_prefix"()
    unless $P10, rx575_fail
    rx575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx575_pos = $P10."pos"()
  # rx pass
    rx575_cur."!cursor_pass"(rx575_pos, "term:sym<statement_prefix>")
    if_null rx575_debug, debug_836
    rx575_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx575_pos)
  debug_836:
    .return (rx575_cur)
  rx575_restart:
.annotate 'line', 10
    if_null rx575_debug, debug_837
    rx575_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_837:
  rx575_fail:
    (rx575_rep, rx575_pos, $I10, $P10) = rx575_cur."!mark_fail"(0)
    lt rx575_pos, -1, rx575_done
    eq rx575_pos, -1, rx575_fail
    jump $I10
  rx575_done:
    rx575_cur."!cursor_fail"()
    if_null rx575_debug, debug_838
    rx575_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_838:
    .return (rx575_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303576195.699") :method
.annotate 'line', 10
    $P577 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P578, "ResizablePMCArray"
    push $P578, $P577
    .return ($P578)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx581_tgt
    .local int rx581_pos
    .local int rx581_off
    .local int rx581_eos
    .local int rx581_rep
    .local pmc rx581_cur
    .local pmc rx581_debug
    (rx581_cur, rx581_pos, rx581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx581_cur
    .local pmc match
    .lex "$/", match
    length rx581_eos, rx581_tgt
    gt rx581_pos, rx581_eos, rx581_done
    set rx581_off, 0
    lt rx581_pos, 2, rx581_start
    sub rx581_off, rx581_pos, 1
    substr rx581_tgt, rx581_tgt, rx581_off
  rx581_start:
    eq $I10, 1, rx581_restart
    if_null rx581_debug, debug_839
    rx581_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_839:
    $I10 = self.'from'()
    ne $I10, -1, rxscan584_done
    goto rxscan584_scan
  rxscan584_loop:
    (rx581_pos) = rx581_cur."from"()
    inc rx581_pos
    rx581_cur."!cursor_from"(rx581_pos)
    ge rx581_pos, rx581_eos, rxscan584_done
  rxscan584_scan:
    set_addr $I10, rxscan584_loop
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  rxscan584_done:
.annotate 'line', 286
  # rx subrule "lambda" subtype=zerowidth negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."lambda"()
    unless $P10, rx581_fail
  # rx subrule "pblock" subtype=capture negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."pblock"()
    unless $P10, rx581_fail
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx581_pos = $P10."pos"()
  # rx pass
    rx581_cur."!cursor_pass"(rx581_pos, "term:sym<lambda>")
    if_null rx581_debug, debug_840
    rx581_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx581_pos)
  debug_840:
    .return (rx581_cur)
  rx581_restart:
.annotate 'line', 10
    if_null rx581_debug, debug_841
    rx581_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_841:
  rx581_fail:
    (rx581_rep, rx581_pos, $I10, $P10) = rx581_cur."!mark_fail"(0)
    lt rx581_pos, -1, rx581_done
    eq rx581_pos, -1, rx581_fail
    jump $I10
  rx581_done:
    rx581_cur."!cursor_fail"()
    if_null rx581_debug, debug_842
    rx581_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_842:
    .return (rx581_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303576195.699") :method
.annotate 'line', 10
    new $P583, "ResizablePMCArray"
    push $P583, ""
    .return ($P583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx586_tgt
    .local int rx586_pos
    .local int rx586_off
    .local int rx586_eos
    .local int rx586_rep
    .local pmc rx586_cur
    .local pmc rx586_debug
    (rx586_cur, rx586_pos, rx586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx586_cur
    .local pmc match
    .lex "$/", match
    length rx586_eos, rx586_tgt
    gt rx586_pos, rx586_eos, rx586_done
    set rx586_off, 0
    lt rx586_pos, 2, rx586_start
    sub rx586_off, rx586_pos, 1
    substr rx586_tgt, rx586_tgt, rx586_off
  rx586_start:
    eq $I10, 1, rx586_restart
    if_null rx586_debug, debug_843
    rx586_cur."!cursor_debug"("START", "fatarrow")
  debug_843:
    $I10 = self.'from'()
    ne $I10, -1, rxscan590_done
    goto rxscan590_scan
  rxscan590_loop:
    (rx586_pos) = rx586_cur."from"()
    inc rx586_pos
    rx586_cur."!cursor_from"(rx586_pos)
    ge rx586_pos, rx586_eos, rxscan590_done
  rxscan590_scan:
    set_addr $I10, rxscan590_loop
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  rxscan590_done:
.annotate 'line', 289
  # rx subrule "identifier" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."identifier"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx586_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx586_pos, rx586_off
    set rx586_rep, 0
    sub $I12, rx586_eos, rx586_pos
  rxenumcharlistq591_loop:
    le $I12, 0, rxenumcharlistq591_done
    substr $S10, rx586_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq591_done
    inc rx586_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq591_loop
  rxenumcharlistq591_done:
    add rx586_pos, rx586_pos, rx586_rep
  # rx literal  "=>"
    add $I11, rx586_pos, 2
    gt $I11, rx586_eos, rx586_fail
    sub $I11, rx586_pos, rx586_off
    substr $S10, rx586_tgt, $I11, 2
    ne $S10, "=>", rx586_fail
    add rx586_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."ws"()
    unless $P10, rx586_fail
    rx586_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."EXPR"("i=")
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx586_pos = $P10."pos"()
.annotate 'line', 288
  # rx pass
    rx586_cur."!cursor_pass"(rx586_pos, "fatarrow")
    if_null rx586_debug, debug_844
    rx586_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx586_pos)
  debug_844:
    .return (rx586_cur)
  rx586_restart:
.annotate 'line', 10
    if_null rx586_debug, debug_845
    rx586_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_845:
  rx586_fail:
    (rx586_rep, rx586_pos, $I10, $P10) = rx586_cur."!mark_fail"(0)
    lt rx586_pos, -1, rx586_done
    eq rx586_pos, -1, rx586_fail
    jump $I10
  rx586_done:
    rx586_cur."!cursor_fail"()
    if_null rx586_debug, debug_846
    rx586_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_846:
    .return (rx586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303576195.699") :method
.annotate 'line', 10
    $P588 = self."!PREFIX__!subrule"("identifier", "")
    new $P589, "ResizablePMCArray"
    push $P589, $P588
    .return ($P589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx593_tgt
    .local int rx593_pos
    .local int rx593_off
    .local int rx593_eos
    .local int rx593_rep
    .local pmc rx593_cur
    .local pmc rx593_debug
    (rx593_cur, rx593_pos, rx593_tgt, $I10) = self."!cursor_start"()
    rx593_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx593_cur
    .local pmc match
    .lex "$/", match
    length rx593_eos, rx593_tgt
    gt rx593_pos, rx593_eos, rx593_done
    set rx593_off, 0
    lt rx593_pos, 2, rx593_start
    sub rx593_off, rx593_pos, 1
    substr rx593_tgt, rx593_tgt, rx593_off
  rx593_start:
    eq $I10, 1, rx593_restart
    if_null rx593_debug, debug_847
    rx593_cur."!cursor_debug"("START", "colonpair")
  debug_847:
    $I10 = self.'from'()
    ne $I10, -1, rxscan599_done
    goto rxscan599_scan
  rxscan599_loop:
    (rx593_pos) = rx593_cur."from"()
    inc rx593_pos
    rx593_cur."!cursor_from"(rx593_pos)
    ge rx593_pos, rx593_eos, rxscan599_done
  rxscan599_scan:
    set_addr $I10, rxscan599_loop
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  rxscan599_done:
.annotate 'line', 293
  # rx literal  ":"
    add $I11, rx593_pos, 1
    gt $I11, rx593_eos, rx593_fail
    sub $I11, rx593_pos, rx593_off
    ord $I11, rx593_tgt, $I11
    ne $I11, 58, rx593_fail
    add rx593_pos, 1
  alt600_0:
.annotate 'line', 294
    set_addr $I10, alt600_1
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
.annotate 'line', 295
  # rx subcapture "not"
    set_addr $I10, rxcap_601_fail
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  # rx literal  "!"
    add $I11, rx593_pos, 1
    gt $I11, rx593_eos, rx593_fail
    sub $I11, rx593_pos, rx593_off
    ord $I11, rx593_tgt, $I11
    ne $I11, 33, rx593_fail
    add rx593_pos, 1
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx593_cur."!mark_peek"($I10)
    rx593_cur."!cursor_pos"($I11)
    ($P10) = rx593_cur."!cursor_start"()
    $P10."!cursor_pass"(rx593_pos, "")
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx593_fail
  rxcap_601_done:
  # rx subrule "identifier" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."identifier"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx593_pos = $P10."pos"()
    goto alt600_end
  alt600_1:
    set_addr $I10, alt600_2
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
.annotate 'line', 296
  # rx subrule "identifier" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."identifier"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx593_pos = $P10."pos"()
  # rx rxquantr602 ** 0..1
    set_addr $I10, rxquantr602_done
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  rxquantr602_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."circumfix"()
    unless $P10, rx593_fail
    goto rxsubrule603_pass
  rxsubrule603_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx593_fail
  rxsubrule603_pass:
    set_addr $I10, rxsubrule603_back
    rx593_cur."!mark_push"(0, rx593_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx593_pos = $P10."pos"()
    set_addr $I10, rxquantr602_done
    (rx593_rep) = rx593_cur."!mark_commit"($I10)
  rxquantr602_done:
    goto alt600_end
  alt600_2:
.annotate 'line', 297
  # rx subrule "circumfix" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."circumfix"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx593_pos = $P10."pos"()
  alt600_end:
.annotate 'line', 292
  # rx pass
    rx593_cur."!cursor_pass"(rx593_pos, "colonpair")
    if_null rx593_debug, debug_848
    rx593_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx593_pos)
  debug_848:
    .return (rx593_cur)
  rx593_restart:
.annotate 'line', 10
    if_null rx593_debug, debug_849
    rx593_cur."!cursor_debug"("NEXT", "colonpair")
  debug_849:
  rx593_fail:
    (rx593_rep, rx593_pos, $I10, $P10) = rx593_cur."!mark_fail"(0)
    lt rx593_pos, -1, rx593_done
    eq rx593_pos, -1, rx593_fail
    jump $I10
  rx593_done:
    rx593_cur."!cursor_fail"()
    if_null rx593_debug, debug_850
    rx593_cur."!cursor_debug"("FAIL", "colonpair")
  debug_850:
    .return (rx593_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303576195.699") :method
.annotate 'line', 10
    $P595 = self."!PREFIX__!subrule"("circumfix", ":")
    $P596 = self."!PREFIX__!subrule"("identifier", ":")
    $P597 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P598, "ResizablePMCArray"
    push $P598, $P595
    push $P598, $P596
    push $P598, $P597
    .return ($P598)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    rx605_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_851
    rx605_cur."!cursor_debug"("START", "variable")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan610_done
    goto rxscan610_scan
  rxscan610_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan610_done
  rxscan610_scan:
    set_addr $I10, rxscan610_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan610_done:
  alt611_0:
.annotate 'line', 301
    set_addr $I10, alt611_1
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
.annotate 'line', 302
  # rx subrule "sigil" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."sigil"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx605_pos = $P10."pos"()
  # rx rxquantr612 ** 0..1
    set_addr $I10, rxquantr612_done
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxquantr612_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."twigil"()
    unless $P10, rx605_fail
    goto rxsubrule613_pass
  rxsubrule613_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx605_fail
  rxsubrule613_pass:
    set_addr $I10, rxsubrule613_back
    rx605_cur."!mark_push"(0, rx605_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx605_pos = $P10."pos"()
    set_addr $I10, rxquantr612_done
    (rx605_rep) = rx605_cur."!mark_commit"($I10)
  rxquantr612_done:
  # rx subrule "name" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."name"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx605_pos = $P10."pos"()
    goto alt611_end
  alt611_1:
    set_addr $I10, alt611_2
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
.annotate 'line', 303
  # rx subrule "sigil" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."sigil"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx605_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx605_pos, rx605_off
    substr $S10, rx605_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx605_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."postcircumfix"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx605_pos = $P10."pos"()
    goto alt611_end
  alt611_2:
.annotate 'line', 304
  # rx subcapture "sigil"
    set_addr $I10, rxcap_614_fail
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  # rx literal  "$"
    add $I11, rx605_pos, 1
    gt $I11, rx605_eos, rx605_fail
    sub $I11, rx605_pos, rx605_off
    ord $I11, rx605_tgt, $I11
    ne $I11, 36, rx605_fail
    add rx605_pos, 1
    set_addr $I10, rxcap_614_fail
    ($I12, $I11) = rx605_cur."!mark_peek"($I10)
    rx605_cur."!cursor_pos"($I11)
    ($P10) = rx605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx605_pos, "")
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_614_done
  rxcap_614_fail:
    goto rx605_fail
  rxcap_614_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_615_fail
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx605_pos, rx605_eos, rx605_fail
    sub $I10, rx605_pos, rx605_off
    substr $S10, rx605_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx605_fail
    inc rx605_pos
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx605_cur."!mark_peek"($I10)
    rx605_cur."!cursor_pos"($I11)
    ($P10) = rx605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx605_pos, "")
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx605_fail
  rxcap_615_done:
  alt611_end:
.annotate 'line', 301
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "variable")
    if_null rx605_debug, debug_852
    rx605_cur."!cursor_debug"("PASS", "variable", " at pos=", rx605_pos)
  debug_852:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_853
    rx605_cur."!cursor_debug"("NEXT", "variable")
  debug_853:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_854
    rx605_cur."!cursor_debug"("FAIL", "variable")
  debug_854:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303576195.699") :method
.annotate 'line', 10
    $P607 = self."!PREFIX__!subrule"("sigil", "")
    $P608 = self."!PREFIX__!subrule"("sigil", "")
    new $P609, "ResizablePMCArray"
    push $P609, "$!"
    push $P609, "$_"
    push $P609, "$/"
    push $P609, $P607
    push $P609, $P608
    .return ($P609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_855
    rx617_cur."!cursor_debug"("START", "sigil")
  debug_855:
    $I10 = self.'from'()
    ne $I10, -1, rxscan620_done
    goto rxscan620_scan
  rxscan620_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan620_done
  rxscan620_scan:
    set_addr $I10, rxscan620_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan620_done:
.annotate 'line', 307
  # rx enumcharlist negate=0 
    ge rx617_pos, rx617_eos, rx617_fail
    sub $I10, rx617_pos, rx617_off
    substr $S10, rx617_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx617_fail
    inc rx617_pos
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "sigil")
    if_null rx617_debug, debug_856
    rx617_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx617_pos)
  debug_856:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_857
    rx617_cur."!cursor_debug"("NEXT", "sigil")
  debug_857:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_858
    rx617_cur."!cursor_debug"("FAIL", "sigil")
  debug_858:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303576195.699") :method
.annotate 'line', 10
    new $P619, "ResizablePMCArray"
    push $P619, "&"
    push $P619, "%"
    push $P619, "@"
    push $P619, "$"
    .return ($P619)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx622_tgt
    .local int rx622_pos
    .local int rx622_off
    .local int rx622_eos
    .local int rx622_rep
    .local pmc rx622_cur
    .local pmc rx622_debug
    (rx622_cur, rx622_pos, rx622_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx622_cur
    .local pmc match
    .lex "$/", match
    length rx622_eos, rx622_tgt
    gt rx622_pos, rx622_eos, rx622_done
    set rx622_off, 0
    lt rx622_pos, 2, rx622_start
    sub rx622_off, rx622_pos, 1
    substr rx622_tgt, rx622_tgt, rx622_off
  rx622_start:
    eq $I10, 1, rx622_restart
    if_null rx622_debug, debug_859
    rx622_cur."!cursor_debug"("START", "twigil")
  debug_859:
    $I10 = self.'from'()
    ne $I10, -1, rxscan625_done
    goto rxscan625_scan
  rxscan625_loop:
    (rx622_pos) = rx622_cur."from"()
    inc rx622_pos
    rx622_cur."!cursor_from"(rx622_pos)
    ge rx622_pos, rx622_eos, rxscan625_done
  rxscan625_scan:
    set_addr $I10, rxscan625_loop
    rx622_cur."!mark_push"(0, rx622_pos, $I10)
  rxscan625_done:
.annotate 'line', 309
  # rx enumcharlist negate=0 
    ge rx622_pos, rx622_eos, rx622_fail
    sub $I10, rx622_pos, rx622_off
    substr $S10, rx622_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx622_fail
    inc rx622_pos
  # rx pass
    rx622_cur."!cursor_pass"(rx622_pos, "twigil")
    if_null rx622_debug, debug_860
    rx622_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx622_pos)
  debug_860:
    .return (rx622_cur)
  rx622_restart:
.annotate 'line', 10
    if_null rx622_debug, debug_861
    rx622_cur."!cursor_debug"("NEXT", "twigil")
  debug_861:
  rx622_fail:
    (rx622_rep, rx622_pos, $I10, $P10) = rx622_cur."!mark_fail"(0)
    lt rx622_pos, -1, rx622_done
    eq rx622_pos, -1, rx622_fail
    jump $I10
  rx622_done:
    rx622_cur."!cursor_fail"()
    if_null rx622_debug, debug_862
    rx622_cur."!cursor_debug"("FAIL", "twigil")
  debug_862:
    .return (rx622_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303576195.699") :method
.annotate 'line', 10
    new $P624, "ResizablePMCArray"
    push $P624, "?"
    push $P624, "!"
    push $P624, "*"
    .return ($P624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303576195.699")
    .param pmc param_627
.annotate 'line', 311
    .lex "self", param_627
    $P628 = param_627."!protoregex"("package_declarator")
    .return ($P628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303576195.699")
    .param pmc param_630
.annotate 'line', 311
    .lex "self", param_630
    $P631 = param_630."!PREFIX__!protoregex"("package_declarator")
    .return ($P631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 313
    new $P633, "Undef"
    .lex "$*OUTERPACKAGE", $P633
.annotate 'line', 314
    new $P634, "Undef"
    .lex "$*PACKAGE-SETUP", $P634
.annotate 'line', 315
    new $P635, "Undef"
    .lex "$*PKGDECL", $P635
.annotate 'line', 10
    .local string rx636_tgt
    .local int rx636_pos
    .local int rx636_off
    .local int rx636_eos
    .local int rx636_rep
    .local pmc rx636_cur
    .local pmc rx636_debug
    (rx636_cur, rx636_pos, rx636_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx636_cur
    .local pmc match
    .lex "$/", match
    length rx636_eos, rx636_tgt
    gt rx636_pos, rx636_eos, rx636_done
    set rx636_off, 0
    lt rx636_pos, 2, rx636_start
    sub rx636_off, rx636_pos, 1
    substr rx636_tgt, rx636_tgt, rx636_off
  rx636_start:
    eq $I10, 1, rx636_restart
    if_null rx636_debug, debug_863
    rx636_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_863:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx636_pos) = rx636_cur."from"()
    inc rx636_pos
    rx636_cur."!cursor_from"(rx636_pos)
    ge rx636_pos, rx636_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxscan640_done:
.annotate 'line', 313
    rx636_cur."!cursor_pos"(rx636_pos)
    find_dynamic_lex $P641, "$*PACKAGE"
    unless_null $P641, vivify_864
    get_hll_global $P641, "$PACKAGE"
    unless_null $P641, vivify_865
    die "Contextual $*PACKAGE not found"
  vivify_865:
  vivify_864:
    store_lex "$*OUTERPACKAGE", $P641
.annotate 'line', 314
    rx636_cur."!cursor_pos"(rx636_pos)
    get_hll_global $P642, ["PAST"], "Stmts"
    $P643 = $P642."new"()
    store_lex "$*PACKAGE-SETUP", $P643
.annotate 'line', 315
    rx636_cur."!cursor_pos"(rx636_pos)
    new $P644, "String"
    assign $P644, "module"
    store_lex "$*PKGDECL", $P644
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_645_fail
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  # rx literal  "module"
    add $I11, rx636_pos, 6
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 6
    ne $S10, "module", rx636_fail
    add rx636_pos, 6
    set_addr $I10, rxcap_645_fail
    ($I12, $I11) = rx636_cur."!mark_peek"($I10)
    rx636_cur."!cursor_pos"($I11)
    ($P10) = rx636_cur."!cursor_start"()
    $P10."!cursor_pass"(rx636_pos, "")
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_645_done
  rxcap_645_fail:
    goto rx636_fail
  rxcap_645_done:
  # rx subrule "package_def" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."package_def"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx636_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx636_cur."!cursor_pass"(rx636_pos, "package_declarator:sym<module>")
    if_null rx636_debug, debug_866
    rx636_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx636_pos)
  debug_866:
    .return (rx636_cur)
  rx636_restart:
.annotate 'line', 10
    if_null rx636_debug, debug_867
    rx636_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_867:
  rx636_fail:
    (rx636_rep, rx636_pos, $I10, $P10) = rx636_cur."!mark_fail"(0)
    lt rx636_pos, -1, rx636_done
    eq rx636_pos, -1, rx636_fail
    jump $I10
  rx636_done:
    rx636_cur."!cursor_fail"()
    if_null rx636_debug, debug_868
    rx636_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_868:
    .return (rx636_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303576195.699") :method
.annotate 'line', 10
    $P638 = self."!PREFIX__!subrule"("package_def", "module")
    new $P639, "ResizablePMCArray"
    push $P639, $P638
    .return ($P639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 319
    new $P647, "Undef"
    .lex "$*OUTERPACKAGE", $P647
.annotate 'line', 320
    new $P648, "Undef"
    .lex "$*PACKAGE-SETUP", $P648
.annotate 'line', 321
    new $P649, "Undef"
    .lex "$*PKGDECL", $P649
.annotate 'line', 10
    .local string rx650_tgt
    .local int rx650_pos
    .local int rx650_off
    .local int rx650_eos
    .local int rx650_rep
    .local pmc rx650_cur
    .local pmc rx650_debug
    (rx650_cur, rx650_pos, rx650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx650_cur
    .local pmc match
    .lex "$/", match
    length rx650_eos, rx650_tgt
    gt rx650_pos, rx650_eos, rx650_done
    set rx650_off, 0
    lt rx650_pos, 2, rx650_start
    sub rx650_off, rx650_pos, 1
    substr rx650_tgt, rx650_tgt, rx650_off
  rx650_start:
    eq $I10, 1, rx650_restart
    if_null rx650_debug, debug_869
    rx650_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan654_done
    goto rxscan654_scan
  rxscan654_loop:
    (rx650_pos) = rx650_cur."from"()
    inc rx650_pos
    rx650_cur."!cursor_from"(rx650_pos)
    ge rx650_pos, rx650_eos, rxscan654_done
  rxscan654_scan:
    set_addr $I10, rxscan654_loop
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxscan654_done:
.annotate 'line', 319
    rx650_cur."!cursor_pos"(rx650_pos)
    find_dynamic_lex $P655, "$*PACKAGE"
    unless_null $P655, vivify_870
    get_hll_global $P655, "$PACKAGE"
    unless_null $P655, vivify_871
    die "Contextual $*PACKAGE not found"
  vivify_871:
  vivify_870:
    store_lex "$*OUTERPACKAGE", $P655
.annotate 'line', 320
    rx650_cur."!cursor_pos"(rx650_pos)
    get_hll_global $P656, ["PAST"], "Stmts"
    $P657 = $P656."new"()
    store_lex "$*PACKAGE-SETUP", $P657
.annotate 'line', 321
    rx650_cur."!cursor_pos"(rx650_pos)
    new $P658, "String"
    assign $P658, "knowhow"
    store_lex "$*PKGDECL", $P658
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_659_fail
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx650_pos, 7
    gt $I11, rx650_eos, rx650_fail
    sub $I11, rx650_pos, rx650_off
    substr $S10, rx650_tgt, $I11, 7
    ne $S10, "knowhow", rx650_fail
    add rx650_pos, 7
    set_addr $I10, rxcap_659_fail
    ($I12, $I11) = rx650_cur."!mark_peek"($I10)
    rx650_cur."!cursor_pos"($I11)
    ($P10) = rx650_cur."!cursor_start"()
    $P10."!cursor_pass"(rx650_pos, "")
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_659_done
  rxcap_659_fail:
    goto rx650_fail
  rxcap_659_done:
  # rx subrule "package_def" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."package_def"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx650_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx650_cur."!cursor_pass"(rx650_pos, "package_declarator:sym<knowhow>")
    if_null rx650_debug, debug_872
    rx650_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx650_pos)
  debug_872:
    .return (rx650_cur)
  rx650_restart:
.annotate 'line', 10
    if_null rx650_debug, debug_873
    rx650_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_873:
  rx650_fail:
    (rx650_rep, rx650_pos, $I10, $P10) = rx650_cur."!mark_fail"(0)
    lt rx650_pos, -1, rx650_done
    eq rx650_pos, -1, rx650_fail
    jump $I10
  rx650_done:
    rx650_cur."!cursor_fail"()
    if_null rx650_debug, debug_874
    rx650_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_874:
    .return (rx650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303576195.699") :method
.annotate 'line', 10
    $P652 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P653, "ResizablePMCArray"
    push $P653, $P652
    .return ($P653)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 325
    new $P661, "Undef"
    .lex "$*OUTERPACKAGE", $P661
.annotate 'line', 326
    new $P662, "Undef"
    .lex "$*PACKAGE-SETUP", $P662
.annotate 'line', 327
    new $P663, "Undef"
    .lex "$*PKGDECL", $P663
.annotate 'line', 10
    .local string rx664_tgt
    .local int rx664_pos
    .local int rx664_off
    .local int rx664_eos
    .local int rx664_rep
    .local pmc rx664_cur
    .local pmc rx664_debug
    (rx664_cur, rx664_pos, rx664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx664_cur
    .local pmc match
    .lex "$/", match
    length rx664_eos, rx664_tgt
    gt rx664_pos, rx664_eos, rx664_done
    set rx664_off, 0
    lt rx664_pos, 2, rx664_start
    sub rx664_off, rx664_pos, 1
    substr rx664_tgt, rx664_tgt, rx664_off
  rx664_start:
    eq $I10, 1, rx664_restart
    if_null rx664_debug, debug_875
    rx664_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_875:
    $I10 = self.'from'()
    ne $I10, -1, rxscan668_done
    goto rxscan668_scan
  rxscan668_loop:
    (rx664_pos) = rx664_cur."from"()
    inc rx664_pos
    rx664_cur."!cursor_from"(rx664_pos)
    ge rx664_pos, rx664_eos, rxscan668_done
  rxscan668_scan:
    set_addr $I10, rxscan668_loop
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  rxscan668_done:
.annotate 'line', 325
    rx664_cur."!cursor_pos"(rx664_pos)
    find_dynamic_lex $P669, "$*PACKAGE"
    unless_null $P669, vivify_876
    get_hll_global $P669, "$PACKAGE"
    unless_null $P669, vivify_877
    die "Contextual $*PACKAGE not found"
  vivify_877:
  vivify_876:
    store_lex "$*OUTERPACKAGE", $P669
.annotate 'line', 326
    rx664_cur."!cursor_pos"(rx664_pos)
    get_hll_global $P670, ["PAST"], "Stmts"
    $P671 = $P670."new"()
    store_lex "$*PACKAGE-SETUP", $P671
.annotate 'line', 327
    rx664_cur."!cursor_pos"(rx664_pos)
    new $P672, "String"
    assign $P672, "class"
    store_lex "$*PKGDECL", $P672
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_673_fail
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  # rx literal  "class"
    add $I11, rx664_pos, 5
    gt $I11, rx664_eos, rx664_fail
    sub $I11, rx664_pos, rx664_off
    substr $S10, rx664_tgt, $I11, 5
    ne $S10, "class", rx664_fail
    add rx664_pos, 5
    set_addr $I10, rxcap_673_fail
    ($I12, $I11) = rx664_cur."!mark_peek"($I10)
    rx664_cur."!cursor_pos"($I11)
    ($P10) = rx664_cur."!cursor_start"()
    $P10."!cursor_pass"(rx664_pos, "")
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_673_done
  rxcap_673_fail:
    goto rx664_fail
  rxcap_673_done:
  # rx subrule "package_def" subtype=capture negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."package_def"()
    unless $P10, rx664_fail
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx664_pos = $P10."pos"()
.annotate 'line', 324
  # rx pass
    rx664_cur."!cursor_pass"(rx664_pos, "package_declarator:sym<class>")
    if_null rx664_debug, debug_878
    rx664_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx664_pos)
  debug_878:
    .return (rx664_cur)
  rx664_restart:
.annotate 'line', 10
    if_null rx664_debug, debug_879
    rx664_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_879:
  rx664_fail:
    (rx664_rep, rx664_pos, $I10, $P10) = rx664_cur."!mark_fail"(0)
    lt rx664_pos, -1, rx664_done
    eq rx664_pos, -1, rx664_fail
    jump $I10
  rx664_done:
    rx664_cur."!cursor_fail"()
    if_null rx664_debug, debug_880
    rx664_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_880:
    .return (rx664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303576195.699") :method
.annotate 'line', 10
    $P666 = self."!PREFIX__!subrule"("package_def", "class")
    new $P667, "ResizablePMCArray"
    push $P667, $P666
    .return ($P667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 331
    new $P675, "Undef"
    .lex "$*OUTERPACKAGE", $P675
.annotate 'line', 332
    new $P676, "Undef"
    .lex "$*PACKAGE-SETUP", $P676
.annotate 'line', 333
    new $P677, "Undef"
    .lex "$*PKGDECL", $P677
.annotate 'line', 10
    .local string rx678_tgt
    .local int rx678_pos
    .local int rx678_off
    .local int rx678_eos
    .local int rx678_rep
    .local pmc rx678_cur
    .local pmc rx678_debug
    (rx678_cur, rx678_pos, rx678_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx678_cur
    .local pmc match
    .lex "$/", match
    length rx678_eos, rx678_tgt
    gt rx678_pos, rx678_eos, rx678_done
    set rx678_off, 0
    lt rx678_pos, 2, rx678_start
    sub rx678_off, rx678_pos, 1
    substr rx678_tgt, rx678_tgt, rx678_off
  rx678_start:
    eq $I10, 1, rx678_restart
    if_null rx678_debug, debug_881
    rx678_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan682_done
    goto rxscan682_scan
  rxscan682_loop:
    (rx678_pos) = rx678_cur."from"()
    inc rx678_pos
    rx678_cur."!cursor_from"(rx678_pos)
    ge rx678_pos, rx678_eos, rxscan682_done
  rxscan682_scan:
    set_addr $I10, rxscan682_loop
    rx678_cur."!mark_push"(0, rx678_pos, $I10)
  rxscan682_done:
.annotate 'line', 331
    rx678_cur."!cursor_pos"(rx678_pos)
    find_dynamic_lex $P683, "$*PACKAGE"
    unless_null $P683, vivify_882
    get_hll_global $P683, "$PACKAGE"
    unless_null $P683, vivify_883
    die "Contextual $*PACKAGE not found"
  vivify_883:
  vivify_882:
    store_lex "$*OUTERPACKAGE", $P683
.annotate 'line', 332
    rx678_cur."!cursor_pos"(rx678_pos)
    get_hll_global $P684, ["PAST"], "Stmts"
    $P685 = $P684."new"()
    store_lex "$*PACKAGE-SETUP", $P685
.annotate 'line', 333
    rx678_cur."!cursor_pos"(rx678_pos)
    new $P686, "String"
    assign $P686, "grammar"
    store_lex "$*PKGDECL", $P686
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_687_fail
    rx678_cur."!mark_push"(0, rx678_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx678_pos, 7
    gt $I11, rx678_eos, rx678_fail
    sub $I11, rx678_pos, rx678_off
    substr $S10, rx678_tgt, $I11, 7
    ne $S10, "grammar", rx678_fail
    add rx678_pos, 7
    set_addr $I10, rxcap_687_fail
    ($I12, $I11) = rx678_cur."!mark_peek"($I10)
    rx678_cur."!cursor_pos"($I11)
    ($P10) = rx678_cur."!cursor_start"()
    $P10."!cursor_pass"(rx678_pos, "")
    rx678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_687_done
  rxcap_687_fail:
    goto rx678_fail
  rxcap_687_done:
  # rx subrule "package_def" subtype=capture negate=
    rx678_cur."!cursor_pos"(rx678_pos)
    $P10 = rx678_cur."package_def"()
    unless $P10, rx678_fail
    rx678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx678_pos = $P10."pos"()
.annotate 'line', 330
  # rx pass
    rx678_cur."!cursor_pass"(rx678_pos, "package_declarator:sym<grammar>")
    if_null rx678_debug, debug_884
    rx678_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx678_pos)
  debug_884:
    .return (rx678_cur)
  rx678_restart:
.annotate 'line', 10
    if_null rx678_debug, debug_885
    rx678_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_885:
  rx678_fail:
    (rx678_rep, rx678_pos, $I10, $P10) = rx678_cur."!mark_fail"(0)
    lt rx678_pos, -1, rx678_done
    eq rx678_pos, -1, rx678_fail
    jump $I10
  rx678_done:
    rx678_cur."!cursor_fail"()
    if_null rx678_debug, debug_886
    rx678_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_886:
    .return (rx678_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303576195.699") :method
.annotate 'line', 10
    $P680 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P681, "ResizablePMCArray"
    push $P681, $P680
    .return ($P681)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 337
    new $P689, "Undef"
    .lex "$*OUTERPACKAGE", $P689
.annotate 'line', 338
    new $P690, "Undef"
    .lex "$*PACKAGE-SETUP", $P690
.annotate 'line', 339
    new $P691, "Undef"
    .lex "$*PKGDECL", $P691
.annotate 'line', 10
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_887
    rx692_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_887:
    $I10 = self.'from'()
    ne $I10, -1, rxscan696_done
    goto rxscan696_scan
  rxscan696_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan696_done
  rxscan696_scan:
    set_addr $I10, rxscan696_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan696_done:
.annotate 'line', 337
    rx692_cur."!cursor_pos"(rx692_pos)
    find_dynamic_lex $P697, "$*PACKAGE"
    unless_null $P697, vivify_888
    get_hll_global $P697, "$PACKAGE"
    unless_null $P697, vivify_889
    die "Contextual $*PACKAGE not found"
  vivify_889:
  vivify_888:
    store_lex "$*OUTERPACKAGE", $P697
.annotate 'line', 338
    rx692_cur."!cursor_pos"(rx692_pos)
    get_hll_global $P698, ["PAST"], "Stmts"
    $P699 = $P698."new"()
    store_lex "$*PACKAGE-SETUP", $P699
.annotate 'line', 339
    rx692_cur."!cursor_pos"(rx692_pos)
    new $P700, "String"
    assign $P700, "role"
    store_lex "$*PKGDECL", $P700
.annotate 'line', 340
  # rx subcapture "sym"
    set_addr $I10, rxcap_701_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "role"
    add $I11, rx692_pos, 4
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I11, 4
    ne $S10, "role", rx692_fail
    add rx692_pos, 4
    set_addr $I10, rxcap_701_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_701_done
  rxcap_701_fail:
    goto rx692_fail
  rxcap_701_done:
  # rx subrule "package_def" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."package_def"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx692_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "package_declarator:sym<role>")
    if_null rx692_debug, debug_890
    rx692_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx692_pos)
  debug_890:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 10
    if_null rx692_debug, debug_891
    rx692_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_891:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_892
    rx692_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_892:
    .return (rx692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303576195.699") :method
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("package_def", "role")
    new $P695, "ResizablePMCArray"
    push $P695, $P694
    .return ($P695)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 343
    new $P703, "Undef"
    .lex "$*OUTERPACKAGE", $P703
.annotate 'line', 344
    new $P704, "Undef"
    .lex "$*PACKAGE-SETUP", $P704
.annotate 'line', 345
    new $P705, "Undef"
    .lex "$*PKGDECL", $P705
.annotate 'line', 10
    .local string rx706_tgt
    .local int rx706_pos
    .local int rx706_off
    .local int rx706_eos
    .local int rx706_rep
    .local pmc rx706_cur
    .local pmc rx706_debug
    (rx706_cur, rx706_pos, rx706_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx706_cur
    .local pmc match
    .lex "$/", match
    length rx706_eos, rx706_tgt
    gt rx706_pos, rx706_eos, rx706_done
    set rx706_off, 0
    lt rx706_pos, 2, rx706_start
    sub rx706_off, rx706_pos, 1
    substr rx706_tgt, rx706_tgt, rx706_off
  rx706_start:
    eq $I10, 1, rx706_restart
    if_null rx706_debug, debug_893
    rx706_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan710_done
    goto rxscan710_scan
  rxscan710_loop:
    (rx706_pos) = rx706_cur."from"()
    inc rx706_pos
    rx706_cur."!cursor_from"(rx706_pos)
    ge rx706_pos, rx706_eos, rxscan710_done
  rxscan710_scan:
    set_addr $I10, rxscan710_loop
    rx706_cur."!mark_push"(0, rx706_pos, $I10)
  rxscan710_done:
.annotate 'line', 343
    rx706_cur."!cursor_pos"(rx706_pos)
    find_dynamic_lex $P711, "$*PACKAGE"
    unless_null $P711, vivify_894
    get_hll_global $P711, "$PACKAGE"
    unless_null $P711, vivify_895
    die "Contextual $*PACKAGE not found"
  vivify_895:
  vivify_894:
    store_lex "$*OUTERPACKAGE", $P711
.annotate 'line', 344
    rx706_cur."!cursor_pos"(rx706_pos)
    get_hll_global $P712, ["PAST"], "Stmts"
    $P713 = $P712."new"()
    store_lex "$*PACKAGE-SETUP", $P713
.annotate 'line', 345
    rx706_cur."!cursor_pos"(rx706_pos)
    new $P714, "String"
    assign $P714, "native"
    store_lex "$*PKGDECL", $P714
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_715_fail
    rx706_cur."!mark_push"(0, rx706_pos, $I10)
  # rx literal  "native"
    add $I11, rx706_pos, 6
    gt $I11, rx706_eos, rx706_fail
    sub $I11, rx706_pos, rx706_off
    substr $S10, rx706_tgt, $I11, 6
    ne $S10, "native", rx706_fail
    add rx706_pos, 6
    set_addr $I10, rxcap_715_fail
    ($I12, $I11) = rx706_cur."!mark_peek"($I10)
    rx706_cur."!cursor_pos"($I11)
    ($P10) = rx706_cur."!cursor_start"()
    $P10."!cursor_pass"(rx706_pos, "")
    rx706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_715_done
  rxcap_715_fail:
    goto rx706_fail
  rxcap_715_done:
  # rx subrule "package_def" subtype=capture negate=
    rx706_cur."!cursor_pos"(rx706_pos)
    $P10 = rx706_cur."package_def"()
    unless $P10, rx706_fail
    rx706_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx706_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx706_cur."!cursor_pass"(rx706_pos, "package_declarator:sym<native>")
    if_null rx706_debug, debug_896
    rx706_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx706_pos)
  debug_896:
    .return (rx706_cur)
  rx706_restart:
.annotate 'line', 10
    if_null rx706_debug, debug_897
    rx706_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_897:
  rx706_fail:
    (rx706_rep, rx706_pos, $I10, $P10) = rx706_cur."!mark_fail"(0)
    lt rx706_pos, -1, rx706_done
    eq rx706_pos, -1, rx706_fail
    jump $I10
  rx706_done:
    rx706_cur."!cursor_fail"()
    if_null rx706_debug, debug_898
    rx706_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_898:
    .return (rx706_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303576195.699") :method
.annotate 'line', 10
    $P708 = self."!PREFIX__!subrule"("package_def", "native")
    new $P709, "ResizablePMCArray"
    push $P709, $P708
    .return ($P709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P740 = "154_1303576195.699" 
    capture_lex $P740
.annotate 'line', 350
    new $P717, "Undef"
    .lex "$*PACKAGE", $P717
.annotate 'line', 351
    $P718 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P718
.annotate 'line', 10
    .local string rx719_tgt
    .local int rx719_pos
    .local int rx719_off
    .local int rx719_eos
    .local int rx719_rep
    .local pmc rx719_cur
    .local pmc rx719_debug
    (rx719_cur, rx719_pos, rx719_tgt, $I10) = self."!cursor_start"()
    rx719_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx719_cur
    .local pmc match
    .lex "$/", match
    length rx719_eos, rx719_tgt
    gt rx719_pos, rx719_eos, rx719_done
    set rx719_off, 0
    lt rx719_pos, 2, rx719_start
    sub rx719_off, rx719_pos, 1
    substr rx719_tgt, rx719_tgt, rx719_off
  rx719_start:
    eq $I10, 1, rx719_restart
    if_null rx719_debug, debug_899
    rx719_cur."!cursor_debug"("START", "package_def")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan723_done
    goto rxscan723_scan
  rxscan723_loop:
    (rx719_pos) = rx719_cur."from"()
    inc rx719_pos
    rx719_cur."!cursor_from"(rx719_pos)
    ge rx719_pos, rx719_eos, rxscan723_done
  rxscan723_scan:
    set_addr $I10, rxscan723_loop
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxscan723_done:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 350
    rx719_cur."!cursor_pos"(rx719_pos)
    find_lex $P725, "$*PACKAGE"
    unless_null $P725, vivify_900
    get_hll_global $P725, "$PACKAGE"
    unless_null $P725, vivify_901
    die "Contextual $*PACKAGE not found"
  vivify_901:
  vivify_900:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 351
    rx719_cur."!cursor_pos"(rx719_pos)
    find_lex $P727, "%*ATTR-CHECK"
    unless_null $P727, vivify_902
    get_hll_global $P727, "%ATTR-CHECK"
    unless_null $P727, vivify_903
    die "Contextual %*ATTR-CHECK not found"
  vivify_903:
  vivify_902:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 353
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr730 ** 0..1
    set_addr $I10, rxquantr730_done
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxquantr730_loop:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx719_pos, 2
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 2
    ne $S10, "is", rx719_fail
    add rx719_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx719_pos, 5
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 5
    ne $S10, "repr(", rx719_fail
    add rx719_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."quote_EXPR"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx719_pos, 1
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    ord $I11, rx719_tgt, $I11
    ne $I11, 41, rx719_fail
    add rx719_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    set_addr $I10, rxquantr730_done
    (rx719_rep) = rx719_cur."!mark_commit"($I10)
  rxquantr730_done:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 356
    rx719_cur."!cursor_pos"(rx719_pos)
    find_lex $P737, unicode:"$\x{a2}"
    $P738 = $P737."MATCH"()
    store_lex "$/", $P738
    .const 'Sub' $P740 = "154_1303576195.699" 
    capture_lex $P740
    $P830 = $P740()
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 384
  # rx rxquantr832 ** 0..1
    set_addr $I10, rxquantr832_done
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxquantr832_loop:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx719_pos, 2
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 2
    ne $S10, "is", rx719_fail
    add rx719_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    set_addr $I10, rxquantr832_done
    (rx719_rep) = rx719_cur."!mark_commit"($I10)
  rxquantr832_done:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 385
  # rx rxquantr837 ** 0..*
    set_addr $I10, rxquantr837_done
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxquantr837_loop:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx719_pos, 4
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 4
    ne $S10, "does", rx719_fail
    add rx719_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    set_addr $I10, rxquantr837_done
    (rx719_rep) = rx719_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr837_done
    rx719_cur."!mark_push"(rx719_rep, rx719_pos, $I10)
    goto rxquantr837_loop
  rxquantr837_done:
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  alt842_0:
.annotate 'line', 386
    set_addr $I10, alt842_1
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx719_pos, 1
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    ord $I11, rx719_tgt, $I11
    ne $I11, 59, rx719_fail
    add rx719_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."comp_unit"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    goto alt842_end
  alt842_1:
    set_addr $I10, alt842_2
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx719_fail
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."block"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
    goto alt842_end
  alt842_2:
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."panic"("Malformed package declaration")
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
  alt842_end:
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."ws"()
    unless $P10, rx719_fail
    rx719_pos = $P10."pos"()
.annotate 'line', 349
  # rx pass
    rx719_cur."!cursor_pass"(rx719_pos, "package_def")
    if_null rx719_debug, debug_971
    rx719_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx719_pos)
  debug_971:
    .return (rx719_cur)
  rx719_restart:
.annotate 'line', 10
    if_null rx719_debug, debug_972
    rx719_cur."!cursor_debug"("NEXT", "package_def")
  debug_972:
  rx719_fail:
    (rx719_rep, rx719_pos, $I10, $P10) = rx719_cur."!mark_fail"(0)
    lt rx719_pos, -1, rx719_done
    eq rx719_pos, -1, rx719_fail
    jump $I10
  rx719_done:
    rx719_cur."!cursor_fail"()
    if_null rx719_debug, debug_973
    rx719_cur."!cursor_debug"("FAIL", "package_def")
  debug_973:
    .return (rx719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303576195.699") :method
.annotate 'line', 10
    $P721 = self."!PREFIX__!subrule"("ws", "")
    new $P722, "ResizablePMCArray"
    push $P722, $P721
    .return ($P722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block739"  :anon :subid("154_1303576195.699") :outer("152_1303576195.699")
.annotate 'line', 359
    $P741 = root_new ['parrot';'Hash']
    .lex "%args", $P741
.annotate 'line', 356
    find_lex $P742, "%args"
    unless_null $P742, vivify_904
    $P742 = root_new ['parrot';'Hash']
  vivify_904:
.annotate 'line', 360
    find_lex $P743, "$/"
    unless_null $P743, vivify_905
    $P743 = root_new ['parrot';'Hash']
  vivify_905:
    set $P744, $P743["name"]
    unless_null $P744, vivify_906
    new $P744, "Undef"
  vivify_906:
    set $S745, $P744
    new $P746, 'String'
    set $P746, $S745
    find_lex $P747, "%args"
    unless_null $P747, vivify_907
    $P747 = root_new ['parrot';'Hash']
    store_lex "%args", $P747
  vivify_907:
    set $P747["name"], $P746
.annotate 'line', 361
    find_lex $P749, "$/"
    unless_null $P749, vivify_908
    $P749 = root_new ['parrot';'Hash']
  vivify_908:
    set $P750, $P749["repr"]
    unless_null $P750, vivify_909
    new $P750, "Undef"
  vivify_909:
    unless $P750, if_748_end
.annotate 'line', 362
    find_lex $P751, "$/"
    unless_null $P751, vivify_910
    $P751 = root_new ['parrot';'Hash']
  vivify_910:
    set $P752, $P751["repr"]
    unless_null $P752, vivify_911
    $P752 = root_new ['parrot';'ResizablePMCArray']
  vivify_911:
    set $P753, $P752[0]
    unless_null $P753, vivify_912
    $P753 = root_new ['parrot';'Hash']
  vivify_912:
    set $P754, $P753["quote_delimited"]
    unless_null $P754, vivify_913
    $P754 = root_new ['parrot';'Hash']
  vivify_913:
    set $P755, $P754["quote_atom"]
    unless_null $P755, vivify_914
    $P755 = root_new ['parrot';'ResizablePMCArray']
  vivify_914:
    set $P756, $P755[0]
    unless_null $P756, vivify_915
    new $P756, "Undef"
  vivify_915:
    set $S757, $P756
    new $P758, 'String'
    set $P758, $S757
    find_lex $P759, "%args"
    unless_null $P759, vivify_916
    $P759 = root_new ['parrot';'Hash']
    store_lex "%args", $P759
  vivify_916:
    set $P759["repr"], $P758
  if_748_end:
.annotate 'line', 364
    find_dynamic_lex $P760, "$*SC"
    unless_null $P760, vivify_917
    get_hll_global $P760, "$SC"
    unless_null $P760, vivify_918
    die "Contextual $*SC not found"
  vivify_918:
  vivify_917:
    find_dynamic_lex $P761, "$*PKGDECL"
    unless_null $P761, vivify_919
    get_hll_global $P761, "$PKGDECL"
    unless_null $P761, vivify_920
    die "Contextual $*PKGDECL not found"
  vivify_920:
  vivify_919:
    find_dynamic_lex $P762, "%*HOW"
    unless_null $P762, vivify_921
    get_hll_global $P762, "%HOW"
    unless_null $P762, vivify_922
    die "Contextual %*HOW not found"
  vivify_922:
  vivify_921:
    set $P763, $P762[$P761]
    unless_null $P763, vivify_923
    new $P763, "Undef"
  vivify_923:
    find_lex $P764, "%args"
    unless_null $P764, vivify_924
    $P764 = root_new ['parrot';'Hash']
  vivify_924:
    $P765 = $P760."pkg_create_mo"($P763, $P764 :flat)
    store_dynamic_lex "$*PACKAGE", $P765
.annotate 'line', 367
    find_dynamic_lex $P770, "$*SCOPE"
    unless_null $P770, vivify_925
    get_hll_global $P770, "$SCOPE"
    unless_null $P770, vivify_926
    die "Contextual $*SCOPE not found"
  vivify_926:
  vivify_925:
    set $S771, $P770
    iseq $I772, $S771, "our"
    unless $I772, unless_769
    new $P768, 'Integer'
    set $P768, $I772
    goto unless_769_end
  unless_769:
    find_dynamic_lex $P773, "$*SCOPE"
    unless_null $P773, vivify_927
    get_hll_global $P773, "$SCOPE"
    unless_null $P773, vivify_928
    die "Contextual $*SCOPE not found"
  vivify_928:
  vivify_927:
    set $S774, $P773
    iseq $I775, $S774, ""
    new $P768, 'Integer'
    set $P768, $I775
  unless_769_end:
    if $P768, if_767
.annotate 'line', 373
    find_dynamic_lex $P802, "$*SCOPE"
    unless_null $P802, vivify_929
    get_hll_global $P802, "$SCOPE"
    unless_null $P802, vivify_930
    die "Contextual $*SCOPE not found"
  vivify_930:
  vivify_929:
    set $S803, $P802
    iseq $I804, $S803, "my"
    if $I804, if_801
.annotate 'line', 380
    find_lex $P825, "$/"
    unless_null $P825, vivify_931
    new $P825, "Undef"
  vivify_931:
    $P826 = $P825."CURSOR"()
    find_dynamic_lex $P827, "$*SCOPE"
    unless_null $P827, vivify_932
    get_hll_global $P827, "$SCOPE"
    unless_null $P827, vivify_933
    die "Contextual $*SCOPE not found"
  vivify_933:
  vivify_932:
    concat $P828, $P827, " scoped packages are not supported"
    $P829 = $P826."panic"($P828)
.annotate 'line', 379
    set $P800, $P829
.annotate 'line', 373
    goto if_801_end
  if_801:
.annotate 'line', 374
    find_lex $P806, "$/"
    unless_null $P806, vivify_934
    $P806 = root_new ['parrot';'Hash']
  vivify_934:
    set $P807, $P806["name"]
    unless_null $P807, vivify_935
    $P807 = root_new ['parrot';'Hash']
  vivify_935:
    set $P808, $P807["identifier"]
    unless_null $P808, vivify_936
    new $P808, "Undef"
  vivify_936:
    set $N809, $P808
    isne $I810, $N809, 1.0
    unless $I810, if_805_end
.annotate 'line', 375
    find_lex $P811, "$/"
    unless_null $P811, vivify_937
    $P811 = root_new ['parrot';'Hash']
  vivify_937:
    set $P812, $P811["name"]
    unless_null $P812, vivify_938
    new $P812, "Undef"
  vivify_938:
    $P813 = $P812."CURSOR"()
    $P813."panic"("A my scoped package cannot have a multi-part name yet")
  if_805_end:
.annotate 'line', 377
    find_dynamic_lex $P814, "$*SC"
    unless_null $P814, vivify_939
    get_hll_global $P814, "$SC"
    unless_null $P814, vivify_940
    die "Contextual $*SC not found"
  vivify_940:
  vivify_939:
    get_hll_global $P815, ["NQP"], "Actions"
    get_who $P816, $P815
    set $P817, $P816["@BLOCK"]
    unless_null $P817, vivify_941
    $P817 = root_new ['parrot';'ResizablePMCArray']
  vivify_941:
    set $P818, $P817[0]
    unless_null $P818, vivify_942
    new $P818, "Undef"
  vivify_942:
    find_lex $P819, "$/"
    unless_null $P819, vivify_943
    $P819 = root_new ['parrot';'Hash']
  vivify_943:
    set $P820, $P819["name"]
    unless_null $P820, vivify_944
    $P820 = root_new ['parrot';'Hash']
  vivify_944:
    set $P821, $P820["identifier"]
    unless_null $P821, vivify_945
    $P821 = root_new ['parrot';'ResizablePMCArray']
  vivify_945:
    set $P822, $P821[0]
    unless_null $P822, vivify_946
    new $P822, "Undef"
  vivify_946:
    find_dynamic_lex $P823, "$*PACKAGE"
    unless_null $P823, vivify_947
    get_hll_global $P823, "$PACKAGE"
    unless_null $P823, vivify_948
    die "Contextual $*PACKAGE not found"
  vivify_948:
  vivify_947:
    $P824 = $P814."install_lexical_symbol"($P818, $P822, $P823)
.annotate 'line', 373
    set $P800, $P824
  if_801_end:
    set $P766, $P800
.annotate 'line', 367
    goto if_767_end
  if_767:
.annotate 'line', 368
    find_dynamic_lex $P776, "$*SC"
    unless_null $P776, vivify_949
    get_hll_global $P776, "$SC"
    unless_null $P776, vivify_950
    die "Contextual $*SC not found"
  vivify_950:
  vivify_949:
    find_dynamic_lex $P777, "$*OUTERPACKAGE"
    unless_null $P777, vivify_951
    get_hll_global $P777, "$OUTERPACKAGE"
    unless_null $P777, vivify_952
    die "Contextual $*OUTERPACKAGE not found"
  vivify_952:
  vivify_951:
    find_lex $P778, "$/"
    unless_null $P778, vivify_953
    $P778 = root_new ['parrot';'Hash']
  vivify_953:
    set $P779, $P778["name"]
    unless_null $P779, vivify_954
    $P779 = root_new ['parrot';'Hash']
  vivify_954:
    set $P780, $P779["identifier"]
    unless_null $P780, vivify_955
    new $P780, "Undef"
  vivify_955:
    find_dynamic_lex $P781, "$*PACKAGE"
    unless_null $P781, vivify_956
    get_hll_global $P781, "$PACKAGE"
    unless_null $P781, vivify_957
    die "Contextual $*PACKAGE not found"
  vivify_957:
  vivify_956:
    $P776."install_package_symbol"($P777, $P780, $P781)
.annotate 'line', 369
    find_lex $P784, "$/"
    unless_null $P784, vivify_958
    $P784 = root_new ['parrot';'Hash']
  vivify_958:
    set $P785, $P784["name"]
    unless_null $P785, vivify_959
    $P785 = root_new ['parrot';'Hash']
  vivify_959:
    set $P786, $P785["identifier"]
    unless_null $P786, vivify_960
    new $P786, "Undef"
  vivify_960:
    set $N787, $P786
    iseq $I788, $N787, 1.0
    if $I788, if_783
    new $P782, 'Integer'
    set $P782, $I788
    goto if_783_end
  if_783:
.annotate 'line', 370
    find_dynamic_lex $P789, "$*SC"
    unless_null $P789, vivify_961
    get_hll_global $P789, "$SC"
    unless_null $P789, vivify_962
    die "Contextual $*SC not found"
  vivify_962:
  vivify_961:
    get_hll_global $P790, ["NQP"], "Actions"
    get_who $P791, $P790
    set $P792, $P791["@BLOCK"]
    unless_null $P792, vivify_963
    $P792 = root_new ['parrot';'ResizablePMCArray']
  vivify_963:
    set $P793, $P792[0]
    unless_null $P793, vivify_964
    new $P793, "Undef"
  vivify_964:
    find_lex $P794, "$/"
    unless_null $P794, vivify_965
    $P794 = root_new ['parrot';'Hash']
  vivify_965:
    set $P795, $P794["name"]
    unless_null $P795, vivify_966
    $P795 = root_new ['parrot';'Hash']
  vivify_966:
    set $P796, $P795["identifier"]
    unless_null $P796, vivify_967
    $P796 = root_new ['parrot';'ResizablePMCArray']
  vivify_967:
    set $P797, $P796[0]
    unless_null $P797, vivify_968
    new $P797, "Undef"
  vivify_968:
    find_dynamic_lex $P798, "$*PACKAGE"
    unless_null $P798, vivify_969
    get_hll_global $P798, "$PACKAGE"
    unless_null $P798, vivify_970
    die "Contextual $*PACKAGE not found"
  vivify_970:
  vivify_969:
    $P799 = $P789."install_lexical_symbol"($P793, $P797, $P798)
.annotate 'line', 369
    set $P782, $P799
  if_783_end:
.annotate 'line', 367
    set $P766, $P782
  if_767_end:
.annotate 'line', 356
    .return ($P766)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303576195.699")
    .param pmc param_853
.annotate 'line', 393
    .lex "self", param_853
    $P854 = param_853."!protoregex"("scope_declarator")
    .return ($P854)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303576195.699")
    .param pmc param_856
.annotate 'line', 393
    .lex "self", param_856
    $P857 = param_856."!PREFIX__!protoregex"("scope_declarator")
    .return ($P857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx859_tgt
    .local int rx859_pos
    .local int rx859_off
    .local int rx859_eos
    .local int rx859_rep
    .local pmc rx859_cur
    .local pmc rx859_debug
    (rx859_cur, rx859_pos, rx859_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx859_cur
    .local pmc match
    .lex "$/", match
    length rx859_eos, rx859_tgt
    gt rx859_pos, rx859_eos, rx859_done
    set rx859_off, 0
    lt rx859_pos, 2, rx859_start
    sub rx859_off, rx859_pos, 1
    substr rx859_tgt, rx859_tgt, rx859_off
  rx859_start:
    eq $I10, 1, rx859_restart
    if_null rx859_debug, debug_974
    rx859_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan863_done
    goto rxscan863_scan
  rxscan863_loop:
    (rx859_pos) = rx859_cur."from"()
    inc rx859_pos
    rx859_cur."!cursor_from"(rx859_pos)
    ge rx859_pos, rx859_eos, rxscan863_done
  rxscan863_scan:
    set_addr $I10, rxscan863_loop
    rx859_cur."!mark_push"(0, rx859_pos, $I10)
  rxscan863_done:
.annotate 'line', 394
  # rx subcapture "sym"
    set_addr $I10, rxcap_864_fail
    rx859_cur."!mark_push"(0, rx859_pos, $I10)
  # rx literal  "my"
    add $I11, rx859_pos, 2
    gt $I11, rx859_eos, rx859_fail
    sub $I11, rx859_pos, rx859_off
    substr $S10, rx859_tgt, $I11, 2
    ne $S10, "my", rx859_fail
    add rx859_pos, 2
    set_addr $I10, rxcap_864_fail
    ($I12, $I11) = rx859_cur."!mark_peek"($I10)
    rx859_cur."!cursor_pos"($I11)
    ($P10) = rx859_cur."!cursor_start"()
    $P10."!cursor_pass"(rx859_pos, "")
    rx859_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_864_done
  rxcap_864_fail:
    goto rx859_fail
  rxcap_864_done:
  # rx subrule "scoped" subtype=capture negate=
    rx859_cur."!cursor_pos"(rx859_pos)
    $P10 = rx859_cur."scoped"("my")
    unless $P10, rx859_fail
    rx859_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx859_pos = $P10."pos"()
  # rx pass
    rx859_cur."!cursor_pass"(rx859_pos, "scope_declarator:sym<my>")
    if_null rx859_debug, debug_975
    rx859_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx859_pos)
  debug_975:
    .return (rx859_cur)
  rx859_restart:
.annotate 'line', 10
    if_null rx859_debug, debug_976
    rx859_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_976:
  rx859_fail:
    (rx859_rep, rx859_pos, $I10, $P10) = rx859_cur."!mark_fail"(0)
    lt rx859_pos, -1, rx859_done
    eq rx859_pos, -1, rx859_fail
    jump $I10
  rx859_done:
    rx859_cur."!cursor_fail"()
    if_null rx859_debug, debug_977
    rx859_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_977:
    .return (rx859_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303576195.699") :method
.annotate 'line', 10
    $P861 = self."!PREFIX__!subrule"("scoped", "my")
    new $P862, "ResizablePMCArray"
    push $P862, $P861
    .return ($P862)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx866_tgt
    .local int rx866_pos
    .local int rx866_off
    .local int rx866_eos
    .local int rx866_rep
    .local pmc rx866_cur
    .local pmc rx866_debug
    (rx866_cur, rx866_pos, rx866_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx866_cur
    .local pmc match
    .lex "$/", match
    length rx866_eos, rx866_tgt
    gt rx866_pos, rx866_eos, rx866_done
    set rx866_off, 0
    lt rx866_pos, 2, rx866_start
    sub rx866_off, rx866_pos, 1
    substr rx866_tgt, rx866_tgt, rx866_off
  rx866_start:
    eq $I10, 1, rx866_restart
    if_null rx866_debug, debug_978
    rx866_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan870_done
    goto rxscan870_scan
  rxscan870_loop:
    (rx866_pos) = rx866_cur."from"()
    inc rx866_pos
    rx866_cur."!cursor_from"(rx866_pos)
    ge rx866_pos, rx866_eos, rxscan870_done
  rxscan870_scan:
    set_addr $I10, rxscan870_loop
    rx866_cur."!mark_push"(0, rx866_pos, $I10)
  rxscan870_done:
.annotate 'line', 395
  # rx subcapture "sym"
    set_addr $I10, rxcap_871_fail
    rx866_cur."!mark_push"(0, rx866_pos, $I10)
  # rx literal  "our"
    add $I11, rx866_pos, 3
    gt $I11, rx866_eos, rx866_fail
    sub $I11, rx866_pos, rx866_off
    substr $S10, rx866_tgt, $I11, 3
    ne $S10, "our", rx866_fail
    add rx866_pos, 3
    set_addr $I10, rxcap_871_fail
    ($I12, $I11) = rx866_cur."!mark_peek"($I10)
    rx866_cur."!cursor_pos"($I11)
    ($P10) = rx866_cur."!cursor_start"()
    $P10."!cursor_pass"(rx866_pos, "")
    rx866_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_871_done
  rxcap_871_fail:
    goto rx866_fail
  rxcap_871_done:
  # rx subrule "scoped" subtype=capture negate=
    rx866_cur."!cursor_pos"(rx866_pos)
    $P10 = rx866_cur."scoped"("our")
    unless $P10, rx866_fail
    rx866_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx866_pos = $P10."pos"()
  # rx pass
    rx866_cur."!cursor_pass"(rx866_pos, "scope_declarator:sym<our>")
    if_null rx866_debug, debug_979
    rx866_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx866_pos)
  debug_979:
    .return (rx866_cur)
  rx866_restart:
.annotate 'line', 10
    if_null rx866_debug, debug_980
    rx866_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_980:
  rx866_fail:
    (rx866_rep, rx866_pos, $I10, $P10) = rx866_cur."!mark_fail"(0)
    lt rx866_pos, -1, rx866_done
    eq rx866_pos, -1, rx866_fail
    jump $I10
  rx866_done:
    rx866_cur."!cursor_fail"()
    if_null rx866_debug, debug_981
    rx866_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_981:
    .return (rx866_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303576195.699") :method
.annotate 'line', 10
    $P868 = self."!PREFIX__!subrule"("scoped", "our")
    new $P869, "ResizablePMCArray"
    push $P869, $P868
    .return ($P869)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx873_tgt
    .local int rx873_pos
    .local int rx873_off
    .local int rx873_eos
    .local int rx873_rep
    .local pmc rx873_cur
    .local pmc rx873_debug
    (rx873_cur, rx873_pos, rx873_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx873_cur
    .local pmc match
    .lex "$/", match
    length rx873_eos, rx873_tgt
    gt rx873_pos, rx873_eos, rx873_done
    set rx873_off, 0
    lt rx873_pos, 2, rx873_start
    sub rx873_off, rx873_pos, 1
    substr rx873_tgt, rx873_tgt, rx873_off
  rx873_start:
    eq $I10, 1, rx873_restart
    if_null rx873_debug, debug_982
    rx873_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan877_done
    goto rxscan877_scan
  rxscan877_loop:
    (rx873_pos) = rx873_cur."from"()
    inc rx873_pos
    rx873_cur."!cursor_from"(rx873_pos)
    ge rx873_pos, rx873_eos, rxscan877_done
  rxscan877_scan:
    set_addr $I10, rxscan877_loop
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxscan877_done:
.annotate 'line', 396
  # rx subcapture "sym"
    set_addr $I10, rxcap_878_fail
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx literal  "has"
    add $I11, rx873_pos, 3
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    substr $S10, rx873_tgt, $I11, 3
    ne $S10, "has", rx873_fail
    add rx873_pos, 3
    set_addr $I10, rxcap_878_fail
    ($I12, $I11) = rx873_cur."!mark_peek"($I10)
    rx873_cur."!cursor_pos"($I11)
    ($P10) = rx873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx873_pos, "")
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_878_done
  rxcap_878_fail:
    goto rx873_fail
  rxcap_878_done:
  # rx subrule "scoped" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."scoped"("has")
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx873_pos = $P10."pos"()
  # rx pass
    rx873_cur."!cursor_pass"(rx873_pos, "scope_declarator:sym<has>")
    if_null rx873_debug, debug_983
    rx873_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx873_pos)
  debug_983:
    .return (rx873_cur)
  rx873_restart:
.annotate 'line', 10
    if_null rx873_debug, debug_984
    rx873_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_984:
  rx873_fail:
    (rx873_rep, rx873_pos, $I10, $P10) = rx873_cur."!mark_fail"(0)
    lt rx873_pos, -1, rx873_done
    eq rx873_pos, -1, rx873_fail
    jump $I10
  rx873_done:
    rx873_cur."!cursor_fail"()
    if_null rx873_debug, debug_985
    rx873_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_985:
    .return (rx873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303576195.699") :method
.annotate 'line', 10
    $P875 = self."!PREFIX__!subrule"("scoped", "has")
    new $P876, "ResizablePMCArray"
    push $P876, $P875
    .return ($P876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303576195.699") :method :outer("12_1303576195.699")
    .param pmc param_880
.annotate 'line', 398
    .lex "$*SCOPE", param_880
.annotate 'line', 10
    .local string rx881_tgt
    .local int rx881_pos
    .local int rx881_off
    .local int rx881_eos
    .local int rx881_rep
    .local pmc rx881_cur
    .local pmc rx881_debug
    (rx881_cur, rx881_pos, rx881_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx881_cur
    .local pmc match
    .lex "$/", match
    length rx881_eos, rx881_tgt
    gt rx881_pos, rx881_eos, rx881_done
    set rx881_off, 0
    lt rx881_pos, 2, rx881_start
    sub rx881_off, rx881_pos, 1
    substr rx881_tgt, rx881_tgt, rx881_off
  rx881_start:
    eq $I10, 1, rx881_restart
    if_null rx881_debug, debug_986
    rx881_cur."!cursor_debug"("START", "scoped")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan887_done
    goto rxscan887_scan
  rxscan887_loop:
    (rx881_pos) = rx881_cur."from"()
    inc rx881_pos
    rx881_cur."!cursor_from"(rx881_pos)
    ge rx881_pos, rx881_eos, rxscan887_done
  rxscan887_scan:
    set_addr $I10, rxscan887_loop
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxscan887_done:
  alt888_0:
.annotate 'line', 398
    set_addr $I10, alt888_1
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
.annotate 'line', 399
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."declarator"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
    goto alt888_end
  alt888_1:
    set_addr $I10, alt888_2
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
.annotate 'line', 400
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."multi_declarator"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
    goto alt888_end
  alt888_2:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."package_declarator"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  alt888_end:
.annotate 'line', 398
  # rx pass
    rx881_cur."!cursor_pass"(rx881_pos, "scoped")
    if_null rx881_debug, debug_987
    rx881_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx881_pos)
  debug_987:
    .return (rx881_cur)
  rx881_restart:
.annotate 'line', 10
    if_null rx881_debug, debug_988
    rx881_cur."!cursor_debug"("NEXT", "scoped")
  debug_988:
  rx881_fail:
    (rx881_rep, rx881_pos, $I10, $P10) = rx881_cur."!mark_fail"(0)
    lt rx881_pos, -1, rx881_done
    eq rx881_pos, -1, rx881_fail
    jump $I10
  rx881_done:
    rx881_cur."!cursor_fail"()
    if_null rx881_debug, debug_989
    rx881_cur."!cursor_debug"("FAIL", "scoped")
  debug_989:
    .return (rx881_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303576195.699") :method
.annotate 'line', 10
    $P883 = self."!PREFIX__!subrule"("ws", "")
    $P884 = self."!PREFIX__!subrule"("ws", "")
    $P885 = self."!PREFIX__!subrule"("ws", "")
    new $P886, "ResizablePMCArray"
    push $P886, $P883
    push $P886, $P884
    push $P886, $P885
    .return ($P886)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx896_tgt
    .local int rx896_pos
    .local int rx896_off
    .local int rx896_eos
    .local int rx896_rep
    .local pmc rx896_cur
    .local pmc rx896_debug
    (rx896_cur, rx896_pos, rx896_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx896_cur
    .local pmc match
    .lex "$/", match
    length rx896_eos, rx896_tgt
    gt rx896_pos, rx896_eos, rx896_done
    set rx896_off, 0
    lt rx896_pos, 2, rx896_start
    sub rx896_off, rx896_pos, 1
    substr rx896_tgt, rx896_tgt, rx896_off
  rx896_start:
    eq $I10, 1, rx896_restart
    if_null rx896_debug, debug_990
    rx896_cur."!cursor_debug"("START", "typename")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan900_done
    goto rxscan900_scan
  rxscan900_loop:
    (rx896_pos) = rx896_cur."from"()
    inc rx896_pos
    rx896_cur."!cursor_from"(rx896_pos)
    ge rx896_pos, rx896_eos, rxscan900_done
  rxscan900_scan:
    set_addr $I10, rxscan900_loop
    rx896_cur."!mark_push"(0, rx896_pos, $I10)
  rxscan900_done:
.annotate 'line', 404
  # rx subrule "name" subtype=capture negate=
    rx896_cur."!cursor_pos"(rx896_pos)
    $P10 = rx896_cur."name"()
    unless $P10, rx896_fail
    rx896_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx896_pos = $P10."pos"()
  # rx pass
    rx896_cur."!cursor_pass"(rx896_pos, "typename")
    if_null rx896_debug, debug_991
    rx896_cur."!cursor_debug"("PASS", "typename", " at pos=", rx896_pos)
  debug_991:
    .return (rx896_cur)
  rx896_restart:
.annotate 'line', 10
    if_null rx896_debug, debug_992
    rx896_cur."!cursor_debug"("NEXT", "typename")
  debug_992:
  rx896_fail:
    (rx896_rep, rx896_pos, $I10, $P10) = rx896_cur."!mark_fail"(0)
    lt rx896_pos, -1, rx896_done
    eq rx896_pos, -1, rx896_fail
    jump $I10
  rx896_done:
    rx896_cur."!cursor_fail"()
    if_null rx896_debug, debug_993
    rx896_cur."!cursor_debug"("FAIL", "typename")
  debug_993:
    .return (rx896_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303576195.699") :method
.annotate 'line', 10
    $P898 = self."!PREFIX__!subrule"("name", "")
    new $P899, "ResizablePMCArray"
    push $P899, $P898
    .return ($P899)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx902_tgt
    .local int rx902_pos
    .local int rx902_off
    .local int rx902_eos
    .local int rx902_rep
    .local pmc rx902_cur
    .local pmc rx902_debug
    (rx902_cur, rx902_pos, rx902_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx902_cur
    .local pmc match
    .lex "$/", match
    length rx902_eos, rx902_tgt
    gt rx902_pos, rx902_eos, rx902_done
    set rx902_off, 0
    lt rx902_pos, 2, rx902_start
    sub rx902_off, rx902_pos, 1
    substr rx902_tgt, rx902_tgt, rx902_off
  rx902_start:
    eq $I10, 1, rx902_restart
    if_null rx902_debug, debug_994
    rx902_cur."!cursor_debug"("START", "declarator")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan907_done
    goto rxscan907_scan
  rxscan907_loop:
    (rx902_pos) = rx902_cur."from"()
    inc rx902_pos
    rx902_cur."!cursor_from"(rx902_pos)
    ge rx902_pos, rx902_eos, rxscan907_done
  rxscan907_scan:
    set_addr $I10, rxscan907_loop
    rx902_cur."!mark_push"(0, rx902_pos, $I10)
  rxscan907_done:
  alt908_0:
.annotate 'line', 406
    set_addr $I10, alt908_1
    rx902_cur."!mark_push"(0, rx902_pos, $I10)
.annotate 'line', 407
  # rx subrule "variable_declarator" subtype=capture negate=
    rx902_cur."!cursor_pos"(rx902_pos)
    $P10 = rx902_cur."variable_declarator"()
    unless $P10, rx902_fail
    rx902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx902_pos = $P10."pos"()
    goto alt908_end
  alt908_1:
.annotate 'line', 408
  # rx subrule "routine_declarator" subtype=capture negate=
    rx902_cur."!cursor_pos"(rx902_pos)
    $P10 = rx902_cur."routine_declarator"()
    unless $P10, rx902_fail
    rx902_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx902_pos = $P10."pos"()
  alt908_end:
.annotate 'line', 406
  # rx pass
    rx902_cur."!cursor_pass"(rx902_pos, "declarator")
    if_null rx902_debug, debug_995
    rx902_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx902_pos)
  debug_995:
    .return (rx902_cur)
  rx902_restart:
.annotate 'line', 10
    if_null rx902_debug, debug_996
    rx902_cur."!cursor_debug"("NEXT", "declarator")
  debug_996:
  rx902_fail:
    (rx902_rep, rx902_pos, $I10, $P10) = rx902_cur."!mark_fail"(0)
    lt rx902_pos, -1, rx902_done
    eq rx902_pos, -1, rx902_fail
    jump $I10
  rx902_done:
    rx902_cur."!cursor_fail"()
    if_null rx902_debug, debug_997
    rx902_cur."!cursor_debug"("FAIL", "declarator")
  debug_997:
    .return (rx902_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303576195.699") :method
.annotate 'line', 10
    $P904 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P905 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P906, "ResizablePMCArray"
    push $P906, $P904
    push $P906, $P905
    .return ($P906)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx910_tgt
    .local int rx910_pos
    .local int rx910_off
    .local int rx910_eos
    .local int rx910_rep
    .local pmc rx910_cur
    .local pmc rx910_debug
    (rx910_cur, rx910_pos, rx910_tgt, $I10) = self."!cursor_start"()
    rx910_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx910_cur
    .local pmc match
    .lex "$/", match
    length rx910_eos, rx910_tgt
    gt rx910_pos, rx910_eos, rx910_done
    set rx910_off, 0
    lt rx910_pos, 2, rx910_start
    sub rx910_off, rx910_pos, 1
    substr rx910_tgt, rx910_tgt, rx910_off
  rx910_start:
    eq $I10, 1, rx910_restart
    if_null rx910_debug, debug_998
    rx910_cur."!cursor_debug"("START", "variable_declarator")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan914_done
    goto rxscan914_scan
  rxscan914_loop:
    (rx910_pos) = rx910_cur."from"()
    inc rx910_pos
    rx910_cur."!cursor_from"(rx910_pos)
    ge rx910_pos, rx910_eos, rxscan914_done
  rxscan914_scan:
    set_addr $I10, rxscan914_loop
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxscan914_done:
.annotate 'line', 411
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  # rx rxquantr916 ** 0..1
    set_addr $I10, rxquantr916_done
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxquantr916_loop:
  # rx subrule "typename" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."typename"()
    unless $P10, rx910_fail
    goto rxsubrule917_pass
  rxsubrule917_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx910_fail
  rxsubrule917_pass:
    set_addr $I10, rxsubrule917_back
    rx910_cur."!mark_push"(0, rx910_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx910_pos = $P10."pos"()
    set_addr $I10, rxquantr916_done
    (rx910_rep) = rx910_cur."!mark_commit"($I10)
  rxquantr916_done:
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."variable"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx910_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ws"()
    unless $P10, rx910_fail
    rx910_pos = $P10."pos"()
  # rx pass
    rx910_cur."!cursor_pass"(rx910_pos, "variable_declarator")
    if_null rx910_debug, debug_999
    rx910_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx910_pos)
  debug_999:
    .return (rx910_cur)
  rx910_restart:
.annotate 'line', 10
    if_null rx910_debug, debug_1000
    rx910_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1000:
  rx910_fail:
    (rx910_rep, rx910_pos, $I10, $P10) = rx910_cur."!mark_fail"(0)
    lt rx910_pos, -1, rx910_done
    eq rx910_pos, -1, rx910_fail
    jump $I10
  rx910_done:
    rx910_cur."!cursor_fail"()
    if_null rx910_debug, debug_1001
    rx910_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1001:
    .return (rx910_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303576195.699") :method
.annotate 'line', 10
    $P912 = self."!PREFIX__!subrule"("ws", "")
    new $P913, "ResizablePMCArray"
    push $P913, $P912
    .return ($P913)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303576195.699")
    .param pmc param_921
.annotate 'line', 413
    .lex "self", param_921
    $P922 = param_921."!protoregex"("routine_declarator")
    .return ($P922)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303576195.699")
    .param pmc param_924
.annotate 'line', 413
    .lex "self", param_924
    $P925 = param_924."!PREFIX__!protoregex"("routine_declarator")
    .return ($P925)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx927_tgt
    .local int rx927_pos
    .local int rx927_off
    .local int rx927_eos
    .local int rx927_rep
    .local pmc rx927_cur
    .local pmc rx927_debug
    (rx927_cur, rx927_pos, rx927_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx927_cur
    .local pmc match
    .lex "$/", match
    length rx927_eos, rx927_tgt
    gt rx927_pos, rx927_eos, rx927_done
    set rx927_off, 0
    lt rx927_pos, 2, rx927_start
    sub rx927_off, rx927_pos, 1
    substr rx927_tgt, rx927_tgt, rx927_off
  rx927_start:
    eq $I10, 1, rx927_restart
    if_null rx927_debug, debug_1002
    rx927_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan931_done
    goto rxscan931_scan
  rxscan931_loop:
    (rx927_pos) = rx927_cur."from"()
    inc rx927_pos
    rx927_cur."!cursor_from"(rx927_pos)
    ge rx927_pos, rx927_eos, rxscan931_done
  rxscan931_scan:
    set_addr $I10, rxscan931_loop
    rx927_cur."!mark_push"(0, rx927_pos, $I10)
  rxscan931_done:
.annotate 'line', 414
  # rx subcapture "sym"
    set_addr $I10, rxcap_932_fail
    rx927_cur."!mark_push"(0, rx927_pos, $I10)
  # rx literal  "sub"
    add $I11, rx927_pos, 3
    gt $I11, rx927_eos, rx927_fail
    sub $I11, rx927_pos, rx927_off
    substr $S10, rx927_tgt, $I11, 3
    ne $S10, "sub", rx927_fail
    add rx927_pos, 3
    set_addr $I10, rxcap_932_fail
    ($I12, $I11) = rx927_cur."!mark_peek"($I10)
    rx927_cur."!cursor_pos"($I11)
    ($P10) = rx927_cur."!cursor_start"()
    $P10."!cursor_pass"(rx927_pos, "")
    rx927_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_932_done
  rxcap_932_fail:
    goto rx927_fail
  rxcap_932_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx927_cur."!cursor_pos"(rx927_pos)
    $P10 = rx927_cur."routine_def"()
    unless $P10, rx927_fail
    rx927_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx927_pos = $P10."pos"()
  # rx pass
    rx927_cur."!cursor_pass"(rx927_pos, "routine_declarator:sym<sub>")
    if_null rx927_debug, debug_1003
    rx927_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx927_pos)
  debug_1003:
    .return (rx927_cur)
  rx927_restart:
.annotate 'line', 10
    if_null rx927_debug, debug_1004
    rx927_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1004:
  rx927_fail:
    (rx927_rep, rx927_pos, $I10, $P10) = rx927_cur."!mark_fail"(0)
    lt rx927_pos, -1, rx927_done
    eq rx927_pos, -1, rx927_fail
    jump $I10
  rx927_done:
    rx927_cur."!cursor_fail"()
    if_null rx927_debug, debug_1005
    rx927_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1005:
    .return (rx927_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303576195.699") :method
.annotate 'line', 10
    $P929 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P930, "ResizablePMCArray"
    push $P930, $P929
    .return ($P930)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx934_tgt
    .local int rx934_pos
    .local int rx934_off
    .local int rx934_eos
    .local int rx934_rep
    .local pmc rx934_cur
    .local pmc rx934_debug
    (rx934_cur, rx934_pos, rx934_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx934_cur
    .local pmc match
    .lex "$/", match
    length rx934_eos, rx934_tgt
    gt rx934_pos, rx934_eos, rx934_done
    set rx934_off, 0
    lt rx934_pos, 2, rx934_start
    sub rx934_off, rx934_pos, 1
    substr rx934_tgt, rx934_tgt, rx934_off
  rx934_start:
    eq $I10, 1, rx934_restart
    if_null rx934_debug, debug_1006
    rx934_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1006:
    $I10 = self.'from'()
    ne $I10, -1, rxscan938_done
    goto rxscan938_scan
  rxscan938_loop:
    (rx934_pos) = rx934_cur."from"()
    inc rx934_pos
    rx934_cur."!cursor_from"(rx934_pos)
    ge rx934_pos, rx934_eos, rxscan938_done
  rxscan938_scan:
    set_addr $I10, rxscan938_loop
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  rxscan938_done:
.annotate 'line', 415
  # rx subcapture "sym"
    set_addr $I10, rxcap_939_fail
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  # rx literal  "method"
    add $I11, rx934_pos, 6
    gt $I11, rx934_eos, rx934_fail
    sub $I11, rx934_pos, rx934_off
    substr $S10, rx934_tgt, $I11, 6
    ne $S10, "method", rx934_fail
    add rx934_pos, 6
    set_addr $I10, rxcap_939_fail
    ($I12, $I11) = rx934_cur."!mark_peek"($I10)
    rx934_cur."!cursor_pos"($I11)
    ($P10) = rx934_cur."!cursor_start"()
    $P10."!cursor_pass"(rx934_pos, "")
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_939_done
  rxcap_939_fail:
    goto rx934_fail
  rxcap_939_done:
  # rx subrule "method_def" subtype=capture negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."method_def"()
    unless $P10, rx934_fail
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx934_pos = $P10."pos"()
  # rx pass
    rx934_cur."!cursor_pass"(rx934_pos, "routine_declarator:sym<method>")
    if_null rx934_debug, debug_1007
    rx934_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx934_pos)
  debug_1007:
    .return (rx934_cur)
  rx934_restart:
.annotate 'line', 10
    if_null rx934_debug, debug_1008
    rx934_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1008:
  rx934_fail:
    (rx934_rep, rx934_pos, $I10, $P10) = rx934_cur."!mark_fail"(0)
    lt rx934_pos, -1, rx934_done
    eq rx934_pos, -1, rx934_fail
    jump $I10
  rx934_done:
    rx934_cur."!cursor_fail"()
    if_null rx934_debug, debug_1009
    rx934_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1009:
    .return (rx934_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303576195.699") :method
.annotate 'line', 10
    $P936 = self."!PREFIX__!subrule"("method_def", "method")
    new $P937, "ResizablePMCArray"
    push $P937, $P936
    .return ($P937)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 418
    new $P941, "Undef"
    .lex "$*RETURN_USED", $P941
.annotate 'line', 10
    .local string rx942_tgt
    .local int rx942_pos
    .local int rx942_off
    .local int rx942_eos
    .local int rx942_rep
    .local pmc rx942_cur
    .local pmc rx942_debug
    (rx942_cur, rx942_pos, rx942_tgt, $I10) = self."!cursor_start"()
    rx942_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx942_cur
    .local pmc match
    .lex "$/", match
    length rx942_eos, rx942_tgt
    gt rx942_pos, rx942_eos, rx942_done
    set rx942_off, 0
    lt rx942_pos, 2, rx942_start
    sub rx942_off, rx942_pos, 1
    substr rx942_tgt, rx942_tgt, rx942_off
  rx942_start:
    eq $I10, 1, rx942_restart
    if_null rx942_debug, debug_1010
    rx942_cur."!cursor_debug"("START", "routine_def")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan946_done
    goto rxscan946_scan
  rxscan946_loop:
    (rx942_pos) = rx942_cur."from"()
    inc rx942_pos
    rx942_cur."!cursor_from"(rx942_pos)
    ge rx942_pos, rx942_eos, rxscan946_done
  rxscan946_scan:
    set_addr $I10, rxscan946_loop
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxscan946_done:
.annotate 'line', 417
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 418
    rx942_cur."!cursor_pos"(rx942_pos)
    new $P948, "Integer"
    assign $P948, 0
    store_lex "$*RETURN_USED", $P948
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 419
  # rx rxquantr950 ** 0..1
    set_addr $I10, rxquantr950_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr950_loop:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_953_fail
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  # rx rxquantr952 ** 0..1
    set_addr $I10, rxquantr952_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr952_loop:
  # rx literal  "&"
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 38, rx942_fail
    add rx942_pos, 1
    set_addr $I10, rxquantr952_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
  rxquantr952_done:
    set_addr $I10, rxcap_953_fail
    ($I12, $I11) = rx942_cur."!mark_peek"($I10)
    rx942_cur."!cursor_pos"($I11)
    ($P10) = rx942_cur."!cursor_start"()
    $P10."!cursor_pass"(rx942_pos, "")
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_953_done
  rxcap_953_fail:
    goto rx942_fail
  rxcap_953_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."deflongname"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    set_addr $I10, rxquantr950_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
  rxquantr950_done:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 420
  # rx subrule "newpad" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."newpad"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt957_0:
.annotate 'line', 421
    set_addr $I10, alt957_1
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 40, rx942_fail
    add rx942_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."signature"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 41, rx942_fail
    add rx942_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    goto alt957_end
  alt957_1:
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt957_end:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 423
  # rx rxquantr965 ** 0..*
    set_addr $I10, rxquantr965_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr965_loop:
  # rx subrule "trait" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."trait"()
    unless $P10, rx942_fail
    goto rxsubrule966_pass
  rxsubrule966_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx942_fail
  rxsubrule966_pass:
    set_addr $I10, rxsubrule966_back
    rx942_cur."!mark_push"(0, rx942_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx942_pos = $P10."pos"()
    set_addr $I10, rxquantr965_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr965_done
    rx942_cur."!mark_push"(rx942_rep, rx942_pos, $I10)
    goto rxquantr965_loop
  rxquantr965_done:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt968_0:
.annotate 'line', 424
    set_addr $I10, alt968_1
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."onlystar"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    goto alt968_end
  alt968_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."blockoid"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  alt968_end:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx942_cur."!cursor_pass"(rx942_pos, "routine_def")
    if_null rx942_debug, debug_1011
    rx942_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx942_pos)
  debug_1011:
    .return (rx942_cur)
  rx942_restart:
.annotate 'line', 10
    if_null rx942_debug, debug_1012
    rx942_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1012:
  rx942_fail:
    (rx942_rep, rx942_pos, $I10, $P10) = rx942_cur."!mark_fail"(0)
    lt rx942_pos, -1, rx942_done
    eq rx942_pos, -1, rx942_fail
    jump $I10
  rx942_done:
    rx942_cur."!cursor_fail"()
    if_null rx942_debug, debug_1013
    rx942_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1013:
    .return (rx942_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303576195.699") :method
.annotate 'line', 10
    $P944 = self."!PREFIX__!subrule"("ws", "")
    new $P945, "ResizablePMCArray"
    push $P945, $P944
    .return ($P945)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P1005 = "181_1303576195.699" 
    capture_lex $P1005
.annotate 'line', 431
    new $P975, "Undef"
    .lex "$*RETURN_USED", $P975
.annotate 'line', 432
    new $P976, "Undef"
    .lex "$*INVOCANT_OK", $P976
.annotate 'line', 10
    .local string rx977_tgt
    .local int rx977_pos
    .local int rx977_off
    .local int rx977_eos
    .local int rx977_rep
    .local pmc rx977_cur
    .local pmc rx977_debug
    (rx977_cur, rx977_pos, rx977_tgt, $I10) = self."!cursor_start"()
    rx977_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx977_cur
    .local pmc match
    .lex "$/", match
    length rx977_eos, rx977_tgt
    gt rx977_pos, rx977_eos, rx977_done
    set rx977_off, 0
    lt rx977_pos, 2, rx977_start
    sub rx977_off, rx977_pos, 1
    substr rx977_tgt, rx977_tgt, rx977_off
  rx977_start:
    eq $I10, 1, rx977_restart
    if_null rx977_debug, debug_1014
    rx977_cur."!cursor_debug"("START", "method_def")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan981_done
    goto rxscan981_scan
  rxscan981_loop:
    (rx977_pos) = rx977_cur."from"()
    inc rx977_pos
    rx977_cur."!cursor_from"(rx977_pos)
    ge rx977_pos, rx977_eos, rxscan981_done
  rxscan981_scan:
    set_addr $I10, rxscan981_loop
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxscan981_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 431
    rx977_cur."!cursor_pos"(rx977_pos)
    new $P983, "Integer"
    assign $P983, 0
    store_lex "$*RETURN_USED", $P983
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 432
    rx977_cur."!cursor_pos"(rx977_pos)
    new $P985, "Integer"
    assign $P985, 1
    store_lex "$*INVOCANT_OK", $P985
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 433
  # rx subcapture "private"
    set_addr $I10, rxcap_988_fail
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  # rx rxquantr987 ** 0..1
    set_addr $I10, rxquantr987_done
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxquantr987_loop:
  # rx literal  "!"
    add $I11, rx977_pos, 1
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    ord $I11, rx977_tgt, $I11
    ne $I11, 33, rx977_fail
    add rx977_pos, 1
    set_addr $I10, rxquantr987_done
    (rx977_rep) = rx977_cur."!mark_commit"($I10)
  rxquantr987_done:
    set_addr $I10, rxcap_988_fail
    ($I12, $I11) = rx977_cur."!mark_peek"($I10)
    rx977_cur."!cursor_pos"($I11)
    ($P10) = rx977_cur."!cursor_start"()
    $P10."!cursor_pass"(rx977_pos, "")
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_988_done
  rxcap_988_fail:
    goto rx977_fail
  rxcap_988_done:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 434
  # rx rxquantr990 ** 0..1
    set_addr $I10, rxquantr990_done
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxquantr990_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."deflongname"()
    unless $P10, rx977_fail
    goto rxsubrule991_pass
  rxsubrule991_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx977_fail
  rxsubrule991_pass:
    set_addr $I10, rxsubrule991_back
    rx977_cur."!mark_push"(0, rx977_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx977_pos = $P10."pos"()
    set_addr $I10, rxquantr990_done
    (rx977_rep) = rx977_cur."!mark_commit"($I10)
  rxquantr990_done:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 435
  # rx subrule "newpad" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."newpad"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt994_0:
.annotate 'line', 436
    set_addr $I10, alt994_1
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx977_pos, 1
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    ord $I11, rx977_tgt, $I11
    ne $I11, 40, rx977_fail
    add rx977_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."signature"()
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx977_pos, 1
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    ord $I11, rx977_tgt, $I11
    ne $I11, 41, rx977_fail
    add rx977_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
    goto alt994_end
  alt994_1:
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt994_end:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 438
    rx977_cur."!cursor_pos"(rx977_pos)
    find_lex $P1002, unicode:"$\x{a2}"
    $P1003 = $P1002."MATCH"()
    store_lex "$/", $P1003
    .const 'Sub' $P1005 = "181_1303576195.699" 
    capture_lex $P1005
    $P1007 = $P1005()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 439
  # rx rxquantr1009 ** 0..*
    set_addr $I10, rxquantr1009_done
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxquantr1009_loop:
  # rx subrule "trait" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."trait"()
    unless $P10, rx977_fail
    goto rxsubrule1010_pass
  rxsubrule1010_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx977_fail
  rxsubrule1010_pass:
    set_addr $I10, rxsubrule1010_back
    rx977_cur."!mark_push"(0, rx977_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx977_pos = $P10."pos"()
    set_addr $I10, rxquantr1009_done
    (rx977_rep) = rx977_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1009_done
    rx977_cur."!mark_push"(rx977_rep, rx977_pos, $I10)
    goto rxquantr1009_loop
  rxquantr1009_done:
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt1012_0:
.annotate 'line', 440
    set_addr $I10, alt1012_1
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."onlystar"()
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
    goto alt1012_end
  alt1012_1:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."blockoid"()
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx977_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
  alt1012_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."ws"()
    unless $P10, rx977_fail
    rx977_pos = $P10."pos"()
.annotate 'line', 430
  # rx pass
    rx977_cur."!cursor_pass"(rx977_pos, "method_def")
    if_null rx977_debug, debug_1015
    rx977_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx977_pos)
  debug_1015:
    .return (rx977_cur)
  rx977_restart:
.annotate 'line', 10
    if_null rx977_debug, debug_1016
    rx977_cur."!cursor_debug"("NEXT", "method_def")
  debug_1016:
  rx977_fail:
    (rx977_rep, rx977_pos, $I10, $P10) = rx977_cur."!mark_fail"(0)
    lt rx977_pos, -1, rx977_done
    eq rx977_pos, -1, rx977_fail
    jump $I10
  rx977_done:
    rx977_cur."!cursor_fail"()
    if_null rx977_debug, debug_1017
    rx977_cur."!cursor_debug"("FAIL", "method_def")
  debug_1017:
    .return (rx977_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303576195.699") :method
.annotate 'line', 10
    $P979 = self."!PREFIX__!subrule"("ws", "")
    new $P980, "ResizablePMCArray"
    push $P980, $P979
    .return ($P980)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1004"  :anon :subid("181_1303576195.699") :outer("179_1303576195.699")
.annotate 'line', 438
    new $P1006, "Integer"
    assign $P1006, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1006
    .return ($P1006)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P1026 = "184_1303576195.699" 
    capture_lex $P1026
    .local string rx1019_tgt
    .local int rx1019_pos
    .local int rx1019_off
    .local int rx1019_eos
    .local int rx1019_rep
    .local pmc rx1019_cur
    .local pmc rx1019_debug
    (rx1019_cur, rx1019_pos, rx1019_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1019_cur
    .local pmc match
    .lex "$/", match
    length rx1019_eos, rx1019_tgt
    gt rx1019_pos, rx1019_eos, rx1019_done
    set rx1019_off, 0
    lt rx1019_pos, 2, rx1019_start
    sub rx1019_off, rx1019_pos, 1
    substr rx1019_tgt, rx1019_tgt, rx1019_off
  rx1019_start:
    eq $I10, 1, rx1019_restart
    if_null rx1019_debug, debug_1018
    rx1019_cur."!cursor_debug"("START", "onlystar")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1022_done
    goto rxscan1022_scan
  rxscan1022_loop:
    (rx1019_pos) = rx1019_cur."from"()
    inc rx1019_pos
    rx1019_cur."!cursor_from"(rx1019_pos)
    ge rx1019_pos, rx1019_eos, rxscan1022_done
  rxscan1022_scan:
    set_addr $I10, rxscan1022_loop
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  rxscan1022_done:
.annotate 'line', 447
    rx1019_cur."!cursor_pos"(rx1019_pos)
    find_lex $P1023, unicode:"$\x{a2}"
    $P1024 = $P1023."MATCH"()
    store_lex "$/", $P1024
    .const 'Sub' $P1026 = "184_1303576195.699" 
    capture_lex $P1026
    $P1030 = $P1026()
    unless $P1030, rx1019_fail
.annotate 'line', 448
  # rx literal  "{"
    add $I11, rx1019_pos, 1
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    ord $I11, rx1019_tgt, $I11
    ne $I11, 123, rx1019_fail
    add rx1019_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."ws"()
    unless $P10, rx1019_fail
    rx1019_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1019_pos, 1
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    ord $I11, rx1019_tgt, $I11
    ne $I11, 42, rx1019_fail
    add rx1019_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."ws"()
    unless $P10, rx1019_fail
    rx1019_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1019_pos, 1
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    ord $I11, rx1019_tgt, $I11
    ne $I11, 125, rx1019_fail
    add rx1019_pos, 1
.annotate 'line', 449
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."ENDSTMT"()
    unless $P10, rx1019_fail
.annotate 'line', 450
  # rx subrule "finishpad" subtype=method negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."finishpad"()
    unless $P10, rx1019_fail
    rx1019_pos = $P10."pos"()
.annotate 'line', 446
  # rx pass
    rx1019_cur."!cursor_pass"(rx1019_pos, "onlystar")
    if_null rx1019_debug, debug_1021
    rx1019_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1019_pos)
  debug_1021:
    .return (rx1019_cur)
  rx1019_restart:
.annotate 'line', 10
    if_null rx1019_debug, debug_1022
    rx1019_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1022:
  rx1019_fail:
    (rx1019_rep, rx1019_pos, $I10, $P10) = rx1019_cur."!mark_fail"(0)
    lt rx1019_pos, -1, rx1019_done
    eq rx1019_pos, -1, rx1019_fail
    jump $I10
  rx1019_done:
    rx1019_cur."!cursor_fail"()
    if_null rx1019_debug, debug_1023
    rx1019_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1023:
    .return (rx1019_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303576195.699") :method
.annotate 'line', 10
    new $P1021, "ResizablePMCArray"
    push $P1021, ""
    .return ($P1021)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1025"  :anon :subid("184_1303576195.699") :outer("182_1303576195.699")
.annotate 'line', 447
    find_dynamic_lex $P1027, "$*MULTINESS"
    unless_null $P1027, vivify_1019
    get_hll_global $P1027, "$MULTINESS"
    unless_null $P1027, vivify_1020
    die "Contextual $*MULTINESS not found"
  vivify_1020:
  vivify_1019:
    set $S1028, $P1027
    iseq $I1029, $S1028, "proto"
    .return ($I1029)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303576195.699")
    .param pmc param_1032
.annotate 'line', 453
    .lex "self", param_1032
    $P1033 = param_1032."!protoregex"("multi_declarator")
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303576195.699")
    .param pmc param_1035
.annotate 'line', 453
    .lex "self", param_1035
    $P1036 = param_1035."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1036)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 455
    new $P1038, "Undef"
    .lex "$*MULTINESS", $P1038
.annotate 'line', 10
    .local string rx1039_tgt
    .local int rx1039_pos
    .local int rx1039_off
    .local int rx1039_eos
    .local int rx1039_rep
    .local pmc rx1039_cur
    .local pmc rx1039_debug
    (rx1039_cur, rx1039_pos, rx1039_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1039_cur
    .local pmc match
    .lex "$/", match
    length rx1039_eos, rx1039_tgt
    gt rx1039_pos, rx1039_eos, rx1039_done
    set rx1039_off, 0
    lt rx1039_pos, 2, rx1039_start
    sub rx1039_off, rx1039_pos, 1
    substr rx1039_tgt, rx1039_tgt, rx1039_off
  rx1039_start:
    eq $I10, 1, rx1039_restart
    if_null rx1039_debug, debug_1024
    rx1039_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1043_done
    goto rxscan1043_scan
  rxscan1043_loop:
    (rx1039_pos) = rx1039_cur."from"()
    inc rx1039_pos
    rx1039_cur."!cursor_from"(rx1039_pos)
    ge rx1039_pos, rx1039_eos, rxscan1043_done
  rxscan1043_scan:
    set_addr $I10, rxscan1043_loop
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  rxscan1043_done:
.annotate 'line', 455
    rx1039_cur."!cursor_pos"(rx1039_pos)
    new $P1044, "String"
    assign $P1044, "multi"
    store_lex "$*MULTINESS", $P1044
.annotate 'line', 456
  # rx subcapture "sym"
    set_addr $I10, rxcap_1045_fail
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1039_pos, 5
    gt $I11, rx1039_eos, rx1039_fail
    sub $I11, rx1039_pos, rx1039_off
    substr $S10, rx1039_tgt, $I11, 5
    ne $S10, "multi", rx1039_fail
    add rx1039_pos, 5
    set_addr $I10, rxcap_1045_fail
    ($I12, $I11) = rx1039_cur."!mark_peek"($I10)
    rx1039_cur."!cursor_pos"($I11)
    ($P10) = rx1039_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1039_pos, "")
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1045_done
  rxcap_1045_fail:
    goto rx1039_fail
  rxcap_1045_done:
.annotate 'line', 457
  # rx subrule "ws" subtype=method negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."ws"()
    unless $P10, rx1039_fail
    rx1039_pos = $P10."pos"()
  alt1046_0:
    set_addr $I10, alt1046_1
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."declarator"()
    unless $P10, rx1039_fail
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1039_pos = $P10."pos"()
    goto alt1046_end
  alt1046_1:
    set_addr $I10, alt1046_2
    rx1039_cur."!mark_push"(0, rx1039_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."routine_def"()
    unless $P10, rx1039_fail
    rx1039_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1039_pos = $P10."pos"()
    goto alt1046_end
  alt1046_2:
  # rx subrule "panic" subtype=method negate=
    rx1039_cur."!cursor_pos"(rx1039_pos)
    $P10 = rx1039_cur."panic"("Malformed multi")
    unless $P10, rx1039_fail
    rx1039_pos = $P10."pos"()
  alt1046_end:
.annotate 'line', 454
  # rx pass
    rx1039_cur."!cursor_pass"(rx1039_pos, "multi_declarator:sym<multi>")
    if_null rx1039_debug, debug_1025
    rx1039_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1039_pos)
  debug_1025:
    .return (rx1039_cur)
  rx1039_restart:
.annotate 'line', 10
    if_null rx1039_debug, debug_1026
    rx1039_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1026:
  rx1039_fail:
    (rx1039_rep, rx1039_pos, $I10, $P10) = rx1039_cur."!mark_fail"(0)
    lt rx1039_pos, -1, rx1039_done
    eq rx1039_pos, -1, rx1039_fail
    jump $I10
  rx1039_done:
    rx1039_cur."!cursor_fail"()
    if_null rx1039_debug, debug_1027
    rx1039_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1027:
    .return (rx1039_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303576195.699") :method
.annotate 'line', 10
    $P1041 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1042, "ResizablePMCArray"
    push $P1042, $P1041
    .return ($P1042)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 460
    new $P1048, "Undef"
    .lex "$*MULTINESS", $P1048
.annotate 'line', 10
    .local string rx1049_tgt
    .local int rx1049_pos
    .local int rx1049_off
    .local int rx1049_eos
    .local int rx1049_rep
    .local pmc rx1049_cur
    .local pmc rx1049_debug
    (rx1049_cur, rx1049_pos, rx1049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1049_cur
    .local pmc match
    .lex "$/", match
    length rx1049_eos, rx1049_tgt
    gt rx1049_pos, rx1049_eos, rx1049_done
    set rx1049_off, 0
    lt rx1049_pos, 2, rx1049_start
    sub rx1049_off, rx1049_pos, 1
    substr rx1049_tgt, rx1049_tgt, rx1049_off
  rx1049_start:
    eq $I10, 1, rx1049_restart
    if_null rx1049_debug, debug_1028
    rx1049_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1053_done
    goto rxscan1053_scan
  rxscan1053_loop:
    (rx1049_pos) = rx1049_cur."from"()
    inc rx1049_pos
    rx1049_cur."!cursor_from"(rx1049_pos)
    ge rx1049_pos, rx1049_eos, rxscan1053_done
  rxscan1053_scan:
    set_addr $I10, rxscan1053_loop
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  rxscan1053_done:
.annotate 'line', 460
    rx1049_cur."!cursor_pos"(rx1049_pos)
    new $P1054, "String"
    assign $P1054, "proto"
    store_lex "$*MULTINESS", $P1054
.annotate 'line', 461
  # rx subcapture "sym"
    set_addr $I10, rxcap_1055_fail
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1049_pos, 5
    gt $I11, rx1049_eos, rx1049_fail
    sub $I11, rx1049_pos, rx1049_off
    substr $S10, rx1049_tgt, $I11, 5
    ne $S10, "proto", rx1049_fail
    add rx1049_pos, 5
    set_addr $I10, rxcap_1055_fail
    ($I12, $I11) = rx1049_cur."!mark_peek"($I10)
    rx1049_cur."!cursor_pos"($I11)
    ($P10) = rx1049_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1049_pos, "")
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1055_done
  rxcap_1055_fail:
    goto rx1049_fail
  rxcap_1055_done:
.annotate 'line', 462
  # rx subrule "ws" subtype=method negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."ws"()
    unless $P10, rx1049_fail
    rx1049_pos = $P10."pos"()
  alt1056_0:
    set_addr $I10, alt1056_1
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."declarator"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1049_pos = $P10."pos"()
    goto alt1056_end
  alt1056_1:
    set_addr $I10, alt1056_2
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."routine_def"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1049_pos = $P10."pos"()
    goto alt1056_end
  alt1056_2:
  # rx subrule "panic" subtype=method negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."panic"("Malformed proto")
    unless $P10, rx1049_fail
    rx1049_pos = $P10."pos"()
  alt1056_end:
.annotate 'line', 459
  # rx pass
    rx1049_cur."!cursor_pass"(rx1049_pos, "multi_declarator:sym<proto>")
    if_null rx1049_debug, debug_1029
    rx1049_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1049_pos)
  debug_1029:
    .return (rx1049_cur)
  rx1049_restart:
.annotate 'line', 10
    if_null rx1049_debug, debug_1030
    rx1049_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1030:
  rx1049_fail:
    (rx1049_rep, rx1049_pos, $I10, $P10) = rx1049_cur."!mark_fail"(0)
    lt rx1049_pos, -1, rx1049_done
    eq rx1049_pos, -1, rx1049_fail
    jump $I10
  rx1049_done:
    rx1049_cur."!cursor_fail"()
    if_null rx1049_debug, debug_1031
    rx1049_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1031:
    .return (rx1049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303576195.699") :method
.annotate 'line', 10
    $P1051 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1052, "ResizablePMCArray"
    push $P1052, $P1051
    .return ($P1052)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 465
    new $P1058, "Undef"
    .lex "$*MULTINESS", $P1058
.annotate 'line', 10
    .local string rx1059_tgt
    .local int rx1059_pos
    .local int rx1059_off
    .local int rx1059_eos
    .local int rx1059_rep
    .local pmc rx1059_cur
    .local pmc rx1059_debug
    (rx1059_cur, rx1059_pos, rx1059_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1059_cur
    .local pmc match
    .lex "$/", match
    length rx1059_eos, rx1059_tgt
    gt rx1059_pos, rx1059_eos, rx1059_done
    set rx1059_off, 0
    lt rx1059_pos, 2, rx1059_start
    sub rx1059_off, rx1059_pos, 1
    substr rx1059_tgt, rx1059_tgt, rx1059_off
  rx1059_start:
    eq $I10, 1, rx1059_restart
    if_null rx1059_debug, debug_1032
    rx1059_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1063_done
    goto rxscan1063_scan
  rxscan1063_loop:
    (rx1059_pos) = rx1059_cur."from"()
    inc rx1059_pos
    rx1059_cur."!cursor_from"(rx1059_pos)
    ge rx1059_pos, rx1059_eos, rxscan1063_done
  rxscan1063_scan:
    set_addr $I10, rxscan1063_loop
    rx1059_cur."!mark_push"(0, rx1059_pos, $I10)
  rxscan1063_done:
.annotate 'line', 465
    rx1059_cur."!cursor_pos"(rx1059_pos)
    new $P1064, "String"
    assign $P1064, ""
    store_lex "$*MULTINESS", $P1064
.annotate 'line', 466
  # rx subrule "declarator" subtype=capture negate=
    rx1059_cur."!cursor_pos"(rx1059_pos)
    $P10 = rx1059_cur."declarator"()
    unless $P10, rx1059_fail
    rx1059_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1059_pos = $P10."pos"()
.annotate 'line', 464
  # rx pass
    rx1059_cur."!cursor_pass"(rx1059_pos, "multi_declarator:sym<null>")
    if_null rx1059_debug, debug_1033
    rx1059_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1059_pos)
  debug_1033:
    .return (rx1059_cur)
  rx1059_restart:
.annotate 'line', 10
    if_null rx1059_debug, debug_1034
    rx1059_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1034:
  rx1059_fail:
    (rx1059_rep, rx1059_pos, $I10, $P10) = rx1059_cur."!mark_fail"(0)
    lt rx1059_pos, -1, rx1059_done
    eq rx1059_pos, -1, rx1059_fail
    jump $I10
  rx1059_done:
    rx1059_cur."!cursor_fail"()
    if_null rx1059_debug, debug_1035
    rx1059_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1035:
    .return (rx1059_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303576195.699") :method
.annotate 'line', 10
    $P1061 = self."!PREFIX__!subrule"("declarator", "")
    new $P1062, "ResizablePMCArray"
    push $P1062, $P1061
    .return ($P1062)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P1074 = "195_1303576195.699" 
    capture_lex $P1074
    .local string rx1066_tgt
    .local int rx1066_pos
    .local int rx1066_off
    .local int rx1066_eos
    .local int rx1066_rep
    .local pmc rx1066_cur
    .local pmc rx1066_debug
    (rx1066_cur, rx1066_pos, rx1066_tgt, $I10) = self."!cursor_start"()
    rx1066_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1066_cur
    .local pmc match
    .lex "$/", match
    length rx1066_eos, rx1066_tgt
    gt rx1066_pos, rx1066_eos, rx1066_done
    set rx1066_off, 0
    lt rx1066_pos, 2, rx1066_start
    sub rx1066_off, rx1066_pos, 1
    substr rx1066_tgt, rx1066_tgt, rx1066_off
  rx1066_start:
    eq $I10, 1, rx1066_restart
    if_null rx1066_debug, debug_1036
    rx1066_cur."!cursor_debug"("START", "signature")
  debug_1036:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1066_pos) = rx1066_cur."from"()
    inc rx1066_pos
    rx1066_cur."!cursor_from"(rx1066_pos)
    ge rx1066_pos, rx1066_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxscan1069_done:
.annotate 'line', 470
  # rx rxquantr1070 ** 0..1
    set_addr $I10, rxquantr1070_done
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxquantr1070_loop:
    rx1066_cur."!cursor_pos"(rx1066_pos)
    find_lex $P1071, unicode:"$\x{a2}"
    $P1072 = $P1071."MATCH"()
    store_lex "$/", $P1072
    .const 'Sub' $P1074 = "195_1303576195.699" 
    capture_lex $P1074
    $P1076 = $P1074()
    unless $P1076, rx1066_fail
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."parameter"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1066_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1066_pos, 1
    gt $I11, rx1066_eos, rx1066_fail
    sub $I11, rx1066_pos, rx1066_off
    ord $I11, rx1066_tgt, $I11
    ne $I11, 58, rx1066_fail
    add rx1066_pos, 1
    set_addr $I10, rxquantr1070_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
  rxquantr1070_done:
.annotate 'line', 471
  # rx rxquantr1077 ** 0..1
    set_addr $I10, rxquantr1077_done
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxquantr1077_loop:
  # rx rxquantr1078 ** 1..*
    set_addr $I10, rxquantr1078_done
    rx1066_cur."!mark_push"(0, -1, $I10)
  rxquantr1078_loop:
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."parameter"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1066_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."ws"()
    unless $P10, rx1066_fail
    rx1066_pos = $P10."pos"()
    set_addr $I10, rxquantr1078_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1078_done
    rx1066_cur."!mark_push"(rx1066_rep, rx1066_pos, $I10)
  # rx literal  ","
    add $I11, rx1066_pos, 1
    gt $I11, rx1066_eos, rx1066_fail
    sub $I11, rx1066_pos, rx1066_off
    ord $I11, rx1066_tgt, $I11
    ne $I11, 44, rx1066_fail
    add rx1066_pos, 1
    goto rxquantr1078_loop
  rxquantr1078_done:
    set_addr $I10, rxquantr1077_done
    (rx1066_rep) = rx1066_cur."!mark_commit"($I10)
  rxquantr1077_done:
.annotate 'line', 469
  # rx pass
    rx1066_cur."!cursor_pass"(rx1066_pos, "signature")
    if_null rx1066_debug, debug_1039
    rx1066_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1066_pos)
  debug_1039:
    .return (rx1066_cur)
  rx1066_restart:
.annotate 'line', 10
    if_null rx1066_debug, debug_1040
    rx1066_cur."!cursor_debug"("NEXT", "signature")
  debug_1040:
  rx1066_fail:
    (rx1066_rep, rx1066_pos, $I10, $P10) = rx1066_cur."!mark_fail"(0)
    lt rx1066_pos, -1, rx1066_done
    eq rx1066_pos, -1, rx1066_fail
    jump $I10
  rx1066_done:
    rx1066_cur."!cursor_fail"()
    if_null rx1066_debug, debug_1041
    rx1066_cur."!cursor_debug"("FAIL", "signature")
  debug_1041:
    .return (rx1066_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303576195.699") :method
.annotate 'line', 10
    new $P1068, "ResizablePMCArray"
    push $P1068, ""
    .return ($P1068)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1073"  :anon :subid("195_1303576195.699") :outer("193_1303576195.699")
.annotate 'line', 470
    find_dynamic_lex $P1075, "$*INVOCANT_OK"
    unless_null $P1075, vivify_1037
    get_hll_global $P1075, "$INVOCANT_OK"
    unless_null $P1075, vivify_1038
    die "Contextual $*INVOCANT_OK not found"
  vivify_1038:
  vivify_1037:
    .return ($P1075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    rx1080_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_1042
    rx1080_cur."!cursor_debug"("START", "parameter")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1083_done
    goto rxscan1083_scan
  rxscan1083_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1083_done
  rxscan1083_scan:
    set_addr $I10, rxscan1083_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1083_done:
.annotate 'line', 475
  # rx rxquantr1084 ** 0..*
    set_addr $I10, rxquantr1084_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1084_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."typename"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1080_pos = $P10."pos"()
  # rx rxquantr1085 ** 0..1
    set_addr $I10, rxquantr1085_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1085_loop:
  # rx literal  ":"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 58, rx1080_fail
    add rx1080_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1086_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1080_pos, rx1080_eos, rx1080_fail
    sub $I10, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1080_fail
    inc rx1080_pos
    set_addr $I10, rxcap_1086_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1086_done
  rxcap_1086_fail:
    goto rx1080_fail
  rxcap_1086_done:
    set_addr $I10, rxquantr1085_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
  rxquantr1085_done:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
    set_addr $I10, rxquantr1084_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1084_done
    rx1080_cur."!mark_push"(rx1080_rep, rx1080_pos, $I10)
    goto rxquantr1084_loop
  rxquantr1084_done:
  alt1087_0:
.annotate 'line', 476
    set_addr $I10, alt1087_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
.annotate 'line', 477
  # rx subcapture "quant"
    set_addr $I10, rxcap_1088_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "*"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 42, rx1080_fail
    add rx1080_pos, 1
    set_addr $I10, rxcap_1088_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1088_done
  rxcap_1088_fail:
    goto rx1080_fail
  rxcap_1088_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."param_var"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1080_pos = $P10."pos"()
    goto alt1087_end
  alt1087_1:
  alt1089_0:
.annotate 'line', 478
    set_addr $I10, alt1089_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."param_var"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1080_pos = $P10."pos"()
    goto alt1089_end
  alt1089_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."named_param"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1080_pos = $P10."pos"()
  alt1089_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1091_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  alt1090_0:
    set_addr $I10, alt1090_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "?"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 63, rx1080_fail
    add rx1080_pos, 1
    goto alt1090_end
  alt1090_1:
    set_addr $I10, alt1090_2
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "!"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 33, rx1080_fail
    add rx1080_pos, 1
    goto alt1090_end
  alt1090_2:
  alt1090_end:
    set_addr $I10, rxcap_1091_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1091_done
  rxcap_1091_fail:
    goto rx1080_fail
  rxcap_1091_done:
  alt1087_end:
.annotate 'line', 480
  # rx rxquantr1092 ** 0..1
    set_addr $I10, rxquantr1092_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1092_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."default_value"()
    unless $P10, rx1080_fail
    goto rxsubrule1093_pass
  rxsubrule1093_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1080_fail
  rxsubrule1093_pass:
    set_addr $I10, rxsubrule1093_back
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1080_pos = $P10."pos"()
    set_addr $I10, rxquantr1092_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
  rxquantr1092_done:
.annotate 'line', 474
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "parameter")
    if_null rx1080_debug, debug_1043
    rx1080_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1080_pos)
  debug_1043:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 10
    if_null rx1080_debug, debug_1044
    rx1080_cur."!cursor_debug"("NEXT", "parameter")
  debug_1044:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_1045
    rx1080_cur."!cursor_debug"("FAIL", "parameter")
  debug_1045:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303576195.699") :method
.annotate 'line', 10
    new $P1082, "ResizablePMCArray"
    push $P1082, ""
    .return ($P1082)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1095_tgt
    .local int rx1095_pos
    .local int rx1095_off
    .local int rx1095_eos
    .local int rx1095_rep
    .local pmc rx1095_cur
    .local pmc rx1095_debug
    (rx1095_cur, rx1095_pos, rx1095_tgt, $I10) = self."!cursor_start"()
    rx1095_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1095_cur
    .local pmc match
    .lex "$/", match
    length rx1095_eos, rx1095_tgt
    gt rx1095_pos, rx1095_eos, rx1095_done
    set rx1095_off, 0
    lt rx1095_pos, 2, rx1095_start
    sub rx1095_off, rx1095_pos, 1
    substr rx1095_tgt, rx1095_tgt, rx1095_off
  rx1095_start:
    eq $I10, 1, rx1095_restart
    if_null rx1095_debug, debug_1046
    rx1095_cur."!cursor_debug"("START", "param_var")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1099_done
    goto rxscan1099_scan
  rxscan1099_loop:
    (rx1095_pos) = rx1095_cur."from"()
    inc rx1095_pos
    rx1095_cur."!cursor_from"(rx1095_pos)
    ge rx1095_pos, rx1095_eos, rxscan1099_done
  rxscan1099_scan:
    set_addr $I10, rxscan1099_loop
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxscan1099_done:
.annotate 'line', 484
  # rx subrule "sigil" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."sigil"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1095_pos = $P10."pos"()
  # rx rxquantr1100 ** 0..1
    set_addr $I10, rxquantr1100_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1100_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."twigil"()
    unless $P10, rx1095_fail
    goto rxsubrule1101_pass
  rxsubrule1101_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1095_fail
  rxsubrule1101_pass:
    set_addr $I10, rxsubrule1101_back
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1100_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1100_done:
  alt1102_0:
.annotate 'line', 485
    set_addr $I10, alt1102_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ident"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1095_pos = $P10."pos"()
    goto alt1102_end
  alt1102_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1103_fail
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1095_pos, rx1095_eos, rx1095_fail
    sub $I10, rx1095_pos, rx1095_off
    substr $S10, rx1095_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1095_fail
    inc rx1095_pos
    set_addr $I10, rxcap_1103_fail
    ($I12, $I11) = rx1095_cur."!mark_peek"($I10)
    rx1095_cur."!cursor_pos"($I11)
    ($P10) = rx1095_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1095_pos, "")
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1103_done
  rxcap_1103_fail:
    goto rx1095_fail
  rxcap_1103_done:
  alt1102_end:
.annotate 'line', 483
  # rx pass
    rx1095_cur."!cursor_pass"(rx1095_pos, "param_var")
    if_null rx1095_debug, debug_1047
    rx1095_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1095_pos)
  debug_1047:
    .return (rx1095_cur)
  rx1095_restart:
.annotate 'line', 10
    if_null rx1095_debug, debug_1048
    rx1095_cur."!cursor_debug"("NEXT", "param_var")
  debug_1048:
  rx1095_fail:
    (rx1095_rep, rx1095_pos, $I10, $P10) = rx1095_cur."!mark_fail"(0)
    lt rx1095_pos, -1, rx1095_done
    eq rx1095_pos, -1, rx1095_fail
    jump $I10
  rx1095_done:
    rx1095_cur."!cursor_fail"()
    if_null rx1095_debug, debug_1049
    rx1095_cur."!cursor_debug"("FAIL", "param_var")
  debug_1049:
    .return (rx1095_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303576195.699") :method
.annotate 'line', 10
    $P1097 = self."!PREFIX__!subrule"("sigil", "")
    new $P1098, "ResizablePMCArray"
    push $P1098, $P1097
    .return ($P1098)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1105_tgt
    .local int rx1105_pos
    .local int rx1105_off
    .local int rx1105_eos
    .local int rx1105_rep
    .local pmc rx1105_cur
    .local pmc rx1105_debug
    (rx1105_cur, rx1105_pos, rx1105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1105_cur
    .local pmc match
    .lex "$/", match
    length rx1105_eos, rx1105_tgt
    gt rx1105_pos, rx1105_eos, rx1105_done
    set rx1105_off, 0
    lt rx1105_pos, 2, rx1105_start
    sub rx1105_off, rx1105_pos, 1
    substr rx1105_tgt, rx1105_tgt, rx1105_off
  rx1105_start:
    eq $I10, 1, rx1105_restart
    if_null rx1105_debug, debug_1050
    rx1105_cur."!cursor_debug"("START", "named_param")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1109_done
    goto rxscan1109_scan
  rxscan1109_loop:
    (rx1105_pos) = rx1105_cur."from"()
    inc rx1105_pos
    rx1105_cur."!cursor_from"(rx1105_pos)
    ge rx1105_pos, rx1105_eos, rxscan1109_done
  rxscan1109_scan:
    set_addr $I10, rxscan1109_loop
    rx1105_cur."!mark_push"(0, rx1105_pos, $I10)
  rxscan1109_done:
.annotate 'line', 489
  # rx literal  ":"
    add $I11, rx1105_pos, 1
    gt $I11, rx1105_eos, rx1105_fail
    sub $I11, rx1105_pos, rx1105_off
    ord $I11, rx1105_tgt, $I11
    ne $I11, 58, rx1105_fail
    add rx1105_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1105_cur."!cursor_pos"(rx1105_pos)
    $P10 = rx1105_cur."param_var"()
    unless $P10, rx1105_fail
    rx1105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1105_pos = $P10."pos"()
.annotate 'line', 488
  # rx pass
    rx1105_cur."!cursor_pass"(rx1105_pos, "named_param")
    if_null rx1105_debug, debug_1051
    rx1105_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1105_pos)
  debug_1051:
    .return (rx1105_cur)
  rx1105_restart:
.annotate 'line', 10
    if_null rx1105_debug, debug_1052
    rx1105_cur."!cursor_debug"("NEXT", "named_param")
  debug_1052:
  rx1105_fail:
    (rx1105_rep, rx1105_pos, $I10, $P10) = rx1105_cur."!mark_fail"(0)
    lt rx1105_pos, -1, rx1105_done
    eq rx1105_pos, -1, rx1105_fail
    jump $I10
  rx1105_done:
    rx1105_cur."!cursor_fail"()
    if_null rx1105_debug, debug_1053
    rx1105_cur."!cursor_debug"("FAIL", "named_param")
  debug_1053:
    .return (rx1105_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303576195.699") :method
.annotate 'line', 10
    $P1107 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1108, "ResizablePMCArray"
    push $P1108, $P1107
    .return ($P1108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1111_tgt
    .local int rx1111_pos
    .local int rx1111_off
    .local int rx1111_eos
    .local int rx1111_rep
    .local pmc rx1111_cur
    .local pmc rx1111_debug
    (rx1111_cur, rx1111_pos, rx1111_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1111_cur
    .local pmc match
    .lex "$/", match
    length rx1111_eos, rx1111_tgt
    gt rx1111_pos, rx1111_eos, rx1111_done
    set rx1111_off, 0
    lt rx1111_pos, 2, rx1111_start
    sub rx1111_off, rx1111_pos, 1
    substr rx1111_tgt, rx1111_tgt, rx1111_off
  rx1111_start:
    eq $I10, 1, rx1111_restart
    if_null rx1111_debug, debug_1054
    rx1111_cur."!cursor_debug"("START", "default_value")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1115_done
    goto rxscan1115_scan
  rxscan1115_loop:
    (rx1111_pos) = rx1111_cur."from"()
    inc rx1111_pos
    rx1111_cur."!cursor_from"(rx1111_pos)
    ge rx1111_pos, rx1111_eos, rxscan1115_done
  rxscan1115_scan:
    set_addr $I10, rxscan1115_loop
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxscan1115_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 61, rx1111_fail
    add rx1111_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."EXPR"("i=")
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx pass
    rx1111_cur."!cursor_pass"(rx1111_pos, "default_value")
    if_null rx1111_debug, debug_1055
    rx1111_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1111_pos)
  debug_1055:
    .return (rx1111_cur)
  rx1111_restart:
.annotate 'line', 10
    if_null rx1111_debug, debug_1056
    rx1111_cur."!cursor_debug"("NEXT", "default_value")
  debug_1056:
  rx1111_fail:
    (rx1111_rep, rx1111_pos, $I10, $P10) = rx1111_cur."!mark_fail"(0)
    lt rx1111_pos, -1, rx1111_done
    eq rx1111_pos, -1, rx1111_fail
    jump $I10
  rx1111_done:
    rx1111_cur."!cursor_fail"()
    if_null rx1111_debug, debug_1057
    rx1111_cur."!cursor_debug"("FAIL", "default_value")
  debug_1057:
    .return (rx1111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303576195.699") :method
.annotate 'line', 10
    $P1113 = self."!PREFIX__!subrule"("ws", "")
    new $P1114, "ResizablePMCArray"
    push $P1114, $P1113
    .return ($P1114)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1120_tgt
    .local int rx1120_pos
    .local int rx1120_off
    .local int rx1120_eos
    .local int rx1120_rep
    .local pmc rx1120_cur
    .local pmc rx1120_debug
    (rx1120_cur, rx1120_pos, rx1120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1120_cur
    .local pmc match
    .lex "$/", match
    length rx1120_eos, rx1120_tgt
    gt rx1120_pos, rx1120_eos, rx1120_done
    set rx1120_off, 0
    lt rx1120_pos, 2, rx1120_start
    sub rx1120_off, rx1120_pos, 1
    substr rx1120_tgt, rx1120_tgt, rx1120_off
  rx1120_start:
    eq $I10, 1, rx1120_restart
    if_null rx1120_debug, debug_1058
    rx1120_cur."!cursor_debug"("START", "trait")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1124_done
    goto rxscan1124_scan
  rxscan1124_loop:
    (rx1120_pos) = rx1120_cur."from"()
    inc rx1120_pos
    rx1120_cur."!cursor_from"(rx1120_pos)
    ge rx1120_pos, rx1120_eos, rxscan1124_done
  rxscan1124_scan:
    set_addr $I10, rxscan1124_loop
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxscan1124_done:
.annotate 'line', 494
  # rx subrule "ws" subtype=method negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."ws"()
    unless $P10, rx1120_fail
    rx1120_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."trait_mod"()
    unless $P10, rx1120_fail
    rx1120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1120_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."ws"()
    unless $P10, rx1120_fail
    rx1120_pos = $P10."pos"()
  # rx pass
    rx1120_cur."!cursor_pass"(rx1120_pos, "trait")
    if_null rx1120_debug, debug_1059
    rx1120_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1120_pos)
  debug_1059:
    .return (rx1120_cur)
  rx1120_restart:
.annotate 'line', 10
    if_null rx1120_debug, debug_1060
    rx1120_cur."!cursor_debug"("NEXT", "trait")
  debug_1060:
  rx1120_fail:
    (rx1120_rep, rx1120_pos, $I10, $P10) = rx1120_cur."!mark_fail"(0)
    lt rx1120_pos, -1, rx1120_done
    eq rx1120_pos, -1, rx1120_fail
    jump $I10
  rx1120_done:
    rx1120_cur."!cursor_fail"()
    if_null rx1120_debug, debug_1061
    rx1120_cur."!cursor_debug"("FAIL", "trait")
  debug_1061:
    .return (rx1120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303576195.699") :method
.annotate 'line', 10
    $P1122 = self."!PREFIX__!subrule"("ws", "")
    new $P1123, "ResizablePMCArray"
    push $P1123, $P1122
    .return ($P1123)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303576195.699")
    .param pmc param_1128
.annotate 'line', 496
    .lex "self", param_1128
    $P1129 = param_1128."!protoregex"("trait_mod")
    .return ($P1129)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303576195.699")
    .param pmc param_1131
.annotate 'line', 496
    .lex "self", param_1131
    $P1132 = param_1131."!PREFIX__!protoregex"("trait_mod")
    .return ($P1132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    rx1134_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_1062
    rx1134_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1138_done
    goto rxscan1138_scan
  rxscan1138_loop:
    (rx1134_pos) = rx1134_cur."from"()
    inc rx1134_pos
    rx1134_cur."!cursor_from"(rx1134_pos)
    ge rx1134_pos, rx1134_eos, rxscan1138_done
  rxscan1138_scan:
    set_addr $I10, rxscan1138_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1138_done:
.annotate 'line', 497
  # rx subcapture "sym"
    set_addr $I10, rxcap_1139_fail
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  # rx literal  "is"
    add $I11, rx1134_pos, 2
    gt $I11, rx1134_eos, rx1134_fail
    sub $I11, rx1134_pos, rx1134_off
    substr $S10, rx1134_tgt, $I11, 2
    ne $S10, "is", rx1134_fail
    add rx1134_pos, 2
    set_addr $I10, rxcap_1139_fail
    ($I12, $I11) = rx1134_cur."!mark_peek"($I10)
    rx1134_cur."!cursor_pos"($I11)
    ($P10) = rx1134_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1134_pos, "")
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1139_done
  rxcap_1139_fail:
    goto rx1134_fail
  rxcap_1139_done:
  # rx subrule "ws" subtype=method negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."ws"()
    unless $P10, rx1134_fail
    rx1134_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."deflongname"()
    unless $P10, rx1134_fail
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1134_pos = $P10."pos"()
  # rx rxquantr1141 ** 0..1
    set_addr $I10, rxquantr1141_done
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxquantr1141_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."circumfix"()
    unless $P10, rx1134_fail
    goto rxsubrule1142_pass
  rxsubrule1142_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1134_fail
  rxsubrule1142_pass:
    set_addr $I10, rxsubrule1142_back
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1134_pos = $P10."pos"()
    set_addr $I10, rxquantr1141_done
    (rx1134_rep) = rx1134_cur."!mark_commit"($I10)
  rxquantr1141_done:
  # rx subrule "ws" subtype=method negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."ws"()
    unless $P10, rx1134_fail
    rx1134_pos = $P10."pos"()
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "trait_mod:sym<is>")
    if_null rx1134_debug, debug_1063
    rx1134_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1134_pos)
  debug_1063:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 10
    if_null rx1134_debug, debug_1064
    rx1134_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1064:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_1065
    rx1134_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1065:
    .return (rx1134_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303576195.699") :method
.annotate 'line', 10
    $P1136 = self."!PREFIX__!subrule"("ws", "is")
    new $P1137, "ResizablePMCArray"
    push $P1137, $P1136
    .return ($P1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1145_tgt
    .local int rx1145_pos
    .local int rx1145_off
    .local int rx1145_eos
    .local int rx1145_rep
    .local pmc rx1145_cur
    .local pmc rx1145_debug
    (rx1145_cur, rx1145_pos, rx1145_tgt, $I10) = self."!cursor_start"()
    rx1145_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1145_cur
    .local pmc match
    .lex "$/", match
    length rx1145_eos, rx1145_tgt
    gt rx1145_pos, rx1145_eos, rx1145_done
    set rx1145_off, 0
    lt rx1145_pos, 2, rx1145_start
    sub rx1145_off, rx1145_pos, 1
    substr rx1145_tgt, rx1145_tgt, rx1145_off
  rx1145_start:
    eq $I10, 1, rx1145_restart
    if_null rx1145_debug, debug_1066
    rx1145_cur."!cursor_debug"("START", "regex_declarator")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1149_done
    goto rxscan1149_scan
  rxscan1149_loop:
    (rx1145_pos) = rx1145_cur."from"()
    inc rx1145_pos
    rx1145_cur."!cursor_from"(rx1145_pos)
    ge rx1145_pos, rx1145_eos, rxscan1149_done
  rxscan1149_scan:
    set_addr $I10, rxscan1149_loop
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  rxscan1149_done:
.annotate 'line', 499
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1151_0:
.annotate 'line', 500
    set_addr $I10, alt1151_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1153_fail
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "proto", rx1145_fail
    add rx1145_pos, 5
    set_addr $I10, rxcap_1153_fail
    ($I12, $I11) = rx1145_cur."!mark_peek"($I10)
    rx1145_cur."!cursor_pos"($I11)
    ($P10) = rx1145_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1145_pos, "")
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1153_done
  rxcap_1153_fail:
    goto rx1145_fail
  rxcap_1153_done:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1155_0:
    set_addr $I10, alt1155_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "regex", rx1145_fail
    add rx1145_pos, 5
    goto alt1155_end
  alt1155_1:
    set_addr $I10, alt1155_2
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "token"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "token", rx1145_fail
    add rx1145_pos, 5
    goto alt1155_end
  alt1155_2:
  # rx literal  "rule"
    add $I11, rx1145_pos, 4
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 4
    ne $S10, "rule", rx1145_fail
    add rx1145_pos, 4
  alt1155_end:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 502
  # rx subrule "deflongname" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."deflongname"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1158_0:
.annotate 'line', 503
    set_addr $I10, alt1158_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "<...>", rx1145_fail
    add rx1145_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ENDSTMT"()
    unless $P10, rx1145_fail
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
    goto alt1158_end
  alt1158_1:
    set_addr $I10, alt1158_2
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1145_pos, 3
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 3
    ne $S10, "<*>", rx1145_fail
    add rx1145_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ENDSTMT"()
    unless $P10, rx1145_fail
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
    goto alt1158_end
  alt1158_2:
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1158_end:
.annotate 'line', 507
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 501
    goto alt1151_end
  alt1151_1:
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1172_fail
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  alt1171_0:
    set_addr $I10, alt1171_1
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "regex", rx1145_fail
    add rx1145_pos, 5
    goto alt1171_end
  alt1171_1:
    set_addr $I10, alt1171_2
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  # rx literal  "token"
    add $I11, rx1145_pos, 5
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 5
    ne $S10, "token", rx1145_fail
    add rx1145_pos, 5
    goto alt1171_end
  alt1171_2:
  # rx literal  "rule"
    add $I11, rx1145_pos, 4
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    substr $S10, rx1145_tgt, $I11, 4
    ne $S10, "rule", rx1145_fail
    add rx1145_pos, 4
  alt1171_end:
    set_addr $I10, rxcap_1172_fail
    ($I12, $I11) = rx1145_cur."!mark_peek"($I10)
    rx1145_cur."!cursor_pos"($I11)
    ($P10) = rx1145_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1145_pos, "")
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1172_done
  rxcap_1172_fail:
    goto rx1145_fail
  rxcap_1172_done:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 509
  # rx subrule "deflongname" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."deflongname"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 510
  # rx subrule "newpad" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."newpad"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 511
  # rx rxquantr1176 ** 0..1
    set_addr $I10, rxquantr1176_done
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  rxquantr1176_loop:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 40, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."signature"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 41, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
    set_addr $I10, rxquantr1176_done
    (rx1145_rep) = rx1145_cur."!mark_commit"($I10)
  rxquantr1176_done:
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 512
  # rx reduce name="regex_declarator" key="open"
    rx1145_cur."!cursor_pos"(rx1145_pos)
    rx1145_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 513
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ENDSTMT"()
    unless $P10, rx1145_fail
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  alt1151_end:
.annotate 'line', 514
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
.annotate 'line', 499
  # rx pass
    rx1145_cur."!cursor_pass"(rx1145_pos, "regex_declarator")
    if_null rx1145_debug, debug_1067
    rx1145_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1145_pos)
  debug_1067:
    .return (rx1145_cur)
  rx1145_restart:
.annotate 'line', 10
    if_null rx1145_debug, debug_1068
    rx1145_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1068:
  rx1145_fail:
    (rx1145_rep, rx1145_pos, $I10, $P10) = rx1145_cur."!mark_fail"(0)
    lt rx1145_pos, -1, rx1145_done
    eq rx1145_pos, -1, rx1145_fail
    jump $I10
  rx1145_done:
    rx1145_cur."!cursor_fail"()
    if_null rx1145_debug, debug_1069
    rx1145_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1069:
    .return (rx1145_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303576195.699") :method
.annotate 'line', 10
    $P1147 = self."!PREFIX__!subrule"("ws", "")
    new $P1148, "ResizablePMCArray"
    push $P1148, $P1147
    .return ($P1148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1186_tgt
    .local int rx1186_pos
    .local int rx1186_off
    .local int rx1186_eos
    .local int rx1186_rep
    .local pmc rx1186_cur
    .local pmc rx1186_debug
    (rx1186_cur, rx1186_pos, rx1186_tgt, $I10) = self."!cursor_start"()
    rx1186_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1186_cur
    .local pmc match
    .lex "$/", match
    length rx1186_eos, rx1186_tgt
    gt rx1186_pos, rx1186_eos, rx1186_done
    set rx1186_off, 0
    lt rx1186_pos, 2, rx1186_start
    sub rx1186_off, rx1186_pos, 1
    substr rx1186_tgt, rx1186_tgt, rx1186_off
  rx1186_start:
    eq $I10, 1, rx1186_restart
    if_null rx1186_debug, debug_1070
    rx1186_cur."!cursor_debug"("START", "dotty")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1190_done
    goto rxscan1190_scan
  rxscan1190_loop:
    (rx1186_pos) = rx1186_cur."from"()
    inc rx1186_pos
    rx1186_cur."!cursor_from"(rx1186_pos)
    ge rx1186_pos, rx1186_eos, rxscan1190_done
  rxscan1190_scan:
    set_addr $I10, rxscan1190_loop
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxscan1190_done:
.annotate 'line', 518
  # rx literal  "."
    add $I11, rx1186_pos, 1
    gt $I11, rx1186_eos, rx1186_fail
    sub $I11, rx1186_pos, rx1186_off
    ord $I11, rx1186_tgt, $I11
    ne $I11, 46, rx1186_fail
    add rx1186_pos, 1
  alt1191_0:
.annotate 'line', 519
    set_addr $I10, alt1191_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."deflongname"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1186_pos = $P10."pos"()
    goto alt1191_end
  alt1191_1:
.annotate 'line', 520
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "quote" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."quote"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1186_pos = $P10."pos"()
  alt1192_0:
.annotate 'line', 521
    set_addr $I10, alt1192_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1186_fail
    goto alt1192_end
  alt1192_1:
  # rx subrule "panic" subtype=method negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1186_fail
    rx1186_pos = $P10."pos"()
  alt1192_end:
  alt1191_end:
.annotate 'line', 527
  # rx rxquantr1193 ** 0..1
    set_addr $I10, rxquantr1193_done
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxquantr1193_loop:
  alt1194_0:
.annotate 'line', 524
    set_addr $I10, alt1194_1
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
.annotate 'line', 525
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "args" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."args"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1186_pos = $P10."pos"()
    goto alt1194_end
  alt1194_1:
.annotate 'line', 526
  # rx literal  ":"
    add $I11, rx1186_pos, 1
    gt $I11, rx1186_eos, rx1186_fail
    sub $I11, rx1186_pos, rx1186_off
    ord $I11, rx1186_tgt, $I11
    ne $I11, 58, rx1186_fail
    add rx1186_pos, 1
  # rx charclass s
    ge rx1186_pos, rx1186_eos, rx1186_fail
    sub $I10, rx1186_pos, rx1186_off
    is_cclass $I11, 32, rx1186_tgt, $I10
    unless $I11, rx1186_fail
    inc rx1186_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."arglist"()
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1186_pos = $P10."pos"()
  alt1194_end:
.annotate 'line', 527
    set_addr $I10, rxquantr1193_done
    (rx1186_rep) = rx1186_cur."!mark_commit"($I10)
  rxquantr1193_done:
.annotate 'line', 517
  # rx pass
    rx1186_cur."!cursor_pass"(rx1186_pos, "dotty")
    if_null rx1186_debug, debug_1071
    rx1186_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1186_pos)
  debug_1071:
    .return (rx1186_cur)
  rx1186_restart:
.annotate 'line', 10
    if_null rx1186_debug, debug_1072
    rx1186_cur."!cursor_debug"("NEXT", "dotty")
  debug_1072:
  rx1186_fail:
    (rx1186_rep, rx1186_pos, $I10, $P10) = rx1186_cur."!mark_fail"(0)
    lt rx1186_pos, -1, rx1186_done
    eq rx1186_pos, -1, rx1186_fail
    jump $I10
  rx1186_done:
    rx1186_cur."!cursor_fail"()
    if_null rx1186_debug, debug_1073
    rx1186_cur."!cursor_debug"("FAIL", "dotty")
  debug_1073:
    .return (rx1186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303576195.699") :method
.annotate 'line', 10
    $P1188 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1189, "ResizablePMCArray"
    push $P1189, "'"
    push $P1189, "\""
    push $P1189, $P1188
    .return ($P1189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303576195.699")
    .param pmc param_1196
.annotate 'line', 531
    .lex "self", param_1196
    $P1197 = param_1196."!protoregex"("term")
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303576195.699")
    .param pmc param_1199
.annotate 'line', 531
    .lex "self", param_1199
    $P1200 = param_1199."!PREFIX__!protoregex"("term")
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1202_tgt
    .local int rx1202_pos
    .local int rx1202_off
    .local int rx1202_eos
    .local int rx1202_rep
    .local pmc rx1202_cur
    .local pmc rx1202_debug
    (rx1202_cur, rx1202_pos, rx1202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1202_cur
    .local pmc match
    .lex "$/", match
    length rx1202_eos, rx1202_tgt
    gt rx1202_pos, rx1202_eos, rx1202_done
    set rx1202_off, 0
    lt rx1202_pos, 2, rx1202_start
    sub rx1202_off, rx1202_pos, 1
    substr rx1202_tgt, rx1202_tgt, rx1202_off
  rx1202_start:
    eq $I10, 1, rx1202_restart
    if_null rx1202_debug, debug_1074
    rx1202_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1205_done
    goto rxscan1205_scan
  rxscan1205_loop:
    (rx1202_pos) = rx1202_cur."from"()
    inc rx1202_pos
    rx1202_cur."!cursor_from"(rx1202_pos)
    ge rx1202_pos, rx1202_eos, rxscan1205_done
  rxscan1205_scan:
    set_addr $I10, rxscan1205_loop
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxscan1205_done:
.annotate 'line', 533
  # rx subcapture "sym"
    set_addr $I10, rxcap_1206_fail
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  # rx literal  "self"
    add $I11, rx1202_pos, 4
    gt $I11, rx1202_eos, rx1202_fail
    sub $I11, rx1202_pos, rx1202_off
    substr $S10, rx1202_tgt, $I11, 4
    ne $S10, "self", rx1202_fail
    add rx1202_pos, 4
    set_addr $I10, rxcap_1206_fail
    ($I12, $I11) = rx1202_cur."!mark_peek"($I10)
    rx1202_cur."!cursor_pos"($I11)
    ($P10) = rx1202_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1202_pos, "")
    rx1202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1206_done
  rxcap_1206_fail:
    goto rx1202_fail
  rxcap_1206_done:
  # rxanchor rwb
    le rx1202_pos, 0, rx1202_fail
    sub $I10, rx1202_pos, rx1202_off
    is_cclass $I11, 8192, rx1202_tgt, $I10
    if $I11, rx1202_fail
    dec $I10
    is_cclass $I11, 8192, rx1202_tgt, $I10
    unless $I11, rx1202_fail
  # rx pass
    rx1202_cur."!cursor_pass"(rx1202_pos, "term:sym<self>")
    if_null rx1202_debug, debug_1075
    rx1202_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1202_pos)
  debug_1075:
    .return (rx1202_cur)
  rx1202_restart:
.annotate 'line', 10
    if_null rx1202_debug, debug_1076
    rx1202_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1076:
  rx1202_fail:
    (rx1202_rep, rx1202_pos, $I10, $P10) = rx1202_cur."!mark_fail"(0)
    lt rx1202_pos, -1, rx1202_done
    eq rx1202_pos, -1, rx1202_fail
    jump $I10
  rx1202_done:
    rx1202_cur."!cursor_fail"()
    if_null rx1202_debug, debug_1077
    rx1202_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1077:
    .return (rx1202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303576195.699") :method
.annotate 'line', 10
    new $P1204, "ResizablePMCArray"
    push $P1204, "self"
    .return ($P1204)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1208_tgt
    .local int rx1208_pos
    .local int rx1208_off
    .local int rx1208_eos
    .local int rx1208_rep
    .local pmc rx1208_cur
    .local pmc rx1208_debug
    (rx1208_cur, rx1208_pos, rx1208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1208_cur
    .local pmc match
    .lex "$/", match
    length rx1208_eos, rx1208_tgt
    gt rx1208_pos, rx1208_eos, rx1208_done
    set rx1208_off, 0
    lt rx1208_pos, 2, rx1208_start
    sub rx1208_off, rx1208_pos, 1
    substr rx1208_tgt, rx1208_tgt, rx1208_off
  rx1208_start:
    eq $I10, 1, rx1208_restart
    if_null rx1208_debug, debug_1078
    rx1208_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1212_done
    goto rxscan1212_scan
  rxscan1212_loop:
    (rx1208_pos) = rx1208_cur."from"()
    inc rx1208_pos
    rx1208_cur."!cursor_from"(rx1208_pos)
    ge rx1208_pos, rx1208_eos, rxscan1212_done
  rxscan1212_scan:
    set_addr $I10, rxscan1212_loop
    rx1208_cur."!mark_push"(0, rx1208_pos, $I10)
  rxscan1212_done:
.annotate 'line', 536
  # rx subrule "deflongname" subtype=capture negate=
    rx1208_cur."!cursor_pos"(rx1208_pos)
    $P10 = rx1208_cur."deflongname"()
    unless $P10, rx1208_fail
    rx1208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1208_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1208_pos, rx1208_off
    substr $S10, rx1208_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1208_fail
  # rx subrule "args" subtype=capture negate=
    rx1208_cur."!cursor_pos"(rx1208_pos)
    $P10 = rx1208_cur."args"()
    unless $P10, rx1208_fail
    rx1208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1208_pos = $P10."pos"()
.annotate 'line', 535
  # rx pass
    rx1208_cur."!cursor_pass"(rx1208_pos, "term:sym<identifier>")
    if_null rx1208_debug, debug_1079
    rx1208_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1208_pos)
  debug_1079:
    .return (rx1208_cur)
  rx1208_restart:
.annotate 'line', 10
    if_null rx1208_debug, debug_1080
    rx1208_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1080:
  rx1208_fail:
    (rx1208_rep, rx1208_pos, $I10, $P10) = rx1208_cur."!mark_fail"(0)
    lt rx1208_pos, -1, rx1208_done
    eq rx1208_pos, -1, rx1208_fail
    jump $I10
  rx1208_done:
    rx1208_cur."!cursor_fail"()
    if_null rx1208_debug, debug_1081
    rx1208_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1081:
    .return (rx1208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303576195.699") :method
.annotate 'line', 10
    $P1210 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1211, "ResizablePMCArray"
    push $P1211, $P1210
    .return ($P1211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1214_tgt
    .local int rx1214_pos
    .local int rx1214_off
    .local int rx1214_eos
    .local int rx1214_rep
    .local pmc rx1214_cur
    .local pmc rx1214_debug
    (rx1214_cur, rx1214_pos, rx1214_tgt, $I10) = self."!cursor_start"()
    rx1214_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1214_cur
    .local pmc match
    .lex "$/", match
    length rx1214_eos, rx1214_tgt
    gt rx1214_pos, rx1214_eos, rx1214_done
    set rx1214_off, 0
    lt rx1214_pos, 2, rx1214_start
    sub rx1214_off, rx1214_pos, 1
    substr rx1214_tgt, rx1214_tgt, rx1214_off
  rx1214_start:
    eq $I10, 1, rx1214_restart
    if_null rx1214_debug, debug_1082
    rx1214_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1214_pos) = rx1214_cur."from"()
    inc rx1214_pos
    rx1214_cur."!cursor_from"(rx1214_pos)
    ge rx1214_pos, rx1214_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxscan1218_done:
.annotate 'line', 540
  # rx subrule "name" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."name"()
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1214_pos = $P10."pos"()
  # rx rxquantr1219 ** 0..1
    set_addr $I10, rxquantr1219_done
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxquantr1219_loop:
  # rx subrule "args" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."args"()
    unless $P10, rx1214_fail
    goto rxsubrule1220_pass
  rxsubrule1220_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1214_fail
  rxsubrule1220_pass:
    set_addr $I10, rxsubrule1220_back
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1214_pos = $P10."pos"()
    set_addr $I10, rxquantr1219_done
    (rx1214_rep) = rx1214_cur."!mark_commit"($I10)
  rxquantr1219_done:
.annotate 'line', 539
  # rx pass
    rx1214_cur."!cursor_pass"(rx1214_pos, "term:sym<name>")
    if_null rx1214_debug, debug_1083
    rx1214_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1214_pos)
  debug_1083:
    .return (rx1214_cur)
  rx1214_restart:
.annotate 'line', 10
    if_null rx1214_debug, debug_1084
    rx1214_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1084:
  rx1214_fail:
    (rx1214_rep, rx1214_pos, $I10, $P10) = rx1214_cur."!mark_fail"(0)
    lt rx1214_pos, -1, rx1214_done
    eq rx1214_pos, -1, rx1214_fail
    jump $I10
  rx1214_done:
    rx1214_cur."!cursor_fail"()
    if_null rx1214_debug, debug_1085
    rx1214_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1085:
    .return (rx1214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303576195.699") :method
.annotate 'line', 10
    $P1216 = self."!PREFIX__!subrule"("name", "")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1216
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1222_tgt
    .local int rx1222_pos
    .local int rx1222_off
    .local int rx1222_eos
    .local int rx1222_rep
    .local pmc rx1222_cur
    .local pmc rx1222_debug
    (rx1222_cur, rx1222_pos, rx1222_tgt, $I10) = self."!cursor_start"()
    rx1222_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1222_cur
    .local pmc match
    .lex "$/", match
    length rx1222_eos, rx1222_tgt
    gt rx1222_pos, rx1222_eos, rx1222_done
    set rx1222_off, 0
    lt rx1222_pos, 2, rx1222_start
    sub rx1222_off, rx1222_pos, 1
    substr rx1222_tgt, rx1222_tgt, rx1222_off
  rx1222_start:
    eq $I10, 1, rx1222_restart
    if_null rx1222_debug, debug_1086
    rx1222_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1225_done
    goto rxscan1225_scan
  rxscan1225_loop:
    (rx1222_pos) = rx1222_cur."from"()
    inc rx1222_pos
    rx1222_cur."!cursor_from"(rx1222_pos)
    ge rx1222_pos, rx1222_eos, rxscan1225_done
  rxscan1225_scan:
    set_addr $I10, rxscan1225_loop
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  rxscan1225_done:
.annotate 'line', 544
  # rx literal  "pir::"
    add $I11, rx1222_pos, 5
    gt $I11, rx1222_eos, rx1222_fail
    sub $I11, rx1222_pos, rx1222_off
    substr $S10, rx1222_tgt, $I11, 5
    ne $S10, "pir::", rx1222_fail
    add rx1222_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1226_fail
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1222_pos, rx1222_off
    find_not_cclass $I11, 8192, rx1222_tgt, $I10, rx1222_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1222_fail
    add rx1222_pos, rx1222_off, $I11
    set_addr $I10, rxcap_1226_fail
    ($I12, $I11) = rx1222_cur."!mark_peek"($I10)
    rx1222_cur."!cursor_pos"($I11)
    ($P10) = rx1222_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1222_pos, "")
    rx1222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1226_done
  rxcap_1226_fail:
    goto rx1222_fail
  rxcap_1226_done:
  # rx rxquantr1227 ** 0..1
    set_addr $I10, rxquantr1227_done
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  rxquantr1227_loop:
  # rx subrule "args" subtype=capture negate=
    rx1222_cur."!cursor_pos"(rx1222_pos)
    $P10 = rx1222_cur."args"()
    unless $P10, rx1222_fail
    goto rxsubrule1228_pass
  rxsubrule1228_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1222_fail
  rxsubrule1228_pass:
    set_addr $I10, rxsubrule1228_back
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1222_pos = $P10."pos"()
    set_addr $I10, rxquantr1227_done
    (rx1222_rep) = rx1222_cur."!mark_commit"($I10)
  rxquantr1227_done:
.annotate 'line', 543
  # rx pass
    rx1222_cur."!cursor_pass"(rx1222_pos, "term:sym<pir::op>")
    if_null rx1222_debug, debug_1087
    rx1222_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1222_pos)
  debug_1087:
    .return (rx1222_cur)
  rx1222_restart:
.annotate 'line', 10
    if_null rx1222_debug, debug_1088
    rx1222_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1088:
  rx1222_fail:
    (rx1222_rep, rx1222_pos, $I10, $P10) = rx1222_cur."!mark_fail"(0)
    lt rx1222_pos, -1, rx1222_done
    eq rx1222_pos, -1, rx1222_fail
    jump $I10
  rx1222_done:
    rx1222_cur."!cursor_fail"()
    if_null rx1222_debug, debug_1089
    rx1222_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1089:
    .return (rx1222_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303576195.699") :method
.annotate 'line', 10
    new $P1224, "ResizablePMCArray"
    push $P1224, "pir::"
    .return ($P1224)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P1238 = "226_1303576195.699" 
    capture_lex $P1238
    .local string rx1230_tgt
    .local int rx1230_pos
    .local int rx1230_off
    .local int rx1230_eos
    .local int rx1230_rep
    .local pmc rx1230_cur
    .local pmc rx1230_debug
    (rx1230_cur, rx1230_pos, rx1230_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1230_cur
    .local pmc match
    .lex "$/", match
    length rx1230_eos, rx1230_tgt
    gt rx1230_pos, rx1230_eos, rx1230_done
    set rx1230_off, 0
    lt rx1230_pos, 2, rx1230_start
    sub rx1230_off, rx1230_pos, 1
    substr rx1230_tgt, rx1230_tgt, rx1230_off
  rx1230_start:
    eq $I10, 1, rx1230_restart
    if_null rx1230_debug, debug_1090
    rx1230_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1090:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1233_done
    goto rxscan1233_scan
  rxscan1233_loop:
    (rx1230_pos) = rx1230_cur."from"()
    inc rx1230_pos
    rx1230_cur."!cursor_from"(rx1230_pos)
    ge rx1230_pos, rx1230_eos, rxscan1233_done
  rxscan1233_scan:
    set_addr $I10, rxscan1233_loop
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  rxscan1233_done:
.annotate 'line', 548
  # rx literal  "{*}"
    add $I11, rx1230_pos, 3
    gt $I11, rx1230_eos, rx1230_fail
    sub $I11, rx1230_pos, rx1230_off
    substr $S10, rx1230_tgt, $I11, 3
    ne $S10, "{*}", rx1230_fail
    add rx1230_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."ENDSTMT"()
    unless $P10, rx1230_fail
  alt1234_0:
.annotate 'line', 549
    set_addr $I10, alt1234_1
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
    rx1230_cur."!cursor_pos"(rx1230_pos)
    find_lex $P1235, unicode:"$\x{a2}"
    $P1236 = $P1235."MATCH"()
    store_lex "$/", $P1236
    .const 'Sub' $P1238 = "226_1303576195.699" 
    capture_lex $P1238
    $P1242 = $P1238()
    unless $P1242, rx1230_fail
    goto alt1234_end
  alt1234_1:
  # rx subrule "panic" subtype=method negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1230_fail
    rx1230_pos = $P10."pos"()
  alt1234_end:
.annotate 'line', 547
  # rx pass
    rx1230_cur."!cursor_pass"(rx1230_pos, "term:sym<onlystar>")
    if_null rx1230_debug, debug_1093
    rx1230_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1230_pos)
  debug_1093:
    .return (rx1230_cur)
  rx1230_restart:
.annotate 'line', 10
    if_null rx1230_debug, debug_1094
    rx1230_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1094:
  rx1230_fail:
    (rx1230_rep, rx1230_pos, $I10, $P10) = rx1230_cur."!mark_fail"(0)
    lt rx1230_pos, -1, rx1230_done
    eq rx1230_pos, -1, rx1230_fail
    jump $I10
  rx1230_done:
    rx1230_cur."!cursor_fail"()
    if_null rx1230_debug, debug_1095
    rx1230_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1095:
    .return (rx1230_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303576195.699") :method
.annotate 'line', 10
    new $P1232, "ResizablePMCArray"
    push $P1232, "{*}"
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1237"  :anon :subid("226_1303576195.699") :outer("224_1303576195.699")
.annotate 'line', 549
    find_dynamic_lex $P1239, "$*MULTINESS"
    unless_null $P1239, vivify_1091
    get_hll_global $P1239, "$MULTINESS"
    unless_null $P1239, vivify_1092
    die "Contextual $*MULTINESS not found"
  vivify_1092:
  vivify_1091:
    set $S1240, $P1239
    iseq $I1241, $S1240, "proto"
    .return ($I1241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_1096
    rx1244_cur."!cursor_debug"("START", "args")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 553
  # rx literal  "("
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 40, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."arglist"()
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1244_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 41, rx1244_fail
    add rx1244_pos, 1
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "args")
    if_null rx1244_debug, debug_1097
    rx1244_cur."!cursor_debug"("PASS", "args", " at pos=", rx1244_pos)
  debug_1097:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 10
    if_null rx1244_debug, debug_1098
    rx1244_cur."!cursor_debug"("NEXT", "args")
  debug_1098:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_1099
    rx1244_cur."!cursor_debug"("FAIL", "args")
  debug_1099:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303576195.699") :method
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1250_tgt
    .local int rx1250_pos
    .local int rx1250_off
    .local int rx1250_eos
    .local int rx1250_rep
    .local pmc rx1250_cur
    .local pmc rx1250_debug
    (rx1250_cur, rx1250_pos, rx1250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1250_cur
    .local pmc match
    .lex "$/", match
    length rx1250_eos, rx1250_tgt
    gt rx1250_pos, rx1250_eos, rx1250_done
    set rx1250_off, 0
    lt rx1250_pos, 2, rx1250_start
    sub rx1250_off, rx1250_pos, 1
    substr rx1250_tgt, rx1250_tgt, rx1250_off
  rx1250_start:
    eq $I10, 1, rx1250_restart
    if_null rx1250_debug, debug_1100
    rx1250_cur."!cursor_debug"("START", "arglist")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1254_done
    goto rxscan1254_scan
  rxscan1254_loop:
    (rx1250_pos) = rx1250_cur."from"()
    inc rx1250_pos
    rx1250_cur."!cursor_from"(rx1250_pos)
    ge rx1250_pos, rx1250_eos, rxscan1254_done
  rxscan1254_scan:
    set_addr $I10, rxscan1254_loop
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  rxscan1254_done:
.annotate 'line', 557
  # rx subrule "ws" subtype=method negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."ws"()
    unless $P10, rx1250_fail
    rx1250_pos = $P10."pos"()
  alt1255_0:
.annotate 'line', 558
    set_addr $I10, alt1255_1
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
.annotate 'line', 559
  # rx subrule "EXPR" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."EXPR"("f=")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1250_pos = $P10."pos"()
    goto alt1255_end
  alt1255_1:
  alt1255_end:
.annotate 'line', 556
  # rx pass
    rx1250_cur."!cursor_pass"(rx1250_pos, "arglist")
    if_null rx1250_debug, debug_1101
    rx1250_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1250_pos)
  debug_1101:
    .return (rx1250_cur)
  rx1250_restart:
.annotate 'line', 10
    if_null rx1250_debug, debug_1102
    rx1250_cur."!cursor_debug"("NEXT", "arglist")
  debug_1102:
  rx1250_fail:
    (rx1250_rep, rx1250_pos, $I10, $P10) = rx1250_cur."!mark_fail"(0)
    lt rx1250_pos, -1, rx1250_done
    eq rx1250_pos, -1, rx1250_fail
    jump $I10
  rx1250_done:
    rx1250_cur."!cursor_fail"()
    if_null rx1250_debug, debug_1103
    rx1250_cur."!cursor_debug"("FAIL", "arglist")
  debug_1103:
    .return (rx1250_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303576195.699") :method
.annotate 'line', 10
    $P1252 = self."!PREFIX__!subrule"("ws", "")
    new $P1253, "ResizablePMCArray"
    push $P1253, $P1252
    .return ($P1253)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_1104
    rx1257_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1261_done
    goto rxscan1261_scan
  rxscan1261_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1261_done
  rxscan1261_scan:
    set_addr $I10, rxscan1261_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1261_done:
.annotate 'line', 565
  # rx subrule "value" subtype=capture negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."value"()
    unless $P10, rx1257_fail
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1257_pos = $P10."pos"()
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, "term:sym<value>")
    if_null rx1257_debug, debug_1105
    rx1257_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1257_pos)
  debug_1105:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 10
    if_null rx1257_debug, debug_1106
    rx1257_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1106:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_1107
    rx1257_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1107:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303576195.699") :method
.annotate 'line', 10
    $P1259 = self."!PREFIX__!subrule"("value", "")
    new $P1260, "ResizablePMCArray"
    push $P1260, $P1259
    .return ($P1260)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1263_tgt
    .local int rx1263_pos
    .local int rx1263_off
    .local int rx1263_eos
    .local int rx1263_rep
    .local pmc rx1263_cur
    .local pmc rx1263_debug
    (rx1263_cur, rx1263_pos, rx1263_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1263_cur
    .local pmc match
    .lex "$/", match
    length rx1263_eos, rx1263_tgt
    gt rx1263_pos, rx1263_eos, rx1263_done
    set rx1263_off, 0
    lt rx1263_pos, 2, rx1263_start
    sub rx1263_off, rx1263_pos, 1
    substr rx1263_tgt, rx1263_tgt, rx1263_off
  rx1263_start:
    eq $I10, 1, rx1263_restart
    if_null rx1263_debug, debug_1108
    rx1263_cur."!cursor_debug"("START", "value")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1268_done
    goto rxscan1268_scan
  rxscan1268_loop:
    (rx1263_pos) = rx1263_cur."from"()
    inc rx1263_pos
    rx1263_cur."!cursor_from"(rx1263_pos)
    ge rx1263_pos, rx1263_eos, rxscan1268_done
  rxscan1268_scan:
    set_addr $I10, rxscan1268_loop
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  rxscan1268_done:
  alt1269_0:
.annotate 'line', 567
    set_addr $I10, alt1269_1
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
.annotate 'line', 568
  # rx subrule "quote" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."quote"()
    unless $P10, rx1263_fail
    rx1263_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1263_pos = $P10."pos"()
    goto alt1269_end
  alt1269_1:
.annotate 'line', 569
  # rx subrule "number" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."number"()
    unless $P10, rx1263_fail
    rx1263_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1263_pos = $P10."pos"()
  alt1269_end:
.annotate 'line', 567
  # rx pass
    rx1263_cur."!cursor_pass"(rx1263_pos, "value")
    if_null rx1263_debug, debug_1109
    rx1263_cur."!cursor_debug"("PASS", "value", " at pos=", rx1263_pos)
  debug_1109:
    .return (rx1263_cur)
  rx1263_restart:
.annotate 'line', 10
    if_null rx1263_debug, debug_1110
    rx1263_cur."!cursor_debug"("NEXT", "value")
  debug_1110:
  rx1263_fail:
    (rx1263_rep, rx1263_pos, $I10, $P10) = rx1263_cur."!mark_fail"(0)
    lt rx1263_pos, -1, rx1263_done
    eq rx1263_pos, -1, rx1263_fail
    jump $I10
  rx1263_done:
    rx1263_cur."!cursor_fail"()
    if_null rx1263_debug, debug_1111
    rx1263_cur."!cursor_debug"("FAIL", "value")
  debug_1111:
    .return (rx1263_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303576195.699") :method
.annotate 'line', 10
    $P1265 = self."!PREFIX__!subrule"("number", "")
    $P1266 = self."!PREFIX__!subrule"("quote", "")
    new $P1267, "ResizablePMCArray"
    push $P1267, $P1265
    push $P1267, $P1266
    .return ($P1267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1271_tgt
    .local int rx1271_pos
    .local int rx1271_off
    .local int rx1271_eos
    .local int rx1271_rep
    .local pmc rx1271_cur
    .local pmc rx1271_debug
    (rx1271_cur, rx1271_pos, rx1271_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1271_cur
    .local pmc match
    .lex "$/", match
    length rx1271_eos, rx1271_tgt
    gt rx1271_pos, rx1271_eos, rx1271_done
    set rx1271_off, 0
    lt rx1271_pos, 2, rx1271_start
    sub rx1271_off, rx1271_pos, 1
    substr rx1271_tgt, rx1271_tgt, rx1271_off
  rx1271_start:
    eq $I10, 1, rx1271_restart
    if_null rx1271_debug, debug_1112
    rx1271_cur."!cursor_debug"("START", "number")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1274_done
    goto rxscan1274_scan
  rxscan1274_loop:
    (rx1271_pos) = rx1271_cur."from"()
    inc rx1271_pos
    rx1271_cur."!cursor_from"(rx1271_pos)
    ge rx1271_pos, rx1271_eos, rxscan1274_done
  rxscan1274_scan:
    set_addr $I10, rxscan1274_loop
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  rxscan1274_done:
.annotate 'line', 573
  # rx subcapture "sign"
    set_addr $I10, rxcap_1276_fail
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1271_pos, rx1271_off
    set rx1271_rep, 0
    sub $I12, rx1271_eos, rx1271_pos
    le $I12, 1, rxenumcharlistq1275_loop
    set $I12, 1
  rxenumcharlistq1275_loop:
    le $I12, 0, rxenumcharlistq1275_done
    substr $S10, rx1271_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1275_done
    inc rx1271_rep
  rxenumcharlistq1275_done:
    add rx1271_pos, rx1271_pos, rx1271_rep
    set_addr $I10, rxcap_1276_fail
    ($I12, $I11) = rx1271_cur."!mark_peek"($I10)
    rx1271_cur."!cursor_pos"($I11)
    ($P10) = rx1271_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1271_pos, "")
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1276_done
  rxcap_1276_fail:
    goto rx1271_fail
  rxcap_1276_done:
  alt1277_0:
.annotate 'line', 574
    set_addr $I10, alt1277_1
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."dec_number"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1271_pos = $P10."pos"()
    goto alt1277_end
  alt1277_1:
  # rx subrule "integer" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."integer"()
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1271_pos = $P10."pos"()
  alt1277_end:
.annotate 'line', 572
  # rx pass
    rx1271_cur."!cursor_pass"(rx1271_pos, "number")
    if_null rx1271_debug, debug_1113
    rx1271_cur."!cursor_debug"("PASS", "number", " at pos=", rx1271_pos)
  debug_1113:
    .return (rx1271_cur)
  rx1271_restart:
.annotate 'line', 10
    if_null rx1271_debug, debug_1114
    rx1271_cur."!cursor_debug"("NEXT", "number")
  debug_1114:
  rx1271_fail:
    (rx1271_rep, rx1271_pos, $I10, $P10) = rx1271_cur."!mark_fail"(0)
    lt rx1271_pos, -1, rx1271_done
    eq rx1271_pos, -1, rx1271_fail
    jump $I10
  rx1271_done:
    rx1271_cur."!cursor_fail"()
    if_null rx1271_debug, debug_1115
    rx1271_cur."!cursor_debug"("FAIL", "number")
  debug_1115:
    .return (rx1271_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303576195.699") :method
.annotate 'line', 10
    new $P1273, "ResizablePMCArray"
    push $P1273, ""
    .return ($P1273)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303576195.699")
    .param pmc param_1279
.annotate 'line', 577
    .lex "self", param_1279
    $P1280 = param_1279."!protoregex"("quote")
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303576195.699")
    .param pmc param_1282
.annotate 'line', 577
    .lex "self", param_1282
    $P1283 = param_1282."!PREFIX__!protoregex"("quote")
    .return ($P1283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1285_tgt
    .local int rx1285_pos
    .local int rx1285_off
    .local int rx1285_eos
    .local int rx1285_rep
    .local pmc rx1285_cur
    .local pmc rx1285_debug
    (rx1285_cur, rx1285_pos, rx1285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1285_cur
    .local pmc match
    .lex "$/", match
    length rx1285_eos, rx1285_tgt
    gt rx1285_pos, rx1285_eos, rx1285_done
    set rx1285_off, 0
    lt rx1285_pos, 2, rx1285_start
    sub rx1285_off, rx1285_pos, 1
    substr rx1285_tgt, rx1285_tgt, rx1285_off
  rx1285_start:
    eq $I10, 1, rx1285_restart
    if_null rx1285_debug, debug_1116
    rx1285_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1116:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1288_done
    goto rxscan1288_scan
  rxscan1288_loop:
    (rx1285_pos) = rx1285_cur."from"()
    inc rx1285_pos
    rx1285_cur."!cursor_from"(rx1285_pos)
    ge rx1285_pos, rx1285_eos, rxscan1288_done
  rxscan1288_scan:
    set_addr $I10, rxscan1288_loop
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxscan1288_done:
.annotate 'line', 578
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1285_pos, rx1285_off
    substr $S10, rx1285_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1285_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."quote_EXPR"(":q")
    unless $P10, rx1285_fail
    rx1285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1285_pos = $P10."pos"()
  # rx pass
    rx1285_cur."!cursor_pass"(rx1285_pos, "quote:sym<apos>")
    if_null rx1285_debug, debug_1117
    rx1285_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1285_pos)
  debug_1117:
    .return (rx1285_cur)
  rx1285_restart:
.annotate 'line', 10
    if_null rx1285_debug, debug_1118
    rx1285_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1118:
  rx1285_fail:
    (rx1285_rep, rx1285_pos, $I10, $P10) = rx1285_cur."!mark_fail"(0)
    lt rx1285_pos, -1, rx1285_done
    eq rx1285_pos, -1, rx1285_fail
    jump $I10
  rx1285_done:
    rx1285_cur."!cursor_fail"()
    if_null rx1285_debug, debug_1119
    rx1285_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1119:
    .return (rx1285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303576195.699") :method
.annotate 'line', 10
    new $P1287, "ResizablePMCArray"
    push $P1287, "'"
    .return ($P1287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1290_tgt
    .local int rx1290_pos
    .local int rx1290_off
    .local int rx1290_eos
    .local int rx1290_rep
    .local pmc rx1290_cur
    .local pmc rx1290_debug
    (rx1290_cur, rx1290_pos, rx1290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1290_cur
    .local pmc match
    .lex "$/", match
    length rx1290_eos, rx1290_tgt
    gt rx1290_pos, rx1290_eos, rx1290_done
    set rx1290_off, 0
    lt rx1290_pos, 2, rx1290_start
    sub rx1290_off, rx1290_pos, 1
    substr rx1290_tgt, rx1290_tgt, rx1290_off
  rx1290_start:
    eq $I10, 1, rx1290_restart
    if_null rx1290_debug, debug_1120
    rx1290_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1293_done
    goto rxscan1293_scan
  rxscan1293_loop:
    (rx1290_pos) = rx1290_cur."from"()
    inc rx1290_pos
    rx1290_cur."!cursor_from"(rx1290_pos)
    ge rx1290_pos, rx1290_eos, rxscan1293_done
  rxscan1293_scan:
    set_addr $I10, rxscan1293_loop
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  rxscan1293_done:
.annotate 'line', 579
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1290_pos, rx1290_off
    substr $S10, rx1290_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1290_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."quote_EXPR"(":qq")
    unless $P10, rx1290_fail
    rx1290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1290_pos = $P10."pos"()
  # rx pass
    rx1290_cur."!cursor_pass"(rx1290_pos, "quote:sym<dblq>")
    if_null rx1290_debug, debug_1121
    rx1290_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1290_pos)
  debug_1121:
    .return (rx1290_cur)
  rx1290_restart:
.annotate 'line', 10
    if_null rx1290_debug, debug_1122
    rx1290_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1122:
  rx1290_fail:
    (rx1290_rep, rx1290_pos, $I10, $P10) = rx1290_cur."!mark_fail"(0)
    lt rx1290_pos, -1, rx1290_done
    eq rx1290_pos, -1, rx1290_fail
    jump $I10
  rx1290_done:
    rx1290_cur."!cursor_fail"()
    if_null rx1290_debug, debug_1123
    rx1290_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1123:
    .return (rx1290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303576195.699") :method
.annotate 'line', 10
    new $P1292, "ResizablePMCArray"
    push $P1292, "\""
    .return ($P1292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_1124
    rx1295_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1299_done
    goto rxscan1299_scan
  rxscan1299_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1299_done
  rxscan1299_scan:
    set_addr $I10, rxscan1299_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1299_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1300_fail
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  # rx literal  "q"
    add $I11, rx1295_pos, 1
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    ord $I11, rx1295_tgt, $I11
    ne $I11, 113, rx1295_fail
    add rx1295_pos, 1
    set_addr $I10, rxcap_1300_fail
    ($I12, $I11) = rx1295_cur."!mark_peek"($I10)
    rx1295_cur."!cursor_pos"($I11)
    ($P10) = rx1295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1295_pos, "")
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1300_done
  rxcap_1300_fail:
    goto rx1295_fail
  rxcap_1300_done:
  # rxanchor rwb
    le rx1295_pos, 0, rx1295_fail
    sub $I10, rx1295_pos, rx1295_off
    is_cclass $I11, 8192, rx1295_tgt, $I10
    if $I11, rx1295_fail
    dec $I10
    is_cclass $I11, 8192, rx1295_tgt, $I10
    unless $I11, rx1295_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1295_pos, rx1295_off
    substr $S10, rx1295_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1295_fail
  # rx subrule "ws" subtype=method negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."ws"()
    unless $P10, rx1295_fail
    rx1295_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."quote_EXPR"(":q")
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1295_pos = $P10."pos"()
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "quote:sym<q>")
    if_null rx1295_debug, debug_1125
    rx1295_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1295_pos)
  debug_1125:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 10
    if_null rx1295_debug, debug_1126
    rx1295_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1126:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_1127
    rx1295_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1127:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303576195.699") :method
.annotate 'line', 10
    $P1297 = self."!PREFIX__!subrule"("ws", "q")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_1128
    rx1302_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1307_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1302_pos, 2
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 2
    ne $S10, "qq", rx1302_fail
    add rx1302_pos, 2
    set_addr $I10, rxcap_1307_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1307_done
  rxcap_1307_fail:
    goto rx1302_fail
  rxcap_1307_done:
  # rxanchor rwb
    le rx1302_pos, 0, rx1302_fail
    sub $I10, rx1302_pos, rx1302_off
    is_cclass $I11, 8192, rx1302_tgt, $I10
    if $I11, rx1302_fail
    dec $I10
    is_cclass $I11, 8192, rx1302_tgt, $I10
    unless $I11, rx1302_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."quote_EXPR"(":qq")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1302_pos = $P10."pos"()
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "quote:sym<qq>")
    if_null rx1302_debug, debug_1129
    rx1302_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1302_pos)
  debug_1129:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 10
    if_null rx1302_debug, debug_1130
    rx1302_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1130:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_1131
    rx1302_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1131:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303576195.699") :method
.annotate 'line', 10
    $P1304 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1309_tgt
    .local int rx1309_pos
    .local int rx1309_off
    .local int rx1309_eos
    .local int rx1309_rep
    .local pmc rx1309_cur
    .local pmc rx1309_debug
    (rx1309_cur, rx1309_pos, rx1309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1309_cur
    .local pmc match
    .lex "$/", match
    length rx1309_eos, rx1309_tgt
    gt rx1309_pos, rx1309_eos, rx1309_done
    set rx1309_off, 0
    lt rx1309_pos, 2, rx1309_start
    sub rx1309_off, rx1309_pos, 1
    substr rx1309_tgt, rx1309_tgt, rx1309_off
  rx1309_start:
    eq $I10, 1, rx1309_restart
    if_null rx1309_debug, debug_1132
    rx1309_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1313_done
    goto rxscan1313_scan
  rxscan1313_loop:
    (rx1309_pos) = rx1309_cur."from"()
    inc rx1309_pos
    rx1309_cur."!cursor_from"(rx1309_pos)
    ge rx1309_pos, rx1309_eos, rxscan1313_done
  rxscan1313_scan:
    set_addr $I10, rxscan1313_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  rxscan1313_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1314_fail
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1309_pos, 1
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    ord $I11, rx1309_tgt, $I11
    ne $I11, 81, rx1309_fail
    add rx1309_pos, 1
    set_addr $I10, rxcap_1314_fail
    ($I12, $I11) = rx1309_cur."!mark_peek"($I10)
    rx1309_cur."!cursor_pos"($I11)
    ($P10) = rx1309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1309_pos, "")
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1314_done
  rxcap_1314_fail:
    goto rx1309_fail
  rxcap_1314_done:
  # rxanchor rwb
    le rx1309_pos, 0, rx1309_fail
    sub $I10, rx1309_pos, rx1309_off
    is_cclass $I11, 8192, rx1309_tgt, $I10
    if $I11, rx1309_fail
    dec $I10
    is_cclass $I11, 8192, rx1309_tgt, $I10
    unless $I11, rx1309_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1309_pos, rx1309_off
    substr $S10, rx1309_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1309_fail
  # rx subrule "ws" subtype=method negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."ws"()
    unless $P10, rx1309_fail
    rx1309_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."quote_EXPR"()
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1309_pos = $P10."pos"()
  # rx pass
    rx1309_cur."!cursor_pass"(rx1309_pos, "quote:sym<Q>")
    if_null rx1309_debug, debug_1133
    rx1309_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1309_pos)
  debug_1133:
    .return (rx1309_cur)
  rx1309_restart:
.annotate 'line', 10
    if_null rx1309_debug, debug_1134
    rx1309_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1134:
  rx1309_fail:
    (rx1309_rep, rx1309_pos, $I10, $P10) = rx1309_cur."!mark_fail"(0)
    lt rx1309_pos, -1, rx1309_done
    eq rx1309_pos, -1, rx1309_fail
    jump $I10
  rx1309_done:
    rx1309_cur."!cursor_fail"()
    if_null rx1309_debug, debug_1135
    rx1309_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1135:
    .return (rx1309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303576195.699") :method
.annotate 'line', 10
    $P1311 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1312, "ResizablePMCArray"
    push $P1312, $P1311
    .return ($P1312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1316_tgt
    .local int rx1316_pos
    .local int rx1316_off
    .local int rx1316_eos
    .local int rx1316_rep
    .local pmc rx1316_cur
    .local pmc rx1316_debug
    (rx1316_cur, rx1316_pos, rx1316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1316_cur
    .local pmc match
    .lex "$/", match
    length rx1316_eos, rx1316_tgt
    gt rx1316_pos, rx1316_eos, rx1316_done
    set rx1316_off, 0
    lt rx1316_pos, 2, rx1316_start
    sub rx1316_off, rx1316_pos, 1
    substr rx1316_tgt, rx1316_tgt, rx1316_off
  rx1316_start:
    eq $I10, 1, rx1316_restart
    if_null rx1316_debug, debug_1136
    rx1316_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1320_done
    goto rxscan1320_scan
  rxscan1320_loop:
    (rx1316_pos) = rx1316_cur."from"()
    inc rx1316_pos
    rx1316_cur."!cursor_from"(rx1316_pos)
    ge rx1316_pos, rx1316_eos, rxscan1320_done
  rxscan1320_scan:
    set_addr $I10, rxscan1320_loop
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  rxscan1320_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1321_fail
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1316_pos, 5
    gt $I11, rx1316_eos, rx1316_fail
    sub $I11, rx1316_pos, rx1316_off
    substr $S10, rx1316_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1316_fail
    add rx1316_pos, 5
    set_addr $I10, rxcap_1321_fail
    ($I12, $I11) = rx1316_cur."!mark_peek"($I10)
    rx1316_cur."!cursor_pos"($I11)
    ($P10) = rx1316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1316_pos, "")
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1321_done
  rxcap_1321_fail:
    goto rx1316_fail
  rxcap_1321_done:
  # rx subrule "ws" subtype=method negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."ws"()
    unless $P10, rx1316_fail
    rx1316_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."quote_EXPR"()
    unless $P10, rx1316_fail
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1316_pos = $P10."pos"()
  # rx pass
    rx1316_cur."!cursor_pass"(rx1316_pos, "quote:sym<Q:PIR>")
    if_null rx1316_debug, debug_1137
    rx1316_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1316_pos)
  debug_1137:
    .return (rx1316_cur)
  rx1316_restart:
.annotate 'line', 10
    if_null rx1316_debug, debug_1138
    rx1316_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1138:
  rx1316_fail:
    (rx1316_rep, rx1316_pos, $I10, $P10) = rx1316_cur."!mark_fail"(0)
    lt rx1316_pos, -1, rx1316_done
    eq rx1316_pos, -1, rx1316_fail
    jump $I10
  rx1316_done:
    rx1316_cur."!cursor_fail"()
    if_null rx1316_debug, debug_1139
    rx1316_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1139:
    .return (rx1316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303576195.699") :method
.annotate 'line', 10
    $P1318 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1319, "ResizablePMCArray"
    push $P1319, $P1318
    .return ($P1319)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1323_tgt
    .local int rx1323_pos
    .local int rx1323_off
    .local int rx1323_eos
    .local int rx1323_rep
    .local pmc rx1323_cur
    .local pmc rx1323_debug
    (rx1323_cur, rx1323_pos, rx1323_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1323_cur
    .local pmc match
    .lex "$/", match
    length rx1323_eos, rx1323_tgt
    gt rx1323_pos, rx1323_eos, rx1323_done
    set rx1323_off, 0
    lt rx1323_pos, 2, rx1323_start
    sub rx1323_off, rx1323_pos, 1
    substr rx1323_tgt, rx1323_tgt, rx1323_off
  rx1323_start:
    eq $I10, 1, rx1323_restart
    if_null rx1323_debug, debug_1140
    rx1323_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1327_done
    goto rxscan1327_scan
  rxscan1327_loop:
    (rx1323_pos) = rx1323_cur."from"()
    inc rx1323_pos
    rx1323_cur."!cursor_from"(rx1323_pos)
    ge rx1323_pos, rx1323_eos, rxscan1327_done
  rxscan1327_scan:
    set_addr $I10, rxscan1327_loop
    rx1323_cur."!mark_push"(0, rx1323_pos, $I10)
  rxscan1327_done:
.annotate 'line', 585
  # rx literal  "/"
    add $I11, rx1323_pos, 1
    gt $I11, rx1323_eos, rx1323_fail
    sub $I11, rx1323_pos, rx1323_off
    ord $I11, rx1323_tgt, $I11
    ne $I11, 47, rx1323_fail
    add rx1323_pos, 1
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."newpad"()
    unless $P10, rx1323_fail
    rx1323_pos = $P10."pos"()
.annotate 'line', 587
  # rx reduce name="quote:sym</ />" key="open"
    rx1323_cur."!cursor_pos"(rx1323_pos)
    rx1323_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 588
  # rx subrule "LANG" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1323_pos = $P10."pos"()
.annotate 'line', 589
  # rx literal  "/"
    add $I11, rx1323_pos, 1
    gt $I11, rx1323_eos, rx1323_fail
    sub $I11, rx1323_pos, rx1323_off
    ord $I11, rx1323_tgt, $I11
    ne $I11, 47, rx1323_fail
    add rx1323_pos, 1
.annotate 'line', 584
  # rx pass
    rx1323_cur."!cursor_pass"(rx1323_pos, "quote:sym</ />")
    if_null rx1323_debug, debug_1141
    rx1323_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1323_pos)
  debug_1141:
    .return (rx1323_cur)
  rx1323_restart:
.annotate 'line', 10
    if_null rx1323_debug, debug_1142
    rx1323_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1142:
  rx1323_fail:
    (rx1323_rep, rx1323_pos, $I10, $P10) = rx1323_cur."!mark_fail"(0)
    lt rx1323_pos, -1, rx1323_done
    eq rx1323_pos, -1, rx1323_fail
    jump $I10
  rx1323_done:
    rx1323_cur."!cursor_fail"()
    if_null rx1323_debug, debug_1143
    rx1323_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1143:
    .return (rx1323_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303576195.699") :method
.annotate 'line', 10
    $P1325 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1326, "ResizablePMCArray"
    push $P1326, $P1325
    .return ($P1326)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1329_tgt
    .local int rx1329_pos
    .local int rx1329_off
    .local int rx1329_eos
    .local int rx1329_rep
    .local pmc rx1329_cur
    .local pmc rx1329_debug
    (rx1329_cur, rx1329_pos, rx1329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1329_cur
    .local pmc match
    .lex "$/", match
    length rx1329_eos, rx1329_tgt
    gt rx1329_pos, rx1329_eos, rx1329_done
    set rx1329_off, 0
    lt rx1329_pos, 2, rx1329_start
    sub rx1329_off, rx1329_pos, 1
    substr rx1329_tgt, rx1329_tgt, rx1329_off
  rx1329_start:
    eq $I10, 1, rx1329_restart
    if_null rx1329_debug, debug_1144
    rx1329_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1144:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1329_pos) = rx1329_cur."from"()
    inc rx1329_pos
    rx1329_cur."!cursor_from"(rx1329_pos)
    ge rx1329_pos, rx1329_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  rxscan1332_done:
.annotate 'line', 592
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1329_pos, rx1329_off
    substr $S10, rx1329_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1329_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."quotemod_check"("s")
    unless $P10, rx1329_fail
  # rx subrule "variable" subtype=capture negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."variable"()
    unless $P10, rx1329_fail
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1329_pos = $P10."pos"()
  # rx pass
    rx1329_cur."!cursor_pass"(rx1329_pos, "quote_escape:sym<$>")
    if_null rx1329_debug, debug_1145
    rx1329_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1329_pos)
  debug_1145:
    .return (rx1329_cur)
  rx1329_restart:
.annotate 'line', 10
    if_null rx1329_debug, debug_1146
    rx1329_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1146:
  rx1329_fail:
    (rx1329_rep, rx1329_pos, $I10, $P10) = rx1329_cur."!mark_fail"(0)
    lt rx1329_pos, -1, rx1329_done
    eq rx1329_pos, -1, rx1329_fail
    jump $I10
  rx1329_done:
    rx1329_cur."!cursor_fail"()
    if_null rx1329_debug, debug_1147
    rx1329_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1147:
    .return (rx1329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303576195.699") :method
.annotate 'line', 10
    new $P1331, "ResizablePMCArray"
    push $P1331, "$"
    .return ($P1331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_1148
    rx1334_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1337_done
    goto rxscan1337_scan
  rxscan1337_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1337_done
  rxscan1337_scan:
    set_addr $I10, rxscan1337_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1337_done:
.annotate 'line', 593
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1334_pos, rx1334_off
    substr $S10, rx1334_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1334_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."quotemod_check"("c")
    unless $P10, rx1334_fail
  # rx subrule "block" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."block"()
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "quote_escape:sym<{ }>")
    if_null rx1334_debug, debug_1149
    rx1334_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1334_pos)
  debug_1149:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 10
    if_null rx1334_debug, debug_1150
    rx1334_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1150:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_1151
    rx1334_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1151:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303576195.699") :method
.annotate 'line', 10
    new $P1336, "ResizablePMCArray"
    push $P1336, "{"
    .return ($P1336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1339_tgt
    .local int rx1339_pos
    .local int rx1339_off
    .local int rx1339_eos
    .local int rx1339_rep
    .local pmc rx1339_cur
    .local pmc rx1339_debug
    (rx1339_cur, rx1339_pos, rx1339_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1339_cur
    .local pmc match
    .lex "$/", match
    length rx1339_eos, rx1339_tgt
    gt rx1339_pos, rx1339_eos, rx1339_done
    set rx1339_off, 0
    lt rx1339_pos, 2, rx1339_start
    sub rx1339_off, rx1339_pos, 1
    substr rx1339_tgt, rx1339_tgt, rx1339_off
  rx1339_start:
    eq $I10, 1, rx1339_restart
    if_null rx1339_debug, debug_1152
    rx1339_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1339_pos) = rx1339_cur."from"()
    inc rx1339_pos
    rx1339_cur."!cursor_from"(rx1339_pos)
    ge rx1339_pos, rx1339_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1339_cur."!mark_push"(0, rx1339_pos, $I10)
  rxscan1342_done:
.annotate 'line', 594
  # rx literal  "\\e"
    add $I11, rx1339_pos, 2
    gt $I11, rx1339_eos, rx1339_fail
    sub $I11, rx1339_pos, rx1339_off
    substr $S10, rx1339_tgt, $I11, 2
    ne $S10, "\\e", rx1339_fail
    add rx1339_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1339_cur."!cursor_pos"(rx1339_pos)
    $P10 = rx1339_cur."quotemod_check"("b")
    unless $P10, rx1339_fail
  # rx pass
    rx1339_cur."!cursor_pass"(rx1339_pos, "quote_escape:sym<esc>")
    if_null rx1339_debug, debug_1153
    rx1339_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1339_pos)
  debug_1153:
    .return (rx1339_cur)
  rx1339_restart:
.annotate 'line', 10
    if_null rx1339_debug, debug_1154
    rx1339_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1154:
  rx1339_fail:
    (rx1339_rep, rx1339_pos, $I10, $P10) = rx1339_cur."!mark_fail"(0)
    lt rx1339_pos, -1, rx1339_done
    eq rx1339_pos, -1, rx1339_fail
    jump $I10
  rx1339_done:
    rx1339_cur."!cursor_fail"()
    if_null rx1339_debug, debug_1155
    rx1339_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1155:
    .return (rx1339_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303576195.699") :method
.annotate 'line', 10
    new $P1341, "ResizablePMCArray"
    push $P1341, "\\e"
    .return ($P1341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1344_tgt
    .local int rx1344_pos
    .local int rx1344_off
    .local int rx1344_eos
    .local int rx1344_rep
    .local pmc rx1344_cur
    .local pmc rx1344_debug
    (rx1344_cur, rx1344_pos, rx1344_tgt, $I10) = self."!cursor_start"()
    rx1344_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1344_cur
    .local pmc match
    .lex "$/", match
    length rx1344_eos, rx1344_tgt
    gt rx1344_pos, rx1344_eos, rx1344_done
    set rx1344_off, 0
    lt rx1344_pos, 2, rx1344_start
    sub rx1344_off, rx1344_pos, 1
    substr rx1344_tgt, rx1344_tgt, rx1344_off
  rx1344_start:
    eq $I10, 1, rx1344_restart
    if_null rx1344_debug, debug_1156
    rx1344_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1156:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1348_done
    goto rxscan1348_scan
  rxscan1348_loop:
    (rx1344_pos) = rx1344_cur."from"()
    inc rx1344_pos
    rx1344_cur."!cursor_from"(rx1344_pos)
    ge rx1344_pos, rx1344_eos, rxscan1348_done
  rxscan1348_scan:
    set_addr $I10, rxscan1348_loop
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10)
  rxscan1348_done:
.annotate 'line', 596
  # rx literal  "("
    add $I11, rx1344_pos, 1
    gt $I11, rx1344_eos, rx1344_fail
    sub $I11, rx1344_pos, rx1344_off
    ord $I11, rx1344_tgt, $I11
    ne $I11, 40, rx1344_fail
    add rx1344_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1344_cur."!cursor_pos"(rx1344_pos)
    $P10 = rx1344_cur."ws"()
    unless $P10, rx1344_fail
    rx1344_pos = $P10."pos"()
  # rx rxquantr1349 ** 0..1
    set_addr $I10, rxquantr1349_done
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10)
  rxquantr1349_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1344_cur."!cursor_pos"(rx1344_pos)
    $P10 = rx1344_cur."EXPR"()
    unless $P10, rx1344_fail
    goto rxsubrule1350_pass
  rxsubrule1350_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1344_fail
  rxsubrule1350_pass:
    set_addr $I10, rxsubrule1350_back
    rx1344_cur."!mark_push"(0, rx1344_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1344_pos = $P10."pos"()
    set_addr $I10, rxquantr1349_done
    (rx1344_rep) = rx1344_cur."!mark_commit"($I10)
  rxquantr1349_done:
  # rx literal  ")"
    add $I11, rx1344_pos, 1
    gt $I11, rx1344_eos, rx1344_fail
    sub $I11, rx1344_pos, rx1344_off
    ord $I11, rx1344_tgt, $I11
    ne $I11, 41, rx1344_fail
    add rx1344_pos, 1
  # rx pass
    rx1344_cur."!cursor_pass"(rx1344_pos, "circumfix:sym<( )>")
    if_null rx1344_debug, debug_1157
    rx1344_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1344_pos)
  debug_1157:
    .return (rx1344_cur)
  rx1344_restart:
.annotate 'line', 10
    if_null rx1344_debug, debug_1158
    rx1344_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1158:
  rx1344_fail:
    (rx1344_rep, rx1344_pos, $I10, $P10) = rx1344_cur."!mark_fail"(0)
    lt rx1344_pos, -1, rx1344_done
    eq rx1344_pos, -1, rx1344_fail
    jump $I10
  rx1344_done:
    rx1344_cur."!cursor_fail"()
    if_null rx1344_debug, debug_1159
    rx1344_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1159:
    .return (rx1344_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303576195.699") :method
.annotate 'line', 10
    $P1346 = self."!PREFIX__!subrule"("ws", "(")
    new $P1347, "ResizablePMCArray"
    push $P1347, $P1346
    .return ($P1347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    rx1352_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_1160
    rx1352_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1356_done
    goto rxscan1356_scan
  rxscan1356_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1356_done
  rxscan1356_scan:
    set_addr $I10, rxscan1356_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1356_done:
.annotate 'line', 597
  # rx literal  "["
    add $I11, rx1352_pos, 1
    gt $I11, rx1352_eos, rx1352_fail
    sub $I11, rx1352_pos, rx1352_off
    ord $I11, rx1352_tgt, $I11
    ne $I11, 91, rx1352_fail
    add rx1352_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."ws"()
    unless $P10, rx1352_fail
    rx1352_pos = $P10."pos"()
  # rx rxquantr1357 ** 0..1
    set_addr $I10, rxquantr1357_done
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxquantr1357_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."EXPR"()
    unless $P10, rx1352_fail
    goto rxsubrule1358_pass
  rxsubrule1358_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1352_fail
  rxsubrule1358_pass:
    set_addr $I10, rxsubrule1358_back
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1352_pos = $P10."pos"()
    set_addr $I10, rxquantr1357_done
    (rx1352_rep) = rx1352_cur."!mark_commit"($I10)
  rxquantr1357_done:
  # rx literal  "]"
    add $I11, rx1352_pos, 1
    gt $I11, rx1352_eos, rx1352_fail
    sub $I11, rx1352_pos, rx1352_off
    ord $I11, rx1352_tgt, $I11
    ne $I11, 93, rx1352_fail
    add rx1352_pos, 1
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "circumfix:sym<[ ]>")
    if_null rx1352_debug, debug_1161
    rx1352_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1352_pos)
  debug_1161:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 10
    if_null rx1352_debug, debug_1162
    rx1352_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1162:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_1163
    rx1352_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1163:
    .return (rx1352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303576195.699") :method
.annotate 'line', 10
    $P1354 = self."!PREFIX__!subrule"("ws", "[")
    new $P1355, "ResizablePMCArray"
    push $P1355, $P1354
    .return ($P1355)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1360_tgt
    .local int rx1360_pos
    .local int rx1360_off
    .local int rx1360_eos
    .local int rx1360_rep
    .local pmc rx1360_cur
    .local pmc rx1360_debug
    (rx1360_cur, rx1360_pos, rx1360_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1360_cur
    .local pmc match
    .lex "$/", match
    length rx1360_eos, rx1360_tgt
    gt rx1360_pos, rx1360_eos, rx1360_done
    set rx1360_off, 0
    lt rx1360_pos, 2, rx1360_start
    sub rx1360_off, rx1360_pos, 1
    substr rx1360_tgt, rx1360_tgt, rx1360_off
  rx1360_start:
    eq $I10, 1, rx1360_restart
    if_null rx1360_debug, debug_1164
    rx1360_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1164:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1363_done
    goto rxscan1363_scan
  rxscan1363_loop:
    (rx1360_pos) = rx1360_cur."from"()
    inc rx1360_pos
    rx1360_cur."!cursor_from"(rx1360_pos)
    ge rx1360_pos, rx1360_eos, rxscan1363_done
  rxscan1363_scan:
    set_addr $I10, rxscan1363_loop
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxscan1363_done:
.annotate 'line', 598
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1360_pos, rx1360_off
    substr $S10, rx1360_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1360_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1360_cur."!cursor_pos"(rx1360_pos)
    $P10 = rx1360_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1360_fail
    rx1360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1360_pos = $P10."pos"()
  # rx pass
    rx1360_cur."!cursor_pass"(rx1360_pos, "circumfix:sym<ang>")
    if_null rx1360_debug, debug_1165
    rx1360_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1360_pos)
  debug_1165:
    .return (rx1360_cur)
  rx1360_restart:
.annotate 'line', 10
    if_null rx1360_debug, debug_1166
    rx1360_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1166:
  rx1360_fail:
    (rx1360_rep, rx1360_pos, $I10, $P10) = rx1360_cur."!mark_fail"(0)
    lt rx1360_pos, -1, rx1360_done
    eq rx1360_pos, -1, rx1360_fail
    jump $I10
  rx1360_done:
    rx1360_cur."!cursor_fail"()
    if_null rx1360_debug, debug_1167
    rx1360_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1167:
    .return (rx1360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303576195.699") :method
.annotate 'line', 10
    new $P1362, "ResizablePMCArray"
    push $P1362, "<"
    .return ($P1362)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_1168
    rx1365_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1368_done
    goto rxscan1368_scan
  rxscan1368_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1368_done
  rxscan1368_scan:
    set_addr $I10, rxscan1368_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1368_done:
.annotate 'line', 599
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1365_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1365_pos = $P10."pos"()
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1365_debug, debug_1169
    rx1365_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1365_pos)
  debug_1169:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 10
    if_null rx1365_debug, debug_1170
    rx1365_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1170:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_1171
    rx1365_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1171:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303576195.699") :method
.annotate 'line', 10
    new $P1367, "ResizablePMCArray"
    push $P1367, unicode:"\x{ab}"
    .return ($P1367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_1172
    rx1370_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1373_done
    goto rxscan1373_scan
  rxscan1373_loop:
    (rx1370_pos) = rx1370_cur."from"()
    inc rx1370_pos
    rx1370_cur."!cursor_from"(rx1370_pos)
    ge rx1370_pos, rx1370_eos, rxscan1373_done
  rxscan1373_scan:
    set_addr $I10, rxscan1373_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1373_done:
.annotate 'line', 600
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1370_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."pblock"()
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "circumfix:sym<{ }>")
    if_null rx1370_debug, debug_1173
    rx1370_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1370_pos)
  debug_1173:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 10
    if_null rx1370_debug, debug_1174
    rx1370_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1174:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_1175
    rx1370_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1175:
    .return (rx1370_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303576195.699") :method
.annotate 'line', 10
    new $P1372, "ResizablePMCArray"
    push $P1372, "{"
    .return ($P1372)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_1176
    rx1375_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1176:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 601
  # rx subrule "sigil" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."sigil"()
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1375_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 40, rx1375_fail
    add rx1375_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."semilist"()
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1375_pos = $P10."pos"()
  alt1380_0:
    set_addr $I10, alt1380_1
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  ")"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 41, rx1375_fail
    add rx1375_pos, 1
    goto alt1380_end
  alt1380_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."FAILGOAL"("')'")
    unless $P10, rx1375_fail
    goto rxsubrule1382_pass
  rxsubrule1382_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1375_fail
  rxsubrule1382_pass:
    set_addr $I10, rxsubrule1382_back
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10, $P10)
    rx1375_pos = $P10."pos"()
  alt1380_end:
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "circumfix:sym<sigil>")
    if_null rx1375_debug, debug_1177
    rx1375_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1375_pos)
  debug_1177:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 10
    if_null rx1375_debug, debug_1178
    rx1375_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1178:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1179
    rx1375_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1179:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303576195.699") :method
.annotate 'line', 10
    $P1377 = self."!PREFIX__!subrule"("sigil", "")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1180
    rx1384_cur."!cursor_debug"("START", "semilist")
  debug_1180:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 603
  # rx subrule "ws" subtype=method negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."ws"()
    unless $P10, rx1384_fail
    rx1384_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."statement"()
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1384_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."ws"()
    unless $P10, rx1384_fail
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "semilist")
    if_null rx1384_debug, debug_1181
    rx1384_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1384_pos)
  debug_1181:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 10
    if_null rx1384_debug, debug_1182
    rx1384_cur."!cursor_debug"("NEXT", "semilist")
  debug_1182:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1183
    rx1384_cur."!cursor_debug"("FAIL", "semilist")
  debug_1183:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303576195.699") :method
.annotate 'line', 10
    $P1386 = self."!PREFIX__!subrule"("ws", "")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1392_tgt
    .local int rx1392_pos
    .local int rx1392_off
    .local int rx1392_eos
    .local int rx1392_rep
    .local pmc rx1392_cur
    .local pmc rx1392_debug
    (rx1392_cur, rx1392_pos, rx1392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1392_cur
    .local pmc match
    .lex "$/", match
    length rx1392_eos, rx1392_tgt
    gt rx1392_pos, rx1392_eos, rx1392_done
    set rx1392_off, 0
    lt rx1392_pos, 2, rx1392_start
    sub rx1392_off, rx1392_pos, 1
    substr rx1392_tgt, rx1392_tgt, rx1392_off
  rx1392_start:
    eq $I10, 1, rx1392_restart
    if_null rx1392_debug, debug_1184
    rx1392_cur."!cursor_debug"("START", "infixish")
  debug_1184:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    (rx1392_pos) = rx1392_cur."from"()
    inc rx1392_pos
    rx1392_cur."!cursor_from"(rx1392_pos)
    ge rx1392_pos, rx1392_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  rxscan1395_done:
.annotate 'line', 626
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1392_cur."!cursor_pos"(rx1392_pos)
    $P10 = rx1392_cur."infixstopper"()
    if $P10, rx1392_fail
  # rx subrule "infix" subtype=capture negate=
    rx1392_cur."!cursor_pos"(rx1392_pos)
    $P10 = rx1392_cur."infix"()
    unless $P10, rx1392_fail
    rx1392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1392_pos = $P10."pos"()
  # rx pass
    rx1392_cur."!cursor_pass"(rx1392_pos, "infixish")
    if_null rx1392_debug, debug_1185
    rx1392_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1392_pos)
  debug_1185:
    .return (rx1392_cur)
  rx1392_restart:
.annotate 'line', 10
    if_null rx1392_debug, debug_1186
    rx1392_cur."!cursor_debug"("NEXT", "infixish")
  debug_1186:
  rx1392_fail:
    (rx1392_rep, rx1392_pos, $I10, $P10) = rx1392_cur."!mark_fail"(0)
    lt rx1392_pos, -1, rx1392_done
    eq rx1392_pos, -1, rx1392_fail
    jump $I10
  rx1392_done:
    rx1392_cur."!cursor_fail"()
    if_null rx1392_debug, debug_1187
    rx1392_cur."!cursor_debug"("FAIL", "infixish")
  debug_1187:
    .return (rx1392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303576195.699") :method
.annotate 'line', 10
    new $P1394, "ResizablePMCArray"
    push $P1394, ""
    .return ($P1394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1397_tgt
    .local int rx1397_pos
    .local int rx1397_off
    .local int rx1397_eos
    .local int rx1397_rep
    .local pmc rx1397_cur
    .local pmc rx1397_debug
    (rx1397_cur, rx1397_pos, rx1397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1397_cur
    .local pmc match
    .lex "$/", match
    length rx1397_eos, rx1397_tgt
    gt rx1397_pos, rx1397_eos, rx1397_done
    set rx1397_off, 0
    lt rx1397_pos, 2, rx1397_start
    sub rx1397_off, rx1397_pos, 1
    substr rx1397_tgt, rx1397_tgt, rx1397_off
  rx1397_start:
    eq $I10, 1, rx1397_restart
    if_null rx1397_debug, debug_1188
    rx1397_cur."!cursor_debug"("START", "infixstopper")
  debug_1188:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1400_done
    goto rxscan1400_scan
  rxscan1400_loop:
    (rx1397_pos) = rx1397_cur."from"()
    inc rx1397_pos
    rx1397_cur."!cursor_from"(rx1397_pos)
    ge rx1397_pos, rx1397_eos, rxscan1400_done
  rxscan1400_scan:
    set_addr $I10, rxscan1400_loop
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  rxscan1400_done:
.annotate 'line', 627
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1397_cur."!cursor_pos"(rx1397_pos)
    $P10 = rx1397_cur."lambda"()
    unless $P10, rx1397_fail
  # rx pass
    rx1397_cur."!cursor_pass"(rx1397_pos, "infixstopper")
    if_null rx1397_debug, debug_1189
    rx1397_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1397_pos)
  debug_1189:
    .return (rx1397_cur)
  rx1397_restart:
.annotate 'line', 10
    if_null rx1397_debug, debug_1190
    rx1397_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1190:
  rx1397_fail:
    (rx1397_rep, rx1397_pos, $I10, $P10) = rx1397_cur."!mark_fail"(0)
    lt rx1397_pos, -1, rx1397_done
    eq rx1397_pos, -1, rx1397_fail
    jump $I10
  rx1397_done:
    rx1397_cur."!cursor_fail"()
    if_null rx1397_debug, debug_1191
    rx1397_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1191:
    .return (rx1397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303576195.699") :method
.annotate 'line', 10
    new $P1399, "ResizablePMCArray"
    push $P1399, ""
    .return ($P1399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1402_tgt
    .local int rx1402_pos
    .local int rx1402_off
    .local int rx1402_eos
    .local int rx1402_rep
    .local pmc rx1402_cur
    .local pmc rx1402_debug
    (rx1402_cur, rx1402_pos, rx1402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1402_cur
    .local pmc match
    .lex "$/", match
    length rx1402_eos, rx1402_tgt
    gt rx1402_pos, rx1402_eos, rx1402_done
    set rx1402_off, 0
    lt rx1402_pos, 2, rx1402_start
    sub rx1402_off, rx1402_pos, 1
    substr rx1402_tgt, rx1402_tgt, rx1402_off
  rx1402_start:
    eq $I10, 1, rx1402_restart
    if_null rx1402_debug, debug_1192
    rx1402_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1192:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1406_done
    goto rxscan1406_scan
  rxscan1406_loop:
    (rx1402_pos) = rx1402_cur."from"()
    inc rx1402_pos
    rx1402_cur."!cursor_from"(rx1402_pos)
    ge rx1402_pos, rx1402_eos, rxscan1406_done
  rxscan1406_scan:
    set_addr $I10, rxscan1406_loop
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  rxscan1406_done:
.annotate 'line', 630
  # rx literal  "["
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 91, rx1402_fail
    add rx1402_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."ws"()
    unless $P10, rx1402_fail
    rx1402_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."EXPR"()
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1402_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 93, rx1402_fail
    add rx1402_pos, 1
.annotate 'line', 631
  # rx subrule "O" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."O"("%methodop")
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1402_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1402_cur."!cursor_pass"(rx1402_pos, "postcircumfix:sym<[ ]>")
    if_null rx1402_debug, debug_1193
    rx1402_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1402_pos)
  debug_1193:
    .return (rx1402_cur)
  rx1402_restart:
.annotate 'line', 10
    if_null rx1402_debug, debug_1194
    rx1402_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1194:
  rx1402_fail:
    (rx1402_rep, rx1402_pos, $I10, $P10) = rx1402_cur."!mark_fail"(0)
    lt rx1402_pos, -1, rx1402_done
    eq rx1402_pos, -1, rx1402_fail
    jump $I10
  rx1402_done:
    rx1402_cur."!cursor_fail"()
    if_null rx1402_debug, debug_1195
    rx1402_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1195:
    .return (rx1402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303576195.699") :method
.annotate 'line', 10
    $P1404 = self."!PREFIX__!subrule"("ws", "[")
    new $P1405, "ResizablePMCArray"
    push $P1405, $P1404
    .return ($P1405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1408_tgt
    .local int rx1408_pos
    .local int rx1408_off
    .local int rx1408_eos
    .local int rx1408_rep
    .local pmc rx1408_cur
    .local pmc rx1408_debug
    (rx1408_cur, rx1408_pos, rx1408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1408_cur
    .local pmc match
    .lex "$/", match
    length rx1408_eos, rx1408_tgt
    gt rx1408_pos, rx1408_eos, rx1408_done
    set rx1408_off, 0
    lt rx1408_pos, 2, rx1408_start
    sub rx1408_off, rx1408_pos, 1
    substr rx1408_tgt, rx1408_tgt, rx1408_off
  rx1408_start:
    eq $I10, 1, rx1408_restart
    if_null rx1408_debug, debug_1196
    rx1408_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1196:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1408_pos) = rx1408_cur."from"()
    inc rx1408_pos
    rx1408_cur."!cursor_from"(rx1408_pos)
    ge rx1408_pos, rx1408_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  rxscan1412_done:
.annotate 'line', 635
  # rx literal  "{"
    add $I11, rx1408_pos, 1
    gt $I11, rx1408_eos, rx1408_fail
    sub $I11, rx1408_pos, rx1408_off
    ord $I11, rx1408_tgt, $I11
    ne $I11, 123, rx1408_fail
    add rx1408_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."ws"()
    unless $P10, rx1408_fail
    rx1408_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."EXPR"()
    unless $P10, rx1408_fail
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1408_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1408_pos, 1
    gt $I11, rx1408_eos, rx1408_fail
    sub $I11, rx1408_pos, rx1408_off
    ord $I11, rx1408_tgt, $I11
    ne $I11, 125, rx1408_fail
    add rx1408_pos, 1
.annotate 'line', 636
  # rx subrule "O" subtype=capture negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."O"("%methodop")
    unless $P10, rx1408_fail
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1408_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1408_cur."!cursor_pass"(rx1408_pos, "postcircumfix:sym<{ }>")
    if_null rx1408_debug, debug_1197
    rx1408_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1408_pos)
  debug_1197:
    .return (rx1408_cur)
  rx1408_restart:
.annotate 'line', 10
    if_null rx1408_debug, debug_1198
    rx1408_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1198:
  rx1408_fail:
    (rx1408_rep, rx1408_pos, $I10, $P10) = rx1408_cur."!mark_fail"(0)
    lt rx1408_pos, -1, rx1408_done
    eq rx1408_pos, -1, rx1408_fail
    jump $I10
  rx1408_done:
    rx1408_cur."!cursor_fail"()
    if_null rx1408_debug, debug_1199
    rx1408_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1199:
    .return (rx1408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303576195.699") :method
.annotate 'line', 10
    $P1410 = self."!PREFIX__!subrule"("ws", "{")
    new $P1411, "ResizablePMCArray"
    push $P1411, $P1410
    .return ($P1411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1414_tgt
    .local int rx1414_pos
    .local int rx1414_off
    .local int rx1414_eos
    .local int rx1414_rep
    .local pmc rx1414_cur
    .local pmc rx1414_debug
    (rx1414_cur, rx1414_pos, rx1414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1414_cur
    .local pmc match
    .lex "$/", match
    length rx1414_eos, rx1414_tgt
    gt rx1414_pos, rx1414_eos, rx1414_done
    set rx1414_off, 0
    lt rx1414_pos, 2, rx1414_start
    sub rx1414_off, rx1414_pos, 1
    substr rx1414_tgt, rx1414_tgt, rx1414_off
  rx1414_start:
    eq $I10, 1, rx1414_restart
    if_null rx1414_debug, debug_1200
    rx1414_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1200:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1417_done
    goto rxscan1417_scan
  rxscan1417_loop:
    (rx1414_pos) = rx1414_cur."from"()
    inc rx1414_pos
    rx1414_cur."!cursor_from"(rx1414_pos)
    ge rx1414_pos, rx1414_eos, rxscan1417_done
  rxscan1417_scan:
    set_addr $I10, rxscan1417_loop
    rx1414_cur."!mark_push"(0, rx1414_pos, $I10)
  rxscan1417_done:
.annotate 'line', 640
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1414_pos, rx1414_off
    substr $S10, rx1414_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1414_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1414_cur."!cursor_pos"(rx1414_pos)
    $P10 = rx1414_cur."quote_EXPR"(":q")
    unless $P10, rx1414_fail
    rx1414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1414_pos = $P10."pos"()
.annotate 'line', 641
  # rx subrule "O" subtype=capture negate=
    rx1414_cur."!cursor_pos"(rx1414_pos)
    $P10 = rx1414_cur."O"("%methodop")
    unless $P10, rx1414_fail
    rx1414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1414_pos = $P10."pos"()
.annotate 'line', 639
  # rx pass
    rx1414_cur."!cursor_pass"(rx1414_pos, "postcircumfix:sym<ang>")
    if_null rx1414_debug, debug_1201
    rx1414_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1414_pos)
  debug_1201:
    .return (rx1414_cur)
  rx1414_restart:
.annotate 'line', 10
    if_null rx1414_debug, debug_1202
    rx1414_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1202:
  rx1414_fail:
    (rx1414_rep, rx1414_pos, $I10, $P10) = rx1414_cur."!mark_fail"(0)
    lt rx1414_pos, -1, rx1414_done
    eq rx1414_pos, -1, rx1414_fail
    jump $I10
  rx1414_done:
    rx1414_cur."!cursor_fail"()
    if_null rx1414_debug, debug_1203
    rx1414_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1203:
    .return (rx1414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303576195.699") :method
.annotate 'line', 10
    new $P1416, "ResizablePMCArray"
    push $P1416, "<"
    .return ($P1416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1204
    rx1419_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1204:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    (rx1419_pos) = rx1419_cur."from"()
    inc rx1419_pos
    rx1419_cur."!cursor_from"(rx1419_pos)
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 645
  # rx literal  "("
    add $I11, rx1419_pos, 1
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    ord $I11, rx1419_tgt, $I11
    ne $I11, 40, rx1419_fail
    add rx1419_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."ws"()
    unless $P10, rx1419_fail
    rx1419_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."arglist"()
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1419_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1419_pos, 1
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    ord $I11, rx1419_tgt, $I11
    ne $I11, 41, rx1419_fail
    add rx1419_pos, 1
.annotate 'line', 646
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%methodop")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
.annotate 'line', 644
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "postcircumfix:sym<( )>")
    if_null rx1419_debug, debug_1205
    rx1419_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1419_pos)
  debug_1205:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 10
    if_null rx1419_debug, debug_1206
    rx1419_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1206:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1207
    rx1419_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1207:
    .return (rx1419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303576195.699") :method
.annotate 'line', 10
    $P1421 = self."!PREFIX__!subrule"("ws", "(")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1425_tgt
    .local int rx1425_pos
    .local int rx1425_off
    .local int rx1425_eos
    .local int rx1425_rep
    .local pmc rx1425_cur
    .local pmc rx1425_debug
    (rx1425_cur, rx1425_pos, rx1425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1425_cur
    .local pmc match
    .lex "$/", match
    length rx1425_eos, rx1425_tgt
    gt rx1425_pos, rx1425_eos, rx1425_done
    set rx1425_off, 0
    lt rx1425_pos, 2, rx1425_start
    sub rx1425_off, rx1425_pos, 1
    substr rx1425_tgt, rx1425_tgt, rx1425_off
  rx1425_start:
    eq $I10, 1, rx1425_restart
    if_null rx1425_debug, debug_1208
    rx1425_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1208:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1429_done
    goto rxscan1429_scan
  rxscan1429_loop:
    (rx1425_pos) = rx1425_cur."from"()
    inc rx1425_pos
    rx1425_cur."!cursor_from"(rx1425_pos)
    ge rx1425_pos, rx1425_eos, rxscan1429_done
  rxscan1429_scan:
    set_addr $I10, rxscan1429_loop
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  rxscan1429_done:
.annotate 'line', 649
  # rx subrule "dotty" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."dotty"()
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1425_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."O"("%methodop")
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1425_pos = $P10."pos"()
  # rx pass
    rx1425_cur."!cursor_pass"(rx1425_pos, "postfix:sym<.>")
    if_null rx1425_debug, debug_1209
    rx1425_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1425_pos)
  debug_1209:
    .return (rx1425_cur)
  rx1425_restart:
.annotate 'line', 10
    if_null rx1425_debug, debug_1210
    rx1425_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1210:
  rx1425_fail:
    (rx1425_rep, rx1425_pos, $I10, $P10) = rx1425_cur."!mark_fail"(0)
    lt rx1425_pos, -1, rx1425_done
    eq rx1425_pos, -1, rx1425_fail
    jump $I10
  rx1425_done:
    rx1425_cur."!cursor_fail"()
    if_null rx1425_debug, debug_1211
    rx1425_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1211:
    .return (rx1425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303576195.699") :method
.annotate 'line', 10
    $P1427 = self."!PREFIX__!subrule"("dotty", "")
    new $P1428, "ResizablePMCArray"
    push $P1428, $P1427
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1431_tgt
    .local int rx1431_pos
    .local int rx1431_off
    .local int rx1431_eos
    .local int rx1431_rep
    .local pmc rx1431_cur
    .local pmc rx1431_debug
    (rx1431_cur, rx1431_pos, rx1431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1431_cur
    .local pmc match
    .lex "$/", match
    length rx1431_eos, rx1431_tgt
    gt rx1431_pos, rx1431_eos, rx1431_done
    set rx1431_off, 0
    lt rx1431_pos, 2, rx1431_start
    sub rx1431_off, rx1431_pos, 1
    substr rx1431_tgt, rx1431_tgt, rx1431_off
  rx1431_start:
    eq $I10, 1, rx1431_restart
    if_null rx1431_debug, debug_1212
    rx1431_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1212:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1435_done
    goto rxscan1435_scan
  rxscan1435_loop:
    (rx1431_pos) = rx1431_cur."from"()
    inc rx1431_pos
    rx1431_cur."!cursor_from"(rx1431_pos)
    ge rx1431_pos, rx1431_eos, rxscan1435_done
  rxscan1435_scan:
    set_addr $I10, rxscan1435_loop
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  rxscan1435_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1436_fail
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  # rx literal  "++"
    add $I11, rx1431_pos, 2
    gt $I11, rx1431_eos, rx1431_fail
    sub $I11, rx1431_pos, rx1431_off
    substr $S10, rx1431_tgt, $I11, 2
    ne $S10, "++", rx1431_fail
    add rx1431_pos, 2
    set_addr $I10, rxcap_1436_fail
    ($I12, $I11) = rx1431_cur."!mark_peek"($I10)
    rx1431_cur."!cursor_pos"($I11)
    ($P10) = rx1431_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1431_pos, "")
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1436_done
  rxcap_1436_fail:
    goto rx1431_fail
  rxcap_1436_done:
  # rx subrule "O" subtype=capture negate=
    rx1431_cur."!cursor_pos"(rx1431_pos)
    $P10 = rx1431_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1431_fail
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1431_pos = $P10."pos"()
  # rx pass
    rx1431_cur."!cursor_pass"(rx1431_pos, "prefix:sym<++>")
    if_null rx1431_debug, debug_1213
    rx1431_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1431_pos)
  debug_1213:
    .return (rx1431_cur)
  rx1431_restart:
.annotate 'line', 10
    if_null rx1431_debug, debug_1214
    rx1431_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1214:
  rx1431_fail:
    (rx1431_rep, rx1431_pos, $I10, $P10) = rx1431_cur."!mark_fail"(0)
    lt rx1431_pos, -1, rx1431_done
    eq rx1431_pos, -1, rx1431_fail
    jump $I10
  rx1431_done:
    rx1431_cur."!cursor_fail"()
    if_null rx1431_debug, debug_1215
    rx1431_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1215:
    .return (rx1431_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303576195.699") :method
.annotate 'line', 10
    $P1433 = self."!PREFIX__!subrule"("O", "++")
    new $P1434, "ResizablePMCArray"
    push $P1434, $P1433
    .return ($P1434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1438_tgt
    .local int rx1438_pos
    .local int rx1438_off
    .local int rx1438_eos
    .local int rx1438_rep
    .local pmc rx1438_cur
    .local pmc rx1438_debug
    (rx1438_cur, rx1438_pos, rx1438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1438_cur
    .local pmc match
    .lex "$/", match
    length rx1438_eos, rx1438_tgt
    gt rx1438_pos, rx1438_eos, rx1438_done
    set rx1438_off, 0
    lt rx1438_pos, 2, rx1438_start
    sub rx1438_off, rx1438_pos, 1
    substr rx1438_tgt, rx1438_tgt, rx1438_off
  rx1438_start:
    eq $I10, 1, rx1438_restart
    if_null rx1438_debug, debug_1216
    rx1438_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1216:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1442_done
    goto rxscan1442_scan
  rxscan1442_loop:
    (rx1438_pos) = rx1438_cur."from"()
    inc rx1438_pos
    rx1438_cur."!cursor_from"(rx1438_pos)
    ge rx1438_pos, rx1438_eos, rxscan1442_done
  rxscan1442_scan:
    set_addr $I10, rxscan1442_loop
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  rxscan1442_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1443_fail
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  # rx literal  "--"
    add $I11, rx1438_pos, 2
    gt $I11, rx1438_eos, rx1438_fail
    sub $I11, rx1438_pos, rx1438_off
    substr $S10, rx1438_tgt, $I11, 2
    ne $S10, "--", rx1438_fail
    add rx1438_pos, 2
    set_addr $I10, rxcap_1443_fail
    ($I12, $I11) = rx1438_cur."!mark_peek"($I10)
    rx1438_cur."!cursor_pos"($I11)
    ($P10) = rx1438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1438_pos, "")
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1443_done
  rxcap_1443_fail:
    goto rx1438_fail
  rxcap_1443_done:
  # rx subrule "O" subtype=capture negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1438_fail
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1438_pos = $P10."pos"()
  # rx pass
    rx1438_cur."!cursor_pass"(rx1438_pos, "prefix:sym<-->")
    if_null rx1438_debug, debug_1217
    rx1438_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1438_pos)
  debug_1217:
    .return (rx1438_cur)
  rx1438_restart:
.annotate 'line', 10
    if_null rx1438_debug, debug_1218
    rx1438_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1218:
  rx1438_fail:
    (rx1438_rep, rx1438_pos, $I10, $P10) = rx1438_cur."!mark_fail"(0)
    lt rx1438_pos, -1, rx1438_done
    eq rx1438_pos, -1, rx1438_fail
    jump $I10
  rx1438_done:
    rx1438_cur."!cursor_fail"()
    if_null rx1438_debug, debug_1219
    rx1438_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1219:
    .return (rx1438_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303576195.699") :method
.annotate 'line', 10
    $P1440 = self."!PREFIX__!subrule"("O", "--")
    new $P1441, "ResizablePMCArray"
    push $P1441, $P1440
    .return ($P1441)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1445_tgt
    .local int rx1445_pos
    .local int rx1445_off
    .local int rx1445_eos
    .local int rx1445_rep
    .local pmc rx1445_cur
    .local pmc rx1445_debug
    (rx1445_cur, rx1445_pos, rx1445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1445_cur
    .local pmc match
    .lex "$/", match
    length rx1445_eos, rx1445_tgt
    gt rx1445_pos, rx1445_eos, rx1445_done
    set rx1445_off, 0
    lt rx1445_pos, 2, rx1445_start
    sub rx1445_off, rx1445_pos, 1
    substr rx1445_tgt, rx1445_tgt, rx1445_off
  rx1445_start:
    eq $I10, 1, rx1445_restart
    if_null rx1445_debug, debug_1220
    rx1445_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1220:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1449_done
    goto rxscan1449_scan
  rxscan1449_loop:
    (rx1445_pos) = rx1445_cur."from"()
    inc rx1445_pos
    rx1445_cur."!cursor_from"(rx1445_pos)
    ge rx1445_pos, rx1445_eos, rxscan1449_done
  rxscan1449_scan:
    set_addr $I10, rxscan1449_loop
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  rxscan1449_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1450_fail
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  # rx literal  "++"
    add $I11, rx1445_pos, 2
    gt $I11, rx1445_eos, rx1445_fail
    sub $I11, rx1445_pos, rx1445_off
    substr $S10, rx1445_tgt, $I11, 2
    ne $S10, "++", rx1445_fail
    add rx1445_pos, 2
    set_addr $I10, rxcap_1450_fail
    ($I12, $I11) = rx1445_cur."!mark_peek"($I10)
    rx1445_cur."!cursor_pos"($I11)
    ($P10) = rx1445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1445_pos, "")
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1450_done
  rxcap_1450_fail:
    goto rx1445_fail
  rxcap_1450_done:
  # rx subrule "O" subtype=capture negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."O"("%autoincrement")
    unless $P10, rx1445_fail
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1445_pos = $P10."pos"()
  # rx pass
    rx1445_cur."!cursor_pass"(rx1445_pos, "postfix:sym<++>")
    if_null rx1445_debug, debug_1221
    rx1445_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1445_pos)
  debug_1221:
    .return (rx1445_cur)
  rx1445_restart:
.annotate 'line', 10
    if_null rx1445_debug, debug_1222
    rx1445_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1222:
  rx1445_fail:
    (rx1445_rep, rx1445_pos, $I10, $P10) = rx1445_cur."!mark_fail"(0)
    lt rx1445_pos, -1, rx1445_done
    eq rx1445_pos, -1, rx1445_fail
    jump $I10
  rx1445_done:
    rx1445_cur."!cursor_fail"()
    if_null rx1445_debug, debug_1223
    rx1445_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1223:
    .return (rx1445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303576195.699") :method
.annotate 'line', 10
    $P1447 = self."!PREFIX__!subrule"("O", "++")
    new $P1448, "ResizablePMCArray"
    push $P1448, $P1447
    .return ($P1448)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1452_tgt
    .local int rx1452_pos
    .local int rx1452_off
    .local int rx1452_eos
    .local int rx1452_rep
    .local pmc rx1452_cur
    .local pmc rx1452_debug
    (rx1452_cur, rx1452_pos, rx1452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1452_cur
    .local pmc match
    .lex "$/", match
    length rx1452_eos, rx1452_tgt
    gt rx1452_pos, rx1452_eos, rx1452_done
    set rx1452_off, 0
    lt rx1452_pos, 2, rx1452_start
    sub rx1452_off, rx1452_pos, 1
    substr rx1452_tgt, rx1452_tgt, rx1452_off
  rx1452_start:
    eq $I10, 1, rx1452_restart
    if_null rx1452_debug, debug_1224
    rx1452_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1224:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1456_done
    goto rxscan1456_scan
  rxscan1456_loop:
    (rx1452_pos) = rx1452_cur."from"()
    inc rx1452_pos
    rx1452_cur."!cursor_from"(rx1452_pos)
    ge rx1452_pos, rx1452_eos, rxscan1456_done
  rxscan1456_scan:
    set_addr $I10, rxscan1456_loop
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  rxscan1456_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1457_fail
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  # rx literal  "--"
    add $I11, rx1452_pos, 2
    gt $I11, rx1452_eos, rx1452_fail
    sub $I11, rx1452_pos, rx1452_off
    substr $S10, rx1452_tgt, $I11, 2
    ne $S10, "--", rx1452_fail
    add rx1452_pos, 2
    set_addr $I10, rxcap_1457_fail
    ($I12, $I11) = rx1452_cur."!mark_peek"($I10)
    rx1452_cur."!cursor_pos"($I11)
    ($P10) = rx1452_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1452_pos, "")
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1457_done
  rxcap_1457_fail:
    goto rx1452_fail
  rxcap_1457_done:
  # rx subrule "O" subtype=capture negate=
    rx1452_cur."!cursor_pos"(rx1452_pos)
    $P10 = rx1452_cur."O"("%autoincrement")
    unless $P10, rx1452_fail
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1452_pos = $P10."pos"()
  # rx pass
    rx1452_cur."!cursor_pass"(rx1452_pos, "postfix:sym<-->")
    if_null rx1452_debug, debug_1225
    rx1452_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1452_pos)
  debug_1225:
    .return (rx1452_cur)
  rx1452_restart:
.annotate 'line', 10
    if_null rx1452_debug, debug_1226
    rx1452_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1226:
  rx1452_fail:
    (rx1452_rep, rx1452_pos, $I10, $P10) = rx1452_cur."!mark_fail"(0)
    lt rx1452_pos, -1, rx1452_done
    eq rx1452_pos, -1, rx1452_fail
    jump $I10
  rx1452_done:
    rx1452_cur."!cursor_fail"()
    if_null rx1452_debug, debug_1227
    rx1452_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1227:
    .return (rx1452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303576195.699") :method
.annotate 'line', 10
    $P1454 = self."!PREFIX__!subrule"("O", "--")
    new $P1455, "ResizablePMCArray"
    push $P1455, $P1454
    .return ($P1455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1459_tgt
    .local int rx1459_pos
    .local int rx1459_off
    .local int rx1459_eos
    .local int rx1459_rep
    .local pmc rx1459_cur
    .local pmc rx1459_debug
    (rx1459_cur, rx1459_pos, rx1459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1459_cur
    .local pmc match
    .lex "$/", match
    length rx1459_eos, rx1459_tgt
    gt rx1459_pos, rx1459_eos, rx1459_done
    set rx1459_off, 0
    lt rx1459_pos, 2, rx1459_start
    sub rx1459_off, rx1459_pos, 1
    substr rx1459_tgt, rx1459_tgt, rx1459_off
  rx1459_start:
    eq $I10, 1, rx1459_restart
    if_null rx1459_debug, debug_1228
    rx1459_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1228:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1463_done
    goto rxscan1463_scan
  rxscan1463_loop:
    (rx1459_pos) = rx1459_cur."from"()
    inc rx1459_pos
    rx1459_cur."!cursor_from"(rx1459_pos)
    ge rx1459_pos, rx1459_eos, rxscan1463_done
  rxscan1463_scan:
    set_addr $I10, rxscan1463_loop
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  rxscan1463_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1464_fail
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  # rx literal  "**"
    add $I11, rx1459_pos, 2
    gt $I11, rx1459_eos, rx1459_fail
    sub $I11, rx1459_pos, rx1459_off
    substr $S10, rx1459_tgt, $I11, 2
    ne $S10, "**", rx1459_fail
    add rx1459_pos, 2
    set_addr $I10, rxcap_1464_fail
    ($I12, $I11) = rx1459_cur."!mark_peek"($I10)
    rx1459_cur."!cursor_pos"($I11)
    ($P10) = rx1459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1459_pos, "")
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1464_done
  rxcap_1464_fail:
    goto rx1459_fail
  rxcap_1464_done:
  # rx subrule "O" subtype=capture negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1459_fail
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1459_pos = $P10."pos"()
  # rx pass
    rx1459_cur."!cursor_pass"(rx1459_pos, "infix:sym<**>")
    if_null rx1459_debug, debug_1229
    rx1459_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1459_pos)
  debug_1229:
    .return (rx1459_cur)
  rx1459_restart:
.annotate 'line', 10
    if_null rx1459_debug, debug_1230
    rx1459_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1230:
  rx1459_fail:
    (rx1459_rep, rx1459_pos, $I10, $P10) = rx1459_cur."!mark_fail"(0)
    lt rx1459_pos, -1, rx1459_done
    eq rx1459_pos, -1, rx1459_fail
    jump $I10
  rx1459_done:
    rx1459_cur."!cursor_fail"()
    if_null rx1459_debug, debug_1231
    rx1459_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1231:
    .return (rx1459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303576195.699") :method
.annotate 'line', 10
    $P1461 = self."!PREFIX__!subrule"("O", "**")
    new $P1462, "ResizablePMCArray"
    push $P1462, $P1461
    .return ($P1462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1232
    rx1466_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1232:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1466_pos) = rx1466_cur."from"()
    inc rx1466_pos
    rx1466_cur."!cursor_from"(rx1466_pos)
    ge rx1466_pos, rx1466_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1470_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1471_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "+"
    add $I11, rx1466_pos, 1
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    ord $I11, rx1466_tgt, $I11
    ne $I11, 43, rx1466_fail
    add rx1466_pos, 1
    set_addr $I10, rxcap_1471_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1471_done
  rxcap_1471_fail:
    goto rx1466_fail
  rxcap_1471_done:
  # rx subrule "O" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1466_pos = $P10."pos"()
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "prefix:sym<+>")
    if_null rx1466_debug, debug_1233
    rx1466_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1466_pos)
  debug_1233:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 10
    if_null rx1466_debug, debug_1234
    rx1466_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1234:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1235
    rx1466_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1235:
    .return (rx1466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303576195.699") :method
.annotate 'line', 10
    $P1468 = self."!PREFIX__!subrule"("O", "+")
    new $P1469, "ResizablePMCArray"
    push $P1469, $P1468
    .return ($P1469)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1473_tgt
    .local int rx1473_pos
    .local int rx1473_off
    .local int rx1473_eos
    .local int rx1473_rep
    .local pmc rx1473_cur
    .local pmc rx1473_debug
    (rx1473_cur, rx1473_pos, rx1473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1473_cur
    .local pmc match
    .lex "$/", match
    length rx1473_eos, rx1473_tgt
    gt rx1473_pos, rx1473_eos, rx1473_done
    set rx1473_off, 0
    lt rx1473_pos, 2, rx1473_start
    sub rx1473_off, rx1473_pos, 1
    substr rx1473_tgt, rx1473_tgt, rx1473_off
  rx1473_start:
    eq $I10, 1, rx1473_restart
    if_null rx1473_debug, debug_1236
    rx1473_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1236:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1477_done
    goto rxscan1477_scan
  rxscan1477_loop:
    (rx1473_pos) = rx1473_cur."from"()
    inc rx1473_pos
    rx1473_cur."!cursor_from"(rx1473_pos)
    ge rx1473_pos, rx1473_eos, rxscan1477_done
  rxscan1477_scan:
    set_addr $I10, rxscan1477_loop
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  rxscan1477_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1478_fail
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  # rx literal  "~"
    add $I11, rx1473_pos, 1
    gt $I11, rx1473_eos, rx1473_fail
    sub $I11, rx1473_pos, rx1473_off
    ord $I11, rx1473_tgt, $I11
    ne $I11, 126, rx1473_fail
    add rx1473_pos, 1
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1473_cur."!mark_peek"($I10)
    rx1473_cur."!cursor_pos"($I11)
    ($P10) = rx1473_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1473_pos, "")
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1473_fail
  rxcap_1478_done:
  # rx subrule "O" subtype=capture negate=
    rx1473_cur."!cursor_pos"(rx1473_pos)
    $P10 = rx1473_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1473_fail
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1473_pos = $P10."pos"()
  # rx pass
    rx1473_cur."!cursor_pass"(rx1473_pos, "prefix:sym<~>")
    if_null rx1473_debug, debug_1237
    rx1473_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1473_pos)
  debug_1237:
    .return (rx1473_cur)
  rx1473_restart:
.annotate 'line', 10
    if_null rx1473_debug, debug_1238
    rx1473_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1238:
  rx1473_fail:
    (rx1473_rep, rx1473_pos, $I10, $P10) = rx1473_cur."!mark_fail"(0)
    lt rx1473_pos, -1, rx1473_done
    eq rx1473_pos, -1, rx1473_fail
    jump $I10
  rx1473_done:
    rx1473_cur."!cursor_fail"()
    if_null rx1473_debug, debug_1239
    rx1473_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1239:
    .return (rx1473_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303576195.699") :method
.annotate 'line', 10
    $P1475 = self."!PREFIX__!subrule"("O", "~")
    new $P1476, "ResizablePMCArray"
    push $P1476, $P1475
    .return ($P1476)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1480_tgt
    .local int rx1480_pos
    .local int rx1480_off
    .local int rx1480_eos
    .local int rx1480_rep
    .local pmc rx1480_cur
    .local pmc rx1480_debug
    (rx1480_cur, rx1480_pos, rx1480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1480_cur
    .local pmc match
    .lex "$/", match
    length rx1480_eos, rx1480_tgt
    gt rx1480_pos, rx1480_eos, rx1480_done
    set rx1480_off, 0
    lt rx1480_pos, 2, rx1480_start
    sub rx1480_off, rx1480_pos, 1
    substr rx1480_tgt, rx1480_tgt, rx1480_off
  rx1480_start:
    eq $I10, 1, rx1480_restart
    if_null rx1480_debug, debug_1240
    rx1480_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1240:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1483_done
    goto rxscan1483_scan
  rxscan1483_loop:
    (rx1480_pos) = rx1480_cur."from"()
    inc rx1480_pos
    rx1480_cur."!cursor_from"(rx1480_pos)
    ge rx1480_pos, rx1480_eos, rxscan1483_done
  rxscan1483_scan:
    set_addr $I10, rxscan1483_loop
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  rxscan1483_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1484_fail
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  # rx literal  "-"
    add $I11, rx1480_pos, 1
    gt $I11, rx1480_eos, rx1480_fail
    sub $I11, rx1480_pos, rx1480_off
    ord $I11, rx1480_tgt, $I11
    ne $I11, 45, rx1480_fail
    add rx1480_pos, 1
    set_addr $I10, rxcap_1484_fail
    ($I12, $I11) = rx1480_cur."!mark_peek"($I10)
    rx1480_cur."!cursor_pos"($I11)
    ($P10) = rx1480_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1480_pos, "")
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1484_done
  rxcap_1484_fail:
    goto rx1480_fail
  rxcap_1484_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1480_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."number"()
    if $P10, rx1480_fail
  # rx subrule "O" subtype=capture negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1480_fail
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1480_pos = $P10."pos"()
  # rx pass
    rx1480_cur."!cursor_pass"(rx1480_pos, "prefix:sym<->")
    if_null rx1480_debug, debug_1241
    rx1480_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1480_pos)
  debug_1241:
    .return (rx1480_cur)
  rx1480_restart:
.annotate 'line', 10
    if_null rx1480_debug, debug_1242
    rx1480_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1242:
  rx1480_fail:
    (rx1480_rep, rx1480_pos, $I10, $P10) = rx1480_cur."!mark_fail"(0)
    lt rx1480_pos, -1, rx1480_done
    eq rx1480_pos, -1, rx1480_fail
    jump $I10
  rx1480_done:
    rx1480_cur."!cursor_fail"()
    if_null rx1480_debug, debug_1243
    rx1480_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1243:
    .return (rx1480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303576195.699") :method
.annotate 'line', 10
    new $P1482, "ResizablePMCArray"
    push $P1482, "-"
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1244
    rx1486_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1244:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1490_done
    goto rxscan1490_scan
  rxscan1490_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1490_done
  rxscan1490_scan:
    set_addr $I10, rxscan1490_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1490_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1491_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "?"
    add $I11, rx1486_pos, 1
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    ord $I11, rx1486_tgt, $I11
    ne $I11, 63, rx1486_fail
    add rx1486_pos, 1
    set_addr $I10, rxcap_1491_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1491_done
  rxcap_1491_fail:
    goto rx1486_fail
  rxcap_1491_done:
  # rx subrule "O" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "prefix:sym<?>")
    if_null rx1486_debug, debug_1245
    rx1486_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1486_pos)
  debug_1245:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 10
    if_null rx1486_debug, debug_1246
    rx1486_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1246:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1247
    rx1486_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1247:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303576195.699") :method
.annotate 'line', 10
    $P1488 = self."!PREFIX__!subrule"("O", "?")
    new $P1489, "ResizablePMCArray"
    push $P1489, $P1488
    .return ($P1489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1248
    rx1493_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1248:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1497_done
    goto rxscan1497_scan
  rxscan1497_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1497_done
  rxscan1497_scan:
    set_addr $I10, rxscan1497_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1497_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1498_fail
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  # rx literal  "!"
    add $I11, rx1493_pos, 1
    gt $I11, rx1493_eos, rx1493_fail
    sub $I11, rx1493_pos, rx1493_off
    ord $I11, rx1493_tgt, $I11
    ne $I11, 33, rx1493_fail
    add rx1493_pos, 1
    set_addr $I10, rxcap_1498_fail
    ($I12, $I11) = rx1493_cur."!mark_peek"($I10)
    rx1493_cur."!cursor_pos"($I11)
    ($P10) = rx1493_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1493_pos, "")
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1498_done
  rxcap_1498_fail:
    goto rx1493_fail
  rxcap_1498_done:
  # rx subrule "O" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "prefix:sym<!>")
    if_null rx1493_debug, debug_1249
    rx1493_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1493_pos)
  debug_1249:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1250
    rx1493_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1250:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1251
    rx1493_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1251:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303576195.699") :method
.annotate 'line', 10
    $P1495 = self."!PREFIX__!subrule"("O", "!")
    new $P1496, "ResizablePMCArray"
    push $P1496, $P1495
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1252
    rx1500_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1252:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1504_done
    goto rxscan1504_scan
  rxscan1504_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1504_done
  rxscan1504_scan:
    set_addr $I10, rxscan1504_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1504_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1505_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  "|"
    add $I11, rx1500_pos, 1
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    ord $I11, rx1500_tgt, $I11
    ne $I11, 124, rx1500_fail
    add rx1500_pos, 1
    set_addr $I10, rxcap_1505_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1505_done
  rxcap_1505_fail:
    goto rx1500_fail
  rxcap_1505_done:
  # rx subrule "O" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."O"("%symbolic_unary")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "prefix:sym<|>")
    if_null rx1500_debug, debug_1253
    rx1500_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1500_pos)
  debug_1253:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1254
    rx1500_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1254:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1255
    rx1500_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1255:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303576195.699") :method
.annotate 'line', 10
    $P1502 = self."!PREFIX__!subrule"("O", "|")
    new $P1503, "ResizablePMCArray"
    push $P1503, $P1502
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1256
    rx1507_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1256:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1511_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  # rx literal  "*"
    add $I11, rx1507_pos, 1
    gt $I11, rx1507_eos, rx1507_fail
    sub $I11, rx1507_pos, rx1507_off
    ord $I11, rx1507_tgt, $I11
    ne $I11, 42, rx1507_fail
    add rx1507_pos, 1
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1507_cur."!mark_peek"($I10)
    rx1507_cur."!cursor_pos"($I11)
    ($P10) = rx1507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1507_pos, "")
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1507_fail
  rxcap_1512_done:
  # rx subrule "O" subtype=capture negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1507_fail
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1507_pos = $P10."pos"()
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "infix:sym<*>")
    if_null rx1507_debug, debug_1257
    rx1507_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1507_pos)
  debug_1257:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 10
    if_null rx1507_debug, debug_1258
    rx1507_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1258:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1259
    rx1507_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1259:
    .return (rx1507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303576195.699") :method
.annotate 'line', 10
    $P1509 = self."!PREFIX__!subrule"("O", "*")
    new $P1510, "ResizablePMCArray"
    push $P1510, $P1509
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1260
    rx1514_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1260:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1518_done
    goto rxscan1518_scan
  rxscan1518_loop:
    (rx1514_pos) = rx1514_cur."from"()
    inc rx1514_pos
    rx1514_cur."!cursor_from"(rx1514_pos)
    ge rx1514_pos, rx1514_eos, rxscan1518_done
  rxscan1518_scan:
    set_addr $I10, rxscan1518_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1518_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1519_fail
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  # rx literal  "/"
    add $I11, rx1514_pos, 1
    gt $I11, rx1514_eos, rx1514_fail
    sub $I11, rx1514_pos, rx1514_off
    ord $I11, rx1514_tgt, $I11
    ne $I11, 47, rx1514_fail
    add rx1514_pos, 1
    set_addr $I10, rxcap_1519_fail
    ($I12, $I11) = rx1514_cur."!mark_peek"($I10)
    rx1514_cur."!cursor_pos"($I11)
    ($P10) = rx1514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1514_pos, "")
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1519_done
  rxcap_1519_fail:
    goto rx1514_fail
  rxcap_1519_done:
  # rx subrule "O" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1514_pos = $P10."pos"()
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "infix:sym</>")
    if_null rx1514_debug, debug_1261
    rx1514_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1514_pos)
  debug_1261:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 10
    if_null rx1514_debug, debug_1262
    rx1514_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1262:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1263
    rx1514_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1263:
    .return (rx1514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303576195.699") :method
.annotate 'line', 10
    $P1516 = self."!PREFIX__!subrule"("O", "/")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1264
    rx1521_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1264:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1525_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "%"
    add $I11, rx1521_pos, 1
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    ord $I11, rx1521_tgt, $I11
    ne $I11, 37, rx1521_fail
    add rx1521_pos, 1
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1521_fail
  rxcap_1526_done:
  # rx subrule "O" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "infix:sym<%>")
    if_null rx1521_debug, debug_1265
    rx1521_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1521_pos)
  debug_1265:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 10
    if_null rx1521_debug, debug_1266
    rx1521_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1266:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1267
    rx1521_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1267:
    .return (rx1521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303576195.699") :method
.annotate 'line', 10
    $P1523 = self."!PREFIX__!subrule"("O", "%")
    new $P1524, "ResizablePMCArray"
    push $P1524, $P1523
    .return ($P1524)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1268
    rx1528_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1268:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1532_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1533_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1528_pos, 2
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 2
    ne $S10, "+&", rx1528_fail
    add rx1528_pos, 2
    set_addr $I10, rxcap_1533_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1533_done
  rxcap_1533_fail:
    goto rx1528_fail
  rxcap_1533_done:
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "infix:sym<+&>")
    if_null rx1528_debug, debug_1269
    rx1528_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1528_pos)
  debug_1269:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 10
    if_null rx1528_debug, debug_1270
    rx1528_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1270:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1271
    rx1528_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1271:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303576195.699") :method
.annotate 'line', 10
    $P1530 = self."!PREFIX__!subrule"("O", "+&")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1272
    rx1535_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1272:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1539_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1540_fail
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  # rx literal  "+"
    add $I11, rx1535_pos, 1
    gt $I11, rx1535_eos, rx1535_fail
    sub $I11, rx1535_pos, rx1535_off
    ord $I11, rx1535_tgt, $I11
    ne $I11, 43, rx1535_fail
    add rx1535_pos, 1
    set_addr $I10, rxcap_1540_fail
    ($I12, $I11) = rx1535_cur."!mark_peek"($I10)
    rx1535_cur."!cursor_pos"($I11)
    ($P10) = rx1535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1535_pos, "")
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1540_done
  rxcap_1540_fail:
    goto rx1535_fail
  rxcap_1540_done:
  # rx subrule "O" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1535_pos = $P10."pos"()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "infix:sym<+>")
    if_null rx1535_debug, debug_1273
    rx1535_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1535_pos)
  debug_1273:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 10
    if_null rx1535_debug, debug_1274
    rx1535_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1274:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1275
    rx1535_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1275:
    .return (rx1535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303576195.699") :method
.annotate 'line', 10
    $P1537 = self."!PREFIX__!subrule"("O", "+")
    new $P1538, "ResizablePMCArray"
    push $P1538, $P1537
    .return ($P1538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1276
    rx1542_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1276:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1546_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1547_fail
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  # rx literal  "-"
    add $I11, rx1542_pos, 1
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    ord $I11, rx1542_tgt, $I11
    ne $I11, 45, rx1542_fail
    add rx1542_pos, 1
    set_addr $I10, rxcap_1547_fail
    ($I12, $I11) = rx1542_cur."!mark_peek"($I10)
    rx1542_cur."!cursor_pos"($I11)
    ($P10) = rx1542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1542_pos, "")
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1547_done
  rxcap_1547_fail:
    goto rx1542_fail
  rxcap_1547_done:
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "infix:sym<->")
    if_null rx1542_debug, debug_1277
    rx1542_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1542_pos)
  debug_1277:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1278
    rx1542_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1278:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1279
    rx1542_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1279:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303576195.699") :method
.annotate 'line', 10
    $P1544 = self."!PREFIX__!subrule"("O", "-")
    new $P1545, "ResizablePMCArray"
    push $P1545, $P1544
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1280
    rx1549_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1280:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1553_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1554_fail
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1549_pos, 2
    gt $I11, rx1549_eos, rx1549_fail
    sub $I11, rx1549_pos, rx1549_off
    substr $S10, rx1549_tgt, $I11, 2
    ne $S10, "+|", rx1549_fail
    add rx1549_pos, 2
    set_addr $I10, rxcap_1554_fail
    ($I12, $I11) = rx1549_cur."!mark_peek"($I10)
    rx1549_cur."!cursor_pos"($I11)
    ($P10) = rx1549_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1549_pos, "")
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1554_done
  rxcap_1554_fail:
    goto rx1549_fail
  rxcap_1554_done:
  # rx subrule "O" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "infix:sym<+|>")
    if_null rx1549_debug, debug_1281
    rx1549_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1549_pos)
  debug_1281:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 10
    if_null rx1549_debug, debug_1282
    rx1549_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1282:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1283
    rx1549_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1283:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303576195.699") :method
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("O", "+|")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1284
    rx1556_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1284:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1560_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1561_fail
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1556_pos, 2
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 2
    ne $S10, "+^", rx1556_fail
    add rx1556_pos, 2
    set_addr $I10, rxcap_1561_fail
    ($I12, $I11) = rx1556_cur."!mark_peek"($I10)
    rx1556_cur."!cursor_pos"($I11)
    ($P10) = rx1556_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1556_pos, "")
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1561_done
  rxcap_1561_fail:
    goto rx1556_fail
  rxcap_1561_done:
  # rx subrule "O" subtype=capture negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1556_fail
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1556_pos = $P10."pos"()
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infix:sym<+^>")
    if_null rx1556_debug, debug_1285
    rx1556_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1556_pos)
  debug_1285:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1286
    rx1556_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1286:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1287
    rx1556_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1287:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303576195.699") :method
.annotate 'line', 10
    $P1558 = self."!PREFIX__!subrule"("O", "+^")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1288
    rx1563_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1288:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1567_done
    goto rxscan1567_scan
  rxscan1567_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1567_done
  rxscan1567_scan:
    set_addr $I10, rxscan1567_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1567_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1568_fail
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  # rx literal  "~"
    add $I11, rx1563_pos, 1
    gt $I11, rx1563_eos, rx1563_fail
    sub $I11, rx1563_pos, rx1563_off
    ord $I11, rx1563_tgt, $I11
    ne $I11, 126, rx1563_fail
    add rx1563_pos, 1
    set_addr $I10, rxcap_1568_fail
    ($I12, $I11) = rx1563_cur."!mark_peek"($I10)
    rx1563_cur."!cursor_pos"($I11)
    ($P10) = rx1563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1563_pos, "")
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1568_done
  rxcap_1568_fail:
    goto rx1563_fail
  rxcap_1568_done:
  # rx subrule "O" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1563_pos = $P10."pos"()
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "infix:sym<~>")
    if_null rx1563_debug, debug_1289
    rx1563_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1563_pos)
  debug_1289:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 10
    if_null rx1563_debug, debug_1290
    rx1563_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1290:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1291
    rx1563_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1291:
    .return (rx1563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303576195.699") :method
.annotate 'line', 10
    $P1565 = self."!PREFIX__!subrule"("O", "~")
    new $P1566, "ResizablePMCArray"
    push $P1566, $P1565
    .return ($P1566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1292
    rx1570_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1292:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1574_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  # rx literal  "=="
    add $I11, rx1570_pos, 2
    gt $I11, rx1570_eos, rx1570_fail
    sub $I11, rx1570_pos, rx1570_off
    substr $S10, rx1570_tgt, $I11, 2
    ne $S10, "==", rx1570_fail
    add rx1570_pos, 2
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1570_cur."!mark_peek"($I10)
    rx1570_cur."!cursor_pos"($I11)
    ($P10) = rx1570_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1570_pos, "")
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1570_fail
  rxcap_1575_done:
  # rx subrule "O" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "infix:sym<==>")
    if_null rx1570_debug, debug_1293
    rx1570_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1570_pos)
  debug_1293:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 10
    if_null rx1570_debug, debug_1294
    rx1570_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1294:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1295
    rx1570_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1295:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303576195.699") :method
.annotate 'line', 10
    $P1572 = self."!PREFIX__!subrule"("O", "==")
    new $P1573, "ResizablePMCArray"
    push $P1573, $P1572
    .return ($P1573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1296
    rx1577_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1296:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1581_done
    goto rxscan1581_scan
  rxscan1581_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1581_done
  rxscan1581_scan:
    set_addr $I10, rxscan1581_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1581_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1582_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "!="
    add $I11, rx1577_pos, 2
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 2
    ne $S10, "!=", rx1577_fail
    add rx1577_pos, 2
    set_addr $I10, rxcap_1582_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1582_done
  rxcap_1582_fail:
    goto rx1577_fail
  rxcap_1582_done:
  # rx subrule "O" subtype=capture negate=
    rx1577_cur."!cursor_pos"(rx1577_pos)
    $P10 = rx1577_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1577_fail
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1577_pos = $P10."pos"()
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "infix:sym<!=>")
    if_null rx1577_debug, debug_1297
    rx1577_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1577_pos)
  debug_1297:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 10
    if_null rx1577_debug, debug_1298
    rx1577_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1298:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1299
    rx1577_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1299:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303576195.699") :method
.annotate 'line', 10
    $P1579 = self."!PREFIX__!subrule"("O", "!=")
    new $P1580, "ResizablePMCArray"
    push $P1580, $P1579
    .return ($P1580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1300
    rx1584_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1300:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1589_fail
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  # rx literal  "<="
    add $I11, rx1584_pos, 2
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    substr $S10, rx1584_tgt, $I11, 2
    ne $S10, "<=", rx1584_fail
    add rx1584_pos, 2
    set_addr $I10, rxcap_1589_fail
    ($I12, $I11) = rx1584_cur."!mark_peek"($I10)
    rx1584_cur."!cursor_pos"($I11)
    ($P10) = rx1584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1584_pos, "")
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1589_done
  rxcap_1589_fail:
    goto rx1584_fail
  rxcap_1589_done:
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "infix:sym<<=>")
    if_null rx1584_debug, debug_1301
    rx1584_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1584_pos)
  debug_1301:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1302
    rx1584_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1302:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1303
    rx1584_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1303:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303576195.699") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("O", "<=")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1304
    rx1591_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1304:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  ">="
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, ">=", rx1591_fail
    add rx1591_pos, 2
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subrule "O" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "infix:sym<>=>")
    if_null rx1591_debug, debug_1305
    rx1591_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1591_pos)
  debug_1305:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 10
    if_null rx1591_debug, debug_1306
    rx1591_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1306:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1307
    rx1591_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1307:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303576195.699") :method
.annotate 'line', 10
    $P1593 = self."!PREFIX__!subrule"("O", ">=")
    new $P1594, "ResizablePMCArray"
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1308
    rx1598_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1308:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1602_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1603_fail
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  # rx literal  "<"
    add $I11, rx1598_pos, 1
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    ord $I11, rx1598_tgt, $I11
    ne $I11, 60, rx1598_fail
    add rx1598_pos, 1
    set_addr $I10, rxcap_1603_fail
    ($I12, $I11) = rx1598_cur."!mark_peek"($I10)
    rx1598_cur."!cursor_pos"($I11)
    ($P10) = rx1598_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1598_pos, "")
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1603_done
  rxcap_1603_fail:
    goto rx1598_fail
  rxcap_1603_done:
  # rx subrule "O" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1598_pos = $P10."pos"()
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "infix:sym<<>")
    if_null rx1598_debug, debug_1309
    rx1598_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1598_pos)
  debug_1309:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 10
    if_null rx1598_debug, debug_1310
    rx1598_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1310:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1311
    rx1598_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1311:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303576195.699") :method
.annotate 'line', 10
    $P1600 = self."!PREFIX__!subrule"("O", "<")
    new $P1601, "ResizablePMCArray"
    push $P1601, $P1600
    .return ($P1601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1605_tgt
    .local int rx1605_pos
    .local int rx1605_off
    .local int rx1605_eos
    .local int rx1605_rep
    .local pmc rx1605_cur
    .local pmc rx1605_debug
    (rx1605_cur, rx1605_pos, rx1605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1605_cur
    .local pmc match
    .lex "$/", match
    length rx1605_eos, rx1605_tgt
    gt rx1605_pos, rx1605_eos, rx1605_done
    set rx1605_off, 0
    lt rx1605_pos, 2, rx1605_start
    sub rx1605_off, rx1605_pos, 1
    substr rx1605_tgt, rx1605_tgt, rx1605_off
  rx1605_start:
    eq $I10, 1, rx1605_restart
    if_null rx1605_debug, debug_1312
    rx1605_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1312:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1609_done
    goto rxscan1609_scan
  rxscan1609_loop:
    (rx1605_pos) = rx1605_cur."from"()
    inc rx1605_pos
    rx1605_cur."!cursor_from"(rx1605_pos)
    ge rx1605_pos, rx1605_eos, rxscan1609_done
  rxscan1609_scan:
    set_addr $I10, rxscan1609_loop
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  rxscan1609_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1610_fail
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  # rx literal  ">"
    add $I11, rx1605_pos, 1
    gt $I11, rx1605_eos, rx1605_fail
    sub $I11, rx1605_pos, rx1605_off
    ord $I11, rx1605_tgt, $I11
    ne $I11, 62, rx1605_fail
    add rx1605_pos, 1
    set_addr $I10, rxcap_1610_fail
    ($I12, $I11) = rx1605_cur."!mark_peek"($I10)
    rx1605_cur."!cursor_pos"($I11)
    ($P10) = rx1605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1605_pos, "")
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1610_done
  rxcap_1610_fail:
    goto rx1605_fail
  rxcap_1610_done:
  # rx subrule "O" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1605_pos = $P10."pos"()
  # rx pass
    rx1605_cur."!cursor_pass"(rx1605_pos, "infix:sym<>>")
    if_null rx1605_debug, debug_1313
    rx1605_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1605_pos)
  debug_1313:
    .return (rx1605_cur)
  rx1605_restart:
.annotate 'line', 10
    if_null rx1605_debug, debug_1314
    rx1605_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1314:
  rx1605_fail:
    (rx1605_rep, rx1605_pos, $I10, $P10) = rx1605_cur."!mark_fail"(0)
    lt rx1605_pos, -1, rx1605_done
    eq rx1605_pos, -1, rx1605_fail
    jump $I10
  rx1605_done:
    rx1605_cur."!cursor_fail"()
    if_null rx1605_debug, debug_1315
    rx1605_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1315:
    .return (rx1605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303576195.699") :method
.annotate 'line', 10
    $P1607 = self."!PREFIX__!subrule"("O", ">")
    new $P1608, "ResizablePMCArray"
    push $P1608, $P1607
    .return ($P1608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1316
    rx1612_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1316:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1616_done
    goto rxscan1616_scan
  rxscan1616_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1616_done
  rxscan1616_scan:
    set_addr $I10, rxscan1616_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1616_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1617_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1612_pos, 2
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    substr $S10, rx1612_tgt, $I11, 2
    ne $S10, "eq", rx1612_fail
    add rx1612_pos, 2
    set_addr $I10, rxcap_1617_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1617_done
  rxcap_1617_fail:
    goto rx1612_fail
  rxcap_1617_done:
  # rx subrule "O" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1612_pos = $P10."pos"()
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "infix:sym<eq>")
    if_null rx1612_debug, debug_1317
    rx1612_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1612_pos)
  debug_1317:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 10
    if_null rx1612_debug, debug_1318
    rx1612_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1318:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1319
    rx1612_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1319:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303576195.699") :method
.annotate 'line', 10
    $P1614 = self."!PREFIX__!subrule"("O", "eq")
    new $P1615, "ResizablePMCArray"
    push $P1615, $P1614
    .return ($P1615)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1619_tgt
    .local int rx1619_pos
    .local int rx1619_off
    .local int rx1619_eos
    .local int rx1619_rep
    .local pmc rx1619_cur
    .local pmc rx1619_debug
    (rx1619_cur, rx1619_pos, rx1619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1619_cur
    .local pmc match
    .lex "$/", match
    length rx1619_eos, rx1619_tgt
    gt rx1619_pos, rx1619_eos, rx1619_done
    set rx1619_off, 0
    lt rx1619_pos, 2, rx1619_start
    sub rx1619_off, rx1619_pos, 1
    substr rx1619_tgt, rx1619_tgt, rx1619_off
  rx1619_start:
    eq $I10, 1, rx1619_restart
    if_null rx1619_debug, debug_1320
    rx1619_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1320:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1623_done
    goto rxscan1623_scan
  rxscan1623_loop:
    (rx1619_pos) = rx1619_cur."from"()
    inc rx1619_pos
    rx1619_cur."!cursor_from"(rx1619_pos)
    ge rx1619_pos, rx1619_eos, rxscan1623_done
  rxscan1623_scan:
    set_addr $I10, rxscan1623_loop
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  rxscan1623_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1624_fail
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1619_pos, 2
    gt $I11, rx1619_eos, rx1619_fail
    sub $I11, rx1619_pos, rx1619_off
    substr $S10, rx1619_tgt, $I11, 2
    ne $S10, "ne", rx1619_fail
    add rx1619_pos, 2
    set_addr $I10, rxcap_1624_fail
    ($I12, $I11) = rx1619_cur."!mark_peek"($I10)
    rx1619_cur."!cursor_pos"($I11)
    ($P10) = rx1619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1619_pos, "")
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1624_done
  rxcap_1624_fail:
    goto rx1619_fail
  rxcap_1624_done:
  # rx subrule "O" subtype=capture negate=
    rx1619_cur."!cursor_pos"(rx1619_pos)
    $P10 = rx1619_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1619_fail
    rx1619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1619_pos = $P10."pos"()
  # rx pass
    rx1619_cur."!cursor_pass"(rx1619_pos, "infix:sym<ne>")
    if_null rx1619_debug, debug_1321
    rx1619_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1619_pos)
  debug_1321:
    .return (rx1619_cur)
  rx1619_restart:
.annotate 'line', 10
    if_null rx1619_debug, debug_1322
    rx1619_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1322:
  rx1619_fail:
    (rx1619_rep, rx1619_pos, $I10, $P10) = rx1619_cur."!mark_fail"(0)
    lt rx1619_pos, -1, rx1619_done
    eq rx1619_pos, -1, rx1619_fail
    jump $I10
  rx1619_done:
    rx1619_cur."!cursor_fail"()
    if_null rx1619_debug, debug_1323
    rx1619_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1323:
    .return (rx1619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303576195.699") :method
.annotate 'line', 10
    $P1621 = self."!PREFIX__!subrule"("O", "ne")
    new $P1622, "ResizablePMCArray"
    push $P1622, $P1621
    .return ($P1622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1626_tgt
    .local int rx1626_pos
    .local int rx1626_off
    .local int rx1626_eos
    .local int rx1626_rep
    .local pmc rx1626_cur
    .local pmc rx1626_debug
    (rx1626_cur, rx1626_pos, rx1626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1626_cur
    .local pmc match
    .lex "$/", match
    length rx1626_eos, rx1626_tgt
    gt rx1626_pos, rx1626_eos, rx1626_done
    set rx1626_off, 0
    lt rx1626_pos, 2, rx1626_start
    sub rx1626_off, rx1626_pos, 1
    substr rx1626_tgt, rx1626_tgt, rx1626_off
  rx1626_start:
    eq $I10, 1, rx1626_restart
    if_null rx1626_debug, debug_1324
    rx1626_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1324:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1630_done
    goto rxscan1630_scan
  rxscan1630_loop:
    (rx1626_pos) = rx1626_cur."from"()
    inc rx1626_pos
    rx1626_cur."!cursor_from"(rx1626_pos)
    ge rx1626_pos, rx1626_eos, rxscan1630_done
  rxscan1630_scan:
    set_addr $I10, rxscan1630_loop
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  rxscan1630_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1631_fail
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  # rx literal  "le"
    add $I11, rx1626_pos, 2
    gt $I11, rx1626_eos, rx1626_fail
    sub $I11, rx1626_pos, rx1626_off
    substr $S10, rx1626_tgt, $I11, 2
    ne $S10, "le", rx1626_fail
    add rx1626_pos, 2
    set_addr $I10, rxcap_1631_fail
    ($I12, $I11) = rx1626_cur."!mark_peek"($I10)
    rx1626_cur."!cursor_pos"($I11)
    ($P10) = rx1626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1626_pos, "")
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1631_done
  rxcap_1631_fail:
    goto rx1626_fail
  rxcap_1631_done:
  # rx subrule "O" subtype=capture negate=
    rx1626_cur."!cursor_pos"(rx1626_pos)
    $P10 = rx1626_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1626_fail
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1626_pos = $P10."pos"()
  # rx pass
    rx1626_cur."!cursor_pass"(rx1626_pos, "infix:sym<le>")
    if_null rx1626_debug, debug_1325
    rx1626_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1626_pos)
  debug_1325:
    .return (rx1626_cur)
  rx1626_restart:
.annotate 'line', 10
    if_null rx1626_debug, debug_1326
    rx1626_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1326:
  rx1626_fail:
    (rx1626_rep, rx1626_pos, $I10, $P10) = rx1626_cur."!mark_fail"(0)
    lt rx1626_pos, -1, rx1626_done
    eq rx1626_pos, -1, rx1626_fail
    jump $I10
  rx1626_done:
    rx1626_cur."!cursor_fail"()
    if_null rx1626_debug, debug_1327
    rx1626_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1327:
    .return (rx1626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303576195.699") :method
.annotate 'line', 10
    $P1628 = self."!PREFIX__!subrule"("O", "le")
    new $P1629, "ResizablePMCArray"
    push $P1629, $P1628
    .return ($P1629)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1633_tgt
    .local int rx1633_pos
    .local int rx1633_off
    .local int rx1633_eos
    .local int rx1633_rep
    .local pmc rx1633_cur
    .local pmc rx1633_debug
    (rx1633_cur, rx1633_pos, rx1633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1633_cur
    .local pmc match
    .lex "$/", match
    length rx1633_eos, rx1633_tgt
    gt rx1633_pos, rx1633_eos, rx1633_done
    set rx1633_off, 0
    lt rx1633_pos, 2, rx1633_start
    sub rx1633_off, rx1633_pos, 1
    substr rx1633_tgt, rx1633_tgt, rx1633_off
  rx1633_start:
    eq $I10, 1, rx1633_restart
    if_null rx1633_debug, debug_1328
    rx1633_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1328:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1637_done
    goto rxscan1637_scan
  rxscan1637_loop:
    (rx1633_pos) = rx1633_cur."from"()
    inc rx1633_pos
    rx1633_cur."!cursor_from"(rx1633_pos)
    ge rx1633_pos, rx1633_eos, rxscan1637_done
  rxscan1637_scan:
    set_addr $I10, rxscan1637_loop
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  rxscan1637_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1638_fail
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1633_pos, 2
    gt $I11, rx1633_eos, rx1633_fail
    sub $I11, rx1633_pos, rx1633_off
    substr $S10, rx1633_tgt, $I11, 2
    ne $S10, "ge", rx1633_fail
    add rx1633_pos, 2
    set_addr $I10, rxcap_1638_fail
    ($I12, $I11) = rx1633_cur."!mark_peek"($I10)
    rx1633_cur."!cursor_pos"($I11)
    ($P10) = rx1633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1633_pos, "")
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1638_done
  rxcap_1638_fail:
    goto rx1633_fail
  rxcap_1638_done:
  # rx subrule "O" subtype=capture negate=
    rx1633_cur."!cursor_pos"(rx1633_pos)
    $P10 = rx1633_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1633_fail
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1633_pos = $P10."pos"()
  # rx pass
    rx1633_cur."!cursor_pass"(rx1633_pos, "infix:sym<ge>")
    if_null rx1633_debug, debug_1329
    rx1633_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1633_pos)
  debug_1329:
    .return (rx1633_cur)
  rx1633_restart:
.annotate 'line', 10
    if_null rx1633_debug, debug_1330
    rx1633_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1330:
  rx1633_fail:
    (rx1633_rep, rx1633_pos, $I10, $P10) = rx1633_cur."!mark_fail"(0)
    lt rx1633_pos, -1, rx1633_done
    eq rx1633_pos, -1, rx1633_fail
    jump $I10
  rx1633_done:
    rx1633_cur."!cursor_fail"()
    if_null rx1633_debug, debug_1331
    rx1633_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1331:
    .return (rx1633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303576195.699") :method
.annotate 'line', 10
    $P1635 = self."!PREFIX__!subrule"("O", "ge")
    new $P1636, "ResizablePMCArray"
    push $P1636, $P1635
    .return ($P1636)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1332
    rx1640_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1332:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1644_done
    goto rxscan1644_scan
  rxscan1644_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1644_done
  rxscan1644_scan:
    set_addr $I10, rxscan1644_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1644_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1645_fail
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1640_pos, 2
    gt $I11, rx1640_eos, rx1640_fail
    sub $I11, rx1640_pos, rx1640_off
    substr $S10, rx1640_tgt, $I11, 2
    ne $S10, "lt", rx1640_fail
    add rx1640_pos, 2
    set_addr $I10, rxcap_1645_fail
    ($I12, $I11) = rx1640_cur."!mark_peek"($I10)
    rx1640_cur."!cursor_pos"($I11)
    ($P10) = rx1640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1640_pos, "")
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1645_done
  rxcap_1645_fail:
    goto rx1640_fail
  rxcap_1645_done:
  # rx subrule "O" subtype=capture negate=
    rx1640_cur."!cursor_pos"(rx1640_pos)
    $P10 = rx1640_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1640_fail
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1640_pos = $P10."pos"()
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "infix:sym<lt>")
    if_null rx1640_debug, debug_1333
    rx1640_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1640_pos)
  debug_1333:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 10
    if_null rx1640_debug, debug_1334
    rx1640_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1334:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1335
    rx1640_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1335:
    .return (rx1640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303576195.699") :method
.annotate 'line', 10
    $P1642 = self."!PREFIX__!subrule"("O", "lt")
    new $P1643, "ResizablePMCArray"
    push $P1643, $P1642
    .return ($P1643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1336
    rx1647_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1336:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1651_done
    goto rxscan1651_scan
  rxscan1651_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1651_done
  rxscan1651_scan:
    set_addr $I10, rxscan1651_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1651_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1652_fail
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1647_pos, 2
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    substr $S10, rx1647_tgt, $I11, 2
    ne $S10, "gt", rx1647_fail
    add rx1647_pos, 2
    set_addr $I10, rxcap_1652_fail
    ($I12, $I11) = rx1647_cur."!mark_peek"($I10)
    rx1647_cur."!cursor_pos"($I11)
    ($P10) = rx1647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1647_pos, "")
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1652_done
  rxcap_1652_fail:
    goto rx1647_fail
  rxcap_1652_done:
  # rx subrule "O" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1647_pos = $P10."pos"()
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "infix:sym<gt>")
    if_null rx1647_debug, debug_1337
    rx1647_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1647_pos)
  debug_1337:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 10
    if_null rx1647_debug, debug_1338
    rx1647_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1338:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1339
    rx1647_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1339:
    .return (rx1647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303576195.699") :method
.annotate 'line', 10
    $P1649 = self."!PREFIX__!subrule"("O", "gt")
    new $P1650, "ResizablePMCArray"
    push $P1650, $P1649
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1340
    rx1654_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1340:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1658_done
    goto rxscan1658_scan
  rxscan1658_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1658_done
  rxscan1658_scan:
    set_addr $I10, rxscan1658_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1658_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1659_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1654_pos, 3
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    substr $S10, rx1654_tgt, $I11, 3
    ne $S10, "=:=", rx1654_fail
    add rx1654_pos, 3
    set_addr $I10, rxcap_1659_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1659_done
  rxcap_1659_fail:
    goto rx1654_fail
  rxcap_1659_done:
  # rx subrule "O" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1654_pos = $P10."pos"()
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "infix:sym<=:=>")
    if_null rx1654_debug, debug_1341
    rx1654_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1654_pos)
  debug_1341:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 10
    if_null rx1654_debug, debug_1342
    rx1654_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1342:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1343
    rx1654_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1343:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303576195.699") :method
.annotate 'line', 10
    $P1656 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1657, "ResizablePMCArray"
    push $P1657, $P1656
    .return ($P1657)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1661_tgt
    .local int rx1661_pos
    .local int rx1661_off
    .local int rx1661_eos
    .local int rx1661_rep
    .local pmc rx1661_cur
    .local pmc rx1661_debug
    (rx1661_cur, rx1661_pos, rx1661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1661_cur
    .local pmc match
    .lex "$/", match
    length rx1661_eos, rx1661_tgt
    gt rx1661_pos, rx1661_eos, rx1661_done
    set rx1661_off, 0
    lt rx1661_pos, 2, rx1661_start
    sub rx1661_off, rx1661_pos, 1
    substr rx1661_tgt, rx1661_tgt, rx1661_off
  rx1661_start:
    eq $I10, 1, rx1661_restart
    if_null rx1661_debug, debug_1344
    rx1661_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1344:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1665_done
    goto rxscan1665_scan
  rxscan1665_loop:
    (rx1661_pos) = rx1661_cur."from"()
    inc rx1661_pos
    rx1661_cur."!cursor_from"(rx1661_pos)
    ge rx1661_pos, rx1661_eos, rxscan1665_done
  rxscan1665_scan:
    set_addr $I10, rxscan1665_loop
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  rxscan1665_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1666_fail
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1661_pos, 2
    gt $I11, rx1661_eos, rx1661_fail
    sub $I11, rx1661_pos, rx1661_off
    substr $S10, rx1661_tgt, $I11, 2
    ne $S10, "~~", rx1661_fail
    add rx1661_pos, 2
    set_addr $I10, rxcap_1666_fail
    ($I12, $I11) = rx1661_cur."!mark_peek"($I10)
    rx1661_cur."!cursor_pos"($I11)
    ($P10) = rx1661_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1661_pos, "")
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1666_done
  rxcap_1666_fail:
    goto rx1661_fail
  rxcap_1666_done:
  # rx subrule "O" subtype=capture negate=
    rx1661_cur."!cursor_pos"(rx1661_pos)
    $P10 = rx1661_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1661_fail
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1661_pos = $P10."pos"()
  # rx pass
    rx1661_cur."!cursor_pass"(rx1661_pos, "infix:sym<~~>")
    if_null rx1661_debug, debug_1345
    rx1661_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1661_pos)
  debug_1345:
    .return (rx1661_cur)
  rx1661_restart:
.annotate 'line', 10
    if_null rx1661_debug, debug_1346
    rx1661_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1346:
  rx1661_fail:
    (rx1661_rep, rx1661_pos, $I10, $P10) = rx1661_cur."!mark_fail"(0)
    lt rx1661_pos, -1, rx1661_done
    eq rx1661_pos, -1, rx1661_fail
    jump $I10
  rx1661_done:
    rx1661_cur."!cursor_fail"()
    if_null rx1661_debug, debug_1347
    rx1661_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1347:
    .return (rx1661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303576195.699") :method
.annotate 'line', 10
    $P1663 = self."!PREFIX__!subrule"("O", "~~")
    new $P1664, "ResizablePMCArray"
    push $P1664, $P1663
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1668_tgt
    .local int rx1668_pos
    .local int rx1668_off
    .local int rx1668_eos
    .local int rx1668_rep
    .local pmc rx1668_cur
    .local pmc rx1668_debug
    (rx1668_cur, rx1668_pos, rx1668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1668_cur
    .local pmc match
    .lex "$/", match
    length rx1668_eos, rx1668_tgt
    gt rx1668_pos, rx1668_eos, rx1668_done
    set rx1668_off, 0
    lt rx1668_pos, 2, rx1668_start
    sub rx1668_off, rx1668_pos, 1
    substr rx1668_tgt, rx1668_tgt, rx1668_off
  rx1668_start:
    eq $I10, 1, rx1668_restart
    if_null rx1668_debug, debug_1348
    rx1668_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1348:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1672_done
    goto rxscan1672_scan
  rxscan1672_loop:
    (rx1668_pos) = rx1668_cur."from"()
    inc rx1668_pos
    rx1668_cur."!cursor_from"(rx1668_pos)
    ge rx1668_pos, rx1668_eos, rxscan1672_done
  rxscan1672_scan:
    set_addr $I10, rxscan1672_loop
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  rxscan1672_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1673_fail
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1668_pos, 2
    gt $I11, rx1668_eos, rx1668_fail
    sub $I11, rx1668_pos, rx1668_off
    substr $S10, rx1668_tgt, $I11, 2
    ne $S10, "&&", rx1668_fail
    add rx1668_pos, 2
    set_addr $I10, rxcap_1673_fail
    ($I12, $I11) = rx1668_cur."!mark_peek"($I10)
    rx1668_cur."!cursor_pos"($I11)
    ($P10) = rx1668_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1668_pos, "")
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1673_done
  rxcap_1673_fail:
    goto rx1668_fail
  rxcap_1673_done:
  # rx subrule "O" subtype=capture negate=
    rx1668_cur."!cursor_pos"(rx1668_pos)
    $P10 = rx1668_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1668_fail
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1668_pos = $P10."pos"()
  # rx pass
    rx1668_cur."!cursor_pass"(rx1668_pos, "infix:sym<&&>")
    if_null rx1668_debug, debug_1349
    rx1668_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1668_pos)
  debug_1349:
    .return (rx1668_cur)
  rx1668_restart:
.annotate 'line', 10
    if_null rx1668_debug, debug_1350
    rx1668_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1350:
  rx1668_fail:
    (rx1668_rep, rx1668_pos, $I10, $P10) = rx1668_cur."!mark_fail"(0)
    lt rx1668_pos, -1, rx1668_done
    eq rx1668_pos, -1, rx1668_fail
    jump $I10
  rx1668_done:
    rx1668_cur."!cursor_fail"()
    if_null rx1668_debug, debug_1351
    rx1668_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1351:
    .return (rx1668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303576195.699") :method
.annotate 'line', 10
    $P1670 = self."!PREFIX__!subrule"("O", "&&")
    new $P1671, "ResizablePMCArray"
    push $P1671, $P1670
    .return ($P1671)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1675_tgt
    .local int rx1675_pos
    .local int rx1675_off
    .local int rx1675_eos
    .local int rx1675_rep
    .local pmc rx1675_cur
    .local pmc rx1675_debug
    (rx1675_cur, rx1675_pos, rx1675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1675_cur
    .local pmc match
    .lex "$/", match
    length rx1675_eos, rx1675_tgt
    gt rx1675_pos, rx1675_eos, rx1675_done
    set rx1675_off, 0
    lt rx1675_pos, 2, rx1675_start
    sub rx1675_off, rx1675_pos, 1
    substr rx1675_tgt, rx1675_tgt, rx1675_off
  rx1675_start:
    eq $I10, 1, rx1675_restart
    if_null rx1675_debug, debug_1352
    rx1675_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1352:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1679_done
    goto rxscan1679_scan
  rxscan1679_loop:
    (rx1675_pos) = rx1675_cur."from"()
    inc rx1675_pos
    rx1675_cur."!cursor_from"(rx1675_pos)
    ge rx1675_pos, rx1675_eos, rxscan1679_done
  rxscan1679_scan:
    set_addr $I10, rxscan1679_loop
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  rxscan1679_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1680_fail
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  # rx literal  "||"
    add $I11, rx1675_pos, 2
    gt $I11, rx1675_eos, rx1675_fail
    sub $I11, rx1675_pos, rx1675_off
    substr $S10, rx1675_tgt, $I11, 2
    ne $S10, "||", rx1675_fail
    add rx1675_pos, 2
    set_addr $I10, rxcap_1680_fail
    ($I12, $I11) = rx1675_cur."!mark_peek"($I10)
    rx1675_cur."!cursor_pos"($I11)
    ($P10) = rx1675_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1675_pos, "")
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1680_done
  rxcap_1680_fail:
    goto rx1675_fail
  rxcap_1680_done:
  # rx subrule "O" subtype=capture negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1675_fail
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1675_pos = $P10."pos"()
  # rx pass
    rx1675_cur."!cursor_pass"(rx1675_pos, "infix:sym<||>")
    if_null rx1675_debug, debug_1353
    rx1675_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1675_pos)
  debug_1353:
    .return (rx1675_cur)
  rx1675_restart:
.annotate 'line', 10
    if_null rx1675_debug, debug_1354
    rx1675_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1354:
  rx1675_fail:
    (rx1675_rep, rx1675_pos, $I10, $P10) = rx1675_cur."!mark_fail"(0)
    lt rx1675_pos, -1, rx1675_done
    eq rx1675_pos, -1, rx1675_fail
    jump $I10
  rx1675_done:
    rx1675_cur."!cursor_fail"()
    if_null rx1675_debug, debug_1355
    rx1675_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1355:
    .return (rx1675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303576195.699") :method
.annotate 'line', 10
    $P1677 = self."!PREFIX__!subrule"("O", "||")
    new $P1678, "ResizablePMCArray"
    push $P1678, $P1677
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1682_tgt
    .local int rx1682_pos
    .local int rx1682_off
    .local int rx1682_eos
    .local int rx1682_rep
    .local pmc rx1682_cur
    .local pmc rx1682_debug
    (rx1682_cur, rx1682_pos, rx1682_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1682_cur
    .local pmc match
    .lex "$/", match
    length rx1682_eos, rx1682_tgt
    gt rx1682_pos, rx1682_eos, rx1682_done
    set rx1682_off, 0
    lt rx1682_pos, 2, rx1682_start
    sub rx1682_off, rx1682_pos, 1
    substr rx1682_tgt, rx1682_tgt, rx1682_off
  rx1682_start:
    eq $I10, 1, rx1682_restart
    if_null rx1682_debug, debug_1356
    rx1682_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1356:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1686_done
    goto rxscan1686_scan
  rxscan1686_loop:
    (rx1682_pos) = rx1682_cur."from"()
    inc rx1682_pos
    rx1682_cur."!cursor_from"(rx1682_pos)
    ge rx1682_pos, rx1682_eos, rxscan1686_done
  rxscan1686_scan:
    set_addr $I10, rxscan1686_loop
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxscan1686_done:
.annotate 'line', 697
  # rx subcapture "sym"
    set_addr $I10, rxcap_1687_fail
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  # rx literal  "//"
    add $I11, rx1682_pos, 2
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 2
    ne $S10, "//", rx1682_fail
    add rx1682_pos, 2
    set_addr $I10, rxcap_1687_fail
    ($I12, $I11) = rx1682_cur."!mark_peek"($I10)
    rx1682_cur."!cursor_pos"($I11)
    ($P10) = rx1682_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1682_pos, "")
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1687_done
  rxcap_1687_fail:
    goto rx1682_fail
  rxcap_1687_done:
  # rx subrule "O" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1682_pos = $P10."pos"()
  # rx pass
    rx1682_cur."!cursor_pass"(rx1682_pos, "infix:sym<//>")
    if_null rx1682_debug, debug_1357
    rx1682_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1682_pos)
  debug_1357:
    .return (rx1682_cur)
  rx1682_restart:
.annotate 'line', 10
    if_null rx1682_debug, debug_1358
    rx1682_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1358:
  rx1682_fail:
    (rx1682_rep, rx1682_pos, $I10, $P10) = rx1682_cur."!mark_fail"(0)
    lt rx1682_pos, -1, rx1682_done
    eq rx1682_pos, -1, rx1682_fail
    jump $I10
  rx1682_done:
    rx1682_cur."!cursor_fail"()
    if_null rx1682_debug, debug_1359
    rx1682_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1359:
    .return (rx1682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303576195.699") :method
.annotate 'line', 10
    $P1684 = self."!PREFIX__!subrule"("O", "//")
    new $P1685, "ResizablePMCArray"
    push $P1685, $P1684
    .return ($P1685)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1689_tgt
    .local int rx1689_pos
    .local int rx1689_off
    .local int rx1689_eos
    .local int rx1689_rep
    .local pmc rx1689_cur
    .local pmc rx1689_debug
    (rx1689_cur, rx1689_pos, rx1689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1689_cur
    .local pmc match
    .lex "$/", match
    length rx1689_eos, rx1689_tgt
    gt rx1689_pos, rx1689_eos, rx1689_done
    set rx1689_off, 0
    lt rx1689_pos, 2, rx1689_start
    sub rx1689_off, rx1689_pos, 1
    substr rx1689_tgt, rx1689_tgt, rx1689_off
  rx1689_start:
    eq $I10, 1, rx1689_restart
    if_null rx1689_debug, debug_1360
    rx1689_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1360:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1693_done
    goto rxscan1693_scan
  rxscan1693_loop:
    (rx1689_pos) = rx1689_cur."from"()
    inc rx1689_pos
    rx1689_cur."!cursor_from"(rx1689_pos)
    ge rx1689_pos, rx1689_eos, rxscan1693_done
  rxscan1693_scan:
    set_addr $I10, rxscan1693_loop
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  rxscan1693_done:
.annotate 'line', 700
  # rx literal  "??"
    add $I11, rx1689_pos, 2
    gt $I11, rx1689_eos, rx1689_fail
    sub $I11, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I11, 2
    ne $S10, "??", rx1689_fail
    add rx1689_pos, 2
.annotate 'line', 701
  # rx subrule "ws" subtype=method negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."ws"()
    unless $P10, rx1689_fail
    rx1689_pos = $P10."pos"()
.annotate 'line', 702
  # rx subrule "EXPR" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."EXPR"("i=")
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1689_pos = $P10."pos"()
.annotate 'line', 703
  # rx literal  "!!"
    add $I11, rx1689_pos, 2
    gt $I11, rx1689_eos, rx1689_fail
    sub $I11, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I11, 2
    ne $S10, "!!", rx1689_fail
    add rx1689_pos, 2
.annotate 'line', 704
  # rx subrule "O" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1689_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1689_cur."!cursor_pass"(rx1689_pos, "infix:sym<?? !!>")
    if_null rx1689_debug, debug_1361
    rx1689_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1689_pos)
  debug_1361:
    .return (rx1689_cur)
  rx1689_restart:
.annotate 'line', 10
    if_null rx1689_debug, debug_1362
    rx1689_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1362:
  rx1689_fail:
    (rx1689_rep, rx1689_pos, $I10, $P10) = rx1689_cur."!mark_fail"(0)
    lt rx1689_pos, -1, rx1689_done
    eq rx1689_pos, -1, rx1689_fail
    jump $I10
  rx1689_done:
    rx1689_cur."!cursor_fail"()
    if_null rx1689_debug, debug_1363
    rx1689_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1363:
    .return (rx1689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303576195.699") :method
.annotate 'line', 10
    $P1691 = self."!PREFIX__!subrule"("ws", "??")
    new $P1692, "ResizablePMCArray"
    push $P1692, $P1691
    .return ($P1692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1695_tgt
    .local int rx1695_pos
    .local int rx1695_off
    .local int rx1695_eos
    .local int rx1695_rep
    .local pmc rx1695_cur
    .local pmc rx1695_debug
    (rx1695_cur, rx1695_pos, rx1695_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1695_cur
    .local pmc match
    .lex "$/", match
    length rx1695_eos, rx1695_tgt
    gt rx1695_pos, rx1695_eos, rx1695_done
    set rx1695_off, 0
    lt rx1695_pos, 2, rx1695_start
    sub rx1695_off, rx1695_pos, 1
    substr rx1695_tgt, rx1695_tgt, rx1695_off
  rx1695_start:
    eq $I10, 1, rx1695_restart
    if_null rx1695_debug, debug_1364
    rx1695_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1364:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1699_done
    goto rxscan1699_scan
  rxscan1699_loop:
    (rx1695_pos) = rx1695_cur."from"()
    inc rx1695_pos
    rx1695_cur."!cursor_from"(rx1695_pos)
    ge rx1695_pos, rx1695_eos, rxscan1699_done
  rxscan1699_scan:
    set_addr $I10, rxscan1699_loop
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
  rxscan1699_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1700_fail
    rx1695_cur."!mark_push"(0, rx1695_pos, $I10)
  # rx literal  "="
    add $I11, rx1695_pos, 1
    gt $I11, rx1695_eos, rx1695_fail
    sub $I11, rx1695_pos, rx1695_off
    ord $I11, rx1695_tgt, $I11
    ne $I11, 61, rx1695_fail
    add rx1695_pos, 1
    set_addr $I10, rxcap_1700_fail
    ($I12, $I11) = rx1695_cur."!mark_peek"($I10)
    rx1695_cur."!cursor_pos"($I11)
    ($P10) = rx1695_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1695_pos, "")
    rx1695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1700_done
  rxcap_1700_fail:
    goto rx1695_fail
  rxcap_1700_done:
  # rx subrule "panic" subtype=method negate=
    rx1695_cur."!cursor_pos"(rx1695_pos)
    $P10 = rx1695_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1695_fail
    rx1695_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx1695_cur."!cursor_pass"(rx1695_pos, "infix:sym<=>")
    if_null rx1695_debug, debug_1365
    rx1695_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1695_pos)
  debug_1365:
    .return (rx1695_cur)
  rx1695_restart:
.annotate 'line', 10
    if_null rx1695_debug, debug_1366
    rx1695_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1366:
  rx1695_fail:
    (rx1695_rep, rx1695_pos, $I10, $P10) = rx1695_cur."!mark_fail"(0)
    lt rx1695_pos, -1, rx1695_done
    eq rx1695_pos, -1, rx1695_fail
    jump $I10
  rx1695_done:
    rx1695_cur."!cursor_fail"()
    if_null rx1695_debug, debug_1367
    rx1695_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1367:
    .return (rx1695_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303576195.699") :method
.annotate 'line', 10
    $P1697 = self."!PREFIX__!subrule"("panic", "=")
    new $P1698, "ResizablePMCArray"
    push $P1698, $P1697
    .return ($P1698)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1702_tgt
    .local int rx1702_pos
    .local int rx1702_off
    .local int rx1702_eos
    .local int rx1702_rep
    .local pmc rx1702_cur
    .local pmc rx1702_debug
    (rx1702_cur, rx1702_pos, rx1702_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1702_cur
    .local pmc match
    .lex "$/", match
    length rx1702_eos, rx1702_tgt
    gt rx1702_pos, rx1702_eos, rx1702_done
    set rx1702_off, 0
    lt rx1702_pos, 2, rx1702_start
    sub rx1702_off, rx1702_pos, 1
    substr rx1702_tgt, rx1702_tgt, rx1702_off
  rx1702_start:
    eq $I10, 1, rx1702_restart
    if_null rx1702_debug, debug_1368
    rx1702_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1368:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1706_done
    goto rxscan1706_scan
  rxscan1706_loop:
    (rx1702_pos) = rx1702_cur."from"()
    inc rx1702_pos
    rx1702_cur."!cursor_from"(rx1702_pos)
    ge rx1702_pos, rx1702_eos, rxscan1706_done
  rxscan1706_scan:
    set_addr $I10, rxscan1706_loop
    rx1702_cur."!mark_push"(0, rx1702_pos, $I10)
  rxscan1706_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1707_fail
    rx1702_cur."!mark_push"(0, rx1702_pos, $I10)
  # rx literal  ":="
    add $I11, rx1702_pos, 2
    gt $I11, rx1702_eos, rx1702_fail
    sub $I11, rx1702_pos, rx1702_off
    substr $S10, rx1702_tgt, $I11, 2
    ne $S10, ":=", rx1702_fail
    add rx1702_pos, 2
    set_addr $I10, rxcap_1707_fail
    ($I12, $I11) = rx1702_cur."!mark_peek"($I10)
    rx1702_cur."!cursor_pos"($I11)
    ($P10) = rx1702_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1702_pos, "")
    rx1702_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1707_done
  rxcap_1707_fail:
    goto rx1702_fail
  rxcap_1707_done:
  # rx subrule "O" subtype=capture negate=
    rx1702_cur."!cursor_pos"(rx1702_pos)
    $P10 = rx1702_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1702_fail
    rx1702_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1702_pos = $P10."pos"()
  # rx pass
    rx1702_cur."!cursor_pass"(rx1702_pos, "infix:sym<:=>")
    if_null rx1702_debug, debug_1369
    rx1702_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1702_pos)
  debug_1369:
    .return (rx1702_cur)
  rx1702_restart:
.annotate 'line', 10
    if_null rx1702_debug, debug_1370
    rx1702_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1370:
  rx1702_fail:
    (rx1702_rep, rx1702_pos, $I10, $P10) = rx1702_cur."!mark_fail"(0)
    lt rx1702_pos, -1, rx1702_done
    eq rx1702_pos, -1, rx1702_fail
    jump $I10
  rx1702_done:
    rx1702_cur."!cursor_fail"()
    if_null rx1702_debug, debug_1371
    rx1702_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1371:
    .return (rx1702_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303576195.699") :method
.annotate 'line', 10
    $P1704 = self."!PREFIX__!subrule"("O", ":=")
    new $P1705, "ResizablePMCArray"
    push $P1705, $P1704
    .return ($P1705)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1709_tgt
    .local int rx1709_pos
    .local int rx1709_off
    .local int rx1709_eos
    .local int rx1709_rep
    .local pmc rx1709_cur
    .local pmc rx1709_debug
    (rx1709_cur, rx1709_pos, rx1709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1709_cur
    .local pmc match
    .lex "$/", match
    length rx1709_eos, rx1709_tgt
    gt rx1709_pos, rx1709_eos, rx1709_done
    set rx1709_off, 0
    lt rx1709_pos, 2, rx1709_start
    sub rx1709_off, rx1709_pos, 1
    substr rx1709_tgt, rx1709_tgt, rx1709_off
  rx1709_start:
    eq $I10, 1, rx1709_restart
    if_null rx1709_debug, debug_1372
    rx1709_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1372:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1713_done
    goto rxscan1713_scan
  rxscan1713_loop:
    (rx1709_pos) = rx1709_cur."from"()
    inc rx1709_pos
    rx1709_cur."!cursor_from"(rx1709_pos)
    ge rx1709_pos, rx1709_eos, rxscan1713_done
  rxscan1713_scan:
    set_addr $I10, rxscan1713_loop
    rx1709_cur."!mark_push"(0, rx1709_pos, $I10)
  rxscan1713_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1714_fail
    rx1709_cur."!mark_push"(0, rx1709_pos, $I10)
  # rx literal  "::="
    add $I11, rx1709_pos, 3
    gt $I11, rx1709_eos, rx1709_fail
    sub $I11, rx1709_pos, rx1709_off
    substr $S10, rx1709_tgt, $I11, 3
    ne $S10, "::=", rx1709_fail
    add rx1709_pos, 3
    set_addr $I10, rxcap_1714_fail
    ($I12, $I11) = rx1709_cur."!mark_peek"($I10)
    rx1709_cur."!cursor_pos"($I11)
    ($P10) = rx1709_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1709_pos, "")
    rx1709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1714_done
  rxcap_1714_fail:
    goto rx1709_fail
  rxcap_1714_done:
  # rx subrule "O" subtype=capture negate=
    rx1709_cur."!cursor_pos"(rx1709_pos)
    $P10 = rx1709_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1709_fail
    rx1709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1709_pos = $P10."pos"()
  # rx pass
    rx1709_cur."!cursor_pass"(rx1709_pos, "infix:sym<::=>")
    if_null rx1709_debug, debug_1373
    rx1709_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1709_pos)
  debug_1373:
    .return (rx1709_cur)
  rx1709_restart:
.annotate 'line', 10
    if_null rx1709_debug, debug_1374
    rx1709_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1374:
  rx1709_fail:
    (rx1709_rep, rx1709_pos, $I10, $P10) = rx1709_cur."!mark_fail"(0)
    lt rx1709_pos, -1, rx1709_done
    eq rx1709_pos, -1, rx1709_fail
    jump $I10
  rx1709_done:
    rx1709_cur."!cursor_fail"()
    if_null rx1709_debug, debug_1375
    rx1709_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1375:
    .return (rx1709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303576195.699") :method
.annotate 'line', 10
    $P1711 = self."!PREFIX__!subrule"("O", "::=")
    new $P1712, "ResizablePMCArray"
    push $P1712, $P1711
    .return ($P1712)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1716_tgt
    .local int rx1716_pos
    .local int rx1716_off
    .local int rx1716_eos
    .local int rx1716_rep
    .local pmc rx1716_cur
    .local pmc rx1716_debug
    (rx1716_cur, rx1716_pos, rx1716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1716_cur
    .local pmc match
    .lex "$/", match
    length rx1716_eos, rx1716_tgt
    gt rx1716_pos, rx1716_eos, rx1716_done
    set rx1716_off, 0
    lt rx1716_pos, 2, rx1716_start
    sub rx1716_off, rx1716_pos, 1
    substr rx1716_tgt, rx1716_tgt, rx1716_off
  rx1716_start:
    eq $I10, 1, rx1716_restart
    if_null rx1716_debug, debug_1376
    rx1716_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1376:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1720_done
    goto rxscan1720_scan
  rxscan1720_loop:
    (rx1716_pos) = rx1716_cur."from"()
    inc rx1716_pos
    rx1716_cur."!cursor_from"(rx1716_pos)
    ge rx1716_pos, rx1716_eos, rxscan1720_done
  rxscan1720_scan:
    set_addr $I10, rxscan1720_loop
    rx1716_cur."!mark_push"(0, rx1716_pos, $I10)
  rxscan1720_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1721_fail
    rx1716_cur."!mark_push"(0, rx1716_pos, $I10)
  # rx literal  ","
    add $I11, rx1716_pos, 1
    gt $I11, rx1716_eos, rx1716_fail
    sub $I11, rx1716_pos, rx1716_off
    ord $I11, rx1716_tgt, $I11
    ne $I11, 44, rx1716_fail
    add rx1716_pos, 1
    set_addr $I10, rxcap_1721_fail
    ($I12, $I11) = rx1716_cur."!mark_peek"($I10)
    rx1716_cur."!cursor_pos"($I11)
    ($P10) = rx1716_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1716_pos, "")
    rx1716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1721_done
  rxcap_1721_fail:
    goto rx1716_fail
  rxcap_1721_done:
  # rx subrule "O" subtype=capture negate=
    rx1716_cur."!cursor_pos"(rx1716_pos)
    $P10 = rx1716_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1716_fail
    rx1716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1716_pos = $P10."pos"()
  # rx pass
    rx1716_cur."!cursor_pass"(rx1716_pos, "infix:sym<,>")
    if_null rx1716_debug, debug_1377
    rx1716_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1716_pos)
  debug_1377:
    .return (rx1716_cur)
  rx1716_restart:
.annotate 'line', 10
    if_null rx1716_debug, debug_1378
    rx1716_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1378:
  rx1716_fail:
    (rx1716_rep, rx1716_pos, $I10, $P10) = rx1716_cur."!mark_fail"(0)
    lt rx1716_pos, -1, rx1716_done
    eq rx1716_pos, -1, rx1716_fail
    jump $I10
  rx1716_done:
    rx1716_cur."!cursor_fail"()
    if_null rx1716_debug, debug_1379
    rx1716_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1379:
    .return (rx1716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303576195.699") :method
.annotate 'line', 10
    $P1718 = self."!PREFIX__!subrule"("O", ",")
    new $P1719, "ResizablePMCArray"
    push $P1719, $P1718
    .return ($P1719)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .const 'Sub' $P1731 = "373_1303576195.699" 
    capture_lex $P1731
    .local string rx1723_tgt
    .local int rx1723_pos
    .local int rx1723_off
    .local int rx1723_eos
    .local int rx1723_rep
    .local pmc rx1723_cur
    .local pmc rx1723_debug
    (rx1723_cur, rx1723_pos, rx1723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1723_cur
    .local pmc match
    .lex "$/", match
    length rx1723_eos, rx1723_tgt
    gt rx1723_pos, rx1723_eos, rx1723_done
    set rx1723_off, 0
    lt rx1723_pos, 2, rx1723_start
    sub rx1723_off, rx1723_pos, 1
    substr rx1723_tgt, rx1723_tgt, rx1723_off
  rx1723_start:
    eq $I10, 1, rx1723_restart
    if_null rx1723_debug, debug_1380
    rx1723_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1380:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1726_done
    goto rxscan1726_scan
  rxscan1726_loop:
    (rx1723_pos) = rx1723_cur."from"()
    inc rx1723_pos
    rx1723_cur."!cursor_from"(rx1723_pos)
    ge rx1723_pos, rx1723_eos, rxscan1726_done
  rxscan1726_scan:
    set_addr $I10, rxscan1726_loop
    rx1723_cur."!mark_push"(0, rx1723_pos, $I10)
  rxscan1726_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1727_fail
    rx1723_cur."!mark_push"(0, rx1723_pos, $I10)
  # rx literal  "return"
    add $I11, rx1723_pos, 6
    gt $I11, rx1723_eos, rx1723_fail
    sub $I11, rx1723_pos, rx1723_off
    substr $S10, rx1723_tgt, $I11, 6
    ne $S10, "return", rx1723_fail
    add rx1723_pos, 6
    set_addr $I10, rxcap_1727_fail
    ($I12, $I11) = rx1723_cur."!mark_peek"($I10)
    rx1723_cur."!cursor_pos"($I11)
    ($P10) = rx1723_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1723_pos, "")
    rx1723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1727_done
  rxcap_1727_fail:
    goto rx1723_fail
  rxcap_1727_done:
  # rx charclass s
    ge rx1723_pos, rx1723_eos, rx1723_fail
    sub $I10, rx1723_pos, rx1723_off
    is_cclass $I11, 32, rx1723_tgt, $I10
    unless $I11, rx1723_fail
    inc rx1723_pos
  # rx subrule "O" subtype=capture negate=
    rx1723_cur."!cursor_pos"(rx1723_pos)
    $P10 = rx1723_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1723_fail
    rx1723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1723_pos = $P10."pos"()
    rx1723_cur."!cursor_pos"(rx1723_pos)
    find_lex $P1728, unicode:"$\x{a2}"
    $P1729 = $P1728."MATCH"()
    store_lex "$/", $P1729
    .const 'Sub' $P1731 = "373_1303576195.699" 
    capture_lex $P1731
    $P1733 = $P1731()
  # rx pass
    rx1723_cur."!cursor_pass"(rx1723_pos, "prefix:sym<return>")
    if_null rx1723_debug, debug_1381
    rx1723_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1723_pos)
  debug_1381:
    .return (rx1723_cur)
  rx1723_restart:
.annotate 'line', 10
    if_null rx1723_debug, debug_1382
    rx1723_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1382:
  rx1723_fail:
    (rx1723_rep, rx1723_pos, $I10, $P10) = rx1723_cur."!mark_fail"(0)
    lt rx1723_pos, -1, rx1723_done
    eq rx1723_pos, -1, rx1723_fail
    jump $I10
  rx1723_done:
    rx1723_cur."!cursor_fail"()
    if_null rx1723_debug, debug_1383
    rx1723_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1383:
    .return (rx1723_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303576195.699") :method
.annotate 'line', 10
    new $P1725, "ResizablePMCArray"
    push $P1725, "return"
    .return ($P1725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1730"  :anon :subid("373_1303576195.699") :outer("371_1303576195.699")
.annotate 'line', 715
    new $P1732, "Integer"
    assign $P1732, 1
    store_dynamic_lex "$*RETURN_USED", $P1732
    .return ($P1732)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1735_tgt
    .local int rx1735_pos
    .local int rx1735_off
    .local int rx1735_eos
    .local int rx1735_rep
    .local pmc rx1735_cur
    .local pmc rx1735_debug
    (rx1735_cur, rx1735_pos, rx1735_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1735_cur
    .local pmc match
    .lex "$/", match
    length rx1735_eos, rx1735_tgt
    gt rx1735_pos, rx1735_eos, rx1735_done
    set rx1735_off, 0
    lt rx1735_pos, 2, rx1735_start
    sub rx1735_off, rx1735_pos, 1
    substr rx1735_tgt, rx1735_tgt, rx1735_off
  rx1735_start:
    eq $I10, 1, rx1735_restart
    if_null rx1735_debug, debug_1384
    rx1735_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1384:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1738_done
    goto rxscan1738_scan
  rxscan1738_loop:
    (rx1735_pos) = rx1735_cur."from"()
    inc rx1735_pos
    rx1735_cur."!cursor_from"(rx1735_pos)
    ge rx1735_pos, rx1735_eos, rxscan1738_done
  rxscan1738_scan:
    set_addr $I10, rxscan1738_loop
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  rxscan1738_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1739_fail
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  # rx literal  "make"
    add $I11, rx1735_pos, 4
    gt $I11, rx1735_eos, rx1735_fail
    sub $I11, rx1735_pos, rx1735_off
    substr $S10, rx1735_tgt, $I11, 4
    ne $S10, "make", rx1735_fail
    add rx1735_pos, 4
    set_addr $I10, rxcap_1739_fail
    ($I12, $I11) = rx1735_cur."!mark_peek"($I10)
    rx1735_cur."!cursor_pos"($I11)
    ($P10) = rx1735_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1735_pos, "")
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1739_done
  rxcap_1739_fail:
    goto rx1735_fail
  rxcap_1739_done:
  # rx charclass s
    ge rx1735_pos, rx1735_eos, rx1735_fail
    sub $I10, rx1735_pos, rx1735_off
    is_cclass $I11, 32, rx1735_tgt, $I10
    unless $I11, rx1735_fail
    inc rx1735_pos
  # rx subrule "O" subtype=capture negate=
    rx1735_cur."!cursor_pos"(rx1735_pos)
    $P10 = rx1735_cur."O"("%list_prefix")
    unless $P10, rx1735_fail
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1735_pos = $P10."pos"()
  # rx pass
    rx1735_cur."!cursor_pass"(rx1735_pos, "prefix:sym<make>")
    if_null rx1735_debug, debug_1385
    rx1735_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1735_pos)
  debug_1385:
    .return (rx1735_cur)
  rx1735_restart:
.annotate 'line', 10
    if_null rx1735_debug, debug_1386
    rx1735_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1386:
  rx1735_fail:
    (rx1735_rep, rx1735_pos, $I10, $P10) = rx1735_cur."!mark_fail"(0)
    lt rx1735_pos, -1, rx1735_done
    eq rx1735_pos, -1, rx1735_fail
    jump $I10
  rx1735_done:
    rx1735_cur."!cursor_fail"()
    if_null rx1735_debug, debug_1387
    rx1735_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1387:
    .return (rx1735_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303576195.699") :method
.annotate 'line', 10
    new $P1737, "ResizablePMCArray"
    push $P1737, "make"
    .return ($P1737)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1741_tgt
    .local int rx1741_pos
    .local int rx1741_off
    .local int rx1741_eos
    .local int rx1741_rep
    .local pmc rx1741_cur
    .local pmc rx1741_debug
    (rx1741_cur, rx1741_pos, rx1741_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1741_cur
    .local pmc match
    .lex "$/", match
    length rx1741_eos, rx1741_tgt
    gt rx1741_pos, rx1741_eos, rx1741_done
    set rx1741_off, 0
    lt rx1741_pos, 2, rx1741_start
    sub rx1741_off, rx1741_pos, 1
    substr rx1741_tgt, rx1741_tgt, rx1741_off
  rx1741_start:
    eq $I10, 1, rx1741_restart
    if_null rx1741_debug, debug_1388
    rx1741_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1388:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1744_done
    goto rxscan1744_scan
  rxscan1744_loop:
    (rx1741_pos) = rx1741_cur."from"()
    inc rx1741_pos
    rx1741_cur."!cursor_from"(rx1741_pos)
    ge rx1741_pos, rx1741_eos, rxscan1744_done
  rxscan1744_scan:
    set_addr $I10, rxscan1744_loop
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  rxscan1744_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1745_fail
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  # rx literal  "last"
    add $I11, rx1741_pos, 4
    gt $I11, rx1741_eos, rx1741_fail
    sub $I11, rx1741_pos, rx1741_off
    substr $S10, rx1741_tgt, $I11, 4
    ne $S10, "last", rx1741_fail
    add rx1741_pos, 4
    set_addr $I10, rxcap_1745_fail
    ($I12, $I11) = rx1741_cur."!mark_peek"($I10)
    rx1741_cur."!cursor_pos"($I11)
    ($P10) = rx1741_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1741_pos, "")
    rx1741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1745_done
  rxcap_1745_fail:
    goto rx1741_fail
  rxcap_1745_done:
  # rx pass
    rx1741_cur."!cursor_pass"(rx1741_pos, "term:sym<last>")
    if_null rx1741_debug, debug_1389
    rx1741_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1741_pos)
  debug_1389:
    .return (rx1741_cur)
  rx1741_restart:
.annotate 'line', 10
    if_null rx1741_debug, debug_1390
    rx1741_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1390:
  rx1741_fail:
    (rx1741_rep, rx1741_pos, $I10, $P10) = rx1741_cur."!mark_fail"(0)
    lt rx1741_pos, -1, rx1741_done
    eq rx1741_pos, -1, rx1741_fail
    jump $I10
  rx1741_done:
    rx1741_cur."!cursor_fail"()
    if_null rx1741_debug, debug_1391
    rx1741_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1391:
    .return (rx1741_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303576195.699") :method
.annotate 'line', 10
    new $P1743, "ResizablePMCArray"
    push $P1743, "last"
    .return ($P1743)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1747_tgt
    .local int rx1747_pos
    .local int rx1747_off
    .local int rx1747_eos
    .local int rx1747_rep
    .local pmc rx1747_cur
    .local pmc rx1747_debug
    (rx1747_cur, rx1747_pos, rx1747_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1747_cur
    .local pmc match
    .lex "$/", match
    length rx1747_eos, rx1747_tgt
    gt rx1747_pos, rx1747_eos, rx1747_done
    set rx1747_off, 0
    lt rx1747_pos, 2, rx1747_start
    sub rx1747_off, rx1747_pos, 1
    substr rx1747_tgt, rx1747_tgt, rx1747_off
  rx1747_start:
    eq $I10, 1, rx1747_restart
    if_null rx1747_debug, debug_1392
    rx1747_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1392:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1750_done
    goto rxscan1750_scan
  rxscan1750_loop:
    (rx1747_pos) = rx1747_cur."from"()
    inc rx1747_pos
    rx1747_cur."!cursor_from"(rx1747_pos)
    ge rx1747_pos, rx1747_eos, rxscan1750_done
  rxscan1750_scan:
    set_addr $I10, rxscan1750_loop
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
  rxscan1750_done:
.annotate 'line', 718
  # rx subcapture "sym"
    set_addr $I10, rxcap_1751_fail
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
  # rx literal  "next"
    add $I11, rx1747_pos, 4
    gt $I11, rx1747_eos, rx1747_fail
    sub $I11, rx1747_pos, rx1747_off
    substr $S10, rx1747_tgt, $I11, 4
    ne $S10, "next", rx1747_fail
    add rx1747_pos, 4
    set_addr $I10, rxcap_1751_fail
    ($I12, $I11) = rx1747_cur."!mark_peek"($I10)
    rx1747_cur."!cursor_pos"($I11)
    ($P10) = rx1747_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1747_pos, "")
    rx1747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1751_done
  rxcap_1751_fail:
    goto rx1747_fail
  rxcap_1751_done:
  # rx pass
    rx1747_cur."!cursor_pass"(rx1747_pos, "term:sym<next>")
    if_null rx1747_debug, debug_1393
    rx1747_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1747_pos)
  debug_1393:
    .return (rx1747_cur)
  rx1747_restart:
.annotate 'line', 10
    if_null rx1747_debug, debug_1394
    rx1747_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1394:
  rx1747_fail:
    (rx1747_rep, rx1747_pos, $I10, $P10) = rx1747_cur."!mark_fail"(0)
    lt rx1747_pos, -1, rx1747_done
    eq rx1747_pos, -1, rx1747_fail
    jump $I10
  rx1747_done:
    rx1747_cur."!cursor_fail"()
    if_null rx1747_debug, debug_1395
    rx1747_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1395:
    .return (rx1747_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303576195.699") :method
.annotate 'line', 10
    new $P1749, "ResizablePMCArray"
    push $P1749, "next"
    .return ($P1749)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303576195.699") :method :outer("12_1303576195.699")
.annotate 'line', 10
    .local string rx1753_tgt
    .local int rx1753_pos
    .local int rx1753_off
    .local int rx1753_eos
    .local int rx1753_rep
    .local pmc rx1753_cur
    .local pmc rx1753_debug
    (rx1753_cur, rx1753_pos, rx1753_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1753_cur
    .local pmc match
    .lex "$/", match
    length rx1753_eos, rx1753_tgt
    gt rx1753_pos, rx1753_eos, rx1753_done
    set rx1753_off, 0
    lt rx1753_pos, 2, rx1753_start
    sub rx1753_off, rx1753_pos, 1
    substr rx1753_tgt, rx1753_tgt, rx1753_off
  rx1753_start:
    eq $I10, 1, rx1753_restart
    if_null rx1753_debug, debug_1396
    rx1753_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1396:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1756_done
    goto rxscan1756_scan
  rxscan1756_loop:
    (rx1753_pos) = rx1753_cur."from"()
    inc rx1753_pos
    rx1753_cur."!cursor_from"(rx1753_pos)
    ge rx1753_pos, rx1753_eos, rxscan1756_done
  rxscan1756_scan:
    set_addr $I10, rxscan1756_loop
    rx1753_cur."!mark_push"(0, rx1753_pos, $I10)
  rxscan1756_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1757_fail
    rx1753_cur."!mark_push"(0, rx1753_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1753_pos, 4
    gt $I11, rx1753_eos, rx1753_fail
    sub $I11, rx1753_pos, rx1753_off
    substr $S10, rx1753_tgt, $I11, 4
    ne $S10, "redo", rx1753_fail
    add rx1753_pos, 4
    set_addr $I10, rxcap_1757_fail
    ($I12, $I11) = rx1753_cur."!mark_peek"($I10)
    rx1753_cur."!cursor_pos"($I11)
    ($P10) = rx1753_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1753_pos, "")
    rx1753_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1757_done
  rxcap_1757_fail:
    goto rx1753_fail
  rxcap_1757_done:
  # rx pass
    rx1753_cur."!cursor_pass"(rx1753_pos, "term:sym<redo>")
    if_null rx1753_debug, debug_1397
    rx1753_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1753_pos)
  debug_1397:
    .return (rx1753_cur)
  rx1753_restart:
.annotate 'line', 10
    if_null rx1753_debug, debug_1398
    rx1753_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1398:
  rx1753_fail:
    (rx1753_rep, rx1753_pos, $I10, $P10) = rx1753_cur."!mark_fail"(0)
    lt rx1753_pos, -1, rx1753_done
    eq rx1753_pos, -1, rx1753_fail
    jump $I10
  rx1753_done:
    rx1753_cur."!cursor_fail"()
    if_null rx1753_debug, debug_1399
    rx1753_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1399:
    .return (rx1753_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303576195.699") :method
.annotate 'line', 10
    new $P1755, "ResizablePMCArray"
    push $P1755, "redo"
    .return ($P1755)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303576195.699") :outer("12_1303576195.699")
    .param pmc param_1759
    .param pmc param_1760
.annotate 'line', 721
    .lex "self", param_1759
    .lex "$/", param_1760
.annotate 'line', 723
    new $P1761, "Undef"
    .lex "$t", $P1761
    find_lex $P1762, "$/"
    unless_null $P1762, vivify_1400
    $P1762 = root_new ['parrot';'ResizablePMCArray']
  vivify_1400:
    set $P1763, $P1762[0]
    unless_null $P1763, vivify_1401
    new $P1763, "Undef"
  vivify_1401:
    store_lex "$t", $P1763
    find_lex $P1764, "$/"
    unless_null $P1764, vivify_1402
    $P1764 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P1765, $P1764[1]
    unless_null $P1765, vivify_1403
    new $P1765, "Undef"
  vivify_1403:
    find_lex $P1766, "$/"
    unless_null $P1766, vivify_1404
    $P1766 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1766
  vivify_1404:
    set $P1766[0], $P1765
    find_lex $P1767, "$t"
    unless_null $P1767, vivify_1405
    new $P1767, "Undef"
  vivify_1405:
    find_lex $P1768, "$/"
    unless_null $P1768, vivify_1406
    $P1768 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1768
  vivify_1406:
    set $P1768[1], $P1767
.annotate 'line', 721
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2493"  :subid("384_1303576195.699") :outer("10_1303576195.699")
.annotate 'line', 727
    .const 'Sub' $P2559 = "405_1303576195.699" 
    capture_lex $P2559
    .const 'Sub' $P2552 = "403_1303576195.699" 
    capture_lex $P2552
    .const 'Sub' $P2547 = "401_1303576195.699" 
    capture_lex $P2547
    .const 'Sub' $P2535 = "398_1303576195.699" 
    capture_lex $P2535
    .const 'Sub' $P2525 = "395_1303576195.699" 
    capture_lex $P2525
    .const 'Sub' $P2520 = "393_1303576195.699" 
    capture_lex $P2520
    .const 'Sub' $P2511 = "390_1303576195.699" 
    capture_lex $P2511
    .const 'Sub' $P2506 = "388_1303576195.699" 
    capture_lex $P2506
    .const 'Sub' $P2497 = "385_1303576195.699" 
    capture_lex $P2497
    .lex "$?PACKAGE", $P2495
    .lex "$?CLASS", $P2496
    .const 'Sub' $P2552 = "403_1303576195.699" 
    capture_lex $P2552
    .return ($P2552)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1407") :outer("384_1303576195.699")
.annotate 'line', 727
    .const 'Sub' $P2494 = "384_1303576195.699" 
    .local pmc block
    set block, $P2494
    .const 'Sub' $P2559 = "405_1303576195.699" 
    capture_lex $P2559
    $P2559()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2558"  :anon :subid("405_1303576195.699") :outer("384_1303576195.699")
.annotate 'line', 727
    nqp_get_sc_object $P2560, "1303576184.274", 2
    .local pmc type_obj
    set type_obj, $P2560
    get_how $P2561, type_obj
    .const 'Sub' $P2562 = "385_1303576195.699" 
    $P2561."add_method"(type_obj, "metachar:sym<:my>", $P2562)
    get_how $P2563, type_obj
    get_global $P2564, "!PREFIX__metachar:sym<:my>"
    $P2563."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2564)
    get_how $P2565, type_obj
    .const 'Sub' $P2566 = "388_1303576195.699" 
    $P2565."add_method"(type_obj, "metachar:sym<{ }>", $P2566)
    get_how $P2567, type_obj
    get_global $P2568, "!PREFIX__metachar:sym<{ }>"
    $P2567."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2568)
    get_how $P2569, type_obj
    .const 'Sub' $P2570 = "390_1303576195.699" 
    $P2569."add_method"(type_obj, "metachar:sym<nqpvar>", $P2570)
    get_how $P2571, type_obj
    get_global $P2572, "!PREFIX__metachar:sym<nqpvar>"
    $P2571."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2572)
    get_how $P2573, type_obj
    .const 'Sub' $P2574 = "393_1303576195.699" 
    $P2573."add_method"(type_obj, "assertion:sym<{ }>", $P2574)
    get_how $P2575, type_obj
    get_global $P2576, "!PREFIX__assertion:sym<{ }>"
    $P2575."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2576)
    get_how $P2577, type_obj
    .const 'Sub' $P2578 = "395_1303576195.699" 
    $P2577."add_method"(type_obj, "assertion:sym<?{ }>", $P2578)
    get_how $P2579, type_obj
    get_global $P2580, "!PREFIX__assertion:sym<?{ }>"
    $P2579."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2580)
    get_how $P2581, type_obj
    .const 'Sub' $P2582 = "398_1303576195.699" 
    $P2581."add_method"(type_obj, "assertion:sym<name>", $P2582)
    get_how $P2583, type_obj
    get_global $P2584, "!PREFIX__assertion:sym<name>"
    $P2583."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2584)
    get_how $P2585, type_obj
    .const 'Sub' $P2586 = "401_1303576195.699" 
    $P2585."add_method"(type_obj, "assertion:sym<var>", $P2586)
    get_how $P2587, type_obj
    get_global $P2588, "!PREFIX__assertion:sym<var>"
    $P2587."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2588)
    get_how $P2589, type_obj
    .const 'Sub' $P2590 = "403_1303576195.699" 
    $P2589."add_method"(type_obj, "codeblock", $P2590)
    get_how $P2591, type_obj
    get_global $P2592, "!PREFIX__codeblock"
    $P2591."add_method"(type_obj, "!PREFIX__codeblock", $P2592)
    get_how $P2593, type_obj
    get_hll_global $P2594, ["Regex";"P6Regex"], "Grammar"
    $P2593."add_parent"(type_obj, $P2594)
    get_how $P2595, type_obj
    $P2596 = $P2595."compose"(type_obj)
    .return ($P2596)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .const 'Sub' $P2503 = "387_1303576195.699" 
    capture_lex $P2503
    .local string rx2498_tgt
    .local int rx2498_pos
    .local int rx2498_off
    .local int rx2498_eos
    .local int rx2498_rep
    .local pmc rx2498_cur
    .local pmc rx2498_debug
    (rx2498_cur, rx2498_pos, rx2498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2498_cur
    .local pmc match
    .lex "$/", match
    length rx2498_eos, rx2498_tgt
    gt rx2498_pos, rx2498_eos, rx2498_done
    set rx2498_off, 0
    lt rx2498_pos, 2, rx2498_start
    sub rx2498_off, rx2498_pos, 1
    substr rx2498_tgt, rx2498_tgt, rx2498_off
  rx2498_start:
    eq $I10, 1, rx2498_restart
    if_null rx2498_debug, debug_1408
    rx2498_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1408:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2501_done
    goto rxscan2501_scan
  rxscan2501_loop:
    (rx2498_pos) = rx2498_cur."from"()
    inc rx2498_pos
    rx2498_cur."!cursor_from"(rx2498_pos)
    ge rx2498_pos, rx2498_eos, rxscan2501_done
  rxscan2501_scan:
    set_addr $I10, rxscan2501_loop
    rx2498_cur."!mark_push"(0, rx2498_pos, $I10)
  rxscan2501_done:
.annotate 'line', 729
  # rx literal  ":"
    add $I11, rx2498_pos, 1
    gt $I11, rx2498_eos, rx2498_fail
    sub $I11, rx2498_pos, rx2498_off
    ord $I11, rx2498_tgt, $I11
    ne $I11, 58, rx2498_fail
    add rx2498_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2498_cur."!cursor_pos"(rx2498_pos)
    .const 'Sub' $P2503 = "387_1303576195.699" 
    capture_lex $P2503
    $P10 = rx2498_cur."before"($P2503)
    unless $P10, rx2498_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2498_cur."!cursor_pos"(rx2498_pos)
    $P10 = rx2498_cur."LANG"("MAIN", "statement")
    unless $P10, rx2498_fail
    rx2498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2498_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2498_cur."!cursor_pos"(rx2498_pos)
    $P10 = rx2498_cur."ws"()
    unless $P10, rx2498_fail
    rx2498_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2498_pos, 1
    gt $I11, rx2498_eos, rx2498_fail
    sub $I11, rx2498_pos, rx2498_off
    ord $I11, rx2498_tgt, $I11
    ne $I11, 59, rx2498_fail
    add rx2498_pos, 1
.annotate 'line', 728
  # rx pass
    rx2498_cur."!cursor_pass"(rx2498_pos, "metachar:sym<:my>")
    if_null rx2498_debug, debug_1413
    rx2498_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2498_pos)
  debug_1413:
    .return (rx2498_cur)
  rx2498_restart:
.annotate 'line', 727
    if_null rx2498_debug, debug_1414
    rx2498_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1414:
  rx2498_fail:
    (rx2498_rep, rx2498_pos, $I10, $P10) = rx2498_cur."!mark_fail"(0)
    lt rx2498_pos, -1, rx2498_done
    eq rx2498_pos, -1, rx2498_fail
    jump $I10
  rx2498_done:
    rx2498_cur."!cursor_fail"()
    if_null rx2498_debug, debug_1415
    rx2498_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1415:
    .return (rx2498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303576195.699") :method
.annotate 'line', 727
    new $P2500, "ResizablePMCArray"
    push $P2500, ":"
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2502"  :anon :subid("387_1303576195.699") :method :outer("385_1303576195.699")
.annotate 'line', 729
    .local string rx2504_tgt
    .local int rx2504_pos
    .local int rx2504_off
    .local int rx2504_eos
    .local int rx2504_rep
    .local pmc rx2504_cur
    .local pmc rx2504_debug
    (rx2504_cur, rx2504_pos, rx2504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2504_cur
    .local pmc match
    .lex "$/", match
    length rx2504_eos, rx2504_tgt
    gt rx2504_pos, rx2504_eos, rx2504_done
    set rx2504_off, 0
    lt rx2504_pos, 2, rx2504_start
    sub rx2504_off, rx2504_pos, 1
    substr rx2504_tgt, rx2504_tgt, rx2504_off
  rx2504_start:
    eq $I10, 1, rx2504_restart
    if_null rx2504_debug, debug_1409
    rx2504_cur."!cursor_debug"("START", "")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2505_done
    goto rxscan2505_scan
  rxscan2505_loop:
    (rx2504_pos) = rx2504_cur."from"()
    inc rx2504_pos
    rx2504_cur."!cursor_from"(rx2504_pos)
    ge rx2504_pos, rx2504_eos, rxscan2505_done
  rxscan2505_scan:
    set_addr $I10, rxscan2505_loop
    rx2504_cur."!mark_push"(0, rx2504_pos, $I10)
  rxscan2505_done:
  # rx literal  "my"
    add $I11, rx2504_pos, 2
    gt $I11, rx2504_eos, rx2504_fail
    sub $I11, rx2504_pos, rx2504_off
    substr $S10, rx2504_tgt, $I11, 2
    ne $S10, "my", rx2504_fail
    add rx2504_pos, 2
  # rx pass
    rx2504_cur."!cursor_pass"(rx2504_pos, "")
    if_null rx2504_debug, debug_1410
    rx2504_cur."!cursor_debug"("PASS", "", " at pos=", rx2504_pos)
  debug_1410:
    .return (rx2504_cur)
  rx2504_restart:
    if_null rx2504_debug, debug_1411
    rx2504_cur."!cursor_debug"("NEXT", "")
  debug_1411:
  rx2504_fail:
    (rx2504_rep, rx2504_pos, $I10, $P10) = rx2504_cur."!mark_fail"(0)
    lt rx2504_pos, -1, rx2504_done
    eq rx2504_pos, -1, rx2504_fail
    jump $I10
  rx2504_done:
    rx2504_cur."!cursor_fail"()
    if_null rx2504_debug, debug_1412
    rx2504_cur."!cursor_debug"("FAIL", "")
  debug_1412:
    .return (rx2504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .local string rx2507_tgt
    .local int rx2507_pos
    .local int rx2507_off
    .local int rx2507_eos
    .local int rx2507_rep
    .local pmc rx2507_cur
    .local pmc rx2507_debug
    (rx2507_cur, rx2507_pos, rx2507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2507_cur
    .local pmc match
    .lex "$/", match
    length rx2507_eos, rx2507_tgt
    gt rx2507_pos, rx2507_eos, rx2507_done
    set rx2507_off, 0
    lt rx2507_pos, 2, rx2507_start
    sub rx2507_off, rx2507_pos, 1
    substr rx2507_tgt, rx2507_tgt, rx2507_off
  rx2507_start:
    eq $I10, 1, rx2507_restart
    if_null rx2507_debug, debug_1416
    rx2507_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1416:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2510_done
    goto rxscan2510_scan
  rxscan2510_loop:
    (rx2507_pos) = rx2507_cur."from"()
    inc rx2507_pos
    rx2507_cur."!cursor_from"(rx2507_pos)
    ge rx2507_pos, rx2507_eos, rxscan2510_done
  rxscan2510_scan:
    set_addr $I10, rxscan2510_loop
    rx2507_cur."!mark_push"(0, rx2507_pos, $I10)
  rxscan2510_done:
.annotate 'line', 733
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2507_pos, rx2507_off
    substr $S10, rx2507_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2507_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."codeblock"()
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2507_pos = $P10."pos"()
.annotate 'line', 732
  # rx pass
    rx2507_cur."!cursor_pass"(rx2507_pos, "metachar:sym<{ }>")
    if_null rx2507_debug, debug_1417
    rx2507_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2507_pos)
  debug_1417:
    .return (rx2507_cur)
  rx2507_restart:
.annotate 'line', 727
    if_null rx2507_debug, debug_1418
    rx2507_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1418:
  rx2507_fail:
    (rx2507_rep, rx2507_pos, $I10, $P10) = rx2507_cur."!mark_fail"(0)
    lt rx2507_pos, -1, rx2507_done
    eq rx2507_pos, -1, rx2507_fail
    jump $I10
  rx2507_done:
    rx2507_cur."!cursor_fail"()
    if_null rx2507_debug, debug_1419
    rx2507_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1419:
    .return (rx2507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303576195.699") :method
.annotate 'line', 727
    new $P2509, "ResizablePMCArray"
    push $P2509, "{"
    .return ($P2509)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .const 'Sub' $P2517 = "392_1303576195.699" 
    capture_lex $P2517
    .local string rx2512_tgt
    .local int rx2512_pos
    .local int rx2512_off
    .local int rx2512_eos
    .local int rx2512_rep
    .local pmc rx2512_cur
    .local pmc rx2512_debug
    (rx2512_cur, rx2512_pos, rx2512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2512_cur
    .local pmc match
    .lex "$/", match
    length rx2512_eos, rx2512_tgt
    gt rx2512_pos, rx2512_eos, rx2512_done
    set rx2512_off, 0
    lt rx2512_pos, 2, rx2512_start
    sub rx2512_off, rx2512_pos, 1
    substr rx2512_tgt, rx2512_tgt, rx2512_off
  rx2512_start:
    eq $I10, 1, rx2512_restart
    if_null rx2512_debug, debug_1420
    rx2512_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1420:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2515_done
    goto rxscan2515_scan
  rxscan2515_loop:
    (rx2512_pos) = rx2512_cur."from"()
    inc rx2512_pos
    rx2512_cur."!cursor_from"(rx2512_pos)
    ge rx2512_pos, rx2512_eos, rxscan2515_done
  rxscan2515_scan:
    set_addr $I10, rxscan2515_loop
    rx2512_cur."!mark_push"(0, rx2512_pos, $I10)
  rxscan2515_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2512_pos, rx2512_off
    substr $S10, rx2512_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2512_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2512_cur."!cursor_pos"(rx2512_pos)
    .const 'Sub' $P2517 = "392_1303576195.699" 
    capture_lex $P2517
    $P10 = rx2512_cur."before"($P2517)
    unless $P10, rx2512_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2512_cur."!cursor_pos"(rx2512_pos)
    $P10 = rx2512_cur."LANG"("MAIN", "variable")
    unless $P10, rx2512_fail
    rx2512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2512_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx2512_cur."!cursor_pass"(rx2512_pos, "metachar:sym<nqpvar>")
    if_null rx2512_debug, debug_1425
    rx2512_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2512_pos)
  debug_1425:
    .return (rx2512_cur)
  rx2512_restart:
.annotate 'line', 727
    if_null rx2512_debug, debug_1426
    rx2512_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1426:
  rx2512_fail:
    (rx2512_rep, rx2512_pos, $I10, $P10) = rx2512_cur."!mark_fail"(0)
    lt rx2512_pos, -1, rx2512_done
    eq rx2512_pos, -1, rx2512_fail
    jump $I10
  rx2512_done:
    rx2512_cur."!cursor_fail"()
    if_null rx2512_debug, debug_1427
    rx2512_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1427:
    .return (rx2512_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303576195.699") :method
.annotate 'line', 727
    new $P2514, "ResizablePMCArray"
    push $P2514, "$"
    push $P2514, "@"
    .return ($P2514)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2516"  :anon :subid("392_1303576195.699") :method :outer("390_1303576195.699")
.annotate 'line', 737
    .local string rx2518_tgt
    .local int rx2518_pos
    .local int rx2518_off
    .local int rx2518_eos
    .local int rx2518_rep
    .local pmc rx2518_cur
    .local pmc rx2518_debug
    (rx2518_cur, rx2518_pos, rx2518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2518_cur
    .local pmc match
    .lex "$/", match
    length rx2518_eos, rx2518_tgt
    gt rx2518_pos, rx2518_eos, rx2518_done
    set rx2518_off, 0
    lt rx2518_pos, 2, rx2518_start
    sub rx2518_off, rx2518_pos, 1
    substr rx2518_tgt, rx2518_tgt, rx2518_off
  rx2518_start:
    eq $I10, 1, rx2518_restart
    if_null rx2518_debug, debug_1421
    rx2518_cur."!cursor_debug"("START", "")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2519_done
    goto rxscan2519_scan
  rxscan2519_loop:
    (rx2518_pos) = rx2518_cur."from"()
    inc rx2518_pos
    rx2518_cur."!cursor_from"(rx2518_pos)
    ge rx2518_pos, rx2518_eos, rxscan2519_done
  rxscan2519_scan:
    set_addr $I10, rxscan2519_loop
    rx2518_cur."!mark_push"(0, rx2518_pos, $I10)
  rxscan2519_done:
  # rx charclass .
    ge rx2518_pos, rx2518_eos, rx2518_fail
    inc rx2518_pos
  # rx charclass w
    ge rx2518_pos, rx2518_eos, rx2518_fail
    sub $I10, rx2518_pos, rx2518_off
    is_cclass $I11, 8192, rx2518_tgt, $I10
    unless $I11, rx2518_fail
    inc rx2518_pos
  # rx pass
    rx2518_cur."!cursor_pass"(rx2518_pos, "")
    if_null rx2518_debug, debug_1422
    rx2518_cur."!cursor_debug"("PASS", "", " at pos=", rx2518_pos)
  debug_1422:
    .return (rx2518_cur)
  rx2518_restart:
    if_null rx2518_debug, debug_1423
    rx2518_cur."!cursor_debug"("NEXT", "")
  debug_1423:
  rx2518_fail:
    (rx2518_rep, rx2518_pos, $I10, $P10) = rx2518_cur."!mark_fail"(0)
    lt rx2518_pos, -1, rx2518_done
    eq rx2518_pos, -1, rx2518_fail
    jump $I10
  rx2518_done:
    rx2518_cur."!cursor_fail"()
    if_null rx2518_debug, debug_1424
    rx2518_cur."!cursor_debug"("FAIL", "")
  debug_1424:
    .return (rx2518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .local string rx2521_tgt
    .local int rx2521_pos
    .local int rx2521_off
    .local int rx2521_eos
    .local int rx2521_rep
    .local pmc rx2521_cur
    .local pmc rx2521_debug
    (rx2521_cur, rx2521_pos, rx2521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2521_cur
    .local pmc match
    .lex "$/", match
    length rx2521_eos, rx2521_tgt
    gt rx2521_pos, rx2521_eos, rx2521_done
    set rx2521_off, 0
    lt rx2521_pos, 2, rx2521_start
    sub rx2521_off, rx2521_pos, 1
    substr rx2521_tgt, rx2521_tgt, rx2521_off
  rx2521_start:
    eq $I10, 1, rx2521_restart
    if_null rx2521_debug, debug_1428
    rx2521_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1428:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2524_done
    goto rxscan2524_scan
  rxscan2524_loop:
    (rx2521_pos) = rx2521_cur."from"()
    inc rx2521_pos
    rx2521_cur."!cursor_from"(rx2521_pos)
    ge rx2521_pos, rx2521_eos, rxscan2524_done
  rxscan2524_scan:
    set_addr $I10, rxscan2524_loop
    rx2521_cur."!mark_push"(0, rx2521_pos, $I10)
  rxscan2524_done:
.annotate 'line', 741
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2521_pos, rx2521_off
    substr $S10, rx2521_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2521_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2521_cur."!cursor_pos"(rx2521_pos)
    $P10 = rx2521_cur."codeblock"()
    unless $P10, rx2521_fail
    rx2521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2521_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx2521_cur."!cursor_pass"(rx2521_pos, "assertion:sym<{ }>")
    if_null rx2521_debug, debug_1429
    rx2521_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2521_pos)
  debug_1429:
    .return (rx2521_cur)
  rx2521_restart:
.annotate 'line', 727
    if_null rx2521_debug, debug_1430
    rx2521_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1430:
  rx2521_fail:
    (rx2521_rep, rx2521_pos, $I10, $P10) = rx2521_cur."!mark_fail"(0)
    lt rx2521_pos, -1, rx2521_done
    eq rx2521_pos, -1, rx2521_fail
    jump $I10
  rx2521_done:
    rx2521_cur."!cursor_fail"()
    if_null rx2521_debug, debug_1431
    rx2521_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1431:
    .return (rx2521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303576195.699") :method
.annotate 'line', 727
    new $P2523, "ResizablePMCArray"
    push $P2523, "{"
    .return ($P2523)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .const 'Sub' $P2531 = "397_1303576195.699" 
    capture_lex $P2531
    .local string rx2526_tgt
    .local int rx2526_pos
    .local int rx2526_off
    .local int rx2526_eos
    .local int rx2526_rep
    .local pmc rx2526_cur
    .local pmc rx2526_debug
    (rx2526_cur, rx2526_pos, rx2526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2526_cur
    .local pmc match
    .lex "$/", match
    length rx2526_eos, rx2526_tgt
    gt rx2526_pos, rx2526_eos, rx2526_done
    set rx2526_off, 0
    lt rx2526_pos, 2, rx2526_start
    sub rx2526_off, rx2526_pos, 1
    substr rx2526_tgt, rx2526_tgt, rx2526_off
  rx2526_start:
    eq $I10, 1, rx2526_restart
    if_null rx2526_debug, debug_1432
    rx2526_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2529_done
    goto rxscan2529_scan
  rxscan2529_loop:
    (rx2526_pos) = rx2526_cur."from"()
    inc rx2526_pos
    rx2526_cur."!cursor_from"(rx2526_pos)
    ge rx2526_pos, rx2526_eos, rxscan2529_done
  rxscan2529_scan:
    set_addr $I10, rxscan2529_loop
    rx2526_cur."!mark_push"(0, rx2526_pos, $I10)
  rxscan2529_done:
.annotate 'line', 745
  # rx subcapture "zw"
    set_addr $I10, rxcap_2534_fail
    rx2526_cur."!mark_push"(0, rx2526_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2526_pos, rx2526_eos, rx2526_fail
    sub $I10, rx2526_pos, rx2526_off
    substr $S10, rx2526_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2526_fail
    inc rx2526_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2526_cur."!cursor_pos"(rx2526_pos)
    .const 'Sub' $P2531 = "397_1303576195.699" 
    capture_lex $P2531
    $P10 = rx2526_cur."before"($P2531)
    unless $P10, rx2526_fail
    set_addr $I10, rxcap_2534_fail
    ($I12, $I11) = rx2526_cur."!mark_peek"($I10)
    rx2526_cur."!cursor_pos"($I11)
    ($P10) = rx2526_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2526_pos, "")
    rx2526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2534_done
  rxcap_2534_fail:
    goto rx2526_fail
  rxcap_2534_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2526_cur."!cursor_pos"(rx2526_pos)
    $P10 = rx2526_cur."codeblock"()
    unless $P10, rx2526_fail
    rx2526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2526_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx2526_cur."!cursor_pass"(rx2526_pos, "assertion:sym<?{ }>")
    if_null rx2526_debug, debug_1437
    rx2526_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2526_pos)
  debug_1437:
    .return (rx2526_cur)
  rx2526_restart:
.annotate 'line', 727
    if_null rx2526_debug, debug_1438
    rx2526_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1438:
  rx2526_fail:
    (rx2526_rep, rx2526_pos, $I10, $P10) = rx2526_cur."!mark_fail"(0)
    lt rx2526_pos, -1, rx2526_done
    eq rx2526_pos, -1, rx2526_fail
    jump $I10
  rx2526_done:
    rx2526_cur."!cursor_fail"()
    if_null rx2526_debug, debug_1439
    rx2526_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1439:
    .return (rx2526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303576195.699") :method
.annotate 'line', 727
    new $P2528, "ResizablePMCArray"
    push $P2528, "!"
    push $P2528, "?"
    .return ($P2528)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2530"  :anon :subid("397_1303576195.699") :method :outer("395_1303576195.699")
.annotate 'line', 745
    .local string rx2532_tgt
    .local int rx2532_pos
    .local int rx2532_off
    .local int rx2532_eos
    .local int rx2532_rep
    .local pmc rx2532_cur
    .local pmc rx2532_debug
    (rx2532_cur, rx2532_pos, rx2532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2532_cur
    .local pmc match
    .lex "$/", match
    length rx2532_eos, rx2532_tgt
    gt rx2532_pos, rx2532_eos, rx2532_done
    set rx2532_off, 0
    lt rx2532_pos, 2, rx2532_start
    sub rx2532_off, rx2532_pos, 1
    substr rx2532_tgt, rx2532_tgt, rx2532_off
  rx2532_start:
    eq $I10, 1, rx2532_restart
    if_null rx2532_debug, debug_1433
    rx2532_cur."!cursor_debug"("START", "")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2533_done
    goto rxscan2533_scan
  rxscan2533_loop:
    (rx2532_pos) = rx2532_cur."from"()
    inc rx2532_pos
    rx2532_cur."!cursor_from"(rx2532_pos)
    ge rx2532_pos, rx2532_eos, rxscan2533_done
  rxscan2533_scan:
    set_addr $I10, rxscan2533_loop
    rx2532_cur."!mark_push"(0, rx2532_pos, $I10)
  rxscan2533_done:
  # rx literal  "{"
    add $I11, rx2532_pos, 1
    gt $I11, rx2532_eos, rx2532_fail
    sub $I11, rx2532_pos, rx2532_off
    ord $I11, rx2532_tgt, $I11
    ne $I11, 123, rx2532_fail
    add rx2532_pos, 1
  # rx pass
    rx2532_cur."!cursor_pass"(rx2532_pos, "")
    if_null rx2532_debug, debug_1434
    rx2532_cur."!cursor_debug"("PASS", "", " at pos=", rx2532_pos)
  debug_1434:
    .return (rx2532_cur)
  rx2532_restart:
    if_null rx2532_debug, debug_1435
    rx2532_cur."!cursor_debug"("NEXT", "")
  debug_1435:
  rx2532_fail:
    (rx2532_rep, rx2532_pos, $I10, $P10) = rx2532_cur."!mark_fail"(0)
    lt rx2532_pos, -1, rx2532_done
    eq rx2532_pos, -1, rx2532_fail
    jump $I10
  rx2532_done:
    rx2532_cur."!cursor_fail"()
    if_null rx2532_debug, debug_1436
    rx2532_cur."!cursor_debug"("FAIL", "")
  debug_1436:
    .return (rx2532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .const 'Sub' $P2544 = "400_1303576195.699" 
    capture_lex $P2544
    .local string rx2536_tgt
    .local int rx2536_pos
    .local int rx2536_off
    .local int rx2536_eos
    .local int rx2536_rep
    .local pmc rx2536_cur
    .local pmc rx2536_debug
    (rx2536_cur, rx2536_pos, rx2536_tgt, $I10) = self."!cursor_start"()
    rx2536_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2536_cur
    .local pmc match
    .lex "$/", match
    length rx2536_eos, rx2536_tgt
    gt rx2536_pos, rx2536_eos, rx2536_done
    set rx2536_off, 0
    lt rx2536_pos, 2, rx2536_start
    sub rx2536_off, rx2536_pos, 1
    substr rx2536_tgt, rx2536_tgt, rx2536_off
  rx2536_start:
    eq $I10, 1, rx2536_restart
    if_null rx2536_debug, debug_1440
    rx2536_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2540_done
    goto rxscan2540_scan
  rxscan2540_loop:
    (rx2536_pos) = rx2536_cur."from"()
    inc rx2536_pos
    rx2536_cur."!cursor_from"(rx2536_pos)
    ge rx2536_pos, rx2536_eos, rxscan2540_done
  rxscan2540_scan:
    set_addr $I10, rxscan2540_loop
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
  rxscan2540_done:
.annotate 'line', 749
  # rx subrule "identifier" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."identifier"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2536_pos = $P10."pos"()
.annotate 'line', 756
  # rx rxquantr2541 ** 0..1
    set_addr $I10, rxquantr2541_done
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
  rxquantr2541_loop:
  alt2542_0:
.annotate 'line', 750
    set_addr $I10, alt2542_1
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 751
  # rx subrule "before" subtype=zerowidth negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    .const 'Sub' $P2544 = "400_1303576195.699" 
    capture_lex $P2544
    $P10 = rx2536_cur."before"($P2544)
    unless $P10, rx2536_fail
    goto alt2542_end
  alt2542_1:
    set_addr $I10, alt2542_2
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 752
  # rx literal  "="
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 61, rx2536_fail
    add rx2536_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."assertion"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2536_pos = $P10."pos"()
    goto alt2542_end
  alt2542_2:
    set_addr $I10, alt2542_3
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 753
  # rx literal  ":"
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 58, rx2536_fail
    add rx2536_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."arglist"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2536_pos = $P10."pos"()
    goto alt2542_end
  alt2542_3:
    set_addr $I10, alt2542_4
    rx2536_cur."!mark_push"(0, rx2536_pos, $I10)
.annotate 'line', 754
  # rx literal  "("
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 40, rx2536_fail
    add rx2536_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2536_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2536_pos, 1
    gt $I11, rx2536_eos, rx2536_fail
    sub $I11, rx2536_pos, rx2536_off
    ord $I11, rx2536_tgt, $I11
    ne $I11, 41, rx2536_fail
    add rx2536_pos, 1
    goto alt2542_end
  alt2542_4:
.annotate 'line', 755
  # rx subrule "normspace" subtype=method negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."normspace"()
    unless $P10, rx2536_fail
    rx2536_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2536_cur."!cursor_pos"(rx2536_pos)
    $P10 = rx2536_cur."nibbler"()
    unless $P10, rx2536_fail
    rx2536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2536_pos = $P10."pos"()
  alt2542_end:
.annotate 'line', 756
    set_addr $I10, rxquantr2541_done
    (rx2536_rep) = rx2536_cur."!mark_commit"($I10)
  rxquantr2541_done:
.annotate 'line', 748
  # rx pass
    rx2536_cur."!cursor_pass"(rx2536_pos, "assertion:sym<name>")
    if_null rx2536_debug, debug_1445
    rx2536_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2536_pos)
  debug_1445:
    .return (rx2536_cur)
  rx2536_restart:
.annotate 'line', 727
    if_null rx2536_debug, debug_1446
    rx2536_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1446:
  rx2536_fail:
    (rx2536_rep, rx2536_pos, $I10, $P10) = rx2536_cur."!mark_fail"(0)
    lt rx2536_pos, -1, rx2536_done
    eq rx2536_pos, -1, rx2536_fail
    jump $I10
  rx2536_done:
    rx2536_cur."!cursor_fail"()
    if_null rx2536_debug, debug_1447
    rx2536_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1447:
    .return (rx2536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303576195.699") :method
.annotate 'line', 727
    $P2538 = self."!PREFIX__!subrule"("identifier", "")
    new $P2539, "ResizablePMCArray"
    push $P2539, $P2538
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2543"  :anon :subid("400_1303576195.699") :method :outer("398_1303576195.699")
.annotate 'line', 751
    .local string rx2545_tgt
    .local int rx2545_pos
    .local int rx2545_off
    .local int rx2545_eos
    .local int rx2545_rep
    .local pmc rx2545_cur
    .local pmc rx2545_debug
    (rx2545_cur, rx2545_pos, rx2545_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2545_cur
    .local pmc match
    .lex "$/", match
    length rx2545_eos, rx2545_tgt
    gt rx2545_pos, rx2545_eos, rx2545_done
    set rx2545_off, 0
    lt rx2545_pos, 2, rx2545_start
    sub rx2545_off, rx2545_pos, 1
    substr rx2545_tgt, rx2545_tgt, rx2545_off
  rx2545_start:
    eq $I10, 1, rx2545_restart
    if_null rx2545_debug, debug_1441
    rx2545_cur."!cursor_debug"("START", "")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2546_done
    goto rxscan2546_scan
  rxscan2546_loop:
    (rx2545_pos) = rx2545_cur."from"()
    inc rx2545_pos
    rx2545_cur."!cursor_from"(rx2545_pos)
    ge rx2545_pos, rx2545_eos, rxscan2546_done
  rxscan2546_scan:
    set_addr $I10, rxscan2546_loop
    rx2545_cur."!mark_push"(0, rx2545_pos, $I10)
  rxscan2546_done:
  # rx literal  ">"
    add $I11, rx2545_pos, 1
    gt $I11, rx2545_eos, rx2545_fail
    sub $I11, rx2545_pos, rx2545_off
    ord $I11, rx2545_tgt, $I11
    ne $I11, 62, rx2545_fail
    add rx2545_pos, 1
  # rx pass
    rx2545_cur."!cursor_pass"(rx2545_pos, "")
    if_null rx2545_debug, debug_1442
    rx2545_cur."!cursor_debug"("PASS", "", " at pos=", rx2545_pos)
  debug_1442:
    .return (rx2545_cur)
  rx2545_restart:
    if_null rx2545_debug, debug_1443
    rx2545_cur."!cursor_debug"("NEXT", "")
  debug_1443:
  rx2545_fail:
    (rx2545_rep, rx2545_pos, $I10, $P10) = rx2545_cur."!mark_fail"(0)
    lt rx2545_pos, -1, rx2545_done
    eq rx2545_pos, -1, rx2545_fail
    jump $I10
  rx2545_done:
    rx2545_cur."!cursor_fail"()
    if_null rx2545_debug, debug_1444
    rx2545_cur."!cursor_debug"("FAIL", "")
  debug_1444:
    .return (rx2545_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .local string rx2548_tgt
    .local int rx2548_pos
    .local int rx2548_off
    .local int rx2548_eos
    .local int rx2548_rep
    .local pmc rx2548_cur
    .local pmc rx2548_debug
    (rx2548_cur, rx2548_pos, rx2548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2548_cur
    .local pmc match
    .lex "$/", match
    length rx2548_eos, rx2548_tgt
    gt rx2548_pos, rx2548_eos, rx2548_done
    set rx2548_off, 0
    lt rx2548_pos, 2, rx2548_start
    sub rx2548_off, rx2548_pos, 1
    substr rx2548_tgt, rx2548_tgt, rx2548_off
  rx2548_start:
    eq $I10, 1, rx2548_restart
    if_null rx2548_debug, debug_1448
    rx2548_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2551_done
    goto rxscan2551_scan
  rxscan2551_loop:
    (rx2548_pos) = rx2548_cur."from"()
    inc rx2548_pos
    rx2548_cur."!cursor_from"(rx2548_pos)
    ge rx2548_pos, rx2548_eos, rxscan2551_done
  rxscan2551_scan:
    set_addr $I10, rxscan2551_loop
    rx2548_cur."!mark_push"(0, rx2548_pos, $I10)
  rxscan2551_done:
.annotate 'line', 760
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2548_pos, rx2548_off
    substr $S10, rx2548_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2548_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2548_cur."!cursor_pos"(rx2548_pos)
    $P10 = rx2548_cur."LANG"("MAIN", "variable")
    unless $P10, rx2548_fail
    rx2548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2548_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx2548_cur."!cursor_pass"(rx2548_pos, "assertion:sym<var>")
    if_null rx2548_debug, debug_1449
    rx2548_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2548_pos)
  debug_1449:
    .return (rx2548_cur)
  rx2548_restart:
.annotate 'line', 727
    if_null rx2548_debug, debug_1450
    rx2548_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1450:
  rx2548_fail:
    (rx2548_rep, rx2548_pos, $I10, $P10) = rx2548_cur."!mark_fail"(0)
    lt rx2548_pos, -1, rx2548_done
    eq rx2548_pos, -1, rx2548_fail
    jump $I10
  rx2548_done:
    rx2548_cur."!cursor_fail"()
    if_null rx2548_debug, debug_1451
    rx2548_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1451:
    .return (rx2548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303576195.699") :method
.annotate 'line', 727
    new $P2550, "ResizablePMCArray"
    push $P2550, "$"
    push $P2550, "@"
    .return ($P2550)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303576195.699") :method :outer("384_1303576195.699")
.annotate 'line', 727
    .local string rx2553_tgt
    .local int rx2553_pos
    .local int rx2553_off
    .local int rx2553_eos
    .local int rx2553_rep
    .local pmc rx2553_cur
    .local pmc rx2553_debug
    (rx2553_cur, rx2553_pos, rx2553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2553_cur
    .local pmc match
    .lex "$/", match
    length rx2553_eos, rx2553_tgt
    gt rx2553_pos, rx2553_eos, rx2553_done
    set rx2553_off, 0
    lt rx2553_pos, 2, rx2553_start
    sub rx2553_off, rx2553_pos, 1
    substr rx2553_tgt, rx2553_tgt, rx2553_off
  rx2553_start:
    eq $I10, 1, rx2553_restart
    if_null rx2553_debug, debug_1452
    rx2553_cur."!cursor_debug"("START", "codeblock")
  debug_1452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2557_done
    goto rxscan2557_scan
  rxscan2557_loop:
    (rx2553_pos) = rx2553_cur."from"()
    inc rx2553_pos
    rx2553_cur."!cursor_from"(rx2553_pos)
    ge rx2553_pos, rx2553_eos, rxscan2557_done
  rxscan2557_scan:
    set_addr $I10, rxscan2557_loop
    rx2553_cur."!mark_push"(0, rx2553_pos, $I10)
  rxscan2557_done:
.annotate 'line', 764
  # rx subrule "LANG" subtype=capture negate=
    rx2553_cur."!cursor_pos"(rx2553_pos)
    $P10 = rx2553_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2553_fail
    rx2553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2553_pos = $P10."pos"()
.annotate 'line', 763
  # rx pass
    rx2553_cur."!cursor_pass"(rx2553_pos, "codeblock")
    if_null rx2553_debug, debug_1453
    rx2553_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2553_pos)
  debug_1453:
    .return (rx2553_cur)
  rx2553_restart:
.annotate 'line', 727
    if_null rx2553_debug, debug_1454
    rx2553_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1454:
  rx2553_fail:
    (rx2553_rep, rx2553_pos, $I10, $P10) = rx2553_cur."!mark_fail"(0)
    lt rx2553_pos, -1, rx2553_done
    eq rx2553_pos, -1, rx2553_fail
    jump $I10
  rx2553_done:
    rx2553_cur."!cursor_fail"()
    if_null rx2553_debug, debug_1455
    rx2553_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1455:
    .return (rx2553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303576195.699") :method
.annotate 'line', 727
    $P2555 = self."!PREFIX__!subrule"("LANG", "")
    new $P2556, "ResizablePMCArray"
    push $P2556, $P2555
    .return ($P2556)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2597"  :subid("406_1303576195.699") :outer("10_1303576195.699")
.annotate 'line', 770
    .const 'Sub' $P5835 = "563_1303576195.699" 
    capture_lex $P5835
    .const 'Sub' $P5821 = "562_1303576195.699" 
    capture_lex $P5821
    .const 'Sub' $P5816 = "561_1303576195.699" 
    capture_lex $P5816
    .const 'Sub' $P5811 = "560_1303576195.699" 
    capture_lex $P5811
    .const 'Sub' $P5806 = "559_1303576195.699" 
    capture_lex $P5806
    .const 'Sub' $P5795 = "558_1303576195.699" 
    capture_lex $P5795
    .const 'Sub' $P5787 = "557_1303576195.699" 
    capture_lex $P5787
    .const 'Sub' $P5779 = "556_1303576195.699" 
    capture_lex $P5779
    .const 'Sub' $P5771 = "555_1303576195.699" 
    capture_lex $P5771
    .const 'Sub' $P5766 = "554_1303576195.699" 
    capture_lex $P5766
    .const 'Sub' $P5754 = "553_1303576195.699" 
    capture_lex $P5754
    .const 'Sub' $P5746 = "552_1303576195.699" 
    capture_lex $P5746
    .const 'Sub' $P5699 = "551_1303576195.699" 
    capture_lex $P5699
    .const 'Sub' $P5687 = "550_1303576195.699" 
    capture_lex $P5687
    .const 'Sub' $P5679 = "549_1303576195.699" 
    capture_lex $P5679
    .const 'Sub' $P5671 = "548_1303576195.699" 
    capture_lex $P5671
    .const 'Sub' $P5663 = "547_1303576195.699" 
    capture_lex $P5663
    .const 'Sub' $P5655 = "546_1303576195.699" 
    capture_lex $P5655
    .const 'Sub' $P5647 = "545_1303576195.699" 
    capture_lex $P5647
    .const 'Sub' $P5621 = "544_1303576195.699" 
    capture_lex $P5621
    .const 'Sub' $P5606 = "543_1303576195.699" 
    capture_lex $P5606
    .const 'Sub' $P5598 = "542_1303576195.699" 
    capture_lex $P5598
    .const 'Sub' $P5587 = "541_1303576195.699" 
    capture_lex $P5587
    .const 'Sub' $P5576 = "540_1303576195.699" 
    capture_lex $P5576
    .const 'Sub' $P5565 = "539_1303576195.699" 
    capture_lex $P5565
    .const 'Sub' $P5557 = "538_1303576195.699" 
    capture_lex $P5557
    .const 'Sub' $P5530 = "537_1303576195.699" 
    capture_lex $P5530
    .const 'Sub' $P5492 = "535_1303576195.699" 
    capture_lex $P5492
    .const 'Sub' $P5484 = "534_1303576195.699" 
    capture_lex $P5484
    .const 'Sub' $P5476 = "533_1303576195.699" 
    capture_lex $P5476
    .const 'Sub' $P5451 = "532_1303576195.699" 
    capture_lex $P5451
    .const 'Sub' $P5435 = "531_1303576195.699" 
    capture_lex $P5435
    .const 'Sub' $P5427 = "530_1303576195.699" 
    capture_lex $P5427
    .const 'Sub' $P5419 = "529_1303576195.699" 
    capture_lex $P5419
    .const 'Sub' $P5317 = "526_1303576195.699" 
    capture_lex $P5317
    .const 'Sub' $P5309 = "525_1303576195.699" 
    capture_lex $P5309
    .const 'Sub' $P5302 = "524_1303576195.699" 
    capture_lex $P5302
    .const 'Sub' $P5271 = "523_1303576195.699" 
    capture_lex $P5271
    .const 'Sub' $P5218 = "521_1303576195.699" 
    capture_lex $P5218
    .const 'Sub' $P5204 = "520_1303576195.699" 
    capture_lex $P5204
    .const 'Sub' $P5197 = "519_1303576195.699" 
    capture_lex $P5197
    .const 'Sub' $P5148 = "518_1303576195.699" 
    capture_lex $P5148
    .const 'Sub' $P4972 = "514_1303576195.699" 
    capture_lex $P4972
    .const 'Sub' $P4909 = "512_1303576195.699" 
    capture_lex $P4909
    .const 'Sub' $P4901 = "511_1303576195.699" 
    capture_lex $P4901
    .const 'Sub' $P4886 = "510_1303576195.699" 
    capture_lex $P4886
    .const 'Sub' $P4871 = "509_1303576195.699" 
    capture_lex $P4871
    .const 'Sub' $P4851 = "508_1303576195.699" 
    capture_lex $P4851
    .const 'Sub' $P4748 = "507_1303576195.699" 
    capture_lex $P4748
    .const 'Sub' $P4700 = "504_1303576195.699" 
    capture_lex $P4700
    .const 'Sub' $P4575 = "501_1303576195.699" 
    capture_lex $P4575
    .const 'Sub' $P4302 = "494_1303576195.699" 
    capture_lex $P4302
    .const 'Sub' $P4294 = "493_1303576195.699" 
    capture_lex $P4294
    .const 'Sub' $P4286 = "492_1303576195.699" 
    capture_lex $P4286
    .const 'Sub' $P4178 = "489_1303576195.699" 
    capture_lex $P4178
    .const 'Sub' $P4170 = "488_1303576195.699" 
    capture_lex $P4170
    .const 'Sub' $P4155 = "487_1303576195.699" 
    capture_lex $P4155
    .const 'Sub' $P4140 = "486_1303576195.699" 
    capture_lex $P4140
    .const 'Sub' $P4125 = "485_1303576195.699" 
    capture_lex $P4125
    .const 'Sub' $P4103 = "484_1303576195.699" 
    capture_lex $P4103
    .const 'Sub' $P4095 = "483_1303576195.699" 
    capture_lex $P4095
    .const 'Sub' $P4087 = "482_1303576195.699" 
    capture_lex $P4087
    .const 'Sub' $P4079 = "481_1303576195.699" 
    capture_lex $P4079
    .const 'Sub' $P3882 = "478_1303576195.699" 
    capture_lex $P3882
    .const 'Sub' $P3874 = "477_1303576195.699" 
    capture_lex $P3874
    .const 'Sub' $P3866 = "476_1303576195.699" 
    capture_lex $P3866
    .const 'Sub' $P3858 = "475_1303576195.699" 
    capture_lex $P3858
    .const 'Sub' $P3850 = "474_1303576195.699" 
    capture_lex $P3850
    .const 'Sub' $P3842 = "473_1303576195.699" 
    capture_lex $P3842
    .const 'Sub' $P3834 = "472_1303576195.699" 
    capture_lex $P3834
    .const 'Sub' $P3723 = "470_1303576195.699" 
    capture_lex $P3723
    .const 'Sub' $P3699 = "469_1303576195.699" 
    capture_lex $P3699
    .const 'Sub' $P3685 = "468_1303576195.699" 
    capture_lex $P3685
    .const 'Sub' $P3677 = "467_1303576195.699" 
    capture_lex $P3677
    .const 'Sub' $P3669 = "466_1303576195.699" 
    capture_lex $P3669
    .const 'Sub' $P3661 = "465_1303576195.699" 
    capture_lex $P3661
    .const 'Sub' $P3653 = "464_1303576195.699" 
    capture_lex $P3653
    .const 'Sub' $P3645 = "463_1303576195.699" 
    capture_lex $P3645
    .const 'Sub' $P3637 = "462_1303576195.699" 
    capture_lex $P3637
    .const 'Sub' $P3629 = "461_1303576195.699" 
    capture_lex $P3629
    .const 'Sub' $P3621 = "460_1303576195.699" 
    capture_lex $P3621
    .const 'Sub' $P3613 = "459_1303576195.699" 
    capture_lex $P3613
    .const 'Sub' $P3605 = "458_1303576195.699" 
    capture_lex $P3605
    .const 'Sub' $P3597 = "457_1303576195.699" 
    capture_lex $P3597
    .const 'Sub' $P3589 = "456_1303576195.699" 
    capture_lex $P3589
    .const 'Sub' $P3581 = "455_1303576195.699" 
    capture_lex $P3581
    .const 'Sub' $P3565 = "454_1303576195.699" 
    capture_lex $P3565
    .const 'Sub' $P3532 = "453_1303576195.699" 
    capture_lex $P3532
    .const 'Sub' $P3518 = "452_1303576195.699" 
    capture_lex $P3518
    .const 'Sub' $P3497 = "451_1303576195.699" 
    capture_lex $P3497
    .const 'Sub' $P3477 = "450_1303576195.699" 
    capture_lex $P3477
    .const 'Sub' $P3453 = "449_1303576195.699" 
    capture_lex $P3453
    .const 'Sub' $P3419 = "448_1303576195.699" 
    capture_lex $P3419
    .const 'Sub' $P3404 = "447_1303576195.699" 
    capture_lex $P3404
    .const 'Sub' $P3392 = "446_1303576195.699" 
    capture_lex $P3392
    .const 'Sub' $P3341 = "444_1303576195.699" 
    capture_lex $P3341
    .const 'Sub' $P3329 = "443_1303576195.699" 
    capture_lex $P3329
    .const 'Sub' $P3322 = "442_1303576195.699" 
    capture_lex $P3322
    .const 'Sub' $P3299 = "441_1303576195.699" 
    capture_lex $P3299
    .const 'Sub' $P3277 = "440_1303576195.699" 
    capture_lex $P3277
    .const 'Sub' $P3266 = "439_1303576195.699" 
    capture_lex $P3266
    .const 'Sub' $P3229 = "437_1303576195.699" 
    capture_lex $P3229
    .const 'Sub' $P3221 = "436_1303576195.699" 
    capture_lex $P3221
    .const 'Sub' $P3213 = "435_1303576195.699" 
    capture_lex $P3213
    .const 'Sub' $P3199 = "434_1303576195.699" 
    capture_lex $P3199
    .const 'Sub' $P3118 = "432_1303576195.699" 
    capture_lex $P3118
    .const 'Sub' $P3077 = "430_1303576195.699" 
    capture_lex $P3077
    .const 'Sub' $P3010 = "429_1303576195.699" 
    capture_lex $P3010
    .const 'Sub' $P2979 = "428_1303576195.699" 
    capture_lex $P2979
    .const 'Sub' $P2971 = "427_1303576195.699" 
    capture_lex $P2971
    .const 'Sub' $P2930 = "425_1303576195.699" 
    capture_lex $P2930
    .const 'Sub' $P2895 = "423_1303576195.699" 
    capture_lex $P2895
    .const 'Sub' $P2890 = "422_1303576195.699" 
    capture_lex $P2890
    .const 'Sub' $P2885 = "421_1303576195.699" 
    capture_lex $P2885
    .const 'Sub' $P2814 = "418_1303576195.699" 
    capture_lex $P2814
    .const 'Sub' $P2802 = "417_1303576195.699" 
    capture_lex $P2802
    .const 'Sub' $P2737 = "415_1303576195.699" 
    capture_lex $P2737
    .const 'Sub' $P2725 = "414_1303576195.699" 
    capture_lex $P2725
    .const 'Sub' $P2671 = "413_1303576195.699" 
    capture_lex $P2671
    .const 'Sub' $P2658 = "412_1303576195.699" 
    capture_lex $P2658
    .const 'Sub' $P2640 = "411_1303576195.699" 
    capture_lex $P2640
    .const 'Sub' $P2607 = "408_1303576195.699" 
    capture_lex $P2607
    .const 'Sub' $P2599 = "407_1303576195.699" 
    capture_lex $P2599
.annotate 'line', 774
    .const 'Sub' $P2599 = "407_1303576195.699" 
    newclosure $P2606, $P2599
    .lex "xblock_immediate", $P2606
.annotate 'line', 779
    .const 'Sub' $P2607 = "408_1303576195.699" 
    newclosure $P2639, $P2607
    .lex "block_immediate", $P2639
.annotate 'line', 789
    .const 'Sub' $P2640 = "411_1303576195.699" 
    newclosure $P2657, $P2640
    .lex "vivitype", $P2657
.annotate 'line', 808
    .const 'Sub' $P2658 = "412_1303576195.699" 
    newclosure $P2670, $P2658
    .lex "colonpair_str", $P2670
.annotate 'line', 1056
    .const 'Sub' $P2671 = "413_1303576195.699" 
    newclosure $P2724, $P2671
    .lex "push_block_handler", $P2724
.annotate 'line', 1613
    .const 'Sub' $P2725 = "414_1303576195.699" 
    newclosure $P2736, $P2725
    .lex "only_star_block", $P2736
.annotate 'line', 1622
    .const 'Sub' $P2737 = "415_1303576195.699" 
    newclosure $P2801, $P2737
    .lex "attach_multi_signature", $P2801
.annotate 'line', 2096
    .const 'Sub' $P2802 = "417_1303576195.699" 
    newclosure $P2813, $P2802
    .lex "control", $P2813
.annotate 'line', 2115
    .const 'Sub' $P2814 = "418_1303576195.699" 
    newclosure $P2884, $P2814
    .lex "lexical_package_lookup", $P2884
.annotate 'line', 2160
    .const 'Sub' $P2885 = "421_1303576195.699" 
    newclosure $P2889, $P2885
    .lex "is_lexical", $P2889
.annotate 'line', 2166
    .const 'Sub' $P2890 = "422_1303576195.699" 
    newclosure $P2894, $P2890
    .lex "is_package", $P2894
.annotate 'line', 2172
    .const 'Sub' $P2895 = "423_1303576195.699" 
    newclosure $P2929, $P2895
    .lex "is_scope", $P2929
.annotate 'line', 2183
    .const 'Sub' $P2930 = "425_1303576195.699" 
    newclosure $P2962, $P2930
    .lex "find_lex", $P2962
.annotate 'line', 770
    .lex "$?PACKAGE", $P2963
    .lex "$?CLASS", $P2964
.annotate 'line', 772
    new $P2965, "ResizablePMCArray"
    find_lex $P2966, "$?PACKAGE"
    get_who $P2967, $P2966
    set $P2967["@BLOCK"], $P2965
    find_lex $P2968, "xblock_immediate"
    find_lex $P2969, "block_immediate"
    find_lex $P2970, "vivitype"
.annotate 'line', 800
    find_lex $P3009, "colonpair_str"
.annotate 'line', 1049
    find_lex $P3517, "push_block_handler"
.annotate 'line', 1541
    find_lex $P4698, "only_star_block"
    find_lex $P4699, "attach_multi_signature"
.annotate 'line', 2087
    find_lex $P5805, "control"
.annotate 'line', 2109
    find_lex $P5829, "lexical_package_lookup"
    find_lex $P5830, "is_lexical"
    find_lex $P5831, "is_package"
    find_lex $P5832, "is_scope"
    find_lex $P5833, "find_lex"
.annotate 'line', 770
    .return ($P5833)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1456") :outer("406_1303576195.699")
.annotate 'line', 770
    .const 'Sub' $P2598 = "406_1303576195.699" 
    .local pmc block
    set block, $P2598
    .const 'Sub' $P5835 = "563_1303576195.699" 
    capture_lex $P5835
    $P5835()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5834"  :anon :subid("563_1303576195.699") :outer("406_1303576195.699")
.annotate 'line', 770
    nqp_get_sc_object $P5836, "1303576184.274", 3
    .local pmc type_obj
    set type_obj, $P5836
    get_how $P5837, type_obj
    .const 'Sub' $P5838 = "427_1303576195.699" 
    $P5837."add_method"(type_obj, "TOP", $P5838)
    get_how $P5839, type_obj
    .const 'Sub' $P5840 = "428_1303576195.699" 
    $P5839."add_method"(type_obj, "deflongname", $P5840)
    get_how $P5841, type_obj
    .const 'Sub' $P5842 = "429_1303576195.699" 
    $P5841."add_method"(type_obj, "comp_unit", $P5842)
    get_how $P5843, type_obj
    .const 'Sub' $P5844 = "430_1303576195.699" 
    $P5843."add_method"(type_obj, "statementlist", $P5844)
    get_how $P5845, type_obj
    .const 'Sub' $P5846 = "432_1303576195.699" 
    $P5845."add_method"(type_obj, "statement", $P5846)
    get_how $P5847, type_obj
    .const 'Sub' $P5848 = "434_1303576195.699" 
    $P5847."add_method"(type_obj, "xblock", $P5848)
    get_how $P5849, type_obj
    .const 'Sub' $P5850 = "435_1303576195.699" 
    $P5849."add_method"(type_obj, "pblock", $P5850)
    get_how $P5851, type_obj
    .const 'Sub' $P5852 = "436_1303576195.699" 
    $P5851."add_method"(type_obj, "block", $P5852)
    get_how $P5853, type_obj
    .const 'Sub' $P5854 = "437_1303576195.699" 
    $P5853."add_method"(type_obj, "blockoid", $P5854)
    get_how $P5855, type_obj
    .const 'Sub' $P5856 = "439_1303576195.699" 
    $P5855."add_method"(type_obj, "newpad", $P5856)
    get_how $P5857, type_obj
    .const 'Sub' $P5858 = "440_1303576195.699" 
    $P5857."add_method"(type_obj, "outerctx", $P5858)
    get_how $P5859, type_obj
    .const 'Sub' $P5860 = "441_1303576195.699" 
    $P5859."add_method"(type_obj, "GLOBALish", $P5860)
    get_how $P5861, type_obj
    .const 'Sub' $P5862 = "442_1303576195.699" 
    $P5861."add_method"(type_obj, "you_are_here", $P5862)
    get_how $P5863, type_obj
    .const 'Sub' $P5864 = "443_1303576195.699" 
    $P5863."add_method"(type_obj, "statement_control:sym<use>", $P5864)
    get_how $P5865, type_obj
    .const 'Sub' $P5866 = "444_1303576195.699" 
    $P5865."add_method"(type_obj, "statement_control:sym<if>", $P5866)
    get_how $P5867, type_obj
    .const 'Sub' $P5868 = "446_1303576195.699" 
    $P5867."add_method"(type_obj, "statement_control:sym<unless>", $P5868)
    get_how $P5869, type_obj
    .const 'Sub' $P5870 = "447_1303576195.699" 
    $P5869."add_method"(type_obj, "statement_control:sym<while>", $P5870)
    get_how $P5871, type_obj
    .const 'Sub' $P5872 = "448_1303576195.699" 
    $P5871."add_method"(type_obj, "statement_control:sym<repeat>", $P5872)
    get_how $P5873, type_obj
    .const 'Sub' $P5874 = "449_1303576195.699" 
    $P5873."add_method"(type_obj, "statement_control:sym<for>", $P5874)
    get_how $P5875, type_obj
    .const 'Sub' $P5876 = "450_1303576195.699" 
    $P5875."add_method"(type_obj, "statement_control:sym<CATCH>", $P5876)
    get_how $P5877, type_obj
    .const 'Sub' $P5878 = "451_1303576195.699" 
    $P5877."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5878)
    get_how $P5879, type_obj
    .const 'Sub' $P5880 = "452_1303576195.699" 
    $P5879."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5880)
    get_how $P5881, type_obj
    .const 'Sub' $P5882 = "453_1303576195.699" 
    $P5881."add_method"(type_obj, "statement_prefix:sym<try>", $P5882)
    get_how $P5883, type_obj
    .const 'Sub' $P5884 = "454_1303576195.699" 
    $P5883."add_method"(type_obj, "blorst", $P5884)
    get_how $P5885, type_obj
    .const 'Sub' $P5886 = "455_1303576195.699" 
    $P5885."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5886)
    get_how $P5887, type_obj
    .const 'Sub' $P5888 = "456_1303576195.699" 
    $P5887."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5888)
    get_how $P5889, type_obj
    .const 'Sub' $P5890 = "457_1303576195.699" 
    $P5889."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5890)
    get_how $P5891, type_obj
    .const 'Sub' $P5892 = "458_1303576195.699" 
    $P5891."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5892)
    get_how $P5893, type_obj
    .const 'Sub' $P5894 = "459_1303576195.699" 
    $P5893."add_method"(type_obj, "term:sym<fatarrow>", $P5894)
    get_how $P5895, type_obj
    .const 'Sub' $P5896 = "460_1303576195.699" 
    $P5895."add_method"(type_obj, "term:sym<colonpair>", $P5896)
    get_how $P5897, type_obj
    .const 'Sub' $P5898 = "461_1303576195.699" 
    $P5897."add_method"(type_obj, "term:sym<variable>", $P5898)
    get_how $P5899, type_obj
    .const 'Sub' $P5900 = "462_1303576195.699" 
    $P5899."add_method"(type_obj, "term:sym<package_declarator>", $P5900)
    get_how $P5901, type_obj
    .const 'Sub' $P5902 = "463_1303576195.699" 
    $P5901."add_method"(type_obj, "term:sym<scope_declarator>", $P5902)
    get_how $P5903, type_obj
    .const 'Sub' $P5904 = "464_1303576195.699" 
    $P5903."add_method"(type_obj, "term:sym<routine_declarator>", $P5904)
    get_how $P5905, type_obj
    .const 'Sub' $P5906 = "465_1303576195.699" 
    $P5905."add_method"(type_obj, "term:sym<regex_declarator>", $P5906)
    get_how $P5907, type_obj
    .const 'Sub' $P5908 = "466_1303576195.699" 
    $P5907."add_method"(type_obj, "term:sym<statement_prefix>", $P5908)
    get_how $P5909, type_obj
    .const 'Sub' $P5910 = "467_1303576195.699" 
    $P5909."add_method"(type_obj, "term:sym<lambda>", $P5910)
    get_how $P5911, type_obj
    .const 'Sub' $P5912 = "468_1303576195.699" 
    $P5911."add_method"(type_obj, "fatarrow", $P5912)
    get_how $P5913, type_obj
    .const 'Sub' $P5914 = "469_1303576195.699" 
    $P5913."add_method"(type_obj, "colonpair", $P5914)
    get_how $P5915, type_obj
    .const 'Sub' $P5916 = "470_1303576195.699" 
    $P5915."add_method"(type_obj, "variable", $P5916)
    get_how $P5917, type_obj
    .const 'Sub' $P5918 = "472_1303576195.699" 
    $P5917."add_method"(type_obj, "package_declarator:sym<module>", $P5918)
    get_how $P5919, type_obj
    .const 'Sub' $P5920 = "473_1303576195.699" 
    $P5919."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5920)
    get_how $P5921, type_obj
    .const 'Sub' $P5922 = "474_1303576195.699" 
    $P5921."add_method"(type_obj, "package_declarator:sym<class>", $P5922)
    get_how $P5923, type_obj
    .const 'Sub' $P5924 = "475_1303576195.699" 
    $P5923."add_method"(type_obj, "package_declarator:sym<grammar>", $P5924)
    get_how $P5925, type_obj
    .const 'Sub' $P5926 = "476_1303576195.699" 
    $P5925."add_method"(type_obj, "package_declarator:sym<role>", $P5926)
    get_how $P5927, type_obj
    .const 'Sub' $P5928 = "477_1303576195.699" 
    $P5927."add_method"(type_obj, "package_declarator:sym<native>", $P5928)
    get_how $P5929, type_obj
    .const 'Sub' $P5930 = "478_1303576195.699" 
    $P5929."add_method"(type_obj, "package_def", $P5930)
    get_how $P5931, type_obj
    .const 'Sub' $P5932 = "481_1303576195.699" 
    $P5931."add_method"(type_obj, "scope_declarator:sym<my>", $P5932)
    get_how $P5933, type_obj
    .const 'Sub' $P5934 = "482_1303576195.699" 
    $P5933."add_method"(type_obj, "scope_declarator:sym<our>", $P5934)
    get_how $P5935, type_obj
    .const 'Sub' $P5936 = "483_1303576195.699" 
    $P5935."add_method"(type_obj, "scope_declarator:sym<has>", $P5936)
    get_how $P5937, type_obj
    .const 'Sub' $P5938 = "484_1303576195.699" 
    $P5937."add_method"(type_obj, "scoped", $P5938)
    get_how $P5939, type_obj
    .const 'Sub' $P5940 = "485_1303576195.699" 
    $P5939."add_method"(type_obj, "declarator", $P5940)
    get_how $P5941, type_obj
    .const 'Sub' $P5942 = "486_1303576195.699" 
    $P5941."add_method"(type_obj, "multi_declarator:sym<multi>", $P5942)
    get_how $P5943, type_obj
    .const 'Sub' $P5944 = "487_1303576195.699" 
    $P5943."add_method"(type_obj, "multi_declarator:sym<proto>", $P5944)
    get_how $P5945, type_obj
    .const 'Sub' $P5946 = "488_1303576195.699" 
    $P5945."add_method"(type_obj, "multi_declarator:sym<null>", $P5946)
    get_how $P5947, type_obj
    .const 'Sub' $P5948 = "489_1303576195.699" 
    $P5947."add_method"(type_obj, "variable_declarator", $P5948)
    get_how $P5949, type_obj
    .const 'Sub' $P5950 = "492_1303576195.699" 
    $P5949."add_method"(type_obj, "routine_declarator:sym<sub>", $P5950)
    get_how $P5951, type_obj
    .const 'Sub' $P5952 = "493_1303576195.699" 
    $P5951."add_method"(type_obj, "routine_declarator:sym<method>", $P5952)
    get_how $P5953, type_obj
    .const 'Sub' $P5954 = "494_1303576195.699" 
    $P5953."add_method"(type_obj, "routine_def", $P5954)
    get_how $P5955, type_obj
    .const 'Sub' $P5956 = "501_1303576195.699" 
    $P5955."add_method"(type_obj, "method_def", $P5956)
    get_how $P5957, type_obj
    .const 'Sub' $P5958 = "504_1303576195.699" 
    $P5957."add_method"(type_obj, "signature", $P5958)
    get_how $P5959, type_obj
    .const 'Sub' $P5960 = "507_1303576195.699" 
    $P5959."add_method"(type_obj, "parameter", $P5960)
    get_how $P5961, type_obj
    .const 'Sub' $P5962 = "508_1303576195.699" 
    $P5961."add_method"(type_obj, "param_var", $P5962)
    get_how $P5963, type_obj
    .const 'Sub' $P5964 = "509_1303576195.699" 
    $P5963."add_method"(type_obj, "named_param", $P5964)
    get_how $P5965, type_obj
    .const 'Sub' $P5966 = "510_1303576195.699" 
    $P5965."add_method"(type_obj, "typename", $P5966)
    get_how $P5967, type_obj
    .const 'Sub' $P5968 = "511_1303576195.699" 
    $P5967."add_method"(type_obj, "trait", $P5968)
    get_how $P5969, type_obj
    .const 'Sub' $P5970 = "512_1303576195.699" 
    $P5969."add_method"(type_obj, "trait_mod:sym<is>", $P5970)
    get_how $P5971, type_obj
    .const 'Sub' $P5972 = "514_1303576195.699" 
    $P5971."add_method"(type_obj, "regex_declarator", $P5972)
    get_how $P5973, type_obj
    .const 'Sub' $P5974 = "518_1303576195.699" 
    $P5973."add_method"(type_obj, "dotty", $P5974)
    get_how $P5975, type_obj
    .const 'Sub' $P5976 = "519_1303576195.699" 
    $P5975."add_method"(type_obj, "term:sym<self>", $P5976)
    get_how $P5977, type_obj
    .const 'Sub' $P5978 = "520_1303576195.699" 
    $P5977."add_method"(type_obj, "term:sym<identifier>", $P5978)
    get_how $P5979, type_obj
    .const 'Sub' $P5980 = "521_1303576195.699" 
    $P5979."add_method"(type_obj, "term:sym<name>", $P5980)
    get_how $P5981, type_obj
    .const 'Sub' $P5982 = "523_1303576195.699" 
    $P5981."add_method"(type_obj, "term:sym<pir::op>", $P5982)
    get_how $P5983, type_obj
    .const 'Sub' $P5984 = "524_1303576195.699" 
    $P5983."add_method"(type_obj, "term:sym<onlystar>", $P5984)
    get_how $P5985, type_obj
    .const 'Sub' $P5986 = "525_1303576195.699" 
    $P5985."add_method"(type_obj, "args", $P5986)
    get_how $P5987, type_obj
    .const 'Sub' $P5988 = "526_1303576195.699" 
    $P5987."add_method"(type_obj, "arglist", $P5988)
    get_how $P5989, type_obj
    .const 'Sub' $P5990 = "529_1303576195.699" 
    $P5989."add_method"(type_obj, "term:sym<multi_declarator>", $P5990)
    get_how $P5991, type_obj
    .const 'Sub' $P5992 = "530_1303576195.699" 
    $P5991."add_method"(type_obj, "term:sym<value>", $P5992)
    get_how $P5993, type_obj
    .const 'Sub' $P5994 = "531_1303576195.699" 
    $P5993."add_method"(type_obj, "circumfix:sym<( )>", $P5994)
    get_how $P5995, type_obj
    .const 'Sub' $P5996 = "532_1303576195.699" 
    $P5995."add_method"(type_obj, "circumfix:sym<[ ]>", $P5996)
    get_how $P5997, type_obj
    .const 'Sub' $P5998 = "533_1303576195.699" 
    $P5997."add_method"(type_obj, "circumfix:sym<ang>", $P5998)
    get_how $P5999, type_obj
    .const 'Sub' $P6000 = "534_1303576195.699" 
    $P5999."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P6000)
    get_how $P6001, type_obj
    .const 'Sub' $P6002 = "535_1303576195.699" 
    $P6001."add_method"(type_obj, "circumfix:sym<{ }>", $P6002)
    get_how $P6003, type_obj
    .const 'Sub' $P6004 = "537_1303576195.699" 
    $P6003."add_method"(type_obj, "circumfix:sym<sigil>", $P6004)
    get_how $P6005, type_obj
    .const 'Sub' $P6006 = "538_1303576195.699" 
    $P6005."add_method"(type_obj, "semilist", $P6006)
    get_how $P6007, type_obj
    .const 'Sub' $P6008 = "539_1303576195.699" 
    $P6007."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P6008)
    get_how $P6009, type_obj
    .const 'Sub' $P6010 = "540_1303576195.699" 
    $P6009."add_method"(type_obj, "postcircumfix:sym<{ }>", $P6010)
    get_how $P6011, type_obj
    .const 'Sub' $P6012 = "541_1303576195.699" 
    $P6011."add_method"(type_obj, "postcircumfix:sym<ang>", $P6012)
    get_how $P6013, type_obj
    .const 'Sub' $P6014 = "542_1303576195.699" 
    $P6013."add_method"(type_obj, "postcircumfix:sym<( )>", $P6014)
    get_how $P6015, type_obj
    .const 'Sub' $P6016 = "543_1303576195.699" 
    $P6015."add_method"(type_obj, "value", $P6016)
    get_how $P6017, type_obj
    .const 'Sub' $P6018 = "544_1303576195.699" 
    $P6017."add_method"(type_obj, "number", $P6018)
    get_how $P6019, type_obj
    .const 'Sub' $P6020 = "545_1303576195.699" 
    $P6019."add_method"(type_obj, "quote:sym<apos>", $P6020)
    get_how $P6021, type_obj
    .const 'Sub' $P6022 = "546_1303576195.699" 
    $P6021."add_method"(type_obj, "quote:sym<dblq>", $P6022)
    get_how $P6023, type_obj
    .const 'Sub' $P6024 = "547_1303576195.699" 
    $P6023."add_method"(type_obj, "quote:sym<qq>", $P6024)
    get_how $P6025, type_obj
    .const 'Sub' $P6026 = "548_1303576195.699" 
    $P6025."add_method"(type_obj, "quote:sym<q>", $P6026)
    get_how $P6027, type_obj
    .const 'Sub' $P6028 = "549_1303576195.699" 
    $P6027."add_method"(type_obj, "quote:sym<Q>", $P6028)
    get_how $P6029, type_obj
    .const 'Sub' $P6030 = "550_1303576195.699" 
    $P6029."add_method"(type_obj, "quote:sym<Q:PIR>", $P6030)
    get_how $P6031, type_obj
    .const 'Sub' $P6032 = "551_1303576195.699" 
    $P6031."add_method"(type_obj, "quote:sym</ />", $P6032)
    get_how $P6033, type_obj
    .const 'Sub' $P6034 = "552_1303576195.699" 
    $P6033."add_method"(type_obj, "quote_escape:sym<$>", $P6034)
    get_how $P6035, type_obj
    .const 'Sub' $P6036 = "553_1303576195.699" 
    $P6035."add_method"(type_obj, "quote_escape:sym<{ }>", $P6036)
    get_how $P6037, type_obj
    .const 'Sub' $P6038 = "554_1303576195.699" 
    $P6037."add_method"(type_obj, "quote_escape:sym<esc>", $P6038)
    get_how $P6039, type_obj
    .const 'Sub' $P6040 = "555_1303576195.699" 
    $P6039."add_method"(type_obj, "postfix:sym<.>", $P6040)
    get_how $P6041, type_obj
    .const 'Sub' $P6042 = "556_1303576195.699" 
    $P6041."add_method"(type_obj, "postfix:sym<++>", $P6042)
    get_how $P6043, type_obj
    .const 'Sub' $P6044 = "557_1303576195.699" 
    $P6043."add_method"(type_obj, "postfix:sym<-->", $P6044)
    get_how $P6045, type_obj
    .const 'Sub' $P6046 = "558_1303576195.699" 
    $P6045."add_method"(type_obj, "prefix:sym<make>", $P6046)
    get_how $P6047, type_obj
    .const 'Sub' $P6048 = "559_1303576195.699" 
    $P6047."add_method"(type_obj, "term:sym<next>", $P6048)
    get_how $P6049, type_obj
    .const 'Sub' $P6050 = "560_1303576195.699" 
    $P6049."add_method"(type_obj, "term:sym<last>", $P6050)
    get_how $P6051, type_obj
    .const 'Sub' $P6052 = "561_1303576195.699" 
    $P6051."add_method"(type_obj, "term:sym<redo>", $P6052)
    get_how $P6053, type_obj
    .const 'Sub' $P6054 = "562_1303576195.699" 
    $P6053."add_method"(type_obj, "infix:sym<~~>", $P6054)
    get_how $P6055, type_obj
    get_hll_global $P6056, ["HLL"], "Actions"
    $P6055."add_parent"(type_obj, $P6056)
    get_how $P6057, type_obj
    $P6058 = $P6057."compose"(type_obj)
    .return ($P6058)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2600
.annotate 'line', 774
    .lex "$xblock", param_2600
.annotate 'line', 775
    find_lex $P2601, "$xblock"
    unless_null $P2601, vivify_1457
    $P2601 = root_new ['parrot';'ResizablePMCArray']
  vivify_1457:
    set $P2602, $P2601[1]
    unless_null $P2602, vivify_1458
    new $P2602, "Undef"
  vivify_1458:
    $P2603 = "block_immediate"($P2602)
    find_lex $P2604, "$xblock"
    unless_null $P2604, vivify_1459
    $P2604 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2604
  vivify_1459:
    set $P2604[1], $P2603
    find_lex $P2605, "$xblock"
    unless_null $P2605, vivify_1460
    new $P2605, "Undef"
  vivify_1460:
.annotate 'line', 774
    .return ($P2605)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2608
.annotate 'line', 779
    .const 'Sub' $P2618 = "409_1303576195.699" 
    capture_lex $P2618
    .lex "$block", param_2608
.annotate 'line', 780
    find_lex $P2609, "$block"
    unless_null $P2609, vivify_1461
    new $P2609, "Undef"
  vivify_1461:
    $P2609."blocktype"("immediate")
.annotate 'line', 781
    find_lex $P2613, "$block"
    unless_null $P2613, vivify_1462
    new $P2613, "Undef"
  vivify_1462:
    $P2614 = $P2613."symtable"()
    unless $P2614, unless_2612
    set $P2611, $P2614
    goto unless_2612_end
  unless_2612:
    find_lex $P2615, "$block"
    unless_null $P2615, vivify_1463
    new $P2615, "Undef"
  vivify_1463:
    $P2616 = $P2615."handlers"()
    set $P2611, $P2616
  unless_2612_end:
    if $P2611, unless_2610_end
    .const 'Sub' $P2618 = "409_1303576195.699" 
    capture_lex $P2618
    $P2618()
  unless_2610_end:
    find_lex $P2638, "$block"
    unless_null $P2638, vivify_1470
    new $P2638, "Undef"
  vivify_1470:
.annotate 'line', 779
    .return ($P2638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2617"  :anon :subid("409_1303576195.699") :outer("408_1303576195.699")
.annotate 'line', 781
    .const 'Sub' $P2629 = "410_1303576195.699" 
    capture_lex $P2629
.annotate 'line', 782
    new $P2619, "Undef"
    .lex "$stmts", $P2619
    get_hll_global $P2620, ["PAST"], "Stmts"
    find_lex $P2621, "$block"
    unless_null $P2621, vivify_1464
    new $P2621, "Undef"
  vivify_1464:
    $P2622 = $P2620."new"($P2621 :named("node"))
    store_lex "$stmts", $P2622
.annotate 'line', 783
    find_lex $P2624, "$block"
    unless_null $P2624, vivify_1465
    new $P2624, "Undef"
  vivify_1465:
    $P2625 = $P2624."list"()
    defined $I2626, $P2625
    unless $I2626, for_undef_1466
    iter $P2623, $P2625
    new $P2635, 'ExceptionHandler'
    set_label $P2635, loop2634_handler
    $P2635."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2635
  loop2634_test:
    unless $P2623, loop2634_done
    shift $P2627, $P2623
  loop2634_redo:
    .const 'Sub' $P2629 = "410_1303576195.699" 
    capture_lex $P2629
    $P2629($P2627)
  loop2634_next:
    goto loop2634_test
  loop2634_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2636, exception, 'type'
    eq $P2636, .CONTROL_LOOP_NEXT, loop2634_next
    eq $P2636, .CONTROL_LOOP_REDO, loop2634_redo
  loop2634_done:
    pop_eh 
  for_undef_1466:
.annotate 'line', 784
    find_lex $P2637, "$stmts"
    unless_null $P2637, vivify_1469
    new $P2637, "Undef"
  vivify_1469:
    store_lex "$block", $P2637
.annotate 'line', 781
    .return ($P2637)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2628"  :anon :subid("410_1303576195.699") :outer("409_1303576195.699")
    .param pmc param_2630
.annotate 'line', 783
    .lex "$_", param_2630
    find_lex $P2631, "$stmts"
    unless_null $P2631, vivify_1467
    new $P2631, "Undef"
  vivify_1467:
    find_lex $P2632, "$_"
    unless_null $P2632, vivify_1468
    new $P2632, "Undef"
  vivify_1468:
    $P2633 = $P2631."push"($P2632)
    .return ($P2633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2641
.annotate 'line', 789
    .lex "$sigil", param_2641
.annotate 'line', 790
    find_lex $P2644, "$sigil"
    unless_null $P2644, vivify_1471
    new $P2644, "Undef"
  vivify_1471:
    set $S2645, $P2644
    iseq $I2646, $S2645, "%"
    if $I2646, if_2643
.annotate 'line', 792
    find_lex $P2651, "$sigil"
    unless_null $P2651, vivify_1472
    new $P2651, "Undef"
  vivify_1472:
    set $S2652, $P2651
    iseq $I2653, $S2652, "@"
    if $I2653, if_2650
    new $P2656, "String"
    assign $P2656, "Undef"
    set $P2649, $P2656
    goto if_2650_end
  if_2650:
.annotate 'line', 793
    get_hll_global $P2654, ["PAST"], "Op"
    $P2655 = $P2654."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2649, $P2655
  if_2650_end:
    set $P2642, $P2649
.annotate 'line', 790
    goto if_2643_end
  if_2643:
.annotate 'line', 791
    get_hll_global $P2647, ["PAST"], "Op"
    $P2648 = $P2647."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2642, $P2648
  if_2643_end:
.annotate 'line', 789
    .return ($P2642)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2659
.annotate 'line', 808
    .lex "$ast", param_2659
.annotate 'line', 809
    get_hll_global $P2662, ["PAST"], "Op"
    find_lex $P2663, "$ast"
    unless_null $P2663, vivify_1473
    new $P2663, "Undef"
  vivify_1473:
    $P2664 = $P2662."ACCEPTS"($P2663)
    if $P2664, if_2661
.annotate 'line', 811
    find_lex $P2668, "$ast"
    unless_null $P2668, vivify_1474
    new $P2668, "Undef"
  vivify_1474:
    $P2669 = $P2668."value"()
    set $P2660, $P2669
.annotate 'line', 809
    goto if_2661_end
  if_2661:
.annotate 'line', 810
    find_lex $P2665, "$ast"
    unless_null $P2665, vivify_1475
    new $P2665, "Undef"
  vivify_1475:
    $P2666 = $P2665."list"()
    join $S2667, " ", $P2666
    new $P2660, 'String'
    set $P2660, $S2667
  if_2661_end:
.annotate 'line', 808
    .return ($P2660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("413_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2672
    .param pmc param_2673
.annotate 'line', 1056
    .lex "$/", param_2672
    .lex "$block", param_2673
.annotate 'line', 1057
    find_lex $P2675, "$?PACKAGE"
    get_who $P2676, $P2675
    set $P2677, $P2676["@BLOCK"]
    unless_null $P2677, vivify_1476
    $P2677 = root_new ['parrot';'ResizablePMCArray']
  vivify_1476:
    set $P2678, $P2677[0]
    unless_null $P2678, vivify_1477
    new $P2678, "Undef"
  vivify_1477:
    $P2679 = $P2678."handlers"()
    if $P2679, unless_2674_end
.annotate 'line', 1058
    find_lex $P2680, "$?PACKAGE"
    get_who $P2681, $P2680
    set $P2682, $P2681["@BLOCK"]
    unless_null $P2682, vivify_1478
    $P2682 = root_new ['parrot';'ResizablePMCArray']
  vivify_1478:
    set $P2683, $P2682[0]
    unless_null $P2683, vivify_1479
    new $P2683, "Undef"
  vivify_1479:
    new $P2684, "ResizablePMCArray"
    $P2683."handlers"($P2684)
  unless_2674_end:
.annotate 'line', 1060
    find_lex $P2686, "$block"
    unless_null $P2686, vivify_1480
    new $P2686, "Undef"
  vivify_1480:
    $P2687 = $P2686."arity"()
    if $P2687, unless_2685_end
.annotate 'line', 1061
    find_lex $P2688, "$block"
    unless_null $P2688, vivify_1481
    new $P2688, "Undef"
  vivify_1481:
.annotate 'line', 1062
    get_hll_global $P2689, ["PAST"], "Op"
.annotate 'line', 1063
    get_hll_global $P2690, ["PAST"], "Var"
    $P2691 = $P2690."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1064
    get_hll_global $P2692, ["PAST"], "Var"
    $P2693 = $P2692."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2694 = $P2689."new"($P2691, $P2693, "bind" :named("pasttype"))
.annotate 'line', 1062
    $P2688."unshift"($P2694)
.annotate 'line', 1067
    find_lex $P2695, "$block"
    unless_null $P2695, vivify_1482
    new $P2695, "Undef"
  vivify_1482:
    get_hll_global $P2696, ["PAST"], "Var"
    $P2697 = $P2696."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2695."unshift"($P2697)
.annotate 'line', 1068
    find_lex $P2698, "$block"
    unless_null $P2698, vivify_1483
    new $P2698, "Undef"
  vivify_1483:
    $P2698."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1069
    find_lex $P2699, "$block"
    unless_null $P2699, vivify_1484
    new $P2699, "Undef"
  vivify_1484:
    $P2699."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1070
    find_lex $P2700, "$block"
    unless_null $P2700, vivify_1485
    new $P2700, "Undef"
  vivify_1485:
    $P2700."arity"(1)
  unless_2685_end:
.annotate 'line', 1072
    find_lex $P2701, "$block"
    unless_null $P2701, vivify_1486
    new $P2701, "Undef"
  vivify_1486:
    $P2701."blocktype"("declaration")
.annotate 'line', 1073
    find_lex $P2702, "$?PACKAGE"
    get_who $P2703, $P2702
    set $P2704, $P2703["@BLOCK"]
    unless_null $P2704, vivify_1487
    $P2704 = root_new ['parrot';'ResizablePMCArray']
  vivify_1487:
    set $P2705, $P2704[0]
    unless_null $P2705, vivify_1488
    new $P2705, "Undef"
  vivify_1488:
    $P2706 = $P2705."handlers"()
.annotate 'line', 1074
    get_hll_global $P2707, ["PAST"], "Control"
    find_lex $P2708, "$/"
    unless_null $P2708, vivify_1489
    new $P2708, "Undef"
  vivify_1489:
.annotate 'line', 1076
    get_hll_global $P2709, ["PAST"], "Stmts"
.annotate 'line', 1077
    get_hll_global $P2710, ["PAST"], "Op"
    find_lex $P2711, "$block"
    unless_null $P2711, vivify_1490
    new $P2711, "Undef"
  vivify_1490:
.annotate 'line', 1079
    get_hll_global $P2712, ["PAST"], "Var"
    $P2713 = $P2712."new"("register" :named("scope"), "exception" :named("name"))
    $P2714 = $P2710."new"($P2711, $P2713, "call" :named("pasttype"))
.annotate 'line', 1081
    get_hll_global $P2715, ["PAST"], "Op"
.annotate 'line', 1082
    get_hll_global $P2716, ["PAST"], "Var"
.annotate 'line', 1083
    get_hll_global $P2717, ["PAST"], "Var"
    $P2718 = $P2717."new"("register" :named("scope"), "exception" :named("name"))
    $P2719 = $P2716."new"($P2718, "handled", "keyed" :named("scope"))
.annotate 'line', 1082
    $P2720 = $P2715."new"($P2719, 1, "bind" :named("pasttype"))
.annotate 'line', 1081
    $P2721 = $P2709."new"($P2714, $P2720)
.annotate 'line', 1076
    $P2722 = $P2707."new"($P2721, $P2708 :named("node"))
.annotate 'line', 1074
    $P2723 = $P2706."unshift"($P2722)
.annotate 'line', 1056
    .return ($P2723)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("414_1303576195.699") :outer("406_1303576195.699")
.annotate 'line', 1614
    new $P2726, "Undef"
    .lex "$past", $P2726
    find_lex $P2727, "$?PACKAGE"
    get_who $P2728, $P2727
    set $P2729, $P2728["@BLOCK"]
    unless_null $P2729, vivify_1491
    $P2729 = root_new ['parrot';'ResizablePMCArray']
  vivify_1491:
    $P2730 = $P2729."shift"()
    store_lex "$past", $P2730
.annotate 'line', 1615
    find_lex $P2731, "$past"
    unless_null $P2731, vivify_1492
    new $P2731, "Undef"
  vivify_1492:
    $P2731."closure"(1)
.annotate 'line', 1616
    find_lex $P2732, "$past"
    unless_null $P2732, vivify_1493
    new $P2732, "Undef"
  vivify_1493:
    get_hll_global $P2733, ["PAST"], "Op"
    $P2734 = $P2733."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2732."push"($P2734)
    find_lex $P2735, "$past"
    unless_null $P2735, vivify_1494
    new $P2735, "Undef"
  vivify_1494:
.annotate 'line', 1613
    .return ($P2735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("415_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2738
.annotate 'line', 1622
    .const 'Sub' $P2752 = "416_1303576195.699" 
    capture_lex $P2752
    .lex "$routine", param_2738
.annotate 'line', 1626
    new $P2739, "Undef"
    .lex "$types", $P2739
.annotate 'line', 1627
    new $P2740, "Undef"
    .lex "$definednesses", $P2740
.annotate 'line', 1626
    get_hll_global $P2741, ["PAST"], "Op"
    $P2742 = $P2741."new"("list" :named("pasttype"))
    store_lex "$types", $P2742
.annotate 'line', 1627
    get_hll_global $P2743, ["PAST"], "Op"
    $P2744 = $P2743."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2744
.annotate 'line', 1628
    find_lex $P2746, "$routine"
    unless_null $P2746, vivify_1495
    $P2746 = root_new ['parrot';'ResizablePMCArray']
  vivify_1495:
    set $P2747, $P2746[0]
    unless_null $P2747, vivify_1496
    new $P2747, "Undef"
  vivify_1496:
    $P2748 = $P2747."list"()
    defined $I2749, $P2748
    unless $I2749, for_undef_1497
    iter $P2745, $P2748
    new $P2790, 'ExceptionHandler'
    set_label $P2790, loop2789_handler
    $P2790."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2790
  loop2789_test:
    unless $P2745, loop2789_done
    shift $P2750, $P2745
  loop2789_redo:
    .const 'Sub' $P2752 = "416_1303576195.699" 
    capture_lex $P2752
    $P2752($P2750)
  loop2789_next:
    goto loop2789_test
  loop2789_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2791, exception, 'type'
    eq $P2791, .CONTROL_LOOP_NEXT, loop2789_next
    eq $P2791, .CONTROL_LOOP_REDO, loop2789_redo
  loop2789_done:
    pop_eh 
  for_undef_1497:
.annotate 'line', 1635
    find_lex $P2792, "$routine"
    unless_null $P2792, vivify_1507
    new $P2792, "Undef"
  vivify_1507:
    $P2793 = $P2792."loadinit"()
    get_hll_global $P2794, ["PAST"], "Op"
.annotate 'line', 1636
    get_hll_global $P2795, ["PAST"], "Var"
    $P2796 = $P2795."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2797, "$types"
    unless_null $P2797, vivify_1508
    new $P2797, "Undef"
  vivify_1508:
    find_lex $P2798, "$definednesses"
    unless_null $P2798, vivify_1509
    new $P2798, "Undef"
  vivify_1509:
    $P2799 = $P2794."new"($P2796, $P2797, $P2798, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1635
    $P2800 = $P2793."push"($P2799)
.annotate 'line', 1622
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2751"  :anon :subid("416_1303576195.699") :outer("415_1303576195.699")
    .param pmc param_2753
.annotate 'line', 1628
    .lex "$_", param_2753
.annotate 'line', 1629
    get_hll_global $P2758, ["PAST"], "Var"
    find_lex $P2759, "$_"
    unless_null $P2759, vivify_1498
    new $P2759, "Undef"
  vivify_1498:
    $P2760 = $P2758."ACCEPTS"($P2759)
    if $P2760, if_2757
    set $P2756, $P2760
    goto if_2757_end
  if_2757:
    find_lex $P2761, "$_"
    unless_null $P2761, vivify_1499
    new $P2761, "Undef"
  vivify_1499:
    $S2762 = $P2761."scope"()
    iseq $I2763, $S2762, "parameter"
    new $P2756, 'Integer'
    set $P2756, $I2763
  if_2757_end:
    if $P2756, if_2755
    set $P2754, $P2756
    goto if_2755_end
  if_2755:
.annotate 'line', 1630
    find_lex $P2764, "$types"
    unless_null $P2764, vivify_1500
    new $P2764, "Undef"
  vivify_1500:
    find_lex $P2766, "$_"
    unless_null $P2766, vivify_1501
    new $P2766, "Undef"
  vivify_1501:
    $P2767 = $P2766."multitype"()
    set $P2765, $P2767
    defined $I2769, $P2765
    if $I2769, default_2768
    get_hll_global $P2770, ["PAST"], "Op"
    $P2771 = $P2770."new"("null P" :named("pirop"))
    set $P2765, $P2771
  default_2768:
    $P2764."push"($P2765)
.annotate 'line', 1631
    find_lex $P2772, "$definednesses"
    unless_null $P2772, vivify_1502
    new $P2772, "Undef"
  vivify_1502:
    find_lex $P2775, "$_"
    unless_null $P2775, vivify_1503
    $P2775 = root_new ['parrot';'Hash']
  vivify_1503:
    set $P2776, $P2775["definedness"]
    unless_null $P2776, vivify_1504
    new $P2776, "Undef"
  vivify_1504:
    set $S2777, $P2776
    iseq $I2778, $S2777, "D"
    if $I2778, if_2774
.annotate 'line', 1632
    find_lex $P2782, "$_"
    unless_null $P2782, vivify_1505
    $P2782 = root_new ['parrot';'Hash']
  vivify_1505:
    set $P2783, $P2782["definedness"]
    unless_null $P2783, vivify_1506
    new $P2783, "Undef"
  vivify_1506:
    set $S2784, $P2783
    iseq $I2785, $S2784, "U"
    if $I2785, if_2781
    new $P2787, "Integer"
    assign $P2787, 0
    set $P2780, $P2787
    goto if_2781_end
  if_2781:
    new $P2786, "Integer"
    assign $P2786, 2
    set $P2780, $P2786
  if_2781_end:
    set $P2773, $P2780
.annotate 'line', 1631
    goto if_2774_end
  if_2774:
    new $P2779, "Integer"
    assign $P2779, 1
    set $P2773, $P2779
  if_2774_end:
    $P2788 = $P2772."push"($P2773)
.annotate 'line', 1629
    set $P2754, $P2788
  if_2755_end:
.annotate 'line', 1628
    .return ($P2754)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("417_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2803
    .param pmc param_2804
.annotate 'line', 2096
    .lex "$/", param_2803
    .lex "$type", param_2804
.annotate 'line', 2097
    find_lex $P2805, "$/"
    get_hll_global $P2806, ["PAST"], "Op"
    find_lex $P2807, "$/"
    unless_null $P2807, vivify_1510
    new $P2807, "Undef"
  vivify_1510:
.annotate 'line', 2101
    get_hll_global $P2808, ["PAST"], "Val"
    find_lex $P2809, "$type"
    unless_null $P2809, vivify_1511
    new $P2809, "Undef"
  vivify_1511:
    $P2810 = $P2808."new"($P2809 :named("value"), "!except_types" :named("returns"))
    $P2811 = $P2806."new"(0, $P2810, $P2807 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2097
    $P2812 = $P2805."!make"($P2811)
.annotate 'line', 2096
    .return ($P2812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("418_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'line', 2115
    .const 'Sub' $P2847 = "419_1303576195.699" 
    capture_lex $P2847
    new $P2816, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2816, control_2815
    push_eh $P2816
    .lex "@name", param_2817
    .lex "$/", param_2818
.annotate 'line', 2121
    new $P2819, "Undef"
    .lex "$final_name", $P2819
.annotate 'line', 2122
    new $P2820, "Undef"
    .lex "$lookup", $P2820
.annotate 'line', 2117
    find_lex $P2822, "@name"
    unless_null $P2822, vivify_1512
    $P2822 = root_new ['parrot';'ResizablePMCArray']
  vivify_1512:
    set $N2823, $P2822
    iseq $I2824, $N2823, 0.0
    unless $I2824, if_2821_end
    find_lex $P2825, "$/"
    unless_null $P2825, vivify_1513
    new $P2825, "Undef"
  vivify_1513:
    $P2826 = $P2825."CURSOR"()
    $P2826."panic"("Cannot compile empty name")
  if_2821_end:
.annotate 'line', 2121
    find_lex $P2827, "@name"
    unless_null $P2827, vivify_1514
    $P2827 = root_new ['parrot';'ResizablePMCArray']
  vivify_1514:
    $P2828 = $P2827."pop"()
    store_lex "$final_name", $P2828
.annotate 'line', 2122
    get_hll_global $P2829, ["PAST"], "Var"
    find_lex $P2830, "$final_name"
    unless_null $P2830, vivify_1515
    new $P2830, "Undef"
  vivify_1515:
    set $S2831, $P2830
    $P2832 = $P2829."new"($S2831, "keyed" :named("scope"))
    store_lex "$lookup", $P2832
.annotate 'line', 2126
    find_lex $P2834, "@name"
    unless_null $P2834, vivify_1516
    $P2834 = root_new ['parrot';'ResizablePMCArray']
  vivify_1516:
    set $N2835, $P2834
    iseq $I2836, $N2835, 0.0
    if $I2836, if_2833
.annotate 'line', 2135
    find_lex $P2843, "@name"
    unless_null $P2843, vivify_1517
    $P2843 = root_new ['parrot';'ResizablePMCArray']
  vivify_1517:
    set $P2844, $P2843[0]
    unless_null $P2844, vivify_1518
    new $P2844, "Undef"
  vivify_1518:
    $P2845 = "is_lexical"($P2844)
    if $P2845, if_2842
.annotate 'line', 2149
    find_lex $P2873, "$lookup"
    unless_null $P2873, vivify_1519
    new $P2873, "Undef"
  vivify_1519:
    get_hll_global $P2874, ["PAST"], "Op"
.annotate 'line', 2151
    get_hll_global $P2875, ["PAST"], "Var"
    find_lex $P2876, "@name"
    unless_null $P2876, vivify_1520
    $P2876 = root_new ['parrot';'ResizablePMCArray']
  vivify_1520:
    $P2877 = $P2876."pop"()
    find_lex $P2878, "@name"
    unless_null $P2878, vivify_1521
    $P2878 = root_new ['parrot';'ResizablePMCArray']
  vivify_1521:
    $P2879 = $P2875."new"($P2877 :named("name"), $P2878 :named("namespace"), "package" :named("scope"))
    $P2880 = $P2874."new"($P2879, "get_who PP" :named("pirop"))
.annotate 'line', 2149
    $P2873."unshift"($P2880)
.annotate 'line', 2144
    goto if_2842_end
  if_2842:
.annotate 'line', 2135
    .const 'Sub' $P2847 = "419_1303576195.699" 
    capture_lex $P2847
    $P2847()
  if_2842_end:
    goto if_2833_end
  if_2833:
.annotate 'line', 2127
    find_lex $P2837, "$lookup"
    unless_null $P2837, vivify_1529
    new $P2837, "Undef"
  vivify_1529:
    get_hll_global $P2838, ["PAST"], "Op"
.annotate 'line', 2129
    get_hll_global $P2839, ["PAST"], "Var"
    $P2840 = $P2839."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2841 = $P2838."new"($P2840, "get_who PP" :named("pirop"))
.annotate 'line', 2127
    $P2837."unshift"($P2841)
  if_2833_end:
.annotate 'line', 2155
    new $P2881, "Exception"
    set $P2881['type'], .CONTROL_RETURN
    find_lex $P2882, "$lookup"
    unless_null $P2882, vivify_1530
    new $P2882, "Undef"
  vivify_1530:
    setattribute $P2881, 'payload', $P2882
    throw $P2881
.annotate 'line', 2115
    .return ()
  control_2815:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2883, exception, "payload"
    .return ($P2883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2846"  :anon :subid("419_1303576195.699") :outer("418_1303576195.699")
.annotate 'line', 2135
    .const 'Sub' $P2858 = "420_1303576195.699" 
    capture_lex $P2858
.annotate 'line', 2136
    new $P2848, "Undef"
    .lex "$path", $P2848
    get_hll_global $P2849, ["PAST"], "Var"
    find_lex $P2850, "@name"
    unless_null $P2850, vivify_1522
    $P2850 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    $P2851 = $P2850."shift"()
    $P2852 = $P2849."new"($P2851 :named("name"), "lexical" :named("scope"))
    store_lex "$path", $P2852
.annotate 'line', 2137
    find_lex $P2854, "@name"
    unless_null $P2854, vivify_1523
    $P2854 = root_new ['parrot';'ResizablePMCArray']
  vivify_1523:
    defined $I2855, $P2854
    unless $I2855, for_undef_1524
    iter $P2853, $P2854
    new $P2866, 'ExceptionHandler'
    set_label $P2866, loop2865_handler
    $P2866."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2866
  loop2865_test:
    unless $P2853, loop2865_done
    shift $P2856, $P2853
  loop2865_redo:
    .const 'Sub' $P2858 = "420_1303576195.699" 
    capture_lex $P2858
    $P2858($P2856)
  loop2865_next:
    goto loop2865_test
  loop2865_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2867, exception, 'type'
    eq $P2867, .CONTROL_LOOP_NEXT, loop2865_next
    eq $P2867, .CONTROL_LOOP_REDO, loop2865_redo
  loop2865_done:
    pop_eh 
  for_undef_1524:
.annotate 'line', 2142
    find_lex $P2868, "$lookup"
    unless_null $P2868, vivify_1527
    new $P2868, "Undef"
  vivify_1527:
    get_hll_global $P2869, ["PAST"], "Op"
    find_lex $P2870, "$path"
    unless_null $P2870, vivify_1528
    new $P2870, "Undef"
  vivify_1528:
    $P2871 = $P2869."new"($P2870, "get_who PP" :named("pirop"))
    $P2872 = $P2868."unshift"($P2871)
.annotate 'line', 2135
    .return ($P2872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2857"  :anon :subid("420_1303576195.699") :outer("419_1303576195.699")
    .param pmc param_2859
.annotate 'line', 2137
    .lex "$_", param_2859
.annotate 'line', 2138
    get_hll_global $P2860, ["PAST"], "Op"
    find_lex $P2861, "$path"
    unless_null $P2861, vivify_1525
    new $P2861, "Undef"
  vivify_1525:
.annotate 'line', 2140
    find_lex $P2862, "$_"
    unless_null $P2862, vivify_1526
    new $P2862, "Undef"
  vivify_1526:
    set $S2863, $P2862
    $P2864 = $P2860."new"($P2861, $S2863, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2138
    store_lex "$path", $P2864
.annotate 'line', 2137
    .return ($P2864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("421_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2886
.annotate 'line', 2160
    .lex "$name", param_2886
.annotate 'line', 2161
    find_lex $P2887, "$name"
    unless_null $P2887, vivify_1531
    new $P2887, "Undef"
  vivify_1531:
    $P2888 = "is_scope"($P2887, "lexical")
.annotate 'line', 2160
    .return ($P2888)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("422_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2891
.annotate 'line', 2166
    .lex "$name", param_2891
.annotate 'line', 2167
    find_lex $P2892, "$name"
    unless_null $P2892, vivify_1532
    new $P2892, "Undef"
  vivify_1532:
    $P2893 = "is_scope"($P2892, "package")
.annotate 'line', 2166
    .return ($P2893)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("423_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2898
    .param pmc param_2899
.annotate 'line', 2172
    .const 'Sub' $P2907 = "424_1303576195.699" 
    capture_lex $P2907
    new $P2897, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2897, control_2896
    push_eh $P2897
    .lex "$name", param_2898
    .lex "$wanted_scope", param_2899
.annotate 'line', 2173
    find_lex $P2901, "$?PACKAGE"
    get_who $P2902, $P2901
    set $P2903, $P2902["@BLOCK"]
    unless_null $P2903, vivify_1533
    $P2903 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    defined $I2904, $P2903
    unless $I2904, for_undef_1534
    iter $P2900, $P2903
    new $P2926, 'ExceptionHandler'
    set_label $P2926, loop2925_handler
    $P2926."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2926
  loop2925_test:
    unless $P2900, loop2925_done
    shift $P2905, $P2900
  loop2925_redo:
    .const 'Sub' $P2907 = "424_1303576195.699" 
    capture_lex $P2907
    $P2907($P2905)
  loop2925_next:
    goto loop2925_test
  loop2925_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2927, exception, 'type'
    eq $P2927, .CONTROL_LOOP_NEXT, loop2925_next
    eq $P2927, .CONTROL_LOOP_REDO, loop2925_redo
  loop2925_done:
    pop_eh 
  for_undef_1534:
.annotate 'line', 2172
    .return (0)
  control_2896:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2928, exception, "payload"
    .return ($P2928)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2906"  :anon :subid("424_1303576195.699") :outer("423_1303576195.699")
    .param pmc param_2909
.annotate 'line', 2174
    $P2908 = root_new ['parrot';'Hash']
    .lex "%sym", $P2908
    .lex "$_", param_2909
    find_lex $P2910, "$_"
    unless_null $P2910, vivify_1535
    new $P2910, "Undef"
  vivify_1535:
    find_lex $P2911, "$name"
    unless_null $P2911, vivify_1536
    new $P2911, "Undef"
  vivify_1536:
    $P2912 = $P2910."symbol"($P2911)
    store_lex "%sym", $P2912
.annotate 'line', 2175
    find_lex $P2915, "%sym"
    unless_null $P2915, vivify_1537
    $P2915 = root_new ['parrot';'Hash']
  vivify_1537:
    set $N2916, $P2915
    if $N2916, if_2914
    new $P2913, 'Float'
    set $P2913, $N2916
    goto if_2914_end
  if_2914:
.annotate 'line', 2176
    new $P2917, "Exception"
    set $P2917['type'], .CONTROL_RETURN
    find_lex $P2918, "%sym"
    unless_null $P2918, vivify_1538
    $P2918 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P2919, $P2918["scope"]
    unless_null $P2919, vivify_1539
    new $P2919, "Undef"
  vivify_1539:
    set $S2920, $P2919
    find_lex $P2921, "$wanted_scope"
    unless_null $P2921, vivify_1540
    new $P2921, "Undef"
  vivify_1540:
    set $S2922, $P2921
    iseq $I2923, $S2920, $S2922
    new $P2924, 'Integer'
    set $P2924, $I2923
    setattribute $P2917, 'payload', $P2924
    throw $P2917
  if_2914_end:
.annotate 'line', 2173
    .return ($P2913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_lex"  :subid("425_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2933
.annotate 'line', 2183
    .const 'Sub' $P2941 = "426_1303576195.699" 
    capture_lex $P2941
    new $P2932, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2932, control_2931
    push_eh $P2932
    .lex "$name", param_2933
.annotate 'line', 2184
    find_lex $P2935, "$?PACKAGE"
    get_who $P2936, $P2935
    set $P2937, $P2936["@BLOCK"]
    unless_null $P2937, vivify_1541
    $P2937 = root_new ['parrot';'ResizablePMCArray']
  vivify_1541:
    defined $I2938, $P2937
    unless $I2938, for_undef_1542
    iter $P2934, $P2937
    new $P2955, 'ExceptionHandler'
    set_label $P2955, loop2954_handler
    $P2955."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2955
  loop2954_test:
    unless $P2934, loop2954_done
    shift $P2939, $P2934
  loop2954_redo:
    .const 'Sub' $P2941 = "426_1303576195.699" 
    capture_lex $P2941
    $P2941($P2939)
  loop2954_next:
    goto loop2954_test
  loop2954_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2956, exception, 'type'
    eq $P2956, .CONTROL_LOOP_NEXT, loop2954_next
    eq $P2956, .CONTROL_LOOP_REDO, loop2954_redo
  loop2954_done:
    pop_eh 
  for_undef_1542:
.annotate 'line', 2190
    new $P2957, 'String'
    set $P2957, "Could not find lexical '"
    find_lex $P2958, "$name"
    unless_null $P2958, vivify_1548
    new $P2958, "Undef"
  vivify_1548:
    concat $P2959, $P2957, $P2958
    concat $P2960, $P2959, "'"
    die $P2960
.annotate 'line', 2183
    .return ()
  control_2931:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2961, exception, "payload"
    .return ($P2961)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2940"  :anon :subid("426_1303576195.699") :outer("425_1303576195.699")
    .param pmc param_2943
.annotate 'line', 2185
    $P2942 = root_new ['parrot';'Hash']
    .lex "%sym", $P2942
    .lex "$_", param_2943
    find_lex $P2944, "$_"
    unless_null $P2944, vivify_1543
    new $P2944, "Undef"
  vivify_1543:
    find_lex $P2945, "$name"
    unless_null $P2945, vivify_1544
    new $P2945, "Undef"
  vivify_1544:
    $P2946 = $P2944."symbol"($P2945)
    store_lex "%sym", $P2946
.annotate 'line', 2186
    find_lex $P2949, "%sym"
    unless_null $P2949, vivify_1545
    $P2949 = root_new ['parrot';'Hash']
  vivify_1545:
    set $N2950, $P2949
    if $N2950, if_2948
    new $P2947, 'Float'
    set $P2947, $N2950
    goto if_2948_end
  if_2948:
.annotate 'line', 2187
    new $P2951, "Exception"
    set $P2951['type'], .CONTROL_RETURN
    find_lex $P2952, "%sym"
    unless_null $P2952, vivify_1546
    $P2952 = root_new ['parrot';'Hash']
  vivify_1546:
    set $P2953, $P2952["value"]
    unless_null $P2953, vivify_1547
    new $P2953, "Undef"
  vivify_1547:
    setattribute $P2951, 'payload', $P2953
    throw $P2951
  if_2948_end:
.annotate 'line', 2184
    .return ($P2947)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("427_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2972
    .param pmc param_2973
.annotate 'line', 798
    .lex "self", param_2972
    .lex "$/", param_2973
    find_lex $P2974, "$/"
    find_lex $P2975, "$/"
    unless_null $P2975, vivify_1549
    $P2975 = root_new ['parrot';'Hash']
  vivify_1549:
    set $P2976, $P2975["comp_unit"]
    unless_null $P2976, vivify_1550
    new $P2976, "Undef"
  vivify_1550:
    $P2977 = $P2976."ast"()
    $P2978 = $P2974."!make"($P2977)
    .return ($P2978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("428_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_2980
    .param pmc param_2981
.annotate 'line', 800
    .lex "self", param_2980
    .lex "$/", param_2981
.annotate 'line', 801
    find_lex $P2982, "$/"
.annotate 'line', 802
    find_lex $P2985, "$/"
    unless_null $P2985, vivify_1551
    $P2985 = root_new ['parrot';'Hash']
  vivify_1551:
    set $P2986, $P2985["colonpair"]
    unless_null $P2986, vivify_1552
    new $P2986, "Undef"
  vivify_1552:
    if $P2986, if_2984
.annotate 'line', 804
    find_lex $P3006, "$/"
    unless_null $P3006, vivify_1553
    new $P3006, "Undef"
  vivify_1553:
    set $S3007, $P3006
    new $P2983, 'String'
    set $P2983, $S3007
.annotate 'line', 802
    goto if_2984_end
  if_2984:
    find_lex $P2987, "$/"
    unless_null $P2987, vivify_1554
    $P2987 = root_new ['parrot';'Hash']
  vivify_1554:
    set $P2988, $P2987["identifier"]
    unless_null $P2988, vivify_1555
    new $P2988, "Undef"
  vivify_1555:
    set $S2989, $P2988
    new $P2990, 'String'
    set $P2990, $S2989
    concat $P2991, $P2990, ":"
    find_lex $P2992, "$/"
    unless_null $P2992, vivify_1556
    $P2992 = root_new ['parrot';'Hash']
  vivify_1556:
    set $P2993, $P2992["colonpair"]
    unless_null $P2993, vivify_1557
    $P2993 = root_new ['parrot';'ResizablePMCArray']
  vivify_1557:
    set $P2994, $P2993[0]
    unless_null $P2994, vivify_1558
    new $P2994, "Undef"
  vivify_1558:
    $P2995 = $P2994."ast"()
    $S2996 = $P2995."named"()
    concat $P2997, $P2991, $S2996
    concat $P2998, $P2997, "<"
.annotate 'line', 803
    find_lex $P2999, "$/"
    unless_null $P2999, vivify_1559
    $P2999 = root_new ['parrot';'Hash']
  vivify_1559:
    set $P3000, $P2999["colonpair"]
    unless_null $P3000, vivify_1560
    $P3000 = root_new ['parrot';'ResizablePMCArray']
  vivify_1560:
    set $P3001, $P3000[0]
    unless_null $P3001, vivify_1561
    new $P3001, "Undef"
  vivify_1561:
    $P3002 = $P3001."ast"()
    $S3003 = "colonpair_str"($P3002)
    concat $P3004, $P2998, $S3003
    concat $P3005, $P3004, ">"
    set $P2983, $P3005
  if_2984_end:
.annotate 'line', 802
    $P3008 = $P2982."!make"($P2983)
.annotate 'line', 800
    .return ($P3008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("429_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3011
    .param pmc param_3012
.annotate 'line', 814
    .lex "self", param_3011
    .lex "$/", param_3012
.annotate 'line', 815
    new $P3013, "Undef"
    .lex "$mainline", $P3013
.annotate 'line', 816
    new $P3014, "Undef"
    .lex "$unit", $P3014
.annotate 'line', 815
    find_lex $P3015, "$/"
    unless_null $P3015, vivify_1562
    $P3015 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3016, $P3015["statementlist"]
    unless_null $P3016, vivify_1563
    new $P3016, "Undef"
  vivify_1563:
    $P3017 = $P3016."ast"()
    store_lex "$mainline", $P3017
.annotate 'line', 816
    find_lex $P3018, "$?PACKAGE"
    get_who $P3019, $P3018
    set $P3020, $P3019["@BLOCK"]
    unless_null $P3020, vivify_1564
    $P3020 = root_new ['parrot';'ResizablePMCArray']
  vivify_1564:
    $P3021 = $P3020."shift"()
    store_lex "$unit", $P3021
.annotate 'line', 820
    find_lex $P3022, "$unit"
    unless_null $P3022, vivify_1565
    new $P3022, "Undef"
  vivify_1565:
    $P3023 = $P3022."loadinit"()
    find_dynamic_lex $P3024, "$*SC"
    unless_null $P3024, vivify_1566
    get_hll_global $P3024, "$SC"
    unless_null $P3024, vivify_1567
    die "Contextual $*SC not found"
  vivify_1567:
  vivify_1566:
    $P3025 = $P3024."to_past"()
    $P3023."push"($P3025)
.annotate 'line', 826
    find_lex $P3026, "$unit"
    unless_null $P3026, vivify_1568
    new $P3026, "Undef"
  vivify_1568:
    $P3027 = $P3026."loadinit"()
    get_hll_global $P3028, ["PAST"], "Op"
.annotate 'line', 828
    get_hll_global $P3029, ["PAST"], "Var"
    new $P3030, "ResizablePMCArray"
    $P3031 = $P3029."new"("GLOBAL" :named("name"), $P3030 :named("namespace"), "package" :named("scope"))
.annotate 'line', 829
    find_dynamic_lex $P3032, "$*SC"
    unless_null $P3032, vivify_1569
    get_hll_global $P3032, "$SC"
    unless_null $P3032, vivify_1570
    die "Contextual $*SC not found"
  vivify_1570:
  vivify_1569:
    find_dynamic_lex $P3033, "$*PACKAGE"
    unless_null $P3033, vivify_1571
    get_hll_global $P3033, "$PACKAGE"
    unless_null $P3033, vivify_1572
    die "Contextual $*PACKAGE not found"
  vivify_1572:
  vivify_1571:
    $P3034 = $P3032."get_slot_past_for_object"($P3033)
    $P3035 = $P3028."new"($P3031, $P3034, "bind" :named("pasttype"))
.annotate 'line', 826
    $P3027."push"($P3035)
.annotate 'line', 835
    find_dynamic_lex $P3037, "$*HAS_YOU_ARE_HERE"
    unless_null $P3037, vivify_1573
    get_hll_global $P3037, "$HAS_YOU_ARE_HERE"
    unless_null $P3037, vivify_1574
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1574:
  vivify_1573:
    if $P3037, unless_3036_end
.annotate 'line', 836
    find_lex $P3038, "$unit"
    unless_null $P3038, vivify_1575
    new $P3038, "Undef"
  vivify_1575:
    find_lex $P3039, "self"
    $P3040 = $P3039."CTXSAVE"()
    $P3038."push"($P3040)
  unless_3036_end:
.annotate 'line', 840
    find_lex $P3041, "$unit"
    unless_null $P3041, vivify_1576
    new $P3041, "Undef"
  vivify_1576:
    $P3041."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 844
    find_dynamic_lex $P3043, "$*MAIN_SUB"
    unless_null $P3043, vivify_1577
    get_hll_global $P3043, "$MAIN_SUB"
    unless_null $P3043, vivify_1578
    die "Contextual $*MAIN_SUB not found"
  vivify_1578:
  vivify_1577:
    unless $P3043, if_3042_end
.annotate 'line', 845
    find_lex $P3044, "$unit"
    unless_null $P3044, vivify_1579
    new $P3044, "Undef"
  vivify_1579:
    get_hll_global $P3045, ["PAST"], "Var"
    $P3046 = $P3045."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3044."unshift"($P3046)
.annotate 'line', 846
    find_lex $P3047, "$mainline"
    unless_null $P3047, vivify_1580
    new $P3047, "Undef"
  vivify_1580:
    get_hll_global $P3048, ["PAST"], "Op"
.annotate 'line', 848
    get_hll_global $P3049, ["PAST"], "Var"
    $P3050 = $P3049."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 849
    get_hll_global $P3051, ["PAST"], "Op"
.annotate 'line', 850
    get_hll_global $P3052, ["PAST"], "Val"
    find_dynamic_lex $P3053, "$*MAIN_SUB"
    unless_null $P3053, vivify_1581
    get_hll_global $P3053, "$MAIN_SUB"
    unless_null $P3053, vivify_1582
    die "Contextual $*MAIN_SUB not found"
  vivify_1582:
  vivify_1581:
    $P3054 = $P3052."new"($P3053 :named("value"))
.annotate 'line', 851
    get_hll_global $P3055, ["PAST"], "Var"
    $P3056 = $P3055."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3057 = $P3051."new"($P3054, $P3056, "call" :named("pasttype"))
.annotate 'line', 849
    $P3058 = $P3048."new"($P3050, $P3057, "if" :named("pasttype"))
.annotate 'line', 846
    $P3047."push"($P3058)
  if_3042_end:
.annotate 'line', 859
    find_lex $P3059, "$unit"
    unless_null $P3059, vivify_1583
    new $P3059, "Undef"
  vivify_1583:
.annotate 'line', 860
    get_hll_global $P3060, ["PAST"], "Op"
    find_lex $P3061, "$mainline"
    unless_null $P3061, vivify_1584
    new $P3061, "Undef"
  vivify_1584:
    $P3062 = $P3060."new"($P3061, "return" :named("pirop"))
    $P3059."push"($P3062)
.annotate 'line', 865
    find_lex $P3063, "$unit"
    unless_null $P3063, vivify_1585
    new $P3063, "Undef"
  vivify_1585:
.annotate 'line', 866
    get_hll_global $P3064, ["PAST"], "Block"
.annotate 'line', 868
    get_hll_global $P3065, ["PAST"], "Op"
    get_hll_global $P3066, ["PAST"], "Val"
    find_lex $P3067, "$unit"
    unless_null $P3067, vivify_1586
    new $P3067, "Undef"
  vivify_1586:
    $P3068 = $P3066."new"($P3067 :named("value"))
    $P3069 = $P3065."new"($P3068, "call" :named("pasttype"))
    $P3070 = $P3064."new"($P3069, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 866
    $P3063."push"($P3070)
.annotate 'line', 871
    find_lex $P3071, "$unit"
    unless_null $P3071, vivify_1587
    new $P3071, "Undef"
  vivify_1587:
    find_lex $P3072, "$/"
    unless_null $P3072, vivify_1588
    new $P3072, "Undef"
  vivify_1588:
    $P3071."node"($P3072)
.annotate 'line', 874
    find_lex $P3073, "$unit"
    unless_null $P3073, vivify_1589
    new $P3073, "Undef"
  vivify_1589:
    $P3073."hll"("nqp")
.annotate 'line', 876
    find_lex $P3074, "$/"
    find_lex $P3075, "$unit"
    unless_null $P3075, vivify_1590
    new $P3075, "Undef"
  vivify_1590:
    $P3076 = $P3074."!make"($P3075)
.annotate 'line', 814
    .return ($P3076)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("430_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3078
    .param pmc param_3079
.annotate 'line', 879
    .const 'Sub' $P3093 = "431_1303576195.699" 
    capture_lex $P3093
    .lex "self", param_3078
    .lex "$/", param_3079
.annotate 'line', 880
    new $P3080, "Undef"
    .lex "$past", $P3080
    get_hll_global $P3081, ["PAST"], "Stmts"
    find_lex $P3082, "$/"
    unless_null $P3082, vivify_1591
    new $P3082, "Undef"
  vivify_1591:
    $P3083 = $P3081."new"($P3082 :named("node"))
    store_lex "$past", $P3083
.annotate 'line', 881
    find_lex $P3085, "$/"
    unless_null $P3085, vivify_1592
    $P3085 = root_new ['parrot';'Hash']
  vivify_1592:
    set $P3086, $P3085["statement"]
    unless_null $P3086, vivify_1593
    new $P3086, "Undef"
  vivify_1593:
    unless $P3086, if_3084_end
.annotate 'line', 882
    find_lex $P3088, "$/"
    unless_null $P3088, vivify_1594
    $P3088 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3089, $P3088["statement"]
    unless_null $P3089, vivify_1595
    new $P3089, "Undef"
  vivify_1595:
    defined $I3090, $P3089
    unless $I3090, for_undef_1596
    iter $P3087, $P3089
    new $P3113, 'ExceptionHandler'
    set_label $P3113, loop3112_handler
    $P3113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3113
  loop3112_test:
    unless $P3087, loop3112_done
    shift $P3091, $P3087
  loop3112_redo:
    .const 'Sub' $P3093 = "431_1303576195.699" 
    capture_lex $P3093
    $P3093($P3091)
  loop3112_next:
    goto loop3112_test
  loop3112_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3114, exception, 'type'
    eq $P3114, .CONTROL_LOOP_NEXT, loop3112_next
    eq $P3114, .CONTROL_LOOP_REDO, loop3112_redo
  loop3112_done:
    pop_eh 
  for_undef_1596:
  if_3084_end:
.annotate 'line', 889
    find_lex $P3115, "$/"
    find_lex $P3116, "$past"
    unless_null $P3116, vivify_1607
    new $P3116, "Undef"
  vivify_1607:
    $P3117 = $P3115."!make"($P3116)
.annotate 'line', 879
    .return ($P3117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3092"  :anon :subid("431_1303576195.699") :outer("430_1303576195.699")
    .param pmc param_3095
.annotate 'line', 883
    new $P3094, "Undef"
    .lex "$ast", $P3094
    .lex "$_", param_3095
    find_lex $P3096, "$_"
    unless_null $P3096, vivify_1597
    new $P3096, "Undef"
  vivify_1597:
    $P3097 = $P3096."ast"()
    store_lex "$ast", $P3097
.annotate 'line', 884
    find_lex $P3099, "$ast"
    unless_null $P3099, vivify_1598
    $P3099 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P3100, $P3099["sink"]
    unless_null $P3100, vivify_1599
    new $P3100, "Undef"
  vivify_1599:
    defined $I3101, $P3100
    unless $I3101, if_3098_end
    find_lex $P3102, "$ast"
    unless_null $P3102, vivify_1600
    $P3102 = root_new ['parrot';'Hash']
  vivify_1600:
    set $P3103, $P3102["sink"]
    unless_null $P3103, vivify_1601
    new $P3103, "Undef"
  vivify_1601:
    store_lex "$ast", $P3103
  if_3098_end:
.annotate 'line', 885
    find_lex $P3105, "$ast"
    unless_null $P3105, vivify_1602
    $P3105 = root_new ['parrot';'Hash']
  vivify_1602:
    set $P3106, $P3105["bareblock"]
    unless_null $P3106, vivify_1603
    new $P3106, "Undef"
  vivify_1603:
    unless $P3106, if_3104_end
    find_lex $P3107, "$ast"
    unless_null $P3107, vivify_1604
    new $P3107, "Undef"
  vivify_1604:
    $P3108 = "block_immediate"($P3107)
    store_lex "$ast", $P3108
  if_3104_end:
.annotate 'line', 886
    find_lex $P3109, "$past"
    unless_null $P3109, vivify_1605
    new $P3109, "Undef"
  vivify_1605:
    find_lex $P3110, "$ast"
    unless_null $P3110, vivify_1606
    new $P3110, "Undef"
  vivify_1606:
    $P3111 = $P3109."push"($P3110)
.annotate 'line', 882
    .return ($P3111)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("432_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3119
    .param pmc param_3120
    .param pmc param_3121 :optional
    .param int has_param_3121 :opt_flag
.annotate 'line', 892
    .const 'Sub' $P3129 = "433_1303576195.699" 
    capture_lex $P3129
    .lex "self", param_3119
    .lex "$/", param_3120
    if has_param_3121, optparam_1608
    new $P3122, "Undef"
    set param_3121, $P3122
  optparam_1608:
    .lex "$key", param_3121
.annotate 'line', 893
    new $P3123, "Undef"
    .lex "$past", $P3123
.annotate 'line', 892
    find_lex $P3124, "$past"
    unless_null $P3124, vivify_1609
    new $P3124, "Undef"
  vivify_1609:
.annotate 'line', 894
    find_lex $P3126, "$/"
    unless_null $P3126, vivify_1610
    $P3126 = root_new ['parrot';'Hash']
  vivify_1610:
    set $P3127, $P3126["EXPR"]
    unless_null $P3127, vivify_1611
    new $P3127, "Undef"
  vivify_1611:
    if $P3127, if_3125
.annotate 'line', 915
    find_lex $P3190, "$/"
    unless_null $P3190, vivify_1612
    $P3190 = root_new ['parrot';'Hash']
  vivify_1612:
    set $P3191, $P3190["statement_control"]
    unless_null $P3191, vivify_1613
    new $P3191, "Undef"
  vivify_1613:
    if $P3191, if_3189
.annotate 'line', 916
    new $P3195, "Integer"
    assign $P3195, 0
    store_lex "$past", $P3195
    goto if_3189_end
  if_3189:
.annotate 'line', 915
    find_lex $P3192, "$/"
    unless_null $P3192, vivify_1614
    $P3192 = root_new ['parrot';'Hash']
  vivify_1614:
    set $P3193, $P3192["statement_control"]
    unless_null $P3193, vivify_1615
    new $P3193, "Undef"
  vivify_1615:
    $P3194 = $P3193."ast"()
    store_lex "$past", $P3194
  if_3189_end:
    goto if_3125_end
  if_3125:
.annotate 'line', 894
    .const 'Sub' $P3129 = "433_1303576195.699" 
    capture_lex $P3129
    $P3129()
  if_3125_end:
.annotate 'line', 917
    find_lex $P3196, "$/"
    find_lex $P3197, "$past"
    unless_null $P3197, vivify_1649
    new $P3197, "Undef"
  vivify_1649:
    $P3198 = $P3196."!make"($P3197)
.annotate 'line', 892
    .return ($P3198)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3128"  :anon :subid("433_1303576195.699") :outer("432_1303576195.699")
.annotate 'line', 895
    new $P3130, "Undef"
    .lex "$mc", $P3130
.annotate 'line', 896
    new $P3131, "Undef"
    .lex "$ml", $P3131
.annotate 'line', 895
    find_lex $P3132, "$/"
    unless_null $P3132, vivify_1616
    $P3132 = root_new ['parrot';'Hash']
  vivify_1616:
    set $P3133, $P3132["statement_mod_cond"]
    unless_null $P3133, vivify_1617
    $P3133 = root_new ['parrot';'ResizablePMCArray']
  vivify_1617:
    set $P3134, $P3133[0]
    unless_null $P3134, vivify_1618
    new $P3134, "Undef"
  vivify_1618:
    store_lex "$mc", $P3134
.annotate 'line', 896
    find_lex $P3135, "$/"
    unless_null $P3135, vivify_1619
    $P3135 = root_new ['parrot';'Hash']
  vivify_1619:
    set $P3136, $P3135["statement_mod_loop"]
    unless_null $P3136, vivify_1620
    $P3136 = root_new ['parrot';'ResizablePMCArray']
  vivify_1620:
    set $P3137, $P3136[0]
    unless_null $P3137, vivify_1621
    new $P3137, "Undef"
  vivify_1621:
    store_lex "$ml", $P3137
.annotate 'line', 897
    find_lex $P3138, "$/"
    unless_null $P3138, vivify_1622
    $P3138 = root_new ['parrot';'Hash']
  vivify_1622:
    set $P3139, $P3138["EXPR"]
    unless_null $P3139, vivify_1623
    new $P3139, "Undef"
  vivify_1623:
    $P3140 = $P3139."ast"()
    store_lex "$past", $P3140
.annotate 'line', 898
    find_lex $P3142, "$mc"
    unless_null $P3142, vivify_1624
    new $P3142, "Undef"
  vivify_1624:
    unless $P3142, if_3141_end
.annotate 'line', 899
    get_hll_global $P3143, ["PAST"], "Op"
    find_lex $P3144, "$mc"
    unless_null $P3144, vivify_1625
    $P3144 = root_new ['parrot';'Hash']
  vivify_1625:
    set $P3145, $P3144["cond"]
    unless_null $P3145, vivify_1626
    new $P3145, "Undef"
  vivify_1626:
    $P3146 = $P3145."ast"()
    find_lex $P3147, "$past"
    unless_null $P3147, vivify_1627
    new $P3147, "Undef"
  vivify_1627:
    find_lex $P3148, "$mc"
    unless_null $P3148, vivify_1628
    $P3148 = root_new ['parrot';'Hash']
  vivify_1628:
    set $P3149, $P3148["sym"]
    unless_null $P3149, vivify_1629
    new $P3149, "Undef"
  vivify_1629:
    set $S3150, $P3149
    find_lex $P3151, "$/"
    unless_null $P3151, vivify_1630
    new $P3151, "Undef"
  vivify_1630:
    $P3152 = $P3143."new"($P3146, $P3147, $S3150 :named("pasttype"), $P3151 :named("node"))
    store_lex "$past", $P3152
  if_3141_end:
.annotate 'line', 901
    find_lex $P3155, "$ml"
    unless_null $P3155, vivify_1631
    new $P3155, "Undef"
  vivify_1631:
    if $P3155, if_3154
    set $P3153, $P3155
    goto if_3154_end
  if_3154:
.annotate 'line', 902
    find_lex $P3158, "$ml"
    unless_null $P3158, vivify_1632
    $P3158 = root_new ['parrot';'Hash']
  vivify_1632:
    set $P3159, $P3158["sym"]
    unless_null $P3159, vivify_1633
    new $P3159, "Undef"
  vivify_1633:
    set $S3160, $P3159
    iseq $I3161, $S3160, "for"
    if $I3161, if_3157
.annotate 'line', 911
    get_hll_global $P3179, ["PAST"], "Op"
    find_lex $P3180, "$ml"
    unless_null $P3180, vivify_1634
    $P3180 = root_new ['parrot';'Hash']
  vivify_1634:
    set $P3181, $P3180["cond"]
    unless_null $P3181, vivify_1635
    new $P3181, "Undef"
  vivify_1635:
    $P3182 = $P3181."ast"()
    find_lex $P3183, "$past"
    unless_null $P3183, vivify_1636
    new $P3183, "Undef"
  vivify_1636:
    find_lex $P3184, "$ml"
    unless_null $P3184, vivify_1637
    $P3184 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3185, $P3184["sym"]
    unless_null $P3185, vivify_1638
    new $P3185, "Undef"
  vivify_1638:
    set $S3186, $P3185
    find_lex $P3187, "$/"
    unless_null $P3187, vivify_1639
    new $P3187, "Undef"
  vivify_1639:
    $P3188 = $P3179."new"($P3182, $P3183, $S3186 :named("pasttype"), $P3187 :named("node"))
    store_lex "$past", $P3188
.annotate 'line', 910
    set $P3156, $P3188
.annotate 'line', 902
    goto if_3157_end
  if_3157:
.annotate 'line', 903
    get_hll_global $P3162, ["PAST"], "Block"
.annotate 'line', 904
    get_hll_global $P3163, ["PAST"], "Var"
    $P3164 = $P3163."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3165, "$past"
    unless_null $P3165, vivify_1640
    new $P3165, "Undef"
  vivify_1640:
    $P3166 = $P3162."new"($P3164, $P3165, "immediate" :named("blocktype"))
.annotate 'line', 903
    store_lex "$past", $P3166
.annotate 'line', 906
    find_lex $P3167, "$past"
    unless_null $P3167, vivify_1641
    new $P3167, "Undef"
  vivify_1641:
    $P3167."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 907
    find_lex $P3168, "$past"
    unless_null $P3168, vivify_1642
    new $P3168, "Undef"
  vivify_1642:
    $P3168."arity"(1)
.annotate 'line', 908
    get_hll_global $P3169, ["PAST"], "Op"
    find_lex $P3170, "$ml"
    unless_null $P3170, vivify_1643
    $P3170 = root_new ['parrot';'Hash']
  vivify_1643:
    set $P3171, $P3170["cond"]
    unless_null $P3171, vivify_1644
    new $P3171, "Undef"
  vivify_1644:
    $P3172 = $P3171."ast"()
    find_lex $P3173, "$past"
    unless_null $P3173, vivify_1645
    new $P3173, "Undef"
  vivify_1645:
    find_lex $P3174, "$ml"
    unless_null $P3174, vivify_1646
    $P3174 = root_new ['parrot';'Hash']
  vivify_1646:
    set $P3175, $P3174["sym"]
    unless_null $P3175, vivify_1647
    new $P3175, "Undef"
  vivify_1647:
    set $S3176, $P3175
    find_lex $P3177, "$/"
    unless_null $P3177, vivify_1648
    new $P3177, "Undef"
  vivify_1648:
    $P3178 = $P3169."new"($P3172, $P3173, $S3176 :named("pasttype"), $P3177 :named("node"))
    store_lex "$past", $P3178
.annotate 'line', 902
    set $P3156, $P3178
  if_3157_end:
.annotate 'line', 901
    set $P3153, $P3156
  if_3154_end:
.annotate 'line', 894
    .return ($P3153)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("434_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3200
    .param pmc param_3201
.annotate 'line', 920
    .lex "self", param_3200
    .lex "$/", param_3201
.annotate 'line', 921
    find_lex $P3202, "$/"
    get_hll_global $P3203, ["PAST"], "Op"
    find_lex $P3204, "$/"
    unless_null $P3204, vivify_1650
    $P3204 = root_new ['parrot';'Hash']
  vivify_1650:
    set $P3205, $P3204["EXPR"]
    unless_null $P3205, vivify_1651
    new $P3205, "Undef"
  vivify_1651:
    $P3206 = $P3205."ast"()
    find_lex $P3207, "$/"
    unless_null $P3207, vivify_1652
    $P3207 = root_new ['parrot';'Hash']
  vivify_1652:
    set $P3208, $P3207["pblock"]
    unless_null $P3208, vivify_1653
    new $P3208, "Undef"
  vivify_1653:
    $P3209 = $P3208."ast"()
    find_lex $P3210, "$/"
    unless_null $P3210, vivify_1654
    new $P3210, "Undef"
  vivify_1654:
    $P3211 = $P3203."new"($P3206, $P3209, "if" :named("pasttype"), $P3210 :named("node"))
    $P3212 = $P3202."!make"($P3211)
.annotate 'line', 920
    .return ($P3212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("435_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3214
    .param pmc param_3215
.annotate 'line', 924
    .lex "self", param_3214
    .lex "$/", param_3215
.annotate 'line', 925
    find_lex $P3216, "$/"
    find_lex $P3217, "$/"
    unless_null $P3217, vivify_1655
    $P3217 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3218, $P3217["blockoid"]
    unless_null $P3218, vivify_1656
    new $P3218, "Undef"
  vivify_1656:
    $P3219 = $P3218."ast"()
    $P3220 = $P3216."!make"($P3219)
.annotate 'line', 924
    .return ($P3220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("436_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3222
    .param pmc param_3223
.annotate 'line', 928
    .lex "self", param_3222
    .lex "$/", param_3223
.annotate 'line', 929
    find_lex $P3224, "$/"
    find_lex $P3225, "$/"
    unless_null $P3225, vivify_1657
    $P3225 = root_new ['parrot';'Hash']
  vivify_1657:
    set $P3226, $P3225["blockoid"]
    unless_null $P3226, vivify_1658
    new $P3226, "Undef"
  vivify_1658:
    $P3227 = $P3226."ast"()
    $P3228 = $P3224."!make"($P3227)
.annotate 'line', 928
    .return ($P3228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("437_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3230
    .param pmc param_3231
.annotate 'line', 932
    .const 'Sub' $P3242 = "438_1303576195.699" 
    capture_lex $P3242
    .lex "self", param_3230
    .lex "$/", param_3231
.annotate 'line', 933
    new $P3232, "Undef"
    .lex "$BLOCK", $P3232
    find_lex $P3233, "$?PACKAGE"
    get_who $P3234, $P3233
    set $P3235, $P3234["@BLOCK"]
    unless_null $P3235, vivify_1659
    $P3235 = root_new ['parrot';'ResizablePMCArray']
  vivify_1659:
    $P3236 = $P3235."shift"()
    store_lex "$BLOCK", $P3236
.annotate 'line', 934
    find_lex $P3239, "$/"
    unless_null $P3239, vivify_1660
    $P3239 = root_new ['parrot';'Hash']
  vivify_1660:
    set $P3240, $P3239["statementlist"]
    unless_null $P3240, vivify_1661
    new $P3240, "Undef"
  vivify_1661:
    if $P3240, if_3238
.annotate 'line', 942
    find_dynamic_lex $P3257, "$*HAS_YOU_ARE_HERE"
    unless_null $P3257, vivify_1662
    get_hll_global $P3257, "$HAS_YOU_ARE_HERE"
    unless_null $P3257, vivify_1663
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1663:
  vivify_1662:
    unless $P3257, if_3256_end
.annotate 'line', 943
    find_lex $P3258, "$/"
    unless_null $P3258, vivify_1664
    new $P3258, "Undef"
  vivify_1664:
    $P3259 = $P3258."CURSOR"()
    $P3259."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3256_end:
.annotate 'line', 945
    new $P3260, "Integer"
    assign $P3260, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3260
.annotate 'line', 946
    find_lex $P3261, "$/"
    find_lex $P3262, "$/"
    unless_null $P3262, vivify_1665
    $P3262 = root_new ['parrot';'Hash']
  vivify_1665:
    set $P3263, $P3262["you_are_here"]
    unless_null $P3263, vivify_1666
    new $P3263, "Undef"
  vivify_1666:
    $P3264 = $P3263."ast"()
    $P3265 = $P3261."!make"($P3264)
.annotate 'line', 941
    set $P3237, $P3265
.annotate 'line', 934
    goto if_3238_end
  if_3238:
    .const 'Sub' $P3242 = "438_1303576195.699" 
    capture_lex $P3242
    $P3255 = $P3242()
    set $P3237, $P3255
  if_3238_end:
.annotate 'line', 932
    .return ($P3237)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3241"  :anon :subid("438_1303576195.699") :outer("437_1303576195.699")
.annotate 'line', 935
    new $P3243, "Undef"
    .lex "$past", $P3243
    find_lex $P3244, "$/"
    unless_null $P3244, vivify_1667
    $P3244 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3245, $P3244["statementlist"]
    unless_null $P3245, vivify_1668
    new $P3245, "Undef"
  vivify_1668:
    $P3246 = $P3245."ast"()
    store_lex "$past", $P3246
.annotate 'line', 936
    find_lex $P3247, "$BLOCK"
    unless_null $P3247, vivify_1669
    new $P3247, "Undef"
  vivify_1669:
    find_lex $P3248, "$past"
    unless_null $P3248, vivify_1670
    new $P3248, "Undef"
  vivify_1670:
    $P3247."push"($P3248)
.annotate 'line', 937
    find_lex $P3249, "$BLOCK"
    unless_null $P3249, vivify_1671
    new $P3249, "Undef"
  vivify_1671:
    find_lex $P3250, "$/"
    unless_null $P3250, vivify_1672
    new $P3250, "Undef"
  vivify_1672:
    $P3249."node"($P3250)
.annotate 'line', 938
    find_lex $P3251, "$BLOCK"
    unless_null $P3251, vivify_1673
    new $P3251, "Undef"
  vivify_1673:
    $P3251."closure"(1)
.annotate 'line', 939
    find_dynamic_lex $P3252, "$/"
    find_lex $P3253, "$BLOCK"
    unless_null $P3253, vivify_1674
    new $P3253, "Undef"
  vivify_1674:
    $P3254 = $P3252."!make"($P3253)
.annotate 'line', 934
    .return ($P3254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("439_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3267
    .param pmc param_3268
.annotate 'line', 950
    .lex "self", param_3267
    .lex "$/", param_3268
.annotate 'line', 951
    find_lex $P3269, "$?PACKAGE"
    get_who $P3270, $P3269
    set $P3271, $P3270["@BLOCK"]
    unless_null $P3271, vivify_1675
    $P3271 = root_new ['parrot';'ResizablePMCArray']
  vivify_1675:
    get_hll_global $P3272, ["PAST"], "Block"
    get_hll_global $P3273, ["PAST"], "Stmts"
    $P3274 = $P3273."new"()
    $P3275 = $P3272."new"($P3274)
    $P3276 = $P3271."unshift"($P3275)
.annotate 'line', 950
    .return ($P3276)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("440_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3278
    .param pmc param_3279
.annotate 'line', 954
    .lex "self", param_3278
    .lex "$/", param_3279
.annotate 'line', 955
    find_dynamic_lex $P3281, "%*COMPILING"
    unless_null $P3281, vivify_1676
    get_hll_global $P3281, "%COMPILING"
    unless_null $P3281, vivify_1677
    die "Contextual %*COMPILING not found"
  vivify_1677:
  vivify_1676:
    set $P3282, $P3281["%?OPTIONS"]
    unless_null $P3282, vivify_1678
    $P3282 = root_new ['parrot';'Hash']
  vivify_1678:
    set $P3283, $P3282["outer_ctx"]
    unless_null $P3283, vivify_1679
    new $P3283, "Undef"
  vivify_1679:
    defined $I3284, $P3283
    if $I3284, unless_3280_end
.annotate 'line', 958
    find_dynamic_lex $P3285, "$*SC"
    unless_null $P3285, vivify_1680
    get_hll_global $P3285, "$SC"
    unless_null $P3285, vivify_1681
    die "Contextual $*SC not found"
  vivify_1681:
  vivify_1680:
    find_dynamic_lex $P3287, "%*COMPILING"
    unless_null $P3287, vivify_1682
    get_hll_global $P3287, "%COMPILING"
    unless_null $P3287, vivify_1683
    die "Contextual %*COMPILING not found"
  vivify_1683:
  vivify_1682:
    set $P3288, $P3287["%?OPTIONS"]
    unless_null $P3288, vivify_1684
    $P3288 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3289, $P3288["setting"]
    unless_null $P3289, vivify_1685
    new $P3289, "Undef"
  vivify_1685:
    set $P3286, $P3289
    defined $I3291, $P3286
    if $I3291, default_3290
    new $P3292, "String"
    assign $P3292, "NQPCORE"
    set $P3286, $P3292
  default_3290:
    $P3285."load_setting"($P3286)
  unless_3280_end:
.annotate 'line', 960
    find_lex $P3293, "self"
    find_lex $P3294, "$?PACKAGE"
    get_who $P3295, $P3294
    set $P3296, $P3295["@BLOCK"]
    unless_null $P3296, vivify_1686
    $P3296 = root_new ['parrot';'ResizablePMCArray']
  vivify_1686:
    set $P3297, $P3296[0]
    unless_null $P3297, vivify_1687
    new $P3297, "Undef"
  vivify_1687:
    $P3298 = $P3293."SET_BLOCK_OUTER_CTX"($P3297)
.annotate 'line', 954
    .return ($P3298)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("441_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3300
    .param pmc param_3301
.annotate 'line', 963
    .lex "self", param_3300
    .lex "$/", param_3301
.annotate 'line', 967
    find_dynamic_lex $P3302, "$*SC"
    unless_null $P3302, vivify_1688
    get_hll_global $P3302, "$SC"
    unless_null $P3302, vivify_1689
    die "Contextual $*SC not found"
  vivify_1689:
  vivify_1688:
    get_hll_global $P3303, "KnowHOW"
    $P3304 = $P3302."pkg_create_mo"($P3303, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3304
.annotate 'line', 968
    find_dynamic_lex $P3305, "$*GLOBALish"
    unless_null $P3305, vivify_1690
    get_hll_global $P3305, "$GLOBALish"
    unless_null $P3305, vivify_1691
    die "Contextual $*GLOBALish not found"
  vivify_1691:
  vivify_1690:
    get_how $P3306, $P3305
    find_dynamic_lex $P3307, "$*GLOBALish"
    unless_null $P3307, vivify_1692
    get_hll_global $P3307, "$GLOBALish"
    unless_null $P3307, vivify_1693
    die "Contextual $*GLOBALish not found"
  vivify_1693:
  vivify_1692:
    $P3306."compose"($P3307)
.annotate 'line', 969
    find_dynamic_lex $P3308, "$*SC"
    unless_null $P3308, vivify_1694
    get_hll_global $P3308, "$SC"
    unless_null $P3308, vivify_1695
    die "Contextual $*SC not found"
  vivify_1695:
  vivify_1694:
    find_lex $P3309, "$?PACKAGE"
    get_who $P3310, $P3309
    set $P3311, $P3310["@BLOCK"]
    unless_null $P3311, vivify_1696
    $P3311 = root_new ['parrot';'ResizablePMCArray']
  vivify_1696:
    set $P3312, $P3311[0]
    unless_null $P3312, vivify_1697
    new $P3312, "Undef"
  vivify_1697:
    find_dynamic_lex $P3313, "$*GLOBALish"
    unless_null $P3313, vivify_1698
    get_hll_global $P3313, "$GLOBALish"
    unless_null $P3313, vivify_1699
    die "Contextual $*GLOBALish not found"
  vivify_1699:
  vivify_1698:
    $P3308."install_lexical_symbol"($P3312, "GLOBALish", $P3313)
.annotate 'line', 972
    find_dynamic_lex $P3314, "$*GLOBALish"
    unless_null $P3314, vivify_1700
    get_hll_global $P3314, "$GLOBALish"
    unless_null $P3314, vivify_1701
    die "Contextual $*GLOBALish not found"
  vivify_1701:
  vivify_1700:
    store_dynamic_lex "$*PACKAGE", $P3314
.annotate 'line', 973
    find_dynamic_lex $P3315, "$*SC"
    unless_null $P3315, vivify_1702
    get_hll_global $P3315, "$SC"
    unless_null $P3315, vivify_1703
    die "Contextual $*SC not found"
  vivify_1703:
  vivify_1702:
    find_lex $P3316, "$?PACKAGE"
    get_who $P3317, $P3316
    set $P3318, $P3317["@BLOCK"]
    unless_null $P3318, vivify_1704
    $P3318 = root_new ['parrot';'ResizablePMCArray']
  vivify_1704:
    set $P3319, $P3318[0]
    unless_null $P3319, vivify_1705
    new $P3319, "Undef"
  vivify_1705:
    find_dynamic_lex $P3320, "$*PACKAGE"
    unless_null $P3320, vivify_1706
    get_hll_global $P3320, "$PACKAGE"
    unless_null $P3320, vivify_1707
    die "Contextual $*PACKAGE not found"
  vivify_1707:
  vivify_1706:
    $P3321 = $P3315."install_lexical_symbol"($P3319, "$?PACKAGE", $P3320)
.annotate 'line', 963
    .return ($P3321)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("442_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3323
    .param pmc param_3324
.annotate 'line', 976
    .lex "self", param_3323
    .lex "$/", param_3324
.annotate 'line', 977
    find_lex $P3325, "$/"
    find_lex $P3326, "self"
    $P3327 = $P3326."CTXSAVE"()
    $P3328 = $P3325."!make"($P3327)
.annotate 'line', 976
    .return ($P3328)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("443_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3330
    .param pmc param_3331
.annotate 'line', 982
    .lex "self", param_3330
    .lex "$/", param_3331
.annotate 'line', 983
    find_dynamic_lex $P3332, "$*SC"
    unless_null $P3332, vivify_1708
    get_hll_global $P3332, "$SC"
    unless_null $P3332, vivify_1709
    die "Contextual $*SC not found"
  vivify_1709:
  vivify_1708:
    find_lex $P3333, "$/"
    unless_null $P3333, vivify_1710
    $P3333 = root_new ['parrot';'Hash']
  vivify_1710:
    set $P3334, $P3333["name"]
    unless_null $P3334, vivify_1711
    new $P3334, "Undef"
  vivify_1711:
    set $S3335, $P3334
    find_dynamic_lex $P3336, "$*GLOBALish"
    unless_null $P3336, vivify_1712
    get_hll_global $P3336, "$GLOBALish"
    unless_null $P3336, vivify_1713
    die "Contextual $*GLOBALish not found"
  vivify_1713:
  vivify_1712:
    $P3332."load_module"($S3335, $P3336)
.annotate 'line', 984
    find_lex $P3337, "$/"
    get_hll_global $P3338, ["PAST"], "Stmts"
    $P3339 = $P3338."new"()
    $P3340 = $P3337."!make"($P3339)
.annotate 'line', 982
    .return ($P3340)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("444_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3342
    .param pmc param_3343
.annotate 'line', 987
    .const 'Sub' $P3371 = "445_1303576195.699" 
    capture_lex $P3371
    .lex "self", param_3342
    .lex "$/", param_3343
.annotate 'line', 988
    new $P3344, "Undef"
    .lex "$count", $P3344
.annotate 'line', 989
    new $P3345, "Undef"
    .lex "$past", $P3345
.annotate 'line', 988
    find_lex $P3346, "$/"
    unless_null $P3346, vivify_1714
    $P3346 = root_new ['parrot';'Hash']
  vivify_1714:
    set $P3347, $P3346["xblock"]
    unless_null $P3347, vivify_1715
    new $P3347, "Undef"
  vivify_1715:
    set $N3348, $P3347
    new $P3349, 'Float'
    set $P3349, $N3348
    sub $P3350, $P3349, 1
    store_lex "$count", $P3350
.annotate 'line', 989
    find_lex $P3351, "$count"
    unless_null $P3351, vivify_1716
    new $P3351, "Undef"
  vivify_1716:
    set $I3352, $P3351
    find_lex $P3353, "$/"
    unless_null $P3353, vivify_1717
    $P3353 = root_new ['parrot';'Hash']
  vivify_1717:
    set $P3354, $P3353["xblock"]
    unless_null $P3354, vivify_1718
    $P3354 = root_new ['parrot';'ResizablePMCArray']
  vivify_1718:
    set $P3355, $P3354[$I3352]
    unless_null $P3355, vivify_1719
    new $P3355, "Undef"
  vivify_1719:
    $P3356 = $P3355."ast"()
    $P3357 = "xblock_immediate"($P3356)
    store_lex "$past", $P3357
.annotate 'line', 990
    find_lex $P3359, "$/"
    unless_null $P3359, vivify_1720
    $P3359 = root_new ['parrot';'Hash']
  vivify_1720:
    set $P3360, $P3359["else"]
    unless_null $P3360, vivify_1721
    new $P3360, "Undef"
  vivify_1721:
    unless $P3360, if_3358_end
.annotate 'line', 991
    find_lex $P3361, "$past"
    unless_null $P3361, vivify_1722
    new $P3361, "Undef"
  vivify_1722:
    find_lex $P3362, "$/"
    unless_null $P3362, vivify_1723
    $P3362 = root_new ['parrot';'Hash']
  vivify_1723:
    set $P3363, $P3362["else"]
    unless_null $P3363, vivify_1724
    $P3363 = root_new ['parrot';'ResizablePMCArray']
  vivify_1724:
    set $P3364, $P3363[0]
    unless_null $P3364, vivify_1725
    new $P3364, "Undef"
  vivify_1725:
    $P3365 = $P3364."ast"()
    $P3366 = "block_immediate"($P3365)
    $P3361."push"($P3366)
  if_3358_end:
.annotate 'line', 994
    new $P3387, 'ExceptionHandler'
    set_label $P3387, loop3386_handler
    $P3387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3387
  loop3386_test:
    find_lex $P3367, "$count"
    unless_null $P3367, vivify_1726
    new $P3367, "Undef"
  vivify_1726:
    set $N3368, $P3367
    isgt $I3369, $N3368, 0.0
    unless $I3369, loop3386_done
  loop3386_redo:
    .const 'Sub' $P3371 = "445_1303576195.699" 
    capture_lex $P3371
    $P3371()
  loop3386_next:
    goto loop3386_test
  loop3386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3388, exception, 'type'
    eq $P3388, .CONTROL_LOOP_NEXT, loop3386_next
    eq $P3388, .CONTROL_LOOP_REDO, loop3386_redo
  loop3386_done:
    pop_eh 
.annotate 'line', 1000
    find_lex $P3389, "$/"
    find_lex $P3390, "$past"
    unless_null $P3390, vivify_1735
    new $P3390, "Undef"
  vivify_1735:
    $P3391 = $P3389."!make"($P3390)
.annotate 'line', 987
    .return ($P3391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3370"  :anon :subid("445_1303576195.699") :outer("444_1303576195.699")
.annotate 'line', 996
    new $P3372, "Undef"
    .lex "$else", $P3372
.annotate 'line', 994
    find_lex $P3373, "$count"
    unless_null $P3373, vivify_1727
    new $P3373, "Undef"
  vivify_1727:
    clone $P3374, $P3373
    dec $P3373
.annotate 'line', 996
    find_lex $P3375, "$past"
    unless_null $P3375, vivify_1728
    new $P3375, "Undef"
  vivify_1728:
    store_lex "$else", $P3375
.annotate 'line', 997
    find_lex $P3376, "$count"
    unless_null $P3376, vivify_1729
    new $P3376, "Undef"
  vivify_1729:
    set $I3377, $P3376
    find_lex $P3378, "$/"
    unless_null $P3378, vivify_1730
    $P3378 = root_new ['parrot';'Hash']
  vivify_1730:
    set $P3379, $P3378["xblock"]
    unless_null $P3379, vivify_1731
    $P3379 = root_new ['parrot';'ResizablePMCArray']
  vivify_1731:
    set $P3380, $P3379[$I3377]
    unless_null $P3380, vivify_1732
    new $P3380, "Undef"
  vivify_1732:
    $P3381 = $P3380."ast"()
    $P3382 = "xblock_immediate"($P3381)
    store_lex "$past", $P3382
.annotate 'line', 998
    find_lex $P3383, "$past"
    unless_null $P3383, vivify_1733
    new $P3383, "Undef"
  vivify_1733:
    find_lex $P3384, "$else"
    unless_null $P3384, vivify_1734
    new $P3384, "Undef"
  vivify_1734:
    $P3385 = $P3383."push"($P3384)
.annotate 'line', 994
    .return ($P3385)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("446_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3393
    .param pmc param_3394
.annotate 'line', 1003
    .lex "self", param_3393
    .lex "$/", param_3394
.annotate 'line', 1004
    new $P3395, "Undef"
    .lex "$past", $P3395
    find_lex $P3396, "$/"
    unless_null $P3396, vivify_1736
    $P3396 = root_new ['parrot';'Hash']
  vivify_1736:
    set $P3397, $P3396["xblock"]
    unless_null $P3397, vivify_1737
    new $P3397, "Undef"
  vivify_1737:
    $P3398 = $P3397."ast"()
    $P3399 = "xblock_immediate"($P3398)
    store_lex "$past", $P3399
.annotate 'line', 1005
    find_lex $P3400, "$past"
    unless_null $P3400, vivify_1738
    new $P3400, "Undef"
  vivify_1738:
    $P3400."pasttype"("unless")
.annotate 'line', 1006
    find_lex $P3401, "$/"
    find_lex $P3402, "$past"
    unless_null $P3402, vivify_1739
    new $P3402, "Undef"
  vivify_1739:
    $P3403 = $P3401."!make"($P3402)
.annotate 'line', 1003
    .return ($P3403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("447_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3405
    .param pmc param_3406
.annotate 'line', 1009
    .lex "self", param_3405
    .lex "$/", param_3406
.annotate 'line', 1010
    new $P3407, "Undef"
    .lex "$past", $P3407
    find_lex $P3408, "$/"
    unless_null $P3408, vivify_1740
    $P3408 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3409, $P3408["xblock"]
    unless_null $P3409, vivify_1741
    new $P3409, "Undef"
  vivify_1741:
    $P3410 = $P3409."ast"()
    $P3411 = "xblock_immediate"($P3410)
    store_lex "$past", $P3411
.annotate 'line', 1011
    find_lex $P3412, "$past"
    unless_null $P3412, vivify_1742
    new $P3412, "Undef"
  vivify_1742:
    find_lex $P3413, "$/"
    unless_null $P3413, vivify_1743
    $P3413 = root_new ['parrot';'Hash']
  vivify_1743:
    set $P3414, $P3413["sym"]
    unless_null $P3414, vivify_1744
    new $P3414, "Undef"
  vivify_1744:
    set $S3415, $P3414
    $P3412."pasttype"($S3415)
.annotate 'line', 1012
    find_lex $P3416, "$/"
    find_lex $P3417, "$past"
    unless_null $P3417, vivify_1745
    new $P3417, "Undef"
  vivify_1745:
    $P3418 = $P3416."!make"($P3417)
.annotate 'line', 1009
    .return ($P3418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("448_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3420
    .param pmc param_3421
.annotate 'line', 1015
    .lex "self", param_3420
    .lex "$/", param_3421
.annotate 'line', 1016
    new $P3422, "Undef"
    .lex "$pasttype", $P3422
.annotate 'line', 1017
    new $P3423, "Undef"
    .lex "$past", $P3423
.annotate 'line', 1016
    new $P3424, "String"
    assign $P3424, "repeat_"
    find_lex $P3425, "$/"
    unless_null $P3425, vivify_1746
    $P3425 = root_new ['parrot';'Hash']
  vivify_1746:
    set $P3426, $P3425["wu"]
    unless_null $P3426, vivify_1747
    new $P3426, "Undef"
  vivify_1747:
    set $S3427, $P3426
    concat $P3428, $P3424, $S3427
    store_lex "$pasttype", $P3428
    find_lex $P3429, "$past"
    unless_null $P3429, vivify_1748
    new $P3429, "Undef"
  vivify_1748:
.annotate 'line', 1018
    find_lex $P3431, "$/"
    unless_null $P3431, vivify_1749
    $P3431 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P3432, $P3431["xblock"]
    unless_null $P3432, vivify_1750
    new $P3432, "Undef"
  vivify_1750:
    if $P3432, if_3430
.annotate 'line', 1023
    get_hll_global $P3439, ["PAST"], "Op"
    find_lex $P3440, "$/"
    unless_null $P3440, vivify_1751
    $P3440 = root_new ['parrot';'Hash']
  vivify_1751:
    set $P3441, $P3440["EXPR"]
    unless_null $P3441, vivify_1752
    new $P3441, "Undef"
  vivify_1752:
    $P3442 = $P3441."ast"()
    find_lex $P3443, "$/"
    unless_null $P3443, vivify_1753
    $P3443 = root_new ['parrot';'Hash']
  vivify_1753:
    set $P3444, $P3443["pblock"]
    unless_null $P3444, vivify_1754
    new $P3444, "Undef"
  vivify_1754:
    $P3445 = $P3444."ast"()
    $P3446 = "block_immediate"($P3445)
    find_lex $P3447, "$pasttype"
    unless_null $P3447, vivify_1755
    new $P3447, "Undef"
  vivify_1755:
    find_lex $P3448, "$/"
    unless_null $P3448, vivify_1756
    new $P3448, "Undef"
  vivify_1756:
    $P3449 = $P3439."new"($P3442, $P3446, $P3447 :named("pasttype"), $P3448 :named("node"))
    store_lex "$past", $P3449
.annotate 'line', 1022
    goto if_3430_end
  if_3430:
.annotate 'line', 1019
    find_lex $P3433, "$/"
    unless_null $P3433, vivify_1757
    $P3433 = root_new ['parrot';'Hash']
  vivify_1757:
    set $P3434, $P3433["xblock"]
    unless_null $P3434, vivify_1758
    new $P3434, "Undef"
  vivify_1758:
    $P3435 = $P3434."ast"()
    $P3436 = "xblock_immediate"($P3435)
    store_lex "$past", $P3436
.annotate 'line', 1020
    find_lex $P3437, "$past"
    unless_null $P3437, vivify_1759
    new $P3437, "Undef"
  vivify_1759:
    find_lex $P3438, "$pasttype"
    unless_null $P3438, vivify_1760
    new $P3438, "Undef"
  vivify_1760:
    $P3437."pasttype"($P3438)
  if_3430_end:
.annotate 'line', 1026
    find_lex $P3450, "$/"
    find_lex $P3451, "$past"
    unless_null $P3451, vivify_1761
    new $P3451, "Undef"
  vivify_1761:
    $P3452 = $P3450."!make"($P3451)
.annotate 'line', 1015
    .return ($P3452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("449_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3454
    .param pmc param_3455
.annotate 'line', 1029
    .lex "self", param_3454
    .lex "$/", param_3455
.annotate 'line', 1030
    new $P3456, "Undef"
    .lex "$past", $P3456
.annotate 'line', 1032
    new $P3457, "Undef"
    .lex "$block", $P3457
.annotate 'line', 1030
    find_lex $P3458, "$/"
    unless_null $P3458, vivify_1762
    $P3458 = root_new ['parrot';'Hash']
  vivify_1762:
    set $P3459, $P3458["xblock"]
    unless_null $P3459, vivify_1763
    new $P3459, "Undef"
  vivify_1763:
    $P3460 = $P3459."ast"()
    store_lex "$past", $P3460
.annotate 'line', 1031
    find_lex $P3461, "$past"
    unless_null $P3461, vivify_1764
    new $P3461, "Undef"
  vivify_1764:
    $P3461."pasttype"("for")
.annotate 'line', 1032
    find_lex $P3462, "$past"
    unless_null $P3462, vivify_1765
    $P3462 = root_new ['parrot';'ResizablePMCArray']
  vivify_1765:
    set $P3463, $P3462[1]
    unless_null $P3463, vivify_1766
    new $P3463, "Undef"
  vivify_1766:
    store_lex "$block", $P3463
.annotate 'line', 1033
    find_lex $P3465, "$block"
    unless_null $P3465, vivify_1767
    new $P3465, "Undef"
  vivify_1767:
    $P3466 = $P3465."arity"()
    if $P3466, unless_3464_end
.annotate 'line', 1034
    find_lex $P3467, "$block"
    unless_null $P3467, vivify_1768
    $P3467 = root_new ['parrot';'ResizablePMCArray']
  vivify_1768:
    set $P3468, $P3467[0]
    unless_null $P3468, vivify_1769
    new $P3468, "Undef"
  vivify_1769:
    get_hll_global $P3469, ["PAST"], "Var"
    $P3470 = $P3469."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3468."push"($P3470)
.annotate 'line', 1035
    find_lex $P3471, "$block"
    unless_null $P3471, vivify_1770
    new $P3471, "Undef"
  vivify_1770:
    $P3471."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1036
    find_lex $P3472, "$block"
    unless_null $P3472, vivify_1771
    new $P3472, "Undef"
  vivify_1771:
    $P3472."arity"(1)
  unless_3464_end:
.annotate 'line', 1038
    find_lex $P3473, "$block"
    unless_null $P3473, vivify_1772
    new $P3473, "Undef"
  vivify_1772:
    $P3473."blocktype"("immediate")
.annotate 'line', 1039
    find_lex $P3474, "$/"
    find_lex $P3475, "$past"
    unless_null $P3475, vivify_1773
    new $P3475, "Undef"
  vivify_1773:
    $P3476 = $P3474."!make"($P3475)
.annotate 'line', 1029
    .return ($P3476)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("450_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3478
    .param pmc param_3479
.annotate 'line', 1042
    .lex "self", param_3478
    .lex "$/", param_3479
.annotate 'line', 1043
    new $P3480, "Undef"
    .lex "$block", $P3480
    find_lex $P3481, "$/"
    unless_null $P3481, vivify_1774
    $P3481 = root_new ['parrot';'Hash']
  vivify_1774:
    set $P3482, $P3481["block"]
    unless_null $P3482, vivify_1775
    new $P3482, "Undef"
  vivify_1775:
    $P3483 = $P3482."ast"()
    store_lex "$block", $P3483
.annotate 'line', 1044
    find_lex $P3484, "$/"
    unless_null $P3484, vivify_1776
    new $P3484, "Undef"
  vivify_1776:
    find_lex $P3485, "$block"
    unless_null $P3485, vivify_1777
    new $P3485, "Undef"
  vivify_1777:
    "push_block_handler"($P3484, $P3485)
.annotate 'line', 1045
    find_lex $P3486, "$?PACKAGE"
    get_who $P3487, $P3486
    set $P3488, $P3487["@BLOCK"]
    unless_null $P3488, vivify_1778
    $P3488 = root_new ['parrot';'ResizablePMCArray']
  vivify_1778:
    set $P3489, $P3488[0]
    unless_null $P3489, vivify_1779
    new $P3489, "Undef"
  vivify_1779:
    $P3490 = $P3489."handlers"()
    set $P3491, $P3490[0]
    unless_null $P3491, vivify_1780
    new $P3491, "Undef"
  vivify_1780:
    $P3491."handle_types_except"("CONTROL")
.annotate 'line', 1046
    find_lex $P3492, "$/"
    get_hll_global $P3493, ["PAST"], "Stmts"
    find_lex $P3494, "$/"
    unless_null $P3494, vivify_1781
    new $P3494, "Undef"
  vivify_1781:
    $P3495 = $P3493."new"($P3494 :named("node"))
    $P3496 = $P3492."!make"($P3495)
.annotate 'line', 1042
    .return ($P3496)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("451_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3498
    .param pmc param_3499
.annotate 'line', 1049
    .lex "self", param_3498
    .lex "$/", param_3499
.annotate 'line', 1050
    new $P3500, "Undef"
    .lex "$block", $P3500
    find_lex $P3501, "$/"
    unless_null $P3501, vivify_1782
    $P3501 = root_new ['parrot';'Hash']
  vivify_1782:
    set $P3502, $P3501["block"]
    unless_null $P3502, vivify_1783
    new $P3502, "Undef"
  vivify_1783:
    $P3503 = $P3502."ast"()
    store_lex "$block", $P3503
.annotate 'line', 1051
    find_lex $P3504, "$/"
    unless_null $P3504, vivify_1784
    new $P3504, "Undef"
  vivify_1784:
    find_lex $P3505, "$block"
    unless_null $P3505, vivify_1785
    new $P3505, "Undef"
  vivify_1785:
    "push_block_handler"($P3504, $P3505)
.annotate 'line', 1052
    find_lex $P3506, "$?PACKAGE"
    get_who $P3507, $P3506
    set $P3508, $P3507["@BLOCK"]
    unless_null $P3508, vivify_1786
    $P3508 = root_new ['parrot';'ResizablePMCArray']
  vivify_1786:
    set $P3509, $P3508[0]
    unless_null $P3509, vivify_1787
    new $P3509, "Undef"
  vivify_1787:
    $P3510 = $P3509."handlers"()
    set $P3511, $P3510[0]
    unless_null $P3511, vivify_1788
    new $P3511, "Undef"
  vivify_1788:
    $P3511."handle_types"("CONTROL")
.annotate 'line', 1053
    find_lex $P3512, "$/"
    get_hll_global $P3513, ["PAST"], "Stmts"
    find_lex $P3514, "$/"
    unless_null $P3514, vivify_1789
    new $P3514, "Undef"
  vivify_1789:
    $P3515 = $P3513."new"($P3514 :named("node"))
    $P3516 = $P3512."!make"($P3515)
.annotate 'line', 1049
    .return ($P3516)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("452_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3519
    .param pmc param_3520
.annotate 'line', 1093
    .lex "self", param_3519
    .lex "$/", param_3520
.annotate 'line', 1094
    find_lex $P3521, "$?PACKAGE"
    get_who $P3522, $P3521
    set $P3523, $P3522["@BLOCK"]
    unless_null $P3523, vivify_1790
    $P3523 = root_new ['parrot';'ResizablePMCArray']
  vivify_1790:
    set $P3524, $P3523[0]
    unless_null $P3524, vivify_1791
    new $P3524, "Undef"
  vivify_1791:
    find_lex $P3525, "$/"
    unless_null $P3525, vivify_1792
    $P3525 = root_new ['parrot';'Hash']
  vivify_1792:
    set $P3526, $P3525["blorst"]
    unless_null $P3526, vivify_1793
    new $P3526, "Undef"
  vivify_1793:
    $P3527 = $P3526."ast"()
    $P3524."push"($P3527)
.annotate 'line', 1095
    find_lex $P3528, "$/"
    get_hll_global $P3529, ["PAST"], "Stmts"
    $P3530 = $P3529."new"()
    $P3531 = $P3528."!make"($P3530)
.annotate 'line', 1093
    .return ($P3531)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("453_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3533
    .param pmc param_3534
.annotate 'line', 1098
    .lex "self", param_3533
    .lex "$/", param_3534
.annotate 'line', 1099
    new $P3535, "Undef"
    .lex "$past", $P3535
    find_lex $P3536, "$/"
    unless_null $P3536, vivify_1794
    $P3536 = root_new ['parrot';'Hash']
  vivify_1794:
    set $P3537, $P3536["blorst"]
    unless_null $P3537, vivify_1795
    new $P3537, "Undef"
  vivify_1795:
    $P3538 = $P3537."ast"()
    store_lex "$past", $P3538
.annotate 'line', 1100
    get_hll_global $P3540, ["PAST"], "Block"
    find_lex $P3541, "$past"
    unless_null $P3541, vivify_1796
    new $P3541, "Undef"
  vivify_1796:
    $P3542 = $P3540."ACCEPTS"($P3541)
    if $P3542, unless_3539_end
.annotate 'line', 1101
    get_hll_global $P3543, ["PAST"], "Block"
    find_lex $P3544, "$past"
    unless_null $P3544, vivify_1797
    new $P3544, "Undef"
  vivify_1797:
    find_lex $P3545, "$/"
    unless_null $P3545, vivify_1798
    new $P3545, "Undef"
  vivify_1798:
    $P3546 = $P3543."new"($P3544, "immediate" :named("blocktype"), $P3545 :named("node"))
    store_lex "$past", $P3546
  unless_3539_end:
.annotate 'line', 1103
    find_lex $P3548, "$past"
    unless_null $P3548, vivify_1799
    new $P3548, "Undef"
  vivify_1799:
    $P3549 = $P3548."handlers"()
    if $P3549, unless_3547_end
.annotate 'line', 1104
    find_lex $P3550, "$past"
    unless_null $P3550, vivify_1800
    new $P3550, "Undef"
  vivify_1800:
    get_hll_global $P3551, ["PAST"], "Control"
.annotate 'line', 1106
    get_hll_global $P3552, ["PAST"], "Stmts"
.annotate 'line', 1107
    get_hll_global $P3553, ["PAST"], "Op"
.annotate 'line', 1108
    get_hll_global $P3554, ["PAST"], "Var"
.annotate 'line', 1109
    get_hll_global $P3555, ["PAST"], "Var"
    $P3556 = $P3555."new"("register" :named("scope"), "exception" :named("name"))
    $P3557 = $P3554."new"($P3556, "handled", "keyed" :named("scope"))
.annotate 'line', 1108
    $P3558 = $P3553."new"($P3557, 1, "bind" :named("pasttype"))
.annotate 'line', 1107
    $P3559 = $P3552."new"($P3558)
.annotate 'line', 1106
    $P3560 = $P3551."new"($P3559, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1104
    new $P3561, "ResizablePMCArray"
    push $P3561, $P3560
    $P3550."handlers"($P3561)
  unless_3547_end:
.annotate 'line', 1118
    find_lex $P3562, "$/"
    find_lex $P3563, "$past"
    unless_null $P3563, vivify_1801
    new $P3563, "Undef"
  vivify_1801:
    $P3564 = $P3562."!make"($P3563)
.annotate 'line', 1098
    .return ($P3564)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("454_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3566
    .param pmc param_3567
.annotate 'line', 1121
    .lex "self", param_3566
    .lex "$/", param_3567
.annotate 'line', 1122
    find_lex $P3568, "$/"
.annotate 'line', 1123
    find_lex $P3571, "$/"
    unless_null $P3571, vivify_1802
    $P3571 = root_new ['parrot';'Hash']
  vivify_1802:
    set $P3572, $P3571["block"]
    unless_null $P3572, vivify_1803
    new $P3572, "Undef"
  vivify_1803:
    if $P3572, if_3570
.annotate 'line', 1124
    find_lex $P3577, "$/"
    unless_null $P3577, vivify_1804
    $P3577 = root_new ['parrot';'Hash']
  vivify_1804:
    set $P3578, $P3577["statement"]
    unless_null $P3578, vivify_1805
    new $P3578, "Undef"
  vivify_1805:
    $P3579 = $P3578."ast"()
    set $P3569, $P3579
.annotate 'line', 1123
    goto if_3570_end
  if_3570:
    find_lex $P3573, "$/"
    unless_null $P3573, vivify_1806
    $P3573 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3574, $P3573["block"]
    unless_null $P3574, vivify_1807
    new $P3574, "Undef"
  vivify_1807:
    $P3575 = $P3574."ast"()
    $P3576 = "block_immediate"($P3575)
    set $P3569, $P3576
  if_3570_end:
    $P3580 = $P3568."!make"($P3569)
.annotate 'line', 1121
    .return ($P3580)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("455_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3582
    .param pmc param_3583
.annotate 'line', 1129
    .lex "self", param_3582
    .lex "$/", param_3583
    find_lex $P3584, "$/"
    find_lex $P3585, "$/"
    unless_null $P3585, vivify_1808
    $P3585 = root_new ['parrot';'Hash']
  vivify_1808:
    set $P3586, $P3585["cond"]
    unless_null $P3586, vivify_1809
    new $P3586, "Undef"
  vivify_1809:
    $P3587 = $P3586."ast"()
    $P3588 = $P3584."!make"($P3587)
    .return ($P3588)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("456_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3590
    .param pmc param_3591
.annotate 'line', 1130
    .lex "self", param_3590
    .lex "$/", param_3591
    find_lex $P3592, "$/"
    find_lex $P3593, "$/"
    unless_null $P3593, vivify_1810
    $P3593 = root_new ['parrot';'Hash']
  vivify_1810:
    set $P3594, $P3593["cond"]
    unless_null $P3594, vivify_1811
    new $P3594, "Undef"
  vivify_1811:
    $P3595 = $P3594."ast"()
    $P3596 = $P3592."!make"($P3595)
    .return ($P3596)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("457_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3598
    .param pmc param_3599
.annotate 'line', 1132
    .lex "self", param_3598
    .lex "$/", param_3599
    find_lex $P3600, "$/"
    find_lex $P3601, "$/"
    unless_null $P3601, vivify_1812
    $P3601 = root_new ['parrot';'Hash']
  vivify_1812:
    set $P3602, $P3601["cond"]
    unless_null $P3602, vivify_1813
    new $P3602, "Undef"
  vivify_1813:
    $P3603 = $P3602."ast"()
    $P3604 = $P3600."!make"($P3603)
    .return ($P3604)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("458_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3606
    .param pmc param_3607
.annotate 'line', 1133
    .lex "self", param_3606
    .lex "$/", param_3607
    find_lex $P3608, "$/"
    find_lex $P3609, "$/"
    unless_null $P3609, vivify_1814
    $P3609 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3610, $P3609["cond"]
    unless_null $P3610, vivify_1815
    new $P3610, "Undef"
  vivify_1815:
    $P3611 = $P3610."ast"()
    $P3612 = $P3608."!make"($P3611)
    .return ($P3612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("459_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3614
    .param pmc param_3615
.annotate 'line', 1137
    .lex "self", param_3614
    .lex "$/", param_3615
    find_lex $P3616, "$/"
    find_lex $P3617, "$/"
    unless_null $P3617, vivify_1816
    $P3617 = root_new ['parrot';'Hash']
  vivify_1816:
    set $P3618, $P3617["fatarrow"]
    unless_null $P3618, vivify_1817
    new $P3618, "Undef"
  vivify_1817:
    $P3619 = $P3618."ast"()
    $P3620 = $P3616."!make"($P3619)
    .return ($P3620)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("460_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3622
    .param pmc param_3623
.annotate 'line', 1138
    .lex "self", param_3622
    .lex "$/", param_3623
    find_lex $P3624, "$/"
    find_lex $P3625, "$/"
    unless_null $P3625, vivify_1818
    $P3625 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P3626, $P3625["colonpair"]
    unless_null $P3626, vivify_1819
    new $P3626, "Undef"
  vivify_1819:
    $P3627 = $P3626."ast"()
    $P3628 = $P3624."!make"($P3627)
    .return ($P3628)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("461_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3630
    .param pmc param_3631
.annotate 'line', 1139
    .lex "self", param_3630
    .lex "$/", param_3631
    find_lex $P3632, "$/"
    find_lex $P3633, "$/"
    unless_null $P3633, vivify_1820
    $P3633 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P3634, $P3633["variable"]
    unless_null $P3634, vivify_1821
    new $P3634, "Undef"
  vivify_1821:
    $P3635 = $P3634."ast"()
    $P3636 = $P3632."!make"($P3635)
    .return ($P3636)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("462_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3638
    .param pmc param_3639
.annotate 'line', 1140
    .lex "self", param_3638
    .lex "$/", param_3639
    find_lex $P3640, "$/"
    find_lex $P3641, "$/"
    unless_null $P3641, vivify_1822
    $P3641 = root_new ['parrot';'Hash']
  vivify_1822:
    set $P3642, $P3641["package_declarator"]
    unless_null $P3642, vivify_1823
    new $P3642, "Undef"
  vivify_1823:
    $P3643 = $P3642."ast"()
    $P3644 = $P3640."!make"($P3643)
    .return ($P3644)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("463_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3646
    .param pmc param_3647
.annotate 'line', 1141
    .lex "self", param_3646
    .lex "$/", param_3647
    find_lex $P3648, "$/"
    find_lex $P3649, "$/"
    unless_null $P3649, vivify_1824
    $P3649 = root_new ['parrot';'Hash']
  vivify_1824:
    set $P3650, $P3649["scope_declarator"]
    unless_null $P3650, vivify_1825
    new $P3650, "Undef"
  vivify_1825:
    $P3651 = $P3650."ast"()
    $P3652 = $P3648."!make"($P3651)
    .return ($P3652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("464_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3654
    .param pmc param_3655
.annotate 'line', 1142
    .lex "self", param_3654
    .lex "$/", param_3655
    find_lex $P3656, "$/"
    find_lex $P3657, "$/"
    unless_null $P3657, vivify_1826
    $P3657 = root_new ['parrot';'Hash']
  vivify_1826:
    set $P3658, $P3657["routine_declarator"]
    unless_null $P3658, vivify_1827
    new $P3658, "Undef"
  vivify_1827:
    $P3659 = $P3658."ast"()
    $P3660 = $P3656."!make"($P3659)
    .return ($P3660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("465_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3662
    .param pmc param_3663
.annotate 'line', 1143
    .lex "self", param_3662
    .lex "$/", param_3663
    find_lex $P3664, "$/"
    find_lex $P3665, "$/"
    unless_null $P3665, vivify_1828
    $P3665 = root_new ['parrot';'Hash']
  vivify_1828:
    set $P3666, $P3665["regex_declarator"]
    unless_null $P3666, vivify_1829
    new $P3666, "Undef"
  vivify_1829:
    $P3667 = $P3666."ast"()
    $P3668 = $P3664."!make"($P3667)
    .return ($P3668)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("466_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3670
    .param pmc param_3671
.annotate 'line', 1144
    .lex "self", param_3670
    .lex "$/", param_3671
    find_lex $P3672, "$/"
    find_lex $P3673, "$/"
    unless_null $P3673, vivify_1830
    $P3673 = root_new ['parrot';'Hash']
  vivify_1830:
    set $P3674, $P3673["statement_prefix"]
    unless_null $P3674, vivify_1831
    new $P3674, "Undef"
  vivify_1831:
    $P3675 = $P3674."ast"()
    $P3676 = $P3672."!make"($P3675)
    .return ($P3676)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("467_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3678
    .param pmc param_3679
.annotate 'line', 1145
    .lex "self", param_3678
    .lex "$/", param_3679
    find_lex $P3680, "$/"
    find_lex $P3681, "$/"
    unless_null $P3681, vivify_1832
    $P3681 = root_new ['parrot';'Hash']
  vivify_1832:
    set $P3682, $P3681["pblock"]
    unless_null $P3682, vivify_1833
    new $P3682, "Undef"
  vivify_1833:
    $P3683 = $P3682."ast"()
    $P3684 = $P3680."!make"($P3683)
    .return ($P3684)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("468_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3686
    .param pmc param_3687
.annotate 'line', 1147
    .lex "self", param_3686
    .lex "$/", param_3687
.annotate 'line', 1148
    new $P3688, "Undef"
    .lex "$past", $P3688
    find_lex $P3689, "$/"
    unless_null $P3689, vivify_1834
    $P3689 = root_new ['parrot';'Hash']
  vivify_1834:
    set $P3690, $P3689["val"]
    unless_null $P3690, vivify_1835
    new $P3690, "Undef"
  vivify_1835:
    $P3691 = $P3690."ast"()
    store_lex "$past", $P3691
.annotate 'line', 1149
    find_lex $P3692, "$past"
    unless_null $P3692, vivify_1836
    new $P3692, "Undef"
  vivify_1836:
    find_lex $P3693, "$/"
    unless_null $P3693, vivify_1837
    $P3693 = root_new ['parrot';'Hash']
  vivify_1837:
    set $P3694, $P3693["key"]
    unless_null $P3694, vivify_1838
    new $P3694, "Undef"
  vivify_1838:
    $P3695 = $P3694."Str"()
    $P3692."named"($P3695)
.annotate 'line', 1150
    find_lex $P3696, "$/"
    find_lex $P3697, "$past"
    unless_null $P3697, vivify_1839
    new $P3697, "Undef"
  vivify_1839:
    $P3698 = $P3696."!make"($P3697)
.annotate 'line', 1147
    .return ($P3698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("469_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3700
    .param pmc param_3701
.annotate 'line', 1153
    .lex "self", param_3700
    .lex "$/", param_3701
.annotate 'line', 1154
    new $P3702, "Undef"
    .lex "$past", $P3702
.annotate 'line', 1155
    find_lex $P3705, "$/"
    unless_null $P3705, vivify_1840
    $P3705 = root_new ['parrot';'Hash']
  vivify_1840:
    set $P3706, $P3705["circumfix"]
    unless_null $P3706, vivify_1841
    new $P3706, "Undef"
  vivify_1841:
    if $P3706, if_3704
.annotate 'line', 1156
    get_hll_global $P3711, ["PAST"], "Val"
    find_lex $P3712, "$/"
    unless_null $P3712, vivify_1842
    $P3712 = root_new ['parrot';'Hash']
  vivify_1842:
    set $P3713, $P3712["not"]
    unless_null $P3713, vivify_1843
    new $P3713, "Undef"
  vivify_1843:
    isfalse $I3714, $P3713
    $P3715 = $P3711."new"($I3714 :named("value"))
    set $P3703, $P3715
.annotate 'line', 1155
    goto if_3704_end
  if_3704:
    find_lex $P3707, "$/"
    unless_null $P3707, vivify_1844
    $P3707 = root_new ['parrot';'Hash']
  vivify_1844:
    set $P3708, $P3707["circumfix"]
    unless_null $P3708, vivify_1845
    $P3708 = root_new ['parrot';'ResizablePMCArray']
  vivify_1845:
    set $P3709, $P3708[0]
    unless_null $P3709, vivify_1846
    new $P3709, "Undef"
  vivify_1846:
    $P3710 = $P3709."ast"()
    set $P3703, $P3710
  if_3704_end:
    store_lex "$past", $P3703
.annotate 'line', 1157
    find_lex $P3716, "$past"
    unless_null $P3716, vivify_1847
    new $P3716, "Undef"
  vivify_1847:
    find_lex $P3717, "$/"
    unless_null $P3717, vivify_1848
    $P3717 = root_new ['parrot';'Hash']
  vivify_1848:
    set $P3718, $P3717["identifier"]
    unless_null $P3718, vivify_1849
    new $P3718, "Undef"
  vivify_1849:
    set $S3719, $P3718
    $P3716."named"($S3719)
.annotate 'line', 1158
    find_lex $P3720, "$/"
    find_lex $P3721, "$past"
    unless_null $P3721, vivify_1850
    new $P3721, "Undef"
  vivify_1850:
    $P3722 = $P3720."!make"($P3721)
.annotate 'line', 1153
    .return ($P3722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("470_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3724
    .param pmc param_3725
.annotate 'line', 1161
    .const 'Sub' $P3738 = "471_1303576195.699" 
    capture_lex $P3738
    .lex "self", param_3724
    .lex "$/", param_3725
.annotate 'line', 1162
    new $P3726, "Undef"
    .lex "$past", $P3726
.annotate 'line', 1161
    find_lex $P3727, "$past"
    unless_null $P3727, vivify_1851
    new $P3727, "Undef"
  vivify_1851:
.annotate 'line', 1163
    find_lex $P3729, "$/"
    unless_null $P3729, vivify_1852
    $P3729 = root_new ['parrot';'Hash']
  vivify_1852:
    set $P3730, $P3729["postcircumfix"]
    unless_null $P3730, vivify_1853
    new $P3730, "Undef"
  vivify_1853:
    if $P3730, if_3728
.annotate 'line', 1167
    .const 'Sub' $P3738 = "471_1303576195.699" 
    capture_lex $P3738
    $P3738()
    goto if_3728_end
  if_3728:
.annotate 'line', 1164
    find_lex $P3731, "$/"
    unless_null $P3731, vivify_1889
    $P3731 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P3732, $P3731["postcircumfix"]
    unless_null $P3732, vivify_1890
    new $P3732, "Undef"
  vivify_1890:
    $P3733 = $P3732."ast"()
    store_lex "$past", $P3733
.annotate 'line', 1165
    find_lex $P3734, "$past"
    unless_null $P3734, vivify_1891
    new $P3734, "Undef"
  vivify_1891:
    get_hll_global $P3735, ["PAST"], "Var"
    $P3736 = $P3735."new"("$/" :named("name"))
    $P3734."unshift"($P3736)
  if_3728_end:
.annotate 'line', 1209
    find_lex $P3831, "$/"
    find_lex $P3832, "$past"
    unless_null $P3832, vivify_1892
    new $P3832, "Undef"
  vivify_1892:
    $P3833 = $P3831."!make"($P3832)
.annotate 'line', 1161
    .return ($P3833)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3737"  :anon :subid("471_1303576195.699") :outer("470_1303576195.699")
.annotate 'line', 1168
    $P3739 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3739
    get_hll_global $P3740, ["NQP"], "Compiler"
    find_lex $P3741, "$/"
    unless_null $P3741, vivify_1854
    new $P3741, "Undef"
  vivify_1854:
    set $S3742, $P3741
    $P3743 = $P3740."parse_name"($S3742)
    store_lex "@name", $P3743
.annotate 'line', 1169
    find_lex $P3746, "@name"
    unless_null $P3746, vivify_1855
    $P3746 = root_new ['parrot';'ResizablePMCArray']
  vivify_1855:
    set $N3747, $P3746
    isgt $I3748, $N3747, 1.0
    if $I3748, if_3745
.annotate 'line', 1176
    find_lex $P3764, "$/"
    unless_null $P3764, vivify_1856
    $P3764 = root_new ['parrot';'Hash']
  vivify_1856:
    set $P3765, $P3764["twigil"]
    unless_null $P3765, vivify_1857
    $P3765 = root_new ['parrot';'ResizablePMCArray']
  vivify_1857:
    set $P3766, $P3765[0]
    unless_null $P3766, vivify_1858
    new $P3766, "Undef"
  vivify_1858:
    set $S3767, $P3766
    iseq $I3768, $S3767, "*"
    if $I3768, if_3763
.annotate 'line', 1191
    find_lex $P3792, "$/"
    unless_null $P3792, vivify_1859
    $P3792 = root_new ['parrot';'Hash']
  vivify_1859:
    set $P3793, $P3792["twigil"]
    unless_null $P3793, vivify_1860
    $P3793 = root_new ['parrot';'ResizablePMCArray']
  vivify_1860:
    set $P3794, $P3793[0]
    unless_null $P3794, vivify_1861
    new $P3794, "Undef"
  vivify_1861:
    set $S3795, $P3794
    iseq $I3796, $S3795, "!"
    if $I3796, if_3791
.annotate 'line', 1199
    find_lex $P3811, "@name"
    unless_null $P3811, vivify_1862
    $P3811 = root_new ['parrot';'ResizablePMCArray']
  vivify_1862:
    set $P3812, $P3811[0]
    unless_null $P3812, vivify_1863
    new $P3812, "Undef"
  vivify_1863:
    set $S3813, $P3812
    $P3814 = "is_package"($S3813)
    if $P3814, if_3810
.annotate 'line', 1204
    get_hll_global $P3823, ["PAST"], "Var"
.annotate 'line', 1205
    find_lex $P3824, "@name"
    unless_null $P3824, vivify_1864
    $P3824 = root_new ['parrot';'ResizablePMCArray']
  vivify_1864:
    $P3825 = $P3824."pop"()
    set $S3826, $P3825
    find_lex $P3827, "$/"
    unless_null $P3827, vivify_1865
    $P3827 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3828, $P3827["sigil"]
    unless_null $P3828, vivify_1866
    new $P3828, "Undef"
  vivify_1866:
    $P3829 = "vivitype"($P3828)
    $P3830 = $P3823."new"($S3826 :named("name"), $P3829 :named("viviself"))
.annotate 'line', 1204
    store_lex "$past", $P3830
.annotate 'line', 1203
    set $P3809, $P3830
.annotate 'line', 1199
    goto if_3810_end
  if_3810:
.annotate 'line', 1200
    find_lex $P3815, "@name"
    unless_null $P3815, vivify_1867
    $P3815 = root_new ['parrot';'ResizablePMCArray']
  vivify_1867:
    find_lex $P3816, "$/"
    unless_null $P3816, vivify_1868
    new $P3816, "Undef"
  vivify_1868:
    $P3817 = "lexical_package_lookup"($P3815, $P3816)
    store_lex "$past", $P3817
.annotate 'line', 1201
    find_lex $P3818, "$past"
    unless_null $P3818, vivify_1869
    new $P3818, "Undef"
  vivify_1869:
    find_lex $P3819, "$/"
    unless_null $P3819, vivify_1870
    $P3819 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P3820, $P3819["sigil"]
    unless_null $P3820, vivify_1871
    new $P3820, "Undef"
  vivify_1871:
    $P3821 = "vivitype"($P3820)
    $P3822 = $P3818."viviself"($P3821)
.annotate 'line', 1199
    set $P3809, $P3822
  if_3810_end:
    set $P3790, $P3809
.annotate 'line', 1191
    goto if_3791_end
  if_3791:
.annotate 'line', 1192
    get_hll_global $P3797, ["PAST"], "Var"
.annotate 'line', 1193
    find_lex $P3798, "@name"
    unless_null $P3798, vivify_1872
    $P3798 = root_new ['parrot';'ResizablePMCArray']
  vivify_1872:
    $P3799 = $P3798."pop"()
    set $S3800, $P3799
.annotate 'line', 1194
    find_lex $P3801, "$/"
    unless_null $P3801, vivify_1873
    $P3801 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P3802, $P3801["sigil"]
    unless_null $P3802, vivify_1874
    new $P3802, "Undef"
  vivify_1874:
    $P3803 = "vivitype"($P3802)
.annotate 'line', 1195
    get_hll_global $P3804, ["PAST"], "Var"
    $P3805 = $P3804."new"("self" :named("name"))
.annotate 'line', 1196
    get_hll_global $P3806, ["PAST"], "Var"
    $P3807 = $P3806."new"("$?CLASS" :named("name"))
    $P3808 = $P3797."new"($P3805, $P3807, $S3800 :named("name"), "attribute" :named("scope"), $P3803 :named("viviself"))
.annotate 'line', 1192
    store_lex "$past", $P3808
.annotate 'line', 1191
    set $P3790, $P3808
  if_3791_end:
    set $P3762, $P3790
.annotate 'line', 1176
    goto if_3763_end
  if_3763:
.annotate 'line', 1177
    get_hll_global $P3769, ["PAST"], "Var"
.annotate 'line', 1178
    find_lex $P3770, "@name"
    unless_null $P3770, vivify_1875
    $P3770 = root_new ['parrot';'ResizablePMCArray']
  vivify_1875:
    $P3771 = $P3770."pop"()
    set $S3772, $P3771
.annotate 'line', 1180
    get_hll_global $P3773, ["PAST"], "Var"
.annotate 'line', 1182
    find_lex $P3774, "$/"
    unless_null $P3774, vivify_1876
    $P3774 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P3775, $P3774["sigil"]
    unless_null $P3775, vivify_1877
    new $P3775, "Undef"
  vivify_1877:
    set $S3776, $P3775
    new $P3777, 'String'
    set $P3777, $S3776
    find_lex $P3778, "$/"
    unless_null $P3778, vivify_1878
    $P3778 = root_new ['parrot';'Hash']
  vivify_1878:
    set $P3779, $P3778["desigilname"]
    unless_null $P3779, vivify_1879
    new $P3779, "Undef"
  vivify_1879:
    concat $P3780, $P3777, $P3779
.annotate 'line', 1184
    get_hll_global $P3781, ["PAST"], "Op"
    new $P3782, "String"
    assign $P3782, "Contextual "
    find_lex $P3783, "$/"
    unless_null $P3783, vivify_1880
    new $P3783, "Undef"
  vivify_1880:
    set $S3784, $P3783
    concat $P3785, $P3782, $S3784
    concat $P3786, $P3785, " not found"
    $P3787 = $P3781."new"($P3786, "die" :named("pirop"))
    $P3788 = $P3773."new"("package" :named("scope"), "" :named("namespace"), $P3780 :named("name"), $P3787 :named("viviself"))
.annotate 'line', 1180
    $P3789 = $P3769."new"($S3772 :named("name"), "contextual" :named("scope"), $P3788 :named("viviself"))
.annotate 'line', 1177
    store_lex "$past", $P3789
.annotate 'line', 1176
    set $P3762, $P3789
  if_3763_end:
    set $P3744, $P3762
.annotate 'line', 1169
    goto if_3745_end
  if_3745:
.annotate 'line', 1170
    find_lex $P3750, "$/"
    unless_null $P3750, vivify_1881
    $P3750 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P3751, $P3750["twigil"]
    unless_null $P3751, vivify_1882
    new $P3751, "Undef"
  vivify_1882:
    unless $P3751, if_3749_end
.annotate 'line', 1171
    find_lex $P3752, "$/"
    unless_null $P3752, vivify_1883
    new $P3752, "Undef"
  vivify_1883:
    $P3753 = $P3752."CURSOR"()
    $P3753."panic"("Twigil not allowed on multi-part name")
  if_3749_end:
.annotate 'line', 1173
    find_lex $P3754, "@name"
    unless_null $P3754, vivify_1884
    $P3754 = root_new ['parrot';'ResizablePMCArray']
  vivify_1884:
    find_lex $P3755, "$/"
    unless_null $P3755, vivify_1885
    new $P3755, "Undef"
  vivify_1885:
    $P3756 = "lexical_package_lookup"($P3754, $P3755)
    store_lex "$past", $P3756
.annotate 'line', 1174
    find_lex $P3757, "$past"
    unless_null $P3757, vivify_1886
    new $P3757, "Undef"
  vivify_1886:
    find_lex $P3758, "$/"
    unless_null $P3758, vivify_1887
    $P3758 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3759, $P3758["sigil"]
    unless_null $P3759, vivify_1888
    new $P3759, "Undef"
  vivify_1888:
    $P3760 = "vivitype"($P3759)
    $P3761 = $P3757."viviself"($P3760)
.annotate 'line', 1169
    set $P3744, $P3761
  if_3745_end:
.annotate 'line', 1167
    .return ($P3744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("472_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3835
    .param pmc param_3836
.annotate 'line', 1212
    .lex "self", param_3835
    .lex "$/", param_3836
    find_lex $P3837, "$/"
    find_lex $P3838, "$/"
    unless_null $P3838, vivify_1893
    $P3838 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3839, $P3838["package_def"]
    unless_null $P3839, vivify_1894
    new $P3839, "Undef"
  vivify_1894:
    $P3840 = $P3839."ast"()
    $P3841 = $P3837."!make"($P3840)
    .return ($P3841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("473_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3843
    .param pmc param_3844
.annotate 'line', 1213
    .lex "self", param_3843
    .lex "$/", param_3844
    find_lex $P3845, "$/"
    find_lex $P3846, "$/"
    unless_null $P3846, vivify_1895
    $P3846 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P3847, $P3846["package_def"]
    unless_null $P3847, vivify_1896
    new $P3847, "Undef"
  vivify_1896:
    $P3848 = $P3847."ast"()
    $P3849 = $P3845."!make"($P3848)
    .return ($P3849)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("474_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3851
    .param pmc param_3852
.annotate 'line', 1214
    .lex "self", param_3851
    .lex "$/", param_3852
    find_lex $P3853, "$/"
    find_lex $P3854, "$/"
    unless_null $P3854, vivify_1897
    $P3854 = root_new ['parrot';'Hash']
  vivify_1897:
    set $P3855, $P3854["package_def"]
    unless_null $P3855, vivify_1898
    new $P3855, "Undef"
  vivify_1898:
    $P3856 = $P3855."ast"()
    $P3857 = $P3853."!make"($P3856)
    .return ($P3857)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("475_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3859
    .param pmc param_3860
.annotate 'line', 1215
    .lex "self", param_3859
    .lex "$/", param_3860
    find_lex $P3861, "$/"
    find_lex $P3862, "$/"
    unless_null $P3862, vivify_1899
    $P3862 = root_new ['parrot';'Hash']
  vivify_1899:
    set $P3863, $P3862["package_def"]
    unless_null $P3863, vivify_1900
    new $P3863, "Undef"
  vivify_1900:
    $P3864 = $P3863."ast"()
    $P3865 = $P3861."!make"($P3864)
    .return ($P3865)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("476_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3867
    .param pmc param_3868
.annotate 'line', 1216
    .lex "self", param_3867
    .lex "$/", param_3868
    find_lex $P3869, "$/"
    find_lex $P3870, "$/"
    unless_null $P3870, vivify_1901
    $P3870 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P3871, $P3870["package_def"]
    unless_null $P3871, vivify_1902
    new $P3871, "Undef"
  vivify_1902:
    $P3872 = $P3871."ast"()
    $P3873 = $P3869."!make"($P3872)
    .return ($P3873)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("477_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3875
    .param pmc param_3876
.annotate 'line', 1217
    .lex "self", param_3875
    .lex "$/", param_3876
    find_lex $P3877, "$/"
    find_lex $P3878, "$/"
    unless_null $P3878, vivify_1903
    $P3878 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P3879, $P3878["package_def"]
    unless_null $P3879, vivify_1904
    new $P3879, "Undef"
  vivify_1904:
    $P3880 = $P3879."ast"()
    $P3881 = $P3877."!make"($P3880)
    .return ($P3881)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("478_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_3883
    .param pmc param_3884
.annotate 'line', 1219
    .const 'Sub' $P4033 = "480_1303576195.699" 
    capture_lex $P4033
    .const 'Sub' $P3975 = "479_1303576195.699" 
    capture_lex $P3975
    .lex "self", param_3883
    .lex "$/", param_3884
.annotate 'line', 1221
    $P3885 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3885
.annotate 'line', 1222
    new $P3886, "Undef"
    .lex "$name", $P3886
.annotate 'line', 1223
    new $P3887, "Undef"
    .lex "$how", $P3887
.annotate 'line', 1226
    new $P3888, "Undef"
    .lex "$past", $P3888
.annotate 'line', 1221
    find_lex $P3889, "$/"
    unless_null $P3889, vivify_1905
    $P3889 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3890, $P3889["name"]
    unless_null $P3890, vivify_1906
    $P3890 = root_new ['parrot';'Hash']
  vivify_1906:
    set $P3891, $P3890["identifier"]
    unless_null $P3891, vivify_1907
    new $P3891, "Undef"
  vivify_1907:
    clone $P3892, $P3891
    store_lex "@ns", $P3892
.annotate 'line', 1222
    find_lex $P3893, "@ns"
    unless_null $P3893, vivify_1908
    $P3893 = root_new ['parrot';'ResizablePMCArray']
  vivify_1908:
    $P3894 = $P3893."pop"()
    set $S3895, $P3894
    new $P3896, 'String'
    set $P3896, $S3895
    store_lex "$name", $P3896
.annotate 'line', 1223
    find_dynamic_lex $P3897, "$*PKGDECL"
    unless_null $P3897, vivify_1909
    get_hll_global $P3897, "$PKGDECL"
    unless_null $P3897, vivify_1910
    die "Contextual $*PKGDECL not found"
  vivify_1910:
  vivify_1909:
    find_dynamic_lex $P3898, "%*HOW"
    unless_null $P3898, vivify_1911
    get_hll_global $P3898, "%HOW"
    unless_null $P3898, vivify_1912
    die "Contextual %*HOW not found"
  vivify_1912:
  vivify_1911:
    set $P3899, $P3898[$P3897]
    unless_null $P3899, vivify_1913
    new $P3899, "Undef"
  vivify_1913:
    store_lex "$how", $P3899
.annotate 'line', 1226
    find_lex $P3902, "$/"
    unless_null $P3902, vivify_1914
    $P3902 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P3903, $P3902["block"]
    unless_null $P3903, vivify_1915
    new $P3903, "Undef"
  vivify_1915:
    if $P3903, if_3901
    find_lex $P3907, "$/"
    unless_null $P3907, vivify_1916
    $P3907 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P3908, $P3907["comp_unit"]
    unless_null $P3908, vivify_1917
    new $P3908, "Undef"
  vivify_1917:
    $P3909 = $P3908."ast"()
    set $P3900, $P3909
    goto if_3901_end
  if_3901:
    find_lex $P3904, "$/"
    unless_null $P3904, vivify_1918
    $P3904 = root_new ['parrot';'Hash']
  vivify_1918:
    set $P3905, $P3904["block"]
    unless_null $P3905, vivify_1919
    new $P3905, "Undef"
  vivify_1919:
    $P3906 = $P3905."ast"()
    set $P3900, $P3906
  if_3901_end:
    store_lex "$past", $P3900
.annotate 'line', 1227
    find_dynamic_lex $P3913, "$*SCOPE"
    unless_null $P3913, vivify_1920
    get_hll_global $P3913, "$SCOPE"
    unless_null $P3913, vivify_1921
    die "Contextual $*SCOPE not found"
  vivify_1921:
  vivify_1920:
    set $S3914, $P3913
    iseq $I3915, $S3914, "our"
    unless $I3915, unless_3912
    new $P3911, 'Integer'
    set $P3911, $I3915
    goto unless_3912_end
  unless_3912:
    find_dynamic_lex $P3916, "$*SCOPE"
    unless_null $P3916, vivify_1922
    get_hll_global $P3916, "$SCOPE"
    unless_null $P3916, vivify_1923
    die "Contextual $*SCOPE not found"
  vivify_1923:
  vivify_1922:
    set $S3917, $P3916
    iseq $I3918, $S3917, ""
    new $P3911, 'Integer'
    set $P3911, $I3918
  unless_3912_end:
    unless $P3911, if_3910_end
.annotate 'line', 1228
    find_lex $P3919, "$past"
    unless_null $P3919, vivify_1924
    new $P3919, "Undef"
  vivify_1924:
    find_lex $P3920, "$/"
    unless_null $P3920, vivify_1925
    $P3920 = root_new ['parrot';'Hash']
  vivify_1925:
    set $P3921, $P3920["name"]
    unless_null $P3921, vivify_1926
    $P3921 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P3922, $P3921["identifier"]
    unless_null $P3922, vivify_1927
    new $P3922, "Undef"
  vivify_1927:
    $P3919."namespace"($P3922)
  if_3910_end:
.annotate 'line', 1232
    find_dynamic_lex $P3923, "$*PACKAGE-SETUP"
    unless_null $P3923, vivify_1928
    get_hll_global $P3923, "$PACKAGE-SETUP"
    unless_null $P3923, vivify_1929
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1929:
  vivify_1928:
    get_hll_global $P3924, ["PAST"], "Stmts"
.annotate 'line', 1233
    get_hll_global $P3925, ["PAST"], "Op"
.annotate 'line', 1234
    get_hll_global $P3926, ["PAST"], "Var"
    $P3927 = $P3926."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1235
    find_dynamic_lex $P3928, "$*SC"
    unless_null $P3928, vivify_1930
    get_hll_global $P3928, "$SC"
    unless_null $P3928, vivify_1931
    die "Contextual $*SC not found"
  vivify_1931:
  vivify_1930:
    find_dynamic_lex $P3929, "$*PACKAGE"
    unless_null $P3929, vivify_1932
    get_hll_global $P3929, "$PACKAGE"
    unless_null $P3929, vivify_1933
    die "Contextual $*PACKAGE not found"
  vivify_1933:
  vivify_1932:
    $P3930 = $P3928."get_slot_past_for_object"($P3929)
    $P3931 = $P3925."new"($P3927, $P3930, "bind" :named("pasttype"))
.annotate 'line', 1233
    $P3932 = $P3924."new"($P3931)
.annotate 'line', 1232
    $P3923."unshift"($P3932)
.annotate 'line', 1244
    find_lex $P3936, "$how"
    unless_null $P3936, vivify_1934
    new $P3936, "Undef"
  vivify_1934:
    can $I3937, $P3936, "parametric"
    if $I3937, if_3935
    new $P3934, 'Integer'
    set $P3934, $I3937
    goto if_3935_end
  if_3935:
    find_lex $P3938, "$how"
    unless_null $P3938, vivify_1935
    new $P3938, "Undef"
  vivify_1935:
    find_lex $P3939, "$how"
    unless_null $P3939, vivify_1936
    new $P3939, "Undef"
  vivify_1936:
    $P3940 = $P3938."parametric"($P3939)
    set $P3934, $P3940
  if_3935_end:
    if $P3934, if_3933
.annotate 'line', 1262
    find_lex $P3964, "$past"
    unless_null $P3964, vivify_1937
    new $P3964, "Undef"
  vivify_1937:
    $P3964."blocktype"("immediate")
.annotate 'line', 1263
    find_dynamic_lex $P3965, "$*SC"
    unless_null $P3965, vivify_1938
    get_hll_global $P3965, "$SC"
    unless_null $P3965, vivify_1939
    die "Contextual $*SC not found"
  vivify_1939:
  vivify_1938:
    find_lex $P3966, "$past"
    unless_null $P3966, vivify_1940
    new $P3966, "Undef"
  vivify_1940:
    find_dynamic_lex $P3967, "$*PACKAGE"
    unless_null $P3967, vivify_1941
    get_hll_global $P3967, "$PACKAGE"
    unless_null $P3967, vivify_1942
    die "Contextual $*PACKAGE not found"
  vivify_1942:
  vivify_1941:
    $P3965."install_lexical_symbol"($P3966, "$?PACKAGE", $P3967)
.annotate 'line', 1264
    find_dynamic_lex $P3968, "$*SC"
    unless_null $P3968, vivify_1943
    get_hll_global $P3968, "$SC"
    unless_null $P3968, vivify_1944
    die "Contextual $*SC not found"
  vivify_1944:
  vivify_1943:
    find_lex $P3969, "$past"
    unless_null $P3969, vivify_1945
    new $P3969, "Undef"
  vivify_1945:
    find_dynamic_lex $P3970, "$*PACKAGE"
    unless_null $P3970, vivify_1946
    get_hll_global $P3970, "$PACKAGE"
    unless_null $P3970, vivify_1947
    die "Contextual $*PACKAGE not found"
  vivify_1947:
  vivify_1946:
    $P3968."install_lexical_symbol"($P3969, "$?CLASS", $P3970)
.annotate 'line', 1261
    goto if_3933_end
  if_3933:
.annotate 'line', 1245
    find_lex $P3941, "$past"
    unless_null $P3941, vivify_1948
    new $P3941, "Undef"
  vivify_1948:
    $P3941."blocktype"("declaration")
.annotate 'line', 1246
    find_lex $P3942, "$past"
    unless_null $P3942, vivify_1949
    new $P3942, "Undef"
  vivify_1949:
    get_hll_global $P3943, ["PAST"], "Var"
    $P3944 = $P3943."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3942."unshift"($P3944)
.annotate 'line', 1247
    find_lex $P3945, "$past"
    unless_null $P3945, vivify_1950
    new $P3945, "Undef"
  vivify_1950:
    $P3945."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1248
    find_dynamic_lex $P3946, "$*PACKAGE-SETUP"
    unless_null $P3946, vivify_1951
    get_hll_global $P3946, "$PACKAGE-SETUP"
    unless_null $P3946, vivify_1952
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1952:
  vivify_1951:
    get_hll_global $P3947, ["PAST"], "Op"
.annotate 'line', 1250
    get_hll_global $P3948, ["PAST"], "Op"
.annotate 'line', 1253
    get_hll_global $P3949, ["PAST"], "Var"
    $P3950 = $P3949."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3951 = $P3948."new"($P3950, "get_how PP" :named("pirop"))
.annotate 'line', 1255
    get_hll_global $P3952, ["PAST"], "Var"
    $P3953 = $P3952."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1256
    get_hll_global $P3954, ["PAST"], "Val"
    find_lex $P3955, "$past"
    unless_null $P3955, vivify_1953
    new $P3955, "Undef"
  vivify_1953:
    $P3956 = $P3954."new"($P3955 :named("value"))
    $P3957 = $P3947."new"($P3951, $P3953, $P3956, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1248
    $P3946."push"($P3957)
.annotate 'line', 1258
    find_dynamic_lex $P3958, "$*SC"
    unless_null $P3958, vivify_1954
    get_hll_global $P3958, "$SC"
    unless_null $P3958, vivify_1955
    die "Contextual $*SC not found"
  vivify_1955:
  vivify_1954:
    find_lex $P3959, "$past"
    unless_null $P3959, vivify_1956
    new $P3959, "Undef"
  vivify_1956:
    find_dynamic_lex $P3960, "$*PACKAGE"
    unless_null $P3960, vivify_1957
    get_hll_global $P3960, "$PACKAGE"
    unless_null $P3960, vivify_1958
    die "Contextual $*PACKAGE not found"
  vivify_1958:
  vivify_1957:
    $P3958."install_lexical_symbol"($P3959, "$?PACKAGE", $P3960)
.annotate 'line', 1259
    find_dynamic_lex $P3961, "$*SC"
    unless_null $P3961, vivify_1959
    get_hll_global $P3961, "$SC"
    unless_null $P3961, vivify_1960
    die "Contextual $*SC not found"
  vivify_1960:
  vivify_1959:
    find_lex $P3962, "$past"
    unless_null $P3962, vivify_1961
    new $P3962, "Undef"
  vivify_1961:
    find_dynamic_lex $P3963, "$*PACKAGE"
    unless_null $P3963, vivify_1962
    get_hll_global $P3963, "$PACKAGE"
    unless_null $P3963, vivify_1963
    die "Contextual $*PACKAGE not found"
  vivify_1963:
  vivify_1962:
    $P3961."install_lexical_symbol"($P3962, "$?ROLE", $P3963)
  if_3933_end:
.annotate 'line', 1269
    find_lex $P3972, "$/"
    unless_null $P3972, vivify_1964
    $P3972 = root_new ['parrot';'Hash']
  vivify_1964:
    set $P3973, $P3972["parent"]
    unless_null $P3973, vivify_1965
    new $P3973, "Undef"
  vivify_1965:
    if $P3973, if_3971
.annotate 'line', 1283
    find_lex $P4003, "$how"
    unless_null $P4003, vivify_1966
    new $P4003, "Undef"
  vivify_1966:
    can $I4004, $P4003, "set_default_parent"
    unless $I4004, if_4002_end
.annotate 'line', 1285
    find_dynamic_lex $P4005, "$*PACKAGE-SETUP"
    unless_null $P4005, vivify_1967
    get_hll_global $P4005, "$PACKAGE-SETUP"
    unless_null $P4005, vivify_1968
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1968:
  vivify_1967:
    get_hll_global $P4006, ["PAST"], "Op"
.annotate 'line', 1287
    get_hll_global $P4007, ["PAST"], "Op"
.annotate 'line', 1290
    get_hll_global $P4008, ["PAST"], "Var"
    $P4009 = $P4008."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4010 = $P4007."new"($P4009, "get_how PP" :named("pirop"))
.annotate 'line', 1292
    get_hll_global $P4011, ["PAST"], "Var"
    $P4012 = $P4011."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1293
    find_dynamic_lex $P4015, "$*PKGDECL"
    unless_null $P4015, vivify_1969
    get_hll_global $P4015, "$PKGDECL"
    unless_null $P4015, vivify_1970
    die "Contextual $*PKGDECL not found"
  vivify_1970:
  vivify_1969:
    set $S4016, $P4015
    iseq $I4017, $S4016, "grammar"
    if $I4017, if_4014
.annotate 'line', 1295
    find_dynamic_lex $P4020, "$*SC"
    unless_null $P4020, vivify_1971
    get_hll_global $P4020, "$SC"
    unless_null $P4020, vivify_1972
    die "Contextual $*SC not found"
  vivify_1972:
  vivify_1971:
    $P4021 = "find_lex"("NQPMu")
    $P4022 = $P4020."get_object_sc_ref_past"($P4021)
    set $P4013, $P4022
.annotate 'line', 1293
    goto if_4014_end
  if_4014:
.annotate 'line', 1294
    get_hll_global $P4018, ["PAST"], "Var"
    $P4019 = $P4018."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    set $P4013, $P4019
  if_4014_end:
.annotate 'line', 1293
    $P4023 = $P4006."new"($P4010, $P4012, $P4013, "callmethod" :named("pasttype"), "set_default_parent" :named("name"))
.annotate 'line', 1285
    $P4005."push"($P4023)
  if_4002_end:
.annotate 'line', 1283
    goto if_3971_end
  if_3971:
.annotate 'line', 1269
    .const 'Sub' $P3975 = "479_1303576195.699" 
    capture_lex $P3975
    $P3975()
  if_3971_end:
.annotate 'line', 1300
    find_lex $P4025, "$/"
    unless_null $P4025, vivify_1982
    $P4025 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P4026, $P4025["role"]
    unless_null $P4026, vivify_1983
    new $P4026, "Undef"
  vivify_1983:
    unless $P4026, if_4024_end
.annotate 'line', 1301
    find_lex $P4028, "$/"
    unless_null $P4028, vivify_1984
    $P4028 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4029, $P4028["role"]
    unless_null $P4029, vivify_1985
    new $P4029, "Undef"
  vivify_1985:
    defined $I4030, $P4029
    unless $I4030, for_undef_1986
    iter $P4027, $P4029
    new $P4060, 'ExceptionHandler'
    set_label $P4060, loop4059_handler
    $P4060."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4060
  loop4059_test:
    unless $P4027, loop4059_done
    shift $P4031, $P4027
  loop4059_redo:
    .const 'Sub' $P4033 = "480_1303576195.699" 
    capture_lex $P4033
    $P4033($P4031)
  loop4059_next:
    goto loop4059_test
  loop4059_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4061, exception, 'type'
    eq $P4061, .CONTROL_LOOP_NEXT, loop4059_next
    eq $P4061, .CONTROL_LOOP_REDO, loop4059_redo
  loop4059_done:
    pop_eh 
  for_undef_1986:
  if_4024_end:
.annotate 'line', 1318
    find_dynamic_lex $P4062, "$*PACKAGE-SETUP"
    unless_null $P4062, vivify_1994
    get_hll_global $P4062, "$PACKAGE-SETUP"
    unless_null $P4062, vivify_1995
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1995:
  vivify_1994:
    get_hll_global $P4063, ["PAST"], "Op"
.annotate 'line', 1320
    get_hll_global $P4064, ["PAST"], "Op"
.annotate 'line', 1323
    get_hll_global $P4065, ["PAST"], "Var"
    $P4066 = $P4065."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4067 = $P4064."new"($P4066, "get_how PP" :named("pirop"))
.annotate 'line', 1325
    get_hll_global $P4068, ["PAST"], "Var"
    $P4069 = $P4068."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4070 = $P4063."new"($P4067, $P4069, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1318
    $P4062."push"($P4070)
.annotate 'line', 1329
    find_lex $P4071, "$past"
    unless_null $P4071, vivify_1996
    new $P4071, "Undef"
  vivify_1996:
    $P4072 = $P4071."loadinit"()
    get_hll_global $P4073, ["PAST"], "Block"
    find_dynamic_lex $P4074, "$*PACKAGE-SETUP"
    unless_null $P4074, vivify_1997
    get_hll_global $P4074, "$PACKAGE-SETUP"
    unless_null $P4074, vivify_1998
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1998:
  vivify_1997:
    $P4075 = $P4073."new"($P4074, "immediate" :named("blocktype"))
    $P4072."push"($P4075)
.annotate 'line', 1331
    find_lex $P4076, "$/"
    find_lex $P4077, "$past"
    unless_null $P4077, vivify_1999
    new $P4077, "Undef"
  vivify_1999:
    $P4078 = $P4076."!make"($P4077)
.annotate 'line', 1219
    .return ($P4078)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3974"  :anon :subid("479_1303576195.699") :outer("478_1303576195.699")
.annotate 'line', 1270
    $P3976 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3976
.annotate 'line', 1271
    new $P3977, "Undef"
    .lex "$name", $P3977
.annotate 'line', 1270
    find_lex $P3978, "$/"
    unless_null $P3978, vivify_1973
    $P3978 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P3979, $P3978["parent"]
    unless_null $P3979, vivify_1974
    $P3979 = root_new ['parrot';'ResizablePMCArray']
  vivify_1974:
    set $P3980, $P3979[0]
    unless_null $P3980, vivify_1975
    $P3980 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P3981, $P3980["identifier"]
    unless_null $P3981, vivify_1976
    new $P3981, "Undef"
  vivify_1976:
    clone $P3982, $P3981
    store_lex "@ns", $P3982
.annotate 'line', 1271
    find_lex $P3983, "@ns"
    unless_null $P3983, vivify_1977
    $P3983 = root_new ['parrot';'ResizablePMCArray']
  vivify_1977:
    $P3984 = $P3983."pop"()
    set $S3985, $P3984
    new $P3986, 'String'
    set $P3986, $S3985
    store_lex "$name", $P3986
.annotate 'line', 1272
    find_dynamic_lex $P3987, "$*PACKAGE-SETUP"
    unless_null $P3987, vivify_1978
    get_hll_global $P3987, "$PACKAGE-SETUP"
    unless_null $P3987, vivify_1979
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1979:
  vivify_1978:
    get_hll_global $P3988, ["PAST"], "Op"
.annotate 'line', 1274
    get_hll_global $P3989, ["PAST"], "Op"
.annotate 'line', 1277
    get_hll_global $P3990, ["PAST"], "Var"
    $P3991 = $P3990."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3992 = $P3989."new"($P3991, "get_how PP" :named("pirop"))
.annotate 'line', 1279
    get_hll_global $P3993, ["PAST"], "Var"
    $P3994 = $P3993."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1280
    get_hll_global $P3995, ["PAST"], "Var"
    find_lex $P3996, "$name"
    unless_null $P3996, vivify_1980
    new $P3996, "Undef"
  vivify_1980:
    set $S3997, $P3996
    find_lex $P3998, "@ns"
    unless_null $P3998, vivify_1981
    $P3998 = root_new ['parrot';'ResizablePMCArray']
  vivify_1981:
    $P3999 = $P3995."new"($S3997 :named("name"), $P3998 :named("namespace"), "package" :named("scope"))
    $P4000 = $P3988."new"($P3992, $P3994, $P3999, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1272
    $P4001 = $P3987."push"($P4000)
.annotate 'line', 1269
    .return ($P4001)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4032"  :anon :subid("480_1303576195.699") :outer("478_1303576195.699")
    .param pmc param_4036
.annotate 'line', 1302
    $P4034 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4034
.annotate 'line', 1303
    new $P4035, "Undef"
    .lex "$name", $P4035
    .lex "$_", param_4036
.annotate 'line', 1302
    find_lex $P4037, "$_"
    unless_null $P4037, vivify_1987
    $P4037 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P4038, $P4037["identifier"]
    unless_null $P4038, vivify_1988
    new $P4038, "Undef"
  vivify_1988:
    clone $P4039, $P4038
    store_lex "@ns", $P4039
.annotate 'line', 1303
    find_lex $P4040, "@ns"
    unless_null $P4040, vivify_1989
    $P4040 = root_new ['parrot';'ResizablePMCArray']
  vivify_1989:
    $P4041 = $P4040."pop"()
    set $S4042, $P4041
    new $P4043, 'String'
    set $P4043, $S4042
    store_lex "$name", $P4043
.annotate 'line', 1304
    find_dynamic_lex $P4044, "$*PACKAGE-SETUP"
    unless_null $P4044, vivify_1990
    get_hll_global $P4044, "$PACKAGE-SETUP"
    unless_null $P4044, vivify_1991
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1991:
  vivify_1990:
    get_hll_global $P4045, ["PAST"], "Op"
.annotate 'line', 1306
    get_hll_global $P4046, ["PAST"], "Op"
.annotate 'line', 1309
    get_hll_global $P4047, ["PAST"], "Var"
    $P4048 = $P4047."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4049 = $P4046."new"($P4048, "get_how PP" :named("pirop"))
.annotate 'line', 1311
    get_hll_global $P4050, ["PAST"], "Var"
    $P4051 = $P4050."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1312
    get_hll_global $P4052, ["PAST"], "Var"
    find_lex $P4053, "$name"
    unless_null $P4053, vivify_1992
    new $P4053, "Undef"
  vivify_1992:
    set $S4054, $P4053
    find_lex $P4055, "@ns"
    unless_null $P4055, vivify_1993
    $P4055 = root_new ['parrot';'ResizablePMCArray']
  vivify_1993:
    $P4056 = $P4052."new"($S4054 :named("name"), $P4055 :named("namespace"), "package" :named("scope"))
    $P4057 = $P4045."new"($P4049, $P4051, $P4056, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1304
    $P4058 = $P4044."push"($P4057)
.annotate 'line', 1301
    .return ($P4058)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("481_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4080
    .param pmc param_4081
.annotate 'line', 1334
    .lex "self", param_4080
    .lex "$/", param_4081
    find_lex $P4082, "$/"
    find_lex $P4083, "$/"
    unless_null $P4083, vivify_2000
    $P4083 = root_new ['parrot';'Hash']
  vivify_2000:
    set $P4084, $P4083["scoped"]
    unless_null $P4084, vivify_2001
    new $P4084, "Undef"
  vivify_2001:
    $P4085 = $P4084."ast"()
    $P4086 = $P4082."!make"($P4085)
    .return ($P4086)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("482_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4088
    .param pmc param_4089
.annotate 'line', 1335
    .lex "self", param_4088
    .lex "$/", param_4089
    find_lex $P4090, "$/"
    find_lex $P4091, "$/"
    unless_null $P4091, vivify_2002
    $P4091 = root_new ['parrot';'Hash']
  vivify_2002:
    set $P4092, $P4091["scoped"]
    unless_null $P4092, vivify_2003
    new $P4092, "Undef"
  vivify_2003:
    $P4093 = $P4092."ast"()
    $P4094 = $P4090."!make"($P4093)
    .return ($P4094)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("483_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4096
    .param pmc param_4097
.annotate 'line', 1336
    .lex "self", param_4096
    .lex "$/", param_4097
    find_lex $P4098, "$/"
    find_lex $P4099, "$/"
    unless_null $P4099, vivify_2004
    $P4099 = root_new ['parrot';'Hash']
  vivify_2004:
    set $P4100, $P4099["scoped"]
    unless_null $P4100, vivify_2005
    new $P4100, "Undef"
  vivify_2005:
    $P4101 = $P4100."ast"()
    $P4102 = $P4098."!make"($P4101)
    .return ($P4102)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("484_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4104
    .param pmc param_4105
.annotate 'line', 1338
    .lex "self", param_4104
    .lex "$/", param_4105
.annotate 'line', 1339
    find_lex $P4106, "$/"
    find_lex $P4109, "$/"
    unless_null $P4109, vivify_2006
    $P4109 = root_new ['parrot';'Hash']
  vivify_2006:
    set $P4110, $P4109["declarator"]
    unless_null $P4110, vivify_2007
    new $P4110, "Undef"
  vivify_2007:
    if $P4110, if_4108
.annotate 'line', 1340
    find_lex $P4116, "$/"
    unless_null $P4116, vivify_2008
    $P4116 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P4117, $P4116["multi_declarator"]
    unless_null $P4117, vivify_2009
    new $P4117, "Undef"
  vivify_2009:
    if $P4117, if_4115
.annotate 'line', 1341
    find_lex $P4121, "$/"
    unless_null $P4121, vivify_2010
    $P4121 = root_new ['parrot';'Hash']
  vivify_2010:
    set $P4122, $P4121["package_declarator"]
    unless_null $P4122, vivify_2011
    new $P4122, "Undef"
  vivify_2011:
    $P4123 = $P4122."ast"()
    set $P4114, $P4123
.annotate 'line', 1340
    goto if_4115_end
  if_4115:
    find_lex $P4118, "$/"
    unless_null $P4118, vivify_2012
    $P4118 = root_new ['parrot';'Hash']
  vivify_2012:
    set $P4119, $P4118["multi_declarator"]
    unless_null $P4119, vivify_2013
    new $P4119, "Undef"
  vivify_2013:
    $P4120 = $P4119."ast"()
    set $P4114, $P4120
  if_4115_end:
    set $P4107, $P4114
.annotate 'line', 1339
    goto if_4108_end
  if_4108:
    find_lex $P4111, "$/"
    unless_null $P4111, vivify_2014
    $P4111 = root_new ['parrot';'Hash']
  vivify_2014:
    set $P4112, $P4111["declarator"]
    unless_null $P4112, vivify_2015
    new $P4112, "Undef"
  vivify_2015:
    $P4113 = $P4112."ast"()
    set $P4107, $P4113
  if_4108_end:
    $P4124 = $P4106."!make"($P4107)
.annotate 'line', 1338
    .return ($P4124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("485_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4126
    .param pmc param_4127
.annotate 'line', 1344
    .lex "self", param_4126
    .lex "$/", param_4127
.annotate 'line', 1345
    find_lex $P4128, "$/"
.annotate 'line', 1346
    find_lex $P4131, "$/"
    unless_null $P4131, vivify_2016
    $P4131 = root_new ['parrot';'Hash']
  vivify_2016:
    set $P4132, $P4131["routine_declarator"]
    unless_null $P4132, vivify_2017
    new $P4132, "Undef"
  vivify_2017:
    if $P4132, if_4130
.annotate 'line', 1347
    find_lex $P4136, "$/"
    unless_null $P4136, vivify_2018
    $P4136 = root_new ['parrot';'Hash']
  vivify_2018:
    set $P4137, $P4136["variable_declarator"]
    unless_null $P4137, vivify_2019
    new $P4137, "Undef"
  vivify_2019:
    $P4138 = $P4137."ast"()
    set $P4129, $P4138
.annotate 'line', 1346
    goto if_4130_end
  if_4130:
    find_lex $P4133, "$/"
    unless_null $P4133, vivify_2020
    $P4133 = root_new ['parrot';'Hash']
  vivify_2020:
    set $P4134, $P4133["routine_declarator"]
    unless_null $P4134, vivify_2021
    new $P4134, "Undef"
  vivify_2021:
    $P4135 = $P4134."ast"()
    set $P4129, $P4135
  if_4130_end:
    $P4139 = $P4128."!make"($P4129)
.annotate 'line', 1344
    .return ($P4139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("486_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4141
    .param pmc param_4142
.annotate 'line', 1350
    .lex "self", param_4141
    .lex "$/", param_4142
    find_lex $P4143, "$/"
    find_lex $P4146, "$/"
    unless_null $P4146, vivify_2022
    $P4146 = root_new ['parrot';'Hash']
  vivify_2022:
    set $P4147, $P4146["declarator"]
    unless_null $P4147, vivify_2023
    new $P4147, "Undef"
  vivify_2023:
    if $P4147, if_4145
    find_lex $P4151, "$/"
    unless_null $P4151, vivify_2024
    $P4151 = root_new ['parrot';'Hash']
  vivify_2024:
    set $P4152, $P4151["routine_def"]
    unless_null $P4152, vivify_2025
    new $P4152, "Undef"
  vivify_2025:
    $P4153 = $P4152."ast"()
    set $P4144, $P4153
    goto if_4145_end
  if_4145:
    find_lex $P4148, "$/"
    unless_null $P4148, vivify_2026
    $P4148 = root_new ['parrot';'Hash']
  vivify_2026:
    set $P4149, $P4148["declarator"]
    unless_null $P4149, vivify_2027
    new $P4149, "Undef"
  vivify_2027:
    $P4150 = $P4149."ast"()
    set $P4144, $P4150
  if_4145_end:
    $P4154 = $P4143."!make"($P4144)
    .return ($P4154)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("487_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4156
    .param pmc param_4157
.annotate 'line', 1351
    .lex "self", param_4156
    .lex "$/", param_4157
    find_lex $P4158, "$/"
    find_lex $P4161, "$/"
    unless_null $P4161, vivify_2028
    $P4161 = root_new ['parrot';'Hash']
  vivify_2028:
    set $P4162, $P4161["declarator"]
    unless_null $P4162, vivify_2029
    new $P4162, "Undef"
  vivify_2029:
    if $P4162, if_4160
    find_lex $P4166, "$/"
    unless_null $P4166, vivify_2030
    $P4166 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P4167, $P4166["routine_def"]
    unless_null $P4167, vivify_2031
    new $P4167, "Undef"
  vivify_2031:
    $P4168 = $P4167."ast"()
    set $P4159, $P4168
    goto if_4160_end
  if_4160:
    find_lex $P4163, "$/"
    unless_null $P4163, vivify_2032
    $P4163 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P4164, $P4163["declarator"]
    unless_null $P4164, vivify_2033
    new $P4164, "Undef"
  vivify_2033:
    $P4165 = $P4164."ast"()
    set $P4159, $P4165
  if_4160_end:
    $P4169 = $P4158."!make"($P4159)
    .return ($P4169)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("488_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4171
    .param pmc param_4172
.annotate 'line', 1352
    .lex "self", param_4171
    .lex "$/", param_4172
    find_lex $P4173, "$/"
    find_lex $P4174, "$/"
    unless_null $P4174, vivify_2034
    $P4174 = root_new ['parrot';'Hash']
  vivify_2034:
    set $P4175, $P4174["declarator"]
    unless_null $P4175, vivify_2035
    new $P4175, "Undef"
  vivify_2035:
    $P4176 = $P4175."ast"()
    $P4177 = $P4173."!make"($P4176)
    .return ($P4177)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("489_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4179
    .param pmc param_4180
.annotate 'line', 1355
    .const 'Sub' $P4212 = "490_1303576195.699" 
    capture_lex $P4212
    .lex "self", param_4179
    .lex "$/", param_4180
.annotate 'line', 1356
    new $P4181, "Undef"
    .lex "$past", $P4181
.annotate 'line', 1357
    new $P4182, "Undef"
    .lex "$sigil", $P4182
.annotate 'line', 1358
    new $P4183, "Undef"
    .lex "$name", $P4183
.annotate 'line', 1359
    new $P4184, "Undef"
    .lex "$BLOCK", $P4184
.annotate 'line', 1356
    find_lex $P4185, "$/"
    unless_null $P4185, vivify_2036
    $P4185 = root_new ['parrot';'Hash']
  vivify_2036:
    set $P4186, $P4185["variable"]
    unless_null $P4186, vivify_2037
    new $P4186, "Undef"
  vivify_2037:
    $P4187 = $P4186."ast"()
    store_lex "$past", $P4187
.annotate 'line', 1357
    find_lex $P4188, "$/"
    unless_null $P4188, vivify_2038
    $P4188 = root_new ['parrot';'Hash']
  vivify_2038:
    set $P4189, $P4188["variable"]
    unless_null $P4189, vivify_2039
    $P4189 = root_new ['parrot';'Hash']
  vivify_2039:
    set $P4190, $P4189["sigil"]
    unless_null $P4190, vivify_2040
    new $P4190, "Undef"
  vivify_2040:
    store_lex "$sigil", $P4190
.annotate 'line', 1358
    find_lex $P4191, "$past"
    unless_null $P4191, vivify_2041
    new $P4191, "Undef"
  vivify_2041:
    $P4192 = $P4191."name"()
    store_lex "$name", $P4192
.annotate 'line', 1359
    find_lex $P4193, "$?PACKAGE"
    get_who $P4194, $P4193
    set $P4195, $P4194["@BLOCK"]
    unless_null $P4195, vivify_2042
    $P4195 = root_new ['parrot';'ResizablePMCArray']
  vivify_2042:
    set $P4196, $P4195[0]
    unless_null $P4196, vivify_2043
    new $P4196, "Undef"
  vivify_2043:
    store_lex "$BLOCK", $P4196
.annotate 'line', 1360
    find_lex $P4200, "$name"
    unless_null $P4200, vivify_2044
    new $P4200, "Undef"
  vivify_2044:
    if $P4200, if_4199
    set $P4198, $P4200
    goto if_4199_end
  if_4199:
    find_lex $P4201, "$BLOCK"
    unless_null $P4201, vivify_2045
    new $P4201, "Undef"
  vivify_2045:
    find_lex $P4202, "$name"
    unless_null $P4202, vivify_2046
    new $P4202, "Undef"
  vivify_2046:
    $P4203 = $P4201."symbol"($P4202)
    set $P4198, $P4203
  if_4199_end:
    unless $P4198, if_4197_end
.annotate 'line', 1361
    find_lex $P4204, "$/"
    unless_null $P4204, vivify_2047
    new $P4204, "Undef"
  vivify_2047:
    $P4205 = $P4204."CURSOR"()
    find_lex $P4206, "$name"
    unless_null $P4206, vivify_2048
    new $P4206, "Undef"
  vivify_2048:
    $P4205."panic"("Redeclaration of symbol ", $P4206)
  if_4197_end:
.annotate 'line', 1363
    find_dynamic_lex $P4208, "$*SCOPE"
    unless_null $P4208, vivify_2049
    get_hll_global $P4208, "$SCOPE"
    unless_null $P4208, vivify_2050
    die "Contextual $*SCOPE not found"
  vivify_2050:
  vivify_2049:
    set $S4209, $P4208
    iseq $I4210, $S4209, "has"
    if $I4210, if_4207
.annotate 'line', 1388
    find_dynamic_lex $P4257, "$*SCOPE"
    unless_null $P4257, vivify_2051
    get_hll_global $P4257, "$SCOPE"
    unless_null $P4257, vivify_2052
    die "Contextual $*SCOPE not found"
  vivify_2052:
  vivify_2051:
    set $S4258, $P4257
    iseq $I4259, $S4258, "our"
    if $I4259, if_4256
.annotate 'line', 1398
    find_lex $P4273, "$BLOCK"
    unless_null $P4273, vivify_2053
    $P4273 = root_new ['parrot';'ResizablePMCArray']
  vivify_2053:
    set $P4274, $P4273[0]
    unless_null $P4274, vivify_2054
    new $P4274, "Undef"
  vivify_2054:
    get_hll_global $P4275, ["PAST"], "Var"
    find_lex $P4276, "$name"
    unless_null $P4276, vivify_2055
    new $P4276, "Undef"
  vivify_2055:
.annotate 'line', 1400
    find_lex $P4277, "$sigil"
    unless_null $P4277, vivify_2056
    new $P4277, "Undef"
  vivify_2056:
    $P4278 = "vivitype"($P4277)
    find_lex $P4279, "$/"
    unless_null $P4279, vivify_2057
    new $P4279, "Undef"
  vivify_2057:
    $P4280 = $P4275."new"($P4276 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4278 :named("viviself"), $P4279 :named("node"))
.annotate 'line', 1398
    $P4274."push"($P4280)
.annotate 'line', 1403
    find_lex $P4281, "$BLOCK"
    unless_null $P4281, vivify_2058
    new $P4281, "Undef"
  vivify_2058:
    find_lex $P4282, "$name"
    unless_null $P4282, vivify_2059
    new $P4282, "Undef"
  vivify_2059:
    $P4281."symbol"($P4282, "lexical" :named("scope"))
.annotate 'line', 1397
    goto if_4256_end
  if_4256:
.annotate 'line', 1392
    find_lex $P4260, "$/"
    unless_null $P4260, vivify_2060
    $P4260 = root_new ['parrot';'Hash']
  vivify_2060:
    set $P4261, $P4260["variable"]
    unless_null $P4261, vivify_2061
    new $P4261, "Undef"
  vivify_2061:
    set $S4262, $P4261
    new $P4263, 'String'
    set $P4263, $S4262
    store_lex "$name", $P4263
.annotate 'line', 1393
    find_lex $P4264, "$name"
    unless_null $P4264, vivify_2062
    new $P4264, "Undef"
  vivify_2062:
    new $P4265, "ResizablePMCArray"
    push $P4265, $P4264
    find_lex $P4266, "$/"
    unless_null $P4266, vivify_2063
    new $P4266, "Undef"
  vivify_2063:
    $P4267 = "lexical_package_lookup"($P4265, $P4266)
    store_lex "$past", $P4267
.annotate 'line', 1394
    find_lex $P4268, "$past"
    unless_null $P4268, vivify_2064
    new $P4268, "Undef"
  vivify_2064:
    find_lex $P4269, "$sigil"
    unless_null $P4269, vivify_2065
    new $P4269, "Undef"
  vivify_2065:
    $P4270 = "vivitype"($P4269)
    $P4268."viviself"($P4270)
.annotate 'line', 1395
    find_lex $P4271, "$BLOCK"
    unless_null $P4271, vivify_2066
    new $P4271, "Undef"
  vivify_2066:
    find_lex $P4272, "$name"
    unless_null $P4272, vivify_2067
    new $P4272, "Undef"
  vivify_2067:
    $P4271."symbol"($P4272, "package" :named("scope"))
  if_4256_end:
.annotate 'line', 1388
    goto if_4207_end
  if_4207:
.annotate 'line', 1363
    .const 'Sub' $P4212 = "490_1303576195.699" 
    capture_lex $P4212
    $P4212()
  if_4207_end:
.annotate 'line', 1405
    find_lex $P4283, "$/"
    find_lex $P4284, "$past"
    unless_null $P4284, vivify_2089
    new $P4284, "Undef"
  vivify_2089:
    $P4285 = $P4283."!make"($P4284)
.annotate 'line', 1355
    .return ($P4285)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4211"  :anon :subid("490_1303576195.699") :outer("489_1303576195.699")
.annotate 'line', 1363
    .const 'Sub' $P4242 = "491_1303576195.699" 
    capture_lex $P4242
.annotate 'line', 1365
    new $P4213, "Undef"
    .lex "$meta-attr-type", $P4213
.annotate 'line', 1373
    new $P4214, "Undef"
    .lex "$meta_args", $P4214
.annotate 'line', 1365
    find_dynamic_lex $P4217, "$*PKGDECL"
    unless_null $P4217, vivify_2068
    get_hll_global $P4217, "$PKGDECL"
    unless_null $P4217, vivify_2069
    die "Contextual $*PKGDECL not found"
  vivify_2069:
  vivify_2068:
    find_dynamic_lex $P4218, "%*HOW-METAATTR"
    unless_null $P4218, vivify_2070
    get_hll_global $P4218, "%HOW-METAATTR"
    unless_null $P4218, vivify_2071
    die "Contextual %*HOW-METAATTR not found"
  vivify_2071:
  vivify_2070:
    set $P4219, $P4218[$P4217]
    unless_null $P4219, vivify_2072
    new $P4219, "Undef"
  vivify_2072:
    unless $P4219, unless_4216
    set $P4215, $P4219
    goto unless_4216_end
  unless_4216:
    find_dynamic_lex $P4220, "$*DEFAULT-METAATTR"
    unless_null $P4220, vivify_2073
    get_hll_global $P4220, "$DEFAULT-METAATTR"
    unless_null $P4220, vivify_2074
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2074:
  vivify_2073:
    set $P4215, $P4220
  unless_4216_end:
    store_lex "$meta-attr-type", $P4215
.annotate 'line', 1366
    find_dynamic_lex $P4221, "$*PACKAGE-SETUP"
    unless_null $P4221, vivify_2075
    get_hll_global $P4221, "$PACKAGE-SETUP"
    unless_null $P4221, vivify_2076
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2076:
  vivify_2075:
    get_hll_global $P4222, ["PAST"], "Op"
.annotate 'line', 1368
    get_hll_global $P4223, ["PAST"], "Op"
.annotate 'line', 1370
    get_hll_global $P4224, ["PAST"], "Var"
    $P4225 = $P4224."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4226 = $P4223."new"($P4225, "get_how PP" :named("pirop"))
.annotate 'line', 1372
    get_hll_global $P4227, ["PAST"], "Var"
    $P4228 = $P4227."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1373
    get_hll_global $P4229, ["PAST"], "Op"
.annotate 'line', 1375
    get_hll_global $P4230, ["PAST"], "Var"
    find_lex $P4231, "$meta-attr-type"
    unless_null $P4231, vivify_2077
    new $P4231, "Undef"
  vivify_2077:
    $P4232 = $P4230."new"($P4231 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1376
    get_hll_global $P4233, ["PAST"], "Val"
    find_lex $P4234, "$name"
    unless_null $P4234, vivify_2078
    new $P4234, "Undef"
  vivify_2078:
    $P4235 = $P4233."new"($P4234 :named("value"), "name" :named("named"))
    $P4236 = $P4229."new"($P4232, $P4235, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1373
    store_lex "$meta_args", $P4236
    $P4237 = $P4222."new"($P4226, $P4228, $P4236, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1366
    $P4221."push"($P4237)
.annotate 'line', 1379
    find_lex $P4239, "$/"
    unless_null $P4239, vivify_2079
    $P4239 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P4240, $P4239["typename"]
    unless_null $P4240, vivify_2080
    new $P4240, "Undef"
  vivify_2080:
    unless $P4240, if_4238_end
    .const 'Sub' $P4242 = "491_1303576195.699" 
    capture_lex $P4242
    $P4242()
  if_4238_end:
.annotate 'line', 1385
    find_lex $P4252, "$BLOCK"
    unless_null $P4252, vivify_2087
    new $P4252, "Undef"
  vivify_2087:
    find_lex $P4253, "$name"
    unless_null $P4253, vivify_2088
    new $P4253, "Undef"
  vivify_2088:
    $P4252."symbol"($P4253, "attribute" :named("scope"))
.annotate 'line', 1386
    get_hll_global $P4254, ["PAST"], "Stmts"
    $P4255 = $P4254."new"()
    store_lex "$past", $P4255
.annotate 'line', 1363
    .return ($P4255)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4241"  :anon :subid("491_1303576195.699") :outer("490_1303576195.699")
.annotate 'line', 1380
    new $P4243, "Undef"
    .lex "$type", $P4243
    find_lex $P4244, "$/"
    unless_null $P4244, vivify_2081
    $P4244 = root_new ['parrot';'Hash']
  vivify_2081:
    set $P4245, $P4244["typename"]
    unless_null $P4245, vivify_2082
    $P4245 = root_new ['parrot';'ResizablePMCArray']
  vivify_2082:
    set $P4246, $P4245[0]
    unless_null $P4246, vivify_2083
    new $P4246, "Undef"
  vivify_2083:
    $P4247 = $P4246."ast"()
    store_lex "$type", $P4247
.annotate 'line', 1381
    find_lex $P4248, "$type"
    unless_null $P4248, vivify_2084
    new $P4248, "Undef"
  vivify_2084:
    $P4248."named"("type")
.annotate 'line', 1382
    find_lex $P4249, "$meta_args"
    unless_null $P4249, vivify_2085
    new $P4249, "Undef"
  vivify_2085:
    find_lex $P4250, "$type"
    unless_null $P4250, vivify_2086
    new $P4250, "Undef"
  vivify_2086:
    $P4251 = $P4249."push"($P4250)
.annotate 'line', 1379
    .return ($P4251)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("492_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4287
    .param pmc param_4288
.annotate 'line', 1408
    .lex "self", param_4287
    .lex "$/", param_4288
    find_lex $P4289, "$/"
    find_lex $P4290, "$/"
    unless_null $P4290, vivify_2090
    $P4290 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P4291, $P4290["routine_def"]
    unless_null $P4291, vivify_2091
    new $P4291, "Undef"
  vivify_2091:
    $P4292 = $P4291."ast"()
    $P4293 = $P4289."!make"($P4292)
    .return ($P4293)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("493_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4295
    .param pmc param_4296
.annotate 'line', 1409
    .lex "self", param_4295
    .lex "$/", param_4296
    find_lex $P4297, "$/"
    find_lex $P4298, "$/"
    unless_null $P4298, vivify_2092
    $P4298 = root_new ['parrot';'Hash']
  vivify_2092:
    set $P4299, $P4298["method_def"]
    unless_null $P4299, vivify_2093
    new $P4299, "Undef"
  vivify_2093:
    $P4300 = $P4299."ast"()
    $P4301 = $P4297."!make"($P4300)
    .return ($P4301)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("494_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4303
    .param pmc param_4304
.annotate 'line', 1411
    .const 'Sub' $P4563 = "500_1303576195.699" 
    capture_lex $P4563
    .const 'Sub' $P4324 = "495_1303576195.699" 
    capture_lex $P4324
    .lex "self", param_4303
    .lex "$/", param_4304
.annotate 'line', 1414
    new $P4305, "Undef"
    .lex "$past", $P4305
.annotate 'line', 1425
    new $P4306, "Undef"
    .lex "$block", $P4306
.annotate 'line', 1411
    find_lex $P4307, "$past"
    unless_null $P4307, vivify_2094
    new $P4307, "Undef"
  vivify_2094:
.annotate 'line', 1415
    find_lex $P4309, "$/"
    unless_null $P4309, vivify_2095
    $P4309 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P4310, $P4309["onlystar"]
    unless_null $P4310, vivify_2096
    new $P4310, "Undef"
  vivify_2096:
    if $P4310, if_4308
.annotate 'line', 1419
    find_lex $P4312, "$/"
    unless_null $P4312, vivify_2097
    $P4312 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P4313, $P4312["blockoid"]
    unless_null $P4313, vivify_2098
    new $P4313, "Undef"
  vivify_2098:
    $P4314 = $P4313."ast"()
    store_lex "$past", $P4314
.annotate 'line', 1420
    find_lex $P4315, "$past"
    unless_null $P4315, vivify_2099
    new $P4315, "Undef"
  vivify_2099:
    $P4315."blocktype"("declaration")
.annotate 'line', 1421
    find_dynamic_lex $P4317, "$*RETURN_USED"
    unless_null $P4317, vivify_2100
    get_hll_global $P4317, "$RETURN_USED"
    unless_null $P4317, vivify_2101
    die "Contextual $*RETURN_USED not found"
  vivify_2101:
  vivify_2100:
    unless $P4317, if_4316_end
.annotate 'line', 1422
    find_lex $P4318, "$past"
    unless_null $P4318, vivify_2102
    new $P4318, "Undef"
  vivify_2102:
    $P4318."control"("return_pir")
  if_4316_end:
.annotate 'line', 1418
    goto if_4308_end
  if_4308:
.annotate 'line', 1416
    $P4311 = "only_star_block"()
    store_lex "$past", $P4311
  if_4308_end:
.annotate 'line', 1425
    find_lex $P4319, "$past"
    unless_null $P4319, vivify_2103
    new $P4319, "Undef"
  vivify_2103:
    store_lex "$block", $P4319
.annotate 'line', 1427
    find_lex $P4321, "$/"
    unless_null $P4321, vivify_2104
    $P4321 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P4322, $P4321["deflongname"]
    unless_null $P4322, vivify_2105
    new $P4322, "Undef"
  vivify_2105:
    unless $P4322, if_4320_end
    .const 'Sub' $P4324 = "495_1303576195.699" 
    capture_lex $P4324
    $P4324()
  if_4320_end:
.annotate 'line', 1532
    find_lex $P4552, "$block"
    unless_null $P4552, vivify_2208
    new $P4552, "Undef"
  vivify_2208:
    find_lex $P4553, "$past"
    unless_null $P4553, vivify_2209
    $P4553 = root_new ['parrot';'Hash']
    store_lex "$past", $P4553
  vivify_2209:
    set $P4553["block_past"], $P4552
.annotate 'line', 1533
    find_lex $P4555, "$/"
    unless_null $P4555, vivify_2210
    $P4555 = root_new ['parrot';'Hash']
  vivify_2210:
    set $P4556, $P4555["trait"]
    unless_null $P4556, vivify_2211
    new $P4556, "Undef"
  vivify_2211:
    unless $P4556, if_4554_end
.annotate 'line', 1534
    find_lex $P4558, "$/"
    unless_null $P4558, vivify_2212
    $P4558 = root_new ['parrot';'Hash']
  vivify_2212:
    set $P4559, $P4558["trait"]
    unless_null $P4559, vivify_2213
    new $P4559, "Undef"
  vivify_2213:
    defined $I4560, $P4559
    unless $I4560, for_undef_2214
    iter $P4557, $P4559
    new $P4570, 'ExceptionHandler'
    set_label $P4570, loop4569_handler
    $P4570."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4570
  loop4569_test:
    unless $P4557, loop4569_done
    shift $P4561, $P4557
  loop4569_redo:
    .const 'Sub' $P4563 = "500_1303576195.699" 
    capture_lex $P4563
    $P4563($P4561)
  loop4569_next:
    goto loop4569_test
  loop4569_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4571, exception, 'type'
    eq $P4571, .CONTROL_LOOP_NEXT, loop4569_next
    eq $P4571, .CONTROL_LOOP_REDO, loop4569_redo
  loop4569_done:
    pop_eh 
  for_undef_2214:
  if_4554_end:
.annotate 'line', 1537
    find_lex $P4572, "$/"
    find_lex $P4573, "$past"
    unless_null $P4573, vivify_2217
    new $P4573, "Undef"
  vivify_2217:
    $P4574 = $P4572."!make"($P4573)
.annotate 'line', 1411
    .return ($P4574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4323"  :anon :subid("495_1303576195.699") :outer("494_1303576195.699")
.annotate 'line', 1427
    .const 'Sub' $P4454 = "499_1303576195.699" 
    capture_lex $P4454
    .const 'Sub' $P4357 = "496_1303576195.699" 
    capture_lex $P4357
.annotate 'line', 1428
    new $P4325, "Undef"
    .lex "$name", $P4325
    find_lex $P4326, "$/"
    unless_null $P4326, vivify_2106
    $P4326 = root_new ['parrot';'Hash']
  vivify_2106:
    set $P4327, $P4326["sigil"]
    unless_null $P4327, vivify_2107
    $P4327 = root_new ['parrot';'ResizablePMCArray']
  vivify_2107:
    set $P4328, $P4327[0]
    unless_null $P4328, vivify_2108
    new $P4328, "Undef"
  vivify_2108:
    set $S4329, $P4328
    new $P4330, 'String'
    set $P4330, $S4329
    find_lex $P4331, "$/"
    unless_null $P4331, vivify_2109
    $P4331 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4332, $P4331["deflongname"]
    unless_null $P4332, vivify_2110
    $P4332 = root_new ['parrot';'ResizablePMCArray']
  vivify_2110:
    set $P4333, $P4332[0]
    unless_null $P4333, vivify_2111
    new $P4333, "Undef"
  vivify_2111:
    $S4334 = $P4333."ast"()
    concat $P4335, $P4330, $S4334
    store_lex "$name", $P4335
.annotate 'line', 1429
    find_lex $P4336, "$past"
    unless_null $P4336, vivify_2112
    new $P4336, "Undef"
  vivify_2112:
    find_lex $P4337, "$name"
    unless_null $P4337, vivify_2113
    new $P4337, "Undef"
  vivify_2113:
    $P4336."name"($P4337)
.annotate 'line', 1430
    find_dynamic_lex $P4343, "$*SCOPE"
    unless_null $P4343, vivify_2114
    get_hll_global $P4343, "$SCOPE"
    unless_null $P4343, vivify_2115
    die "Contextual $*SCOPE not found"
  vivify_2115:
  vivify_2114:
    set $S4344, $P4343
    iseq $I4345, $S4344, ""
    unless $I4345, unless_4342
    new $P4341, 'Integer'
    set $P4341, $I4345
    goto unless_4342_end
  unless_4342:
    find_dynamic_lex $P4346, "$*SCOPE"
    unless_null $P4346, vivify_2116
    get_hll_global $P4346, "$SCOPE"
    unless_null $P4346, vivify_2117
    die "Contextual $*SCOPE not found"
  vivify_2117:
  vivify_2116:
    set $S4347, $P4346
    iseq $I4348, $S4347, "my"
    new $P4341, 'Integer'
    set $P4341, $I4348
  unless_4342_end:
    unless $P4341, unless_4340
    set $P4339, $P4341
    goto unless_4340_end
  unless_4340:
    find_dynamic_lex $P4349, "$*SCOPE"
    unless_null $P4349, vivify_2118
    get_hll_global $P4349, "$SCOPE"
    unless_null $P4349, vivify_2119
    die "Contextual $*SCOPE not found"
  vivify_2119:
  vivify_2118:
    set $S4350, $P4349
    iseq $I4351, $S4350, "our"
    new $P4339, 'Integer'
    set $P4339, $I4351
  unless_4340_end:
    if $P4339, if_4338
.annotate 'line', 1522
    find_lex $P4537, "$/"
    unless_null $P4537, vivify_2120
    new $P4537, "Undef"
  vivify_2120:
    $P4538 = $P4537."CURSOR"()
    find_dynamic_lex $P4539, "$*SCOPE"
    unless_null $P4539, vivify_2121
    get_hll_global $P4539, "$SCOPE"
    unless_null $P4539, vivify_2122
    die "Contextual $*SCOPE not found"
  vivify_2122:
  vivify_2121:
    concat $P4540, $P4539, " scoped routines are not supported yet"
    $P4538."panic"($P4540)
.annotate 'line', 1521
    goto if_4338_end
  if_4338:
.annotate 'line', 1431
    find_dynamic_lex $P4353, "$*MULTINESS"
    unless_null $P4353, vivify_2123
    get_hll_global $P4353, "$MULTINESS"
    unless_null $P4353, vivify_2124
    die "Contextual $*MULTINESS not found"
  vivify_2124:
  vivify_2123:
    set $S4354, $P4353
    iseq $I4355, $S4354, "multi"
    if $I4355, if_4352
.annotate 'line', 1482
    find_dynamic_lex $P4450, "$*MULTINESS"
    unless_null $P4450, vivify_2125
    get_hll_global $P4450, "$MULTINESS"
    unless_null $P4450, vivify_2126
    die "Contextual $*MULTINESS not found"
  vivify_2126:
  vivify_2125:
    set $S4451, $P4450
    iseq $I4452, $S4451, "proto"
    if $I4452, if_4449
.annotate 'line', 1501
    find_lex $P4490, "$?PACKAGE"
    get_who $P4491, $P4490
    set $P4492, $P4491["@BLOCK"]
    unless_null $P4492, vivify_2127
    $P4492 = root_new ['parrot';'ResizablePMCArray']
  vivify_2127:
    set $P4493, $P4492[0]
    unless_null $P4493, vivify_2128
    $P4493 = root_new ['parrot';'ResizablePMCArray']
  vivify_2128:
    set $P4494, $P4493[0]
    unless_null $P4494, vivify_2129
    new $P4494, "Undef"
  vivify_2129:
    get_hll_global $P4495, ["PAST"], "Var"
    find_lex $P4496, "$name"
    unless_null $P4496, vivify_2130
    new $P4496, "Undef"
  vivify_2130:
    find_lex $P4497, "$past"
    unless_null $P4497, vivify_2131
    new $P4497, "Undef"
  vivify_2131:
    $P4498 = $P4495."new"($P4496 :named("name"), 1 :named("isdecl"), $P4497 :named("viviself"), "lexical" :named("scope"))
    $P4494."push"($P4498)
.annotate 'line', 1503
    find_lex $P4499, "$?PACKAGE"
    get_who $P4500, $P4499
    set $P4501, $P4500["@BLOCK"]
    unless_null $P4501, vivify_2132
    $P4501 = root_new ['parrot';'ResizablePMCArray']
  vivify_2132:
    set $P4502, $P4501[0]
    unless_null $P4502, vivify_2133
    new $P4502, "Undef"
  vivify_2133:
    find_lex $P4503, "$name"
    unless_null $P4503, vivify_2134
    new $P4503, "Undef"
  vivify_2134:
    $P4502."symbol"($P4503, "lexical" :named("scope"))
.annotate 'line', 1504
    find_dynamic_lex $P4505, "$*SCOPE"
    unless_null $P4505, vivify_2135
    get_hll_global $P4505, "$SCOPE"
    unless_null $P4505, vivify_2136
    die "Contextual $*SCOPE not found"
  vivify_2136:
  vivify_2135:
    set $S4506, $P4505
    iseq $I4507, $S4506, "our"
    unless $I4507, if_4504_end
.annotate 'line', 1507
    find_lex $P4508, "$?PACKAGE"
    get_who $P4509, $P4508
    set $P4510, $P4509["@BLOCK"]
    unless_null $P4510, vivify_2137
    $P4510 = root_new ['parrot';'ResizablePMCArray']
  vivify_2137:
    set $P4511, $P4510[0]
    unless_null $P4511, vivify_2138
    $P4511 = root_new ['parrot';'ResizablePMCArray']
  vivify_2138:
    set $P4512, $P4511[0]
    unless_null $P4512, vivify_2139
    new $P4512, "Undef"
  vivify_2139:
    get_hll_global $P4513, ["PAST"], "Op"
.annotate 'line', 1509
    get_hll_global $P4514, ["PAST"], "Var"
    find_lex $P4515, "$name"
    unless_null $P4515, vivify_2140
    new $P4515, "Undef"
  vivify_2140:
    $P4516 = $P4514."new"($P4515 :named("name"), "package" :named("scope"))
.annotate 'line', 1510
    get_hll_global $P4517, ["PAST"], "Var"
    find_lex $P4518, "$name"
    unless_null $P4518, vivify_2141
    new $P4518, "Undef"
  vivify_2141:
    $P4519 = $P4517."new"($P4518 :named("name"), "lexical" :named("scope"))
    $P4520 = $P4513."new"($P4516, $P4519, "bind" :named("pasttype"))
.annotate 'line', 1507
    $P4512."push"($P4520)
.annotate 'line', 1512
    find_lex $P4521, "$?PACKAGE"
    get_who $P4522, $P4521
    set $P4523, $P4522["@BLOCK"]
    unless_null $P4523, vivify_2142
    $P4523 = root_new ['parrot';'ResizablePMCArray']
  vivify_2142:
    set $P4524, $P4523[0]
    unless_null $P4524, vivify_2143
    new $P4524, "Undef"
  vivify_2143:
    $P4525 = $P4524."loadinit"()
    get_hll_global $P4526, ["PAST"], "Op"
.annotate 'line', 1514
    get_hll_global $P4527, ["PAST"], "Var"
    find_lex $P4528, "$name"
    unless_null $P4528, vivify_2144
    new $P4528, "Undef"
  vivify_2144:
    $P4529 = $P4527."new"($P4528 :named("name"), "package" :named("scope"))
.annotate 'line', 1515
    get_hll_global $P4530, ["PAST"], "Val"
    find_lex $P4531, "$past"
    unless_null $P4531, vivify_2145
    new $P4531, "Undef"
  vivify_2145:
    $P4532 = $P4530."new"($P4531 :named("value"))
    $P4533 = $P4526."new"($P4529, $P4532, "bind" :named("pasttype"))
.annotate 'line', 1512
    $P4525."push"($P4533)
  if_4504_end:
.annotate 'line', 1500
    goto if_4449_end
  if_4449:
.annotate 'line', 1482
    .const 'Sub' $P4454 = "499_1303576195.699" 
    capture_lex $P4454
    $P4454()
  if_4449_end:
    goto if_4352_end
  if_4352:
.annotate 'line', 1431
    .const 'Sub' $P4357 = "496_1303576195.699" 
    capture_lex $P4357
    $P4357()
  if_4352_end:
.annotate 'line', 1519
    get_hll_global $P4534, ["PAST"], "Var"
    find_lex $P4535, "$name"
    unless_null $P4535, vivify_2203
    new $P4535, "Undef"
  vivify_2203:
    $P4536 = $P4534."new"($P4535 :named("name"))
    store_lex "$past", $P4536
  if_4338_end:
.annotate 'line', 1526
    find_lex $P4545, "$name"
    unless_null $P4545, vivify_2204
    new $P4545, "Undef"
  vivify_2204:
    set $S4546, $P4545
    iseq $I4547, $S4546, "MAIN"
    if $I4547, if_4544
    new $P4543, 'Integer'
    set $P4543, $I4547
    goto if_4544_end
  if_4544:
    find_dynamic_lex $P4548, "$*MULTINESS"
    unless_null $P4548, vivify_2205
    get_hll_global $P4548, "$MULTINESS"
    unless_null $P4548, vivify_2206
    die "Contextual $*MULTINESS not found"
  vivify_2206:
  vivify_2205:
    set $S4549, $P4548
    isne $I4550, $S4549, "multi"
    new $P4543, 'Integer'
    set $P4543, $I4550
  if_4544_end:
    if $P4543, if_4542
    set $P4541, $P4543
    goto if_4542_end
  if_4542:
.annotate 'line', 1527
    find_lex $P4551, "$block"
    unless_null $P4551, vivify_2207
    new $P4551, "Undef"
  vivify_2207:
    store_dynamic_lex "$*MAIN_SUB", $P4551
.annotate 'line', 1526
    set $P4541, $P4551
  if_4542_end:
.annotate 'line', 1427
    .return ($P4541)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4453"  :anon :subid("499_1303576195.699") :outer("495_1303576195.699")
.annotate 'line', 1487
    new $P4455, "Undef"
    .lex "$cholder", $P4455
.annotate 'line', 1486
    find_dynamic_lex $P4457, "$*SCOPE"
    unless_null $P4457, vivify_2146
    get_hll_global $P4457, "$SCOPE"
    unless_null $P4457, vivify_2147
    die "Contextual $*SCOPE not found"
  vivify_2147:
  vivify_2146:
    set $S4458, $P4457
    iseq $I4459, $S4458, "our"
    unless $I4459, if_4456_end
    die "our-scoped protos not yet implemented"
  if_4456_end:
.annotate 'line', 1487
    get_hll_global $P4460, ["PAST"], "Op"
    $P4461 = $P4460."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4461
.annotate 'line', 1488
    find_lex $P4462, "$?PACKAGE"
    get_who $P4463, $P4462
    set $P4464, $P4463["@BLOCK"]
    unless_null $P4464, vivify_2148
    $P4464 = root_new ['parrot';'ResizablePMCArray']
  vivify_2148:
    set $P4465, $P4464[0]
    unless_null $P4465, vivify_2149
    $P4465 = root_new ['parrot';'ResizablePMCArray']
  vivify_2149:
    set $P4466, $P4465[0]
    unless_null $P4466, vivify_2150
    new $P4466, "Undef"
  vivify_2150:
    get_hll_global $P4467, ["PAST"], "Var"
    find_lex $P4468, "$name"
    unless_null $P4468, vivify_2151
    new $P4468, "Undef"
  vivify_2151:
    find_lex $P4469, "$past"
    unless_null $P4469, vivify_2152
    new $P4469, "Undef"
  vivify_2152:
    $P4470 = $P4467."new"($P4468 :named("name"), 1 :named("isdecl"), $P4469 :named("viviself"), "lexical" :named("scope"))
    $P4466."push"($P4470)
.annotate 'line', 1490
    find_lex $P4471, "$?PACKAGE"
    get_who $P4472, $P4471
    set $P4473, $P4472["@BLOCK"]
    unless_null $P4473, vivify_2153
    $P4473 = root_new ['parrot';'ResizablePMCArray']
  vivify_2153:
    set $P4474, $P4473[0]
    unless_null $P4474, vivify_2154
    $P4474 = root_new ['parrot';'ResizablePMCArray']
  vivify_2154:
    set $P4475, $P4474[0]
    unless_null $P4475, vivify_2155
    new $P4475, "Undef"
  vivify_2155:
    get_hll_global $P4476, ["PAST"], "Op"
.annotate 'line', 1492
    get_hll_global $P4477, ["PAST"], "Var"
    find_lex $P4478, "$name"
    unless_null $P4478, vivify_2156
    new $P4478, "Undef"
  vivify_2156:
    $P4479 = $P4477."new"($P4478 :named("name"))
    find_lex $P4480, "$cholder"
    unless_null $P4480, vivify_2157
    new $P4480, "Undef"
  vivify_2157:
    $P4481 = $P4476."new"($P4479, $P4480, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1490
    $P4475."push"($P4481)
.annotate 'line', 1495
    find_lex $P4482, "$?PACKAGE"
    get_who $P4483, $P4482
    set $P4484, $P4483["@BLOCK"]
    unless_null $P4484, vivify_2158
    $P4484 = root_new ['parrot';'ResizablePMCArray']
  vivify_2158:
    set $P4485, $P4484[0]
    unless_null $P4485, vivify_2159
    new $P4485, "Undef"
  vivify_2159:
    find_lex $P4486, "$name"
    unless_null $P4486, vivify_2160
    new $P4486, "Undef"
  vivify_2160:
    find_lex $P4487, "$cholder"
    unless_null $P4487, vivify_2161
    new $P4487, "Undef"
  vivify_2161:
    $P4485."symbol"($P4486, "lexical" :named("scope"), 1 :named("proto"), $P4487 :named("cholder"))
.annotate 'line', 1498
    find_lex $P4488, "$past"
    unless_null $P4488, vivify_2162
    new $P4488, "Undef"
  vivify_2162:
    $P4489 = $P4488."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1482
    .return ($P4489)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4356"  :anon :subid("496_1303576195.699") :outer("495_1303576195.699")
.annotate 'line', 1431
    .const 'Sub' $P4377 = "497_1303576195.699" 
    capture_lex $P4377
.annotate 'line', 1434
    new $P4358, "Undef"
    .lex "$cholder", $P4358
.annotate 'line', 1435
    $P4359 = root_new ['parrot';'Hash']
    .lex "%sym", $P4359
.annotate 'line', 1433
    find_dynamic_lex $P4361, "$*SCOPE"
    unless_null $P4361, vivify_2163
    get_hll_global $P4361, "$SCOPE"
    unless_null $P4361, vivify_2164
    die "Contextual $*SCOPE not found"
  vivify_2164:
  vivify_2163:
    set $S4362, $P4361
    iseq $I4363, $S4362, "our"
    unless $I4363, if_4360_end
    die "our-scoped multis not yet implemented"
  if_4360_end:
    find_lex $P4364, "$cholder"
    unless_null $P4364, vivify_2165
    new $P4364, "Undef"
  vivify_2165:
.annotate 'line', 1435
    find_lex $P4365, "$?PACKAGE"
    get_who $P4366, $P4365
    set $P4367, $P4366["@BLOCK"]
    unless_null $P4367, vivify_2166
    $P4367 = root_new ['parrot';'ResizablePMCArray']
  vivify_2166:
    set $P4368, $P4367[0]
    unless_null $P4368, vivify_2167
    new $P4368, "Undef"
  vivify_2167:
    find_lex $P4369, "$name"
    unless_null $P4369, vivify_2168
    new $P4369, "Undef"
  vivify_2168:
    $P4370 = $P4368."symbol"($P4369)
    store_lex "%sym", $P4370
.annotate 'line', 1436
    find_lex $P4372, "%sym"
    unless_null $P4372, vivify_2169
    $P4372 = root_new ['parrot';'Hash']
  vivify_2169:
    set $P4373, $P4372["cholder"]
    unless_null $P4373, vivify_2170
    new $P4373, "Undef"
  vivify_2170:
    if $P4373, if_4371
.annotate 'line', 1441
    .const 'Sub' $P4377 = "497_1303576195.699" 
    capture_lex $P4377
    $P4377()
    goto if_4371_end
  if_4371:
.annotate 'line', 1437
    find_lex $P4374, "%sym"
    unless_null $P4374, vivify_2198
    $P4374 = root_new ['parrot';'Hash']
  vivify_2198:
    set $P4375, $P4374["cholder"]
    unless_null $P4375, vivify_2199
    new $P4375, "Undef"
  vivify_2199:
    store_lex "$cholder", $P4375
  if_4371_end:
.annotate 'line', 1477
    find_lex $P4445, "$cholder"
    unless_null $P4445, vivify_2200
    new $P4445, "Undef"
  vivify_2200:
    find_lex $P4446, "$past"
    unless_null $P4446, vivify_2201
    new $P4446, "Undef"
  vivify_2201:
    $P4445."push"($P4446)
.annotate 'line', 1480
    find_lex $P4447, "$past"
    unless_null $P4447, vivify_2202
    new $P4447, "Undef"
  vivify_2202:
    $P4448 = "attach_multi_signature"($P4447)
.annotate 'line', 1431
    .return ($P4448)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4376"  :anon :subid("497_1303576195.699") :outer("496_1303576195.699")
.annotate 'line', 1441
    .const 'Sub' $P4393 = "498_1303576195.699" 
    capture_lex $P4393
.annotate 'line', 1448
    new $P4378, "Undef"
    .lex "$found_proto", $P4378
.annotate 'line', 1466
    new $P4379, "Undef"
    .lex "$dispatch_setup", $P4379
.annotate 'line', 1443
    find_lex $P4381, "%sym"
    unless_null $P4381, vivify_2171
    $P4381 = root_new ['parrot';'Hash']
  vivify_2171:
    set $P4382, $P4381["proto"]
    unless_null $P4382, vivify_2172
    new $P4382, "Undef"
  vivify_2172:
    unless $P4382, if_4380_end
.annotate 'line', 1446
    find_lex $P4383, "$/"
    unless_null $P4383, vivify_2173
    new $P4383, "Undef"
  vivify_2173:
    $P4384 = $P4383."CURSOR"()
    $P4384."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4380_end:
.annotate 'line', 1443
    find_lex $P4385, "$found_proto"
    unless_null $P4385, vivify_2174
    new $P4385, "Undef"
  vivify_2174:
.annotate 'line', 1449
    find_lex $P4387, "$?PACKAGE"
    get_who $P4388, $P4387
    set $P4389, $P4388["@BLOCK"]
    unless_null $P4389, vivify_2175
    $P4389 = root_new ['parrot';'ResizablePMCArray']
  vivify_2175:
    defined $I4390, $P4389
    unless $I4390, for_undef_2176
    iter $P4386, $P4389
    new $P4415, 'ExceptionHandler'
    set_label $P4415, loop4414_handler
    $P4415."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4415
  loop4414_test:
    unless $P4386, loop4414_done
    shift $P4391, $P4386
  loop4414_redo:
    .const 'Sub' $P4393 = "498_1303576195.699" 
    capture_lex $P4393
    $P4393($P4391)
  loop4414_next:
    goto loop4414_test
  loop4414_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4416, exception, 'type'
    eq $P4416, .CONTROL_LOOP_NEXT, loop4414_next
    eq $P4416, .CONTROL_LOOP_REDO, loop4414_redo
  loop4414_done:
    pop_eh 
  for_undef_2176:
.annotate 'line', 1460
    find_lex $P4418, "$found_proto"
    unless_null $P4418, vivify_2185
    new $P4418, "Undef"
  vivify_2185:
    if $P4418, unless_4417_end
.annotate 'line', 1461
    find_lex $P4419, "$/"
    unless_null $P4419, vivify_2186
    new $P4419, "Undef"
  vivify_2186:
    $P4420 = $P4419."CURSOR"()
    $P4420."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4417_end:
.annotate 'line', 1465
    get_hll_global $P4421, ["PAST"], "Op"
    $P4422 = $P4421."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4422
.annotate 'line', 1466
    get_hll_global $P4423, ["PAST"], "Op"
.annotate 'line', 1468
    get_hll_global $P4424, ["PAST"], "Var"
    find_lex $P4425, "$name"
    unless_null $P4425, vivify_2187
    new $P4425, "Undef"
  vivify_2187:
    $P4426 = $P4424."new"($P4425 :named("name"), "outer" :named("scope"))
    find_lex $P4427, "$cholder"
    unless_null $P4427, vivify_2188
    new $P4427, "Undef"
  vivify_2188:
    $P4428 = $P4423."new"($P4426, $P4427, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1466
    store_lex "$dispatch_setup", $P4428
.annotate 'line', 1471
    find_lex $P4429, "$?PACKAGE"
    get_who $P4430, $P4429
    set $P4431, $P4430["@BLOCK"]
    unless_null $P4431, vivify_2189
    $P4431 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $P4432, $P4431[0]
    unless_null $P4432, vivify_2190
    $P4432 = root_new ['parrot';'ResizablePMCArray']
  vivify_2190:
    set $P4433, $P4432[0]
    unless_null $P4433, vivify_2191
    new $P4433, "Undef"
  vivify_2191:
    get_hll_global $P4434, ["PAST"], "Var"
    find_lex $P4435, "$name"
    unless_null $P4435, vivify_2192
    new $P4435, "Undef"
  vivify_2192:
    find_lex $P4436, "$dispatch_setup"
    unless_null $P4436, vivify_2193
    new $P4436, "Undef"
  vivify_2193:
    $P4437 = $P4434."new"($P4435 :named("name"), 1 :named("isdecl"), $P4436 :named("viviself"), "lexical" :named("scope"))
    $P4433."push"($P4437)
.annotate 'line', 1473
    find_lex $P4438, "$?PACKAGE"
    get_who $P4439, $P4438
    set $P4440, $P4439["@BLOCK"]
    unless_null $P4440, vivify_2194
    $P4440 = root_new ['parrot';'ResizablePMCArray']
  vivify_2194:
    set $P4441, $P4440[0]
    unless_null $P4441, vivify_2195
    new $P4441, "Undef"
  vivify_2195:
    find_lex $P4442, "$name"
    unless_null $P4442, vivify_2196
    new $P4442, "Undef"
  vivify_2196:
    find_lex $P4443, "$cholder"
    unless_null $P4443, vivify_2197
    new $P4443, "Undef"
  vivify_2197:
    $P4444 = $P4441."symbol"($P4442, "lexical" :named("scope"), $P4443 :named("cholder"))
.annotate 'line', 1441
    .return ($P4444)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4392"  :anon :subid("498_1303576195.699") :outer("497_1303576195.699")
    .param pmc param_4395
.annotate 'line', 1450
    $P4394 = root_new ['parrot';'Hash']
    .lex "%sym", $P4394
    .lex "$_", param_4395
    find_lex $P4396, "$_"
    unless_null $P4396, vivify_2177
    new $P4396, "Undef"
  vivify_2177:
    find_lex $P4397, "$name"
    unless_null $P4397, vivify_2178
    new $P4397, "Undef"
  vivify_2178:
    $P4398 = $P4396."symbol"($P4397)
    store_lex "%sym", $P4398
.annotate 'line', 1451
    find_lex $P4403, "%sym"
    unless_null $P4403, vivify_2179
    $P4403 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P4404, $P4403["proto"]
    unless_null $P4404, vivify_2180
    new $P4404, "Undef"
  vivify_2180:
    unless $P4404, unless_4402
    set $P4401, $P4404
    goto unless_4402_end
  unless_4402:
    find_lex $P4405, "%sym"
    unless_null $P4405, vivify_2181
    $P4405 = root_new ['parrot';'Hash']
  vivify_2181:
    set $P4406, $P4405["cholder"]
    unless_null $P4406, vivify_2182
    new $P4406, "Undef"
  vivify_2182:
    set $P4401, $P4406
  unless_4402_end:
    if $P4401, if_4400
.annotate 'line', 1454
    find_lex $P4410, "%sym"
    unless_null $P4410, vivify_2183
    $P4410 = root_new ['parrot';'Hash']
  vivify_2183:
    if $P4410, if_4409
    set $P4408, $P4410
    goto if_4409_end
  if_4409:
.annotate 'line', 1455
    find_lex $P4411, "$/"
    unless_null $P4411, vivify_2184
    new $P4411, "Undef"
  vivify_2184:
    $P4412 = $P4411."CURSOR"()
    $P4413 = $P4412."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1454
    set $P4408, $P4413
  if_4409_end:
    set $P4399, $P4408
.annotate 'line', 1451
    goto if_4400_end
  if_4400:
.annotate 'line', 1452
    new $P4407, "Integer"
    assign $P4407, 1
    store_lex "$found_proto", $P4407
.annotate 'line', 1451
    set $P4399, $P4407
  if_4400_end:
.annotate 'line', 1449
    .return ($P4399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4562"  :anon :subid("500_1303576195.699") :outer("494_1303576195.699")
    .param pmc param_4564
.annotate 'line', 1534
    .lex "$_", param_4564
    find_lex $P4565, "$_"
    unless_null $P4565, vivify_2215
    new $P4565, "Undef"
  vivify_2215:
    $P4566 = $P4565."ast"()
    find_lex $P4567, "$/"
    unless_null $P4567, vivify_2216
    new $P4567, "Undef"
  vivify_2216:
    $P4568 = $P4566($P4567)
    .return ($P4568)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("501_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4576
    .param pmc param_4577
.annotate 'line', 1541
    .const 'Sub' $P4689 = "503_1303576195.699" 
    capture_lex $P4689
    .const 'Sub' $P4605 = "502_1303576195.699" 
    capture_lex $P4605
    .lex "self", param_4576
    .lex "$/", param_4577
.annotate 'line', 1544
    new $P4578, "Undef"
    .lex "$past", $P4578
.annotate 'line', 1541
    find_lex $P4579, "$past"
    unless_null $P4579, vivify_2218
    new $P4579, "Undef"
  vivify_2218:
.annotate 'line', 1545
    find_lex $P4581, "$/"
    unless_null $P4581, vivify_2219
    $P4581 = root_new ['parrot';'Hash']
  vivify_2219:
    set $P4582, $P4581["onlystar"]
    unless_null $P4582, vivify_2220
    new $P4582, "Undef"
  vivify_2220:
    if $P4582, if_4580
.annotate 'line', 1549
    find_lex $P4584, "$/"
    unless_null $P4584, vivify_2221
    $P4584 = root_new ['parrot';'Hash']
  vivify_2221:
    set $P4585, $P4584["blockoid"]
    unless_null $P4585, vivify_2222
    new $P4585, "Undef"
  vivify_2222:
    $P4586 = $P4585."ast"()
    store_lex "$past", $P4586
.annotate 'line', 1550
    find_lex $P4587, "$past"
    unless_null $P4587, vivify_2223
    new $P4587, "Undef"
  vivify_2223:
    $P4587."blocktype"("declaration")
.annotate 'line', 1551
    find_dynamic_lex $P4589, "$*RETURN_USED"
    unless_null $P4589, vivify_2224
    get_hll_global $P4589, "$RETURN_USED"
    unless_null $P4589, vivify_2225
    die "Contextual $*RETURN_USED not found"
  vivify_2225:
  vivify_2224:
    unless $P4589, if_4588_end
.annotate 'line', 1552
    find_lex $P4590, "$past"
    unless_null $P4590, vivify_2226
    new $P4590, "Undef"
  vivify_2226:
    $P4590."control"("return_pir")
  if_4588_end:
.annotate 'line', 1548
    goto if_4580_end
  if_4580:
.annotate 'line', 1546
    $P4583 = "only_star_block"()
    store_lex "$past", $P4583
  if_4580_end:
.annotate 'line', 1557
    find_lex $P4592, "$past"
    unless_null $P4592, vivify_2227
    $P4592 = root_new ['parrot';'Hash']
  vivify_2227:
    set $P4593, $P4592["signature_has_invocant"]
    unless_null $P4593, vivify_2228
    new $P4593, "Undef"
  vivify_2228:
    if $P4593, unless_4591_end
.annotate 'line', 1558
    find_lex $P4594, "$past"
    unless_null $P4594, vivify_2229
    $P4594 = root_new ['parrot';'ResizablePMCArray']
  vivify_2229:
    set $P4595, $P4594[0]
    unless_null $P4595, vivify_2230
    new $P4595, "Undef"
  vivify_2230:
    get_hll_global $P4596, ["PAST"], "Var"
.annotate 'line', 1560
    get_hll_global $P4597, ["PAST"], "Var"
    $P4598 = $P4597."new"("$?CLASS" :named("name"))
    $P4599 = $P4596."new"("self" :named("name"), "parameter" :named("scope"), $P4598 :named("multitype"))
.annotate 'line', 1558
    $P4595."unshift"($P4599)
  unless_4591_end:
.annotate 'line', 1563
    find_lex $P4600, "$past"
    unless_null $P4600, vivify_2231
    new $P4600, "Undef"
  vivify_2231:
    $P4600."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1566
    find_lex $P4602, "$/"
    unless_null $P4602, vivify_2232
    $P4602 = root_new ['parrot';'Hash']
  vivify_2232:
    set $P4603, $P4602["deflongname"]
    unless_null $P4603, vivify_2233
    new $P4603, "Undef"
  vivify_2233:
    unless $P4603, if_4601_end
    .const 'Sub' $P4605 = "502_1303576195.699" 
    capture_lex $P4605
    $P4605()
  if_4601_end:
.annotate 'line', 1601
    find_dynamic_lex $P4671, "$*SCOPE"
    unless_null $P4671, vivify_2259
    get_hll_global $P4671, "$SCOPE"
    unless_null $P4671, vivify_2260
    die "Contextual $*SCOPE not found"
  vivify_2260:
  vivify_2259:
    set $S4672, $P4671
    iseq $I4673, $S4672, "our"
    unless $I4673, if_4670_end
.annotate 'line', 1602
    find_lex $P4674, "$past"
    unless_null $P4674, vivify_2261
    new $P4674, "Undef"
  vivify_2261:
    $P4674."pirflags"(":nsentry")
  if_4670_end:
.annotate 'line', 1606
    find_lex $P4675, "$/"
    find_lex $P4676, "$past"
    unless_null $P4676, vivify_2262
    new $P4676, "Undef"
  vivify_2262:
    $P4675."!make"($P4676)
.annotate 'line', 1607
    find_lex $P4677, "$past"
    unless_null $P4677, vivify_2263
    new $P4677, "Undef"
  vivify_2263:
    find_lex $P4678, "$past"
    unless_null $P4678, vivify_2264
    $P4678 = root_new ['parrot';'Hash']
    store_lex "$past", $P4678
  vivify_2264:
    set $P4678["block_past"], $P4677
.annotate 'line', 1608
    find_lex $P4681, "$/"
    unless_null $P4681, vivify_2265
    $P4681 = root_new ['parrot';'Hash']
  vivify_2265:
    set $P4682, $P4681["trait"]
    unless_null $P4682, vivify_2266
    new $P4682, "Undef"
  vivify_2266:
    if $P4682, if_4680
    set $P4679, $P4682
    goto if_4680_end
  if_4680:
.annotate 'line', 1609
    find_lex $P4684, "$/"
    unless_null $P4684, vivify_2267
    $P4684 = root_new ['parrot';'Hash']
  vivify_2267:
    set $P4685, $P4684["trait"]
    unless_null $P4685, vivify_2268
    new $P4685, "Undef"
  vivify_2268:
    defined $I4686, $P4685
    unless $I4686, for_undef_2269
    iter $P4683, $P4685
    new $P4696, 'ExceptionHandler'
    set_label $P4696, loop4695_handler
    $P4696."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4696
  loop4695_test:
    unless $P4683, loop4695_done
    shift $P4687, $P4683
  loop4695_redo:
    .const 'Sub' $P4689 = "503_1303576195.699" 
    capture_lex $P4689
    $P4689($P4687)
  loop4695_next:
    goto loop4695_test
  loop4695_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4697, exception, 'type'
    eq $P4697, .CONTROL_LOOP_NEXT, loop4695_next
    eq $P4697, .CONTROL_LOOP_REDO, loop4695_redo
  loop4695_done:
    pop_eh 
  for_undef_2269:
.annotate 'line', 1608
    set $P4679, $P4683
  if_4680_end:
.annotate 'line', 1541
    .return ($P4679)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4604"  :anon :subid("502_1303576195.699") :outer("501_1303576195.699")
.annotate 'line', 1568
    new $P4606, "Undef"
    .lex "$name", $P4606
.annotate 'line', 1573
    new $P4607, "Undef"
    .lex "$to_add", $P4607
.annotate 'line', 1568
    find_lex $P4608, "$/"
    unless_null $P4608, vivify_2234
    $P4608 = root_new ['parrot';'Hash']
  vivify_2234:
    set $P4609, $P4608["private"]
    unless_null $P4609, vivify_2235
    new $P4609, "Undef"
  vivify_2235:
    set $S4610, $P4609
    new $P4611, 'String'
    set $P4611, $S4610
    find_lex $P4612, "$/"
    unless_null $P4612, vivify_2236
    $P4612 = root_new ['parrot';'Hash']
  vivify_2236:
    set $P4613, $P4612["deflongname"]
    unless_null $P4613, vivify_2237
    $P4613 = root_new ['parrot';'ResizablePMCArray']
  vivify_2237:
    set $P4614, $P4613[0]
    unless_null $P4614, vivify_2238
    new $P4614, "Undef"
  vivify_2238:
    $P4615 = $P4614."ast"()
    set $S4616, $P4615
    concat $P4617, $P4611, $S4616
    store_lex "$name", $P4617
.annotate 'line', 1569
    find_lex $P4618, "$past"
    unless_null $P4618, vivify_2239
    new $P4618, "Undef"
  vivify_2239:
    find_lex $P4619, "$name"
    unless_null $P4619, vivify_2240
    new $P4619, "Undef"
  vivify_2240:
    $P4618."name"($P4619)
.annotate 'line', 1573
    find_dynamic_lex $P4622, "$*MULTINESS"
    unless_null $P4622, vivify_2241
    get_hll_global $P4622, "$MULTINESS"
    unless_null $P4622, vivify_2242
    die "Contextual $*MULTINESS not found"
  vivify_2242:
  vivify_2241:
    set $S4623, $P4622
    isne $I4624, $S4623, "proto"
    if $I4624, if_4621
.annotate 'line', 1575
    get_hll_global $P4628, ["PAST"], "Op"
.annotate 'line', 1577
    get_hll_global $P4629, ["PAST"], "Val"
    find_lex $P4630, "$past"
    unless_null $P4630, vivify_2243
    new $P4630, "Undef"
  vivify_2243:
    $P4631 = $P4629."new"($P4630 :named("value"))
.annotate 'line', 1578
    get_hll_global $P4632, ["PAST"], "Op"
    $P4633 = $P4632."new"("list" :named("pasttype"))
    $P4634 = $P4628."new"($P4631, $P4633, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1575
    set $P4620, $P4634
.annotate 'line', 1573
    goto if_4621_end
  if_4621:
.annotate 'line', 1574
    get_hll_global $P4625, ["PAST"], "Val"
    find_lex $P4626, "$past"
    unless_null $P4626, vivify_2244
    new $P4626, "Undef"
  vivify_2244:
    $P4627 = $P4625."new"($P4626 :named("value"))
    set $P4620, $P4627
  if_4621_end:
.annotate 'line', 1573
    store_lex "$to_add", $P4620
.annotate 'line', 1580
    find_dynamic_lex $P4636, "$*MULTINESS"
    unless_null $P4636, vivify_2245
    get_hll_global $P4636, "$MULTINESS"
    unless_null $P4636, vivify_2246
    die "Contextual $*MULTINESS not found"
  vivify_2246:
  vivify_2245:
    set $S4637, $P4636
    iseq $I4638, $S4637, "proto"
    unless $I4638, if_4635_end
    find_lex $P4639, "$past"
    unless_null $P4639, vivify_2247
    new $P4639, "Undef"
  vivify_2247:
    $P4639."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4635_end:
.annotate 'line', 1584
    find_dynamic_lex $P4641, "$*MULTINESS"
    unless_null $P4641, vivify_2248
    get_hll_global $P4641, "$MULTINESS"
    unless_null $P4641, vivify_2249
    die "Contextual $*MULTINESS not found"
  vivify_2249:
  vivify_2248:
    set $S4642, $P4641
    iseq $I4643, $S4642, "multi"
    unless $I4643, if_4640_end
    find_lex $P4644, "$past"
    unless_null $P4644, vivify_2250
    new $P4644, "Undef"
  vivify_2250:
    "attach_multi_signature"($P4644)
  if_4640_end:
.annotate 'line', 1587
    find_dynamic_lex $P4647, "$*PACKAGE-SETUP"
    unless_null $P4647, vivify_2251
    get_hll_global $P4647, "$PACKAGE-SETUP"
    unless_null $P4647, vivify_2252
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2252:
  vivify_2251:
    defined $I4648, $P4647
    if $I4648, if_4646
    new $P4645, 'Integer'
    set $P4645, $I4648
    goto if_4646_end
  if_4646:
.annotate 'line', 1588
    find_dynamic_lex $P4649, "$*PACKAGE-SETUP"
    unless_null $P4649, vivify_2253
    get_hll_global $P4649, "$PACKAGE-SETUP"
    unless_null $P4649, vivify_2254
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2254:
  vivify_2253:
    get_hll_global $P4650, ["PAST"], "Op"
.annotate 'line', 1589
    find_dynamic_lex $P4653, "$*MULTINESS"
    unless_null $P4653, vivify_2255
    get_hll_global $P4653, "$MULTINESS"
    unless_null $P4653, vivify_2256
    die "Contextual $*MULTINESS not found"
  vivify_2256:
  vivify_2255:
    set $S4654, $P4653
    iseq $I4655, $S4654, "multi"
    if $I4655, if_4652
    new $P4657, "String"
    assign $P4657, "add_method"
    set $P4651, $P4657
    goto if_4652_end
  if_4652:
    new $P4656, "String"
    assign $P4656, "add_multi_method"
    set $P4651, $P4656
  if_4652_end:
.annotate 'line', 1590
    get_hll_global $P4658, ["PAST"], "Op"
.annotate 'line', 1593
    get_hll_global $P4659, ["PAST"], "Var"
    $P4660 = $P4659."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4661 = $P4658."new"($P4660, "get_how PP" :named("pirop"))
.annotate 'line', 1595
    get_hll_global $P4662, ["PAST"], "Var"
    $P4663 = $P4662."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1596
    get_hll_global $P4664, ["PAST"], "Val"
    find_lex $P4665, "$name"
    unless_null $P4665, vivify_2257
    new $P4665, "Undef"
  vivify_2257:
    $P4666 = $P4664."new"($P4665 :named("value"))
    find_lex $P4667, "$to_add"
    unless_null $P4667, vivify_2258
    new $P4667, "Undef"
  vivify_2258:
    $P4668 = $P4650."new"($P4661, $P4663, $P4666, $P4667, "callmethod" :named("pasttype"), $P4651 :named("name"))
.annotate 'line', 1588
    $P4669 = $P4649."push"($P4668)
.annotate 'line', 1587
    set $P4645, $P4669
  if_4646_end:
.annotate 'line', 1566
    .return ($P4645)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4688"  :anon :subid("503_1303576195.699") :outer("501_1303576195.699")
    .param pmc param_4690
.annotate 'line', 1609
    .lex "$_", param_4690
    find_lex $P4691, "$_"
    unless_null $P4691, vivify_2270
    new $P4691, "Undef"
  vivify_2270:
    $P4692 = $P4691."ast"()
    find_lex $P4693, "$/"
    unless_null $P4693, vivify_2271
    new $P4693, "Undef"
  vivify_2271:
    $P4694 = $P4692($P4693)
    .return ($P4694)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("504_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4701
    .param pmc param_4702
.annotate 'line', 1641
    .const 'Sub' $P4739 = "506_1303576195.699" 
    capture_lex $P4739
    .const 'Sub' $P4713 = "505_1303576195.699" 
    capture_lex $P4713
    .lex "self", param_4701
    .lex "$/", param_4702
.annotate 'line', 1642
    new $P4703, "Undef"
    .lex "$BLOCKINIT", $P4703
    find_lex $P4704, "$?PACKAGE"
    get_who $P4705, $P4704
    set $P4706, $P4705["@BLOCK"]
    unless_null $P4706, vivify_2272
    $P4706 = root_new ['parrot';'ResizablePMCArray']
  vivify_2272:
    set $P4707, $P4706[0]
    unless_null $P4707, vivify_2273
    $P4707 = root_new ['parrot';'ResizablePMCArray']
  vivify_2273:
    set $P4708, $P4707[0]
    unless_null $P4708, vivify_2274
    new $P4708, "Undef"
  vivify_2274:
    store_lex "$BLOCKINIT", $P4708
.annotate 'line', 1643
    find_lex $P4710, "$/"
    unless_null $P4710, vivify_2275
    $P4710 = root_new ['parrot';'Hash']
  vivify_2275:
    set $P4711, $P4710["invocant"]
    unless_null $P4711, vivify_2276
    new $P4711, "Undef"
  vivify_2276:
    unless $P4711, if_4709_end
    .const 'Sub' $P4713 = "505_1303576195.699" 
    capture_lex $P4713
    $P4713()
  if_4709_end:
.annotate 'line', 1652
    find_lex $P4734, "$/"
    unless_null $P4734, vivify_2286
    $P4734 = root_new ['parrot';'Hash']
  vivify_2286:
    set $P4735, $P4734["parameter"]
    unless_null $P4735, vivify_2287
    new $P4735, "Undef"
  vivify_2287:
    defined $I4736, $P4735
    unless $I4736, for_undef_2288
    iter $P4733, $P4735
    new $P4746, 'ExceptionHandler'
    set_label $P4746, loop4745_handler
    $P4746."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4746
  loop4745_test:
    unless $P4733, loop4745_done
    shift $P4737, $P4733
  loop4745_redo:
    .const 'Sub' $P4739 = "506_1303576195.699" 
    capture_lex $P4739
    $P4739($P4737)
  loop4745_next:
    goto loop4745_test
  loop4745_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4747, exception, 'type'
    eq $P4747, .CONTROL_LOOP_NEXT, loop4745_next
    eq $P4747, .CONTROL_LOOP_REDO, loop4745_redo
  loop4745_done:
    pop_eh 
  for_undef_2288:
.annotate 'line', 1641
    .return ($P4733)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4712"  :anon :subid("505_1303576195.699") :outer("504_1303576195.699")
.annotate 'line', 1644
    new $P4714, "Undef"
    .lex "$inv", $P4714
    find_lex $P4715, "$/"
    unless_null $P4715, vivify_2277
    $P4715 = root_new ['parrot';'Hash']
  vivify_2277:
    set $P4716, $P4715["invocant"]
    unless_null $P4716, vivify_2278
    $P4716 = root_new ['parrot';'ResizablePMCArray']
  vivify_2278:
    set $P4717, $P4716[0]
    unless_null $P4717, vivify_2279
    new $P4717, "Undef"
  vivify_2279:
    $P4718 = $P4717."ast"()
    store_lex "$inv", $P4718
.annotate 'line', 1645
    find_lex $P4719, "$BLOCKINIT"
    unless_null $P4719, vivify_2280
    new $P4719, "Undef"
  vivify_2280:
    find_lex $P4720, "$inv"
    unless_null $P4720, vivify_2281
    new $P4720, "Undef"
  vivify_2281:
    $P4719."push"($P4720)
.annotate 'line', 1646
    find_lex $P4721, "$BLOCKINIT"
    unless_null $P4721, vivify_2282
    new $P4721, "Undef"
  vivify_2282:
    get_hll_global $P4722, ["PAST"], "Var"
.annotate 'line', 1648
    get_hll_global $P4723, ["PAST"], "Var"
    find_lex $P4724, "$inv"
    unless_null $P4724, vivify_2283
    new $P4724, "Undef"
  vivify_2283:
    $P4725 = $P4724."name"()
    $P4726 = $P4723."new"("lexical" :named("scope"), $P4725 :named("name"))
    $P4727 = $P4722."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4726 :named("viviself"))
.annotate 'line', 1646
    $P4721."push"($P4727)
.annotate 'line', 1650
    new $P4728, "Integer"
    assign $P4728, 1
    find_lex $P4729, "$?PACKAGE"
    get_who $P4730, $P4729
    set $P4731, $P4730["@BLOCK"]
    unless_null $P4731, vivify_2284
    $P4731 = root_new ['parrot';'ResizablePMCArray']
    set $P4730["@BLOCK"], $P4731
  vivify_2284:
    set $P4732, $P4731[0]
    unless_null $P4732, vivify_2285
    $P4732 = root_new ['parrot';'Hash']
    set $P4731[0], $P4732
  vivify_2285:
    set $P4732["signature_has_invocant"], $P4728
.annotate 'line', 1643
    .return ($P4728)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4738"  :anon :subid("506_1303576195.699") :outer("504_1303576195.699")
    .param pmc param_4740
.annotate 'line', 1652
    .lex "$_", param_4740
    find_lex $P4741, "$BLOCKINIT"
    unless_null $P4741, vivify_2289
    new $P4741, "Undef"
  vivify_2289:
    find_lex $P4742, "$_"
    unless_null $P4742, vivify_2290
    new $P4742, "Undef"
  vivify_2290:
    $P4743 = $P4742."ast"()
    $P4744 = $P4741."push"($P4743)
    .return ($P4744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("507_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4749
    .param pmc param_4750
.annotate 'line', 1655
    .lex "self", param_4749
    .lex "$/", param_4750
.annotate 'line', 1656
    new $P4751, "Undef"
    .lex "$quant", $P4751
.annotate 'line', 1657
    new $P4752, "Undef"
    .lex "$past", $P4752
.annotate 'line', 1656
    find_lex $P4753, "$/"
    unless_null $P4753, vivify_2291
    $P4753 = root_new ['parrot';'Hash']
  vivify_2291:
    set $P4754, $P4753["quant"]
    unless_null $P4754, vivify_2292
    new $P4754, "Undef"
  vivify_2292:
    store_lex "$quant", $P4754
    find_lex $P4755, "$past"
    unless_null $P4755, vivify_2293
    new $P4755, "Undef"
  vivify_2293:
.annotate 'line', 1658
    find_lex $P4757, "$/"
    unless_null $P4757, vivify_2294
    $P4757 = root_new ['parrot';'Hash']
  vivify_2294:
    set $P4758, $P4757["named_param"]
    unless_null $P4758, vivify_2295
    new $P4758, "Undef"
  vivify_2295:
    if $P4758, if_4756
.annotate 'line', 1665
    find_lex $P4772, "$/"
    unless_null $P4772, vivify_2296
    $P4772 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P4773, $P4772["param_var"]
    unless_null $P4773, vivify_2297
    new $P4773, "Undef"
  vivify_2297:
    $P4774 = $P4773."ast"()
    store_lex "$past", $P4774
.annotate 'line', 1666
    find_lex $P4776, "$quant"
    unless_null $P4776, vivify_2298
    new $P4776, "Undef"
  vivify_2298:
    set $S4777, $P4776
    iseq $I4778, $S4777, "*"
    if $I4778, if_4775
.annotate 'line', 1670
    find_lex $P4787, "$quant"
    unless_null $P4787, vivify_2299
    new $P4787, "Undef"
  vivify_2299:
    set $S4788, $P4787
    iseq $I4789, $S4788, "?"
    unless $I4789, if_4786_end
.annotate 'line', 1671
    find_lex $P4790, "$past"
    unless_null $P4790, vivify_2300
    new $P4790, "Undef"
  vivify_2300:
    find_lex $P4791, "$/"
    unless_null $P4791, vivify_2301
    $P4791 = root_new ['parrot';'Hash']
  vivify_2301:
    set $P4792, $P4791["param_var"]
    unless_null $P4792, vivify_2302
    $P4792 = root_new ['parrot';'Hash']
  vivify_2302:
    set $P4793, $P4792["sigil"]
    unless_null $P4793, vivify_2303
    new $P4793, "Undef"
  vivify_2303:
    $P4794 = "vivitype"($P4793)
    $P4790."viviself"($P4794)
  if_4786_end:
.annotate 'line', 1670
    goto if_4775_end
  if_4775:
.annotate 'line', 1667
    find_lex $P4779, "$past"
    unless_null $P4779, vivify_2304
    new $P4779, "Undef"
  vivify_2304:
    $P4779."slurpy"(1)
.annotate 'line', 1668
    find_lex $P4780, "$past"
    unless_null $P4780, vivify_2305
    new $P4780, "Undef"
  vivify_2305:
    find_lex $P4781, "$/"
    unless_null $P4781, vivify_2306
    $P4781 = root_new ['parrot';'Hash']
  vivify_2306:
    set $P4782, $P4781["param_var"]
    unless_null $P4782, vivify_2307
    $P4782 = root_new ['parrot';'Hash']
  vivify_2307:
    set $P4783, $P4782["sigil"]
    unless_null $P4783, vivify_2308
    new $P4783, "Undef"
  vivify_2308:
    set $S4784, $P4783
    iseq $I4785, $S4784, "%"
    $P4780."named"($I4785)
  if_4775_end:
.annotate 'line', 1664
    goto if_4756_end
  if_4756:
.annotate 'line', 1659
    find_lex $P4759, "$/"
    unless_null $P4759, vivify_2309
    $P4759 = root_new ['parrot';'Hash']
  vivify_2309:
    set $P4760, $P4759["named_param"]
    unless_null $P4760, vivify_2310
    new $P4760, "Undef"
  vivify_2310:
    $P4761 = $P4760."ast"()
    store_lex "$past", $P4761
.annotate 'line', 1660
    find_lex $P4763, "$quant"
    unless_null $P4763, vivify_2311
    new $P4763, "Undef"
  vivify_2311:
    set $S4764, $P4763
    isne $I4765, $S4764, "!"
    unless $I4765, if_4762_end
.annotate 'line', 1661
    find_lex $P4766, "$past"
    unless_null $P4766, vivify_2312
    new $P4766, "Undef"
  vivify_2312:
    find_lex $P4767, "$/"
    unless_null $P4767, vivify_2313
    $P4767 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P4768, $P4767["named_param"]
    unless_null $P4768, vivify_2314
    $P4768 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P4769, $P4768["param_var"]
    unless_null $P4769, vivify_2315
    $P4769 = root_new ['parrot';'Hash']
  vivify_2315:
    set $P4770, $P4769["sigil"]
    unless_null $P4770, vivify_2316
    new $P4770, "Undef"
  vivify_2316:
    $P4771 = "vivitype"($P4770)
    $P4766."viviself"($P4771)
  if_4762_end:
  if_4756_end:
.annotate 'line', 1674
    find_lex $P4796, "$/"
    unless_null $P4796, vivify_2317
    $P4796 = root_new ['parrot';'Hash']
  vivify_2317:
    set $P4797, $P4796["default_value"]
    unless_null $P4797, vivify_2318
    new $P4797, "Undef"
  vivify_2318:
    unless $P4797, if_4795_end
.annotate 'line', 1675
    find_lex $P4799, "$quant"
    unless_null $P4799, vivify_2319
    new $P4799, "Undef"
  vivify_2319:
    set $S4800, $P4799
    iseq $I4801, $S4800, "*"
    unless $I4801, if_4798_end
.annotate 'line', 1676
    find_lex $P4802, "$/"
    unless_null $P4802, vivify_2320
    new $P4802, "Undef"
  vivify_2320:
    $P4803 = $P4802."CURSOR"()
    $P4803."panic"("Can't put default on slurpy parameter")
  if_4798_end:
.annotate 'line', 1678
    find_lex $P4805, "$quant"
    unless_null $P4805, vivify_2321
    new $P4805, "Undef"
  vivify_2321:
    set $S4806, $P4805
    iseq $I4807, $S4806, "!"
    unless $I4807, if_4804_end
.annotate 'line', 1679
    find_lex $P4808, "$/"
    unless_null $P4808, vivify_2322
    new $P4808, "Undef"
  vivify_2322:
    $P4809 = $P4808."CURSOR"()
    $P4809."panic"("Can't put default on required parameter")
  if_4804_end:
.annotate 'line', 1681
    find_lex $P4810, "$past"
    unless_null $P4810, vivify_2323
    new $P4810, "Undef"
  vivify_2323:
    find_lex $P4811, "$/"
    unless_null $P4811, vivify_2324
    $P4811 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P4812, $P4811["default_value"]
    unless_null $P4812, vivify_2325
    $P4812 = root_new ['parrot';'ResizablePMCArray']
  vivify_2325:
    set $P4813, $P4812[0]
    unless_null $P4813, vivify_2326
    $P4813 = root_new ['parrot';'Hash']
  vivify_2326:
    set $P4814, $P4813["EXPR"]
    unless_null $P4814, vivify_2327
    new $P4814, "Undef"
  vivify_2327:
    $P4815 = $P4814."ast"()
    $P4810."viviself"($P4815)
  if_4795_end:
.annotate 'line', 1683
    find_lex $P4817, "$past"
    unless_null $P4817, vivify_2328
    new $P4817, "Undef"
  vivify_2328:
    $P4818 = $P4817."viviself"()
    if $P4818, unless_4816_end
    find_lex $P4819, "$?PACKAGE"
    get_who $P4820, $P4819
    set $P4821, $P4820["@BLOCK"]
    unless_null $P4821, vivify_2329
    $P4821 = root_new ['parrot';'ResizablePMCArray']
  vivify_2329:
    set $P4822, $P4821[0]
    unless_null $P4822, vivify_2330
    new $P4822, "Undef"
  vivify_2330:
    find_lex $P4823, "$?PACKAGE"
    get_who $P4824, $P4823
    set $P4825, $P4824["@BLOCK"]
    unless_null $P4825, vivify_2331
    $P4825 = root_new ['parrot';'ResizablePMCArray']
  vivify_2331:
    set $P4826, $P4825[0]
    unless_null $P4826, vivify_2332
    new $P4826, "Undef"
  vivify_2332:
    $P4827 = $P4826."arity"()
    set $N4828, $P4827
    new $P4829, 'Float'
    set $P4829, $N4828
    add $P4830, $P4829, 1
    $P4822."arity"($P4830)
  unless_4816_end:
.annotate 'line', 1687
    find_lex $P4832, "$/"
    unless_null $P4832, vivify_2333
    $P4832 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P4833, $P4832["typename"]
    unless_null $P4833, vivify_2334
    new $P4833, "Undef"
  vivify_2334:
    unless $P4833, if_4831_end
.annotate 'line', 1688
    find_lex $P4834, "$past"
    unless_null $P4834, vivify_2335
    new $P4834, "Undef"
  vivify_2335:
    find_lex $P4835, "$/"
    unless_null $P4835, vivify_2336
    $P4835 = root_new ['parrot';'Hash']
  vivify_2336:
    set $P4836, $P4835["typename"]
    unless_null $P4836, vivify_2337
    $P4836 = root_new ['parrot';'ResizablePMCArray']
  vivify_2337:
    set $P4837, $P4836[0]
    unless_null $P4837, vivify_2338
    new $P4837, "Undef"
  vivify_2338:
    $P4838 = $P4837."ast"()
    $P4834."multitype"($P4838)
  if_4831_end:
.annotate 'line', 1692
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2339
    $P4840 = root_new ['parrot';'Hash']
  vivify_2339:
    set $P4841, $P4840["definedness"]
    unless_null $P4841, vivify_2340
    new $P4841, "Undef"
  vivify_2340:
    unless $P4841, if_4839_end
.annotate 'line', 1693
    find_lex $P4842, "$/"
    unless_null $P4842, vivify_2341
    $P4842 = root_new ['parrot';'Hash']
  vivify_2341:
    set $P4843, $P4842["definedness"]
    unless_null $P4843, vivify_2342
    $P4843 = root_new ['parrot';'ResizablePMCArray']
  vivify_2342:
    set $P4844, $P4843[0]
    unless_null $P4844, vivify_2343
    new $P4844, "Undef"
  vivify_2343:
    set $S4845, $P4844
    new $P4846, 'String'
    set $P4846, $S4845
    find_lex $P4847, "$past"
    unless_null $P4847, vivify_2344
    $P4847 = root_new ['parrot';'Hash']
    store_lex "$past", $P4847
  vivify_2344:
    set $P4847["definedness"], $P4846
  if_4839_end:
.annotate 'line', 1696
    find_lex $P4848, "$/"
    find_lex $P4849, "$past"
    unless_null $P4849, vivify_2345
    new $P4849, "Undef"
  vivify_2345:
    $P4850 = $P4848."!make"($P4849)
.annotate 'line', 1655
    .return ($P4850)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("508_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4852
    .param pmc param_4853
.annotate 'line', 1699
    .lex "self", param_4852
    .lex "$/", param_4853
.annotate 'line', 1700
    new $P4854, "Undef"
    .lex "$name", $P4854
.annotate 'line', 1701
    new $P4855, "Undef"
    .lex "$past", $P4855
.annotate 'line', 1700
    find_lex $P4856, "$/"
    unless_null $P4856, vivify_2346
    new $P4856, "Undef"
  vivify_2346:
    set $S4857, $P4856
    new $P4858, 'String'
    set $P4858, $S4857
    store_lex "$name", $P4858
.annotate 'line', 1701
    get_hll_global $P4859, ["PAST"], "Var"
    find_lex $P4860, "$name"
    unless_null $P4860, vivify_2347
    new $P4860, "Undef"
  vivify_2347:
    find_lex $P4861, "$/"
    unless_null $P4861, vivify_2348
    new $P4861, "Undef"
  vivify_2348:
    $P4862 = $P4859."new"($P4860 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4861 :named("node"))
    store_lex "$past", $P4862
.annotate 'line', 1703
    find_lex $P4863, "$?PACKAGE"
    get_who $P4864, $P4863
    set $P4865, $P4864["@BLOCK"]
    unless_null $P4865, vivify_2349
    $P4865 = root_new ['parrot';'ResizablePMCArray']
  vivify_2349:
    set $P4866, $P4865[0]
    unless_null $P4866, vivify_2350
    new $P4866, "Undef"
  vivify_2350:
    find_lex $P4867, "$name"
    unless_null $P4867, vivify_2351
    new $P4867, "Undef"
  vivify_2351:
    $P4866."symbol"($P4867, "lexical" :named("scope"))
.annotate 'line', 1704
    find_lex $P4868, "$/"
    find_lex $P4869, "$past"
    unless_null $P4869, vivify_2352
    new $P4869, "Undef"
  vivify_2352:
    $P4870 = $P4868."!make"($P4869)
.annotate 'line', 1699
    .return ($P4870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("509_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4872
    .param pmc param_4873
.annotate 'line', 1707
    .lex "self", param_4872
    .lex "$/", param_4873
.annotate 'line', 1708
    new $P4874, "Undef"
    .lex "$past", $P4874
    find_lex $P4875, "$/"
    unless_null $P4875, vivify_2353
    $P4875 = root_new ['parrot';'Hash']
  vivify_2353:
    set $P4876, $P4875["param_var"]
    unless_null $P4876, vivify_2354
    new $P4876, "Undef"
  vivify_2354:
    $P4877 = $P4876."ast"()
    store_lex "$past", $P4877
.annotate 'line', 1709
    find_lex $P4878, "$past"
    unless_null $P4878, vivify_2355
    new $P4878, "Undef"
  vivify_2355:
    find_lex $P4879, "$/"
    unless_null $P4879, vivify_2356
    $P4879 = root_new ['parrot';'Hash']
  vivify_2356:
    set $P4880, $P4879["param_var"]
    unless_null $P4880, vivify_2357
    $P4880 = root_new ['parrot';'Hash']
  vivify_2357:
    set $P4881, $P4880["name"]
    unless_null $P4881, vivify_2358
    new $P4881, "Undef"
  vivify_2358:
    set $S4882, $P4881
    $P4878."named"($S4882)
.annotate 'line', 1710
    find_lex $P4883, "$/"
    find_lex $P4884, "$past"
    unless_null $P4884, vivify_2359
    new $P4884, "Undef"
  vivify_2359:
    $P4885 = $P4883."!make"($P4884)
.annotate 'line', 1707
    .return ($P4885)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("510_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4887
    .param pmc param_4888
.annotate 'line', 1713
    .lex "self", param_4887
    .lex "$/", param_4888
.annotate 'line', 1714
    $P4889 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4889
    get_hll_global $P4890, ["HLL"], "Compiler"
    find_lex $P4891, "$/"
    unless_null $P4891, vivify_2360
    new $P4891, "Undef"
  vivify_2360:
    set $S4892, $P4891
    $P4893 = $P4890."parse_name"($S4892)
    store_lex "@name", $P4893
.annotate 'line', 1715
    find_lex $P4894, "$/"
    get_hll_global $P4895, ["PAST"], "Var"
.annotate 'line', 1716
    find_lex $P4896, "@name"
    unless_null $P4896, vivify_2361
    $P4896 = root_new ['parrot';'ResizablePMCArray']
  vivify_2361:
    $P4897 = $P4896."pop"()
    find_lex $P4898, "@name"
    unless_null $P4898, vivify_2362
    $P4898 = root_new ['parrot';'ResizablePMCArray']
  vivify_2362:
    $P4899 = $P4895."new"($P4897 :named("name"), $P4898 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1715
    $P4900 = $P4894."!make"($P4899)
.annotate 'line', 1713
    .return ($P4900)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("511_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4902
    .param pmc param_4903
.annotate 'line', 1722
    .lex "self", param_4902
    .lex "$/", param_4903
.annotate 'line', 1723
    find_lex $P4904, "$/"
    find_lex $P4905, "$/"
    unless_null $P4905, vivify_2363
    $P4905 = root_new ['parrot';'Hash']
  vivify_2363:
    set $P4906, $P4905["trait_mod"]
    unless_null $P4906, vivify_2364
    new $P4906, "Undef"
  vivify_2364:
    $P4907 = $P4906."ast"()
    $P4908 = $P4904."!make"($P4907)
.annotate 'line', 1722
    .return ($P4908)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("512_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4910
    .param pmc param_4911
.annotate 'line', 1726
    .const 'Sub' $P4931 = "513_1303576195.699" 
    capture_lex $P4931
    .lex "self", param_4910
    .lex "$/", param_4911
.annotate 'line', 1727
    new $P4912, "Undef"
    .lex "$cpast", $P4912
    find_lex $P4913, "$/"
    unless_null $P4913, vivify_2365
    $P4913 = root_new ['parrot';'Hash']
  vivify_2365:
    set $P4914, $P4913["circumfix"]
    unless_null $P4914, vivify_2366
    $P4914 = root_new ['parrot';'ResizablePMCArray']
  vivify_2366:
    set $P4915, $P4914[0]
    unless_null $P4915, vivify_2367
    new $P4915, "Undef"
  vivify_2367:
    $P4916 = $P4915."ast"()
    store_lex "$cpast", $P4916
.annotate 'line', 1728
    find_lex $P4919, "$/"
    unless_null $P4919, vivify_2368
    $P4919 = root_new ['parrot';'Hash']
  vivify_2368:
    set $P4920, $P4919["longname"]
    unless_null $P4920, vivify_2369
    new $P4920, "Undef"
  vivify_2369:
    set $S4921, $P4920
    iseq $I4922, $S4921, "parrot_vtable"
    if $I4922, if_4918
.annotate 'line', 1748
    find_lex $P4957, "$/"
    unless_null $P4957, vivify_2370
    $P4957 = root_new ['parrot';'Hash']
  vivify_2370:
    set $P4958, $P4957["longname"]
    unless_null $P4958, vivify_2371
    new $P4958, "Undef"
  vivify_2371:
    set $S4959, $P4958
    iseq $I4960, $S4959, "pirflags"
    if $I4960, if_4956
.annotate 'line', 1752
    find_lex $P4964, "$/"
    unless_null $P4964, vivify_2372
    new $P4964, "Undef"
  vivify_2372:
    $P4965 = $P4964."CURSOR"()
    new $P4966, 'String'
    set $P4966, "Trait '"
    find_lex $P4967, "$/"
    unless_null $P4967, vivify_2373
    $P4967 = root_new ['parrot';'Hash']
  vivify_2373:
    set $P4968, $P4967["longname"]
    unless_null $P4968, vivify_2374
    new $P4968, "Undef"
  vivify_2374:
    concat $P4969, $P4966, $P4968
    concat $P4970, $P4969, "' not implemented"
    $P4971 = $P4965."panic"($P4970)
.annotate 'line', 1751
    set $P4955, $P4971
.annotate 'line', 1748
    goto if_4956_end
  if_4956:
.annotate 'line', 1749
    find_lex $P4961, "$/"
    unless_null $P4961, vivify_2375
    new $P4961, "Undef"
  vivify_2375:
    $P4962 = $P4961."CURSOR"()
    $P4963 = $P4962."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1748
    set $P4955, $P4963
  if_4956_end:
    set $P4917, $P4955
.annotate 'line', 1728
    goto if_4918_end
  if_4918:
.annotate 'line', 1731
    get_hll_global $P4924, ["PAST"], "Val"
    find_lex $P4925, "$cpast"
    unless_null $P4925, vivify_2376
    new $P4925, "Undef"
  vivify_2376:
    $P4926 = $P4924."ACCEPTS"($P4925)
    if $P4926, unless_4923_end
.annotate 'line', 1730
    find_lex $P4927, "$/"
    unless_null $P4927, vivify_2377
    new $P4927, "Undef"
  vivify_2377:
    $P4928 = $P4927."CURSOR"()
    $P4928."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4923_end:
.annotate 'line', 1732
    find_lex $P4929, "$/"
    .const 'Sub' $P4931 = "513_1303576195.699" 
    newclosure $P4953, $P4931
    $P4954 = $P4929."!make"($P4953)
.annotate 'line', 1728
    set $P4917, $P4954
  if_4918_end:
.annotate 'line', 1726
    .return ($P4917)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4930"  :anon :subid("513_1303576195.699") :outer("512_1303576195.699")
    .param pmc param_4932
.annotate 'line', 1732
    .lex "$match", param_4932
.annotate 'line', 1733
    new $P4933, "Undef"
    .lex "$meth", $P4933
    find_lex $P4934, "$match"
    unless_null $P4934, vivify_2378
    new $P4934, "Undef"
  vivify_2378:
    $P4935 = $P4934."ast"()
    set $P4936, $P4935["block_past"]
    unless_null $P4936, vivify_2379
    new $P4936, "Undef"
  vivify_2379:
    store_lex "$meth", $P4936
.annotate 'line', 1734
    find_dynamic_lex $P4939, "$*PACKAGE-SETUP"
    unless_null $P4939, vivify_2380
    get_hll_global $P4939, "$PACKAGE-SETUP"
    unless_null $P4939, vivify_2381
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2381:
  vivify_2380:
    defined $I4940, $P4939
    if $I4940, if_4938
    new $P4937, 'Integer'
    set $P4937, $I4940
    goto if_4938_end
  if_4938:
.annotate 'line', 1735
    find_dynamic_lex $P4941, "$*PACKAGE-SETUP"
    unless_null $P4941, vivify_2382
    get_hll_global $P4941, "$PACKAGE-SETUP"
    unless_null $P4941, vivify_2383
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2383:
  vivify_2382:
    get_hll_global $P4942, ["PAST"], "Op"
.annotate 'line', 1737
    get_hll_global $P4943, ["PAST"], "Op"
.annotate 'line', 1740
    get_hll_global $P4944, ["PAST"], "Var"
    $P4945 = $P4944."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4946 = $P4943."new"($P4945, "get_how PP" :named("pirop"))
.annotate 'line', 1742
    get_hll_global $P4947, ["PAST"], "Var"
    $P4948 = $P4947."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4949, "$cpast"
    unless_null $P4949, vivify_2384
    new $P4949, "Undef"
  vivify_2384:
    find_lex $P4950, "$meth"
    unless_null $P4950, vivify_2385
    new $P4950, "Undef"
  vivify_2385:
    $P4951 = $P4942."new"($P4946, $P4948, $P4949, $P4950, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1735
    $P4952 = $P4941."push"($P4951)
.annotate 'line', 1734
    set $P4937, $P4952
  if_4938_end:
.annotate 'line', 1732
    .return ($P4937)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("514_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_4975
    .param pmc param_4976
    .param pmc param_4977 :optional
    .param int has_param_4977 :opt_flag
.annotate 'line', 1756
    .const 'Sub' $P5084 = "517_1303576195.699" 
    capture_lex $P5084
    .const 'Sub' $P5049 = "516_1303576195.699" 
    capture_lex $P5049
    .const 'Sub' $P5022 = "515_1303576195.699" 
    capture_lex $P5022
    new $P4974, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4974, control_4973
    push_eh $P4974
    .lex "self", param_4975
    .lex "$/", param_4976
    if has_param_4977, optparam_2386
    new $P4978, "Undef"
    set param_4977, $P4978
  optparam_2386:
    .lex "$key", param_4977
.annotate 'line', 1757
    $P4979 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4979
.annotate 'line', 1758
    new $P4980, "Undef"
    .lex "$name", $P4980
.annotate 'line', 1759
    new $P4981, "Undef"
    .lex "$past", $P4981
.annotate 'line', 1757
    get_hll_global $P4982, ["Regex";"P6Regex"], "Actions"
    get_who $P4983, $P4982
    set $P4984, $P4983["@MODIFIERS"]
    unless_null $P4984, vivify_2387
    $P4984 = root_new ['parrot';'ResizablePMCArray']
  vivify_2387:
    store_lex "@MODIFIERS", $P4984
.annotate 'line', 1758
    find_lex $P4985, "$/"
    unless_null $P4985, vivify_2388
    $P4985 = root_new ['parrot';'Hash']
  vivify_2388:
    set $P4986, $P4985["deflongname"]
    unless_null $P4986, vivify_2389
    new $P4986, "Undef"
  vivify_2389:
    $P4987 = $P4986."ast"()
    set $S4988, $P4987
    new $P4989, 'String'
    set $P4989, $S4988
    store_lex "$name", $P4989
    find_lex $P4990, "$past"
    unless_null $P4990, vivify_2390
    new $P4990, "Undef"
  vivify_2390:
.annotate 'line', 1760
    find_lex $P4992, "$/"
    unless_null $P4992, vivify_2391
    $P4992 = root_new ['parrot';'Hash']
  vivify_2391:
    set $P4993, $P4992["proto"]
    unless_null $P4993, vivify_2392
    new $P4993, "Undef"
  vivify_2392:
    if $P4993, if_4991
.annotate 'line', 1799
    find_lex $P5045, "$key"
    unless_null $P5045, vivify_2393
    new $P5045, "Undef"
  vivify_2393:
    set $S5046, $P5045
    iseq $I5047, $S5046, "open"
    if $I5047, if_5044
.annotate 'line', 1809
    .const 'Sub' $P5084 = "517_1303576195.699" 
    capture_lex $P5084
    $P5084()
    goto if_5044_end
  if_5044:
.annotate 'line', 1799
    .const 'Sub' $P5049 = "516_1303576195.699" 
    capture_lex $P5049
    $P5049()
  if_5044_end:
    goto if_4991_end
  if_4991:
.annotate 'line', 1762
    get_hll_global $P4994, ["PAST"], "Stmts"
.annotate 'line', 1763
    get_hll_global $P4995, ["PAST"], "Block"
    find_lex $P4996, "$name"
    unless_null $P4996, vivify_2428
    new $P4996, "Undef"
  vivify_2428:
.annotate 'line', 1764
    get_hll_global $P4997, ["PAST"], "Op"
.annotate 'line', 1765
    get_hll_global $P4998, ["PAST"], "Var"
    $P4999 = $P4998."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5000, "$name"
    unless_null $P5000, vivify_2429
    new $P5000, "Undef"
  vivify_2429:
    $P5001 = $P4997."new"($P4999, $P5000, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1764
    find_lex $P5002, "$/"
    unless_null $P5002, vivify_2430
    new $P5002, "Undef"
  vivify_2430:
    $P5003 = $P4995."new"($P5001, $P4996 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5002 :named("node"))
.annotate 'line', 1774
    get_hll_global $P5004, ["PAST"], "Block"
    new $P5005, "String"
    assign $P5005, "!PREFIX__"
    find_lex $P5006, "$name"
    unless_null $P5006, vivify_2431
    new $P5006, "Undef"
  vivify_2431:
    concat $P5007, $P5005, $P5006
.annotate 'line', 1775
    get_hll_global $P5008, ["PAST"], "Op"
.annotate 'line', 1776
    get_hll_global $P5009, ["PAST"], "Var"
    $P5010 = $P5009."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5011, "$name"
    unless_null $P5011, vivify_2432
    new $P5011, "Undef"
  vivify_2432:
    $P5012 = $P5008."new"($P5010, $P5011, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1775
    find_lex $P5013, "$/"
    unless_null $P5013, vivify_2433
    new $P5013, "Undef"
  vivify_2433:
    $P5014 = $P5004."new"($P5012, $P5007 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5013 :named("node"))
.annotate 'line', 1774
    $P5015 = $P4994."new"($P5003, $P5014)
.annotate 'line', 1762
    store_lex "$past", $P5015
.annotate 'line', 1786
    find_lex $P5017, "$past"
    unless_null $P5017, vivify_2434
    new $P5017, "Undef"
  vivify_2434:
    $P5018 = $P5017."list"()
    defined $I5019, $P5018
    unless $I5019, for_undef_2435
    iter $P5016, $P5018
    new $P5042, 'ExceptionHandler'
    set_label $P5042, loop5041_handler
    $P5042."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5042
  loop5041_test:
    unless $P5016, loop5041_done
    shift $P5020, $P5016
  loop5041_redo:
    .const 'Sub' $P5022 = "515_1303576195.699" 
    capture_lex $P5022
    $P5022($P5020)
  loop5041_next:
    goto loop5041_test
  loop5041_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5043, exception, 'type'
    eq $P5043, .CONTROL_LOOP_NEXT, loop5041_next
    eq $P5043, .CONTROL_LOOP_REDO, loop5041_redo
  loop5041_done:
    pop_eh 
  for_undef_2435:
  if_4991_end:
.annotate 'line', 1845
    find_lex $P5144, "$/"
    find_lex $P5145, "$past"
    unless_null $P5145, vivify_2440
    new $P5145, "Undef"
  vivify_2440:
    $P5146 = $P5144."!make"($P5145)
.annotate 'line', 1756
    .return ($P5146)
  control_4973:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5147, exception, "payload"
    .return ($P5147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5083"  :anon :subid("517_1303576195.699") :outer("514_1303576195.699")
.annotate 'line', 1810
    new $P5085, "Undef"
    .lex "$regex", $P5085
.annotate 'line', 1811
    get_hll_global $P5086, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5087, "$/"
    unless_null $P5087, vivify_2394
    $P5087 = root_new ['parrot';'Hash']
  vivify_2394:
    set $P5088, $P5087["p6regex"]
    unless_null $P5088, vivify_2395
    new $P5088, "Undef"
  vivify_2395:
    $P5089 = $P5088."ast"()
    find_lex $P5090, "$?PACKAGE"
    get_who $P5091, $P5090
    set $P5092, $P5091["@BLOCK"]
    unless_null $P5092, vivify_2396
    $P5092 = root_new ['parrot';'ResizablePMCArray']
  vivify_2396:
    $P5093 = $P5092."shift"()
    $P5094 = $P5086($P5089, $P5093)
    store_lex "$regex", $P5094
.annotate 'line', 1812
    find_lex $P5095, "$regex"
    unless_null $P5095, vivify_2397
    new $P5095, "Undef"
  vivify_2397:
    find_lex $P5096, "$name"
    unless_null $P5096, vivify_2398
    new $P5096, "Undef"
  vivify_2398:
    $P5095."name"($P5096)
.annotate 'line', 1814
    get_hll_global $P5097, ["PAST"], "Op"
.annotate 'line', 1816
    get_hll_global $P5098, ["PAST"], "Var"
    new $P5099, "ResizablePMCArray"
    push $P5099, "Regex"
    $P5100 = $P5098."new"("Method" :named("name"), $P5099 :named("namespace"), "package" :named("scope"))
    find_lex $P5101, "$regex"
    unless_null $P5101, vivify_2399
    new $P5101, "Undef"
  vivify_2399:
    $P5102 = $P5097."new"($P5100, $P5101, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1814
    store_lex "$past", $P5102
.annotate 'line', 1819
    find_dynamic_lex $P5104, "$*PACKAGE-SETUP"
    unless_null $P5104, vivify_2400
    get_hll_global $P5104, "$PACKAGE-SETUP"
    unless_null $P5104, vivify_2401
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2401:
  vivify_2400:
    defined $I5105, $P5104
    unless $I5105, if_5103_end
.annotate 'line', 1820
    find_dynamic_lex $P5106, "$*PACKAGE-SETUP"
    unless_null $P5106, vivify_2402
    get_hll_global $P5106, "$PACKAGE-SETUP"
    unless_null $P5106, vivify_2403
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2403:
  vivify_2402:
    get_hll_global $P5107, ["PAST"], "Op"
.annotate 'line', 1822
    get_hll_global $P5108, ["PAST"], "Op"
.annotate 'line', 1824
    get_hll_global $P5109, ["PAST"], "Var"
    $P5110 = $P5109."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5111 = $P5108."new"($P5110, "get_how PP" :named("pirop"))
.annotate 'line', 1826
    get_hll_global $P5112, ["PAST"], "Var"
    $P5113 = $P5112."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1827
    get_hll_global $P5114, ["PAST"], "Val"
    find_lex $P5115, "$name"
    unless_null $P5115, vivify_2404
    new $P5115, "Undef"
  vivify_2404:
    $P5116 = $P5114."new"($P5115 :named("value"))
.annotate 'line', 1828
    get_hll_global $P5117, ["PAST"], "Val"
    find_lex $P5118, "$regex"
    unless_null $P5118, vivify_2405
    new $P5118, "Undef"
  vivify_2405:
    $P5119 = $P5117."new"($P5118 :named("value"))
    $P5120 = $P5107."new"($P5111, $P5113, $P5116, $P5119, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1820
    $P5106."push"($P5120)
.annotate 'line', 1830
    find_dynamic_lex $P5121, "$*PACKAGE-SETUP"
    unless_null $P5121, vivify_2406
    get_hll_global $P5121, "$PACKAGE-SETUP"
    unless_null $P5121, vivify_2407
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2407:
  vivify_2406:
    get_hll_global $P5122, ["PAST"], "Op"
.annotate 'line', 1832
    get_hll_global $P5123, ["PAST"], "Op"
.annotate 'line', 1834
    get_hll_global $P5124, ["PAST"], "Var"
    $P5125 = $P5124."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5126 = $P5123."new"($P5125, "get_how PP" :named("pirop"))
.annotate 'line', 1836
    get_hll_global $P5127, ["PAST"], "Var"
    $P5128 = $P5127."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1837
    get_hll_global $P5129, ["PAST"], "Val"
    new $P5130, "String"
    assign $P5130, "!PREFIX__"
    find_lex $P5131, "$name"
    unless_null $P5131, vivify_2408
    new $P5131, "Undef"
  vivify_2408:
    concat $P5132, $P5130, $P5131
    $P5133 = $P5129."new"($P5132 :named("value"))
.annotate 'line', 1838
    get_hll_global $P5134, ["PAST"], "Var"
    new $P5135, "String"
    assign $P5135, "!PREFIX__"
    find_lex $P5136, "$name"
    unless_null $P5136, vivify_2409
    new $P5136, "Undef"
  vivify_2409:
    concat $P5137, $P5135, $P5136
    $P5138 = $P5134."new"($P5137 :named("name"), "package" :named("scope"))
    $P5139 = $P5122."new"($P5126, $P5128, $P5133, $P5138, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1830
    $P5121."push"($P5139)
  if_5103_end:
.annotate 'line', 1842
    find_lex $P5140, "$regex"
    unless_null $P5140, vivify_2410
    new $P5140, "Undef"
  vivify_2410:
    find_lex $P5141, "$past"
    unless_null $P5141, vivify_2411
    $P5141 = root_new ['parrot';'Hash']
    store_lex "$past", $P5141
  vivify_2411:
    set $P5141["sink"], $P5140
.annotate 'line', 1843
    find_lex $P5142, "@MODIFIERS"
    unless_null $P5142, vivify_2412
    $P5142 = root_new ['parrot';'ResizablePMCArray']
  vivify_2412:
    $P5143 = $P5142."shift"()
.annotate 'line', 1809
    .return ($P5143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5048"  :anon :subid("516_1303576195.699") :outer("514_1303576195.699")
.annotate 'line', 1800
    $P5050 = root_new ['parrot';'Hash']
    .lex "%h", $P5050
.annotate 'line', 1799
    find_lex $P5051, "%h"
    unless_null $P5051, vivify_2413
    $P5051 = root_new ['parrot';'Hash']
  vivify_2413:
.annotate 'line', 1801
    find_lex $P5053, "$/"
    unless_null $P5053, vivify_2414
    $P5053 = root_new ['parrot';'Hash']
  vivify_2414:
    set $P5054, $P5053["sym"]
    unless_null $P5054, vivify_2415
    new $P5054, "Undef"
  vivify_2415:
    set $S5055, $P5054
    iseq $I5056, $S5055, "token"
    unless $I5056, if_5052_end
    new $P5057, "Integer"
    assign $P5057, 1
    find_lex $P5058, "%h"
    unless_null $P5058, vivify_2416
    $P5058 = root_new ['parrot';'Hash']
    store_lex "%h", $P5058
  vivify_2416:
    set $P5058["r"], $P5057
  if_5052_end:
.annotate 'line', 1802
    find_lex $P5060, "$/"
    unless_null $P5060, vivify_2417
    $P5060 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5061, $P5060["sym"]
    unless_null $P5061, vivify_2418
    new $P5061, "Undef"
  vivify_2418:
    set $S5062, $P5061
    iseq $I5063, $S5062, "rule"
    unless $I5063, if_5059_end
    new $P5064, "Integer"
    assign $P5064, 1
    find_lex $P5065, "%h"
    unless_null $P5065, vivify_2419
    $P5065 = root_new ['parrot';'Hash']
    store_lex "%h", $P5065
  vivify_2419:
    set $P5065["r"], $P5064
    new $P5066, "Integer"
    assign $P5066, 1
    find_lex $P5067, "%h"
    unless_null $P5067, vivify_2420
    $P5067 = root_new ['parrot';'Hash']
    store_lex "%h", $P5067
  vivify_2420:
    set $P5067["s"], $P5066
  if_5059_end:
.annotate 'line', 1803
    find_lex $P5068, "@MODIFIERS"
    unless_null $P5068, vivify_2421
    $P5068 = root_new ['parrot';'ResizablePMCArray']
  vivify_2421:
    find_lex $P5069, "%h"
    unless_null $P5069, vivify_2422
    $P5069 = root_new ['parrot';'Hash']
  vivify_2422:
    $P5068."unshift"($P5069)
.annotate 'line', 1804
    find_lex $P5070, "$name"
    unless_null $P5070, vivify_2423
    new $P5070, "Undef"
  vivify_2423:
    get_hll_global $P5071, ["Regex";"P6Regex"], "Actions"
    get_who $P5072, $P5071
    set $P5072["$REGEXNAME"], $P5070
.annotate 'line', 1805
    find_lex $P5073, "$?PACKAGE"
    get_who $P5074, $P5073
    set $P5075, $P5074["@BLOCK"]
    unless_null $P5075, vivify_2424
    $P5075 = root_new ['parrot';'ResizablePMCArray']
  vivify_2424:
    set $P5076, $P5075[0]
    unless_null $P5076, vivify_2425
    new $P5076, "Undef"
  vivify_2425:
    $P5076."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1806
    find_lex $P5077, "$?PACKAGE"
    get_who $P5078, $P5077
    set $P5079, $P5078["@BLOCK"]
    unless_null $P5079, vivify_2426
    $P5079 = root_new ['parrot';'ResizablePMCArray']
  vivify_2426:
    set $P5080, $P5079[0]
    unless_null $P5080, vivify_2427
    new $P5080, "Undef"
  vivify_2427:
    $P5080."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1807
    new $P5081, "Exception"
    set $P5081['type'], .CONTROL_RETURN
    new $P5082, "Integer"
    assign $P5082, 0
    setattribute $P5081, 'payload', $P5082
    throw $P5081
.annotate 'line', 1799
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5021"  :anon :subid("515_1303576195.699") :outer("514_1303576195.699")
    .param pmc param_5023
.annotate 'line', 1786
    .lex "$_", param_5023
.annotate 'line', 1787
    find_dynamic_lex $P5024, "$*PACKAGE-SETUP"
    unless_null $P5024, vivify_2436
    get_hll_global $P5024, "$PACKAGE-SETUP"
    unless_null $P5024, vivify_2437
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2437:
  vivify_2436:
    get_hll_global $P5025, ["PAST"], "Op"
.annotate 'line', 1789
    get_hll_global $P5026, ["PAST"], "Op"
.annotate 'line', 1791
    get_hll_global $P5027, ["PAST"], "Var"
    $P5028 = $P5027."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5029 = $P5026."new"($P5028, "get_how PP" :named("pirop"))
.annotate 'line', 1793
    get_hll_global $P5030, ["PAST"], "Var"
    $P5031 = $P5030."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1794
    get_hll_global $P5032, ["PAST"], "Val"
    find_lex $P5033, "$_"
    unless_null $P5033, vivify_2438
    new $P5033, "Undef"
  vivify_2438:
    $P5034 = $P5033."name"()
    $P5035 = $P5032."new"($P5034 :named("value"))
.annotate 'line', 1795
    get_hll_global $P5036, ["PAST"], "Val"
    find_lex $P5037, "$_"
    unless_null $P5037, vivify_2439
    new $P5037, "Undef"
  vivify_2439:
    $P5038 = $P5036."new"($P5037 :named("value"))
    $P5039 = $P5025."new"($P5029, $P5031, $P5035, $P5038, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1787
    $P5040 = $P5024."push"($P5039)
.annotate 'line', 1786
    .return ($P5040)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("518_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5149
    .param pmc param_5150
.annotate 'line', 1849
    .lex "self", param_5149
    .lex "$/", param_5150
.annotate 'line', 1850
    new $P5151, "Undef"
    .lex "$past", $P5151
    find_lex $P5154, "$/"
    unless_null $P5154, vivify_2441
    $P5154 = root_new ['parrot';'Hash']
  vivify_2441:
    set $P5155, $P5154["args"]
    unless_null $P5155, vivify_2442
    new $P5155, "Undef"
  vivify_2442:
    if $P5155, if_5153
    get_hll_global $P5160, ["PAST"], "Op"
    find_lex $P5161, "$/"
    unless_null $P5161, vivify_2443
    new $P5161, "Undef"
  vivify_2443:
    $P5162 = $P5160."new"($P5161 :named("node"))
    set $P5152, $P5162
    goto if_5153_end
  if_5153:
    find_lex $P5156, "$/"
    unless_null $P5156, vivify_2444
    $P5156 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P5157, $P5156["args"]
    unless_null $P5157, vivify_2445
    $P5157 = root_new ['parrot';'ResizablePMCArray']
  vivify_2445:
    set $P5158, $P5157[0]
    unless_null $P5158, vivify_2446
    new $P5158, "Undef"
  vivify_2446:
    $P5159 = $P5158."ast"()
    set $P5152, $P5159
  if_5153_end:
    store_lex "$past", $P5152
.annotate 'line', 1851
    find_lex $P5164, "$/"
    unless_null $P5164, vivify_2447
    $P5164 = root_new ['parrot';'Hash']
  vivify_2447:
    set $P5165, $P5164["quote"]
    unless_null $P5165, vivify_2448
    new $P5165, "Undef"
  vivify_2448:
    if $P5165, if_5163
.annotate 'line', 1855
    find_lex $P5172, "$/"
    unless_null $P5172, vivify_2449
    $P5172 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P5173, $P5172["longname"]
    unless_null $P5173, vivify_2450
    new $P5173, "Undef"
  vivify_2450:
    set $S5174, $P5173
    iseq $I5175, $S5174, "HOW"
    if $I5175, if_5171
.annotate 'line', 1858
    find_lex $P5178, "$/"
    unless_null $P5178, vivify_2451
    $P5178 = root_new ['parrot';'Hash']
  vivify_2451:
    set $P5179, $P5178["longname"]
    unless_null $P5179, vivify_2452
    new $P5179, "Undef"
  vivify_2452:
    set $S5180, $P5179
    iseq $I5181, $S5180, "WHAT"
    if $I5181, if_5177
.annotate 'line', 1861
    find_lex $P5184, "$/"
    unless_null $P5184, vivify_2453
    $P5184 = root_new ['parrot';'Hash']
  vivify_2453:
    set $P5185, $P5184["longname"]
    unless_null $P5185, vivify_2454
    new $P5185, "Undef"
  vivify_2454:
    set $S5186, $P5185
    iseq $I5187, $S5186, "WHO"
    if $I5187, if_5183
.annotate 'line', 1865
    find_lex $P5189, "$past"
    unless_null $P5189, vivify_2455
    new $P5189, "Undef"
  vivify_2455:
    find_lex $P5190, "$/"
    unless_null $P5190, vivify_2456
    $P5190 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P5191, $P5190["longname"]
    unless_null $P5191, vivify_2457
    new $P5191, "Undef"
  vivify_2457:
    set $S5192, $P5191
    $P5189."name"($S5192)
.annotate 'line', 1866
    find_lex $P5193, "$past"
    unless_null $P5193, vivify_2458
    new $P5193, "Undef"
  vivify_2458:
    $P5193."pasttype"("callmethod")
.annotate 'line', 1864
    goto if_5183_end
  if_5183:
.annotate 'line', 1862
    find_lex $P5188, "$past"
    unless_null $P5188, vivify_2459
    new $P5188, "Undef"
  vivify_2459:
    $P5188."pirop"("get_who PP")
  if_5183_end:
.annotate 'line', 1861
    goto if_5177_end
  if_5177:
.annotate 'line', 1859
    find_lex $P5182, "$past"
    unless_null $P5182, vivify_2460
    new $P5182, "Undef"
  vivify_2460:
    $P5182."pirop"("get_what PP")
  if_5177_end:
.annotate 'line', 1858
    goto if_5171_end
  if_5171:
.annotate 'line', 1856
    find_lex $P5176, "$past"
    unless_null $P5176, vivify_2461
    new $P5176, "Undef"
  vivify_2461:
    $P5176."pirop"("get_how PP")
  if_5171_end:
.annotate 'line', 1855
    goto if_5163_end
  if_5163:
.annotate 'line', 1852
    find_lex $P5166, "$past"
    unless_null $P5166, vivify_2462
    new $P5166, "Undef"
  vivify_2462:
    find_lex $P5167, "$/"
    unless_null $P5167, vivify_2463
    $P5167 = root_new ['parrot';'Hash']
  vivify_2463:
    set $P5168, $P5167["quote"]
    unless_null $P5168, vivify_2464
    new $P5168, "Undef"
  vivify_2464:
    $P5169 = $P5168."ast"()
    $P5166."name"($P5169)
.annotate 'line', 1853
    find_lex $P5170, "$past"
    unless_null $P5170, vivify_2465
    new $P5170, "Undef"
  vivify_2465:
    $P5170."pasttype"("callmethod")
  if_5163_end:
.annotate 'line', 1868
    find_lex $P5194, "$/"
    find_lex $P5195, "$past"
    unless_null $P5195, vivify_2466
    new $P5195, "Undef"
  vivify_2466:
    $P5196 = $P5194."!make"($P5195)
.annotate 'line', 1849
    .return ($P5196)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("519_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5198
    .param pmc param_5199
.annotate 'line', 1873
    .lex "self", param_5198
    .lex "$/", param_5199
.annotate 'line', 1874
    find_lex $P5200, "$/"
    get_hll_global $P5201, ["PAST"], "Var"
    $P5202 = $P5201."new"("self" :named("name"))
    $P5203 = $P5200."!make"($P5202)
.annotate 'line', 1873
    .return ($P5203)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("520_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5205
    .param pmc param_5206
.annotate 'line', 1877
    .lex "self", param_5205
    .lex "$/", param_5206
.annotate 'line', 1878
    new $P5207, "Undef"
    .lex "$past", $P5207
    find_lex $P5208, "$/"
    unless_null $P5208, vivify_2467
    $P5208 = root_new ['parrot';'Hash']
  vivify_2467:
    set $P5209, $P5208["args"]
    unless_null $P5209, vivify_2468
    new $P5209, "Undef"
  vivify_2468:
    $P5210 = $P5209."ast"()
    store_lex "$past", $P5210
.annotate 'line', 1879
    find_lex $P5211, "$past"
    unless_null $P5211, vivify_2469
    new $P5211, "Undef"
  vivify_2469:
    find_lex $P5212, "$/"
    unless_null $P5212, vivify_2470
    $P5212 = root_new ['parrot';'Hash']
  vivify_2470:
    set $P5213, $P5212["deflongname"]
    unless_null $P5213, vivify_2471
    new $P5213, "Undef"
  vivify_2471:
    set $S5214, $P5213
    $P5211."name"($S5214)
.annotate 'line', 1880
    find_lex $P5215, "$/"
    find_lex $P5216, "$past"
    unless_null $P5216, vivify_2472
    new $P5216, "Undef"
  vivify_2472:
    $P5217 = $P5215."!make"($P5216)
.annotate 'line', 1877
    .return ($P5217)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("521_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5219
    .param pmc param_5220
.annotate 'line', 1883
    .const 'Sub' $P5235 = "522_1303576195.699" 
    capture_lex $P5235
    .lex "self", param_5219
    .lex "$/", param_5220
.annotate 'line', 1885
    new $P5221, "Undef"
    .lex "$var", $P5221
.annotate 'line', 1899
    new $P5222, "Undef"
    .lex "$past", $P5222
.annotate 'line', 1883
    find_lex $P5223, "$var"
    unless_null $P5223, vivify_2473
    new $P5223, "Undef"
  vivify_2473:
.annotate 'line', 1886
    find_lex $P5225, "$/"
    unless_null $P5225, vivify_2474
    $P5225 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P5226, $P5225["name"]
    unless_null $P5226, vivify_2475
    new $P5226, "Undef"
  vivify_2475:
    set $S5227, $P5226
    $P5228 = "is_lexical"($S5227)
    if $P5228, if_5224
.annotate 'line', 1889
    .const 'Sub' $P5235 = "522_1303576195.699" 
    capture_lex $P5235
    $P5235()
    goto if_5224_end
  if_5224:
.annotate 'line', 1887
    get_hll_global $P5229, ["PAST"], "Var"
    find_lex $P5230, "$/"
    unless_null $P5230, vivify_2486
    $P5230 = root_new ['parrot';'Hash']
  vivify_2486:
    set $P5231, $P5230["name"]
    unless_null $P5231, vivify_2487
    new $P5231, "Undef"
  vivify_2487:
    set $S5232, $P5231
    $P5233 = $P5229."new"($S5232 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5233
  if_5224_end:
.annotate 'line', 1899
    find_lex $P5258, "$var"
    unless_null $P5258, vivify_2488
    new $P5258, "Undef"
  vivify_2488:
    store_lex "$past", $P5258
.annotate 'line', 1900
    find_lex $P5260, "$/"
    unless_null $P5260, vivify_2489
    $P5260 = root_new ['parrot';'Hash']
  vivify_2489:
    set $P5261, $P5260["args"]
    unless_null $P5261, vivify_2490
    new $P5261, "Undef"
  vivify_2490:
    unless $P5261, if_5259_end
.annotate 'line', 1901
    find_lex $P5262, "$/"
    unless_null $P5262, vivify_2491
    $P5262 = root_new ['parrot';'Hash']
  vivify_2491:
    set $P5263, $P5262["args"]
    unless_null $P5263, vivify_2492
    $P5263 = root_new ['parrot';'ResizablePMCArray']
  vivify_2492:
    set $P5264, $P5263[0]
    unless_null $P5264, vivify_2493
    new $P5264, "Undef"
  vivify_2493:
    $P5265 = $P5264."ast"()
    store_lex "$past", $P5265
.annotate 'line', 1902
    find_lex $P5266, "$past"
    unless_null $P5266, vivify_2494
    new $P5266, "Undef"
  vivify_2494:
    find_lex $P5267, "$var"
    unless_null $P5267, vivify_2495
    new $P5267, "Undef"
  vivify_2495:
    $P5266."unshift"($P5267)
  if_5259_end:
.annotate 'line', 1904
    find_lex $P5268, "$/"
    find_lex $P5269, "$past"
    unless_null $P5269, vivify_2496
    new $P5269, "Undef"
  vivify_2496:
    $P5270 = $P5268."!make"($P5269)
.annotate 'line', 1883
    .return ($P5270)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5234"  :anon :subid("522_1303576195.699") :outer("521_1303576195.699")
.annotate 'line', 1890
    $P5236 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5236
.annotate 'line', 1891
    new $P5237, "Undef"
    .lex "$name", $P5237
.annotate 'line', 1890
    find_lex $P5238, "$/"
    unless_null $P5238, vivify_2476
    $P5238 = root_new ['parrot';'Hash']
  vivify_2476:
    set $P5239, $P5238["name"]
    unless_null $P5239, vivify_2477
    $P5239 = root_new ['parrot';'Hash']
  vivify_2477:
    set $P5240, $P5239["identifier"]
    unless_null $P5240, vivify_2478
    new $P5240, "Undef"
  vivify_2478:
    clone $P5241, $P5240
    store_lex "@ns", $P5241
.annotate 'line', 1891
    find_lex $P5242, "@ns"
    unless_null $P5242, vivify_2479
    $P5242 = root_new ['parrot';'ResizablePMCArray']
  vivify_2479:
    $P5243 = $P5242."pop"()
    store_lex "$name", $P5243
.annotate 'line', 1892
    find_lex $P5247, "@ns"
    unless_null $P5247, vivify_2480
    $P5247 = root_new ['parrot';'ResizablePMCArray']
  vivify_2480:
    if $P5247, if_5246
    set $P5245, $P5247
    goto if_5246_end
  if_5246:
    find_lex $P5248, "@ns"
    unless_null $P5248, vivify_2481
    $P5248 = root_new ['parrot';'ResizablePMCArray']
  vivify_2481:
    set $P5249, $P5248[0]
    unless_null $P5249, vivify_2482
    new $P5249, "Undef"
  vivify_2482:
    set $S5250, $P5249
    iseq $I5251, $S5250, "GLOBAL"
    new $P5245, 'Integer'
    set $P5245, $I5251
  if_5246_end:
    unless $P5245, if_5244_end
    find_lex $P5252, "@ns"
    unless_null $P5252, vivify_2483
    $P5252 = root_new ['parrot';'ResizablePMCArray']
  vivify_2483:
    $P5252."shift"()
  if_5244_end:
.annotate 'line', 1893
    get_hll_global $P5253, ["PAST"], "Var"
    find_lex $P5254, "$name"
    unless_null $P5254, vivify_2484
    new $P5254, "Undef"
  vivify_2484:
    set $S5255, $P5254
    find_lex $P5256, "@ns"
    unless_null $P5256, vivify_2485
    $P5256 = root_new ['parrot';'ResizablePMCArray']
  vivify_2485:
    $P5257 = $P5253."new"($S5255 :named("name"), $P5256 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P5257
.annotate 'line', 1889
    .return ($P5257)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("523_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5272
    .param pmc param_5273
.annotate 'line', 1907
    .lex "self", param_5272
    .lex "$/", param_5273
.annotate 'line', 1908
    new $P5274, "Undef"
    .lex "$past", $P5274
.annotate 'line', 1909
    new $P5275, "Undef"
    .lex "$pirop", $P5275
.annotate 'line', 1908
    find_lex $P5278, "$/"
    unless_null $P5278, vivify_2497
    $P5278 = root_new ['parrot';'Hash']
  vivify_2497:
    set $P5279, $P5278["args"]
    unless_null $P5279, vivify_2498
    new $P5279, "Undef"
  vivify_2498:
    if $P5279, if_5277
    get_hll_global $P5284, ["PAST"], "Op"
    find_lex $P5285, "$/"
    unless_null $P5285, vivify_2499
    new $P5285, "Undef"
  vivify_2499:
    $P5286 = $P5284."new"($P5285 :named("node"))
    set $P5276, $P5286
    goto if_5277_end
  if_5277:
    find_lex $P5280, "$/"
    unless_null $P5280, vivify_2500
    $P5280 = root_new ['parrot';'Hash']
  vivify_2500:
    set $P5281, $P5280["args"]
    unless_null $P5281, vivify_2501
    $P5281 = root_new ['parrot';'ResizablePMCArray']
  vivify_2501:
    set $P5282, $P5281[0]
    unless_null $P5282, vivify_2502
    new $P5282, "Undef"
  vivify_2502:
    $P5283 = $P5282."ast"()
    set $P5276, $P5283
  if_5277_end:
    store_lex "$past", $P5276
.annotate 'line', 1909
    find_lex $P5287, "$/"
    unless_null $P5287, vivify_2503
    $P5287 = root_new ['parrot';'Hash']
  vivify_2503:
    set $P5288, $P5287["op"]
    unless_null $P5288, vivify_2504
    new $P5288, "Undef"
  vivify_2504:
    set $S5289, $P5288
    new $P5290, 'String'
    set $P5290, $S5289
    store_lex "$pirop", $P5290
.annotate 'line', 1910
    find_lex $P5291, "$pirop"
    unless_null $P5291, vivify_2505
    new $P5291, "Undef"
  vivify_2505:
    set $S5292, $P5291
    split $P5293, "__", $S5292
    join $S5294, " ", $P5293
    new $P5295, 'String'
    set $P5295, $S5294
    store_lex "$pirop", $P5295
.annotate 'line', 1911
    find_lex $P5296, "$past"
    unless_null $P5296, vivify_2506
    new $P5296, "Undef"
  vivify_2506:
    find_lex $P5297, "$pirop"
    unless_null $P5297, vivify_2507
    new $P5297, "Undef"
  vivify_2507:
    $P5296."pirop"($P5297)
.annotate 'line', 1912
    find_lex $P5298, "$past"
    unless_null $P5298, vivify_2508
    new $P5298, "Undef"
  vivify_2508:
    $P5298."pasttype"("pirop")
.annotate 'line', 1913
    find_lex $P5299, "$/"
    find_lex $P5300, "$past"
    unless_null $P5300, vivify_2509
    new $P5300, "Undef"
  vivify_2509:
    $P5301 = $P5299."!make"($P5300)
.annotate 'line', 1907
    .return ($P5301)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("524_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5303
    .param pmc param_5304
.annotate 'line', 1916
    .lex "self", param_5303
    .lex "$/", param_5304
.annotate 'line', 1917
    find_lex $P5305, "$/"
    get_hll_global $P5306, ["PAST"], "Op"
    $P5307 = $P5306."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5308 = $P5305."!make"($P5307)
.annotate 'line', 1916
    .return ($P5308)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("525_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5310
    .param pmc param_5311
.annotate 'line', 1922
    .lex "self", param_5310
    .lex "$/", param_5311
    find_lex $P5312, "$/"
    find_lex $P5313, "$/"
    unless_null $P5313, vivify_2510
    $P5313 = root_new ['parrot';'Hash']
  vivify_2510:
    set $P5314, $P5313["arglist"]
    unless_null $P5314, vivify_2511
    new $P5314, "Undef"
  vivify_2511:
    $P5315 = $P5314."ast"()
    $P5316 = $P5312."!make"($P5315)
    .return ($P5316)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("526_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5318
    .param pmc param_5319
.annotate 'line', 1924
    .const 'Sub' $P5330 = "527_1303576195.699" 
    capture_lex $P5330
    .lex "self", param_5318
    .lex "$/", param_5319
.annotate 'line', 1925
    new $P5320, "Undef"
    .lex "$past", $P5320
.annotate 'line', 1933
    new $P5321, "Undef"
    .lex "$i", $P5321
.annotate 'line', 1934
    new $P5322, "Undef"
    .lex "$n", $P5322
.annotate 'line', 1925
    get_hll_global $P5323, ["PAST"], "Op"
    find_lex $P5324, "$/"
    unless_null $P5324, vivify_2512
    new $P5324, "Undef"
  vivify_2512:
    $P5325 = $P5323."new"("call" :named("pasttype"), $P5324 :named("node"))
    store_lex "$past", $P5325
.annotate 'line', 1926
    find_lex $P5327, "$/"
    unless_null $P5327, vivify_2513
    $P5327 = root_new ['parrot';'Hash']
  vivify_2513:
    set $P5328, $P5327["EXPR"]
    unless_null $P5328, vivify_2514
    new $P5328, "Undef"
  vivify_2514:
    unless $P5328, if_5326_end
    .const 'Sub' $P5330 = "527_1303576195.699" 
    capture_lex $P5330
    $P5330()
  if_5326_end:
.annotate 'line', 1933
    new $P5362, "Integer"
    assign $P5362, 0
    store_lex "$i", $P5362
.annotate 'line', 1934
    find_lex $P5363, "$past"
    unless_null $P5363, vivify_2525
    new $P5363, "Undef"
  vivify_2525:
    $P5364 = $P5363."list"()
    set $N5365, $P5364
    new $P5366, 'Float'
    set $P5366, $N5365
    store_lex "$n", $P5366
.annotate 'line', 1935
    new $P5414, 'ExceptionHandler'
    set_label $P5414, loop5413_handler
    $P5414."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5414
  loop5413_test:
    find_lex $P5367, "$i"
    unless_null $P5367, vivify_2526
    new $P5367, "Undef"
  vivify_2526:
    set $N5368, $P5367
    find_lex $P5369, "$n"
    unless_null $P5369, vivify_2527
    new $P5369, "Undef"
  vivify_2527:
    set $N5370, $P5369
    islt $I5371, $N5368, $N5370
    unless $I5371, loop5413_done
  loop5413_redo:
.annotate 'line', 1936
    find_lex $P5373, "$i"
    unless_null $P5373, vivify_2528
    new $P5373, "Undef"
  vivify_2528:
    set $I5374, $P5373
    find_lex $P5375, "$past"
    unless_null $P5375, vivify_2529
    $P5375 = root_new ['parrot';'ResizablePMCArray']
  vivify_2529:
    set $P5376, $P5375[$I5374]
    unless_null $P5376, vivify_2530
    new $P5376, "Undef"
  vivify_2530:
    $S5377 = $P5376."name"()
    iseq $I5378, $S5377, "&prefix:<|>"
    unless $I5378, if_5372_end
.annotate 'line', 1937
    find_lex $P5379, "$i"
    unless_null $P5379, vivify_2531
    new $P5379, "Undef"
  vivify_2531:
    set $I5380, $P5379
    find_lex $P5381, "$past"
    unless_null $P5381, vivify_2532
    $P5381 = root_new ['parrot';'ResizablePMCArray']
  vivify_2532:
    set $P5382, $P5381[$I5380]
    unless_null $P5382, vivify_2533
    $P5382 = root_new ['parrot';'ResizablePMCArray']
  vivify_2533:
    set $P5383, $P5382[0]
    unless_null $P5383, vivify_2534
    new $P5383, "Undef"
  vivify_2534:
    find_lex $P5384, "$i"
    unless_null $P5384, vivify_2535
    new $P5384, "Undef"
  vivify_2535:
    set $I5385, $P5384
    find_lex $P5386, "$past"
    unless_null $P5386, vivify_2536
    $P5386 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5386
  vivify_2536:
    set $P5386[$I5385], $P5383
.annotate 'line', 1938
    find_lex $P5387, "$i"
    unless_null $P5387, vivify_2537
    new $P5387, "Undef"
  vivify_2537:
    set $I5388, $P5387
    find_lex $P5389, "$past"
    unless_null $P5389, vivify_2538
    $P5389 = root_new ['parrot';'ResizablePMCArray']
  vivify_2538:
    set $P5390, $P5389[$I5388]
    unless_null $P5390, vivify_2539
    new $P5390, "Undef"
  vivify_2539:
    $P5390."flat"(1)
.annotate 'line', 1939
    find_lex $P5394, "$i"
    unless_null $P5394, vivify_2540
    new $P5394, "Undef"
  vivify_2540:
    set $I5395, $P5394
    find_lex $P5396, "$past"
    unless_null $P5396, vivify_2541
    $P5396 = root_new ['parrot';'ResizablePMCArray']
  vivify_2541:
    set $P5397, $P5396[$I5395]
    unless_null $P5397, vivify_2542
    new $P5397, "Undef"
  vivify_2542:
    get_hll_global $P5398, ["PAST"], "Val"
    $P5399 = $P5397."isa"($P5398)
    if $P5399, if_5393
    set $P5392, $P5399
    goto if_5393_end
  if_5393:
.annotate 'line', 1940
    find_lex $P5400, "$i"
    unless_null $P5400, vivify_2543
    new $P5400, "Undef"
  vivify_2543:
    set $I5401, $P5400
    find_lex $P5402, "$past"
    unless_null $P5402, vivify_2544
    $P5402 = root_new ['parrot';'ResizablePMCArray']
  vivify_2544:
    set $P5403, $P5402[$I5401]
    unless_null $P5403, vivify_2545
    new $P5403, "Undef"
  vivify_2545:
    $S5404 = $P5403."name"()
    substr $S5405, $S5404, 0, 1
    iseq $I5406, $S5405, "%"
    new $P5392, 'Integer'
    set $P5392, $I5406
  if_5393_end:
    unless $P5392, if_5391_end
.annotate 'line', 1941
    find_lex $P5407, "$i"
    unless_null $P5407, vivify_2546
    new $P5407, "Undef"
  vivify_2546:
    set $I5408, $P5407
    find_lex $P5409, "$past"
    unless_null $P5409, vivify_2547
    $P5409 = root_new ['parrot';'ResizablePMCArray']
  vivify_2547:
    set $P5410, $P5409[$I5408]
    unless_null $P5410, vivify_2548
    new $P5410, "Undef"
  vivify_2548:
    $P5410."named"(1)
  if_5391_end:
  if_5372_end:
.annotate 'line', 1936
    find_lex $P5411, "$i"
    unless_null $P5411, vivify_2549
    new $P5411, "Undef"
  vivify_2549:
    clone $P5412, $P5411
    inc $P5411
  loop5413_next:
.annotate 'line', 1935
    goto loop5413_test
  loop5413_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5415, exception, 'type'
    eq $P5415, .CONTROL_LOOP_NEXT, loop5413_next
    eq $P5415, .CONTROL_LOOP_REDO, loop5413_redo
  loop5413_done:
    pop_eh 
.annotate 'line', 1946
    find_lex $P5416, "$/"
    find_lex $P5417, "$past"
    unless_null $P5417, vivify_2550
    new $P5417, "Undef"
  vivify_2550:
    $P5418 = $P5416."!make"($P5417)
.annotate 'line', 1924
    .return ($P5418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5329"  :anon :subid("527_1303576195.699") :outer("526_1303576195.699")
.annotate 'line', 1926
    .const 'Sub' $P5351 = "528_1303576195.699" 
    capture_lex $P5351
.annotate 'line', 1927
    new $P5331, "Undef"
    .lex "$expr", $P5331
    find_lex $P5332, "$/"
    unless_null $P5332, vivify_2515
    $P5332 = root_new ['parrot';'Hash']
  vivify_2515:
    set $P5333, $P5332["EXPR"]
    unless_null $P5333, vivify_2516
    new $P5333, "Undef"
  vivify_2516:
    $P5334 = $P5333."ast"()
    store_lex "$expr", $P5334
.annotate 'line', 1928
    find_lex $P5339, "$expr"
    unless_null $P5339, vivify_2517
    new $P5339, "Undef"
  vivify_2517:
    $S5340 = $P5339."name"()
    iseq $I5341, $S5340, "&infix:<,>"
    if $I5341, if_5338
    new $P5337, 'Integer'
    set $P5337, $I5341
    goto if_5338_end
  if_5338:
    find_lex $P5342, "$expr"
    unless_null $P5342, vivify_2518
    new $P5342, "Undef"
  vivify_2518:
    $P5343 = $P5342."named"()
    isfalse $I5344, $P5343
    new $P5337, 'Integer'
    set $P5337, $I5344
  if_5338_end:
    if $P5337, if_5336
.annotate 'line', 1931
    find_lex $P5359, "$past"
    unless_null $P5359, vivify_2519
    new $P5359, "Undef"
  vivify_2519:
    find_lex $P5360, "$expr"
    unless_null $P5360, vivify_2520
    new $P5360, "Undef"
  vivify_2520:
    $P5361 = $P5359."push"($P5360)
    set $P5335, $P5361
.annotate 'line', 1928
    goto if_5336_end
  if_5336:
.annotate 'line', 1929
    find_lex $P5346, "$expr"
    unless_null $P5346, vivify_2521
    new $P5346, "Undef"
  vivify_2521:
    $P5347 = $P5346."list"()
    defined $I5348, $P5347
    unless $I5348, for_undef_2522
    iter $P5345, $P5347
    new $P5357, 'ExceptionHandler'
    set_label $P5357, loop5356_handler
    $P5357."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5357
  loop5356_test:
    unless $P5345, loop5356_done
    shift $P5349, $P5345
  loop5356_redo:
    .const 'Sub' $P5351 = "528_1303576195.699" 
    capture_lex $P5351
    $P5351($P5349)
  loop5356_next:
    goto loop5356_test
  loop5356_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5358, exception, 'type'
    eq $P5358, .CONTROL_LOOP_NEXT, loop5356_next
    eq $P5358, .CONTROL_LOOP_REDO, loop5356_redo
  loop5356_done:
    pop_eh 
  for_undef_2522:
.annotate 'line', 1928
    set $P5335, $P5345
  if_5336_end:
.annotate 'line', 1926
    .return ($P5335)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5350"  :anon :subid("528_1303576195.699") :outer("527_1303576195.699")
    .param pmc param_5352
.annotate 'line', 1929
    .lex "$_", param_5352
    find_lex $P5353, "$past"
    unless_null $P5353, vivify_2523
    new $P5353, "Undef"
  vivify_2523:
    find_lex $P5354, "$_"
    unless_null $P5354, vivify_2524
    new $P5354, "Undef"
  vivify_2524:
    $P5355 = $P5353."push"($P5354)
    .return ($P5355)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("529_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5420
    .param pmc param_5421
.annotate 'line', 1949
    .lex "self", param_5420
    .lex "$/", param_5421
    find_lex $P5422, "$/"
    find_lex $P5423, "$/"
    unless_null $P5423, vivify_2551
    $P5423 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P5424, $P5423["multi_declarator"]
    unless_null $P5424, vivify_2552
    new $P5424, "Undef"
  vivify_2552:
    $P5425 = $P5424."ast"()
    $P5426 = $P5422."!make"($P5425)
    .return ($P5426)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("530_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5428
    .param pmc param_5429
.annotate 'line', 1951
    .lex "self", param_5428
    .lex "$/", param_5429
    find_lex $P5430, "$/"
    find_lex $P5431, "$/"
    unless_null $P5431, vivify_2553
    $P5431 = root_new ['parrot';'Hash']
  vivify_2553:
    set $P5432, $P5431["value"]
    unless_null $P5432, vivify_2554
    new $P5432, "Undef"
  vivify_2554:
    $P5433 = $P5432."ast"()
    $P5434 = $P5430."!make"($P5433)
    .return ($P5434)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("531_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5436
    .param pmc param_5437
.annotate 'line', 1953
    .lex "self", param_5436
    .lex "$/", param_5437
.annotate 'line', 1954
    find_lex $P5438, "$/"
.annotate 'line', 1955
    find_lex $P5441, "$/"
    unless_null $P5441, vivify_2555
    $P5441 = root_new ['parrot';'Hash']
  vivify_2555:
    set $P5442, $P5441["EXPR"]
    unless_null $P5442, vivify_2556
    new $P5442, "Undef"
  vivify_2556:
    if $P5442, if_5440
.annotate 'line', 1956
    get_hll_global $P5447, ["PAST"], "Op"
    find_lex $P5448, "$/"
    unless_null $P5448, vivify_2557
    new $P5448, "Undef"
  vivify_2557:
    $P5449 = $P5447."new"("list" :named("pasttype"), $P5448 :named("node"))
    set $P5439, $P5449
.annotate 'line', 1955
    goto if_5440_end
  if_5440:
    find_lex $P5443, "$/"
    unless_null $P5443, vivify_2558
    $P5443 = root_new ['parrot';'Hash']
  vivify_2558:
    set $P5444, $P5443["EXPR"]
    unless_null $P5444, vivify_2559
    $P5444 = root_new ['parrot';'ResizablePMCArray']
  vivify_2559:
    set $P5445, $P5444[0]
    unless_null $P5445, vivify_2560
    new $P5445, "Undef"
  vivify_2560:
    $P5446 = $P5445."ast"()
    set $P5439, $P5446
  if_5440_end:
    $P5450 = $P5438."!make"($P5439)
.annotate 'line', 1953
    .return ($P5450)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("532_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5452
    .param pmc param_5453
.annotate 'line', 1959
    .lex "self", param_5452
    .lex "$/", param_5453
.annotate 'line', 1960
    new $P5454, "Undef"
    .lex "$past", $P5454
.annotate 'line', 1959
    find_lex $P5455, "$past"
    unless_null $P5455, vivify_2561
    new $P5455, "Undef"
  vivify_2561:
.annotate 'line', 1961
    find_lex $P5457, "$/"
    unless_null $P5457, vivify_2562
    $P5457 = root_new ['parrot';'Hash']
  vivify_2562:
    set $P5458, $P5457["EXPR"]
    unless_null $P5458, vivify_2563
    new $P5458, "Undef"
  vivify_2563:
    if $P5458, if_5456
.annotate 'line', 1968
    get_hll_global $P5470, ["PAST"], "Op"
    $P5471 = $P5470."new"("list" :named("pasttype"))
    store_lex "$past", $P5471
.annotate 'line', 1967
    goto if_5456_end
  if_5456:
.annotate 'line', 1962
    find_lex $P5459, "$/"
    unless_null $P5459, vivify_2564
    $P5459 = root_new ['parrot';'Hash']
  vivify_2564:
    set $P5460, $P5459["EXPR"]
    unless_null $P5460, vivify_2565
    $P5460 = root_new ['parrot';'ResizablePMCArray']
  vivify_2565:
    set $P5461, $P5460[0]
    unless_null $P5461, vivify_2566
    new $P5461, "Undef"
  vivify_2566:
    $P5462 = $P5461."ast"()
    store_lex "$past", $P5462
.annotate 'line', 1963
    find_lex $P5464, "$past"
    unless_null $P5464, vivify_2567
    new $P5464, "Undef"
  vivify_2567:
    $S5465 = $P5464."name"()
    isne $I5466, $S5465, "&infix:<,>"
    unless $I5466, if_5463_end
.annotate 'line', 1964
    get_hll_global $P5467, ["PAST"], "Op"
    find_lex $P5468, "$past"
    unless_null $P5468, vivify_2568
    new $P5468, "Undef"
  vivify_2568:
    $P5469 = $P5467."new"($P5468, "list" :named("pasttype"))
    store_lex "$past", $P5469
  if_5463_end:
  if_5456_end:
.annotate 'line', 1970
    find_lex $P5472, "$past"
    unless_null $P5472, vivify_2569
    new $P5472, "Undef"
  vivify_2569:
    $P5472."name"("&circumfix:<[ ]>")
.annotate 'line', 1971
    find_lex $P5473, "$/"
    find_lex $P5474, "$past"
    unless_null $P5474, vivify_2570
    new $P5474, "Undef"
  vivify_2570:
    $P5475 = $P5473."!make"($P5474)
.annotate 'line', 1959
    .return ($P5475)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("533_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5477
    .param pmc param_5478
.annotate 'line', 1974
    .lex "self", param_5477
    .lex "$/", param_5478
    find_lex $P5479, "$/"
    find_lex $P5480, "$/"
    unless_null $P5480, vivify_2571
    $P5480 = root_new ['parrot';'Hash']
  vivify_2571:
    set $P5481, $P5480["quote_EXPR"]
    unless_null $P5481, vivify_2572
    new $P5481, "Undef"
  vivify_2572:
    $P5482 = $P5481."ast"()
    $P5483 = $P5479."!make"($P5482)
    .return ($P5483)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("534_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5485
    .param pmc param_5486
.annotate 'line', 1975
    .lex "self", param_5485
    .lex "$/", param_5486
    find_lex $P5487, "$/"
    find_lex $P5488, "$/"
    unless_null $P5488, vivify_2573
    $P5488 = root_new ['parrot';'Hash']
  vivify_2573:
    set $P5489, $P5488["quote_EXPR"]
    unless_null $P5489, vivify_2574
    new $P5489, "Undef"
  vivify_2574:
    $P5490 = $P5489."ast"()
    $P5491 = $P5487."!make"($P5490)
    .return ($P5491)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("535_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5493
    .param pmc param_5494
.annotate 'line', 1977
    .const 'Sub' $P5505 = "536_1303576195.699" 
    capture_lex $P5505
    .lex "self", param_5493
    .lex "$/", param_5494
.annotate 'line', 1978
    find_lex $P5497, "$/"
    unless_null $P5497, vivify_2575
    $P5497 = root_new ['parrot';'Hash']
  vivify_2575:
    set $P5498, $P5497["pblock"]
    unless_null $P5498, vivify_2576
    $P5498 = root_new ['parrot';'Hash']
  vivify_2576:
    set $P5499, $P5498["blockoid"]
    unless_null $P5499, vivify_2577
    $P5499 = root_new ['parrot';'Hash']
  vivify_2577:
    set $P5500, $P5499["statementlist"]
    unless_null $P5500, vivify_2578
    $P5500 = root_new ['parrot';'Hash']
  vivify_2578:
    set $P5501, $P5500["statement"]
    unless_null $P5501, vivify_2579
    new $P5501, "Undef"
  vivify_2579:
    set $N5502, $P5501
    isgt $I5503, $N5502, 0.0
    if $I5503, if_5496
.annotate 'line', 1983
    find_lex $P5518, "$/"
    unless_null $P5518, vivify_2580
    $P5518 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5519, $P5518["pblock"]
    unless_null $P5519, vivify_2581
    $P5519 = root_new ['parrot';'Hash']
  vivify_2581:
    set $P5520, $P5519["blockoid"]
    unless_null $P5520, vivify_2582
    $P5520 = root_new ['parrot';'Hash']
  vivify_2582:
    set $P5521, $P5520["you_are_here"]
    unless_null $P5521, vivify_2583
    new $P5521, "Undef"
  vivify_2583:
    if $P5521, if_5517
.annotate 'line', 1987
    find_lex $P5527, "$/"
    $P5528 = "vivitype"("%")
    $P5529 = $P5527."!make"($P5528)
.annotate 'line', 1986
    set $P5516, $P5529
.annotate 'line', 1983
    goto if_5517_end
  if_5517:
.annotate 'line', 1984
    find_lex $P5522, "$/"
    find_lex $P5523, "$/"
    unless_null $P5523, vivify_2584
    $P5523 = root_new ['parrot';'Hash']
  vivify_2584:
    set $P5524, $P5523["pblock"]
    unless_null $P5524, vivify_2585
    new $P5524, "Undef"
  vivify_2585:
    $P5525 = $P5524."ast"()
    $P5526 = $P5522."!make"($P5525)
.annotate 'line', 1983
    set $P5516, $P5526
  if_5517_end:
    set $P5495, $P5516
.annotate 'line', 1978
    goto if_5496_end
  if_5496:
    .const 'Sub' $P5505 = "536_1303576195.699" 
    capture_lex $P5505
    $P5515 = $P5505()
    set $P5495, $P5515
  if_5496_end:
.annotate 'line', 1977
    .return ($P5495)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5504"  :anon :subid("536_1303576195.699") :outer("535_1303576195.699")
.annotate 'line', 1979
    new $P5506, "Undef"
    .lex "$past", $P5506
    find_lex $P5507, "$/"
    unless_null $P5507, vivify_2586
    $P5507 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P5508, $P5507["pblock"]
    unless_null $P5508, vivify_2587
    new $P5508, "Undef"
  vivify_2587:
    $P5509 = $P5508."ast"()
    store_lex "$past", $P5509
.annotate 'line', 1980
    new $P5510, "Integer"
    assign $P5510, 1
    find_lex $P5511, "$past"
    unless_null $P5511, vivify_2588
    $P5511 = root_new ['parrot';'Hash']
    store_lex "$past", $P5511
  vivify_2588:
    set $P5511["bareblock"], $P5510
.annotate 'line', 1981
    find_dynamic_lex $P5512, "$/"
    find_lex $P5513, "$past"
    unless_null $P5513, vivify_2589
    new $P5513, "Undef"
  vivify_2589:
    $P5514 = $P5512."!make"($P5513)
.annotate 'line', 1978
    .return ($P5514)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("537_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5531
    .param pmc param_5532
.annotate 'line', 1991
    .lex "self", param_5531
    .lex "$/", param_5532
.annotate 'line', 1992
    new $P5533, "Undef"
    .lex "$name", $P5533
    find_lex $P5536, "$/"
    unless_null $P5536, vivify_2590
    $P5536 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5537, $P5536["sigil"]
    unless_null $P5537, vivify_2591
    new $P5537, "Undef"
  vivify_2591:
    set $S5538, $P5537
    iseq $I5539, $S5538, "@"
    if $I5539, if_5535
.annotate 'line', 1993
    find_lex $P5543, "$/"
    unless_null $P5543, vivify_2592
    $P5543 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P5544, $P5543["sigil"]
    unless_null $P5544, vivify_2593
    new $P5544, "Undef"
  vivify_2593:
    set $S5545, $P5544
    iseq $I5546, $S5545, "%"
    if $I5546, if_5542
    new $P5548, "String"
    assign $P5548, "item"
    set $P5541, $P5548
    goto if_5542_end
  if_5542:
    new $P5547, "String"
    assign $P5547, "hash"
    set $P5541, $P5547
  if_5542_end:
    set $P5534, $P5541
.annotate 'line', 1992
    goto if_5535_end
  if_5535:
    new $P5540, "String"
    assign $P5540, "list"
    set $P5534, $P5540
  if_5535_end:
    store_lex "$name", $P5534
.annotate 'line', 1995
    find_lex $P5549, "$/"
    get_hll_global $P5550, ["PAST"], "Op"
    find_lex $P5551, "$name"
    unless_null $P5551, vivify_2594
    new $P5551, "Undef"
  vivify_2594:
    find_lex $P5552, "$/"
    unless_null $P5552, vivify_2595
    $P5552 = root_new ['parrot';'Hash']
  vivify_2595:
    set $P5553, $P5552["semilist"]
    unless_null $P5553, vivify_2596
    new $P5553, "Undef"
  vivify_2596:
    $P5554 = $P5553."ast"()
    $P5555 = $P5550."new"($P5554, "callmethod" :named("pasttype"), $P5551 :named("name"))
    $P5556 = $P5549."!make"($P5555)
.annotate 'line', 1991
    .return ($P5556)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("538_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5558
    .param pmc param_5559
.annotate 'line', 1998
    .lex "self", param_5558
    .lex "$/", param_5559
    find_lex $P5560, "$/"
    find_lex $P5561, "$/"
    unless_null $P5561, vivify_2597
    $P5561 = root_new ['parrot';'Hash']
  vivify_2597:
    set $P5562, $P5561["statement"]
    unless_null $P5562, vivify_2598
    new $P5562, "Undef"
  vivify_2598:
    $P5563 = $P5562."ast"()
    $P5564 = $P5560."!make"($P5563)
    .return ($P5564)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("539_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5566
    .param pmc param_5567
.annotate 'line', 2000
    .lex "self", param_5566
    .lex "$/", param_5567
.annotate 'line', 2001
    find_lex $P5568, "$/"
    get_hll_global $P5569, ["PAST"], "Var"
    find_lex $P5570, "$/"
    unless_null $P5570, vivify_2599
    $P5570 = root_new ['parrot';'Hash']
  vivify_2599:
    set $P5571, $P5570["EXPR"]
    unless_null $P5571, vivify_2600
    new $P5571, "Undef"
  vivify_2600:
    $P5572 = $P5571."ast"()
.annotate 'line', 2003
    $P5573 = "vivitype"("@")
    $P5574 = $P5569."new"($P5572, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5573 :named("vivibase"))
.annotate 'line', 2001
    $P5575 = $P5568."!make"($P5574)
.annotate 'line', 2000
    .return ($P5575)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("540_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5577
    .param pmc param_5578
.annotate 'line', 2006
    .lex "self", param_5577
    .lex "$/", param_5578
.annotate 'line', 2007
    find_lex $P5579, "$/"
    get_hll_global $P5580, ["PAST"], "Var"
    find_lex $P5581, "$/"
    unless_null $P5581, vivify_2601
    $P5581 = root_new ['parrot';'Hash']
  vivify_2601:
    set $P5582, $P5581["EXPR"]
    unless_null $P5582, vivify_2602
    new $P5582, "Undef"
  vivify_2602:
    $P5583 = $P5582."ast"()
.annotate 'line', 2009
    $P5584 = "vivitype"("%")
    $P5585 = $P5580."new"($P5583, "keyed" :named("scope"), "Undef" :named("viviself"), $P5584 :named("vivibase"))
.annotate 'line', 2007
    $P5586 = $P5579."!make"($P5585)
.annotate 'line', 2006
    .return ($P5586)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("541_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5588
    .param pmc param_5589
.annotate 'line', 2012
    .lex "self", param_5588
    .lex "$/", param_5589
.annotate 'line', 2013
    find_lex $P5590, "$/"
    get_hll_global $P5591, ["PAST"], "Var"
    find_lex $P5592, "$/"
    unless_null $P5592, vivify_2603
    $P5592 = root_new ['parrot';'Hash']
  vivify_2603:
    set $P5593, $P5592["quote_EXPR"]
    unless_null $P5593, vivify_2604
    new $P5593, "Undef"
  vivify_2604:
    $P5594 = $P5593."ast"()
.annotate 'line', 2015
    $P5595 = "vivitype"("%")
    $P5596 = $P5591."new"($P5594, "keyed" :named("scope"), "Undef" :named("viviself"), $P5595 :named("vivibase"))
.annotate 'line', 2013
    $P5597 = $P5590."!make"($P5596)
.annotate 'line', 2012
    .return ($P5597)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("542_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5599
    .param pmc param_5600
.annotate 'line', 2018
    .lex "self", param_5599
    .lex "$/", param_5600
.annotate 'line', 2019
    find_lex $P5601, "$/"
    find_lex $P5602, "$/"
    unless_null $P5602, vivify_2605
    $P5602 = root_new ['parrot';'Hash']
  vivify_2605:
    set $P5603, $P5602["arglist"]
    unless_null $P5603, vivify_2606
    new $P5603, "Undef"
  vivify_2606:
    $P5604 = $P5603."ast"()
    $P5605 = $P5601."!make"($P5604)
.annotate 'line', 2018
    .return ($P5605)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("543_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5607
    .param pmc param_5608
.annotate 'line', 2022
    .lex "self", param_5607
    .lex "$/", param_5608
.annotate 'line', 2023
    find_lex $P5609, "$/"
    find_lex $P5612, "$/"
    unless_null $P5612, vivify_2607
    $P5612 = root_new ['parrot';'Hash']
  vivify_2607:
    set $P5613, $P5612["quote"]
    unless_null $P5613, vivify_2608
    new $P5613, "Undef"
  vivify_2608:
    if $P5613, if_5611
    find_lex $P5617, "$/"
    unless_null $P5617, vivify_2609
    $P5617 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5618, $P5617["number"]
    unless_null $P5618, vivify_2610
    new $P5618, "Undef"
  vivify_2610:
    $P5619 = $P5618."ast"()
    set $P5610, $P5619
    goto if_5611_end
  if_5611:
    find_lex $P5614, "$/"
    unless_null $P5614, vivify_2611
    $P5614 = root_new ['parrot';'Hash']
  vivify_2611:
    set $P5615, $P5614["quote"]
    unless_null $P5615, vivify_2612
    new $P5615, "Undef"
  vivify_2612:
    $P5616 = $P5615."ast"()
    set $P5610, $P5616
  if_5611_end:
    $P5620 = $P5609."!make"($P5610)
.annotate 'line', 2022
    .return ($P5620)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("544_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5622
    .param pmc param_5623
.annotate 'line', 2026
    .lex "self", param_5622
    .lex "$/", param_5623
.annotate 'line', 2027
    new $P5624, "Undef"
    .lex "$value", $P5624
    find_lex $P5627, "$/"
    unless_null $P5627, vivify_2613
    $P5627 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5628, $P5627["dec_number"]
    unless_null $P5628, vivify_2614
    new $P5628, "Undef"
  vivify_2614:
    if $P5628, if_5626
    find_lex $P5632, "$/"
    unless_null $P5632, vivify_2615
    $P5632 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P5633, $P5632["integer"]
    unless_null $P5633, vivify_2616
    new $P5633, "Undef"
  vivify_2616:
    $P5634 = $P5633."ast"()
    set $P5625, $P5634
    goto if_5626_end
  if_5626:
    find_lex $P5629, "$/"
    unless_null $P5629, vivify_2617
    $P5629 = root_new ['parrot';'Hash']
  vivify_2617:
    set $P5630, $P5629["dec_number"]
    unless_null $P5630, vivify_2618
    new $P5630, "Undef"
  vivify_2618:
    $P5631 = $P5630."ast"()
    set $P5625, $P5631
  if_5626_end:
    store_lex "$value", $P5625
.annotate 'line', 2028
    find_lex $P5636, "$/"
    unless_null $P5636, vivify_2619
    $P5636 = root_new ['parrot';'Hash']
  vivify_2619:
    set $P5637, $P5636["sign"]
    unless_null $P5637, vivify_2620
    new $P5637, "Undef"
  vivify_2620:
    set $S5638, $P5637
    iseq $I5639, $S5638, "-"
    unless $I5639, if_5635_end
    find_lex $P5640, "$value"
    unless_null $P5640, vivify_2621
    new $P5640, "Undef"
  vivify_2621:
    neg $P5641, $P5640
    store_lex "$value", $P5641
  if_5635_end:
.annotate 'line', 2029
    find_lex $P5642, "$/"
    get_hll_global $P5643, ["PAST"], "Val"
    find_lex $P5644, "$value"
    unless_null $P5644, vivify_2622
    new $P5644, "Undef"
  vivify_2622:
    $P5645 = $P5643."new"($P5644 :named("value"))
    $P5646 = $P5642."!make"($P5645)
.annotate 'line', 2026
    .return ($P5646)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("545_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5648
    .param pmc param_5649
.annotate 'line', 2032
    .lex "self", param_5648
    .lex "$/", param_5649
    find_lex $P5650, "$/"
    find_lex $P5651, "$/"
    unless_null $P5651, vivify_2623
    $P5651 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5652, $P5651["quote_EXPR"]
    unless_null $P5652, vivify_2624
    new $P5652, "Undef"
  vivify_2624:
    $P5653 = $P5652."ast"()
    $P5654 = $P5650."!make"($P5653)
    .return ($P5654)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("546_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5656
    .param pmc param_5657
.annotate 'line', 2033
    .lex "self", param_5656
    .lex "$/", param_5657
    find_lex $P5658, "$/"
    find_lex $P5659, "$/"
    unless_null $P5659, vivify_2625
    $P5659 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P5660, $P5659["quote_EXPR"]
    unless_null $P5660, vivify_2626
    new $P5660, "Undef"
  vivify_2626:
    $P5661 = $P5660."ast"()
    $P5662 = $P5658."!make"($P5661)
    .return ($P5662)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("547_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5664
    .param pmc param_5665
.annotate 'line', 2034
    .lex "self", param_5664
    .lex "$/", param_5665
    find_lex $P5666, "$/"
    find_lex $P5667, "$/"
    unless_null $P5667, vivify_2627
    $P5667 = root_new ['parrot';'Hash']
  vivify_2627:
    set $P5668, $P5667["quote_EXPR"]
    unless_null $P5668, vivify_2628
    new $P5668, "Undef"
  vivify_2628:
    $P5669 = $P5668."ast"()
    $P5670 = $P5666."!make"($P5669)
    .return ($P5670)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("548_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5672
    .param pmc param_5673
.annotate 'line', 2035
    .lex "self", param_5672
    .lex "$/", param_5673
    find_lex $P5674, "$/"
    find_lex $P5675, "$/"
    unless_null $P5675, vivify_2629
    $P5675 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P5676, $P5675["quote_EXPR"]
    unless_null $P5676, vivify_2630
    new $P5676, "Undef"
  vivify_2630:
    $P5677 = $P5676."ast"()
    $P5678 = $P5674."!make"($P5677)
    .return ($P5678)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("549_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5680
    .param pmc param_5681
.annotate 'line', 2036
    .lex "self", param_5680
    .lex "$/", param_5681
    find_lex $P5682, "$/"
    find_lex $P5683, "$/"
    unless_null $P5683, vivify_2631
    $P5683 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P5684, $P5683["quote_EXPR"]
    unless_null $P5684, vivify_2632
    new $P5684, "Undef"
  vivify_2632:
    $P5685 = $P5684."ast"()
    $P5686 = $P5682."!make"($P5685)
    .return ($P5686)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("550_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5688
    .param pmc param_5689
.annotate 'line', 2037
    .lex "self", param_5688
    .lex "$/", param_5689
.annotate 'line', 2038
    find_lex $P5690, "$/"
    get_hll_global $P5691, ["PAST"], "Op"
    find_lex $P5692, "$/"
    unless_null $P5692, vivify_2633
    $P5692 = root_new ['parrot';'Hash']
  vivify_2633:
    set $P5693, $P5692["quote_EXPR"]
    unless_null $P5693, vivify_2634
    new $P5693, "Undef"
  vivify_2634:
    $P5694 = $P5693."ast"()
    $P5695 = $P5694."value"()
    find_lex $P5696, "$/"
    unless_null $P5696, vivify_2635
    new $P5696, "Undef"
  vivify_2635:
    $P5697 = $P5691."new"($P5695 :named("inline"), "inline" :named("pasttype"), $P5696 :named("node"))
    $P5698 = $P5690."!make"($P5697)
.annotate 'line', 2037
    .return ($P5698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("551_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5702
    .param pmc param_5703
    .param pmc param_5704 :optional
    .param int has_param_5704 :opt_flag
.annotate 'line', 2043
    new $P5701, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5701, control_5700
    push_eh $P5701
    .lex "self", param_5702
    .lex "$/", param_5703
    if has_param_5704, optparam_2636
    new $P5705, "Undef"
    set param_5704, $P5705
  optparam_2636:
    .lex "$key", param_5704
.annotate 'line', 2050
    new $P5706, "Undef"
    .lex "$regex", $P5706
.annotate 'line', 2052
    new $P5707, "Undef"
    .lex "$past", $P5707
.annotate 'line', 2044
    find_lex $P5709, "$key"
    unless_null $P5709, vivify_2637
    new $P5709, "Undef"
  vivify_2637:
    set $S5710, $P5709
    iseq $I5711, $S5710, "open"
    unless $I5711, if_5708_end
.annotate 'line', 2045
    null $P5712
    get_hll_global $P5713, ["Regex";"P6Regex"], "Actions"
    get_who $P5714, $P5713
    set $P5714["$REGEXNAME"], $P5712
.annotate 'line', 2046
    find_lex $P5715, "$?PACKAGE"
    get_who $P5716, $P5715
    set $P5717, $P5716["@BLOCK"]
    unless_null $P5717, vivify_2638
    $P5717 = root_new ['parrot';'ResizablePMCArray']
  vivify_2638:
    set $P5718, $P5717[0]
    unless_null $P5718, vivify_2639
    new $P5718, "Undef"
  vivify_2639:
    $P5718."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2047
    find_lex $P5719, "$?PACKAGE"
    get_who $P5720, $P5719
    set $P5721, $P5720["@BLOCK"]
    unless_null $P5721, vivify_2640
    $P5721 = root_new ['parrot';'ResizablePMCArray']
  vivify_2640:
    set $P5722, $P5721[0]
    unless_null $P5722, vivify_2641
    new $P5722, "Undef"
  vivify_2641:
    $P5722."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2048
    new $P5723, "Exception"
    set $P5723['type'], .CONTROL_RETURN
    new $P5724, "Integer"
    assign $P5724, 0
    setattribute $P5723, 'payload', $P5724
    throw $P5723
  if_5708_end:
.annotate 'line', 2051
    get_hll_global $P5725, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5726, "$/"
    unless_null $P5726, vivify_2642
    $P5726 = root_new ['parrot';'Hash']
  vivify_2642:
    set $P5727, $P5726["p6regex"]
    unless_null $P5727, vivify_2643
    new $P5727, "Undef"
  vivify_2643:
    $P5728 = $P5727."ast"()
    find_lex $P5729, "$?PACKAGE"
    get_who $P5730, $P5729
    set $P5731, $P5730["@BLOCK"]
    unless_null $P5731, vivify_2644
    $P5731 = root_new ['parrot';'ResizablePMCArray']
  vivify_2644:
    $P5732 = $P5731."shift"()
    $P5733 = $P5725($P5728, $P5732)
    store_lex "$regex", $P5733
.annotate 'line', 2053
    get_hll_global $P5734, ["PAST"], "Op"
.annotate 'line', 2055
    get_hll_global $P5735, ["PAST"], "Var"
    new $P5736, "ResizablePMCArray"
    push $P5736, "Regex"
    $P5737 = $P5735."new"("Regex" :named("name"), $P5736 :named("namespace"), "package" :named("scope"))
    find_lex $P5738, "$regex"
    unless_null $P5738, vivify_2645
    new $P5738, "Undef"
  vivify_2645:
    $P5739 = $P5734."new"($P5737, $P5738, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2053
    store_lex "$past", $P5739
.annotate 'line', 2059
    find_lex $P5740, "$regex"
    unless_null $P5740, vivify_2646
    new $P5740, "Undef"
  vivify_2646:
    find_lex $P5741, "$past"
    unless_null $P5741, vivify_2647
    $P5741 = root_new ['parrot';'Hash']
    store_lex "$past", $P5741
  vivify_2647:
    set $P5741["sink"], $P5740
.annotate 'line', 2060
    find_lex $P5742, "$/"
    find_lex $P5743, "$past"
    unless_null $P5743, vivify_2648
    new $P5743, "Undef"
  vivify_2648:
    $P5744 = $P5742."!make"($P5743)
.annotate 'line', 2043
    .return ($P5744)
  control_5700:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5745, exception, "payload"
    .return ($P5745)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("552_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5747
    .param pmc param_5748
.annotate 'line', 2063
    .lex "self", param_5747
    .lex "$/", param_5748
    find_lex $P5749, "$/"
    find_lex $P5750, "$/"
    unless_null $P5750, vivify_2649
    $P5750 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5751, $P5750["variable"]
    unless_null $P5751, vivify_2650
    new $P5751, "Undef"
  vivify_2650:
    $P5752 = $P5751."ast"()
    $P5753 = $P5749."!make"($P5752)
    .return ($P5753)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("553_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5755
    .param pmc param_5756
.annotate 'line', 2064
    .lex "self", param_5755
    .lex "$/", param_5756
.annotate 'line', 2065
    find_lex $P5757, "$/"
    get_hll_global $P5758, ["PAST"], "Op"
.annotate 'line', 2066
    find_lex $P5759, "$/"
    unless_null $P5759, vivify_2651
    $P5759 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P5760, $P5759["block"]
    unless_null $P5760, vivify_2652
    new $P5760, "Undef"
  vivify_2652:
    $P5761 = $P5760."ast"()
    $P5762 = "block_immediate"($P5761)
    find_lex $P5763, "$/"
    unless_null $P5763, vivify_2653
    new $P5763, "Undef"
  vivify_2653:
    $P5764 = $P5758."new"($P5762, "set S*" :named("pirop"), $P5763 :named("node"))
.annotate 'line', 2065
    $P5765 = $P5757."!make"($P5764)
.annotate 'line', 2064
    .return ($P5765)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("554_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5767
    .param pmc param_5768
.annotate 'line', 2069
    .lex "self", param_5767
    .lex "$/", param_5768
    find_lex $P5769, "$/"
    $P5770 = $P5769."!make"("\e")
    .return ($P5770)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("555_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5772
    .param pmc param_5773
.annotate 'line', 2073
    .lex "self", param_5772
    .lex "$/", param_5773
    find_lex $P5774, "$/"
    find_lex $P5775, "$/"
    unless_null $P5775, vivify_2654
    $P5775 = root_new ['parrot';'Hash']
  vivify_2654:
    set $P5776, $P5775["dotty"]
    unless_null $P5776, vivify_2655
    new $P5776, "Undef"
  vivify_2655:
    $P5777 = $P5776."ast"()
    $P5778 = $P5774."!make"($P5777)
    .return ($P5778)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("556_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5780
    .param pmc param_5781
.annotate 'line', 2075
    .lex "self", param_5780
    .lex "$/", param_5781
.annotate 'line', 2076
    find_lex $P5782, "$/"
    get_hll_global $P5783, ["PAST"], "Op"
.annotate 'line', 2077
    new $P5784, "ResizablePMCArray"
    push $P5784, "    clone %r, %0"
    push $P5784, "    inc %0"
    $P5785 = $P5783."new"("postfix:<++>" :named("name"), $P5784 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2076
    $P5786 = $P5782."!make"($P5785)
.annotate 'line', 2075
    .return ($P5786)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("557_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5788
    .param pmc param_5789
.annotate 'line', 2081
    .lex "self", param_5788
    .lex "$/", param_5789
.annotate 'line', 2082
    find_lex $P5790, "$/"
    get_hll_global $P5791, ["PAST"], "Op"
.annotate 'line', 2083
    new $P5792, "ResizablePMCArray"
    push $P5792, "    clone %r, %0"
    push $P5792, "    dec %0"
    $P5793 = $P5791."new"("postfix:<-->" :named("name"), $P5792 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2082
    $P5794 = $P5790."!make"($P5793)
.annotate 'line', 2081
    .return ($P5794)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("558_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5796
    .param pmc param_5797
.annotate 'line', 2087
    .lex "self", param_5796
    .lex "$/", param_5797
.annotate 'line', 2088
    find_lex $P5798, "$/"
    get_hll_global $P5799, ["PAST"], "Op"
.annotate 'line', 2089
    get_hll_global $P5800, ["PAST"], "Var"
    $P5801 = $P5800."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5802, "$/"
    unless_null $P5802, vivify_2656
    new $P5802, "Undef"
  vivify_2656:
    $P5803 = $P5799."new"($P5801, "callmethod" :named("pasttype"), "!make" :named("name"), $P5802 :named("node"))
.annotate 'line', 2088
    $P5804 = $P5798."!make"($P5803)
.annotate 'line', 2087
    .return ($P5804)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("559_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5807
    .param pmc param_5808
.annotate 'line', 2105
    .lex "self", param_5807
    .lex "$/", param_5808
    find_lex $P5809, "$/"
    unless_null $P5809, vivify_2657
    new $P5809, "Undef"
  vivify_2657:
    $P5810 = "control"($P5809, "CONTROL_LOOP_NEXT")
    .return ($P5810)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("560_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5812
    .param pmc param_5813
.annotate 'line', 2106
    .lex "self", param_5812
    .lex "$/", param_5813
    find_lex $P5814, "$/"
    unless_null $P5814, vivify_2658
    new $P5814, "Undef"
  vivify_2658:
    $P5815 = "control"($P5814, "CONTROL_LOOP_LAST")
    .return ($P5815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("561_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5817
    .param pmc param_5818
.annotate 'line', 2107
    .lex "self", param_5817
    .lex "$/", param_5818
    find_lex $P5819, "$/"
    unless_null $P5819, vivify_2659
    new $P5819, "Undef"
  vivify_2659:
    $P5820 = "control"($P5819, "CONTROL_LOOP_REDO")
    .return ($P5820)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("562_1303576195.699") :outer("406_1303576195.699")
    .param pmc param_5822
    .param pmc param_5823
.annotate 'line', 2109
    .lex "self", param_5822
    .lex "$/", param_5823
.annotate 'line', 2110
    find_lex $P5824, "$/"
    get_hll_global $P5825, ["PAST"], "Op"
    find_lex $P5826, "$/"
    unless_null $P5826, vivify_2660
    new $P5826, "Undef"
  vivify_2660:
    $P5827 = $P5825."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5826 :named("node"))
    $P5828 = $P5824."!make"($P5827)
.annotate 'line', 2109
    .return ($P5828)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6059"  :subid("564_1303576195.699") :outer("10_1303576195.699")
.annotate 'line', 2194
    .const 'Sub' $P6160 = "572_1303576195.699" 
    capture_lex $P6160
    .const 'Sub' $P6135 = "571_1303576195.699" 
    capture_lex $P6135
    .const 'Sub' $P6124 = "570_1303576195.699" 
    capture_lex $P6124
    .const 'Sub' $P6109 = "569_1303576195.699" 
    capture_lex $P6109
    .const 'Sub' $P6098 = "568_1303576195.699" 
    capture_lex $P6098
    .const 'Sub' $P6087 = "567_1303576195.699" 
    capture_lex $P6087
    .const 'Sub' $P6076 = "566_1303576195.699" 
    capture_lex $P6076
    .const 'Sub' $P6063 = "565_1303576195.699" 
    capture_lex $P6063
    .lex "$?PACKAGE", $P6061
    .lex "$?CLASS", $P6062
.annotate 'line', 2228
    .const 'Sub' $P6135 = "571_1303576195.699" 
    newclosure $P6158, $P6135
.annotate 'line', 2194
    .return ($P6158)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2661") :outer("564_1303576195.699")
.annotate 'line', 2194
    .const 'Sub' $P6060 = "564_1303576195.699" 
    .local pmc block
    set block, $P6060
    .const 'Sub' $P6160 = "572_1303576195.699" 
    capture_lex $P6160
    $P6160()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6159"  :anon :subid("572_1303576195.699") :outer("564_1303576195.699")
.annotate 'line', 2194
    nqp_get_sc_object $P6161, "1303576184.274", 4
    .local pmc type_obj
    set type_obj, $P6161
    get_how $P6162, type_obj
    .const 'Sub' $P6163 = "565_1303576195.699" 
    $P6162."add_method"(type_obj, "metachar:sym<:my>", $P6163)
    get_how $P6164, type_obj
    .const 'Sub' $P6165 = "566_1303576195.699" 
    $P6164."add_method"(type_obj, "metachar:sym<{ }>", $P6165)
    get_how $P6166, type_obj
    .const 'Sub' $P6167 = "567_1303576195.699" 
    $P6166."add_method"(type_obj, "metachar:sym<nqpvar>", $P6167)
    get_how $P6168, type_obj
    .const 'Sub' $P6169 = "568_1303576195.699" 
    $P6168."add_method"(type_obj, "assertion:sym<{ }>", $P6169)
    get_how $P6170, type_obj
    .const 'Sub' $P6171 = "569_1303576195.699" 
    $P6170."add_method"(type_obj, "assertion:sym<?{ }>", $P6171)
    get_how $P6172, type_obj
    .const 'Sub' $P6173 = "570_1303576195.699" 
    $P6172."add_method"(type_obj, "assertion:sym<var>", $P6173)
    get_how $P6174, type_obj
    .const 'Sub' $P6175 = "571_1303576195.699" 
    $P6174."add_method"(type_obj, "codeblock", $P6175)
    get_how $P6176, type_obj
    get_hll_global $P6177, ["Regex";"P6Regex"], "Actions"
    $P6176."add_parent"(type_obj, $P6177)
    get_how $P6178, type_obj
    $P6179 = $P6178."compose"(type_obj)
    .return ($P6179)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("565_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6064
    .param pmc param_6065
.annotate 'line', 2196
    .lex "self", param_6064
    .lex "$/", param_6065
.annotate 'line', 2197
    new $P6066, "Undef"
    .lex "$past", $P6066
    find_lex $P6067, "$/"
    unless_null $P6067, vivify_2662
    $P6067 = root_new ['parrot';'Hash']
  vivify_2662:
    set $P6068, $P6067["statement"]
    unless_null $P6068, vivify_2663
    new $P6068, "Undef"
  vivify_2663:
    $P6069 = $P6068."ast"()
    store_lex "$past", $P6069
.annotate 'line', 2198
    find_lex $P6070, "$/"
    get_hll_global $P6071, ["PAST"], "Regex"
    find_lex $P6072, "$past"
    unless_null $P6072, vivify_2664
    new $P6072, "Undef"
  vivify_2664:
    find_lex $P6073, "$/"
    unless_null $P6073, vivify_2665
    new $P6073, "Undef"
  vivify_2665:
    $P6074 = $P6071."new"($P6072, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6073 :named("node"))
    $P6075 = $P6070."!make"($P6074)
.annotate 'line', 2196
    .return ($P6075)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("566_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6077
    .param pmc param_6078
.annotate 'line', 2202
    .lex "self", param_6077
    .lex "$/", param_6078
.annotate 'line', 2203
    find_lex $P6079, "$/"
    get_hll_global $P6080, ["PAST"], "Regex"
    find_lex $P6081, "$/"
    unless_null $P6081, vivify_2666
    $P6081 = root_new ['parrot';'Hash']
  vivify_2666:
    set $P6082, $P6081["codeblock"]
    unless_null $P6082, vivify_2667
    new $P6082, "Undef"
  vivify_2667:
    $P6083 = $P6082."ast"()
    find_lex $P6084, "$/"
    unless_null $P6084, vivify_2668
    new $P6084, "Undef"
  vivify_2668:
    $P6085 = $P6080."new"($P6083, "pastnode" :named("pasttype"), $P6084 :named("node"))
    $P6086 = $P6079."!make"($P6085)
.annotate 'line', 2202
    .return ($P6086)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("567_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6088
    .param pmc param_6089
.annotate 'line', 2207
    .lex "self", param_6088
    .lex "$/", param_6089
.annotate 'line', 2208
    find_lex $P6090, "$/"
    get_hll_global $P6091, ["PAST"], "Regex"
    find_lex $P6092, "$/"
    unless_null $P6092, vivify_2669
    $P6092 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P6093, $P6092["var"]
    unless_null $P6093, vivify_2670
    new $P6093, "Undef"
  vivify_2670:
    $P6094 = $P6093."ast"()
    find_lex $P6095, "$/"
    unless_null $P6095, vivify_2671
    new $P6095, "Undef"
  vivify_2671:
    $P6096 = $P6091."new"("!INTERPOLATE", $P6094, "subrule" :named("pasttype"), "method" :named("subtype"), $P6095 :named("node"))
    $P6097 = $P6090."!make"($P6096)
.annotate 'line', 2207
    .return ($P6097)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("568_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6099
    .param pmc param_6100
.annotate 'line', 2212
    .lex "self", param_6099
    .lex "$/", param_6100
.annotate 'line', 2213
    find_lex $P6101, "$/"
    get_hll_global $P6102, ["PAST"], "Regex"
    find_lex $P6103, "$/"
    unless_null $P6103, vivify_2672
    $P6103 = root_new ['parrot';'Hash']
  vivify_2672:
    set $P6104, $P6103["codeblock"]
    unless_null $P6104, vivify_2673
    new $P6104, "Undef"
  vivify_2673:
    $P6105 = $P6104."ast"()
    find_lex $P6106, "$/"
    unless_null $P6106, vivify_2674
    new $P6106, "Undef"
  vivify_2674:
    $P6107 = $P6102."new"("!INTERPOLATE_REGEX", $P6105, "subrule" :named("pasttype"), "method" :named("subtype"), $P6106 :named("node"))
    $P6108 = $P6101."!make"($P6107)
.annotate 'line', 2212
    .return ($P6108)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("569_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6110
    .param pmc param_6111
.annotate 'line', 2217
    .lex "self", param_6110
    .lex "$/", param_6111
.annotate 'line', 2218
    find_lex $P6112, "$/"
    get_hll_global $P6113, ["PAST"], "Regex"
    find_lex $P6114, "$/"
    unless_null $P6114, vivify_2675
    $P6114 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P6115, $P6114["codeblock"]
    unless_null $P6115, vivify_2676
    new $P6115, "Undef"
  vivify_2676:
    $P6116 = $P6115."ast"()
.annotate 'line', 2219
    find_lex $P6117, "$/"
    unless_null $P6117, vivify_2677
    $P6117 = root_new ['parrot';'Hash']
  vivify_2677:
    set $P6118, $P6117["zw"]
    unless_null $P6118, vivify_2678
    new $P6118, "Undef"
  vivify_2678:
    set $S6119, $P6118
    iseq $I6120, $S6119, "!"
    find_lex $P6121, "$/"
    unless_null $P6121, vivify_2679
    new $P6121, "Undef"
  vivify_2679:
    $P6122 = $P6113."new"($P6116, "zerowidth" :named("subtype"), $I6120 :named("negate"), "pastnode" :named("pasttype"), $P6121 :named("node"))
.annotate 'line', 2218
    $P6123 = $P6112."!make"($P6122)
.annotate 'line', 2217
    .return ($P6123)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("570_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6125
    .param pmc param_6126
.annotate 'line', 2223
    .lex "self", param_6125
    .lex "$/", param_6126
.annotate 'line', 2224
    find_lex $P6127, "$/"
    get_hll_global $P6128, ["PAST"], "Regex"
    find_lex $P6129, "$/"
    unless_null $P6129, vivify_2680
    $P6129 = root_new ['parrot';'Hash']
  vivify_2680:
    set $P6130, $P6129["var"]
    unless_null $P6130, vivify_2681
    new $P6130, "Undef"
  vivify_2681:
    $P6131 = $P6130."ast"()
    find_lex $P6132, "$/"
    unless_null $P6132, vivify_2682
    new $P6132, "Undef"
  vivify_2682:
    $P6133 = $P6128."new"("!INTERPOLATE_REGEX", $P6131, "subrule" :named("pasttype"), "method" :named("subtype"), $P6132 :named("node"))
    $P6134 = $P6127."!make"($P6133)
.annotate 'line', 2223
    .return ($P6134)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("571_1303576195.699") :outer("564_1303576195.699")
    .param pmc param_6136
    .param pmc param_6137
.annotate 'line', 2228
    .lex "self", param_6136
    .lex "$/", param_6137
.annotate 'line', 2229
    new $P6138, "Undef"
    .lex "$block", $P6138
.annotate 'line', 2231
    new $P6139, "Undef"
    .lex "$past", $P6139
.annotate 'line', 2229
    find_lex $P6140, "$/"
    unless_null $P6140, vivify_2683
    $P6140 = root_new ['parrot';'Hash']
  vivify_2683:
    set $P6141, $P6140["block"]
    unless_null $P6141, vivify_2684
    new $P6141, "Undef"
  vivify_2684:
    $P6142 = $P6141."ast"()
    store_lex "$block", $P6142
.annotate 'line', 2230
    find_lex $P6143, "$block"
    unless_null $P6143, vivify_2685
    new $P6143, "Undef"
  vivify_2685:
    $P6143."blocktype"("immediate")
.annotate 'line', 2232
    get_hll_global $P6144, ["PAST"], "Stmts"
.annotate 'line', 2233
    get_hll_global $P6145, ["PAST"], "Op"
.annotate 'line', 2234
    get_hll_global $P6146, ["PAST"], "Var"
    $P6147 = $P6146."new"("$/" :named("name"))
.annotate 'line', 2235
    get_hll_global $P6148, ["PAST"], "Op"
.annotate 'line', 2236
    get_hll_global $P6149, ["PAST"], "Var"
    $P6150 = $P6149."new"(unicode:"$\x{a2}" :named("name"))
    $P6151 = $P6148."new"($P6150, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2235
    $P6152 = $P6145."new"($P6147, $P6151, "bind" :named("pasttype"))
.annotate 'line', 2233
    find_lex $P6153, "$block"
    unless_null $P6153, vivify_2686
    new $P6153, "Undef"
  vivify_2686:
    $P6154 = $P6144."new"($P6152, $P6153)
.annotate 'line', 2232
    store_lex "$past", $P6154
.annotate 'line', 2244
    find_lex $P6155, "$/"
    find_lex $P6156, "$past"
    unless_null $P6156, vivify_2687
    new $P6156, "Undef"
  vivify_2687:
    $P6157 = $P6155."!make"($P6156)
.annotate 'line', 2228
    .return ($P6157)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6180"  :subid("573_1303576195.699") :outer("10_1303576195.699")
.annotate 'line', 2249
    .const 'Sub' $P6185 = "574_1303576195.699" 
    capture_lex $P6185
    .lex "$?PACKAGE", $P6182
    .lex "$?CLASS", $P6183
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2688") :outer("573_1303576195.699")
.annotate 'line', 2249
    .const 'Sub' $P6181 = "573_1303576195.699" 
    .local pmc block
    set block, $P6181
    .const 'Sub' $P6185 = "574_1303576195.699" 
    capture_lex $P6185
    $P6185()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6184"  :anon :subid("574_1303576195.699") :outer("573_1303576195.699")
.annotate 'line', 2249
    nqp_get_sc_object $P6186, "1303576184.274", 5
    .local pmc type_obj
    set type_obj, $P6186
    get_how $P6187, type_obj
    get_hll_global $P6188, ["HLL"], "Compiler"
    $P6187."add_parent"(type_obj, $P6188)
    get_how $P6189, type_obj
    $P6190 = $P6189."compose"(type_obj)
    .return ($P6190)
.end


.HLL "nqp"

.namespace []
.sub "_block6198" :load :anon :subid("575_1303576195.699")
.annotate 'line', 1
    .const 'Sub' $P6200 = "10_1303576195.699" 
    $P6201 = $P6200()
    .return ($P6201)
.end

