
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1304523757.895")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7050 = "615_1304523757.895" 
    capture_lex $P7050
    .const 'Sub' $P6917 = "607_1304523757.895" 
    capture_lex $P6917
    .const 'Sub' $P2863 = "432_1304523757.895" 
    capture_lex $P2863
    .const 'Sub' $P2798 = "411_1304523757.895" 
    capture_lex $P2798
    .const 'Sub' $P935 = "38_1304523757.895" 
    capture_lex $P935
    .const 'Sub' $P47 = "12_1304523757.895" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1304523757.895" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2681
    .const 'Sub' $P16 = "11_1304523757.895" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 11
    .const 'Sub' $P47 = "12_1304523757.895" 
    capture_lex $P47
    $P47()
.annotate 'line', 421
    .const 'Sub' $P935 = "38_1304523757.895" 
    capture_lex $P935
    $P935()
.annotate 'line', 1137
    .const 'Sub' $P2798 = "411_1304523757.895" 
    capture_lex $P2798
    $P2798()
.annotate 'line', 1180
    .const 'Sub' $P2863 = "432_1304523757.895" 
    capture_lex $P2863
    $P2863()
.annotate 'line', 2623
    .const 'Sub' $P6917 = "607_1304523757.895" 
    capture_lex $P6917
    $P6917()
.annotate 'line', 2678
    .const 'Sub' $P7050 = "615_1304523757.895" 
    capture_lex $P7050
    $P7050()
    find_lex $P7053, "MAIN"
    find_lex $P7056, "@ARGS"
    if $P7056, if_7055
    set $P7054, $P7056
    goto if_7055_end
  if_7055:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7057, "ModuleLoader"
    getinterp $P7058
    set $P7059, $P7058["context"]
    $P7057."set_mainline_module"($P7059)
    .const 'Sub' $P7060 = "11_1304523757.895" 
    find_lex $P7061, "@ARGS"
    $P7062 = $P7060($P7061 :flat)
    set $P7054, $P7062
  if_7055_end:
.annotate 'line', 1
    .return ($P7054)
    .const 'Sub' $P7064 = "616_1304523757.895" 
    .return ($P7064)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post617") :outer("10_1304523757.895")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1304523757.895" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7068, "1304523744.097"
    isnull $I7069, $P7068
    if $I7069, if_7067
    .const 'Sub' $P9246 = "10_1304523757.895" 
    $P9247 = $P9246."get_lexinfo"()
    nqp_get_sc_object $P9248, "1304523744.097", 0
    $P9247."set_static_lexpad_value"("GLOBALish", $P9248)
    .const 'Sub' $P9249 = "10_1304523757.895" 
    $P9250 = $P9249."get_lexinfo"()
    $P9250."finish_static_lexpad"()
    .const 'Sub' $P9251 = "10_1304523757.895" 
    $P9252 = $P9251."get_lexinfo"()
    nqp_get_sc_object $P9253, "1304523744.097", 0
    $P9252."set_static_lexpad_value"("$?PACKAGE", $P9253)
    .const 'Sub' $P9254 = "10_1304523757.895" 
    $P9255 = $P9254."get_lexinfo"()
    $P9255."finish_static_lexpad"()
    nqp_get_sc_object $P9256, "1304523744.097", 2
    .const 'Sub' $P9257 = "13_1304523757.895" 
    assign $P9256, $P9257
    nqp_get_sc_object $P9258, "1304523744.097", 3
    .const 'Sub' $P9259 = "15_1304523757.895" 
    assign $P9258, $P9259
    nqp_get_sc_object $P9260, "1304523744.097", 4
    .const 'Sub' $P9261 = "16_1304523757.895" 
    assign $P9260, $P9261
    nqp_get_sc_object $P9262, "1304523744.097", 5
    .const 'Sub' $P9263 = "19_1304523757.895" 
    assign $P9262, $P9263
    nqp_get_sc_object $P9264, "1304523744.097", 6
    .const 'Sub' $P9265 = "20_1304523757.895" 
    assign $P9264, $P9265
    nqp_get_sc_object $P9266, "1304523744.097", 7
    .const 'Sub' $P9267 = "21_1304523757.895" 
    assign $P9266, $P9267
    nqp_get_sc_object $P9268, "1304523744.097", 8
    .const 'Sub' $P9269 = "22_1304523757.895" 
    assign $P9268, $P9269
    nqp_get_sc_object $P9270, "1304523744.097", 9
    .const 'Sub' $P9271 = "26_1304523757.895" 
    assign $P9270, $P9271
    nqp_get_sc_object $P9272, "1304523744.097", 10
    .const 'Sub' $P9273 = "28_1304523757.895" 
    assign $P9272, $P9273
    nqp_get_sc_object $P9274, "1304523744.097", 11
    .const 'Sub' $P9275 = "29_1304523757.895" 
    assign $P9274, $P9275
    nqp_get_sc_object $P9276, "1304523744.097", 12
    .const 'Sub' $P9277 = "34_1304523757.895" 
    assign $P9276, $P9277
    nqp_get_sc_object $P9278, "1304523744.097", 13
    .const 'Sub' $P9279 = "35_1304523757.895" 
    assign $P9278, $P9279
    nqp_get_sc_object $P9280, "1304523744.097", 14
    .const 'Sub' $P9281 = "36_1304523757.895" 
    assign $P9280, $P9281
    .const 'Sub' $P9282 = "12_1304523757.895" 
    $P9283 = $P9282."get_lexinfo"()
    nqp_get_sc_object $P9284, "1304523744.097", 1
    $P9283."set_static_lexpad_value"("$?PACKAGE", $P9284)
    .const 'Sub' $P9285 = "12_1304523757.895" 
    $P9286 = $P9285."get_lexinfo"()
    $P9286."finish_static_lexpad"()
    .const 'Sub' $P9287 = "12_1304523757.895" 
    $P9288 = $P9287."get_lexinfo"()
    nqp_get_sc_object $P9289, "1304523744.097", 1
    $P9288."set_static_lexpad_value"("$?CLASS", $P9289)
    .const 'Sub' $P9290 = "12_1304523757.895" 
    $P9291 = $P9290."get_lexinfo"()
    $P9291."finish_static_lexpad"()
    nqp_get_sc_object $P9292, "1304523744.097", 16
    .const 'Sub' $P9293 = "39_1304523757.895" 
    assign $P9292, $P9293
    nqp_get_sc_object $P9294, "1304523744.097", 17
    .const 'Sub' $P9295 = "40_1304523757.895" 
    assign $P9294, $P9295
    nqp_get_sc_object $P9296, "1304523744.097", 18
    .const 'Sub' $P9297 = "41_1304523757.895" 
    assign $P9296, $P9297
    nqp_get_sc_object $P9298, "1304523744.097", 19
    .const 'Sub' $P9299 = "42_1304523757.895" 
    assign $P9298, $P9299
    nqp_get_sc_object $P9300, "1304523744.097", 20
    .const 'Sub' $P9301 = "43_1304523757.895" 
    assign $P9300, $P9301
    nqp_get_sc_object $P9302, "1304523744.097", 21
    .const 'Sub' $P9303 = "44_1304523757.895" 
    assign $P9302, $P9303
    nqp_get_sc_object $P9304, "1304523744.097", 22
    .const 'Sub' $P9305 = "45_1304523757.895" 
    assign $P9304, $P9305
    nqp_get_sc_object $P9306, "1304523744.097", 23
    .const 'Sub' $P9307 = "46_1304523757.895" 
    assign $P9306, $P9307
    nqp_get_sc_object $P9308, "1304523744.097", 24
    .const 'Sub' $P9309 = "47_1304523757.895" 
    assign $P9308, $P9309
    nqp_get_sc_object $P9310, "1304523744.097", 25
    .const 'Sub' $P9311 = "48_1304523757.895" 
    assign $P9310, $P9311
    nqp_get_sc_object $P9312, "1304523744.097", 26
    .const 'Sub' $P9313 = "49_1304523757.895" 
    assign $P9312, $P9313
    nqp_get_sc_object $P9314, "1304523744.097", 27
    .const 'Sub' $P9315 = "50_1304523757.895" 
    assign $P9314, $P9315
    nqp_get_sc_object $P9316, "1304523744.097", 28
    .const 'Sub' $P9317 = "52_1304523757.895" 
    assign $P9316, $P9317
    nqp_get_sc_object $P9318, "1304523744.097", 29
    .const 'Sub' $P9319 = "53_1304523757.895" 
    assign $P9318, $P9319
    nqp_get_sc_object $P9320, "1304523744.097", 30
    .const 'Sub' $P9321 = "55_1304523757.895" 
    assign $P9320, $P9321
    nqp_get_sc_object $P9322, "1304523744.097", 31
    .const 'Sub' $P9323 = "56_1304523757.895" 
    assign $P9322, $P9323
    nqp_get_sc_object $P9324, "1304523744.097", 32
    .const 'Sub' $P9325 = "57_1304523757.895" 
    assign $P9324, $P9325
    nqp_get_sc_object $P9326, "1304523744.097", 33
    .const 'Sub' $P9327 = "58_1304523757.895" 
    assign $P9326, $P9327
    nqp_get_sc_object $P9328, "1304523744.097", 34
    .const 'Sub' $P9329 = "59_1304523757.895" 
    assign $P9328, $P9329
    nqp_get_sc_object $P9330, "1304523744.097", 35
    .const 'Sub' $P9331 = "60_1304523757.895" 
    assign $P9330, $P9331
    nqp_get_sc_object $P9332, "1304523744.097", 36
    .const 'Sub' $P9333 = "62_1304523757.895" 
    assign $P9332, $P9333
    nqp_get_sc_object $P9334, "1304523744.097", 37
    .const 'Sub' $P9335 = "63_1304523757.895" 
    assign $P9334, $P9335
    nqp_get_sc_object $P9336, "1304523744.097", 38
    .const 'Sub' $P9337 = "64_1304523757.895" 
    assign $P9336, $P9337
    nqp_get_sc_object $P9338, "1304523744.097", 39
    .const 'Sub' $P9339 = "65_1304523757.895" 
    assign $P9338, $P9339
    nqp_get_sc_object $P9340, "1304523744.097", 40
    .const 'Sub' $P9341 = "66_1304523757.895" 
    assign $P9340, $P9341
    nqp_get_sc_object $P9342, "1304523744.097", 41
    .const 'Sub' $P9343 = "67_1304523757.895" 
    assign $P9342, $P9343
    nqp_get_sc_object $P9344, "1304523744.097", 42
    .const 'Sub' $P9345 = "68_1304523757.895" 
    assign $P9344, $P9345
    nqp_get_sc_object $P9346, "1304523744.097", 43
    .const 'Sub' $P9347 = "69_1304523757.895" 
    assign $P9346, $P9347
    nqp_get_sc_object $P9348, "1304523744.097", 44
    .const 'Sub' $P9349 = "70_1304523757.895" 
    assign $P9348, $P9349
    nqp_get_sc_object $P9350, "1304523744.097", 45
    .const 'Sub' $P9351 = "71_1304523757.895" 
    assign $P9350, $P9351
    nqp_get_sc_object $P9352, "1304523744.097", 46
    .const 'Sub' $P9353 = "72_1304523757.895" 
    assign $P9352, $P9353
    nqp_get_sc_object $P9354, "1304523744.097", 47
    .const 'Sub' $P9355 = "73_1304523757.895" 
    assign $P9354, $P9355
    nqp_get_sc_object $P9356, "1304523744.097", 48
    .const 'Sub' $P9357 = "74_1304523757.895" 
    assign $P9356, $P9357
    nqp_get_sc_object $P9358, "1304523744.097", 49
    .const 'Sub' $P9359 = "75_1304523757.895" 
    assign $P9358, $P9359
    nqp_get_sc_object $P9360, "1304523744.097", 50
    .const 'Sub' $P9361 = "76_1304523757.895" 
    assign $P9360, $P9361
    nqp_get_sc_object $P9362, "1304523744.097", 51
    .const 'Sub' $P9363 = "77_1304523757.895" 
    assign $P9362, $P9363
    nqp_get_sc_object $P9364, "1304523744.097", 52
    .const 'Sub' $P9365 = "78_1304523757.895" 
    assign $P9364, $P9365
    nqp_get_sc_object $P9366, "1304523744.097", 53
    .const 'Sub' $P9367 = "79_1304523757.895" 
    assign $P9366, $P9367
    nqp_get_sc_object $P9368, "1304523744.097", 54
    .const 'Sub' $P9369 = "80_1304523757.895" 
    assign $P9368, $P9369
    nqp_get_sc_object $P9370, "1304523744.097", 55
    .const 'Sub' $P9371 = "81_1304523757.895" 
    assign $P9370, $P9371
    nqp_get_sc_object $P9372, "1304523744.097", 56
    .const 'Sub' $P9373 = "82_1304523757.895" 
    assign $P9372, $P9373
    nqp_get_sc_object $P9374, "1304523744.097", 57
    .const 'Sub' $P9375 = "83_1304523757.895" 
    assign $P9374, $P9375
    nqp_get_sc_object $P9376, "1304523744.097", 58
    .const 'Sub' $P9377 = "84_1304523757.895" 
    assign $P9376, $P9377
    nqp_get_sc_object $P9378, "1304523744.097", 59
    .const 'Sub' $P9379 = "85_1304523757.895" 
    assign $P9378, $P9379
    nqp_get_sc_object $P9380, "1304523744.097", 60
    .const 'Sub' $P9381 = "86_1304523757.895" 
    assign $P9380, $P9381
    nqp_get_sc_object $P9382, "1304523744.097", 61
    .const 'Sub' $P9383 = "87_1304523757.895" 
    assign $P9382, $P9383
    nqp_get_sc_object $P9384, "1304523744.097", 62
    .const 'Sub' $P9385 = "88_1304523757.895" 
    assign $P9384, $P9385
    nqp_get_sc_object $P9386, "1304523744.097", 63
    .const 'Sub' $P9387 = "89_1304523757.895" 
    assign $P9386, $P9387
    nqp_get_sc_object $P9388, "1304523744.097", 64
    .const 'Sub' $P9389 = "90_1304523757.895" 
    assign $P9388, $P9389
    nqp_get_sc_object $P9390, "1304523744.097", 65
    .const 'Sub' $P9391 = "91_1304523757.895" 
    assign $P9390, $P9391
    nqp_get_sc_object $P9392, "1304523744.097", 66
    .const 'Sub' $P9393 = "92_1304523757.895" 
    assign $P9392, $P9393
    nqp_get_sc_object $P9394, "1304523744.097", 67
    .const 'Sub' $P9395 = "93_1304523757.895" 
    assign $P9394, $P9395
    nqp_get_sc_object $P9396, "1304523744.097", 68
    .const 'Sub' $P9397 = "94_1304523757.895" 
    assign $P9396, $P9397
    nqp_get_sc_object $P9398, "1304523744.097", 69
    .const 'Sub' $P9399 = "95_1304523757.895" 
    assign $P9398, $P9399
    nqp_get_sc_object $P9400, "1304523744.097", 70
    .const 'Sub' $P9401 = "96_1304523757.895" 
    assign $P9400, $P9401
    nqp_get_sc_object $P9402, "1304523744.097", 71
    .const 'Sub' $P9403 = "97_1304523757.895" 
    assign $P9402, $P9403
    nqp_get_sc_object $P9404, "1304523744.097", 72
    .const 'Sub' $P9405 = "99_1304523757.895" 
    assign $P9404, $P9405
    nqp_get_sc_object $P9406, "1304523744.097", 73
    .const 'Sub' $P9407 = "100_1304523757.895" 
    assign $P9406, $P9407
    nqp_get_sc_object $P9408, "1304523744.097", 74
    .const 'Sub' $P9409 = "101_1304523757.895" 
    assign $P9408, $P9409
    nqp_get_sc_object $P9410, "1304523744.097", 75
    .const 'Sub' $P9411 = "102_1304523757.895" 
    assign $P9410, $P9411
    nqp_get_sc_object $P9412, "1304523744.097", 76
    .const 'Sub' $P9413 = "103_1304523757.895" 
    assign $P9412, $P9413
    nqp_get_sc_object $P9414, "1304523744.097", 77
    .const 'Sub' $P9415 = "104_1304523757.895" 
    assign $P9414, $P9415
    nqp_get_sc_object $P9416, "1304523744.097", 78
    .const 'Sub' $P9417 = "105_1304523757.895" 
    assign $P9416, $P9417
    nqp_get_sc_object $P9418, "1304523744.097", 79
    .const 'Sub' $P9419 = "106_1304523757.895" 
    assign $P9418, $P9419
    nqp_get_sc_object $P9420, "1304523744.097", 80
    .const 'Sub' $P9421 = "107_1304523757.895" 
    assign $P9420, $P9421
    nqp_get_sc_object $P9422, "1304523744.097", 81
    .const 'Sub' $P9423 = "108_1304523757.895" 
    assign $P9422, $P9423
    nqp_get_sc_object $P9424, "1304523744.097", 82
    .const 'Sub' $P9425 = "109_1304523757.895" 
    assign $P9424, $P9425
    nqp_get_sc_object $P9426, "1304523744.097", 83
    .const 'Sub' $P9427 = "110_1304523757.895" 
    assign $P9426, $P9427
    nqp_get_sc_object $P9428, "1304523744.097", 84
    .const 'Sub' $P9429 = "111_1304523757.895" 
    assign $P9428, $P9429
    nqp_get_sc_object $P9430, "1304523744.097", 85
    .const 'Sub' $P9431 = "112_1304523757.895" 
    assign $P9430, $P9431
    nqp_get_sc_object $P9432, "1304523744.097", 86
    .const 'Sub' $P9433 = "113_1304523757.895" 
    assign $P9432, $P9433
    nqp_get_sc_object $P9434, "1304523744.097", 87
    .const 'Sub' $P9435 = "114_1304523757.895" 
    assign $P9434, $P9435
    nqp_get_sc_object $P9436, "1304523744.097", 88
    .const 'Sub' $P9437 = "115_1304523757.895" 
    assign $P9436, $P9437
    nqp_get_sc_object $P9438, "1304523744.097", 89
    .const 'Sub' $P9439 = "116_1304523757.895" 
    assign $P9438, $P9439
    nqp_get_sc_object $P9440, "1304523744.097", 90
    .const 'Sub' $P9441 = "117_1304523757.895" 
    assign $P9440, $P9441
    nqp_get_sc_object $P9442, "1304523744.097", 91
    .const 'Sub' $P9443 = "118_1304523757.895" 
    assign $P9442, $P9443
    nqp_get_sc_object $P9444, "1304523744.097", 92
    .const 'Sub' $P9445 = "119_1304523757.895" 
    assign $P9444, $P9445
    nqp_get_sc_object $P9446, "1304523744.097", 93
    .const 'Sub' $P9447 = "120_1304523757.895" 
    assign $P9446, $P9447
    nqp_get_sc_object $P9448, "1304523744.097", 94
    .const 'Sub' $P9449 = "121_1304523757.895" 
    assign $P9448, $P9449
    nqp_get_sc_object $P9450, "1304523744.097", 95
    .const 'Sub' $P9451 = "122_1304523757.895" 
    assign $P9450, $P9451
    nqp_get_sc_object $P9452, "1304523744.097", 96
    .const 'Sub' $P9453 = "123_1304523757.895" 
    assign $P9452, $P9453
    nqp_get_sc_object $P9454, "1304523744.097", 97
    .const 'Sub' $P9455 = "124_1304523757.895" 
    assign $P9454, $P9455
    nqp_get_sc_object $P9456, "1304523744.097", 98
    .const 'Sub' $P9457 = "125_1304523757.895" 
    assign $P9456, $P9457
    nqp_get_sc_object $P9458, "1304523744.097", 99
    .const 'Sub' $P9459 = "126_1304523757.895" 
    assign $P9458, $P9459
    nqp_get_sc_object $P9460, "1304523744.097", 100
    .const 'Sub' $P9461 = "127_1304523757.895" 
    assign $P9460, $P9461
    nqp_get_sc_object $P9462, "1304523744.097", 101
    .const 'Sub' $P9463 = "128_1304523757.895" 
    assign $P9462, $P9463
    nqp_get_sc_object $P9464, "1304523744.097", 102
    .const 'Sub' $P9465 = "129_1304523757.895" 
    assign $P9464, $P9465
    nqp_get_sc_object $P9466, "1304523744.097", 103
    .const 'Sub' $P9467 = "130_1304523757.895" 
    assign $P9466, $P9467
    nqp_get_sc_object $P9468, "1304523744.097", 104
    .const 'Sub' $P9469 = "131_1304523757.895" 
    assign $P9468, $P9469
    nqp_get_sc_object $P9470, "1304523744.097", 105
    .const 'Sub' $P9471 = "132_1304523757.895" 
    assign $P9470, $P9471
    nqp_get_sc_object $P9472, "1304523744.097", 106
    .const 'Sub' $P9473 = "133_1304523757.895" 
    assign $P9472, $P9473
    nqp_get_sc_object $P9474, "1304523744.097", 107
    .const 'Sub' $P9475 = "134_1304523757.895" 
    assign $P9474, $P9475
    nqp_get_sc_object $P9476, "1304523744.097", 108
    .const 'Sub' $P9477 = "135_1304523757.895" 
    assign $P9476, $P9477
    nqp_get_sc_object $P9478, "1304523744.097", 109
    .const 'Sub' $P9479 = "136_1304523757.895" 
    assign $P9478, $P9479
    nqp_get_sc_object $P9480, "1304523744.097", 110
    .const 'Sub' $P9481 = "137_1304523757.895" 
    assign $P9480, $P9481
    nqp_get_sc_object $P9482, "1304523744.097", 111
    .const 'Sub' $P9483 = "138_1304523757.895" 
    assign $P9482, $P9483
    nqp_get_sc_object $P9484, "1304523744.097", 112
    .const 'Sub' $P9485 = "139_1304523757.895" 
    assign $P9484, $P9485
    nqp_get_sc_object $P9486, "1304523744.097", 113
    .const 'Sub' $P9487 = "140_1304523757.895" 
    assign $P9486, $P9487
    nqp_get_sc_object $P9488, "1304523744.097", 114
    .const 'Sub' $P9489 = "141_1304523757.895" 
    assign $P9488, $P9489
    nqp_get_sc_object $P9490, "1304523744.097", 115
    .const 'Sub' $P9491 = "142_1304523757.895" 
    assign $P9490, $P9491
    nqp_get_sc_object $P9492, "1304523744.097", 116
    .const 'Sub' $P9493 = "143_1304523757.895" 
    assign $P9492, $P9493
    nqp_get_sc_object $P9494, "1304523744.097", 117
    .const 'Sub' $P9495 = "144_1304523757.895" 
    assign $P9494, $P9495
    nqp_get_sc_object $P9496, "1304523744.097", 118
    .const 'Sub' $P9497 = "147_1304523757.895" 
    assign $P9496, $P9497
    nqp_get_sc_object $P9498, "1304523744.097", 119
    .const 'Sub' $P9499 = "148_1304523757.895" 
    assign $P9498, $P9499
    nqp_get_sc_object $P9500, "1304523744.097", 120
    .const 'Sub' $P9501 = "149_1304523757.895" 
    assign $P9500, $P9501
    nqp_get_sc_object $P9502, "1304523744.097", 121
    .const 'Sub' $P9503 = "150_1304523757.895" 
    assign $P9502, $P9503
    nqp_get_sc_object $P9504, "1304523744.097", 122
    .const 'Sub' $P9505 = "151_1304523757.895" 
    assign $P9504, $P9505
    nqp_get_sc_object $P9506, "1304523744.097", 123
    .const 'Sub' $P9507 = "152_1304523757.895" 
    assign $P9506, $P9507
    nqp_get_sc_object $P9508, "1304523744.097", 124
    .const 'Sub' $P9509 = "153_1304523757.895" 
    assign $P9508, $P9509
    nqp_get_sc_object $P9510, "1304523744.097", 125
    .const 'Sub' $P9511 = "154_1304523757.895" 
    assign $P9510, $P9511
    nqp_get_sc_object $P9512, "1304523744.097", 126
    .const 'Sub' $P9513 = "155_1304523757.895" 
    assign $P9512, $P9513
    nqp_get_sc_object $P9514, "1304523744.097", 127
    .const 'Sub' $P9515 = "156_1304523757.895" 
    assign $P9514, $P9515
    nqp_get_sc_object $P9516, "1304523744.097", 128
    .const 'Sub' $P9517 = "157_1304523757.895" 
    assign $P9516, $P9517
    nqp_get_sc_object $P9518, "1304523744.097", 129
    .const 'Sub' $P9519 = "158_1304523757.895" 
    assign $P9518, $P9519
    nqp_get_sc_object $P9520, "1304523744.097", 130
    .const 'Sub' $P9521 = "159_1304523757.895" 
    assign $P9520, $P9521
    nqp_get_sc_object $P9522, "1304523744.097", 131
    .const 'Sub' $P9523 = "160_1304523757.895" 
    assign $P9522, $P9523
    nqp_get_sc_object $P9524, "1304523744.097", 132
    .const 'Sub' $P9525 = "161_1304523757.895" 
    assign $P9524, $P9525
    nqp_get_sc_object $P9526, "1304523744.097", 133
    .const 'Sub' $P9527 = "162_1304523757.895" 
    assign $P9526, $P9527
    nqp_get_sc_object $P9528, "1304523744.097", 134
    .const 'Sub' $P9529 = "163_1304523757.895" 
    assign $P9528, $P9529
    nqp_get_sc_object $P9530, "1304523744.097", 135
    .const 'Sub' $P9531 = "164_1304523757.895" 
    assign $P9530, $P9531
    nqp_get_sc_object $P9532, "1304523744.097", 136
    .const 'Sub' $P9533 = "165_1304523757.895" 
    assign $P9532, $P9533
    nqp_get_sc_object $P9534, "1304523744.097", 137
    .const 'Sub' $P9535 = "166_1304523757.895" 
    assign $P9534, $P9535
    nqp_get_sc_object $P9536, "1304523744.097", 138
    .const 'Sub' $P9537 = "167_1304523757.895" 
    assign $P9536, $P9537
    nqp_get_sc_object $P9538, "1304523744.097", 139
    .const 'Sub' $P9539 = "168_1304523757.895" 
    assign $P9538, $P9539
    nqp_get_sc_object $P9540, "1304523744.097", 140
    .const 'Sub' $P9541 = "169_1304523757.895" 
    assign $P9540, $P9541
    nqp_get_sc_object $P9542, "1304523744.097", 141
    .const 'Sub' $P9543 = "170_1304523757.895" 
    assign $P9542, $P9543
    nqp_get_sc_object $P9544, "1304523744.097", 142
    .const 'Sub' $P9545 = "171_1304523757.895" 
    assign $P9544, $P9545
    nqp_get_sc_object $P9546, "1304523744.097", 143
    .const 'Sub' $P9547 = "172_1304523757.895" 
    assign $P9546, $P9547
    nqp_get_sc_object $P9548, "1304523744.097", 144
    .const 'Sub' $P9549 = "173_1304523757.895" 
    assign $P9548, $P9549
    nqp_get_sc_object $P9550, "1304523744.097", 145
    .const 'Sub' $P9551 = "174_1304523757.895" 
    assign $P9550, $P9551
    nqp_get_sc_object $P9552, "1304523744.097", 146
    .const 'Sub' $P9553 = "175_1304523757.895" 
    assign $P9552, $P9553
    nqp_get_sc_object $P9554, "1304523744.097", 147
    .const 'Sub' $P9555 = "176_1304523757.895" 
    assign $P9554, $P9555
    nqp_get_sc_object $P9556, "1304523744.097", 148
    .const 'Sub' $P9557 = "177_1304523757.895" 
    assign $P9556, $P9557
    nqp_get_sc_object $P9558, "1304523744.097", 149
    .const 'Sub' $P9559 = "178_1304523757.895" 
    assign $P9558, $P9559
    nqp_get_sc_object $P9560, "1304523744.097", 150
    .const 'Sub' $P9561 = "180_1304523757.895" 
    assign $P9560, $P9561
    nqp_get_sc_object $P9562, "1304523744.097", 151
    .const 'Sub' $P9563 = "181_1304523757.895" 
    assign $P9562, $P9563
    nqp_get_sc_object $P9564, "1304523744.097", 152
    .const 'Sub' $P9565 = "182_1304523757.895" 
    assign $P9564, $P9565
    nqp_get_sc_object $P9566, "1304523744.097", 153
    .const 'Sub' $P9567 = "183_1304523757.895" 
    assign $P9566, $P9567
    nqp_get_sc_object $P9568, "1304523744.097", 154
    .const 'Sub' $P9569 = "184_1304523757.895" 
    assign $P9568, $P9569
    nqp_get_sc_object $P9570, "1304523744.097", 155
    .const 'Sub' $P9571 = "185_1304523757.895" 
    assign $P9570, $P9571
    nqp_get_sc_object $P9572, "1304523744.097", 156
    .const 'Sub' $P9573 = "186_1304523757.895" 
    assign $P9572, $P9573
    nqp_get_sc_object $P9574, "1304523744.097", 157
    .const 'Sub' $P9575 = "187_1304523757.895" 
    assign $P9574, $P9575
    nqp_get_sc_object $P9576, "1304523744.097", 158
    .const 'Sub' $P9577 = "188_1304523757.895" 
    assign $P9576, $P9577
    nqp_get_sc_object $P9578, "1304523744.097", 159
    .const 'Sub' $P9579 = "189_1304523757.895" 
    assign $P9578, $P9579
    nqp_get_sc_object $P9580, "1304523744.097", 160
    .const 'Sub' $P9581 = "190_1304523757.895" 
    assign $P9580, $P9581
    nqp_get_sc_object $P9582, "1304523744.097", 161
    .const 'Sub' $P9583 = "191_1304523757.895" 
    assign $P9582, $P9583
    nqp_get_sc_object $P9584, "1304523744.097", 162
    .const 'Sub' $P9585 = "193_1304523757.895" 
    assign $P9584, $P9585
    nqp_get_sc_object $P9586, "1304523744.097", 163
    .const 'Sub' $P9587 = "194_1304523757.895" 
    assign $P9586, $P9587
    nqp_get_sc_object $P9588, "1304523744.097", 164
    .const 'Sub' $P9589 = "195_1304523757.895" 
    assign $P9588, $P9589
    nqp_get_sc_object $P9590, "1304523744.097", 165
    .const 'Sub' $P9591 = "196_1304523757.895" 
    assign $P9590, $P9591
    nqp_get_sc_object $P9592, "1304523744.097", 166
    .const 'Sub' $P9593 = "198_1304523757.895" 
    assign $P9592, $P9593
    nqp_get_sc_object $P9594, "1304523744.097", 167
    .const 'Sub' $P9595 = "199_1304523757.895" 
    assign $P9594, $P9595
    nqp_get_sc_object $P9596, "1304523744.097", 168
    .const 'Sub' $P9597 = "200_1304523757.895" 
    assign $P9596, $P9597
    nqp_get_sc_object $P9598, "1304523744.097", 169
    .const 'Sub' $P9599 = "201_1304523757.895" 
    assign $P9598, $P9599
    nqp_get_sc_object $P9600, "1304523744.097", 170
    .const 'Sub' $P9601 = "202_1304523757.895" 
    assign $P9600, $P9601
    nqp_get_sc_object $P9602, "1304523744.097", 171
    .const 'Sub' $P9603 = "203_1304523757.895" 
    assign $P9602, $P9603
    nqp_get_sc_object $P9604, "1304523744.097", 172
    .const 'Sub' $P9605 = "204_1304523757.895" 
    assign $P9604, $P9605
    nqp_get_sc_object $P9606, "1304523744.097", 173
    .const 'Sub' $P9607 = "205_1304523757.895" 
    assign $P9606, $P9607
    nqp_get_sc_object $P9608, "1304523744.097", 174
    .const 'Sub' $P9609 = "206_1304523757.895" 
    assign $P9608, $P9609
    nqp_get_sc_object $P9610, "1304523744.097", 175
    .const 'Sub' $P9611 = "207_1304523757.895" 
    assign $P9610, $P9611
    nqp_get_sc_object $P9612, "1304523744.097", 176
    .const 'Sub' $P9613 = "209_1304523757.895" 
    assign $P9612, $P9613
    nqp_get_sc_object $P9614, "1304523744.097", 177
    .const 'Sub' $P9615 = "210_1304523757.895" 
    assign $P9614, $P9615
    nqp_get_sc_object $P9616, "1304523744.097", 178
    .const 'Sub' $P9617 = "212_1304523757.895" 
    assign $P9616, $P9617
    nqp_get_sc_object $P9618, "1304523744.097", 179
    .const 'Sub' $P9619 = "213_1304523757.895" 
    assign $P9618, $P9619
    nqp_get_sc_object $P9620, "1304523744.097", 180
    .const 'Sub' $P9621 = "214_1304523757.895" 
    assign $P9620, $P9621
    nqp_get_sc_object $P9622, "1304523744.097", 181
    .const 'Sub' $P9623 = "215_1304523757.895" 
    assign $P9622, $P9623
    nqp_get_sc_object $P9624, "1304523744.097", 182
    .const 'Sub' $P9625 = "216_1304523757.895" 
    assign $P9624, $P9625
    nqp_get_sc_object $P9626, "1304523744.097", 183
    .const 'Sub' $P9627 = "217_1304523757.895" 
    assign $P9626, $P9627
    nqp_get_sc_object $P9628, "1304523744.097", 184
    .const 'Sub' $P9629 = "218_1304523757.895" 
    assign $P9628, $P9629
    nqp_get_sc_object $P9630, "1304523744.097", 185
    .const 'Sub' $P9631 = "219_1304523757.895" 
    assign $P9630, $P9631
    nqp_get_sc_object $P9632, "1304523744.097", 186
    .const 'Sub' $P9633 = "220_1304523757.895" 
    assign $P9632, $P9633
    nqp_get_sc_object $P9634, "1304523744.097", 187
    .const 'Sub' $P9635 = "221_1304523757.895" 
    assign $P9634, $P9635
    nqp_get_sc_object $P9636, "1304523744.097", 188
    .const 'Sub' $P9637 = "223_1304523757.895" 
    assign $P9636, $P9637
    nqp_get_sc_object $P9638, "1304523744.097", 189
    .const 'Sub' $P9639 = "224_1304523757.895" 
    assign $P9638, $P9639
    nqp_get_sc_object $P9640, "1304523744.097", 190
    .const 'Sub' $P9641 = "225_1304523757.895" 
    assign $P9640, $P9641
    nqp_get_sc_object $P9642, "1304523744.097", 191
    .const 'Sub' $P9643 = "226_1304523757.895" 
    assign $P9642, $P9643
    nqp_get_sc_object $P9644, "1304523744.097", 192
    .const 'Sub' $P9645 = "227_1304523757.895" 
    assign $P9644, $P9645
    nqp_get_sc_object $P9646, "1304523744.097", 193
    .const 'Sub' $P9647 = "228_1304523757.895" 
    assign $P9646, $P9647
    nqp_get_sc_object $P9648, "1304523744.097", 194
    .const 'Sub' $P9649 = "229_1304523757.895" 
    assign $P9648, $P9649
    nqp_get_sc_object $P9650, "1304523744.097", 195
    .const 'Sub' $P9651 = "230_1304523757.895" 
    assign $P9650, $P9651
    nqp_get_sc_object $P9652, "1304523744.097", 196
    .const 'Sub' $P9653 = "231_1304523757.895" 
    assign $P9652, $P9653
    nqp_get_sc_object $P9654, "1304523744.097", 197
    .const 'Sub' $P9655 = "232_1304523757.895" 
    assign $P9654, $P9655
    nqp_get_sc_object $P9656, "1304523744.097", 198
    .const 'Sub' $P9657 = "233_1304523757.895" 
    assign $P9656, $P9657
    nqp_get_sc_object $P9658, "1304523744.097", 199
    .const 'Sub' $P9659 = "234_1304523757.895" 
    assign $P9658, $P9659
    nqp_get_sc_object $P9660, "1304523744.097", 200
    .const 'Sub' $P9661 = "235_1304523757.895" 
    assign $P9660, $P9661
    nqp_get_sc_object $P9662, "1304523744.097", 201
    .const 'Sub' $P9663 = "236_1304523757.895" 
    assign $P9662, $P9663
    nqp_get_sc_object $P9664, "1304523744.097", 202
    .const 'Sub' $P9665 = "237_1304523757.895" 
    assign $P9664, $P9665
    nqp_get_sc_object $P9666, "1304523744.097", 203
    .const 'Sub' $P9667 = "238_1304523757.895" 
    assign $P9666, $P9667
    nqp_get_sc_object $P9668, "1304523744.097", 204
    .const 'Sub' $P9669 = "239_1304523757.895" 
    assign $P9668, $P9669
    nqp_get_sc_object $P9670, "1304523744.097", 205
    .const 'Sub' $P9671 = "240_1304523757.895" 
    assign $P9670, $P9671
    nqp_get_sc_object $P9672, "1304523744.097", 206
    .const 'Sub' $P9673 = "241_1304523757.895" 
    assign $P9672, $P9673
    nqp_get_sc_object $P9674, "1304523744.097", 207
    .const 'Sub' $P9675 = "242_1304523757.895" 
    assign $P9674, $P9675
    nqp_get_sc_object $P9676, "1304523744.097", 208
    .const 'Sub' $P9677 = "243_1304523757.895" 
    assign $P9676, $P9677
    nqp_get_sc_object $P9678, "1304523744.097", 209
    .const 'Sub' $P9679 = "244_1304523757.895" 
    assign $P9678, $P9679
    nqp_get_sc_object $P9680, "1304523744.097", 210
    .const 'Sub' $P9681 = "245_1304523757.895" 
    assign $P9680, $P9681
    nqp_get_sc_object $P9682, "1304523744.097", 211
    .const 'Sub' $P9683 = "246_1304523757.895" 
    assign $P9682, $P9683
    nqp_get_sc_object $P9684, "1304523744.097", 212
    .const 'Sub' $P9685 = "247_1304523757.895" 
    assign $P9684, $P9685
    nqp_get_sc_object $P9686, "1304523744.097", 213
    .const 'Sub' $P9687 = "248_1304523757.895" 
    assign $P9686, $P9687
    nqp_get_sc_object $P9688, "1304523744.097", 214
    .const 'Sub' $P9689 = "249_1304523757.895" 
    assign $P9688, $P9689
    nqp_get_sc_object $P9690, "1304523744.097", 215
    .const 'Sub' $P9691 = "250_1304523757.895" 
    assign $P9690, $P9691
    nqp_get_sc_object $P9692, "1304523744.097", 216
    .const 'Sub' $P9693 = "251_1304523757.895" 
    assign $P9692, $P9693
    nqp_get_sc_object $P9694, "1304523744.097", 217
    .const 'Sub' $P9695 = "252_1304523757.895" 
    assign $P9694, $P9695
    nqp_get_sc_object $P9696, "1304523744.097", 218
    .const 'Sub' $P9697 = "254_1304523757.895" 
    assign $P9696, $P9697
    nqp_get_sc_object $P9698, "1304523744.097", 219
    .const 'Sub' $P9699 = "255_1304523757.895" 
    assign $P9698, $P9699
    nqp_get_sc_object $P9700, "1304523744.097", 220
    .const 'Sub' $P9701 = "256_1304523757.895" 
    assign $P9700, $P9701
    nqp_get_sc_object $P9702, "1304523744.097", 221
    .const 'Sub' $P9703 = "257_1304523757.895" 
    assign $P9702, $P9703
    nqp_get_sc_object $P9704, "1304523744.097", 222
    .const 'Sub' $P9705 = "258_1304523757.895" 
    assign $P9704, $P9705
    nqp_get_sc_object $P9706, "1304523744.097", 223
    .const 'Sub' $P9707 = "259_1304523757.895" 
    assign $P9706, $P9707
    nqp_get_sc_object $P9708, "1304523744.097", 224
    .const 'Sub' $P9709 = "260_1304523757.895" 
    assign $P9708, $P9709
    nqp_get_sc_object $P9710, "1304523744.097", 225
    .const 'Sub' $P9711 = "261_1304523757.895" 
    assign $P9710, $P9711
    nqp_get_sc_object $P9712, "1304523744.097", 226
    .const 'Sub' $P9713 = "262_1304523757.895" 
    assign $P9712, $P9713
    nqp_get_sc_object $P9714, "1304523744.097", 227
    .const 'Sub' $P9715 = "263_1304523757.895" 
    assign $P9714, $P9715
    nqp_get_sc_object $P9716, "1304523744.097", 228
    .const 'Sub' $P9717 = "264_1304523757.895" 
    assign $P9716, $P9717
    nqp_get_sc_object $P9718, "1304523744.097", 229
    .const 'Sub' $P9719 = "265_1304523757.895" 
    assign $P9718, $P9719
    nqp_get_sc_object $P9720, "1304523744.097", 230
    .const 'Sub' $P9721 = "266_1304523757.895" 
    assign $P9720, $P9721
    nqp_get_sc_object $P9722, "1304523744.097", 231
    .const 'Sub' $P9723 = "267_1304523757.895" 
    assign $P9722, $P9723
    nqp_get_sc_object $P9724, "1304523744.097", 232
    .const 'Sub' $P9725 = "268_1304523757.895" 
    assign $P9724, $P9725
    nqp_get_sc_object $P9726, "1304523744.097", 233
    .const 'Sub' $P9727 = "269_1304523757.895" 
    assign $P9726, $P9727
    nqp_get_sc_object $P9728, "1304523744.097", 234
    .const 'Sub' $P9729 = "270_1304523757.895" 
    assign $P9728, $P9729
    nqp_get_sc_object $P9730, "1304523744.097", 235
    .const 'Sub' $P9731 = "271_1304523757.895" 
    assign $P9730, $P9731
    nqp_get_sc_object $P9732, "1304523744.097", 236
    .const 'Sub' $P9733 = "272_1304523757.895" 
    assign $P9732, $P9733
    nqp_get_sc_object $P9734, "1304523744.097", 237
    .const 'Sub' $P9735 = "273_1304523757.895" 
    assign $P9734, $P9735
    nqp_get_sc_object $P9736, "1304523744.097", 238
    .const 'Sub' $P9737 = "274_1304523757.895" 
    assign $P9736, $P9737
    nqp_get_sc_object $P9738, "1304523744.097", 239
    .const 'Sub' $P9739 = "275_1304523757.895" 
    assign $P9738, $P9739
    nqp_get_sc_object $P9740, "1304523744.097", 240
    .const 'Sub' $P9741 = "276_1304523757.895" 
    assign $P9740, $P9741
    nqp_get_sc_object $P9742, "1304523744.097", 241
    .const 'Sub' $P9743 = "277_1304523757.895" 
    assign $P9742, $P9743
    nqp_get_sc_object $P9744, "1304523744.097", 242
    .const 'Sub' $P9745 = "278_1304523757.895" 
    assign $P9744, $P9745
    nqp_get_sc_object $P9746, "1304523744.097", 243
    .const 'Sub' $P9747 = "279_1304523757.895" 
    assign $P9746, $P9747
    nqp_get_sc_object $P9748, "1304523744.097", 244
    .const 'Sub' $P9749 = "280_1304523757.895" 
    assign $P9748, $P9749
    nqp_get_sc_object $P9750, "1304523744.097", 245
    .const 'Sub' $P9751 = "281_1304523757.895" 
    assign $P9750, $P9751
    nqp_get_sc_object $P9752, "1304523744.097", 246
    .const 'Sub' $P9753 = "282_1304523757.895" 
    assign $P9752, $P9753
    nqp_get_sc_object $P9754, "1304523744.097", 247
    .const 'Sub' $P9755 = "283_1304523757.895" 
    assign $P9754, $P9755
    nqp_get_sc_object $P9756, "1304523744.097", 248
    .const 'Sub' $P9757 = "284_1304523757.895" 
    assign $P9756, $P9757
    nqp_get_sc_object $P9758, "1304523744.097", 249
    .const 'Sub' $P9759 = "285_1304523757.895" 
    assign $P9758, $P9759
    nqp_get_sc_object $P9760, "1304523744.097", 250
    .const 'Sub' $P9761 = "286_1304523757.895" 
    assign $P9760, $P9761
    nqp_get_sc_object $P9762, "1304523744.097", 251
    .const 'Sub' $P9763 = "287_1304523757.895" 
    assign $P9762, $P9763
    nqp_get_sc_object $P9764, "1304523744.097", 252
    .const 'Sub' $P9765 = "288_1304523757.895" 
    assign $P9764, $P9765
    nqp_get_sc_object $P9766, "1304523744.097", 253
    .const 'Sub' $P9767 = "289_1304523757.895" 
    assign $P9766, $P9767
    nqp_get_sc_object $P9768, "1304523744.097", 254
    .const 'Sub' $P9769 = "290_1304523757.895" 
    assign $P9768, $P9769
    nqp_get_sc_object $P9770, "1304523744.097", 255
    .const 'Sub' $P9771 = "291_1304523757.895" 
    assign $P9770, $P9771
    nqp_get_sc_object $P9772, "1304523744.097", 256
    .const 'Sub' $P9773 = "292_1304523757.895" 
    assign $P9772, $P9773
    nqp_get_sc_object $P9774, "1304523744.097", 257
    .const 'Sub' $P9775 = "293_1304523757.895" 
    assign $P9774, $P9775
    nqp_get_sc_object $P9776, "1304523744.097", 258
    .const 'Sub' $P9777 = "294_1304523757.895" 
    assign $P9776, $P9777
    nqp_get_sc_object $P9778, "1304523744.097", 259
    .const 'Sub' $P9779 = "295_1304523757.895" 
    assign $P9778, $P9779
    nqp_get_sc_object $P9780, "1304523744.097", 260
    .const 'Sub' $P9781 = "296_1304523757.895" 
    assign $P9780, $P9781
    nqp_get_sc_object $P9782, "1304523744.097", 261
    .const 'Sub' $P9783 = "297_1304523757.895" 
    assign $P9782, $P9783
    nqp_get_sc_object $P9784, "1304523744.097", 262
    .const 'Sub' $P9785 = "298_1304523757.895" 
    assign $P9784, $P9785
    nqp_get_sc_object $P9786, "1304523744.097", 263
    .const 'Sub' $P9787 = "299_1304523757.895" 
    assign $P9786, $P9787
    nqp_get_sc_object $P9788, "1304523744.097", 264
    .const 'Sub' $P9789 = "300_1304523757.895" 
    assign $P9788, $P9789
    nqp_get_sc_object $P9790, "1304523744.097", 265
    .const 'Sub' $P9791 = "301_1304523757.895" 
    assign $P9790, $P9791
    nqp_get_sc_object $P9792, "1304523744.097", 266
    .const 'Sub' $P9793 = "302_1304523757.895" 
    assign $P9792, $P9793
    nqp_get_sc_object $P9794, "1304523744.097", 267
    .const 'Sub' $P9795 = "303_1304523757.895" 
    assign $P9794, $P9795
    nqp_get_sc_object $P9796, "1304523744.097", 268
    .const 'Sub' $P9797 = "304_1304523757.895" 
    assign $P9796, $P9797
    nqp_get_sc_object $P9798, "1304523744.097", 269
    .const 'Sub' $P9799 = "305_1304523757.895" 
    assign $P9798, $P9799
    nqp_get_sc_object $P9800, "1304523744.097", 270
    .const 'Sub' $P9801 = "306_1304523757.895" 
    assign $P9800, $P9801
    nqp_get_sc_object $P9802, "1304523744.097", 271
    .const 'Sub' $P9803 = "307_1304523757.895" 
    assign $P9802, $P9803
    nqp_get_sc_object $P9804, "1304523744.097", 272
    .const 'Sub' $P9805 = "308_1304523757.895" 
    assign $P9804, $P9805
    nqp_get_sc_object $P9806, "1304523744.097", 273
    .const 'Sub' $P9807 = "309_1304523757.895" 
    assign $P9806, $P9807
    nqp_get_sc_object $P9808, "1304523744.097", 274
    .const 'Sub' $P9809 = "310_1304523757.895" 
    assign $P9808, $P9809
    nqp_get_sc_object $P9810, "1304523744.097", 275
    .const 'Sub' $P9811 = "311_1304523757.895" 
    assign $P9810, $P9811
    nqp_get_sc_object $P9812, "1304523744.097", 276
    .const 'Sub' $P9813 = "312_1304523757.895" 
    assign $P9812, $P9813
    nqp_get_sc_object $P9814, "1304523744.097", 277
    .const 'Sub' $P9815 = "313_1304523757.895" 
    assign $P9814, $P9815
    nqp_get_sc_object $P9816, "1304523744.097", 278
    .const 'Sub' $P9817 = "314_1304523757.895" 
    assign $P9816, $P9817
    nqp_get_sc_object $P9818, "1304523744.097", 279
    .const 'Sub' $P9819 = "315_1304523757.895" 
    assign $P9818, $P9819
    nqp_get_sc_object $P9820, "1304523744.097", 280
    .const 'Sub' $P9821 = "316_1304523757.895" 
    assign $P9820, $P9821
    nqp_get_sc_object $P9822, "1304523744.097", 281
    .const 'Sub' $P9823 = "317_1304523757.895" 
    assign $P9822, $P9823
    nqp_get_sc_object $P9824, "1304523744.097", 282
    .const 'Sub' $P9825 = "318_1304523757.895" 
    assign $P9824, $P9825
    nqp_get_sc_object $P9826, "1304523744.097", 283
    .const 'Sub' $P9827 = "319_1304523757.895" 
    assign $P9826, $P9827
    nqp_get_sc_object $P9828, "1304523744.097", 284
    .const 'Sub' $P9829 = "320_1304523757.895" 
    assign $P9828, $P9829
    nqp_get_sc_object $P9830, "1304523744.097", 285
    .const 'Sub' $P9831 = "321_1304523757.895" 
    assign $P9830, $P9831
    nqp_get_sc_object $P9832, "1304523744.097", 286
    .const 'Sub' $P9833 = "322_1304523757.895" 
    assign $P9832, $P9833
    nqp_get_sc_object $P9834, "1304523744.097", 287
    .const 'Sub' $P9835 = "323_1304523757.895" 
    assign $P9834, $P9835
    nqp_get_sc_object $P9836, "1304523744.097", 288
    .const 'Sub' $P9837 = "324_1304523757.895" 
    assign $P9836, $P9837
    nqp_get_sc_object $P9838, "1304523744.097", 289
    .const 'Sub' $P9839 = "325_1304523757.895" 
    assign $P9838, $P9839
    nqp_get_sc_object $P9840, "1304523744.097", 290
    .const 'Sub' $P9841 = "326_1304523757.895" 
    assign $P9840, $P9841
    nqp_get_sc_object $P9842, "1304523744.097", 291
    .const 'Sub' $P9843 = "327_1304523757.895" 
    assign $P9842, $P9843
    nqp_get_sc_object $P9844, "1304523744.097", 292
    .const 'Sub' $P9845 = "328_1304523757.895" 
    assign $P9844, $P9845
    nqp_get_sc_object $P9846, "1304523744.097", 293
    .const 'Sub' $P9847 = "329_1304523757.895" 
    assign $P9846, $P9847
    nqp_get_sc_object $P9848, "1304523744.097", 294
    .const 'Sub' $P9849 = "330_1304523757.895" 
    assign $P9848, $P9849
    nqp_get_sc_object $P9850, "1304523744.097", 295
    .const 'Sub' $P9851 = "331_1304523757.895" 
    assign $P9850, $P9851
    nqp_get_sc_object $P9852, "1304523744.097", 296
    .const 'Sub' $P9853 = "332_1304523757.895" 
    assign $P9852, $P9853
    nqp_get_sc_object $P9854, "1304523744.097", 297
    .const 'Sub' $P9855 = "333_1304523757.895" 
    assign $P9854, $P9855
    nqp_get_sc_object $P9856, "1304523744.097", 298
    .const 'Sub' $P9857 = "334_1304523757.895" 
    assign $P9856, $P9857
    nqp_get_sc_object $P9858, "1304523744.097", 299
    .const 'Sub' $P9859 = "335_1304523757.895" 
    assign $P9858, $P9859
    nqp_get_sc_object $P9860, "1304523744.097", 300
    .const 'Sub' $P9861 = "336_1304523757.895" 
    assign $P9860, $P9861
    nqp_get_sc_object $P9862, "1304523744.097", 301
    .const 'Sub' $P9863 = "337_1304523757.895" 
    assign $P9862, $P9863
    nqp_get_sc_object $P9864, "1304523744.097", 302
    .const 'Sub' $P9865 = "338_1304523757.895" 
    assign $P9864, $P9865
    nqp_get_sc_object $P9866, "1304523744.097", 303
    .const 'Sub' $P9867 = "339_1304523757.895" 
    assign $P9866, $P9867
    nqp_get_sc_object $P9868, "1304523744.097", 304
    .const 'Sub' $P9869 = "340_1304523757.895" 
    assign $P9868, $P9869
    nqp_get_sc_object $P9870, "1304523744.097", 305
    .const 'Sub' $P9871 = "341_1304523757.895" 
    assign $P9870, $P9871
    nqp_get_sc_object $P9872, "1304523744.097", 306
    .const 'Sub' $P9873 = "342_1304523757.895" 
    assign $P9872, $P9873
    nqp_get_sc_object $P9874, "1304523744.097", 307
    .const 'Sub' $P9875 = "343_1304523757.895" 
    assign $P9874, $P9875
    nqp_get_sc_object $P9876, "1304523744.097", 308
    .const 'Sub' $P9877 = "344_1304523757.895" 
    assign $P9876, $P9877
    nqp_get_sc_object $P9878, "1304523744.097", 309
    .const 'Sub' $P9879 = "345_1304523757.895" 
    assign $P9878, $P9879
    nqp_get_sc_object $P9880, "1304523744.097", 310
    .const 'Sub' $P9881 = "346_1304523757.895" 
    assign $P9880, $P9881
    nqp_get_sc_object $P9882, "1304523744.097", 311
    .const 'Sub' $P9883 = "347_1304523757.895" 
    assign $P9882, $P9883
    nqp_get_sc_object $P9884, "1304523744.097", 312
    .const 'Sub' $P9885 = "348_1304523757.895" 
    assign $P9884, $P9885
    nqp_get_sc_object $P9886, "1304523744.097", 313
    .const 'Sub' $P9887 = "349_1304523757.895" 
    assign $P9886, $P9887
    nqp_get_sc_object $P9888, "1304523744.097", 314
    .const 'Sub' $P9889 = "350_1304523757.895" 
    assign $P9888, $P9889
    nqp_get_sc_object $P9890, "1304523744.097", 315
    .const 'Sub' $P9891 = "351_1304523757.895" 
    assign $P9890, $P9891
    nqp_get_sc_object $P9892, "1304523744.097", 316
    .const 'Sub' $P9893 = "352_1304523757.895" 
    assign $P9892, $P9893
    nqp_get_sc_object $P9894, "1304523744.097", 317
    .const 'Sub' $P9895 = "353_1304523757.895" 
    assign $P9894, $P9895
    nqp_get_sc_object $P9896, "1304523744.097", 318
    .const 'Sub' $P9897 = "354_1304523757.895" 
    assign $P9896, $P9897
    nqp_get_sc_object $P9898, "1304523744.097", 319
    .const 'Sub' $P9899 = "355_1304523757.895" 
    assign $P9898, $P9899
    nqp_get_sc_object $P9900, "1304523744.097", 320
    .const 'Sub' $P9901 = "356_1304523757.895" 
    assign $P9900, $P9901
    nqp_get_sc_object $P9902, "1304523744.097", 321
    .const 'Sub' $P9903 = "357_1304523757.895" 
    assign $P9902, $P9903
    nqp_get_sc_object $P9904, "1304523744.097", 322
    .const 'Sub' $P9905 = "358_1304523757.895" 
    assign $P9904, $P9905
    nqp_get_sc_object $P9906, "1304523744.097", 323
    .const 'Sub' $P9907 = "359_1304523757.895" 
    assign $P9906, $P9907
    nqp_get_sc_object $P9908, "1304523744.097", 324
    .const 'Sub' $P9909 = "360_1304523757.895" 
    assign $P9908, $P9909
    nqp_get_sc_object $P9910, "1304523744.097", 325
    .const 'Sub' $P9911 = "361_1304523757.895" 
    assign $P9910, $P9911
    nqp_get_sc_object $P9912, "1304523744.097", 326
    .const 'Sub' $P9913 = "362_1304523757.895" 
    assign $P9912, $P9913
    nqp_get_sc_object $P9914, "1304523744.097", 327
    .const 'Sub' $P9915 = "363_1304523757.895" 
    assign $P9914, $P9915
    nqp_get_sc_object $P9916, "1304523744.097", 328
    .const 'Sub' $P9917 = "364_1304523757.895" 
    assign $P9916, $P9917
    nqp_get_sc_object $P9918, "1304523744.097", 329
    .const 'Sub' $P9919 = "365_1304523757.895" 
    assign $P9918, $P9919
    nqp_get_sc_object $P9920, "1304523744.097", 330
    .const 'Sub' $P9921 = "366_1304523757.895" 
    assign $P9920, $P9921
    nqp_get_sc_object $P9922, "1304523744.097", 331
    .const 'Sub' $P9923 = "367_1304523757.895" 
    assign $P9922, $P9923
    nqp_get_sc_object $P9924, "1304523744.097", 332
    .const 'Sub' $P9925 = "368_1304523757.895" 
    assign $P9924, $P9925
    nqp_get_sc_object $P9926, "1304523744.097", 333
    .const 'Sub' $P9927 = "369_1304523757.895" 
    assign $P9926, $P9927
    nqp_get_sc_object $P9928, "1304523744.097", 334
    .const 'Sub' $P9929 = "370_1304523757.895" 
    assign $P9928, $P9929
    nqp_get_sc_object $P9930, "1304523744.097", 335
    .const 'Sub' $P9931 = "371_1304523757.895" 
    assign $P9930, $P9931
    nqp_get_sc_object $P9932, "1304523744.097", 336
    .const 'Sub' $P9933 = "372_1304523757.895" 
    assign $P9932, $P9933
    nqp_get_sc_object $P9934, "1304523744.097", 337
    .const 'Sub' $P9935 = "373_1304523757.895" 
    assign $P9934, $P9935
    nqp_get_sc_object $P9936, "1304523744.097", 338
    .const 'Sub' $P9937 = "374_1304523757.895" 
    assign $P9936, $P9937
    nqp_get_sc_object $P9938, "1304523744.097", 339
    .const 'Sub' $P9939 = "375_1304523757.895" 
    assign $P9938, $P9939
    nqp_get_sc_object $P9940, "1304523744.097", 340
    .const 'Sub' $P9941 = "376_1304523757.895" 
    assign $P9940, $P9941
    nqp_get_sc_object $P9942, "1304523744.097", 341
    .const 'Sub' $P9943 = "377_1304523757.895" 
    assign $P9942, $P9943
    nqp_get_sc_object $P9944, "1304523744.097", 342
    .const 'Sub' $P9945 = "378_1304523757.895" 
    assign $P9944, $P9945
    nqp_get_sc_object $P9946, "1304523744.097", 343
    .const 'Sub' $P9947 = "379_1304523757.895" 
    assign $P9946, $P9947
    nqp_get_sc_object $P9948, "1304523744.097", 344
    .const 'Sub' $P9949 = "380_1304523757.895" 
    assign $P9948, $P9949
    nqp_get_sc_object $P9950, "1304523744.097", 345
    .const 'Sub' $P9951 = "381_1304523757.895" 
    assign $P9950, $P9951
    nqp_get_sc_object $P9952, "1304523744.097", 346
    .const 'Sub' $P9953 = "382_1304523757.895" 
    assign $P9952, $P9953
    nqp_get_sc_object $P9954, "1304523744.097", 347
    .const 'Sub' $P9955 = "383_1304523757.895" 
    assign $P9954, $P9955
    nqp_get_sc_object $P9956, "1304523744.097", 348
    .const 'Sub' $P9957 = "384_1304523757.895" 
    assign $P9956, $P9957
    nqp_get_sc_object $P9958, "1304523744.097", 349
    .const 'Sub' $P9959 = "385_1304523757.895" 
    assign $P9958, $P9959
    nqp_get_sc_object $P9960, "1304523744.097", 350
    .const 'Sub' $P9961 = "386_1304523757.895" 
    assign $P9960, $P9961
    nqp_get_sc_object $P9962, "1304523744.097", 351
    .const 'Sub' $P9963 = "387_1304523757.895" 
    assign $P9962, $P9963
    nqp_get_sc_object $P9964, "1304523744.097", 352
    .const 'Sub' $P9965 = "388_1304523757.895" 
    assign $P9964, $P9965
    nqp_get_sc_object $P9966, "1304523744.097", 353
    .const 'Sub' $P9967 = "389_1304523757.895" 
    assign $P9966, $P9967
    nqp_get_sc_object $P9968, "1304523744.097", 354
    .const 'Sub' $P9969 = "390_1304523757.895" 
    assign $P9968, $P9969
    nqp_get_sc_object $P9970, "1304523744.097", 355
    .const 'Sub' $P9971 = "391_1304523757.895" 
    assign $P9970, $P9971
    nqp_get_sc_object $P9972, "1304523744.097", 356
    .const 'Sub' $P9973 = "392_1304523757.895" 
    assign $P9972, $P9973
    nqp_get_sc_object $P9974, "1304523744.097", 357
    .const 'Sub' $P9975 = "393_1304523757.895" 
    assign $P9974, $P9975
    nqp_get_sc_object $P9976, "1304523744.097", 358
    .const 'Sub' $P9977 = "394_1304523757.895" 
    assign $P9976, $P9977
    nqp_get_sc_object $P9978, "1304523744.097", 359
    .const 'Sub' $P9979 = "395_1304523757.895" 
    assign $P9978, $P9979
    nqp_get_sc_object $P9980, "1304523744.097", 360
    .const 'Sub' $P9981 = "396_1304523757.895" 
    assign $P9980, $P9981
    nqp_get_sc_object $P9982, "1304523744.097", 361
    .const 'Sub' $P9983 = "397_1304523757.895" 
    assign $P9982, $P9983
    nqp_get_sc_object $P9984, "1304523744.097", 362
    .const 'Sub' $P9985 = "398_1304523757.895" 
    assign $P9984, $P9985
    nqp_get_sc_object $P9986, "1304523744.097", 363
    .const 'Sub' $P9987 = "399_1304523757.895" 
    assign $P9986, $P9987
    nqp_get_sc_object $P9988, "1304523744.097", 364
    .const 'Sub' $P9989 = "401_1304523757.895" 
    assign $P9988, $P9989
    nqp_get_sc_object $P9990, "1304523744.097", 365
    .const 'Sub' $P9991 = "402_1304523757.895" 
    assign $P9990, $P9991
    nqp_get_sc_object $P9992, "1304523744.097", 366
    .const 'Sub' $P9993 = "403_1304523757.895" 
    assign $P9992, $P9993
    nqp_get_sc_object $P9994, "1304523744.097", 367
    .const 'Sub' $P9995 = "404_1304523757.895" 
    assign $P9994, $P9995
    nqp_get_sc_object $P9996, "1304523744.097", 368
    .const 'Sub' $P9997 = "405_1304523757.895" 
    assign $P9996, $P9997
    nqp_get_sc_object $P9998, "1304523744.097", 369
    .const 'Sub' $P9999 = "406_1304523757.895" 
    assign $P9998, $P9999
    nqp_get_sc_object $P10000, "1304523744.097", 370
    .const 'Sub' $P10001 = "407_1304523757.895" 
    assign $P10000, $P10001
    nqp_get_sc_object $P10002, "1304523744.097", 371
    .const 'Sub' $P10003 = "408_1304523757.895" 
    assign $P10002, $P10003
    nqp_get_sc_object $P10004, "1304523744.097", 372
    .const 'Sub' $P10005 = "409_1304523757.895" 
    assign $P10004, $P10005
    nqp_get_sc_object $P10006, "1304523744.097", 373
    .const 'Sub' $P10007 = "410_1304523757.895" 
    assign $P10006, $P10007
    .const 'Sub' $P10008 = "38_1304523757.895" 
    $P10009 = $P10008."get_lexinfo"()
    nqp_get_sc_object $P10010, "1304523744.097", 15
    $P10009."set_static_lexpad_value"("$?PACKAGE", $P10010)
    .const 'Sub' $P10011 = "38_1304523757.895" 
    $P10012 = $P10011."get_lexinfo"()
    $P10012."finish_static_lexpad"()
    .const 'Sub' $P10013 = "38_1304523757.895" 
    $P10014 = $P10013."get_lexinfo"()
    nqp_get_sc_object $P10015, "1304523744.097", 15
    $P10014."set_static_lexpad_value"("$?CLASS", $P10015)
    .const 'Sub' $P10016 = "38_1304523757.895" 
    $P10017 = $P10016."get_lexinfo"()
    $P10017."finish_static_lexpad"()
    nqp_get_sc_object $P10018, "1304523744.097", 375
    .const 'Sub' $P10019 = "412_1304523757.895" 
    assign $P10018, $P10019
    nqp_get_sc_object $P10020, "1304523744.097", 376
    .const 'Sub' $P10021 = "414_1304523757.895" 
    assign $P10020, $P10021
    nqp_get_sc_object $P10022, "1304523744.097", 377
    .const 'Sub' $P10023 = "415_1304523757.895" 
    assign $P10022, $P10023
    nqp_get_sc_object $P10024, "1304523744.097", 378
    .const 'Sub' $P10025 = "416_1304523757.895" 
    assign $P10024, $P10025
    nqp_get_sc_object $P10026, "1304523744.097", 379
    .const 'Sub' $P10027 = "417_1304523757.895" 
    assign $P10026, $P10027
    nqp_get_sc_object $P10028, "1304523744.097", 380
    .const 'Sub' $P10029 = "419_1304523757.895" 
    assign $P10028, $P10029
    nqp_get_sc_object $P10030, "1304523744.097", 381
    .const 'Sub' $P10031 = "420_1304523757.895" 
    assign $P10030, $P10031
    nqp_get_sc_object $P10032, "1304523744.097", 382
    .const 'Sub' $P10033 = "421_1304523757.895" 
    assign $P10032, $P10033
    nqp_get_sc_object $P10034, "1304523744.097", 383
    .const 'Sub' $P10035 = "422_1304523757.895" 
    assign $P10034, $P10035
    nqp_get_sc_object $P10036, "1304523744.097", 384
    .const 'Sub' $P10037 = "424_1304523757.895" 
    assign $P10036, $P10037
    nqp_get_sc_object $P10038, "1304523744.097", 385
    .const 'Sub' $P10039 = "425_1304523757.895" 
    assign $P10038, $P10039
    nqp_get_sc_object $P10040, "1304523744.097", 386
    .const 'Sub' $P10041 = "427_1304523757.895" 
    assign $P10040, $P10041
    nqp_get_sc_object $P10042, "1304523744.097", 387
    .const 'Sub' $P10043 = "428_1304523757.895" 
    assign $P10042, $P10043
    nqp_get_sc_object $P10044, "1304523744.097", 388
    .const 'Sub' $P10045 = "429_1304523757.895" 
    assign $P10044, $P10045
    nqp_get_sc_object $P10046, "1304523744.097", 389
    .const 'Sub' $P10047 = "430_1304523757.895" 
    assign $P10046, $P10047
    nqp_get_sc_object $P10048, "1304523744.097", 390
    .const 'Sub' $P10049 = "431_1304523757.895" 
    assign $P10048, $P10049
    .const 'Sub' $P10050 = "411_1304523757.895" 
    $P10051 = $P10050."get_lexinfo"()
    nqp_get_sc_object $P10052, "1304523744.097", 374
    $P10051."set_static_lexpad_value"("$?PACKAGE", $P10052)
    .const 'Sub' $P10053 = "411_1304523757.895" 
    $P10054 = $P10053."get_lexinfo"()
    $P10054."finish_static_lexpad"()
    .const 'Sub' $P10055 = "411_1304523757.895" 
    $P10056 = $P10055."get_lexinfo"()
    nqp_get_sc_object $P10057, "1304523744.097", 374
    $P10056."set_static_lexpad_value"("$?CLASS", $P10057)
    .const 'Sub' $P10058 = "411_1304523757.895" 
    $P10059 = $P10058."get_lexinfo"()
    $P10059."finish_static_lexpad"()
    nqp_get_sc_object $P10060, "1304523744.097", 392
    .const 'Sub' $P10061 = "459_1304523757.895" 
    assign $P10060, $P10061
    nqp_get_sc_object $P10062, "1304523744.097", 393
    .const 'Sub' $P10063 = "460_1304523757.895" 
    assign $P10062, $P10063
    nqp_get_sc_object $P10064, "1304523744.097", 394
    .const 'Sub' $P10065 = "461_1304523757.895" 
    assign $P10064, $P10065
    nqp_get_sc_object $P10066, "1304523744.097", 395
    .const 'Sub' $P10067 = "462_1304523757.895" 
    assign $P10066, $P10067
    nqp_get_sc_object $P10068, "1304523744.097", 396
    .const 'Sub' $P10069 = "464_1304523757.895" 
    assign $P10068, $P10069
    nqp_get_sc_object $P10070, "1304523744.097", 397
    .const 'Sub' $P10071 = "466_1304523757.895" 
    assign $P10070, $P10071
    nqp_get_sc_object $P10072, "1304523744.097", 398
    .const 'Sub' $P10073 = "467_1304523757.895" 
    assign $P10072, $P10073
    nqp_get_sc_object $P10074, "1304523744.097", 399
    .const 'Sub' $P10075 = "468_1304523757.895" 
    assign $P10074, $P10075
    nqp_get_sc_object $P10076, "1304523744.097", 400
    .const 'Sub' $P10077 = "469_1304523757.895" 
    assign $P10076, $P10077
    nqp_get_sc_object $P10078, "1304523744.097", 401
    .const 'Sub' $P10079 = "471_1304523757.895" 
    assign $P10078, $P10079
    nqp_get_sc_object $P10080, "1304523744.097", 402
    .const 'Sub' $P10081 = "472_1304523757.895" 
    assign $P10080, $P10081
    nqp_get_sc_object $P10082, "1304523744.097", 403
    .const 'Sub' $P10083 = "474_1304523757.895" 
    assign $P10082, $P10083
    nqp_get_sc_object $P10084, "1304523744.097", 404
    .const 'Sub' $P10085 = "475_1304523757.895" 
    assign $P10084, $P10085
    nqp_get_sc_object $P10086, "1304523744.097", 405
    .const 'Sub' $P10087 = "476_1304523757.895" 
    assign $P10086, $P10087
    nqp_get_sc_object $P10088, "1304523744.097", 406
    .const 'Sub' $P10089 = "477_1304523757.895" 
    assign $P10088, $P10089
    nqp_get_sc_object $P10090, "1304523744.097", 407
    .const 'Sub' $P10091 = "479_1304523757.895" 
    assign $P10090, $P10091
    nqp_get_sc_object $P10092, "1304523744.097", 408
    .const 'Sub' $P10093 = "480_1304523757.895" 
    assign $P10092, $P10093
    nqp_get_sc_object $P10094, "1304523744.097", 409
    .const 'Sub' $P10095 = "481_1304523757.895" 
    assign $P10094, $P10095
    nqp_get_sc_object $P10096, "1304523744.097", 410
    .const 'Sub' $P10097 = "482_1304523757.895" 
    assign $P10096, $P10097
    nqp_get_sc_object $P10098, "1304523744.097", 411
    .const 'Sub' $P10099 = "483_1304523757.895" 
    assign $P10098, $P10099
    nqp_get_sc_object $P10100, "1304523744.097", 412
    .const 'Sub' $P10101 = "484_1304523757.895" 
    assign $P10100, $P10101
    nqp_get_sc_object $P10102, "1304523744.097", 413
    .const 'Sub' $P10103 = "485_1304523757.895" 
    assign $P10102, $P10103
    nqp_get_sc_object $P10104, "1304523744.097", 414
    .const 'Sub' $P10105 = "486_1304523757.895" 
    assign $P10104, $P10105
    nqp_get_sc_object $P10106, "1304523744.097", 415
    .const 'Sub' $P10107 = "487_1304523757.895" 
    assign $P10106, $P10107
    nqp_get_sc_object $P10108, "1304523744.097", 416
    .const 'Sub' $P10109 = "488_1304523757.895" 
    assign $P10108, $P10109
    nqp_get_sc_object $P10110, "1304523744.097", 417
    .const 'Sub' $P10111 = "489_1304523757.895" 
    assign $P10110, $P10111
    nqp_get_sc_object $P10112, "1304523744.097", 418
    .const 'Sub' $P10113 = "490_1304523757.895" 
    assign $P10112, $P10113
    nqp_get_sc_object $P10114, "1304523744.097", 419
    .const 'Sub' $P10115 = "491_1304523757.895" 
    assign $P10114, $P10115
    nqp_get_sc_object $P10116, "1304523744.097", 420
    .const 'Sub' $P10117 = "492_1304523757.895" 
    assign $P10116, $P10117
    nqp_get_sc_object $P10118, "1304523744.097", 421
    .const 'Sub' $P10119 = "493_1304523757.895" 
    assign $P10118, $P10119
    nqp_get_sc_object $P10120, "1304523744.097", 422
    .const 'Sub' $P10121 = "494_1304523757.895" 
    assign $P10120, $P10121
    nqp_get_sc_object $P10122, "1304523744.097", 423
    .const 'Sub' $P10123 = "495_1304523757.895" 
    assign $P10122, $P10123
    nqp_get_sc_object $P10124, "1304523744.097", 424
    .const 'Sub' $P10125 = "496_1304523757.895" 
    assign $P10124, $P10125
    nqp_get_sc_object $P10126, "1304523744.097", 425
    .const 'Sub' $P10127 = "497_1304523757.895" 
    assign $P10126, $P10127
    nqp_get_sc_object $P10128, "1304523744.097", 426
    .const 'Sub' $P10129 = "498_1304523757.895" 
    assign $P10128, $P10129
    nqp_get_sc_object $P10130, "1304523744.097", 427
    .const 'Sub' $P10131 = "499_1304523757.895" 
    assign $P10130, $P10131
    nqp_get_sc_object $P10132, "1304523744.097", 428
    .const 'Sub' $P10133 = "500_1304523757.895" 
    assign $P10132, $P10133
    nqp_get_sc_object $P10134, "1304523744.097", 429
    .const 'Sub' $P10135 = "501_1304523757.895" 
    assign $P10134, $P10135
    nqp_get_sc_object $P10136, "1304523744.097", 430
    .const 'Sub' $P10137 = "502_1304523757.895" 
    assign $P10136, $P10137
    nqp_get_sc_object $P10138, "1304523744.097", 431
    .const 'Sub' $P10139 = "503_1304523757.895" 
    assign $P10138, $P10139
    nqp_get_sc_object $P10140, "1304523744.097", 432
    .const 'Sub' $P10141 = "509_1304523757.895" 
    assign $P10140, $P10141
    nqp_get_sc_object $P10142, "1304523744.097", 433
    .const 'Sub' $P10143 = "510_1304523757.895" 
    assign $P10142, $P10143
    nqp_get_sc_object $P10144, "1304523744.097", 434
    .const 'Sub' $P10145 = "511_1304523757.895" 
    assign $P10144, $P10145
    nqp_get_sc_object $P10146, "1304523744.097", 435
    .const 'Sub' $P10147 = "512_1304523757.895" 
    assign $P10146, $P10147
    nqp_get_sc_object $P10148, "1304523744.097", 436
    .const 'Sub' $P10149 = "513_1304523757.895" 
    assign $P10148, $P10149
    nqp_get_sc_object $P10150, "1304523744.097", 437
    .const 'Sub' $P10151 = "514_1304523757.895" 
    assign $P10150, $P10151
    nqp_get_sc_object $P10152, "1304523744.097", 438
    .const 'Sub' $P10153 = "515_1304523757.895" 
    assign $P10152, $P10153
    nqp_get_sc_object $P10154, "1304523744.097", 439
    .const 'Sub' $P10155 = "521_1304523757.895" 
    assign $P10154, $P10155
    nqp_get_sc_object $P10156, "1304523744.097", 440
    .const 'Sub' $P10157 = "522_1304523757.895" 
    assign $P10156, $P10157
    nqp_get_sc_object $P10158, "1304523744.097", 441
    .const 'Sub' $P10159 = "523_1304523757.895" 
    assign $P10158, $P10159
    nqp_get_sc_object $P10160, "1304523744.097", 442
    .const 'Sub' $P10161 = "524_1304523757.895" 
    assign $P10160, $P10161
    nqp_get_sc_object $P10162, "1304523744.097", 443
    .const 'Sub' $P10163 = "525_1304523757.895" 
    assign $P10162, $P10163
    nqp_get_sc_object $P10164, "1304523744.097", 444
    .const 'Sub' $P10165 = "526_1304523757.895" 
    assign $P10164, $P10165
    nqp_get_sc_object $P10166, "1304523744.097", 445
    .const 'Sub' $P10167 = "527_1304523757.895" 
    assign $P10166, $P10167
    nqp_get_sc_object $P10168, "1304523744.097", 446
    .const 'Sub' $P10169 = "528_1304523757.895" 
    assign $P10168, $P10169
    nqp_get_sc_object $P10170, "1304523744.097", 447
    .const 'Sub' $P10171 = "529_1304523757.895" 
    assign $P10170, $P10171
    nqp_get_sc_object $P10172, "1304523744.097", 448
    .const 'Sub' $P10173 = "531_1304523757.895" 
    assign $P10172, $P10173
    nqp_get_sc_object $P10174, "1304523744.097", 449
    .const 'Sub' $P10175 = "532_1304523757.895" 
    assign $P10174, $P10175
    nqp_get_sc_object $P10176, "1304523744.097", 450
    .const 'Sub' $P10177 = "533_1304523757.895" 
    assign $P10176, $P10177
    nqp_get_sc_object $P10178, "1304523744.097", 451
    .const 'Sub' $P10179 = "540_1304523757.895" 
    assign $P10178, $P10179
    nqp_get_sc_object $P10180, "1304523744.097", 452
    .const 'Sub' $P10181 = "543_1304523757.895" 
    assign $P10180, $P10181
    nqp_get_sc_object $P10182, "1304523744.097", 453
    .const 'Sub' $P10183 = "546_1304523757.895" 
    assign $P10182, $P10183
    nqp_get_sc_object $P10184, "1304523744.097", 454
    .const 'Sub' $P10185 = "547_1304523757.895" 
    assign $P10184, $P10185
    nqp_get_sc_object $P10186, "1304523744.097", 455
    .const 'Sub' $P10187 = "548_1304523757.895" 
    assign $P10186, $P10187
    nqp_get_sc_object $P10188, "1304523744.097", 456
    .const 'Sub' $P10189 = "549_1304523757.895" 
    assign $P10188, $P10189
    nqp_get_sc_object $P10190, "1304523744.097", 457
    .const 'Sub' $P10191 = "551_1304523757.895" 
    assign $P10190, $P10191
    nqp_get_sc_object $P10192, "1304523744.097", 458
    .const 'Sub' $P10193 = "552_1304523757.895" 
    assign $P10192, $P10193
    nqp_get_sc_object $P10194, "1304523744.097", 459
    .const 'Sub' $P10195 = "555_1304523757.895" 
    assign $P10194, $P10195
    nqp_get_sc_object $P10196, "1304523744.097", 460
    .const 'Sub' $P10197 = "560_1304523757.895" 
    assign $P10196, $P10197
    nqp_get_sc_object $P10198, "1304523744.097", 461
    .const 'Sub' $P10199 = "561_1304523757.895" 
    assign $P10198, $P10199
    nqp_get_sc_object $P10200, "1304523744.097", 462
    .const 'Sub' $P10201 = "562_1304523757.895" 
    assign $P10200, $P10201
    nqp_get_sc_object $P10202, "1304523744.097", 463
    .const 'Sub' $P10203 = "563_1304523757.895" 
    assign $P10202, $P10203
    nqp_get_sc_object $P10204, "1304523744.097", 464
    .const 'Sub' $P10205 = "565_1304523757.895" 
    assign $P10204, $P10205
    nqp_get_sc_object $P10206, "1304523744.097", 465
    .const 'Sub' $P10207 = "566_1304523757.895" 
    assign $P10206, $P10207
    nqp_get_sc_object $P10208, "1304523744.097", 466
    .const 'Sub' $P10209 = "567_1304523757.895" 
    assign $P10208, $P10209
    nqp_get_sc_object $P10210, "1304523744.097", 467
    .const 'Sub' $P10211 = "568_1304523757.895" 
    assign $P10210, $P10211
    nqp_get_sc_object $P10212, "1304523744.097", 468
    .const 'Sub' $P10213 = "571_1304523757.895" 
    assign $P10212, $P10213
    nqp_get_sc_object $P10214, "1304523744.097", 469
    .const 'Sub' $P10215 = "572_1304523757.895" 
    assign $P10214, $P10215
    nqp_get_sc_object $P10216, "1304523744.097", 470
    .const 'Sub' $P10217 = "573_1304523757.895" 
    assign $P10216, $P10217
    nqp_get_sc_object $P10218, "1304523744.097", 471
    .const 'Sub' $P10219 = "574_1304523757.895" 
    assign $P10218, $P10219
    nqp_get_sc_object $P10220, "1304523744.097", 472
    .const 'Sub' $P10221 = "575_1304523757.895" 
    assign $P10220, $P10221
    nqp_get_sc_object $P10222, "1304523744.097", 473
    .const 'Sub' $P10223 = "576_1304523757.895" 
    assign $P10222, $P10223
    nqp_get_sc_object $P10224, "1304523744.097", 474
    .const 'Sub' $P10225 = "577_1304523757.895" 
    assign $P10224, $P10225
    nqp_get_sc_object $P10226, "1304523744.097", 475
    .const 'Sub' $P10227 = "579_1304523757.895" 
    assign $P10226, $P10227
    nqp_get_sc_object $P10228, "1304523744.097", 476
    .const 'Sub' $P10229 = "580_1304523757.895" 
    assign $P10228, $P10229
    nqp_get_sc_object $P10230, "1304523744.097", 477
    .const 'Sub' $P10231 = "581_1304523757.895" 
    assign $P10230, $P10231
    nqp_get_sc_object $P10232, "1304523744.097", 478
    .const 'Sub' $P10233 = "582_1304523757.895" 
    assign $P10232, $P10233
    nqp_get_sc_object $P10234, "1304523744.097", 479
    .const 'Sub' $P10235 = "583_1304523757.895" 
    assign $P10234, $P10235
    nqp_get_sc_object $P10236, "1304523744.097", 480
    .const 'Sub' $P10237 = "584_1304523757.895" 
    assign $P10236, $P10237
    nqp_get_sc_object $P10238, "1304523744.097", 481
    .const 'Sub' $P10239 = "585_1304523757.895" 
    assign $P10238, $P10239
    nqp_get_sc_object $P10240, "1304523744.097", 482
    .const 'Sub' $P10241 = "586_1304523757.895" 
    assign $P10240, $P10241
    nqp_get_sc_object $P10242, "1304523744.097", 483
    .const 'Sub' $P10243 = "587_1304523757.895" 
    assign $P10242, $P10243
    nqp_get_sc_object $P10244, "1304523744.097", 484
    .const 'Sub' $P10245 = "588_1304523757.895" 
    assign $P10244, $P10245
    nqp_get_sc_object $P10246, "1304523744.097", 485
    .const 'Sub' $P10247 = "589_1304523757.895" 
    assign $P10246, $P10247
    nqp_get_sc_object $P10248, "1304523744.097", 486
    .const 'Sub' $P10249 = "590_1304523757.895" 
    assign $P10248, $P10249
    nqp_get_sc_object $P10250, "1304523744.097", 487
    .const 'Sub' $P10251 = "591_1304523757.895" 
    assign $P10250, $P10251
    nqp_get_sc_object $P10252, "1304523744.097", 488
    .const 'Sub' $P10253 = "592_1304523757.895" 
    assign $P10252, $P10253
    nqp_get_sc_object $P10254, "1304523744.097", 489
    .const 'Sub' $P10255 = "593_1304523757.895" 
    assign $P10254, $P10255
    nqp_get_sc_object $P10256, "1304523744.097", 490
    .const 'Sub' $P10257 = "594_1304523757.895" 
    assign $P10256, $P10257
    nqp_get_sc_object $P10258, "1304523744.097", 491
    .const 'Sub' $P10259 = "595_1304523757.895" 
    assign $P10258, $P10259
    nqp_get_sc_object $P10260, "1304523744.097", 492
    .const 'Sub' $P10261 = "596_1304523757.895" 
    assign $P10260, $P10261
    nqp_get_sc_object $P10262, "1304523744.097", 493
    .const 'Sub' $P10263 = "597_1304523757.895" 
    assign $P10262, $P10263
    nqp_get_sc_object $P10264, "1304523744.097", 494
    .const 'Sub' $P10265 = "598_1304523757.895" 
    assign $P10264, $P10265
    nqp_get_sc_object $P10266, "1304523744.097", 495
    .const 'Sub' $P10267 = "599_1304523757.895" 
    assign $P10266, $P10267
    nqp_get_sc_object $P10268, "1304523744.097", 496
    .const 'Sub' $P10269 = "600_1304523757.895" 
    assign $P10268, $P10269
    nqp_get_sc_object $P10270, "1304523744.097", 497
    .const 'Sub' $P10271 = "601_1304523757.895" 
    assign $P10270, $P10271
    nqp_get_sc_object $P10272, "1304523744.097", 498
    .const 'Sub' $P10273 = "602_1304523757.895" 
    assign $P10272, $P10273
    nqp_get_sc_object $P10274, "1304523744.097", 499
    .const 'Sub' $P10275 = "603_1304523757.895" 
    assign $P10274, $P10275
    nqp_get_sc_object $P10276, "1304523744.097", 500
    .const 'Sub' $P10277 = "604_1304523757.895" 
    assign $P10276, $P10277
    nqp_get_sc_object $P10278, "1304523744.097", 501
    .const 'Sub' $P10279 = "605_1304523757.895" 
    assign $P10278, $P10279
    .const 'Sub' $P10280 = "432_1304523757.895" 
    $P10281 = $P10280."get_lexinfo"()
    nqp_get_sc_object $P10282, "1304523744.097", 391
    $P10281."set_static_lexpad_value"("$?PACKAGE", $P10282)
    .const 'Sub' $P10283 = "432_1304523757.895" 
    $P10284 = $P10283."get_lexinfo"()
    $P10284."finish_static_lexpad"()
    .const 'Sub' $P10285 = "432_1304523757.895" 
    $P10286 = $P10285."get_lexinfo"()
    nqp_get_sc_object $P10287, "1304523744.097", 391
    $P10286."set_static_lexpad_value"("$?CLASS", $P10287)
    .const 'Sub' $P10288 = "432_1304523757.895" 
    $P10289 = $P10288."get_lexinfo"()
    $P10289."finish_static_lexpad"()
    nqp_get_sc_object $P10290, "1304523744.097", 503
    .const 'Sub' $P10291 = "608_1304523757.895" 
    assign $P10290, $P10291
    nqp_get_sc_object $P10292, "1304523744.097", 504
    .const 'Sub' $P10293 = "609_1304523757.895" 
    assign $P10292, $P10293
    nqp_get_sc_object $P10294, "1304523744.097", 505
    .const 'Sub' $P10295 = "610_1304523757.895" 
    assign $P10294, $P10295
    nqp_get_sc_object $P10296, "1304523744.097", 506
    .const 'Sub' $P10297 = "611_1304523757.895" 
    assign $P10296, $P10297
    nqp_get_sc_object $P10298, "1304523744.097", 507
    .const 'Sub' $P10299 = "612_1304523757.895" 
    assign $P10298, $P10299
    nqp_get_sc_object $P10300, "1304523744.097", 508
    .const 'Sub' $P10301 = "613_1304523757.895" 
    assign $P10300, $P10301
    nqp_get_sc_object $P10302, "1304523744.097", 509
    .const 'Sub' $P10303 = "614_1304523757.895" 
    assign $P10302, $P10303
    .const 'Sub' $P10304 = "607_1304523757.895" 
    $P10305 = $P10304."get_lexinfo"()
    nqp_get_sc_object $P10306, "1304523744.097", 502
    $P10305."set_static_lexpad_value"("$?PACKAGE", $P10306)
    .const 'Sub' $P10307 = "607_1304523757.895" 
    $P10308 = $P10307."get_lexinfo"()
    $P10308."finish_static_lexpad"()
    .const 'Sub' $P10309 = "607_1304523757.895" 
    $P10310 = $P10309."get_lexinfo"()
    nqp_get_sc_object $P10311, "1304523744.097", 502
    $P10310."set_static_lexpad_value"("$?CLASS", $P10311)
    .const 'Sub' $P10312 = "607_1304523757.895" 
    $P10313 = $P10312."get_lexinfo"()
    $P10313."finish_static_lexpad"()
    .const 'Sub' $P10314 = "615_1304523757.895" 
    $P10315 = $P10314."get_lexinfo"()
    nqp_get_sc_object $P10316, "1304523744.097", 510
    $P10315."set_static_lexpad_value"("$?PACKAGE", $P10316)
    .const 'Sub' $P10317 = "615_1304523757.895" 
    $P10318 = $P10317."get_lexinfo"()
    $P10318."finish_static_lexpad"()
    .const 'Sub' $P10319 = "615_1304523757.895" 
    $P10320 = $P10319."get_lexinfo"()
    nqp_get_sc_object $P10321, "1304523744.097", 510
    $P10320."set_static_lexpad_value"("$?CLASS", $P10321)
    .const 'Sub' $P10322 = "615_1304523757.895" 
    $P10323 = $P10322."get_lexinfo"()
    $P10323."finish_static_lexpad"()
    goto if_7067_end
  if_7067:
    nqp_dynop_setup 
    getinterp $P7070
    get_class $P7071, "LexPad"
    get_class $P7072, "NQPLexPad"
    $P7070."hll_map"($P7071, $P7072)
    nqp_create_sc $P7073, "1304523744.097"
    .local pmc cur_sc
    set cur_sc, $P7073
    nqp_get_sc_object $P7074, "__6MODEL_CORE__", 0
    $P7075 = $P7074."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7075, cur_sc
    nqp_set_sc_object "1304523744.097", 0, $P7075
    .const 'Sub' $P7076 = "10_1304523757.895" 
    $P7077 = $P7076."get_lexinfo"()
    nqp_get_sc_object $P7078, "1304523744.097", 0
    $P7077."set_static_lexpad_value"("GLOBALish", $P7078)
    .const 'Sub' $P7079 = "10_1304523757.895" 
    $P7080 = $P7079."get_lexinfo"()
    $P7080."finish_static_lexpad"()
    .const 'Sub' $P7081 = "10_1304523757.895" 
    $P7082 = $P7081."get_lexinfo"()
    nqp_get_sc_object $P7083, "1304523744.097", 0
    $P7082."set_static_lexpad_value"("$?PACKAGE", $P7083)
    .const 'Sub' $P7084 = "10_1304523757.895" 
    $P7085 = $P7084."get_lexinfo"()
    $P7085."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7086, "ModuleLoader"
    $P7087 = $P7086."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7087)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7088, "ModuleLoader"
    nqp_get_sc_object $P7089, "1304523744.097", 0
    $P7088."load_module"("NQPRegex", $P7089)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7090, "ModuleLoader"
    nqp_get_sc_object $P7091, "1304523744.097", 0
    $P7090."load_module"("NQPP6Regex", $P7091)
    nqp_get_sc_object $P7092, "1304523719.327", 41
    $P7093 = $P7092."new_type"("NQP::SymbolTable" :named("name"))
    nqp_set_sc_for_object $P7093, cur_sc
    nqp_set_sc_object "1304523744.097", 1, $P7093
    nqp_get_sc_object $P7094, "1304523744.097", 1
    nqp_get_sc_object $P7095, "1304523744.097", 0
    nqp_get_package_through_who $P7096, $P7095, "NQP"
    get_who $P7097, $P7096
    set $P7097["SymbolTable"], $P7094
    nqp_get_sc_object $P7098, "1304523744.097", 1
    get_how $P7099, $P7098
    nqp_get_sc_object $P7100, "1304523744.097", 1
    .const 'Sub' $P7101 = "13_1304523757.895" 
    $P7099."add_method"($P7100, "load_setting", $P7101)
    nqp_get_sc_object $P7102, "1304523744.097", 1
    get_how $P7103, $P7102
    nqp_get_sc_object $P7104, "1304523744.097", 1
    .const 'Sub' $P7105 = "15_1304523757.895" 
    $P7103."add_method"($P7104, "load_module", $P7105)
    nqp_get_sc_object $P7106, "1304523744.097", 1
    get_how $P7107, $P7106
    nqp_get_sc_object $P7108, "1304523744.097", 1
    .const 'Sub' $P7109 = "16_1304523757.895" 
    $P7107."add_method"($P7108, "install_package_symbol", $P7109)
    nqp_get_sc_object $P7110, "1304523744.097", 1
    get_how $P7111, $P7110
    nqp_get_sc_object $P7112, "1304523744.097", 1
    .const 'Sub' $P7113 = "19_1304523757.895" 
    $P7111."add_method"($P7112, "install_lexical_symbol", $P7113)
    nqp_get_sc_object $P7114, "1304523744.097", 1
    get_how $P7115, $P7114
    nqp_get_sc_object $P7116, "1304523744.097", 1
    .const 'Sub' $P7117 = "20_1304523757.895" 
    $P7115."add_method"($P7116, "install_package_routine", $P7117)
    nqp_get_sc_object $P7118, "1304523744.097", 1
    get_how $P7119, $P7118
    nqp_get_sc_object $P7120, "1304523744.097", 1
    .const 'Sub' $P7121 = "21_1304523757.895" 
    $P7119."add_method"($P7120, "pkg_create_mo", $P7121)
    nqp_get_sc_object $P7122, "1304523744.097", 1
    get_how $P7123, $P7122
    nqp_get_sc_object $P7124, "1304523744.097", 1
    .const 'Sub' $P7125 = "22_1304523757.895" 
    $P7123."add_method"($P7124, "pkg_add_attribute", $P7125)
    nqp_get_sc_object $P7126, "1304523744.097", 1
    get_how $P7127, $P7126
    nqp_get_sc_object $P7128, "1304523744.097", 1
    .const 'Sub' $P7129 = "26_1304523757.895" 
    $P7127."add_method"($P7128, "pkg_add_method", $P7129)
    nqp_get_sc_object $P7130, "1304523744.097", 1
    get_how $P7131, $P7130
    nqp_get_sc_object $P7132, "1304523744.097", 1
    .const 'Sub' $P7133 = "28_1304523757.895" 
    $P7131."add_method"($P7132, "set_routine_signature", $P7133)
    nqp_get_sc_object $P7134, "1304523744.097", 1
    get_how $P7135, $P7134
    nqp_get_sc_object $P7136, "1304523744.097", 1
    .const 'Sub' $P7137 = "29_1304523757.895" 
    $P7135."add_method"($P7136, "pkg_set_body_block", $P7137)
    nqp_get_sc_object $P7138, "1304523744.097", 1
    get_how $P7139, $P7138
    nqp_get_sc_object $P7140, "1304523744.097", 1
    .const 'Sub' $P7141 = "34_1304523757.895" 
    $P7139."add_method"($P7140, "pkg_add_parent_or_role", $P7141)
    nqp_get_sc_object $P7142, "1304523744.097", 1
    get_how $P7143, $P7142
    nqp_get_sc_object $P7144, "1304523744.097", 1
    .const 'Sub' $P7145 = "35_1304523757.895" 
    $P7143."add_method"($P7144, "pkg_compose", $P7145)
    nqp_get_sc_object $P7146, "1304523744.097", 1
    get_how $P7147, $P7146
    nqp_get_sc_object $P7148, "1304523744.097", 1
    .const 'Sub' $P7149 = "36_1304523757.895" 
    $P7147."add_method"($P7148, "to_past", $P7149)
    .const 'Sub' $P7150 = "12_1304523757.895" 
    $P7151 = $P7150."get_lexinfo"()
    nqp_get_sc_object $P7152, "1304523744.097", 1
    $P7151."set_static_lexpad_value"("$?PACKAGE", $P7152)
    .const 'Sub' $P7153 = "12_1304523757.895" 
    $P7154 = $P7153."get_lexinfo"()
    $P7154."finish_static_lexpad"()
    .const 'Sub' $P7155 = "12_1304523757.895" 
    $P7156 = $P7155."get_lexinfo"()
    nqp_get_sc_object $P7157, "1304523744.097", 1
    $P7156."set_static_lexpad_value"("$?CLASS", $P7157)
    .const 'Sub' $P7158 = "12_1304523757.895" 
    $P7159 = $P7158."get_lexinfo"()
    $P7159."finish_static_lexpad"()
    nqp_get_sc_object $P7160, "1304523744.097", 1
    get_how $P7161, $P7160
    nqp_get_sc_object $P7162, "1304523744.097", 1
    nqp_get_sc_object $P7163, "1304523727.177", 191
    $P7161."add_parent"($P7162, $P7163)
    nqp_get_sc_object $P7164, "1304523744.097", 1
    get_how $P7165, $P7164
    nqp_get_sc_object $P7166, "1304523744.097", 1
    $P7165."compose"($P7166)
    nqp_get_sc_object $P7167, "1304523719.327", 41
    $P7168 = $P7167."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7168, cur_sc
    nqp_set_sc_object "1304523744.097", 15, $P7168
    nqp_get_sc_object $P7169, "1304523744.097", 15
    nqp_get_sc_object $P7170, "1304523744.097", 0
    nqp_get_package_through_who $P7171, $P7170, "NQP"
    get_who $P7172, $P7171
    set $P7172["Grammar"], $P7169
    nqp_get_sc_object $P7173, "1304523744.097", 15
    get_how $P7174, $P7173
    nqp_get_sc_object $P7175, "1304523744.097", 15
    .const 'Sub' $P7176 = "39_1304523757.895" 
    $P7174."add_method"($P7175, "TOP", $P7176)
    nqp_get_sc_object $P7177, "1304523744.097", 15
    get_how $P7178, $P7177
    nqp_get_sc_object $P7179, "1304523744.097", 15
    .const 'Sub' $P7180 = "40_1304523757.895" 
    $P7178."add_method"($P7179, "identifier", $P7180)
    nqp_get_sc_object $P7181, "1304523744.097", 15
    get_how $P7182, $P7181
    nqp_get_sc_object $P7183, "1304523744.097", 15
    .const 'Sub' $P7184 = "41_1304523757.895" 
    $P7182."add_method"($P7183, "!PREFIX__identifier", $P7184)
    nqp_get_sc_object $P7185, "1304523744.097", 15
    get_how $P7186, $P7185
    nqp_get_sc_object $P7187, "1304523744.097", 15
    .const 'Sub' $P7188 = "42_1304523757.895" 
    $P7186."add_method"($P7187, "name", $P7188)
    nqp_get_sc_object $P7189, "1304523744.097", 15
    get_how $P7190, $P7189
    nqp_get_sc_object $P7191, "1304523744.097", 15
    .const 'Sub' $P7192 = "43_1304523757.895" 
    $P7190."add_method"($P7191, "!PREFIX__name", $P7192)
    nqp_get_sc_object $P7193, "1304523744.097", 15
    get_how $P7194, $P7193
    nqp_get_sc_object $P7195, "1304523744.097", 15
    .const 'Sub' $P7196 = "44_1304523757.895" 
    $P7194."add_method"($P7195, "deflongname", $P7196)
    nqp_get_sc_object $P7197, "1304523744.097", 15
    get_how $P7198, $P7197
    nqp_get_sc_object $P7199, "1304523744.097", 15
    .const 'Sub' $P7200 = "45_1304523757.895" 
    $P7198."add_method"($P7199, "!PREFIX__deflongname", $P7200)
    nqp_get_sc_object $P7201, "1304523744.097", 15
    get_how $P7202, $P7201
    nqp_get_sc_object $P7203, "1304523744.097", 15
    .const 'Sub' $P7204 = "46_1304523757.895" 
    $P7202."add_method"($P7203, "ENDSTMT", $P7204)
    nqp_get_sc_object $P7205, "1304523744.097", 15
    get_how $P7206, $P7205
    nqp_get_sc_object $P7207, "1304523744.097", 15
    .const 'Sub' $P7208 = "47_1304523757.895" 
    $P7206."add_method"($P7207, "!PREFIX__ENDSTMT", $P7208)
    nqp_get_sc_object $P7209, "1304523744.097", 15
    get_how $P7210, $P7209
    nqp_get_sc_object $P7211, "1304523744.097", 15
    .const 'Sub' $P7212 = "48_1304523757.895" 
    $P7210."add_method"($P7211, "ws", $P7212)
    nqp_get_sc_object $P7213, "1304523744.097", 15
    get_how $P7214, $P7213
    nqp_get_sc_object $P7215, "1304523744.097", 15
    .const 'Sub' $P7216 = "49_1304523757.895" 
    $P7214."add_method"($P7215, "!PREFIX__ws", $P7216)
    nqp_get_sc_object $P7217, "1304523744.097", 15
    get_how $P7218, $P7217
    nqp_get_sc_object $P7219, "1304523744.097", 15
    .const 'Sub' $P7220 = "50_1304523757.895" 
    $P7218."add_method"($P7219, "unv", $P7220)
    nqp_get_sc_object $P7221, "1304523744.097", 15
    get_how $P7222, $P7221
    nqp_get_sc_object $P7223, "1304523744.097", 15
    .const 'Sub' $P7224 = "52_1304523757.895" 
    $P7222."add_method"($P7223, "!PREFIX__unv", $P7224)
    nqp_get_sc_object $P7225, "1304523744.097", 15
    get_how $P7226, $P7225
    nqp_get_sc_object $P7227, "1304523744.097", 15
    .const 'Sub' $P7228 = "53_1304523757.895" 
    $P7226."add_method"($P7227, "pod_comment", $P7228)
    nqp_get_sc_object $P7229, "1304523744.097", 15
    get_how $P7230, $P7229
    nqp_get_sc_object $P7231, "1304523744.097", 15
    .const 'Sub' $P7232 = "55_1304523757.895" 
    $P7230."add_method"($P7231, "!PREFIX__pod_comment", $P7232)
    nqp_get_sc_object $P7233, "1304523744.097", 15
    get_how $P7234, $P7233
    nqp_get_sc_object $P7235, "1304523744.097", 15
    .const 'Sub' $P7236 = "56_1304523757.895" 
    $P7234."add_method"($P7235, "comp_unit", $P7236)
    nqp_get_sc_object $P7237, "1304523744.097", 15
    get_how $P7238, $P7237
    nqp_get_sc_object $P7239, "1304523744.097", 15
    .const 'Sub' $P7240 = "57_1304523757.895" 
    $P7238."add_method"($P7239, "!PREFIX__comp_unit", $P7240)
    nqp_get_sc_object $P7241, "1304523744.097", 15
    get_how $P7242, $P7241
    nqp_get_sc_object $P7243, "1304523744.097", 15
    .const 'Sub' $P7244 = "58_1304523757.895" 
    $P7242."add_method"($P7243, "statementlist", $P7244)
    nqp_get_sc_object $P7245, "1304523744.097", 15
    get_how $P7246, $P7245
    nqp_get_sc_object $P7247, "1304523744.097", 15
    .const 'Sub' $P7248 = "59_1304523757.895" 
    $P7246."add_method"($P7247, "!PREFIX__statementlist", $P7248)
    nqp_get_sc_object $P7249, "1304523744.097", 15
    get_how $P7250, $P7249
    nqp_get_sc_object $P7251, "1304523744.097", 15
    .const 'Sub' $P7252 = "60_1304523757.895" 
    $P7250."add_method"($P7251, "statement", $P7252)
    nqp_get_sc_object $P7253, "1304523744.097", 15
    get_how $P7254, $P7253
    nqp_get_sc_object $P7255, "1304523744.097", 15
    .const 'Sub' $P7256 = "62_1304523757.895" 
    $P7254."add_method"($P7255, "!PREFIX__statement", $P7256)
    nqp_get_sc_object $P7257, "1304523744.097", 15
    get_how $P7258, $P7257
    nqp_get_sc_object $P7259, "1304523744.097", 15
    .const 'Sub' $P7260 = "63_1304523757.895" 
    $P7258."add_method"($P7259, "eat_terminator", $P7260)
    nqp_get_sc_object $P7261, "1304523744.097", 15
    get_how $P7262, $P7261
    nqp_get_sc_object $P7263, "1304523744.097", 15
    .const 'Sub' $P7264 = "64_1304523757.895" 
    $P7262."add_method"($P7263, "!PREFIX__eat_terminator", $P7264)
    nqp_get_sc_object $P7265, "1304523744.097", 15
    get_how $P7266, $P7265
    nqp_get_sc_object $P7267, "1304523744.097", 15
    .const 'Sub' $P7268 = "65_1304523757.895" 
    $P7266."add_method"($P7267, "xblock", $P7268)
    nqp_get_sc_object $P7269, "1304523744.097", 15
    get_how $P7270, $P7269
    nqp_get_sc_object $P7271, "1304523744.097", 15
    .const 'Sub' $P7272 = "66_1304523757.895" 
    $P7270."add_method"($P7271, "!PREFIX__xblock", $P7272)
    nqp_get_sc_object $P7273, "1304523744.097", 15
    get_how $P7274, $P7273
    nqp_get_sc_object $P7275, "1304523744.097", 15
    .const 'Sub' $P7276 = "67_1304523757.895" 
    $P7274."add_method"($P7275, "pblock", $P7276)
    nqp_get_sc_object $P7277, "1304523744.097", 15
    get_how $P7278, $P7277
    nqp_get_sc_object $P7279, "1304523744.097", 15
    .const 'Sub' $P7280 = "68_1304523757.895" 
    $P7278."add_method"($P7279, "!PREFIX__pblock", $P7280)
    nqp_get_sc_object $P7281, "1304523744.097", 15
    get_how $P7282, $P7281
    nqp_get_sc_object $P7283, "1304523744.097", 15
    .const 'Sub' $P7284 = "69_1304523757.895" 
    $P7282."add_method"($P7283, "lambda", $P7284)
    nqp_get_sc_object $P7285, "1304523744.097", 15
    get_how $P7286, $P7285
    nqp_get_sc_object $P7287, "1304523744.097", 15
    .const 'Sub' $P7288 = "70_1304523757.895" 
    $P7286."add_method"($P7287, "!PREFIX__lambda", $P7288)
    nqp_get_sc_object $P7289, "1304523744.097", 15
    get_how $P7290, $P7289
    nqp_get_sc_object $P7291, "1304523744.097", 15
    .const 'Sub' $P7292 = "71_1304523757.895" 
    $P7290."add_method"($P7291, "block", $P7292)
    nqp_get_sc_object $P7293, "1304523744.097", 15
    get_how $P7294, $P7293
    nqp_get_sc_object $P7295, "1304523744.097", 15
    .const 'Sub' $P7296 = "72_1304523757.895" 
    $P7294."add_method"($P7295, "!PREFIX__block", $P7296)
    nqp_get_sc_object $P7297, "1304523744.097", 15
    get_how $P7298, $P7297
    nqp_get_sc_object $P7299, "1304523744.097", 15
    .const 'Sub' $P7300 = "73_1304523757.895" 
    $P7298."add_method"($P7299, "blockoid", $P7300)
    nqp_get_sc_object $P7301, "1304523744.097", 15
    get_how $P7302, $P7301
    nqp_get_sc_object $P7303, "1304523744.097", 15
    .const 'Sub' $P7304 = "74_1304523757.895" 
    $P7302."add_method"($P7303, "!PREFIX__blockoid", $P7304)
    nqp_get_sc_object $P7305, "1304523744.097", 15
    get_how $P7306, $P7305
    nqp_get_sc_object $P7307, "1304523744.097", 15
    .const 'Sub' $P7308 = "75_1304523757.895" 
    $P7306."add_method"($P7307, "newpad", $P7308)
    nqp_get_sc_object $P7309, "1304523744.097", 15
    get_how $P7310, $P7309
    nqp_get_sc_object $P7311, "1304523744.097", 15
    .const 'Sub' $P7312 = "76_1304523757.895" 
    $P7310."add_method"($P7311, "!PREFIX__newpad", $P7312)
    nqp_get_sc_object $P7313, "1304523744.097", 15
    get_how $P7314, $P7313
    nqp_get_sc_object $P7315, "1304523744.097", 15
    .const 'Sub' $P7316 = "77_1304523757.895" 
    $P7314."add_method"($P7315, "outerctx", $P7316)
    nqp_get_sc_object $P7317, "1304523744.097", 15
    get_how $P7318, $P7317
    nqp_get_sc_object $P7319, "1304523744.097", 15
    .const 'Sub' $P7320 = "78_1304523757.895" 
    $P7318."add_method"($P7319, "!PREFIX__outerctx", $P7320)
    nqp_get_sc_object $P7321, "1304523744.097", 15
    get_how $P7322, $P7321
    nqp_get_sc_object $P7323, "1304523744.097", 15
    .const 'Sub' $P7324 = "79_1304523757.895" 
    $P7322."add_method"($P7323, "GLOBALish", $P7324)
    nqp_get_sc_object $P7325, "1304523744.097", 15
    get_how $P7326, $P7325
    nqp_get_sc_object $P7327, "1304523744.097", 15
    .const 'Sub' $P7328 = "80_1304523757.895" 
    $P7326."add_method"($P7327, "!PREFIX__GLOBALish", $P7328)
    nqp_get_sc_object $P7329, "1304523744.097", 15
    get_how $P7330, $P7329
    nqp_get_sc_object $P7331, "1304523744.097", 15
    .const 'Sub' $P7332 = "81_1304523757.895" 
    $P7330."add_method"($P7331, "finishpad", $P7332)
    nqp_get_sc_object $P7333, "1304523744.097", 15
    get_how $P7334, $P7333
    nqp_get_sc_object $P7335, "1304523744.097", 15
    .const 'Sub' $P7336 = "82_1304523757.895" 
    $P7334."add_method"($P7335, "!PREFIX__finishpad", $P7336)
    nqp_get_sc_object $P7337, "1304523744.097", 15
    get_how $P7338, $P7337
    nqp_get_sc_object $P7339, "1304523744.097", 15
    .const 'Sub' $P7340 = "83_1304523757.895" 
    $P7338."add_method"($P7339, "you_are_here", $P7340)
    nqp_get_sc_object $P7341, "1304523744.097", 15
    get_how $P7342, $P7341
    nqp_get_sc_object $P7343, "1304523744.097", 15
    .const 'Sub' $P7344 = "84_1304523757.895" 
    $P7342."add_method"($P7343, "!PREFIX__you_are_here", $P7344)
    nqp_get_sc_object $P7345, "1304523744.097", 15
    get_how $P7346, $P7345
    nqp_get_sc_object $P7347, "1304523744.097", 15
    .const 'Sub' $P7348 = "85_1304523757.895" 
    $P7346."add_method"($P7347, "terminator", $P7348)
    nqp_get_sc_object $P7349, "1304523744.097", 15
    get_how $P7350, $P7349
    nqp_get_sc_object $P7351, "1304523744.097", 15
    .const 'Sub' $P7352 = "86_1304523757.895" 
    $P7350."add_method"($P7351, "!PREFIX__terminator", $P7352)
    nqp_get_sc_object $P7353, "1304523744.097", 15
    get_how $P7354, $P7353
    nqp_get_sc_object $P7355, "1304523744.097", 15
    .const 'Sub' $P7356 = "87_1304523757.895" 
    $P7354."add_method"($P7355, "terminator:sym<;>", $P7356)
    nqp_get_sc_object $P7357, "1304523744.097", 15
    get_how $P7358, $P7357
    nqp_get_sc_object $P7359, "1304523744.097", 15
    .const 'Sub' $P7360 = "88_1304523757.895" 
    $P7358."add_method"($P7359, "!PREFIX__terminator:sym<;>", $P7360)
    nqp_get_sc_object $P7361, "1304523744.097", 15
    get_how $P7362, $P7361
    nqp_get_sc_object $P7363, "1304523744.097", 15
    .const 'Sub' $P7364 = "89_1304523757.895" 
    $P7362."add_method"($P7363, "terminator:sym<}>", $P7364)
    nqp_get_sc_object $P7365, "1304523744.097", 15
    get_how $P7366, $P7365
    nqp_get_sc_object $P7367, "1304523744.097", 15
    .const 'Sub' $P7368 = "90_1304523757.895" 
    $P7366."add_method"($P7367, "!PREFIX__terminator:sym<}>", $P7368)
    nqp_get_sc_object $P7369, "1304523744.097", 15
    get_how $P7370, $P7369
    nqp_get_sc_object $P7371, "1304523744.097", 15
    .const 'Sub' $P7372 = "91_1304523757.895" 
    $P7370."add_method"($P7371, "statement_control", $P7372)
    nqp_get_sc_object $P7373, "1304523744.097", 15
    get_how $P7374, $P7373
    nqp_get_sc_object $P7375, "1304523744.097", 15
    .const 'Sub' $P7376 = "92_1304523757.895" 
    $P7374."add_method"($P7375, "!PREFIX__statement_control", $P7376)
    nqp_get_sc_object $P7377, "1304523744.097", 15
    get_how $P7378, $P7377
    nqp_get_sc_object $P7379, "1304523744.097", 15
    .const 'Sub' $P7380 = "93_1304523757.895" 
    $P7378."add_method"($P7379, "statement_control:sym<use>", $P7380)
    nqp_get_sc_object $P7381, "1304523744.097", 15
    get_how $P7382, $P7381
    nqp_get_sc_object $P7383, "1304523744.097", 15
    .const 'Sub' $P7384 = "94_1304523757.895" 
    $P7382."add_method"($P7383, "!PREFIX__statement_control:sym<use>", $P7384)
    nqp_get_sc_object $P7385, "1304523744.097", 15
    get_how $P7386, $P7385
    nqp_get_sc_object $P7387, "1304523744.097", 15
    .const 'Sub' $P7388 = "95_1304523757.895" 
    $P7386."add_method"($P7387, "statement_control:sym<if>", $P7388)
    nqp_get_sc_object $P7389, "1304523744.097", 15
    get_how $P7390, $P7389
    nqp_get_sc_object $P7391, "1304523744.097", 15
    .const 'Sub' $P7392 = "96_1304523757.895" 
    $P7390."add_method"($P7391, "!PREFIX__statement_control:sym<if>", $P7392)
    nqp_get_sc_object $P7393, "1304523744.097", 15
    get_how $P7394, $P7393
    nqp_get_sc_object $P7395, "1304523744.097", 15
    .const 'Sub' $P7396 = "97_1304523757.895" 
    $P7394."add_method"($P7395, "statement_control:sym<unless>", $P7396)
    nqp_get_sc_object $P7397, "1304523744.097", 15
    get_how $P7398, $P7397
    nqp_get_sc_object $P7399, "1304523744.097", 15
    .const 'Sub' $P7400 = "99_1304523757.895" 
    $P7398."add_method"($P7399, "!PREFIX__statement_control:sym<unless>", $P7400)
    nqp_get_sc_object $P7401, "1304523744.097", 15
    get_how $P7402, $P7401
    nqp_get_sc_object $P7403, "1304523744.097", 15
    .const 'Sub' $P7404 = "100_1304523757.895" 
    $P7402."add_method"($P7403, "statement_control:sym<while>", $P7404)
    nqp_get_sc_object $P7405, "1304523744.097", 15
    get_how $P7406, $P7405
    nqp_get_sc_object $P7407, "1304523744.097", 15
    .const 'Sub' $P7408 = "101_1304523757.895" 
    $P7406."add_method"($P7407, "!PREFIX__statement_control:sym<while>", $P7408)
    nqp_get_sc_object $P7409, "1304523744.097", 15
    get_how $P7410, $P7409
    nqp_get_sc_object $P7411, "1304523744.097", 15
    .const 'Sub' $P7412 = "102_1304523757.895" 
    $P7410."add_method"($P7411, "statement_control:sym<repeat>", $P7412)
    nqp_get_sc_object $P7413, "1304523744.097", 15
    get_how $P7414, $P7413
    nqp_get_sc_object $P7415, "1304523744.097", 15
    .const 'Sub' $P7416 = "103_1304523757.895" 
    $P7414."add_method"($P7415, "!PREFIX__statement_control:sym<repeat>", $P7416)
    nqp_get_sc_object $P7417, "1304523744.097", 15
    get_how $P7418, $P7417
    nqp_get_sc_object $P7419, "1304523744.097", 15
    .const 'Sub' $P7420 = "104_1304523757.895" 
    $P7418."add_method"($P7419, "statement_control:sym<for>", $P7420)
    nqp_get_sc_object $P7421, "1304523744.097", 15
    get_how $P7422, $P7421
    nqp_get_sc_object $P7423, "1304523744.097", 15
    .const 'Sub' $P7424 = "105_1304523757.895" 
    $P7422."add_method"($P7423, "!PREFIX__statement_control:sym<for>", $P7424)
    nqp_get_sc_object $P7425, "1304523744.097", 15
    get_how $P7426, $P7425
    nqp_get_sc_object $P7427, "1304523744.097", 15
    .const 'Sub' $P7428 = "106_1304523757.895" 
    $P7426."add_method"($P7427, "statement_control:sym<CATCH>", $P7428)
    nqp_get_sc_object $P7429, "1304523744.097", 15
    get_how $P7430, $P7429
    nqp_get_sc_object $P7431, "1304523744.097", 15
    .const 'Sub' $P7432 = "107_1304523757.895" 
    $P7430."add_method"($P7431, "!PREFIX__statement_control:sym<CATCH>", $P7432)
    nqp_get_sc_object $P7433, "1304523744.097", 15
    get_how $P7434, $P7433
    nqp_get_sc_object $P7435, "1304523744.097", 15
    .const 'Sub' $P7436 = "108_1304523757.895" 
    $P7434."add_method"($P7435, "statement_control:sym<CONTROL>", $P7436)
    nqp_get_sc_object $P7437, "1304523744.097", 15
    get_how $P7438, $P7437
    nqp_get_sc_object $P7439, "1304523744.097", 15
    .const 'Sub' $P7440 = "109_1304523757.895" 
    $P7438."add_method"($P7439, "!PREFIX__statement_control:sym<CONTROL>", $P7440)
    nqp_get_sc_object $P7441, "1304523744.097", 15
    get_how $P7442, $P7441
    nqp_get_sc_object $P7443, "1304523744.097", 15
    .const 'Sub' $P7444 = "110_1304523757.895" 
    $P7442."add_method"($P7443, "statement_prefix", $P7444)
    nqp_get_sc_object $P7445, "1304523744.097", 15
    get_how $P7446, $P7445
    nqp_get_sc_object $P7447, "1304523744.097", 15
    .const 'Sub' $P7448 = "111_1304523757.895" 
    $P7446."add_method"($P7447, "!PREFIX__statement_prefix", $P7448)
    nqp_get_sc_object $P7449, "1304523744.097", 15
    get_how $P7450, $P7449
    nqp_get_sc_object $P7451, "1304523744.097", 15
    .const 'Sub' $P7452 = "112_1304523757.895" 
    $P7450."add_method"($P7451, "statement_prefix:sym<INIT>", $P7452)
    nqp_get_sc_object $P7453, "1304523744.097", 15
    get_how $P7454, $P7453
    nqp_get_sc_object $P7455, "1304523744.097", 15
    .const 'Sub' $P7456 = "113_1304523757.895" 
    $P7454."add_method"($P7455, "!PREFIX__statement_prefix:sym<INIT>", $P7456)
    nqp_get_sc_object $P7457, "1304523744.097", 15
    get_how $P7458, $P7457
    nqp_get_sc_object $P7459, "1304523744.097", 15
    .const 'Sub' $P7460 = "114_1304523757.895" 
    $P7458."add_method"($P7459, "statement_prefix:sym<try>", $P7460)
    nqp_get_sc_object $P7461, "1304523744.097", 15
    get_how $P7462, $P7461
    nqp_get_sc_object $P7463, "1304523744.097", 15
    .const 'Sub' $P7464 = "115_1304523757.895" 
    $P7462."add_method"($P7463, "!PREFIX__statement_prefix:sym<try>", $P7464)
    nqp_get_sc_object $P7465, "1304523744.097", 15
    get_how $P7466, $P7465
    nqp_get_sc_object $P7467, "1304523744.097", 15
    .const 'Sub' $P7468 = "116_1304523757.895" 
    $P7466."add_method"($P7467, "blorst", $P7468)
    nqp_get_sc_object $P7469, "1304523744.097", 15
    get_how $P7470, $P7469
    nqp_get_sc_object $P7471, "1304523744.097", 15
    .const 'Sub' $P7472 = "117_1304523757.895" 
    $P7470."add_method"($P7471, "!PREFIX__blorst", $P7472)
    nqp_get_sc_object $P7473, "1304523744.097", 15
    get_how $P7474, $P7473
    nqp_get_sc_object $P7475, "1304523744.097", 15
    .const 'Sub' $P7476 = "118_1304523757.895" 
    $P7474."add_method"($P7475, "statement_mod_cond", $P7476)
    nqp_get_sc_object $P7477, "1304523744.097", 15
    get_how $P7478, $P7477
    nqp_get_sc_object $P7479, "1304523744.097", 15
    .const 'Sub' $P7480 = "119_1304523757.895" 
    $P7478."add_method"($P7479, "!PREFIX__statement_mod_cond", $P7480)
    nqp_get_sc_object $P7481, "1304523744.097", 15
    get_how $P7482, $P7481
    nqp_get_sc_object $P7483, "1304523744.097", 15
    .const 'Sub' $P7484 = "120_1304523757.895" 
    $P7482."add_method"($P7483, "statement_mod_cond:sym<if>", $P7484)
    nqp_get_sc_object $P7485, "1304523744.097", 15
    get_how $P7486, $P7485
    nqp_get_sc_object $P7487, "1304523744.097", 15
    .const 'Sub' $P7488 = "121_1304523757.895" 
    $P7486."add_method"($P7487, "!PREFIX__statement_mod_cond:sym<if>", $P7488)
    nqp_get_sc_object $P7489, "1304523744.097", 15
    get_how $P7490, $P7489
    nqp_get_sc_object $P7491, "1304523744.097", 15
    .const 'Sub' $P7492 = "122_1304523757.895" 
    $P7490."add_method"($P7491, "statement_mod_cond:sym<unless>", $P7492)
    nqp_get_sc_object $P7493, "1304523744.097", 15
    get_how $P7494, $P7493
    nqp_get_sc_object $P7495, "1304523744.097", 15
    .const 'Sub' $P7496 = "123_1304523757.895" 
    $P7494."add_method"($P7495, "!PREFIX__statement_mod_cond:sym<unless>", $P7496)
    nqp_get_sc_object $P7497, "1304523744.097", 15
    get_how $P7498, $P7497
    nqp_get_sc_object $P7499, "1304523744.097", 15
    .const 'Sub' $P7500 = "124_1304523757.895" 
    $P7498."add_method"($P7499, "statement_mod_loop", $P7500)
    nqp_get_sc_object $P7501, "1304523744.097", 15
    get_how $P7502, $P7501
    nqp_get_sc_object $P7503, "1304523744.097", 15
    .const 'Sub' $P7504 = "125_1304523757.895" 
    $P7502."add_method"($P7503, "!PREFIX__statement_mod_loop", $P7504)
    nqp_get_sc_object $P7505, "1304523744.097", 15
    get_how $P7506, $P7505
    nqp_get_sc_object $P7507, "1304523744.097", 15
    .const 'Sub' $P7508 = "126_1304523757.895" 
    $P7506."add_method"($P7507, "statement_mod_loop:sym<while>", $P7508)
    nqp_get_sc_object $P7509, "1304523744.097", 15
    get_how $P7510, $P7509
    nqp_get_sc_object $P7511, "1304523744.097", 15
    .const 'Sub' $P7512 = "127_1304523757.895" 
    $P7510."add_method"($P7511, "!PREFIX__statement_mod_loop:sym<while>", $P7512)
    nqp_get_sc_object $P7513, "1304523744.097", 15
    get_how $P7514, $P7513
    nqp_get_sc_object $P7515, "1304523744.097", 15
    .const 'Sub' $P7516 = "128_1304523757.895" 
    $P7514."add_method"($P7515, "statement_mod_loop:sym<until>", $P7516)
    nqp_get_sc_object $P7517, "1304523744.097", 15
    get_how $P7518, $P7517
    nqp_get_sc_object $P7519, "1304523744.097", 15
    .const 'Sub' $P7520 = "129_1304523757.895" 
    $P7518."add_method"($P7519, "!PREFIX__statement_mod_loop:sym<until>", $P7520)
    nqp_get_sc_object $P7521, "1304523744.097", 15
    get_how $P7522, $P7521
    nqp_get_sc_object $P7523, "1304523744.097", 15
    .const 'Sub' $P7524 = "130_1304523757.895" 
    $P7522."add_method"($P7523, "statement_mod_loop:sym<for>", $P7524)
    nqp_get_sc_object $P7525, "1304523744.097", 15
    get_how $P7526, $P7525
    nqp_get_sc_object $P7527, "1304523744.097", 15
    .const 'Sub' $P7528 = "131_1304523757.895" 
    $P7526."add_method"($P7527, "!PREFIX__statement_mod_loop:sym<for>", $P7528)
    nqp_get_sc_object $P7529, "1304523744.097", 15
    get_how $P7530, $P7529
    nqp_get_sc_object $P7531, "1304523744.097", 15
    .const 'Sub' $P7532 = "132_1304523757.895" 
    $P7530."add_method"($P7531, "term:sym<fatarrow>", $P7532)
    nqp_get_sc_object $P7533, "1304523744.097", 15
    get_how $P7534, $P7533
    nqp_get_sc_object $P7535, "1304523744.097", 15
    .const 'Sub' $P7536 = "133_1304523757.895" 
    $P7534."add_method"($P7535, "!PREFIX__term:sym<fatarrow>", $P7536)
    nqp_get_sc_object $P7537, "1304523744.097", 15
    get_how $P7538, $P7537
    nqp_get_sc_object $P7539, "1304523744.097", 15
    .const 'Sub' $P7540 = "134_1304523757.895" 
    $P7538."add_method"($P7539, "term:sym<colonpair>", $P7540)
    nqp_get_sc_object $P7541, "1304523744.097", 15
    get_how $P7542, $P7541
    nqp_get_sc_object $P7543, "1304523744.097", 15
    .const 'Sub' $P7544 = "135_1304523757.895" 
    $P7542."add_method"($P7543, "!PREFIX__term:sym<colonpair>", $P7544)
    nqp_get_sc_object $P7545, "1304523744.097", 15
    get_how $P7546, $P7545
    nqp_get_sc_object $P7547, "1304523744.097", 15
    .const 'Sub' $P7548 = "136_1304523757.895" 
    $P7546."add_method"($P7547, "term:sym<variable>", $P7548)
    nqp_get_sc_object $P7549, "1304523744.097", 15
    get_how $P7550, $P7549
    nqp_get_sc_object $P7551, "1304523744.097", 15
    .const 'Sub' $P7552 = "137_1304523757.895" 
    $P7550."add_method"($P7551, "!PREFIX__term:sym<variable>", $P7552)
    nqp_get_sc_object $P7553, "1304523744.097", 15
    get_how $P7554, $P7553
    nqp_get_sc_object $P7555, "1304523744.097", 15
    .const 'Sub' $P7556 = "138_1304523757.895" 
    $P7554."add_method"($P7555, "term:sym<package_declarator>", $P7556)
    nqp_get_sc_object $P7557, "1304523744.097", 15
    get_how $P7558, $P7557
    nqp_get_sc_object $P7559, "1304523744.097", 15
    .const 'Sub' $P7560 = "139_1304523757.895" 
    $P7558."add_method"($P7559, "!PREFIX__term:sym<package_declarator>", $P7560)
    nqp_get_sc_object $P7561, "1304523744.097", 15
    get_how $P7562, $P7561
    nqp_get_sc_object $P7563, "1304523744.097", 15
    .const 'Sub' $P7564 = "140_1304523757.895" 
    $P7562."add_method"($P7563, "term:sym<scope_declarator>", $P7564)
    nqp_get_sc_object $P7565, "1304523744.097", 15
    get_how $P7566, $P7565
    nqp_get_sc_object $P7567, "1304523744.097", 15
    .const 'Sub' $P7568 = "141_1304523757.895" 
    $P7566."add_method"($P7567, "!PREFIX__term:sym<scope_declarator>", $P7568)
    nqp_get_sc_object $P7569, "1304523744.097", 15
    get_how $P7570, $P7569
    nqp_get_sc_object $P7571, "1304523744.097", 15
    .const 'Sub' $P7572 = "142_1304523757.895" 
    $P7570."add_method"($P7571, "term:sym<routine_declarator>", $P7572)
    nqp_get_sc_object $P7573, "1304523744.097", 15
    get_how $P7574, $P7573
    nqp_get_sc_object $P7575, "1304523744.097", 15
    .const 'Sub' $P7576 = "143_1304523757.895" 
    $P7574."add_method"($P7575, "!PREFIX__term:sym<routine_declarator>", $P7576)
    nqp_get_sc_object $P7577, "1304523744.097", 15
    get_how $P7578, $P7577
    nqp_get_sc_object $P7579, "1304523744.097", 15
    .const 'Sub' $P7580 = "144_1304523757.895" 
    $P7578."add_method"($P7579, "term:sym<multi_declarator>", $P7580)
    nqp_get_sc_object $P7581, "1304523744.097", 15
    get_how $P7582, $P7581
    nqp_get_sc_object $P7583, "1304523744.097", 15
    .const 'Sub' $P7584 = "147_1304523757.895" 
    $P7582."add_method"($P7583, "!PREFIX__term:sym<multi_declarator>", $P7584)
    nqp_get_sc_object $P7585, "1304523744.097", 15
    get_how $P7586, $P7585
    nqp_get_sc_object $P7587, "1304523744.097", 15
    .const 'Sub' $P7588 = "148_1304523757.895" 
    $P7586."add_method"($P7587, "term:sym<regex_declarator>", $P7588)
    nqp_get_sc_object $P7589, "1304523744.097", 15
    get_how $P7590, $P7589
    nqp_get_sc_object $P7591, "1304523744.097", 15
    .const 'Sub' $P7592 = "149_1304523757.895" 
    $P7590."add_method"($P7591, "!PREFIX__term:sym<regex_declarator>", $P7592)
    nqp_get_sc_object $P7593, "1304523744.097", 15
    get_how $P7594, $P7593
    nqp_get_sc_object $P7595, "1304523744.097", 15
    .const 'Sub' $P7596 = "150_1304523757.895" 
    $P7594."add_method"($P7595, "term:sym<statement_prefix>", $P7596)
    nqp_get_sc_object $P7597, "1304523744.097", 15
    get_how $P7598, $P7597
    nqp_get_sc_object $P7599, "1304523744.097", 15
    .const 'Sub' $P7600 = "151_1304523757.895" 
    $P7598."add_method"($P7599, "!PREFIX__term:sym<statement_prefix>", $P7600)
    nqp_get_sc_object $P7601, "1304523744.097", 15
    get_how $P7602, $P7601
    nqp_get_sc_object $P7603, "1304523744.097", 15
    .const 'Sub' $P7604 = "152_1304523757.895" 
    $P7602."add_method"($P7603, "term:sym<lambda>", $P7604)
    nqp_get_sc_object $P7605, "1304523744.097", 15
    get_how $P7606, $P7605
    nqp_get_sc_object $P7607, "1304523744.097", 15
    .const 'Sub' $P7608 = "153_1304523757.895" 
    $P7606."add_method"($P7607, "!PREFIX__term:sym<lambda>", $P7608)
    nqp_get_sc_object $P7609, "1304523744.097", 15
    get_how $P7610, $P7609
    nqp_get_sc_object $P7611, "1304523744.097", 15
    .const 'Sub' $P7612 = "154_1304523757.895" 
    $P7610."add_method"($P7611, "fatarrow", $P7612)
    nqp_get_sc_object $P7613, "1304523744.097", 15
    get_how $P7614, $P7613
    nqp_get_sc_object $P7615, "1304523744.097", 15
    .const 'Sub' $P7616 = "155_1304523757.895" 
    $P7614."add_method"($P7615, "!PREFIX__fatarrow", $P7616)
    nqp_get_sc_object $P7617, "1304523744.097", 15
    get_how $P7618, $P7617
    nqp_get_sc_object $P7619, "1304523744.097", 15
    .const 'Sub' $P7620 = "156_1304523757.895" 
    $P7618."add_method"($P7619, "colonpair", $P7620)
    nqp_get_sc_object $P7621, "1304523744.097", 15
    get_how $P7622, $P7621
    nqp_get_sc_object $P7623, "1304523744.097", 15
    .const 'Sub' $P7624 = "157_1304523757.895" 
    $P7622."add_method"($P7623, "!PREFIX__colonpair", $P7624)
    nqp_get_sc_object $P7625, "1304523744.097", 15
    get_how $P7626, $P7625
    nqp_get_sc_object $P7627, "1304523744.097", 15
    .const 'Sub' $P7628 = "158_1304523757.895" 
    $P7626."add_method"($P7627, "variable", $P7628)
    nqp_get_sc_object $P7629, "1304523744.097", 15
    get_how $P7630, $P7629
    nqp_get_sc_object $P7631, "1304523744.097", 15
    .const 'Sub' $P7632 = "159_1304523757.895" 
    $P7630."add_method"($P7631, "!PREFIX__variable", $P7632)
    nqp_get_sc_object $P7633, "1304523744.097", 15
    get_how $P7634, $P7633
    nqp_get_sc_object $P7635, "1304523744.097", 15
    .const 'Sub' $P7636 = "160_1304523757.895" 
    $P7634."add_method"($P7635, "sigil", $P7636)
    nqp_get_sc_object $P7637, "1304523744.097", 15
    get_how $P7638, $P7637
    nqp_get_sc_object $P7639, "1304523744.097", 15
    .const 'Sub' $P7640 = "161_1304523757.895" 
    $P7638."add_method"($P7639, "!PREFIX__sigil", $P7640)
    nqp_get_sc_object $P7641, "1304523744.097", 15
    get_how $P7642, $P7641
    nqp_get_sc_object $P7643, "1304523744.097", 15
    .const 'Sub' $P7644 = "162_1304523757.895" 
    $P7642."add_method"($P7643, "twigil", $P7644)
    nqp_get_sc_object $P7645, "1304523744.097", 15
    get_how $P7646, $P7645
    nqp_get_sc_object $P7647, "1304523744.097", 15
    .const 'Sub' $P7648 = "163_1304523757.895" 
    $P7646."add_method"($P7647, "!PREFIX__twigil", $P7648)
    nqp_get_sc_object $P7649, "1304523744.097", 15
    get_how $P7650, $P7649
    nqp_get_sc_object $P7651, "1304523744.097", 15
    .const 'Sub' $P7652 = "164_1304523757.895" 
    $P7650."add_method"($P7651, "package_declarator", $P7652)
    nqp_get_sc_object $P7653, "1304523744.097", 15
    get_how $P7654, $P7653
    nqp_get_sc_object $P7655, "1304523744.097", 15
    .const 'Sub' $P7656 = "165_1304523757.895" 
    $P7654."add_method"($P7655, "!PREFIX__package_declarator", $P7656)
    nqp_get_sc_object $P7657, "1304523744.097", 15
    get_how $P7658, $P7657
    nqp_get_sc_object $P7659, "1304523744.097", 15
    .const 'Sub' $P7660 = "166_1304523757.895" 
    $P7658."add_method"($P7659, "package_declarator:sym<module>", $P7660)
    nqp_get_sc_object $P7661, "1304523744.097", 15
    get_how $P7662, $P7661
    nqp_get_sc_object $P7663, "1304523744.097", 15
    .const 'Sub' $P7664 = "167_1304523757.895" 
    $P7662."add_method"($P7663, "!PREFIX__package_declarator:sym<module>", $P7664)
    nqp_get_sc_object $P7665, "1304523744.097", 15
    get_how $P7666, $P7665
    nqp_get_sc_object $P7667, "1304523744.097", 15
    .const 'Sub' $P7668 = "168_1304523757.895" 
    $P7666."add_method"($P7667, "package_declarator:sym<knowhow>", $P7668)
    nqp_get_sc_object $P7669, "1304523744.097", 15
    get_how $P7670, $P7669
    nqp_get_sc_object $P7671, "1304523744.097", 15
    .const 'Sub' $P7672 = "169_1304523757.895" 
    $P7670."add_method"($P7671, "!PREFIX__package_declarator:sym<knowhow>", $P7672)
    nqp_get_sc_object $P7673, "1304523744.097", 15
    get_how $P7674, $P7673
    nqp_get_sc_object $P7675, "1304523744.097", 15
    .const 'Sub' $P7676 = "170_1304523757.895" 
    $P7674."add_method"($P7675, "package_declarator:sym<class>", $P7676)
    nqp_get_sc_object $P7677, "1304523744.097", 15
    get_how $P7678, $P7677
    nqp_get_sc_object $P7679, "1304523744.097", 15
    .const 'Sub' $P7680 = "171_1304523757.895" 
    $P7678."add_method"($P7679, "!PREFIX__package_declarator:sym<class>", $P7680)
    nqp_get_sc_object $P7681, "1304523744.097", 15
    get_how $P7682, $P7681
    nqp_get_sc_object $P7683, "1304523744.097", 15
    .const 'Sub' $P7684 = "172_1304523757.895" 
    $P7682."add_method"($P7683, "package_declarator:sym<grammar>", $P7684)
    nqp_get_sc_object $P7685, "1304523744.097", 15
    get_how $P7686, $P7685
    nqp_get_sc_object $P7687, "1304523744.097", 15
    .const 'Sub' $P7688 = "173_1304523757.895" 
    $P7686."add_method"($P7687, "!PREFIX__package_declarator:sym<grammar>", $P7688)
    nqp_get_sc_object $P7689, "1304523744.097", 15
    get_how $P7690, $P7689
    nqp_get_sc_object $P7691, "1304523744.097", 15
    .const 'Sub' $P7692 = "174_1304523757.895" 
    $P7690."add_method"($P7691, "package_declarator:sym<role>", $P7692)
    nqp_get_sc_object $P7693, "1304523744.097", 15
    get_how $P7694, $P7693
    nqp_get_sc_object $P7695, "1304523744.097", 15
    .const 'Sub' $P7696 = "175_1304523757.895" 
    $P7694."add_method"($P7695, "!PREFIX__package_declarator:sym<role>", $P7696)
    nqp_get_sc_object $P7697, "1304523744.097", 15
    get_how $P7698, $P7697
    nqp_get_sc_object $P7699, "1304523744.097", 15
    .const 'Sub' $P7700 = "176_1304523757.895" 
    $P7698."add_method"($P7699, "package_declarator:sym<native>", $P7700)
    nqp_get_sc_object $P7701, "1304523744.097", 15
    get_how $P7702, $P7701
    nqp_get_sc_object $P7703, "1304523744.097", 15
    .const 'Sub' $P7704 = "177_1304523757.895" 
    $P7702."add_method"($P7703, "!PREFIX__package_declarator:sym<native>", $P7704)
    nqp_get_sc_object $P7705, "1304523744.097", 15
    get_how $P7706, $P7705
    nqp_get_sc_object $P7707, "1304523744.097", 15
    .const 'Sub' $P7708 = "178_1304523757.895" 
    $P7706."add_method"($P7707, "package_def", $P7708)
    nqp_get_sc_object $P7709, "1304523744.097", 15
    get_how $P7710, $P7709
    nqp_get_sc_object $P7711, "1304523744.097", 15
    .const 'Sub' $P7712 = "180_1304523757.895" 
    $P7710."add_method"($P7711, "!PREFIX__package_def", $P7712)
    nqp_get_sc_object $P7713, "1304523744.097", 15
    get_how $P7714, $P7713
    nqp_get_sc_object $P7715, "1304523744.097", 15
    .const 'Sub' $P7716 = "181_1304523757.895" 
    $P7714."add_method"($P7715, "scope_declarator", $P7716)
    nqp_get_sc_object $P7717, "1304523744.097", 15
    get_how $P7718, $P7717
    nqp_get_sc_object $P7719, "1304523744.097", 15
    .const 'Sub' $P7720 = "182_1304523757.895" 
    $P7718."add_method"($P7719, "!PREFIX__scope_declarator", $P7720)
    nqp_get_sc_object $P7721, "1304523744.097", 15
    get_how $P7722, $P7721
    nqp_get_sc_object $P7723, "1304523744.097", 15
    .const 'Sub' $P7724 = "183_1304523757.895" 
    $P7722."add_method"($P7723, "scope_declarator:sym<my>", $P7724)
    nqp_get_sc_object $P7725, "1304523744.097", 15
    get_how $P7726, $P7725
    nqp_get_sc_object $P7727, "1304523744.097", 15
    .const 'Sub' $P7728 = "184_1304523757.895" 
    $P7726."add_method"($P7727, "!PREFIX__scope_declarator:sym<my>", $P7728)
    nqp_get_sc_object $P7729, "1304523744.097", 15
    get_how $P7730, $P7729
    nqp_get_sc_object $P7731, "1304523744.097", 15
    .const 'Sub' $P7732 = "185_1304523757.895" 
    $P7730."add_method"($P7731, "scope_declarator:sym<our>", $P7732)
    nqp_get_sc_object $P7733, "1304523744.097", 15
    get_how $P7734, $P7733
    nqp_get_sc_object $P7735, "1304523744.097", 15
    .const 'Sub' $P7736 = "186_1304523757.895" 
    $P7734."add_method"($P7735, "!PREFIX__scope_declarator:sym<our>", $P7736)
    nqp_get_sc_object $P7737, "1304523744.097", 15
    get_how $P7738, $P7737
    nqp_get_sc_object $P7739, "1304523744.097", 15
    .const 'Sub' $P7740 = "187_1304523757.895" 
    $P7738."add_method"($P7739, "scope_declarator:sym<has>", $P7740)
    nqp_get_sc_object $P7741, "1304523744.097", 15
    get_how $P7742, $P7741
    nqp_get_sc_object $P7743, "1304523744.097", 15
    .const 'Sub' $P7744 = "188_1304523757.895" 
    $P7742."add_method"($P7743, "!PREFIX__scope_declarator:sym<has>", $P7744)
    nqp_get_sc_object $P7745, "1304523744.097", 15
    get_how $P7746, $P7745
    nqp_get_sc_object $P7747, "1304523744.097", 15
    .const 'Sub' $P7748 = "189_1304523757.895" 
    $P7746."add_method"($P7747, "scoped", $P7748)
    nqp_get_sc_object $P7749, "1304523744.097", 15
    get_how $P7750, $P7749
    nqp_get_sc_object $P7751, "1304523744.097", 15
    .const 'Sub' $P7752 = "190_1304523757.895" 
    $P7750."add_method"($P7751, "!PREFIX__scoped", $P7752)
    nqp_get_sc_object $P7753, "1304523744.097", 15
    get_how $P7754, $P7753
    nqp_get_sc_object $P7755, "1304523744.097", 15
    .const 'Sub' $P7756 = "191_1304523757.895" 
    $P7754."add_method"($P7755, "typename", $P7756)
    nqp_get_sc_object $P7757, "1304523744.097", 15
    get_how $P7758, $P7757
    nqp_get_sc_object $P7759, "1304523744.097", 15
    .const 'Sub' $P7760 = "193_1304523757.895" 
    $P7758."add_method"($P7759, "!PREFIX__typename", $P7760)
    nqp_get_sc_object $P7761, "1304523744.097", 15
    get_how $P7762, $P7761
    nqp_get_sc_object $P7763, "1304523744.097", 15
    .const 'Sub' $P7764 = "194_1304523757.895" 
    $P7762."add_method"($P7763, "declarator", $P7764)
    nqp_get_sc_object $P7765, "1304523744.097", 15
    get_how $P7766, $P7765
    nqp_get_sc_object $P7767, "1304523744.097", 15
    .const 'Sub' $P7768 = "195_1304523757.895" 
    $P7766."add_method"($P7767, "!PREFIX__declarator", $P7768)
    nqp_get_sc_object $P7769, "1304523744.097", 15
    get_how $P7770, $P7769
    nqp_get_sc_object $P7771, "1304523744.097", 15
    .const 'Sub' $P7772 = "196_1304523757.895" 
    $P7770."add_method"($P7771, "variable_declarator", $P7772)
    nqp_get_sc_object $P7773, "1304523744.097", 15
    get_how $P7774, $P7773
    nqp_get_sc_object $P7775, "1304523744.097", 15
    .const 'Sub' $P7776 = "198_1304523757.895" 
    $P7774."add_method"($P7775, "!PREFIX__variable_declarator", $P7776)
    nqp_get_sc_object $P7777, "1304523744.097", 15
    get_how $P7778, $P7777
    nqp_get_sc_object $P7779, "1304523744.097", 15
    .const 'Sub' $P7780 = "199_1304523757.895" 
    $P7778."add_method"($P7779, "routine_declarator", $P7780)
    nqp_get_sc_object $P7781, "1304523744.097", 15
    get_how $P7782, $P7781
    nqp_get_sc_object $P7783, "1304523744.097", 15
    .const 'Sub' $P7784 = "200_1304523757.895" 
    $P7782."add_method"($P7783, "!PREFIX__routine_declarator", $P7784)
    nqp_get_sc_object $P7785, "1304523744.097", 15
    get_how $P7786, $P7785
    nqp_get_sc_object $P7787, "1304523744.097", 15
    .const 'Sub' $P7788 = "201_1304523757.895" 
    $P7786."add_method"($P7787, "routine_declarator:sym<sub>", $P7788)
    nqp_get_sc_object $P7789, "1304523744.097", 15
    get_how $P7790, $P7789
    nqp_get_sc_object $P7791, "1304523744.097", 15
    .const 'Sub' $P7792 = "202_1304523757.895" 
    $P7790."add_method"($P7791, "!PREFIX__routine_declarator:sym<sub>", $P7792)
    nqp_get_sc_object $P7793, "1304523744.097", 15
    get_how $P7794, $P7793
    nqp_get_sc_object $P7795, "1304523744.097", 15
    .const 'Sub' $P7796 = "203_1304523757.895" 
    $P7794."add_method"($P7795, "routine_declarator:sym<method>", $P7796)
    nqp_get_sc_object $P7797, "1304523744.097", 15
    get_how $P7798, $P7797
    nqp_get_sc_object $P7799, "1304523744.097", 15
    .const 'Sub' $P7800 = "204_1304523757.895" 
    $P7798."add_method"($P7799, "!PREFIX__routine_declarator:sym<method>", $P7800)
    nqp_get_sc_object $P7801, "1304523744.097", 15
    get_how $P7802, $P7801
    nqp_get_sc_object $P7803, "1304523744.097", 15
    .const 'Sub' $P7804 = "205_1304523757.895" 
    $P7802."add_method"($P7803, "routine_def", $P7804)
    nqp_get_sc_object $P7805, "1304523744.097", 15
    get_how $P7806, $P7805
    nqp_get_sc_object $P7807, "1304523744.097", 15
    .const 'Sub' $P7808 = "206_1304523757.895" 
    $P7806."add_method"($P7807, "!PREFIX__routine_def", $P7808)
    nqp_get_sc_object $P7809, "1304523744.097", 15
    get_how $P7810, $P7809
    nqp_get_sc_object $P7811, "1304523744.097", 15
    .const 'Sub' $P7812 = "207_1304523757.895" 
    $P7810."add_method"($P7811, "method_def", $P7812)
    nqp_get_sc_object $P7813, "1304523744.097", 15
    get_how $P7814, $P7813
    nqp_get_sc_object $P7815, "1304523744.097", 15
    .const 'Sub' $P7816 = "209_1304523757.895" 
    $P7814."add_method"($P7815, "!PREFIX__method_def", $P7816)
    nqp_get_sc_object $P7817, "1304523744.097", 15
    get_how $P7818, $P7817
    nqp_get_sc_object $P7819, "1304523744.097", 15
    .const 'Sub' $P7820 = "210_1304523757.895" 
    $P7818."add_method"($P7819, "onlystar", $P7820)
    nqp_get_sc_object $P7821, "1304523744.097", 15
    get_how $P7822, $P7821
    nqp_get_sc_object $P7823, "1304523744.097", 15
    .const 'Sub' $P7824 = "212_1304523757.895" 
    $P7822."add_method"($P7823, "!PREFIX__onlystar", $P7824)
    nqp_get_sc_object $P7825, "1304523744.097", 15
    get_how $P7826, $P7825
    nqp_get_sc_object $P7827, "1304523744.097", 15
    .const 'Sub' $P7828 = "213_1304523757.895" 
    $P7826."add_method"($P7827, "multi_declarator", $P7828)
    nqp_get_sc_object $P7829, "1304523744.097", 15
    get_how $P7830, $P7829
    nqp_get_sc_object $P7831, "1304523744.097", 15
    .const 'Sub' $P7832 = "214_1304523757.895" 
    $P7830."add_method"($P7831, "!PREFIX__multi_declarator", $P7832)
    nqp_get_sc_object $P7833, "1304523744.097", 15
    get_how $P7834, $P7833
    nqp_get_sc_object $P7835, "1304523744.097", 15
    .const 'Sub' $P7836 = "215_1304523757.895" 
    $P7834."add_method"($P7835, "multi_declarator:sym<multi>", $P7836)
    nqp_get_sc_object $P7837, "1304523744.097", 15
    get_how $P7838, $P7837
    nqp_get_sc_object $P7839, "1304523744.097", 15
    .const 'Sub' $P7840 = "216_1304523757.895" 
    $P7838."add_method"($P7839, "!PREFIX__multi_declarator:sym<multi>", $P7840)
    nqp_get_sc_object $P7841, "1304523744.097", 15
    get_how $P7842, $P7841
    nqp_get_sc_object $P7843, "1304523744.097", 15
    .const 'Sub' $P7844 = "217_1304523757.895" 
    $P7842."add_method"($P7843, "multi_declarator:sym<proto>", $P7844)
    nqp_get_sc_object $P7845, "1304523744.097", 15
    get_how $P7846, $P7845
    nqp_get_sc_object $P7847, "1304523744.097", 15
    .const 'Sub' $P7848 = "218_1304523757.895" 
    $P7846."add_method"($P7847, "!PREFIX__multi_declarator:sym<proto>", $P7848)
    nqp_get_sc_object $P7849, "1304523744.097", 15
    get_how $P7850, $P7849
    nqp_get_sc_object $P7851, "1304523744.097", 15
    .const 'Sub' $P7852 = "219_1304523757.895" 
    $P7850."add_method"($P7851, "multi_declarator:sym<null>", $P7852)
    nqp_get_sc_object $P7853, "1304523744.097", 15
    get_how $P7854, $P7853
    nqp_get_sc_object $P7855, "1304523744.097", 15
    .const 'Sub' $P7856 = "220_1304523757.895" 
    $P7854."add_method"($P7855, "!PREFIX__multi_declarator:sym<null>", $P7856)
    nqp_get_sc_object $P7857, "1304523744.097", 15
    get_how $P7858, $P7857
    nqp_get_sc_object $P7859, "1304523744.097", 15
    .const 'Sub' $P7860 = "221_1304523757.895" 
    $P7858."add_method"($P7859, "signature", $P7860)
    nqp_get_sc_object $P7861, "1304523744.097", 15
    get_how $P7862, $P7861
    nqp_get_sc_object $P7863, "1304523744.097", 15
    .const 'Sub' $P7864 = "223_1304523757.895" 
    $P7862."add_method"($P7863, "!PREFIX__signature", $P7864)
    nqp_get_sc_object $P7865, "1304523744.097", 15
    get_how $P7866, $P7865
    nqp_get_sc_object $P7867, "1304523744.097", 15
    .const 'Sub' $P7868 = "224_1304523757.895" 
    $P7866."add_method"($P7867, "parameter", $P7868)
    nqp_get_sc_object $P7869, "1304523744.097", 15
    get_how $P7870, $P7869
    nqp_get_sc_object $P7871, "1304523744.097", 15
    .const 'Sub' $P7872 = "225_1304523757.895" 
    $P7870."add_method"($P7871, "!PREFIX__parameter", $P7872)
    nqp_get_sc_object $P7873, "1304523744.097", 15
    get_how $P7874, $P7873
    nqp_get_sc_object $P7875, "1304523744.097", 15
    .const 'Sub' $P7876 = "226_1304523757.895" 
    $P7874."add_method"($P7875, "param_var", $P7876)
    nqp_get_sc_object $P7877, "1304523744.097", 15
    get_how $P7878, $P7877
    nqp_get_sc_object $P7879, "1304523744.097", 15
    .const 'Sub' $P7880 = "227_1304523757.895" 
    $P7878."add_method"($P7879, "!PREFIX__param_var", $P7880)
    nqp_get_sc_object $P7881, "1304523744.097", 15
    get_how $P7882, $P7881
    nqp_get_sc_object $P7883, "1304523744.097", 15
    .const 'Sub' $P7884 = "228_1304523757.895" 
    $P7882."add_method"($P7883, "named_param", $P7884)
    nqp_get_sc_object $P7885, "1304523744.097", 15
    get_how $P7886, $P7885
    nqp_get_sc_object $P7887, "1304523744.097", 15
    .const 'Sub' $P7888 = "229_1304523757.895" 
    $P7886."add_method"($P7887, "!PREFIX__named_param", $P7888)
    nqp_get_sc_object $P7889, "1304523744.097", 15
    get_how $P7890, $P7889
    nqp_get_sc_object $P7891, "1304523744.097", 15
    .const 'Sub' $P7892 = "230_1304523757.895" 
    $P7890."add_method"($P7891, "default_value", $P7892)
    nqp_get_sc_object $P7893, "1304523744.097", 15
    get_how $P7894, $P7893
    nqp_get_sc_object $P7895, "1304523744.097", 15
    .const 'Sub' $P7896 = "231_1304523757.895" 
    $P7894."add_method"($P7895, "!PREFIX__default_value", $P7896)
    nqp_get_sc_object $P7897, "1304523744.097", 15
    get_how $P7898, $P7897
    nqp_get_sc_object $P7899, "1304523744.097", 15
    .const 'Sub' $P7900 = "232_1304523757.895" 
    $P7898."add_method"($P7899, "trait", $P7900)
    nqp_get_sc_object $P7901, "1304523744.097", 15
    get_how $P7902, $P7901
    nqp_get_sc_object $P7903, "1304523744.097", 15
    .const 'Sub' $P7904 = "233_1304523757.895" 
    $P7902."add_method"($P7903, "!PREFIX__trait", $P7904)
    nqp_get_sc_object $P7905, "1304523744.097", 15
    get_how $P7906, $P7905
    nqp_get_sc_object $P7907, "1304523744.097", 15
    .const 'Sub' $P7908 = "234_1304523757.895" 
    $P7906."add_method"($P7907, "trait_mod", $P7908)
    nqp_get_sc_object $P7909, "1304523744.097", 15
    get_how $P7910, $P7909
    nqp_get_sc_object $P7911, "1304523744.097", 15
    .const 'Sub' $P7912 = "235_1304523757.895" 
    $P7910."add_method"($P7911, "!PREFIX__trait_mod", $P7912)
    nqp_get_sc_object $P7913, "1304523744.097", 15
    get_how $P7914, $P7913
    nqp_get_sc_object $P7915, "1304523744.097", 15
    .const 'Sub' $P7916 = "236_1304523757.895" 
    $P7914."add_method"($P7915, "trait_mod:sym<is>", $P7916)
    nqp_get_sc_object $P7917, "1304523744.097", 15
    get_how $P7918, $P7917
    nqp_get_sc_object $P7919, "1304523744.097", 15
    .const 'Sub' $P7920 = "237_1304523757.895" 
    $P7918."add_method"($P7919, "!PREFIX__trait_mod:sym<is>", $P7920)
    nqp_get_sc_object $P7921, "1304523744.097", 15
    get_how $P7922, $P7921
    nqp_get_sc_object $P7923, "1304523744.097", 15
    .const 'Sub' $P7924 = "238_1304523757.895" 
    $P7922."add_method"($P7923, "regex_declarator", $P7924)
    nqp_get_sc_object $P7925, "1304523744.097", 15
    get_how $P7926, $P7925
    nqp_get_sc_object $P7927, "1304523744.097", 15
    .const 'Sub' $P7928 = "239_1304523757.895" 
    $P7926."add_method"($P7927, "!PREFIX__regex_declarator", $P7928)
    nqp_get_sc_object $P7929, "1304523744.097", 15
    get_how $P7930, $P7929
    nqp_get_sc_object $P7931, "1304523744.097", 15
    .const 'Sub' $P7932 = "240_1304523757.895" 
    $P7930."add_method"($P7931, "dotty", $P7932)
    nqp_get_sc_object $P7933, "1304523744.097", 15
    get_how $P7934, $P7933
    nqp_get_sc_object $P7935, "1304523744.097", 15
    .const 'Sub' $P7936 = "241_1304523757.895" 
    $P7934."add_method"($P7935, "!PREFIX__dotty", $P7936)
    nqp_get_sc_object $P7937, "1304523744.097", 15
    get_how $P7938, $P7937
    nqp_get_sc_object $P7939, "1304523744.097", 15
    .const 'Sub' $P7940 = "242_1304523757.895" 
    $P7938."add_method"($P7939, "term", $P7940)
    nqp_get_sc_object $P7941, "1304523744.097", 15
    get_how $P7942, $P7941
    nqp_get_sc_object $P7943, "1304523744.097", 15
    .const 'Sub' $P7944 = "243_1304523757.895" 
    $P7942."add_method"($P7943, "!PREFIX__term", $P7944)
    nqp_get_sc_object $P7945, "1304523744.097", 15
    get_how $P7946, $P7945
    nqp_get_sc_object $P7947, "1304523744.097", 15
    .const 'Sub' $P7948 = "244_1304523757.895" 
    $P7946."add_method"($P7947, "term:sym<self>", $P7948)
    nqp_get_sc_object $P7949, "1304523744.097", 15
    get_how $P7950, $P7949
    nqp_get_sc_object $P7951, "1304523744.097", 15
    .const 'Sub' $P7952 = "245_1304523757.895" 
    $P7950."add_method"($P7951, "!PREFIX__term:sym<self>", $P7952)
    nqp_get_sc_object $P7953, "1304523744.097", 15
    get_how $P7954, $P7953
    nqp_get_sc_object $P7955, "1304523744.097", 15
    .const 'Sub' $P7956 = "246_1304523757.895" 
    $P7954."add_method"($P7955, "term:sym<identifier>", $P7956)
    nqp_get_sc_object $P7957, "1304523744.097", 15
    get_how $P7958, $P7957
    nqp_get_sc_object $P7959, "1304523744.097", 15
    .const 'Sub' $P7960 = "247_1304523757.895" 
    $P7958."add_method"($P7959, "!PREFIX__term:sym<identifier>", $P7960)
    nqp_get_sc_object $P7961, "1304523744.097", 15
    get_how $P7962, $P7961
    nqp_get_sc_object $P7963, "1304523744.097", 15
    .const 'Sub' $P7964 = "248_1304523757.895" 
    $P7962."add_method"($P7963, "term:sym<name>", $P7964)
    nqp_get_sc_object $P7965, "1304523744.097", 15
    get_how $P7966, $P7965
    nqp_get_sc_object $P7967, "1304523744.097", 15
    .const 'Sub' $P7968 = "249_1304523757.895" 
    $P7966."add_method"($P7967, "!PREFIX__term:sym<name>", $P7968)
    nqp_get_sc_object $P7969, "1304523744.097", 15
    get_how $P7970, $P7969
    nqp_get_sc_object $P7971, "1304523744.097", 15
    .const 'Sub' $P7972 = "250_1304523757.895" 
    $P7970."add_method"($P7971, "term:sym<pir::op>", $P7972)
    nqp_get_sc_object $P7973, "1304523744.097", 15
    get_how $P7974, $P7973
    nqp_get_sc_object $P7975, "1304523744.097", 15
    .const 'Sub' $P7976 = "251_1304523757.895" 
    $P7974."add_method"($P7975, "!PREFIX__term:sym<pir::op>", $P7976)
    nqp_get_sc_object $P7977, "1304523744.097", 15
    get_how $P7978, $P7977
    nqp_get_sc_object $P7979, "1304523744.097", 15
    .const 'Sub' $P7980 = "252_1304523757.895" 
    $P7978."add_method"($P7979, "term:sym<onlystar>", $P7980)
    nqp_get_sc_object $P7981, "1304523744.097", 15
    get_how $P7982, $P7981
    nqp_get_sc_object $P7983, "1304523744.097", 15
    .const 'Sub' $P7984 = "254_1304523757.895" 
    $P7982."add_method"($P7983, "!PREFIX__term:sym<onlystar>", $P7984)
    nqp_get_sc_object $P7985, "1304523744.097", 15
    get_how $P7986, $P7985
    nqp_get_sc_object $P7987, "1304523744.097", 15
    .const 'Sub' $P7988 = "255_1304523757.895" 
    $P7986."add_method"($P7987, "args", $P7988)
    nqp_get_sc_object $P7989, "1304523744.097", 15
    get_how $P7990, $P7989
    nqp_get_sc_object $P7991, "1304523744.097", 15
    .const 'Sub' $P7992 = "256_1304523757.895" 
    $P7990."add_method"($P7991, "!PREFIX__args", $P7992)
    nqp_get_sc_object $P7993, "1304523744.097", 15
    get_how $P7994, $P7993
    nqp_get_sc_object $P7995, "1304523744.097", 15
    .const 'Sub' $P7996 = "257_1304523757.895" 
    $P7994."add_method"($P7995, "arglist", $P7996)
    nqp_get_sc_object $P7997, "1304523744.097", 15
    get_how $P7998, $P7997
    nqp_get_sc_object $P7999, "1304523744.097", 15
    .const 'Sub' $P8000 = "258_1304523757.895" 
    $P7998."add_method"($P7999, "!PREFIX__arglist", $P8000)
    nqp_get_sc_object $P8001, "1304523744.097", 15
    get_how $P8002, $P8001
    nqp_get_sc_object $P8003, "1304523744.097", 15
    .const 'Sub' $P8004 = "259_1304523757.895" 
    $P8002."add_method"($P8003, "term:sym<value>", $P8004)
    nqp_get_sc_object $P8005, "1304523744.097", 15
    get_how $P8006, $P8005
    nqp_get_sc_object $P8007, "1304523744.097", 15
    .const 'Sub' $P8008 = "260_1304523757.895" 
    $P8006."add_method"($P8007, "!PREFIX__term:sym<value>", $P8008)
    nqp_get_sc_object $P8009, "1304523744.097", 15
    get_how $P8010, $P8009
    nqp_get_sc_object $P8011, "1304523744.097", 15
    .const 'Sub' $P8012 = "261_1304523757.895" 
    $P8010."add_method"($P8011, "value", $P8012)
    nqp_get_sc_object $P8013, "1304523744.097", 15
    get_how $P8014, $P8013
    nqp_get_sc_object $P8015, "1304523744.097", 15
    .const 'Sub' $P8016 = "262_1304523757.895" 
    $P8014."add_method"($P8015, "!PREFIX__value", $P8016)
    nqp_get_sc_object $P8017, "1304523744.097", 15
    get_how $P8018, $P8017
    nqp_get_sc_object $P8019, "1304523744.097", 15
    .const 'Sub' $P8020 = "263_1304523757.895" 
    $P8018."add_method"($P8019, "number", $P8020)
    nqp_get_sc_object $P8021, "1304523744.097", 15
    get_how $P8022, $P8021
    nqp_get_sc_object $P8023, "1304523744.097", 15
    .const 'Sub' $P8024 = "264_1304523757.895" 
    $P8022."add_method"($P8023, "!PREFIX__number", $P8024)
    nqp_get_sc_object $P8025, "1304523744.097", 15
    get_how $P8026, $P8025
    nqp_get_sc_object $P8027, "1304523744.097", 15
    .const 'Sub' $P8028 = "265_1304523757.895" 
    $P8026."add_method"($P8027, "quote", $P8028)
    nqp_get_sc_object $P8029, "1304523744.097", 15
    get_how $P8030, $P8029
    nqp_get_sc_object $P8031, "1304523744.097", 15
    .const 'Sub' $P8032 = "266_1304523757.895" 
    $P8030."add_method"($P8031, "!PREFIX__quote", $P8032)
    nqp_get_sc_object $P8033, "1304523744.097", 15
    get_how $P8034, $P8033
    nqp_get_sc_object $P8035, "1304523744.097", 15
    .const 'Sub' $P8036 = "267_1304523757.895" 
    $P8034."add_method"($P8035, "quote:sym<apos>", $P8036)
    nqp_get_sc_object $P8037, "1304523744.097", 15
    get_how $P8038, $P8037
    nqp_get_sc_object $P8039, "1304523744.097", 15
    .const 'Sub' $P8040 = "268_1304523757.895" 
    $P8038."add_method"($P8039, "!PREFIX__quote:sym<apos>", $P8040)
    nqp_get_sc_object $P8041, "1304523744.097", 15
    get_how $P8042, $P8041
    nqp_get_sc_object $P8043, "1304523744.097", 15
    .const 'Sub' $P8044 = "269_1304523757.895" 
    $P8042."add_method"($P8043, "quote:sym<dblq>", $P8044)
    nqp_get_sc_object $P8045, "1304523744.097", 15
    get_how $P8046, $P8045
    nqp_get_sc_object $P8047, "1304523744.097", 15
    .const 'Sub' $P8048 = "270_1304523757.895" 
    $P8046."add_method"($P8047, "!PREFIX__quote:sym<dblq>", $P8048)
    nqp_get_sc_object $P8049, "1304523744.097", 15
    get_how $P8050, $P8049
    nqp_get_sc_object $P8051, "1304523744.097", 15
    .const 'Sub' $P8052 = "271_1304523757.895" 
    $P8050."add_method"($P8051, "quote:sym<q>", $P8052)
    nqp_get_sc_object $P8053, "1304523744.097", 15
    get_how $P8054, $P8053
    nqp_get_sc_object $P8055, "1304523744.097", 15
    .const 'Sub' $P8056 = "272_1304523757.895" 
    $P8054."add_method"($P8055, "!PREFIX__quote:sym<q>", $P8056)
    nqp_get_sc_object $P8057, "1304523744.097", 15
    get_how $P8058, $P8057
    nqp_get_sc_object $P8059, "1304523744.097", 15
    .const 'Sub' $P8060 = "273_1304523757.895" 
    $P8058."add_method"($P8059, "quote:sym<qq>", $P8060)
    nqp_get_sc_object $P8061, "1304523744.097", 15
    get_how $P8062, $P8061
    nqp_get_sc_object $P8063, "1304523744.097", 15
    .const 'Sub' $P8064 = "274_1304523757.895" 
    $P8062."add_method"($P8063, "!PREFIX__quote:sym<qq>", $P8064)
    nqp_get_sc_object $P8065, "1304523744.097", 15
    get_how $P8066, $P8065
    nqp_get_sc_object $P8067, "1304523744.097", 15
    .const 'Sub' $P8068 = "275_1304523757.895" 
    $P8066."add_method"($P8067, "quote:sym<Q>", $P8068)
    nqp_get_sc_object $P8069, "1304523744.097", 15
    get_how $P8070, $P8069
    nqp_get_sc_object $P8071, "1304523744.097", 15
    .const 'Sub' $P8072 = "276_1304523757.895" 
    $P8070."add_method"($P8071, "!PREFIX__quote:sym<Q>", $P8072)
    nqp_get_sc_object $P8073, "1304523744.097", 15
    get_how $P8074, $P8073
    nqp_get_sc_object $P8075, "1304523744.097", 15
    .const 'Sub' $P8076 = "277_1304523757.895" 
    $P8074."add_method"($P8075, "quote:sym<Q:PIR>", $P8076)
    nqp_get_sc_object $P8077, "1304523744.097", 15
    get_how $P8078, $P8077
    nqp_get_sc_object $P8079, "1304523744.097", 15
    .const 'Sub' $P8080 = "278_1304523757.895" 
    $P8078."add_method"($P8079, "!PREFIX__quote:sym<Q:PIR>", $P8080)
    nqp_get_sc_object $P8081, "1304523744.097", 15
    get_how $P8082, $P8081
    nqp_get_sc_object $P8083, "1304523744.097", 15
    .const 'Sub' $P8084 = "279_1304523757.895" 
    $P8082."add_method"($P8083, "quote:sym</ />", $P8084)
    nqp_get_sc_object $P8085, "1304523744.097", 15
    get_how $P8086, $P8085
    nqp_get_sc_object $P8087, "1304523744.097", 15
    .const 'Sub' $P8088 = "280_1304523757.895" 
    $P8086."add_method"($P8087, "!PREFIX__quote:sym</ />", $P8088)
    nqp_get_sc_object $P8089, "1304523744.097", 15
    get_how $P8090, $P8089
    nqp_get_sc_object $P8091, "1304523744.097", 15
    .const 'Sub' $P8092 = "281_1304523757.895" 
    $P8090."add_method"($P8091, "quote_escape:sym<$>", $P8092)
    nqp_get_sc_object $P8093, "1304523744.097", 15
    get_how $P8094, $P8093
    nqp_get_sc_object $P8095, "1304523744.097", 15
    .const 'Sub' $P8096 = "282_1304523757.895" 
    $P8094."add_method"($P8095, "!PREFIX__quote_escape:sym<$>", $P8096)
    nqp_get_sc_object $P8097, "1304523744.097", 15
    get_how $P8098, $P8097
    nqp_get_sc_object $P8099, "1304523744.097", 15
    .const 'Sub' $P8100 = "283_1304523757.895" 
    $P8098."add_method"($P8099, "quote_escape:sym<{ }>", $P8100)
    nqp_get_sc_object $P8101, "1304523744.097", 15
    get_how $P8102, $P8101
    nqp_get_sc_object $P8103, "1304523744.097", 15
    .const 'Sub' $P8104 = "284_1304523757.895" 
    $P8102."add_method"($P8103, "!PREFIX__quote_escape:sym<{ }>", $P8104)
    nqp_get_sc_object $P8105, "1304523744.097", 15
    get_how $P8106, $P8105
    nqp_get_sc_object $P8107, "1304523744.097", 15
    .const 'Sub' $P8108 = "285_1304523757.895" 
    $P8106."add_method"($P8107, "quote_escape:sym<esc>", $P8108)
    nqp_get_sc_object $P8109, "1304523744.097", 15
    get_how $P8110, $P8109
    nqp_get_sc_object $P8111, "1304523744.097", 15
    .const 'Sub' $P8112 = "286_1304523757.895" 
    $P8110."add_method"($P8111, "!PREFIX__quote_escape:sym<esc>", $P8112)
    nqp_get_sc_object $P8113, "1304523744.097", 15
    get_how $P8114, $P8113
    nqp_get_sc_object $P8115, "1304523744.097", 15
    .const 'Sub' $P8116 = "287_1304523757.895" 
    $P8114."add_method"($P8115, "circumfix:sym<( )>", $P8116)
    nqp_get_sc_object $P8117, "1304523744.097", 15
    get_how $P8118, $P8117
    nqp_get_sc_object $P8119, "1304523744.097", 15
    .const 'Sub' $P8120 = "288_1304523757.895" 
    $P8118."add_method"($P8119, "!PREFIX__circumfix:sym<( )>", $P8120)
    nqp_get_sc_object $P8121, "1304523744.097", 15
    get_how $P8122, $P8121
    nqp_get_sc_object $P8123, "1304523744.097", 15
    .const 'Sub' $P8124 = "289_1304523757.895" 
    $P8122."add_method"($P8123, "circumfix:sym<[ ]>", $P8124)
    nqp_get_sc_object $P8125, "1304523744.097", 15
    get_how $P8126, $P8125
    nqp_get_sc_object $P8127, "1304523744.097", 15
    .const 'Sub' $P8128 = "290_1304523757.895" 
    $P8126."add_method"($P8127, "!PREFIX__circumfix:sym<[ ]>", $P8128)
    nqp_get_sc_object $P8129, "1304523744.097", 15
    get_how $P8130, $P8129
    nqp_get_sc_object $P8131, "1304523744.097", 15
    .const 'Sub' $P8132 = "291_1304523757.895" 
    $P8130."add_method"($P8131, "circumfix:sym<ang>", $P8132)
    nqp_get_sc_object $P8133, "1304523744.097", 15
    get_how $P8134, $P8133
    nqp_get_sc_object $P8135, "1304523744.097", 15
    .const 'Sub' $P8136 = "292_1304523757.895" 
    $P8134."add_method"($P8135, "!PREFIX__circumfix:sym<ang>", $P8136)
    nqp_get_sc_object $P8137, "1304523744.097", 15
    get_how $P8138, $P8137
    nqp_get_sc_object $P8139, "1304523744.097", 15
    .const 'Sub' $P8140 = "293_1304523757.895" 
    $P8138."add_method"($P8139, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8140)
    nqp_get_sc_object $P8141, "1304523744.097", 15
    get_how $P8142, $P8141
    nqp_get_sc_object $P8143, "1304523744.097", 15
    .const 'Sub' $P8144 = "294_1304523757.895" 
    $P8142."add_method"($P8143, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P8144)
    nqp_get_sc_object $P8145, "1304523744.097", 15
    get_how $P8146, $P8145
    nqp_get_sc_object $P8147, "1304523744.097", 15
    .const 'Sub' $P8148 = "295_1304523757.895" 
    $P8146."add_method"($P8147, "circumfix:sym<{ }>", $P8148)
    nqp_get_sc_object $P8149, "1304523744.097", 15
    get_how $P8150, $P8149
    nqp_get_sc_object $P8151, "1304523744.097", 15
    .const 'Sub' $P8152 = "296_1304523757.895" 
    $P8150."add_method"($P8151, "!PREFIX__circumfix:sym<{ }>", $P8152)
    nqp_get_sc_object $P8153, "1304523744.097", 15
    get_how $P8154, $P8153
    nqp_get_sc_object $P8155, "1304523744.097", 15
    .const 'Sub' $P8156 = "297_1304523757.895" 
    $P8154."add_method"($P8155, "circumfix:sym<sigil>", $P8156)
    nqp_get_sc_object $P8157, "1304523744.097", 15
    get_how $P8158, $P8157
    nqp_get_sc_object $P8159, "1304523744.097", 15
    .const 'Sub' $P8160 = "298_1304523757.895" 
    $P8158."add_method"($P8159, "!PREFIX__circumfix:sym<sigil>", $P8160)
    nqp_get_sc_object $P8161, "1304523744.097", 15
    get_how $P8162, $P8161
    nqp_get_sc_object $P8163, "1304523744.097", 15
    .const 'Sub' $P8164 = "299_1304523757.895" 
    $P8162."add_method"($P8163, "semilist", $P8164)
    nqp_get_sc_object $P8165, "1304523744.097", 15
    get_how $P8166, $P8165
    nqp_get_sc_object $P8167, "1304523744.097", 15
    .const 'Sub' $P8168 = "300_1304523757.895" 
    $P8166."add_method"($P8167, "!PREFIX__semilist", $P8168)
    nqp_get_sc_object $P8169, "1304523744.097", 15
    get_how $P8170, $P8169
    nqp_get_sc_object $P8171, "1304523744.097", 15
    .const 'Sub' $P8172 = "301_1304523757.895" 
    $P8170."add_method"($P8171, "infixish", $P8172)
    nqp_get_sc_object $P8173, "1304523744.097", 15
    get_how $P8174, $P8173
    nqp_get_sc_object $P8175, "1304523744.097", 15
    .const 'Sub' $P8176 = "302_1304523757.895" 
    $P8174."add_method"($P8175, "!PREFIX__infixish", $P8176)
    nqp_get_sc_object $P8177, "1304523744.097", 15
    get_how $P8178, $P8177
    nqp_get_sc_object $P8179, "1304523744.097", 15
    .const 'Sub' $P8180 = "303_1304523757.895" 
    $P8178."add_method"($P8179, "infixstopper", $P8180)
    nqp_get_sc_object $P8181, "1304523744.097", 15
    get_how $P8182, $P8181
    nqp_get_sc_object $P8183, "1304523744.097", 15
    .const 'Sub' $P8184 = "304_1304523757.895" 
    $P8182."add_method"($P8183, "!PREFIX__infixstopper", $P8184)
    nqp_get_sc_object $P8185, "1304523744.097", 15
    get_how $P8186, $P8185
    nqp_get_sc_object $P8187, "1304523744.097", 15
    .const 'Sub' $P8188 = "305_1304523757.895" 
    $P8186."add_method"($P8187, "postcircumfix:sym<[ ]>", $P8188)
    nqp_get_sc_object $P8189, "1304523744.097", 15
    get_how $P8190, $P8189
    nqp_get_sc_object $P8191, "1304523744.097", 15
    .const 'Sub' $P8192 = "306_1304523757.895" 
    $P8190."add_method"($P8191, "!PREFIX__postcircumfix:sym<[ ]>", $P8192)
    nqp_get_sc_object $P8193, "1304523744.097", 15
    get_how $P8194, $P8193
    nqp_get_sc_object $P8195, "1304523744.097", 15
    .const 'Sub' $P8196 = "307_1304523757.895" 
    $P8194."add_method"($P8195, "postcircumfix:sym<{ }>", $P8196)
    nqp_get_sc_object $P8197, "1304523744.097", 15
    get_how $P8198, $P8197
    nqp_get_sc_object $P8199, "1304523744.097", 15
    .const 'Sub' $P8200 = "308_1304523757.895" 
    $P8198."add_method"($P8199, "!PREFIX__postcircumfix:sym<{ }>", $P8200)
    nqp_get_sc_object $P8201, "1304523744.097", 15
    get_how $P8202, $P8201
    nqp_get_sc_object $P8203, "1304523744.097", 15
    .const 'Sub' $P8204 = "309_1304523757.895" 
    $P8202."add_method"($P8203, "postcircumfix:sym<ang>", $P8204)
    nqp_get_sc_object $P8205, "1304523744.097", 15
    get_how $P8206, $P8205
    nqp_get_sc_object $P8207, "1304523744.097", 15
    .const 'Sub' $P8208 = "310_1304523757.895" 
    $P8206."add_method"($P8207, "!PREFIX__postcircumfix:sym<ang>", $P8208)
    nqp_get_sc_object $P8209, "1304523744.097", 15
    get_how $P8210, $P8209
    nqp_get_sc_object $P8211, "1304523744.097", 15
    .const 'Sub' $P8212 = "311_1304523757.895" 
    $P8210."add_method"($P8211, "postcircumfix:sym<( )>", $P8212)
    nqp_get_sc_object $P8213, "1304523744.097", 15
    get_how $P8214, $P8213
    nqp_get_sc_object $P8215, "1304523744.097", 15
    .const 'Sub' $P8216 = "312_1304523757.895" 
    $P8214."add_method"($P8215, "!PREFIX__postcircumfix:sym<( )>", $P8216)
    nqp_get_sc_object $P8217, "1304523744.097", 15
    get_how $P8218, $P8217
    nqp_get_sc_object $P8219, "1304523744.097", 15
    .const 'Sub' $P8220 = "313_1304523757.895" 
    $P8218."add_method"($P8219, "postfix:sym<.>", $P8220)
    nqp_get_sc_object $P8221, "1304523744.097", 15
    get_how $P8222, $P8221
    nqp_get_sc_object $P8223, "1304523744.097", 15
    .const 'Sub' $P8224 = "314_1304523757.895" 
    $P8222."add_method"($P8223, "!PREFIX__postfix:sym<.>", $P8224)
    nqp_get_sc_object $P8225, "1304523744.097", 15
    get_how $P8226, $P8225
    nqp_get_sc_object $P8227, "1304523744.097", 15
    .const 'Sub' $P8228 = "315_1304523757.895" 
    $P8226."add_method"($P8227, "prefix:sym<++>", $P8228)
    nqp_get_sc_object $P8229, "1304523744.097", 15
    get_how $P8230, $P8229
    nqp_get_sc_object $P8231, "1304523744.097", 15
    .const 'Sub' $P8232 = "316_1304523757.895" 
    $P8230."add_method"($P8231, "!PREFIX__prefix:sym<++>", $P8232)
    nqp_get_sc_object $P8233, "1304523744.097", 15
    get_how $P8234, $P8233
    nqp_get_sc_object $P8235, "1304523744.097", 15
    .const 'Sub' $P8236 = "317_1304523757.895" 
    $P8234."add_method"($P8235, "prefix:sym<-->", $P8236)
    nqp_get_sc_object $P8237, "1304523744.097", 15
    get_how $P8238, $P8237
    nqp_get_sc_object $P8239, "1304523744.097", 15
    .const 'Sub' $P8240 = "318_1304523757.895" 
    $P8238."add_method"($P8239, "!PREFIX__prefix:sym<-->", $P8240)
    nqp_get_sc_object $P8241, "1304523744.097", 15
    get_how $P8242, $P8241
    nqp_get_sc_object $P8243, "1304523744.097", 15
    .const 'Sub' $P8244 = "319_1304523757.895" 
    $P8242."add_method"($P8243, "postfix:sym<++>", $P8244)
    nqp_get_sc_object $P8245, "1304523744.097", 15
    get_how $P8246, $P8245
    nqp_get_sc_object $P8247, "1304523744.097", 15
    .const 'Sub' $P8248 = "320_1304523757.895" 
    $P8246."add_method"($P8247, "!PREFIX__postfix:sym<++>", $P8248)
    nqp_get_sc_object $P8249, "1304523744.097", 15
    get_how $P8250, $P8249
    nqp_get_sc_object $P8251, "1304523744.097", 15
    .const 'Sub' $P8252 = "321_1304523757.895" 
    $P8250."add_method"($P8251, "postfix:sym<-->", $P8252)
    nqp_get_sc_object $P8253, "1304523744.097", 15
    get_how $P8254, $P8253
    nqp_get_sc_object $P8255, "1304523744.097", 15
    .const 'Sub' $P8256 = "322_1304523757.895" 
    $P8254."add_method"($P8255, "!PREFIX__postfix:sym<-->", $P8256)
    nqp_get_sc_object $P8257, "1304523744.097", 15
    get_how $P8258, $P8257
    nqp_get_sc_object $P8259, "1304523744.097", 15
    .const 'Sub' $P8260 = "323_1304523757.895" 
    $P8258."add_method"($P8259, "infix:sym<**>", $P8260)
    nqp_get_sc_object $P8261, "1304523744.097", 15
    get_how $P8262, $P8261
    nqp_get_sc_object $P8263, "1304523744.097", 15
    .const 'Sub' $P8264 = "324_1304523757.895" 
    $P8262."add_method"($P8263, "!PREFIX__infix:sym<**>", $P8264)
    nqp_get_sc_object $P8265, "1304523744.097", 15
    get_how $P8266, $P8265
    nqp_get_sc_object $P8267, "1304523744.097", 15
    .const 'Sub' $P8268 = "325_1304523757.895" 
    $P8266."add_method"($P8267, "prefix:sym<+>", $P8268)
    nqp_get_sc_object $P8269, "1304523744.097", 15
    get_how $P8270, $P8269
    nqp_get_sc_object $P8271, "1304523744.097", 15
    .const 'Sub' $P8272 = "326_1304523757.895" 
    $P8270."add_method"($P8271, "!PREFIX__prefix:sym<+>", $P8272)
    nqp_get_sc_object $P8273, "1304523744.097", 15
    get_how $P8274, $P8273
    nqp_get_sc_object $P8275, "1304523744.097", 15
    .const 'Sub' $P8276 = "327_1304523757.895" 
    $P8274."add_method"($P8275, "prefix:sym<~>", $P8276)
    nqp_get_sc_object $P8277, "1304523744.097", 15
    get_how $P8278, $P8277
    nqp_get_sc_object $P8279, "1304523744.097", 15
    .const 'Sub' $P8280 = "328_1304523757.895" 
    $P8278."add_method"($P8279, "!PREFIX__prefix:sym<~>", $P8280)
    nqp_get_sc_object $P8281, "1304523744.097", 15
    get_how $P8282, $P8281
    nqp_get_sc_object $P8283, "1304523744.097", 15
    .const 'Sub' $P8284 = "329_1304523757.895" 
    $P8282."add_method"($P8283, "prefix:sym<->", $P8284)
    nqp_get_sc_object $P8285, "1304523744.097", 15
    get_how $P8286, $P8285
    nqp_get_sc_object $P8287, "1304523744.097", 15
    .const 'Sub' $P8288 = "330_1304523757.895" 
    $P8286."add_method"($P8287, "!PREFIX__prefix:sym<->", $P8288)
    nqp_get_sc_object $P8289, "1304523744.097", 15
    get_how $P8290, $P8289
    nqp_get_sc_object $P8291, "1304523744.097", 15
    .const 'Sub' $P8292 = "331_1304523757.895" 
    $P8290."add_method"($P8291, "prefix:sym<?>", $P8292)
    nqp_get_sc_object $P8293, "1304523744.097", 15
    get_how $P8294, $P8293
    nqp_get_sc_object $P8295, "1304523744.097", 15
    .const 'Sub' $P8296 = "332_1304523757.895" 
    $P8294."add_method"($P8295, "!PREFIX__prefix:sym<?>", $P8296)
    nqp_get_sc_object $P8297, "1304523744.097", 15
    get_how $P8298, $P8297
    nqp_get_sc_object $P8299, "1304523744.097", 15
    .const 'Sub' $P8300 = "333_1304523757.895" 
    $P8298."add_method"($P8299, "prefix:sym<!>", $P8300)
    nqp_get_sc_object $P8301, "1304523744.097", 15
    get_how $P8302, $P8301
    nqp_get_sc_object $P8303, "1304523744.097", 15
    .const 'Sub' $P8304 = "334_1304523757.895" 
    $P8302."add_method"($P8303, "!PREFIX__prefix:sym<!>", $P8304)
    nqp_get_sc_object $P8305, "1304523744.097", 15
    get_how $P8306, $P8305
    nqp_get_sc_object $P8307, "1304523744.097", 15
    .const 'Sub' $P8308 = "335_1304523757.895" 
    $P8306."add_method"($P8307, "prefix:sym<|>", $P8308)
    nqp_get_sc_object $P8309, "1304523744.097", 15
    get_how $P8310, $P8309
    nqp_get_sc_object $P8311, "1304523744.097", 15
    .const 'Sub' $P8312 = "336_1304523757.895" 
    $P8310."add_method"($P8311, "!PREFIX__prefix:sym<|>", $P8312)
    nqp_get_sc_object $P8313, "1304523744.097", 15
    get_how $P8314, $P8313
    nqp_get_sc_object $P8315, "1304523744.097", 15
    .const 'Sub' $P8316 = "337_1304523757.895" 
    $P8314."add_method"($P8315, "infix:sym<*>", $P8316)
    nqp_get_sc_object $P8317, "1304523744.097", 15
    get_how $P8318, $P8317
    nqp_get_sc_object $P8319, "1304523744.097", 15
    .const 'Sub' $P8320 = "338_1304523757.895" 
    $P8318."add_method"($P8319, "!PREFIX__infix:sym<*>", $P8320)
    nqp_get_sc_object $P8321, "1304523744.097", 15
    get_how $P8322, $P8321
    nqp_get_sc_object $P8323, "1304523744.097", 15
    .const 'Sub' $P8324 = "339_1304523757.895" 
    $P8322."add_method"($P8323, "infix:sym</>", $P8324)
    nqp_get_sc_object $P8325, "1304523744.097", 15
    get_how $P8326, $P8325
    nqp_get_sc_object $P8327, "1304523744.097", 15
    .const 'Sub' $P8328 = "340_1304523757.895" 
    $P8326."add_method"($P8327, "!PREFIX__infix:sym</>", $P8328)
    nqp_get_sc_object $P8329, "1304523744.097", 15
    get_how $P8330, $P8329
    nqp_get_sc_object $P8331, "1304523744.097", 15
    .const 'Sub' $P8332 = "341_1304523757.895" 
    $P8330."add_method"($P8331, "infix:sym<%>", $P8332)
    nqp_get_sc_object $P8333, "1304523744.097", 15
    get_how $P8334, $P8333
    nqp_get_sc_object $P8335, "1304523744.097", 15
    .const 'Sub' $P8336 = "342_1304523757.895" 
    $P8334."add_method"($P8335, "!PREFIX__infix:sym<%>", $P8336)
    nqp_get_sc_object $P8337, "1304523744.097", 15
    get_how $P8338, $P8337
    nqp_get_sc_object $P8339, "1304523744.097", 15
    .const 'Sub' $P8340 = "343_1304523757.895" 
    $P8338."add_method"($P8339, "infix:sym<+&>", $P8340)
    nqp_get_sc_object $P8341, "1304523744.097", 15
    get_how $P8342, $P8341
    nqp_get_sc_object $P8343, "1304523744.097", 15
    .const 'Sub' $P8344 = "344_1304523757.895" 
    $P8342."add_method"($P8343, "!PREFIX__infix:sym<+&>", $P8344)
    nqp_get_sc_object $P8345, "1304523744.097", 15
    get_how $P8346, $P8345
    nqp_get_sc_object $P8347, "1304523744.097", 15
    .const 'Sub' $P8348 = "345_1304523757.895" 
    $P8346."add_method"($P8347, "infix:sym<+>", $P8348)
    nqp_get_sc_object $P8349, "1304523744.097", 15
    get_how $P8350, $P8349
    nqp_get_sc_object $P8351, "1304523744.097", 15
    .const 'Sub' $P8352 = "346_1304523757.895" 
    $P8350."add_method"($P8351, "!PREFIX__infix:sym<+>", $P8352)
    nqp_get_sc_object $P8353, "1304523744.097", 15
    get_how $P8354, $P8353
    nqp_get_sc_object $P8355, "1304523744.097", 15
    .const 'Sub' $P8356 = "347_1304523757.895" 
    $P8354."add_method"($P8355, "infix:sym<->", $P8356)
    nqp_get_sc_object $P8357, "1304523744.097", 15
    get_how $P8358, $P8357
    nqp_get_sc_object $P8359, "1304523744.097", 15
    .const 'Sub' $P8360 = "348_1304523757.895" 
    $P8358."add_method"($P8359, "!PREFIX__infix:sym<->", $P8360)
    nqp_get_sc_object $P8361, "1304523744.097", 15
    get_how $P8362, $P8361
    nqp_get_sc_object $P8363, "1304523744.097", 15
    .const 'Sub' $P8364 = "349_1304523757.895" 
    $P8362."add_method"($P8363, "infix:sym<+|>", $P8364)
    nqp_get_sc_object $P8365, "1304523744.097", 15
    get_how $P8366, $P8365
    nqp_get_sc_object $P8367, "1304523744.097", 15
    .const 'Sub' $P8368 = "350_1304523757.895" 
    $P8366."add_method"($P8367, "!PREFIX__infix:sym<+|>", $P8368)
    nqp_get_sc_object $P8369, "1304523744.097", 15
    get_how $P8370, $P8369
    nqp_get_sc_object $P8371, "1304523744.097", 15
    .const 'Sub' $P8372 = "351_1304523757.895" 
    $P8370."add_method"($P8371, "infix:sym<+^>", $P8372)
    nqp_get_sc_object $P8373, "1304523744.097", 15
    get_how $P8374, $P8373
    nqp_get_sc_object $P8375, "1304523744.097", 15
    .const 'Sub' $P8376 = "352_1304523757.895" 
    $P8374."add_method"($P8375, "!PREFIX__infix:sym<+^>", $P8376)
    nqp_get_sc_object $P8377, "1304523744.097", 15
    get_how $P8378, $P8377
    nqp_get_sc_object $P8379, "1304523744.097", 15
    .const 'Sub' $P8380 = "353_1304523757.895" 
    $P8378."add_method"($P8379, "infix:sym<~>", $P8380)
    nqp_get_sc_object $P8381, "1304523744.097", 15
    get_how $P8382, $P8381
    nqp_get_sc_object $P8383, "1304523744.097", 15
    .const 'Sub' $P8384 = "354_1304523757.895" 
    $P8382."add_method"($P8383, "!PREFIX__infix:sym<~>", $P8384)
    nqp_get_sc_object $P8385, "1304523744.097", 15
    get_how $P8386, $P8385
    nqp_get_sc_object $P8387, "1304523744.097", 15
    .const 'Sub' $P8388 = "355_1304523757.895" 
    $P8386."add_method"($P8387, "infix:sym<==>", $P8388)
    nqp_get_sc_object $P8389, "1304523744.097", 15
    get_how $P8390, $P8389
    nqp_get_sc_object $P8391, "1304523744.097", 15
    .const 'Sub' $P8392 = "356_1304523757.895" 
    $P8390."add_method"($P8391, "!PREFIX__infix:sym<==>", $P8392)
    nqp_get_sc_object $P8393, "1304523744.097", 15
    get_how $P8394, $P8393
    nqp_get_sc_object $P8395, "1304523744.097", 15
    .const 'Sub' $P8396 = "357_1304523757.895" 
    $P8394."add_method"($P8395, "infix:sym<!=>", $P8396)
    nqp_get_sc_object $P8397, "1304523744.097", 15
    get_how $P8398, $P8397
    nqp_get_sc_object $P8399, "1304523744.097", 15
    .const 'Sub' $P8400 = "358_1304523757.895" 
    $P8398."add_method"($P8399, "!PREFIX__infix:sym<!=>", $P8400)
    nqp_get_sc_object $P8401, "1304523744.097", 15
    get_how $P8402, $P8401
    nqp_get_sc_object $P8403, "1304523744.097", 15
    .const 'Sub' $P8404 = "359_1304523757.895" 
    $P8402."add_method"($P8403, "infix:sym<<=>", $P8404)
    nqp_get_sc_object $P8405, "1304523744.097", 15
    get_how $P8406, $P8405
    nqp_get_sc_object $P8407, "1304523744.097", 15
    .const 'Sub' $P8408 = "360_1304523757.895" 
    $P8406."add_method"($P8407, "!PREFIX__infix:sym<<=>", $P8408)
    nqp_get_sc_object $P8409, "1304523744.097", 15
    get_how $P8410, $P8409
    nqp_get_sc_object $P8411, "1304523744.097", 15
    .const 'Sub' $P8412 = "361_1304523757.895" 
    $P8410."add_method"($P8411, "infix:sym<>=>", $P8412)
    nqp_get_sc_object $P8413, "1304523744.097", 15
    get_how $P8414, $P8413
    nqp_get_sc_object $P8415, "1304523744.097", 15
    .const 'Sub' $P8416 = "362_1304523757.895" 
    $P8414."add_method"($P8415, "!PREFIX__infix:sym<>=>", $P8416)
    nqp_get_sc_object $P8417, "1304523744.097", 15
    get_how $P8418, $P8417
    nqp_get_sc_object $P8419, "1304523744.097", 15
    .const 'Sub' $P8420 = "363_1304523757.895" 
    $P8418."add_method"($P8419, "infix:sym<<>", $P8420)
    nqp_get_sc_object $P8421, "1304523744.097", 15
    get_how $P8422, $P8421
    nqp_get_sc_object $P8423, "1304523744.097", 15
    .const 'Sub' $P8424 = "364_1304523757.895" 
    $P8422."add_method"($P8423, "!PREFIX__infix:sym<<>", $P8424)
    nqp_get_sc_object $P8425, "1304523744.097", 15
    get_how $P8426, $P8425
    nqp_get_sc_object $P8427, "1304523744.097", 15
    .const 'Sub' $P8428 = "365_1304523757.895" 
    $P8426."add_method"($P8427, "infix:sym<>>", $P8428)
    nqp_get_sc_object $P8429, "1304523744.097", 15
    get_how $P8430, $P8429
    nqp_get_sc_object $P8431, "1304523744.097", 15
    .const 'Sub' $P8432 = "366_1304523757.895" 
    $P8430."add_method"($P8431, "!PREFIX__infix:sym<>>", $P8432)
    nqp_get_sc_object $P8433, "1304523744.097", 15
    get_how $P8434, $P8433
    nqp_get_sc_object $P8435, "1304523744.097", 15
    .const 'Sub' $P8436 = "367_1304523757.895" 
    $P8434."add_method"($P8435, "infix:sym<eq>", $P8436)
    nqp_get_sc_object $P8437, "1304523744.097", 15
    get_how $P8438, $P8437
    nqp_get_sc_object $P8439, "1304523744.097", 15
    .const 'Sub' $P8440 = "368_1304523757.895" 
    $P8438."add_method"($P8439, "!PREFIX__infix:sym<eq>", $P8440)
    nqp_get_sc_object $P8441, "1304523744.097", 15
    get_how $P8442, $P8441
    nqp_get_sc_object $P8443, "1304523744.097", 15
    .const 'Sub' $P8444 = "369_1304523757.895" 
    $P8442."add_method"($P8443, "infix:sym<ne>", $P8444)
    nqp_get_sc_object $P8445, "1304523744.097", 15
    get_how $P8446, $P8445
    nqp_get_sc_object $P8447, "1304523744.097", 15
    .const 'Sub' $P8448 = "370_1304523757.895" 
    $P8446."add_method"($P8447, "!PREFIX__infix:sym<ne>", $P8448)
    nqp_get_sc_object $P8449, "1304523744.097", 15
    get_how $P8450, $P8449
    nqp_get_sc_object $P8451, "1304523744.097", 15
    .const 'Sub' $P8452 = "371_1304523757.895" 
    $P8450."add_method"($P8451, "infix:sym<le>", $P8452)
    nqp_get_sc_object $P8453, "1304523744.097", 15
    get_how $P8454, $P8453
    nqp_get_sc_object $P8455, "1304523744.097", 15
    .const 'Sub' $P8456 = "372_1304523757.895" 
    $P8454."add_method"($P8455, "!PREFIX__infix:sym<le>", $P8456)
    nqp_get_sc_object $P8457, "1304523744.097", 15
    get_how $P8458, $P8457
    nqp_get_sc_object $P8459, "1304523744.097", 15
    .const 'Sub' $P8460 = "373_1304523757.895" 
    $P8458."add_method"($P8459, "infix:sym<ge>", $P8460)
    nqp_get_sc_object $P8461, "1304523744.097", 15
    get_how $P8462, $P8461
    nqp_get_sc_object $P8463, "1304523744.097", 15
    .const 'Sub' $P8464 = "374_1304523757.895" 
    $P8462."add_method"($P8463, "!PREFIX__infix:sym<ge>", $P8464)
    nqp_get_sc_object $P8465, "1304523744.097", 15
    get_how $P8466, $P8465
    nqp_get_sc_object $P8467, "1304523744.097", 15
    .const 'Sub' $P8468 = "375_1304523757.895" 
    $P8466."add_method"($P8467, "infix:sym<lt>", $P8468)
    nqp_get_sc_object $P8469, "1304523744.097", 15
    get_how $P8470, $P8469
    nqp_get_sc_object $P8471, "1304523744.097", 15
    .const 'Sub' $P8472 = "376_1304523757.895" 
    $P8470."add_method"($P8471, "!PREFIX__infix:sym<lt>", $P8472)
    nqp_get_sc_object $P8473, "1304523744.097", 15
    get_how $P8474, $P8473
    nqp_get_sc_object $P8475, "1304523744.097", 15
    .const 'Sub' $P8476 = "377_1304523757.895" 
    $P8474."add_method"($P8475, "infix:sym<gt>", $P8476)
    nqp_get_sc_object $P8477, "1304523744.097", 15
    get_how $P8478, $P8477
    nqp_get_sc_object $P8479, "1304523744.097", 15
    .const 'Sub' $P8480 = "378_1304523757.895" 
    $P8478."add_method"($P8479, "!PREFIX__infix:sym<gt>", $P8480)
    nqp_get_sc_object $P8481, "1304523744.097", 15
    get_how $P8482, $P8481
    nqp_get_sc_object $P8483, "1304523744.097", 15
    .const 'Sub' $P8484 = "379_1304523757.895" 
    $P8482."add_method"($P8483, "infix:sym<=:=>", $P8484)
    nqp_get_sc_object $P8485, "1304523744.097", 15
    get_how $P8486, $P8485
    nqp_get_sc_object $P8487, "1304523744.097", 15
    .const 'Sub' $P8488 = "380_1304523757.895" 
    $P8486."add_method"($P8487, "!PREFIX__infix:sym<=:=>", $P8488)
    nqp_get_sc_object $P8489, "1304523744.097", 15
    get_how $P8490, $P8489
    nqp_get_sc_object $P8491, "1304523744.097", 15
    .const 'Sub' $P8492 = "381_1304523757.895" 
    $P8490."add_method"($P8491, "infix:sym<~~>", $P8492)
    nqp_get_sc_object $P8493, "1304523744.097", 15
    get_how $P8494, $P8493
    nqp_get_sc_object $P8495, "1304523744.097", 15
    .const 'Sub' $P8496 = "382_1304523757.895" 
    $P8494."add_method"($P8495, "!PREFIX__infix:sym<~~>", $P8496)
    nqp_get_sc_object $P8497, "1304523744.097", 15
    get_how $P8498, $P8497
    nqp_get_sc_object $P8499, "1304523744.097", 15
    .const 'Sub' $P8500 = "383_1304523757.895" 
    $P8498."add_method"($P8499, "infix:sym<&&>", $P8500)
    nqp_get_sc_object $P8501, "1304523744.097", 15
    get_how $P8502, $P8501
    nqp_get_sc_object $P8503, "1304523744.097", 15
    .const 'Sub' $P8504 = "384_1304523757.895" 
    $P8502."add_method"($P8503, "!PREFIX__infix:sym<&&>", $P8504)
    nqp_get_sc_object $P8505, "1304523744.097", 15
    get_how $P8506, $P8505
    nqp_get_sc_object $P8507, "1304523744.097", 15
    .const 'Sub' $P8508 = "385_1304523757.895" 
    $P8506."add_method"($P8507, "infix:sym<||>", $P8508)
    nqp_get_sc_object $P8509, "1304523744.097", 15
    get_how $P8510, $P8509
    nqp_get_sc_object $P8511, "1304523744.097", 15
    .const 'Sub' $P8512 = "386_1304523757.895" 
    $P8510."add_method"($P8511, "!PREFIX__infix:sym<||>", $P8512)
    nqp_get_sc_object $P8513, "1304523744.097", 15
    get_how $P8514, $P8513
    nqp_get_sc_object $P8515, "1304523744.097", 15
    .const 'Sub' $P8516 = "387_1304523757.895" 
    $P8514."add_method"($P8515, "infix:sym<//>", $P8516)
    nqp_get_sc_object $P8517, "1304523744.097", 15
    get_how $P8518, $P8517
    nqp_get_sc_object $P8519, "1304523744.097", 15
    .const 'Sub' $P8520 = "388_1304523757.895" 
    $P8518."add_method"($P8519, "!PREFIX__infix:sym<//>", $P8520)
    nqp_get_sc_object $P8521, "1304523744.097", 15
    get_how $P8522, $P8521
    nqp_get_sc_object $P8523, "1304523744.097", 15
    .const 'Sub' $P8524 = "389_1304523757.895" 
    $P8522."add_method"($P8523, "infix:sym<?? !!>", $P8524)
    nqp_get_sc_object $P8525, "1304523744.097", 15
    get_how $P8526, $P8525
    nqp_get_sc_object $P8527, "1304523744.097", 15
    .const 'Sub' $P8528 = "390_1304523757.895" 
    $P8526."add_method"($P8527, "!PREFIX__infix:sym<?? !!>", $P8528)
    nqp_get_sc_object $P8529, "1304523744.097", 15
    get_how $P8530, $P8529
    nqp_get_sc_object $P8531, "1304523744.097", 15
    .const 'Sub' $P8532 = "391_1304523757.895" 
    $P8530."add_method"($P8531, "infix:sym<=>", $P8532)
    nqp_get_sc_object $P8533, "1304523744.097", 15
    get_how $P8534, $P8533
    nqp_get_sc_object $P8535, "1304523744.097", 15
    .const 'Sub' $P8536 = "392_1304523757.895" 
    $P8534."add_method"($P8535, "!PREFIX__infix:sym<=>", $P8536)
    nqp_get_sc_object $P8537, "1304523744.097", 15
    get_how $P8538, $P8537
    nqp_get_sc_object $P8539, "1304523744.097", 15
    .const 'Sub' $P8540 = "393_1304523757.895" 
    $P8538."add_method"($P8539, "infix:sym<:=>", $P8540)
    nqp_get_sc_object $P8541, "1304523744.097", 15
    get_how $P8542, $P8541
    nqp_get_sc_object $P8543, "1304523744.097", 15
    .const 'Sub' $P8544 = "394_1304523757.895" 
    $P8542."add_method"($P8543, "!PREFIX__infix:sym<:=>", $P8544)
    nqp_get_sc_object $P8545, "1304523744.097", 15
    get_how $P8546, $P8545
    nqp_get_sc_object $P8547, "1304523744.097", 15
    .const 'Sub' $P8548 = "395_1304523757.895" 
    $P8546."add_method"($P8547, "infix:sym<::=>", $P8548)
    nqp_get_sc_object $P8549, "1304523744.097", 15
    get_how $P8550, $P8549
    nqp_get_sc_object $P8551, "1304523744.097", 15
    .const 'Sub' $P8552 = "396_1304523757.895" 
    $P8550."add_method"($P8551, "!PREFIX__infix:sym<::=>", $P8552)
    nqp_get_sc_object $P8553, "1304523744.097", 15
    get_how $P8554, $P8553
    nqp_get_sc_object $P8555, "1304523744.097", 15
    .const 'Sub' $P8556 = "397_1304523757.895" 
    $P8554."add_method"($P8555, "infix:sym<,>", $P8556)
    nqp_get_sc_object $P8557, "1304523744.097", 15
    get_how $P8558, $P8557
    nqp_get_sc_object $P8559, "1304523744.097", 15
    .const 'Sub' $P8560 = "398_1304523757.895" 
    $P8558."add_method"($P8559, "!PREFIX__infix:sym<,>", $P8560)
    nqp_get_sc_object $P8561, "1304523744.097", 15
    get_how $P8562, $P8561
    nqp_get_sc_object $P8563, "1304523744.097", 15
    .const 'Sub' $P8564 = "399_1304523757.895" 
    $P8562."add_method"($P8563, "prefix:sym<return>", $P8564)
    nqp_get_sc_object $P8565, "1304523744.097", 15
    get_how $P8566, $P8565
    nqp_get_sc_object $P8567, "1304523744.097", 15
    .const 'Sub' $P8568 = "401_1304523757.895" 
    $P8566."add_method"($P8567, "!PREFIX__prefix:sym<return>", $P8568)
    nqp_get_sc_object $P8569, "1304523744.097", 15
    get_how $P8570, $P8569
    nqp_get_sc_object $P8571, "1304523744.097", 15
    .const 'Sub' $P8572 = "402_1304523757.895" 
    $P8570."add_method"($P8571, "prefix:sym<make>", $P8572)
    nqp_get_sc_object $P8573, "1304523744.097", 15
    get_how $P8574, $P8573
    nqp_get_sc_object $P8575, "1304523744.097", 15
    .const 'Sub' $P8576 = "403_1304523757.895" 
    $P8574."add_method"($P8575, "!PREFIX__prefix:sym<make>", $P8576)
    nqp_get_sc_object $P8577, "1304523744.097", 15
    get_how $P8578, $P8577
    nqp_get_sc_object $P8579, "1304523744.097", 15
    .const 'Sub' $P8580 = "404_1304523757.895" 
    $P8578."add_method"($P8579, "term:sym<last>", $P8580)
    nqp_get_sc_object $P8581, "1304523744.097", 15
    get_how $P8582, $P8581
    nqp_get_sc_object $P8583, "1304523744.097", 15
    .const 'Sub' $P8584 = "405_1304523757.895" 
    $P8582."add_method"($P8583, "!PREFIX__term:sym<last>", $P8584)
    nqp_get_sc_object $P8585, "1304523744.097", 15
    get_how $P8586, $P8585
    nqp_get_sc_object $P8587, "1304523744.097", 15
    .const 'Sub' $P8588 = "406_1304523757.895" 
    $P8586."add_method"($P8587, "term:sym<next>", $P8588)
    nqp_get_sc_object $P8589, "1304523744.097", 15
    get_how $P8590, $P8589
    nqp_get_sc_object $P8591, "1304523744.097", 15
    .const 'Sub' $P8592 = "407_1304523757.895" 
    $P8590."add_method"($P8591, "!PREFIX__term:sym<next>", $P8592)
    nqp_get_sc_object $P8593, "1304523744.097", 15
    get_how $P8594, $P8593
    nqp_get_sc_object $P8595, "1304523744.097", 15
    .const 'Sub' $P8596 = "408_1304523757.895" 
    $P8594."add_method"($P8595, "term:sym<redo>", $P8596)
    nqp_get_sc_object $P8597, "1304523744.097", 15
    get_how $P8598, $P8597
    nqp_get_sc_object $P8599, "1304523744.097", 15
    .const 'Sub' $P8600 = "409_1304523757.895" 
    $P8598."add_method"($P8599, "!PREFIX__term:sym<redo>", $P8600)
    nqp_get_sc_object $P8601, "1304523744.097", 15
    get_how $P8602, $P8601
    nqp_get_sc_object $P8603, "1304523744.097", 15
    .const 'Sub' $P8604 = "410_1304523757.895" 
    $P8602."add_method"($P8603, "smartmatch", $P8604)
    .const 'Sub' $P8605 = "38_1304523757.895" 
    $P8606 = $P8605."get_lexinfo"()
    nqp_get_sc_object $P8607, "1304523744.097", 15
    $P8606."set_static_lexpad_value"("$?PACKAGE", $P8607)
    .const 'Sub' $P8608 = "38_1304523757.895" 
    $P8609 = $P8608."get_lexinfo"()
    $P8609."finish_static_lexpad"()
    .const 'Sub' $P8610 = "38_1304523757.895" 
    $P8611 = $P8610."get_lexinfo"()
    nqp_get_sc_object $P8612, "1304523744.097", 15
    $P8611."set_static_lexpad_value"("$?CLASS", $P8612)
    .const 'Sub' $P8613 = "38_1304523757.895" 
    $P8614 = $P8613."get_lexinfo"()
    $P8614."finish_static_lexpad"()
    nqp_get_sc_object $P8615, "1304523744.097", 15
    get_how $P8616, $P8615
    nqp_get_sc_object $P8617, "1304523744.097", 15
    nqp_get_sc_object $P8618, "1304523727.177", 1
    $P8616."add_parent"($P8617, $P8618)
    nqp_get_sc_object $P8619, "1304523744.097", 15
    get_how $P8620, $P8619
    nqp_get_sc_object $P8621, "1304523744.097", 15
    $P8620."compose"($P8621)
    nqp_get_sc_object $P8622, "1304523719.327", 41
    $P8623 = $P8622."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P8623, cur_sc
    nqp_set_sc_object "1304523744.097", 374, $P8623
    nqp_get_sc_object $P8624, "1304523744.097", 374
    nqp_get_sc_object $P8625, "1304523744.097", 0
    nqp_get_package_through_who $P8626, $P8625, "NQP"
    get_who $P8627, $P8626
    set $P8627["Regex"], $P8624
    nqp_get_sc_object $P8628, "1304523744.097", 374
    get_how $P8629, $P8628
    nqp_get_sc_object $P8630, "1304523744.097", 374
    .const 'Sub' $P8631 = "412_1304523757.895" 
    $P8629."add_method"($P8630, "metachar:sym<:my>", $P8631)
    nqp_get_sc_object $P8632, "1304523744.097", 374
    get_how $P8633, $P8632
    nqp_get_sc_object $P8634, "1304523744.097", 374
    .const 'Sub' $P8635 = "414_1304523757.895" 
    $P8633."add_method"($P8634, "!PREFIX__metachar:sym<:my>", $P8635)
    nqp_get_sc_object $P8636, "1304523744.097", 374
    get_how $P8637, $P8636
    nqp_get_sc_object $P8638, "1304523744.097", 374
    .const 'Sub' $P8639 = "415_1304523757.895" 
    $P8637."add_method"($P8638, "metachar:sym<{ }>", $P8639)
    nqp_get_sc_object $P8640, "1304523744.097", 374
    get_how $P8641, $P8640
    nqp_get_sc_object $P8642, "1304523744.097", 374
    .const 'Sub' $P8643 = "416_1304523757.895" 
    $P8641."add_method"($P8642, "!PREFIX__metachar:sym<{ }>", $P8643)
    nqp_get_sc_object $P8644, "1304523744.097", 374
    get_how $P8645, $P8644
    nqp_get_sc_object $P8646, "1304523744.097", 374
    .const 'Sub' $P8647 = "417_1304523757.895" 
    $P8645."add_method"($P8646, "metachar:sym<nqpvar>", $P8647)
    nqp_get_sc_object $P8648, "1304523744.097", 374
    get_how $P8649, $P8648
    nqp_get_sc_object $P8650, "1304523744.097", 374
    .const 'Sub' $P8651 = "419_1304523757.895" 
    $P8649."add_method"($P8650, "!PREFIX__metachar:sym<nqpvar>", $P8651)
    nqp_get_sc_object $P8652, "1304523744.097", 374
    get_how $P8653, $P8652
    nqp_get_sc_object $P8654, "1304523744.097", 374
    .const 'Sub' $P8655 = "420_1304523757.895" 
    $P8653."add_method"($P8654, "assertion:sym<{ }>", $P8655)
    nqp_get_sc_object $P8656, "1304523744.097", 374
    get_how $P8657, $P8656
    nqp_get_sc_object $P8658, "1304523744.097", 374
    .const 'Sub' $P8659 = "421_1304523757.895" 
    $P8657."add_method"($P8658, "!PREFIX__assertion:sym<{ }>", $P8659)
    nqp_get_sc_object $P8660, "1304523744.097", 374
    get_how $P8661, $P8660
    nqp_get_sc_object $P8662, "1304523744.097", 374
    .const 'Sub' $P8663 = "422_1304523757.895" 
    $P8661."add_method"($P8662, "assertion:sym<?{ }>", $P8663)
    nqp_get_sc_object $P8664, "1304523744.097", 374
    get_how $P8665, $P8664
    nqp_get_sc_object $P8666, "1304523744.097", 374
    .const 'Sub' $P8667 = "424_1304523757.895" 
    $P8665."add_method"($P8666, "!PREFIX__assertion:sym<?{ }>", $P8667)
    nqp_get_sc_object $P8668, "1304523744.097", 374
    get_how $P8669, $P8668
    nqp_get_sc_object $P8670, "1304523744.097", 374
    .const 'Sub' $P8671 = "425_1304523757.895" 
    $P8669."add_method"($P8670, "assertion:sym<name>", $P8671)
    nqp_get_sc_object $P8672, "1304523744.097", 374
    get_how $P8673, $P8672
    nqp_get_sc_object $P8674, "1304523744.097", 374
    .const 'Sub' $P8675 = "427_1304523757.895" 
    $P8673."add_method"($P8674, "!PREFIX__assertion:sym<name>", $P8675)
    nqp_get_sc_object $P8676, "1304523744.097", 374
    get_how $P8677, $P8676
    nqp_get_sc_object $P8678, "1304523744.097", 374
    .const 'Sub' $P8679 = "428_1304523757.895" 
    $P8677."add_method"($P8678, "assertion:sym<var>", $P8679)
    nqp_get_sc_object $P8680, "1304523744.097", 374
    get_how $P8681, $P8680
    nqp_get_sc_object $P8682, "1304523744.097", 374
    .const 'Sub' $P8683 = "429_1304523757.895" 
    $P8681."add_method"($P8682, "!PREFIX__assertion:sym<var>", $P8683)
    nqp_get_sc_object $P8684, "1304523744.097", 374
    get_how $P8685, $P8684
    nqp_get_sc_object $P8686, "1304523744.097", 374
    .const 'Sub' $P8687 = "430_1304523757.895" 
    $P8685."add_method"($P8686, "codeblock", $P8687)
    nqp_get_sc_object $P8688, "1304523744.097", 374
    get_how $P8689, $P8688
    nqp_get_sc_object $P8690, "1304523744.097", 374
    .const 'Sub' $P8691 = "431_1304523757.895" 
    $P8689."add_method"($P8690, "!PREFIX__codeblock", $P8691)
    .const 'Sub' $P8692 = "411_1304523757.895" 
    $P8693 = $P8692."get_lexinfo"()
    nqp_get_sc_object $P8694, "1304523744.097", 374
    $P8693."set_static_lexpad_value"("$?PACKAGE", $P8694)
    .const 'Sub' $P8695 = "411_1304523757.895" 
    $P8696 = $P8695."get_lexinfo"()
    $P8696."finish_static_lexpad"()
    .const 'Sub' $P8697 = "411_1304523757.895" 
    $P8698 = $P8697."get_lexinfo"()
    nqp_get_sc_object $P8699, "1304523744.097", 374
    $P8698."set_static_lexpad_value"("$?CLASS", $P8699)
    .const 'Sub' $P8700 = "411_1304523757.895" 
    $P8701 = $P8700."get_lexinfo"()
    $P8701."finish_static_lexpad"()
    nqp_get_sc_object $P8702, "1304523744.097", 374
    get_how $P8703, $P8702
    nqp_get_sc_object $P8704, "1304523744.097", 374
    nqp_get_sc_object $P8705, "1304523737.1", 1
    $P8703."add_parent"($P8704, $P8705)
    nqp_get_sc_object $P8706, "1304523744.097", 374
    get_how $P8707, $P8706
    nqp_get_sc_object $P8708, "1304523744.097", 374
    $P8707."compose"($P8708)
    nqp_get_sc_object $P8709, "1304523719.327", 41
    $P8710 = $P8709."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P8710, cur_sc
    nqp_set_sc_object "1304523744.097", 391, $P8710
    nqp_get_sc_object $P8711, "1304523744.097", 391
    nqp_get_sc_object $P8712, "1304523744.097", 0
    nqp_get_package_through_who $P8713, $P8712, "NQP"
    get_who $P8714, $P8713
    set $P8714["Actions"], $P8711
    nqp_get_sc_object $P8715, "1304523744.097", 391
    get_how $P8716, $P8715
    nqp_get_sc_object $P8717, "1304523744.097", 391
    .const 'Sub' $P8718 = "459_1304523757.895" 
    $P8716."add_method"($P8717, "TOP", $P8718)
    nqp_get_sc_object $P8719, "1304523744.097", 391
    get_how $P8720, $P8719
    nqp_get_sc_object $P8721, "1304523744.097", 391
    .const 'Sub' $P8722 = "460_1304523757.895" 
    $P8720."add_method"($P8721, "deflongname", $P8722)
    nqp_get_sc_object $P8723, "1304523744.097", 391
    get_how $P8724, $P8723
    nqp_get_sc_object $P8725, "1304523744.097", 391
    .const 'Sub' $P8726 = "461_1304523757.895" 
    $P8724."add_method"($P8725, "comp_unit", $P8726)
    nqp_get_sc_object $P8727, "1304523744.097", 391
    get_how $P8728, $P8727
    nqp_get_sc_object $P8729, "1304523744.097", 391
    .const 'Sub' $P8730 = "462_1304523757.895" 
    $P8728."add_method"($P8729, "statementlist", $P8730)
    nqp_get_sc_object $P8731, "1304523744.097", 391
    get_how $P8732, $P8731
    nqp_get_sc_object $P8733, "1304523744.097", 391
    .const 'Sub' $P8734 = "464_1304523757.895" 
    $P8732."add_method"($P8733, "statement", $P8734)
    nqp_get_sc_object $P8735, "1304523744.097", 391
    get_how $P8736, $P8735
    nqp_get_sc_object $P8737, "1304523744.097", 391
    .const 'Sub' $P8738 = "466_1304523757.895" 
    $P8736."add_method"($P8737, "xblock", $P8738)
    nqp_get_sc_object $P8739, "1304523744.097", 391
    get_how $P8740, $P8739
    nqp_get_sc_object $P8741, "1304523744.097", 391
    .const 'Sub' $P8742 = "467_1304523757.895" 
    $P8740."add_method"($P8741, "pblock", $P8742)
    nqp_get_sc_object $P8743, "1304523744.097", 391
    get_how $P8744, $P8743
    nqp_get_sc_object $P8745, "1304523744.097", 391
    .const 'Sub' $P8746 = "468_1304523757.895" 
    $P8744."add_method"($P8745, "block", $P8746)
    nqp_get_sc_object $P8747, "1304523744.097", 391
    get_how $P8748, $P8747
    nqp_get_sc_object $P8749, "1304523744.097", 391
    .const 'Sub' $P8750 = "469_1304523757.895" 
    $P8748."add_method"($P8749, "blockoid", $P8750)
    nqp_get_sc_object $P8751, "1304523744.097", 391
    get_how $P8752, $P8751
    nqp_get_sc_object $P8753, "1304523744.097", 391
    .const 'Sub' $P8754 = "471_1304523757.895" 
    $P8752."add_method"($P8753, "newpad", $P8754)
    nqp_get_sc_object $P8755, "1304523744.097", 391
    get_how $P8756, $P8755
    nqp_get_sc_object $P8757, "1304523744.097", 391
    .const 'Sub' $P8758 = "472_1304523757.895" 
    $P8756."add_method"($P8757, "outerctx", $P8758)
    nqp_get_sc_object $P8759, "1304523744.097", 391
    get_how $P8760, $P8759
    nqp_get_sc_object $P8761, "1304523744.097", 391
    .const 'Sub' $P8762 = "474_1304523757.895" 
    $P8760."add_method"($P8761, "GLOBALish", $P8762)
    nqp_get_sc_object $P8763, "1304523744.097", 391
    get_how $P8764, $P8763
    nqp_get_sc_object $P8765, "1304523744.097", 391
    .const 'Sub' $P8766 = "475_1304523757.895" 
    $P8764."add_method"($P8765, "you_are_here", $P8766)
    nqp_get_sc_object $P8767, "1304523744.097", 391
    get_how $P8768, $P8767
    nqp_get_sc_object $P8769, "1304523744.097", 391
    .const 'Sub' $P8770 = "476_1304523757.895" 
    $P8768."add_method"($P8769, "statement_control:sym<use>", $P8770)
    nqp_get_sc_object $P8771, "1304523744.097", 391
    get_how $P8772, $P8771
    nqp_get_sc_object $P8773, "1304523744.097", 391
    .const 'Sub' $P8774 = "477_1304523757.895" 
    $P8772."add_method"($P8773, "statement_control:sym<if>", $P8774)
    nqp_get_sc_object $P8775, "1304523744.097", 391
    get_how $P8776, $P8775
    nqp_get_sc_object $P8777, "1304523744.097", 391
    .const 'Sub' $P8778 = "479_1304523757.895" 
    $P8776."add_method"($P8777, "statement_control:sym<unless>", $P8778)
    nqp_get_sc_object $P8779, "1304523744.097", 391
    get_how $P8780, $P8779
    nqp_get_sc_object $P8781, "1304523744.097", 391
    .const 'Sub' $P8782 = "480_1304523757.895" 
    $P8780."add_method"($P8781, "statement_control:sym<while>", $P8782)
    nqp_get_sc_object $P8783, "1304523744.097", 391
    get_how $P8784, $P8783
    nqp_get_sc_object $P8785, "1304523744.097", 391
    .const 'Sub' $P8786 = "481_1304523757.895" 
    $P8784."add_method"($P8785, "statement_control:sym<repeat>", $P8786)
    nqp_get_sc_object $P8787, "1304523744.097", 391
    get_how $P8788, $P8787
    nqp_get_sc_object $P8789, "1304523744.097", 391
    .const 'Sub' $P8790 = "482_1304523757.895" 
    $P8788."add_method"($P8789, "statement_control:sym<for>", $P8790)
    nqp_get_sc_object $P8791, "1304523744.097", 391
    get_how $P8792, $P8791
    nqp_get_sc_object $P8793, "1304523744.097", 391
    .const 'Sub' $P8794 = "483_1304523757.895" 
    $P8792."add_method"($P8793, "statement_control:sym<CATCH>", $P8794)
    nqp_get_sc_object $P8795, "1304523744.097", 391
    get_how $P8796, $P8795
    nqp_get_sc_object $P8797, "1304523744.097", 391
    .const 'Sub' $P8798 = "484_1304523757.895" 
    $P8796."add_method"($P8797, "statement_control:sym<CONTROL>", $P8798)
    nqp_get_sc_object $P8799, "1304523744.097", 391
    get_how $P8800, $P8799
    nqp_get_sc_object $P8801, "1304523744.097", 391
    .const 'Sub' $P8802 = "485_1304523757.895" 
    $P8800."add_method"($P8801, "statement_prefix:sym<INIT>", $P8802)
    nqp_get_sc_object $P8803, "1304523744.097", 391
    get_how $P8804, $P8803
    nqp_get_sc_object $P8805, "1304523744.097", 391
    .const 'Sub' $P8806 = "486_1304523757.895" 
    $P8804."add_method"($P8805, "statement_prefix:sym<try>", $P8806)
    nqp_get_sc_object $P8807, "1304523744.097", 391
    get_how $P8808, $P8807
    nqp_get_sc_object $P8809, "1304523744.097", 391
    .const 'Sub' $P8810 = "487_1304523757.895" 
    $P8808."add_method"($P8809, "blorst", $P8810)
    nqp_get_sc_object $P8811, "1304523744.097", 391
    get_how $P8812, $P8811
    nqp_get_sc_object $P8813, "1304523744.097", 391
    .const 'Sub' $P8814 = "488_1304523757.895" 
    $P8812."add_method"($P8813, "statement_mod_cond:sym<if>", $P8814)
    nqp_get_sc_object $P8815, "1304523744.097", 391
    get_how $P8816, $P8815
    nqp_get_sc_object $P8817, "1304523744.097", 391
    .const 'Sub' $P8818 = "489_1304523757.895" 
    $P8816."add_method"($P8817, "statement_mod_cond:sym<unless>", $P8818)
    nqp_get_sc_object $P8819, "1304523744.097", 391
    get_how $P8820, $P8819
    nqp_get_sc_object $P8821, "1304523744.097", 391
    .const 'Sub' $P8822 = "490_1304523757.895" 
    $P8820."add_method"($P8821, "statement_mod_loop:sym<while>", $P8822)
    nqp_get_sc_object $P8823, "1304523744.097", 391
    get_how $P8824, $P8823
    nqp_get_sc_object $P8825, "1304523744.097", 391
    .const 'Sub' $P8826 = "491_1304523757.895" 
    $P8824."add_method"($P8825, "statement_mod_loop:sym<until>", $P8826)
    nqp_get_sc_object $P8827, "1304523744.097", 391
    get_how $P8828, $P8827
    nqp_get_sc_object $P8829, "1304523744.097", 391
    .const 'Sub' $P8830 = "492_1304523757.895" 
    $P8828."add_method"($P8829, "term:sym<fatarrow>", $P8830)
    nqp_get_sc_object $P8831, "1304523744.097", 391
    get_how $P8832, $P8831
    nqp_get_sc_object $P8833, "1304523744.097", 391
    .const 'Sub' $P8834 = "493_1304523757.895" 
    $P8832."add_method"($P8833, "term:sym<colonpair>", $P8834)
    nqp_get_sc_object $P8835, "1304523744.097", 391
    get_how $P8836, $P8835
    nqp_get_sc_object $P8837, "1304523744.097", 391
    .const 'Sub' $P8838 = "494_1304523757.895" 
    $P8836."add_method"($P8837, "term:sym<variable>", $P8838)
    nqp_get_sc_object $P8839, "1304523744.097", 391
    get_how $P8840, $P8839
    nqp_get_sc_object $P8841, "1304523744.097", 391
    .const 'Sub' $P8842 = "495_1304523757.895" 
    $P8840."add_method"($P8841, "term:sym<package_declarator>", $P8842)
    nqp_get_sc_object $P8843, "1304523744.097", 391
    get_how $P8844, $P8843
    nqp_get_sc_object $P8845, "1304523744.097", 391
    .const 'Sub' $P8846 = "496_1304523757.895" 
    $P8844."add_method"($P8845, "term:sym<scope_declarator>", $P8846)
    nqp_get_sc_object $P8847, "1304523744.097", 391
    get_how $P8848, $P8847
    nqp_get_sc_object $P8849, "1304523744.097", 391
    .const 'Sub' $P8850 = "497_1304523757.895" 
    $P8848."add_method"($P8849, "term:sym<routine_declarator>", $P8850)
    nqp_get_sc_object $P8851, "1304523744.097", 391
    get_how $P8852, $P8851
    nqp_get_sc_object $P8853, "1304523744.097", 391
    .const 'Sub' $P8854 = "498_1304523757.895" 
    $P8852."add_method"($P8853, "term:sym<regex_declarator>", $P8854)
    nqp_get_sc_object $P8855, "1304523744.097", 391
    get_how $P8856, $P8855
    nqp_get_sc_object $P8857, "1304523744.097", 391
    .const 'Sub' $P8858 = "499_1304523757.895" 
    $P8856."add_method"($P8857, "term:sym<statement_prefix>", $P8858)
    nqp_get_sc_object $P8859, "1304523744.097", 391
    get_how $P8860, $P8859
    nqp_get_sc_object $P8861, "1304523744.097", 391
    .const 'Sub' $P8862 = "500_1304523757.895" 
    $P8860."add_method"($P8861, "term:sym<lambda>", $P8862)
    nqp_get_sc_object $P8863, "1304523744.097", 391
    get_how $P8864, $P8863
    nqp_get_sc_object $P8865, "1304523744.097", 391
    .const 'Sub' $P8866 = "501_1304523757.895" 
    $P8864."add_method"($P8865, "fatarrow", $P8866)
    nqp_get_sc_object $P8867, "1304523744.097", 391
    get_how $P8868, $P8867
    nqp_get_sc_object $P8869, "1304523744.097", 391
    .const 'Sub' $P8870 = "502_1304523757.895" 
    $P8868."add_method"($P8869, "colonpair", $P8870)
    nqp_get_sc_object $P8871, "1304523744.097", 391
    get_how $P8872, $P8871
    nqp_get_sc_object $P8873, "1304523744.097", 391
    .const 'Sub' $P8874 = "503_1304523757.895" 
    $P8872."add_method"($P8873, "variable", $P8874)
    nqp_get_sc_object $P8875, "1304523744.097", 391
    get_how $P8876, $P8875
    nqp_get_sc_object $P8877, "1304523744.097", 391
    .const 'Sub' $P8878 = "509_1304523757.895" 
    $P8876."add_method"($P8877, "package_declarator:sym<module>", $P8878)
    nqp_get_sc_object $P8879, "1304523744.097", 391
    get_how $P8880, $P8879
    nqp_get_sc_object $P8881, "1304523744.097", 391
    .const 'Sub' $P8882 = "510_1304523757.895" 
    $P8880."add_method"($P8881, "package_declarator:sym<knowhow>", $P8882)
    nqp_get_sc_object $P8883, "1304523744.097", 391
    get_how $P8884, $P8883
    nqp_get_sc_object $P8885, "1304523744.097", 391
    .const 'Sub' $P8886 = "511_1304523757.895" 
    $P8884."add_method"($P8885, "package_declarator:sym<class>", $P8886)
    nqp_get_sc_object $P8887, "1304523744.097", 391
    get_how $P8888, $P8887
    nqp_get_sc_object $P8889, "1304523744.097", 391
    .const 'Sub' $P8890 = "512_1304523757.895" 
    $P8888."add_method"($P8889, "package_declarator:sym<grammar>", $P8890)
    nqp_get_sc_object $P8891, "1304523744.097", 391
    get_how $P8892, $P8891
    nqp_get_sc_object $P8893, "1304523744.097", 391
    .const 'Sub' $P8894 = "513_1304523757.895" 
    $P8892."add_method"($P8893, "package_declarator:sym<role>", $P8894)
    nqp_get_sc_object $P8895, "1304523744.097", 391
    get_how $P8896, $P8895
    nqp_get_sc_object $P8897, "1304523744.097", 391
    .const 'Sub' $P8898 = "514_1304523757.895" 
    $P8896."add_method"($P8897, "package_declarator:sym<native>", $P8898)
    nqp_get_sc_object $P8899, "1304523744.097", 391
    get_how $P8900, $P8899
    nqp_get_sc_object $P8901, "1304523744.097", 391
    .const 'Sub' $P8902 = "515_1304523757.895" 
    $P8900."add_method"($P8901, "package_def", $P8902)
    nqp_get_sc_object $P8903, "1304523744.097", 391
    get_how $P8904, $P8903
    nqp_get_sc_object $P8905, "1304523744.097", 391
    .const 'Sub' $P8906 = "521_1304523757.895" 
    $P8904."add_method"($P8905, "scope_declarator:sym<my>", $P8906)
    nqp_get_sc_object $P8907, "1304523744.097", 391
    get_how $P8908, $P8907
    nqp_get_sc_object $P8909, "1304523744.097", 391
    .const 'Sub' $P8910 = "522_1304523757.895" 
    $P8908."add_method"($P8909, "scope_declarator:sym<our>", $P8910)
    nqp_get_sc_object $P8911, "1304523744.097", 391
    get_how $P8912, $P8911
    nqp_get_sc_object $P8913, "1304523744.097", 391
    .const 'Sub' $P8914 = "523_1304523757.895" 
    $P8912."add_method"($P8913, "scope_declarator:sym<has>", $P8914)
    nqp_get_sc_object $P8915, "1304523744.097", 391
    get_how $P8916, $P8915
    nqp_get_sc_object $P8917, "1304523744.097", 391
    .const 'Sub' $P8918 = "524_1304523757.895" 
    $P8916."add_method"($P8917, "scoped", $P8918)
    nqp_get_sc_object $P8919, "1304523744.097", 391
    get_how $P8920, $P8919
    nqp_get_sc_object $P8921, "1304523744.097", 391
    .const 'Sub' $P8922 = "525_1304523757.895" 
    $P8920."add_method"($P8921, "declarator", $P8922)
    nqp_get_sc_object $P8923, "1304523744.097", 391
    get_how $P8924, $P8923
    nqp_get_sc_object $P8925, "1304523744.097", 391
    .const 'Sub' $P8926 = "526_1304523757.895" 
    $P8924."add_method"($P8925, "multi_declarator:sym<multi>", $P8926)
    nqp_get_sc_object $P8927, "1304523744.097", 391
    get_how $P8928, $P8927
    nqp_get_sc_object $P8929, "1304523744.097", 391
    .const 'Sub' $P8930 = "527_1304523757.895" 
    $P8928."add_method"($P8929, "multi_declarator:sym<proto>", $P8930)
    nqp_get_sc_object $P8931, "1304523744.097", 391
    get_how $P8932, $P8931
    nqp_get_sc_object $P8933, "1304523744.097", 391
    .const 'Sub' $P8934 = "528_1304523757.895" 
    $P8932."add_method"($P8933, "multi_declarator:sym<null>", $P8934)
    nqp_get_sc_object $P8935, "1304523744.097", 391
    get_how $P8936, $P8935
    nqp_get_sc_object $P8937, "1304523744.097", 391
    .const 'Sub' $P8938 = "529_1304523757.895" 
    $P8936."add_method"($P8937, "variable_declarator", $P8938)
    nqp_get_sc_object $P8939, "1304523744.097", 391
    get_how $P8940, $P8939
    nqp_get_sc_object $P8941, "1304523744.097", 391
    .const 'Sub' $P8942 = "531_1304523757.895" 
    $P8940."add_method"($P8941, "routine_declarator:sym<sub>", $P8942)
    nqp_get_sc_object $P8943, "1304523744.097", 391
    get_how $P8944, $P8943
    nqp_get_sc_object $P8945, "1304523744.097", 391
    .const 'Sub' $P8946 = "532_1304523757.895" 
    $P8944."add_method"($P8945, "routine_declarator:sym<method>", $P8946)
    nqp_get_sc_object $P8947, "1304523744.097", 391
    get_how $P8948, $P8947
    nqp_get_sc_object $P8949, "1304523744.097", 391
    .const 'Sub' $P8950 = "533_1304523757.895" 
    $P8948."add_method"($P8949, "routine_def", $P8950)
    nqp_get_sc_object $P8951, "1304523744.097", 391
    get_how $P8952, $P8951
    nqp_get_sc_object $P8953, "1304523744.097", 391
    .const 'Sub' $P8954 = "540_1304523757.895" 
    $P8952."add_method"($P8953, "method_def", $P8954)
    nqp_get_sc_object $P8955, "1304523744.097", 391
    get_how $P8956, $P8955
    nqp_get_sc_object $P8957, "1304523744.097", 391
    .const 'Sub' $P8958 = "543_1304523757.895" 
    $P8956."add_method"($P8957, "signature", $P8958)
    nqp_get_sc_object $P8959, "1304523744.097", 391
    get_how $P8960, $P8959
    nqp_get_sc_object $P8961, "1304523744.097", 391
    .const 'Sub' $P8962 = "546_1304523757.895" 
    $P8960."add_method"($P8961, "parameter", $P8962)
    nqp_get_sc_object $P8963, "1304523744.097", 391
    get_how $P8964, $P8963
    nqp_get_sc_object $P8965, "1304523744.097", 391
    .const 'Sub' $P8966 = "547_1304523757.895" 
    $P8964."add_method"($P8965, "param_var", $P8966)
    nqp_get_sc_object $P8967, "1304523744.097", 391
    get_how $P8968, $P8967
    nqp_get_sc_object $P8969, "1304523744.097", 391
    .const 'Sub' $P8970 = "548_1304523757.895" 
    $P8968."add_method"($P8969, "named_param", $P8970)
    nqp_get_sc_object $P8971, "1304523744.097", 391
    get_how $P8972, $P8971
    nqp_get_sc_object $P8973, "1304523744.097", 391
    .const 'Sub' $P8974 = "549_1304523757.895" 
    $P8972."add_method"($P8973, "typename", $P8974)
    nqp_get_sc_object $P8975, "1304523744.097", 391
    get_how $P8976, $P8975
    nqp_get_sc_object $P8977, "1304523744.097", 391
    .const 'Sub' $P8978 = "551_1304523757.895" 
    $P8976."add_method"($P8977, "trait", $P8978)
    nqp_get_sc_object $P8979, "1304523744.097", 391
    get_how $P8980, $P8979
    nqp_get_sc_object $P8981, "1304523744.097", 391
    .const 'Sub' $P8982 = "552_1304523757.895" 
    $P8980."add_method"($P8981, "trait_mod:sym<is>", $P8982)
    nqp_get_sc_object $P8983, "1304523744.097", 391
    get_how $P8984, $P8983
    nqp_get_sc_object $P8985, "1304523744.097", 391
    .const 'Sub' $P8986 = "555_1304523757.895" 
    $P8984."add_method"($P8985, "regex_declarator", $P8986)
    nqp_get_sc_object $P8987, "1304523744.097", 391
    get_how $P8988, $P8987
    nqp_get_sc_object $P8989, "1304523744.097", 391
    .const 'Sub' $P8990 = "560_1304523757.895" 
    $P8988."add_method"($P8989, "dotty", $P8990)
    nqp_get_sc_object $P8991, "1304523744.097", 391
    get_how $P8992, $P8991
    nqp_get_sc_object $P8993, "1304523744.097", 391
    .const 'Sub' $P8994 = "561_1304523757.895" 
    $P8992."add_method"($P8993, "term:sym<self>", $P8994)
    nqp_get_sc_object $P8995, "1304523744.097", 391
    get_how $P8996, $P8995
    nqp_get_sc_object $P8997, "1304523744.097", 391
    .const 'Sub' $P8998 = "562_1304523757.895" 
    $P8996."add_method"($P8997, "term:sym<identifier>", $P8998)
    nqp_get_sc_object $P8999, "1304523744.097", 391
    get_how $P9000, $P8999
    nqp_get_sc_object $P9001, "1304523744.097", 391
    .const 'Sub' $P9002 = "563_1304523757.895" 
    $P9000."add_method"($P9001, "term:sym<name>", $P9002)
    nqp_get_sc_object $P9003, "1304523744.097", 391
    get_how $P9004, $P9003
    nqp_get_sc_object $P9005, "1304523744.097", 391
    .const 'Sub' $P9006 = "565_1304523757.895" 
    $P9004."add_method"($P9005, "term:sym<pir::op>", $P9006)
    nqp_get_sc_object $P9007, "1304523744.097", 391
    get_how $P9008, $P9007
    nqp_get_sc_object $P9009, "1304523744.097", 391
    .const 'Sub' $P9010 = "566_1304523757.895" 
    $P9008."add_method"($P9009, "term:sym<onlystar>", $P9010)
    nqp_get_sc_object $P9011, "1304523744.097", 391
    get_how $P9012, $P9011
    nqp_get_sc_object $P9013, "1304523744.097", 391
    .const 'Sub' $P9014 = "567_1304523757.895" 
    $P9012."add_method"($P9013, "args", $P9014)
    nqp_get_sc_object $P9015, "1304523744.097", 391
    get_how $P9016, $P9015
    nqp_get_sc_object $P9017, "1304523744.097", 391
    .const 'Sub' $P9018 = "568_1304523757.895" 
    $P9016."add_method"($P9017, "arglist", $P9018)
    nqp_get_sc_object $P9019, "1304523744.097", 391
    get_how $P9020, $P9019
    nqp_get_sc_object $P9021, "1304523744.097", 391
    .const 'Sub' $P9022 = "571_1304523757.895" 
    $P9020."add_method"($P9021, "term:sym<multi_declarator>", $P9022)
    nqp_get_sc_object $P9023, "1304523744.097", 391
    get_how $P9024, $P9023
    nqp_get_sc_object $P9025, "1304523744.097", 391
    .const 'Sub' $P9026 = "572_1304523757.895" 
    $P9024."add_method"($P9025, "term:sym<value>", $P9026)
    nqp_get_sc_object $P9027, "1304523744.097", 391
    get_how $P9028, $P9027
    nqp_get_sc_object $P9029, "1304523744.097", 391
    .const 'Sub' $P9030 = "573_1304523757.895" 
    $P9028."add_method"($P9029, "circumfix:sym<( )>", $P9030)
    nqp_get_sc_object $P9031, "1304523744.097", 391
    get_how $P9032, $P9031
    nqp_get_sc_object $P9033, "1304523744.097", 391
    .const 'Sub' $P9034 = "574_1304523757.895" 
    $P9032."add_method"($P9033, "circumfix:sym<[ ]>", $P9034)
    nqp_get_sc_object $P9035, "1304523744.097", 391
    get_how $P9036, $P9035
    nqp_get_sc_object $P9037, "1304523744.097", 391
    .const 'Sub' $P9038 = "575_1304523757.895" 
    $P9036."add_method"($P9037, "circumfix:sym<ang>", $P9038)
    nqp_get_sc_object $P9039, "1304523744.097", 391
    get_how $P9040, $P9039
    nqp_get_sc_object $P9041, "1304523744.097", 391
    .const 'Sub' $P9042 = "576_1304523757.895" 
    $P9040."add_method"($P9041, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P9042)
    nqp_get_sc_object $P9043, "1304523744.097", 391
    get_how $P9044, $P9043
    nqp_get_sc_object $P9045, "1304523744.097", 391
    .const 'Sub' $P9046 = "577_1304523757.895" 
    $P9044."add_method"($P9045, "circumfix:sym<{ }>", $P9046)
    nqp_get_sc_object $P9047, "1304523744.097", 391
    get_how $P9048, $P9047
    nqp_get_sc_object $P9049, "1304523744.097", 391
    .const 'Sub' $P9050 = "579_1304523757.895" 
    $P9048."add_method"($P9049, "circumfix:sym<sigil>", $P9050)
    nqp_get_sc_object $P9051, "1304523744.097", 391
    get_how $P9052, $P9051
    nqp_get_sc_object $P9053, "1304523744.097", 391
    .const 'Sub' $P9054 = "580_1304523757.895" 
    $P9052."add_method"($P9053, "semilist", $P9054)
    nqp_get_sc_object $P9055, "1304523744.097", 391
    get_how $P9056, $P9055
    nqp_get_sc_object $P9057, "1304523744.097", 391
    .const 'Sub' $P9058 = "581_1304523757.895" 
    $P9056."add_method"($P9057, "postcircumfix:sym<[ ]>", $P9058)
    nqp_get_sc_object $P9059, "1304523744.097", 391
    get_how $P9060, $P9059
    nqp_get_sc_object $P9061, "1304523744.097", 391
    .const 'Sub' $P9062 = "582_1304523757.895" 
    $P9060."add_method"($P9061, "postcircumfix:sym<{ }>", $P9062)
    nqp_get_sc_object $P9063, "1304523744.097", 391
    get_how $P9064, $P9063
    nqp_get_sc_object $P9065, "1304523744.097", 391
    .const 'Sub' $P9066 = "583_1304523757.895" 
    $P9064."add_method"($P9065, "postcircumfix:sym<ang>", $P9066)
    nqp_get_sc_object $P9067, "1304523744.097", 391
    get_how $P9068, $P9067
    nqp_get_sc_object $P9069, "1304523744.097", 391
    .const 'Sub' $P9070 = "584_1304523757.895" 
    $P9068."add_method"($P9069, "postcircumfix:sym<( )>", $P9070)
    nqp_get_sc_object $P9071, "1304523744.097", 391
    get_how $P9072, $P9071
    nqp_get_sc_object $P9073, "1304523744.097", 391
    .const 'Sub' $P9074 = "585_1304523757.895" 
    $P9072."add_method"($P9073, "value", $P9074)
    nqp_get_sc_object $P9075, "1304523744.097", 391
    get_how $P9076, $P9075
    nqp_get_sc_object $P9077, "1304523744.097", 391
    .const 'Sub' $P9078 = "586_1304523757.895" 
    $P9076."add_method"($P9077, "number", $P9078)
    nqp_get_sc_object $P9079, "1304523744.097", 391
    get_how $P9080, $P9079
    nqp_get_sc_object $P9081, "1304523744.097", 391
    .const 'Sub' $P9082 = "587_1304523757.895" 
    $P9080."add_method"($P9081, "quote:sym<apos>", $P9082)
    nqp_get_sc_object $P9083, "1304523744.097", 391
    get_how $P9084, $P9083
    nqp_get_sc_object $P9085, "1304523744.097", 391
    .const 'Sub' $P9086 = "588_1304523757.895" 
    $P9084."add_method"($P9085, "quote:sym<dblq>", $P9086)
    nqp_get_sc_object $P9087, "1304523744.097", 391
    get_how $P9088, $P9087
    nqp_get_sc_object $P9089, "1304523744.097", 391
    .const 'Sub' $P9090 = "589_1304523757.895" 
    $P9088."add_method"($P9089, "quote:sym<qq>", $P9090)
    nqp_get_sc_object $P9091, "1304523744.097", 391
    get_how $P9092, $P9091
    nqp_get_sc_object $P9093, "1304523744.097", 391
    .const 'Sub' $P9094 = "590_1304523757.895" 
    $P9092."add_method"($P9093, "quote:sym<q>", $P9094)
    nqp_get_sc_object $P9095, "1304523744.097", 391
    get_how $P9096, $P9095
    nqp_get_sc_object $P9097, "1304523744.097", 391
    .const 'Sub' $P9098 = "591_1304523757.895" 
    $P9096."add_method"($P9097, "quote:sym<Q>", $P9098)
    nqp_get_sc_object $P9099, "1304523744.097", 391
    get_how $P9100, $P9099
    nqp_get_sc_object $P9101, "1304523744.097", 391
    .const 'Sub' $P9102 = "592_1304523757.895" 
    $P9100."add_method"($P9101, "quote:sym<Q:PIR>", $P9102)
    nqp_get_sc_object $P9103, "1304523744.097", 391
    get_how $P9104, $P9103
    nqp_get_sc_object $P9105, "1304523744.097", 391
    .const 'Sub' $P9106 = "593_1304523757.895" 
    $P9104."add_method"($P9105, "quote:sym</ />", $P9106)
    nqp_get_sc_object $P9107, "1304523744.097", 391
    get_how $P9108, $P9107
    nqp_get_sc_object $P9109, "1304523744.097", 391
    .const 'Sub' $P9110 = "594_1304523757.895" 
    $P9108."add_method"($P9109, "quote_escape:sym<$>", $P9110)
    nqp_get_sc_object $P9111, "1304523744.097", 391
    get_how $P9112, $P9111
    nqp_get_sc_object $P9113, "1304523744.097", 391
    .const 'Sub' $P9114 = "595_1304523757.895" 
    $P9112."add_method"($P9113, "quote_escape:sym<{ }>", $P9114)
    nqp_get_sc_object $P9115, "1304523744.097", 391
    get_how $P9116, $P9115
    nqp_get_sc_object $P9117, "1304523744.097", 391
    .const 'Sub' $P9118 = "596_1304523757.895" 
    $P9116."add_method"($P9117, "quote_escape:sym<esc>", $P9118)
    nqp_get_sc_object $P9119, "1304523744.097", 391
    get_how $P9120, $P9119
    nqp_get_sc_object $P9121, "1304523744.097", 391
    .const 'Sub' $P9122 = "597_1304523757.895" 
    $P9120."add_method"($P9121, "postfix:sym<.>", $P9122)
    nqp_get_sc_object $P9123, "1304523744.097", 391
    get_how $P9124, $P9123
    nqp_get_sc_object $P9125, "1304523744.097", 391
    .const 'Sub' $P9126 = "598_1304523757.895" 
    $P9124."add_method"($P9125, "postfix:sym<++>", $P9126)
    nqp_get_sc_object $P9127, "1304523744.097", 391
    get_how $P9128, $P9127
    nqp_get_sc_object $P9129, "1304523744.097", 391
    .const 'Sub' $P9130 = "599_1304523757.895" 
    $P9128."add_method"($P9129, "postfix:sym<-->", $P9130)
    nqp_get_sc_object $P9131, "1304523744.097", 391
    get_how $P9132, $P9131
    nqp_get_sc_object $P9133, "1304523744.097", 391
    .const 'Sub' $P9134 = "600_1304523757.895" 
    $P9132."add_method"($P9133, "prefix:sym<make>", $P9134)
    nqp_get_sc_object $P9135, "1304523744.097", 391
    get_how $P9136, $P9135
    nqp_get_sc_object $P9137, "1304523744.097", 391
    .const 'Sub' $P9138 = "601_1304523757.895" 
    $P9136."add_method"($P9137, "term:sym<next>", $P9138)
    nqp_get_sc_object $P9139, "1304523744.097", 391
    get_how $P9140, $P9139
    nqp_get_sc_object $P9141, "1304523744.097", 391
    .const 'Sub' $P9142 = "602_1304523757.895" 
    $P9140."add_method"($P9141, "term:sym<last>", $P9142)
    nqp_get_sc_object $P9143, "1304523744.097", 391
    get_how $P9144, $P9143
    nqp_get_sc_object $P9145, "1304523744.097", 391
    .const 'Sub' $P9146 = "603_1304523757.895" 
    $P9144."add_method"($P9145, "term:sym<redo>", $P9146)
    nqp_get_sc_object $P9147, "1304523744.097", 391
    get_how $P9148, $P9147
    nqp_get_sc_object $P9149, "1304523744.097", 391
    .const 'Sub' $P9150 = "604_1304523757.895" 
    $P9148."add_method"($P9149, "infix:sym<~~>", $P9150)
    nqp_get_sc_object $P9151, "1304523744.097", 391
    get_how $P9152, $P9151
    nqp_get_sc_object $P9153, "1304523744.097", 391
    .const 'Sub' $P9154 = "605_1304523757.895" 
    $P9152."add_method"($P9153, "known_sym", $P9154)
    .const 'Sub' $P9155 = "432_1304523757.895" 
    $P9156 = $P9155."get_lexinfo"()
    nqp_get_sc_object $P9157, "1304523744.097", 391
    $P9156."set_static_lexpad_value"("$?PACKAGE", $P9157)
    .const 'Sub' $P9158 = "432_1304523757.895" 
    $P9159 = $P9158."get_lexinfo"()
    $P9159."finish_static_lexpad"()
    .const 'Sub' $P9160 = "432_1304523757.895" 
    $P9161 = $P9160."get_lexinfo"()
    nqp_get_sc_object $P9162, "1304523744.097", 391
    $P9161."set_static_lexpad_value"("$?CLASS", $P9162)
    .const 'Sub' $P9163 = "432_1304523757.895" 
    $P9164 = $P9163."get_lexinfo"()
    $P9164."finish_static_lexpad"()
    nqp_get_sc_object $P9165, "1304523744.097", 391
    get_how $P9166, $P9165
    nqp_get_sc_object $P9167, "1304523744.097", 391
    nqp_get_sc_object $P9168, "1304523727.177", 105
    $P9166."add_parent"($P9167, $P9168)
    nqp_get_sc_object $P9169, "1304523744.097", 391
    get_how $P9170, $P9169
    nqp_get_sc_object $P9171, "1304523744.097", 391
    $P9170."compose"($P9171)
    nqp_get_sc_object $P9172, "1304523719.327", 41
    $P9173 = $P9172."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P9173, cur_sc
    nqp_set_sc_object "1304523744.097", 502, $P9173
    nqp_get_sc_object $P9174, "1304523744.097", 502
    nqp_get_sc_object $P9175, "1304523744.097", 0
    nqp_get_package_through_who $P9176, $P9175, "NQP"
    get_who $P9177, $P9176
    set $P9177["RegexActions"], $P9174
    nqp_get_sc_object $P9178, "1304523744.097", 502
    get_how $P9179, $P9178
    nqp_get_sc_object $P9180, "1304523744.097", 502
    .const 'Sub' $P9181 = "608_1304523757.895" 
    $P9179."add_method"($P9180, "metachar:sym<:my>", $P9181)
    nqp_get_sc_object $P9182, "1304523744.097", 502
    get_how $P9183, $P9182
    nqp_get_sc_object $P9184, "1304523744.097", 502
    .const 'Sub' $P9185 = "609_1304523757.895" 
    $P9183."add_method"($P9184, "metachar:sym<{ }>", $P9185)
    nqp_get_sc_object $P9186, "1304523744.097", 502
    get_how $P9187, $P9186
    nqp_get_sc_object $P9188, "1304523744.097", 502
    .const 'Sub' $P9189 = "610_1304523757.895" 
    $P9187."add_method"($P9188, "metachar:sym<nqpvar>", $P9189)
    nqp_get_sc_object $P9190, "1304523744.097", 502
    get_how $P9191, $P9190
    nqp_get_sc_object $P9192, "1304523744.097", 502
    .const 'Sub' $P9193 = "611_1304523757.895" 
    $P9191."add_method"($P9192, "assertion:sym<{ }>", $P9193)
    nqp_get_sc_object $P9194, "1304523744.097", 502
    get_how $P9195, $P9194
    nqp_get_sc_object $P9196, "1304523744.097", 502
    .const 'Sub' $P9197 = "612_1304523757.895" 
    $P9195."add_method"($P9196, "assertion:sym<?{ }>", $P9197)
    nqp_get_sc_object $P9198, "1304523744.097", 502
    get_how $P9199, $P9198
    nqp_get_sc_object $P9200, "1304523744.097", 502
    .const 'Sub' $P9201 = "613_1304523757.895" 
    $P9199."add_method"($P9200, "assertion:sym<var>", $P9201)
    nqp_get_sc_object $P9202, "1304523744.097", 502
    get_how $P9203, $P9202
    nqp_get_sc_object $P9204, "1304523744.097", 502
    .const 'Sub' $P9205 = "614_1304523757.895" 
    $P9203."add_method"($P9204, "codeblock", $P9205)
    .const 'Sub' $P9206 = "607_1304523757.895" 
    $P9207 = $P9206."get_lexinfo"()
    nqp_get_sc_object $P9208, "1304523744.097", 502
    $P9207."set_static_lexpad_value"("$?PACKAGE", $P9208)
    .const 'Sub' $P9209 = "607_1304523757.895" 
    $P9210 = $P9209."get_lexinfo"()
    $P9210."finish_static_lexpad"()
    .const 'Sub' $P9211 = "607_1304523757.895" 
    $P9212 = $P9211."get_lexinfo"()
    nqp_get_sc_object $P9213, "1304523744.097", 502
    $P9212."set_static_lexpad_value"("$?CLASS", $P9213)
    .const 'Sub' $P9214 = "607_1304523757.895" 
    $P9215 = $P9214."get_lexinfo"()
    $P9215."finish_static_lexpad"()
    nqp_get_sc_object $P9216, "1304523744.097", 502
    get_how $P9217, $P9216
    nqp_get_sc_object $P9218, "1304523744.097", 502
    nqp_get_sc_object $P9219, "1304523737.1", 145
    $P9217."add_parent"($P9218, $P9219)
    nqp_get_sc_object $P9220, "1304523744.097", 502
    get_how $P9221, $P9220
    nqp_get_sc_object $P9222, "1304523744.097", 502
    $P9221."compose"($P9222)
    nqp_get_sc_object $P9223, "1304523719.327", 41
    $P9224 = $P9223."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P9224, cur_sc
    nqp_set_sc_object "1304523744.097", 510, $P9224
    nqp_get_sc_object $P9225, "1304523744.097", 510
    nqp_get_sc_object $P9226, "1304523744.097", 0
    nqp_get_package_through_who $P9227, $P9226, "NQP"
    get_who $P9228, $P9227
    set $P9228["Compiler"], $P9225
    .const 'Sub' $P9229 = "615_1304523757.895" 
    $P9230 = $P9229."get_lexinfo"()
    nqp_get_sc_object $P9231, "1304523744.097", 510
    $P9230."set_static_lexpad_value"("$?PACKAGE", $P9231)
    .const 'Sub' $P9232 = "615_1304523757.895" 
    $P9233 = $P9232."get_lexinfo"()
    $P9233."finish_static_lexpad"()
    .const 'Sub' $P9234 = "615_1304523757.895" 
    $P9235 = $P9234."get_lexinfo"()
    nqp_get_sc_object $P9236, "1304523744.097", 510
    $P9235."set_static_lexpad_value"("$?CLASS", $P9236)
    .const 'Sub' $P9237 = "615_1304523757.895" 
    $P9238 = $P9237."get_lexinfo"()
    $P9238."finish_static_lexpad"()
    nqp_get_sc_object $P9239, "1304523744.097", 510
    get_how $P9240, $P9239
    nqp_get_sc_object $P9241, "1304523744.097", 510
    nqp_get_sc_object $P9242, "1304523727.177", 138
    $P9240."add_parent"($P9241, $P9242)
    nqp_get_sc_object $P9243, "1304523744.097", 510
    get_how $P9244, $P9243
    nqp_get_sc_object $P9245, "1304523744.097", 510
    $P9244."compose"($P9245)
  if_7067_end:
    nqp_get_sc_object $P10324, "1304523744.097", 0
    set_hll_global "GLOBAL", $P10324
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1304523757.895") :outer("10_1304523757.895")
    .param pmc param_17
.annotate 'line', 2681
    .lex "@ARGS", param_17
.annotate 'line', 2683
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2689
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2683
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2684
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_618
    new $P25, "Undef"
  vivify_618:
    $P25."language"("nqp")
.annotate 'line', 2685
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_619
    new $P26, "Undef"
  vivify_619:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2686
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_620
    new $P31, "Undef"
  vivify_620:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2689
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_621
    new $P36, "Undef"
  vivify_621:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2690
    find_lex $P38, "@clo"
    unless_null $P38, vivify_622
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_622:
    $P38."push"("parsetrace")
.annotate 'line', 2691
    find_lex $P39, "@clo"
    unless_null $P39, vivify_623
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_623:
    $P39."push"("setting=s")
.annotate 'line', 2692
    find_lex $P40, "@clo"
    unless_null $P40, vivify_624
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_624:
    $P40."push"("setting-path=s")
.annotate 'line', 2693
    find_lex $P41, "@clo"
    unless_null $P41, vivify_625
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_625:
    $P41."push"("module-path=s")
.annotate 'line', 2696
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_626
    new $P42, "Undef"
  vivify_626:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_627
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_627:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2681
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block46"  :subid("12_1304523757.895") :outer("10_1304523757.895")
.annotate 'line', 11
    .const 'Sub' $P824 = "36_1304523757.895" 
    capture_lex $P824
    .const 'Sub' $P800 = "35_1304523757.895" 
    capture_lex $P800
    .const 'Sub' $P767 = "34_1304523757.895" 
    capture_lex $P767
    .const 'Sub' $P652 = "29_1304523757.895" 
    capture_lex $P652
    .const 'Sub' $P605 = "28_1304523757.895" 
    capture_lex $P605
    .const 'Sub' $P494 = "26_1304523757.895" 
    capture_lex $P494
    .const 'Sub' $P490 = "25_1304523757.895" 
    capture_lex $P490
    .const 'Sub' $P404 = "22_1304523757.895" 
    capture_lex $P404
    .const 'Sub' $P327 = "21_1304523757.895" 
    capture_lex $P327
    .const 'Sub' $P291 = "20_1304523757.895" 
    capture_lex $P291
    .const 'Sub' $P228 = "19_1304523757.895" 
    capture_lex $P228
    .const 'Sub' $P152 = "16_1304523757.895" 
    capture_lex $P152
    .const 'Sub' $P111 = "15_1304523757.895" 
    capture_lex $P111
    .const 'Sub' $P53 = "13_1304523757.895" 
    capture_lex $P53
.annotate 'line', 16
    new $P48, "Undef"
    .lex "$loader", $P48
.annotate 'line', 212
    new $P49, "Undef"
    .lex "$stub_code", $P49
    .lex "$?PACKAGE", $P50
    .lex "$?CLASS", $P51
.annotate 'line', 16
    get_hll_global $P52, "ModuleLoader"
    store_lex "$loader", $P52
.annotate 'line', 212
    .const 'Sub' $P490 = "25_1304523757.895" 
    newclosure $P493, $P490
    store_lex "$stub_code", $P493
.annotate 'line', 387
    .const 'Sub' $P824 = "36_1304523757.895" 
    newclosure $P933, $P824
.annotate 'line', 11
    .return ($P933)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_setting"  :subid("13_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_56
    .param pmc param_57
.annotate 'line', 19
    .const 'Sub' $P64 = "14_1304523757.895" 
    capture_lex $P64
    new $P55, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P55, control_54
    push_eh $P55
    .lex "self", param_56
    .lex "$setting_name", param_57
.annotate 'line', 21
    find_lex $P60, "$setting_name"
    unless_null $P60, vivify_628
    new $P60, "Undef"
  vivify_628:
    set $S61, $P60
    isne $I62, $S61, "NULL"
    if $I62, if_59
    new $P58, 'Integer'
    set $P58, $I62
    goto if_59_end
  if_59:
    .const 'Sub' $P64 = "14_1304523757.895" 
    capture_lex $P64
    $P109 = $P64()
    set $P58, $P109
  if_59_end:
.annotate 'line', 19
    .return ($P58)
  control_54:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P110, exception, "payload"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block63"  :anon :subid("14_1304523757.895") :outer("13_1304523757.895")
.annotate 'line', 25
    new $P65, "Undef"
    .lex "$setting", $P65
.annotate 'line', 26
    find_lex $P66, "$loader"
    unless_null $P66, vivify_629
    new $P66, "Undef"
  vivify_629:
    find_lex $P67, "$setting_name"
    unless_null $P67, vivify_630
    new $P67, "Undef"
  vivify_630:
    $P68 = $P66."load_setting"($P67)
    find_dynamic_lex $P71, "%*COMPILING"
    unless_null $P71, vivify_631
    get_hll_global $P69, "GLOBAL"
    get_who $P70, $P69
    set $P71, $P70["%COMPILING"]
    unless_null $P71, vivify_632
    die "Contextual %*COMPILING not found"
  vivify_632:
    store_dynamic_lex "%*COMPILING", $P71
  vivify_631:
    set $P72, $P71["%?OPTIONS"]
    unless_null $P72, vivify_633
    $P72 = root_new ['parrot';'Hash']
    set $P71["%?OPTIONS"], $P72
  vivify_633:
    set $P72["outer_ctx"], $P68
    store_lex "$setting", $P68
.annotate 'line', 29
    find_lex $P73, "self"
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "PAST"
    get_who $P76, $P75
    set $P77, $P76["Stmts"]
.annotate 'line', 30
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "PAST"
    get_who $P80, $P79
    set $P81, $P80["Op"]
    $P82 = $P81."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 33
    get_hll_global $P83, "GLOBAL"
    nqp_get_package_through_who $P84, $P83, "PAST"
    get_who $P85, $P84
    set $P86, $P85["Op"]
.annotate 'line', 35
    get_hll_global $P87, "GLOBAL"
    nqp_get_package_through_who $P88, $P87, "PAST"
    get_who $P89, $P88
    set $P90, $P89["Var"]
    $P91 = $P90."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 36
    get_hll_global $P92, "GLOBAL"
    nqp_get_package_through_who $P93, $P92, "PAST"
    get_who $P94, $P93
    set $P95, $P94["Op"]
.annotate 'line', 38
    get_hll_global $P96, "GLOBAL"
    nqp_get_package_through_who $P97, $P96, "PAST"
    get_who $P98, $P97
    set $P99, $P98["Var"]
    new $P100, "ResizablePMCArray"
    $P101 = $P99."new"("ModuleLoader" :named("name"), $P100 :named("namespace"), "package" :named("scope"))
    find_lex $P102, "$setting_name"
    unless_null $P102, vivify_634
    new $P102, "Undef"
  vivify_634:
    $P103 = $P95."new"($P101, $P102, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 36
    $P104 = $P86."new"($P91, $P103, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 33
    $P105 = $P77."new"($P82, $P104)
.annotate 'line', 29
    $P73."add_event"($P105 :named("deserialize_past"))
.annotate 'line', 44
    new $P106, "Exception"
    set $P106['type'], .CONTROL_RETURN
    find_lex $P107, "$setting"
    unless_null $P107, vivify_635
    new $P107, "Undef"
  vivify_635:
    getattribute $P108, $P107, "lex_pad"
    setattribute $P106, 'payload', $P108
    throw $P106
.annotate 'line', 21
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "load_module"  :subid("15_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_114
    .param pmc param_115
    .param pmc param_116
.annotate 'line', 50
    new $P113, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P113, control_112
    push_eh $P113
    .lex "self", param_114
    .lex "$module_name", param_115
    .lex "$cur_GLOBALish", param_116
.annotate 'line', 52
    new $P117, "Undef"
    .lex "$module", $P117
    find_lex $P118, "$loader"
    unless_null $P118, vivify_636
    new $P118, "Undef"
  vivify_636:
    find_lex $P119, "$module_name"
    unless_null $P119, vivify_637
    new $P119, "Undef"
  vivify_637:
    find_lex $P120, "$cur_GLOBALish"
    unless_null $P120, vivify_638
    new $P120, "Undef"
  vivify_638:
    $P121 = $P118."load_module"($P119, $P120)
    store_lex "$module", $P121
.annotate 'line', 55
    find_lex $P122, "self"
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Stmts"]
.annotate 'line', 56
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    $P131 = $P130."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 59
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 61
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    new $P140, "ResizablePMCArray"
    $P141 = $P139."new"("ModuleLoader" :named("name"), $P140 :named("namespace"), "package" :named("scope"))
    find_lex $P142, "$module_name"
    unless_null $P142, vivify_639
    new $P142, "Undef"
  vivify_639:
.annotate 'line', 63
    find_lex $P143, "self"
    find_lex $P144, "$cur_GLOBALish"
    unless_null $P144, vivify_640
    new $P144, "Undef"
  vivify_640:
    $P145 = $P143."get_slot_past_for_object"($P144)
    $P146 = $P135."new"($P141, $P142, $P145, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 59
    $P147 = $P126."new"($P131, $P146)
.annotate 'line', 55
    $P122."add_event"($P147 :named("deserialize_past"))
.annotate 'line', 66
    new $P148, "Exception"
    set $P148['type'], .CONTROL_RETURN
    find_lex $P149, "$module"
    unless_null $P149, vivify_641
    new $P149, "Undef"
  vivify_641:
    getattribute $P150, $P149, "lex_pad"
    setattribute $P148, 'payload', $P150
    throw $P148
.annotate 'line', 50
    .return ()
  control_112:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P151, exception, "payload"
    .return ($P151)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "install_package_symbol"  :subid("16_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_153
    .param pmc param_154
    .param pmc param_155
    .param pmc param_156
.annotate 'line', 71
    .const 'Sub' $P193 = "18_1304523757.895" 
    capture_lex $P193
    .const 'Sub' $P172 = "17_1304523757.895" 
    capture_lex $P172
    .lex "self", param_153
    .lex "$package", param_154
    .lex "@sym", param_155
    .lex "$obj", param_156
.annotate 'line', 73
    new $P157, "Undef"
    .lex "$name", $P157
.annotate 'line', 76
    new $P158, "Undef"
    .lex "$target", $P158
.annotate 'line', 83
    new $P159, "Undef"
    .lex "$path", $P159
.annotate 'line', 72
    find_lex $P160, "@sym"
    unless_null $P160, vivify_642
    $P160 = root_new ['parrot';'ResizablePMCArray']
  vivify_642:
    clone $P161, $P160
    store_lex "@sym", $P161
.annotate 'line', 73
    find_lex $P162, "@sym"
    unless_null $P162, vivify_643
    $P162 = root_new ['parrot';'ResizablePMCArray']
  vivify_643:
    $P163 = $P162."pop"()
    set $S164, $P163
    new $P165, 'String'
    set $P165, $S164
    store_lex "$name", $P165
.annotate 'line', 76
    find_lex $P166, "$package"
    unless_null $P166, vivify_644
    new $P166, "Undef"
  vivify_644:
    store_lex "$target", $P166
.annotate 'line', 77
    find_lex $P168, "@sym"
    unless_null $P168, vivify_645
    $P168 = root_new ['parrot';'ResizablePMCArray']
  vivify_645:
    defined $I169, $P168
    unless $I169, for_undef_646
    iter $P167, $P168
    new $P179, 'ExceptionHandler'
    set_label $P179, loop178_handler
    $P179."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P179
  loop178_test:
    unless $P167, loop178_done
    shift $P170, $P167
  loop178_redo:
    .const 'Sub' $P172 = "17_1304523757.895" 
    capture_lex $P172
    $P172($P170)
  loop178_next:
    goto loop178_test
  loop178_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P180, exception, 'type'
    eq $P180, .CONTROL_LOOP_NEXT, loop178_next
    eq $P180, .CONTROL_LOOP_REDO, loop178_redo
  loop178_done:
    pop_eh 
  for_undef_646:
.annotate 'line', 80
    find_lex $P181, "$obj"
    unless_null $P181, vivify_649
    new $P181, "Undef"
  vivify_649:
    find_lex $P182, "$name"
    unless_null $P182, vivify_650
    new $P182, "Undef"
  vivify_650:
    find_lex $P183, "$target"
    unless_null $P183, vivify_651
    new $P183, "Undef"
    store_lex "$target", $P183
  vivify_651:
    get_who $P184, $P183
    set $P184[$P182], $P181
.annotate 'line', 83
    find_lex $P185, "self"
    find_lex $P186, "$package"
    unless_null $P186, vivify_652
    new $P186, "Undef"
  vivify_652:
    $P187 = $P185."get_slot_past_for_object"($P186)
    store_lex "$path", $P187
.annotate 'line', 84
    find_lex $P189, "@sym"
    unless_null $P189, vivify_653
    $P189 = root_new ['parrot';'ResizablePMCArray']
  vivify_653:
    defined $I190, $P189
    unless $I190, for_undef_654
    iter $P188, $P189
    new $P204, 'ExceptionHandler'
    set_label $P204, loop203_handler
    $P204."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P204
  loop203_test:
    unless $P188, loop203_done
    shift $P191, $P188
  loop203_redo:
    .const 'Sub' $P193 = "18_1304523757.895" 
    capture_lex $P193
    $P193($P191)
  loop203_next:
    goto loop203_test
  loop203_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P205, exception, 'type'
    eq $P205, .CONTROL_LOOP_NEXT, loop203_next
    eq $P205, .CONTROL_LOOP_REDO, loop203_redo
  loop203_done:
    pop_eh 
  for_undef_654:
.annotate 'line', 87
    find_lex $P206, "self"
    get_hll_global $P207, "GLOBAL"
    nqp_get_package_through_who $P208, $P207, "PAST"
    get_who $P209, $P208
    set $P210, $P209["Op"]
.annotate 'line', 89
    get_hll_global $P211, "GLOBAL"
    nqp_get_package_through_who $P212, $P211, "PAST"
    get_who $P213, $P212
    set $P214, $P213["Var"]
.annotate 'line', 91
    get_hll_global $P215, "GLOBAL"
    nqp_get_package_through_who $P216, $P215, "PAST"
    get_who $P217, $P216
    set $P218, $P217["Op"]
    find_lex $P219, "$path"
    unless_null $P219, vivify_657
    new $P219, "Undef"
  vivify_657:
    $P220 = $P218."new"($P219, "get_who PP" :named("pirop"))
    find_lex $P221, "$name"
    unless_null $P221, vivify_658
    new $P221, "Undef"
  vivify_658:
    $P222 = $P214."new"($P220, $P221, "keyed" :named("scope"))
.annotate 'line', 94
    find_lex $P223, "self"
    find_lex $P224, "$obj"
    unless_null $P224, vivify_659
    new $P224, "Undef"
  vivify_659:
    $P225 = $P223."get_slot_past_for_object"($P224)
    $P226 = $P210."new"($P222, $P225, "bind" :named("pasttype"))
.annotate 'line', 87
    $P227 = $P206."add_event"($P226 :named("deserialize_past"))
.annotate 'line', 71
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block171"  :anon :subid("17_1304523757.895") :outer("16_1304523757.895")
    .param pmc param_173
.annotate 'line', 77
    .lex "$_", param_173
.annotate 'line', 78
    find_lex $P174, "$target"
    unless_null $P174, vivify_647
    new $P174, "Undef"
  vivify_647:
    find_lex $P175, "$_"
    unless_null $P175, vivify_648
    new $P175, "Undef"
  vivify_648:
    set $S176, $P175
    nqp_get_package_through_who $P177, $P174, $S176
    store_lex "$target", $P177
.annotate 'line', 77
    .return ($P177)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block192"  :anon :subid("18_1304523757.895") :outer("16_1304523757.895")
    .param pmc param_194
.annotate 'line', 84
    .lex "$_", param_194
.annotate 'line', 85
    get_hll_global $P195, "GLOBAL"
    nqp_get_package_through_who $P196, $P195, "PAST"
    get_who $P197, $P196
    set $P198, $P197["Op"]
    find_lex $P199, "$path"
    unless_null $P199, vivify_655
    new $P199, "Undef"
  vivify_655:
    find_lex $P200, "$_"
    unless_null $P200, vivify_656
    new $P200, "Undef"
  vivify_656:
    set $S201, $P200
    $P202 = $P198."new"($P199, $S201, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P202
.annotate 'line', 84
    .return ($P202)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_lexical_symbol"  :subid("19_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_229
    .param pmc param_230
    .param pmc param_231
    .param pmc param_232
.annotate 'line', 102
    .lex "self", param_229
    .lex "$block", param_230
    .lex "$name", param_231
    .lex "$obj", param_232
.annotate 'line', 108
    new $P233, "Undef"
    .lex "$fixup", $P233
.annotate 'line', 104
    find_lex $P234, "$block"
    unless_null $P234, vivify_660
    new $P234, "Undef"
  vivify_660:
    find_lex $P235, "$name"
    unless_null $P235, vivify_661
    new $P235, "Undef"
  vivify_661:
    find_lex $P236, "$obj"
    unless_null $P236, vivify_662
    new $P236, "Undef"
  vivify_662:
    $P234."symbol"($P235, "lexical" :named("scope"), $P236 :named("value"))
.annotate 'line', 105
    find_lex $P237, "$block"
    unless_null $P237, vivify_663
    $P237 = root_new ['parrot';'ResizablePMCArray']
  vivify_663:
    set $P238, $P237[0]
    unless_null $P238, vivify_664
    new $P238, "Undef"
  vivify_664:
    get_hll_global $P239, "GLOBAL"
    nqp_get_package_through_who $P240, $P239, "PAST"
    get_who $P241, $P240
    set $P242, $P241["Var"]
    find_lex $P243, "$name"
    unless_null $P243, vivify_665
    new $P243, "Undef"
  vivify_665:
    $P244 = $P242."new"("lexical" :named("scope"), $P243 :named("name"), 1 :named("isdecl"))
    $P238."push"($P244)
.annotate 'line', 108
    get_hll_global $P245, "GLOBAL"
    nqp_get_package_through_who $P246, $P245, "PAST"
    get_who $P247, $P246
    set $P248, $P247["Stmts"]
.annotate 'line', 109
    get_hll_global $P249, "GLOBAL"
    nqp_get_package_through_who $P250, $P249, "PAST"
    get_who $P251, $P250
    set $P252, $P251["Op"]
.annotate 'line', 111
    get_hll_global $P253, "GLOBAL"
    nqp_get_package_through_who $P254, $P253, "PAST"
    get_who $P255, $P254
    set $P256, $P255["Op"]
.annotate 'line', 113
    get_hll_global $P257, "GLOBAL"
    nqp_get_package_through_who $P258, $P257, "PAST"
    get_who $P259, $P258
    set $P260, $P259["Val"]
    find_lex $P261, "$block"
    unless_null $P261, vivify_666
    new $P261, "Undef"
  vivify_666:
    $P262 = $P260."new"($P261 :named("value"))
    $P263 = $P256."new"($P262, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 115
    find_lex $P264, "$name"
    unless_null $P264, vivify_667
    new $P264, "Undef"
  vivify_667:
    set $S265, $P264
    find_lex $P266, "self"
    find_lex $P267, "$obj"
    unless_null $P267, vivify_668
    new $P267, "Undef"
  vivify_668:
    $P268 = $P266."get_slot_past_for_object"($P267)
    $P269 = $P252."new"($P263, $S265, $P268, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 119
    get_hll_global $P270, "GLOBAL"
    nqp_get_package_through_who $P271, $P270, "PAST"
    get_who $P272, $P271
    set $P273, $P272["Op"]
.annotate 'line', 121
    get_hll_global $P274, "GLOBAL"
    nqp_get_package_through_who $P275, $P274, "PAST"
    get_who $P276, $P275
    set $P277, $P276["Op"]
.annotate 'line', 123
    get_hll_global $P278, "GLOBAL"
    nqp_get_package_through_who $P279, $P278, "PAST"
    get_who $P280, $P279
    set $P281, $P280["Val"]
    find_lex $P282, "$block"
    unless_null $P282, vivify_669
    new $P282, "Undef"
  vivify_669:
    $P283 = $P281."new"($P282 :named("value"))
    $P284 = $P277."new"($P283, "callmethod" :named("pasttype"), "get_lexinfo" :named("name"))
.annotate 'line', 121
    $P285 = $P273."new"($P284, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 119
    $P286 = $P248."new"($P269, $P285)
.annotate 'line', 108
    store_lex "$fixup", $P286
.annotate 'line', 127
    find_lex $P287, "self"
    find_lex $P288, "$fixup"
    unless_null $P288, vivify_670
    new $P288, "Undef"
  vivify_670:
    find_lex $P289, "$fixup"
    unless_null $P289, vivify_671
    new $P289, "Undef"
  vivify_671:
    $P290 = $P287."add_event"($P288 :named("deserialize_past"), $P289 :named("fixup_past"))
.annotate 'line', 102
    .return ($P290)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "install_package_routine"  :subid("20_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_292
    .param pmc param_293
    .param pmc param_294
    .param pmc param_295
.annotate 'line', 132
    .lex "self", param_292
    .lex "$package", param_293
    .lex "$name", param_294
    .lex "$past_block", param_295
.annotate 'line', 133
    new $P296, "Undef"
    .lex "$fixup", $P296
    get_hll_global $P297, "GLOBAL"
    nqp_get_package_through_who $P298, $P297, "PAST"
    get_who $P299, $P298
    set $P300, $P299["Op"]
.annotate 'line', 135
    get_hll_global $P301, "GLOBAL"
    nqp_get_package_through_who $P302, $P301, "PAST"
    get_who $P303, $P302
    set $P304, $P303["Var"]
.annotate 'line', 137
    get_hll_global $P305, "GLOBAL"
    nqp_get_package_through_who $P306, $P305, "PAST"
    get_who $P307, $P306
    set $P308, $P307["Op"]
    find_lex $P309, "self"
    find_lex $P310, "$package"
    unless_null $P310, vivify_672
    new $P310, "Undef"
  vivify_672:
    $P311 = $P309."get_slot_past_for_object"($P310)
    $P312 = $P308."new"($P311, "get_who PP" :named("pirop"))
.annotate 'line', 138
    find_lex $P313, "$name"
    unless_null $P313, vivify_673
    new $P313, "Undef"
  vivify_673:
    set $S314, $P313
    $P315 = $P304."new"($P312, $S314, "keyed" :named("scope"))
.annotate 'line', 140
    get_hll_global $P316, "GLOBAL"
    nqp_get_package_through_who $P317, $P316, "PAST"
    get_who $P318, $P317
    set $P319, $P318["Val"]
    find_lex $P320, "$past_block"
    unless_null $P320, vivify_674
    new $P320, "Undef"
  vivify_674:
    $P321 = $P319."new"($P320 :named("value"))
    $P322 = $P300."new"($P315, $P321, "bind" :named("pasttype"))
.annotate 'line', 133
    store_lex "$fixup", $P322
.annotate 'line', 142
    find_lex $P323, "self"
    find_lex $P324, "$fixup"
    unless_null $P324, vivify_675
    new $P324, "Undef"
  vivify_675:
    find_lex $P325, "$fixup"
    unless_null $P325, vivify_676
    new $P325, "Undef"
  vivify_676:
    $P326 = $P323."add_event"($P324 :named("deserialize_past"), $P325 :named("fixup_past"))
.annotate 'line', 132
    .return ($P326)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_create_mo"  :subid("21_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_330
    .param pmc param_331
    .param pmc param_332 :optional :named("name")
    .param int has_param_332 :opt_flag
    .param pmc param_334 :optional :named("repr")
    .param int has_param_334 :opt_flag
.annotate 'line', 147
    new $P329, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P329, control_328
    push_eh $P329
    .lex "self", param_330
    .lex "$how", param_331
    if has_param_332, optparam_677
    new $P333, "Undef"
    set param_332, $P333
  optparam_677:
    .lex "$name", param_332
    if has_param_334, optparam_678
    new $P335, "Undef"
    set param_334, $P335
  optparam_678:
    .lex "$repr", param_334
.annotate 'line', 149
    $P336 = root_new ['parrot';'Hash']
    .lex "%args", $P336
.annotate 'line', 152
    new $P337, "Undef"
    .lex "$mo", $P337
.annotate 'line', 153
    new $P338, "Undef"
    .lex "$slot", $P338
.annotate 'line', 157
    $P339 = root_new ['parrot';'ResizablePMCArray']
    .lex "@how_ns", $P339
.annotate 'line', 158
    new $P340, "Undef"
    .lex "$how_name", $P340
.annotate 'line', 159
    new $P341, "Undef"
    .lex "$setup_call", $P341
.annotate 'line', 147
    find_lex $P342, "%args"
    unless_null $P342, vivify_679
    $P342 = root_new ['parrot';'Hash']
  vivify_679:
.annotate 'line', 150
    find_lex $P344, "$name"
    unless_null $P344, vivify_680
    new $P344, "Undef"
  vivify_680:
    defined $I345, $P344
    unless $I345, if_343_end
    find_lex $P346, "$name"
    unless_null $P346, vivify_681
    new $P346, "Undef"
  vivify_681:
    find_lex $P347, "%args"
    unless_null $P347, vivify_682
    $P347 = root_new ['parrot';'Hash']
    store_lex "%args", $P347
  vivify_682:
    set $P347["name"], $P346
  if_343_end:
.annotate 'line', 151
    find_lex $P349, "$repr"
    unless_null $P349, vivify_683
    new $P349, "Undef"
  vivify_683:
    defined $I350, $P349
    unless $I350, if_348_end
    find_lex $P351, "$repr"
    unless_null $P351, vivify_684
    new $P351, "Undef"
  vivify_684:
    find_lex $P352, "%args"
    unless_null $P352, vivify_685
    $P352 = root_new ['parrot';'Hash']
    store_lex "%args", $P352
  vivify_685:
    set $P352["repr"], $P351
  if_348_end:
.annotate 'line', 152
    find_lex $P353, "$how"
    unless_null $P353, vivify_686
    new $P353, "Undef"
  vivify_686:
    find_lex $P354, "%args"
    unless_null $P354, vivify_687
    $P354 = root_new ['parrot';'Hash']
  vivify_687:
    $P355 = $P353."new_type"($P354 :flat)
    store_lex "$mo", $P355
.annotate 'line', 153
    find_lex $P356, "self"
    find_lex $P357, "$mo"
    unless_null $P357, vivify_688
    new $P357, "Undef"
  vivify_688:
    $P358 = $P356."add_object"($P357)
    store_lex "$slot", $P358
.annotate 'line', 157
    find_lex $P359, "$how"
    unless_null $P359, vivify_689
    new $P359, "Undef"
  vivify_689:
    get_how $P360, $P359
    find_lex $P361, "$how"
    unless_null $P361, vivify_690
    new $P361, "Undef"
  vivify_690:
    $S362 = $P360."name"($P361)
    split $P363, "::", $S362
    store_lex "@how_ns", $P363
.annotate 'line', 158
    find_lex $P364, "@how_ns"
    unless_null $P364, vivify_691
    $P364 = root_new ['parrot';'ResizablePMCArray']
  vivify_691:
    $P365 = $P364."pop"()
    store_lex "$how_name", $P365
.annotate 'line', 159
    get_hll_global $P366, "GLOBAL"
    nqp_get_package_through_who $P367, $P366, "PAST"
    get_who $P368, $P367
    set $P369, $P368["Op"]
.annotate 'line', 161
    find_lex $P370, "self"
    find_lex $P371, "$how"
    unless_null $P371, vivify_692
    new $P371, "Undef"
  vivify_692:
    $P372 = $P370."get_object_sc_ref_past"($P371)
    $P373 = $P369."new"($P372, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 159
    store_lex "$setup_call", $P373
.annotate 'line', 163
    find_lex $P375, "$name"
    unless_null $P375, vivify_693
    new $P375, "Undef"
  vivify_693:
    defined $I376, $P375
    unless $I376, if_374_end
.annotate 'line', 164
    find_lex $P377, "$setup_call"
    unless_null $P377, vivify_694
    new $P377, "Undef"
  vivify_694:
    get_hll_global $P378, "GLOBAL"
    nqp_get_package_through_who $P379, $P378, "PAST"
    get_who $P380, $P379
    set $P381, $P380["Val"]
    find_lex $P382, "$name"
    unless_null $P382, vivify_695
    new $P382, "Undef"
  vivify_695:
    $P383 = $P381."new"($P382 :named("value"), "name" :named("named"))
    $P377."push"($P383)
  if_374_end:
.annotate 'line', 166
    find_lex $P385, "$repr"
    unless_null $P385, vivify_696
    new $P385, "Undef"
  vivify_696:
    defined $I386, $P385
    unless $I386, if_384_end
.annotate 'line', 167
    find_lex $P387, "$setup_call"
    unless_null $P387, vivify_697
    new $P387, "Undef"
  vivify_697:
    get_hll_global $P388, "GLOBAL"
    nqp_get_package_through_who $P389, $P388, "PAST"
    get_who $P390, $P389
    set $P391, $P390["Val"]
    find_lex $P392, "$repr"
    unless_null $P392, vivify_698
    new $P392, "Undef"
  vivify_698:
    $P393 = $P391."new"($P392 :named("value"), "repr" :named("named"))
    $P387."push"($P393)
  if_384_end:
.annotate 'line', 169
    find_lex $P394, "self"
.annotate 'line', 170
    find_lex $P395, "self"
    find_lex $P396, "$slot"
    unless_null $P396, vivify_699
    new $P396, "Undef"
  vivify_699:
    find_lex $P397, "self"
    find_lex $P398, "$setup_call"
    unless_null $P398, vivify_700
    new $P398, "Undef"
  vivify_700:
    $P399 = $P397."set_cur_sc"($P398)
    $P400 = $P395."set_slot_past"($P396, $P399)
    $P394."add_event"($P400 :named("deserialize_past"))
.annotate 'line', 173
    new $P401, "Exception"
    set $P401['type'], .CONTROL_RETURN
    find_lex $P402, "$mo"
    unless_null $P402, vivify_701
    new $P402, "Undef"
  vivify_701:
    setattribute $P401, 'payload', $P402
    throw $P401
.annotate 'line', 147
    .return ()
  control_328:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P403, exception, "payload"
    .return ($P403)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "pkg_add_attribute"  :subid("22_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_405
    .param pmc param_406
    .param pmc param_407
    .param pmc param_408
    .param pmc param_409
.annotate 'line', 181
    .const 'Sub' $P455 = "24_1304523757.895" 
    capture_lex $P455
    .const 'Sub' $P434 = "23_1304523757.895" 
    capture_lex $P434
    .lex "self", param_405
    .lex "$obj", param_406
    .lex "$meta_attr", param_407
    .lex "%lit_args", param_408
    .lex "%obj_args", param_409
.annotate 'line', 183
    new $P410, "Undef"
    .lex "$attr", $P410
.annotate 'line', 187
    new $P411, "Undef"
    .lex "$create_call", $P411
.annotate 'line', 199
    new $P412, "Undef"
    .lex "$obj_slot_past", $P412
.annotate 'line', 183
    find_lex $P413, "$meta_attr"
    unless_null $P413, vivify_702
    new $P413, "Undef"
  vivify_702:
    find_lex $P414, "%lit_args"
    unless_null $P414, vivify_703
    $P414 = root_new ['parrot';'Hash']
  vivify_703:
    find_lex $P415, "%obj_args"
    unless_null $P415, vivify_704
    $P415 = root_new ['parrot';'Hash']
  vivify_704:
    $P416 = $P413."new"($P414 :flat, $P415 :flat)
    store_lex "$attr", $P416
.annotate 'line', 184
    find_lex $P417, "$obj"
    unless_null $P417, vivify_705
    new $P417, "Undef"
  vivify_705:
    get_how $P418, $P417
    find_lex $P419, "$obj"
    unless_null $P419, vivify_706
    new $P419, "Undef"
  vivify_706:
    find_lex $P420, "$attr"
    unless_null $P420, vivify_707
    new $P420, "Undef"
  vivify_707:
    $P418."add_attribute"($P419, $P420)
.annotate 'line', 187
    get_hll_global $P421, "GLOBAL"
    nqp_get_package_through_who $P422, $P421, "PAST"
    get_who $P423, $P422
    set $P424, $P423["Op"]
.annotate 'line', 189
    find_lex $P425, "self"
    find_lex $P426, "$meta_attr"
    unless_null $P426, vivify_708
    new $P426, "Undef"
  vivify_708:
    $P427 = $P425."get_object_sc_ref_past"($P426)
    $P428 = $P424."new"($P427, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 187
    store_lex "$create_call", $P428
.annotate 'line', 191
    find_lex $P430, "%lit_args"
    unless_null $P430, vivify_709
    $P430 = root_new ['parrot';'Hash']
  vivify_709:
    defined $I431, $P430
    unless $I431, for_undef_710
    iter $P429, $P430
    new $P448, 'ExceptionHandler'
    set_label $P448, loop447_handler
    $P448."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P448
  loop447_test:
    unless $P429, loop447_done
    shift $P432, $P429
  loop447_redo:
    .const 'Sub' $P434 = "23_1304523757.895" 
    capture_lex $P434
    $P434($P432)
  loop447_next:
    goto loop447_test
  loop447_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P449, exception, 'type'
    eq $P449, .CONTROL_LOOP_NEXT, loop447_next
    eq $P449, .CONTROL_LOOP_REDO, loop447_redo
  loop447_done:
    pop_eh 
  for_undef_710:
.annotate 'line', 194
    find_lex $P451, "%obj_args"
    unless_null $P451, vivify_714
    $P451 = root_new ['parrot';'Hash']
  vivify_714:
    defined $I452, $P451
    unless $I452, for_undef_715
    iter $P450, $P451
    new $P469, 'ExceptionHandler'
    set_label $P469, loop468_handler
    $P469."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P469
  loop468_test:
    unless $P450, loop468_done
    shift $P453, $P450
  loop468_redo:
    .const 'Sub' $P455 = "24_1304523757.895" 
    capture_lex $P455
    $P455($P453)
  loop468_next:
    goto loop468_test
  loop468_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P470, exception, 'type'
    eq $P470, .CONTROL_LOOP_NEXT, loop468_next
    eq $P470, .CONTROL_LOOP_REDO, loop468_redo
  loop468_done:
    pop_eh 
  for_undef_715:
.annotate 'line', 199
    find_lex $P471, "self"
    find_lex $P472, "$obj"
    unless_null $P472, vivify_721
    new $P472, "Undef"
  vivify_721:
    $P473 = $P471."get_slot_past_for_object"($P472)
    store_lex "$obj_slot_past", $P473
.annotate 'line', 200
    find_lex $P474, "self"
    get_hll_global $P475, "GLOBAL"
    nqp_get_package_through_who $P476, $P475, "PAST"
    get_who $P477, $P476
    set $P478, $P477["Op"]
.annotate 'line', 202
    get_hll_global $P479, "GLOBAL"
    nqp_get_package_through_who $P480, $P479, "PAST"
    get_who $P481, $P480
    set $P482, $P481["Op"]
    find_lex $P483, "$obj_slot_past"
    unless_null $P483, vivify_722
    new $P483, "Undef"
  vivify_722:
    $P484 = $P482."new"($P483, "get_how PP" :named("pirop"))
    find_lex $P485, "$obj_slot_past"
    unless_null $P485, vivify_723
    new $P485, "Undef"
  vivify_723:
    find_lex $P486, "$create_call"
    unless_null $P486, vivify_724
    new $P486, "Undef"
  vivify_724:
    $P487 = $P478."new"($P484, $P485, $P486, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 200
    $P488 = $P474."add_event"($P487 :named("deserialize_past"))
.annotate 'line', 181
    .return ($P488)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block433"  :anon :subid("23_1304523757.895") :outer("22_1304523757.895")
    .param pmc param_435
.annotate 'line', 191
    .lex "$_", param_435
.annotate 'line', 192
    find_lex $P436, "$create_call"
    unless_null $P436, vivify_711
    new $P436, "Undef"
  vivify_711:
    get_hll_global $P437, "GLOBAL"
    nqp_get_package_through_who $P438, $P437, "PAST"
    get_who $P439, $P438
    set $P440, $P439["Val"]
    find_lex $P441, "$_"
    unless_null $P441, vivify_712
    new $P441, "Undef"
  vivify_712:
    $P442 = $P441."value"()
    find_lex $P443, "$_"
    unless_null $P443, vivify_713
    new $P443, "Undef"
  vivify_713:
    $P444 = $P443."key"()
    $P445 = $P440."new"($P442 :named("value"), $P444 :named("named"))
    $P446 = $P436."push"($P445)
.annotate 'line', 191
    .return ($P446)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block454"  :anon :subid("24_1304523757.895") :outer("22_1304523757.895")
    .param pmc param_457
.annotate 'line', 195
    new $P456, "Undef"
    .lex "$lookup", $P456
    .lex "$_", param_457
    find_lex $P458, "self"
    find_lex $P459, "$_"
    unless_null $P459, vivify_716
    new $P459, "Undef"
  vivify_716:
    $P460 = $P459."value"()
    $P461 = $P458."get_object_sc_ref_past"($P460)
    store_lex "$lookup", $P461
.annotate 'line', 196
    find_lex $P462, "$lookup"
    unless_null $P462, vivify_717
    new $P462, "Undef"
  vivify_717:
    find_lex $P463, "$_"
    unless_null $P463, vivify_718
    new $P463, "Undef"
  vivify_718:
    $P464 = $P463."key"()
    $P462."named"($P464)
.annotate 'line', 197
    find_lex $P465, "$create_call"
    unless_null $P465, vivify_719
    new $P465, "Undef"
  vivify_719:
    find_lex $P466, "$lookup"
    unless_null $P466, vivify_720
    new $P466, "Undef"
  vivify_720:
    $P467 = $P465."push"($P466)
.annotate 'line', 194
    .return ($P467)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block489"  :anon :subid("25_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_491 :slurpy
    .param pmc param_492 :slurpy :named
.annotate 'line', 212
    .lex "@args", param_491
    .lex "%named", param_492
.annotate 'line', 213
    die "Cannot run code that has not yet been compiled."
.annotate 'line', 212
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_method"  :subid("26_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_495
    .param pmc param_496
    .param pmc param_497
    .param pmc param_498
    .param pmc param_499
    .param pmc param_500
.annotate 'line', 219
    .const 'Sub' $P523 = "27_1304523757.895" 
    capture_lex $P523
    .lex "self", param_495
    .lex "$obj", param_496
    .lex "$meta_method_name", param_497
    .lex "$name", param_498
    .lex "$method_past", param_499
    .lex "$is_dispatcher", param_500
.annotate 'line', 221
    new $P501, "Undef"
    .lex "$fixups", $P501
.annotate 'line', 222
    new $P502, "Undef"
    .lex "$dummy", $P502
.annotate 'line', 267
    new $P503, "Undef"
    .lex "$slot_past", $P503
.annotate 'line', 221
    get_hll_global $P504, "GLOBAL"
    nqp_get_package_through_who $P505, $P504, "PAST"
    get_who $P506, $P505
    set $P507, $P506["Stmts"]
    $P508 = $P507."new"()
    store_lex "$fixups", $P508
    find_lex $P509, "$dummy"
    unless_null $P509, vivify_725
    new $P509, "Undef"
  vivify_725:
.annotate 'line', 223
    find_lex $P511, "$method_past"
    unless_null $P511, vivify_726
    $P511 = root_new ['parrot';'Hash']
  vivify_726:
    set $P512, $P511["compile_time_dummy"]
    unless_null $P512, vivify_727
    new $P512, "Undef"
  vivify_727:
    defined $I513, $P512
    if $I513, if_510
.annotate 'line', 230
    find_lex $P517, "$is_dispatcher"
    unless_null $P517, vivify_728
    new $P517, "Undef"
  vivify_728:
    if $P517, if_516
.annotate 'line', 246
    find_lex $P546, "$stub_code"
    unless_null $P546, vivify_729
    new $P546, "Undef"
  vivify_729:
    clone $P547, $P546
    store_lex "$dummy", $P547
.annotate 'line', 245
    goto if_516_end
  if_516:
.annotate 'line', 231
    find_lex $P518, "$method_past"
    unless_null $P518, vivify_730
    new $P518, "Undef"
  vivify_730:
    $P518."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 232
    new $P519, "DispatcherSub"
    find_lex $P520, "$stub_code"
    unless_null $P520, vivify_731
    new $P520, "Undef"
  vivify_731:
    assign $P519, $P520
    store_lex "$dummy", $P519
.annotate 'line', 236
    find_lex $P521, "$dummy"
    unless_null $P521, vivify_732
    new $P521, "Undef"
  vivify_732:
    .const 'Sub' $P523 = "27_1304523757.895" 
    newclosure $P545, $P523
    setprop $P521, "CLONE_CALLBACK", $P545
  if_516_end:
.annotate 'line', 248
    find_lex $P548, "$dummy"
    unless_null $P548, vivify_737
    new $P548, "Undef"
  vivify_737:
    find_lex $P549, "$name"
    unless_null $P549, vivify_738
    new $P549, "Undef"
  vivify_738:
    set $S550, $P549
    assign $P548, $S550
.annotate 'line', 249
    find_lex $P551, "self"
    find_lex $P552, "$dummy"
    unless_null $P552, vivify_739
    new $P552, "Undef"
  vivify_739:
    $P551."add_code"($P552)
.annotate 'line', 250
    find_lex $P553, "$dummy"
    unless_null $P553, vivify_740
    new $P553, "Undef"
  vivify_740:
    find_lex $P554, "$method_past"
    unless_null $P554, vivify_741
    $P554 = root_new ['parrot';'Hash']
    store_lex "$method_past", $P554
  vivify_741:
    set $P554["compile_time_dummy"], $P553
.annotate 'line', 226
    goto if_510_end
  if_510:
.annotate 'line', 224
    find_lex $P514, "$method_past"
    unless_null $P514, vivify_742
    $P514 = root_new ['parrot';'Hash']
  vivify_742:
    set $P515, $P514["compile_time_dummy"]
    unless_null $P515, vivify_743
    new $P515, "Undef"
  vivify_743:
    store_lex "$dummy", $P515
  if_510_end:
.annotate 'line', 254
    find_lex $P555, "$dummy"
    unless_null $P555, vivify_744
    new $P555, "Undef"
  vivify_744:
    find_lex $P556, "$method_past"
    unless_null $P556, vivify_745
    new $P556, "Undef"
  vivify_745:
    setprop $P555, "PAST", $P556
.annotate 'line', 257
    find_lex $P557, "$obj"
    unless_null $P557, vivify_746
    new $P557, "Undef"
  vivify_746:
    get_how $P558, $P557
    find_lex $P559, "$obj"
    unless_null $P559, vivify_747
    new $P559, "Undef"
  vivify_747:
    find_lex $P560, "$name"
    unless_null $P560, vivify_748
    new $P560, "Undef"
  vivify_748:
    find_lex $P561, "$dummy"
    unless_null $P561, vivify_749
    new $P561, "Undef"
  vivify_749:
    find_lex $P562, "$meta_method_name"
    unless_null $P562, vivify_750
    new $P562, "Undef"
  vivify_750:
    set $S563, $P562
    $P558.$S563($P559, $P560, $P561)
.annotate 'line', 262
    find_lex $P564, "$fixups"
    unless_null $P564, vivify_751
    new $P564, "Undef"
  vivify_751:
    get_hll_global $P565, "GLOBAL"
    nqp_get_package_through_who $P566, $P565, "PAST"
    get_who $P567, $P566
    set $P568, $P567["Op"]
.annotate 'line', 264
    find_lex $P569, "self"
    find_lex $P570, "$dummy"
    unless_null $P570, vivify_752
    new $P570, "Undef"
  vivify_752:
    $P571 = $P569."get_slot_past_for_object"($P570)
.annotate 'line', 265
    get_hll_global $P572, "GLOBAL"
    nqp_get_package_through_who $P573, $P572, "PAST"
    get_who $P574, $P573
    set $P575, $P574["Val"]
    find_lex $P576, "$method_past"
    unless_null $P576, vivify_753
    new $P576, "Undef"
  vivify_753:
    $P577 = $P575."new"($P576 :named("value"))
    $P578 = $P568."new"($P571, $P577, "assign vPP" :named("pirop"))
.annotate 'line', 262
    $P564."push"($P578)
.annotate 'line', 267
    find_lex $P579, "self"
    find_lex $P580, "$obj"
    unless_null $P580, vivify_754
    new $P580, "Undef"
  vivify_754:
    $P581 = $P579."get_slot_past_for_object"($P580)
    store_lex "$slot_past", $P581
.annotate 'line', 268
    find_lex $P582, "self"
.annotate 'line', 269
    get_hll_global $P583, "GLOBAL"
    nqp_get_package_through_who $P584, $P583, "PAST"
    get_who $P585, $P584
    set $P586, $P585["Op"]
    find_lex $P587, "$meta_method_name"
    unless_null $P587, vivify_755
    new $P587, "Undef"
  vivify_755:
.annotate 'line', 271
    get_hll_global $P588, "GLOBAL"
    nqp_get_package_through_who $P589, $P588, "PAST"
    get_who $P590, $P589
    set $P591, $P590["Op"]
    find_lex $P592, "$slot_past"
    unless_null $P592, vivify_756
    new $P592, "Undef"
  vivify_756:
    $P593 = $P591."new"($P592, "get_how PP" :named("pirop"))
    find_lex $P594, "$slot_past"
    unless_null $P594, vivify_757
    new $P594, "Undef"
  vivify_757:
    find_lex $P595, "$name"
    unless_null $P595, vivify_758
    new $P595, "Undef"
  vivify_758:
.annotate 'line', 274
    get_hll_global $P596, "GLOBAL"
    nqp_get_package_through_who $P597, $P596, "PAST"
    get_who $P598, $P597
    set $P599, $P598["Val"]
    find_lex $P600, "$method_past"
    unless_null $P600, vivify_759
    new $P600, "Undef"
  vivify_759:
    $P601 = $P599."new"($P600 :named("value"))
    $P602 = $P586."new"($P593, $P594, $P595, $P601, "callmethod" :named("pasttype"), $P587 :named("name"))
.annotate 'line', 269
    find_lex $P603, "$fixups"
    unless_null $P603, vivify_760
    new $P603, "Undef"
  vivify_760:
    $P604 = $P582."add_event"($P602 :named("deserialize_past"), $P603 :named("fixup_past"))
.annotate 'line', 219
    .return ($P604)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block522"  :anon :subid("27_1304523757.895") :outer("26_1304523757.895")
    .param pmc param_524
    .param pmc param_525
.annotate 'line', 236
    .lex "$orig", param_524
    .lex "$clone", param_525
.annotate 'line', 237
    find_lex $P526, "self"
    find_lex $P527, "$clone"
    unless_null $P527, vivify_733
    new $P527, "Undef"
  vivify_733:
    $P526."add_code"($P527)
.annotate 'line', 238
    find_lex $P528, "$fixups"
    unless_null $P528, vivify_734
    new $P528, "Undef"
  vivify_734:
    get_hll_global $P529, "GLOBAL"
    nqp_get_package_through_who $P530, $P529, "PAST"
    get_who $P531, $P530
    set $P532, $P531["Op"]
.annotate 'line', 240
    find_lex $P533, "self"
    find_lex $P534, "$clone"
    unless_null $P534, vivify_735
    new $P534, "Undef"
  vivify_735:
    $P535 = $P533."get_slot_past_for_object"($P534)
.annotate 'line', 241
    get_hll_global $P536, "GLOBAL"
    nqp_get_package_through_who $P537, $P536, "PAST"
    get_who $P538, $P537
    set $P539, $P538["Val"]
    find_lex $P540, "$orig"
    unless_null $P540, vivify_736
    new $P540, "Undef"
  vivify_736:
    getprop $P541, "PAST", $P540
    $P542 = $P539."new"($P541 :named("value"))
    $P543 = $P532."new"($P535, $P542, "assign vPP" :named("pirop"))
.annotate 'line', 238
    $P544 = $P528."push"($P543)
.annotate 'line', 236
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "set_routine_signature"  :subid("28_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_606
    .param pmc param_607
    .param pmc param_608
    .param pmc param_609
.annotate 'line', 280
    .lex "self", param_606
    .lex "$routine", param_607
    .lex "$types", param_608
    .lex "$definednesses", param_609
.annotate 'line', 283
    new $P610, "Undef"
    .lex "$fixup", $P610
.annotate 'line', 290
    new $P611, "Undef"
    .lex "$des", $P611
.annotate 'line', 283
    get_hll_global $P612, "GLOBAL"
    nqp_get_package_through_who $P613, $P612, "PAST"
    get_who $P614, $P613
    set $P615, $P614["Op"]
    find_lex $P616, "$types"
    unless_null $P616, vivify_761
    new $P616, "Undef"
  vivify_761:
    find_lex $P617, "$definednesses"
    unless_null $P617, vivify_762
    new $P617, "Undef"
  vivify_762:
    $P618 = $P615."new"($P616, $P617, "set_sub_multisig vPPP" :named("pirop"))
    store_lex "$fixup", $P618
.annotate 'line', 284
    find_lex $P620, "$routine"
    unless_null $P620, vivify_763
    $P620 = root_new ['parrot';'Hash']
  vivify_763:
    set $P621, $P620["compile_time_dummy"]
    unless_null $P621, vivify_764
    new $P621, "Undef"
  vivify_764:
    defined $I622, $P621
    if $I622, if_619
.annotate 'line', 288
    find_lex $P628, "$fixup"
    unless_null $P628, vivify_765
    new $P628, "Undef"
  vivify_765:
    get_hll_global $P629, "GLOBAL"
    nqp_get_package_through_who $P630, $P629, "PAST"
    get_who $P631, $P630
    set $P632, $P631["Val"]
    find_lex $P633, "$routine"
    unless_null $P633, vivify_766
    new $P633, "Undef"
  vivify_766:
    $P634 = $P632."new"($P633 :named("value"))
    $P628."unshift"($P634)
.annotate 'line', 287
    goto if_619_end
  if_619:
.annotate 'line', 285
    find_lex $P623, "$fixup"
    unless_null $P623, vivify_767
    new $P623, "Undef"
  vivify_767:
    find_lex $P624, "self"
    find_lex $P625, "$routine"
    unless_null $P625, vivify_768
    $P625 = root_new ['parrot';'Hash']
  vivify_768:
    set $P626, $P625["compile_time_dummy"]
    unless_null $P626, vivify_769
    new $P626, "Undef"
  vivify_769:
    $P627 = $P624."get_slot_past_for_object"($P626)
    $P623."unshift"($P627)
  if_619_end:
.annotate 'line', 290
    get_hll_global $P635, "GLOBAL"
    nqp_get_package_through_who $P636, $P635, "PAST"
    get_who $P637, $P636
    set $P638, $P637["Op"]
.annotate 'line', 291
    get_hll_global $P639, "GLOBAL"
    nqp_get_package_through_who $P640, $P639, "PAST"
    get_who $P641, $P640
    set $P642, $P641["Val"]
    find_lex $P643, "$routine"
    unless_null $P643, vivify_770
    new $P643, "Undef"
  vivify_770:
    $P644 = $P642."new"($P643 :named("value"))
    find_lex $P645, "$types"
    unless_null $P645, vivify_771
    new $P645, "Undef"
  vivify_771:
    find_lex $P646, "$definednesses"
    unless_null $P646, vivify_772
    new $P646, "Undef"
  vivify_772:
    $P647 = $P638."new"($P644, $P645, $P646, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 290
    store_lex "$des", $P647
.annotate 'line', 293
    find_lex $P648, "self"
    find_lex $P649, "$des"
    unless_null $P649, vivify_773
    new $P649, "Undef"
  vivify_773:
    find_lex $P650, "$fixup"
    unless_null $P650, vivify_774
    new $P650, "Undef"
  vivify_774:
    $P651 = $P648."add_event"($P649 :named("deserialize_past"), $P650 :named("fixup_past"))
.annotate 'line', 280
    .return ($P651)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_set_body_block"  :subid("29_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_653
    .param pmc param_654
    .param pmc param_655
.annotate 'line', 297
    .const 'Sub' $P666 = "30_1304523757.895" 
    capture_lex $P666
    .lex "self", param_653
    .lex "$obj", param_654
    .lex "$body_past", param_655
.annotate 'line', 308
    new $P656, "Undef"
    .lex "$fixups", $P656
.annotate 'line', 309
    new $P657, "Undef"
    .lex "$dummy", $P657
.annotate 'line', 344
    new $P658, "Undef"
    .lex "$slot_past", $P658
.annotate 'line', 345
    new $P659, "Undef"
    .lex "$des", $P659
.annotate 'line', 308
    get_hll_global $P660, "GLOBAL"
    nqp_get_package_through_who $P661, $P660, "PAST"
    get_who $P662, $P661
    set $P663, $P662["Stmts"]
    $P664 = $P663."new"()
    store_lex "$fixups", $P664
.annotate 'line', 309
    .const 'Sub' $P666 = "30_1304523757.895" 
    newclosure $P737, $P666
    store_lex "$dummy", $P737
.annotate 'line', 341
    find_lex $P738, "$obj"
    unless_null $P738, vivify_792
    new $P738, "Undef"
  vivify_792:
    get_how $P739, $P738
    find_lex $P740, "$obj"
    unless_null $P740, vivify_793
    new $P740, "Undef"
  vivify_793:
    find_lex $P741, "$dummy"
    unless_null $P741, vivify_794
    new $P741, "Undef"
  vivify_794:
    $P739."set_body_block"($P740, $P741)
.annotate 'line', 344
    find_lex $P742, "self"
    find_lex $P743, "$obj"
    unless_null $P743, vivify_795
    new $P743, "Undef"
  vivify_795:
    $P744 = $P742."get_slot_past_for_object"($P743)
    store_lex "$slot_past", $P744
.annotate 'line', 345
    get_hll_global $P745, "GLOBAL"
    nqp_get_package_through_who $P746, $P745, "PAST"
    get_who $P747, $P746
    set $P748, $P747["Op"]
.annotate 'line', 347
    get_hll_global $P749, "GLOBAL"
    nqp_get_package_through_who $P750, $P749, "PAST"
    get_who $P751, $P750
    set $P752, $P751["Op"]
    find_lex $P753, "$slot_past"
    unless_null $P753, vivify_796
    new $P753, "Undef"
  vivify_796:
    $P754 = $P752."new"($P753, "get_how PP" :named("pirop"))
    find_lex $P755, "$slot_past"
    unless_null $P755, vivify_797
    new $P755, "Undef"
  vivify_797:
.annotate 'line', 349
    get_hll_global $P756, "GLOBAL"
    nqp_get_package_through_who $P757, $P756, "PAST"
    get_who $P758, $P757
    set $P759, $P758["Val"]
    find_lex $P760, "$body_past"
    unless_null $P760, vivify_798
    new $P760, "Undef"
  vivify_798:
    $P761 = $P759."new"($P760 :named("value"))
    $P762 = $P748."new"($P754, $P755, $P761, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 345
    store_lex "$des", $P762
.annotate 'line', 352
    find_lex $P763, "self"
    find_lex $P764, "$des"
    unless_null $P764, vivify_799
    new $P764, "Undef"
  vivify_799:
    find_lex $P765, "$fixups"
    unless_null $P765, vivify_800
    new $P765, "Undef"
  vivify_800:
    $P766 = $P763."add_event"($P764 :named("deserialize_past"), $P765 :named("fixup_past"))
.annotate 'line', 297
    .return ($P766)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "_block665"  :anon :subid("30_1304523757.895") :outer("29_1304523757.895")
    .param pmc param_667 :slurpy
.annotate 'line', 309
    .const 'Sub' $P705 = "32_1304523757.895" 
    capture_lex $P705
    .const 'Sub' $P685 = "31_1304523757.895" 
    capture_lex $P685
    .lex "@type_args", param_667
.annotate 'line', 311
    new $P668, "Undef"
    .lex "$invoke_body", $P668
    get_hll_global $P669, "GLOBAL"
    nqp_get_package_through_who $P670, $P669, "PAST"
    get_who $P671, $P670
    set $P672, $P671["Op"]
.annotate 'line', 313
    get_hll_global $P673, "GLOBAL"
    nqp_get_package_through_who $P674, $P673, "PAST"
    get_who $P675, $P674
    set $P676, $P675["Val"]
    find_lex $P677, "$body_past"
    unless_null $P677, vivify_775
    new $P677, "Undef"
  vivify_775:
    $P678 = $P676."new"($P677 :named("value"))
    $P679 = $P672."new"($P678, "call" :named("pasttype"))
.annotate 'line', 311
    store_lex "$invoke_body", $P679
.annotate 'line', 315
    find_lex $P681, "@type_args"
    unless_null $P681, vivify_776
    $P681 = root_new ['parrot';'ResizablePMCArray']
  vivify_776:
    defined $I682, $P681
    unless $I682, for_undef_777
    iter $P680, $P681
    new $P693, 'ExceptionHandler'
    set_label $P693, loop692_handler
    $P693."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P693
  loop692_test:
    unless $P680, loop692_done
    shift $P683, $P680
  loop692_redo:
    .const 'Sub' $P685 = "31_1304523757.895" 
    capture_lex $P685
    $P685($P683)
  loop692_next:
    goto loop692_test
  loop692_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P694, exception, 'type'
    eq $P694, .CONTROL_LOOP_NEXT, loop692_next
    eq $P694, .CONTROL_LOOP_REDO, loop692_redo
  loop692_done:
    pop_eh 
  for_undef_777:
.annotate 'line', 318
    find_lex $P695, "$fixups"
    unless_null $P695, vivify_780
    new $P695, "Undef"
  vivify_780:
    find_lex $P696, "$invoke_body"
    unless_null $P696, vivify_781
    new $P696, "Undef"
  vivify_781:
    $P695."push"($P696)
.annotate 'line', 321
    find_lex $P698, "$obj"
    unless_null $P698, vivify_782
    new $P698, "Undef"
  vivify_782:
    get_how $P699, $P698
    find_lex $P700, "$obj"
    unless_null $P700, vivify_783
    new $P700, "Undef"
  vivify_783:
    $P701 = $P699."methods"($P700, 1 :named("local"))
    defined $I702, $P701
    unless $I702, for_undef_784
    iter $P697, $P701
    new $P735, 'ExceptionHandler'
    set_label $P735, loop734_handler
    $P735."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P735
  loop734_test:
    unless $P697, loop734_done
    shift $P703, $P697
  loop734_redo:
    .const 'Sub' $P705 = "32_1304523757.895" 
    capture_lex $P705
    $P705($P703)
  loop734_next:
    goto loop734_test
  loop734_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P736, exception, 'type'
    eq $P736, .CONTROL_LOOP_NEXT, loop734_next
    eq $P736, .CONTROL_LOOP_REDO, loop734_redo
  loop734_done:
    pop_eh 
  for_undef_784:
.annotate 'line', 309
    .return ($P697)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block684"  :anon :subid("31_1304523757.895") :outer("30_1304523757.895")
    .param pmc param_686
.annotate 'line', 315
    .lex "$_", param_686
.annotate 'line', 316
    find_lex $P687, "$invoke_body"
    unless_null $P687, vivify_778
    new $P687, "Undef"
  vivify_778:
    find_lex $P688, "self"
    find_lex $P689, "$_"
    unless_null $P689, vivify_779
    new $P689, "Undef"
  vivify_779:
    $P690 = $P688."get_slot_past_for_object"($P689)
    $P691 = $P687."push"($P690)
.annotate 'line', 315
    .return ($P691)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block704"  :anon :subid("32_1304523757.895") :outer("30_1304523757.895")
    .param pmc param_706
.annotate 'line', 321
    .const 'Sub' $P709 = "33_1304523757.895" 
    capture_lex $P709
    .lex "$_", param_706
.annotate 'line', 322
    find_lex $P707, "$_"
    unless_null $P707, vivify_785
    new $P707, "Undef"
  vivify_785:
    .const 'Sub' $P709 = "33_1304523757.895" 
    newclosure $P733, $P709
    setprop $P707, "REIFY_CALLBACK", $P733
.annotate 'line', 321
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block708"  :anon :subid("33_1304523757.895") :outer("32_1304523757.895")
    .param pmc param_710
.annotate 'line', 322
    .lex "$meth", param_710
.annotate 'line', 324
    new $P711, "Undef"
    .lex "$clone", $P711
    find_lex $P712, "$meth"
    unless_null $P712, vivify_786
    new $P712, "Undef"
  vivify_786:
    clone $P713, $P712
    store_lex "$clone", $P713
.annotate 'line', 325
    find_lex $P714, "self"
    find_lex $P715, "$clone"
    unless_null $P715, vivify_787
    new $P715, "Undef"
  vivify_787:
    $P714."add_code"($P715)
.annotate 'line', 328
    find_lex $P716, "$fixups"
    unless_null $P716, vivify_788
    new $P716, "Undef"
  vivify_788:
    get_hll_global $P717, "GLOBAL"
    nqp_get_package_through_who $P718, $P717, "PAST"
    get_who $P719, $P718
    set $P720, $P719["Op"]
.annotate 'line', 330
    find_lex $P721, "self"
    find_lex $P722, "$clone"
    unless_null $P722, vivify_789
    new $P722, "Undef"
  vivify_789:
    $P723 = $P721."get_slot_past_for_object"($P722)
.annotate 'line', 331
    get_hll_global $P724, "GLOBAL"
    nqp_get_package_through_who $P725, $P724, "PAST"
    get_who $P726, $P725
    set $P727, $P726["Val"]
    find_lex $P728, "$meth"
    unless_null $P728, vivify_790
    new $P728, "Undef"
  vivify_790:
    getprop $P729, "PAST", $P728
    $P730 = $P727."new"($P729 :named("value"))
    $P731 = $P720."new"($P723, $P730, "assign vPP" :named("pirop"))
.annotate 'line', 328
    $P716."push"($P731)
    find_lex $P732, "$clone"
    unless_null $P732, vivify_791
    new $P732, "Undef"
  vivify_791:
.annotate 'line', 322
    .return ($P732)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_add_parent_or_role"  :subid("34_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_768
    .param pmc param_769
    .param pmc param_770
    .param pmc param_771
.annotate 'line', 357
    .lex "self", param_768
    .lex "$obj", param_769
    .lex "$meta_method_name", param_770
    .lex "$to_add", param_771
.annotate 'line', 362
    new $P772, "Undef"
    .lex "$slot_past", $P772
.annotate 'line', 359
    find_lex $P773, "$obj"
    unless_null $P773, vivify_801
    new $P773, "Undef"
  vivify_801:
    get_how $P774, $P773
    find_lex $P775, "$obj"
    unless_null $P775, vivify_802
    new $P775, "Undef"
  vivify_802:
    find_lex $P776, "$to_add"
    unless_null $P776, vivify_803
    new $P776, "Undef"
  vivify_803:
    find_lex $P777, "$meta_method_name"
    unless_null $P777, vivify_804
    new $P777, "Undef"
  vivify_804:
    set $S778, $P777
    $P774.$S778($P775, $P776)
.annotate 'line', 362
    find_lex $P779, "self"
    find_lex $P780, "$obj"
    unless_null $P780, vivify_805
    new $P780, "Undef"
  vivify_805:
    $P781 = $P779."get_slot_past_for_object"($P780)
    store_lex "$slot_past", $P781
.annotate 'line', 363
    find_lex $P782, "self"
    get_hll_global $P783, "GLOBAL"
    nqp_get_package_through_who $P784, $P783, "PAST"
    get_who $P785, $P784
    set $P786, $P785["Op"]
    find_lex $P787, "$meta_method_name"
    unless_null $P787, vivify_806
    new $P787, "Undef"
  vivify_806:
.annotate 'line', 365
    get_hll_global $P788, "GLOBAL"
    nqp_get_package_through_who $P789, $P788, "PAST"
    get_who $P790, $P789
    set $P791, $P790["Op"]
    find_lex $P792, "$slot_past"
    unless_null $P792, vivify_807
    new $P792, "Undef"
  vivify_807:
    $P793 = $P791."new"($P792, "get_how PP" :named("pirop"))
    find_lex $P794, "$slot_past"
    unless_null $P794, vivify_808
    new $P794, "Undef"
  vivify_808:
.annotate 'line', 367
    find_lex $P795, "self"
    find_lex $P796, "$to_add"
    unless_null $P796, vivify_809
    new $P796, "Undef"
  vivify_809:
    $P797 = $P795."get_object_sc_ref_past"($P796)
    $P798 = $P786."new"($P793, $P794, $P797, "callmethod" :named("pasttype"), $P787 :named("name"))
.annotate 'line', 363
    $P799 = $P782."add_event"($P798 :named("deserialize_past"))
.annotate 'line', 357
    .return ($P799)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "pkg_compose"  :subid("35_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_801
    .param pmc param_802
.annotate 'line', 372
    .lex "self", param_801
    .lex "$obj", param_802
.annotate 'line', 377
    new $P803, "Undef"
    .lex "$slot_past", $P803
.annotate 'line', 374
    find_lex $P804, "$obj"
    unless_null $P804, vivify_810
    new $P804, "Undef"
  vivify_810:
    get_how $P805, $P804
    find_lex $P806, "$obj"
    unless_null $P806, vivify_811
    new $P806, "Undef"
  vivify_811:
    $P805."compose"($P806)
.annotate 'line', 377
    find_lex $P807, "self"
    find_lex $P808, "$obj"
    unless_null $P808, vivify_812
    new $P808, "Undef"
  vivify_812:
    $P809 = $P807."get_slot_past_for_object"($P808)
    store_lex "$slot_past", $P809
.annotate 'line', 378
    find_lex $P810, "self"
    get_hll_global $P811, "GLOBAL"
    nqp_get_package_through_who $P812, $P811, "PAST"
    get_who $P813, $P812
    set $P814, $P813["Op"]
.annotate 'line', 380
    get_hll_global $P815, "GLOBAL"
    nqp_get_package_through_who $P816, $P815, "PAST"
    get_who $P817, $P816
    set $P818, $P817["Op"]
    find_lex $P819, "$slot_past"
    unless_null $P819, vivify_813
    new $P819, "Undef"
  vivify_813:
    $P820 = $P818."new"($P819, "get_how PP" :named("pirop"))
    find_lex $P821, "$slot_past"
    unless_null $P821, vivify_814
    new $P821, "Undef"
  vivify_814:
    $P822 = $P814."new"($P820, $P821, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 378
    $P823 = $P810."add_event"($P822 :named("deserialize_past"))
.annotate 'line', 372
    .return ($P823)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.include "except_types.pasm"
.sub "to_past"  :subid("36_1304523757.895") :outer("12_1304523757.895")
    .param pmc param_825
.annotate 'line', 387
    .const 'Sub' $P844 = "37_1304523757.895" 
    capture_lex $P844
    .lex "self", param_825
.annotate 'line', 388
    new $P826, "Undef"
    .lex "$des", $P826
.annotate 'line', 389
    new $P827, "Undef"
    .lex "$fix", $P827
.annotate 'line', 388
    get_hll_global $P828, "GLOBAL"
    nqp_get_package_through_who $P829, $P828, "PAST"
    get_who $P830, $P829
    set $P831, $P830["Stmts"]
    $P832 = $P831."new"()
    store_lex "$des", $P832
.annotate 'line', 389
    get_hll_global $P833, "GLOBAL"
    nqp_get_package_through_who $P834, $P833, "PAST"
    get_who $P835, $P834
    set $P836, $P835["Stmts"]
    $P837 = $P836."new"()
    store_lex "$fix", $P837
.annotate 'line', 390
    find_lex $P839, "self"
    $P840 = $P839."event_stream"()
    defined $I841, $P840
    unless $I841, for_undef_815
    iter $P838, $P840
    new $P863, 'ExceptionHandler'
    set_label $P863, loop862_handler
    $P863."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P863
  loop862_test:
    unless $P838, loop862_done
    shift $P842, $P838
  loop862_redo:
    .const 'Sub' $P844 = "37_1304523757.895" 
    capture_lex $P844
    $P844($P842)
  loop862_next:
    goto loop862_test
  loop862_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P864, exception, 'type'
    eq $P864, .CONTROL_LOOP_NEXT, loop862_next
    eq $P864, .CONTROL_LOOP_REDO, loop862_redo
  loop862_done:
    pop_eh 
  for_undef_815:
.annotate 'line', 394
    find_dynamic_lex $P865, "$/"
    get_hll_global $P866, "GLOBAL"
    nqp_get_package_through_who $P867, $P866, "PAST"
    get_who $P868, $P867
    set $P869, $P868["Op"]
.annotate 'line', 396
    get_hll_global $P870, "GLOBAL"
    nqp_get_package_through_who $P871, $P870, "PAST"
    get_who $P872, $P871
    set $P873, $P872["Op"]
.annotate 'line', 398
    get_hll_global $P874, "GLOBAL"
    nqp_get_package_through_who $P875, $P874, "PAST"
    get_who $P876, $P875
    set $P877, $P876["Op"]
    find_lex $P878, "self"
    $P879 = $P878."handle"()
    $P880 = $P877."new"($P879, "nqp_get_sc Ps" :named("pirop"))
    $P881 = $P873."new"($P880, "isnull IP" :named("pirop"))
.annotate 'line', 400
    get_hll_global $P882, "GLOBAL"
    nqp_get_package_through_who $P883, $P882, "PAST"
    get_who $P884, $P883
    set $P885, $P884["Stmts"]
.annotate 'line', 401
    get_hll_global $P886, "GLOBAL"
    nqp_get_package_through_who $P887, $P886, "PAST"
    get_who $P888, $P887
    set $P889, $P888["Op"]
    $P890 = $P889."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 402
    get_hll_global $P891, "GLOBAL"
    nqp_get_package_through_who $P892, $P891, "PAST"
    get_who $P893, $P892
    set $P894, $P893["Op"]
.annotate 'line', 404
    get_hll_global $P895, "GLOBAL"
    nqp_get_package_through_who $P896, $P895, "PAST"
    get_who $P897, $P896
    set $P898, $P897["Op"]
    $P899 = $P898."new"("getinterp P" :named("pirop"))
.annotate 'line', 405
    get_hll_global $P900, "GLOBAL"
    nqp_get_package_through_who $P901, $P900, "PAST"
    get_who $P902, $P901
    set $P903, $P902["Op"]
    $P904 = $P903."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 406
    get_hll_global $P905, "GLOBAL"
    nqp_get_package_through_who $P906, $P905, "PAST"
    get_who $P907, $P906
    set $P908, $P907["Op"]
    $P909 = $P908."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P910 = $P894."new"($P899, $P904, $P909, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 408
    get_hll_global $P911, "GLOBAL"
    nqp_get_package_through_who $P912, $P911, "PAST"
    get_who $P913, $P912
    set $P914, $P913["Op"]
.annotate 'line', 410
    get_hll_global $P915, "GLOBAL"
    nqp_get_package_through_who $P916, $P915, "PAST"
    get_who $P917, $P916
    set $P918, $P917["Var"]
    $P919 = $P918."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 411
    get_hll_global $P920, "GLOBAL"
    nqp_get_package_through_who $P921, $P920, "PAST"
    get_who $P922, $P921
    set $P923, $P922["Op"]
    find_lex $P924, "self"
    $P925 = $P924."handle"()
    $P926 = $P923."new"($P925, "nqp_create_sc Ps" :named("pirop"))
    $P927 = $P914."new"($P919, $P926, "bind" :named("pasttype"))
.annotate 'line', 408
    find_lex $P928, "$des"
    unless_null $P928, vivify_822
    new $P928, "Undef"
  vivify_822:
    $P929 = $P885."new"($P890, $P910, $P927, $P928)
.annotate 'line', 400
    find_lex $P930, "$fix"
    unless_null $P930, vivify_823
    new $P930, "Undef"
  vivify_823:
    $P931 = $P869."new"($P881, $P929, $P930, "if" :named("pasttype"))
.annotate 'line', 394
    $P932 = $P865."!make"($P931)
.annotate 'line', 387
    .return ($P932)
.end


.HLL "nqp"

.namespace ["NQP";"SymbolTable"]
.sub "_block843"  :anon :subid("37_1304523757.895") :outer("36_1304523757.895")
    .param pmc param_845
.annotate 'line', 390
    .lex "$_", param_845
.annotate 'line', 391
    find_lex $P847, "$_"
    unless_null $P847, vivify_816
    new $P847, "Undef"
  vivify_816:
    $P848 = $P847."deserialize_past"()
    defined $I849, $P848
    unless $I849, if_846_end
    find_lex $P850, "$des"
    unless_null $P850, vivify_817
    new $P850, "Undef"
  vivify_817:
    find_lex $P851, "$_"
    unless_null $P851, vivify_818
    new $P851, "Undef"
  vivify_818:
    $P852 = $P851."deserialize_past"()
    $P850."push"($P852)
  if_846_end:
.annotate 'line', 392
    find_lex $P855, "$_"
    unless_null $P855, vivify_819
    new $P855, "Undef"
  vivify_819:
    $P856 = $P855."fixup_past"()
    defined $I857, $P856
    if $I857, if_854
    new $P853, 'Integer'
    set $P853, $I857
    goto if_854_end
  if_854:
    find_lex $P858, "$fix"
    unless_null $P858, vivify_820
    new $P858, "Undef"
  vivify_820:
    find_lex $P859, "$_"
    unless_null $P859, vivify_821
    new $P859, "Undef"
  vivify_821:
    $P860 = $P859."fixup_past"()
    $P861 = $P858."push"($P860)
    set $P853, $P861
  if_854_end:
.annotate 'line', 390
    .return ($P853)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block934"  :subid("38_1304523757.895") :outer("10_1304523757.895")
.annotate 'line', 421
    .const 'Sub' $P2785 = "410_1304523757.895" 
    capture_lex $P2785
    .const 'Sub' $P2783 = "409_1304523757.895" 
    capture_lex $P2783
    .const 'Sub' $P2779 = "408_1304523757.895" 
    capture_lex $P2779
    .const 'Sub' $P2777 = "407_1304523757.895" 
    capture_lex $P2777
    .const 'Sub' $P2773 = "406_1304523757.895" 
    capture_lex $P2773
    .const 'Sub' $P2771 = "405_1304523757.895" 
    capture_lex $P2771
    .const 'Sub' $P2767 = "404_1304523757.895" 
    capture_lex $P2767
    .const 'Sub' $P2765 = "403_1304523757.895" 
    capture_lex $P2765
    .const 'Sub' $P2761 = "402_1304523757.895" 
    capture_lex $P2761
    .const 'Sub' $P2759 = "401_1304523757.895" 
    capture_lex $P2759
    .const 'Sub' $P2749 = "399_1304523757.895" 
    capture_lex $P2749
    .const 'Sub' $P2746 = "398_1304523757.895" 
    capture_lex $P2746
    .const 'Sub' $P2742 = "397_1304523757.895" 
    capture_lex $P2742
    .const 'Sub' $P2739 = "396_1304523757.895" 
    capture_lex $P2739
    .const 'Sub' $P2735 = "395_1304523757.895" 
    capture_lex $P2735
    .const 'Sub' $P2732 = "394_1304523757.895" 
    capture_lex $P2732
    .const 'Sub' $P2728 = "393_1304523757.895" 
    capture_lex $P2728
    .const 'Sub' $P2725 = "392_1304523757.895" 
    capture_lex $P2725
    .const 'Sub' $P2721 = "391_1304523757.895" 
    capture_lex $P2721
    .const 'Sub' $P2718 = "390_1304523757.895" 
    capture_lex $P2718
    .const 'Sub' $P2715 = "389_1304523757.895" 
    capture_lex $P2715
    .const 'Sub' $P2712 = "388_1304523757.895" 
    capture_lex $P2712
    .const 'Sub' $P2708 = "387_1304523757.895" 
    capture_lex $P2708
    .const 'Sub' $P2705 = "386_1304523757.895" 
    capture_lex $P2705
    .const 'Sub' $P2701 = "385_1304523757.895" 
    capture_lex $P2701
    .const 'Sub' $P2698 = "384_1304523757.895" 
    capture_lex $P2698
    .const 'Sub' $P2694 = "383_1304523757.895" 
    capture_lex $P2694
    .const 'Sub' $P2691 = "382_1304523757.895" 
    capture_lex $P2691
    .const 'Sub' $P2687 = "381_1304523757.895" 
    capture_lex $P2687
    .const 'Sub' $P2684 = "380_1304523757.895" 
    capture_lex $P2684
    .const 'Sub' $P2680 = "379_1304523757.895" 
    capture_lex $P2680
    .const 'Sub' $P2677 = "378_1304523757.895" 
    capture_lex $P2677
    .const 'Sub' $P2673 = "377_1304523757.895" 
    capture_lex $P2673
    .const 'Sub' $P2670 = "376_1304523757.895" 
    capture_lex $P2670
    .const 'Sub' $P2666 = "375_1304523757.895" 
    capture_lex $P2666
    .const 'Sub' $P2663 = "374_1304523757.895" 
    capture_lex $P2663
    .const 'Sub' $P2659 = "373_1304523757.895" 
    capture_lex $P2659
    .const 'Sub' $P2656 = "372_1304523757.895" 
    capture_lex $P2656
    .const 'Sub' $P2652 = "371_1304523757.895" 
    capture_lex $P2652
    .const 'Sub' $P2649 = "370_1304523757.895" 
    capture_lex $P2649
    .const 'Sub' $P2645 = "369_1304523757.895" 
    capture_lex $P2645
    .const 'Sub' $P2642 = "368_1304523757.895" 
    capture_lex $P2642
    .const 'Sub' $P2638 = "367_1304523757.895" 
    capture_lex $P2638
    .const 'Sub' $P2635 = "366_1304523757.895" 
    capture_lex $P2635
    .const 'Sub' $P2631 = "365_1304523757.895" 
    capture_lex $P2631
    .const 'Sub' $P2628 = "364_1304523757.895" 
    capture_lex $P2628
    .const 'Sub' $P2624 = "363_1304523757.895" 
    capture_lex $P2624
    .const 'Sub' $P2621 = "362_1304523757.895" 
    capture_lex $P2621
    .const 'Sub' $P2617 = "361_1304523757.895" 
    capture_lex $P2617
    .const 'Sub' $P2614 = "360_1304523757.895" 
    capture_lex $P2614
    .const 'Sub' $P2610 = "359_1304523757.895" 
    capture_lex $P2610
    .const 'Sub' $P2607 = "358_1304523757.895" 
    capture_lex $P2607
    .const 'Sub' $P2603 = "357_1304523757.895" 
    capture_lex $P2603
    .const 'Sub' $P2600 = "356_1304523757.895" 
    capture_lex $P2600
    .const 'Sub' $P2596 = "355_1304523757.895" 
    capture_lex $P2596
    .const 'Sub' $P2593 = "354_1304523757.895" 
    capture_lex $P2593
    .const 'Sub' $P2589 = "353_1304523757.895" 
    capture_lex $P2589
    .const 'Sub' $P2586 = "352_1304523757.895" 
    capture_lex $P2586
    .const 'Sub' $P2582 = "351_1304523757.895" 
    capture_lex $P2582
    .const 'Sub' $P2579 = "350_1304523757.895" 
    capture_lex $P2579
    .const 'Sub' $P2575 = "349_1304523757.895" 
    capture_lex $P2575
    .const 'Sub' $P2572 = "348_1304523757.895" 
    capture_lex $P2572
    .const 'Sub' $P2568 = "347_1304523757.895" 
    capture_lex $P2568
    .const 'Sub' $P2565 = "346_1304523757.895" 
    capture_lex $P2565
    .const 'Sub' $P2561 = "345_1304523757.895" 
    capture_lex $P2561
    .const 'Sub' $P2558 = "344_1304523757.895" 
    capture_lex $P2558
    .const 'Sub' $P2554 = "343_1304523757.895" 
    capture_lex $P2554
    .const 'Sub' $P2551 = "342_1304523757.895" 
    capture_lex $P2551
    .const 'Sub' $P2547 = "341_1304523757.895" 
    capture_lex $P2547
    .const 'Sub' $P2544 = "340_1304523757.895" 
    capture_lex $P2544
    .const 'Sub' $P2540 = "339_1304523757.895" 
    capture_lex $P2540
    .const 'Sub' $P2537 = "338_1304523757.895" 
    capture_lex $P2537
    .const 'Sub' $P2533 = "337_1304523757.895" 
    capture_lex $P2533
    .const 'Sub' $P2530 = "336_1304523757.895" 
    capture_lex $P2530
    .const 'Sub' $P2526 = "335_1304523757.895" 
    capture_lex $P2526
    .const 'Sub' $P2523 = "334_1304523757.895" 
    capture_lex $P2523
    .const 'Sub' $P2519 = "333_1304523757.895" 
    capture_lex $P2519
    .const 'Sub' $P2516 = "332_1304523757.895" 
    capture_lex $P2516
    .const 'Sub' $P2512 = "331_1304523757.895" 
    capture_lex $P2512
    .const 'Sub' $P2510 = "330_1304523757.895" 
    capture_lex $P2510
    .const 'Sub' $P2506 = "329_1304523757.895" 
    capture_lex $P2506
    .const 'Sub' $P2503 = "328_1304523757.895" 
    capture_lex $P2503
    .const 'Sub' $P2499 = "327_1304523757.895" 
    capture_lex $P2499
    .const 'Sub' $P2496 = "326_1304523757.895" 
    capture_lex $P2496
    .const 'Sub' $P2492 = "325_1304523757.895" 
    capture_lex $P2492
    .const 'Sub' $P2489 = "324_1304523757.895" 
    capture_lex $P2489
    .const 'Sub' $P2485 = "323_1304523757.895" 
    capture_lex $P2485
    .const 'Sub' $P2482 = "322_1304523757.895" 
    capture_lex $P2482
    .const 'Sub' $P2478 = "321_1304523757.895" 
    capture_lex $P2478
    .const 'Sub' $P2475 = "320_1304523757.895" 
    capture_lex $P2475
    .const 'Sub' $P2471 = "319_1304523757.895" 
    capture_lex $P2471
    .const 'Sub' $P2468 = "318_1304523757.895" 
    capture_lex $P2468
    .const 'Sub' $P2464 = "317_1304523757.895" 
    capture_lex $P2464
    .const 'Sub' $P2461 = "316_1304523757.895" 
    capture_lex $P2461
    .const 'Sub' $P2457 = "315_1304523757.895" 
    capture_lex $P2457
    .const 'Sub' $P2454 = "314_1304523757.895" 
    capture_lex $P2454
    .const 'Sub' $P2451 = "313_1304523757.895" 
    capture_lex $P2451
    .const 'Sub' $P2448 = "312_1304523757.895" 
    capture_lex $P2448
    .const 'Sub' $P2445 = "311_1304523757.895" 
    capture_lex $P2445
    .const 'Sub' $P2443 = "310_1304523757.895" 
    capture_lex $P2443
    .const 'Sub' $P2440 = "309_1304523757.895" 
    capture_lex $P2440
    .const 'Sub' $P2437 = "308_1304523757.895" 
    capture_lex $P2437
    .const 'Sub' $P2434 = "307_1304523757.895" 
    capture_lex $P2434
    .const 'Sub' $P2431 = "306_1304523757.895" 
    capture_lex $P2431
    .const 'Sub' $P2428 = "305_1304523757.895" 
    capture_lex $P2428
    .const 'Sub' $P2426 = "304_1304523757.895" 
    capture_lex $P2426
    .const 'Sub' $P2423 = "303_1304523757.895" 
    capture_lex $P2423
    .const 'Sub' $P2421 = "302_1304523757.895" 
    capture_lex $P2421
    .const 'Sub' $P2418 = "301_1304523757.895" 
    capture_lex $P2418
    .const 'Sub' $P2415 = "300_1304523757.895" 
    capture_lex $P2415
    .const 'Sub' $P2410 = "299_1304523757.895" 
    capture_lex $P2410
    .const 'Sub' $P2407 = "298_1304523757.895" 
    capture_lex $P2407
    .const 'Sub' $P2401 = "297_1304523757.895" 
    capture_lex $P2401
    .const 'Sub' $P2399 = "296_1304523757.895" 
    capture_lex $P2399
    .const 'Sub' $P2396 = "295_1304523757.895" 
    capture_lex $P2396
    .const 'Sub' $P2394 = "294_1304523757.895" 
    capture_lex $P2394
    .const 'Sub' $P2391 = "293_1304523757.895" 
    capture_lex $P2391
    .const 'Sub' $P2389 = "292_1304523757.895" 
    capture_lex $P2389
    .const 'Sub' $P2386 = "291_1304523757.895" 
    capture_lex $P2386
    .const 'Sub' $P2383 = "290_1304523757.895" 
    capture_lex $P2383
    .const 'Sub' $P2378 = "289_1304523757.895" 
    capture_lex $P2378
    .const 'Sub' $P2375 = "288_1304523757.895" 
    capture_lex $P2375
    .const 'Sub' $P2370 = "287_1304523757.895" 
    capture_lex $P2370
    .const 'Sub' $P2368 = "286_1304523757.895" 
    capture_lex $P2368
    .const 'Sub' $P2365 = "285_1304523757.895" 
    capture_lex $P2365
    .const 'Sub' $P2363 = "284_1304523757.895" 
    capture_lex $P2363
    .const 'Sub' $P2360 = "283_1304523757.895" 
    capture_lex $P2360
    .const 'Sub' $P2358 = "282_1304523757.895" 
    capture_lex $P2358
    .const 'Sub' $P2355 = "281_1304523757.895" 
    capture_lex $P2355
    .const 'Sub' $P2352 = "280_1304523757.895" 
    capture_lex $P2352
    .const 'Sub' $P2349 = "279_1304523757.895" 
    capture_lex $P2349
    .const 'Sub' $P2346 = "278_1304523757.895" 
    capture_lex $P2346
    .const 'Sub' $P2342 = "277_1304523757.895" 
    capture_lex $P2342
    .const 'Sub' $P2339 = "276_1304523757.895" 
    capture_lex $P2339
    .const 'Sub' $P2335 = "275_1304523757.895" 
    capture_lex $P2335
    .const 'Sub' $P2332 = "274_1304523757.895" 
    capture_lex $P2332
    .const 'Sub' $P2328 = "273_1304523757.895" 
    capture_lex $P2328
    .const 'Sub' $P2325 = "272_1304523757.895" 
    capture_lex $P2325
    .const 'Sub' $P2321 = "271_1304523757.895" 
    capture_lex $P2321
    .const 'Sub' $P2319 = "270_1304523757.895" 
    capture_lex $P2319
    .const 'Sub' $P2316 = "269_1304523757.895" 
    capture_lex $P2316
    .const 'Sub' $P2314 = "268_1304523757.895" 
    capture_lex $P2314
    .const 'Sub' $P2311 = "267_1304523757.895" 
    capture_lex $P2311
    .const 'Sub' $P2303 = "264_1304523757.895" 
    capture_lex $P2303
    .const 'Sub' $P2297 = "263_1304523757.895" 
    capture_lex $P2297
    .const 'Sub' $P2293 = "262_1304523757.895" 
    capture_lex $P2293
    .const 'Sub' $P2289 = "261_1304523757.895" 
    capture_lex $P2289
    .const 'Sub' $P2286 = "260_1304523757.895" 
    capture_lex $P2286
    .const 'Sub' $P2283 = "259_1304523757.895" 
    capture_lex $P2283
    .const 'Sub' $P2280 = "258_1304523757.895" 
    capture_lex $P2280
    .const 'Sub' $P2276 = "257_1304523757.895" 
    capture_lex $P2276
    .const 'Sub' $P2273 = "256_1304523757.895" 
    capture_lex $P2273
    .const 'Sub' $P2270 = "255_1304523757.895" 
    capture_lex $P2270
    .const 'Sub' $P2268 = "254_1304523757.895" 
    capture_lex $P2268
    .const 'Sub' $P2254 = "252_1304523757.895" 
    capture_lex $P2254
    .const 'Sub' $P2252 = "251_1304523757.895" 
    capture_lex $P2252
    .const 'Sub' $P2246 = "250_1304523757.895" 
    capture_lex $P2246
    .const 'Sub' $P2243 = "249_1304523757.895" 
    capture_lex $P2243
    .const 'Sub' $P2238 = "248_1304523757.895" 
    capture_lex $P2238
    .const 'Sub' $P2235 = "247_1304523757.895" 
    capture_lex $P2235
    .const 'Sub' $P2232 = "246_1304523757.895" 
    capture_lex $P2232
    .const 'Sub' $P2230 = "245_1304523757.895" 
    capture_lex $P2230
    .const 'Sub' $P2226 = "244_1304523757.895" 
    capture_lex $P2226
    .const 'Sub' $P2217 = "241_1304523757.895" 
    capture_lex $P2217
    .const 'Sub' $P2210 = "240_1304523757.895" 
    capture_lex $P2210
    .const 'Sub' $P2207 = "239_1304523757.895" 
    capture_lex $P2207
    .const 'Sub' $P2169 = "238_1304523757.895" 
    capture_lex $P2169
    .const 'Sub' $P2166 = "237_1304523757.895" 
    capture_lex $P2166
    .const 'Sub' $P2158 = "236_1304523757.895" 
    capture_lex $P2158
    .const 'Sub' $P2149 = "233_1304523757.895" 
    capture_lex $P2149
    .const 'Sub' $P2144 = "232_1304523757.895" 
    capture_lex $P2144
    .const 'Sub' $P2141 = "231_1304523757.895" 
    capture_lex $P2141
    .const 'Sub' $P2135 = "230_1304523757.895" 
    capture_lex $P2135
    .const 'Sub' $P2132 = "229_1304523757.895" 
    capture_lex $P2132
    .const 'Sub' $P2129 = "228_1304523757.895" 
    capture_lex $P2129
    .const 'Sub' $P2126 = "227_1304523757.895" 
    capture_lex $P2126
    .const 'Sub' $P2119 = "226_1304523757.895" 
    capture_lex $P2119
    .const 'Sub' $P2117 = "225_1304523757.895" 
    capture_lex $P2117
    .const 'Sub' $P2104 = "224_1304523757.895" 
    capture_lex $P2104
    .const 'Sub' $P2102 = "223_1304523757.895" 
    capture_lex $P2102
    .const 'Sub' $P2088 = "221_1304523757.895" 
    capture_lex $P2088
    .const 'Sub' $P2085 = "220_1304523757.895" 
    capture_lex $P2085
    .const 'Sub' $P2080 = "219_1304523757.895" 
    capture_lex $P2080
    .const 'Sub' $P2077 = "218_1304523757.895" 
    capture_lex $P2077
    .const 'Sub' $P2070 = "217_1304523757.895" 
    capture_lex $P2070
    .const 'Sub' $P2067 = "216_1304523757.895" 
    capture_lex $P2067
    .const 'Sub' $P2060 = "215_1304523757.895" 
    capture_lex $P2060
    .const 'Sub' $P2052 = "212_1304523757.895" 
    capture_lex $P2052
    .const 'Sub' $P2039 = "210_1304523757.895" 
    capture_lex $P2039
    .const 'Sub' $P2036 = "209_1304523757.895" 
    capture_lex $P2036
    .const 'Sub' $P1995 = "207_1304523757.895" 
    capture_lex $P1995
    .const 'Sub' $P1992 = "206_1304523757.895" 
    capture_lex $P1992
    .const 'Sub' $P1961 = "205_1304523757.895" 
    capture_lex $P1961
    .const 'Sub' $P1958 = "204_1304523757.895" 
    capture_lex $P1958
    .const 'Sub' $P1954 = "203_1304523757.895" 
    capture_lex $P1954
    .const 'Sub' $P1951 = "202_1304523757.895" 
    capture_lex $P1951
    .const 'Sub' $P1947 = "201_1304523757.895" 
    capture_lex $P1947
    .const 'Sub' $P1938 = "198_1304523757.895" 
    capture_lex $P1938
    .const 'Sub' $P1920 = "196_1304523757.895" 
    capture_lex $P1920
    .const 'Sub' $P1916 = "195_1304523757.895" 
    capture_lex $P1916
    .const 'Sub' $P1912 = "194_1304523757.895" 
    capture_lex $P1912
    .const 'Sub' $P1909 = "193_1304523757.895" 
    capture_lex $P1909
    .const 'Sub' $P1893 = "191_1304523757.895" 
    capture_lex $P1893
    .const 'Sub' $P1888 = "190_1304523757.895" 
    capture_lex $P1888
    .const 'Sub' $P1877 = "189_1304523757.895" 
    capture_lex $P1877
    .const 'Sub' $P1874 = "188_1304523757.895" 
    capture_lex $P1874
    .const 'Sub' $P1870 = "187_1304523757.895" 
    capture_lex $P1870
    .const 'Sub' $P1867 = "186_1304523757.895" 
    capture_lex $P1867
    .const 'Sub' $P1863 = "185_1304523757.895" 
    capture_lex $P1863
    .const 'Sub' $P1860 = "184_1304523757.895" 
    capture_lex $P1860
    .const 'Sub' $P1856 = "183_1304523757.895" 
    capture_lex $P1856
    .const 'Sub' $P1847 = "180_1304523757.895" 
    capture_lex $P1847
    .const 'Sub' $P1678 = "178_1304523757.895" 
    capture_lex $P1678
    .const 'Sub' $P1675 = "177_1304523757.895" 
    capture_lex $P1675
    .const 'Sub' $P1665 = "176_1304523757.895" 
    capture_lex $P1665
    .const 'Sub' $P1662 = "175_1304523757.895" 
    capture_lex $P1662
    .const 'Sub' $P1652 = "174_1304523757.895" 
    capture_lex $P1652
    .const 'Sub' $P1649 = "173_1304523757.895" 
    capture_lex $P1649
    .const 'Sub' $P1639 = "172_1304523757.895" 
    capture_lex $P1639
    .const 'Sub' $P1636 = "171_1304523757.895" 
    capture_lex $P1636
    .const 'Sub' $P1626 = "170_1304523757.895" 
    capture_lex $P1626
    .const 'Sub' $P1623 = "169_1304523757.895" 
    capture_lex $P1623
    .const 'Sub' $P1613 = "168_1304523757.895" 
    capture_lex $P1613
    .const 'Sub' $P1610 = "167_1304523757.895" 
    capture_lex $P1610
    .const 'Sub' $P1600 = "166_1304523757.895" 
    capture_lex $P1600
    .const 'Sub' $P1592 = "163_1304523757.895" 
    capture_lex $P1592
    .const 'Sub' $P1589 = "162_1304523757.895" 
    capture_lex $P1589
    .const 'Sub' $P1587 = "161_1304523757.895" 
    capture_lex $P1587
    .const 'Sub' $P1584 = "160_1304523757.895" 
    capture_lex $P1584
    .const 'Sub' $P1580 = "159_1304523757.895" 
    capture_lex $P1580
    .const 'Sub' $P1572 = "158_1304523757.895" 
    capture_lex $P1572
    .const 'Sub' $P1567 = "157_1304523757.895" 
    capture_lex $P1567
    .const 'Sub' $P1560 = "156_1304523757.895" 
    capture_lex $P1560
    .const 'Sub' $P1557 = "155_1304523757.895" 
    capture_lex $P1557
    .const 'Sub' $P1553 = "154_1304523757.895" 
    capture_lex $P1553
    .const 'Sub' $P1551 = "153_1304523757.895" 
    capture_lex $P1551
    .const 'Sub' $P1548 = "152_1304523757.895" 
    capture_lex $P1548
    .const 'Sub' $P1545 = "151_1304523757.895" 
    capture_lex $P1545
    .const 'Sub' $P1542 = "150_1304523757.895" 
    capture_lex $P1542
    .const 'Sub' $P1539 = "149_1304523757.895" 
    capture_lex $P1539
    .const 'Sub' $P1536 = "148_1304523757.895" 
    capture_lex $P1536
    .const 'Sub' $P1534 = "147_1304523757.895" 
    capture_lex $P1534
    .const 'Sub' $P1521 = "144_1304523757.895" 
    capture_lex $P1521
    .const 'Sub' $P1518 = "143_1304523757.895" 
    capture_lex $P1518
    .const 'Sub' $P1515 = "142_1304523757.895" 
    capture_lex $P1515
    .const 'Sub' $P1512 = "141_1304523757.895" 
    capture_lex $P1512
    .const 'Sub' $P1509 = "140_1304523757.895" 
    capture_lex $P1509
    .const 'Sub' $P1506 = "139_1304523757.895" 
    capture_lex $P1506
    .const 'Sub' $P1503 = "138_1304523757.895" 
    capture_lex $P1503
    .const 'Sub' $P1500 = "137_1304523757.895" 
    capture_lex $P1500
    .const 'Sub' $P1497 = "136_1304523757.895" 
    capture_lex $P1497
    .const 'Sub' $P1494 = "135_1304523757.895" 
    capture_lex $P1494
    .const 'Sub' $P1491 = "134_1304523757.895" 
    capture_lex $P1491
    .const 'Sub' $P1488 = "133_1304523757.895" 
    capture_lex $P1488
    .const 'Sub' $P1485 = "132_1304523757.895" 
    capture_lex $P1485
    .const 'Sub' $P1482 = "131_1304523757.895" 
    capture_lex $P1482
    .const 'Sub' $P1476 = "130_1304523757.895" 
    capture_lex $P1476
    .const 'Sub' $P1473 = "129_1304523757.895" 
    capture_lex $P1473
    .const 'Sub' $P1467 = "128_1304523757.895" 
    capture_lex $P1467
    .const 'Sub' $P1464 = "127_1304523757.895" 
    capture_lex $P1464
    .const 'Sub' $P1458 = "126_1304523757.895" 
    capture_lex $P1458
    .const 'Sub' $P1449 = "123_1304523757.895" 
    capture_lex $P1449
    .const 'Sub' $P1443 = "122_1304523757.895" 
    capture_lex $P1443
    .const 'Sub' $P1440 = "121_1304523757.895" 
    capture_lex $P1440
    .const 'Sub' $P1434 = "120_1304523757.895" 
    capture_lex $P1434
    .const 'Sub' $P1426 = "117_1304523757.895" 
    capture_lex $P1426
    .const 'Sub' $P1422 = "116_1304523757.895" 
    capture_lex $P1422
    .const 'Sub' $P1419 = "115_1304523757.895" 
    capture_lex $P1419
    .const 'Sub' $P1415 = "114_1304523757.895" 
    capture_lex $P1415
    .const 'Sub' $P1412 = "113_1304523757.895" 
    capture_lex $P1412
    .const 'Sub' $P1408 = "112_1304523757.895" 
    capture_lex $P1408
    .const 'Sub' $P1400 = "109_1304523757.895" 
    capture_lex $P1400
    .const 'Sub' $P1394 = "108_1304523757.895" 
    capture_lex $P1394
    .const 'Sub' $P1392 = "107_1304523757.895" 
    capture_lex $P1392
    .const 'Sub' $P1386 = "106_1304523757.895" 
    capture_lex $P1386
    .const 'Sub' $P1384 = "105_1304523757.895" 
    capture_lex $P1384
    .const 'Sub' $P1378 = "104_1304523757.895" 
    capture_lex $P1378
    .const 'Sub' $P1376 = "103_1304523757.895" 
    capture_lex $P1376
    .const 'Sub' $P1358 = "102_1304523757.895" 
    capture_lex $P1358
    .const 'Sub' $P1356 = "101_1304523757.895" 
    capture_lex $P1356
    .const 'Sub' $P1349 = "100_1304523757.895" 
    capture_lex $P1349
    .const 'Sub' $P1347 = "99_1304523757.895" 
    capture_lex $P1347
    .const 'Sub' $P1331 = "97_1304523757.895" 
    capture_lex $P1331
    .const 'Sub' $P1329 = "96_1304523757.895" 
    capture_lex $P1329
    .const 'Sub' $P1313 = "95_1304523757.895" 
    capture_lex $P1313
    .const 'Sub' $P1311 = "94_1304523757.895" 
    capture_lex $P1311
    .const 'Sub' $P1305 = "93_1304523757.895" 
    capture_lex $P1305
    .const 'Sub' $P1297 = "90_1304523757.895" 
    capture_lex $P1297
    .const 'Sub' $P1294 = "89_1304523757.895" 
    capture_lex $P1294
    .const 'Sub' $P1292 = "88_1304523757.895" 
    capture_lex $P1292
    .const 'Sub' $P1289 = "87_1304523757.895" 
    capture_lex $P1289
    .const 'Sub' $P1281 = "84_1304523757.895" 
    capture_lex $P1281
    .const 'Sub' $P1278 = "83_1304523757.895" 
    capture_lex $P1278
    .const 'Sub' $P1276 = "82_1304523757.895" 
    capture_lex $P1276
    .const 'Sub' $P1273 = "81_1304523757.895" 
    capture_lex $P1273
    .const 'Sub' $P1271 = "80_1304523757.895" 
    capture_lex $P1271
    .const 'Sub' $P1268 = "79_1304523757.895" 
    capture_lex $P1268
    .const 'Sub' $P1266 = "78_1304523757.895" 
    capture_lex $P1266
    .const 'Sub' $P1263 = "77_1304523757.895" 
    capture_lex $P1263
    .const 'Sub' $P1261 = "76_1304523757.895" 
    capture_lex $P1261
    .const 'Sub' $P1258 = "75_1304523757.895" 
    capture_lex $P1258
    .const 'Sub' $P1255 = "74_1304523757.895" 
    capture_lex $P1255
    .const 'Sub' $P1248 = "73_1304523757.895" 
    capture_lex $P1248
    .const 'Sub' $P1245 = "72_1304523757.895" 
    capture_lex $P1245
    .const 'Sub' $P1241 = "71_1304523757.895" 
    capture_lex $P1241
    .const 'Sub' $P1239 = "70_1304523757.895" 
    capture_lex $P1239
    .const 'Sub' $P1235 = "69_1304523757.895" 
    capture_lex $P1235
    .const 'Sub' $P1231 = "68_1304523757.895" 
    capture_lex $P1231
    .const 'Sub' $P1227 = "67_1304523757.895" 
    capture_lex $P1227
    .const 'Sub' $P1224 = "66_1304523757.895" 
    capture_lex $P1224
    .const 'Sub' $P1221 = "65_1304523757.895" 
    capture_lex $P1221
    .const 'Sub' $P1219 = "64_1304523757.895" 
    capture_lex $P1219
    .const 'Sub' $P1215 = "63_1304523757.895" 
    capture_lex $P1215
    .const 'Sub' $P1213 = "62_1304523757.895" 
    capture_lex $P1213
    .const 'Sub' $P1200 = "60_1304523757.895" 
    capture_lex $P1200
    .const 'Sub' $P1196 = "59_1304523757.895" 
    capture_lex $P1196
    .const 'Sub' $P1186 = "58_1304523757.895" 
    capture_lex $P1186
    .const 'Sub' $P1183 = "57_1304523757.895" 
    capture_lex $P1183
    .const 'Sub' $P1163 = "56_1304523757.895" 
    capture_lex $P1163
    .const 'Sub' $P1161 = "55_1304523757.895" 
    capture_lex $P1161
    .const 'Sub' $P1124 = "53_1304523757.895" 
    capture_lex $P1124
    .const 'Sub' $P1122 = "52_1304523757.895" 
    capture_lex $P1122
    .const 'Sub' $P1109 = "50_1304523757.895" 
    capture_lex $P1109
    .const 'Sub' $P1107 = "49_1304523757.895" 
    capture_lex $P1107
    .const 'Sub' $P1098 = "48_1304523757.895" 
    capture_lex $P1098
    .const 'Sub' $P1096 = "47_1304523757.895" 
    capture_lex $P1096
    .const 'Sub' $P1086 = "46_1304523757.895" 
    capture_lex $P1086
    .const 'Sub' $P1083 = "45_1304523757.895" 
    capture_lex $P1083
    .const 'Sub' $P1078 = "44_1304523757.895" 
    capture_lex $P1078
    .const 'Sub' $P1076 = "43_1304523757.895" 
    capture_lex $P1076
    .const 'Sub' $P1071 = "42_1304523757.895" 
    capture_lex $P1071
    .const 'Sub' $P1068 = "41_1304523757.895" 
    capture_lex $P1068
    .const 'Sub' $P1064 = "40_1304523757.895" 
    capture_lex $P1064
    .const 'Sub' $P998 = "39_1304523757.895" 
    capture_lex $P998
    .lex "$?PACKAGE", $P936
    .lex "$?CLASS", $P937
.annotate 'line', 1018
    get_hll_global $P938, "GLOBAL"
    nqp_get_package_through_who $P939, $P938, "NQP"
    get_who $P940, $P939
    set $P941, $P940["Grammar"]
    $P941."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1019
    get_hll_global $P942, "GLOBAL"
    nqp_get_package_through_who $P943, $P942, "NQP"
    get_who $P944, $P943
    set $P945, $P944["Grammar"]
    $P945."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1020
    get_hll_global $P946, "GLOBAL"
    nqp_get_package_through_who $P947, $P946, "NQP"
    get_who $P948, $P947
    set $P949, $P948["Grammar"]
    $P949."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1021
    get_hll_global $P950, "GLOBAL"
    nqp_get_package_through_who $P951, $P950, "NQP"
    get_who $P952, $P951
    set $P953, $P952["Grammar"]
    $P953."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1022
    get_hll_global $P954, "GLOBAL"
    nqp_get_package_through_who $P955, $P954, "NQP"
    get_who $P956, $P955
    set $P957, $P956["Grammar"]
    $P957."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1023
    get_hll_global $P958, "GLOBAL"
    nqp_get_package_through_who $P959, $P958, "NQP"
    get_who $P960, $P959
    set $P961, $P960["Grammar"]
    $P961."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1024
    get_hll_global $P962, "GLOBAL"
    nqp_get_package_through_who $P963, $P962, "NQP"
    get_who $P964, $P963
    set $P965, $P964["Grammar"]
    $P965."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1025
    get_hll_global $P966, "GLOBAL"
    nqp_get_package_through_who $P967, $P966, "NQP"
    get_who $P968, $P967
    set $P969, $P968["Grammar"]
    $P969."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1026
    get_hll_global $P970, "GLOBAL"
    nqp_get_package_through_who $P971, $P970, "NQP"
    get_who $P972, $P971
    set $P973, $P972["Grammar"]
    $P973."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1027
    get_hll_global $P974, "GLOBAL"
    nqp_get_package_through_who $P975, $P974, "NQP"
    get_who $P976, $P975
    set $P977, $P976["Grammar"]
    $P977."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1028
    get_hll_global $P978, "GLOBAL"
    nqp_get_package_through_who $P979, $P978, "NQP"
    get_who $P980, $P979
    set $P981, $P980["Grammar"]
    $P981."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1029
    get_hll_global $P982, "GLOBAL"
    nqp_get_package_through_who $P983, $P982, "NQP"
    get_who $P984, $P983
    set $P985, $P984["Grammar"]
    $P985."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1030
    get_hll_global $P986, "GLOBAL"
    nqp_get_package_through_who $P987, $P986, "NQP"
    get_who $P988, $P987
    set $P989, $P988["Grammar"]
    $P989."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1031
    get_hll_global $P990, "GLOBAL"
    nqp_get_package_through_who $P991, $P990, "NQP"
    get_who $P992, $P991
    set $P993, $P992["Grammar"]
    $P993."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1032
    get_hll_global $P994, "GLOBAL"
    nqp_get_package_through_who $P995, $P994, "NQP"
    get_who $P996, $P995
    set $P997, $P996["Grammar"]
    $P997."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1131
    .const 'Sub' $P2785 = "410_1304523757.895" 
    newclosure $P2796, $P2785
.annotate 'line', 421
    .return ($P2796)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("39_1304523757.895") :outer("38_1304523757.895")
    .param pmc param_999
.annotate 'line', 422
    .lex "self", param_999
.annotate 'line', 424
    $P1000 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P1000
.annotate 'line', 433
    $P1001 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P1001
.annotate 'line', 440
    new $P1002, "Undef"
    .lex "$*SC", $P1002
.annotate 'line', 444
    new $P1003, "Undef"
    .lex "$*SCOPE", $P1003
.annotate 'line', 445
    new $P1004, "Undef"
    .lex "$*MULTINESS", $P1004
.annotate 'line', 446
    new $P1005, "Undef"
    .lex "$*PKGDECL", $P1005
.annotate 'line', 447
    new $P1006, "Undef"
    .lex "$*INVOCANT_OK", $P1006
.annotate 'line', 448
    new $P1007, "Undef"
    .lex "$*RETURN_USED", $P1007
.annotate 'line', 422
    find_lex $P1010, "%*LANG"
    unless_null $P1010, vivify_824
    get_hll_global $P1008, "GLOBAL"
    get_who $P1009, $P1008
    set $P1010, $P1009["%LANG"]
    unless_null $P1010, vivify_825
    die "Contextual %*LANG not found"
  vivify_825:
  vivify_824:
.annotate 'line', 425
    get_hll_global $P1011, "GLOBAL"
    nqp_get_package_through_who $P1012, $P1011, "NQP"
    get_who $P1013, $P1012
    set $P1014, $P1013["Regex"]
    find_lex $P1017, "%*LANG"
    unless_null $P1017, vivify_826
    get_hll_global $P1015, "GLOBAL"
    get_who $P1016, $P1015
    set $P1017, $P1016["%LANG"]
    unless_null $P1017, vivify_827
    die "Contextual %*LANG not found"
  vivify_827:
    store_lex "%*LANG", $P1017
  vivify_826:
    set $P1017["Regex"], $P1014
.annotate 'line', 426
    get_hll_global $P1018, "GLOBAL"
    nqp_get_package_through_who $P1019, $P1018, "NQP"
    get_who $P1020, $P1019
    set $P1021, $P1020["RegexActions"]
    find_lex $P1024, "%*LANG"
    unless_null $P1024, vivify_828
    get_hll_global $P1022, "GLOBAL"
    get_who $P1023, $P1022
    set $P1024, $P1023["%LANG"]
    unless_null $P1024, vivify_829
    die "Contextual %*LANG not found"
  vivify_829:
    store_lex "%*LANG", $P1024
  vivify_828:
    set $P1024["Regex-actions"], $P1021
.annotate 'line', 427
    get_hll_global $P1025, "GLOBAL"
    nqp_get_package_through_who $P1026, $P1025, "NQP"
    get_who $P1027, $P1026
    set $P1028, $P1027["Grammar"]
    find_lex $P1031, "%*LANG"
    unless_null $P1031, vivify_830
    get_hll_global $P1029, "GLOBAL"
    get_who $P1030, $P1029
    set $P1031, $P1030["%LANG"]
    unless_null $P1031, vivify_831
    die "Contextual %*LANG not found"
  vivify_831:
    store_lex "%*LANG", $P1031
  vivify_830:
    set $P1031["MAIN"], $P1028
.annotate 'line', 428
    get_hll_global $P1032, "GLOBAL"
    nqp_get_package_through_who $P1033, $P1032, "NQP"
    get_who $P1034, $P1033
    set $P1035, $P1034["Actions"]
    find_lex $P1038, "%*LANG"
    unless_null $P1038, vivify_832
    get_hll_global $P1036, "GLOBAL"
    get_who $P1037, $P1036
    set $P1038, $P1037["%LANG"]
    unless_null $P1038, vivify_833
    die "Contextual %*LANG not found"
  vivify_833:
    store_lex "%*LANG", $P1038
  vivify_832:
    set $P1038["MAIN-actions"], $P1035
    find_lex $P1041, "%*HOW"
    unless_null $P1041, vivify_834
    get_hll_global $P1039, "GLOBAL"
    get_who $P1040, $P1039
    set $P1041, $P1040["%HOW"]
    unless_null $P1041, vivify_835
    die "Contextual %*HOW not found"
  vivify_835:
  vivify_834:
.annotate 'line', 434
    get_knowhow $P1042
    find_lex $P1045, "%*HOW"
    unless_null $P1045, vivify_836
    get_hll_global $P1043, "GLOBAL"
    get_who $P1044, $P1043
    set $P1045, $P1044["%HOW"]
    unless_null $P1045, vivify_837
    die "Contextual %*HOW not found"
  vivify_837:
    store_lex "%*HOW", $P1045
  vivify_836:
    set $P1045["knowhow"], $P1042
.annotate 'line', 435
    get_knowhow_attribute $P1046
    find_lex $P1049, "%*HOW"
    unless_null $P1049, vivify_838
    get_hll_global $P1047, "GLOBAL"
    get_who $P1048, $P1047
    set $P1049, $P1048["%HOW"]
    unless_null $P1049, vivify_839
    die "Contextual %*HOW not found"
  vivify_839:
    store_lex "%*HOW", $P1049
  vivify_838:
    set $P1049["knowhow-attr"], $P1046
.annotate 'line', 440
    get_hll_global $P1050, "GLOBAL"
    nqp_get_package_through_who $P1051, $P1050, "NQP"
    get_who $P1052, $P1051
    set $P1053, $P1052["SymbolTable"]
.annotate 'line', 442
    time $N1054
    set $S1055, $N1054
    $P1056 = $P1053."new"($S1055 :named("handle"))
.annotate 'line', 440
    store_lex "$*SC", $P1056
.annotate 'line', 444
    new $P1057, "String"
    assign $P1057, ""
    store_lex "$*SCOPE", $P1057
.annotate 'line', 445
    new $P1058, "String"
    assign $P1058, ""
    store_lex "$*MULTINESS", $P1058
.annotate 'line', 446
    new $P1059, "String"
    assign $P1059, ""
    store_lex "$*PKGDECL", $P1059
.annotate 'line', 447
    new $P1060, "Integer"
    assign $P1060, 0
    store_lex "$*INVOCANT_OK", $P1060
.annotate 'line', 448
    new $P1061, "Integer"
    assign $P1061, 0
    store_lex "$*RETURN_USED", $P1061
.annotate 'line', 449
    find_lex $P1062, "self"
    $P1063 = $P1062."comp_unit"()
.annotate 'line', 422
    .return ($P1063)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("40_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1065_tgt
    .local int rx1065_pos
    .local int rx1065_off
    .local int rx1065_eos
    .local int rx1065_rep
    .local pmc rx1065_cur
    .local pmc rx1065_debug
    (rx1065_cur, rx1065_pos, rx1065_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1065_cur
    .local pmc match
    .lex "$/", match
    length rx1065_eos, rx1065_tgt
    gt rx1065_pos, rx1065_eos, rx1065_done
    set rx1065_off, 0
    lt rx1065_pos, 2, rx1065_start
    sub rx1065_off, rx1065_pos, 1
    substr rx1065_tgt, rx1065_tgt, rx1065_off
  rx1065_start:
    eq $I10, 1, rx1065_restart
    if_null rx1065_debug, debug_840
    rx1065_cur."!cursor_debug"("START", "identifier")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1066_done
    goto rxscan1066_scan
  rxscan1066_loop:
    (rx1065_pos) = rx1065_cur."from"()
    inc rx1065_pos
    rx1065_cur."!cursor_from"(rx1065_pos)
    ge rx1065_pos, rx1065_eos, rxscan1066_done
  rxscan1066_scan:
    set_addr $I10, rxscan1066_loop
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxscan1066_done:
.annotate 'line', 454
  # rx subrule "ident" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ident"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
  # rx rxquantr1067 ** 0..*
    set_addr $I10, rxquantr1067_done
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxquantr1067_loop:
  # rx enumcharlist negate=0 
    ge rx1065_pos, rx1065_eos, rx1065_fail
    sub $I10, rx1065_pos, rx1065_off
    substr $S10, rx1065_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1065_fail
    inc rx1065_pos
  # rx subrule "ident" subtype=method negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."ident"()
    unless $P10, rx1065_fail
    rx1065_pos = $P10."pos"()
    set_addr $I10, rxquantr1067_done
    (rx1065_rep) = rx1065_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1067_done
    rx1065_cur."!mark_push"(rx1065_rep, rx1065_pos, $I10)
    goto rxquantr1067_loop
  rxquantr1067_done:
  # rx pass
    rx1065_cur."!cursor_pass"(rx1065_pos, "identifier")
    if_null rx1065_debug, debug_841
    rx1065_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1065_pos)
  debug_841:
    .return (rx1065_cur)
  rx1065_restart:
.annotate 'line', 422
    if_null rx1065_debug, debug_842
    rx1065_cur."!cursor_debug"("NEXT", "identifier")
  debug_842:
  rx1065_fail:
    (rx1065_rep, rx1065_pos, $I10, $P10) = rx1065_cur."!mark_fail"(0)
    lt rx1065_pos, -1, rx1065_done
    eq rx1065_pos, -1, rx1065_fail
    jump $I10
  rx1065_done:
    rx1065_cur."!cursor_fail"()
    if_null rx1065_debug, debug_843
    rx1065_cur."!cursor_debug"("FAIL", "identifier")
  debug_843:
    .return (rx1065_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("41_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1069 = self."!PREFIX__!subrule"("ident", "")
    new $P1070, "ResizablePMCArray"
    push $P1070, $P1069
    .return ($P1070)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("42_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1072_tgt
    .local int rx1072_pos
    .local int rx1072_off
    .local int rx1072_eos
    .local int rx1072_rep
    .local pmc rx1072_cur
    .local pmc rx1072_debug
    (rx1072_cur, rx1072_pos, rx1072_tgt, $I10) = self."!cursor_start"()
    rx1072_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1072_cur
    .local pmc match
    .lex "$/", match
    length rx1072_eos, rx1072_tgt
    gt rx1072_pos, rx1072_eos, rx1072_done
    set rx1072_off, 0
    lt rx1072_pos, 2, rx1072_start
    sub rx1072_off, rx1072_pos, 1
    substr rx1072_tgt, rx1072_tgt, rx1072_off
  rx1072_start:
    eq $I10, 1, rx1072_restart
    if_null rx1072_debug, debug_844
    rx1072_cur."!cursor_debug"("START", "name")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1073_done
    goto rxscan1073_scan
  rxscan1073_loop:
    (rx1072_pos) = rx1072_cur."from"()
    inc rx1072_pos
    rx1072_cur."!cursor_from"(rx1072_pos)
    ge rx1072_pos, rx1072_eos, rxscan1073_done
  rxscan1073_scan:
    set_addr $I10, rxscan1073_loop
    rx1072_cur."!mark_push"(0, rx1072_pos, $I10)
  rxscan1073_done:
.annotate 'line', 456
  # rx rxquantr1074 ** 1..*
    set_addr $I10, rxquantr1074_done
    rx1072_cur."!mark_push"(0, -1, $I10)
  rxquantr1074_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1072_cur."!cursor_pos"(rx1072_pos)
    $P10 = rx1072_cur."identifier"()
    unless $P10, rx1072_fail
    goto rxsubrule1075_pass
  rxsubrule1075_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1072_fail
  rxsubrule1075_pass:
    set_addr $I10, rxsubrule1075_back
    rx1072_cur."!mark_push"(0, rx1072_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1072_pos = $P10."pos"()
    set_addr $I10, rxquantr1074_done
    (rx1072_rep) = rx1072_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1074_done
    rx1072_cur."!mark_push"(rx1072_rep, rx1072_pos, $I10)
  # rx literal  "::"
    add $I11, rx1072_pos, 2
    gt $I11, rx1072_eos, rx1072_fail
    sub $I11, rx1072_pos, rx1072_off
    substr $S10, rx1072_tgt, $I11, 2
    ne $S10, "::", rx1072_fail
    add rx1072_pos, 2
    goto rxquantr1074_loop
  rxquantr1074_done:
  # rx pass
    rx1072_cur."!cursor_pass"(rx1072_pos, "name")
    if_null rx1072_debug, debug_845
    rx1072_cur."!cursor_debug"("PASS", "name", " at pos=", rx1072_pos)
  debug_845:
    .return (rx1072_cur)
  rx1072_restart:
.annotate 'line', 422
    if_null rx1072_debug, debug_846
    rx1072_cur."!cursor_debug"("NEXT", "name")
  debug_846:
  rx1072_fail:
    (rx1072_rep, rx1072_pos, $I10, $P10) = rx1072_cur."!mark_fail"(0)
    lt rx1072_pos, -1, rx1072_done
    eq rx1072_pos, -1, rx1072_fail
    jump $I10
  rx1072_done:
    rx1072_cur."!cursor_fail"()
    if_null rx1072_debug, debug_847
    rx1072_cur."!cursor_debug"("FAIL", "name")
  debug_847:
    .return (rx1072_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("43_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1077, "ResizablePMCArray"
    push $P1077, ""
    .return ($P1077)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("44_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1079_tgt
    .local int rx1079_pos
    .local int rx1079_off
    .local int rx1079_eos
    .local int rx1079_rep
    .local pmc rx1079_cur
    .local pmc rx1079_debug
    (rx1079_cur, rx1079_pos, rx1079_tgt, $I10) = self."!cursor_start"()
    rx1079_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1079_cur
    .local pmc match
    .lex "$/", match
    length rx1079_eos, rx1079_tgt
    gt rx1079_pos, rx1079_eos, rx1079_done
    set rx1079_off, 0
    lt rx1079_pos, 2, rx1079_start
    sub rx1079_off, rx1079_pos, 1
    substr rx1079_tgt, rx1079_tgt, rx1079_off
  rx1079_start:
    eq $I10, 1, rx1079_restart
    if_null rx1079_debug, debug_848
    rx1079_cur."!cursor_debug"("START", "deflongname")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1080_done
    goto rxscan1080_scan
  rxscan1080_loop:
    (rx1079_pos) = rx1079_cur."from"()
    inc rx1079_pos
    rx1079_cur."!cursor_from"(rx1079_pos)
    ge rx1079_pos, rx1079_eos, rxscan1080_done
  rxscan1080_scan:
    set_addr $I10, rxscan1080_loop
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxscan1080_done:
.annotate 'line', 459
  # rx subrule "identifier" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."identifier"()
    unless $P10, rx1079_fail
    rx1079_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1079_pos = $P10."pos"()
  # rx rxquantr1081 ** 0..1
    set_addr $I10, rxquantr1081_done
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10)
  rxquantr1081_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1079_cur."!cursor_pos"(rx1079_pos)
    $P10 = rx1079_cur."colonpair"()
    unless $P10, rx1079_fail
    goto rxsubrule1082_pass
  rxsubrule1082_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1079_fail
  rxsubrule1082_pass:
    set_addr $I10, rxsubrule1082_back
    rx1079_cur."!mark_push"(0, rx1079_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1079_pos = $P10."pos"()
    set_addr $I10, rxquantr1081_done
    (rx1079_rep) = rx1079_cur."!mark_commit"($I10)
  rxquantr1081_done:
.annotate 'line', 458
  # rx pass
    rx1079_cur."!cursor_pass"(rx1079_pos, "deflongname")
    if_null rx1079_debug, debug_849
    rx1079_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1079_pos)
  debug_849:
    .return (rx1079_cur)
  rx1079_restart:
.annotate 'line', 422
    if_null rx1079_debug, debug_850
    rx1079_cur."!cursor_debug"("NEXT", "deflongname")
  debug_850:
  rx1079_fail:
    (rx1079_rep, rx1079_pos, $I10, $P10) = rx1079_cur."!mark_fail"(0)
    lt rx1079_pos, -1, rx1079_done
    eq rx1079_pos, -1, rx1079_fail
    jump $I10
  rx1079_done:
    rx1079_cur."!cursor_fail"()
    if_null rx1079_debug, debug_851
    rx1079_cur."!cursor_debug"("FAIL", "deflongname")
  debug_851:
    .return (rx1079_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("45_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1084 = self."!PREFIX__!subrule"("identifier", "")
    new $P1085, "ResizablePMCArray"
    push $P1085, $P1084
    .return ($P1085)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("46_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1087_tgt
    .local int rx1087_pos
    .local int rx1087_off
    .local int rx1087_eos
    .local int rx1087_rep
    .local pmc rx1087_cur
    .local pmc rx1087_debug
    (rx1087_cur, rx1087_pos, rx1087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1087_cur
    .local pmc match
    .lex "$/", match
    length rx1087_eos, rx1087_tgt
    gt rx1087_pos, rx1087_eos, rx1087_done
    set rx1087_off, 0
    lt rx1087_pos, 2, rx1087_start
    sub rx1087_off, rx1087_pos, 1
    substr rx1087_tgt, rx1087_tgt, rx1087_off
  rx1087_start:
    eq $I10, 1, rx1087_restart
    if_null rx1087_debug, debug_852
    rx1087_cur."!cursor_debug"("START", "ENDSTMT")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1088_done
    goto rxscan1088_scan
  rxscan1088_loop:
    (rx1087_pos) = rx1087_cur."from"()
    inc rx1087_pos
    rx1087_cur."!cursor_from"(rx1087_pos)
    ge rx1087_pos, rx1087_eos, rxscan1088_done
  rxscan1088_scan:
    set_addr $I10, rxscan1088_loop
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxscan1088_done:
.annotate 'line', 466
  # rx rxquantr1089 ** 0..1
    set_addr $I10, rxquantr1089_done
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxquantr1089_loop:
  alt1090_0:
.annotate 'line', 463
    set_addr $I10, alt1090_1
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
.annotate 'line', 464
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1087_pos, rx1087_off
    set rx1087_rep, 0
    sub $I12, rx1087_eos, rx1087_pos
  rxenumcharlistq1091_loop:
    le $I12, 0, rxenumcharlistq1091_done
    substr $S10, rx1087_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1091_done
    inc rx1087_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1091_loop
  rxenumcharlistq1091_done:
    add rx1087_pos, rx1087_pos, rx1087_rep
  # rxanchor eol
    sub $I10, rx1087_pos, rx1087_off
    is_cclass $I11, 4096, rx1087_tgt, $I10
    if $I11, rxanchor1092_done
    ne rx1087_pos, rx1087_eos, rx1087_fail
    eq rx1087_pos, 0, rxanchor1092_done
    dec $I10
    is_cclass $I11, 4096, rx1087_tgt, $I10
    if $I11, rx1087_fail
  rxanchor1092_done:
  # rx subrule "ws" subtype=method negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."ws"()
    unless $P10, rx1087_fail
    rx1087_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."MARKER"("endstmt")
    unless $P10, rx1087_fail
    goto alt1090_end
  alt1090_1:
.annotate 'line', 465
  # rx rxquantr1093 ** 0..1
    set_addr $I10, rxquantr1093_done
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxquantr1093_loop:
  # rx subrule "unv" subtype=method negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."unv"()
    unless $P10, rx1087_fail
    goto rxsubrule1094_pass
  rxsubrule1094_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1087_fail
  rxsubrule1094_pass:
    set_addr $I10, rxsubrule1094_back
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10, $P10)
    rx1087_pos = $P10."pos"()
    set_addr $I10, rxquantr1093_done
    (rx1087_rep) = rx1087_cur."!mark_commit"($I10)
  rxquantr1093_done:
  # rxanchor eol
    sub $I10, rx1087_pos, rx1087_off
    is_cclass $I11, 4096, rx1087_tgt, $I10
    if $I11, rxanchor1095_done
    ne rx1087_pos, rx1087_eos, rx1087_fail
    eq rx1087_pos, 0, rxanchor1095_done
    dec $I10
    is_cclass $I11, 4096, rx1087_tgt, $I10
    if $I11, rx1087_fail
  rxanchor1095_done:
  # rx subrule "ws" subtype=method negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."ws"()
    unless $P10, rx1087_fail
    rx1087_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."MARKER"("endstmt")
    unless $P10, rx1087_fail
  alt1090_end:
.annotate 'line', 466
    set_addr $I10, rxquantr1089_done
    (rx1087_rep) = rx1087_cur."!mark_commit"($I10)
  rxquantr1089_done:
.annotate 'line', 462
  # rx pass
    rx1087_cur."!cursor_pass"(rx1087_pos, "ENDSTMT")
    if_null rx1087_debug, debug_853
    rx1087_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1087_pos)
  debug_853:
    .return (rx1087_cur)
  rx1087_restart:
.annotate 'line', 422
    if_null rx1087_debug, debug_854
    rx1087_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_854:
  rx1087_fail:
    (rx1087_rep, rx1087_pos, $I10, $P10) = rx1087_cur."!mark_fail"(0)
    lt rx1087_pos, -1, rx1087_done
    eq rx1087_pos, -1, rx1087_fail
    jump $I10
  rx1087_done:
    rx1087_cur."!cursor_fail"()
    if_null rx1087_debug, debug_855
    rx1087_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_855:
    .return (rx1087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("47_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1097, "ResizablePMCArray"
    push $P1097, ""
    .return ($P1097)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("48_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1099_tgt
    .local int rx1099_pos
    .local int rx1099_off
    .local int rx1099_eos
    .local int rx1099_rep
    .local pmc rx1099_cur
    .local pmc rx1099_debug
    (rx1099_cur, rx1099_pos, rx1099_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1099_cur
    .local pmc match
    .lex "$/", match
    length rx1099_eos, rx1099_tgt
    gt rx1099_pos, rx1099_eos, rx1099_done
    set rx1099_off, 0
    lt rx1099_pos, 2, rx1099_start
    sub rx1099_off, rx1099_pos, 1
    substr rx1099_tgt, rx1099_tgt, rx1099_off
  rx1099_start:
    eq $I10, 1, rx1099_restart
    if_null rx1099_debug, debug_856
    rx1099_cur."!cursor_debug"("START", "ws")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1100_done
    goto rxscan1100_scan
  rxscan1100_loop:
    (rx1099_pos) = rx1099_cur."from"()
    inc rx1099_pos
    rx1099_cur."!cursor_from"(rx1099_pos)
    ge rx1099_pos, rx1099_eos, rxscan1100_done
  rxscan1100_scan:
    set_addr $I10, rxscan1100_loop
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
  rxscan1100_done:
  alt1101_0:
.annotate 'line', 469
    set_addr $I10, alt1101_1
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
.annotate 'line', 470
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."MARKED"("ws")
    unless $P10, rx1099_fail
    goto alt1101_end
  alt1101_1:
.annotate 'line', 471
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."ww"()
    if $P10, rx1099_fail
.annotate 'line', 476
  # rx rxquantr1102 ** 0..*
    set_addr $I10, rxquantr1102_done
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
  rxquantr1102_loop:
  alt1103_0:
.annotate 'line', 472
    set_addr $I10, alt1103_1
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1099_pos, rx1099_off
    set rx1099_rep, 0
    sub $I12, rx1099_eos, rx1099_pos
  rxenumcharlistq1104_loop:
    le $I12, 0, rxenumcharlistq1104_done
    substr $S10, rx1099_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1104_done
    inc rx1099_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1104_loop
  rxenumcharlistq1104_done:
    lt rx1099_rep, 1, rx1099_fail
    add rx1099_pos, rx1099_pos, rx1099_rep
    goto alt1103_end
  alt1103_1:
    set_addr $I10, alt1103_2
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
.annotate 'line', 473
  # rx literal  "#"
    add $I11, rx1099_pos, 1
    gt $I11, rx1099_eos, rx1099_fail
    sub $I11, rx1099_pos, rx1099_off
    ord $I11, rx1099_tgt, $I11
    ne $I11, 35, rx1099_fail
    add rx1099_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1099_pos, rx1099_off
    find_cclass $I11, 4096, rx1099_tgt, $I10, rx1099_eos
    add rx1099_pos, rx1099_off, $I11
    goto alt1103_end
  alt1103_2:
    set_addr $I10, alt1103_3
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
.annotate 'line', 474
  # rxanchor bol
    eq rx1099_pos, 0, rxanchor1105_done
    ge rx1099_pos, rx1099_eos, rx1099_fail
    sub $I10, rx1099_pos, rx1099_off
    dec $I10
    is_cclass $I11, 4096, rx1099_tgt, $I10
    unless $I11, rx1099_fail
  rxanchor1105_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."pod_comment"()
    unless $P10, rx1099_fail
    rx1099_pos = $P10."pos"()
    goto alt1103_end
  alt1103_3:
.annotate 'line', 475
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1099_pos, rx1099_off
    set rx1099_rep, 0
    sub $I12, rx1099_eos, rx1099_pos
  rxenumcharlistq1106_loop:
    le $I12, 0, rxenumcharlistq1106_done
    substr $S10, rx1099_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1106_done
    inc rx1099_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1106_loop
  rxenumcharlistq1106_done:
    lt rx1099_rep, 1, rx1099_fail
    add rx1099_pos, rx1099_pos, rx1099_rep
  alt1103_end:
.annotate 'line', 476
    set_addr $I10, rxquantr1102_done
    (rx1099_rep) = rx1099_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1102_done
    rx1099_cur."!mark_push"(rx1099_rep, rx1099_pos, $I10)
    goto rxquantr1102_loop
  rxquantr1102_done:
.annotate 'line', 477
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."MARKER"("ws")
    unless $P10, rx1099_fail
  alt1101_end:
.annotate 'line', 469
  # rx pass
    rx1099_cur."!cursor_pass"(rx1099_pos, "ws")
    if_null rx1099_debug, debug_857
    rx1099_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1099_pos)
  debug_857:
    .return (rx1099_cur)
  rx1099_restart:
.annotate 'line', 422
    if_null rx1099_debug, debug_858
    rx1099_cur."!cursor_debug"("NEXT", "ws")
  debug_858:
  rx1099_fail:
    (rx1099_rep, rx1099_pos, $I10, $P10) = rx1099_cur."!mark_fail"(0)
    lt rx1099_pos, -1, rx1099_done
    eq rx1099_pos, -1, rx1099_fail
    jump $I10
  rx1099_done:
    rx1099_cur."!cursor_fail"()
    if_null rx1099_debug, debug_859
    rx1099_cur."!cursor_debug"("FAIL", "ws")
  debug_859:
    .return (rx1099_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("49_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1108, "ResizablePMCArray"
    push $P1108, ""
    push $P1108, ""
    .return ($P1108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("50_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1115 = "51_1304523757.895" 
    capture_lex $P1115
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_860
    rx1110_cur."!cursor_debug"("START", "unv")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1111_done
    goto rxscan1111_scan
  rxscan1111_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1111_done
  rxscan1111_scan:
    set_addr $I10, rxscan1111_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1111_done:
  alt1112_0:
.annotate 'line', 482
    set_addr $I10, alt1112_1
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
.annotate 'line', 483
  # rxanchor bol
    eq rx1110_pos, 0, rxanchor1113_done
    ge rx1110_pos, rx1110_eos, rx1110_fail
    sub $I10, rx1110_pos, rx1110_off
    dec $I10
    is_cclass $I11, 4096, rx1110_tgt, $I10
    unless $I11, rx1110_fail
  rxanchor1113_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    .const 'Sub' $P1115 = "51_1304523757.895" 
    capture_lex $P1115
    $P10 = rx1110_cur."before"($P1115)
    unless $P10, rx1110_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."pod_comment"()
    unless $P10, rx1110_fail
    rx1110_pos = $P10."pos"()
    goto alt1112_end
  alt1112_1:
    set_addr $I10, alt1112_2
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
.annotate 'line', 484
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1110_pos, rx1110_off
    set rx1110_rep, 0
    sub $I12, rx1110_eos, rx1110_pos
  rxenumcharlistq1120_loop:
    le $I12, 0, rxenumcharlistq1120_done
    substr $S10, rx1110_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1120_done
    inc rx1110_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1120_loop
  rxenumcharlistq1120_done:
    add rx1110_pos, rx1110_pos, rx1110_rep
  # rx literal  "#"
    add $I11, rx1110_pos, 1
    gt $I11, rx1110_eos, rx1110_fail
    sub $I11, rx1110_pos, rx1110_off
    ord $I11, rx1110_tgt, $I11
    ne $I11, 35, rx1110_fail
    add rx1110_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1110_pos, rx1110_off
    find_cclass $I11, 4096, rx1110_tgt, $I10, rx1110_eos
    add rx1110_pos, rx1110_off, $I11
    goto alt1112_end
  alt1112_2:
.annotate 'line', 485
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1110_pos, rx1110_off
    set rx1110_rep, 0
    sub $I12, rx1110_eos, rx1110_pos
  rxenumcharlistq1121_loop:
    le $I12, 0, rxenumcharlistq1121_done
    substr $S10, rx1110_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1121_done
    inc rx1110_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1121_loop
  rxenumcharlistq1121_done:
    lt rx1110_rep, 1, rx1110_fail
    add rx1110_pos, rx1110_pos, rx1110_rep
  alt1112_end:
.annotate 'line', 480
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "unv")
    if_null rx1110_debug, debug_865
    rx1110_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1110_pos)
  debug_865:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 422
    if_null rx1110_debug, debug_866
    rx1110_cur."!cursor_debug"("NEXT", "unv")
  debug_866:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_867
    rx1110_cur."!cursor_debug"("FAIL", "unv")
  debug_867:
    .return (rx1110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1114"  :anon :subid("51_1304523757.895") :method :outer("50_1304523757.895")
.annotate 'line', 483
    .local string rx1116_tgt
    .local int rx1116_pos
    .local int rx1116_off
    .local int rx1116_eos
    .local int rx1116_rep
    .local pmc rx1116_cur
    .local pmc rx1116_debug
    (rx1116_cur, rx1116_pos, rx1116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1116_cur
    .local pmc match
    .lex "$/", match
    length rx1116_eos, rx1116_tgt
    gt rx1116_pos, rx1116_eos, rx1116_done
    set rx1116_off, 0
    lt rx1116_pos, 2, rx1116_start
    sub rx1116_off, rx1116_pos, 1
    substr rx1116_tgt, rx1116_tgt, rx1116_off
  rx1116_start:
    eq $I10, 1, rx1116_restart
    if_null rx1116_debug, debug_861
    rx1116_cur."!cursor_debug"("START", "")
  debug_861:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1117_done
    goto rxscan1117_scan
  rxscan1117_loop:
    (rx1116_pos) = rx1116_cur."from"()
    inc rx1116_pos
    rx1116_cur."!cursor_from"(rx1116_pos)
    ge rx1116_pos, rx1116_eos, rxscan1117_done
  rxscan1117_scan:
    set_addr $I10, rxscan1117_loop
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxscan1117_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1116_pos, rx1116_off
    set rx1116_rep, 0
    sub $I12, rx1116_eos, rx1116_pos
  rxenumcharlistq1118_loop:
    le $I12, 0, rxenumcharlistq1118_done
    substr $S10, rx1116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1118_done
    inc rx1116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1118_loop
  rxenumcharlistq1118_done:
    add rx1116_pos, rx1116_pos, rx1116_rep
  # rx literal  "="
    add $I11, rx1116_pos, 1
    gt $I11, rx1116_eos, rx1116_fail
    sub $I11, rx1116_pos, rx1116_off
    ord $I11, rx1116_tgt, $I11
    ne $I11, 61, rx1116_fail
    add rx1116_pos, 1
  alt1119_0:
    set_addr $I10, alt1119_1
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  # rx charclass w
    ge rx1116_pos, rx1116_eos, rx1116_fail
    sub $I10, rx1116_pos, rx1116_off
    is_cclass $I11, 8192, rx1116_tgt, $I10
    unless $I11, rx1116_fail
    inc rx1116_pos
    goto alt1119_end
  alt1119_1:
  # rx literal  "\\"
    add $I11, rx1116_pos, 1
    gt $I11, rx1116_eos, rx1116_fail
    sub $I11, rx1116_pos, rx1116_off
    ord $I11, rx1116_tgt, $I11
    ne $I11, 92, rx1116_fail
    add rx1116_pos, 1
  alt1119_end:
  # rx pass
    rx1116_cur."!cursor_pass"(rx1116_pos, "")
    if_null rx1116_debug, debug_862
    rx1116_cur."!cursor_debug"("PASS", "", " at pos=", rx1116_pos)
  debug_862:
    .return (rx1116_cur)
  rx1116_restart:
    if_null rx1116_debug, debug_863
    rx1116_cur."!cursor_debug"("NEXT", "")
  debug_863:
  rx1116_fail:
    (rx1116_rep, rx1116_pos, $I10, $P10) = rx1116_cur."!mark_fail"(0)
    lt rx1116_pos, -1, rx1116_done
    eq rx1116_pos, -1, rx1116_fail
    jump $I10
  rx1116_done:
    rx1116_cur."!cursor_fail"()
    if_null rx1116_debug, debug_864
    rx1116_cur."!cursor_debug"("FAIL", "")
  debug_864:
    .return (rx1116_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("52_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1123, "ResizablePMCArray"
    push $P1123, ""
    push $P1123, ""
    push $P1123, ""
    .return ($P1123)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("53_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1154 = "54_1304523757.895" 
    capture_lex $P1154
    .local string rx1125_tgt
    .local int rx1125_pos
    .local int rx1125_off
    .local int rx1125_eos
    .local int rx1125_rep
    .local pmc rx1125_cur
    .local pmc rx1125_debug
    (rx1125_cur, rx1125_pos, rx1125_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1125_cur
    .local pmc match
    .lex "$/", match
    length rx1125_eos, rx1125_tgt
    gt rx1125_pos, rx1125_eos, rx1125_done
    set rx1125_off, 0
    lt rx1125_pos, 2, rx1125_start
    sub rx1125_off, rx1125_pos, 1
    substr rx1125_tgt, rx1125_tgt, rx1125_off
  rx1125_start:
    eq $I10, 1, rx1125_restart
    if_null rx1125_debug, debug_868
    rx1125_cur."!cursor_debug"("START", "pod_comment")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1126_done
    goto rxscan1126_scan
  rxscan1126_loop:
    (rx1125_pos) = rx1125_cur."from"()
    inc rx1125_pos
    rx1125_cur."!cursor_from"(rx1125_pos)
    ge rx1125_pos, rx1125_eos, rxscan1126_done
  rxscan1126_scan:
    set_addr $I10, rxscan1126_loop
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
  rxscan1126_done:
.annotate 'line', 490
  # rxanchor bol
    eq rx1125_pos, 0, rxanchor1127_done
    ge rx1125_pos, rx1125_eos, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    dec $I10
    is_cclass $I11, 4096, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  rxanchor1127_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1128_loop:
    le $I12, 0, rxenumcharlistq1128_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1128_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1128_loop
  rxenumcharlistq1128_done:
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx literal  "="
    add $I11, rx1125_pos, 1
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    ord $I11, rx1125_tgt, $I11
    ne $I11, 61, rx1125_fail
    add rx1125_pos, 1
  alt1129_0:
.annotate 'line', 491
    set_addr $I10, alt1129_1
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
.annotate 'line', 492
  # rx literal  "begin"
    add $I11, rx1125_pos, 5
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 5
    ne $S10, "begin", rx1125_fail
    add rx1125_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1130_loop:
    le $I12, 0, rxenumcharlistq1130_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1130_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1130_loop
  rxenumcharlistq1130_done:
    lt rx1125_rep, 1, rx1125_fail
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx literal  "END"
    add $I11, rx1125_pos, 3
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 3
    ne $S10, "END", rx1125_fail
    add rx1125_pos, 3
  # rxanchor rwb
    le rx1125_pos, 0, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 8192, rx1125_tgt, $I10
    if $I11, rx1125_fail
    dec $I10
    is_cclass $I11, 8192, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  alt1131_0:
.annotate 'line', 493
    set_addr $I10, alt1131_1
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
  # rx rxquantf1132 ** 0..*
    set_addr $I10, rxquantf1132_loop
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
    goto rxquantf1132_done
  rxquantf1132_loop:
  # rx charclass .
    ge rx1125_pos, rx1125_eos, rx1125_fail
    inc rx1125_pos
    set_addr $I10, rxquantf1132_loop
    rx1125_cur."!mark_push"(rx1125_rep, rx1125_pos, $I10)
  rxquantf1132_done:
  # rx charclass nl
    ge rx1125_pos, rx1125_eos, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 4096, rx1125_tgt, $I10
    unless $I11, rx1125_fail
    substr $S10, rx1125_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1125_pos, $I11
    inc rx1125_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1134_loop:
    le $I12, 0, rxenumcharlistq1134_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1134_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1134_loop
  rxenumcharlistq1134_done:
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx literal  "=end"
    add $I11, rx1125_pos, 4
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 4
    ne $S10, "=end", rx1125_fail
    add rx1125_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1135_loop:
    le $I12, 0, rxenumcharlistq1135_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1135_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1135_loop
  rxenumcharlistq1135_done:
    lt rx1125_rep, 1, rx1125_fail
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx literal  "END"
    add $I11, rx1125_pos, 3
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 3
    ne $S10, "END", rx1125_fail
    add rx1125_pos, 3
  # rxanchor rwb
    le rx1125_pos, 0, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 8192, rx1125_tgt, $I10
    if $I11, rx1125_fail
    dec $I10
    is_cclass $I11, 8192, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    find_cclass $I11, 4096, rx1125_tgt, $I10, rx1125_eos
    add rx1125_pos, rx1125_off, $I11
    goto alt1131_end
  alt1131_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    find_not_cclass $I11, 65535, rx1125_tgt, $I10, rx1125_eos
    add rx1125_pos, rx1125_off, $I11
  alt1131_end:
.annotate 'line', 492
    goto alt1129_end
  alt1129_1:
    set_addr $I10, alt1129_2
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
.annotate 'line', 494
  # rx literal  "begin"
    add $I11, rx1125_pos, 5
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 5
    ne $S10, "begin", rx1125_fail
    add rx1125_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1136_loop:
    le $I12, 0, rxenumcharlistq1136_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1136_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1136_loop
  rxenumcharlistq1136_done:
    lt rx1125_rep, 1, rx1125_fail
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."identifier"()
    unless $P10, rx1125_fail
    rx1125_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1125_pos = $P10."pos"()
  alt1137_0:
.annotate 'line', 495
    set_addr $I10, alt1137_1
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
.annotate 'line', 496
  # rx rxquantf1138 ** 0..*
    set_addr $I10, rxquantf1138_loop
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
    goto rxquantf1138_done
  rxquantf1138_loop:
  # rx charclass .
    ge rx1125_pos, rx1125_eos, rx1125_fail
    inc rx1125_pos
    set_addr $I10, rxquantf1138_loop
    rx1125_cur."!mark_push"(rx1125_rep, rx1125_pos, $I10)
  rxquantf1138_done:
  # rx charclass nl
    ge rx1125_pos, rx1125_eos, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 4096, rx1125_tgt, $I10
    unless $I11, rx1125_fail
    substr $S10, rx1125_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1125_pos, $I11
    inc rx1125_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1140_loop:
    le $I12, 0, rxenumcharlistq1140_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1140_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1140_loop
  rxenumcharlistq1140_done:
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx literal  "=end"
    add $I11, rx1125_pos, 4
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 4
    ne $S10, "=end", rx1125_fail
    add rx1125_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1141_loop:
    le $I12, 0, rxenumcharlistq1141_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1141_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1141_loop
  rxenumcharlistq1141_done:
    lt rx1125_rep, 1, rx1125_fail
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."!BACKREF"("identifier")
    unless $P10, rx1125_fail
    rx1125_pos = $P10."pos"()
  # rxanchor rwb
    le rx1125_pos, 0, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 8192, rx1125_tgt, $I10
    if $I11, rx1125_fail
    dec $I10
    is_cclass $I11, 8192, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    find_cclass $I11, 4096, rx1125_tgt, $I10, rx1125_eos
    add rx1125_pos, rx1125_off, $I11
    goto alt1137_end
  alt1137_1:
.annotate 'line', 497
  # rx subrule "panic" subtype=method negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."panic"("=begin without matching =end")
    unless $P10, rx1125_fail
    rx1125_pos = $P10."pos"()
  alt1137_end:
.annotate 'line', 494
    goto alt1129_end
  alt1129_2:
    set_addr $I10, alt1129_3
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
.annotate 'line', 499
  # rx literal  "begin"
    add $I11, rx1125_pos, 5
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 5
    ne $S10, "begin", rx1125_fail
    add rx1125_pos, 5
  # rxanchor rwb
    le rx1125_pos, 0, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 8192, rx1125_tgt, $I10
    if $I11, rx1125_fail
    dec $I10
    is_cclass $I11, 8192, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1143_loop:
    le $I12, 0, rxenumcharlistq1143_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1143_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1143_loop
  rxenumcharlistq1143_done:
    add rx1125_pos, rx1125_pos, rx1125_rep
  alt1144_0:
.annotate 'line', 500
    set_addr $I10, alt1144_1
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
  # rxanchor eol
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 4096, rx1125_tgt, $I10
    if $I11, rxanchor1145_done
    ne rx1125_pos, rx1125_eos, rx1125_fail
    eq rx1125_pos, 0, rxanchor1145_done
    dec $I10
    is_cclass $I11, 4096, rx1125_tgt, $I10
    if $I11, rx1125_fail
  rxanchor1145_done:
    goto alt1144_end
  alt1144_1:
    set_addr $I10, alt1144_2
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
  # rx literal  "#"
    add $I11, rx1125_pos, 1
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    ord $I11, rx1125_tgt, $I11
    ne $I11, 35, rx1125_fail
    add rx1125_pos, 1
    goto alt1144_end
  alt1144_2:
  # rx subrule "panic" subtype=method negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1125_fail
    rx1125_pos = $P10."pos"()
  alt1144_end:
  alt1146_0:
.annotate 'line', 501
    set_addr $I10, alt1146_1
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
.annotate 'line', 502
  # rx rxquantf1147 ** 0..*
    set_addr $I10, rxquantf1147_loop
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
    goto rxquantf1147_done
  rxquantf1147_loop:
  # rx charclass .
    ge rx1125_pos, rx1125_eos, rx1125_fail
    inc rx1125_pos
    set_addr $I10, rxquantf1147_loop
    rx1125_cur."!mark_push"(rx1125_rep, rx1125_pos, $I10)
  rxquantf1147_done:
  # rx charclass nl
    ge rx1125_pos, rx1125_eos, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 4096, rx1125_tgt, $I10
    unless $I11, rx1125_fail
    substr $S10, rx1125_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1125_pos, $I11
    inc rx1125_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    set rx1125_rep, 0
    sub $I12, rx1125_eos, rx1125_pos
  rxenumcharlistq1149_loop:
    le $I12, 0, rxenumcharlistq1149_done
    substr $S10, rx1125_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1149_done
    inc rx1125_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1149_loop
  rxenumcharlistq1149_done:
    add rx1125_pos, rx1125_pos, rx1125_rep
  # rx literal  "=end"
    add $I11, rx1125_pos, 4
    gt $I11, rx1125_eos, rx1125_fail
    sub $I11, rx1125_pos, rx1125_off
    substr $S10, rx1125_tgt, $I11, 4
    ne $S10, "=end", rx1125_fail
    add rx1125_pos, 4
  # rxanchor rwb
    le rx1125_pos, 0, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 8192, rx1125_tgt, $I10
    if $I11, rx1125_fail
    dec $I10
    is_cclass $I11, 8192, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    find_cclass $I11, 4096, rx1125_tgt, $I10, rx1125_eos
    add rx1125_pos, rx1125_off, $I11
    goto alt1146_end
  alt1146_1:
.annotate 'line', 503
  # rx subrule "panic" subtype=method negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."panic"("=begin without matching =end")
    unless $P10, rx1125_fail
    rx1125_pos = $P10."pos"()
  alt1146_end:
.annotate 'line', 499
    goto alt1129_end
  alt1129_3:
    set_addr $I10, alt1129_4
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
.annotate 'line', 505
  # rx subrule "identifier" subtype=capture negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."identifier"()
    unless $P10, rx1125_fail
    rx1125_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1125_pos = $P10."pos"()
.annotate 'line', 506
  # rx rxquantf1150 ** 0..*
    set_addr $I10, rxquantf1150_loop
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
    goto rxquantf1150_done
  rxquantf1150_loop:
  # rx charclass .
    ge rx1125_pos, rx1125_eos, rx1125_fail
    inc rx1125_pos
    set_addr $I10, rxquantf1150_loop
    rx1125_cur."!mark_push"(rx1125_rep, rx1125_pos, $I10)
  rxquantf1150_done:
  # rxanchor bol
    eq rx1125_pos, 0, rxanchor1152_done
    ge rx1125_pos, rx1125_eos, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    dec $I10
    is_cclass $I11, 4096, rx1125_tgt, $I10
    unless $I11, rx1125_fail
  rxanchor1152_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    .const 'Sub' $P1154 = "54_1304523757.895" 
    capture_lex $P1154
    $P10 = rx1125_cur."before"($P1154)
    unless $P10, rx1125_fail
.annotate 'line', 505
    goto alt1129_end
  alt1129_4:
  alt1160_0:
.annotate 'line', 512
    set_addr $I10, alt1160_1
    rx1125_cur."!mark_push"(0, rx1125_pos, $I10)
  # rx charclass s
    ge rx1125_pos, rx1125_eos, rx1125_fail
    sub $I10, rx1125_pos, rx1125_off
    is_cclass $I11, 32, rx1125_tgt, $I10
    unless $I11, rx1125_fail
    inc rx1125_pos
    goto alt1160_end
  alt1160_1:
  # rx subrule "panic" subtype=method negate=
    rx1125_cur."!cursor_pos"(rx1125_pos)
    $P10 = rx1125_cur."panic"("Illegal pod directive")
    unless $P10, rx1125_fail
    rx1125_pos = $P10."pos"()
  alt1160_end:
.annotate 'line', 513
  # rx charclass_q N r 0..-1
    sub $I10, rx1125_pos, rx1125_off
    find_cclass $I11, 4096, rx1125_tgt, $I10, rx1125_eos
    add rx1125_pos, rx1125_off, $I11
  alt1129_end:
.annotate 'line', 489
  # rx pass
    rx1125_cur."!cursor_pass"(rx1125_pos, "pod_comment")
    if_null rx1125_debug, debug_873
    rx1125_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1125_pos)
  debug_873:
    .return (rx1125_cur)
  rx1125_restart:
.annotate 'line', 422
    if_null rx1125_debug, debug_874
    rx1125_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_874:
  rx1125_fail:
    (rx1125_rep, rx1125_pos, $I10, $P10) = rx1125_cur."!mark_fail"(0)
    lt rx1125_pos, -1, rx1125_done
    eq rx1125_pos, -1, rx1125_fail
    jump $I10
  rx1125_done:
    rx1125_cur."!cursor_fail"()
    if_null rx1125_debug, debug_875
    rx1125_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_875:
    .return (rx1125_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1153"  :anon :subid("54_1304523757.895") :method :outer("53_1304523757.895")
.annotate 'line', 506
    .local string rx1155_tgt
    .local int rx1155_pos
    .local int rx1155_off
    .local int rx1155_eos
    .local int rx1155_rep
    .local pmc rx1155_cur
    .local pmc rx1155_debug
    (rx1155_cur, rx1155_pos, rx1155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1155_cur
    .local pmc match
    .lex "$/", match
    length rx1155_eos, rx1155_tgt
    gt rx1155_pos, rx1155_eos, rx1155_done
    set rx1155_off, 0
    lt rx1155_pos, 2, rx1155_start
    sub rx1155_off, rx1155_pos, 1
    substr rx1155_tgt, rx1155_tgt, rx1155_off
  rx1155_start:
    eq $I10, 1, rx1155_restart
    if_null rx1155_debug, debug_869
    rx1155_cur."!cursor_debug"("START", "")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1156_done
    goto rxscan1156_scan
  rxscan1156_loop:
    (rx1155_pos) = rx1155_cur."from"()
    inc rx1155_pos
    rx1155_cur."!cursor_from"(rx1155_pos)
    ge rx1155_pos, rx1155_eos, rxscan1156_done
  rxscan1156_scan:
    set_addr $I10, rxscan1156_loop
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
  rxscan1156_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1155_pos, rx1155_off
    set rx1155_rep, 0
    sub $I12, rx1155_eos, rx1155_pos
  rxenumcharlistq1157_loop:
    le $I12, 0, rxenumcharlistq1157_done
    substr $S10, rx1155_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1157_done
    inc rx1155_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1157_loop
  rxenumcharlistq1157_done:
    add rx1155_pos, rx1155_pos, rx1155_rep
  alt1158_0:
    set_addr $I10, alt1158_1
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
.annotate 'line', 507
  # rx literal  "="
    add $I11, rx1155_pos, 1
    gt $I11, rx1155_eos, rx1155_fail
    sub $I11, rx1155_pos, rx1155_off
    ord $I11, rx1155_tgt, $I11
    ne $I11, 61, rx1155_fail
    add rx1155_pos, 1
.annotate 'line', 509
  # rx rxquantr1159 ** 0..1
    set_addr $I10, rxquantr1159_done
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
  rxquantr1159_loop:
.annotate 'line', 508
  # rx literal  "cut"
    add $I11, rx1155_pos, 3
    gt $I11, rx1155_eos, rx1155_fail
    sub $I11, rx1155_pos, rx1155_off
    substr $S10, rx1155_tgt, $I11, 3
    ne $S10, "cut", rx1155_fail
    add rx1155_pos, 3
  # rxanchor rwb
    le rx1155_pos, 0, rx1155_fail
    sub $I10, rx1155_pos, rx1155_off
    is_cclass $I11, 8192, rx1155_tgt, $I10
    if $I11, rx1155_fail
    dec $I10
    is_cclass $I11, 8192, rx1155_tgt, $I10
    unless $I11, rx1155_fail
.annotate 'line', 509
  # rx subrule "panic" subtype=method negate=
    rx1155_cur."!cursor_pos"(rx1155_pos)
    $P10 = rx1155_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1155_fail
    rx1155_pos = $P10."pos"()
    set_addr $I10, rxquantr1159_done
    (rx1155_rep) = rx1155_cur."!mark_commit"($I10)
  rxquantr1159_done:
.annotate 'line', 506
    goto alt1158_end
  alt1158_1:
.annotate 'line', 510
  # rx charclass nl
    ge rx1155_pos, rx1155_eos, rx1155_fail
    sub $I10, rx1155_pos, rx1155_off
    is_cclass $I11, 4096, rx1155_tgt, $I10
    unless $I11, rx1155_fail
    substr $S10, rx1155_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1155_pos, $I11
    inc rx1155_pos
  alt1158_end:
.annotate 'line', 506
  # rx pass
    rx1155_cur."!cursor_pass"(rx1155_pos, "")
    if_null rx1155_debug, debug_870
    rx1155_cur."!cursor_debug"("PASS", "", " at pos=", rx1155_pos)
  debug_870:
    .return (rx1155_cur)
  rx1155_restart:
    if_null rx1155_debug, debug_871
    rx1155_cur."!cursor_debug"("NEXT", "")
  debug_871:
  rx1155_fail:
    (rx1155_rep, rx1155_pos, $I10, $P10) = rx1155_cur."!mark_fail"(0)
    lt rx1155_pos, -1, rx1155_done
    eq rx1155_pos, -1, rx1155_fail
    jump $I10
  rx1155_done:
    rx1155_cur."!cursor_fail"()
    if_null rx1155_debug, debug_872
    rx1155_cur."!cursor_debug"("FAIL", "")
  debug_872:
    .return (rx1155_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("55_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1162, "ResizablePMCArray"
    push $P1162, ""
    .return ($P1162)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("56_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 521
    new $P1164, "Undef"
    .lex "$*IN_DECL", $P1164
.annotate 'line', 523
    new $P1165, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P1165
.annotate 'line', 524
    new $P1166, "Undef"
    .lex "$*MAIN_SUB", $P1166
.annotate 'line', 527
    new $P1167, "Undef"
    .lex "$*PACKAGE", $P1167
.annotate 'line', 528
    new $P1168, "Undef"
    .lex "$*GLOBALish", $P1168
.annotate 'line', 422
    .local string rx1169_tgt
    .local int rx1169_pos
    .local int rx1169_off
    .local int rx1169_eos
    .local int rx1169_rep
    .local pmc rx1169_cur
    .local pmc rx1169_debug
    (rx1169_cur, rx1169_pos, rx1169_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1169_cur
    .local pmc match
    .lex "$/", match
    length rx1169_eos, rx1169_tgt
    gt rx1169_pos, rx1169_eos, rx1169_done
    set rx1169_off, 0
    lt rx1169_pos, 2, rx1169_start
    sub rx1169_off, rx1169_pos, 1
    substr rx1169_tgt, rx1169_tgt, rx1169_off
  rx1169_start:
    eq $I10, 1, rx1169_restart
    if_null rx1169_debug, debug_876
    rx1169_cur."!cursor_debug"("START", "comp_unit")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1170_done
    goto rxscan1170_scan
  rxscan1170_loop:
    (rx1169_pos) = rx1169_cur."from"()
    inc rx1169_pos
    rx1169_cur."!cursor_from"(rx1169_pos)
    ge rx1169_pos, rx1169_eos, rxscan1170_done
  rxscan1170_scan:
    set_addr $I10, rxscan1170_loop
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10)
  rxscan1170_done:
.annotate 'line', 521
    rx1169_cur."!cursor_pos"(rx1169_pos)
    new $P1171, "String"
    assign $P1171, ""
    store_lex "$*IN_DECL", $P1171
.annotate 'line', 523
    rx1169_cur."!cursor_pos"(rx1169_pos)
    new $P1172, "Integer"
    assign $P1172, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P1172
.annotate 'line', 524
    rx1169_cur."!cursor_pos"(rx1169_pos)
    find_lex $P1175, "$*MAIN_SUB"
    unless_null $P1175, vivify_877
    get_hll_global $P1173, "GLOBAL"
    get_who $P1174, $P1173
    set $P1175, $P1174["$MAIN_SUB"]
    unless_null $P1175, vivify_878
    die "Contextual $*MAIN_SUB not found"
  vivify_878:
  vivify_877:
.annotate 'line', 525
  # rx subrule "newpad" subtype=method negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."newpad"()
    unless $P10, rx1169_fail
    rx1169_pos = $P10."pos"()
.annotate 'line', 527
    rx1169_cur."!cursor_pos"(rx1169_pos)
    find_lex $P1178, "$*PACKAGE"
    unless_null $P1178, vivify_879
    get_hll_global $P1176, "GLOBAL"
    get_who $P1177, $P1176
    set $P1178, $P1177["$PACKAGE"]
    unless_null $P1178, vivify_880
    die "Contextual $*PACKAGE not found"
  vivify_880:
  vivify_879:
.annotate 'line', 528
    rx1169_cur."!cursor_pos"(rx1169_pos)
    find_lex $P1181, "$*GLOBALish"
    unless_null $P1181, vivify_881
    get_hll_global $P1179, "GLOBAL"
    get_who $P1180, $P1179
    set $P1181, $P1180["$GLOBALish"]
    unless_null $P1181, vivify_882
    die "Contextual $*GLOBALish not found"
  vivify_882:
  vivify_881:
.annotate 'line', 529
  # rx subrule "GLOBALish" subtype=method negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."GLOBALish"()
    unless $P10, rx1169_fail
    rx1169_pos = $P10."pos"()
.annotate 'line', 531
  # rx subrule "outerctx" subtype=method negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."outerctx"()
    unless $P10, rx1169_fail
    rx1169_pos = $P10."pos"()
.annotate 'line', 533
  # rx subrule "statementlist" subtype=capture negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."statementlist"()
    unless $P10, rx1169_fail
    rx1169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1169_pos = $P10."pos"()
  alt1182_0:
.annotate 'line', 534
    set_addr $I10, alt1182_1
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10)
  # rxanchor eos
    ne rx1169_pos, rx1169_eos, rx1169_fail
    goto alt1182_end
  alt1182_1:
  # rx subrule "panic" subtype=method negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."panic"("Confused")
    unless $P10, rx1169_fail
    rx1169_pos = $P10."pos"()
  alt1182_end:
.annotate 'line', 520
  # rx pass
    rx1169_cur."!cursor_pass"(rx1169_pos, "comp_unit")
    if_null rx1169_debug, debug_883
    rx1169_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1169_pos)
  debug_883:
    .return (rx1169_cur)
  rx1169_restart:
.annotate 'line', 422
    if_null rx1169_debug, debug_884
    rx1169_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_884:
  rx1169_fail:
    (rx1169_rep, rx1169_pos, $I10, $P10) = rx1169_cur."!mark_fail"(0)
    lt rx1169_pos, -1, rx1169_done
    eq rx1169_pos, -1, rx1169_fail
    jump $I10
  rx1169_done:
    rx1169_cur."!cursor_fail"()
    if_null rx1169_debug, debug_885
    rx1169_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_885:
    .return (rx1169_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("57_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1184 = self."!PREFIX__!subrule"("newpad", "")
    new $P1185, "ResizablePMCArray"
    push $P1185, $P1184
    .return ($P1185)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("58_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1187_tgt
    .local int rx1187_pos
    .local int rx1187_off
    .local int rx1187_eos
    .local int rx1187_rep
    .local pmc rx1187_cur
    .local pmc rx1187_debug
    (rx1187_cur, rx1187_pos, rx1187_tgt, $I10) = self."!cursor_start"()
    rx1187_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1187_cur
    .local pmc match
    .lex "$/", match
    length rx1187_eos, rx1187_tgt
    gt rx1187_pos, rx1187_eos, rx1187_done
    set rx1187_off, 0
    lt rx1187_pos, 2, rx1187_start
    sub rx1187_off, rx1187_pos, 1
    substr rx1187_tgt, rx1187_tgt, rx1187_off
  rx1187_start:
    eq $I10, 1, rx1187_restart
    if_null rx1187_debug, debug_886
    rx1187_cur."!cursor_debug"("START", "statementlist")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1188_done
    goto rxscan1188_scan
  rxscan1188_loop:
    (rx1187_pos) = rx1187_cur."from"()
    inc rx1187_pos
    rx1187_cur."!cursor_from"(rx1187_pos)
    ge rx1187_pos, rx1187_eos, rxscan1188_done
  rxscan1188_scan:
    set_addr $I10, rxscan1188_loop
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  rxscan1188_done:
  alt1189_0:
.annotate 'line', 537
    set_addr $I10, alt1189_1
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
.annotate 'line', 538
  # rx subrule "ws" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."ws"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
  # rxanchor eos
    ne rx1187_pos, rx1187_eos, rx1187_fail
  # rx subrule "ws" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."ws"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
    goto alt1189_end
  alt1189_1:
.annotate 'line', 539
  # rx subrule "ws" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."ws"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
  # rx rxquantr1193 ** 0..*
    set_addr $I10, rxquantr1193_done
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  rxquantr1193_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."statement"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1187_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."eat_terminator"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."ws"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
    set_addr $I10, rxquantr1193_done
    (rx1187_rep) = rx1187_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1193_done
    rx1187_cur."!mark_push"(rx1187_rep, rx1187_pos, $I10)
    goto rxquantr1193_loop
  rxquantr1193_done:
  # rx subrule "ws" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."ws"()
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
  alt1189_end:
.annotate 'line', 537
  # rx pass
    rx1187_cur."!cursor_pass"(rx1187_pos, "statementlist")
    if_null rx1187_debug, debug_887
    rx1187_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1187_pos)
  debug_887:
    .return (rx1187_cur)
  rx1187_restart:
.annotate 'line', 422
    if_null rx1187_debug, debug_888
    rx1187_cur."!cursor_debug"("NEXT", "statementlist")
  debug_888:
  rx1187_fail:
    (rx1187_rep, rx1187_pos, $I10, $P10) = rx1187_cur."!mark_fail"(0)
    lt rx1187_pos, -1, rx1187_done
    eq rx1187_pos, -1, rx1187_fail
    jump $I10
  rx1187_done:
    rx1187_cur."!cursor_fail"()
    if_null rx1187_debug, debug_889
    rx1187_cur."!cursor_debug"("FAIL", "statementlist")
  debug_889:
    .return (rx1187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("59_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1197 = self."!PREFIX__!subrule"("ws", "")
    $P1198 = self."!PREFIX__!subrule"("ws", "")
    new $P1199, "ResizablePMCArray"
    push $P1199, $P1197
    push $P1199, $P1198
    .return ($P1199)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("60_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1204 = "61_1304523757.895" 
    capture_lex $P1204
    .local string rx1201_tgt
    .local int rx1201_pos
    .local int rx1201_off
    .local int rx1201_eos
    .local int rx1201_rep
    .local pmc rx1201_cur
    .local pmc rx1201_debug
    (rx1201_cur, rx1201_pos, rx1201_tgt, $I10) = self."!cursor_start"()
    rx1201_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1201_cur
    .local pmc match
    .lex "$/", match
    length rx1201_eos, rx1201_tgt
    gt rx1201_pos, rx1201_eos, rx1201_done
    set rx1201_off, 0
    lt rx1201_pos, 2, rx1201_start
    sub rx1201_off, rx1201_pos, 1
    substr rx1201_tgt, rx1201_tgt, rx1201_off
  rx1201_start:
    eq $I10, 1, rx1201_restart
    if_null rx1201_debug, debug_890
    rx1201_cur."!cursor_debug"("START", "statement")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1202_done
    goto rxscan1202_scan
  rxscan1202_loop:
    (rx1201_pos) = rx1201_cur."from"()
    inc rx1201_pos
    rx1201_cur."!cursor_from"(rx1201_pos)
    ge rx1201_pos, rx1201_eos, rxscan1202_done
  rxscan1202_scan:
    set_addr $I10, rxscan1202_loop
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxscan1202_done:
.annotate 'line', 543
  # rx subrule "before" subtype=zerowidth negate=1
    rx1201_cur."!cursor_pos"(rx1201_pos)
    .const 'Sub' $P1204 = "61_1304523757.895" 
    capture_lex $P1204
    $P10 = rx1201_cur."before"($P1204)
    if $P10, rx1201_fail
  alt1208_0:
.annotate 'line', 544
    set_addr $I10, alt1208_1
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
.annotate 'line', 545
  # rx subrule "statement_control" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."statement_control"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1201_pos = $P10."pos"()
    goto alt1208_end
  alt1208_1:
.annotate 'line', 546
  # rx subrule "EXPR" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."EXPR"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1201_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."ws"()
    unless $P10, rx1201_fail
    rx1201_pos = $P10."pos"()
.annotate 'line', 551
  # rx rxquantr1209 ** 0..1
    set_addr $I10, rxquantr1209_done
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxquantr1209_loop:
  alt1210_0:
.annotate 'line', 547
    set_addr $I10, alt1210_1
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
.annotate 'line', 548
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."MARKED"("endstmt")
    unless $P10, rx1201_fail
    goto alt1210_end
  alt1210_1:
    set_addr $I10, alt1210_2
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
.annotate 'line', 549
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."statement_mod_cond"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1201_pos = $P10."pos"()
  # rx rxquantr1211 ** 0..1
    set_addr $I10, rxquantr1211_done
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxquantr1211_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."statement_mod_loop"()
    unless $P10, rx1201_fail
    goto rxsubrule1212_pass
  rxsubrule1212_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1201_fail
  rxsubrule1212_pass:
    set_addr $I10, rxsubrule1212_back
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1201_pos = $P10."pos"()
    set_addr $I10, rxquantr1211_done
    (rx1201_rep) = rx1201_cur."!mark_commit"($I10)
  rxquantr1211_done:
    goto alt1210_end
  alt1210_2:
.annotate 'line', 550
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."statement_mod_loop"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1201_pos = $P10."pos"()
  alt1210_end:
.annotate 'line', 551
    set_addr $I10, rxquantr1209_done
    (rx1201_rep) = rx1201_cur."!mark_commit"($I10)
  rxquantr1209_done:
  alt1208_end:
.annotate 'line', 542
  # rx pass
    rx1201_cur."!cursor_pass"(rx1201_pos, "statement")
    if_null rx1201_debug, debug_895
    rx1201_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1201_pos)
  debug_895:
    .return (rx1201_cur)
  rx1201_restart:
.annotate 'line', 422
    if_null rx1201_debug, debug_896
    rx1201_cur."!cursor_debug"("NEXT", "statement")
  debug_896:
  rx1201_fail:
    (rx1201_rep, rx1201_pos, $I10, $P10) = rx1201_cur."!mark_fail"(0)
    lt rx1201_pos, -1, rx1201_done
    eq rx1201_pos, -1, rx1201_fail
    jump $I10
  rx1201_done:
    rx1201_cur."!cursor_fail"()
    if_null rx1201_debug, debug_897
    rx1201_cur."!cursor_debug"("FAIL", "statement")
  debug_897:
    .return (rx1201_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1203"  :anon :subid("61_1304523757.895") :method :outer("60_1304523757.895")
.annotate 'line', 543
    .local string rx1205_tgt
    .local int rx1205_pos
    .local int rx1205_off
    .local int rx1205_eos
    .local int rx1205_rep
    .local pmc rx1205_cur
    .local pmc rx1205_debug
    (rx1205_cur, rx1205_pos, rx1205_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1205_cur
    .local pmc match
    .lex "$/", match
    length rx1205_eos, rx1205_tgt
    gt rx1205_pos, rx1205_eos, rx1205_done
    set rx1205_off, 0
    lt rx1205_pos, 2, rx1205_start
    sub rx1205_off, rx1205_pos, 1
    substr rx1205_tgt, rx1205_tgt, rx1205_off
  rx1205_start:
    eq $I10, 1, rx1205_restart
    if_null rx1205_debug, debug_891
    rx1205_cur."!cursor_debug"("START", "")
  debug_891:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1206_done
    goto rxscan1206_scan
  rxscan1206_loop:
    (rx1205_pos) = rx1205_cur."from"()
    inc rx1205_pos
    rx1205_cur."!cursor_from"(rx1205_pos)
    ge rx1205_pos, rx1205_eos, rxscan1206_done
  rxscan1206_scan:
    set_addr $I10, rxscan1206_loop
    rx1205_cur."!mark_push"(0, rx1205_pos, $I10)
  rxscan1206_done:
  alt1207_0:
    set_addr $I10, alt1207_1
    rx1205_cur."!mark_push"(0, rx1205_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1205_pos, rx1205_eos, rx1205_fail
    sub $I10, rx1205_pos, rx1205_off
    substr $S10, rx1205_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1205_fail
    inc rx1205_pos
    goto alt1207_end
  alt1207_1:
  # rxanchor eos
    ne rx1205_pos, rx1205_eos, rx1205_fail
  alt1207_end:
  # rx pass
    rx1205_cur."!cursor_pass"(rx1205_pos, "")
    if_null rx1205_debug, debug_892
    rx1205_cur."!cursor_debug"("PASS", "", " at pos=", rx1205_pos)
  debug_892:
    .return (rx1205_cur)
  rx1205_restart:
    if_null rx1205_debug, debug_893
    rx1205_cur."!cursor_debug"("NEXT", "")
  debug_893:
  rx1205_fail:
    (rx1205_rep, rx1205_pos, $I10, $P10) = rx1205_cur."!mark_fail"(0)
    lt rx1205_pos, -1, rx1205_done
    eq rx1205_pos, -1, rx1205_fail
    jump $I10
  rx1205_done:
    rx1205_cur."!cursor_fail"()
    if_null rx1205_debug, debug_894
    rx1205_cur."!cursor_debug"("FAIL", "")
  debug_894:
    .return (rx1205_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("62_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1214, "ResizablePMCArray"
    push $P1214, ""
    .return ($P1214)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("63_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1216_tgt
    .local int rx1216_pos
    .local int rx1216_off
    .local int rx1216_eos
    .local int rx1216_rep
    .local pmc rx1216_cur
    .local pmc rx1216_debug
    (rx1216_cur, rx1216_pos, rx1216_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1216_cur
    .local pmc match
    .lex "$/", match
    length rx1216_eos, rx1216_tgt
    gt rx1216_pos, rx1216_eos, rx1216_done
    set rx1216_off, 0
    lt rx1216_pos, 2, rx1216_start
    sub rx1216_off, rx1216_pos, 1
    substr rx1216_tgt, rx1216_tgt, rx1216_off
  rx1216_start:
    eq $I10, 1, rx1216_restart
    if_null rx1216_debug, debug_898
    rx1216_cur."!cursor_debug"("START", "eat_terminator")
  debug_898:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1217_done
    goto rxscan1217_scan
  rxscan1217_loop:
    (rx1216_pos) = rx1216_cur."from"()
    inc rx1216_pos
    rx1216_cur."!cursor_from"(rx1216_pos)
    ge rx1216_pos, rx1216_eos, rxscan1217_done
  rxscan1217_scan:
    set_addr $I10, rxscan1217_loop
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
  rxscan1217_done:
  alt1218_0:
.annotate 'line', 555
    set_addr $I10, alt1218_1
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
.annotate 'line', 556
  # rx literal  ";"
    add $I11, rx1216_pos, 1
    gt $I11, rx1216_eos, rx1216_fail
    sub $I11, rx1216_pos, rx1216_off
    ord $I11, rx1216_tgt, $I11
    ne $I11, 59, rx1216_fail
    add rx1216_pos, 1
    goto alt1218_end
  alt1218_1:
    set_addr $I10, alt1218_2
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
.annotate 'line', 557
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1216_cur."!cursor_pos"(rx1216_pos)
    $P10 = rx1216_cur."MARKED"("endstmt")
    unless $P10, rx1216_fail
    goto alt1218_end
  alt1218_2:
    set_addr $I10, alt1218_3
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
.annotate 'line', 558
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1216_cur."!cursor_pos"(rx1216_pos)
    $P10 = rx1216_cur."terminator"()
    unless $P10, rx1216_fail
    goto alt1218_end
  alt1218_3:
.annotate 'line', 559
  # rxanchor eos
    ne rx1216_pos, rx1216_eos, rx1216_fail
  alt1218_end:
.annotate 'line', 555
  # rx pass
    rx1216_cur."!cursor_pass"(rx1216_pos, "eat_terminator")
    if_null rx1216_debug, debug_899
    rx1216_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1216_pos)
  debug_899:
    .return (rx1216_cur)
  rx1216_restart:
.annotate 'line', 422
    if_null rx1216_debug, debug_900
    rx1216_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_900:
  rx1216_fail:
    (rx1216_rep, rx1216_pos, $I10, $P10) = rx1216_cur."!mark_fail"(0)
    lt rx1216_pos, -1, rx1216_done
    eq rx1216_pos, -1, rx1216_fail
    jump $I10
  rx1216_done:
    rx1216_cur."!cursor_fail"()
    if_null rx1216_debug, debug_901
    rx1216_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_901:
    .return (rx1216_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("64_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1220, "ResizablePMCArray"
    push $P1220, ""
    push $P1220, ""
    push $P1220, ""
    push $P1220, ";"
    .return ($P1220)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("65_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1222_tgt
    .local int rx1222_pos
    .local int rx1222_off
    .local int rx1222_eos
    .local int rx1222_rep
    .local pmc rx1222_cur
    .local pmc rx1222_debug
    (rx1222_cur, rx1222_pos, rx1222_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1222_cur
    .local pmc match
    .lex "$/", match
    length rx1222_eos, rx1222_tgt
    gt rx1222_pos, rx1222_eos, rx1222_done
    set rx1222_off, 0
    lt rx1222_pos, 2, rx1222_start
    sub rx1222_off, rx1222_pos, 1
    substr rx1222_tgt, rx1222_tgt, rx1222_off
  rx1222_start:
    eq $I10, 1, rx1222_restart
    if_null rx1222_debug, debug_902
    rx1222_cur."!cursor_debug"("START", "xblock")
  debug_902:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1223_done
    goto rxscan1223_scan
  rxscan1223_loop:
    (rx1222_pos) = rx1222_cur."from"()
    inc rx1222_pos
    rx1222_cur."!cursor_from"(rx1222_pos)
    ge rx1222_pos, rx1222_eos, rxscan1223_done
  rxscan1223_scan:
    set_addr $I10, rxscan1223_loop
    rx1222_cur."!mark_push"(0, rx1222_pos, $I10)
  rxscan1223_done:
.annotate 'line', 563
  # rx subrule "EXPR" subtype=capture negate=
    rx1222_cur."!cursor_pos"(rx1222_pos)
    $P10 = rx1222_cur."EXPR"()
    unless $P10, rx1222_fail
    rx1222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1222_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1222_cur."!cursor_pos"(rx1222_pos)
    $P10 = rx1222_cur."ws"()
    unless $P10, rx1222_fail
    rx1222_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1222_cur."!cursor_pos"(rx1222_pos)
    $P10 = rx1222_cur."pblock"()
    unless $P10, rx1222_fail
    rx1222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1222_pos = $P10."pos"()
.annotate 'line', 562
  # rx pass
    rx1222_cur."!cursor_pass"(rx1222_pos, "xblock")
    if_null rx1222_debug, debug_903
    rx1222_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1222_pos)
  debug_903:
    .return (rx1222_cur)
  rx1222_restart:
.annotate 'line', 422
    if_null rx1222_debug, debug_904
    rx1222_cur."!cursor_debug"("NEXT", "xblock")
  debug_904:
  rx1222_fail:
    (rx1222_rep, rx1222_pos, $I10, $P10) = rx1222_cur."!mark_fail"(0)
    lt rx1222_pos, -1, rx1222_done
    eq rx1222_pos, -1, rx1222_fail
    jump $I10
  rx1222_done:
    rx1222_cur."!cursor_fail"()
    if_null rx1222_debug, debug_905
    rx1222_cur."!cursor_debug"("FAIL", "xblock")
  debug_905:
    .return (rx1222_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("66_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1225 = self."!PREFIX__!subrule"("EXPR", "")
    new $P1226, "ResizablePMCArray"
    push $P1226, $P1225
    .return ($P1226)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("67_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1228_tgt
    .local int rx1228_pos
    .local int rx1228_off
    .local int rx1228_eos
    .local int rx1228_rep
    .local pmc rx1228_cur
    .local pmc rx1228_debug
    (rx1228_cur, rx1228_pos, rx1228_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1228_cur
    .local pmc match
    .lex "$/", match
    length rx1228_eos, rx1228_tgt
    gt rx1228_pos, rx1228_eos, rx1228_done
    set rx1228_off, 0
    lt rx1228_pos, 2, rx1228_start
    sub rx1228_off, rx1228_pos, 1
    substr rx1228_tgt, rx1228_tgt, rx1228_off
  rx1228_start:
    eq $I10, 1, rx1228_restart
    if_null rx1228_debug, debug_906
    rx1228_cur."!cursor_debug"("START", "pblock")
  debug_906:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1228_pos) = rx1228_cur."from"()
    inc rx1228_pos
    rx1228_cur."!cursor_from"(rx1228_pos)
    ge rx1228_pos, rx1228_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxscan1229_done:
  alt1230_0:
.annotate 'line', 566
    set_addr $I10, alt1230_1
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
.annotate 'line', 567
  # rx subrule "lambda" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."lambda"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
.annotate 'line', 568
  # rx subrule "newpad" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."newpad"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
.annotate 'line', 569
  # rx subrule "signature" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."signature"()
    unless $P10, rx1228_fail
    rx1228_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1228_pos = $P10."pos"()
.annotate 'line', 570
  # rx subrule "blockoid" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."blockoid"()
    unless $P10, rx1228_fail
    rx1228_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1228_pos = $P10."pos"()
.annotate 'line', 567
    goto alt1230_end
  alt1230_1:
    set_addr $I10, alt1230_2
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
.annotate 'line', 571
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1228_pos, rx1228_off
    substr $S10, rx1228_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1228_fail
.annotate 'line', 572
  # rx subrule "newpad" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."newpad"()
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
.annotate 'line', 573
  # rx subrule "blockoid" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."blockoid"()
    unless $P10, rx1228_fail
    rx1228_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1228_pos = $P10."pos"()
.annotate 'line', 571
    goto alt1230_end
  alt1230_2:
.annotate 'line', 574
  # rx subrule "panic" subtype=method negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."panic"("Missing block")
    unless $P10, rx1228_fail
    rx1228_pos = $P10."pos"()
  alt1230_end:
.annotate 'line', 566
  # rx pass
    rx1228_cur."!cursor_pass"(rx1228_pos, "pblock")
    if_null rx1228_debug, debug_907
    rx1228_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1228_pos)
  debug_907:
    .return (rx1228_cur)
  rx1228_restart:
.annotate 'line', 422
    if_null rx1228_debug, debug_908
    rx1228_cur."!cursor_debug"("NEXT", "pblock")
  debug_908:
  rx1228_fail:
    (rx1228_rep, rx1228_pos, $I10, $P10) = rx1228_cur."!mark_fail"(0)
    lt rx1228_pos, -1, rx1228_done
    eq rx1228_pos, -1, rx1228_fail
    jump $I10
  rx1228_done:
    rx1228_cur."!cursor_fail"()
    if_null rx1228_debug, debug_909
    rx1228_cur."!cursor_debug"("FAIL", "pblock")
  debug_909:
    .return (rx1228_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("68_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1232 = self."!PREFIX__!subrule"("panic", "")
    $P1233 = self."!PREFIX__!subrule"("lambda", "")
    new $P1234, "ResizablePMCArray"
    push $P1234, $P1232
    push $P1234, "{"
    push $P1234, $P1233
    .return ($P1234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("69_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_910
    rx1236_cur."!cursor_debug"("START", "lambda")
  debug_910:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1237_done
    goto rxscan1237_scan
  rxscan1237_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1237_done
  rxscan1237_scan:
    set_addr $I10, rxscan1237_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1237_done:
  alt1238_0:
.annotate 'line', 577
    set_addr $I10, alt1238_1
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  # rx literal  "->"
    add $I11, rx1236_pos, 2
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    substr $S10, rx1236_tgt, $I11, 2
    ne $S10, "->", rx1236_fail
    add rx1236_pos, 2
    goto alt1238_end
  alt1238_1:
  # rx literal  "<->"
    add $I11, rx1236_pos, 3
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    substr $S10, rx1236_tgt, $I11, 3
    ne $S10, "<->", rx1236_fail
    add rx1236_pos, 3
  alt1238_end:
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "lambda")
    if_null rx1236_debug, debug_911
    rx1236_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1236_pos)
  debug_911:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 422
    if_null rx1236_debug, debug_912
    rx1236_cur."!cursor_debug"("NEXT", "lambda")
  debug_912:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_913
    rx1236_cur."!cursor_debug"("FAIL", "lambda")
  debug_913:
    .return (rx1236_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("70_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1240, "ResizablePMCArray"
    push $P1240, "<->"
    push $P1240, "->"
    .return ($P1240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("71_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_914
    rx1242_cur."!cursor_debug"("START", "block")
  debug_914:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1243_done
    goto rxscan1243_scan
  rxscan1243_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1243_done
  rxscan1243_scan:
    set_addr $I10, rxscan1243_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1243_done:
  alt1244_0:
.annotate 'line', 580
    set_addr $I10, alt1244_1
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1242_pos, rx1242_off
    substr $S10, rx1242_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1242_fail
    goto alt1244_end
  alt1244_1:
  # rx subrule "panic" subtype=method negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."panic"("Missing block")
    unless $P10, rx1242_fail
    rx1242_pos = $P10."pos"()
  alt1244_end:
.annotate 'line', 581
  # rx subrule "newpad" subtype=method negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."newpad"()
    unless $P10, rx1242_fail
    rx1242_pos = $P10."pos"()
.annotate 'line', 582
  # rx subrule "blockoid" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."blockoid"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1242_pos = $P10."pos"()
.annotate 'line', 579
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "block")
    if_null rx1242_debug, debug_915
    rx1242_cur."!cursor_debug"("PASS", "block", " at pos=", rx1242_pos)
  debug_915:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 422
    if_null rx1242_debug, debug_916
    rx1242_cur."!cursor_debug"("NEXT", "block")
  debug_916:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_917
    rx1242_cur."!cursor_debug"("FAIL", "block")
  debug_917:
    .return (rx1242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("72_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1246 = self."!PREFIX__!subrule"("panic", "")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    push $P1247, "{"
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("73_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1249_tgt
    .local int rx1249_pos
    .local int rx1249_off
    .local int rx1249_eos
    .local int rx1249_rep
    .local pmc rx1249_cur
    .local pmc rx1249_debug
    (rx1249_cur, rx1249_pos, rx1249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1249_cur
    .local pmc match
    .lex "$/", match
    length rx1249_eos, rx1249_tgt
    gt rx1249_pos, rx1249_eos, rx1249_done
    set rx1249_off, 0
    lt rx1249_pos, 2, rx1249_start
    sub rx1249_off, rx1249_pos, 1
    substr rx1249_tgt, rx1249_tgt, rx1249_off
  rx1249_start:
    eq $I10, 1, rx1249_restart
    if_null rx1249_debug, debug_918
    rx1249_cur."!cursor_debug"("START", "blockoid")
  debug_918:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1250_done
    goto rxscan1250_scan
  rxscan1250_loop:
    (rx1249_pos) = rx1249_cur."from"()
    inc rx1249_pos
    rx1249_cur."!cursor_from"(rx1249_pos)
    ge rx1249_pos, rx1249_eos, rxscan1250_done
  rxscan1250_scan:
    set_addr $I10, rxscan1250_loop
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
  rxscan1250_done:
.annotate 'line', 586
  # rx subrule "finishpad" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."finishpad"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  alt1251_0:
.annotate 'line', 587
    set_addr $I10, alt1251_1
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
.annotate 'line', 588
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1249_pos, 14
    gt $I11, rx1249_eos, rx1249_fail
    sub $I11, rx1249_pos, rx1249_off
    substr $S10, rx1249_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1249_fail
    add rx1249_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."you_are_here"()
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1249_pos = $P10."pos"()
    goto alt1251_end
  alt1251_1:
.annotate 'line', 589
  # rx literal  "{"
    add $I11, rx1249_pos, 1
    gt $I11, rx1249_eos, rx1249_fail
    sub $I11, rx1249_pos, rx1249_off
    ord $I11, rx1249_tgt, $I11
    ne $I11, 123, rx1249_fail
    add rx1249_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."statementlist"()
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1249_pos = $P10."pos"()
  alt1252_0:
    set_addr $I10, alt1252_1
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
  # rx literal  "}"
    add $I11, rx1249_pos, 1
    gt $I11, rx1249_eos, rx1249_fail
    sub $I11, rx1249_pos, rx1249_off
    ord $I11, rx1249_tgt, $I11
    ne $I11, 125, rx1249_fail
    add rx1249_pos, 1
    goto alt1252_end
  alt1252_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."FAILGOAL"("'}'")
    unless $P10, rx1249_fail
    goto rxsubrule1254_pass
  rxsubrule1254_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1249_fail
  rxsubrule1254_pass:
    set_addr $I10, rxsubrule1254_back
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10, $P10)
    rx1249_pos = $P10."pos"()
  alt1252_end:
  alt1251_end:
.annotate 'line', 591
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ENDSTMT"()
    unless $P10, rx1249_fail
.annotate 'line', 585
  # rx pass
    rx1249_cur."!cursor_pass"(rx1249_pos, "blockoid")
    if_null rx1249_debug, debug_919
    rx1249_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1249_pos)
  debug_919:
    .return (rx1249_cur)
  rx1249_restart:
.annotate 'line', 422
    if_null rx1249_debug, debug_920
    rx1249_cur."!cursor_debug"("NEXT", "blockoid")
  debug_920:
  rx1249_fail:
    (rx1249_rep, rx1249_pos, $I10, $P10) = rx1249_cur."!mark_fail"(0)
    lt rx1249_pos, -1, rx1249_done
    eq rx1249_pos, -1, rx1249_fail
    jump $I10
  rx1249_done:
    rx1249_cur."!cursor_fail"()
    if_null rx1249_debug, debug_921
    rx1249_cur."!cursor_debug"("FAIL", "blockoid")
  debug_921:
    .return (rx1249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("74_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1256 = self."!PREFIX__!subrule"("finishpad", "")
    new $P1257, "ResizablePMCArray"
    push $P1257, $P1256
    .return ($P1257)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("75_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1259_tgt
    .local int rx1259_pos
    .local int rx1259_off
    .local int rx1259_eos
    .local int rx1259_rep
    .local pmc rx1259_cur
    .local pmc rx1259_debug
    (rx1259_cur, rx1259_pos, rx1259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1259_cur
    .local pmc match
    .lex "$/", match
    length rx1259_eos, rx1259_tgt
    gt rx1259_pos, rx1259_eos, rx1259_done
    set rx1259_off, 0
    lt rx1259_pos, 2, rx1259_start
    sub rx1259_off, rx1259_pos, 1
    substr rx1259_tgt, rx1259_tgt, rx1259_off
  rx1259_start:
    eq $I10, 1, rx1259_restart
    if_null rx1259_debug, debug_922
    rx1259_cur."!cursor_debug"("START", "newpad")
  debug_922:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1260_done
    goto rxscan1260_scan
  rxscan1260_loop:
    (rx1259_pos) = rx1259_cur."from"()
    inc rx1259_pos
    rx1259_cur."!cursor_from"(rx1259_pos)
    ge rx1259_pos, rx1259_eos, rxscan1260_done
  rxscan1260_scan:
    set_addr $I10, rxscan1260_loop
    rx1259_cur."!mark_push"(0, rx1259_pos, $I10)
  rxscan1260_done:
.annotate 'line', 594
  # rx pass
    rx1259_cur."!cursor_pass"(rx1259_pos, "newpad")
    if_null rx1259_debug, debug_923
    rx1259_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1259_pos)
  debug_923:
    .return (rx1259_cur)
  rx1259_restart:
.annotate 'line', 422
    if_null rx1259_debug, debug_924
    rx1259_cur."!cursor_debug"("NEXT", "newpad")
  debug_924:
  rx1259_fail:
    (rx1259_rep, rx1259_pos, $I10, $P10) = rx1259_cur."!mark_fail"(0)
    lt rx1259_pos, -1, rx1259_done
    eq rx1259_pos, -1, rx1259_fail
    jump $I10
  rx1259_done:
    rx1259_cur."!cursor_fail"()
    if_null rx1259_debug, debug_925
    rx1259_cur."!cursor_debug"("FAIL", "newpad")
  debug_925:
    .return (rx1259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("76_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1262, "ResizablePMCArray"
    push $P1262, ""
    .return ($P1262)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("77_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1264_tgt
    .local int rx1264_pos
    .local int rx1264_off
    .local int rx1264_eos
    .local int rx1264_rep
    .local pmc rx1264_cur
    .local pmc rx1264_debug
    (rx1264_cur, rx1264_pos, rx1264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1264_cur
    .local pmc match
    .lex "$/", match
    length rx1264_eos, rx1264_tgt
    gt rx1264_pos, rx1264_eos, rx1264_done
    set rx1264_off, 0
    lt rx1264_pos, 2, rx1264_start
    sub rx1264_off, rx1264_pos, 1
    substr rx1264_tgt, rx1264_tgt, rx1264_off
  rx1264_start:
    eq $I10, 1, rx1264_restart
    if_null rx1264_debug, debug_926
    rx1264_cur."!cursor_debug"("START", "outerctx")
  debug_926:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1264_pos) = rx1264_cur."from"()
    inc rx1264_pos
    rx1264_cur."!cursor_from"(rx1264_pos)
    ge rx1264_pos, rx1264_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1264_cur."!mark_push"(0, rx1264_pos, $I10)
  rxscan1265_done:
.annotate 'line', 595
  # rx pass
    rx1264_cur."!cursor_pass"(rx1264_pos, "outerctx")
    if_null rx1264_debug, debug_927
    rx1264_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1264_pos)
  debug_927:
    .return (rx1264_cur)
  rx1264_restart:
.annotate 'line', 422
    if_null rx1264_debug, debug_928
    rx1264_cur."!cursor_debug"("NEXT", "outerctx")
  debug_928:
  rx1264_fail:
    (rx1264_rep, rx1264_pos, $I10, $P10) = rx1264_cur."!mark_fail"(0)
    lt rx1264_pos, -1, rx1264_done
    eq rx1264_pos, -1, rx1264_fail
    jump $I10
  rx1264_done:
    rx1264_cur."!cursor_fail"()
    if_null rx1264_debug, debug_929
    rx1264_cur."!cursor_debug"("FAIL", "outerctx")
  debug_929:
    .return (rx1264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("78_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1267, "ResizablePMCArray"
    push $P1267, ""
    .return ($P1267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("79_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1269_tgt
    .local int rx1269_pos
    .local int rx1269_off
    .local int rx1269_eos
    .local int rx1269_rep
    .local pmc rx1269_cur
    .local pmc rx1269_debug
    (rx1269_cur, rx1269_pos, rx1269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1269_cur
    .local pmc match
    .lex "$/", match
    length rx1269_eos, rx1269_tgt
    gt rx1269_pos, rx1269_eos, rx1269_done
    set rx1269_off, 0
    lt rx1269_pos, 2, rx1269_start
    sub rx1269_off, rx1269_pos, 1
    substr rx1269_tgt, rx1269_tgt, rx1269_off
  rx1269_start:
    eq $I10, 1, rx1269_restart
    if_null rx1269_debug, debug_930
    rx1269_cur."!cursor_debug"("START", "GLOBALish")
  debug_930:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1270_done
    goto rxscan1270_scan
  rxscan1270_loop:
    (rx1269_pos) = rx1269_cur."from"()
    inc rx1269_pos
    rx1269_cur."!cursor_from"(rx1269_pos)
    ge rx1269_pos, rx1269_eos, rxscan1270_done
  rxscan1270_scan:
    set_addr $I10, rxscan1270_loop
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  rxscan1270_done:
.annotate 'line', 596
  # rx pass
    rx1269_cur."!cursor_pass"(rx1269_pos, "GLOBALish")
    if_null rx1269_debug, debug_931
    rx1269_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1269_pos)
  debug_931:
    .return (rx1269_cur)
  rx1269_restart:
.annotate 'line', 422
    if_null rx1269_debug, debug_932
    rx1269_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_932:
  rx1269_fail:
    (rx1269_rep, rx1269_pos, $I10, $P10) = rx1269_cur."!mark_fail"(0)
    lt rx1269_pos, -1, rx1269_done
    eq rx1269_pos, -1, rx1269_fail
    jump $I10
  rx1269_done:
    rx1269_cur."!cursor_fail"()
    if_null rx1269_debug, debug_933
    rx1269_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_933:
    .return (rx1269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("80_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1272, "ResizablePMCArray"
    push $P1272, ""
    .return ($P1272)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("81_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1274_tgt
    .local int rx1274_pos
    .local int rx1274_off
    .local int rx1274_eos
    .local int rx1274_rep
    .local pmc rx1274_cur
    .local pmc rx1274_debug
    (rx1274_cur, rx1274_pos, rx1274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1274_cur
    .local pmc match
    .lex "$/", match
    length rx1274_eos, rx1274_tgt
    gt rx1274_pos, rx1274_eos, rx1274_done
    set rx1274_off, 0
    lt rx1274_pos, 2, rx1274_start
    sub rx1274_off, rx1274_pos, 1
    substr rx1274_tgt, rx1274_tgt, rx1274_off
  rx1274_start:
    eq $I10, 1, rx1274_restart
    if_null rx1274_debug, debug_934
    rx1274_cur."!cursor_debug"("START", "finishpad")
  debug_934:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1275_done
    goto rxscan1275_scan
  rxscan1275_loop:
    (rx1274_pos) = rx1274_cur."from"()
    inc rx1274_pos
    rx1274_cur."!cursor_from"(rx1274_pos)
    ge rx1274_pos, rx1274_eos, rxscan1275_done
  rxscan1275_scan:
    set_addr $I10, rxscan1275_loop
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxscan1275_done:
.annotate 'line', 597
  # rx pass
    rx1274_cur."!cursor_pass"(rx1274_pos, "finishpad")
    if_null rx1274_debug, debug_935
    rx1274_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1274_pos)
  debug_935:
    .return (rx1274_cur)
  rx1274_restart:
.annotate 'line', 422
    if_null rx1274_debug, debug_936
    rx1274_cur."!cursor_debug"("NEXT", "finishpad")
  debug_936:
  rx1274_fail:
    (rx1274_rep, rx1274_pos, $I10, $P10) = rx1274_cur."!mark_fail"(0)
    lt rx1274_pos, -1, rx1274_done
    eq rx1274_pos, -1, rx1274_fail
    jump $I10
  rx1274_done:
    rx1274_cur."!cursor_fail"()
    if_null rx1274_debug, debug_937
    rx1274_cur."!cursor_debug"("FAIL", "finishpad")
  debug_937:
    .return (rx1274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("82_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1277, "ResizablePMCArray"
    push $P1277, ""
    .return ($P1277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("83_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_938
    rx1279_cur."!cursor_debug"("START", "you_are_here")
  debug_938:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1279_pos) = rx1279_cur."from"()
    inc rx1279_pos
    rx1279_cur."!cursor_from"(rx1279_pos)
    ge rx1279_pos, rx1279_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1280_done:
.annotate 'line', 598
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "you_are_here")
    if_null rx1279_debug, debug_939
    rx1279_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1279_pos)
  debug_939:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 422
    if_null rx1279_debug, debug_940
    rx1279_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_940:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_941
    rx1279_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_941:
    .return (rx1279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("84_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1282, "ResizablePMCArray"
    push $P1282, ""
    .return ($P1282)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("85_1304523757.895")
    .param pmc param_1284
.annotate 'line', 600
    .lex "self", param_1284
    $P1285 = param_1284."!protoregex"("terminator")
    .return ($P1285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("86_1304523757.895")
    .param pmc param_1287
.annotate 'line', 600
    .lex "self", param_1287
    $P1288 = param_1287."!PREFIX__!protoregex"("terminator")
    .return ($P1288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("87_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1290_tgt
    .local int rx1290_pos
    .local int rx1290_off
    .local int rx1290_eos
    .local int rx1290_rep
    .local pmc rx1290_cur
    .local pmc rx1290_debug
    (rx1290_cur, rx1290_pos, rx1290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1290_cur
    .local pmc match
    .lex "$/", match
    length rx1290_eos, rx1290_tgt
    gt rx1290_pos, rx1290_eos, rx1290_done
    set rx1290_off, 0
    lt rx1290_pos, 2, rx1290_start
    sub rx1290_off, rx1290_pos, 1
    substr rx1290_tgt, rx1290_tgt, rx1290_off
  rx1290_start:
    eq $I10, 1, rx1290_restart
    if_null rx1290_debug, debug_942
    rx1290_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_942:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1291_done
    goto rxscan1291_scan
  rxscan1291_loop:
    (rx1290_pos) = rx1290_cur."from"()
    inc rx1290_pos
    rx1290_cur."!cursor_from"(rx1290_pos)
    ge rx1290_pos, rx1290_eos, rxscan1291_done
  rxscan1291_scan:
    set_addr $I10, rxscan1291_loop
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  rxscan1291_done:
.annotate 'line', 602
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1290_pos, rx1290_off
    substr $S10, rx1290_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1290_fail
  # rx pass
    rx1290_cur."!cursor_pass"(rx1290_pos, "terminator:sym<;>")
    if_null rx1290_debug, debug_943
    rx1290_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1290_pos)
  debug_943:
    .return (rx1290_cur)
  rx1290_restart:
.annotate 'line', 422
    if_null rx1290_debug, debug_944
    rx1290_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_944:
  rx1290_fail:
    (rx1290_rep, rx1290_pos, $I10, $P10) = rx1290_cur."!mark_fail"(0)
    lt rx1290_pos, -1, rx1290_done
    eq rx1290_pos, -1, rx1290_fail
    jump $I10
  rx1290_done:
    rx1290_cur."!cursor_fail"()
    if_null rx1290_debug, debug_945
    rx1290_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_945:
    .return (rx1290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("88_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1293, "ResizablePMCArray"
    push $P1293, ";"
    .return ($P1293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("89_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_946
    rx1295_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_946:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1296_done
    goto rxscan1296_scan
  rxscan1296_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1296_done
  rxscan1296_scan:
    set_addr $I10, rxscan1296_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1296_done:
.annotate 'line', 603
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1295_pos, rx1295_off
    substr $S10, rx1295_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1295_fail
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "terminator:sym<}>")
    if_null rx1295_debug, debug_947
    rx1295_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1295_pos)
  debug_947:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 422
    if_null rx1295_debug, debug_948
    rx1295_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_948:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_949
    rx1295_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_949:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("90_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1298, "ResizablePMCArray"
    push $P1298, "}"
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("91_1304523757.895")
    .param pmc param_1300
.annotate 'line', 607
    .lex "self", param_1300
    $P1301 = param_1300."!protoregex"("statement_control")
    .return ($P1301)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("92_1304523757.895")
    .param pmc param_1303
.annotate 'line', 607
    .lex "self", param_1303
    $P1304 = param_1303."!PREFIX__!protoregex"("statement_control")
    .return ($P1304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("93_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1306_tgt
    .local int rx1306_pos
    .local int rx1306_off
    .local int rx1306_eos
    .local int rx1306_rep
    .local pmc rx1306_cur
    .local pmc rx1306_debug
    (rx1306_cur, rx1306_pos, rx1306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1306_cur
    .local pmc match
    .lex "$/", match
    length rx1306_eos, rx1306_tgt
    gt rx1306_pos, rx1306_eos, rx1306_done
    set rx1306_off, 0
    lt rx1306_pos, 2, rx1306_start
    sub rx1306_off, rx1306_pos, 1
    substr rx1306_tgt, rx1306_tgt, rx1306_off
  rx1306_start:
    eq $I10, 1, rx1306_restart
    if_null rx1306_debug, debug_950
    rx1306_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_950:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1307_done
    goto rxscan1307_scan
  rxscan1307_loop:
    (rx1306_pos) = rx1306_cur."from"()
    inc rx1306_pos
    rx1306_cur."!cursor_from"(rx1306_pos)
    ge rx1306_pos, rx1306_eos, rxscan1307_done
  rxscan1307_scan:
    set_addr $I10, rxscan1307_loop
    rx1306_cur."!mark_push"(0, rx1306_pos, $I10)
  rxscan1307_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1308_fail
    rx1306_cur."!mark_push"(0, rx1306_pos, $I10)
  # rx literal  "use"
    add $I11, rx1306_pos, 3
    gt $I11, rx1306_eos, rx1306_fail
    sub $I11, rx1306_pos, rx1306_off
    substr $S10, rx1306_tgt, $I11, 3
    ne $S10, "use", rx1306_fail
    add rx1306_pos, 3
    set_addr $I10, rxcap_1308_fail
    ($I12, $I11) = rx1306_cur."!mark_peek"($I10)
    rx1306_cur."!cursor_pos"($I11)
    ($P10) = rx1306_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1306_pos, "")
    rx1306_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1308_done
  rxcap_1308_fail:
    goto rx1306_fail
  rxcap_1308_done:
  # rx charclass s
    ge rx1306_pos, rx1306_eos, rx1306_fail
    sub $I10, rx1306_pos, rx1306_off
    is_cclass $I11, 32, rx1306_tgt, $I10
    unless $I11, rx1306_fail
    inc rx1306_pos
  # rx subrule "ws" subtype=method negate=
    rx1306_cur."!cursor_pos"(rx1306_pos)
    $P10 = rx1306_cur."ws"()
    unless $P10, rx1306_fail
    rx1306_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1306_cur."!cursor_pos"(rx1306_pos)
    $P10 = rx1306_cur."name"()
    unless $P10, rx1306_fail
    rx1306_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1306_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1306_cur."!cursor_pos"(rx1306_pos)
    $P10 = rx1306_cur."ws"()
    unless $P10, rx1306_fail
    rx1306_pos = $P10."pos"()
.annotate 'line', 609
  # rx pass
    rx1306_cur."!cursor_pass"(rx1306_pos, "statement_control:sym<use>")
    if_null rx1306_debug, debug_951
    rx1306_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1306_pos)
  debug_951:
    .return (rx1306_cur)
  rx1306_restart:
.annotate 'line', 422
    if_null rx1306_debug, debug_952
    rx1306_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_952:
  rx1306_fail:
    (rx1306_rep, rx1306_pos, $I10, $P10) = rx1306_cur."!mark_fail"(0)
    lt rx1306_pos, -1, rx1306_done
    eq rx1306_pos, -1, rx1306_fail
    jump $I10
  rx1306_done:
    rx1306_cur."!cursor_fail"()
    if_null rx1306_debug, debug_953
    rx1306_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_953:
    .return (rx1306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("94_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1312, "ResizablePMCArray"
    push $P1312, "use"
    .return ($P1312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("95_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1314_tgt
    .local int rx1314_pos
    .local int rx1314_off
    .local int rx1314_eos
    .local int rx1314_rep
    .local pmc rx1314_cur
    .local pmc rx1314_debug
    (rx1314_cur, rx1314_pos, rx1314_tgt, $I10) = self."!cursor_start"()
    rx1314_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1314_cur
    .local pmc match
    .lex "$/", match
    length rx1314_eos, rx1314_tgt
    gt rx1314_pos, rx1314_eos, rx1314_done
    set rx1314_off, 0
    lt rx1314_pos, 2, rx1314_start
    sub rx1314_off, rx1314_pos, 1
    substr rx1314_tgt, rx1314_tgt, rx1314_off
  rx1314_start:
    eq $I10, 1, rx1314_restart
    if_null rx1314_debug, debug_954
    rx1314_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_954:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1315_done
    goto rxscan1315_scan
  rxscan1315_loop:
    (rx1314_pos) = rx1314_cur."from"()
    inc rx1314_pos
    rx1314_cur."!cursor_from"(rx1314_pos)
    ge rx1314_pos, rx1314_eos, rxscan1315_done
  rxscan1315_scan:
    set_addr $I10, rxscan1315_loop
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxscan1315_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1316_fail
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  # rx literal  "if"
    add $I11, rx1314_pos, 2
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    substr $S10, rx1314_tgt, $I11, 2
    ne $S10, "if", rx1314_fail
    add rx1314_pos, 2
    set_addr $I10, rxcap_1316_fail
    ($I12, $I11) = rx1314_cur."!mark_peek"($I10)
    rx1314_cur."!cursor_pos"($I11)
    ($P10) = rx1314_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1314_pos, "")
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1316_done
  rxcap_1316_fail:
    goto rx1314_fail
  rxcap_1316_done:
  # rx charclass s
    ge rx1314_pos, rx1314_eos, rx1314_fail
    sub $I10, rx1314_pos, rx1314_off
    is_cclass $I11, 32, rx1314_tgt, $I10
    unless $I11, rx1314_fail
    inc rx1314_pos
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
.annotate 'line', 615
  # rx subrule "xblock" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."xblock"()
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
.annotate 'line', 616
  # rx rxquantr1319 ** 0..*
    set_addr $I10, rxquantr1319_done
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxquantr1319_loop:
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1314_pos, 5
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    substr $S10, rx1314_tgt, $I11, 5
    ne $S10, "elsif", rx1314_fail
    add rx1314_pos, 5
  # rx charclass s
    ge rx1314_pos, rx1314_eos, rx1314_fail
    sub $I10, rx1314_pos, rx1314_off
    is_cclass $I11, 32, rx1314_tgt, $I10
    unless $I11, rx1314_fail
    inc rx1314_pos
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."xblock"()
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
    set_addr $I10, rxquantr1319_done
    (rx1314_rep) = rx1314_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1319_done
    rx1314_cur."!mark_push"(rx1314_rep, rx1314_pos, $I10)
    goto rxquantr1319_loop
  rxquantr1319_done:
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
.annotate 'line', 617
  # rx rxquantr1324 ** 0..1
    set_addr $I10, rxquantr1324_done
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxquantr1324_loop:
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1314_pos, 4
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    substr $S10, rx1314_tgt, $I11, 4
    ne $S10, "else", rx1314_fail
    add rx1314_pos, 4
  # rx charclass s
    ge rx1314_pos, rx1314_eos, rx1314_fail
    sub $I10, rx1314_pos, rx1314_off
    is_cclass $I11, 32, rx1314_tgt, $I10
    unless $I11, rx1314_fail
    inc rx1314_pos
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."pblock"()
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
    set_addr $I10, rxquantr1324_done
    (rx1314_rep) = rx1314_cur."!mark_commit"($I10)
  rxquantr1324_done:
  # rx subrule "ws" subtype=method negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."ws"()
    unless $P10, rx1314_fail
    rx1314_pos = $P10."pos"()
.annotate 'line', 613
  # rx pass
    rx1314_cur."!cursor_pass"(rx1314_pos, "statement_control:sym<if>")
    if_null rx1314_debug, debug_955
    rx1314_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1314_pos)
  debug_955:
    .return (rx1314_cur)
  rx1314_restart:
.annotate 'line', 422
    if_null rx1314_debug, debug_956
    rx1314_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_956:
  rx1314_fail:
    (rx1314_rep, rx1314_pos, $I10, $P10) = rx1314_cur."!mark_fail"(0)
    lt rx1314_pos, -1, rx1314_done
    eq rx1314_pos, -1, rx1314_fail
    jump $I10
  rx1314_done:
    rx1314_cur."!cursor_fail"()
    if_null rx1314_debug, debug_957
    rx1314_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_957:
    .return (rx1314_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("96_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1330, "ResizablePMCArray"
    push $P1330, "if"
    .return ($P1330)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("97_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1340 = "98_1304523757.895" 
    capture_lex $P1340
    .local string rx1332_tgt
    .local int rx1332_pos
    .local int rx1332_off
    .local int rx1332_eos
    .local int rx1332_rep
    .local pmc rx1332_cur
    .local pmc rx1332_debug
    (rx1332_cur, rx1332_pos, rx1332_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1332_cur
    .local pmc match
    .lex "$/", match
    length rx1332_eos, rx1332_tgt
    gt rx1332_pos, rx1332_eos, rx1332_done
    set rx1332_off, 0
    lt rx1332_pos, 2, rx1332_start
    sub rx1332_off, rx1332_pos, 1
    substr rx1332_tgt, rx1332_tgt, rx1332_off
  rx1332_start:
    eq $I10, 1, rx1332_restart
    if_null rx1332_debug, debug_958
    rx1332_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_958:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1333_done
    goto rxscan1333_scan
  rxscan1333_loop:
    (rx1332_pos) = rx1332_cur."from"()
    inc rx1332_pos
    rx1332_cur."!cursor_from"(rx1332_pos)
    ge rx1332_pos, rx1332_eos, rxscan1333_done
  rxscan1333_scan:
    set_addr $I10, rxscan1333_loop
    rx1332_cur."!mark_push"(0, rx1332_pos, $I10)
  rxscan1333_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1334_fail
    rx1332_cur."!mark_push"(0, rx1332_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1332_pos, 6
    gt $I11, rx1332_eos, rx1332_fail
    sub $I11, rx1332_pos, rx1332_off
    substr $S10, rx1332_tgt, $I11, 6
    ne $S10, "unless", rx1332_fail
    add rx1332_pos, 6
    set_addr $I10, rxcap_1334_fail
    ($I12, $I11) = rx1332_cur."!mark_peek"($I10)
    rx1332_cur."!cursor_pos"($I11)
    ($P10) = rx1332_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1332_pos, "")
    rx1332_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1334_done
  rxcap_1334_fail:
    goto rx1332_fail
  rxcap_1334_done:
  # rx charclass s
    ge rx1332_pos, rx1332_eos, rx1332_fail
    sub $I10, rx1332_pos, rx1332_off
    is_cclass $I11, 32, rx1332_tgt, $I10
    unless $I11, rx1332_fail
    inc rx1332_pos
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
.annotate 'line', 622
  # rx subrule "xblock" subtype=capture negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."xblock"()
    unless $P10, rx1332_fail
    rx1332_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1332_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
  alt1337_0:
.annotate 'line', 623
    set_addr $I10, alt1337_1
    rx1332_cur."!mark_push"(0, rx1332_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1332_cur."!cursor_pos"(rx1332_pos)
    .const 'Sub' $P1340 = "98_1304523757.895" 
    capture_lex $P1340
    $P10 = rx1332_cur."before"($P1340)
    if $P10, rx1332_fail
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
    goto alt1337_end
  alt1337_1:
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
  alt1337_end:
  # rx subrule "ws" subtype=method negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."ws"()
    unless $P10, rx1332_fail
    rx1332_pos = $P10."pos"()
.annotate 'line', 620
  # rx pass
    rx1332_cur."!cursor_pass"(rx1332_pos, "statement_control:sym<unless>")
    if_null rx1332_debug, debug_963
    rx1332_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1332_pos)
  debug_963:
    .return (rx1332_cur)
  rx1332_restart:
.annotate 'line', 422
    if_null rx1332_debug, debug_964
    rx1332_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_964:
  rx1332_fail:
    (rx1332_rep, rx1332_pos, $I10, $P10) = rx1332_cur."!mark_fail"(0)
    lt rx1332_pos, -1, rx1332_done
    eq rx1332_pos, -1, rx1332_fail
    jump $I10
  rx1332_done:
    rx1332_cur."!cursor_fail"()
    if_null rx1332_debug, debug_965
    rx1332_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_965:
    .return (rx1332_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1339"  :anon :subid("98_1304523757.895") :method :outer("97_1304523757.895")
.annotate 'line', 623
    .local string rx1341_tgt
    .local int rx1341_pos
    .local int rx1341_off
    .local int rx1341_eos
    .local int rx1341_rep
    .local pmc rx1341_cur
    .local pmc rx1341_debug
    (rx1341_cur, rx1341_pos, rx1341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1341_cur
    .local pmc match
    .lex "$/", match
    length rx1341_eos, rx1341_tgt
    gt rx1341_pos, rx1341_eos, rx1341_done
    set rx1341_off, 0
    lt rx1341_pos, 2, rx1341_start
    sub rx1341_off, rx1341_pos, 1
    substr rx1341_tgt, rx1341_tgt, rx1341_off
  rx1341_start:
    eq $I10, 1, rx1341_restart
    if_null rx1341_debug, debug_959
    rx1341_cur."!cursor_debug"("START", "")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1341_pos) = rx1341_cur."from"()
    inc rx1341_pos
    rx1341_cur."!cursor_from"(rx1341_pos)
    ge rx1341_pos, rx1341_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  rxscan1342_done:
  # rx literal  "else"
    add $I11, rx1341_pos, 4
    gt $I11, rx1341_eos, rx1341_fail
    sub $I11, rx1341_pos, rx1341_off
    substr $S10, rx1341_tgt, $I11, 4
    ne $S10, "else", rx1341_fail
    add rx1341_pos, 4
  # rx pass
    rx1341_cur."!cursor_pass"(rx1341_pos, "")
    if_null rx1341_debug, debug_960
    rx1341_cur."!cursor_debug"("PASS", "", " at pos=", rx1341_pos)
  debug_960:
    .return (rx1341_cur)
  rx1341_restart:
    if_null rx1341_debug, debug_961
    rx1341_cur."!cursor_debug"("NEXT", "")
  debug_961:
  rx1341_fail:
    (rx1341_rep, rx1341_pos, $I10, $P10) = rx1341_cur."!mark_fail"(0)
    lt rx1341_pos, -1, rx1341_done
    eq rx1341_pos, -1, rx1341_fail
    jump $I10
  rx1341_done:
    rx1341_cur."!cursor_fail"()
    if_null rx1341_debug, debug_962
    rx1341_cur."!cursor_debug"("FAIL", "")
  debug_962:
    .return (rx1341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("99_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1348, "ResizablePMCArray"
    push $P1348, "unless"
    .return ($P1348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("100_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1350_tgt
    .local int rx1350_pos
    .local int rx1350_off
    .local int rx1350_eos
    .local int rx1350_rep
    .local pmc rx1350_cur
    .local pmc rx1350_debug
    (rx1350_cur, rx1350_pos, rx1350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1350_cur
    .local pmc match
    .lex "$/", match
    length rx1350_eos, rx1350_tgt
    gt rx1350_pos, rx1350_eos, rx1350_done
    set rx1350_off, 0
    lt rx1350_pos, 2, rx1350_start
    sub rx1350_off, rx1350_pos, 1
    substr rx1350_tgt, rx1350_tgt, rx1350_off
  rx1350_start:
    eq $I10, 1, rx1350_restart
    if_null rx1350_debug, debug_966
    rx1350_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_966:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1351_done
    goto rxscan1351_scan
  rxscan1351_loop:
    (rx1350_pos) = rx1350_cur."from"()
    inc rx1350_pos
    rx1350_cur."!cursor_from"(rx1350_pos)
    ge rx1350_pos, rx1350_eos, rxscan1351_done
  rxscan1351_scan:
    set_addr $I10, rxscan1351_loop
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  rxscan1351_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1353_fail
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  alt1352_0:
    set_addr $I10, alt1352_1
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  # rx literal  "while"
    add $I11, rx1350_pos, 5
    gt $I11, rx1350_eos, rx1350_fail
    sub $I11, rx1350_pos, rx1350_off
    substr $S10, rx1350_tgt, $I11, 5
    ne $S10, "while", rx1350_fail
    add rx1350_pos, 5
    goto alt1352_end
  alt1352_1:
  # rx literal  "until"
    add $I11, rx1350_pos, 5
    gt $I11, rx1350_eos, rx1350_fail
    sub $I11, rx1350_pos, rx1350_off
    substr $S10, rx1350_tgt, $I11, 5
    ne $S10, "until", rx1350_fail
    add rx1350_pos, 5
  alt1352_end:
    set_addr $I10, rxcap_1353_fail
    ($I12, $I11) = rx1350_cur."!mark_peek"($I10)
    rx1350_cur."!cursor_pos"($I11)
    ($P10) = rx1350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1350_pos, "")
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1353_done
  rxcap_1353_fail:
    goto rx1350_fail
  rxcap_1353_done:
  # rx charclass s
    ge rx1350_pos, rx1350_eos, rx1350_fail
    sub $I10, rx1350_pos, rx1350_off
    is_cclass $I11, 32, rx1350_tgt, $I10
    unless $I11, rx1350_fail
    inc rx1350_pos
  # rx subrule "ws" subtype=method negate=
    rx1350_cur."!cursor_pos"(rx1350_pos)
    $P10 = rx1350_cur."ws"()
    unless $P10, rx1350_fail
    rx1350_pos = $P10."pos"()
.annotate 'line', 628
  # rx subrule "xblock" subtype=capture negate=
    rx1350_cur."!cursor_pos"(rx1350_pos)
    $P10 = rx1350_cur."xblock"()
    unless $P10, rx1350_fail
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1350_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1350_cur."!cursor_pos"(rx1350_pos)
    $P10 = rx1350_cur."ws"()
    unless $P10, rx1350_fail
    rx1350_pos = $P10."pos"()
.annotate 'line', 626
  # rx pass
    rx1350_cur."!cursor_pass"(rx1350_pos, "statement_control:sym<while>")
    if_null rx1350_debug, debug_967
    rx1350_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1350_pos)
  debug_967:
    .return (rx1350_cur)
  rx1350_restart:
.annotate 'line', 422
    if_null rx1350_debug, debug_968
    rx1350_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_968:
  rx1350_fail:
    (rx1350_rep, rx1350_pos, $I10, $P10) = rx1350_cur."!mark_fail"(0)
    lt rx1350_pos, -1, rx1350_done
    eq rx1350_pos, -1, rx1350_fail
    jump $I10
  rx1350_done:
    rx1350_cur."!cursor_fail"()
    if_null rx1350_debug, debug_969
    rx1350_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_969:
    .return (rx1350_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("101_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1357, "ResizablePMCArray"
    push $P1357, "until"
    push $P1357, "while"
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("102_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_970
    rx1359_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_970:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1360_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1361_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1359_pos, 6
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 6
    ne $S10, "repeat", rx1359_fail
    add rx1359_pos, 6
    set_addr $I10, rxcap_1361_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1361_done
  rxcap_1361_fail:
    goto rx1359_fail
  rxcap_1361_done:
  # rx charclass s
    ge rx1359_pos, rx1359_eos, rx1359_fail
    sub $I10, rx1359_pos, rx1359_off
    is_cclass $I11, 32, rx1359_tgt, $I10
    unless $I11, rx1359_fail
    inc rx1359_pos
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  alt1363_0:
.annotate 'line', 633
    set_addr $I10, alt1363_1
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
.annotate 'line', 634
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1366_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  alt1365_0:
    set_addr $I10, alt1365_1
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "while"
    add $I11, rx1359_pos, 5
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 5
    ne $S10, "while", rx1359_fail
    add rx1359_pos, 5
    goto alt1365_end
  alt1365_1:
  # rx literal  "until"
    add $I11, rx1359_pos, 5
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 5
    ne $S10, "until", rx1359_fail
    add rx1359_pos, 5
  alt1365_end:
    set_addr $I10, rxcap_1366_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1366_done
  rxcap_1366_fail:
    goto rx1359_fail
  rxcap_1366_done:
  # rx charclass s
    ge rx1359_pos, rx1359_eos, rx1359_fail
    sub $I10, rx1359_pos, rx1359_off
    is_cclass $I11, 32, rx1359_tgt, $I10
    unless $I11, rx1359_fail
    inc rx1359_pos
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."xblock"()
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1359_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
    goto alt1363_end
  alt1363_1:
.annotate 'line', 635
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."pblock"()
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1359_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1372_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  alt1371_0:
    set_addr $I10, alt1371_1
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "while"
    add $I11, rx1359_pos, 5
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 5
    ne $S10, "while", rx1359_fail
    add rx1359_pos, 5
    goto alt1371_end
  alt1371_1:
  # rx literal  "until"
    add $I11, rx1359_pos, 5
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 5
    ne $S10, "until", rx1359_fail
    add rx1359_pos, 5
  alt1371_end:
    set_addr $I10, rxcap_1372_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1372_done
  rxcap_1372_fail:
    goto rx1359_fail
  rxcap_1372_done:
  # rx charclass s
    ge rx1359_pos, rx1359_eos, rx1359_fail
    sub $I10, rx1359_pos, rx1359_off
    is_cclass $I11, 32, rx1359_tgt, $I10
    unless $I11, rx1359_fail
    inc rx1359_pos
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."EXPR"()
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1359_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
  alt1363_end:
.annotate 'line', 636
  # rx subrule "ws" subtype=method negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."ws"()
    unless $P10, rx1359_fail
    rx1359_pos = $P10."pos"()
.annotate 'line', 631
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "statement_control:sym<repeat>")
    if_null rx1359_debug, debug_971
    rx1359_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1359_pos)
  debug_971:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 422
    if_null rx1359_debug, debug_972
    rx1359_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_972:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_973
    rx1359_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_973:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("103_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1377, "ResizablePMCArray"
    push $P1377, "repeat"
    .return ($P1377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("104_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1379_tgt
    .local int rx1379_pos
    .local int rx1379_off
    .local int rx1379_eos
    .local int rx1379_rep
    .local pmc rx1379_cur
    .local pmc rx1379_debug
    (rx1379_cur, rx1379_pos, rx1379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1379_cur
    .local pmc match
    .lex "$/", match
    length rx1379_eos, rx1379_tgt
    gt rx1379_pos, rx1379_eos, rx1379_done
    set rx1379_off, 0
    lt rx1379_pos, 2, rx1379_start
    sub rx1379_off, rx1379_pos, 1
    substr rx1379_tgt, rx1379_tgt, rx1379_off
  rx1379_start:
    eq $I10, 1, rx1379_restart
    if_null rx1379_debug, debug_974
    rx1379_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1380_done
    goto rxscan1380_scan
  rxscan1380_loop:
    (rx1379_pos) = rx1379_cur."from"()
    inc rx1379_pos
    rx1379_cur."!cursor_from"(rx1379_pos)
    ge rx1379_pos, rx1379_eos, rxscan1380_done
  rxscan1380_scan:
    set_addr $I10, rxscan1380_loop
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxscan1380_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1381_fail
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  # rx literal  "for"
    add $I11, rx1379_pos, 3
    gt $I11, rx1379_eos, rx1379_fail
    sub $I11, rx1379_pos, rx1379_off
    substr $S10, rx1379_tgt, $I11, 3
    ne $S10, "for", rx1379_fail
    add rx1379_pos, 3
    set_addr $I10, rxcap_1381_fail
    ($I12, $I11) = rx1379_cur."!mark_peek"($I10)
    rx1379_cur."!cursor_pos"($I11)
    ($P10) = rx1379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1379_pos, "")
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1381_done
  rxcap_1381_fail:
    goto rx1379_fail
  rxcap_1381_done:
  # rx charclass s
    ge rx1379_pos, rx1379_eos, rx1379_fail
    sub $I10, rx1379_pos, rx1379_off
    is_cclass $I11, 32, rx1379_tgt, $I10
    unless $I11, rx1379_fail
    inc rx1379_pos
  # rx subrule "ws" subtype=method negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."ws"()
    unless $P10, rx1379_fail
    rx1379_pos = $P10."pos"()
.annotate 'line', 641
  # rx subrule "xblock" subtype=capture negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."xblock"()
    unless $P10, rx1379_fail
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1379_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."ws"()
    unless $P10, rx1379_fail
    rx1379_pos = $P10."pos"()
.annotate 'line', 639
  # rx pass
    rx1379_cur."!cursor_pass"(rx1379_pos, "statement_control:sym<for>")
    if_null rx1379_debug, debug_975
    rx1379_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1379_pos)
  debug_975:
    .return (rx1379_cur)
  rx1379_restart:
.annotate 'line', 422
    if_null rx1379_debug, debug_976
    rx1379_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_976:
  rx1379_fail:
    (rx1379_rep, rx1379_pos, $I10, $P10) = rx1379_cur."!mark_fail"(0)
    lt rx1379_pos, -1, rx1379_done
    eq rx1379_pos, -1, rx1379_fail
    jump $I10
  rx1379_done:
    rx1379_cur."!cursor_fail"()
    if_null rx1379_debug, debug_977
    rx1379_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_977:
    .return (rx1379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("105_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1385, "ResizablePMCArray"
    push $P1385, "for"
    .return ($P1385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("106_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_978
    rx1387_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1388_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1387_pos, 5
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    substr $S10, rx1387_tgt, $I11, 5
    ne $S10, "CATCH", rx1387_fail
    add rx1387_pos, 5
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1387_cur."!mark_peek"($I10)
    rx1387_cur."!cursor_pos"($I11)
    ($P10) = rx1387_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1387_pos, "")
    rx1387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1387_fail
  rxcap_1389_done:
  # rx charclass s
    ge rx1387_pos, rx1387_eos, rx1387_fail
    sub $I10, rx1387_pos, rx1387_off
    is_cclass $I11, 32, rx1387_tgt, $I10
    unless $I11, rx1387_fail
    inc rx1387_pos
  # rx subrule "ws" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ws"()
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
.annotate 'line', 646
  # rx subrule "block" subtype=capture negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."block"()
    unless $P10, rx1387_fail
    rx1387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1387_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ws"()
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
.annotate 'line', 644
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "statement_control:sym<CATCH>")
    if_null rx1387_debug, debug_979
    rx1387_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1387_pos)
  debug_979:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 422
    if_null rx1387_debug, debug_980
    rx1387_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_980:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_981
    rx1387_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_981:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("107_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1393, "ResizablePMCArray"
    push $P1393, "CATCH"
    .return ($P1393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("108_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1395_tgt
    .local int rx1395_pos
    .local int rx1395_off
    .local int rx1395_eos
    .local int rx1395_rep
    .local pmc rx1395_cur
    .local pmc rx1395_debug
    (rx1395_cur, rx1395_pos, rx1395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1395_cur
    .local pmc match
    .lex "$/", match
    length rx1395_eos, rx1395_tgt
    gt rx1395_pos, rx1395_eos, rx1395_done
    set rx1395_off, 0
    lt rx1395_pos, 2, rx1395_start
    sub rx1395_off, rx1395_pos, 1
    substr rx1395_tgt, rx1395_tgt, rx1395_off
  rx1395_start:
    eq $I10, 1, rx1395_restart
    if_null rx1395_debug, debug_982
    rx1395_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1395_pos) = rx1395_cur."from"()
    inc rx1395_pos
    rx1395_cur."!cursor_from"(rx1395_pos)
    ge rx1395_pos, rx1395_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  rxscan1396_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1397_fail
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1395_pos, 7
    gt $I11, rx1395_eos, rx1395_fail
    sub $I11, rx1395_pos, rx1395_off
    substr $S10, rx1395_tgt, $I11, 7
    ne $S10, "CONTROL", rx1395_fail
    add rx1395_pos, 7
    set_addr $I10, rxcap_1397_fail
    ($I12, $I11) = rx1395_cur."!mark_peek"($I10)
    rx1395_cur."!cursor_pos"($I11)
    ($P10) = rx1395_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1395_pos, "")
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1397_done
  rxcap_1397_fail:
    goto rx1395_fail
  rxcap_1397_done:
  # rx charclass s
    ge rx1395_pos, rx1395_eos, rx1395_fail
    sub $I10, rx1395_pos, rx1395_off
    is_cclass $I11, 32, rx1395_tgt, $I10
    unless $I11, rx1395_fail
    inc rx1395_pos
  # rx subrule "ws" subtype=method negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."ws"()
    unless $P10, rx1395_fail
    rx1395_pos = $P10."pos"()
.annotate 'line', 651
  # rx subrule "block" subtype=capture negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."block"()
    unless $P10, rx1395_fail
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1395_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."ws"()
    unless $P10, rx1395_fail
    rx1395_pos = $P10."pos"()
.annotate 'line', 649
  # rx pass
    rx1395_cur."!cursor_pass"(rx1395_pos, "statement_control:sym<CONTROL>")
    if_null rx1395_debug, debug_983
    rx1395_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1395_pos)
  debug_983:
    .return (rx1395_cur)
  rx1395_restart:
.annotate 'line', 422
    if_null rx1395_debug, debug_984
    rx1395_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_984:
  rx1395_fail:
    (rx1395_rep, rx1395_pos, $I10, $P10) = rx1395_cur."!mark_fail"(0)
    lt rx1395_pos, -1, rx1395_done
    eq rx1395_pos, -1, rx1395_fail
    jump $I10
  rx1395_done:
    rx1395_cur."!cursor_fail"()
    if_null rx1395_debug, debug_985
    rx1395_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_985:
    .return (rx1395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("109_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1401, "ResizablePMCArray"
    push $P1401, "CONTROL"
    .return ($P1401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("110_1304523757.895")
    .param pmc param_1403
.annotate 'line', 654
    .lex "self", param_1403
    $P1404 = param_1403."!protoregex"("statement_prefix")
    .return ($P1404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("111_1304523757.895")
    .param pmc param_1406
.annotate 'line', 654
    .lex "self", param_1406
    $P1407 = param_1406."!PREFIX__!protoregex"("statement_prefix")
    .return ($P1407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("112_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_986
    rx1409_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1410_done
    goto rxscan1410_scan
  rxscan1410_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1410_done
  rxscan1410_scan:
    set_addr $I10, rxscan1410_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1410_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1411_fail
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1409_pos, 4
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    substr $S10, rx1409_tgt, $I11, 4
    ne $S10, "INIT", rx1409_fail
    add rx1409_pos, 4
    set_addr $I10, rxcap_1411_fail
    ($I12, $I11) = rx1409_cur."!mark_peek"($I10)
    rx1409_cur."!cursor_pos"($I11)
    ($P10) = rx1409_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1409_pos, "")
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1411_done
  rxcap_1411_fail:
    goto rx1409_fail
  rxcap_1411_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."blorst"()
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1409_pos = $P10."pos"()
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "statement_prefix:sym<INIT>")
    if_null rx1409_debug, debug_987
    rx1409_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1409_pos)
  debug_987:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 422
    if_null rx1409_debug, debug_988
    rx1409_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_988:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_989
    rx1409_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_989:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("113_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1413 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P1414, "ResizablePMCArray"
    push $P1414, $P1413
    .return ($P1414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("114_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_990
    rx1416_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1417_done
    goto rxscan1417_scan
  rxscan1417_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1417_done
  rxscan1417_scan:
    set_addr $I10, rxscan1417_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1417_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1418_fail
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  # rx literal  "try"
    add $I11, rx1416_pos, 3
    gt $I11, rx1416_eos, rx1416_fail
    sub $I11, rx1416_pos, rx1416_off
    substr $S10, rx1416_tgt, $I11, 3
    ne $S10, "try", rx1416_fail
    add rx1416_pos, 3
    set_addr $I10, rxcap_1418_fail
    ($I12, $I11) = rx1416_cur."!mark_peek"($I10)
    rx1416_cur."!cursor_pos"($I11)
    ($P10) = rx1416_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1416_pos, "")
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1418_done
  rxcap_1418_fail:
    goto rx1416_fail
  rxcap_1418_done:
.annotate 'line', 659
  # rx subrule "blorst" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."blorst"()
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1416_pos = $P10."pos"()
.annotate 'line', 657
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "statement_prefix:sym<try>")
    if_null rx1416_debug, debug_991
    rx1416_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1416_pos)
  debug_991:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 422
    if_null rx1416_debug, debug_992
    rx1416_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_992:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_993
    rx1416_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_993:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("115_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1420 = self."!PREFIX__!subrule"("blorst", "try")
    new $P1421, "ResizablePMCArray"
    push $P1421, $P1420
    .return ($P1421)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("116_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1423_tgt
    .local int rx1423_pos
    .local int rx1423_off
    .local int rx1423_eos
    .local int rx1423_rep
    .local pmc rx1423_cur
    .local pmc rx1423_debug
    (rx1423_cur, rx1423_pos, rx1423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1423_cur
    .local pmc match
    .lex "$/", match
    length rx1423_eos, rx1423_tgt
    gt rx1423_pos, rx1423_eos, rx1423_done
    set rx1423_off, 0
    lt rx1423_pos, 2, rx1423_start
    sub rx1423_off, rx1423_pos, 1
    substr rx1423_tgt, rx1423_tgt, rx1423_off
  rx1423_start:
    eq $I10, 1, rx1423_restart
    if_null rx1423_debug, debug_994
    rx1423_cur."!cursor_debug"("START", "blorst")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1424_done
    goto rxscan1424_scan
  rxscan1424_loop:
    (rx1423_pos) = rx1423_cur."from"()
    inc rx1423_pos
    rx1423_cur."!cursor_from"(rx1423_pos)
    ge rx1423_pos, rx1423_eos, rxscan1424_done
  rxscan1424_scan:
    set_addr $I10, rxscan1424_loop
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  rxscan1424_done:
.annotate 'line', 663
  # rx charclass s
    ge rx1423_pos, rx1423_eos, rx1423_fail
    sub $I10, rx1423_pos, rx1423_off
    is_cclass $I11, 32, rx1423_tgt, $I10
    unless $I11, rx1423_fail
    inc rx1423_pos
  # rx subrule "ws" subtype=method negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."ws"()
    unless $P10, rx1423_fail
    rx1423_pos = $P10."pos"()
  alt1425_0:
    set_addr $I10, alt1425_1
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1423_pos, rx1423_off
    substr $S10, rx1423_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1423_fail
  # rx subrule "block" subtype=capture negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."block"()
    unless $P10, rx1423_fail
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1423_pos = $P10."pos"()
    goto alt1425_end
  alt1425_1:
  # rx subrule "statement" subtype=capture negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."statement"()
    unless $P10, rx1423_fail
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1423_pos = $P10."pos"()
  alt1425_end:
.annotate 'line', 662
  # rx pass
    rx1423_cur."!cursor_pass"(rx1423_pos, "blorst")
    if_null rx1423_debug, debug_995
    rx1423_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1423_pos)
  debug_995:
    .return (rx1423_cur)
  rx1423_restart:
.annotate 'line', 422
    if_null rx1423_debug, debug_996
    rx1423_cur."!cursor_debug"("NEXT", "blorst")
  debug_996:
  rx1423_fail:
    (rx1423_rep, rx1423_pos, $I10, $P10) = rx1423_cur."!mark_fail"(0)
    lt rx1423_pos, -1, rx1423_done
    eq rx1423_pos, -1, rx1423_fail
    jump $I10
  rx1423_done:
    rx1423_cur."!cursor_fail"()
    if_null rx1423_debug, debug_997
    rx1423_cur."!cursor_debug"("FAIL", "blorst")
  debug_997:
    .return (rx1423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("117_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1427, "ResizablePMCArray"
    push $P1427, ""
    .return ($P1427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("118_1304523757.895")
    .param pmc param_1429
.annotate 'line', 668
    .lex "self", param_1429
    $P1430 = param_1429."!protoregex"("statement_mod_cond")
    .return ($P1430)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("119_1304523757.895")
    .param pmc param_1432
.annotate 'line', 668
    .lex "self", param_1432
    $P1433 = param_1432."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("120_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_998
    rx1435_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1436_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx literal  "if"
    add $I11, rx1435_pos, 2
    gt $I11, rx1435_eos, rx1435_fail
    sub $I11, rx1435_pos, rx1435_off
    substr $S10, rx1435_tgt, $I11, 2
    ne $S10, "if", rx1435_fail
    add rx1435_pos, 2
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1435_cur."!mark_peek"($I10)
    rx1435_cur."!cursor_pos"($I11)
    ($P10) = rx1435_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1435_pos, "")
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1435_fail
  rxcap_1437_done:
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."EXPR"()
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1435_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "statement_mod_cond:sym<if>")
    if_null rx1435_debug, debug_999
    rx1435_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1435_pos)
  debug_999:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 422
    if_null rx1435_debug, debug_1000
    rx1435_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1000:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1001
    rx1435_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1001:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("121_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1441 = self."!PREFIX__!subrule"("ws", "if")
    new $P1442, "ResizablePMCArray"
    push $P1442, $P1441
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("122_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1002
    rx1444_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1445_done
    goto rxscan1445_scan
  rxscan1445_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1445_done
  rxscan1445_scan:
    set_addr $I10, rxscan1445_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1445_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1446_fail
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1444_pos, 6
    gt $I11, rx1444_eos, rx1444_fail
    sub $I11, rx1444_pos, rx1444_off
    substr $S10, rx1444_tgt, $I11, 6
    ne $S10, "unless", rx1444_fail
    add rx1444_pos, 6
    set_addr $I10, rxcap_1446_fail
    ($I12, $I11) = rx1444_cur."!mark_peek"($I10)
    rx1444_cur."!cursor_pos"($I11)
    ($P10) = rx1444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1444_pos, "")
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1446_done
  rxcap_1446_fail:
    goto rx1444_fail
  rxcap_1446_done:
  # rx subrule "ws" subtype=method negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."ws"()
    unless $P10, rx1444_fail
    rx1444_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."EXPR"()
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1444_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."ws"()
    unless $P10, rx1444_fail
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "statement_mod_cond:sym<unless>")
    if_null rx1444_debug, debug_1003
    rx1444_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1444_pos)
  debug_1003:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 422
    if_null rx1444_debug, debug_1004
    rx1444_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1004:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1005
    rx1444_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1005:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("123_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1450 = self."!PREFIX__!subrule"("ws", "unless")
    new $P1451, "ResizablePMCArray"
    push $P1451, $P1450
    .return ($P1451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("124_1304523757.895")
    .param pmc param_1453
.annotate 'line', 673
    .lex "self", param_1453
    $P1454 = param_1453."!protoregex"("statement_mod_loop")
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("125_1304523757.895")
    .param pmc param_1456
.annotate 'line', 673
    .lex "self", param_1456
    $P1457 = param_1456."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("126_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1459_tgt
    .local int rx1459_pos
    .local int rx1459_off
    .local int rx1459_eos
    .local int rx1459_rep
    .local pmc rx1459_cur
    .local pmc rx1459_debug
    (rx1459_cur, rx1459_pos, rx1459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1459_cur
    .local pmc match
    .lex "$/", match
    length rx1459_eos, rx1459_tgt
    gt rx1459_pos, rx1459_eos, rx1459_done
    set rx1459_off, 0
    lt rx1459_pos, 2, rx1459_start
    sub rx1459_off, rx1459_pos, 1
    substr rx1459_tgt, rx1459_tgt, rx1459_off
  rx1459_start:
    eq $I10, 1, rx1459_restart
    if_null rx1459_debug, debug_1006
    rx1459_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1006:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1460_done
    goto rxscan1460_scan
  rxscan1460_loop:
    (rx1459_pos) = rx1459_cur."from"()
    inc rx1459_pos
    rx1459_cur."!cursor_from"(rx1459_pos)
    ge rx1459_pos, rx1459_eos, rxscan1460_done
  rxscan1460_scan:
    set_addr $I10, rxscan1460_loop
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  rxscan1460_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1461_fail
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  # rx literal  "while"
    add $I11, rx1459_pos, 5
    gt $I11, rx1459_eos, rx1459_fail
    sub $I11, rx1459_pos, rx1459_off
    substr $S10, rx1459_tgt, $I11, 5
    ne $S10, "while", rx1459_fail
    add rx1459_pos, 5
    set_addr $I10, rxcap_1461_fail
    ($I12, $I11) = rx1459_cur."!mark_peek"($I10)
    rx1459_cur."!cursor_pos"($I11)
    ($P10) = rx1459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1459_pos, "")
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1461_done
  rxcap_1461_fail:
    goto rx1459_fail
  rxcap_1461_done:
  # rx subrule "ws" subtype=method negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."ws"()
    unless $P10, rx1459_fail
    rx1459_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."EXPR"()
    unless $P10, rx1459_fail
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1459_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."ws"()
    unless $P10, rx1459_fail
    rx1459_pos = $P10."pos"()
  # rx pass
    rx1459_cur."!cursor_pass"(rx1459_pos, "statement_mod_loop:sym<while>")
    if_null rx1459_debug, debug_1007
    rx1459_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1459_pos)
  debug_1007:
    .return (rx1459_cur)
  rx1459_restart:
.annotate 'line', 422
    if_null rx1459_debug, debug_1008
    rx1459_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1008:
  rx1459_fail:
    (rx1459_rep, rx1459_pos, $I10, $P10) = rx1459_cur."!mark_fail"(0)
    lt rx1459_pos, -1, rx1459_done
    eq rx1459_pos, -1, rx1459_fail
    jump $I10
  rx1459_done:
    rx1459_cur."!cursor_fail"()
    if_null rx1459_debug, debug_1009
    rx1459_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1009:
    .return (rx1459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("127_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1465 = self."!PREFIX__!subrule"("ws", "while")
    new $P1466, "ResizablePMCArray"
    push $P1466, $P1465
    .return ($P1466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("128_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1010
    rx1468_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1469_done
    goto rxscan1469_scan
  rxscan1469_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1469_done
  rxscan1469_scan:
    set_addr $I10, rxscan1469_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1469_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1470_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "until"
    add $I11, rx1468_pos, 5
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I11, 5
    ne $S10, "until", rx1468_fail
    add rx1468_pos, 5
    set_addr $I10, rxcap_1470_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1470_done
  rxcap_1470_fail:
    goto rx1468_fail
  rxcap_1470_done:
  # rx subrule "ws" subtype=method negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."ws"()
    unless $P10, rx1468_fail
    rx1468_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."EXPR"()
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1468_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."ws"()
    unless $P10, rx1468_fail
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "statement_mod_loop:sym<until>")
    if_null rx1468_debug, debug_1011
    rx1468_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1468_pos)
  debug_1011:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 422
    if_null rx1468_debug, debug_1012
    rx1468_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1012:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1013
    rx1468_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1013:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("129_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1474 = self."!PREFIX__!subrule"("ws", "until")
    new $P1475, "ResizablePMCArray"
    push $P1475, $P1474
    .return ($P1475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("130_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1477_tgt
    .local int rx1477_pos
    .local int rx1477_off
    .local int rx1477_eos
    .local int rx1477_rep
    .local pmc rx1477_cur
    .local pmc rx1477_debug
    (rx1477_cur, rx1477_pos, rx1477_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1477_cur
    .local pmc match
    .lex "$/", match
    length rx1477_eos, rx1477_tgt
    gt rx1477_pos, rx1477_eos, rx1477_done
    set rx1477_off, 0
    lt rx1477_pos, 2, rx1477_start
    sub rx1477_off, rx1477_pos, 1
    substr rx1477_tgt, rx1477_tgt, rx1477_off
  rx1477_start:
    eq $I10, 1, rx1477_restart
    if_null rx1477_debug, debug_1014
    rx1477_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1478_done
    goto rxscan1478_scan
  rxscan1478_loop:
    (rx1477_pos) = rx1477_cur."from"()
    inc rx1477_pos
    rx1477_cur."!cursor_from"(rx1477_pos)
    ge rx1477_pos, rx1477_eos, rxscan1478_done
  rxscan1478_scan:
    set_addr $I10, rxscan1478_loop
    rx1477_cur."!mark_push"(0, rx1477_pos, $I10)
  rxscan1478_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1479_fail
    rx1477_cur."!mark_push"(0, rx1477_pos, $I10)
  # rx literal  "for"
    add $I11, rx1477_pos, 3
    gt $I11, rx1477_eos, rx1477_fail
    sub $I11, rx1477_pos, rx1477_off
    substr $S10, rx1477_tgt, $I11, 3
    ne $S10, "for", rx1477_fail
    add rx1477_pos, 3
    set_addr $I10, rxcap_1479_fail
    ($I12, $I11) = rx1477_cur."!mark_peek"($I10)
    rx1477_cur."!cursor_pos"($I11)
    ($P10) = rx1477_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1477_pos, "")
    rx1477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1479_done
  rxcap_1479_fail:
    goto rx1477_fail
  rxcap_1479_done:
  # rx subrule "ws" subtype=method negate=
    rx1477_cur."!cursor_pos"(rx1477_pos)
    $P10 = rx1477_cur."ws"()
    unless $P10, rx1477_fail
    rx1477_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1477_cur."!cursor_pos"(rx1477_pos)
    $P10 = rx1477_cur."EXPR"()
    unless $P10, rx1477_fail
    rx1477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1477_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1477_cur."!cursor_pos"(rx1477_pos)
    $P10 = rx1477_cur."ws"()
    unless $P10, rx1477_fail
    rx1477_pos = $P10."pos"()
  # rx pass
    rx1477_cur."!cursor_pass"(rx1477_pos, "statement_mod_loop:sym<for>")
    if_null rx1477_debug, debug_1015
    rx1477_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1477_pos)
  debug_1015:
    .return (rx1477_cur)
  rx1477_restart:
.annotate 'line', 422
    if_null rx1477_debug, debug_1016
    rx1477_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1016:
  rx1477_fail:
    (rx1477_rep, rx1477_pos, $I10, $P10) = rx1477_cur."!mark_fail"(0)
    lt rx1477_pos, -1, rx1477_done
    eq rx1477_pos, -1, rx1477_fail
    jump $I10
  rx1477_done:
    rx1477_cur."!cursor_fail"()
    if_null rx1477_debug, debug_1017
    rx1477_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1017:
    .return (rx1477_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("131_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1483 = self."!PREFIX__!subrule"("ws", "for")
    new $P1484, "ResizablePMCArray"
    push $P1484, $P1483
    .return ($P1484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("132_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1018
    rx1486_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1487_done:
.annotate 'line', 681
  # rx subrule "fatarrow" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."fatarrow"()
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "term:sym<fatarrow>")
    if_null rx1486_debug, debug_1019
    rx1486_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1486_pos)
  debug_1019:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 422
    if_null rx1486_debug, debug_1020
    rx1486_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1020:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1021
    rx1486_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1021:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("133_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1489 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("134_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1492_tgt
    .local int rx1492_pos
    .local int rx1492_off
    .local int rx1492_eos
    .local int rx1492_rep
    .local pmc rx1492_cur
    .local pmc rx1492_debug
    (rx1492_cur, rx1492_pos, rx1492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1492_cur
    .local pmc match
    .lex "$/", match
    length rx1492_eos, rx1492_tgt
    gt rx1492_pos, rx1492_eos, rx1492_done
    set rx1492_off, 0
    lt rx1492_pos, 2, rx1492_start
    sub rx1492_off, rx1492_pos, 1
    substr rx1492_tgt, rx1492_tgt, rx1492_off
  rx1492_start:
    eq $I10, 1, rx1492_restart
    if_null rx1492_debug, debug_1022
    rx1492_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1022:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1492_pos) = rx1492_cur."from"()
    inc rx1492_pos
    rx1492_cur."!cursor_from"(rx1492_pos)
    ge rx1492_pos, rx1492_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxscan1493_done:
.annotate 'line', 682
  # rx subrule "colonpair" subtype=capture negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."colonpair"()
    unless $P10, rx1492_fail
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1492_pos = $P10."pos"()
  # rx pass
    rx1492_cur."!cursor_pass"(rx1492_pos, "term:sym<colonpair>")
    if_null rx1492_debug, debug_1023
    rx1492_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1492_pos)
  debug_1023:
    .return (rx1492_cur)
  rx1492_restart:
.annotate 'line', 422
    if_null rx1492_debug, debug_1024
    rx1492_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1024:
  rx1492_fail:
    (rx1492_rep, rx1492_pos, $I10, $P10) = rx1492_cur."!mark_fail"(0)
    lt rx1492_pos, -1, rx1492_done
    eq rx1492_pos, -1, rx1492_fail
    jump $I10
  rx1492_done:
    rx1492_cur."!cursor_fail"()
    if_null rx1492_debug, debug_1025
    rx1492_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1025:
    .return (rx1492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("135_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1495 = self."!PREFIX__!subrule"("colonpair", "")
    new $P1496, "ResizablePMCArray"
    push $P1496, $P1495
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("136_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1498_tgt
    .local int rx1498_pos
    .local int rx1498_off
    .local int rx1498_eos
    .local int rx1498_rep
    .local pmc rx1498_cur
    .local pmc rx1498_debug
    (rx1498_cur, rx1498_pos, rx1498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1498_cur
    .local pmc match
    .lex "$/", match
    length rx1498_eos, rx1498_tgt
    gt rx1498_pos, rx1498_eos, rx1498_done
    set rx1498_off, 0
    lt rx1498_pos, 2, rx1498_start
    sub rx1498_off, rx1498_pos, 1
    substr rx1498_tgt, rx1498_tgt, rx1498_off
  rx1498_start:
    eq $I10, 1, rx1498_restart
    if_null rx1498_debug, debug_1026
    rx1498_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1026:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1499_done
    goto rxscan1499_scan
  rxscan1499_loop:
    (rx1498_pos) = rx1498_cur."from"()
    inc rx1498_pos
    rx1498_cur."!cursor_from"(rx1498_pos)
    ge rx1498_pos, rx1498_eos, rxscan1499_done
  rxscan1499_scan:
    set_addr $I10, rxscan1499_loop
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  rxscan1499_done:
.annotate 'line', 683
  # rx subrule "variable" subtype=capture negate=
    rx1498_cur."!cursor_pos"(rx1498_pos)
    $P10 = rx1498_cur."variable"()
    unless $P10, rx1498_fail
    rx1498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1498_pos = $P10."pos"()
  # rx pass
    rx1498_cur."!cursor_pass"(rx1498_pos, "term:sym<variable>")
    if_null rx1498_debug, debug_1027
    rx1498_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1498_pos)
  debug_1027:
    .return (rx1498_cur)
  rx1498_restart:
.annotate 'line', 422
    if_null rx1498_debug, debug_1028
    rx1498_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1028:
  rx1498_fail:
    (rx1498_rep, rx1498_pos, $I10, $P10) = rx1498_cur."!mark_fail"(0)
    lt rx1498_pos, -1, rx1498_done
    eq rx1498_pos, -1, rx1498_fail
    jump $I10
  rx1498_done:
    rx1498_cur."!cursor_fail"()
    if_null rx1498_debug, debug_1029
    rx1498_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1029:
    .return (rx1498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("137_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1501 = self."!PREFIX__!subrule"("variable", "")
    new $P1502, "ResizablePMCArray"
    push $P1502, $P1501
    .return ($P1502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("138_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1504_tgt
    .local int rx1504_pos
    .local int rx1504_off
    .local int rx1504_eos
    .local int rx1504_rep
    .local pmc rx1504_cur
    .local pmc rx1504_debug
    (rx1504_cur, rx1504_pos, rx1504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1504_cur
    .local pmc match
    .lex "$/", match
    length rx1504_eos, rx1504_tgt
    gt rx1504_pos, rx1504_eos, rx1504_done
    set rx1504_off, 0
    lt rx1504_pos, 2, rx1504_start
    sub rx1504_off, rx1504_pos, 1
    substr rx1504_tgt, rx1504_tgt, rx1504_off
  rx1504_start:
    eq $I10, 1, rx1504_restart
    if_null rx1504_debug, debug_1030
    rx1504_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1030:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1505_done
    goto rxscan1505_scan
  rxscan1505_loop:
    (rx1504_pos) = rx1504_cur."from"()
    inc rx1504_pos
    rx1504_cur."!cursor_from"(rx1504_pos)
    ge rx1504_pos, rx1504_eos, rxscan1505_done
  rxscan1505_scan:
    set_addr $I10, rxscan1505_loop
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  rxscan1505_done:
.annotate 'line', 684
  # rx subrule "package_declarator" subtype=capture negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."package_declarator"()
    unless $P10, rx1504_fail
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1504_pos = $P10."pos"()
  # rx pass
    rx1504_cur."!cursor_pass"(rx1504_pos, "term:sym<package_declarator>")
    if_null rx1504_debug, debug_1031
    rx1504_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1504_pos)
  debug_1031:
    .return (rx1504_cur)
  rx1504_restart:
.annotate 'line', 422
    if_null rx1504_debug, debug_1032
    rx1504_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1032:
  rx1504_fail:
    (rx1504_rep, rx1504_pos, $I10, $P10) = rx1504_cur."!mark_fail"(0)
    lt rx1504_pos, -1, rx1504_done
    eq rx1504_pos, -1, rx1504_fail
    jump $I10
  rx1504_done:
    rx1504_cur."!cursor_fail"()
    if_null rx1504_debug, debug_1033
    rx1504_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1033:
    .return (rx1504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("139_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1507 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P1508, "ResizablePMCArray"
    push $P1508, $P1507
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("140_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1034
    rx1510_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1511_done:
.annotate 'line', 685
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."scope_declarator"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "term:sym<scope_declarator>")
    if_null rx1510_debug, debug_1035
    rx1510_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1510_pos)
  debug_1035:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 422
    if_null rx1510_debug, debug_1036
    rx1510_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1036:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1037
    rx1510_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1037:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("141_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1513 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("142_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1516_tgt
    .local int rx1516_pos
    .local int rx1516_off
    .local int rx1516_eos
    .local int rx1516_rep
    .local pmc rx1516_cur
    .local pmc rx1516_debug
    (rx1516_cur, rx1516_pos, rx1516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1516_cur
    .local pmc match
    .lex "$/", match
    length rx1516_eos, rx1516_tgt
    gt rx1516_pos, rx1516_eos, rx1516_done
    set rx1516_off, 0
    lt rx1516_pos, 2, rx1516_start
    sub rx1516_off, rx1516_pos, 1
    substr rx1516_tgt, rx1516_tgt, rx1516_off
  rx1516_start:
    eq $I10, 1, rx1516_restart
    if_null rx1516_debug, debug_1038
    rx1516_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1517_done
    goto rxscan1517_scan
  rxscan1517_loop:
    (rx1516_pos) = rx1516_cur."from"()
    inc rx1516_pos
    rx1516_cur."!cursor_from"(rx1516_pos)
    ge rx1516_pos, rx1516_eos, rxscan1517_done
  rxscan1517_scan:
    set_addr $I10, rxscan1517_loop
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  rxscan1517_done:
.annotate 'line', 686
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."routine_declarator"()
    unless $P10, rx1516_fail
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1516_pos = $P10."pos"()
  # rx pass
    rx1516_cur."!cursor_pass"(rx1516_pos, "term:sym<routine_declarator>")
    if_null rx1516_debug, debug_1039
    rx1516_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1516_pos)
  debug_1039:
    .return (rx1516_cur)
  rx1516_restart:
.annotate 'line', 422
    if_null rx1516_debug, debug_1040
    rx1516_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1040:
  rx1516_fail:
    (rx1516_rep, rx1516_pos, $I10, $P10) = rx1516_cur."!mark_fail"(0)
    lt rx1516_pos, -1, rx1516_done
    eq rx1516_pos, -1, rx1516_fail
    jump $I10
  rx1516_done:
    rx1516_cur."!cursor_fail"()
    if_null rx1516_debug, debug_1041
    rx1516_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1041:
    .return (rx1516_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("143_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1519 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P1520, "ResizablePMCArray"
    push $P1520, $P1519
    .return ($P1520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("144_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1530 = "146_1304523757.895" 
    capture_lex $P1530
    .const 'Sub' $P1525 = "145_1304523757.895" 
    capture_lex $P1525
    .local string rx1522_tgt
    .local int rx1522_pos
    .local int rx1522_off
    .local int rx1522_eos
    .local int rx1522_rep
    .local pmc rx1522_cur
    .local pmc rx1522_debug
    (rx1522_cur, rx1522_pos, rx1522_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1522_cur
    .local pmc match
    .lex "$/", match
    length rx1522_eos, rx1522_tgt
    gt rx1522_pos, rx1522_eos, rx1522_done
    set rx1522_off, 0
    lt rx1522_pos, 2, rx1522_start
    sub rx1522_off, rx1522_pos, 1
    substr rx1522_tgt, rx1522_tgt, rx1522_off
  rx1522_start:
    eq $I10, 1, rx1522_restart
    if_null rx1522_debug, debug_1042
    rx1522_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1523_done
    goto rxscan1523_scan
  rxscan1523_loop:
    (rx1522_pos) = rx1522_cur."from"()
    inc rx1522_pos
    rx1522_cur."!cursor_from"(rx1522_pos)
    ge rx1522_pos, rx1522_eos, rxscan1523_done
  rxscan1523_scan:
    set_addr $I10, rxscan1523_loop
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  rxscan1523_done:
.annotate 'line', 688
  # rx subrule "before" subtype=zerowidth negate=
    rx1522_cur."!cursor_pos"(rx1522_pos)
    .const 'Sub' $P1525 = "145_1304523757.895" 
    capture_lex $P1525
    $P10 = rx1522_cur."before"($P1525)
    unless $P10, rx1522_fail
.annotate 'line', 689
  # rx subrule "before" subtype=zerowidth negate=1
    rx1522_cur."!cursor_pos"(rx1522_pos)
    .const 'Sub' $P1530 = "146_1304523757.895" 
    capture_lex $P1530
    $P10 = rx1522_cur."before"($P1530)
    if $P10, rx1522_fail
.annotate 'line', 690
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1522_cur."!cursor_pos"(rx1522_pos)
    $P10 = rx1522_cur."multi_declarator"()
    unless $P10, rx1522_fail
    rx1522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1522_pos = $P10."pos"()
.annotate 'line', 687
  # rx pass
    rx1522_cur."!cursor_pass"(rx1522_pos, "term:sym<multi_declarator>")
    if_null rx1522_debug, debug_1051
    rx1522_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1522_pos)
  debug_1051:
    .return (rx1522_cur)
  rx1522_restart:
.annotate 'line', 422
    if_null rx1522_debug, debug_1052
    rx1522_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1052:
  rx1522_fail:
    (rx1522_rep, rx1522_pos, $I10, $P10) = rx1522_cur."!mark_fail"(0)
    lt rx1522_pos, -1, rx1522_done
    eq rx1522_pos, -1, rx1522_fail
    jump $I10
  rx1522_done:
    rx1522_cur."!cursor_fail"()
    if_null rx1522_debug, debug_1053
    rx1522_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1053:
    .return (rx1522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1524"  :anon :subid("145_1304523757.895") :method :outer("144_1304523757.895")
.annotate 'line', 688
    .local string rx1526_tgt
    .local int rx1526_pos
    .local int rx1526_off
    .local int rx1526_eos
    .local int rx1526_rep
    .local pmc rx1526_cur
    .local pmc rx1526_debug
    (rx1526_cur, rx1526_pos, rx1526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1526_cur
    .local pmc match
    .lex "$/", match
    length rx1526_eos, rx1526_tgt
    gt rx1526_pos, rx1526_eos, rx1526_done
    set rx1526_off, 0
    lt rx1526_pos, 2, rx1526_start
    sub rx1526_off, rx1526_pos, 1
    substr rx1526_tgt, rx1526_tgt, rx1526_off
  rx1526_start:
    eq $I10, 1, rx1526_restart
    if_null rx1526_debug, debug_1043
    rx1526_cur."!cursor_debug"("START", "")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1526_pos) = rx1526_cur."from"()
    inc rx1526_pos
    rx1526_cur."!cursor_from"(rx1526_pos)
    ge rx1526_pos, rx1526_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  rxscan1527_done:
  alt1528_0:
    set_addr $I10, alt1528_1
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1526_pos, 5
    gt $I11, rx1526_eos, rx1526_fail
    sub $I11, rx1526_pos, rx1526_off
    substr $S10, rx1526_tgt, $I11, 5
    ne $S10, "multi", rx1526_fail
    add rx1526_pos, 5
    goto alt1528_end
  alt1528_1:
    set_addr $I10, alt1528_2
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1526_pos, 5
    gt $I11, rx1526_eos, rx1526_fail
    sub $I11, rx1526_pos, rx1526_off
    substr $S10, rx1526_tgt, $I11, 5
    ne $S10, "proto", rx1526_fail
    add rx1526_pos, 5
    goto alt1528_end
  alt1528_2:
  # rx literal  "only"
    add $I11, rx1526_pos, 4
    gt $I11, rx1526_eos, rx1526_fail
    sub $I11, rx1526_pos, rx1526_off
    substr $S10, rx1526_tgt, $I11, 4
    ne $S10, "only", rx1526_fail
    add rx1526_pos, 4
  alt1528_end:
  # rx pass
    rx1526_cur."!cursor_pass"(rx1526_pos, "")
    if_null rx1526_debug, debug_1044
    rx1526_cur."!cursor_debug"("PASS", "", " at pos=", rx1526_pos)
  debug_1044:
    .return (rx1526_cur)
  rx1526_restart:
    if_null rx1526_debug, debug_1045
    rx1526_cur."!cursor_debug"("NEXT", "")
  debug_1045:
  rx1526_fail:
    (rx1526_rep, rx1526_pos, $I10, $P10) = rx1526_cur."!mark_fail"(0)
    lt rx1526_pos, -1, rx1526_done
    eq rx1526_pos, -1, rx1526_fail
    jump $I10
  rx1526_done:
    rx1526_cur."!cursor_fail"()
    if_null rx1526_debug, debug_1046
    rx1526_cur."!cursor_debug"("FAIL", "")
  debug_1046:
    .return (rx1526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1529"  :anon :subid("146_1304523757.895") :method :outer("144_1304523757.895")
.annotate 'line', 689
    .local string rx1531_tgt
    .local int rx1531_pos
    .local int rx1531_off
    .local int rx1531_eos
    .local int rx1531_rep
    .local pmc rx1531_cur
    .local pmc rx1531_debug
    (rx1531_cur, rx1531_pos, rx1531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1531_cur
    .local pmc match
    .lex "$/", match
    length rx1531_eos, rx1531_tgt
    gt rx1531_pos, rx1531_eos, rx1531_done
    set rx1531_off, 0
    lt rx1531_pos, 2, rx1531_start
    sub rx1531_off, rx1531_pos, 1
    substr rx1531_tgt, rx1531_tgt, rx1531_off
  rx1531_start:
    eq $I10, 1, rx1531_restart
    if_null rx1531_debug, debug_1047
    rx1531_cur."!cursor_debug"("START", "")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1531_pos) = rx1531_cur."from"()
    inc rx1531_pos
    rx1531_cur."!cursor_from"(rx1531_pos)
    ge rx1531_pos, rx1531_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  rxscan1532_done:
  # rx literal  "proto"
    add $I11, rx1531_pos, 5
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 5
    ne $S10, "proto", rx1531_fail
    add rx1531_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."ws"()
    unless $P10, rx1531_fail
    rx1531_pos = $P10."pos"()
  alt1533_0:
    set_addr $I10, alt1533_1
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1531_pos, 5
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 5
    ne $S10, "regex", rx1531_fail
    add rx1531_pos, 5
    goto alt1533_end
  alt1533_1:
    set_addr $I10, alt1533_2
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  # rx literal  "token"
    add $I11, rx1531_pos, 5
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 5
    ne $S10, "token", rx1531_fail
    add rx1531_pos, 5
    goto alt1533_end
  alt1533_2:
  # rx literal  "rule"
    add $I11, rx1531_pos, 4
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    substr $S10, rx1531_tgt, $I11, 4
    ne $S10, "rule", rx1531_fail
    add rx1531_pos, 4
  alt1533_end:
  # rx pass
    rx1531_cur."!cursor_pass"(rx1531_pos, "")
    if_null rx1531_debug, debug_1048
    rx1531_cur."!cursor_debug"("PASS", "", " at pos=", rx1531_pos)
  debug_1048:
    .return (rx1531_cur)
  rx1531_restart:
    if_null rx1531_debug, debug_1049
    rx1531_cur."!cursor_debug"("NEXT", "")
  debug_1049:
  rx1531_fail:
    (rx1531_rep, rx1531_pos, $I10, $P10) = rx1531_cur."!mark_fail"(0)
    lt rx1531_pos, -1, rx1531_done
    eq rx1531_pos, -1, rx1531_fail
    jump $I10
  rx1531_done:
    rx1531_cur."!cursor_fail"()
    if_null rx1531_debug, debug_1050
    rx1531_cur."!cursor_debug"("FAIL", "")
  debug_1050:
    .return (rx1531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("147_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1535, "ResizablePMCArray"
    push $P1535, ""
    .return ($P1535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("148_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1054
    rx1537_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1538_done:
.annotate 'line', 692
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."regex_declarator"()
    unless $P10, rx1537_fail
    rx1537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1537_pos = $P10."pos"()
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "term:sym<regex_declarator>")
    if_null rx1537_debug, debug_1055
    rx1537_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1537_pos)
  debug_1055:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 422
    if_null rx1537_debug, debug_1056
    rx1537_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1056:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1057
    rx1537_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1057:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("149_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1540 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P1541, "ResizablePMCArray"
    push $P1541, $P1540
    .return ($P1541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("150_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1058
    rx1543_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1544_done:
.annotate 'line', 693
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."statement_prefix"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "term:sym<statement_prefix>")
    if_null rx1543_debug, debug_1059
    rx1543_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1543_pos)
  debug_1059:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 422
    if_null rx1543_debug, debug_1060
    rx1543_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1060:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1061
    rx1543_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1061:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("151_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1546 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P1547, "ResizablePMCArray"
    push $P1547, $P1546
    .return ($P1547)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("152_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1062
    rx1549_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1550_done
    goto rxscan1550_scan
  rxscan1550_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1550_done
  rxscan1550_scan:
    set_addr $I10, rxscan1550_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1550_done:
.annotate 'line', 694
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."lambda"()
    unless $P10, rx1549_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."pblock"()
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "term:sym<lambda>")
    if_null rx1549_debug, debug_1063
    rx1549_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1549_pos)
  debug_1063:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 422
    if_null rx1549_debug, debug_1064
    rx1549_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1064:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1065
    rx1549_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1065:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("153_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1552, "ResizablePMCArray"
    push $P1552, ""
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("154_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1554_tgt
    .local int rx1554_pos
    .local int rx1554_off
    .local int rx1554_eos
    .local int rx1554_rep
    .local pmc rx1554_cur
    .local pmc rx1554_debug
    (rx1554_cur, rx1554_pos, rx1554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1554_cur
    .local pmc match
    .lex "$/", match
    length rx1554_eos, rx1554_tgt
    gt rx1554_pos, rx1554_eos, rx1554_done
    set rx1554_off, 0
    lt rx1554_pos, 2, rx1554_start
    sub rx1554_off, rx1554_pos, 1
    substr rx1554_tgt, rx1554_tgt, rx1554_off
  rx1554_start:
    eq $I10, 1, rx1554_restart
    if_null rx1554_debug, debug_1066
    rx1554_cur."!cursor_debug"("START", "fatarrow")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1555_done
    goto rxscan1555_scan
  rxscan1555_loop:
    (rx1554_pos) = rx1554_cur."from"()
    inc rx1554_pos
    rx1554_cur."!cursor_from"(rx1554_pos)
    ge rx1554_pos, rx1554_eos, rxscan1555_done
  rxscan1555_scan:
    set_addr $I10, rxscan1555_loop
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  rxscan1555_done:
.annotate 'line', 697
  # rx subrule "identifier" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."identifier"()
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1554_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1554_pos, rx1554_off
    set rx1554_rep, 0
    sub $I12, rx1554_eos, rx1554_pos
  rxenumcharlistq1556_loop:
    le $I12, 0, rxenumcharlistq1556_done
    substr $S10, rx1554_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1556_done
    inc rx1554_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1556_loop
  rxenumcharlistq1556_done:
    add rx1554_pos, rx1554_pos, rx1554_rep
  # rx literal  "=>"
    add $I11, rx1554_pos, 2
    gt $I11, rx1554_eos, rx1554_fail
    sub $I11, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I11, 2
    ne $S10, "=>", rx1554_fail
    add rx1554_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."ws"()
    unless $P10, rx1554_fail
    rx1554_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."EXPR"("i=")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1554_pos = $P10."pos"()
.annotate 'line', 696
  # rx pass
    rx1554_cur."!cursor_pass"(rx1554_pos, "fatarrow")
    if_null rx1554_debug, debug_1067
    rx1554_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1554_pos)
  debug_1067:
    .return (rx1554_cur)
  rx1554_restart:
.annotate 'line', 422
    if_null rx1554_debug, debug_1068
    rx1554_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1068:
  rx1554_fail:
    (rx1554_rep, rx1554_pos, $I10, $P10) = rx1554_cur."!mark_fail"(0)
    lt rx1554_pos, -1, rx1554_done
    eq rx1554_pos, -1, rx1554_fail
    jump $I10
  rx1554_done:
    rx1554_cur."!cursor_fail"()
    if_null rx1554_debug, debug_1069
    rx1554_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1069:
    .return (rx1554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("155_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1558 = self."!PREFIX__!subrule"("identifier", "")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("156_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    rx1561_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1070
    rx1561_cur."!cursor_debug"("START", "colonpair")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1562_done:
.annotate 'line', 701
  # rx literal  ":"
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 58, rx1561_fail
    add rx1561_pos, 1
  alt1563_0:
.annotate 'line', 702
    set_addr $I10, alt1563_1
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
.annotate 'line', 703
  # rx subcapture "not"
    set_addr $I10, rxcap_1564_fail
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  # rx literal  "!"
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 33, rx1561_fail
    add rx1561_pos, 1
    set_addr $I10, rxcap_1564_fail
    ($I12, $I11) = rx1561_cur."!mark_peek"($I10)
    rx1561_cur."!cursor_pos"($I11)
    ($P10) = rx1561_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1561_pos, "")
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1564_done
  rxcap_1564_fail:
    goto rx1561_fail
  rxcap_1564_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."identifier"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1561_pos = $P10."pos"()
    goto alt1563_end
  alt1563_1:
    set_addr $I10, alt1563_2
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
.annotate 'line', 704
  # rx subrule "identifier" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."identifier"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1561_pos = $P10."pos"()
  # rx rxquantr1565 ** 0..1
    set_addr $I10, rxquantr1565_done
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxquantr1565_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."circumfix"()
    unless $P10, rx1561_fail
    goto rxsubrule1566_pass
  rxsubrule1566_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1561_fail
  rxsubrule1566_pass:
    set_addr $I10, rxsubrule1566_back
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1561_pos = $P10."pos"()
    set_addr $I10, rxquantr1565_done
    (rx1561_rep) = rx1561_cur."!mark_commit"($I10)
  rxquantr1565_done:
    goto alt1563_end
  alt1563_2:
.annotate 'line', 705
  # rx subrule "circumfix" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."circumfix"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1561_pos = $P10."pos"()
  alt1563_end:
.annotate 'line', 700
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "colonpair")
    if_null rx1561_debug, debug_1071
    rx1561_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1561_pos)
  debug_1071:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 422
    if_null rx1561_debug, debug_1072
    rx1561_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1072:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1073
    rx1561_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1073:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("157_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1568 = self."!PREFIX__!subrule"("circumfix", ":")
    $P1569 = self."!PREFIX__!subrule"("identifier", ":")
    $P1570 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P1571, "ResizablePMCArray"
    push $P1571, $P1568
    push $P1571, $P1569
    push $P1571, $P1570
    .return ($P1571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("158_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    rx1573_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1074
    rx1573_cur."!cursor_debug"("START", "variable")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1574_done:
  alt1575_0:
.annotate 'line', 709
    set_addr $I10, alt1575_1
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
.annotate 'line', 710
  # rx subrule "sigil" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."sigil"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1573_pos = $P10."pos"()
  # rx rxquantr1576 ** 0..1
    set_addr $I10, rxquantr1576_done
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxquantr1576_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."twigil"()
    unless $P10, rx1573_fail
    goto rxsubrule1577_pass
  rxsubrule1577_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1573_fail
  rxsubrule1577_pass:
    set_addr $I10, rxsubrule1577_back
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1573_pos = $P10."pos"()
    set_addr $I10, rxquantr1576_done
    (rx1573_rep) = rx1573_cur."!mark_commit"($I10)
  rxquantr1576_done:
  # rx subrule "name" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."name"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1573_pos = $P10."pos"()
    goto alt1575_end
  alt1575_1:
    set_addr $I10, alt1575_2
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
.annotate 'line', 711
  # rx subrule "sigil" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."sigil"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1573_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1573_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."postcircumfix"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1573_pos = $P10."pos"()
    goto alt1575_end
  alt1575_2:
.annotate 'line', 712
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1578_fail
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  # rx literal  "$"
    add $I11, rx1573_pos, 1
    gt $I11, rx1573_eos, rx1573_fail
    sub $I11, rx1573_pos, rx1573_off
    ord $I11, rx1573_tgt, $I11
    ne $I11, 36, rx1573_fail
    add rx1573_pos, 1
    set_addr $I10, rxcap_1578_fail
    ($I12, $I11) = rx1573_cur."!mark_peek"($I10)
    rx1573_cur."!cursor_pos"($I11)
    ($P10) = rx1573_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1573_pos, "")
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1578_done
  rxcap_1578_fail:
    goto rx1573_fail
  rxcap_1578_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1579_fail
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1573_pos, rx1573_eos, rx1573_fail
    sub $I10, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1573_fail
    inc rx1573_pos
    set_addr $I10, rxcap_1579_fail
    ($I12, $I11) = rx1573_cur."!mark_peek"($I10)
    rx1573_cur."!cursor_pos"($I11)
    ($P10) = rx1573_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1573_pos, "")
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1579_done
  rxcap_1579_fail:
    goto rx1573_fail
  rxcap_1579_done:
  alt1575_end:
.annotate 'line', 709
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "variable")
    if_null rx1573_debug, debug_1075
    rx1573_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1573_pos)
  debug_1075:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 422
    if_null rx1573_debug, debug_1076
    rx1573_cur."!cursor_debug"("NEXT", "variable")
  debug_1076:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1077
    rx1573_cur."!cursor_debug"("FAIL", "variable")
  debug_1077:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("159_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1581 = self."!PREFIX__!subrule"("sigil", "")
    $P1582 = self."!PREFIX__!subrule"("sigil", "")
    new $P1583, "ResizablePMCArray"
    push $P1583, "/"
    push $P1583, "_"
    push $P1583, "!"
    push $P1583, $P1581
    push $P1583, $P1582
    .return ($P1583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("160_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1585_tgt
    .local int rx1585_pos
    .local int rx1585_off
    .local int rx1585_eos
    .local int rx1585_rep
    .local pmc rx1585_cur
    .local pmc rx1585_debug
    (rx1585_cur, rx1585_pos, rx1585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1585_cur
    .local pmc match
    .lex "$/", match
    length rx1585_eos, rx1585_tgt
    gt rx1585_pos, rx1585_eos, rx1585_done
    set rx1585_off, 0
    lt rx1585_pos, 2, rx1585_start
    sub rx1585_off, rx1585_pos, 1
    substr rx1585_tgt, rx1585_tgt, rx1585_off
  rx1585_start:
    eq $I10, 1, rx1585_restart
    if_null rx1585_debug, debug_1078
    rx1585_cur."!cursor_debug"("START", "sigil")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1585_pos) = rx1585_cur."from"()
    inc rx1585_pos
    rx1585_cur."!cursor_from"(rx1585_pos)
    ge rx1585_pos, rx1585_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  rxscan1586_done:
.annotate 'line', 715
  # rx enumcharlist negate=0 
    ge rx1585_pos, rx1585_eos, rx1585_fail
    sub $I10, rx1585_pos, rx1585_off
    substr $S10, rx1585_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1585_fail
    inc rx1585_pos
  # rx pass
    rx1585_cur."!cursor_pass"(rx1585_pos, "sigil")
    if_null rx1585_debug, debug_1079
    rx1585_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1585_pos)
  debug_1079:
    .return (rx1585_cur)
  rx1585_restart:
.annotate 'line', 422
    if_null rx1585_debug, debug_1080
    rx1585_cur."!cursor_debug"("NEXT", "sigil")
  debug_1080:
  rx1585_fail:
    (rx1585_rep, rx1585_pos, $I10, $P10) = rx1585_cur."!mark_fail"(0)
    lt rx1585_pos, -1, rx1585_done
    eq rx1585_pos, -1, rx1585_fail
    jump $I10
  rx1585_done:
    rx1585_cur."!cursor_fail"()
    if_null rx1585_debug, debug_1081
    rx1585_cur."!cursor_debug"("FAIL", "sigil")
  debug_1081:
    .return (rx1585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("161_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1588, "ResizablePMCArray"
    push $P1588, "$"
    push $P1588, "@"
    push $P1588, "%"
    push $P1588, "&"
    .return ($P1588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("162_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1082
    rx1590_cur."!cursor_debug"("START", "twigil")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1591_done
    goto rxscan1591_scan
  rxscan1591_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1591_done
  rxscan1591_scan:
    set_addr $I10, rxscan1591_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1591_done:
.annotate 'line', 717
  # rx enumcharlist negate=0 
    ge rx1590_pos, rx1590_eos, rx1590_fail
    sub $I10, rx1590_pos, rx1590_off
    substr $S10, rx1590_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1590_fail
    inc rx1590_pos
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "twigil")
    if_null rx1590_debug, debug_1083
    rx1590_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1590_pos)
  debug_1083:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 422
    if_null rx1590_debug, debug_1084
    rx1590_cur."!cursor_debug"("NEXT", "twigil")
  debug_1084:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1085
    rx1590_cur."!cursor_debug"("FAIL", "twigil")
  debug_1085:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("163_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P1593, "ResizablePMCArray"
    push $P1593, "*"
    push $P1593, "!"
    push $P1593, "?"
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("164_1304523757.895")
    .param pmc param_1595
.annotate 'line', 719
    .lex "self", param_1595
    $P1596 = param_1595."!protoregex"("package_declarator")
    .return ($P1596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("165_1304523757.895")
    .param pmc param_1598
.annotate 'line', 719
    .lex "self", param_1598
    $P1599 = param_1598."!PREFIX__!protoregex"("package_declarator")
    .return ($P1599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("166_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 721
    new $P1601, "Undef"
    .lex "$*OUTERPACKAGE", $P1601
.annotate 'line', 722
    new $P1602, "Undef"
    .lex "$*PKGDECL", $P1602
.annotate 'line', 422
    .local string rx1603_tgt
    .local int rx1603_pos
    .local int rx1603_off
    .local int rx1603_eos
    .local int rx1603_rep
    .local pmc rx1603_cur
    .local pmc rx1603_debug
    (rx1603_cur, rx1603_pos, rx1603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1603_cur
    .local pmc match
    .lex "$/", match
    length rx1603_eos, rx1603_tgt
    gt rx1603_pos, rx1603_eos, rx1603_done
    set rx1603_off, 0
    lt rx1603_pos, 2, rx1603_start
    sub rx1603_off, rx1603_pos, 1
    substr rx1603_tgt, rx1603_tgt, rx1603_off
  rx1603_start:
    eq $I10, 1, rx1603_restart
    if_null rx1603_debug, debug_1086
    rx1603_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1604_done
    goto rxscan1604_scan
  rxscan1604_loop:
    (rx1603_pos) = rx1603_cur."from"()
    inc rx1603_pos
    rx1603_cur."!cursor_from"(rx1603_pos)
    ge rx1603_pos, rx1603_eos, rxscan1604_done
  rxscan1604_scan:
    set_addr $I10, rxscan1604_loop
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxscan1604_done:
.annotate 'line', 721
    rx1603_cur."!cursor_pos"(rx1603_pos)
    find_dynamic_lex $P1607, "$*PACKAGE"
    unless_null $P1607, vivify_1087
    get_hll_global $P1605, "GLOBAL"
    get_who $P1606, $P1605
    set $P1607, $P1606["$PACKAGE"]
    unless_null $P1607, vivify_1088
    die "Contextual $*PACKAGE not found"
  vivify_1088:
  vivify_1087:
    store_lex "$*OUTERPACKAGE", $P1607
.annotate 'line', 722
    rx1603_cur."!cursor_pos"(rx1603_pos)
    new $P1608, "String"
    assign $P1608, "module"
    store_lex "$*PKGDECL", $P1608
.annotate 'line', 723
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  # rx literal  "module"
    add $I11, rx1603_pos, 6
    gt $I11, rx1603_eos, rx1603_fail
    sub $I11, rx1603_pos, rx1603_off
    substr $S10, rx1603_tgt, $I11, 6
    ne $S10, "module", rx1603_fail
    add rx1603_pos, 6
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1603_cur."!mark_peek"($I10)
    rx1603_cur."!cursor_pos"($I11)
    ($P10) = rx1603_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1603_pos, "")
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1603_fail
  rxcap_1609_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."package_def"()
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1603_pos = $P10."pos"()
.annotate 'line', 720
  # rx pass
    rx1603_cur."!cursor_pass"(rx1603_pos, "package_declarator:sym<module>")
    if_null rx1603_debug, debug_1089
    rx1603_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1603_pos)
  debug_1089:
    .return (rx1603_cur)
  rx1603_restart:
.annotate 'line', 422
    if_null rx1603_debug, debug_1090
    rx1603_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1090:
  rx1603_fail:
    (rx1603_rep, rx1603_pos, $I10, $P10) = rx1603_cur."!mark_fail"(0)
    lt rx1603_pos, -1, rx1603_done
    eq rx1603_pos, -1, rx1603_fail
    jump $I10
  rx1603_done:
    rx1603_cur."!cursor_fail"()
    if_null rx1603_debug, debug_1091
    rx1603_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1091:
    .return (rx1603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("167_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1611 = self."!PREFIX__!subrule"("package_def", "module")
    new $P1612, "ResizablePMCArray"
    push $P1612, $P1611
    .return ($P1612)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("168_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 726
    new $P1614, "Undef"
    .lex "$*OUTERPACKAGE", $P1614
.annotate 'line', 727
    new $P1615, "Undef"
    .lex "$*PKGDECL", $P1615
.annotate 'line', 422
    .local string rx1616_tgt
    .local int rx1616_pos
    .local int rx1616_off
    .local int rx1616_eos
    .local int rx1616_rep
    .local pmc rx1616_cur
    .local pmc rx1616_debug
    (rx1616_cur, rx1616_pos, rx1616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1616_cur
    .local pmc match
    .lex "$/", match
    length rx1616_eos, rx1616_tgt
    gt rx1616_pos, rx1616_eos, rx1616_done
    set rx1616_off, 0
    lt rx1616_pos, 2, rx1616_start
    sub rx1616_off, rx1616_pos, 1
    substr rx1616_tgt, rx1616_tgt, rx1616_off
  rx1616_start:
    eq $I10, 1, rx1616_restart
    if_null rx1616_debug, debug_1092
    rx1616_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1092:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1617_done
    goto rxscan1617_scan
  rxscan1617_loop:
    (rx1616_pos) = rx1616_cur."from"()
    inc rx1616_pos
    rx1616_cur."!cursor_from"(rx1616_pos)
    ge rx1616_pos, rx1616_eos, rxscan1617_done
  rxscan1617_scan:
    set_addr $I10, rxscan1617_loop
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  rxscan1617_done:
.annotate 'line', 726
    rx1616_cur."!cursor_pos"(rx1616_pos)
    find_dynamic_lex $P1620, "$*PACKAGE"
    unless_null $P1620, vivify_1093
    get_hll_global $P1618, "GLOBAL"
    get_who $P1619, $P1618
    set $P1620, $P1619["$PACKAGE"]
    unless_null $P1620, vivify_1094
    die "Contextual $*PACKAGE not found"
  vivify_1094:
  vivify_1093:
    store_lex "$*OUTERPACKAGE", $P1620
.annotate 'line', 727
    rx1616_cur."!cursor_pos"(rx1616_pos)
    new $P1621, "String"
    assign $P1621, "knowhow"
    store_lex "$*PKGDECL", $P1621
.annotate 'line', 728
  # rx subcapture "sym"
    set_addr $I10, rxcap_1622_fail
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1616_pos, 7
    gt $I11, rx1616_eos, rx1616_fail
    sub $I11, rx1616_pos, rx1616_off
    substr $S10, rx1616_tgt, $I11, 7
    ne $S10, "knowhow", rx1616_fail
    add rx1616_pos, 7
    set_addr $I10, rxcap_1622_fail
    ($I12, $I11) = rx1616_cur."!mark_peek"($I10)
    rx1616_cur."!cursor_pos"($I11)
    ($P10) = rx1616_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1616_pos, "")
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1622_done
  rxcap_1622_fail:
    goto rx1616_fail
  rxcap_1622_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1616_cur."!cursor_pos"(rx1616_pos)
    $P10 = rx1616_cur."package_def"()
    unless $P10, rx1616_fail
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1616_pos = $P10."pos"()
.annotate 'line', 725
  # rx pass
    rx1616_cur."!cursor_pass"(rx1616_pos, "package_declarator:sym<knowhow>")
    if_null rx1616_debug, debug_1095
    rx1616_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1616_pos)
  debug_1095:
    .return (rx1616_cur)
  rx1616_restart:
.annotate 'line', 422
    if_null rx1616_debug, debug_1096
    rx1616_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1096:
  rx1616_fail:
    (rx1616_rep, rx1616_pos, $I10, $P10) = rx1616_cur."!mark_fail"(0)
    lt rx1616_pos, -1, rx1616_done
    eq rx1616_pos, -1, rx1616_fail
    jump $I10
  rx1616_done:
    rx1616_cur."!cursor_fail"()
    if_null rx1616_debug, debug_1097
    rx1616_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1097:
    .return (rx1616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("169_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1624 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P1625, "ResizablePMCArray"
    push $P1625, $P1624
    .return ($P1625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("170_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 731
    new $P1627, "Undef"
    .lex "$*OUTERPACKAGE", $P1627
.annotate 'line', 732
    new $P1628, "Undef"
    .lex "$*PKGDECL", $P1628
.annotate 'line', 422
    .local string rx1629_tgt
    .local int rx1629_pos
    .local int rx1629_off
    .local int rx1629_eos
    .local int rx1629_rep
    .local pmc rx1629_cur
    .local pmc rx1629_debug
    (rx1629_cur, rx1629_pos, rx1629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1629_cur
    .local pmc match
    .lex "$/", match
    length rx1629_eos, rx1629_tgt
    gt rx1629_pos, rx1629_eos, rx1629_done
    set rx1629_off, 0
    lt rx1629_pos, 2, rx1629_start
    sub rx1629_off, rx1629_pos, 1
    substr rx1629_tgt, rx1629_tgt, rx1629_off
  rx1629_start:
    eq $I10, 1, rx1629_restart
    if_null rx1629_debug, debug_1098
    rx1629_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1098:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1630_done
    goto rxscan1630_scan
  rxscan1630_loop:
    (rx1629_pos) = rx1629_cur."from"()
    inc rx1629_pos
    rx1629_cur."!cursor_from"(rx1629_pos)
    ge rx1629_pos, rx1629_eos, rxscan1630_done
  rxscan1630_scan:
    set_addr $I10, rxscan1630_loop
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  rxscan1630_done:
.annotate 'line', 731
    rx1629_cur."!cursor_pos"(rx1629_pos)
    find_dynamic_lex $P1633, "$*PACKAGE"
    unless_null $P1633, vivify_1099
    get_hll_global $P1631, "GLOBAL"
    get_who $P1632, $P1631
    set $P1633, $P1632["$PACKAGE"]
    unless_null $P1633, vivify_1100
    die "Contextual $*PACKAGE not found"
  vivify_1100:
  vivify_1099:
    store_lex "$*OUTERPACKAGE", $P1633
.annotate 'line', 732
    rx1629_cur."!cursor_pos"(rx1629_pos)
    new $P1634, "String"
    assign $P1634, "class"
    store_lex "$*PKGDECL", $P1634
.annotate 'line', 733
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  # rx literal  "class"
    add $I11, rx1629_pos, 5
    gt $I11, rx1629_eos, rx1629_fail
    sub $I11, rx1629_pos, rx1629_off
    substr $S10, rx1629_tgt, $I11, 5
    ne $S10, "class", rx1629_fail
    add rx1629_pos, 5
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1629_cur."!mark_peek"($I10)
    rx1629_cur."!cursor_pos"($I11)
    ($P10) = rx1629_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1629_pos, "")
    rx1629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1629_fail
  rxcap_1635_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1629_cur."!cursor_pos"(rx1629_pos)
    $P10 = rx1629_cur."package_def"()
    unless $P10, rx1629_fail
    rx1629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1629_pos = $P10."pos"()
.annotate 'line', 730
  # rx pass
    rx1629_cur."!cursor_pass"(rx1629_pos, "package_declarator:sym<class>")
    if_null rx1629_debug, debug_1101
    rx1629_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1629_pos)
  debug_1101:
    .return (rx1629_cur)
  rx1629_restart:
.annotate 'line', 422
    if_null rx1629_debug, debug_1102
    rx1629_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1102:
  rx1629_fail:
    (rx1629_rep, rx1629_pos, $I10, $P10) = rx1629_cur."!mark_fail"(0)
    lt rx1629_pos, -1, rx1629_done
    eq rx1629_pos, -1, rx1629_fail
    jump $I10
  rx1629_done:
    rx1629_cur."!cursor_fail"()
    if_null rx1629_debug, debug_1103
    rx1629_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1103:
    .return (rx1629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("171_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1637 = self."!PREFIX__!subrule"("package_def", "class")
    new $P1638, "ResizablePMCArray"
    push $P1638, $P1637
    .return ($P1638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("172_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 736
    new $P1640, "Undef"
    .lex "$*OUTERPACKAGE", $P1640
.annotate 'line', 737
    new $P1641, "Undef"
    .lex "$*PKGDECL", $P1641
.annotate 'line', 422
    .local string rx1642_tgt
    .local int rx1642_pos
    .local int rx1642_off
    .local int rx1642_eos
    .local int rx1642_rep
    .local pmc rx1642_cur
    .local pmc rx1642_debug
    (rx1642_cur, rx1642_pos, rx1642_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1642_cur
    .local pmc match
    .lex "$/", match
    length rx1642_eos, rx1642_tgt
    gt rx1642_pos, rx1642_eos, rx1642_done
    set rx1642_off, 0
    lt rx1642_pos, 2, rx1642_start
    sub rx1642_off, rx1642_pos, 1
    substr rx1642_tgt, rx1642_tgt, rx1642_off
  rx1642_start:
    eq $I10, 1, rx1642_restart
    if_null rx1642_debug, debug_1104
    rx1642_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1643_done
    goto rxscan1643_scan
  rxscan1643_loop:
    (rx1642_pos) = rx1642_cur."from"()
    inc rx1642_pos
    rx1642_cur."!cursor_from"(rx1642_pos)
    ge rx1642_pos, rx1642_eos, rxscan1643_done
  rxscan1643_scan:
    set_addr $I10, rxscan1643_loop
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  rxscan1643_done:
.annotate 'line', 736
    rx1642_cur."!cursor_pos"(rx1642_pos)
    find_dynamic_lex $P1646, "$*PACKAGE"
    unless_null $P1646, vivify_1105
    get_hll_global $P1644, "GLOBAL"
    get_who $P1645, $P1644
    set $P1646, $P1645["$PACKAGE"]
    unless_null $P1646, vivify_1106
    die "Contextual $*PACKAGE not found"
  vivify_1106:
  vivify_1105:
    store_lex "$*OUTERPACKAGE", $P1646
.annotate 'line', 737
    rx1642_cur."!cursor_pos"(rx1642_pos)
    new $P1647, "String"
    assign $P1647, "grammar"
    store_lex "$*PKGDECL", $P1647
.annotate 'line', 738
  # rx subcapture "sym"
    set_addr $I10, rxcap_1648_fail
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1642_pos, 7
    gt $I11, rx1642_eos, rx1642_fail
    sub $I11, rx1642_pos, rx1642_off
    substr $S10, rx1642_tgt, $I11, 7
    ne $S10, "grammar", rx1642_fail
    add rx1642_pos, 7
    set_addr $I10, rxcap_1648_fail
    ($I12, $I11) = rx1642_cur."!mark_peek"($I10)
    rx1642_cur."!cursor_pos"($I11)
    ($P10) = rx1642_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1642_pos, "")
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1648_done
  rxcap_1648_fail:
    goto rx1642_fail
  rxcap_1648_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1642_cur."!cursor_pos"(rx1642_pos)
    $P10 = rx1642_cur."package_def"()
    unless $P10, rx1642_fail
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1642_pos = $P10."pos"()
.annotate 'line', 735
  # rx pass
    rx1642_cur."!cursor_pass"(rx1642_pos, "package_declarator:sym<grammar>")
    if_null rx1642_debug, debug_1107
    rx1642_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1642_pos)
  debug_1107:
    .return (rx1642_cur)
  rx1642_restart:
.annotate 'line', 422
    if_null rx1642_debug, debug_1108
    rx1642_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1108:
  rx1642_fail:
    (rx1642_rep, rx1642_pos, $I10, $P10) = rx1642_cur."!mark_fail"(0)
    lt rx1642_pos, -1, rx1642_done
    eq rx1642_pos, -1, rx1642_fail
    jump $I10
  rx1642_done:
    rx1642_cur."!cursor_fail"()
    if_null rx1642_debug, debug_1109
    rx1642_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1109:
    .return (rx1642_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("173_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1650 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P1651, "ResizablePMCArray"
    push $P1651, $P1650
    .return ($P1651)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("174_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 741
    new $P1653, "Undef"
    .lex "$*OUTERPACKAGE", $P1653
.annotate 'line', 742
    new $P1654, "Undef"
    .lex "$*PKGDECL", $P1654
.annotate 'line', 422
    .local string rx1655_tgt
    .local int rx1655_pos
    .local int rx1655_off
    .local int rx1655_eos
    .local int rx1655_rep
    .local pmc rx1655_cur
    .local pmc rx1655_debug
    (rx1655_cur, rx1655_pos, rx1655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1655_cur
    .local pmc match
    .lex "$/", match
    length rx1655_eos, rx1655_tgt
    gt rx1655_pos, rx1655_eos, rx1655_done
    set rx1655_off, 0
    lt rx1655_pos, 2, rx1655_start
    sub rx1655_off, rx1655_pos, 1
    substr rx1655_tgt, rx1655_tgt, rx1655_off
  rx1655_start:
    eq $I10, 1, rx1655_restart
    if_null rx1655_debug, debug_1110
    rx1655_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1655_pos) = rx1655_cur."from"()
    inc rx1655_pos
    rx1655_cur."!cursor_from"(rx1655_pos)
    ge rx1655_pos, rx1655_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1655_cur."!mark_push"(0, rx1655_pos, $I10)
  rxscan1656_done:
.annotate 'line', 741
    rx1655_cur."!cursor_pos"(rx1655_pos)
    find_dynamic_lex $P1659, "$*PACKAGE"
    unless_null $P1659, vivify_1111
    get_hll_global $P1657, "GLOBAL"
    get_who $P1658, $P1657
    set $P1659, $P1658["$PACKAGE"]
    unless_null $P1659, vivify_1112
    die "Contextual $*PACKAGE not found"
  vivify_1112:
  vivify_1111:
    store_lex "$*OUTERPACKAGE", $P1659
.annotate 'line', 742
    rx1655_cur."!cursor_pos"(rx1655_pos)
    new $P1660, "String"
    assign $P1660, "role"
    store_lex "$*PKGDECL", $P1660
.annotate 'line', 743
  # rx subcapture "sym"
    set_addr $I10, rxcap_1661_fail
    rx1655_cur."!mark_push"(0, rx1655_pos, $I10)
  # rx literal  "role"
    add $I11, rx1655_pos, 4
    gt $I11, rx1655_eos, rx1655_fail
    sub $I11, rx1655_pos, rx1655_off
    substr $S10, rx1655_tgt, $I11, 4
    ne $S10, "role", rx1655_fail
    add rx1655_pos, 4
    set_addr $I10, rxcap_1661_fail
    ($I12, $I11) = rx1655_cur."!mark_peek"($I10)
    rx1655_cur."!cursor_pos"($I11)
    ($P10) = rx1655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1655_pos, "")
    rx1655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1661_done
  rxcap_1661_fail:
    goto rx1655_fail
  rxcap_1661_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1655_cur."!cursor_pos"(rx1655_pos)
    $P10 = rx1655_cur."package_def"()
    unless $P10, rx1655_fail
    rx1655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1655_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx1655_cur."!cursor_pass"(rx1655_pos, "package_declarator:sym<role>")
    if_null rx1655_debug, debug_1113
    rx1655_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1655_pos)
  debug_1113:
    .return (rx1655_cur)
  rx1655_restart:
.annotate 'line', 422
    if_null rx1655_debug, debug_1114
    rx1655_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1114:
  rx1655_fail:
    (rx1655_rep, rx1655_pos, $I10, $P10) = rx1655_cur."!mark_fail"(0)
    lt rx1655_pos, -1, rx1655_done
    eq rx1655_pos, -1, rx1655_fail
    jump $I10
  rx1655_done:
    rx1655_cur."!cursor_fail"()
    if_null rx1655_debug, debug_1115
    rx1655_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1115:
    .return (rx1655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("175_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1663 = self."!PREFIX__!subrule"("package_def", "role")
    new $P1664, "ResizablePMCArray"
    push $P1664, $P1663
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("176_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 746
    new $P1666, "Undef"
    .lex "$*OUTERPACKAGE", $P1666
.annotate 'line', 747
    new $P1667, "Undef"
    .lex "$*PKGDECL", $P1667
.annotate 'line', 422
    .local string rx1668_tgt
    .local int rx1668_pos
    .local int rx1668_off
    .local int rx1668_eos
    .local int rx1668_rep
    .local pmc rx1668_cur
    .local pmc rx1668_debug
    (rx1668_cur, rx1668_pos, rx1668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1668_cur
    .local pmc match
    .lex "$/", match
    length rx1668_eos, rx1668_tgt
    gt rx1668_pos, rx1668_eos, rx1668_done
    set rx1668_off, 0
    lt rx1668_pos, 2, rx1668_start
    sub rx1668_off, rx1668_pos, 1
    substr rx1668_tgt, rx1668_tgt, rx1668_off
  rx1668_start:
    eq $I10, 1, rx1668_restart
    if_null rx1668_debug, debug_1116
    rx1668_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1116:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1669_done
    goto rxscan1669_scan
  rxscan1669_loop:
    (rx1668_pos) = rx1668_cur."from"()
    inc rx1668_pos
    rx1668_cur."!cursor_from"(rx1668_pos)
    ge rx1668_pos, rx1668_eos, rxscan1669_done
  rxscan1669_scan:
    set_addr $I10, rxscan1669_loop
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  rxscan1669_done:
.annotate 'line', 746
    rx1668_cur."!cursor_pos"(rx1668_pos)
    find_dynamic_lex $P1672, "$*PACKAGE"
    unless_null $P1672, vivify_1117
    get_hll_global $P1670, "GLOBAL"
    get_who $P1671, $P1670
    set $P1672, $P1671["$PACKAGE"]
    unless_null $P1672, vivify_1118
    die "Contextual $*PACKAGE not found"
  vivify_1118:
  vivify_1117:
    store_lex "$*OUTERPACKAGE", $P1672
.annotate 'line', 747
    rx1668_cur."!cursor_pos"(rx1668_pos)
    new $P1673, "String"
    assign $P1673, "native"
    store_lex "$*PKGDECL", $P1673
.annotate 'line', 748
  # rx subcapture "sym"
    set_addr $I10, rxcap_1674_fail
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  # rx literal  "native"
    add $I11, rx1668_pos, 6
    gt $I11, rx1668_eos, rx1668_fail
    sub $I11, rx1668_pos, rx1668_off
    substr $S10, rx1668_tgt, $I11, 6
    ne $S10, "native", rx1668_fail
    add rx1668_pos, 6
    set_addr $I10, rxcap_1674_fail
    ($I12, $I11) = rx1668_cur."!mark_peek"($I10)
    rx1668_cur."!cursor_pos"($I11)
    ($P10) = rx1668_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1668_pos, "")
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1674_done
  rxcap_1674_fail:
    goto rx1668_fail
  rxcap_1674_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1668_cur."!cursor_pos"(rx1668_pos)
    $P10 = rx1668_cur."package_def"()
    unless $P10, rx1668_fail
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1668_pos = $P10."pos"()
.annotate 'line', 745
  # rx pass
    rx1668_cur."!cursor_pass"(rx1668_pos, "package_declarator:sym<native>")
    if_null rx1668_debug, debug_1119
    rx1668_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1668_pos)
  debug_1119:
    .return (rx1668_cur)
  rx1668_restart:
.annotate 'line', 422
    if_null rx1668_debug, debug_1120
    rx1668_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1120:
  rx1668_fail:
    (rx1668_rep, rx1668_pos, $I10, $P10) = rx1668_cur."!mark_fail"(0)
    lt rx1668_pos, -1, rx1668_done
    eq rx1668_pos, -1, rx1668_fail
    jump $I10
  rx1668_done:
    rx1668_cur."!cursor_fail"()
    if_null rx1668_debug, debug_1121
    rx1668_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1121:
    .return (rx1668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("177_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1676 = self."!PREFIX__!subrule"("package_def", "native")
    new $P1677, "ResizablePMCArray"
    push $P1677, $P1676
    .return ($P1677)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("178_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1703 = "179_1304523757.895" 
    capture_lex $P1703
.annotate 'line', 752
    new $P1679, "Undef"
    .lex "$*PACKAGE", $P1679
.annotate 'line', 753
    $P1680 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P1680
.annotate 'line', 422
    .local string rx1681_tgt
    .local int rx1681_pos
    .local int rx1681_off
    .local int rx1681_eos
    .local int rx1681_rep
    .local pmc rx1681_cur
    .local pmc rx1681_debug
    (rx1681_cur, rx1681_pos, rx1681_tgt, $I10) = self."!cursor_start"()
    rx1681_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1681_cur
    .local pmc match
    .lex "$/", match
    length rx1681_eos, rx1681_tgt
    gt rx1681_pos, rx1681_eos, rx1681_done
    set rx1681_off, 0
    lt rx1681_pos, 2, rx1681_start
    sub rx1681_off, rx1681_pos, 1
    substr rx1681_tgt, rx1681_tgt, rx1681_off
  rx1681_start:
    eq $I10, 1, rx1681_restart
    if_null rx1681_debug, debug_1122
    rx1681_cur."!cursor_debug"("START", "package_def")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1682_done
    goto rxscan1682_scan
  rxscan1682_loop:
    (rx1681_pos) = rx1681_cur."from"()
    inc rx1681_pos
    rx1681_cur."!cursor_from"(rx1681_pos)
    ge rx1681_pos, rx1681_eos, rxscan1682_done
  rxscan1682_scan:
    set_addr $I10, rxscan1682_loop
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
  rxscan1682_done:
.annotate 'line', 751
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 752
    rx1681_cur."!cursor_pos"(rx1681_pos)
    find_lex $P1686, "$*PACKAGE"
    unless_null $P1686, vivify_1123
    get_hll_global $P1684, "GLOBAL"
    get_who $P1685, $P1684
    set $P1686, $P1685["$PACKAGE"]
    unless_null $P1686, vivify_1124
    die "Contextual $*PACKAGE not found"
  vivify_1124:
  vivify_1123:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 753
    rx1681_cur."!cursor_pos"(rx1681_pos)
    find_lex $P1690, "%*ATTR-CHECK"
    unless_null $P1690, vivify_1125
    get_hll_global $P1688, "GLOBAL"
    get_who $P1689, $P1688
    set $P1690, $P1689["%ATTR-CHECK"]
    unless_null $P1690, vivify_1126
    die "Contextual %*ATTR-CHECK not found"
  vivify_1126:
  vivify_1125:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 755
  # rx subrule "name" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."name"()
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 756
  # rx rxquantr1693 ** 0..1
    set_addr $I10, rxquantr1693_done
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
  rxquantr1693_loop:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1681_pos, 2
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    substr $S10, rx1681_tgt, $I11, 2
    ne $S10, "is", rx1681_fail
    add rx1681_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1681_pos, 5
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    substr $S10, rx1681_tgt, $I11, 5
    ne $S10, "repr(", rx1681_fail
    add rx1681_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."quote_EXPR"()
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1681_pos, 1
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    ord $I11, rx1681_tgt, $I11
    ne $I11, 41, rx1681_fail
    add rx1681_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
    set_addr $I10, rxquantr1693_done
    (rx1681_rep) = rx1681_cur."!mark_commit"($I10)
  rxquantr1693_done:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 758
    rx1681_cur."!cursor_pos"(rx1681_pos)
    find_lex $P1700, unicode:"$\x{a2}"
    $P1701 = $P1700."MATCH"()
    store_lex "$/", $P1701
    .const 'Sub' $P1703 = "179_1304523757.895" 
    capture_lex $P1703
    $P1825 = $P1703()
.annotate 'line', 784
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 786
  # rx rxquantr1827 ** 0..1
    set_addr $I10, rxquantr1827_done
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
  rxquantr1827_loop:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1681_pos, 2
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    substr $S10, rx1681_tgt, $I11, 2
    ne $S10, "is", rx1681_fail
    add rx1681_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."name"()
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
    set_addr $I10, rxquantr1827_done
    (rx1681_rep) = rx1681_cur."!mark_commit"($I10)
  rxquantr1827_done:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 787
  # rx rxquantr1832 ** 0..*
    set_addr $I10, rxquantr1832_done
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
  rxquantr1832_loop:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1681_pos, 4
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    substr $S10, rx1681_tgt, $I11, 4
    ne $S10, "does", rx1681_fail
    add rx1681_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."name"()
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
    set_addr $I10, rxquantr1832_done
    (rx1681_rep) = rx1681_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1832_done
    rx1681_cur."!mark_push"(rx1681_rep, rx1681_pos, $I10)
    goto rxquantr1832_loop
  rxquantr1832_done:
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  alt1837_0:
.annotate 'line', 788
    set_addr $I10, alt1837_1
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
.annotate 'line', 789
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1681_pos, 1
    gt $I11, rx1681_eos, rx1681_fail
    sub $I11, rx1681_pos, rx1681_off
    ord $I11, rx1681_tgt, $I11
    ne $I11, 59, rx1681_fail
    add rx1681_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."comp_unit"()
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
    goto alt1837_end
  alt1837_1:
    set_addr $I10, alt1837_2
    rx1681_cur."!mark_push"(0, rx1681_pos, $I10)
.annotate 'line', 790
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1681_pos, rx1681_off
    substr $S10, rx1681_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1681_fail
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."block"()
    unless $P10, rx1681_fail
    rx1681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
    goto alt1837_end
  alt1837_2:
.annotate 'line', 791
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."panic"("Malformed package declaration")
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
  alt1837_end:
.annotate 'line', 792
  # rx subrule "ws" subtype=method negate=
    rx1681_cur."!cursor_pos"(rx1681_pos)
    $P10 = rx1681_cur."ws"()
    unless $P10, rx1681_fail
    rx1681_pos = $P10."pos"()
.annotate 'line', 751
  # rx pass
    rx1681_cur."!cursor_pass"(rx1681_pos, "package_def")
    if_null rx1681_debug, debug_1194
    rx1681_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1681_pos)
  debug_1194:
    .return (rx1681_cur)
  rx1681_restart:
.annotate 'line', 422
    if_null rx1681_debug, debug_1195
    rx1681_cur."!cursor_debug"("NEXT", "package_def")
  debug_1195:
  rx1681_fail:
    (rx1681_rep, rx1681_pos, $I10, $P10) = rx1681_cur."!mark_fail"(0)
    lt rx1681_pos, -1, rx1681_done
    eq rx1681_pos, -1, rx1681_fail
    jump $I10
  rx1681_done:
    rx1681_cur."!cursor_fail"()
    if_null rx1681_debug, debug_1196
    rx1681_cur."!cursor_debug"("FAIL", "package_def")
  debug_1196:
    .return (rx1681_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1702"  :anon :subid("179_1304523757.895") :outer("178_1304523757.895")
.annotate 'line', 761
    $P1704 = root_new ['parrot';'Hash']
    .lex "%args", $P1704
.annotate 'line', 758
    find_lex $P1705, "%args"
    unless_null $P1705, vivify_1127
    $P1705 = root_new ['parrot';'Hash']
  vivify_1127:
.annotate 'line', 762
    find_lex $P1706, "$/"
    unless_null $P1706, vivify_1128
    $P1706 = root_new ['parrot';'Hash']
  vivify_1128:
    set $P1707, $P1706["name"]
    unless_null $P1707, vivify_1129
    new $P1707, "Undef"
  vivify_1129:
    set $S1708, $P1707
    new $P1709, 'String'
    set $P1709, $S1708
    find_lex $P1710, "%args"
    unless_null $P1710, vivify_1130
    $P1710 = root_new ['parrot';'Hash']
    store_lex "%args", $P1710
  vivify_1130:
    set $P1710["name"], $P1709
.annotate 'line', 763
    find_lex $P1712, "$/"
    unless_null $P1712, vivify_1131
    $P1712 = root_new ['parrot';'Hash']
  vivify_1131:
    set $P1713, $P1712["repr"]
    unless_null $P1713, vivify_1132
    new $P1713, "Undef"
  vivify_1132:
    unless $P1713, if_1711_end
.annotate 'line', 764
    find_lex $P1714, "$/"
    unless_null $P1714, vivify_1133
    $P1714 = root_new ['parrot';'Hash']
  vivify_1133:
    set $P1715, $P1714["repr"]
    unless_null $P1715, vivify_1134
    $P1715 = root_new ['parrot';'ResizablePMCArray']
  vivify_1134:
    set $P1716, $P1715[0]
    unless_null $P1716, vivify_1135
    $P1716 = root_new ['parrot';'Hash']
  vivify_1135:
    set $P1717, $P1716["quote_delimited"]
    unless_null $P1717, vivify_1136
    $P1717 = root_new ['parrot';'Hash']
  vivify_1136:
    set $P1718, $P1717["quote_atom"]
    unless_null $P1718, vivify_1137
    $P1718 = root_new ['parrot';'ResizablePMCArray']
  vivify_1137:
    set $P1719, $P1718[0]
    unless_null $P1719, vivify_1138
    new $P1719, "Undef"
  vivify_1138:
    set $S1720, $P1719
    new $P1721, 'String'
    set $P1721, $S1720
    find_lex $P1722, "%args"
    unless_null $P1722, vivify_1139
    $P1722 = root_new ['parrot';'Hash']
    store_lex "%args", $P1722
  vivify_1139:
    set $P1722["repr"], $P1721
  if_1711_end:
.annotate 'line', 766
    find_dynamic_lex $P1725, "$*SC"
    unless_null $P1725, vivify_1140
    get_hll_global $P1723, "GLOBAL"
    get_who $P1724, $P1723
    set $P1725, $P1724["$SC"]
    unless_null $P1725, vivify_1141
    die "Contextual $*SC not found"
  vivify_1141:
  vivify_1140:
    find_dynamic_lex $P1728, "$*PKGDECL"
    unless_null $P1728, vivify_1142
    get_hll_global $P1726, "GLOBAL"
    get_who $P1727, $P1726
    set $P1728, $P1727["$PKGDECL"]
    unless_null $P1728, vivify_1143
    die "Contextual $*PKGDECL not found"
  vivify_1143:
  vivify_1142:
    find_dynamic_lex $P1731, "%*HOW"
    unless_null $P1731, vivify_1144
    get_hll_global $P1729, "GLOBAL"
    get_who $P1730, $P1729
    set $P1731, $P1730["%HOW"]
    unless_null $P1731, vivify_1145
    die "Contextual %*HOW not found"
  vivify_1145:
  vivify_1144:
    set $P1732, $P1731[$P1728]
    unless_null $P1732, vivify_1146
    new $P1732, "Undef"
  vivify_1146:
    find_lex $P1733, "%args"
    unless_null $P1733, vivify_1147
    $P1733 = root_new ['parrot';'Hash']
  vivify_1147:
    $P1734 = $P1725."pkg_create_mo"($P1732, $P1733 :flat)
    store_dynamic_lex "$*PACKAGE", $P1734
.annotate 'line', 769
    find_dynamic_lex $P1741, "$*SCOPE"
    unless_null $P1741, vivify_1148
    get_hll_global $P1739, "GLOBAL"
    get_who $P1740, $P1739
    set $P1741, $P1740["$SCOPE"]
    unless_null $P1741, vivify_1149
    die "Contextual $*SCOPE not found"
  vivify_1149:
  vivify_1148:
    set $S1742, $P1741
    iseq $I1743, $S1742, "our"
    unless $I1743, unless_1738
    new $P1737, 'Integer'
    set $P1737, $I1743
    goto unless_1738_end
  unless_1738:
    find_dynamic_lex $P1746, "$*SCOPE"
    unless_null $P1746, vivify_1150
    get_hll_global $P1744, "GLOBAL"
    get_who $P1745, $P1744
    set $P1746, $P1745["$SCOPE"]
    unless_null $P1746, vivify_1151
    die "Contextual $*SCOPE not found"
  vivify_1151:
  vivify_1150:
    set $S1747, $P1746
    iseq $I1748, $S1747, ""
    new $P1737, 'Integer'
    set $P1737, $I1748
  unless_1738_end:
    if $P1737, if_1736
.annotate 'line', 775
    find_dynamic_lex $P1789, "$*SCOPE"
    unless_null $P1789, vivify_1152
    get_hll_global $P1787, "GLOBAL"
    get_who $P1788, $P1787
    set $P1789, $P1788["$SCOPE"]
    unless_null $P1789, vivify_1153
    die "Contextual $*SCOPE not found"
  vivify_1153:
  vivify_1152:
    set $S1790, $P1789
    iseq $I1791, $S1790, "my"
    if $I1791, if_1786
.annotate 'line', 782
    find_lex $P1818, "$/"
    unless_null $P1818, vivify_1154
    new $P1818, "Undef"
  vivify_1154:
    $P1819 = $P1818."CURSOR"()
    find_dynamic_lex $P1822, "$*SCOPE"
    unless_null $P1822, vivify_1155
    get_hll_global $P1820, "GLOBAL"
    get_who $P1821, $P1820
    set $P1822, $P1821["$SCOPE"]
    unless_null $P1822, vivify_1156
    die "Contextual $*SCOPE not found"
  vivify_1156:
  vivify_1155:
    concat $P1823, $P1822, " scoped packages are not supported"
    $P1824 = $P1819."panic"($P1823)
.annotate 'line', 781
    set $P1785, $P1824
.annotate 'line', 775
    goto if_1786_end
  if_1786:
.annotate 'line', 776
    find_lex $P1793, "$/"
    unless_null $P1793, vivify_1157
    $P1793 = root_new ['parrot';'Hash']
  vivify_1157:
    set $P1794, $P1793["name"]
    unless_null $P1794, vivify_1158
    $P1794 = root_new ['parrot';'Hash']
  vivify_1158:
    set $P1795, $P1794["identifier"]
    unless_null $P1795, vivify_1159
    new $P1795, "Undef"
  vivify_1159:
    set $N1796, $P1795
    isne $I1797, $N1796, 1.0
    unless $I1797, if_1792_end
.annotate 'line', 777
    find_lex $P1798, "$/"
    unless_null $P1798, vivify_1160
    $P1798 = root_new ['parrot';'Hash']
  vivify_1160:
    set $P1799, $P1798["name"]
    unless_null $P1799, vivify_1161
    new $P1799, "Undef"
  vivify_1161:
    $P1800 = $P1799."CURSOR"()
    $P1800."panic"("A my scoped package cannot have a multi-part name yet")
  if_1792_end:
.annotate 'line', 779
    find_dynamic_lex $P1803, "$*SC"
    unless_null $P1803, vivify_1162
    get_hll_global $P1801, "GLOBAL"
    get_who $P1802, $P1801
    set $P1803, $P1802["$SC"]
    unless_null $P1803, vivify_1163
    die "Contextual $*SC not found"
  vivify_1163:
  vivify_1162:
    get_hll_global $P1804, "GLOBAL"
    nqp_get_package_through_who $P1805, $P1804, "NQP"
    nqp_get_package_through_who $P1806, $P1805, "Actions"
    get_who $P1807, $P1806
    set $P1808, $P1807["@BLOCK"]
    unless_null $P1808, vivify_1164
    $P1808 = root_new ['parrot';'ResizablePMCArray']
  vivify_1164:
    set $P1809, $P1808[0]
    unless_null $P1809, vivify_1165
    new $P1809, "Undef"
  vivify_1165:
    find_lex $P1810, "$/"
    unless_null $P1810, vivify_1166
    $P1810 = root_new ['parrot';'Hash']
  vivify_1166:
    set $P1811, $P1810["name"]
    unless_null $P1811, vivify_1167
    $P1811 = root_new ['parrot';'Hash']
  vivify_1167:
    set $P1812, $P1811["identifier"]
    unless_null $P1812, vivify_1168
    $P1812 = root_new ['parrot';'ResizablePMCArray']
  vivify_1168:
    set $P1813, $P1812[0]
    unless_null $P1813, vivify_1169
    new $P1813, "Undef"
  vivify_1169:
    find_dynamic_lex $P1816, "$*PACKAGE"
    unless_null $P1816, vivify_1170
    get_hll_global $P1814, "GLOBAL"
    get_who $P1815, $P1814
    set $P1816, $P1815["$PACKAGE"]
    unless_null $P1816, vivify_1171
    die "Contextual $*PACKAGE not found"
  vivify_1171:
  vivify_1170:
    $P1817 = $P1803."install_lexical_symbol"($P1809, $P1813, $P1816)
.annotate 'line', 775
    set $P1785, $P1817
  if_1786_end:
    set $P1735, $P1785
.annotate 'line', 769
    goto if_1736_end
  if_1736:
.annotate 'line', 770
    find_dynamic_lex $P1751, "$*SC"
    unless_null $P1751, vivify_1172
    get_hll_global $P1749, "GLOBAL"
    get_who $P1750, $P1749
    set $P1751, $P1750["$SC"]
    unless_null $P1751, vivify_1173
    die "Contextual $*SC not found"
  vivify_1173:
  vivify_1172:
    find_dynamic_lex $P1754, "$*OUTERPACKAGE"
    unless_null $P1754, vivify_1174
    get_hll_global $P1752, "GLOBAL"
    get_who $P1753, $P1752
    set $P1754, $P1753["$OUTERPACKAGE"]
    unless_null $P1754, vivify_1175
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1175:
  vivify_1174:
    find_lex $P1755, "$/"
    unless_null $P1755, vivify_1176
    $P1755 = root_new ['parrot';'Hash']
  vivify_1176:
    set $P1756, $P1755["name"]
    unless_null $P1756, vivify_1177
    $P1756 = root_new ['parrot';'Hash']
  vivify_1177:
    set $P1757, $P1756["identifier"]
    unless_null $P1757, vivify_1178
    new $P1757, "Undef"
  vivify_1178:
    find_dynamic_lex $P1760, "$*PACKAGE"
    unless_null $P1760, vivify_1179
    get_hll_global $P1758, "GLOBAL"
    get_who $P1759, $P1758
    set $P1760, $P1759["$PACKAGE"]
    unless_null $P1760, vivify_1180
    die "Contextual $*PACKAGE not found"
  vivify_1180:
  vivify_1179:
    $P1751."install_package_symbol"($P1754, $P1757, $P1760)
.annotate 'line', 771
    find_lex $P1763, "$/"
    unless_null $P1763, vivify_1181
    $P1763 = root_new ['parrot';'Hash']
  vivify_1181:
    set $P1764, $P1763["name"]
    unless_null $P1764, vivify_1182
    $P1764 = root_new ['parrot';'Hash']
  vivify_1182:
    set $P1765, $P1764["identifier"]
    unless_null $P1765, vivify_1183
    new $P1765, "Undef"
  vivify_1183:
    set $N1766, $P1765
    iseq $I1767, $N1766, 1.0
    if $I1767, if_1762
    new $P1761, 'Integer'
    set $P1761, $I1767
    goto if_1762_end
  if_1762:
.annotate 'line', 772
    find_dynamic_lex $P1770, "$*SC"
    unless_null $P1770, vivify_1184
    get_hll_global $P1768, "GLOBAL"
    get_who $P1769, $P1768
    set $P1770, $P1769["$SC"]
    unless_null $P1770, vivify_1185
    die "Contextual $*SC not found"
  vivify_1185:
  vivify_1184:
    get_hll_global $P1771, "GLOBAL"
    nqp_get_package_through_who $P1772, $P1771, "NQP"
    nqp_get_package_through_who $P1773, $P1772, "Actions"
    get_who $P1774, $P1773
    set $P1775, $P1774["@BLOCK"]
    unless_null $P1775, vivify_1186
    $P1775 = root_new ['parrot';'ResizablePMCArray']
  vivify_1186:
    set $P1776, $P1775[0]
    unless_null $P1776, vivify_1187
    new $P1776, "Undef"
  vivify_1187:
    find_lex $P1777, "$/"
    unless_null $P1777, vivify_1188
    $P1777 = root_new ['parrot';'Hash']
  vivify_1188:
    set $P1778, $P1777["name"]
    unless_null $P1778, vivify_1189
    $P1778 = root_new ['parrot';'Hash']
  vivify_1189:
    set $P1779, $P1778["identifier"]
    unless_null $P1779, vivify_1190
    $P1779 = root_new ['parrot';'ResizablePMCArray']
  vivify_1190:
    set $P1780, $P1779[0]
    unless_null $P1780, vivify_1191
    new $P1780, "Undef"
  vivify_1191:
    find_dynamic_lex $P1783, "$*PACKAGE"
    unless_null $P1783, vivify_1192
    get_hll_global $P1781, "GLOBAL"
    get_who $P1782, $P1781
    set $P1783, $P1782["$PACKAGE"]
    unless_null $P1783, vivify_1193
    die "Contextual $*PACKAGE not found"
  vivify_1193:
  vivify_1192:
    $P1784 = $P1770."install_lexical_symbol"($P1776, $P1780, $P1783)
.annotate 'line', 771
    set $P1761, $P1784
  if_1762_end:
.annotate 'line', 769
    set $P1735, $P1761
  if_1736_end:
.annotate 'line', 758
    .return ($P1735)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("180_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1848 = self."!PREFIX__!subrule"("ws", "")
    new $P1849, "ResizablePMCArray"
    push $P1849, $P1848
    .return ($P1849)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("181_1304523757.895")
    .param pmc param_1851
.annotate 'line', 795
    .lex "self", param_1851
    $P1852 = param_1851."!protoregex"("scope_declarator")
    .return ($P1852)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("182_1304523757.895")
    .param pmc param_1854
.annotate 'line', 795
    .lex "self", param_1854
    $P1855 = param_1854."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1855)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("183_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1857_tgt
    .local int rx1857_pos
    .local int rx1857_off
    .local int rx1857_eos
    .local int rx1857_rep
    .local pmc rx1857_cur
    .local pmc rx1857_debug
    (rx1857_cur, rx1857_pos, rx1857_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1857_cur
    .local pmc match
    .lex "$/", match
    length rx1857_eos, rx1857_tgt
    gt rx1857_pos, rx1857_eos, rx1857_done
    set rx1857_off, 0
    lt rx1857_pos, 2, rx1857_start
    sub rx1857_off, rx1857_pos, 1
    substr rx1857_tgt, rx1857_tgt, rx1857_off
  rx1857_start:
    eq $I10, 1, rx1857_restart
    if_null rx1857_debug, debug_1197
    rx1857_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1197:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1858_done
    goto rxscan1858_scan
  rxscan1858_loop:
    (rx1857_pos) = rx1857_cur."from"()
    inc rx1857_pos
    rx1857_cur."!cursor_from"(rx1857_pos)
    ge rx1857_pos, rx1857_eos, rxscan1858_done
  rxscan1858_scan:
    set_addr $I10, rxscan1858_loop
    rx1857_cur."!mark_push"(0, rx1857_pos, $I10)
  rxscan1858_done:
.annotate 'line', 796
  # rx subcapture "sym"
    set_addr $I10, rxcap_1859_fail
    rx1857_cur."!mark_push"(0, rx1857_pos, $I10)
  # rx literal  "my"
    add $I11, rx1857_pos, 2
    gt $I11, rx1857_eos, rx1857_fail
    sub $I11, rx1857_pos, rx1857_off
    substr $S10, rx1857_tgt, $I11, 2
    ne $S10, "my", rx1857_fail
    add rx1857_pos, 2
    set_addr $I10, rxcap_1859_fail
    ($I12, $I11) = rx1857_cur."!mark_peek"($I10)
    rx1857_cur."!cursor_pos"($I11)
    ($P10) = rx1857_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1857_pos, "")
    rx1857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1859_done
  rxcap_1859_fail:
    goto rx1857_fail
  rxcap_1859_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1857_cur."!cursor_pos"(rx1857_pos)
    $P10 = rx1857_cur."scoped"("my")
    unless $P10, rx1857_fail
    rx1857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1857_pos = $P10."pos"()
  # rx pass
    rx1857_cur."!cursor_pass"(rx1857_pos, "scope_declarator:sym<my>")
    if_null rx1857_debug, debug_1198
    rx1857_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1857_pos)
  debug_1198:
    .return (rx1857_cur)
  rx1857_restart:
.annotate 'line', 422
    if_null rx1857_debug, debug_1199
    rx1857_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1199:
  rx1857_fail:
    (rx1857_rep, rx1857_pos, $I10, $P10) = rx1857_cur."!mark_fail"(0)
    lt rx1857_pos, -1, rx1857_done
    eq rx1857_pos, -1, rx1857_fail
    jump $I10
  rx1857_done:
    rx1857_cur."!cursor_fail"()
    if_null rx1857_debug, debug_1200
    rx1857_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1200:
    .return (rx1857_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("184_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1861 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1862, "ResizablePMCArray"
    push $P1862, $P1861
    .return ($P1862)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("185_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1864_tgt
    .local int rx1864_pos
    .local int rx1864_off
    .local int rx1864_eos
    .local int rx1864_rep
    .local pmc rx1864_cur
    .local pmc rx1864_debug
    (rx1864_cur, rx1864_pos, rx1864_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1864_cur
    .local pmc match
    .lex "$/", match
    length rx1864_eos, rx1864_tgt
    gt rx1864_pos, rx1864_eos, rx1864_done
    set rx1864_off, 0
    lt rx1864_pos, 2, rx1864_start
    sub rx1864_off, rx1864_pos, 1
    substr rx1864_tgt, rx1864_tgt, rx1864_off
  rx1864_start:
    eq $I10, 1, rx1864_restart
    if_null rx1864_debug, debug_1201
    rx1864_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1201:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1865_done
    goto rxscan1865_scan
  rxscan1865_loop:
    (rx1864_pos) = rx1864_cur."from"()
    inc rx1864_pos
    rx1864_cur."!cursor_from"(rx1864_pos)
    ge rx1864_pos, rx1864_eos, rxscan1865_done
  rxscan1865_scan:
    set_addr $I10, rxscan1865_loop
    rx1864_cur."!mark_push"(0, rx1864_pos, $I10)
  rxscan1865_done:
.annotate 'line', 797
  # rx subcapture "sym"
    set_addr $I10, rxcap_1866_fail
    rx1864_cur."!mark_push"(0, rx1864_pos, $I10)
  # rx literal  "our"
    add $I11, rx1864_pos, 3
    gt $I11, rx1864_eos, rx1864_fail
    sub $I11, rx1864_pos, rx1864_off
    substr $S10, rx1864_tgt, $I11, 3
    ne $S10, "our", rx1864_fail
    add rx1864_pos, 3
    set_addr $I10, rxcap_1866_fail
    ($I12, $I11) = rx1864_cur."!mark_peek"($I10)
    rx1864_cur."!cursor_pos"($I11)
    ($P10) = rx1864_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1864_pos, "")
    rx1864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1866_done
  rxcap_1866_fail:
    goto rx1864_fail
  rxcap_1866_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1864_cur."!cursor_pos"(rx1864_pos)
    $P10 = rx1864_cur."scoped"("our")
    unless $P10, rx1864_fail
    rx1864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1864_pos = $P10."pos"()
  # rx pass
    rx1864_cur."!cursor_pass"(rx1864_pos, "scope_declarator:sym<our>")
    if_null rx1864_debug, debug_1202
    rx1864_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1864_pos)
  debug_1202:
    .return (rx1864_cur)
  rx1864_restart:
.annotate 'line', 422
    if_null rx1864_debug, debug_1203
    rx1864_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1203:
  rx1864_fail:
    (rx1864_rep, rx1864_pos, $I10, $P10) = rx1864_cur."!mark_fail"(0)
    lt rx1864_pos, -1, rx1864_done
    eq rx1864_pos, -1, rx1864_fail
    jump $I10
  rx1864_done:
    rx1864_cur."!cursor_fail"()
    if_null rx1864_debug, debug_1204
    rx1864_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1204:
    .return (rx1864_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("186_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1868 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1869, "ResizablePMCArray"
    push $P1869, $P1868
    .return ($P1869)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("187_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1871_tgt
    .local int rx1871_pos
    .local int rx1871_off
    .local int rx1871_eos
    .local int rx1871_rep
    .local pmc rx1871_cur
    .local pmc rx1871_debug
    (rx1871_cur, rx1871_pos, rx1871_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1871_cur
    .local pmc match
    .lex "$/", match
    length rx1871_eos, rx1871_tgt
    gt rx1871_pos, rx1871_eos, rx1871_done
    set rx1871_off, 0
    lt rx1871_pos, 2, rx1871_start
    sub rx1871_off, rx1871_pos, 1
    substr rx1871_tgt, rx1871_tgt, rx1871_off
  rx1871_start:
    eq $I10, 1, rx1871_restart
    if_null rx1871_debug, debug_1205
    rx1871_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1205:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1872_done
    goto rxscan1872_scan
  rxscan1872_loop:
    (rx1871_pos) = rx1871_cur."from"()
    inc rx1871_pos
    rx1871_cur."!cursor_from"(rx1871_pos)
    ge rx1871_pos, rx1871_eos, rxscan1872_done
  rxscan1872_scan:
    set_addr $I10, rxscan1872_loop
    rx1871_cur."!mark_push"(0, rx1871_pos, $I10)
  rxscan1872_done:
.annotate 'line', 798
  # rx subcapture "sym"
    set_addr $I10, rxcap_1873_fail
    rx1871_cur."!mark_push"(0, rx1871_pos, $I10)
  # rx literal  "has"
    add $I11, rx1871_pos, 3
    gt $I11, rx1871_eos, rx1871_fail
    sub $I11, rx1871_pos, rx1871_off
    substr $S10, rx1871_tgt, $I11, 3
    ne $S10, "has", rx1871_fail
    add rx1871_pos, 3
    set_addr $I10, rxcap_1873_fail
    ($I12, $I11) = rx1871_cur."!mark_peek"($I10)
    rx1871_cur."!cursor_pos"($I11)
    ($P10) = rx1871_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1871_pos, "")
    rx1871_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1873_done
  rxcap_1873_fail:
    goto rx1871_fail
  rxcap_1873_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1871_cur."!cursor_pos"(rx1871_pos)
    $P10 = rx1871_cur."scoped"("has")
    unless $P10, rx1871_fail
    rx1871_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1871_pos = $P10."pos"()
  # rx pass
    rx1871_cur."!cursor_pass"(rx1871_pos, "scope_declarator:sym<has>")
    if_null rx1871_debug, debug_1206
    rx1871_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1871_pos)
  debug_1206:
    .return (rx1871_cur)
  rx1871_restart:
.annotate 'line', 422
    if_null rx1871_debug, debug_1207
    rx1871_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1207:
  rx1871_fail:
    (rx1871_rep, rx1871_pos, $I10, $P10) = rx1871_cur."!mark_fail"(0)
    lt rx1871_pos, -1, rx1871_done
    eq rx1871_pos, -1, rx1871_fail
    jump $I10
  rx1871_done:
    rx1871_cur."!cursor_fail"()
    if_null rx1871_debug, debug_1208
    rx1871_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1208:
    .return (rx1871_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("188_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1875 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1876, "ResizablePMCArray"
    push $P1876, $P1875
    .return ($P1876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("189_1304523757.895") :method :outer("38_1304523757.895")
    .param pmc param_1878
.annotate 'line', 800
    .lex "$*SCOPE", param_1878
.annotate 'line', 422
    .local string rx1879_tgt
    .local int rx1879_pos
    .local int rx1879_off
    .local int rx1879_eos
    .local int rx1879_rep
    .local pmc rx1879_cur
    .local pmc rx1879_debug
    (rx1879_cur, rx1879_pos, rx1879_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1879_cur
    .local pmc match
    .lex "$/", match
    length rx1879_eos, rx1879_tgt
    gt rx1879_pos, rx1879_eos, rx1879_done
    set rx1879_off, 0
    lt rx1879_pos, 2, rx1879_start
    sub rx1879_off, rx1879_pos, 1
    substr rx1879_tgt, rx1879_tgt, rx1879_off
  rx1879_start:
    eq $I10, 1, rx1879_restart
    if_null rx1879_debug, debug_1209
    rx1879_cur."!cursor_debug"("START", "scoped")
  debug_1209:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1880_done
    goto rxscan1880_scan
  rxscan1880_loop:
    (rx1879_pos) = rx1879_cur."from"()
    inc rx1879_pos
    rx1879_cur."!cursor_from"(rx1879_pos)
    ge rx1879_pos, rx1879_eos, rxscan1880_done
  rxscan1880_scan:
    set_addr $I10, rxscan1880_loop
    rx1879_cur."!mark_push"(0, rx1879_pos, $I10)
  rxscan1880_done:
  alt1881_0:
.annotate 'line', 800
    set_addr $I10, alt1881_1
    rx1879_cur."!mark_push"(0, rx1879_pos, $I10)
.annotate 'line', 801
  # rx subrule "ws" subtype=method negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."ws"()
    unless $P10, rx1879_fail
    rx1879_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."declarator"()
    unless $P10, rx1879_fail
    rx1879_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1879_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."ws"()
    unless $P10, rx1879_fail
    rx1879_pos = $P10."pos"()
    goto alt1881_end
  alt1881_1:
    set_addr $I10, alt1881_2
    rx1879_cur."!mark_push"(0, rx1879_pos, $I10)
.annotate 'line', 802
  # rx subrule "ws" subtype=method negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."ws"()
    unless $P10, rx1879_fail
    rx1879_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."multi_declarator"()
    unless $P10, rx1879_fail
    rx1879_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1879_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."ws"()
    unless $P10, rx1879_fail
    rx1879_pos = $P10."pos"()
    goto alt1881_end
  alt1881_2:
.annotate 'line', 803
  # rx subrule "ws" subtype=method negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."ws"()
    unless $P10, rx1879_fail
    rx1879_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."package_declarator"()
    unless $P10, rx1879_fail
    rx1879_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1879_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1879_cur."!cursor_pos"(rx1879_pos)
    $P10 = rx1879_cur."ws"()
    unless $P10, rx1879_fail
    rx1879_pos = $P10."pos"()
  alt1881_end:
.annotate 'line', 800
  # rx pass
    rx1879_cur."!cursor_pass"(rx1879_pos, "scoped")
    if_null rx1879_debug, debug_1210
    rx1879_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1879_pos)
  debug_1210:
    .return (rx1879_cur)
  rx1879_restart:
.annotate 'line', 422
    if_null rx1879_debug, debug_1211
    rx1879_cur."!cursor_debug"("NEXT", "scoped")
  debug_1211:
  rx1879_fail:
    (rx1879_rep, rx1879_pos, $I10, $P10) = rx1879_cur."!mark_fail"(0)
    lt rx1879_pos, -1, rx1879_done
    eq rx1879_pos, -1, rx1879_fail
    jump $I10
  rx1879_done:
    rx1879_cur."!cursor_fail"()
    if_null rx1879_debug, debug_1212
    rx1879_cur."!cursor_debug"("FAIL", "scoped")
  debug_1212:
    .return (rx1879_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("190_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1889 = self."!PREFIX__!subrule"("ws", "")
    $P1890 = self."!PREFIX__!subrule"("ws", "")
    $P1891 = self."!PREFIX__!subrule"("ws", "")
    new $P1892, "ResizablePMCArray"
    push $P1892, $P1889
    push $P1892, $P1890
    push $P1892, $P1891
    .return ($P1892)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("191_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1899 = "192_1304523757.895" 
    capture_lex $P1899
    .local string rx1894_tgt
    .local int rx1894_pos
    .local int rx1894_off
    .local int rx1894_eos
    .local int rx1894_rep
    .local pmc rx1894_cur
    .local pmc rx1894_debug
    (rx1894_cur, rx1894_pos, rx1894_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1894_cur
    .local pmc match
    .lex "$/", match
    length rx1894_eos, rx1894_tgt
    gt rx1894_pos, rx1894_eos, rx1894_done
    set rx1894_off, 0
    lt rx1894_pos, 2, rx1894_start
    sub rx1894_off, rx1894_pos, 1
    substr rx1894_tgt, rx1894_tgt, rx1894_off
  rx1894_start:
    eq $I10, 1, rx1894_restart
    if_null rx1894_debug, debug_1213
    rx1894_cur."!cursor_debug"("START", "typename")
  debug_1213:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1895_done
    goto rxscan1895_scan
  rxscan1895_loop:
    (rx1894_pos) = rx1894_cur."from"()
    inc rx1894_pos
    rx1894_cur."!cursor_from"(rx1894_pos)
    ge rx1894_pos, rx1894_eos, rxscan1895_done
  rxscan1895_scan:
    set_addr $I10, rxscan1895_loop
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxscan1895_done:
.annotate 'line', 807
  # rx subrule "name" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."name"()
    unless $P10, rx1894_fail
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1894_pos = $P10."pos"()
.annotate 'line', 808
    rx1894_cur."!cursor_pos"(rx1894_pos)
    find_lex $P1896, unicode:"$\x{a2}"
    $P1897 = $P1896."MATCH"()
    store_lex "$/", $P1897
    .const 'Sub' $P1899 = "192_1304523757.895" 
    capture_lex $P1899
    $P1908 = $P1899()
    unless $P1908, rx1894_fail
.annotate 'line', 806
  # rx pass
    rx1894_cur."!cursor_pass"(rx1894_pos, "typename")
    if_null rx1894_debug, debug_1220
    rx1894_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1894_pos)
  debug_1220:
    .return (rx1894_cur)
  rx1894_restart:
.annotate 'line', 422
    if_null rx1894_debug, debug_1221
    rx1894_cur."!cursor_debug"("NEXT", "typename")
  debug_1221:
  rx1894_fail:
    (rx1894_rep, rx1894_pos, $I10, $P10) = rx1894_cur."!mark_fail"(0)
    lt rx1894_pos, -1, rx1894_done
    eq rx1894_pos, -1, rx1894_fail
    jump $I10
  rx1894_done:
    rx1894_cur."!cursor_fail"()
    if_null rx1894_debug, debug_1222
    rx1894_cur."!cursor_debug"("FAIL", "typename")
  debug_1222:
    .return (rx1894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1898"  :anon :subid("192_1304523757.895") :outer("191_1304523757.895")
.annotate 'line', 808
    find_dynamic_lex $P1902, "$*ACTIONS"
    unless_null $P1902, vivify_1214
    get_hll_global $P1900, "GLOBAL"
    get_who $P1901, $P1900
    set $P1902, $P1901["$ACTIONS"]
    unless_null $P1902, vivify_1215
    die "Contextual $*ACTIONS not found"
  vivify_1215:
  vivify_1214:
    find_lex $P1903, "$/"
    unless_null $P1903, vivify_1216
    new $P1903, "Undef"
  vivify_1216:
    find_lex $P1904, "$/"
    unless_null $P1904, vivify_1217
    $P1904 = root_new ['parrot';'Hash']
  vivify_1217:
    set $P1905, $P1904["name"]
    unless_null $P1905, vivify_1218
    $P1905 = root_new ['parrot';'Hash']
  vivify_1218:
    set $P1906, $P1905["identifier"]
    unless_null $P1906, vivify_1219
    new $P1906, "Undef"
  vivify_1219:
    $P1907 = $P1902."known_sym"($P1903, $P1906)
    .return ($P1907)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("193_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1910 = self."!PREFIX__!subrule"("name", "")
    new $P1911, "ResizablePMCArray"
    push $P1911, $P1910
    .return ($P1911)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("194_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1913_tgt
    .local int rx1913_pos
    .local int rx1913_off
    .local int rx1913_eos
    .local int rx1913_rep
    .local pmc rx1913_cur
    .local pmc rx1913_debug
    (rx1913_cur, rx1913_pos, rx1913_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1913_cur
    .local pmc match
    .lex "$/", match
    length rx1913_eos, rx1913_tgt
    gt rx1913_pos, rx1913_eos, rx1913_done
    set rx1913_off, 0
    lt rx1913_pos, 2, rx1913_start
    sub rx1913_off, rx1913_pos, 1
    substr rx1913_tgt, rx1913_tgt, rx1913_off
  rx1913_start:
    eq $I10, 1, rx1913_restart
    if_null rx1913_debug, debug_1223
    rx1913_cur."!cursor_debug"("START", "declarator")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1914_done
    goto rxscan1914_scan
  rxscan1914_loop:
    (rx1913_pos) = rx1913_cur."from"()
    inc rx1913_pos
    rx1913_cur."!cursor_from"(rx1913_pos)
    ge rx1913_pos, rx1913_eos, rxscan1914_done
  rxscan1914_scan:
    set_addr $I10, rxscan1914_loop
    rx1913_cur."!mark_push"(0, rx1913_pos, $I10)
  rxscan1914_done:
  alt1915_0:
.annotate 'line', 811
    set_addr $I10, alt1915_1
    rx1913_cur."!mark_push"(0, rx1913_pos, $I10)
.annotate 'line', 812
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1913_cur."!cursor_pos"(rx1913_pos)
    $P10 = rx1913_cur."variable_declarator"()
    unless $P10, rx1913_fail
    rx1913_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1913_pos = $P10."pos"()
    goto alt1915_end
  alt1915_1:
.annotate 'line', 813
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1913_cur."!cursor_pos"(rx1913_pos)
    $P10 = rx1913_cur."routine_declarator"()
    unless $P10, rx1913_fail
    rx1913_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1913_pos = $P10."pos"()
  alt1915_end:
.annotate 'line', 811
  # rx pass
    rx1913_cur."!cursor_pass"(rx1913_pos, "declarator")
    if_null rx1913_debug, debug_1224
    rx1913_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1913_pos)
  debug_1224:
    .return (rx1913_cur)
  rx1913_restart:
.annotate 'line', 422
    if_null rx1913_debug, debug_1225
    rx1913_cur."!cursor_debug"("NEXT", "declarator")
  debug_1225:
  rx1913_fail:
    (rx1913_rep, rx1913_pos, $I10, $P10) = rx1913_cur."!mark_fail"(0)
    lt rx1913_pos, -1, rx1913_done
    eq rx1913_pos, -1, rx1913_fail
    jump $I10
  rx1913_done:
    rx1913_cur."!cursor_fail"()
    if_null rx1913_debug, debug_1226
    rx1913_cur."!cursor_debug"("FAIL", "declarator")
  debug_1226:
    .return (rx1913_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("195_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1917 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1918 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1919, "ResizablePMCArray"
    push $P1919, $P1917
    push $P1919, $P1918
    .return ($P1919)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("196_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P1934 = "197_1304523757.895" 
    capture_lex $P1934
.annotate 'line', 818
    new $P1921, "Undef"
    .lex "$*IN_DECL", $P1921
.annotate 'line', 422
    .local string rx1922_tgt
    .local int rx1922_pos
    .local int rx1922_off
    .local int rx1922_eos
    .local int rx1922_rep
    .local pmc rx1922_cur
    .local pmc rx1922_debug
    (rx1922_cur, rx1922_pos, rx1922_tgt, $I10) = self."!cursor_start"()
    rx1922_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1922_cur
    .local pmc match
    .lex "$/", match
    length rx1922_eos, rx1922_tgt
    gt rx1922_pos, rx1922_eos, rx1922_done
    set rx1922_off, 0
    lt rx1922_pos, 2, rx1922_start
    sub rx1922_off, rx1922_pos, 1
    substr rx1922_tgt, rx1922_tgt, rx1922_off
  rx1922_start:
    eq $I10, 1, rx1922_restart
    if_null rx1922_debug, debug_1227
    rx1922_cur."!cursor_debug"("START", "variable_declarator")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1923_done
    goto rxscan1923_scan
  rxscan1923_loop:
    (rx1922_pos) = rx1922_cur."from"()
    inc rx1922_pos
    rx1922_cur."!cursor_from"(rx1922_pos)
    ge rx1922_pos, rx1922_eos, rxscan1923_done
  rxscan1923_scan:
    set_addr $I10, rxscan1923_loop
    rx1922_cur."!mark_push"(0, rx1922_pos, $I10)
  rxscan1923_done:
.annotate 'line', 816
  # rx subrule "ws" subtype=method negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."ws"()
    unless $P10, rx1922_fail
    rx1922_pos = $P10."pos"()
.annotate 'line', 817
  # rx rxquantr1925 ** 0..1
    set_addr $I10, rxquantr1925_done
    rx1922_cur."!mark_push"(0, rx1922_pos, $I10)
  rxquantr1925_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."typename"()
    unless $P10, rx1922_fail
    goto rxsubrule1926_pass
  rxsubrule1926_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1922_fail
  rxsubrule1926_pass:
    set_addr $I10, rxsubrule1926_back
    rx1922_cur."!mark_push"(0, rx1922_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1922_pos = $P10."pos"()
    set_addr $I10, rxquantr1925_done
    (rx1922_rep) = rx1922_cur."!mark_commit"($I10)
  rxquantr1925_done:
  # rx subrule "ws" subtype=method negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."ws"()
    unless $P10, rx1922_fail
    rx1922_pos = $P10."pos"()
.annotate 'line', 818
    rx1922_cur."!cursor_pos"(rx1922_pos)
    new $P1928, "String"
    assign $P1928, "variable"
    store_lex "$*IN_DECL", $P1928
  # rx subrule "ws" subtype=method negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."ws"()
    unless $P10, rx1922_fail
    rx1922_pos = $P10."pos"()
.annotate 'line', 819
  # rx subrule "variable" subtype=capture negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."variable"()
    unless $P10, rx1922_fail
    rx1922_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1922_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."ws"()
    unless $P10, rx1922_fail
    rx1922_pos = $P10."pos"()
.annotate 'line', 820
    rx1922_cur."!cursor_pos"(rx1922_pos)
    find_lex $P1931, unicode:"$\x{a2}"
    $P1932 = $P1931."MATCH"()
    store_lex "$/", $P1932
    .const 'Sub' $P1934 = "197_1304523757.895" 
    capture_lex $P1934
    $P1936 = $P1934()
  # rx subrule "ws" subtype=method negate=
    rx1922_cur."!cursor_pos"(rx1922_pos)
    $P10 = rx1922_cur."ws"()
    unless $P10, rx1922_fail
    rx1922_pos = $P10."pos"()
.annotate 'line', 816
  # rx pass
    rx1922_cur."!cursor_pass"(rx1922_pos, "variable_declarator")
    if_null rx1922_debug, debug_1228
    rx1922_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1922_pos)
  debug_1228:
    .return (rx1922_cur)
  rx1922_restart:
.annotate 'line', 422
    if_null rx1922_debug, debug_1229
    rx1922_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1229:
  rx1922_fail:
    (rx1922_rep, rx1922_pos, $I10, $P10) = rx1922_cur."!mark_fail"(0)
    lt rx1922_pos, -1, rx1922_done
    eq rx1922_pos, -1, rx1922_fail
    jump $I10
  rx1922_done:
    rx1922_cur."!cursor_fail"()
    if_null rx1922_debug, debug_1230
    rx1922_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1230:
    .return (rx1922_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1933"  :anon :subid("197_1304523757.895") :outer("196_1304523757.895")
.annotate 'line', 820
    new $P1935, "Integer"
    assign $P1935, 0
    store_dynamic_lex "$*IN_DECL", $P1935
    .return ($P1935)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("198_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1939 = self."!PREFIX__!subrule"("ws", "")
    new $P1940, "ResizablePMCArray"
    push $P1940, $P1939
    .return ($P1940)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("199_1304523757.895")
    .param pmc param_1942
.annotate 'line', 823
    .lex "self", param_1942
    $P1943 = param_1942."!protoregex"("routine_declarator")
    .return ($P1943)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("200_1304523757.895")
    .param pmc param_1945
.annotate 'line', 823
    .lex "self", param_1945
    $P1946 = param_1945."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1946)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("201_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1948_tgt
    .local int rx1948_pos
    .local int rx1948_off
    .local int rx1948_eos
    .local int rx1948_rep
    .local pmc rx1948_cur
    .local pmc rx1948_debug
    (rx1948_cur, rx1948_pos, rx1948_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1948_cur
    .local pmc match
    .lex "$/", match
    length rx1948_eos, rx1948_tgt
    gt rx1948_pos, rx1948_eos, rx1948_done
    set rx1948_off, 0
    lt rx1948_pos, 2, rx1948_start
    sub rx1948_off, rx1948_pos, 1
    substr rx1948_tgt, rx1948_tgt, rx1948_off
  rx1948_start:
    eq $I10, 1, rx1948_restart
    if_null rx1948_debug, debug_1231
    rx1948_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1949_done
    goto rxscan1949_scan
  rxscan1949_loop:
    (rx1948_pos) = rx1948_cur."from"()
    inc rx1948_pos
    rx1948_cur."!cursor_from"(rx1948_pos)
    ge rx1948_pos, rx1948_eos, rxscan1949_done
  rxscan1949_scan:
    set_addr $I10, rxscan1949_loop
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
  rxscan1949_done:
.annotate 'line', 824
  # rx subcapture "sym"
    set_addr $I10, rxcap_1950_fail
    rx1948_cur."!mark_push"(0, rx1948_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1948_pos, 3
    gt $I11, rx1948_eos, rx1948_fail
    sub $I11, rx1948_pos, rx1948_off
    substr $S10, rx1948_tgt, $I11, 3
    ne $S10, "sub", rx1948_fail
    add rx1948_pos, 3
    set_addr $I10, rxcap_1950_fail
    ($I12, $I11) = rx1948_cur."!mark_peek"($I10)
    rx1948_cur."!cursor_pos"($I11)
    ($P10) = rx1948_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1948_pos, "")
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1950_done
  rxcap_1950_fail:
    goto rx1948_fail
  rxcap_1950_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1948_cur."!cursor_pos"(rx1948_pos)
    $P10 = rx1948_cur."routine_def"()
    unless $P10, rx1948_fail
    rx1948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1948_pos = $P10."pos"()
  # rx pass
    rx1948_cur."!cursor_pass"(rx1948_pos, "routine_declarator:sym<sub>")
    if_null rx1948_debug, debug_1232
    rx1948_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1948_pos)
  debug_1232:
    .return (rx1948_cur)
  rx1948_restart:
.annotate 'line', 422
    if_null rx1948_debug, debug_1233
    rx1948_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1233:
  rx1948_fail:
    (rx1948_rep, rx1948_pos, $I10, $P10) = rx1948_cur."!mark_fail"(0)
    lt rx1948_pos, -1, rx1948_done
    eq rx1948_pos, -1, rx1948_fail
    jump $I10
  rx1948_done:
    rx1948_cur."!cursor_fail"()
    if_null rx1948_debug, debug_1234
    rx1948_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1234:
    .return (rx1948_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("202_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1952 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1953, "ResizablePMCArray"
    push $P1953, $P1952
    .return ($P1953)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("203_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx1955_tgt
    .local int rx1955_pos
    .local int rx1955_off
    .local int rx1955_eos
    .local int rx1955_rep
    .local pmc rx1955_cur
    .local pmc rx1955_debug
    (rx1955_cur, rx1955_pos, rx1955_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1955_cur
    .local pmc match
    .lex "$/", match
    length rx1955_eos, rx1955_tgt
    gt rx1955_pos, rx1955_eos, rx1955_done
    set rx1955_off, 0
    lt rx1955_pos, 2, rx1955_start
    sub rx1955_off, rx1955_pos, 1
    substr rx1955_tgt, rx1955_tgt, rx1955_off
  rx1955_start:
    eq $I10, 1, rx1955_restart
    if_null rx1955_debug, debug_1235
    rx1955_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1956_done
    goto rxscan1956_scan
  rxscan1956_loop:
    (rx1955_pos) = rx1955_cur."from"()
    inc rx1955_pos
    rx1955_cur."!cursor_from"(rx1955_pos)
    ge rx1955_pos, rx1955_eos, rxscan1956_done
  rxscan1956_scan:
    set_addr $I10, rxscan1956_loop
    rx1955_cur."!mark_push"(0, rx1955_pos, $I10)
  rxscan1956_done:
.annotate 'line', 825
  # rx subcapture "sym"
    set_addr $I10, rxcap_1957_fail
    rx1955_cur."!mark_push"(0, rx1955_pos, $I10)
  # rx literal  "method"
    add $I11, rx1955_pos, 6
    gt $I11, rx1955_eos, rx1955_fail
    sub $I11, rx1955_pos, rx1955_off
    substr $S10, rx1955_tgt, $I11, 6
    ne $S10, "method", rx1955_fail
    add rx1955_pos, 6
    set_addr $I10, rxcap_1957_fail
    ($I12, $I11) = rx1955_cur."!mark_peek"($I10)
    rx1955_cur."!cursor_pos"($I11)
    ($P10) = rx1955_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1955_pos, "")
    rx1955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1957_done
  rxcap_1957_fail:
    goto rx1955_fail
  rxcap_1957_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1955_cur."!cursor_pos"(rx1955_pos)
    $P10 = rx1955_cur."method_def"()
    unless $P10, rx1955_fail
    rx1955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1955_pos = $P10."pos"()
  # rx pass
    rx1955_cur."!cursor_pass"(rx1955_pos, "routine_declarator:sym<method>")
    if_null rx1955_debug, debug_1236
    rx1955_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1955_pos)
  debug_1236:
    .return (rx1955_cur)
  rx1955_restart:
.annotate 'line', 422
    if_null rx1955_debug, debug_1237
    rx1955_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1237:
  rx1955_fail:
    (rx1955_rep, rx1955_pos, $I10, $P10) = rx1955_cur."!mark_fail"(0)
    lt rx1955_pos, -1, rx1955_done
    eq rx1955_pos, -1, rx1955_fail
    jump $I10
  rx1955_done:
    rx1955_cur."!cursor_fail"()
    if_null rx1955_debug, debug_1238
    rx1955_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1238:
    .return (rx1955_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("204_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1959 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1960, "ResizablePMCArray"
    push $P1960, $P1959
    .return ($P1960)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("205_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 828
    new $P1962, "Undef"
    .lex "$*RETURN_USED", $P1962
.annotate 'line', 422
    .local string rx1963_tgt
    .local int rx1963_pos
    .local int rx1963_off
    .local int rx1963_eos
    .local int rx1963_rep
    .local pmc rx1963_cur
    .local pmc rx1963_debug
    (rx1963_cur, rx1963_pos, rx1963_tgt, $I10) = self."!cursor_start"()
    rx1963_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1963_cur
    .local pmc match
    .lex "$/", match
    length rx1963_eos, rx1963_tgt
    gt rx1963_pos, rx1963_eos, rx1963_done
    set rx1963_off, 0
    lt rx1963_pos, 2, rx1963_start
    sub rx1963_off, rx1963_pos, 1
    substr rx1963_tgt, rx1963_tgt, rx1963_off
  rx1963_start:
    eq $I10, 1, rx1963_restart
    if_null rx1963_debug, debug_1239
    rx1963_cur."!cursor_debug"("START", "routine_def")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1964_done
    goto rxscan1964_scan
  rxscan1964_loop:
    (rx1963_pos) = rx1963_cur."from"()
    inc rx1963_pos
    rx1963_cur."!cursor_from"(rx1963_pos)
    ge rx1963_pos, rx1963_eos, rxscan1964_done
  rxscan1964_scan:
    set_addr $I10, rxscan1964_loop
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  rxscan1964_done:
.annotate 'line', 827
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
.annotate 'line', 828
    rx1963_cur."!cursor_pos"(rx1963_pos)
    new $P1966, "Integer"
    assign $P1966, 0
    store_lex "$*RETURN_USED", $P1966
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
.annotate 'line', 829
  # rx rxquantr1968 ** 0..1
    set_addr $I10, rxquantr1968_done
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  rxquantr1968_loop:
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1971_fail
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  # rx rxquantr1970 ** 0..1
    set_addr $I10, rxquantr1970_done
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  rxquantr1970_loop:
  # rx literal  "&"
    add $I11, rx1963_pos, 1
    gt $I11, rx1963_eos, rx1963_fail
    sub $I11, rx1963_pos, rx1963_off
    ord $I11, rx1963_tgt, $I11
    ne $I11, 38, rx1963_fail
    add rx1963_pos, 1
    set_addr $I10, rxquantr1970_done
    (rx1963_rep) = rx1963_cur."!mark_commit"($I10)
  rxquantr1970_done:
    set_addr $I10, rxcap_1971_fail
    ($I12, $I11) = rx1963_cur."!mark_peek"($I10)
    rx1963_cur."!cursor_pos"($I11)
    ($P10) = rx1963_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1963_pos, "")
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1971_done
  rxcap_1971_fail:
    goto rx1963_fail
  rxcap_1971_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."deflongname"()
    unless $P10, rx1963_fail
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1963_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
    set_addr $I10, rxquantr1968_done
    (rx1963_rep) = rx1963_cur."!mark_commit"($I10)
  rxquantr1968_done:
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
.annotate 'line', 830
  # rx subrule "newpad" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."newpad"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  alt1975_0:
.annotate 'line', 831
    set_addr $I10, alt1975_1
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1963_pos, 1
    gt $I11, rx1963_eos, rx1963_fail
    sub $I11, rx1963_pos, rx1963_off
    ord $I11, rx1963_tgt, $I11
    ne $I11, 40, rx1963_fail
    add rx1963_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."signature"()
    unless $P10, rx1963_fail
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1963_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1963_pos, 1
    gt $I11, rx1963_eos, rx1963_fail
    sub $I11, rx1963_pos, rx1963_off
    ord $I11, rx1963_tgt, $I11
    ne $I11, 41, rx1963_fail
    add rx1963_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
    goto alt1975_end
  alt1975_1:
.annotate 'line', 832
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  alt1975_end:
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
.annotate 'line', 833
  # rx rxquantr1983 ** 0..*
    set_addr $I10, rxquantr1983_done
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
  rxquantr1983_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."trait"()
    unless $P10, rx1963_fail
    goto rxsubrule1984_pass
  rxsubrule1984_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1963_fail
  rxsubrule1984_pass:
    set_addr $I10, rxsubrule1984_back
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1963_pos = $P10."pos"()
    set_addr $I10, rxquantr1983_done
    (rx1963_rep) = rx1963_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1983_done
    rx1963_cur."!mark_push"(rx1963_rep, rx1963_pos, $I10)
    goto rxquantr1983_loop
  rxquantr1983_done:
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  alt1986_0:
.annotate 'line', 834
    set_addr $I10, alt1986_1
    rx1963_cur."!mark_push"(0, rx1963_pos, $I10)
.annotate 'line', 835
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."onlystar"()
    unless $P10, rx1963_fail
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1963_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
    goto alt1986_end
  alt1986_1:
.annotate 'line', 836
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."blockoid"()
    unless $P10, rx1963_fail
    rx1963_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1963_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
  alt1986_end:
.annotate 'line', 837
  # rx subrule "ws" subtype=method negate=
    rx1963_cur."!cursor_pos"(rx1963_pos)
    $P10 = rx1963_cur."ws"()
    unless $P10, rx1963_fail
    rx1963_pos = $P10."pos"()
.annotate 'line', 827
  # rx pass
    rx1963_cur."!cursor_pass"(rx1963_pos, "routine_def")
    if_null rx1963_debug, debug_1240
    rx1963_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1963_pos)
  debug_1240:
    .return (rx1963_cur)
  rx1963_restart:
.annotate 'line', 422
    if_null rx1963_debug, debug_1241
    rx1963_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1241:
  rx1963_fail:
    (rx1963_rep, rx1963_pos, $I10, $P10) = rx1963_cur."!mark_fail"(0)
    lt rx1963_pos, -1, rx1963_done
    eq rx1963_pos, -1, rx1963_fail
    jump $I10
  rx1963_done:
    rx1963_cur."!cursor_fail"()
    if_null rx1963_debug, debug_1242
    rx1963_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1242:
    .return (rx1963_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("206_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P1993 = self."!PREFIX__!subrule"("ws", "")
    new $P1994, "ResizablePMCArray"
    push $P1994, $P1993
    .return ($P1994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("207_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P2023 = "208_1304523757.895" 
    capture_lex $P2023
.annotate 'line', 841
    new $P1996, "Undef"
    .lex "$*RETURN_USED", $P1996
.annotate 'line', 842
    new $P1997, "Undef"
    .lex "$*INVOCANT_OK", $P1997
.annotate 'line', 422
    .local string rx1998_tgt
    .local int rx1998_pos
    .local int rx1998_off
    .local int rx1998_eos
    .local int rx1998_rep
    .local pmc rx1998_cur
    .local pmc rx1998_debug
    (rx1998_cur, rx1998_pos, rx1998_tgt, $I10) = self."!cursor_start"()
    rx1998_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1998_cur
    .local pmc match
    .lex "$/", match
    length rx1998_eos, rx1998_tgt
    gt rx1998_pos, rx1998_eos, rx1998_done
    set rx1998_off, 0
    lt rx1998_pos, 2, rx1998_start
    sub rx1998_off, rx1998_pos, 1
    substr rx1998_tgt, rx1998_tgt, rx1998_off
  rx1998_start:
    eq $I10, 1, rx1998_restart
    if_null rx1998_debug, debug_1243
    rx1998_cur."!cursor_debug"("START", "method_def")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1999_done
    goto rxscan1999_scan
  rxscan1999_loop:
    (rx1998_pos) = rx1998_cur."from"()
    inc rx1998_pos
    rx1998_cur."!cursor_from"(rx1998_pos)
    ge rx1998_pos, rx1998_eos, rxscan1999_done
  rxscan1999_scan:
    set_addr $I10, rxscan1999_loop
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  rxscan1999_done:
.annotate 'line', 840
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 841
    rx1998_cur."!cursor_pos"(rx1998_pos)
    new $P2001, "Integer"
    assign $P2001, 0
    store_lex "$*RETURN_USED", $P2001
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 842
    rx1998_cur."!cursor_pos"(rx1998_pos)
    new $P2003, "Integer"
    assign $P2003, 1
    store_lex "$*INVOCANT_OK", $P2003
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 843
  # rx subcapture "private"
    set_addr $I10, rxcap_2006_fail
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  # rx rxquantr2005 ** 0..1
    set_addr $I10, rxquantr2005_done
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  rxquantr2005_loop:
  # rx literal  "!"
    add $I11, rx1998_pos, 1
    gt $I11, rx1998_eos, rx1998_fail
    sub $I11, rx1998_pos, rx1998_off
    ord $I11, rx1998_tgt, $I11
    ne $I11, 33, rx1998_fail
    add rx1998_pos, 1
    set_addr $I10, rxquantr2005_done
    (rx1998_rep) = rx1998_cur."!mark_commit"($I10)
  rxquantr2005_done:
    set_addr $I10, rxcap_2006_fail
    ($I12, $I11) = rx1998_cur."!mark_peek"($I10)
    rx1998_cur."!cursor_pos"($I11)
    ($P10) = rx1998_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1998_pos, "")
    rx1998_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_2006_done
  rxcap_2006_fail:
    goto rx1998_fail
  rxcap_2006_done:
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 844
  # rx rxquantr2008 ** 0..1
    set_addr $I10, rxquantr2008_done
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  rxquantr2008_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."deflongname"()
    unless $P10, rx1998_fail
    goto rxsubrule2009_pass
  rxsubrule2009_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1998_fail
  rxsubrule2009_pass:
    set_addr $I10, rxsubrule2009_back
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1998_pos = $P10."pos"()
    set_addr $I10, rxquantr2008_done
    (rx1998_rep) = rx1998_cur."!mark_commit"($I10)
  rxquantr2008_done:
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 845
  # rx subrule "newpad" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."newpad"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  alt2012_0:
.annotate 'line', 846
    set_addr $I10, alt2012_1
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1998_pos, 1
    gt $I11, rx1998_eos, rx1998_fail
    sub $I11, rx1998_pos, rx1998_off
    ord $I11, rx1998_tgt, $I11
    ne $I11, 40, rx1998_fail
    add rx1998_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."signature"()
    unless $P10, rx1998_fail
    rx1998_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1998_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1998_pos, 1
    gt $I11, rx1998_eos, rx1998_fail
    sub $I11, rx1998_pos, rx1998_off
    ord $I11, rx1998_tgt, $I11
    ne $I11, 41, rx1998_fail
    add rx1998_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
    goto alt2012_end
  alt2012_1:
.annotate 'line', 847
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  alt2012_end:
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 848
    rx1998_cur."!cursor_pos"(rx1998_pos)
    find_lex $P2020, unicode:"$\x{a2}"
    $P2021 = $P2020."MATCH"()
    store_lex "$/", $P2021
    .const 'Sub' $P2023 = "208_1304523757.895" 
    capture_lex $P2023
    $P2025 = $P2023()
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 849
  # rx rxquantr2027 ** 0..*
    set_addr $I10, rxquantr2027_done
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  rxquantr2027_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."trait"()
    unless $P10, rx1998_fail
    goto rxsubrule2028_pass
  rxsubrule2028_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1998_fail
  rxsubrule2028_pass:
    set_addr $I10, rxsubrule2028_back
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1998_pos = $P10."pos"()
    set_addr $I10, rxquantr2027_done
    (rx1998_rep) = rx1998_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2027_done
    rx1998_cur."!mark_push"(rx1998_rep, rx1998_pos, $I10)
    goto rxquantr2027_loop
  rxquantr2027_done:
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  alt2030_0:
.annotate 'line', 850
    set_addr $I10, alt2030_1
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
.annotate 'line', 851
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."onlystar"()
    unless $P10, rx1998_fail
    rx1998_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1998_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
    goto alt2030_end
  alt2030_1:
.annotate 'line', 852
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."blockoid"()
    unless $P10, rx1998_fail
    rx1998_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1998_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
  alt2030_end:
.annotate 'line', 853
  # rx subrule "ws" subtype=method negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."ws"()
    unless $P10, rx1998_fail
    rx1998_pos = $P10."pos"()
.annotate 'line', 840
  # rx pass
    rx1998_cur."!cursor_pass"(rx1998_pos, "method_def")
    if_null rx1998_debug, debug_1244
    rx1998_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1998_pos)
  debug_1244:
    .return (rx1998_cur)
  rx1998_restart:
.annotate 'line', 422
    if_null rx1998_debug, debug_1245
    rx1998_cur."!cursor_debug"("NEXT", "method_def")
  debug_1245:
  rx1998_fail:
    (rx1998_rep, rx1998_pos, $I10, $P10) = rx1998_cur."!mark_fail"(0)
    lt rx1998_pos, -1, rx1998_done
    eq rx1998_pos, -1, rx1998_fail
    jump $I10
  rx1998_done:
    rx1998_cur."!cursor_fail"()
    if_null rx1998_debug, debug_1246
    rx1998_cur."!cursor_debug"("FAIL", "method_def")
  debug_1246:
    .return (rx1998_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2022"  :anon :subid("208_1304523757.895") :outer("207_1304523757.895")
.annotate 'line', 848
    new $P2024, "Integer"
    assign $P2024, 0
    store_dynamic_lex "$*INVOCANT_OK", $P2024
    .return ($P2024)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("209_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2037 = self."!PREFIX__!subrule"("ws", "")
    new $P2038, "ResizablePMCArray"
    push $P2038, $P2037
    .return ($P2038)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("210_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P2045 = "211_1304523757.895" 
    capture_lex $P2045
    .local string rx2040_tgt
    .local int rx2040_pos
    .local int rx2040_off
    .local int rx2040_eos
    .local int rx2040_rep
    .local pmc rx2040_cur
    .local pmc rx2040_debug
    (rx2040_cur, rx2040_pos, rx2040_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2040_cur
    .local pmc match
    .lex "$/", match
    length rx2040_eos, rx2040_tgt
    gt rx2040_pos, rx2040_eos, rx2040_done
    set rx2040_off, 0
    lt rx2040_pos, 2, rx2040_start
    sub rx2040_off, rx2040_pos, 1
    substr rx2040_tgt, rx2040_tgt, rx2040_off
  rx2040_start:
    eq $I10, 1, rx2040_restart
    if_null rx2040_debug, debug_1247
    rx2040_cur."!cursor_debug"("START", "onlystar")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2041_done
    goto rxscan2041_scan
  rxscan2041_loop:
    (rx2040_pos) = rx2040_cur."from"()
    inc rx2040_pos
    rx2040_cur."!cursor_from"(rx2040_pos)
    ge rx2040_pos, rx2040_eos, rxscan2041_done
  rxscan2041_scan:
    set_addr $I10, rxscan2041_loop
    rx2040_cur."!mark_push"(0, rx2040_pos, $I10)
  rxscan2041_done:
.annotate 'line', 857
    rx2040_cur."!cursor_pos"(rx2040_pos)
    find_lex $P2042, unicode:"$\x{a2}"
    $P2043 = $P2042."MATCH"()
    store_lex "$/", $P2043
    .const 'Sub' $P2045 = "211_1304523757.895" 
    capture_lex $P2045
    $P2051 = $P2045()
    unless $P2051, rx2040_fail
.annotate 'line', 858
  # rx literal  "{"
    add $I11, rx2040_pos, 1
    gt $I11, rx2040_eos, rx2040_fail
    sub $I11, rx2040_pos, rx2040_off
    ord $I11, rx2040_tgt, $I11
    ne $I11, 123, rx2040_fail
    add rx2040_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2040_cur."!cursor_pos"(rx2040_pos)
    $P10 = rx2040_cur."ws"()
    unless $P10, rx2040_fail
    rx2040_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx2040_pos, 1
    gt $I11, rx2040_eos, rx2040_fail
    sub $I11, rx2040_pos, rx2040_off
    ord $I11, rx2040_tgt, $I11
    ne $I11, 42, rx2040_fail
    add rx2040_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2040_cur."!cursor_pos"(rx2040_pos)
    $P10 = rx2040_cur."ws"()
    unless $P10, rx2040_fail
    rx2040_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2040_pos, 1
    gt $I11, rx2040_eos, rx2040_fail
    sub $I11, rx2040_pos, rx2040_off
    ord $I11, rx2040_tgt, $I11
    ne $I11, 125, rx2040_fail
    add rx2040_pos, 1
.annotate 'line', 859
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2040_cur."!cursor_pos"(rx2040_pos)
    $P10 = rx2040_cur."ENDSTMT"()
    unless $P10, rx2040_fail
.annotate 'line', 860
  # rx subrule "finishpad" subtype=method negate=
    rx2040_cur."!cursor_pos"(rx2040_pos)
    $P10 = rx2040_cur."finishpad"()
    unless $P10, rx2040_fail
    rx2040_pos = $P10."pos"()
.annotate 'line', 856
  # rx pass
    rx2040_cur."!cursor_pass"(rx2040_pos, "onlystar")
    if_null rx2040_debug, debug_1250
    rx2040_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx2040_pos)
  debug_1250:
    .return (rx2040_cur)
  rx2040_restart:
.annotate 'line', 422
    if_null rx2040_debug, debug_1251
    rx2040_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1251:
  rx2040_fail:
    (rx2040_rep, rx2040_pos, $I10, $P10) = rx2040_cur."!mark_fail"(0)
    lt rx2040_pos, -1, rx2040_done
    eq rx2040_pos, -1, rx2040_fail
    jump $I10
  rx2040_done:
    rx2040_cur."!cursor_fail"()
    if_null rx2040_debug, debug_1252
    rx2040_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1252:
    .return (rx2040_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2044"  :anon :subid("211_1304523757.895") :outer("210_1304523757.895")
.annotate 'line', 857
    find_dynamic_lex $P2048, "$*MULTINESS"
    unless_null $P2048, vivify_1248
    get_hll_global $P2046, "GLOBAL"
    get_who $P2047, $P2046
    set $P2048, $P2047["$MULTINESS"]
    unless_null $P2048, vivify_1249
    die "Contextual $*MULTINESS not found"
  vivify_1249:
  vivify_1248:
    set $S2049, $P2048
    iseq $I2050, $S2049, "proto"
    .return ($I2050)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("212_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2053, "ResizablePMCArray"
    push $P2053, ""
    .return ($P2053)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("213_1304523757.895")
    .param pmc param_2055
.annotate 'line', 863
    .lex "self", param_2055
    $P2056 = param_2055."!protoregex"("multi_declarator")
    .return ($P2056)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("214_1304523757.895")
    .param pmc param_2058
.annotate 'line', 863
    .lex "self", param_2058
    $P2059 = param_2058."!PREFIX__!protoregex"("multi_declarator")
    .return ($P2059)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("215_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 865
    new $P2061, "Undef"
    .lex "$*MULTINESS", $P2061
.annotate 'line', 422
    .local string rx2062_tgt
    .local int rx2062_pos
    .local int rx2062_off
    .local int rx2062_eos
    .local int rx2062_rep
    .local pmc rx2062_cur
    .local pmc rx2062_debug
    (rx2062_cur, rx2062_pos, rx2062_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2062_cur
    .local pmc match
    .lex "$/", match
    length rx2062_eos, rx2062_tgt
    gt rx2062_pos, rx2062_eos, rx2062_done
    set rx2062_off, 0
    lt rx2062_pos, 2, rx2062_start
    sub rx2062_off, rx2062_pos, 1
    substr rx2062_tgt, rx2062_tgt, rx2062_off
  rx2062_start:
    eq $I10, 1, rx2062_restart
    if_null rx2062_debug, debug_1253
    rx2062_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1253:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2063_done
    goto rxscan2063_scan
  rxscan2063_loop:
    (rx2062_pos) = rx2062_cur."from"()
    inc rx2062_pos
    rx2062_cur."!cursor_from"(rx2062_pos)
    ge rx2062_pos, rx2062_eos, rxscan2063_done
  rxscan2063_scan:
    set_addr $I10, rxscan2063_loop
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10)
  rxscan2063_done:
.annotate 'line', 865
    rx2062_cur."!cursor_pos"(rx2062_pos)
    new $P2064, "String"
    assign $P2064, "multi"
    store_lex "$*MULTINESS", $P2064
.annotate 'line', 866
  # rx subcapture "sym"
    set_addr $I10, rxcap_2065_fail
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10)
  # rx literal  "multi"
    add $I11, rx2062_pos, 5
    gt $I11, rx2062_eos, rx2062_fail
    sub $I11, rx2062_pos, rx2062_off
    substr $S10, rx2062_tgt, $I11, 5
    ne $S10, "multi", rx2062_fail
    add rx2062_pos, 5
    set_addr $I10, rxcap_2065_fail
    ($I12, $I11) = rx2062_cur."!mark_peek"($I10)
    rx2062_cur."!cursor_pos"($I11)
    ($P10) = rx2062_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2062_pos, "")
    rx2062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2065_done
  rxcap_2065_fail:
    goto rx2062_fail
  rxcap_2065_done:
.annotate 'line', 867
  # rx subrule "ws" subtype=method negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."ws"()
    unless $P10, rx2062_fail
    rx2062_pos = $P10."pos"()
  alt2066_0:
    set_addr $I10, alt2066_1
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."declarator"()
    unless $P10, rx2062_fail
    rx2062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2062_pos = $P10."pos"()
    goto alt2066_end
  alt2066_1:
    set_addr $I10, alt2066_2
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."routine_def"()
    unless $P10, rx2062_fail
    rx2062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2062_pos = $P10."pos"()
    goto alt2066_end
  alt2066_2:
  # rx subrule "panic" subtype=method negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."panic"("Malformed multi")
    unless $P10, rx2062_fail
    rx2062_pos = $P10."pos"()
  alt2066_end:
.annotate 'line', 864
  # rx pass
    rx2062_cur."!cursor_pass"(rx2062_pos, "multi_declarator:sym<multi>")
    if_null rx2062_debug, debug_1254
    rx2062_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx2062_pos)
  debug_1254:
    .return (rx2062_cur)
  rx2062_restart:
.annotate 'line', 422
    if_null rx2062_debug, debug_1255
    rx2062_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1255:
  rx2062_fail:
    (rx2062_rep, rx2062_pos, $I10, $P10) = rx2062_cur."!mark_fail"(0)
    lt rx2062_pos, -1, rx2062_done
    eq rx2062_pos, -1, rx2062_fail
    jump $I10
  rx2062_done:
    rx2062_cur."!cursor_fail"()
    if_null rx2062_debug, debug_1256
    rx2062_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1256:
    .return (rx2062_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("216_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2068 = self."!PREFIX__!subrule"("ws", "multi")
    new $P2069, "ResizablePMCArray"
    push $P2069, $P2068
    .return ($P2069)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("217_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 870
    new $P2071, "Undef"
    .lex "$*MULTINESS", $P2071
.annotate 'line', 422
    .local string rx2072_tgt
    .local int rx2072_pos
    .local int rx2072_off
    .local int rx2072_eos
    .local int rx2072_rep
    .local pmc rx2072_cur
    .local pmc rx2072_debug
    (rx2072_cur, rx2072_pos, rx2072_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2072_cur
    .local pmc match
    .lex "$/", match
    length rx2072_eos, rx2072_tgt
    gt rx2072_pos, rx2072_eos, rx2072_done
    set rx2072_off, 0
    lt rx2072_pos, 2, rx2072_start
    sub rx2072_off, rx2072_pos, 1
    substr rx2072_tgt, rx2072_tgt, rx2072_off
  rx2072_start:
    eq $I10, 1, rx2072_restart
    if_null rx2072_debug, debug_1257
    rx2072_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1257:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2073_done
    goto rxscan2073_scan
  rxscan2073_loop:
    (rx2072_pos) = rx2072_cur."from"()
    inc rx2072_pos
    rx2072_cur."!cursor_from"(rx2072_pos)
    ge rx2072_pos, rx2072_eos, rxscan2073_done
  rxscan2073_scan:
    set_addr $I10, rxscan2073_loop
    rx2072_cur."!mark_push"(0, rx2072_pos, $I10)
  rxscan2073_done:
.annotate 'line', 870
    rx2072_cur."!cursor_pos"(rx2072_pos)
    new $P2074, "String"
    assign $P2074, "proto"
    store_lex "$*MULTINESS", $P2074
.annotate 'line', 871
  # rx subcapture "sym"
    set_addr $I10, rxcap_2075_fail
    rx2072_cur."!mark_push"(0, rx2072_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2072_pos, 5
    gt $I11, rx2072_eos, rx2072_fail
    sub $I11, rx2072_pos, rx2072_off
    substr $S10, rx2072_tgt, $I11, 5
    ne $S10, "proto", rx2072_fail
    add rx2072_pos, 5
    set_addr $I10, rxcap_2075_fail
    ($I12, $I11) = rx2072_cur."!mark_peek"($I10)
    rx2072_cur."!cursor_pos"($I11)
    ($P10) = rx2072_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2072_pos, "")
    rx2072_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2075_done
  rxcap_2075_fail:
    goto rx2072_fail
  rxcap_2075_done:
.annotate 'line', 872
  # rx subrule "ws" subtype=method negate=
    rx2072_cur."!cursor_pos"(rx2072_pos)
    $P10 = rx2072_cur."ws"()
    unless $P10, rx2072_fail
    rx2072_pos = $P10."pos"()
  alt2076_0:
    set_addr $I10, alt2076_1
    rx2072_cur."!mark_push"(0, rx2072_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx2072_cur."!cursor_pos"(rx2072_pos)
    $P10 = rx2072_cur."declarator"()
    unless $P10, rx2072_fail
    rx2072_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2072_pos = $P10."pos"()
    goto alt2076_end
  alt2076_1:
    set_addr $I10, alt2076_2
    rx2072_cur."!mark_push"(0, rx2072_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx2072_cur."!cursor_pos"(rx2072_pos)
    $P10 = rx2072_cur."routine_def"()
    unless $P10, rx2072_fail
    rx2072_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx2072_pos = $P10."pos"()
    goto alt2076_end
  alt2076_2:
  # rx subrule "panic" subtype=method negate=
    rx2072_cur."!cursor_pos"(rx2072_pos)
    $P10 = rx2072_cur."panic"("Malformed proto")
    unless $P10, rx2072_fail
    rx2072_pos = $P10."pos"()
  alt2076_end:
.annotate 'line', 869
  # rx pass
    rx2072_cur."!cursor_pass"(rx2072_pos, "multi_declarator:sym<proto>")
    if_null rx2072_debug, debug_1258
    rx2072_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx2072_pos)
  debug_1258:
    .return (rx2072_cur)
  rx2072_restart:
.annotate 'line', 422
    if_null rx2072_debug, debug_1259
    rx2072_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1259:
  rx2072_fail:
    (rx2072_rep, rx2072_pos, $I10, $P10) = rx2072_cur."!mark_fail"(0)
    lt rx2072_pos, -1, rx2072_done
    eq rx2072_pos, -1, rx2072_fail
    jump $I10
  rx2072_done:
    rx2072_cur."!cursor_fail"()
    if_null rx2072_debug, debug_1260
    rx2072_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1260:
    .return (rx2072_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("218_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2078 = self."!PREFIX__!subrule"("ws", "proto")
    new $P2079, "ResizablePMCArray"
    push $P2079, $P2078
    .return ($P2079)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("219_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 875
    new $P2081, "Undef"
    .lex "$*MULTINESS", $P2081
.annotate 'line', 422
    .local string rx2082_tgt
    .local int rx2082_pos
    .local int rx2082_off
    .local int rx2082_eos
    .local int rx2082_rep
    .local pmc rx2082_cur
    .local pmc rx2082_debug
    (rx2082_cur, rx2082_pos, rx2082_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2082_cur
    .local pmc match
    .lex "$/", match
    length rx2082_eos, rx2082_tgt
    gt rx2082_pos, rx2082_eos, rx2082_done
    set rx2082_off, 0
    lt rx2082_pos, 2, rx2082_start
    sub rx2082_off, rx2082_pos, 1
    substr rx2082_tgt, rx2082_tgt, rx2082_off
  rx2082_start:
    eq $I10, 1, rx2082_restart
    if_null rx2082_debug, debug_1261
    rx2082_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1261:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2083_done
    goto rxscan2083_scan
  rxscan2083_loop:
    (rx2082_pos) = rx2082_cur."from"()
    inc rx2082_pos
    rx2082_cur."!cursor_from"(rx2082_pos)
    ge rx2082_pos, rx2082_eos, rxscan2083_done
  rxscan2083_scan:
    set_addr $I10, rxscan2083_loop
    rx2082_cur."!mark_push"(0, rx2082_pos, $I10)
  rxscan2083_done:
.annotate 'line', 875
    rx2082_cur."!cursor_pos"(rx2082_pos)
    new $P2084, "String"
    assign $P2084, ""
    store_lex "$*MULTINESS", $P2084
.annotate 'line', 876
  # rx subrule "declarator" subtype=capture negate=
    rx2082_cur."!cursor_pos"(rx2082_pos)
    $P10 = rx2082_cur."declarator"()
    unless $P10, rx2082_fail
    rx2082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx2082_pos = $P10."pos"()
.annotate 'line', 874
  # rx pass
    rx2082_cur."!cursor_pass"(rx2082_pos, "multi_declarator:sym<null>")
    if_null rx2082_debug, debug_1262
    rx2082_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx2082_pos)
  debug_1262:
    .return (rx2082_cur)
  rx2082_restart:
.annotate 'line', 422
    if_null rx2082_debug, debug_1263
    rx2082_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1263:
  rx2082_fail:
    (rx2082_rep, rx2082_pos, $I10, $P10) = rx2082_cur."!mark_fail"(0)
    lt rx2082_pos, -1, rx2082_done
    eq rx2082_pos, -1, rx2082_fail
    jump $I10
  rx2082_done:
    rx2082_cur."!cursor_fail"()
    if_null rx2082_debug, debug_1264
    rx2082_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1264:
    .return (rx2082_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("220_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2086 = self."!PREFIX__!subrule"("declarator", "")
    new $P2087, "ResizablePMCArray"
    push $P2087, $P2086
    .return ($P2087)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("221_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P2095 = "222_1304523757.895" 
    capture_lex $P2095
    .local string rx2089_tgt
    .local int rx2089_pos
    .local int rx2089_off
    .local int rx2089_eos
    .local int rx2089_rep
    .local pmc rx2089_cur
    .local pmc rx2089_debug
    (rx2089_cur, rx2089_pos, rx2089_tgt, $I10) = self."!cursor_start"()
    rx2089_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx2089_cur
    .local pmc match
    .lex "$/", match
    length rx2089_eos, rx2089_tgt
    gt rx2089_pos, rx2089_eos, rx2089_done
    set rx2089_off, 0
    lt rx2089_pos, 2, rx2089_start
    sub rx2089_off, rx2089_pos, 1
    substr rx2089_tgt, rx2089_tgt, rx2089_off
  rx2089_start:
    eq $I10, 1, rx2089_restart
    if_null rx2089_debug, debug_1265
    rx2089_cur."!cursor_debug"("START", "signature")
  debug_1265:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2090_done
    goto rxscan2090_scan
  rxscan2090_loop:
    (rx2089_pos) = rx2089_cur."from"()
    inc rx2089_pos
    rx2089_cur."!cursor_from"(rx2089_pos)
    ge rx2089_pos, rx2089_eos, rxscan2090_done
  rxscan2090_scan:
    set_addr $I10, rxscan2090_loop
    rx2089_cur."!mark_push"(0, rx2089_pos, $I10)
  rxscan2090_done:
.annotate 'line', 880
  # rx rxquantr2091 ** 0..1
    set_addr $I10, rxquantr2091_done
    rx2089_cur."!mark_push"(0, rx2089_pos, $I10)
  rxquantr2091_loop:
    rx2089_cur."!cursor_pos"(rx2089_pos)
    find_lex $P2092, unicode:"$\x{a2}"
    $P2093 = $P2092."MATCH"()
    store_lex "$/", $P2093
    .const 'Sub' $P2095 = "222_1304523757.895" 
    capture_lex $P2095
    $P2099 = $P2095()
    unless $P2099, rx2089_fail
  # rx subrule "ws" subtype=method negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."ws"()
    unless $P10, rx2089_fail
    rx2089_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."parameter"()
    unless $P10, rx2089_fail
    rx2089_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx2089_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."ws"()
    unless $P10, rx2089_fail
    rx2089_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx2089_pos, 1
    gt $I11, rx2089_eos, rx2089_fail
    sub $I11, rx2089_pos, rx2089_off
    ord $I11, rx2089_tgt, $I11
    ne $I11, 58, rx2089_fail
    add rx2089_pos, 1
    set_addr $I10, rxquantr2091_done
    (rx2089_rep) = rx2089_cur."!mark_commit"($I10)
  rxquantr2091_done:
.annotate 'line', 881
  # rx rxquantr2100 ** 0..1
    set_addr $I10, rxquantr2100_done
    rx2089_cur."!mark_push"(0, rx2089_pos, $I10)
  rxquantr2100_loop:
  # rx rxquantr2101 ** 1..*
    set_addr $I10, rxquantr2101_done
    rx2089_cur."!mark_push"(0, -1, $I10)
  rxquantr2101_loop:
  # rx subrule "ws" subtype=method negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."ws"()
    unless $P10, rx2089_fail
    rx2089_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."parameter"()
    unless $P10, rx2089_fail
    rx2089_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx2089_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2089_cur."!cursor_pos"(rx2089_pos)
    $P10 = rx2089_cur."ws"()
    unless $P10, rx2089_fail
    rx2089_pos = $P10."pos"()
    set_addr $I10, rxquantr2101_done
    (rx2089_rep) = rx2089_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2101_done
    rx2089_cur."!mark_push"(rx2089_rep, rx2089_pos, $I10)
  # rx literal  ","
    add $I11, rx2089_pos, 1
    gt $I11, rx2089_eos, rx2089_fail
    sub $I11, rx2089_pos, rx2089_off
    ord $I11, rx2089_tgt, $I11
    ne $I11, 44, rx2089_fail
    add rx2089_pos, 1
    goto rxquantr2101_loop
  rxquantr2101_done:
    set_addr $I10, rxquantr2100_done
    (rx2089_rep) = rx2089_cur."!mark_commit"($I10)
  rxquantr2100_done:
.annotate 'line', 879
  # rx pass
    rx2089_cur."!cursor_pass"(rx2089_pos, "signature")
    if_null rx2089_debug, debug_1268
    rx2089_cur."!cursor_debug"("PASS", "signature", " at pos=", rx2089_pos)
  debug_1268:
    .return (rx2089_cur)
  rx2089_restart:
.annotate 'line', 422
    if_null rx2089_debug, debug_1269
    rx2089_cur."!cursor_debug"("NEXT", "signature")
  debug_1269:
  rx2089_fail:
    (rx2089_rep, rx2089_pos, $I10, $P10) = rx2089_cur."!mark_fail"(0)
    lt rx2089_pos, -1, rx2089_done
    eq rx2089_pos, -1, rx2089_fail
    jump $I10
  rx2089_done:
    rx2089_cur."!cursor_fail"()
    if_null rx2089_debug, debug_1270
    rx2089_cur."!cursor_debug"("FAIL", "signature")
  debug_1270:
    .return (rx2089_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2094"  :anon :subid("222_1304523757.895") :outer("221_1304523757.895")
.annotate 'line', 880
    find_dynamic_lex $P2098, "$*INVOCANT_OK"
    unless_null $P2098, vivify_1266
    get_hll_global $P2096, "GLOBAL"
    get_who $P2097, $P2096
    set $P2098, $P2097["$INVOCANT_OK"]
    unless_null $P2098, vivify_1267
    die "Contextual $*INVOCANT_OK not found"
  vivify_1267:
  vivify_1266:
    .return ($P2098)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("223_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2103, "ResizablePMCArray"
    push $P2103, ""
    .return ($P2103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("224_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2105_tgt
    .local int rx2105_pos
    .local int rx2105_off
    .local int rx2105_eos
    .local int rx2105_rep
    .local pmc rx2105_cur
    .local pmc rx2105_debug
    (rx2105_cur, rx2105_pos, rx2105_tgt, $I10) = self."!cursor_start"()
    rx2105_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx2105_cur
    .local pmc match
    .lex "$/", match
    length rx2105_eos, rx2105_tgt
    gt rx2105_pos, rx2105_eos, rx2105_done
    set rx2105_off, 0
    lt rx2105_pos, 2, rx2105_start
    sub rx2105_off, rx2105_pos, 1
    substr rx2105_tgt, rx2105_tgt, rx2105_off
  rx2105_start:
    eq $I10, 1, rx2105_restart
    if_null rx2105_debug, debug_1271
    rx2105_cur."!cursor_debug"("START", "parameter")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2106_done
    goto rxscan2106_scan
  rxscan2106_loop:
    (rx2105_pos) = rx2105_cur."from"()
    inc rx2105_pos
    rx2105_cur."!cursor_from"(rx2105_pos)
    ge rx2105_pos, rx2105_eos, rxscan2106_done
  rxscan2106_scan:
    set_addr $I10, rxscan2106_loop
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  rxscan2106_done:
.annotate 'line', 885
  # rx rxquantr2107 ** 0..*
    set_addr $I10, rxquantr2107_done
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  rxquantr2107_loop:
  # rx subrule "typename" subtype=capture negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."typename"()
    unless $P10, rx2105_fail
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx2105_pos = $P10."pos"()
  # rx rxquantr2108 ** 0..1
    set_addr $I10, rxquantr2108_done
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  rxquantr2108_loop:
  # rx literal  ":"
    add $I11, rx2105_pos, 1
    gt $I11, rx2105_eos, rx2105_fail
    sub $I11, rx2105_pos, rx2105_off
    ord $I11, rx2105_tgt, $I11
    ne $I11, 58, rx2105_fail
    add rx2105_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_2109_fail
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2105_pos, rx2105_eos, rx2105_fail
    sub $I10, rx2105_pos, rx2105_off
    substr $S10, rx2105_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx2105_fail
    inc rx2105_pos
    set_addr $I10, rxcap_2109_fail
    ($I12, $I11) = rx2105_cur."!mark_peek"($I10)
    rx2105_cur."!cursor_pos"($I11)
    ($P10) = rx2105_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2105_pos, "")
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_2109_done
  rxcap_2109_fail:
    goto rx2105_fail
  rxcap_2109_done:
    set_addr $I10, rxquantr2108_done
    (rx2105_rep) = rx2105_cur."!mark_commit"($I10)
  rxquantr2108_done:
  # rx subrule "ws" subtype=method negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."ws"()
    unless $P10, rx2105_fail
    rx2105_pos = $P10."pos"()
    set_addr $I10, rxquantr2107_done
    (rx2105_rep) = rx2105_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr2107_done
    rx2105_cur."!mark_push"(rx2105_rep, rx2105_pos, $I10)
    goto rxquantr2107_loop
  rxquantr2107_done:
  alt2110_0:
.annotate 'line', 886
    set_addr $I10, alt2110_1
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
.annotate 'line', 887
  # rx subcapture "quant"
    set_addr $I10, rxcap_2111_fail
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  # rx literal  "*"
    add $I11, rx2105_pos, 1
    gt $I11, rx2105_eos, rx2105_fail
    sub $I11, rx2105_pos, rx2105_off
    ord $I11, rx2105_tgt, $I11
    ne $I11, 42, rx2105_fail
    add rx2105_pos, 1
    set_addr $I10, rxcap_2111_fail
    ($I12, $I11) = rx2105_cur."!mark_peek"($I10)
    rx2105_cur."!cursor_pos"($I11)
    ($P10) = rx2105_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2105_pos, "")
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2111_done
  rxcap_2111_fail:
    goto rx2105_fail
  rxcap_2111_done:
  # rx subrule "param_var" subtype=capture negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."param_var"()
    unless $P10, rx2105_fail
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2105_pos = $P10."pos"()
    goto alt2110_end
  alt2110_1:
  alt2112_0:
.annotate 'line', 888
    set_addr $I10, alt2112_1
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."param_var"()
    unless $P10, rx2105_fail
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2105_pos = $P10."pos"()
    goto alt2112_end
  alt2112_1:
  # rx subrule "named_param" subtype=capture negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."named_param"()
    unless $P10, rx2105_fail
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx2105_pos = $P10."pos"()
  alt2112_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_2114_fail
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  alt2113_0:
    set_addr $I10, alt2113_1
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  # rx literal  "?"
    add $I11, rx2105_pos, 1
    gt $I11, rx2105_eos, rx2105_fail
    sub $I11, rx2105_pos, rx2105_off
    ord $I11, rx2105_tgt, $I11
    ne $I11, 63, rx2105_fail
    add rx2105_pos, 1
    goto alt2113_end
  alt2113_1:
    set_addr $I10, alt2113_2
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  # rx literal  "!"
    add $I11, rx2105_pos, 1
    gt $I11, rx2105_eos, rx2105_fail
    sub $I11, rx2105_pos, rx2105_off
    ord $I11, rx2105_tgt, $I11
    ne $I11, 33, rx2105_fail
    add rx2105_pos, 1
    goto alt2113_end
  alt2113_2:
  alt2113_end:
    set_addr $I10, rxcap_2114_fail
    ($I12, $I11) = rx2105_cur."!mark_peek"($I10)
    rx2105_cur."!cursor_pos"($I11)
    ($P10) = rx2105_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2105_pos, "")
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_2114_done
  rxcap_2114_fail:
    goto rx2105_fail
  rxcap_2114_done:
  alt2110_end:
.annotate 'line', 890
  # rx rxquantr2115 ** 0..1
    set_addr $I10, rxquantr2115_done
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  rxquantr2115_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."default_value"()
    unless $P10, rx2105_fail
    goto rxsubrule2116_pass
  rxsubrule2116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2105_fail
  rxsubrule2116_pass:
    set_addr $I10, rxsubrule2116_back
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx2105_pos = $P10."pos"()
    set_addr $I10, rxquantr2115_done
    (rx2105_rep) = rx2105_cur."!mark_commit"($I10)
  rxquantr2115_done:
.annotate 'line', 884
  # rx pass
    rx2105_cur."!cursor_pass"(rx2105_pos, "parameter")
    if_null rx2105_debug, debug_1272
    rx2105_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx2105_pos)
  debug_1272:
    .return (rx2105_cur)
  rx2105_restart:
.annotate 'line', 422
    if_null rx2105_debug, debug_1273
    rx2105_cur."!cursor_debug"("NEXT", "parameter")
  debug_1273:
  rx2105_fail:
    (rx2105_rep, rx2105_pos, $I10, $P10) = rx2105_cur."!mark_fail"(0)
    lt rx2105_pos, -1, rx2105_done
    eq rx2105_pos, -1, rx2105_fail
    jump $I10
  rx2105_done:
    rx2105_cur."!cursor_fail"()
    if_null rx2105_debug, debug_1274
    rx2105_cur."!cursor_debug"("FAIL", "parameter")
  debug_1274:
    .return (rx2105_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("225_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2118, "ResizablePMCArray"
    push $P2118, ""
    .return ($P2118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("226_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2120_tgt
    .local int rx2120_pos
    .local int rx2120_off
    .local int rx2120_eos
    .local int rx2120_rep
    .local pmc rx2120_cur
    .local pmc rx2120_debug
    (rx2120_cur, rx2120_pos, rx2120_tgt, $I10) = self."!cursor_start"()
    rx2120_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx2120_cur
    .local pmc match
    .lex "$/", match
    length rx2120_eos, rx2120_tgt
    gt rx2120_pos, rx2120_eos, rx2120_done
    set rx2120_off, 0
    lt rx2120_pos, 2, rx2120_start
    sub rx2120_off, rx2120_pos, 1
    substr rx2120_tgt, rx2120_tgt, rx2120_off
  rx2120_start:
    eq $I10, 1, rx2120_restart
    if_null rx2120_debug, debug_1275
    rx2120_cur."!cursor_debug"("START", "param_var")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2121_done
    goto rxscan2121_scan
  rxscan2121_loop:
    (rx2120_pos) = rx2120_cur."from"()
    inc rx2120_pos
    rx2120_cur."!cursor_from"(rx2120_pos)
    ge rx2120_pos, rx2120_eos, rxscan2121_done
  rxscan2121_scan:
    set_addr $I10, rxscan2121_loop
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10)
  rxscan2121_done:
.annotate 'line', 894
  # rx subrule "sigil" subtype=capture negate=
    rx2120_cur."!cursor_pos"(rx2120_pos)
    $P10 = rx2120_cur."sigil"()
    unless $P10, rx2120_fail
    rx2120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2120_pos = $P10."pos"()
  # rx rxquantr2122 ** 0..1
    set_addr $I10, rxquantr2122_done
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10)
  rxquantr2122_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx2120_cur."!cursor_pos"(rx2120_pos)
    $P10 = rx2120_cur."twigil"()
    unless $P10, rx2120_fail
    goto rxsubrule2123_pass
  rxsubrule2123_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2120_fail
  rxsubrule2123_pass:
    set_addr $I10, rxsubrule2123_back
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx2120_pos = $P10."pos"()
    set_addr $I10, rxquantr2122_done
    (rx2120_rep) = rx2120_cur."!mark_commit"($I10)
  rxquantr2122_done:
  alt2124_0:
.annotate 'line', 895
    set_addr $I10, alt2124_1
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx2120_cur."!cursor_pos"(rx2120_pos)
    $P10 = rx2120_cur."ident"()
    unless $P10, rx2120_fail
    rx2120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2120_pos = $P10."pos"()
    goto alt2124_end
  alt2124_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_2125_fail
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2120_pos, rx2120_eos, rx2120_fail
    sub $I10, rx2120_pos, rx2120_off
    substr $S10, rx2120_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx2120_fail
    inc rx2120_pos
    set_addr $I10, rxcap_2125_fail
    ($I12, $I11) = rx2120_cur."!mark_peek"($I10)
    rx2120_cur."!cursor_pos"($I11)
    ($P10) = rx2120_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2120_pos, "")
    rx2120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_2125_done
  rxcap_2125_fail:
    goto rx2120_fail
  rxcap_2125_done:
  alt2124_end:
.annotate 'line', 893
  # rx pass
    rx2120_cur."!cursor_pass"(rx2120_pos, "param_var")
    if_null rx2120_debug, debug_1276
    rx2120_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx2120_pos)
  debug_1276:
    .return (rx2120_cur)
  rx2120_restart:
.annotate 'line', 422
    if_null rx2120_debug, debug_1277
    rx2120_cur."!cursor_debug"("NEXT", "param_var")
  debug_1277:
  rx2120_fail:
    (rx2120_rep, rx2120_pos, $I10, $P10) = rx2120_cur."!mark_fail"(0)
    lt rx2120_pos, -1, rx2120_done
    eq rx2120_pos, -1, rx2120_fail
    jump $I10
  rx2120_done:
    rx2120_cur."!cursor_fail"()
    if_null rx2120_debug, debug_1278
    rx2120_cur."!cursor_debug"("FAIL", "param_var")
  debug_1278:
    .return (rx2120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("227_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2127 = self."!PREFIX__!subrule"("sigil", "")
    new $P2128, "ResizablePMCArray"
    push $P2128, $P2127
    .return ($P2128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("228_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2130_tgt
    .local int rx2130_pos
    .local int rx2130_off
    .local int rx2130_eos
    .local int rx2130_rep
    .local pmc rx2130_cur
    .local pmc rx2130_debug
    (rx2130_cur, rx2130_pos, rx2130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2130_cur
    .local pmc match
    .lex "$/", match
    length rx2130_eos, rx2130_tgt
    gt rx2130_pos, rx2130_eos, rx2130_done
    set rx2130_off, 0
    lt rx2130_pos, 2, rx2130_start
    sub rx2130_off, rx2130_pos, 1
    substr rx2130_tgt, rx2130_tgt, rx2130_off
  rx2130_start:
    eq $I10, 1, rx2130_restart
    if_null rx2130_debug, debug_1279
    rx2130_cur."!cursor_debug"("START", "named_param")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2131_done
    goto rxscan2131_scan
  rxscan2131_loop:
    (rx2130_pos) = rx2130_cur."from"()
    inc rx2130_pos
    rx2130_cur."!cursor_from"(rx2130_pos)
    ge rx2130_pos, rx2130_eos, rxscan2131_done
  rxscan2131_scan:
    set_addr $I10, rxscan2131_loop
    rx2130_cur."!mark_push"(0, rx2130_pos, $I10)
  rxscan2131_done:
.annotate 'line', 899
  # rx literal  ":"
    add $I11, rx2130_pos, 1
    gt $I11, rx2130_eos, rx2130_fail
    sub $I11, rx2130_pos, rx2130_off
    ord $I11, rx2130_tgt, $I11
    ne $I11, 58, rx2130_fail
    add rx2130_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx2130_cur."!cursor_pos"(rx2130_pos)
    $P10 = rx2130_cur."param_var"()
    unless $P10, rx2130_fail
    rx2130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx2130_pos = $P10."pos"()
.annotate 'line', 898
  # rx pass
    rx2130_cur."!cursor_pass"(rx2130_pos, "named_param")
    if_null rx2130_debug, debug_1280
    rx2130_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx2130_pos)
  debug_1280:
    .return (rx2130_cur)
  rx2130_restart:
.annotate 'line', 422
    if_null rx2130_debug, debug_1281
    rx2130_cur."!cursor_debug"("NEXT", "named_param")
  debug_1281:
  rx2130_fail:
    (rx2130_rep, rx2130_pos, $I10, $P10) = rx2130_cur."!mark_fail"(0)
    lt rx2130_pos, -1, rx2130_done
    eq rx2130_pos, -1, rx2130_fail
    jump $I10
  rx2130_done:
    rx2130_cur."!cursor_fail"()
    if_null rx2130_debug, debug_1282
    rx2130_cur."!cursor_debug"("FAIL", "named_param")
  debug_1282:
    .return (rx2130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("229_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2133 = self."!PREFIX__!subrule"("param_var", ":")
    new $P2134, "ResizablePMCArray"
    push $P2134, $P2133
    .return ($P2134)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("230_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2136_tgt
    .local int rx2136_pos
    .local int rx2136_off
    .local int rx2136_eos
    .local int rx2136_rep
    .local pmc rx2136_cur
    .local pmc rx2136_debug
    (rx2136_cur, rx2136_pos, rx2136_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2136_cur
    .local pmc match
    .lex "$/", match
    length rx2136_eos, rx2136_tgt
    gt rx2136_pos, rx2136_eos, rx2136_done
    set rx2136_off, 0
    lt rx2136_pos, 2, rx2136_start
    sub rx2136_off, rx2136_pos, 1
    substr rx2136_tgt, rx2136_tgt, rx2136_off
  rx2136_start:
    eq $I10, 1, rx2136_restart
    if_null rx2136_debug, debug_1283
    rx2136_cur."!cursor_debug"("START", "default_value")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2137_done
    goto rxscan2137_scan
  rxscan2137_loop:
    (rx2136_pos) = rx2136_cur."from"()
    inc rx2136_pos
    rx2136_cur."!cursor_from"(rx2136_pos)
    ge rx2136_pos, rx2136_eos, rxscan2137_done
  rxscan2137_scan:
    set_addr $I10, rxscan2137_loop
    rx2136_cur."!mark_push"(0, rx2136_pos, $I10)
  rxscan2137_done:
.annotate 'line', 902
  # rx subrule "ws" subtype=method negate=
    rx2136_cur."!cursor_pos"(rx2136_pos)
    $P10 = rx2136_cur."ws"()
    unless $P10, rx2136_fail
    rx2136_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx2136_pos, 1
    gt $I11, rx2136_eos, rx2136_fail
    sub $I11, rx2136_pos, rx2136_off
    ord $I11, rx2136_tgt, $I11
    ne $I11, 61, rx2136_fail
    add rx2136_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2136_cur."!cursor_pos"(rx2136_pos)
    $P10 = rx2136_cur."ws"()
    unless $P10, rx2136_fail
    rx2136_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2136_cur."!cursor_pos"(rx2136_pos)
    $P10 = rx2136_cur."EXPR"("i=")
    unless $P10, rx2136_fail
    rx2136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2136_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2136_cur."!cursor_pos"(rx2136_pos)
    $P10 = rx2136_cur."ws"()
    unless $P10, rx2136_fail
    rx2136_pos = $P10."pos"()
  # rx pass
    rx2136_cur."!cursor_pass"(rx2136_pos, "default_value")
    if_null rx2136_debug, debug_1284
    rx2136_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx2136_pos)
  debug_1284:
    .return (rx2136_cur)
  rx2136_restart:
.annotate 'line', 422
    if_null rx2136_debug, debug_1285
    rx2136_cur."!cursor_debug"("NEXT", "default_value")
  debug_1285:
  rx2136_fail:
    (rx2136_rep, rx2136_pos, $I10, $P10) = rx2136_cur."!mark_fail"(0)
    lt rx2136_pos, -1, rx2136_done
    eq rx2136_pos, -1, rx2136_fail
    jump $I10
  rx2136_done:
    rx2136_cur."!cursor_fail"()
    if_null rx2136_debug, debug_1286
    rx2136_cur."!cursor_debug"("FAIL", "default_value")
  debug_1286:
    .return (rx2136_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("231_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2142 = self."!PREFIX__!subrule"("ws", "")
    new $P2143, "ResizablePMCArray"
    push $P2143, $P2142
    .return ($P2143)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("232_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2145_tgt
    .local int rx2145_pos
    .local int rx2145_off
    .local int rx2145_eos
    .local int rx2145_rep
    .local pmc rx2145_cur
    .local pmc rx2145_debug
    (rx2145_cur, rx2145_pos, rx2145_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2145_cur
    .local pmc match
    .lex "$/", match
    length rx2145_eos, rx2145_tgt
    gt rx2145_pos, rx2145_eos, rx2145_done
    set rx2145_off, 0
    lt rx2145_pos, 2, rx2145_start
    sub rx2145_off, rx2145_pos, 1
    substr rx2145_tgt, rx2145_tgt, rx2145_off
  rx2145_start:
    eq $I10, 1, rx2145_restart
    if_null rx2145_debug, debug_1287
    rx2145_cur."!cursor_debug"("START", "trait")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2146_done
    goto rxscan2146_scan
  rxscan2146_loop:
    (rx2145_pos) = rx2145_cur."from"()
    inc rx2145_pos
    rx2145_cur."!cursor_from"(rx2145_pos)
    ge rx2145_pos, rx2145_eos, rxscan2146_done
  rxscan2146_scan:
    set_addr $I10, rxscan2146_loop
    rx2145_cur."!mark_push"(0, rx2145_pos, $I10)
  rxscan2146_done:
.annotate 'line', 904
  # rx subrule "ws" subtype=method negate=
    rx2145_cur."!cursor_pos"(rx2145_pos)
    $P10 = rx2145_cur."ws"()
    unless $P10, rx2145_fail
    rx2145_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx2145_cur."!cursor_pos"(rx2145_pos)
    $P10 = rx2145_cur."trait_mod"()
    unless $P10, rx2145_fail
    rx2145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx2145_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2145_cur."!cursor_pos"(rx2145_pos)
    $P10 = rx2145_cur."ws"()
    unless $P10, rx2145_fail
    rx2145_pos = $P10."pos"()
  # rx pass
    rx2145_cur."!cursor_pass"(rx2145_pos, "trait")
    if_null rx2145_debug, debug_1288
    rx2145_cur."!cursor_debug"("PASS", "trait", " at pos=", rx2145_pos)
  debug_1288:
    .return (rx2145_cur)
  rx2145_restart:
.annotate 'line', 422
    if_null rx2145_debug, debug_1289
    rx2145_cur."!cursor_debug"("NEXT", "trait")
  debug_1289:
  rx2145_fail:
    (rx2145_rep, rx2145_pos, $I10, $P10) = rx2145_cur."!mark_fail"(0)
    lt rx2145_pos, -1, rx2145_done
    eq rx2145_pos, -1, rx2145_fail
    jump $I10
  rx2145_done:
    rx2145_cur."!cursor_fail"()
    if_null rx2145_debug, debug_1290
    rx2145_cur."!cursor_debug"("FAIL", "trait")
  debug_1290:
    .return (rx2145_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("233_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2150 = self."!PREFIX__!subrule"("ws", "")
    new $P2151, "ResizablePMCArray"
    push $P2151, $P2150
    .return ($P2151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("234_1304523757.895")
    .param pmc param_2153
.annotate 'line', 906
    .lex "self", param_2153
    $P2154 = param_2153."!protoregex"("trait_mod")
    .return ($P2154)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("235_1304523757.895")
    .param pmc param_2156
.annotate 'line', 906
    .lex "self", param_2156
    $P2157 = param_2156."!PREFIX__!protoregex"("trait_mod")
    .return ($P2157)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("236_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2159_tgt
    .local int rx2159_pos
    .local int rx2159_off
    .local int rx2159_eos
    .local int rx2159_rep
    .local pmc rx2159_cur
    .local pmc rx2159_debug
    (rx2159_cur, rx2159_pos, rx2159_tgt, $I10) = self."!cursor_start"()
    rx2159_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx2159_cur
    .local pmc match
    .lex "$/", match
    length rx2159_eos, rx2159_tgt
    gt rx2159_pos, rx2159_eos, rx2159_done
    set rx2159_off, 0
    lt rx2159_pos, 2, rx2159_start
    sub rx2159_off, rx2159_pos, 1
    substr rx2159_tgt, rx2159_tgt, rx2159_off
  rx2159_start:
    eq $I10, 1, rx2159_restart
    if_null rx2159_debug, debug_1291
    rx2159_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2160_done
    goto rxscan2160_scan
  rxscan2160_loop:
    (rx2159_pos) = rx2159_cur."from"()
    inc rx2159_pos
    rx2159_cur."!cursor_from"(rx2159_pos)
    ge rx2159_pos, rx2159_eos, rxscan2160_done
  rxscan2160_scan:
    set_addr $I10, rxscan2160_loop
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  rxscan2160_done:
.annotate 'line', 907
  # rx subcapture "sym"
    set_addr $I10, rxcap_2161_fail
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  # rx literal  "is"
    add $I11, rx2159_pos, 2
    gt $I11, rx2159_eos, rx2159_fail
    sub $I11, rx2159_pos, rx2159_off
    substr $S10, rx2159_tgt, $I11, 2
    ne $S10, "is", rx2159_fail
    add rx2159_pos, 2
    set_addr $I10, rxcap_2161_fail
    ($I12, $I11) = rx2159_cur."!mark_peek"($I10)
    rx2159_cur."!cursor_pos"($I11)
    ($P10) = rx2159_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2159_pos, "")
    rx2159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2161_done
  rxcap_2161_fail:
    goto rx2159_fail
  rxcap_2161_done:
  # rx subrule "ws" subtype=method negate=
    rx2159_cur."!cursor_pos"(rx2159_pos)
    $P10 = rx2159_cur."ws"()
    unless $P10, rx2159_fail
    rx2159_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx2159_cur."!cursor_pos"(rx2159_pos)
    $P10 = rx2159_cur."deflongname"()
    unless $P10, rx2159_fail
    rx2159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2159_pos = $P10."pos"()
  # rx rxquantr2163 ** 0..1
    set_addr $I10, rxquantr2163_done
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10)
  rxquantr2163_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx2159_cur."!cursor_pos"(rx2159_pos)
    $P10 = rx2159_cur."circumfix"()
    unless $P10, rx2159_fail
    goto rxsubrule2164_pass
  rxsubrule2164_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2159_fail
  rxsubrule2164_pass:
    set_addr $I10, rxsubrule2164_back
    rx2159_cur."!mark_push"(0, rx2159_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx2159_pos = $P10."pos"()
    set_addr $I10, rxquantr2163_done
    (rx2159_rep) = rx2159_cur."!mark_commit"($I10)
  rxquantr2163_done:
  # rx subrule "ws" subtype=method negate=
    rx2159_cur."!cursor_pos"(rx2159_pos)
    $P10 = rx2159_cur."ws"()
    unless $P10, rx2159_fail
    rx2159_pos = $P10."pos"()
  # rx pass
    rx2159_cur."!cursor_pass"(rx2159_pos, "trait_mod:sym<is>")
    if_null rx2159_debug, debug_1292
    rx2159_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx2159_pos)
  debug_1292:
    .return (rx2159_cur)
  rx2159_restart:
.annotate 'line', 422
    if_null rx2159_debug, debug_1293
    rx2159_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1293:
  rx2159_fail:
    (rx2159_rep, rx2159_pos, $I10, $P10) = rx2159_cur."!mark_fail"(0)
    lt rx2159_pos, -1, rx2159_done
    eq rx2159_pos, -1, rx2159_fail
    jump $I10
  rx2159_done:
    rx2159_cur."!cursor_fail"()
    if_null rx2159_debug, debug_1294
    rx2159_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1294:
    .return (rx2159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("237_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2167 = self."!PREFIX__!subrule"("ws", "is")
    new $P2168, "ResizablePMCArray"
    push $P2168, $P2167
    .return ($P2168)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("238_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2170_tgt
    .local int rx2170_pos
    .local int rx2170_off
    .local int rx2170_eos
    .local int rx2170_rep
    .local pmc rx2170_cur
    .local pmc rx2170_debug
    (rx2170_cur, rx2170_pos, rx2170_tgt, $I10) = self."!cursor_start"()
    rx2170_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx2170_cur
    .local pmc match
    .lex "$/", match
    length rx2170_eos, rx2170_tgt
    gt rx2170_pos, rx2170_eos, rx2170_done
    set rx2170_off, 0
    lt rx2170_pos, 2, rx2170_start
    sub rx2170_off, rx2170_pos, 1
    substr rx2170_tgt, rx2170_tgt, rx2170_off
  rx2170_start:
    eq $I10, 1, rx2170_restart
    if_null rx2170_debug, debug_1295
    rx2170_cur."!cursor_debug"("START", "regex_declarator")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2171_done
    goto rxscan2171_scan
  rxscan2171_loop:
    (rx2170_pos) = rx2170_cur."from"()
    inc rx2170_pos
    rx2170_cur."!cursor_from"(rx2170_pos)
    ge rx2170_pos, rx2170_eos, rxscan2171_done
  rxscan2171_scan:
    set_addr $I10, rxscan2171_loop
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  rxscan2171_done:
.annotate 'line', 909
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  alt2173_0:
.annotate 'line', 910
    set_addr $I10, alt2173_1
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
.annotate 'line', 911
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_2175_fail
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  # rx literal  "proto"
    add $I11, rx2170_pos, 5
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 5
    ne $S10, "proto", rx2170_fail
    add rx2170_pos, 5
    set_addr $I10, rxcap_2175_fail
    ($I12, $I11) = rx2170_cur."!mark_peek"($I10)
    rx2170_cur."!cursor_pos"($I11)
    ($P10) = rx2170_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2170_pos, "")
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_2175_done
  rxcap_2175_fail:
    goto rx2170_fail
  rxcap_2175_done:
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  alt2177_0:
    set_addr $I10, alt2177_1
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2170_pos, 5
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 5
    ne $S10, "regex", rx2170_fail
    add rx2170_pos, 5
    goto alt2177_end
  alt2177_1:
    set_addr $I10, alt2177_2
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  # rx literal  "token"
    add $I11, rx2170_pos, 5
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 5
    ne $S10, "token", rx2170_fail
    add rx2170_pos, 5
    goto alt2177_end
  alt2177_2:
  # rx literal  "rule"
    add $I11, rx2170_pos, 4
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 4
    ne $S10, "rule", rx2170_fail
    add rx2170_pos, 4
  alt2177_end:
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 912
  # rx subrule "deflongname" subtype=capture negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."deflongname"()
    unless $P10, rx2170_fail
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2170_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  alt2180_0:
.annotate 'line', 913
    set_addr $I10, alt2180_1
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
.annotate 'line', 914
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 123, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx2170_pos, 5
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 5
    ne $S10, "<...>", rx2170_fail
    add rx2170_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 125, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ENDSTMT"()
    unless $P10, rx2170_fail
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
    goto alt2180_end
  alt2180_1:
    set_addr $I10, alt2180_2
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
.annotate 'line', 915
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 123, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx2170_pos, 3
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 3
    ne $S10, "<*>", rx2170_fail
    add rx2170_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 125, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ENDSTMT"()
    unless $P10, rx2170_fail
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
    goto alt2180_end
  alt2180_2:
.annotate 'line', 916
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  alt2180_end:
.annotate 'line', 917
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 911
    goto alt2173_end
  alt2173_1:
.annotate 'line', 918
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_2194_fail
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  alt2193_0:
    set_addr $I10, alt2193_1
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  # rx literal  "regex"
    add $I11, rx2170_pos, 5
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 5
    ne $S10, "regex", rx2170_fail
    add rx2170_pos, 5
    goto alt2193_end
  alt2193_1:
    set_addr $I10, alt2193_2
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  # rx literal  "token"
    add $I11, rx2170_pos, 5
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 5
    ne $S10, "token", rx2170_fail
    add rx2170_pos, 5
    goto alt2193_end
  alt2193_2:
  # rx literal  "rule"
    add $I11, rx2170_pos, 4
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 4
    ne $S10, "rule", rx2170_fail
    add rx2170_pos, 4
  alt2193_end:
    set_addr $I10, rxcap_2194_fail
    ($I12, $I11) = rx2170_cur."!mark_peek"($I10)
    rx2170_cur."!cursor_pos"($I11)
    ($P10) = rx2170_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2170_pos, "")
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2194_done
  rxcap_2194_fail:
    goto rx2170_fail
  rxcap_2194_done:
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 919
  # rx subrule "deflongname" subtype=capture negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."deflongname"()
    unless $P10, rx2170_fail
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2170_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 920
  # rx subrule "newpad" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."newpad"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 921
  # rx rxquantr2198 ** 0..1
    set_addr $I10, rxquantr2198_done
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  rxquantr2198_loop:
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 40, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."signature"()
    unless $P10, rx2170_fail
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx2170_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 41, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
    set_addr $I10, rxquantr2198_done
    (rx2170_rep) = rx2170_cur."!mark_commit"($I10)
  rxquantr2198_done:
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 922
  # rx reduce name="regex_declarator" key="open"
    rx2170_cur."!cursor_pos"(rx2170_pos)
    rx2170_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 923
  # rx literal  "{"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 123, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2170_fail
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2170_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2170_pos, 1
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    ord $I11, rx2170_tgt, $I11
    ne $I11, 125, rx2170_fail
    add rx2170_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ENDSTMT"()
    unless $P10, rx2170_fail
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
  alt2173_end:
.annotate 'line', 924
  # rx subrule "ws" subtype=method negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."ws"()
    unless $P10, rx2170_fail
    rx2170_pos = $P10."pos"()
.annotate 'line', 909
  # rx pass
    rx2170_cur."!cursor_pass"(rx2170_pos, "regex_declarator")
    if_null rx2170_debug, debug_1296
    rx2170_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx2170_pos)
  debug_1296:
    .return (rx2170_cur)
  rx2170_restart:
.annotate 'line', 422
    if_null rx2170_debug, debug_1297
    rx2170_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1297:
  rx2170_fail:
    (rx2170_rep, rx2170_pos, $I10, $P10) = rx2170_cur."!mark_fail"(0)
    lt rx2170_pos, -1, rx2170_done
    eq rx2170_pos, -1, rx2170_fail
    jump $I10
  rx2170_done:
    rx2170_cur."!cursor_fail"()
    if_null rx2170_debug, debug_1298
    rx2170_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1298:
    .return (rx2170_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("239_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2208 = self."!PREFIX__!subrule"("ws", "")
    new $P2209, "ResizablePMCArray"
    push $P2209, $P2208
    .return ($P2209)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("240_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2211_tgt
    .local int rx2211_pos
    .local int rx2211_off
    .local int rx2211_eos
    .local int rx2211_rep
    .local pmc rx2211_cur
    .local pmc rx2211_debug
    (rx2211_cur, rx2211_pos, rx2211_tgt, $I10) = self."!cursor_start"()
    rx2211_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2211_cur
    .local pmc match
    .lex "$/", match
    length rx2211_eos, rx2211_tgt
    gt rx2211_pos, rx2211_eos, rx2211_done
    set rx2211_off, 0
    lt rx2211_pos, 2, rx2211_start
    sub rx2211_off, rx2211_pos, 1
    substr rx2211_tgt, rx2211_tgt, rx2211_off
  rx2211_start:
    eq $I10, 1, rx2211_restart
    if_null rx2211_debug, debug_1299
    rx2211_cur."!cursor_debug"("START", "dotty")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2212_done
    goto rxscan2212_scan
  rxscan2212_loop:
    (rx2211_pos) = rx2211_cur."from"()
    inc rx2211_pos
    rx2211_cur."!cursor_from"(rx2211_pos)
    ge rx2211_pos, rx2211_eos, rxscan2212_done
  rxscan2212_scan:
    set_addr $I10, rxscan2212_loop
    rx2211_cur."!mark_push"(0, rx2211_pos, $I10)
  rxscan2212_done:
.annotate 'line', 928
  # rx literal  "."
    add $I11, rx2211_pos, 1
    gt $I11, rx2211_eos, rx2211_fail
    sub $I11, rx2211_pos, rx2211_off
    ord $I11, rx2211_tgt, $I11
    ne $I11, 46, rx2211_fail
    add rx2211_pos, 1
  alt2213_0:
.annotate 'line', 929
    set_addr $I10, alt2213_1
    rx2211_cur."!mark_push"(0, rx2211_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx2211_cur."!cursor_pos"(rx2211_pos)
    $P10 = rx2211_cur."deflongname"()
    unless $P10, rx2211_fail
    rx2211_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx2211_pos = $P10."pos"()
    goto alt2213_end
  alt2213_1:
.annotate 'line', 930
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2211_pos, rx2211_off
    substr $S10, rx2211_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx2211_fail
  # rx subrule "quote" subtype=capture negate=
    rx2211_cur."!cursor_pos"(rx2211_pos)
    $P10 = rx2211_cur."quote"()
    unless $P10, rx2211_fail
    rx2211_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2211_pos = $P10."pos"()
  alt2214_0:
.annotate 'line', 931
    set_addr $I10, alt2214_1
    rx2211_cur."!mark_push"(0, rx2211_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2211_pos, rx2211_off
    substr $S10, rx2211_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2211_fail
    goto alt2214_end
  alt2214_1:
  # rx subrule "panic" subtype=method negate=
    rx2211_cur."!cursor_pos"(rx2211_pos)
    $P10 = rx2211_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx2211_fail
    rx2211_pos = $P10."pos"()
  alt2214_end:
  alt2213_end:
.annotate 'line', 937
  # rx rxquantr2215 ** 0..1
    set_addr $I10, rxquantr2215_done
    rx2211_cur."!mark_push"(0, rx2211_pos, $I10)
  rxquantr2215_loop:
  alt2216_0:
.annotate 'line', 934
    set_addr $I10, alt2216_1
    rx2211_cur."!mark_push"(0, rx2211_pos, $I10)
.annotate 'line', 935
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2211_pos, rx2211_off
    substr $S10, rx2211_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2211_fail
  # rx subrule "args" subtype=capture negate=
    rx2211_cur."!cursor_pos"(rx2211_pos)
    $P10 = rx2211_cur."args"()
    unless $P10, rx2211_fail
    rx2211_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2211_pos = $P10."pos"()
    goto alt2216_end
  alt2216_1:
.annotate 'line', 936
  # rx literal  ":"
    add $I11, rx2211_pos, 1
    gt $I11, rx2211_eos, rx2211_fail
    sub $I11, rx2211_pos, rx2211_off
    ord $I11, rx2211_tgt, $I11
    ne $I11, 58, rx2211_fail
    add rx2211_pos, 1
  # rx charclass s
    ge rx2211_pos, rx2211_eos, rx2211_fail
    sub $I10, rx2211_pos, rx2211_off
    is_cclass $I11, 32, rx2211_tgt, $I10
    unless $I11, rx2211_fail
    inc rx2211_pos
  # rx subrule "arglist" subtype=capture negate=
    rx2211_cur."!cursor_pos"(rx2211_pos)
    $P10 = rx2211_cur."arglist"()
    unless $P10, rx2211_fail
    rx2211_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2211_pos = $P10."pos"()
  alt2216_end:
.annotate 'line', 937
    set_addr $I10, rxquantr2215_done
    (rx2211_rep) = rx2211_cur."!mark_commit"($I10)
  rxquantr2215_done:
.annotate 'line', 927
  # rx pass
    rx2211_cur."!cursor_pass"(rx2211_pos, "dotty")
    if_null rx2211_debug, debug_1300
    rx2211_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx2211_pos)
  debug_1300:
    .return (rx2211_cur)
  rx2211_restart:
.annotate 'line', 422
    if_null rx2211_debug, debug_1301
    rx2211_cur."!cursor_debug"("NEXT", "dotty")
  debug_1301:
  rx2211_fail:
    (rx2211_rep, rx2211_pos, $I10, $P10) = rx2211_cur."!mark_fail"(0)
    lt rx2211_pos, -1, rx2211_done
    eq rx2211_pos, -1, rx2211_fail
    jump $I10
  rx2211_done:
    rx2211_cur."!cursor_fail"()
    if_null rx2211_debug, debug_1302
    rx2211_cur."!cursor_debug"("FAIL", "dotty")
  debug_1302:
    .return (rx2211_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("241_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2218 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P2219, "ResizablePMCArray"
    push $P2219, "'"
    push $P2219, "\""
    push $P2219, $P2218
    .return ($P2219)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("242_1304523757.895")
    .param pmc param_2221
.annotate 'line', 941
    .lex "self", param_2221
    $P2222 = param_2221."!protoregex"("term")
    .return ($P2222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("243_1304523757.895")
    .param pmc param_2224
.annotate 'line', 941
    .lex "self", param_2224
    $P2225 = param_2224."!PREFIX__!protoregex"("term")
    .return ($P2225)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("244_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2227_tgt
    .local int rx2227_pos
    .local int rx2227_off
    .local int rx2227_eos
    .local int rx2227_rep
    .local pmc rx2227_cur
    .local pmc rx2227_debug
    (rx2227_cur, rx2227_pos, rx2227_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2227_cur
    .local pmc match
    .lex "$/", match
    length rx2227_eos, rx2227_tgt
    gt rx2227_pos, rx2227_eos, rx2227_done
    set rx2227_off, 0
    lt rx2227_pos, 2, rx2227_start
    sub rx2227_off, rx2227_pos, 1
    substr rx2227_tgt, rx2227_tgt, rx2227_off
  rx2227_start:
    eq $I10, 1, rx2227_restart
    if_null rx2227_debug, debug_1303
    rx2227_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2228_done
    goto rxscan2228_scan
  rxscan2228_loop:
    (rx2227_pos) = rx2227_cur."from"()
    inc rx2227_pos
    rx2227_cur."!cursor_from"(rx2227_pos)
    ge rx2227_pos, rx2227_eos, rxscan2228_done
  rxscan2228_scan:
    set_addr $I10, rxscan2228_loop
    rx2227_cur."!mark_push"(0, rx2227_pos, $I10)
  rxscan2228_done:
.annotate 'line', 943
  # rx subcapture "sym"
    set_addr $I10, rxcap_2229_fail
    rx2227_cur."!mark_push"(0, rx2227_pos, $I10)
  # rx literal  "self"
    add $I11, rx2227_pos, 4
    gt $I11, rx2227_eos, rx2227_fail
    sub $I11, rx2227_pos, rx2227_off
    substr $S10, rx2227_tgt, $I11, 4
    ne $S10, "self", rx2227_fail
    add rx2227_pos, 4
    set_addr $I10, rxcap_2229_fail
    ($I12, $I11) = rx2227_cur."!mark_peek"($I10)
    rx2227_cur."!cursor_pos"($I11)
    ($P10) = rx2227_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2227_pos, "")
    rx2227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2229_done
  rxcap_2229_fail:
    goto rx2227_fail
  rxcap_2229_done:
  # rxanchor rwb
    le rx2227_pos, 0, rx2227_fail
    sub $I10, rx2227_pos, rx2227_off
    is_cclass $I11, 8192, rx2227_tgt, $I10
    if $I11, rx2227_fail
    dec $I10
    is_cclass $I11, 8192, rx2227_tgt, $I10
    unless $I11, rx2227_fail
  # rx pass
    rx2227_cur."!cursor_pass"(rx2227_pos, "term:sym<self>")
    if_null rx2227_debug, debug_1304
    rx2227_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx2227_pos)
  debug_1304:
    .return (rx2227_cur)
  rx2227_restart:
.annotate 'line', 422
    if_null rx2227_debug, debug_1305
    rx2227_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1305:
  rx2227_fail:
    (rx2227_rep, rx2227_pos, $I10, $P10) = rx2227_cur."!mark_fail"(0)
    lt rx2227_pos, -1, rx2227_done
    eq rx2227_pos, -1, rx2227_fail
    jump $I10
  rx2227_done:
    rx2227_cur."!cursor_fail"()
    if_null rx2227_debug, debug_1306
    rx2227_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1306:
    .return (rx2227_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("245_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2231, "ResizablePMCArray"
    push $P2231, "self"
    .return ($P2231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("246_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2233_tgt
    .local int rx2233_pos
    .local int rx2233_off
    .local int rx2233_eos
    .local int rx2233_rep
    .local pmc rx2233_cur
    .local pmc rx2233_debug
    (rx2233_cur, rx2233_pos, rx2233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2233_cur
    .local pmc match
    .lex "$/", match
    length rx2233_eos, rx2233_tgt
    gt rx2233_pos, rx2233_eos, rx2233_done
    set rx2233_off, 0
    lt rx2233_pos, 2, rx2233_start
    sub rx2233_off, rx2233_pos, 1
    substr rx2233_tgt, rx2233_tgt, rx2233_off
  rx2233_start:
    eq $I10, 1, rx2233_restart
    if_null rx2233_debug, debug_1307
    rx2233_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2234_done
    goto rxscan2234_scan
  rxscan2234_loop:
    (rx2233_pos) = rx2233_cur."from"()
    inc rx2233_pos
    rx2233_cur."!cursor_from"(rx2233_pos)
    ge rx2233_pos, rx2233_eos, rxscan2234_done
  rxscan2234_scan:
    set_addr $I10, rxscan2234_loop
    rx2233_cur."!mark_push"(0, rx2233_pos, $I10)
  rxscan2234_done:
.annotate 'line', 946
  # rx subrule "deflongname" subtype=capture negate=
    rx2233_cur."!cursor_pos"(rx2233_pos)
    $P10 = rx2233_cur."deflongname"()
    unless $P10, rx2233_fail
    rx2233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx2233_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2233_pos, rx2233_off
    substr $S10, rx2233_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx2233_fail
  # rx subrule "args" subtype=capture negate=
    rx2233_cur."!cursor_pos"(rx2233_pos)
    $P10 = rx2233_cur."args"()
    unless $P10, rx2233_fail
    rx2233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx2233_pos = $P10."pos"()
.annotate 'line', 945
  # rx pass
    rx2233_cur."!cursor_pass"(rx2233_pos, "term:sym<identifier>")
    if_null rx2233_debug, debug_1308
    rx2233_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx2233_pos)
  debug_1308:
    .return (rx2233_cur)
  rx2233_restart:
.annotate 'line', 422
    if_null rx2233_debug, debug_1309
    rx2233_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1309:
  rx2233_fail:
    (rx2233_rep, rx2233_pos, $I10, $P10) = rx2233_cur."!mark_fail"(0)
    lt rx2233_pos, -1, rx2233_done
    eq rx2233_pos, -1, rx2233_fail
    jump $I10
  rx2233_done:
    rx2233_cur."!cursor_fail"()
    if_null rx2233_debug, debug_1310
    rx2233_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1310:
    .return (rx2233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("247_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2236 = self."!PREFIX__!subrule"("deflongname", "")
    new $P2237, "ResizablePMCArray"
    push $P2237, $P2236
    .return ($P2237)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("248_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2239_tgt
    .local int rx2239_pos
    .local int rx2239_off
    .local int rx2239_eos
    .local int rx2239_rep
    .local pmc rx2239_cur
    .local pmc rx2239_debug
    (rx2239_cur, rx2239_pos, rx2239_tgt, $I10) = self."!cursor_start"()
    rx2239_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2239_cur
    .local pmc match
    .lex "$/", match
    length rx2239_eos, rx2239_tgt
    gt rx2239_pos, rx2239_eos, rx2239_done
    set rx2239_off, 0
    lt rx2239_pos, 2, rx2239_start
    sub rx2239_off, rx2239_pos, 1
    substr rx2239_tgt, rx2239_tgt, rx2239_off
  rx2239_start:
    eq $I10, 1, rx2239_restart
    if_null rx2239_debug, debug_1311
    rx2239_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2240_done
    goto rxscan2240_scan
  rxscan2240_loop:
    (rx2239_pos) = rx2239_cur."from"()
    inc rx2239_pos
    rx2239_cur."!cursor_from"(rx2239_pos)
    ge rx2239_pos, rx2239_eos, rxscan2240_done
  rxscan2240_scan:
    set_addr $I10, rxscan2240_loop
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10)
  rxscan2240_done:
.annotate 'line', 950
  # rx subrule "name" subtype=capture negate=
    rx2239_cur."!cursor_pos"(rx2239_pos)
    $P10 = rx2239_cur."name"()
    unless $P10, rx2239_fail
    rx2239_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx2239_pos = $P10."pos"()
  # rx rxquantr2241 ** 0..1
    set_addr $I10, rxquantr2241_done
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10)
  rxquantr2241_loop:
  # rx subrule "args" subtype=capture negate=
    rx2239_cur."!cursor_pos"(rx2239_pos)
    $P10 = rx2239_cur."args"()
    unless $P10, rx2239_fail
    goto rxsubrule2242_pass
  rxsubrule2242_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2239_fail
  rxsubrule2242_pass:
    set_addr $I10, rxsubrule2242_back
    rx2239_cur."!mark_push"(0, rx2239_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2239_pos = $P10."pos"()
    set_addr $I10, rxquantr2241_done
    (rx2239_rep) = rx2239_cur."!mark_commit"($I10)
  rxquantr2241_done:
.annotate 'line', 949
  # rx pass
    rx2239_cur."!cursor_pass"(rx2239_pos, "term:sym<name>")
    if_null rx2239_debug, debug_1312
    rx2239_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx2239_pos)
  debug_1312:
    .return (rx2239_cur)
  rx2239_restart:
.annotate 'line', 422
    if_null rx2239_debug, debug_1313
    rx2239_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1313:
  rx2239_fail:
    (rx2239_rep, rx2239_pos, $I10, $P10) = rx2239_cur."!mark_fail"(0)
    lt rx2239_pos, -1, rx2239_done
    eq rx2239_pos, -1, rx2239_fail
    jump $I10
  rx2239_done:
    rx2239_cur."!cursor_fail"()
    if_null rx2239_debug, debug_1314
    rx2239_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1314:
    .return (rx2239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("249_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2244 = self."!PREFIX__!subrule"("name", "")
    new $P2245, "ResizablePMCArray"
    push $P2245, $P2244
    .return ($P2245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("250_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2247_tgt
    .local int rx2247_pos
    .local int rx2247_off
    .local int rx2247_eos
    .local int rx2247_rep
    .local pmc rx2247_cur
    .local pmc rx2247_debug
    (rx2247_cur, rx2247_pos, rx2247_tgt, $I10) = self."!cursor_start"()
    rx2247_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx2247_cur
    .local pmc match
    .lex "$/", match
    length rx2247_eos, rx2247_tgt
    gt rx2247_pos, rx2247_eos, rx2247_done
    set rx2247_off, 0
    lt rx2247_pos, 2, rx2247_start
    sub rx2247_off, rx2247_pos, 1
    substr rx2247_tgt, rx2247_tgt, rx2247_off
  rx2247_start:
    eq $I10, 1, rx2247_restart
    if_null rx2247_debug, debug_1315
    rx2247_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2248_done
    goto rxscan2248_scan
  rxscan2248_loop:
    (rx2247_pos) = rx2247_cur."from"()
    inc rx2247_pos
    rx2247_cur."!cursor_from"(rx2247_pos)
    ge rx2247_pos, rx2247_eos, rxscan2248_done
  rxscan2248_scan:
    set_addr $I10, rxscan2248_loop
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  rxscan2248_done:
.annotate 'line', 954
  # rx literal  "pir::"
    add $I11, rx2247_pos, 5
    gt $I11, rx2247_eos, rx2247_fail
    sub $I11, rx2247_pos, rx2247_off
    substr $S10, rx2247_tgt, $I11, 5
    ne $S10, "pir::", rx2247_fail
    add rx2247_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_2249_fail
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx2247_pos, rx2247_off
    find_not_cclass $I11, 8192, rx2247_tgt, $I10, rx2247_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx2247_fail
    add rx2247_pos, rx2247_off, $I11
    set_addr $I10, rxcap_2249_fail
    ($I12, $I11) = rx2247_cur."!mark_peek"($I10)
    rx2247_cur."!cursor_pos"($I11)
    ($P10) = rx2247_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2247_pos, "")
    rx2247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_2249_done
  rxcap_2249_fail:
    goto rx2247_fail
  rxcap_2249_done:
  # rx rxquantr2250 ** 0..1
    set_addr $I10, rxquantr2250_done
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10)
  rxquantr2250_loop:
  # rx subrule "args" subtype=capture negate=
    rx2247_cur."!cursor_pos"(rx2247_pos)
    $P10 = rx2247_cur."args"()
    unless $P10, rx2247_fail
    goto rxsubrule2251_pass
  rxsubrule2251_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2247_fail
  rxsubrule2251_pass:
    set_addr $I10, rxsubrule2251_back
    rx2247_cur."!mark_push"(0, rx2247_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx2247_pos = $P10."pos"()
    set_addr $I10, rxquantr2250_done
    (rx2247_rep) = rx2247_cur."!mark_commit"($I10)
  rxquantr2250_done:
.annotate 'line', 953
  # rx pass
    rx2247_cur."!cursor_pass"(rx2247_pos, "term:sym<pir::op>")
    if_null rx2247_debug, debug_1316
    rx2247_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx2247_pos)
  debug_1316:
    .return (rx2247_cur)
  rx2247_restart:
.annotate 'line', 422
    if_null rx2247_debug, debug_1317
    rx2247_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1317:
  rx2247_fail:
    (rx2247_rep, rx2247_pos, $I10, $P10) = rx2247_cur."!mark_fail"(0)
    lt rx2247_pos, -1, rx2247_done
    eq rx2247_pos, -1, rx2247_fail
    jump $I10
  rx2247_done:
    rx2247_cur."!cursor_fail"()
    if_null rx2247_debug, debug_1318
    rx2247_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1318:
    .return (rx2247_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("251_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2253, "ResizablePMCArray"
    push $P2253, "pir::"
    .return ($P2253)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("252_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P2261 = "253_1304523757.895" 
    capture_lex $P2261
    .local string rx2255_tgt
    .local int rx2255_pos
    .local int rx2255_off
    .local int rx2255_eos
    .local int rx2255_rep
    .local pmc rx2255_cur
    .local pmc rx2255_debug
    (rx2255_cur, rx2255_pos, rx2255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2255_cur
    .local pmc match
    .lex "$/", match
    length rx2255_eos, rx2255_tgt
    gt rx2255_pos, rx2255_eos, rx2255_done
    set rx2255_off, 0
    lt rx2255_pos, 2, rx2255_start
    sub rx2255_off, rx2255_pos, 1
    substr rx2255_tgt, rx2255_tgt, rx2255_off
  rx2255_start:
    eq $I10, 1, rx2255_restart
    if_null rx2255_debug, debug_1319
    rx2255_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2256_done
    goto rxscan2256_scan
  rxscan2256_loop:
    (rx2255_pos) = rx2255_cur."from"()
    inc rx2255_pos
    rx2255_cur."!cursor_from"(rx2255_pos)
    ge rx2255_pos, rx2255_eos, rxscan2256_done
  rxscan2256_scan:
    set_addr $I10, rxscan2256_loop
    rx2255_cur."!mark_push"(0, rx2255_pos, $I10)
  rxscan2256_done:
.annotate 'line', 958
  # rx literal  "{*}"
    add $I11, rx2255_pos, 3
    gt $I11, rx2255_eos, rx2255_fail
    sub $I11, rx2255_pos, rx2255_off
    substr $S10, rx2255_tgt, $I11, 3
    ne $S10, "{*}", rx2255_fail
    add rx2255_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx2255_cur."!cursor_pos"(rx2255_pos)
    $P10 = rx2255_cur."ENDSTMT"()
    unless $P10, rx2255_fail
  alt2257_0:
.annotate 'line', 959
    set_addr $I10, alt2257_1
    rx2255_cur."!mark_push"(0, rx2255_pos, $I10)
    rx2255_cur."!cursor_pos"(rx2255_pos)
    find_lex $P2258, unicode:"$\x{a2}"
    $P2259 = $P2258."MATCH"()
    store_lex "$/", $P2259
    .const 'Sub' $P2261 = "253_1304523757.895" 
    capture_lex $P2261
    $P2267 = $P2261()
    unless $P2267, rx2255_fail
    goto alt2257_end
  alt2257_1:
  # rx subrule "panic" subtype=method negate=
    rx2255_cur."!cursor_pos"(rx2255_pos)
    $P10 = rx2255_cur."panic"("{*} may only appear in proto")
    unless $P10, rx2255_fail
    rx2255_pos = $P10."pos"()
  alt2257_end:
.annotate 'line', 957
  # rx pass
    rx2255_cur."!cursor_pass"(rx2255_pos, "term:sym<onlystar>")
    if_null rx2255_debug, debug_1322
    rx2255_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx2255_pos)
  debug_1322:
    .return (rx2255_cur)
  rx2255_restart:
.annotate 'line', 422
    if_null rx2255_debug, debug_1323
    rx2255_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1323:
  rx2255_fail:
    (rx2255_rep, rx2255_pos, $I10, $P10) = rx2255_cur."!mark_fail"(0)
    lt rx2255_pos, -1, rx2255_done
    eq rx2255_pos, -1, rx2255_fail
    jump $I10
  rx2255_done:
    rx2255_cur."!cursor_fail"()
    if_null rx2255_debug, debug_1324
    rx2255_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1324:
    .return (rx2255_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2260"  :anon :subid("253_1304523757.895") :outer("252_1304523757.895")
.annotate 'line', 959
    find_dynamic_lex $P2264, "$*MULTINESS"
    unless_null $P2264, vivify_1320
    get_hll_global $P2262, "GLOBAL"
    get_who $P2263, $P2262
    set $P2264, $P2263["$MULTINESS"]
    unless_null $P2264, vivify_1321
    die "Contextual $*MULTINESS not found"
  vivify_1321:
  vivify_1320:
    set $S2265, $P2264
    iseq $I2266, $S2265, "proto"
    .return ($I2266)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("254_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2269, "ResizablePMCArray"
    push $P2269, "{*}"
    .return ($P2269)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("255_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2271_tgt
    .local int rx2271_pos
    .local int rx2271_off
    .local int rx2271_eos
    .local int rx2271_rep
    .local pmc rx2271_cur
    .local pmc rx2271_debug
    (rx2271_cur, rx2271_pos, rx2271_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2271_cur
    .local pmc match
    .lex "$/", match
    length rx2271_eos, rx2271_tgt
    gt rx2271_pos, rx2271_eos, rx2271_done
    set rx2271_off, 0
    lt rx2271_pos, 2, rx2271_start
    sub rx2271_off, rx2271_pos, 1
    substr rx2271_tgt, rx2271_tgt, rx2271_off
  rx2271_start:
    eq $I10, 1, rx2271_restart
    if_null rx2271_debug, debug_1325
    rx2271_cur."!cursor_debug"("START", "args")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2272_done
    goto rxscan2272_scan
  rxscan2272_loop:
    (rx2271_pos) = rx2271_cur."from"()
    inc rx2271_pos
    rx2271_cur."!cursor_from"(rx2271_pos)
    ge rx2271_pos, rx2271_eos, rxscan2272_done
  rxscan2272_scan:
    set_addr $I10, rxscan2272_loop
    rx2271_cur."!mark_push"(0, rx2271_pos, $I10)
  rxscan2272_done:
.annotate 'line', 963
  # rx literal  "("
    add $I11, rx2271_pos, 1
    gt $I11, rx2271_eos, rx2271_fail
    sub $I11, rx2271_pos, rx2271_off
    ord $I11, rx2271_tgt, $I11
    ne $I11, 40, rx2271_fail
    add rx2271_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2271_cur."!cursor_pos"(rx2271_pos)
    $P10 = rx2271_cur."arglist"()
    unless $P10, rx2271_fail
    rx2271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2271_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2271_pos, 1
    gt $I11, rx2271_eos, rx2271_fail
    sub $I11, rx2271_pos, rx2271_off
    ord $I11, rx2271_tgt, $I11
    ne $I11, 41, rx2271_fail
    add rx2271_pos, 1
  # rx pass
    rx2271_cur."!cursor_pass"(rx2271_pos, "args")
    if_null rx2271_debug, debug_1326
    rx2271_cur."!cursor_debug"("PASS", "args", " at pos=", rx2271_pos)
  debug_1326:
    .return (rx2271_cur)
  rx2271_restart:
.annotate 'line', 422
    if_null rx2271_debug, debug_1327
    rx2271_cur."!cursor_debug"("NEXT", "args")
  debug_1327:
  rx2271_fail:
    (rx2271_rep, rx2271_pos, $I10, $P10) = rx2271_cur."!mark_fail"(0)
    lt rx2271_pos, -1, rx2271_done
    eq rx2271_pos, -1, rx2271_fail
    jump $I10
  rx2271_done:
    rx2271_cur."!cursor_fail"()
    if_null rx2271_debug, debug_1328
    rx2271_cur."!cursor_debug"("FAIL", "args")
  debug_1328:
    .return (rx2271_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("256_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2274 = self."!PREFIX__!subrule"("arglist", "(")
    new $P2275, "ResizablePMCArray"
    push $P2275, $P2274
    .return ($P2275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("257_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2277_tgt
    .local int rx2277_pos
    .local int rx2277_off
    .local int rx2277_eos
    .local int rx2277_rep
    .local pmc rx2277_cur
    .local pmc rx2277_debug
    (rx2277_cur, rx2277_pos, rx2277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2277_cur
    .local pmc match
    .lex "$/", match
    length rx2277_eos, rx2277_tgt
    gt rx2277_pos, rx2277_eos, rx2277_done
    set rx2277_off, 0
    lt rx2277_pos, 2, rx2277_start
    sub rx2277_off, rx2277_pos, 1
    substr rx2277_tgt, rx2277_tgt, rx2277_off
  rx2277_start:
    eq $I10, 1, rx2277_restart
    if_null rx2277_debug, debug_1329
    rx2277_cur."!cursor_debug"("START", "arglist")
  debug_1329:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2278_done
    goto rxscan2278_scan
  rxscan2278_loop:
    (rx2277_pos) = rx2277_cur."from"()
    inc rx2277_pos
    rx2277_cur."!cursor_from"(rx2277_pos)
    ge rx2277_pos, rx2277_eos, rxscan2278_done
  rxscan2278_scan:
    set_addr $I10, rxscan2278_loop
    rx2277_cur."!mark_push"(0, rx2277_pos, $I10)
  rxscan2278_done:
.annotate 'line', 967
  # rx subrule "ws" subtype=method negate=
    rx2277_cur."!cursor_pos"(rx2277_pos)
    $P10 = rx2277_cur."ws"()
    unless $P10, rx2277_fail
    rx2277_pos = $P10."pos"()
  alt2279_0:
.annotate 'line', 968
    set_addr $I10, alt2279_1
    rx2277_cur."!mark_push"(0, rx2277_pos, $I10)
.annotate 'line', 969
  # rx subrule "EXPR" subtype=capture negate=
    rx2277_cur."!cursor_pos"(rx2277_pos)
    $P10 = rx2277_cur."EXPR"("f=")
    unless $P10, rx2277_fail
    rx2277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2277_pos = $P10."pos"()
    goto alt2279_end
  alt2279_1:
  alt2279_end:
.annotate 'line', 966
  # rx pass
    rx2277_cur."!cursor_pass"(rx2277_pos, "arglist")
    if_null rx2277_debug, debug_1330
    rx2277_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx2277_pos)
  debug_1330:
    .return (rx2277_cur)
  rx2277_restart:
.annotate 'line', 422
    if_null rx2277_debug, debug_1331
    rx2277_cur."!cursor_debug"("NEXT", "arglist")
  debug_1331:
  rx2277_fail:
    (rx2277_rep, rx2277_pos, $I10, $P10) = rx2277_cur."!mark_fail"(0)
    lt rx2277_pos, -1, rx2277_done
    eq rx2277_pos, -1, rx2277_fail
    jump $I10
  rx2277_done:
    rx2277_cur."!cursor_fail"()
    if_null rx2277_debug, debug_1332
    rx2277_cur."!cursor_debug"("FAIL", "arglist")
  debug_1332:
    .return (rx2277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("258_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2281 = self."!PREFIX__!subrule"("ws", "")
    new $P2282, "ResizablePMCArray"
    push $P2282, $P2281
    .return ($P2282)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("259_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2284_tgt
    .local int rx2284_pos
    .local int rx2284_off
    .local int rx2284_eos
    .local int rx2284_rep
    .local pmc rx2284_cur
    .local pmc rx2284_debug
    (rx2284_cur, rx2284_pos, rx2284_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2284_cur
    .local pmc match
    .lex "$/", match
    length rx2284_eos, rx2284_tgt
    gt rx2284_pos, rx2284_eos, rx2284_done
    set rx2284_off, 0
    lt rx2284_pos, 2, rx2284_start
    sub rx2284_off, rx2284_pos, 1
    substr rx2284_tgt, rx2284_tgt, rx2284_off
  rx2284_start:
    eq $I10, 1, rx2284_restart
    if_null rx2284_debug, debug_1333
    rx2284_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2285_done
    goto rxscan2285_scan
  rxscan2285_loop:
    (rx2284_pos) = rx2284_cur."from"()
    inc rx2284_pos
    rx2284_cur."!cursor_from"(rx2284_pos)
    ge rx2284_pos, rx2284_eos, rxscan2285_done
  rxscan2285_scan:
    set_addr $I10, rxscan2285_loop
    rx2284_cur."!mark_push"(0, rx2284_pos, $I10)
  rxscan2285_done:
.annotate 'line', 975
  # rx subrule "value" subtype=capture negate=
    rx2284_cur."!cursor_pos"(rx2284_pos)
    $P10 = rx2284_cur."value"()
    unless $P10, rx2284_fail
    rx2284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx2284_pos = $P10."pos"()
  # rx pass
    rx2284_cur."!cursor_pass"(rx2284_pos, "term:sym<value>")
    if_null rx2284_debug, debug_1334
    rx2284_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx2284_pos)
  debug_1334:
    .return (rx2284_cur)
  rx2284_restart:
.annotate 'line', 422
    if_null rx2284_debug, debug_1335
    rx2284_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1335:
  rx2284_fail:
    (rx2284_rep, rx2284_pos, $I10, $P10) = rx2284_cur."!mark_fail"(0)
    lt rx2284_pos, -1, rx2284_done
    eq rx2284_pos, -1, rx2284_fail
    jump $I10
  rx2284_done:
    rx2284_cur."!cursor_fail"()
    if_null rx2284_debug, debug_1336
    rx2284_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1336:
    .return (rx2284_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("260_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2287 = self."!PREFIX__!subrule"("value", "")
    new $P2288, "ResizablePMCArray"
    push $P2288, $P2287
    .return ($P2288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("261_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2290_tgt
    .local int rx2290_pos
    .local int rx2290_off
    .local int rx2290_eos
    .local int rx2290_rep
    .local pmc rx2290_cur
    .local pmc rx2290_debug
    (rx2290_cur, rx2290_pos, rx2290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2290_cur
    .local pmc match
    .lex "$/", match
    length rx2290_eos, rx2290_tgt
    gt rx2290_pos, rx2290_eos, rx2290_done
    set rx2290_off, 0
    lt rx2290_pos, 2, rx2290_start
    sub rx2290_off, rx2290_pos, 1
    substr rx2290_tgt, rx2290_tgt, rx2290_off
  rx2290_start:
    eq $I10, 1, rx2290_restart
    if_null rx2290_debug, debug_1337
    rx2290_cur."!cursor_debug"("START", "value")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2291_done
    goto rxscan2291_scan
  rxscan2291_loop:
    (rx2290_pos) = rx2290_cur."from"()
    inc rx2290_pos
    rx2290_cur."!cursor_from"(rx2290_pos)
    ge rx2290_pos, rx2290_eos, rxscan2291_done
  rxscan2291_scan:
    set_addr $I10, rxscan2291_loop
    rx2290_cur."!mark_push"(0, rx2290_pos, $I10)
  rxscan2291_done:
  alt2292_0:
.annotate 'line', 977
    set_addr $I10, alt2292_1
    rx2290_cur."!mark_push"(0, rx2290_pos, $I10)
.annotate 'line', 978
  # rx subrule "quote" subtype=capture negate=
    rx2290_cur."!cursor_pos"(rx2290_pos)
    $P10 = rx2290_cur."quote"()
    unless $P10, rx2290_fail
    rx2290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx2290_pos = $P10."pos"()
    goto alt2292_end
  alt2292_1:
.annotate 'line', 979
  # rx subrule "number" subtype=capture negate=
    rx2290_cur."!cursor_pos"(rx2290_pos)
    $P10 = rx2290_cur."number"()
    unless $P10, rx2290_fail
    rx2290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx2290_pos = $P10."pos"()
  alt2292_end:
.annotate 'line', 977
  # rx pass
    rx2290_cur."!cursor_pass"(rx2290_pos, "value")
    if_null rx2290_debug, debug_1338
    rx2290_cur."!cursor_debug"("PASS", "value", " at pos=", rx2290_pos)
  debug_1338:
    .return (rx2290_cur)
  rx2290_restart:
.annotate 'line', 422
    if_null rx2290_debug, debug_1339
    rx2290_cur."!cursor_debug"("NEXT", "value")
  debug_1339:
  rx2290_fail:
    (rx2290_rep, rx2290_pos, $I10, $P10) = rx2290_cur."!mark_fail"(0)
    lt rx2290_pos, -1, rx2290_done
    eq rx2290_pos, -1, rx2290_fail
    jump $I10
  rx2290_done:
    rx2290_cur."!cursor_fail"()
    if_null rx2290_debug, debug_1340
    rx2290_cur."!cursor_debug"("FAIL", "value")
  debug_1340:
    .return (rx2290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("262_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2294 = self."!PREFIX__!subrule"("number", "")
    $P2295 = self."!PREFIX__!subrule"("quote", "")
    new $P2296, "ResizablePMCArray"
    push $P2296, $P2294
    push $P2296, $P2295
    .return ($P2296)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("263_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2298_tgt
    .local int rx2298_pos
    .local int rx2298_off
    .local int rx2298_eos
    .local int rx2298_rep
    .local pmc rx2298_cur
    .local pmc rx2298_debug
    (rx2298_cur, rx2298_pos, rx2298_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2298_cur
    .local pmc match
    .lex "$/", match
    length rx2298_eos, rx2298_tgt
    gt rx2298_pos, rx2298_eos, rx2298_done
    set rx2298_off, 0
    lt rx2298_pos, 2, rx2298_start
    sub rx2298_off, rx2298_pos, 1
    substr rx2298_tgt, rx2298_tgt, rx2298_off
  rx2298_start:
    eq $I10, 1, rx2298_restart
    if_null rx2298_debug, debug_1341
    rx2298_cur."!cursor_debug"("START", "number")
  debug_1341:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2299_done
    goto rxscan2299_scan
  rxscan2299_loop:
    (rx2298_pos) = rx2298_cur."from"()
    inc rx2298_pos
    rx2298_cur."!cursor_from"(rx2298_pos)
    ge rx2298_pos, rx2298_eos, rxscan2299_done
  rxscan2299_scan:
    set_addr $I10, rxscan2299_loop
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  rxscan2299_done:
.annotate 'line', 983
  # rx subcapture "sign"
    set_addr $I10, rxcap_2301_fail
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx2298_pos, rx2298_off
    set rx2298_rep, 0
    sub $I12, rx2298_eos, rx2298_pos
    le $I12, 1, rxenumcharlistq2300_loop
    set $I12, 1
  rxenumcharlistq2300_loop:
    le $I12, 0, rxenumcharlistq2300_done
    substr $S10, rx2298_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq2300_done
    inc rx2298_rep
  rxenumcharlistq2300_done:
    add rx2298_pos, rx2298_pos, rx2298_rep
    set_addr $I10, rxcap_2301_fail
    ($I12, $I11) = rx2298_cur."!mark_peek"($I10)
    rx2298_cur."!cursor_pos"($I11)
    ($P10) = rx2298_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2298_pos, "")
    rx2298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_2301_done
  rxcap_2301_fail:
    goto rx2298_fail
  rxcap_2301_done:
  alt2302_0:
.annotate 'line', 984
    set_addr $I10, alt2302_1
    rx2298_cur."!mark_push"(0, rx2298_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx2298_cur."!cursor_pos"(rx2298_pos)
    $P10 = rx2298_cur."dec_number"()
    unless $P10, rx2298_fail
    rx2298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx2298_pos = $P10."pos"()
    goto alt2302_end
  alt2302_1:
  # rx subrule "integer" subtype=capture negate=
    rx2298_cur."!cursor_pos"(rx2298_pos)
    $P10 = rx2298_cur."integer"()
    unless $P10, rx2298_fail
    rx2298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx2298_pos = $P10."pos"()
  alt2302_end:
.annotate 'line', 982
  # rx pass
    rx2298_cur."!cursor_pass"(rx2298_pos, "number")
    if_null rx2298_debug, debug_1342
    rx2298_cur."!cursor_debug"("PASS", "number", " at pos=", rx2298_pos)
  debug_1342:
    .return (rx2298_cur)
  rx2298_restart:
.annotate 'line', 422
    if_null rx2298_debug, debug_1343
    rx2298_cur."!cursor_debug"("NEXT", "number")
  debug_1343:
  rx2298_fail:
    (rx2298_rep, rx2298_pos, $I10, $P10) = rx2298_cur."!mark_fail"(0)
    lt rx2298_pos, -1, rx2298_done
    eq rx2298_pos, -1, rx2298_fail
    jump $I10
  rx2298_done:
    rx2298_cur."!cursor_fail"()
    if_null rx2298_debug, debug_1344
    rx2298_cur."!cursor_debug"("FAIL", "number")
  debug_1344:
    .return (rx2298_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("264_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2304, "ResizablePMCArray"
    push $P2304, ""
    .return ($P2304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("265_1304523757.895")
    .param pmc param_2306
.annotate 'line', 987
    .lex "self", param_2306
    $P2307 = param_2306."!protoregex"("quote")
    .return ($P2307)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("266_1304523757.895")
    .param pmc param_2309
.annotate 'line', 987
    .lex "self", param_2309
    $P2310 = param_2309."!PREFIX__!protoregex"("quote")
    .return ($P2310)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("267_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2312_tgt
    .local int rx2312_pos
    .local int rx2312_off
    .local int rx2312_eos
    .local int rx2312_rep
    .local pmc rx2312_cur
    .local pmc rx2312_debug
    (rx2312_cur, rx2312_pos, rx2312_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2312_cur
    .local pmc match
    .lex "$/", match
    length rx2312_eos, rx2312_tgt
    gt rx2312_pos, rx2312_eos, rx2312_done
    set rx2312_off, 0
    lt rx2312_pos, 2, rx2312_start
    sub rx2312_off, rx2312_pos, 1
    substr rx2312_tgt, rx2312_tgt, rx2312_off
  rx2312_start:
    eq $I10, 1, rx2312_restart
    if_null rx2312_debug, debug_1345
    rx2312_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2313_done
    goto rxscan2313_scan
  rxscan2313_loop:
    (rx2312_pos) = rx2312_cur."from"()
    inc rx2312_pos
    rx2312_cur."!cursor_from"(rx2312_pos)
    ge rx2312_pos, rx2312_eos, rxscan2313_done
  rxscan2313_scan:
    set_addr $I10, rxscan2313_loop
    rx2312_cur."!mark_push"(0, rx2312_pos, $I10)
  rxscan2313_done:
.annotate 'line', 988
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2312_pos, rx2312_off
    substr $S10, rx2312_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx2312_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2312_cur."!cursor_pos"(rx2312_pos)
    $P10 = rx2312_cur."quote_EXPR"(":q")
    unless $P10, rx2312_fail
    rx2312_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2312_pos = $P10."pos"()
  # rx pass
    rx2312_cur."!cursor_pass"(rx2312_pos, "quote:sym<apos>")
    if_null rx2312_debug, debug_1346
    rx2312_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx2312_pos)
  debug_1346:
    .return (rx2312_cur)
  rx2312_restart:
.annotate 'line', 422
    if_null rx2312_debug, debug_1347
    rx2312_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1347:
  rx2312_fail:
    (rx2312_rep, rx2312_pos, $I10, $P10) = rx2312_cur."!mark_fail"(0)
    lt rx2312_pos, -1, rx2312_done
    eq rx2312_pos, -1, rx2312_fail
    jump $I10
  rx2312_done:
    rx2312_cur."!cursor_fail"()
    if_null rx2312_debug, debug_1348
    rx2312_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1348:
    .return (rx2312_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("268_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2315, "ResizablePMCArray"
    push $P2315, "'"
    .return ($P2315)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("269_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2317_tgt
    .local int rx2317_pos
    .local int rx2317_off
    .local int rx2317_eos
    .local int rx2317_rep
    .local pmc rx2317_cur
    .local pmc rx2317_debug
    (rx2317_cur, rx2317_pos, rx2317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2317_cur
    .local pmc match
    .lex "$/", match
    length rx2317_eos, rx2317_tgt
    gt rx2317_pos, rx2317_eos, rx2317_done
    set rx2317_off, 0
    lt rx2317_pos, 2, rx2317_start
    sub rx2317_off, rx2317_pos, 1
    substr rx2317_tgt, rx2317_tgt, rx2317_off
  rx2317_start:
    eq $I10, 1, rx2317_restart
    if_null rx2317_debug, debug_1349
    rx2317_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2318_done
    goto rxscan2318_scan
  rxscan2318_loop:
    (rx2317_pos) = rx2317_cur."from"()
    inc rx2317_pos
    rx2317_cur."!cursor_from"(rx2317_pos)
    ge rx2317_pos, rx2317_eos, rxscan2318_done
  rxscan2318_scan:
    set_addr $I10, rxscan2318_loop
    rx2317_cur."!mark_push"(0, rx2317_pos, $I10)
  rxscan2318_done:
.annotate 'line', 989
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2317_pos, rx2317_off
    substr $S10, rx2317_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx2317_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2317_cur."!cursor_pos"(rx2317_pos)
    $P10 = rx2317_cur."quote_EXPR"(":qq")
    unless $P10, rx2317_fail
    rx2317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2317_pos = $P10."pos"()
  # rx pass
    rx2317_cur."!cursor_pass"(rx2317_pos, "quote:sym<dblq>")
    if_null rx2317_debug, debug_1350
    rx2317_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx2317_pos)
  debug_1350:
    .return (rx2317_cur)
  rx2317_restart:
.annotate 'line', 422
    if_null rx2317_debug, debug_1351
    rx2317_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1351:
  rx2317_fail:
    (rx2317_rep, rx2317_pos, $I10, $P10) = rx2317_cur."!mark_fail"(0)
    lt rx2317_pos, -1, rx2317_done
    eq rx2317_pos, -1, rx2317_fail
    jump $I10
  rx2317_done:
    rx2317_cur."!cursor_fail"()
    if_null rx2317_debug, debug_1352
    rx2317_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1352:
    .return (rx2317_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("270_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2320, "ResizablePMCArray"
    push $P2320, "\""
    .return ($P2320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("271_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2322_tgt
    .local int rx2322_pos
    .local int rx2322_off
    .local int rx2322_eos
    .local int rx2322_rep
    .local pmc rx2322_cur
    .local pmc rx2322_debug
    (rx2322_cur, rx2322_pos, rx2322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2322_cur
    .local pmc match
    .lex "$/", match
    length rx2322_eos, rx2322_tgt
    gt rx2322_pos, rx2322_eos, rx2322_done
    set rx2322_off, 0
    lt rx2322_pos, 2, rx2322_start
    sub rx2322_off, rx2322_pos, 1
    substr rx2322_tgt, rx2322_tgt, rx2322_off
  rx2322_start:
    eq $I10, 1, rx2322_restart
    if_null rx2322_debug, debug_1353
    rx2322_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1353:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2323_done
    goto rxscan2323_scan
  rxscan2323_loop:
    (rx2322_pos) = rx2322_cur."from"()
    inc rx2322_pos
    rx2322_cur."!cursor_from"(rx2322_pos)
    ge rx2322_pos, rx2322_eos, rxscan2323_done
  rxscan2323_scan:
    set_addr $I10, rxscan2323_loop
    rx2322_cur."!mark_push"(0, rx2322_pos, $I10)
  rxscan2323_done:
.annotate 'line', 990
  # rx subcapture "sym"
    set_addr $I10, rxcap_2324_fail
    rx2322_cur."!mark_push"(0, rx2322_pos, $I10)
  # rx literal  "q"
    add $I11, rx2322_pos, 1
    gt $I11, rx2322_eos, rx2322_fail
    sub $I11, rx2322_pos, rx2322_off
    ord $I11, rx2322_tgt, $I11
    ne $I11, 113, rx2322_fail
    add rx2322_pos, 1
    set_addr $I10, rxcap_2324_fail
    ($I12, $I11) = rx2322_cur."!mark_peek"($I10)
    rx2322_cur."!cursor_pos"($I11)
    ($P10) = rx2322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2322_pos, "")
    rx2322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2324_done
  rxcap_2324_fail:
    goto rx2322_fail
  rxcap_2324_done:
  # rxanchor rwb
    le rx2322_pos, 0, rx2322_fail
    sub $I10, rx2322_pos, rx2322_off
    is_cclass $I11, 8192, rx2322_tgt, $I10
    if $I11, rx2322_fail
    dec $I10
    is_cclass $I11, 8192, rx2322_tgt, $I10
    unless $I11, rx2322_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2322_pos, rx2322_off
    substr $S10, rx2322_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2322_fail
  # rx subrule "ws" subtype=method negate=
    rx2322_cur."!cursor_pos"(rx2322_pos)
    $P10 = rx2322_cur."ws"()
    unless $P10, rx2322_fail
    rx2322_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2322_cur."!cursor_pos"(rx2322_pos)
    $P10 = rx2322_cur."quote_EXPR"(":q")
    unless $P10, rx2322_fail
    rx2322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2322_pos = $P10."pos"()
  # rx pass
    rx2322_cur."!cursor_pass"(rx2322_pos, "quote:sym<q>")
    if_null rx2322_debug, debug_1354
    rx2322_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx2322_pos)
  debug_1354:
    .return (rx2322_cur)
  rx2322_restart:
.annotate 'line', 422
    if_null rx2322_debug, debug_1355
    rx2322_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1355:
  rx2322_fail:
    (rx2322_rep, rx2322_pos, $I10, $P10) = rx2322_cur."!mark_fail"(0)
    lt rx2322_pos, -1, rx2322_done
    eq rx2322_pos, -1, rx2322_fail
    jump $I10
  rx2322_done:
    rx2322_cur."!cursor_fail"()
    if_null rx2322_debug, debug_1356
    rx2322_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1356:
    .return (rx2322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("272_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2326 = self."!PREFIX__!subrule"("ws", "q")
    new $P2327, "ResizablePMCArray"
    push $P2327, $P2326
    .return ($P2327)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("273_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2329_tgt
    .local int rx2329_pos
    .local int rx2329_off
    .local int rx2329_eos
    .local int rx2329_rep
    .local pmc rx2329_cur
    .local pmc rx2329_debug
    (rx2329_cur, rx2329_pos, rx2329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2329_cur
    .local pmc match
    .lex "$/", match
    length rx2329_eos, rx2329_tgt
    gt rx2329_pos, rx2329_eos, rx2329_done
    set rx2329_off, 0
    lt rx2329_pos, 2, rx2329_start
    sub rx2329_off, rx2329_pos, 1
    substr rx2329_tgt, rx2329_tgt, rx2329_off
  rx2329_start:
    eq $I10, 1, rx2329_restart
    if_null rx2329_debug, debug_1357
    rx2329_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2330_done
    goto rxscan2330_scan
  rxscan2330_loop:
    (rx2329_pos) = rx2329_cur."from"()
    inc rx2329_pos
    rx2329_cur."!cursor_from"(rx2329_pos)
    ge rx2329_pos, rx2329_eos, rxscan2330_done
  rxscan2330_scan:
    set_addr $I10, rxscan2330_loop
    rx2329_cur."!mark_push"(0, rx2329_pos, $I10)
  rxscan2330_done:
.annotate 'line', 991
  # rx subcapture "sym"
    set_addr $I10, rxcap_2331_fail
    rx2329_cur."!mark_push"(0, rx2329_pos, $I10)
  # rx literal  "qq"
    add $I11, rx2329_pos, 2
    gt $I11, rx2329_eos, rx2329_fail
    sub $I11, rx2329_pos, rx2329_off
    substr $S10, rx2329_tgt, $I11, 2
    ne $S10, "qq", rx2329_fail
    add rx2329_pos, 2
    set_addr $I10, rxcap_2331_fail
    ($I12, $I11) = rx2329_cur."!mark_peek"($I10)
    rx2329_cur."!cursor_pos"($I11)
    ($P10) = rx2329_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2329_pos, "")
    rx2329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2331_done
  rxcap_2331_fail:
    goto rx2329_fail
  rxcap_2331_done:
  # rxanchor rwb
    le rx2329_pos, 0, rx2329_fail
    sub $I10, rx2329_pos, rx2329_off
    is_cclass $I11, 8192, rx2329_tgt, $I10
    if $I11, rx2329_fail
    dec $I10
    is_cclass $I11, 8192, rx2329_tgt, $I10
    unless $I11, rx2329_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2329_pos, rx2329_off
    substr $S10, rx2329_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2329_fail
  # rx subrule "ws" subtype=method negate=
    rx2329_cur."!cursor_pos"(rx2329_pos)
    $P10 = rx2329_cur."ws"()
    unless $P10, rx2329_fail
    rx2329_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2329_cur."!cursor_pos"(rx2329_pos)
    $P10 = rx2329_cur."quote_EXPR"(":qq")
    unless $P10, rx2329_fail
    rx2329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2329_pos = $P10."pos"()
  # rx pass
    rx2329_cur."!cursor_pass"(rx2329_pos, "quote:sym<qq>")
    if_null rx2329_debug, debug_1358
    rx2329_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx2329_pos)
  debug_1358:
    .return (rx2329_cur)
  rx2329_restart:
.annotate 'line', 422
    if_null rx2329_debug, debug_1359
    rx2329_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1359:
  rx2329_fail:
    (rx2329_rep, rx2329_pos, $I10, $P10) = rx2329_cur."!mark_fail"(0)
    lt rx2329_pos, -1, rx2329_done
    eq rx2329_pos, -1, rx2329_fail
    jump $I10
  rx2329_done:
    rx2329_cur."!cursor_fail"()
    if_null rx2329_debug, debug_1360
    rx2329_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1360:
    .return (rx2329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("274_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2333 = self."!PREFIX__!subrule"("ws", "qq")
    new $P2334, "ResizablePMCArray"
    push $P2334, $P2333
    .return ($P2334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("275_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2336_tgt
    .local int rx2336_pos
    .local int rx2336_off
    .local int rx2336_eos
    .local int rx2336_rep
    .local pmc rx2336_cur
    .local pmc rx2336_debug
    (rx2336_cur, rx2336_pos, rx2336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2336_cur
    .local pmc match
    .lex "$/", match
    length rx2336_eos, rx2336_tgt
    gt rx2336_pos, rx2336_eos, rx2336_done
    set rx2336_off, 0
    lt rx2336_pos, 2, rx2336_start
    sub rx2336_off, rx2336_pos, 1
    substr rx2336_tgt, rx2336_tgt, rx2336_off
  rx2336_start:
    eq $I10, 1, rx2336_restart
    if_null rx2336_debug, debug_1361
    rx2336_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1361:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2337_done
    goto rxscan2337_scan
  rxscan2337_loop:
    (rx2336_pos) = rx2336_cur."from"()
    inc rx2336_pos
    rx2336_cur."!cursor_from"(rx2336_pos)
    ge rx2336_pos, rx2336_eos, rxscan2337_done
  rxscan2337_scan:
    set_addr $I10, rxscan2337_loop
    rx2336_cur."!mark_push"(0, rx2336_pos, $I10)
  rxscan2337_done:
.annotate 'line', 992
  # rx subcapture "sym"
    set_addr $I10, rxcap_2338_fail
    rx2336_cur."!mark_push"(0, rx2336_pos, $I10)
  # rx literal  "Q"
    add $I11, rx2336_pos, 1
    gt $I11, rx2336_eos, rx2336_fail
    sub $I11, rx2336_pos, rx2336_off
    ord $I11, rx2336_tgt, $I11
    ne $I11, 81, rx2336_fail
    add rx2336_pos, 1
    set_addr $I10, rxcap_2338_fail
    ($I12, $I11) = rx2336_cur."!mark_peek"($I10)
    rx2336_cur."!cursor_pos"($I11)
    ($P10) = rx2336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2336_pos, "")
    rx2336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2338_done
  rxcap_2338_fail:
    goto rx2336_fail
  rxcap_2338_done:
  # rxanchor rwb
    le rx2336_pos, 0, rx2336_fail
    sub $I10, rx2336_pos, rx2336_off
    is_cclass $I11, 8192, rx2336_tgt, $I10
    if $I11, rx2336_fail
    dec $I10
    is_cclass $I11, 8192, rx2336_tgt, $I10
    unless $I11, rx2336_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2336_pos, rx2336_off
    substr $S10, rx2336_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2336_fail
  # rx subrule "ws" subtype=method negate=
    rx2336_cur."!cursor_pos"(rx2336_pos)
    $P10 = rx2336_cur."ws"()
    unless $P10, rx2336_fail
    rx2336_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2336_cur."!cursor_pos"(rx2336_pos)
    $P10 = rx2336_cur."quote_EXPR"()
    unless $P10, rx2336_fail
    rx2336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2336_pos = $P10."pos"()
  # rx pass
    rx2336_cur."!cursor_pass"(rx2336_pos, "quote:sym<Q>")
    if_null rx2336_debug, debug_1362
    rx2336_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx2336_pos)
  debug_1362:
    .return (rx2336_cur)
  rx2336_restart:
.annotate 'line', 422
    if_null rx2336_debug, debug_1363
    rx2336_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1363:
  rx2336_fail:
    (rx2336_rep, rx2336_pos, $I10, $P10) = rx2336_cur."!mark_fail"(0)
    lt rx2336_pos, -1, rx2336_done
    eq rx2336_pos, -1, rx2336_fail
    jump $I10
  rx2336_done:
    rx2336_cur."!cursor_fail"()
    if_null rx2336_debug, debug_1364
    rx2336_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1364:
    .return (rx2336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("276_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2340 = self."!PREFIX__!subrule"("ws", "Q")
    new $P2341, "ResizablePMCArray"
    push $P2341, $P2340
    .return ($P2341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("277_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2343_tgt
    .local int rx2343_pos
    .local int rx2343_off
    .local int rx2343_eos
    .local int rx2343_rep
    .local pmc rx2343_cur
    .local pmc rx2343_debug
    (rx2343_cur, rx2343_pos, rx2343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2343_cur
    .local pmc match
    .lex "$/", match
    length rx2343_eos, rx2343_tgt
    gt rx2343_pos, rx2343_eos, rx2343_done
    set rx2343_off, 0
    lt rx2343_pos, 2, rx2343_start
    sub rx2343_off, rx2343_pos, 1
    substr rx2343_tgt, rx2343_tgt, rx2343_off
  rx2343_start:
    eq $I10, 1, rx2343_restart
    if_null rx2343_debug, debug_1365
    rx2343_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2344_done
    goto rxscan2344_scan
  rxscan2344_loop:
    (rx2343_pos) = rx2343_cur."from"()
    inc rx2343_pos
    rx2343_cur."!cursor_from"(rx2343_pos)
    ge rx2343_pos, rx2343_eos, rxscan2344_done
  rxscan2344_scan:
    set_addr $I10, rxscan2344_loop
    rx2343_cur."!mark_push"(0, rx2343_pos, $I10)
  rxscan2344_done:
.annotate 'line', 993
  # rx subcapture "sym"
    set_addr $I10, rxcap_2345_fail
    rx2343_cur."!mark_push"(0, rx2343_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx2343_pos, 5
    gt $I11, rx2343_eos, rx2343_fail
    sub $I11, rx2343_pos, rx2343_off
    substr $S10, rx2343_tgt, $I11, 5
    ne $S10, "Q:PIR", rx2343_fail
    add rx2343_pos, 5
    set_addr $I10, rxcap_2345_fail
    ($I12, $I11) = rx2343_cur."!mark_peek"($I10)
    rx2343_cur."!cursor_pos"($I11)
    ($P10) = rx2343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2343_pos, "")
    rx2343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2345_done
  rxcap_2345_fail:
    goto rx2343_fail
  rxcap_2345_done:
  # rx subrule "ws" subtype=method negate=
    rx2343_cur."!cursor_pos"(rx2343_pos)
    $P10 = rx2343_cur."ws"()
    unless $P10, rx2343_fail
    rx2343_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2343_cur."!cursor_pos"(rx2343_pos)
    $P10 = rx2343_cur."quote_EXPR"()
    unless $P10, rx2343_fail
    rx2343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2343_pos = $P10."pos"()
  # rx pass
    rx2343_cur."!cursor_pass"(rx2343_pos, "quote:sym<Q:PIR>")
    if_null rx2343_debug, debug_1366
    rx2343_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx2343_pos)
  debug_1366:
    .return (rx2343_cur)
  rx2343_restart:
.annotate 'line', 422
    if_null rx2343_debug, debug_1367
    rx2343_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1367:
  rx2343_fail:
    (rx2343_rep, rx2343_pos, $I10, $P10) = rx2343_cur."!mark_fail"(0)
    lt rx2343_pos, -1, rx2343_done
    eq rx2343_pos, -1, rx2343_fail
    jump $I10
  rx2343_done:
    rx2343_cur."!cursor_fail"()
    if_null rx2343_debug, debug_1368
    rx2343_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1368:
    .return (rx2343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("278_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2347 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P2348, "ResizablePMCArray"
    push $P2348, $P2347
    .return ($P2348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("279_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2350_tgt
    .local int rx2350_pos
    .local int rx2350_off
    .local int rx2350_eos
    .local int rx2350_rep
    .local pmc rx2350_cur
    .local pmc rx2350_debug
    (rx2350_cur, rx2350_pos, rx2350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2350_cur
    .local pmc match
    .lex "$/", match
    length rx2350_eos, rx2350_tgt
    gt rx2350_pos, rx2350_eos, rx2350_done
    set rx2350_off, 0
    lt rx2350_pos, 2, rx2350_start
    sub rx2350_off, rx2350_pos, 1
    substr rx2350_tgt, rx2350_tgt, rx2350_off
  rx2350_start:
    eq $I10, 1, rx2350_restart
    if_null rx2350_debug, debug_1369
    rx2350_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2351_done
    goto rxscan2351_scan
  rxscan2351_loop:
    (rx2350_pos) = rx2350_cur."from"()
    inc rx2350_pos
    rx2350_cur."!cursor_from"(rx2350_pos)
    ge rx2350_pos, rx2350_eos, rxscan2351_done
  rxscan2351_scan:
    set_addr $I10, rxscan2351_loop
    rx2350_cur."!mark_push"(0, rx2350_pos, $I10)
  rxscan2351_done:
.annotate 'line', 995
  # rx literal  "/"
    add $I11, rx2350_pos, 1
    gt $I11, rx2350_eos, rx2350_fail
    sub $I11, rx2350_pos, rx2350_off
    ord $I11, rx2350_tgt, $I11
    ne $I11, 47, rx2350_fail
    add rx2350_pos, 1
.annotate 'line', 996
  # rx subrule "newpad" subtype=method negate=
    rx2350_cur."!cursor_pos"(rx2350_pos)
    $P10 = rx2350_cur."newpad"()
    unless $P10, rx2350_fail
    rx2350_pos = $P10."pos"()
.annotate 'line', 997
  # rx reduce name="quote:sym</ />" key="open"
    rx2350_cur."!cursor_pos"(rx2350_pos)
    rx2350_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 998
  # rx subrule "LANG" subtype=capture negate=
    rx2350_cur."!cursor_pos"(rx2350_pos)
    $P10 = rx2350_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2350_fail
    rx2350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2350_pos = $P10."pos"()
.annotate 'line', 999
  # rx literal  "/"
    add $I11, rx2350_pos, 1
    gt $I11, rx2350_eos, rx2350_fail
    sub $I11, rx2350_pos, rx2350_off
    ord $I11, rx2350_tgt, $I11
    ne $I11, 47, rx2350_fail
    add rx2350_pos, 1
.annotate 'line', 994
  # rx pass
    rx2350_cur."!cursor_pass"(rx2350_pos, "quote:sym</ />")
    if_null rx2350_debug, debug_1370
    rx2350_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2350_pos)
  debug_1370:
    .return (rx2350_cur)
  rx2350_restart:
.annotate 'line', 422
    if_null rx2350_debug, debug_1371
    rx2350_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1371:
  rx2350_fail:
    (rx2350_rep, rx2350_pos, $I10, $P10) = rx2350_cur."!mark_fail"(0)
    lt rx2350_pos, -1, rx2350_done
    eq rx2350_pos, -1, rx2350_fail
    jump $I10
  rx2350_done:
    rx2350_cur."!cursor_fail"()
    if_null rx2350_debug, debug_1372
    rx2350_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1372:
    .return (rx2350_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("280_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2353 = self."!PREFIX__!subrule"("newpad", "/")
    new $P2354, "ResizablePMCArray"
    push $P2354, $P2353
    .return ($P2354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("281_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2356_tgt
    .local int rx2356_pos
    .local int rx2356_off
    .local int rx2356_eos
    .local int rx2356_rep
    .local pmc rx2356_cur
    .local pmc rx2356_debug
    (rx2356_cur, rx2356_pos, rx2356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2356_cur
    .local pmc match
    .lex "$/", match
    length rx2356_eos, rx2356_tgt
    gt rx2356_pos, rx2356_eos, rx2356_done
    set rx2356_off, 0
    lt rx2356_pos, 2, rx2356_start
    sub rx2356_off, rx2356_pos, 1
    substr rx2356_tgt, rx2356_tgt, rx2356_off
  rx2356_start:
    eq $I10, 1, rx2356_restart
    if_null rx2356_debug, debug_1373
    rx2356_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1373:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2357_done
    goto rxscan2357_scan
  rxscan2357_loop:
    (rx2356_pos) = rx2356_cur."from"()
    inc rx2356_pos
    rx2356_cur."!cursor_from"(rx2356_pos)
    ge rx2356_pos, rx2356_eos, rxscan2357_done
  rxscan2357_scan:
    set_addr $I10, rxscan2357_loop
    rx2356_cur."!mark_push"(0, rx2356_pos, $I10)
  rxscan2357_done:
.annotate 'line', 1002
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2356_pos, rx2356_off
    substr $S10, rx2356_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2356_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2356_cur."!cursor_pos"(rx2356_pos)
    $P10 = rx2356_cur."quotemod_check"("s")
    unless $P10, rx2356_fail
  # rx subrule "variable" subtype=capture negate=
    rx2356_cur."!cursor_pos"(rx2356_pos)
    $P10 = rx2356_cur."variable"()
    unless $P10, rx2356_fail
    rx2356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2356_pos = $P10."pos"()
  # rx pass
    rx2356_cur."!cursor_pass"(rx2356_pos, "quote_escape:sym<$>")
    if_null rx2356_debug, debug_1374
    rx2356_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2356_pos)
  debug_1374:
    .return (rx2356_cur)
  rx2356_restart:
.annotate 'line', 422
    if_null rx2356_debug, debug_1375
    rx2356_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1375:
  rx2356_fail:
    (rx2356_rep, rx2356_pos, $I10, $P10) = rx2356_cur."!mark_fail"(0)
    lt rx2356_pos, -1, rx2356_done
    eq rx2356_pos, -1, rx2356_fail
    jump $I10
  rx2356_done:
    rx2356_cur."!cursor_fail"()
    if_null rx2356_debug, debug_1376
    rx2356_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1376:
    .return (rx2356_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("282_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2359, "ResizablePMCArray"
    push $P2359, "$"
    .return ($P2359)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("283_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2361_tgt
    .local int rx2361_pos
    .local int rx2361_off
    .local int rx2361_eos
    .local int rx2361_rep
    .local pmc rx2361_cur
    .local pmc rx2361_debug
    (rx2361_cur, rx2361_pos, rx2361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2361_cur
    .local pmc match
    .lex "$/", match
    length rx2361_eos, rx2361_tgt
    gt rx2361_pos, rx2361_eos, rx2361_done
    set rx2361_off, 0
    lt rx2361_pos, 2, rx2361_start
    sub rx2361_off, rx2361_pos, 1
    substr rx2361_tgt, rx2361_tgt, rx2361_off
  rx2361_start:
    eq $I10, 1, rx2361_restart
    if_null rx2361_debug, debug_1377
    rx2361_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1377:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2362_done
    goto rxscan2362_scan
  rxscan2362_loop:
    (rx2361_pos) = rx2361_cur."from"()
    inc rx2361_pos
    rx2361_cur."!cursor_from"(rx2361_pos)
    ge rx2361_pos, rx2361_eos, rxscan2362_done
  rxscan2362_scan:
    set_addr $I10, rxscan2362_loop
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
  rxscan2362_done:
.annotate 'line', 1003
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2361_pos, rx2361_off
    substr $S10, rx2361_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2361_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."quotemod_check"("c")
    unless $P10, rx2361_fail
  # rx subrule "block" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."block"()
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2361_pos = $P10."pos"()
  # rx pass
    rx2361_cur."!cursor_pass"(rx2361_pos, "quote_escape:sym<{ }>")
    if_null rx2361_debug, debug_1378
    rx2361_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2361_pos)
  debug_1378:
    .return (rx2361_cur)
  rx2361_restart:
.annotate 'line', 422
    if_null rx2361_debug, debug_1379
    rx2361_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1379:
  rx2361_fail:
    (rx2361_rep, rx2361_pos, $I10, $P10) = rx2361_cur."!mark_fail"(0)
    lt rx2361_pos, -1, rx2361_done
    eq rx2361_pos, -1, rx2361_fail
    jump $I10
  rx2361_done:
    rx2361_cur."!cursor_fail"()
    if_null rx2361_debug, debug_1380
    rx2361_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1380:
    .return (rx2361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("284_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2364, "ResizablePMCArray"
    push $P2364, "{"
    .return ($P2364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("285_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2366_tgt
    .local int rx2366_pos
    .local int rx2366_off
    .local int rx2366_eos
    .local int rx2366_rep
    .local pmc rx2366_cur
    .local pmc rx2366_debug
    (rx2366_cur, rx2366_pos, rx2366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2366_cur
    .local pmc match
    .lex "$/", match
    length rx2366_eos, rx2366_tgt
    gt rx2366_pos, rx2366_eos, rx2366_done
    set rx2366_off, 0
    lt rx2366_pos, 2, rx2366_start
    sub rx2366_off, rx2366_pos, 1
    substr rx2366_tgt, rx2366_tgt, rx2366_off
  rx2366_start:
    eq $I10, 1, rx2366_restart
    if_null rx2366_debug, debug_1381
    rx2366_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1381:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2367_done
    goto rxscan2367_scan
  rxscan2367_loop:
    (rx2366_pos) = rx2366_cur."from"()
    inc rx2366_pos
    rx2366_cur."!cursor_from"(rx2366_pos)
    ge rx2366_pos, rx2366_eos, rxscan2367_done
  rxscan2367_scan:
    set_addr $I10, rxscan2367_loop
    rx2366_cur."!mark_push"(0, rx2366_pos, $I10)
  rxscan2367_done:
.annotate 'line', 1004
  # rx literal  "\\e"
    add $I11, rx2366_pos, 2
    gt $I11, rx2366_eos, rx2366_fail
    sub $I11, rx2366_pos, rx2366_off
    substr $S10, rx2366_tgt, $I11, 2
    ne $S10, "\\e", rx2366_fail
    add rx2366_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2366_cur."!cursor_pos"(rx2366_pos)
    $P10 = rx2366_cur."quotemod_check"("b")
    unless $P10, rx2366_fail
  # rx pass
    rx2366_cur."!cursor_pass"(rx2366_pos, "quote_escape:sym<esc>")
    if_null rx2366_debug, debug_1382
    rx2366_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2366_pos)
  debug_1382:
    .return (rx2366_cur)
  rx2366_restart:
.annotate 'line', 422
    if_null rx2366_debug, debug_1383
    rx2366_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1383:
  rx2366_fail:
    (rx2366_rep, rx2366_pos, $I10, $P10) = rx2366_cur."!mark_fail"(0)
    lt rx2366_pos, -1, rx2366_done
    eq rx2366_pos, -1, rx2366_fail
    jump $I10
  rx2366_done:
    rx2366_cur."!cursor_fail"()
    if_null rx2366_debug, debug_1384
    rx2366_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1384:
    .return (rx2366_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("286_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2369, "ResizablePMCArray"
    push $P2369, "\\e"
    .return ($P2369)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("287_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2371_tgt
    .local int rx2371_pos
    .local int rx2371_off
    .local int rx2371_eos
    .local int rx2371_rep
    .local pmc rx2371_cur
    .local pmc rx2371_debug
    (rx2371_cur, rx2371_pos, rx2371_tgt, $I10) = self."!cursor_start"()
    rx2371_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2371_cur
    .local pmc match
    .lex "$/", match
    length rx2371_eos, rx2371_tgt
    gt rx2371_pos, rx2371_eos, rx2371_done
    set rx2371_off, 0
    lt rx2371_pos, 2, rx2371_start
    sub rx2371_off, rx2371_pos, 1
    substr rx2371_tgt, rx2371_tgt, rx2371_off
  rx2371_start:
    eq $I10, 1, rx2371_restart
    if_null rx2371_debug, debug_1385
    rx2371_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1385:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2372_done
    goto rxscan2372_scan
  rxscan2372_loop:
    (rx2371_pos) = rx2371_cur."from"()
    inc rx2371_pos
    rx2371_cur."!cursor_from"(rx2371_pos)
    ge rx2371_pos, rx2371_eos, rxscan2372_done
  rxscan2372_scan:
    set_addr $I10, rxscan2372_loop
    rx2371_cur."!mark_push"(0, rx2371_pos, $I10)
  rxscan2372_done:
.annotate 'line', 1006
  # rx literal  "("
    add $I11, rx2371_pos, 1
    gt $I11, rx2371_eos, rx2371_fail
    sub $I11, rx2371_pos, rx2371_off
    ord $I11, rx2371_tgt, $I11
    ne $I11, 40, rx2371_fail
    add rx2371_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2371_cur."!cursor_pos"(rx2371_pos)
    $P10 = rx2371_cur."ws"()
    unless $P10, rx2371_fail
    rx2371_pos = $P10."pos"()
  # rx rxquantr2373 ** 0..1
    set_addr $I10, rxquantr2373_done
    rx2371_cur."!mark_push"(0, rx2371_pos, $I10)
  rxquantr2373_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2371_cur."!cursor_pos"(rx2371_pos)
    $P10 = rx2371_cur."EXPR"()
    unless $P10, rx2371_fail
    goto rxsubrule2374_pass
  rxsubrule2374_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2371_fail
  rxsubrule2374_pass:
    set_addr $I10, rxsubrule2374_back
    rx2371_cur."!mark_push"(0, rx2371_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2371_pos = $P10."pos"()
    set_addr $I10, rxquantr2373_done
    (rx2371_rep) = rx2371_cur."!mark_commit"($I10)
  rxquantr2373_done:
  # rx literal  ")"
    add $I11, rx2371_pos, 1
    gt $I11, rx2371_eos, rx2371_fail
    sub $I11, rx2371_pos, rx2371_off
    ord $I11, rx2371_tgt, $I11
    ne $I11, 41, rx2371_fail
    add rx2371_pos, 1
  # rx pass
    rx2371_cur."!cursor_pass"(rx2371_pos, "circumfix:sym<( )>")
    if_null rx2371_debug, debug_1386
    rx2371_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2371_pos)
  debug_1386:
    .return (rx2371_cur)
  rx2371_restart:
.annotate 'line', 422
    if_null rx2371_debug, debug_1387
    rx2371_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1387:
  rx2371_fail:
    (rx2371_rep, rx2371_pos, $I10, $P10) = rx2371_cur."!mark_fail"(0)
    lt rx2371_pos, -1, rx2371_done
    eq rx2371_pos, -1, rx2371_fail
    jump $I10
  rx2371_done:
    rx2371_cur."!cursor_fail"()
    if_null rx2371_debug, debug_1388
    rx2371_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1388:
    .return (rx2371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("288_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2376 = self."!PREFIX__!subrule"("ws", "(")
    new $P2377, "ResizablePMCArray"
    push $P2377, $P2376
    .return ($P2377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("289_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2379_tgt
    .local int rx2379_pos
    .local int rx2379_off
    .local int rx2379_eos
    .local int rx2379_rep
    .local pmc rx2379_cur
    .local pmc rx2379_debug
    (rx2379_cur, rx2379_pos, rx2379_tgt, $I10) = self."!cursor_start"()
    rx2379_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2379_cur
    .local pmc match
    .lex "$/", match
    length rx2379_eos, rx2379_tgt
    gt rx2379_pos, rx2379_eos, rx2379_done
    set rx2379_off, 0
    lt rx2379_pos, 2, rx2379_start
    sub rx2379_off, rx2379_pos, 1
    substr rx2379_tgt, rx2379_tgt, rx2379_off
  rx2379_start:
    eq $I10, 1, rx2379_restart
    if_null rx2379_debug, debug_1389
    rx2379_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1389:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2380_done
    goto rxscan2380_scan
  rxscan2380_loop:
    (rx2379_pos) = rx2379_cur."from"()
    inc rx2379_pos
    rx2379_cur."!cursor_from"(rx2379_pos)
    ge rx2379_pos, rx2379_eos, rxscan2380_done
  rxscan2380_scan:
    set_addr $I10, rxscan2380_loop
    rx2379_cur."!mark_push"(0, rx2379_pos, $I10)
  rxscan2380_done:
.annotate 'line', 1007
  # rx literal  "["
    add $I11, rx2379_pos, 1
    gt $I11, rx2379_eos, rx2379_fail
    sub $I11, rx2379_pos, rx2379_off
    ord $I11, rx2379_tgt, $I11
    ne $I11, 91, rx2379_fail
    add rx2379_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2379_cur."!cursor_pos"(rx2379_pos)
    $P10 = rx2379_cur."ws"()
    unless $P10, rx2379_fail
    rx2379_pos = $P10."pos"()
  # rx rxquantr2381 ** 0..1
    set_addr $I10, rxquantr2381_done
    rx2379_cur."!mark_push"(0, rx2379_pos, $I10)
  rxquantr2381_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2379_cur."!cursor_pos"(rx2379_pos)
    $P10 = rx2379_cur."EXPR"()
    unless $P10, rx2379_fail
    goto rxsubrule2382_pass
  rxsubrule2382_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2379_fail
  rxsubrule2382_pass:
    set_addr $I10, rxsubrule2382_back
    rx2379_cur."!mark_push"(0, rx2379_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2379_pos = $P10."pos"()
    set_addr $I10, rxquantr2381_done
    (rx2379_rep) = rx2379_cur."!mark_commit"($I10)
  rxquantr2381_done:
  # rx literal  "]"
    add $I11, rx2379_pos, 1
    gt $I11, rx2379_eos, rx2379_fail
    sub $I11, rx2379_pos, rx2379_off
    ord $I11, rx2379_tgt, $I11
    ne $I11, 93, rx2379_fail
    add rx2379_pos, 1
  # rx pass
    rx2379_cur."!cursor_pass"(rx2379_pos, "circumfix:sym<[ ]>")
    if_null rx2379_debug, debug_1390
    rx2379_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2379_pos)
  debug_1390:
    .return (rx2379_cur)
  rx2379_restart:
.annotate 'line', 422
    if_null rx2379_debug, debug_1391
    rx2379_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1391:
  rx2379_fail:
    (rx2379_rep, rx2379_pos, $I10, $P10) = rx2379_cur."!mark_fail"(0)
    lt rx2379_pos, -1, rx2379_done
    eq rx2379_pos, -1, rx2379_fail
    jump $I10
  rx2379_done:
    rx2379_cur."!cursor_fail"()
    if_null rx2379_debug, debug_1392
    rx2379_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1392:
    .return (rx2379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("290_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2384 = self."!PREFIX__!subrule"("ws", "[")
    new $P2385, "ResizablePMCArray"
    push $P2385, $P2384
    .return ($P2385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("291_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2387_tgt
    .local int rx2387_pos
    .local int rx2387_off
    .local int rx2387_eos
    .local int rx2387_rep
    .local pmc rx2387_cur
    .local pmc rx2387_debug
    (rx2387_cur, rx2387_pos, rx2387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2387_cur
    .local pmc match
    .lex "$/", match
    length rx2387_eos, rx2387_tgt
    gt rx2387_pos, rx2387_eos, rx2387_done
    set rx2387_off, 0
    lt rx2387_pos, 2, rx2387_start
    sub rx2387_off, rx2387_pos, 1
    substr rx2387_tgt, rx2387_tgt, rx2387_off
  rx2387_start:
    eq $I10, 1, rx2387_restart
    if_null rx2387_debug, debug_1393
    rx2387_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1393:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2388_done
    goto rxscan2388_scan
  rxscan2388_loop:
    (rx2387_pos) = rx2387_cur."from"()
    inc rx2387_pos
    rx2387_cur."!cursor_from"(rx2387_pos)
    ge rx2387_pos, rx2387_eos, rxscan2388_done
  rxscan2388_scan:
    set_addr $I10, rxscan2388_loop
    rx2387_cur."!mark_push"(0, rx2387_pos, $I10)
  rxscan2388_done:
.annotate 'line', 1008
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2387_pos, rx2387_off
    substr $S10, rx2387_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2387_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2387_cur."!cursor_pos"(rx2387_pos)
    $P10 = rx2387_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2387_fail
    rx2387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2387_pos = $P10."pos"()
  # rx pass
    rx2387_cur."!cursor_pass"(rx2387_pos, "circumfix:sym<ang>")
    if_null rx2387_debug, debug_1394
    rx2387_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2387_pos)
  debug_1394:
    .return (rx2387_cur)
  rx2387_restart:
.annotate 'line', 422
    if_null rx2387_debug, debug_1395
    rx2387_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1395:
  rx2387_fail:
    (rx2387_rep, rx2387_pos, $I10, $P10) = rx2387_cur."!mark_fail"(0)
    lt rx2387_pos, -1, rx2387_done
    eq rx2387_pos, -1, rx2387_fail
    jump $I10
  rx2387_done:
    rx2387_cur."!cursor_fail"()
    if_null rx2387_debug, debug_1396
    rx2387_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1396:
    .return (rx2387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("292_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2390, "ResizablePMCArray"
    push $P2390, "<"
    .return ($P2390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("293_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2392_tgt
    .local int rx2392_pos
    .local int rx2392_off
    .local int rx2392_eos
    .local int rx2392_rep
    .local pmc rx2392_cur
    .local pmc rx2392_debug
    (rx2392_cur, rx2392_pos, rx2392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2392_cur
    .local pmc match
    .lex "$/", match
    length rx2392_eos, rx2392_tgt
    gt rx2392_pos, rx2392_eos, rx2392_done
    set rx2392_off, 0
    lt rx2392_pos, 2, rx2392_start
    sub rx2392_off, rx2392_pos, 1
    substr rx2392_tgt, rx2392_tgt, rx2392_off
  rx2392_start:
    eq $I10, 1, rx2392_restart
    if_null rx2392_debug, debug_1397
    rx2392_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1397:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2393_done
    goto rxscan2393_scan
  rxscan2393_loop:
    (rx2392_pos) = rx2392_cur."from"()
    inc rx2392_pos
    rx2392_cur."!cursor_from"(rx2392_pos)
    ge rx2392_pos, rx2392_eos, rxscan2393_done
  rxscan2393_scan:
    set_addr $I10, rxscan2393_loop
    rx2392_cur."!mark_push"(0, rx2392_pos, $I10)
  rxscan2393_done:
.annotate 'line', 1009
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2392_pos, rx2392_off
    substr $S10, rx2392_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2392_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2392_cur."!cursor_pos"(rx2392_pos)
    $P10 = rx2392_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2392_fail
    rx2392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2392_pos = $P10."pos"()
  # rx pass
    rx2392_cur."!cursor_pass"(rx2392_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2392_debug, debug_1398
    rx2392_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2392_pos)
  debug_1398:
    .return (rx2392_cur)
  rx2392_restart:
.annotate 'line', 422
    if_null rx2392_debug, debug_1399
    rx2392_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1399:
  rx2392_fail:
    (rx2392_rep, rx2392_pos, $I10, $P10) = rx2392_cur."!mark_fail"(0)
    lt rx2392_pos, -1, rx2392_done
    eq rx2392_pos, -1, rx2392_fail
    jump $I10
  rx2392_done:
    rx2392_cur."!cursor_fail"()
    if_null rx2392_debug, debug_1400
    rx2392_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1400:
    .return (rx2392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("294_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2395, "ResizablePMCArray"
    push $P2395, unicode:"\x{ab}"
    .return ($P2395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("295_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2397_tgt
    .local int rx2397_pos
    .local int rx2397_off
    .local int rx2397_eos
    .local int rx2397_rep
    .local pmc rx2397_cur
    .local pmc rx2397_debug
    (rx2397_cur, rx2397_pos, rx2397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2397_cur
    .local pmc match
    .lex "$/", match
    length rx2397_eos, rx2397_tgt
    gt rx2397_pos, rx2397_eos, rx2397_done
    set rx2397_off, 0
    lt rx2397_pos, 2, rx2397_start
    sub rx2397_off, rx2397_pos, 1
    substr rx2397_tgt, rx2397_tgt, rx2397_off
  rx2397_start:
    eq $I10, 1, rx2397_restart
    if_null rx2397_debug, debug_1401
    rx2397_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1401:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2398_done
    goto rxscan2398_scan
  rxscan2398_loop:
    (rx2397_pos) = rx2397_cur."from"()
    inc rx2397_pos
    rx2397_cur."!cursor_from"(rx2397_pos)
    ge rx2397_pos, rx2397_eos, rxscan2398_done
  rxscan2398_scan:
    set_addr $I10, rxscan2398_loop
    rx2397_cur."!mark_push"(0, rx2397_pos, $I10)
  rxscan2398_done:
.annotate 'line', 1010
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2397_pos, rx2397_off
    substr $S10, rx2397_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2397_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2397_cur."!cursor_pos"(rx2397_pos)
    $P10 = rx2397_cur."pblock"()
    unless $P10, rx2397_fail
    rx2397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2397_pos = $P10."pos"()
  # rx pass
    rx2397_cur."!cursor_pass"(rx2397_pos, "circumfix:sym<{ }>")
    if_null rx2397_debug, debug_1402
    rx2397_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2397_pos)
  debug_1402:
    .return (rx2397_cur)
  rx2397_restart:
.annotate 'line', 422
    if_null rx2397_debug, debug_1403
    rx2397_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1403:
  rx2397_fail:
    (rx2397_rep, rx2397_pos, $I10, $P10) = rx2397_cur."!mark_fail"(0)
    lt rx2397_pos, -1, rx2397_done
    eq rx2397_pos, -1, rx2397_fail
    jump $I10
  rx2397_done:
    rx2397_cur."!cursor_fail"()
    if_null rx2397_debug, debug_1404
    rx2397_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1404:
    .return (rx2397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("296_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2400, "ResizablePMCArray"
    push $P2400, "{"
    .return ($P2400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("297_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2402_tgt
    .local int rx2402_pos
    .local int rx2402_off
    .local int rx2402_eos
    .local int rx2402_rep
    .local pmc rx2402_cur
    .local pmc rx2402_debug
    (rx2402_cur, rx2402_pos, rx2402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2402_cur
    .local pmc match
    .lex "$/", match
    length rx2402_eos, rx2402_tgt
    gt rx2402_pos, rx2402_eos, rx2402_done
    set rx2402_off, 0
    lt rx2402_pos, 2, rx2402_start
    sub rx2402_off, rx2402_pos, 1
    substr rx2402_tgt, rx2402_tgt, rx2402_off
  rx2402_start:
    eq $I10, 1, rx2402_restart
    if_null rx2402_debug, debug_1405
    rx2402_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1405:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2403_done
    goto rxscan2403_scan
  rxscan2403_loop:
    (rx2402_pos) = rx2402_cur."from"()
    inc rx2402_pos
    rx2402_cur."!cursor_from"(rx2402_pos)
    ge rx2402_pos, rx2402_eos, rxscan2403_done
  rxscan2403_scan:
    set_addr $I10, rxscan2403_loop
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10)
  rxscan2403_done:
.annotate 'line', 1011
  # rx subrule "sigil" subtype=capture negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."sigil"()
    unless $P10, rx2402_fail
    rx2402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2402_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 40, rx2402_fail
    add rx2402_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."semilist"()
    unless $P10, rx2402_fail
    rx2402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2402_pos = $P10."pos"()
  alt2404_0:
    set_addr $I10, alt2404_1
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10)
  # rx literal  ")"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 41, rx2402_fail
    add rx2402_pos, 1
    goto alt2404_end
  alt2404_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."FAILGOAL"("')'")
    unless $P10, rx2402_fail
    goto rxsubrule2406_pass
  rxsubrule2406_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2402_fail
  rxsubrule2406_pass:
    set_addr $I10, rxsubrule2406_back
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10, $P10)
    rx2402_pos = $P10."pos"()
  alt2404_end:
  # rx pass
    rx2402_cur."!cursor_pass"(rx2402_pos, "circumfix:sym<sigil>")
    if_null rx2402_debug, debug_1406
    rx2402_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2402_pos)
  debug_1406:
    .return (rx2402_cur)
  rx2402_restart:
.annotate 'line', 422
    if_null rx2402_debug, debug_1407
    rx2402_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1407:
  rx2402_fail:
    (rx2402_rep, rx2402_pos, $I10, $P10) = rx2402_cur."!mark_fail"(0)
    lt rx2402_pos, -1, rx2402_done
    eq rx2402_pos, -1, rx2402_fail
    jump $I10
  rx2402_done:
    rx2402_cur."!cursor_fail"()
    if_null rx2402_debug, debug_1408
    rx2402_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1408:
    .return (rx2402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("298_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2408 = self."!PREFIX__!subrule"("sigil", "")
    new $P2409, "ResizablePMCArray"
    push $P2409, $P2408
    .return ($P2409)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("299_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2411_tgt
    .local int rx2411_pos
    .local int rx2411_off
    .local int rx2411_eos
    .local int rx2411_rep
    .local pmc rx2411_cur
    .local pmc rx2411_debug
    (rx2411_cur, rx2411_pos, rx2411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2411_cur
    .local pmc match
    .lex "$/", match
    length rx2411_eos, rx2411_tgt
    gt rx2411_pos, rx2411_eos, rx2411_done
    set rx2411_off, 0
    lt rx2411_pos, 2, rx2411_start
    sub rx2411_off, rx2411_pos, 1
    substr rx2411_tgt, rx2411_tgt, rx2411_off
  rx2411_start:
    eq $I10, 1, rx2411_restart
    if_null rx2411_debug, debug_1409
    rx2411_cur."!cursor_debug"("START", "semilist")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2412_done
    goto rxscan2412_scan
  rxscan2412_loop:
    (rx2411_pos) = rx2411_cur."from"()
    inc rx2411_pos
    rx2411_cur."!cursor_from"(rx2411_pos)
    ge rx2411_pos, rx2411_eos, rxscan2412_done
  rxscan2412_scan:
    set_addr $I10, rxscan2412_loop
    rx2411_cur."!mark_push"(0, rx2411_pos, $I10)
  rxscan2412_done:
.annotate 'line', 1013
  # rx subrule "ws" subtype=method negate=
    rx2411_cur."!cursor_pos"(rx2411_pos)
    $P10 = rx2411_cur."ws"()
    unless $P10, rx2411_fail
    rx2411_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2411_cur."!cursor_pos"(rx2411_pos)
    $P10 = rx2411_cur."statement"()
    unless $P10, rx2411_fail
    rx2411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2411_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2411_cur."!cursor_pos"(rx2411_pos)
    $P10 = rx2411_cur."ws"()
    unless $P10, rx2411_fail
    rx2411_pos = $P10."pos"()
  # rx pass
    rx2411_cur."!cursor_pass"(rx2411_pos, "semilist")
    if_null rx2411_debug, debug_1410
    rx2411_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2411_pos)
  debug_1410:
    .return (rx2411_cur)
  rx2411_restart:
.annotate 'line', 422
    if_null rx2411_debug, debug_1411
    rx2411_cur."!cursor_debug"("NEXT", "semilist")
  debug_1411:
  rx2411_fail:
    (rx2411_rep, rx2411_pos, $I10, $P10) = rx2411_cur."!mark_fail"(0)
    lt rx2411_pos, -1, rx2411_done
    eq rx2411_pos, -1, rx2411_fail
    jump $I10
  rx2411_done:
    rx2411_cur."!cursor_fail"()
    if_null rx2411_debug, debug_1412
    rx2411_cur."!cursor_debug"("FAIL", "semilist")
  debug_1412:
    .return (rx2411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("300_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2416 = self."!PREFIX__!subrule"("ws", "")
    new $P2417, "ResizablePMCArray"
    push $P2417, $P2416
    .return ($P2417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("301_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2419_tgt
    .local int rx2419_pos
    .local int rx2419_off
    .local int rx2419_eos
    .local int rx2419_rep
    .local pmc rx2419_cur
    .local pmc rx2419_debug
    (rx2419_cur, rx2419_pos, rx2419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2419_cur
    .local pmc match
    .lex "$/", match
    length rx2419_eos, rx2419_tgt
    gt rx2419_pos, rx2419_eos, rx2419_done
    set rx2419_off, 0
    lt rx2419_pos, 2, rx2419_start
    sub rx2419_off, rx2419_pos, 1
    substr rx2419_tgt, rx2419_tgt, rx2419_off
  rx2419_start:
    eq $I10, 1, rx2419_restart
    if_null rx2419_debug, debug_1413
    rx2419_cur."!cursor_debug"("START", "infixish")
  debug_1413:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2420_done
    goto rxscan2420_scan
  rxscan2420_loop:
    (rx2419_pos) = rx2419_cur."from"()
    inc rx2419_pos
    rx2419_cur."!cursor_from"(rx2419_pos)
    ge rx2419_pos, rx2419_eos, rxscan2420_done
  rxscan2420_scan:
    set_addr $I10, rxscan2420_loop
    rx2419_cur."!mark_push"(0, rx2419_pos, $I10)
  rxscan2420_done:
.annotate 'line', 1036
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2419_cur."!cursor_pos"(rx2419_pos)
    $P10 = rx2419_cur."infixstopper"()
    if $P10, rx2419_fail
  # rx subrule "infix" subtype=capture negate=
    rx2419_cur."!cursor_pos"(rx2419_pos)
    $P10 = rx2419_cur."infix"()
    unless $P10, rx2419_fail
    rx2419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2419_pos = $P10."pos"()
  # rx pass
    rx2419_cur."!cursor_pass"(rx2419_pos, "infixish")
    if_null rx2419_debug, debug_1414
    rx2419_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2419_pos)
  debug_1414:
    .return (rx2419_cur)
  rx2419_restart:
.annotate 'line', 422
    if_null rx2419_debug, debug_1415
    rx2419_cur."!cursor_debug"("NEXT", "infixish")
  debug_1415:
  rx2419_fail:
    (rx2419_rep, rx2419_pos, $I10, $P10) = rx2419_cur."!mark_fail"(0)
    lt rx2419_pos, -1, rx2419_done
    eq rx2419_pos, -1, rx2419_fail
    jump $I10
  rx2419_done:
    rx2419_cur."!cursor_fail"()
    if_null rx2419_debug, debug_1416
    rx2419_cur."!cursor_debug"("FAIL", "infixish")
  debug_1416:
    .return (rx2419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("302_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2422, "ResizablePMCArray"
    push $P2422, ""
    .return ($P2422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("303_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2424_tgt
    .local int rx2424_pos
    .local int rx2424_off
    .local int rx2424_eos
    .local int rx2424_rep
    .local pmc rx2424_cur
    .local pmc rx2424_debug
    (rx2424_cur, rx2424_pos, rx2424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2424_cur
    .local pmc match
    .lex "$/", match
    length rx2424_eos, rx2424_tgt
    gt rx2424_pos, rx2424_eos, rx2424_done
    set rx2424_off, 0
    lt rx2424_pos, 2, rx2424_start
    sub rx2424_off, rx2424_pos, 1
    substr rx2424_tgt, rx2424_tgt, rx2424_off
  rx2424_start:
    eq $I10, 1, rx2424_restart
    if_null rx2424_debug, debug_1417
    rx2424_cur."!cursor_debug"("START", "infixstopper")
  debug_1417:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2425_done
    goto rxscan2425_scan
  rxscan2425_loop:
    (rx2424_pos) = rx2424_cur."from"()
    inc rx2424_pos
    rx2424_cur."!cursor_from"(rx2424_pos)
    ge rx2424_pos, rx2424_eos, rxscan2425_done
  rxscan2425_scan:
    set_addr $I10, rxscan2425_loop
    rx2424_cur."!mark_push"(0, rx2424_pos, $I10)
  rxscan2425_done:
.annotate 'line', 1037
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2424_cur."!cursor_pos"(rx2424_pos)
    $P10 = rx2424_cur."lambda"()
    unless $P10, rx2424_fail
  # rx pass
    rx2424_cur."!cursor_pass"(rx2424_pos, "infixstopper")
    if_null rx2424_debug, debug_1418
    rx2424_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2424_pos)
  debug_1418:
    .return (rx2424_cur)
  rx2424_restart:
.annotate 'line', 422
    if_null rx2424_debug, debug_1419
    rx2424_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1419:
  rx2424_fail:
    (rx2424_rep, rx2424_pos, $I10, $P10) = rx2424_cur."!mark_fail"(0)
    lt rx2424_pos, -1, rx2424_done
    eq rx2424_pos, -1, rx2424_fail
    jump $I10
  rx2424_done:
    rx2424_cur."!cursor_fail"()
    if_null rx2424_debug, debug_1420
    rx2424_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1420:
    .return (rx2424_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("304_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2427, "ResizablePMCArray"
    push $P2427, ""
    .return ($P2427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("305_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2429_tgt
    .local int rx2429_pos
    .local int rx2429_off
    .local int rx2429_eos
    .local int rx2429_rep
    .local pmc rx2429_cur
    .local pmc rx2429_debug
    (rx2429_cur, rx2429_pos, rx2429_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2429_cur
    .local pmc match
    .lex "$/", match
    length rx2429_eos, rx2429_tgt
    gt rx2429_pos, rx2429_eos, rx2429_done
    set rx2429_off, 0
    lt rx2429_pos, 2, rx2429_start
    sub rx2429_off, rx2429_pos, 1
    substr rx2429_tgt, rx2429_tgt, rx2429_off
  rx2429_start:
    eq $I10, 1, rx2429_restart
    if_null rx2429_debug, debug_1421
    rx2429_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2430_done
    goto rxscan2430_scan
  rxscan2430_loop:
    (rx2429_pos) = rx2429_cur."from"()
    inc rx2429_pos
    rx2429_cur."!cursor_from"(rx2429_pos)
    ge rx2429_pos, rx2429_eos, rxscan2430_done
  rxscan2430_scan:
    set_addr $I10, rxscan2430_loop
    rx2429_cur."!mark_push"(0, rx2429_pos, $I10)
  rxscan2430_done:
.annotate 'line', 1040
  # rx literal  "["
    add $I11, rx2429_pos, 1
    gt $I11, rx2429_eos, rx2429_fail
    sub $I11, rx2429_pos, rx2429_off
    ord $I11, rx2429_tgt, $I11
    ne $I11, 91, rx2429_fail
    add rx2429_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2429_cur."!cursor_pos"(rx2429_pos)
    $P10 = rx2429_cur."ws"()
    unless $P10, rx2429_fail
    rx2429_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2429_cur."!cursor_pos"(rx2429_pos)
    $P10 = rx2429_cur."EXPR"()
    unless $P10, rx2429_fail
    rx2429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2429_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2429_pos, 1
    gt $I11, rx2429_eos, rx2429_fail
    sub $I11, rx2429_pos, rx2429_off
    ord $I11, rx2429_tgt, $I11
    ne $I11, 93, rx2429_fail
    add rx2429_pos, 1
.annotate 'line', 1041
  # rx subrule "O" subtype=capture negate=
    rx2429_cur."!cursor_pos"(rx2429_pos)
    $P10 = rx2429_cur."O"("%methodop")
    unless $P10, rx2429_fail
    rx2429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2429_pos = $P10."pos"()
.annotate 'line', 1039
  # rx pass
    rx2429_cur."!cursor_pass"(rx2429_pos, "postcircumfix:sym<[ ]>")
    if_null rx2429_debug, debug_1422
    rx2429_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2429_pos)
  debug_1422:
    .return (rx2429_cur)
  rx2429_restart:
.annotate 'line', 422
    if_null rx2429_debug, debug_1423
    rx2429_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1423:
  rx2429_fail:
    (rx2429_rep, rx2429_pos, $I10, $P10) = rx2429_cur."!mark_fail"(0)
    lt rx2429_pos, -1, rx2429_done
    eq rx2429_pos, -1, rx2429_fail
    jump $I10
  rx2429_done:
    rx2429_cur."!cursor_fail"()
    if_null rx2429_debug, debug_1424
    rx2429_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1424:
    .return (rx2429_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("306_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2432 = self."!PREFIX__!subrule"("ws", "[")
    new $P2433, "ResizablePMCArray"
    push $P2433, $P2432
    .return ($P2433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("307_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2435_tgt
    .local int rx2435_pos
    .local int rx2435_off
    .local int rx2435_eos
    .local int rx2435_rep
    .local pmc rx2435_cur
    .local pmc rx2435_debug
    (rx2435_cur, rx2435_pos, rx2435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2435_cur
    .local pmc match
    .lex "$/", match
    length rx2435_eos, rx2435_tgt
    gt rx2435_pos, rx2435_eos, rx2435_done
    set rx2435_off, 0
    lt rx2435_pos, 2, rx2435_start
    sub rx2435_off, rx2435_pos, 1
    substr rx2435_tgt, rx2435_tgt, rx2435_off
  rx2435_start:
    eq $I10, 1, rx2435_restart
    if_null rx2435_debug, debug_1425
    rx2435_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1425:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2436_done
    goto rxscan2436_scan
  rxscan2436_loop:
    (rx2435_pos) = rx2435_cur."from"()
    inc rx2435_pos
    rx2435_cur."!cursor_from"(rx2435_pos)
    ge rx2435_pos, rx2435_eos, rxscan2436_done
  rxscan2436_scan:
    set_addr $I10, rxscan2436_loop
    rx2435_cur."!mark_push"(0, rx2435_pos, $I10)
  rxscan2436_done:
.annotate 'line', 1045
  # rx literal  "{"
    add $I11, rx2435_pos, 1
    gt $I11, rx2435_eos, rx2435_fail
    sub $I11, rx2435_pos, rx2435_off
    ord $I11, rx2435_tgt, $I11
    ne $I11, 123, rx2435_fail
    add rx2435_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2435_cur."!cursor_pos"(rx2435_pos)
    $P10 = rx2435_cur."ws"()
    unless $P10, rx2435_fail
    rx2435_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2435_cur."!cursor_pos"(rx2435_pos)
    $P10 = rx2435_cur."EXPR"()
    unless $P10, rx2435_fail
    rx2435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2435_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2435_pos, 1
    gt $I11, rx2435_eos, rx2435_fail
    sub $I11, rx2435_pos, rx2435_off
    ord $I11, rx2435_tgt, $I11
    ne $I11, 125, rx2435_fail
    add rx2435_pos, 1
.annotate 'line', 1046
  # rx subrule "O" subtype=capture negate=
    rx2435_cur."!cursor_pos"(rx2435_pos)
    $P10 = rx2435_cur."O"("%methodop")
    unless $P10, rx2435_fail
    rx2435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2435_pos = $P10."pos"()
.annotate 'line', 1044
  # rx pass
    rx2435_cur."!cursor_pass"(rx2435_pos, "postcircumfix:sym<{ }>")
    if_null rx2435_debug, debug_1426
    rx2435_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2435_pos)
  debug_1426:
    .return (rx2435_cur)
  rx2435_restart:
.annotate 'line', 422
    if_null rx2435_debug, debug_1427
    rx2435_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1427:
  rx2435_fail:
    (rx2435_rep, rx2435_pos, $I10, $P10) = rx2435_cur."!mark_fail"(0)
    lt rx2435_pos, -1, rx2435_done
    eq rx2435_pos, -1, rx2435_fail
    jump $I10
  rx2435_done:
    rx2435_cur."!cursor_fail"()
    if_null rx2435_debug, debug_1428
    rx2435_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1428:
    .return (rx2435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("308_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2438 = self."!PREFIX__!subrule"("ws", "{")
    new $P2439, "ResizablePMCArray"
    push $P2439, $P2438
    .return ($P2439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("309_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2441_tgt
    .local int rx2441_pos
    .local int rx2441_off
    .local int rx2441_eos
    .local int rx2441_rep
    .local pmc rx2441_cur
    .local pmc rx2441_debug
    (rx2441_cur, rx2441_pos, rx2441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2441_cur
    .local pmc match
    .lex "$/", match
    length rx2441_eos, rx2441_tgt
    gt rx2441_pos, rx2441_eos, rx2441_done
    set rx2441_off, 0
    lt rx2441_pos, 2, rx2441_start
    sub rx2441_off, rx2441_pos, 1
    substr rx2441_tgt, rx2441_tgt, rx2441_off
  rx2441_start:
    eq $I10, 1, rx2441_restart
    if_null rx2441_debug, debug_1429
    rx2441_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1429:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2442_done
    goto rxscan2442_scan
  rxscan2442_loop:
    (rx2441_pos) = rx2441_cur."from"()
    inc rx2441_pos
    rx2441_cur."!cursor_from"(rx2441_pos)
    ge rx2441_pos, rx2441_eos, rxscan2442_done
  rxscan2442_scan:
    set_addr $I10, rxscan2442_loop
    rx2441_cur."!mark_push"(0, rx2441_pos, $I10)
  rxscan2442_done:
.annotate 'line', 1050
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2441_pos, rx2441_off
    substr $S10, rx2441_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2441_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2441_cur."!cursor_pos"(rx2441_pos)
    $P10 = rx2441_cur."quote_EXPR"(":q")
    unless $P10, rx2441_fail
    rx2441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2441_pos = $P10."pos"()
.annotate 'line', 1051
  # rx subrule "O" subtype=capture negate=
    rx2441_cur."!cursor_pos"(rx2441_pos)
    $P10 = rx2441_cur."O"("%methodop")
    unless $P10, rx2441_fail
    rx2441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2441_pos = $P10."pos"()
.annotate 'line', 1049
  # rx pass
    rx2441_cur."!cursor_pass"(rx2441_pos, "postcircumfix:sym<ang>")
    if_null rx2441_debug, debug_1430
    rx2441_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2441_pos)
  debug_1430:
    .return (rx2441_cur)
  rx2441_restart:
.annotate 'line', 422
    if_null rx2441_debug, debug_1431
    rx2441_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1431:
  rx2441_fail:
    (rx2441_rep, rx2441_pos, $I10, $P10) = rx2441_cur."!mark_fail"(0)
    lt rx2441_pos, -1, rx2441_done
    eq rx2441_pos, -1, rx2441_fail
    jump $I10
  rx2441_done:
    rx2441_cur."!cursor_fail"()
    if_null rx2441_debug, debug_1432
    rx2441_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1432:
    .return (rx2441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("310_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2444, "ResizablePMCArray"
    push $P2444, "<"
    .return ($P2444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("311_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2446_tgt
    .local int rx2446_pos
    .local int rx2446_off
    .local int rx2446_eos
    .local int rx2446_rep
    .local pmc rx2446_cur
    .local pmc rx2446_debug
    (rx2446_cur, rx2446_pos, rx2446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2446_cur
    .local pmc match
    .lex "$/", match
    length rx2446_eos, rx2446_tgt
    gt rx2446_pos, rx2446_eos, rx2446_done
    set rx2446_off, 0
    lt rx2446_pos, 2, rx2446_start
    sub rx2446_off, rx2446_pos, 1
    substr rx2446_tgt, rx2446_tgt, rx2446_off
  rx2446_start:
    eq $I10, 1, rx2446_restart
    if_null rx2446_debug, debug_1433
    rx2446_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2447_done
    goto rxscan2447_scan
  rxscan2447_loop:
    (rx2446_pos) = rx2446_cur."from"()
    inc rx2446_pos
    rx2446_cur."!cursor_from"(rx2446_pos)
    ge rx2446_pos, rx2446_eos, rxscan2447_done
  rxscan2447_scan:
    set_addr $I10, rxscan2447_loop
    rx2446_cur."!mark_push"(0, rx2446_pos, $I10)
  rxscan2447_done:
.annotate 'line', 1055
  # rx literal  "("
    add $I11, rx2446_pos, 1
    gt $I11, rx2446_eos, rx2446_fail
    sub $I11, rx2446_pos, rx2446_off
    ord $I11, rx2446_tgt, $I11
    ne $I11, 40, rx2446_fail
    add rx2446_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2446_cur."!cursor_pos"(rx2446_pos)
    $P10 = rx2446_cur."ws"()
    unless $P10, rx2446_fail
    rx2446_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2446_cur."!cursor_pos"(rx2446_pos)
    $P10 = rx2446_cur."arglist"()
    unless $P10, rx2446_fail
    rx2446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2446_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2446_pos, 1
    gt $I11, rx2446_eos, rx2446_fail
    sub $I11, rx2446_pos, rx2446_off
    ord $I11, rx2446_tgt, $I11
    ne $I11, 41, rx2446_fail
    add rx2446_pos, 1
.annotate 'line', 1056
  # rx subrule "O" subtype=capture negate=
    rx2446_cur."!cursor_pos"(rx2446_pos)
    $P10 = rx2446_cur."O"("%methodop")
    unless $P10, rx2446_fail
    rx2446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2446_pos = $P10."pos"()
.annotate 'line', 1054
  # rx pass
    rx2446_cur."!cursor_pass"(rx2446_pos, "postcircumfix:sym<( )>")
    if_null rx2446_debug, debug_1434
    rx2446_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2446_pos)
  debug_1434:
    .return (rx2446_cur)
  rx2446_restart:
.annotate 'line', 422
    if_null rx2446_debug, debug_1435
    rx2446_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1435:
  rx2446_fail:
    (rx2446_rep, rx2446_pos, $I10, $P10) = rx2446_cur."!mark_fail"(0)
    lt rx2446_pos, -1, rx2446_done
    eq rx2446_pos, -1, rx2446_fail
    jump $I10
  rx2446_done:
    rx2446_cur."!cursor_fail"()
    if_null rx2446_debug, debug_1436
    rx2446_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1436:
    .return (rx2446_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("312_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2449 = self."!PREFIX__!subrule"("ws", "(")
    new $P2450, "ResizablePMCArray"
    push $P2450, $P2449
    .return ($P2450)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("313_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2452_tgt
    .local int rx2452_pos
    .local int rx2452_off
    .local int rx2452_eos
    .local int rx2452_rep
    .local pmc rx2452_cur
    .local pmc rx2452_debug
    (rx2452_cur, rx2452_pos, rx2452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2452_cur
    .local pmc match
    .lex "$/", match
    length rx2452_eos, rx2452_tgt
    gt rx2452_pos, rx2452_eos, rx2452_done
    set rx2452_off, 0
    lt rx2452_pos, 2, rx2452_start
    sub rx2452_off, rx2452_pos, 1
    substr rx2452_tgt, rx2452_tgt, rx2452_off
  rx2452_start:
    eq $I10, 1, rx2452_restart
    if_null rx2452_debug, debug_1437
    rx2452_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2453_done
    goto rxscan2453_scan
  rxscan2453_loop:
    (rx2452_pos) = rx2452_cur."from"()
    inc rx2452_pos
    rx2452_cur."!cursor_from"(rx2452_pos)
    ge rx2452_pos, rx2452_eos, rxscan2453_done
  rxscan2453_scan:
    set_addr $I10, rxscan2453_loop
    rx2452_cur."!mark_push"(0, rx2452_pos, $I10)
  rxscan2453_done:
.annotate 'line', 1059
  # rx subrule "dotty" subtype=capture negate=
    rx2452_cur."!cursor_pos"(rx2452_pos)
    $P10 = rx2452_cur."dotty"()
    unless $P10, rx2452_fail
    rx2452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2452_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2452_cur."!cursor_pos"(rx2452_pos)
    $P10 = rx2452_cur."O"("%methodop")
    unless $P10, rx2452_fail
    rx2452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2452_pos = $P10."pos"()
  # rx pass
    rx2452_cur."!cursor_pass"(rx2452_pos, "postfix:sym<.>")
    if_null rx2452_debug, debug_1438
    rx2452_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2452_pos)
  debug_1438:
    .return (rx2452_cur)
  rx2452_restart:
.annotate 'line', 422
    if_null rx2452_debug, debug_1439
    rx2452_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1439:
  rx2452_fail:
    (rx2452_rep, rx2452_pos, $I10, $P10) = rx2452_cur."!mark_fail"(0)
    lt rx2452_pos, -1, rx2452_done
    eq rx2452_pos, -1, rx2452_fail
    jump $I10
  rx2452_done:
    rx2452_cur."!cursor_fail"()
    if_null rx2452_debug, debug_1440
    rx2452_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1440:
    .return (rx2452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("314_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2455 = self."!PREFIX__!subrule"("dotty", "")
    new $P2456, "ResizablePMCArray"
    push $P2456, $P2455
    .return ($P2456)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("315_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2458_tgt
    .local int rx2458_pos
    .local int rx2458_off
    .local int rx2458_eos
    .local int rx2458_rep
    .local pmc rx2458_cur
    .local pmc rx2458_debug
    (rx2458_cur, rx2458_pos, rx2458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2458_cur
    .local pmc match
    .lex "$/", match
    length rx2458_eos, rx2458_tgt
    gt rx2458_pos, rx2458_eos, rx2458_done
    set rx2458_off, 0
    lt rx2458_pos, 2, rx2458_start
    sub rx2458_off, rx2458_pos, 1
    substr rx2458_tgt, rx2458_tgt, rx2458_off
  rx2458_start:
    eq $I10, 1, rx2458_restart
    if_null rx2458_debug, debug_1441
    rx2458_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2459_done
    goto rxscan2459_scan
  rxscan2459_loop:
    (rx2458_pos) = rx2458_cur."from"()
    inc rx2458_pos
    rx2458_cur."!cursor_from"(rx2458_pos)
    ge rx2458_pos, rx2458_eos, rxscan2459_done
  rxscan2459_scan:
    set_addr $I10, rxscan2459_loop
    rx2458_cur."!mark_push"(0, rx2458_pos, $I10)
  rxscan2459_done:
.annotate 'line', 1061
  # rx subcapture "sym"
    set_addr $I10, rxcap_2460_fail
    rx2458_cur."!mark_push"(0, rx2458_pos, $I10)
  # rx literal  "++"
    add $I11, rx2458_pos, 2
    gt $I11, rx2458_eos, rx2458_fail
    sub $I11, rx2458_pos, rx2458_off
    substr $S10, rx2458_tgt, $I11, 2
    ne $S10, "++", rx2458_fail
    add rx2458_pos, 2
    set_addr $I10, rxcap_2460_fail
    ($I12, $I11) = rx2458_cur."!mark_peek"($I10)
    rx2458_cur."!cursor_pos"($I11)
    ($P10) = rx2458_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2458_pos, "")
    rx2458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2460_done
  rxcap_2460_fail:
    goto rx2458_fail
  rxcap_2460_done:
  # rx subrule "O" subtype=capture negate=
    rx2458_cur."!cursor_pos"(rx2458_pos)
    $P10 = rx2458_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2458_fail
    rx2458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2458_pos = $P10."pos"()
  # rx pass
    rx2458_cur."!cursor_pass"(rx2458_pos, "prefix:sym<++>")
    if_null rx2458_debug, debug_1442
    rx2458_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2458_pos)
  debug_1442:
    .return (rx2458_cur)
  rx2458_restart:
.annotate 'line', 422
    if_null rx2458_debug, debug_1443
    rx2458_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1443:
  rx2458_fail:
    (rx2458_rep, rx2458_pos, $I10, $P10) = rx2458_cur."!mark_fail"(0)
    lt rx2458_pos, -1, rx2458_done
    eq rx2458_pos, -1, rx2458_fail
    jump $I10
  rx2458_done:
    rx2458_cur."!cursor_fail"()
    if_null rx2458_debug, debug_1444
    rx2458_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1444:
    .return (rx2458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("316_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2462 = self."!PREFIX__!subrule"("O", "++")
    new $P2463, "ResizablePMCArray"
    push $P2463, $P2462
    .return ($P2463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("317_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2465_tgt
    .local int rx2465_pos
    .local int rx2465_off
    .local int rx2465_eos
    .local int rx2465_rep
    .local pmc rx2465_cur
    .local pmc rx2465_debug
    (rx2465_cur, rx2465_pos, rx2465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2465_cur
    .local pmc match
    .lex "$/", match
    length rx2465_eos, rx2465_tgt
    gt rx2465_pos, rx2465_eos, rx2465_done
    set rx2465_off, 0
    lt rx2465_pos, 2, rx2465_start
    sub rx2465_off, rx2465_pos, 1
    substr rx2465_tgt, rx2465_tgt, rx2465_off
  rx2465_start:
    eq $I10, 1, rx2465_restart
    if_null rx2465_debug, debug_1445
    rx2465_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2466_done
    goto rxscan2466_scan
  rxscan2466_loop:
    (rx2465_pos) = rx2465_cur."from"()
    inc rx2465_pos
    rx2465_cur."!cursor_from"(rx2465_pos)
    ge rx2465_pos, rx2465_eos, rxscan2466_done
  rxscan2466_scan:
    set_addr $I10, rxscan2466_loop
    rx2465_cur."!mark_push"(0, rx2465_pos, $I10)
  rxscan2466_done:
.annotate 'line', 1062
  # rx subcapture "sym"
    set_addr $I10, rxcap_2467_fail
    rx2465_cur."!mark_push"(0, rx2465_pos, $I10)
  # rx literal  "--"
    add $I11, rx2465_pos, 2
    gt $I11, rx2465_eos, rx2465_fail
    sub $I11, rx2465_pos, rx2465_off
    substr $S10, rx2465_tgt, $I11, 2
    ne $S10, "--", rx2465_fail
    add rx2465_pos, 2
    set_addr $I10, rxcap_2467_fail
    ($I12, $I11) = rx2465_cur."!mark_peek"($I10)
    rx2465_cur."!cursor_pos"($I11)
    ($P10) = rx2465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2465_pos, "")
    rx2465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2467_done
  rxcap_2467_fail:
    goto rx2465_fail
  rxcap_2467_done:
  # rx subrule "O" subtype=capture negate=
    rx2465_cur."!cursor_pos"(rx2465_pos)
    $P10 = rx2465_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2465_fail
    rx2465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2465_pos = $P10."pos"()
  # rx pass
    rx2465_cur."!cursor_pass"(rx2465_pos, "prefix:sym<-->")
    if_null rx2465_debug, debug_1446
    rx2465_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2465_pos)
  debug_1446:
    .return (rx2465_cur)
  rx2465_restart:
.annotate 'line', 422
    if_null rx2465_debug, debug_1447
    rx2465_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1447:
  rx2465_fail:
    (rx2465_rep, rx2465_pos, $I10, $P10) = rx2465_cur."!mark_fail"(0)
    lt rx2465_pos, -1, rx2465_done
    eq rx2465_pos, -1, rx2465_fail
    jump $I10
  rx2465_done:
    rx2465_cur."!cursor_fail"()
    if_null rx2465_debug, debug_1448
    rx2465_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1448:
    .return (rx2465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("318_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2469 = self."!PREFIX__!subrule"("O", "--")
    new $P2470, "ResizablePMCArray"
    push $P2470, $P2469
    .return ($P2470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("319_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2472_tgt
    .local int rx2472_pos
    .local int rx2472_off
    .local int rx2472_eos
    .local int rx2472_rep
    .local pmc rx2472_cur
    .local pmc rx2472_debug
    (rx2472_cur, rx2472_pos, rx2472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2472_cur
    .local pmc match
    .lex "$/", match
    length rx2472_eos, rx2472_tgt
    gt rx2472_pos, rx2472_eos, rx2472_done
    set rx2472_off, 0
    lt rx2472_pos, 2, rx2472_start
    sub rx2472_off, rx2472_pos, 1
    substr rx2472_tgt, rx2472_tgt, rx2472_off
  rx2472_start:
    eq $I10, 1, rx2472_restart
    if_null rx2472_debug, debug_1449
    rx2472_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1449:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2473_done
    goto rxscan2473_scan
  rxscan2473_loop:
    (rx2472_pos) = rx2472_cur."from"()
    inc rx2472_pos
    rx2472_cur."!cursor_from"(rx2472_pos)
    ge rx2472_pos, rx2472_eos, rxscan2473_done
  rxscan2473_scan:
    set_addr $I10, rxscan2473_loop
    rx2472_cur."!mark_push"(0, rx2472_pos, $I10)
  rxscan2473_done:
.annotate 'line', 1065
  # rx subcapture "sym"
    set_addr $I10, rxcap_2474_fail
    rx2472_cur."!mark_push"(0, rx2472_pos, $I10)
  # rx literal  "++"
    add $I11, rx2472_pos, 2
    gt $I11, rx2472_eos, rx2472_fail
    sub $I11, rx2472_pos, rx2472_off
    substr $S10, rx2472_tgt, $I11, 2
    ne $S10, "++", rx2472_fail
    add rx2472_pos, 2
    set_addr $I10, rxcap_2474_fail
    ($I12, $I11) = rx2472_cur."!mark_peek"($I10)
    rx2472_cur."!cursor_pos"($I11)
    ($P10) = rx2472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2472_pos, "")
    rx2472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2474_done
  rxcap_2474_fail:
    goto rx2472_fail
  rxcap_2474_done:
  # rx subrule "O" subtype=capture negate=
    rx2472_cur."!cursor_pos"(rx2472_pos)
    $P10 = rx2472_cur."O"("%autoincrement")
    unless $P10, rx2472_fail
    rx2472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2472_pos = $P10."pos"()
  # rx pass
    rx2472_cur."!cursor_pass"(rx2472_pos, "postfix:sym<++>")
    if_null rx2472_debug, debug_1450
    rx2472_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2472_pos)
  debug_1450:
    .return (rx2472_cur)
  rx2472_restart:
.annotate 'line', 422
    if_null rx2472_debug, debug_1451
    rx2472_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1451:
  rx2472_fail:
    (rx2472_rep, rx2472_pos, $I10, $P10) = rx2472_cur."!mark_fail"(0)
    lt rx2472_pos, -1, rx2472_done
    eq rx2472_pos, -1, rx2472_fail
    jump $I10
  rx2472_done:
    rx2472_cur."!cursor_fail"()
    if_null rx2472_debug, debug_1452
    rx2472_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1452:
    .return (rx2472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("320_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2476 = self."!PREFIX__!subrule"("O", "++")
    new $P2477, "ResizablePMCArray"
    push $P2477, $P2476
    .return ($P2477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("321_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2479_tgt
    .local int rx2479_pos
    .local int rx2479_off
    .local int rx2479_eos
    .local int rx2479_rep
    .local pmc rx2479_cur
    .local pmc rx2479_debug
    (rx2479_cur, rx2479_pos, rx2479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2479_cur
    .local pmc match
    .lex "$/", match
    length rx2479_eos, rx2479_tgt
    gt rx2479_pos, rx2479_eos, rx2479_done
    set rx2479_off, 0
    lt rx2479_pos, 2, rx2479_start
    sub rx2479_off, rx2479_pos, 1
    substr rx2479_tgt, rx2479_tgt, rx2479_off
  rx2479_start:
    eq $I10, 1, rx2479_restart
    if_null rx2479_debug, debug_1453
    rx2479_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2480_done
    goto rxscan2480_scan
  rxscan2480_loop:
    (rx2479_pos) = rx2479_cur."from"()
    inc rx2479_pos
    rx2479_cur."!cursor_from"(rx2479_pos)
    ge rx2479_pos, rx2479_eos, rxscan2480_done
  rxscan2480_scan:
    set_addr $I10, rxscan2480_loop
    rx2479_cur."!mark_push"(0, rx2479_pos, $I10)
  rxscan2480_done:
.annotate 'line', 1066
  # rx subcapture "sym"
    set_addr $I10, rxcap_2481_fail
    rx2479_cur."!mark_push"(0, rx2479_pos, $I10)
  # rx literal  "--"
    add $I11, rx2479_pos, 2
    gt $I11, rx2479_eos, rx2479_fail
    sub $I11, rx2479_pos, rx2479_off
    substr $S10, rx2479_tgt, $I11, 2
    ne $S10, "--", rx2479_fail
    add rx2479_pos, 2
    set_addr $I10, rxcap_2481_fail
    ($I12, $I11) = rx2479_cur."!mark_peek"($I10)
    rx2479_cur."!cursor_pos"($I11)
    ($P10) = rx2479_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2479_pos, "")
    rx2479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2481_done
  rxcap_2481_fail:
    goto rx2479_fail
  rxcap_2481_done:
  # rx subrule "O" subtype=capture negate=
    rx2479_cur."!cursor_pos"(rx2479_pos)
    $P10 = rx2479_cur."O"("%autoincrement")
    unless $P10, rx2479_fail
    rx2479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2479_pos = $P10."pos"()
  # rx pass
    rx2479_cur."!cursor_pass"(rx2479_pos, "postfix:sym<-->")
    if_null rx2479_debug, debug_1454
    rx2479_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2479_pos)
  debug_1454:
    .return (rx2479_cur)
  rx2479_restart:
.annotate 'line', 422
    if_null rx2479_debug, debug_1455
    rx2479_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1455:
  rx2479_fail:
    (rx2479_rep, rx2479_pos, $I10, $P10) = rx2479_cur."!mark_fail"(0)
    lt rx2479_pos, -1, rx2479_done
    eq rx2479_pos, -1, rx2479_fail
    jump $I10
  rx2479_done:
    rx2479_cur."!cursor_fail"()
    if_null rx2479_debug, debug_1456
    rx2479_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1456:
    .return (rx2479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("322_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2483 = self."!PREFIX__!subrule"("O", "--")
    new $P2484, "ResizablePMCArray"
    push $P2484, $P2483
    .return ($P2484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("323_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2486_tgt
    .local int rx2486_pos
    .local int rx2486_off
    .local int rx2486_eos
    .local int rx2486_rep
    .local pmc rx2486_cur
    .local pmc rx2486_debug
    (rx2486_cur, rx2486_pos, rx2486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2486_cur
    .local pmc match
    .lex "$/", match
    length rx2486_eos, rx2486_tgt
    gt rx2486_pos, rx2486_eos, rx2486_done
    set rx2486_off, 0
    lt rx2486_pos, 2, rx2486_start
    sub rx2486_off, rx2486_pos, 1
    substr rx2486_tgt, rx2486_tgt, rx2486_off
  rx2486_start:
    eq $I10, 1, rx2486_restart
    if_null rx2486_debug, debug_1457
    rx2486_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2487_done
    goto rxscan2487_scan
  rxscan2487_loop:
    (rx2486_pos) = rx2486_cur."from"()
    inc rx2486_pos
    rx2486_cur."!cursor_from"(rx2486_pos)
    ge rx2486_pos, rx2486_eos, rxscan2487_done
  rxscan2487_scan:
    set_addr $I10, rxscan2487_loop
    rx2486_cur."!mark_push"(0, rx2486_pos, $I10)
  rxscan2487_done:
.annotate 'line', 1068
  # rx subcapture "sym"
    set_addr $I10, rxcap_2488_fail
    rx2486_cur."!mark_push"(0, rx2486_pos, $I10)
  # rx literal  "**"
    add $I11, rx2486_pos, 2
    gt $I11, rx2486_eos, rx2486_fail
    sub $I11, rx2486_pos, rx2486_off
    substr $S10, rx2486_tgt, $I11, 2
    ne $S10, "**", rx2486_fail
    add rx2486_pos, 2
    set_addr $I10, rxcap_2488_fail
    ($I12, $I11) = rx2486_cur."!mark_peek"($I10)
    rx2486_cur."!cursor_pos"($I11)
    ($P10) = rx2486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2486_pos, "")
    rx2486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2488_done
  rxcap_2488_fail:
    goto rx2486_fail
  rxcap_2488_done:
  # rx subrule "O" subtype=capture negate=
    rx2486_cur."!cursor_pos"(rx2486_pos)
    $P10 = rx2486_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx2486_fail
    rx2486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2486_pos = $P10."pos"()
  # rx pass
    rx2486_cur."!cursor_pass"(rx2486_pos, "infix:sym<**>")
    if_null rx2486_debug, debug_1458
    rx2486_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2486_pos)
  debug_1458:
    .return (rx2486_cur)
  rx2486_restart:
.annotate 'line', 422
    if_null rx2486_debug, debug_1459
    rx2486_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1459:
  rx2486_fail:
    (rx2486_rep, rx2486_pos, $I10, $P10) = rx2486_cur."!mark_fail"(0)
    lt rx2486_pos, -1, rx2486_done
    eq rx2486_pos, -1, rx2486_fail
    jump $I10
  rx2486_done:
    rx2486_cur."!cursor_fail"()
    if_null rx2486_debug, debug_1460
    rx2486_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1460:
    .return (rx2486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("324_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2490 = self."!PREFIX__!subrule"("O", "**")
    new $P2491, "ResizablePMCArray"
    push $P2491, $P2490
    .return ($P2491)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("325_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2493_tgt
    .local int rx2493_pos
    .local int rx2493_off
    .local int rx2493_eos
    .local int rx2493_rep
    .local pmc rx2493_cur
    .local pmc rx2493_debug
    (rx2493_cur, rx2493_pos, rx2493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2493_cur
    .local pmc match
    .lex "$/", match
    length rx2493_eos, rx2493_tgt
    gt rx2493_pos, rx2493_eos, rx2493_done
    set rx2493_off, 0
    lt rx2493_pos, 2, rx2493_start
    sub rx2493_off, rx2493_pos, 1
    substr rx2493_tgt, rx2493_tgt, rx2493_off
  rx2493_start:
    eq $I10, 1, rx2493_restart
    if_null rx2493_debug, debug_1461
    rx2493_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1461:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2494_done
    goto rxscan2494_scan
  rxscan2494_loop:
    (rx2493_pos) = rx2493_cur."from"()
    inc rx2493_pos
    rx2493_cur."!cursor_from"(rx2493_pos)
    ge rx2493_pos, rx2493_eos, rxscan2494_done
  rxscan2494_scan:
    set_addr $I10, rxscan2494_loop
    rx2493_cur."!mark_push"(0, rx2493_pos, $I10)
  rxscan2494_done:
.annotate 'line', 1070
  # rx subcapture "sym"
    set_addr $I10, rxcap_2495_fail
    rx2493_cur."!mark_push"(0, rx2493_pos, $I10)
  # rx literal  "+"
    add $I11, rx2493_pos, 1
    gt $I11, rx2493_eos, rx2493_fail
    sub $I11, rx2493_pos, rx2493_off
    ord $I11, rx2493_tgt, $I11
    ne $I11, 43, rx2493_fail
    add rx2493_pos, 1
    set_addr $I10, rxcap_2495_fail
    ($I12, $I11) = rx2493_cur."!mark_peek"($I10)
    rx2493_cur."!cursor_pos"($I11)
    ($P10) = rx2493_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2493_pos, "")
    rx2493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2495_done
  rxcap_2495_fail:
    goto rx2493_fail
  rxcap_2495_done:
  # rx subrule "O" subtype=capture negate=
    rx2493_cur."!cursor_pos"(rx2493_pos)
    $P10 = rx2493_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2493_fail
    rx2493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2493_pos = $P10."pos"()
  # rx pass
    rx2493_cur."!cursor_pass"(rx2493_pos, "prefix:sym<+>")
    if_null rx2493_debug, debug_1462
    rx2493_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2493_pos)
  debug_1462:
    .return (rx2493_cur)
  rx2493_restart:
.annotate 'line', 422
    if_null rx2493_debug, debug_1463
    rx2493_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1463:
  rx2493_fail:
    (rx2493_rep, rx2493_pos, $I10, $P10) = rx2493_cur."!mark_fail"(0)
    lt rx2493_pos, -1, rx2493_done
    eq rx2493_pos, -1, rx2493_fail
    jump $I10
  rx2493_done:
    rx2493_cur."!cursor_fail"()
    if_null rx2493_debug, debug_1464
    rx2493_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1464:
    .return (rx2493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("326_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2497 = self."!PREFIX__!subrule"("O", "+")
    new $P2498, "ResizablePMCArray"
    push $P2498, $P2497
    .return ($P2498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("327_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2500_tgt
    .local int rx2500_pos
    .local int rx2500_off
    .local int rx2500_eos
    .local int rx2500_rep
    .local pmc rx2500_cur
    .local pmc rx2500_debug
    (rx2500_cur, rx2500_pos, rx2500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2500_cur
    .local pmc match
    .lex "$/", match
    length rx2500_eos, rx2500_tgt
    gt rx2500_pos, rx2500_eos, rx2500_done
    set rx2500_off, 0
    lt rx2500_pos, 2, rx2500_start
    sub rx2500_off, rx2500_pos, 1
    substr rx2500_tgt, rx2500_tgt, rx2500_off
  rx2500_start:
    eq $I10, 1, rx2500_restart
    if_null rx2500_debug, debug_1465
    rx2500_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1465:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2501_done
    goto rxscan2501_scan
  rxscan2501_loop:
    (rx2500_pos) = rx2500_cur."from"()
    inc rx2500_pos
    rx2500_cur."!cursor_from"(rx2500_pos)
    ge rx2500_pos, rx2500_eos, rxscan2501_done
  rxscan2501_scan:
    set_addr $I10, rxscan2501_loop
    rx2500_cur."!mark_push"(0, rx2500_pos, $I10)
  rxscan2501_done:
.annotate 'line', 1071
  # rx subcapture "sym"
    set_addr $I10, rxcap_2502_fail
    rx2500_cur."!mark_push"(0, rx2500_pos, $I10)
  # rx literal  "~"
    add $I11, rx2500_pos, 1
    gt $I11, rx2500_eos, rx2500_fail
    sub $I11, rx2500_pos, rx2500_off
    ord $I11, rx2500_tgt, $I11
    ne $I11, 126, rx2500_fail
    add rx2500_pos, 1
    set_addr $I10, rxcap_2502_fail
    ($I12, $I11) = rx2500_cur."!mark_peek"($I10)
    rx2500_cur."!cursor_pos"($I11)
    ($P10) = rx2500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2500_pos, "")
    rx2500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2502_done
  rxcap_2502_fail:
    goto rx2500_fail
  rxcap_2502_done:
  # rx subrule "O" subtype=capture negate=
    rx2500_cur."!cursor_pos"(rx2500_pos)
    $P10 = rx2500_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2500_fail
    rx2500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2500_pos = $P10."pos"()
  # rx pass
    rx2500_cur."!cursor_pass"(rx2500_pos, "prefix:sym<~>")
    if_null rx2500_debug, debug_1466
    rx2500_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2500_pos)
  debug_1466:
    .return (rx2500_cur)
  rx2500_restart:
.annotate 'line', 422
    if_null rx2500_debug, debug_1467
    rx2500_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1467:
  rx2500_fail:
    (rx2500_rep, rx2500_pos, $I10, $P10) = rx2500_cur."!mark_fail"(0)
    lt rx2500_pos, -1, rx2500_done
    eq rx2500_pos, -1, rx2500_fail
    jump $I10
  rx2500_done:
    rx2500_cur."!cursor_fail"()
    if_null rx2500_debug, debug_1468
    rx2500_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1468:
    .return (rx2500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("328_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2504 = self."!PREFIX__!subrule"("O", "~")
    new $P2505, "ResizablePMCArray"
    push $P2505, $P2504
    .return ($P2505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("329_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2507_tgt
    .local int rx2507_pos
    .local int rx2507_off
    .local int rx2507_eos
    .local int rx2507_rep
    .local pmc rx2507_cur
    .local pmc rx2507_debug
    (rx2507_cur, rx2507_pos, rx2507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2507_cur
    .local pmc match
    .lex "$/", match
    length rx2507_eos, rx2507_tgt
    gt rx2507_pos, rx2507_eos, rx2507_done
    set rx2507_off, 0
    lt rx2507_pos, 2, rx2507_start
    sub rx2507_off, rx2507_pos, 1
    substr rx2507_tgt, rx2507_tgt, rx2507_off
  rx2507_start:
    eq $I10, 1, rx2507_restart
    if_null rx2507_debug, debug_1469
    rx2507_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1469:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2508_done
    goto rxscan2508_scan
  rxscan2508_loop:
    (rx2507_pos) = rx2507_cur."from"()
    inc rx2507_pos
    rx2507_cur."!cursor_from"(rx2507_pos)
    ge rx2507_pos, rx2507_eos, rxscan2508_done
  rxscan2508_scan:
    set_addr $I10, rxscan2508_loop
    rx2507_cur."!mark_push"(0, rx2507_pos, $I10)
  rxscan2508_done:
.annotate 'line', 1072
  # rx subcapture "sym"
    set_addr $I10, rxcap_2509_fail
    rx2507_cur."!mark_push"(0, rx2507_pos, $I10)
  # rx literal  "-"
    add $I11, rx2507_pos, 1
    gt $I11, rx2507_eos, rx2507_fail
    sub $I11, rx2507_pos, rx2507_off
    ord $I11, rx2507_tgt, $I11
    ne $I11, 45, rx2507_fail
    add rx2507_pos, 1
    set_addr $I10, rxcap_2509_fail
    ($I12, $I11) = rx2507_cur."!mark_peek"($I10)
    rx2507_cur."!cursor_pos"($I11)
    ($P10) = rx2507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2507_pos, "")
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2509_done
  rxcap_2509_fail:
    goto rx2507_fail
  rxcap_2509_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2507_pos, rx2507_off
    substr $S10, rx2507_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2507_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."number"()
    if $P10, rx2507_fail
  # rx subrule "O" subtype=capture negate=
    rx2507_cur."!cursor_pos"(rx2507_pos)
    $P10 = rx2507_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2507_fail
    rx2507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2507_pos = $P10."pos"()
  # rx pass
    rx2507_cur."!cursor_pass"(rx2507_pos, "prefix:sym<->")
    if_null rx2507_debug, debug_1470
    rx2507_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2507_pos)
  debug_1470:
    .return (rx2507_cur)
  rx2507_restart:
.annotate 'line', 422
    if_null rx2507_debug, debug_1471
    rx2507_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1471:
  rx2507_fail:
    (rx2507_rep, rx2507_pos, $I10, $P10) = rx2507_cur."!mark_fail"(0)
    lt rx2507_pos, -1, rx2507_done
    eq rx2507_pos, -1, rx2507_fail
    jump $I10
  rx2507_done:
    rx2507_cur."!cursor_fail"()
    if_null rx2507_debug, debug_1472
    rx2507_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1472:
    .return (rx2507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("330_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2511, "ResizablePMCArray"
    push $P2511, "-"
    .return ($P2511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("331_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2513_tgt
    .local int rx2513_pos
    .local int rx2513_off
    .local int rx2513_eos
    .local int rx2513_rep
    .local pmc rx2513_cur
    .local pmc rx2513_debug
    (rx2513_cur, rx2513_pos, rx2513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2513_cur
    .local pmc match
    .lex "$/", match
    length rx2513_eos, rx2513_tgt
    gt rx2513_pos, rx2513_eos, rx2513_done
    set rx2513_off, 0
    lt rx2513_pos, 2, rx2513_start
    sub rx2513_off, rx2513_pos, 1
    substr rx2513_tgt, rx2513_tgt, rx2513_off
  rx2513_start:
    eq $I10, 1, rx2513_restart
    if_null rx2513_debug, debug_1473
    rx2513_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1473:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2514_done
    goto rxscan2514_scan
  rxscan2514_loop:
    (rx2513_pos) = rx2513_cur."from"()
    inc rx2513_pos
    rx2513_cur."!cursor_from"(rx2513_pos)
    ge rx2513_pos, rx2513_eos, rxscan2514_done
  rxscan2514_scan:
    set_addr $I10, rxscan2514_loop
    rx2513_cur."!mark_push"(0, rx2513_pos, $I10)
  rxscan2514_done:
.annotate 'line', 1073
  # rx subcapture "sym"
    set_addr $I10, rxcap_2515_fail
    rx2513_cur."!mark_push"(0, rx2513_pos, $I10)
  # rx literal  "?"
    add $I11, rx2513_pos, 1
    gt $I11, rx2513_eos, rx2513_fail
    sub $I11, rx2513_pos, rx2513_off
    ord $I11, rx2513_tgt, $I11
    ne $I11, 63, rx2513_fail
    add rx2513_pos, 1
    set_addr $I10, rxcap_2515_fail
    ($I12, $I11) = rx2513_cur."!mark_peek"($I10)
    rx2513_cur."!cursor_pos"($I11)
    ($P10) = rx2513_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2513_pos, "")
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2515_done
  rxcap_2515_fail:
    goto rx2513_fail
  rxcap_2515_done:
  # rx subrule "O" subtype=capture negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2513_fail
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2513_pos = $P10."pos"()
  # rx pass
    rx2513_cur."!cursor_pass"(rx2513_pos, "prefix:sym<?>")
    if_null rx2513_debug, debug_1474
    rx2513_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2513_pos)
  debug_1474:
    .return (rx2513_cur)
  rx2513_restart:
.annotate 'line', 422
    if_null rx2513_debug, debug_1475
    rx2513_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1475:
  rx2513_fail:
    (rx2513_rep, rx2513_pos, $I10, $P10) = rx2513_cur."!mark_fail"(0)
    lt rx2513_pos, -1, rx2513_done
    eq rx2513_pos, -1, rx2513_fail
    jump $I10
  rx2513_done:
    rx2513_cur."!cursor_fail"()
    if_null rx2513_debug, debug_1476
    rx2513_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1476:
    .return (rx2513_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("332_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2517 = self."!PREFIX__!subrule"("O", "?")
    new $P2518, "ResizablePMCArray"
    push $P2518, $P2517
    .return ($P2518)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("333_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2520_tgt
    .local int rx2520_pos
    .local int rx2520_off
    .local int rx2520_eos
    .local int rx2520_rep
    .local pmc rx2520_cur
    .local pmc rx2520_debug
    (rx2520_cur, rx2520_pos, rx2520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2520_cur
    .local pmc match
    .lex "$/", match
    length rx2520_eos, rx2520_tgt
    gt rx2520_pos, rx2520_eos, rx2520_done
    set rx2520_off, 0
    lt rx2520_pos, 2, rx2520_start
    sub rx2520_off, rx2520_pos, 1
    substr rx2520_tgt, rx2520_tgt, rx2520_off
  rx2520_start:
    eq $I10, 1, rx2520_restart
    if_null rx2520_debug, debug_1477
    rx2520_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1477:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2521_done
    goto rxscan2521_scan
  rxscan2521_loop:
    (rx2520_pos) = rx2520_cur."from"()
    inc rx2520_pos
    rx2520_cur."!cursor_from"(rx2520_pos)
    ge rx2520_pos, rx2520_eos, rxscan2521_done
  rxscan2521_scan:
    set_addr $I10, rxscan2521_loop
    rx2520_cur."!mark_push"(0, rx2520_pos, $I10)
  rxscan2521_done:
.annotate 'line', 1074
  # rx subcapture "sym"
    set_addr $I10, rxcap_2522_fail
    rx2520_cur."!mark_push"(0, rx2520_pos, $I10)
  # rx literal  "!"
    add $I11, rx2520_pos, 1
    gt $I11, rx2520_eos, rx2520_fail
    sub $I11, rx2520_pos, rx2520_off
    ord $I11, rx2520_tgt, $I11
    ne $I11, 33, rx2520_fail
    add rx2520_pos, 1
    set_addr $I10, rxcap_2522_fail
    ($I12, $I11) = rx2520_cur."!mark_peek"($I10)
    rx2520_cur."!cursor_pos"($I11)
    ($P10) = rx2520_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2520_pos, "")
    rx2520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2522_done
  rxcap_2522_fail:
    goto rx2520_fail
  rxcap_2522_done:
  # rx subrule "O" subtype=capture negate=
    rx2520_cur."!cursor_pos"(rx2520_pos)
    $P10 = rx2520_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2520_fail
    rx2520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2520_pos = $P10."pos"()
  # rx pass
    rx2520_cur."!cursor_pass"(rx2520_pos, "prefix:sym<!>")
    if_null rx2520_debug, debug_1478
    rx2520_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2520_pos)
  debug_1478:
    .return (rx2520_cur)
  rx2520_restart:
.annotate 'line', 422
    if_null rx2520_debug, debug_1479
    rx2520_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1479:
  rx2520_fail:
    (rx2520_rep, rx2520_pos, $I10, $P10) = rx2520_cur."!mark_fail"(0)
    lt rx2520_pos, -1, rx2520_done
    eq rx2520_pos, -1, rx2520_fail
    jump $I10
  rx2520_done:
    rx2520_cur."!cursor_fail"()
    if_null rx2520_debug, debug_1480
    rx2520_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1480:
    .return (rx2520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("334_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2524 = self."!PREFIX__!subrule"("O", "!")
    new $P2525, "ResizablePMCArray"
    push $P2525, $P2524
    .return ($P2525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("335_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2527_tgt
    .local int rx2527_pos
    .local int rx2527_off
    .local int rx2527_eos
    .local int rx2527_rep
    .local pmc rx2527_cur
    .local pmc rx2527_debug
    (rx2527_cur, rx2527_pos, rx2527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2527_cur
    .local pmc match
    .lex "$/", match
    length rx2527_eos, rx2527_tgt
    gt rx2527_pos, rx2527_eos, rx2527_done
    set rx2527_off, 0
    lt rx2527_pos, 2, rx2527_start
    sub rx2527_off, rx2527_pos, 1
    substr rx2527_tgt, rx2527_tgt, rx2527_off
  rx2527_start:
    eq $I10, 1, rx2527_restart
    if_null rx2527_debug, debug_1481
    rx2527_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1481:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2528_done
    goto rxscan2528_scan
  rxscan2528_loop:
    (rx2527_pos) = rx2527_cur."from"()
    inc rx2527_pos
    rx2527_cur."!cursor_from"(rx2527_pos)
    ge rx2527_pos, rx2527_eos, rxscan2528_done
  rxscan2528_scan:
    set_addr $I10, rxscan2528_loop
    rx2527_cur."!mark_push"(0, rx2527_pos, $I10)
  rxscan2528_done:
.annotate 'line', 1075
  # rx subcapture "sym"
    set_addr $I10, rxcap_2529_fail
    rx2527_cur."!mark_push"(0, rx2527_pos, $I10)
  # rx literal  "|"
    add $I11, rx2527_pos, 1
    gt $I11, rx2527_eos, rx2527_fail
    sub $I11, rx2527_pos, rx2527_off
    ord $I11, rx2527_tgt, $I11
    ne $I11, 124, rx2527_fail
    add rx2527_pos, 1
    set_addr $I10, rxcap_2529_fail
    ($I12, $I11) = rx2527_cur."!mark_peek"($I10)
    rx2527_cur."!cursor_pos"($I11)
    ($P10) = rx2527_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2527_pos, "")
    rx2527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2529_done
  rxcap_2529_fail:
    goto rx2527_fail
  rxcap_2529_done:
  # rx subrule "O" subtype=capture negate=
    rx2527_cur."!cursor_pos"(rx2527_pos)
    $P10 = rx2527_cur."O"("%symbolic_unary")
    unless $P10, rx2527_fail
    rx2527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2527_pos = $P10."pos"()
  # rx pass
    rx2527_cur."!cursor_pass"(rx2527_pos, "prefix:sym<|>")
    if_null rx2527_debug, debug_1482
    rx2527_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2527_pos)
  debug_1482:
    .return (rx2527_cur)
  rx2527_restart:
.annotate 'line', 422
    if_null rx2527_debug, debug_1483
    rx2527_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1483:
  rx2527_fail:
    (rx2527_rep, rx2527_pos, $I10, $P10) = rx2527_cur."!mark_fail"(0)
    lt rx2527_pos, -1, rx2527_done
    eq rx2527_pos, -1, rx2527_fail
    jump $I10
  rx2527_done:
    rx2527_cur."!cursor_fail"()
    if_null rx2527_debug, debug_1484
    rx2527_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1484:
    .return (rx2527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("336_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2531 = self."!PREFIX__!subrule"("O", "|")
    new $P2532, "ResizablePMCArray"
    push $P2532, $P2531
    .return ($P2532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("337_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2534_tgt
    .local int rx2534_pos
    .local int rx2534_off
    .local int rx2534_eos
    .local int rx2534_rep
    .local pmc rx2534_cur
    .local pmc rx2534_debug
    (rx2534_cur, rx2534_pos, rx2534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2534_cur
    .local pmc match
    .lex "$/", match
    length rx2534_eos, rx2534_tgt
    gt rx2534_pos, rx2534_eos, rx2534_done
    set rx2534_off, 0
    lt rx2534_pos, 2, rx2534_start
    sub rx2534_off, rx2534_pos, 1
    substr rx2534_tgt, rx2534_tgt, rx2534_off
  rx2534_start:
    eq $I10, 1, rx2534_restart
    if_null rx2534_debug, debug_1485
    rx2534_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1485:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2535_done
    goto rxscan2535_scan
  rxscan2535_loop:
    (rx2534_pos) = rx2534_cur."from"()
    inc rx2534_pos
    rx2534_cur."!cursor_from"(rx2534_pos)
    ge rx2534_pos, rx2534_eos, rxscan2535_done
  rxscan2535_scan:
    set_addr $I10, rxscan2535_loop
    rx2534_cur."!mark_push"(0, rx2534_pos, $I10)
  rxscan2535_done:
.annotate 'line', 1077
  # rx subcapture "sym"
    set_addr $I10, rxcap_2536_fail
    rx2534_cur."!mark_push"(0, rx2534_pos, $I10)
  # rx literal  "*"
    add $I11, rx2534_pos, 1
    gt $I11, rx2534_eos, rx2534_fail
    sub $I11, rx2534_pos, rx2534_off
    ord $I11, rx2534_tgt, $I11
    ne $I11, 42, rx2534_fail
    add rx2534_pos, 1
    set_addr $I10, rxcap_2536_fail
    ($I12, $I11) = rx2534_cur."!mark_peek"($I10)
    rx2534_cur."!cursor_pos"($I11)
    ($P10) = rx2534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2534_pos, "")
    rx2534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2536_done
  rxcap_2536_fail:
    goto rx2534_fail
  rxcap_2536_done:
  # rx subrule "O" subtype=capture negate=
    rx2534_cur."!cursor_pos"(rx2534_pos)
    $P10 = rx2534_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2534_fail
    rx2534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2534_pos = $P10."pos"()
  # rx pass
    rx2534_cur."!cursor_pass"(rx2534_pos, "infix:sym<*>")
    if_null rx2534_debug, debug_1486
    rx2534_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2534_pos)
  debug_1486:
    .return (rx2534_cur)
  rx2534_restart:
.annotate 'line', 422
    if_null rx2534_debug, debug_1487
    rx2534_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1487:
  rx2534_fail:
    (rx2534_rep, rx2534_pos, $I10, $P10) = rx2534_cur."!mark_fail"(0)
    lt rx2534_pos, -1, rx2534_done
    eq rx2534_pos, -1, rx2534_fail
    jump $I10
  rx2534_done:
    rx2534_cur."!cursor_fail"()
    if_null rx2534_debug, debug_1488
    rx2534_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1488:
    .return (rx2534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("338_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2538 = self."!PREFIX__!subrule"("O", "*")
    new $P2539, "ResizablePMCArray"
    push $P2539, $P2538
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("339_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2541_tgt
    .local int rx2541_pos
    .local int rx2541_off
    .local int rx2541_eos
    .local int rx2541_rep
    .local pmc rx2541_cur
    .local pmc rx2541_debug
    (rx2541_cur, rx2541_pos, rx2541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2541_cur
    .local pmc match
    .lex "$/", match
    length rx2541_eos, rx2541_tgt
    gt rx2541_pos, rx2541_eos, rx2541_done
    set rx2541_off, 0
    lt rx2541_pos, 2, rx2541_start
    sub rx2541_off, rx2541_pos, 1
    substr rx2541_tgt, rx2541_tgt, rx2541_off
  rx2541_start:
    eq $I10, 1, rx2541_restart
    if_null rx2541_debug, debug_1489
    rx2541_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1489:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2542_done
    goto rxscan2542_scan
  rxscan2542_loop:
    (rx2541_pos) = rx2541_cur."from"()
    inc rx2541_pos
    rx2541_cur."!cursor_from"(rx2541_pos)
    ge rx2541_pos, rx2541_eos, rxscan2542_done
  rxscan2542_scan:
    set_addr $I10, rxscan2542_loop
    rx2541_cur."!mark_push"(0, rx2541_pos, $I10)
  rxscan2542_done:
.annotate 'line', 1078
  # rx subcapture "sym"
    set_addr $I10, rxcap_2543_fail
    rx2541_cur."!mark_push"(0, rx2541_pos, $I10)
  # rx literal  "/"
    add $I11, rx2541_pos, 1
    gt $I11, rx2541_eos, rx2541_fail
    sub $I11, rx2541_pos, rx2541_off
    ord $I11, rx2541_tgt, $I11
    ne $I11, 47, rx2541_fail
    add rx2541_pos, 1
    set_addr $I10, rxcap_2543_fail
    ($I12, $I11) = rx2541_cur."!mark_peek"($I10)
    rx2541_cur."!cursor_pos"($I11)
    ($P10) = rx2541_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2541_pos, "")
    rx2541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2543_done
  rxcap_2543_fail:
    goto rx2541_fail
  rxcap_2543_done:
  # rx subrule "O" subtype=capture negate=
    rx2541_cur."!cursor_pos"(rx2541_pos)
    $P10 = rx2541_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2541_fail
    rx2541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2541_pos = $P10."pos"()
  # rx pass
    rx2541_cur."!cursor_pass"(rx2541_pos, "infix:sym</>")
    if_null rx2541_debug, debug_1490
    rx2541_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2541_pos)
  debug_1490:
    .return (rx2541_cur)
  rx2541_restart:
.annotate 'line', 422
    if_null rx2541_debug, debug_1491
    rx2541_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1491:
  rx2541_fail:
    (rx2541_rep, rx2541_pos, $I10, $P10) = rx2541_cur."!mark_fail"(0)
    lt rx2541_pos, -1, rx2541_done
    eq rx2541_pos, -1, rx2541_fail
    jump $I10
  rx2541_done:
    rx2541_cur."!cursor_fail"()
    if_null rx2541_debug, debug_1492
    rx2541_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1492:
    .return (rx2541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("340_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2545 = self."!PREFIX__!subrule"("O", "/")
    new $P2546, "ResizablePMCArray"
    push $P2546, $P2545
    .return ($P2546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("341_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2548_tgt
    .local int rx2548_pos
    .local int rx2548_off
    .local int rx2548_eos
    .local int rx2548_rep
    .local pmc rx2548_cur
    .local pmc rx2548_debug
    (rx2548_cur, rx2548_pos, rx2548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2548_cur
    .local pmc match
    .lex "$/", match
    length rx2548_eos, rx2548_tgt
    gt rx2548_pos, rx2548_eos, rx2548_done
    set rx2548_off, 0
    lt rx2548_pos, 2, rx2548_start
    sub rx2548_off, rx2548_pos, 1
    substr rx2548_tgt, rx2548_tgt, rx2548_off
  rx2548_start:
    eq $I10, 1, rx2548_restart
    if_null rx2548_debug, debug_1493
    rx2548_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1493:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2549_done
    goto rxscan2549_scan
  rxscan2549_loop:
    (rx2548_pos) = rx2548_cur."from"()
    inc rx2548_pos
    rx2548_cur."!cursor_from"(rx2548_pos)
    ge rx2548_pos, rx2548_eos, rxscan2549_done
  rxscan2549_scan:
    set_addr $I10, rxscan2549_loop
    rx2548_cur."!mark_push"(0, rx2548_pos, $I10)
  rxscan2549_done:
.annotate 'line', 1079
  # rx subcapture "sym"
    set_addr $I10, rxcap_2550_fail
    rx2548_cur."!mark_push"(0, rx2548_pos, $I10)
  # rx literal  "%"
    add $I11, rx2548_pos, 1
    gt $I11, rx2548_eos, rx2548_fail
    sub $I11, rx2548_pos, rx2548_off
    ord $I11, rx2548_tgt, $I11
    ne $I11, 37, rx2548_fail
    add rx2548_pos, 1
    set_addr $I10, rxcap_2550_fail
    ($I12, $I11) = rx2548_cur."!mark_peek"($I10)
    rx2548_cur."!cursor_pos"($I11)
    ($P10) = rx2548_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2548_pos, "")
    rx2548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2550_done
  rxcap_2550_fail:
    goto rx2548_fail
  rxcap_2550_done:
  # rx subrule "O" subtype=capture negate=
    rx2548_cur."!cursor_pos"(rx2548_pos)
    $P10 = rx2548_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2548_fail
    rx2548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2548_pos = $P10."pos"()
  # rx pass
    rx2548_cur."!cursor_pass"(rx2548_pos, "infix:sym<%>")
    if_null rx2548_debug, debug_1494
    rx2548_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2548_pos)
  debug_1494:
    .return (rx2548_cur)
  rx2548_restart:
.annotate 'line', 422
    if_null rx2548_debug, debug_1495
    rx2548_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1495:
  rx2548_fail:
    (rx2548_rep, rx2548_pos, $I10, $P10) = rx2548_cur."!mark_fail"(0)
    lt rx2548_pos, -1, rx2548_done
    eq rx2548_pos, -1, rx2548_fail
    jump $I10
  rx2548_done:
    rx2548_cur."!cursor_fail"()
    if_null rx2548_debug, debug_1496
    rx2548_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1496:
    .return (rx2548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("342_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2552 = self."!PREFIX__!subrule"("O", "%")
    new $P2553, "ResizablePMCArray"
    push $P2553, $P2552
    .return ($P2553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("343_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2555_tgt
    .local int rx2555_pos
    .local int rx2555_off
    .local int rx2555_eos
    .local int rx2555_rep
    .local pmc rx2555_cur
    .local pmc rx2555_debug
    (rx2555_cur, rx2555_pos, rx2555_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2555_cur
    .local pmc match
    .lex "$/", match
    length rx2555_eos, rx2555_tgt
    gt rx2555_pos, rx2555_eos, rx2555_done
    set rx2555_off, 0
    lt rx2555_pos, 2, rx2555_start
    sub rx2555_off, rx2555_pos, 1
    substr rx2555_tgt, rx2555_tgt, rx2555_off
  rx2555_start:
    eq $I10, 1, rx2555_restart
    if_null rx2555_debug, debug_1497
    rx2555_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1497:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2556_done
    goto rxscan2556_scan
  rxscan2556_loop:
    (rx2555_pos) = rx2555_cur."from"()
    inc rx2555_pos
    rx2555_cur."!cursor_from"(rx2555_pos)
    ge rx2555_pos, rx2555_eos, rxscan2556_done
  rxscan2556_scan:
    set_addr $I10, rxscan2556_loop
    rx2555_cur."!mark_push"(0, rx2555_pos, $I10)
  rxscan2556_done:
.annotate 'line', 1080
  # rx subcapture "sym"
    set_addr $I10, rxcap_2557_fail
    rx2555_cur."!mark_push"(0, rx2555_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2555_pos, 2
    gt $I11, rx2555_eos, rx2555_fail
    sub $I11, rx2555_pos, rx2555_off
    substr $S10, rx2555_tgt, $I11, 2
    ne $S10, "+&", rx2555_fail
    add rx2555_pos, 2
    set_addr $I10, rxcap_2557_fail
    ($I12, $I11) = rx2555_cur."!mark_peek"($I10)
    rx2555_cur."!cursor_pos"($I11)
    ($P10) = rx2555_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2555_pos, "")
    rx2555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2557_done
  rxcap_2557_fail:
    goto rx2555_fail
  rxcap_2557_done:
  # rx subrule "O" subtype=capture negate=
    rx2555_cur."!cursor_pos"(rx2555_pos)
    $P10 = rx2555_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2555_fail
    rx2555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2555_pos = $P10."pos"()
  # rx pass
    rx2555_cur."!cursor_pass"(rx2555_pos, "infix:sym<+&>")
    if_null rx2555_debug, debug_1498
    rx2555_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2555_pos)
  debug_1498:
    .return (rx2555_cur)
  rx2555_restart:
.annotate 'line', 422
    if_null rx2555_debug, debug_1499
    rx2555_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1499:
  rx2555_fail:
    (rx2555_rep, rx2555_pos, $I10, $P10) = rx2555_cur."!mark_fail"(0)
    lt rx2555_pos, -1, rx2555_done
    eq rx2555_pos, -1, rx2555_fail
    jump $I10
  rx2555_done:
    rx2555_cur."!cursor_fail"()
    if_null rx2555_debug, debug_1500
    rx2555_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1500:
    .return (rx2555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("344_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2559 = self."!PREFIX__!subrule"("O", "+&")
    new $P2560, "ResizablePMCArray"
    push $P2560, $P2559
    .return ($P2560)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("345_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2562_tgt
    .local int rx2562_pos
    .local int rx2562_off
    .local int rx2562_eos
    .local int rx2562_rep
    .local pmc rx2562_cur
    .local pmc rx2562_debug
    (rx2562_cur, rx2562_pos, rx2562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2562_cur
    .local pmc match
    .lex "$/", match
    length rx2562_eos, rx2562_tgt
    gt rx2562_pos, rx2562_eos, rx2562_done
    set rx2562_off, 0
    lt rx2562_pos, 2, rx2562_start
    sub rx2562_off, rx2562_pos, 1
    substr rx2562_tgt, rx2562_tgt, rx2562_off
  rx2562_start:
    eq $I10, 1, rx2562_restart
    if_null rx2562_debug, debug_1501
    rx2562_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1501:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2563_done
    goto rxscan2563_scan
  rxscan2563_loop:
    (rx2562_pos) = rx2562_cur."from"()
    inc rx2562_pos
    rx2562_cur."!cursor_from"(rx2562_pos)
    ge rx2562_pos, rx2562_eos, rxscan2563_done
  rxscan2563_scan:
    set_addr $I10, rxscan2563_loop
    rx2562_cur."!mark_push"(0, rx2562_pos, $I10)
  rxscan2563_done:
.annotate 'line', 1082
  # rx subcapture "sym"
    set_addr $I10, rxcap_2564_fail
    rx2562_cur."!mark_push"(0, rx2562_pos, $I10)
  # rx literal  "+"
    add $I11, rx2562_pos, 1
    gt $I11, rx2562_eos, rx2562_fail
    sub $I11, rx2562_pos, rx2562_off
    ord $I11, rx2562_tgt, $I11
    ne $I11, 43, rx2562_fail
    add rx2562_pos, 1
    set_addr $I10, rxcap_2564_fail
    ($I12, $I11) = rx2562_cur."!mark_peek"($I10)
    rx2562_cur."!cursor_pos"($I11)
    ($P10) = rx2562_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2562_pos, "")
    rx2562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2564_done
  rxcap_2564_fail:
    goto rx2562_fail
  rxcap_2564_done:
  # rx subrule "O" subtype=capture negate=
    rx2562_cur."!cursor_pos"(rx2562_pos)
    $P10 = rx2562_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2562_fail
    rx2562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2562_pos = $P10."pos"()
  # rx pass
    rx2562_cur."!cursor_pass"(rx2562_pos, "infix:sym<+>")
    if_null rx2562_debug, debug_1502
    rx2562_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2562_pos)
  debug_1502:
    .return (rx2562_cur)
  rx2562_restart:
.annotate 'line', 422
    if_null rx2562_debug, debug_1503
    rx2562_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1503:
  rx2562_fail:
    (rx2562_rep, rx2562_pos, $I10, $P10) = rx2562_cur."!mark_fail"(0)
    lt rx2562_pos, -1, rx2562_done
    eq rx2562_pos, -1, rx2562_fail
    jump $I10
  rx2562_done:
    rx2562_cur."!cursor_fail"()
    if_null rx2562_debug, debug_1504
    rx2562_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1504:
    .return (rx2562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("346_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2566 = self."!PREFIX__!subrule"("O", "+")
    new $P2567, "ResizablePMCArray"
    push $P2567, $P2566
    .return ($P2567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("347_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2569_tgt
    .local int rx2569_pos
    .local int rx2569_off
    .local int rx2569_eos
    .local int rx2569_rep
    .local pmc rx2569_cur
    .local pmc rx2569_debug
    (rx2569_cur, rx2569_pos, rx2569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2569_cur
    .local pmc match
    .lex "$/", match
    length rx2569_eos, rx2569_tgt
    gt rx2569_pos, rx2569_eos, rx2569_done
    set rx2569_off, 0
    lt rx2569_pos, 2, rx2569_start
    sub rx2569_off, rx2569_pos, 1
    substr rx2569_tgt, rx2569_tgt, rx2569_off
  rx2569_start:
    eq $I10, 1, rx2569_restart
    if_null rx2569_debug, debug_1505
    rx2569_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1505:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2570_done
    goto rxscan2570_scan
  rxscan2570_loop:
    (rx2569_pos) = rx2569_cur."from"()
    inc rx2569_pos
    rx2569_cur."!cursor_from"(rx2569_pos)
    ge rx2569_pos, rx2569_eos, rxscan2570_done
  rxscan2570_scan:
    set_addr $I10, rxscan2570_loop
    rx2569_cur."!mark_push"(0, rx2569_pos, $I10)
  rxscan2570_done:
.annotate 'line', 1083
  # rx subcapture "sym"
    set_addr $I10, rxcap_2571_fail
    rx2569_cur."!mark_push"(0, rx2569_pos, $I10)
  # rx literal  "-"
    add $I11, rx2569_pos, 1
    gt $I11, rx2569_eos, rx2569_fail
    sub $I11, rx2569_pos, rx2569_off
    ord $I11, rx2569_tgt, $I11
    ne $I11, 45, rx2569_fail
    add rx2569_pos, 1
    set_addr $I10, rxcap_2571_fail
    ($I12, $I11) = rx2569_cur."!mark_peek"($I10)
    rx2569_cur."!cursor_pos"($I11)
    ($P10) = rx2569_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2569_pos, "")
    rx2569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2571_done
  rxcap_2571_fail:
    goto rx2569_fail
  rxcap_2571_done:
  # rx subrule "O" subtype=capture negate=
    rx2569_cur."!cursor_pos"(rx2569_pos)
    $P10 = rx2569_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2569_fail
    rx2569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2569_pos = $P10."pos"()
  # rx pass
    rx2569_cur."!cursor_pass"(rx2569_pos, "infix:sym<->")
    if_null rx2569_debug, debug_1506
    rx2569_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2569_pos)
  debug_1506:
    .return (rx2569_cur)
  rx2569_restart:
.annotate 'line', 422
    if_null rx2569_debug, debug_1507
    rx2569_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1507:
  rx2569_fail:
    (rx2569_rep, rx2569_pos, $I10, $P10) = rx2569_cur."!mark_fail"(0)
    lt rx2569_pos, -1, rx2569_done
    eq rx2569_pos, -1, rx2569_fail
    jump $I10
  rx2569_done:
    rx2569_cur."!cursor_fail"()
    if_null rx2569_debug, debug_1508
    rx2569_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1508:
    .return (rx2569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("348_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2573 = self."!PREFIX__!subrule"("O", "-")
    new $P2574, "ResizablePMCArray"
    push $P2574, $P2573
    .return ($P2574)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("349_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2576_tgt
    .local int rx2576_pos
    .local int rx2576_off
    .local int rx2576_eos
    .local int rx2576_rep
    .local pmc rx2576_cur
    .local pmc rx2576_debug
    (rx2576_cur, rx2576_pos, rx2576_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2576_cur
    .local pmc match
    .lex "$/", match
    length rx2576_eos, rx2576_tgt
    gt rx2576_pos, rx2576_eos, rx2576_done
    set rx2576_off, 0
    lt rx2576_pos, 2, rx2576_start
    sub rx2576_off, rx2576_pos, 1
    substr rx2576_tgt, rx2576_tgt, rx2576_off
  rx2576_start:
    eq $I10, 1, rx2576_restart
    if_null rx2576_debug, debug_1509
    rx2576_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1509:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2577_done
    goto rxscan2577_scan
  rxscan2577_loop:
    (rx2576_pos) = rx2576_cur."from"()
    inc rx2576_pos
    rx2576_cur."!cursor_from"(rx2576_pos)
    ge rx2576_pos, rx2576_eos, rxscan2577_done
  rxscan2577_scan:
    set_addr $I10, rxscan2577_loop
    rx2576_cur."!mark_push"(0, rx2576_pos, $I10)
  rxscan2577_done:
.annotate 'line', 1084
  # rx subcapture "sym"
    set_addr $I10, rxcap_2578_fail
    rx2576_cur."!mark_push"(0, rx2576_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2576_pos, 2
    gt $I11, rx2576_eos, rx2576_fail
    sub $I11, rx2576_pos, rx2576_off
    substr $S10, rx2576_tgt, $I11, 2
    ne $S10, "+|", rx2576_fail
    add rx2576_pos, 2
    set_addr $I10, rxcap_2578_fail
    ($I12, $I11) = rx2576_cur."!mark_peek"($I10)
    rx2576_cur."!cursor_pos"($I11)
    ($P10) = rx2576_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2576_pos, "")
    rx2576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2578_done
  rxcap_2578_fail:
    goto rx2576_fail
  rxcap_2578_done:
  # rx subrule "O" subtype=capture negate=
    rx2576_cur."!cursor_pos"(rx2576_pos)
    $P10 = rx2576_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2576_fail
    rx2576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2576_pos = $P10."pos"()
  # rx pass
    rx2576_cur."!cursor_pass"(rx2576_pos, "infix:sym<+|>")
    if_null rx2576_debug, debug_1510
    rx2576_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2576_pos)
  debug_1510:
    .return (rx2576_cur)
  rx2576_restart:
.annotate 'line', 422
    if_null rx2576_debug, debug_1511
    rx2576_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1511:
  rx2576_fail:
    (rx2576_rep, rx2576_pos, $I10, $P10) = rx2576_cur."!mark_fail"(0)
    lt rx2576_pos, -1, rx2576_done
    eq rx2576_pos, -1, rx2576_fail
    jump $I10
  rx2576_done:
    rx2576_cur."!cursor_fail"()
    if_null rx2576_debug, debug_1512
    rx2576_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1512:
    .return (rx2576_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("350_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2580 = self."!PREFIX__!subrule"("O", "+|")
    new $P2581, "ResizablePMCArray"
    push $P2581, $P2580
    .return ($P2581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("351_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2583_tgt
    .local int rx2583_pos
    .local int rx2583_off
    .local int rx2583_eos
    .local int rx2583_rep
    .local pmc rx2583_cur
    .local pmc rx2583_debug
    (rx2583_cur, rx2583_pos, rx2583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2583_cur
    .local pmc match
    .lex "$/", match
    length rx2583_eos, rx2583_tgt
    gt rx2583_pos, rx2583_eos, rx2583_done
    set rx2583_off, 0
    lt rx2583_pos, 2, rx2583_start
    sub rx2583_off, rx2583_pos, 1
    substr rx2583_tgt, rx2583_tgt, rx2583_off
  rx2583_start:
    eq $I10, 1, rx2583_restart
    if_null rx2583_debug, debug_1513
    rx2583_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1513:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2584_done
    goto rxscan2584_scan
  rxscan2584_loop:
    (rx2583_pos) = rx2583_cur."from"()
    inc rx2583_pos
    rx2583_cur."!cursor_from"(rx2583_pos)
    ge rx2583_pos, rx2583_eos, rxscan2584_done
  rxscan2584_scan:
    set_addr $I10, rxscan2584_loop
    rx2583_cur."!mark_push"(0, rx2583_pos, $I10)
  rxscan2584_done:
.annotate 'line', 1085
  # rx subcapture "sym"
    set_addr $I10, rxcap_2585_fail
    rx2583_cur."!mark_push"(0, rx2583_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2583_pos, 2
    gt $I11, rx2583_eos, rx2583_fail
    sub $I11, rx2583_pos, rx2583_off
    substr $S10, rx2583_tgt, $I11, 2
    ne $S10, "+^", rx2583_fail
    add rx2583_pos, 2
    set_addr $I10, rxcap_2585_fail
    ($I12, $I11) = rx2583_cur."!mark_peek"($I10)
    rx2583_cur."!cursor_pos"($I11)
    ($P10) = rx2583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2583_pos, "")
    rx2583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2585_done
  rxcap_2585_fail:
    goto rx2583_fail
  rxcap_2585_done:
  # rx subrule "O" subtype=capture negate=
    rx2583_cur."!cursor_pos"(rx2583_pos)
    $P10 = rx2583_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2583_fail
    rx2583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2583_pos = $P10."pos"()
  # rx pass
    rx2583_cur."!cursor_pass"(rx2583_pos, "infix:sym<+^>")
    if_null rx2583_debug, debug_1514
    rx2583_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2583_pos)
  debug_1514:
    .return (rx2583_cur)
  rx2583_restart:
.annotate 'line', 422
    if_null rx2583_debug, debug_1515
    rx2583_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1515:
  rx2583_fail:
    (rx2583_rep, rx2583_pos, $I10, $P10) = rx2583_cur."!mark_fail"(0)
    lt rx2583_pos, -1, rx2583_done
    eq rx2583_pos, -1, rx2583_fail
    jump $I10
  rx2583_done:
    rx2583_cur."!cursor_fail"()
    if_null rx2583_debug, debug_1516
    rx2583_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1516:
    .return (rx2583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("352_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2587 = self."!PREFIX__!subrule"("O", "+^")
    new $P2588, "ResizablePMCArray"
    push $P2588, $P2587
    .return ($P2588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("353_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2590_tgt
    .local int rx2590_pos
    .local int rx2590_off
    .local int rx2590_eos
    .local int rx2590_rep
    .local pmc rx2590_cur
    .local pmc rx2590_debug
    (rx2590_cur, rx2590_pos, rx2590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2590_cur
    .local pmc match
    .lex "$/", match
    length rx2590_eos, rx2590_tgt
    gt rx2590_pos, rx2590_eos, rx2590_done
    set rx2590_off, 0
    lt rx2590_pos, 2, rx2590_start
    sub rx2590_off, rx2590_pos, 1
    substr rx2590_tgt, rx2590_tgt, rx2590_off
  rx2590_start:
    eq $I10, 1, rx2590_restart
    if_null rx2590_debug, debug_1517
    rx2590_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1517:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2591_done
    goto rxscan2591_scan
  rxscan2591_loop:
    (rx2590_pos) = rx2590_cur."from"()
    inc rx2590_pos
    rx2590_cur."!cursor_from"(rx2590_pos)
    ge rx2590_pos, rx2590_eos, rxscan2591_done
  rxscan2591_scan:
    set_addr $I10, rxscan2591_loop
    rx2590_cur."!mark_push"(0, rx2590_pos, $I10)
  rxscan2591_done:
.annotate 'line', 1087
  # rx subcapture "sym"
    set_addr $I10, rxcap_2592_fail
    rx2590_cur."!mark_push"(0, rx2590_pos, $I10)
  # rx literal  "~"
    add $I11, rx2590_pos, 1
    gt $I11, rx2590_eos, rx2590_fail
    sub $I11, rx2590_pos, rx2590_off
    ord $I11, rx2590_tgt, $I11
    ne $I11, 126, rx2590_fail
    add rx2590_pos, 1
    set_addr $I10, rxcap_2592_fail
    ($I12, $I11) = rx2590_cur."!mark_peek"($I10)
    rx2590_cur."!cursor_pos"($I11)
    ($P10) = rx2590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2590_pos, "")
    rx2590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2592_done
  rxcap_2592_fail:
    goto rx2590_fail
  rxcap_2592_done:
  # rx subrule "O" subtype=capture negate=
    rx2590_cur."!cursor_pos"(rx2590_pos)
    $P10 = rx2590_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2590_fail
    rx2590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2590_pos = $P10."pos"()
  # rx pass
    rx2590_cur."!cursor_pass"(rx2590_pos, "infix:sym<~>")
    if_null rx2590_debug, debug_1518
    rx2590_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2590_pos)
  debug_1518:
    .return (rx2590_cur)
  rx2590_restart:
.annotate 'line', 422
    if_null rx2590_debug, debug_1519
    rx2590_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1519:
  rx2590_fail:
    (rx2590_rep, rx2590_pos, $I10, $P10) = rx2590_cur."!mark_fail"(0)
    lt rx2590_pos, -1, rx2590_done
    eq rx2590_pos, -1, rx2590_fail
    jump $I10
  rx2590_done:
    rx2590_cur."!cursor_fail"()
    if_null rx2590_debug, debug_1520
    rx2590_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1520:
    .return (rx2590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("354_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2594 = self."!PREFIX__!subrule"("O", "~")
    new $P2595, "ResizablePMCArray"
    push $P2595, $P2594
    .return ($P2595)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("355_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2597_tgt
    .local int rx2597_pos
    .local int rx2597_off
    .local int rx2597_eos
    .local int rx2597_rep
    .local pmc rx2597_cur
    .local pmc rx2597_debug
    (rx2597_cur, rx2597_pos, rx2597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2597_cur
    .local pmc match
    .lex "$/", match
    length rx2597_eos, rx2597_tgt
    gt rx2597_pos, rx2597_eos, rx2597_done
    set rx2597_off, 0
    lt rx2597_pos, 2, rx2597_start
    sub rx2597_off, rx2597_pos, 1
    substr rx2597_tgt, rx2597_tgt, rx2597_off
  rx2597_start:
    eq $I10, 1, rx2597_restart
    if_null rx2597_debug, debug_1521
    rx2597_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1521:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2598_done
    goto rxscan2598_scan
  rxscan2598_loop:
    (rx2597_pos) = rx2597_cur."from"()
    inc rx2597_pos
    rx2597_cur."!cursor_from"(rx2597_pos)
    ge rx2597_pos, rx2597_eos, rxscan2598_done
  rxscan2598_scan:
    set_addr $I10, rxscan2598_loop
    rx2597_cur."!mark_push"(0, rx2597_pos, $I10)
  rxscan2598_done:
.annotate 'line', 1089
  # rx subcapture "sym"
    set_addr $I10, rxcap_2599_fail
    rx2597_cur."!mark_push"(0, rx2597_pos, $I10)
  # rx literal  "=="
    add $I11, rx2597_pos, 2
    gt $I11, rx2597_eos, rx2597_fail
    sub $I11, rx2597_pos, rx2597_off
    substr $S10, rx2597_tgt, $I11, 2
    ne $S10, "==", rx2597_fail
    add rx2597_pos, 2
    set_addr $I10, rxcap_2599_fail
    ($I12, $I11) = rx2597_cur."!mark_peek"($I10)
    rx2597_cur."!cursor_pos"($I11)
    ($P10) = rx2597_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2597_pos, "")
    rx2597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2599_done
  rxcap_2599_fail:
    goto rx2597_fail
  rxcap_2599_done:
  # rx subrule "O" subtype=capture negate=
    rx2597_cur."!cursor_pos"(rx2597_pos)
    $P10 = rx2597_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2597_fail
    rx2597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2597_pos = $P10."pos"()
  # rx pass
    rx2597_cur."!cursor_pass"(rx2597_pos, "infix:sym<==>")
    if_null rx2597_debug, debug_1522
    rx2597_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2597_pos)
  debug_1522:
    .return (rx2597_cur)
  rx2597_restart:
.annotate 'line', 422
    if_null rx2597_debug, debug_1523
    rx2597_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1523:
  rx2597_fail:
    (rx2597_rep, rx2597_pos, $I10, $P10) = rx2597_cur."!mark_fail"(0)
    lt rx2597_pos, -1, rx2597_done
    eq rx2597_pos, -1, rx2597_fail
    jump $I10
  rx2597_done:
    rx2597_cur."!cursor_fail"()
    if_null rx2597_debug, debug_1524
    rx2597_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1524:
    .return (rx2597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("356_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2601 = self."!PREFIX__!subrule"("O", "==")
    new $P2602, "ResizablePMCArray"
    push $P2602, $P2601
    .return ($P2602)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("357_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2604_tgt
    .local int rx2604_pos
    .local int rx2604_off
    .local int rx2604_eos
    .local int rx2604_rep
    .local pmc rx2604_cur
    .local pmc rx2604_debug
    (rx2604_cur, rx2604_pos, rx2604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2604_cur
    .local pmc match
    .lex "$/", match
    length rx2604_eos, rx2604_tgt
    gt rx2604_pos, rx2604_eos, rx2604_done
    set rx2604_off, 0
    lt rx2604_pos, 2, rx2604_start
    sub rx2604_off, rx2604_pos, 1
    substr rx2604_tgt, rx2604_tgt, rx2604_off
  rx2604_start:
    eq $I10, 1, rx2604_restart
    if_null rx2604_debug, debug_1525
    rx2604_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1525:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2605_done
    goto rxscan2605_scan
  rxscan2605_loop:
    (rx2604_pos) = rx2604_cur."from"()
    inc rx2604_pos
    rx2604_cur."!cursor_from"(rx2604_pos)
    ge rx2604_pos, rx2604_eos, rxscan2605_done
  rxscan2605_scan:
    set_addr $I10, rxscan2605_loop
    rx2604_cur."!mark_push"(0, rx2604_pos, $I10)
  rxscan2605_done:
.annotate 'line', 1090
  # rx subcapture "sym"
    set_addr $I10, rxcap_2606_fail
    rx2604_cur."!mark_push"(0, rx2604_pos, $I10)
  # rx literal  "!="
    add $I11, rx2604_pos, 2
    gt $I11, rx2604_eos, rx2604_fail
    sub $I11, rx2604_pos, rx2604_off
    substr $S10, rx2604_tgt, $I11, 2
    ne $S10, "!=", rx2604_fail
    add rx2604_pos, 2
    set_addr $I10, rxcap_2606_fail
    ($I12, $I11) = rx2604_cur."!mark_peek"($I10)
    rx2604_cur."!cursor_pos"($I11)
    ($P10) = rx2604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2604_pos, "")
    rx2604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2606_done
  rxcap_2606_fail:
    goto rx2604_fail
  rxcap_2606_done:
  # rx subrule "O" subtype=capture negate=
    rx2604_cur."!cursor_pos"(rx2604_pos)
    $P10 = rx2604_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2604_fail
    rx2604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2604_pos = $P10."pos"()
  # rx pass
    rx2604_cur."!cursor_pass"(rx2604_pos, "infix:sym<!=>")
    if_null rx2604_debug, debug_1526
    rx2604_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2604_pos)
  debug_1526:
    .return (rx2604_cur)
  rx2604_restart:
.annotate 'line', 422
    if_null rx2604_debug, debug_1527
    rx2604_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1527:
  rx2604_fail:
    (rx2604_rep, rx2604_pos, $I10, $P10) = rx2604_cur."!mark_fail"(0)
    lt rx2604_pos, -1, rx2604_done
    eq rx2604_pos, -1, rx2604_fail
    jump $I10
  rx2604_done:
    rx2604_cur."!cursor_fail"()
    if_null rx2604_debug, debug_1528
    rx2604_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1528:
    .return (rx2604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("358_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2608 = self."!PREFIX__!subrule"("O", "!=")
    new $P2609, "ResizablePMCArray"
    push $P2609, $P2608
    .return ($P2609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("359_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2611_tgt
    .local int rx2611_pos
    .local int rx2611_off
    .local int rx2611_eos
    .local int rx2611_rep
    .local pmc rx2611_cur
    .local pmc rx2611_debug
    (rx2611_cur, rx2611_pos, rx2611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2611_cur
    .local pmc match
    .lex "$/", match
    length rx2611_eos, rx2611_tgt
    gt rx2611_pos, rx2611_eos, rx2611_done
    set rx2611_off, 0
    lt rx2611_pos, 2, rx2611_start
    sub rx2611_off, rx2611_pos, 1
    substr rx2611_tgt, rx2611_tgt, rx2611_off
  rx2611_start:
    eq $I10, 1, rx2611_restart
    if_null rx2611_debug, debug_1529
    rx2611_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1529:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2612_done
    goto rxscan2612_scan
  rxscan2612_loop:
    (rx2611_pos) = rx2611_cur."from"()
    inc rx2611_pos
    rx2611_cur."!cursor_from"(rx2611_pos)
    ge rx2611_pos, rx2611_eos, rxscan2612_done
  rxscan2612_scan:
    set_addr $I10, rxscan2612_loop
    rx2611_cur."!mark_push"(0, rx2611_pos, $I10)
  rxscan2612_done:
.annotate 'line', 1091
  # rx subcapture "sym"
    set_addr $I10, rxcap_2613_fail
    rx2611_cur."!mark_push"(0, rx2611_pos, $I10)
  # rx literal  "<="
    add $I11, rx2611_pos, 2
    gt $I11, rx2611_eos, rx2611_fail
    sub $I11, rx2611_pos, rx2611_off
    substr $S10, rx2611_tgt, $I11, 2
    ne $S10, "<=", rx2611_fail
    add rx2611_pos, 2
    set_addr $I10, rxcap_2613_fail
    ($I12, $I11) = rx2611_cur."!mark_peek"($I10)
    rx2611_cur."!cursor_pos"($I11)
    ($P10) = rx2611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2611_pos, "")
    rx2611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2613_done
  rxcap_2613_fail:
    goto rx2611_fail
  rxcap_2613_done:
  # rx subrule "O" subtype=capture negate=
    rx2611_cur."!cursor_pos"(rx2611_pos)
    $P10 = rx2611_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2611_fail
    rx2611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2611_pos = $P10."pos"()
  # rx pass
    rx2611_cur."!cursor_pass"(rx2611_pos, "infix:sym<<=>")
    if_null rx2611_debug, debug_1530
    rx2611_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2611_pos)
  debug_1530:
    .return (rx2611_cur)
  rx2611_restart:
.annotate 'line', 422
    if_null rx2611_debug, debug_1531
    rx2611_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1531:
  rx2611_fail:
    (rx2611_rep, rx2611_pos, $I10, $P10) = rx2611_cur."!mark_fail"(0)
    lt rx2611_pos, -1, rx2611_done
    eq rx2611_pos, -1, rx2611_fail
    jump $I10
  rx2611_done:
    rx2611_cur."!cursor_fail"()
    if_null rx2611_debug, debug_1532
    rx2611_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1532:
    .return (rx2611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("360_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2615 = self."!PREFIX__!subrule"("O", "<=")
    new $P2616, "ResizablePMCArray"
    push $P2616, $P2615
    .return ($P2616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("361_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2618_tgt
    .local int rx2618_pos
    .local int rx2618_off
    .local int rx2618_eos
    .local int rx2618_rep
    .local pmc rx2618_cur
    .local pmc rx2618_debug
    (rx2618_cur, rx2618_pos, rx2618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2618_cur
    .local pmc match
    .lex "$/", match
    length rx2618_eos, rx2618_tgt
    gt rx2618_pos, rx2618_eos, rx2618_done
    set rx2618_off, 0
    lt rx2618_pos, 2, rx2618_start
    sub rx2618_off, rx2618_pos, 1
    substr rx2618_tgt, rx2618_tgt, rx2618_off
  rx2618_start:
    eq $I10, 1, rx2618_restart
    if_null rx2618_debug, debug_1533
    rx2618_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1533:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2619_done
    goto rxscan2619_scan
  rxscan2619_loop:
    (rx2618_pos) = rx2618_cur."from"()
    inc rx2618_pos
    rx2618_cur."!cursor_from"(rx2618_pos)
    ge rx2618_pos, rx2618_eos, rxscan2619_done
  rxscan2619_scan:
    set_addr $I10, rxscan2619_loop
    rx2618_cur."!mark_push"(0, rx2618_pos, $I10)
  rxscan2619_done:
.annotate 'line', 1092
  # rx subcapture "sym"
    set_addr $I10, rxcap_2620_fail
    rx2618_cur."!mark_push"(0, rx2618_pos, $I10)
  # rx literal  ">="
    add $I11, rx2618_pos, 2
    gt $I11, rx2618_eos, rx2618_fail
    sub $I11, rx2618_pos, rx2618_off
    substr $S10, rx2618_tgt, $I11, 2
    ne $S10, ">=", rx2618_fail
    add rx2618_pos, 2
    set_addr $I10, rxcap_2620_fail
    ($I12, $I11) = rx2618_cur."!mark_peek"($I10)
    rx2618_cur."!cursor_pos"($I11)
    ($P10) = rx2618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2618_pos, "")
    rx2618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2620_done
  rxcap_2620_fail:
    goto rx2618_fail
  rxcap_2620_done:
  # rx subrule "O" subtype=capture negate=
    rx2618_cur."!cursor_pos"(rx2618_pos)
    $P10 = rx2618_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2618_fail
    rx2618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2618_pos = $P10."pos"()
  # rx pass
    rx2618_cur."!cursor_pass"(rx2618_pos, "infix:sym<>=>")
    if_null rx2618_debug, debug_1534
    rx2618_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2618_pos)
  debug_1534:
    .return (rx2618_cur)
  rx2618_restart:
.annotate 'line', 422
    if_null rx2618_debug, debug_1535
    rx2618_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1535:
  rx2618_fail:
    (rx2618_rep, rx2618_pos, $I10, $P10) = rx2618_cur."!mark_fail"(0)
    lt rx2618_pos, -1, rx2618_done
    eq rx2618_pos, -1, rx2618_fail
    jump $I10
  rx2618_done:
    rx2618_cur."!cursor_fail"()
    if_null rx2618_debug, debug_1536
    rx2618_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1536:
    .return (rx2618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("362_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2622 = self."!PREFIX__!subrule"("O", ">=")
    new $P2623, "ResizablePMCArray"
    push $P2623, $P2622
    .return ($P2623)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("363_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2625_tgt
    .local int rx2625_pos
    .local int rx2625_off
    .local int rx2625_eos
    .local int rx2625_rep
    .local pmc rx2625_cur
    .local pmc rx2625_debug
    (rx2625_cur, rx2625_pos, rx2625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2625_cur
    .local pmc match
    .lex "$/", match
    length rx2625_eos, rx2625_tgt
    gt rx2625_pos, rx2625_eos, rx2625_done
    set rx2625_off, 0
    lt rx2625_pos, 2, rx2625_start
    sub rx2625_off, rx2625_pos, 1
    substr rx2625_tgt, rx2625_tgt, rx2625_off
  rx2625_start:
    eq $I10, 1, rx2625_restart
    if_null rx2625_debug, debug_1537
    rx2625_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1537:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2626_done
    goto rxscan2626_scan
  rxscan2626_loop:
    (rx2625_pos) = rx2625_cur."from"()
    inc rx2625_pos
    rx2625_cur."!cursor_from"(rx2625_pos)
    ge rx2625_pos, rx2625_eos, rxscan2626_done
  rxscan2626_scan:
    set_addr $I10, rxscan2626_loop
    rx2625_cur."!mark_push"(0, rx2625_pos, $I10)
  rxscan2626_done:
.annotate 'line', 1093
  # rx subcapture "sym"
    set_addr $I10, rxcap_2627_fail
    rx2625_cur."!mark_push"(0, rx2625_pos, $I10)
  # rx literal  "<"
    add $I11, rx2625_pos, 1
    gt $I11, rx2625_eos, rx2625_fail
    sub $I11, rx2625_pos, rx2625_off
    ord $I11, rx2625_tgt, $I11
    ne $I11, 60, rx2625_fail
    add rx2625_pos, 1
    set_addr $I10, rxcap_2627_fail
    ($I12, $I11) = rx2625_cur."!mark_peek"($I10)
    rx2625_cur."!cursor_pos"($I11)
    ($P10) = rx2625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2625_pos, "")
    rx2625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2627_done
  rxcap_2627_fail:
    goto rx2625_fail
  rxcap_2627_done:
  # rx subrule "O" subtype=capture negate=
    rx2625_cur."!cursor_pos"(rx2625_pos)
    $P10 = rx2625_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2625_fail
    rx2625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2625_pos = $P10."pos"()
  # rx pass
    rx2625_cur."!cursor_pass"(rx2625_pos, "infix:sym<<>")
    if_null rx2625_debug, debug_1538
    rx2625_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2625_pos)
  debug_1538:
    .return (rx2625_cur)
  rx2625_restart:
.annotate 'line', 422
    if_null rx2625_debug, debug_1539
    rx2625_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1539:
  rx2625_fail:
    (rx2625_rep, rx2625_pos, $I10, $P10) = rx2625_cur."!mark_fail"(0)
    lt rx2625_pos, -1, rx2625_done
    eq rx2625_pos, -1, rx2625_fail
    jump $I10
  rx2625_done:
    rx2625_cur."!cursor_fail"()
    if_null rx2625_debug, debug_1540
    rx2625_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1540:
    .return (rx2625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("364_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2629 = self."!PREFIX__!subrule"("O", "<")
    new $P2630, "ResizablePMCArray"
    push $P2630, $P2629
    .return ($P2630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("365_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2632_tgt
    .local int rx2632_pos
    .local int rx2632_off
    .local int rx2632_eos
    .local int rx2632_rep
    .local pmc rx2632_cur
    .local pmc rx2632_debug
    (rx2632_cur, rx2632_pos, rx2632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2632_cur
    .local pmc match
    .lex "$/", match
    length rx2632_eos, rx2632_tgt
    gt rx2632_pos, rx2632_eos, rx2632_done
    set rx2632_off, 0
    lt rx2632_pos, 2, rx2632_start
    sub rx2632_off, rx2632_pos, 1
    substr rx2632_tgt, rx2632_tgt, rx2632_off
  rx2632_start:
    eq $I10, 1, rx2632_restart
    if_null rx2632_debug, debug_1541
    rx2632_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1541:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2633_done
    goto rxscan2633_scan
  rxscan2633_loop:
    (rx2632_pos) = rx2632_cur."from"()
    inc rx2632_pos
    rx2632_cur."!cursor_from"(rx2632_pos)
    ge rx2632_pos, rx2632_eos, rxscan2633_done
  rxscan2633_scan:
    set_addr $I10, rxscan2633_loop
    rx2632_cur."!mark_push"(0, rx2632_pos, $I10)
  rxscan2633_done:
.annotate 'line', 1094
  # rx subcapture "sym"
    set_addr $I10, rxcap_2634_fail
    rx2632_cur."!mark_push"(0, rx2632_pos, $I10)
  # rx literal  ">"
    add $I11, rx2632_pos, 1
    gt $I11, rx2632_eos, rx2632_fail
    sub $I11, rx2632_pos, rx2632_off
    ord $I11, rx2632_tgt, $I11
    ne $I11, 62, rx2632_fail
    add rx2632_pos, 1
    set_addr $I10, rxcap_2634_fail
    ($I12, $I11) = rx2632_cur."!mark_peek"($I10)
    rx2632_cur."!cursor_pos"($I11)
    ($P10) = rx2632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2632_pos, "")
    rx2632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2634_done
  rxcap_2634_fail:
    goto rx2632_fail
  rxcap_2634_done:
  # rx subrule "O" subtype=capture negate=
    rx2632_cur."!cursor_pos"(rx2632_pos)
    $P10 = rx2632_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2632_fail
    rx2632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2632_pos = $P10."pos"()
  # rx pass
    rx2632_cur."!cursor_pass"(rx2632_pos, "infix:sym<>>")
    if_null rx2632_debug, debug_1542
    rx2632_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2632_pos)
  debug_1542:
    .return (rx2632_cur)
  rx2632_restart:
.annotate 'line', 422
    if_null rx2632_debug, debug_1543
    rx2632_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1543:
  rx2632_fail:
    (rx2632_rep, rx2632_pos, $I10, $P10) = rx2632_cur."!mark_fail"(0)
    lt rx2632_pos, -1, rx2632_done
    eq rx2632_pos, -1, rx2632_fail
    jump $I10
  rx2632_done:
    rx2632_cur."!cursor_fail"()
    if_null rx2632_debug, debug_1544
    rx2632_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1544:
    .return (rx2632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("366_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2636 = self."!PREFIX__!subrule"("O", ">")
    new $P2637, "ResizablePMCArray"
    push $P2637, $P2636
    .return ($P2637)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("367_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2639_tgt
    .local int rx2639_pos
    .local int rx2639_off
    .local int rx2639_eos
    .local int rx2639_rep
    .local pmc rx2639_cur
    .local pmc rx2639_debug
    (rx2639_cur, rx2639_pos, rx2639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2639_cur
    .local pmc match
    .lex "$/", match
    length rx2639_eos, rx2639_tgt
    gt rx2639_pos, rx2639_eos, rx2639_done
    set rx2639_off, 0
    lt rx2639_pos, 2, rx2639_start
    sub rx2639_off, rx2639_pos, 1
    substr rx2639_tgt, rx2639_tgt, rx2639_off
  rx2639_start:
    eq $I10, 1, rx2639_restart
    if_null rx2639_debug, debug_1545
    rx2639_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1545:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2640_done
    goto rxscan2640_scan
  rxscan2640_loop:
    (rx2639_pos) = rx2639_cur."from"()
    inc rx2639_pos
    rx2639_cur."!cursor_from"(rx2639_pos)
    ge rx2639_pos, rx2639_eos, rxscan2640_done
  rxscan2640_scan:
    set_addr $I10, rxscan2640_loop
    rx2639_cur."!mark_push"(0, rx2639_pos, $I10)
  rxscan2640_done:
.annotate 'line', 1095
  # rx subcapture "sym"
    set_addr $I10, rxcap_2641_fail
    rx2639_cur."!mark_push"(0, rx2639_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2639_pos, 2
    gt $I11, rx2639_eos, rx2639_fail
    sub $I11, rx2639_pos, rx2639_off
    substr $S10, rx2639_tgt, $I11, 2
    ne $S10, "eq", rx2639_fail
    add rx2639_pos, 2
    set_addr $I10, rxcap_2641_fail
    ($I12, $I11) = rx2639_cur."!mark_peek"($I10)
    rx2639_cur."!cursor_pos"($I11)
    ($P10) = rx2639_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2639_pos, "")
    rx2639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2641_done
  rxcap_2641_fail:
    goto rx2639_fail
  rxcap_2641_done:
  # rx subrule "O" subtype=capture negate=
    rx2639_cur."!cursor_pos"(rx2639_pos)
    $P10 = rx2639_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2639_fail
    rx2639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2639_pos = $P10."pos"()
  # rx pass
    rx2639_cur."!cursor_pass"(rx2639_pos, "infix:sym<eq>")
    if_null rx2639_debug, debug_1546
    rx2639_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2639_pos)
  debug_1546:
    .return (rx2639_cur)
  rx2639_restart:
.annotate 'line', 422
    if_null rx2639_debug, debug_1547
    rx2639_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1547:
  rx2639_fail:
    (rx2639_rep, rx2639_pos, $I10, $P10) = rx2639_cur."!mark_fail"(0)
    lt rx2639_pos, -1, rx2639_done
    eq rx2639_pos, -1, rx2639_fail
    jump $I10
  rx2639_done:
    rx2639_cur."!cursor_fail"()
    if_null rx2639_debug, debug_1548
    rx2639_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1548:
    .return (rx2639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("368_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2643 = self."!PREFIX__!subrule"("O", "eq")
    new $P2644, "ResizablePMCArray"
    push $P2644, $P2643
    .return ($P2644)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("369_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2646_tgt
    .local int rx2646_pos
    .local int rx2646_off
    .local int rx2646_eos
    .local int rx2646_rep
    .local pmc rx2646_cur
    .local pmc rx2646_debug
    (rx2646_cur, rx2646_pos, rx2646_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2646_cur
    .local pmc match
    .lex "$/", match
    length rx2646_eos, rx2646_tgt
    gt rx2646_pos, rx2646_eos, rx2646_done
    set rx2646_off, 0
    lt rx2646_pos, 2, rx2646_start
    sub rx2646_off, rx2646_pos, 1
    substr rx2646_tgt, rx2646_tgt, rx2646_off
  rx2646_start:
    eq $I10, 1, rx2646_restart
    if_null rx2646_debug, debug_1549
    rx2646_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1549:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2647_done
    goto rxscan2647_scan
  rxscan2647_loop:
    (rx2646_pos) = rx2646_cur."from"()
    inc rx2646_pos
    rx2646_cur."!cursor_from"(rx2646_pos)
    ge rx2646_pos, rx2646_eos, rxscan2647_done
  rxscan2647_scan:
    set_addr $I10, rxscan2647_loop
    rx2646_cur."!mark_push"(0, rx2646_pos, $I10)
  rxscan2647_done:
.annotate 'line', 1096
  # rx subcapture "sym"
    set_addr $I10, rxcap_2648_fail
    rx2646_cur."!mark_push"(0, rx2646_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2646_pos, 2
    gt $I11, rx2646_eos, rx2646_fail
    sub $I11, rx2646_pos, rx2646_off
    substr $S10, rx2646_tgt, $I11, 2
    ne $S10, "ne", rx2646_fail
    add rx2646_pos, 2
    set_addr $I10, rxcap_2648_fail
    ($I12, $I11) = rx2646_cur."!mark_peek"($I10)
    rx2646_cur."!cursor_pos"($I11)
    ($P10) = rx2646_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2646_pos, "")
    rx2646_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2648_done
  rxcap_2648_fail:
    goto rx2646_fail
  rxcap_2648_done:
  # rx subrule "O" subtype=capture negate=
    rx2646_cur."!cursor_pos"(rx2646_pos)
    $P10 = rx2646_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2646_fail
    rx2646_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2646_pos = $P10."pos"()
  # rx pass
    rx2646_cur."!cursor_pass"(rx2646_pos, "infix:sym<ne>")
    if_null rx2646_debug, debug_1550
    rx2646_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2646_pos)
  debug_1550:
    .return (rx2646_cur)
  rx2646_restart:
.annotate 'line', 422
    if_null rx2646_debug, debug_1551
    rx2646_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1551:
  rx2646_fail:
    (rx2646_rep, rx2646_pos, $I10, $P10) = rx2646_cur."!mark_fail"(0)
    lt rx2646_pos, -1, rx2646_done
    eq rx2646_pos, -1, rx2646_fail
    jump $I10
  rx2646_done:
    rx2646_cur."!cursor_fail"()
    if_null rx2646_debug, debug_1552
    rx2646_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1552:
    .return (rx2646_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("370_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2650 = self."!PREFIX__!subrule"("O", "ne")
    new $P2651, "ResizablePMCArray"
    push $P2651, $P2650
    .return ($P2651)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("371_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2653_tgt
    .local int rx2653_pos
    .local int rx2653_off
    .local int rx2653_eos
    .local int rx2653_rep
    .local pmc rx2653_cur
    .local pmc rx2653_debug
    (rx2653_cur, rx2653_pos, rx2653_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2653_cur
    .local pmc match
    .lex "$/", match
    length rx2653_eos, rx2653_tgt
    gt rx2653_pos, rx2653_eos, rx2653_done
    set rx2653_off, 0
    lt rx2653_pos, 2, rx2653_start
    sub rx2653_off, rx2653_pos, 1
    substr rx2653_tgt, rx2653_tgt, rx2653_off
  rx2653_start:
    eq $I10, 1, rx2653_restart
    if_null rx2653_debug, debug_1553
    rx2653_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1553:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2654_done
    goto rxscan2654_scan
  rxscan2654_loop:
    (rx2653_pos) = rx2653_cur."from"()
    inc rx2653_pos
    rx2653_cur."!cursor_from"(rx2653_pos)
    ge rx2653_pos, rx2653_eos, rxscan2654_done
  rxscan2654_scan:
    set_addr $I10, rxscan2654_loop
    rx2653_cur."!mark_push"(0, rx2653_pos, $I10)
  rxscan2654_done:
.annotate 'line', 1097
  # rx subcapture "sym"
    set_addr $I10, rxcap_2655_fail
    rx2653_cur."!mark_push"(0, rx2653_pos, $I10)
  # rx literal  "le"
    add $I11, rx2653_pos, 2
    gt $I11, rx2653_eos, rx2653_fail
    sub $I11, rx2653_pos, rx2653_off
    substr $S10, rx2653_tgt, $I11, 2
    ne $S10, "le", rx2653_fail
    add rx2653_pos, 2
    set_addr $I10, rxcap_2655_fail
    ($I12, $I11) = rx2653_cur."!mark_peek"($I10)
    rx2653_cur."!cursor_pos"($I11)
    ($P10) = rx2653_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2653_pos, "")
    rx2653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2655_done
  rxcap_2655_fail:
    goto rx2653_fail
  rxcap_2655_done:
  # rx subrule "O" subtype=capture negate=
    rx2653_cur."!cursor_pos"(rx2653_pos)
    $P10 = rx2653_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2653_fail
    rx2653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2653_pos = $P10."pos"()
  # rx pass
    rx2653_cur."!cursor_pass"(rx2653_pos, "infix:sym<le>")
    if_null rx2653_debug, debug_1554
    rx2653_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2653_pos)
  debug_1554:
    .return (rx2653_cur)
  rx2653_restart:
.annotate 'line', 422
    if_null rx2653_debug, debug_1555
    rx2653_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1555:
  rx2653_fail:
    (rx2653_rep, rx2653_pos, $I10, $P10) = rx2653_cur."!mark_fail"(0)
    lt rx2653_pos, -1, rx2653_done
    eq rx2653_pos, -1, rx2653_fail
    jump $I10
  rx2653_done:
    rx2653_cur."!cursor_fail"()
    if_null rx2653_debug, debug_1556
    rx2653_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1556:
    .return (rx2653_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("372_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2657 = self."!PREFIX__!subrule"("O", "le")
    new $P2658, "ResizablePMCArray"
    push $P2658, $P2657
    .return ($P2658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("373_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2660_tgt
    .local int rx2660_pos
    .local int rx2660_off
    .local int rx2660_eos
    .local int rx2660_rep
    .local pmc rx2660_cur
    .local pmc rx2660_debug
    (rx2660_cur, rx2660_pos, rx2660_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2660_cur
    .local pmc match
    .lex "$/", match
    length rx2660_eos, rx2660_tgt
    gt rx2660_pos, rx2660_eos, rx2660_done
    set rx2660_off, 0
    lt rx2660_pos, 2, rx2660_start
    sub rx2660_off, rx2660_pos, 1
    substr rx2660_tgt, rx2660_tgt, rx2660_off
  rx2660_start:
    eq $I10, 1, rx2660_restart
    if_null rx2660_debug, debug_1557
    rx2660_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1557:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2661_done
    goto rxscan2661_scan
  rxscan2661_loop:
    (rx2660_pos) = rx2660_cur."from"()
    inc rx2660_pos
    rx2660_cur."!cursor_from"(rx2660_pos)
    ge rx2660_pos, rx2660_eos, rxscan2661_done
  rxscan2661_scan:
    set_addr $I10, rxscan2661_loop
    rx2660_cur."!mark_push"(0, rx2660_pos, $I10)
  rxscan2661_done:
.annotate 'line', 1098
  # rx subcapture "sym"
    set_addr $I10, rxcap_2662_fail
    rx2660_cur."!mark_push"(0, rx2660_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2660_pos, 2
    gt $I11, rx2660_eos, rx2660_fail
    sub $I11, rx2660_pos, rx2660_off
    substr $S10, rx2660_tgt, $I11, 2
    ne $S10, "ge", rx2660_fail
    add rx2660_pos, 2
    set_addr $I10, rxcap_2662_fail
    ($I12, $I11) = rx2660_cur."!mark_peek"($I10)
    rx2660_cur."!cursor_pos"($I11)
    ($P10) = rx2660_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2660_pos, "")
    rx2660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2662_done
  rxcap_2662_fail:
    goto rx2660_fail
  rxcap_2662_done:
  # rx subrule "O" subtype=capture negate=
    rx2660_cur."!cursor_pos"(rx2660_pos)
    $P10 = rx2660_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2660_fail
    rx2660_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2660_pos = $P10."pos"()
  # rx pass
    rx2660_cur."!cursor_pass"(rx2660_pos, "infix:sym<ge>")
    if_null rx2660_debug, debug_1558
    rx2660_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2660_pos)
  debug_1558:
    .return (rx2660_cur)
  rx2660_restart:
.annotate 'line', 422
    if_null rx2660_debug, debug_1559
    rx2660_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1559:
  rx2660_fail:
    (rx2660_rep, rx2660_pos, $I10, $P10) = rx2660_cur."!mark_fail"(0)
    lt rx2660_pos, -1, rx2660_done
    eq rx2660_pos, -1, rx2660_fail
    jump $I10
  rx2660_done:
    rx2660_cur."!cursor_fail"()
    if_null rx2660_debug, debug_1560
    rx2660_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1560:
    .return (rx2660_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("374_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2664 = self."!PREFIX__!subrule"("O", "ge")
    new $P2665, "ResizablePMCArray"
    push $P2665, $P2664
    .return ($P2665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("375_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2667_tgt
    .local int rx2667_pos
    .local int rx2667_off
    .local int rx2667_eos
    .local int rx2667_rep
    .local pmc rx2667_cur
    .local pmc rx2667_debug
    (rx2667_cur, rx2667_pos, rx2667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2667_cur
    .local pmc match
    .lex "$/", match
    length rx2667_eos, rx2667_tgt
    gt rx2667_pos, rx2667_eos, rx2667_done
    set rx2667_off, 0
    lt rx2667_pos, 2, rx2667_start
    sub rx2667_off, rx2667_pos, 1
    substr rx2667_tgt, rx2667_tgt, rx2667_off
  rx2667_start:
    eq $I10, 1, rx2667_restart
    if_null rx2667_debug, debug_1561
    rx2667_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1561:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2668_done
    goto rxscan2668_scan
  rxscan2668_loop:
    (rx2667_pos) = rx2667_cur."from"()
    inc rx2667_pos
    rx2667_cur."!cursor_from"(rx2667_pos)
    ge rx2667_pos, rx2667_eos, rxscan2668_done
  rxscan2668_scan:
    set_addr $I10, rxscan2668_loop
    rx2667_cur."!mark_push"(0, rx2667_pos, $I10)
  rxscan2668_done:
.annotate 'line', 1099
  # rx subcapture "sym"
    set_addr $I10, rxcap_2669_fail
    rx2667_cur."!mark_push"(0, rx2667_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2667_pos, 2
    gt $I11, rx2667_eos, rx2667_fail
    sub $I11, rx2667_pos, rx2667_off
    substr $S10, rx2667_tgt, $I11, 2
    ne $S10, "lt", rx2667_fail
    add rx2667_pos, 2
    set_addr $I10, rxcap_2669_fail
    ($I12, $I11) = rx2667_cur."!mark_peek"($I10)
    rx2667_cur."!cursor_pos"($I11)
    ($P10) = rx2667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2667_pos, "")
    rx2667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2669_done
  rxcap_2669_fail:
    goto rx2667_fail
  rxcap_2669_done:
  # rx subrule "O" subtype=capture negate=
    rx2667_cur."!cursor_pos"(rx2667_pos)
    $P10 = rx2667_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2667_fail
    rx2667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2667_pos = $P10."pos"()
  # rx pass
    rx2667_cur."!cursor_pass"(rx2667_pos, "infix:sym<lt>")
    if_null rx2667_debug, debug_1562
    rx2667_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2667_pos)
  debug_1562:
    .return (rx2667_cur)
  rx2667_restart:
.annotate 'line', 422
    if_null rx2667_debug, debug_1563
    rx2667_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1563:
  rx2667_fail:
    (rx2667_rep, rx2667_pos, $I10, $P10) = rx2667_cur."!mark_fail"(0)
    lt rx2667_pos, -1, rx2667_done
    eq rx2667_pos, -1, rx2667_fail
    jump $I10
  rx2667_done:
    rx2667_cur."!cursor_fail"()
    if_null rx2667_debug, debug_1564
    rx2667_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1564:
    .return (rx2667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("376_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2671 = self."!PREFIX__!subrule"("O", "lt")
    new $P2672, "ResizablePMCArray"
    push $P2672, $P2671
    .return ($P2672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("377_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2674_tgt
    .local int rx2674_pos
    .local int rx2674_off
    .local int rx2674_eos
    .local int rx2674_rep
    .local pmc rx2674_cur
    .local pmc rx2674_debug
    (rx2674_cur, rx2674_pos, rx2674_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2674_cur
    .local pmc match
    .lex "$/", match
    length rx2674_eos, rx2674_tgt
    gt rx2674_pos, rx2674_eos, rx2674_done
    set rx2674_off, 0
    lt rx2674_pos, 2, rx2674_start
    sub rx2674_off, rx2674_pos, 1
    substr rx2674_tgt, rx2674_tgt, rx2674_off
  rx2674_start:
    eq $I10, 1, rx2674_restart
    if_null rx2674_debug, debug_1565
    rx2674_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1565:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2675_done
    goto rxscan2675_scan
  rxscan2675_loop:
    (rx2674_pos) = rx2674_cur."from"()
    inc rx2674_pos
    rx2674_cur."!cursor_from"(rx2674_pos)
    ge rx2674_pos, rx2674_eos, rxscan2675_done
  rxscan2675_scan:
    set_addr $I10, rxscan2675_loop
    rx2674_cur."!mark_push"(0, rx2674_pos, $I10)
  rxscan2675_done:
.annotate 'line', 1100
  # rx subcapture "sym"
    set_addr $I10, rxcap_2676_fail
    rx2674_cur."!mark_push"(0, rx2674_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2674_pos, 2
    gt $I11, rx2674_eos, rx2674_fail
    sub $I11, rx2674_pos, rx2674_off
    substr $S10, rx2674_tgt, $I11, 2
    ne $S10, "gt", rx2674_fail
    add rx2674_pos, 2
    set_addr $I10, rxcap_2676_fail
    ($I12, $I11) = rx2674_cur."!mark_peek"($I10)
    rx2674_cur."!cursor_pos"($I11)
    ($P10) = rx2674_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2674_pos, "")
    rx2674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2676_done
  rxcap_2676_fail:
    goto rx2674_fail
  rxcap_2676_done:
  # rx subrule "O" subtype=capture negate=
    rx2674_cur."!cursor_pos"(rx2674_pos)
    $P10 = rx2674_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2674_fail
    rx2674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2674_pos = $P10."pos"()
  # rx pass
    rx2674_cur."!cursor_pass"(rx2674_pos, "infix:sym<gt>")
    if_null rx2674_debug, debug_1566
    rx2674_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2674_pos)
  debug_1566:
    .return (rx2674_cur)
  rx2674_restart:
.annotate 'line', 422
    if_null rx2674_debug, debug_1567
    rx2674_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1567:
  rx2674_fail:
    (rx2674_rep, rx2674_pos, $I10, $P10) = rx2674_cur."!mark_fail"(0)
    lt rx2674_pos, -1, rx2674_done
    eq rx2674_pos, -1, rx2674_fail
    jump $I10
  rx2674_done:
    rx2674_cur."!cursor_fail"()
    if_null rx2674_debug, debug_1568
    rx2674_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1568:
    .return (rx2674_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("378_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2678 = self."!PREFIX__!subrule"("O", "gt")
    new $P2679, "ResizablePMCArray"
    push $P2679, $P2678
    .return ($P2679)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("379_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2681_tgt
    .local int rx2681_pos
    .local int rx2681_off
    .local int rx2681_eos
    .local int rx2681_rep
    .local pmc rx2681_cur
    .local pmc rx2681_debug
    (rx2681_cur, rx2681_pos, rx2681_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2681_cur
    .local pmc match
    .lex "$/", match
    length rx2681_eos, rx2681_tgt
    gt rx2681_pos, rx2681_eos, rx2681_done
    set rx2681_off, 0
    lt rx2681_pos, 2, rx2681_start
    sub rx2681_off, rx2681_pos, 1
    substr rx2681_tgt, rx2681_tgt, rx2681_off
  rx2681_start:
    eq $I10, 1, rx2681_restart
    if_null rx2681_debug, debug_1569
    rx2681_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1569:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2682_done
    goto rxscan2682_scan
  rxscan2682_loop:
    (rx2681_pos) = rx2681_cur."from"()
    inc rx2681_pos
    rx2681_cur."!cursor_from"(rx2681_pos)
    ge rx2681_pos, rx2681_eos, rxscan2682_done
  rxscan2682_scan:
    set_addr $I10, rxscan2682_loop
    rx2681_cur."!mark_push"(0, rx2681_pos, $I10)
  rxscan2682_done:
.annotate 'line', 1101
  # rx subcapture "sym"
    set_addr $I10, rxcap_2683_fail
    rx2681_cur."!mark_push"(0, rx2681_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2681_pos, 3
    gt $I11, rx2681_eos, rx2681_fail
    sub $I11, rx2681_pos, rx2681_off
    substr $S10, rx2681_tgt, $I11, 3
    ne $S10, "=:=", rx2681_fail
    add rx2681_pos, 3
    set_addr $I10, rxcap_2683_fail
    ($I12, $I11) = rx2681_cur."!mark_peek"($I10)
    rx2681_cur."!cursor_pos"($I11)
    ($P10) = rx2681_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2681_pos, "")
    rx2681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2683_done
  rxcap_2683_fail:
    goto rx2681_fail
  rxcap_2683_done:
  # rx subrule "O" subtype=capture negate=
    rx2681_cur."!cursor_pos"(rx2681_pos)
    $P10 = rx2681_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2681_fail
    rx2681_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2681_pos = $P10."pos"()
  # rx pass
    rx2681_cur."!cursor_pass"(rx2681_pos, "infix:sym<=:=>")
    if_null rx2681_debug, debug_1570
    rx2681_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2681_pos)
  debug_1570:
    .return (rx2681_cur)
  rx2681_restart:
.annotate 'line', 422
    if_null rx2681_debug, debug_1571
    rx2681_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1571:
  rx2681_fail:
    (rx2681_rep, rx2681_pos, $I10, $P10) = rx2681_cur."!mark_fail"(0)
    lt rx2681_pos, -1, rx2681_done
    eq rx2681_pos, -1, rx2681_fail
    jump $I10
  rx2681_done:
    rx2681_cur."!cursor_fail"()
    if_null rx2681_debug, debug_1572
    rx2681_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1572:
    .return (rx2681_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("380_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2685 = self."!PREFIX__!subrule"("O", "=:=")
    new $P2686, "ResizablePMCArray"
    push $P2686, $P2685
    .return ($P2686)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("381_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2688_tgt
    .local int rx2688_pos
    .local int rx2688_off
    .local int rx2688_eos
    .local int rx2688_rep
    .local pmc rx2688_cur
    .local pmc rx2688_debug
    (rx2688_cur, rx2688_pos, rx2688_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2688_cur
    .local pmc match
    .lex "$/", match
    length rx2688_eos, rx2688_tgt
    gt rx2688_pos, rx2688_eos, rx2688_done
    set rx2688_off, 0
    lt rx2688_pos, 2, rx2688_start
    sub rx2688_off, rx2688_pos, 1
    substr rx2688_tgt, rx2688_tgt, rx2688_off
  rx2688_start:
    eq $I10, 1, rx2688_restart
    if_null rx2688_debug, debug_1573
    rx2688_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1573:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2689_done
    goto rxscan2689_scan
  rxscan2689_loop:
    (rx2688_pos) = rx2688_cur."from"()
    inc rx2688_pos
    rx2688_cur."!cursor_from"(rx2688_pos)
    ge rx2688_pos, rx2688_eos, rxscan2689_done
  rxscan2689_scan:
    set_addr $I10, rxscan2689_loop
    rx2688_cur."!mark_push"(0, rx2688_pos, $I10)
  rxscan2689_done:
.annotate 'line', 1102
  # rx subcapture "sym"
    set_addr $I10, rxcap_2690_fail
    rx2688_cur."!mark_push"(0, rx2688_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2688_pos, 2
    gt $I11, rx2688_eos, rx2688_fail
    sub $I11, rx2688_pos, rx2688_off
    substr $S10, rx2688_tgt, $I11, 2
    ne $S10, "~~", rx2688_fail
    add rx2688_pos, 2
    set_addr $I10, rxcap_2690_fail
    ($I12, $I11) = rx2688_cur."!mark_peek"($I10)
    rx2688_cur."!cursor_pos"($I11)
    ($P10) = rx2688_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2688_pos, "")
    rx2688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2690_done
  rxcap_2690_fail:
    goto rx2688_fail
  rxcap_2690_done:
  # rx subrule "O" subtype=capture negate=
    rx2688_cur."!cursor_pos"(rx2688_pos)
    $P10 = rx2688_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2688_fail
    rx2688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2688_pos = $P10."pos"()
  # rx pass
    rx2688_cur."!cursor_pass"(rx2688_pos, "infix:sym<~~>")
    if_null rx2688_debug, debug_1574
    rx2688_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2688_pos)
  debug_1574:
    .return (rx2688_cur)
  rx2688_restart:
.annotate 'line', 422
    if_null rx2688_debug, debug_1575
    rx2688_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1575:
  rx2688_fail:
    (rx2688_rep, rx2688_pos, $I10, $P10) = rx2688_cur."!mark_fail"(0)
    lt rx2688_pos, -1, rx2688_done
    eq rx2688_pos, -1, rx2688_fail
    jump $I10
  rx2688_done:
    rx2688_cur."!cursor_fail"()
    if_null rx2688_debug, debug_1576
    rx2688_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1576:
    .return (rx2688_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("382_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2692 = self."!PREFIX__!subrule"("O", "~~")
    new $P2693, "ResizablePMCArray"
    push $P2693, $P2692
    .return ($P2693)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("383_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2695_tgt
    .local int rx2695_pos
    .local int rx2695_off
    .local int rx2695_eos
    .local int rx2695_rep
    .local pmc rx2695_cur
    .local pmc rx2695_debug
    (rx2695_cur, rx2695_pos, rx2695_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2695_cur
    .local pmc match
    .lex "$/", match
    length rx2695_eos, rx2695_tgt
    gt rx2695_pos, rx2695_eos, rx2695_done
    set rx2695_off, 0
    lt rx2695_pos, 2, rx2695_start
    sub rx2695_off, rx2695_pos, 1
    substr rx2695_tgt, rx2695_tgt, rx2695_off
  rx2695_start:
    eq $I10, 1, rx2695_restart
    if_null rx2695_debug, debug_1577
    rx2695_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1577:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2696_done
    goto rxscan2696_scan
  rxscan2696_loop:
    (rx2695_pos) = rx2695_cur."from"()
    inc rx2695_pos
    rx2695_cur."!cursor_from"(rx2695_pos)
    ge rx2695_pos, rx2695_eos, rxscan2696_done
  rxscan2696_scan:
    set_addr $I10, rxscan2696_loop
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
  rxscan2696_done:
.annotate 'line', 1104
  # rx subcapture "sym"
    set_addr $I10, rxcap_2697_fail
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2695_pos, 2
    gt $I11, rx2695_eos, rx2695_fail
    sub $I11, rx2695_pos, rx2695_off
    substr $S10, rx2695_tgt, $I11, 2
    ne $S10, "&&", rx2695_fail
    add rx2695_pos, 2
    set_addr $I10, rxcap_2697_fail
    ($I12, $I11) = rx2695_cur."!mark_peek"($I10)
    rx2695_cur."!cursor_pos"($I11)
    ($P10) = rx2695_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2695_pos, "")
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2697_done
  rxcap_2697_fail:
    goto rx2695_fail
  rxcap_2697_done:
  # rx subrule "O" subtype=capture negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2695_fail
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2695_pos = $P10."pos"()
  # rx pass
    rx2695_cur."!cursor_pass"(rx2695_pos, "infix:sym<&&>")
    if_null rx2695_debug, debug_1578
    rx2695_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2695_pos)
  debug_1578:
    .return (rx2695_cur)
  rx2695_restart:
.annotate 'line', 422
    if_null rx2695_debug, debug_1579
    rx2695_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1579:
  rx2695_fail:
    (rx2695_rep, rx2695_pos, $I10, $P10) = rx2695_cur."!mark_fail"(0)
    lt rx2695_pos, -1, rx2695_done
    eq rx2695_pos, -1, rx2695_fail
    jump $I10
  rx2695_done:
    rx2695_cur."!cursor_fail"()
    if_null rx2695_debug, debug_1580
    rx2695_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1580:
    .return (rx2695_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("384_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2699 = self."!PREFIX__!subrule"("O", "&&")
    new $P2700, "ResizablePMCArray"
    push $P2700, $P2699
    .return ($P2700)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("385_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2702_tgt
    .local int rx2702_pos
    .local int rx2702_off
    .local int rx2702_eos
    .local int rx2702_rep
    .local pmc rx2702_cur
    .local pmc rx2702_debug
    (rx2702_cur, rx2702_pos, rx2702_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2702_cur
    .local pmc match
    .lex "$/", match
    length rx2702_eos, rx2702_tgt
    gt rx2702_pos, rx2702_eos, rx2702_done
    set rx2702_off, 0
    lt rx2702_pos, 2, rx2702_start
    sub rx2702_off, rx2702_pos, 1
    substr rx2702_tgt, rx2702_tgt, rx2702_off
  rx2702_start:
    eq $I10, 1, rx2702_restart
    if_null rx2702_debug, debug_1581
    rx2702_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1581:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2703_done
    goto rxscan2703_scan
  rxscan2703_loop:
    (rx2702_pos) = rx2702_cur."from"()
    inc rx2702_pos
    rx2702_cur."!cursor_from"(rx2702_pos)
    ge rx2702_pos, rx2702_eos, rxscan2703_done
  rxscan2703_scan:
    set_addr $I10, rxscan2703_loop
    rx2702_cur."!mark_push"(0, rx2702_pos, $I10)
  rxscan2703_done:
.annotate 'line', 1106
  # rx subcapture "sym"
    set_addr $I10, rxcap_2704_fail
    rx2702_cur."!mark_push"(0, rx2702_pos, $I10)
  # rx literal  "||"
    add $I11, rx2702_pos, 2
    gt $I11, rx2702_eos, rx2702_fail
    sub $I11, rx2702_pos, rx2702_off
    substr $S10, rx2702_tgt, $I11, 2
    ne $S10, "||", rx2702_fail
    add rx2702_pos, 2
    set_addr $I10, rxcap_2704_fail
    ($I12, $I11) = rx2702_cur."!mark_peek"($I10)
    rx2702_cur."!cursor_pos"($I11)
    ($P10) = rx2702_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2702_pos, "")
    rx2702_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2704_done
  rxcap_2704_fail:
    goto rx2702_fail
  rxcap_2704_done:
  # rx subrule "O" subtype=capture negate=
    rx2702_cur."!cursor_pos"(rx2702_pos)
    $P10 = rx2702_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2702_fail
    rx2702_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2702_pos = $P10."pos"()
  # rx pass
    rx2702_cur."!cursor_pass"(rx2702_pos, "infix:sym<||>")
    if_null rx2702_debug, debug_1582
    rx2702_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2702_pos)
  debug_1582:
    .return (rx2702_cur)
  rx2702_restart:
.annotate 'line', 422
    if_null rx2702_debug, debug_1583
    rx2702_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1583:
  rx2702_fail:
    (rx2702_rep, rx2702_pos, $I10, $P10) = rx2702_cur."!mark_fail"(0)
    lt rx2702_pos, -1, rx2702_done
    eq rx2702_pos, -1, rx2702_fail
    jump $I10
  rx2702_done:
    rx2702_cur."!cursor_fail"()
    if_null rx2702_debug, debug_1584
    rx2702_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1584:
    .return (rx2702_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("386_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2706 = self."!PREFIX__!subrule"("O", "||")
    new $P2707, "ResizablePMCArray"
    push $P2707, $P2706
    .return ($P2707)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("387_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2709_tgt
    .local int rx2709_pos
    .local int rx2709_off
    .local int rx2709_eos
    .local int rx2709_rep
    .local pmc rx2709_cur
    .local pmc rx2709_debug
    (rx2709_cur, rx2709_pos, rx2709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2709_cur
    .local pmc match
    .lex "$/", match
    length rx2709_eos, rx2709_tgt
    gt rx2709_pos, rx2709_eos, rx2709_done
    set rx2709_off, 0
    lt rx2709_pos, 2, rx2709_start
    sub rx2709_off, rx2709_pos, 1
    substr rx2709_tgt, rx2709_tgt, rx2709_off
  rx2709_start:
    eq $I10, 1, rx2709_restart
    if_null rx2709_debug, debug_1585
    rx2709_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1585:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2710_done
    goto rxscan2710_scan
  rxscan2710_loop:
    (rx2709_pos) = rx2709_cur."from"()
    inc rx2709_pos
    rx2709_cur."!cursor_from"(rx2709_pos)
    ge rx2709_pos, rx2709_eos, rxscan2710_done
  rxscan2710_scan:
    set_addr $I10, rxscan2710_loop
    rx2709_cur."!mark_push"(0, rx2709_pos, $I10)
  rxscan2710_done:
.annotate 'line', 1107
  # rx subcapture "sym"
    set_addr $I10, rxcap_2711_fail
    rx2709_cur."!mark_push"(0, rx2709_pos, $I10)
  # rx literal  "//"
    add $I11, rx2709_pos, 2
    gt $I11, rx2709_eos, rx2709_fail
    sub $I11, rx2709_pos, rx2709_off
    substr $S10, rx2709_tgt, $I11, 2
    ne $S10, "//", rx2709_fail
    add rx2709_pos, 2
    set_addr $I10, rxcap_2711_fail
    ($I12, $I11) = rx2709_cur."!mark_peek"($I10)
    rx2709_cur."!cursor_pos"($I11)
    ($P10) = rx2709_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2709_pos, "")
    rx2709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2711_done
  rxcap_2711_fail:
    goto rx2709_fail
  rxcap_2711_done:
  # rx subrule "O" subtype=capture negate=
    rx2709_cur."!cursor_pos"(rx2709_pos)
    $P10 = rx2709_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2709_fail
    rx2709_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2709_pos = $P10."pos"()
  # rx pass
    rx2709_cur."!cursor_pass"(rx2709_pos, "infix:sym<//>")
    if_null rx2709_debug, debug_1586
    rx2709_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2709_pos)
  debug_1586:
    .return (rx2709_cur)
  rx2709_restart:
.annotate 'line', 422
    if_null rx2709_debug, debug_1587
    rx2709_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1587:
  rx2709_fail:
    (rx2709_rep, rx2709_pos, $I10, $P10) = rx2709_cur."!mark_fail"(0)
    lt rx2709_pos, -1, rx2709_done
    eq rx2709_pos, -1, rx2709_fail
    jump $I10
  rx2709_done:
    rx2709_cur."!cursor_fail"()
    if_null rx2709_debug, debug_1588
    rx2709_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1588:
    .return (rx2709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("388_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2713 = self."!PREFIX__!subrule"("O", "//")
    new $P2714, "ResizablePMCArray"
    push $P2714, $P2713
    .return ($P2714)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("389_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2716_tgt
    .local int rx2716_pos
    .local int rx2716_off
    .local int rx2716_eos
    .local int rx2716_rep
    .local pmc rx2716_cur
    .local pmc rx2716_debug
    (rx2716_cur, rx2716_pos, rx2716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2716_cur
    .local pmc match
    .lex "$/", match
    length rx2716_eos, rx2716_tgt
    gt rx2716_pos, rx2716_eos, rx2716_done
    set rx2716_off, 0
    lt rx2716_pos, 2, rx2716_start
    sub rx2716_off, rx2716_pos, 1
    substr rx2716_tgt, rx2716_tgt, rx2716_off
  rx2716_start:
    eq $I10, 1, rx2716_restart
    if_null rx2716_debug, debug_1589
    rx2716_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1589:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2717_done
    goto rxscan2717_scan
  rxscan2717_loop:
    (rx2716_pos) = rx2716_cur."from"()
    inc rx2716_pos
    rx2716_cur."!cursor_from"(rx2716_pos)
    ge rx2716_pos, rx2716_eos, rxscan2717_done
  rxscan2717_scan:
    set_addr $I10, rxscan2717_loop
    rx2716_cur."!mark_push"(0, rx2716_pos, $I10)
  rxscan2717_done:
.annotate 'line', 1110
  # rx literal  "??"
    add $I11, rx2716_pos, 2
    gt $I11, rx2716_eos, rx2716_fail
    sub $I11, rx2716_pos, rx2716_off
    substr $S10, rx2716_tgt, $I11, 2
    ne $S10, "??", rx2716_fail
    add rx2716_pos, 2
.annotate 'line', 1111
  # rx subrule "ws" subtype=method negate=
    rx2716_cur."!cursor_pos"(rx2716_pos)
    $P10 = rx2716_cur."ws"()
    unless $P10, rx2716_fail
    rx2716_pos = $P10."pos"()
.annotate 'line', 1112
  # rx subrule "EXPR" subtype=capture negate=
    rx2716_cur."!cursor_pos"(rx2716_pos)
    $P10 = rx2716_cur."EXPR"("i=")
    unless $P10, rx2716_fail
    rx2716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2716_pos = $P10."pos"()
.annotate 'line', 1113
  # rx literal  "!!"
    add $I11, rx2716_pos, 2
    gt $I11, rx2716_eos, rx2716_fail
    sub $I11, rx2716_pos, rx2716_off
    substr $S10, rx2716_tgt, $I11, 2
    ne $S10, "!!", rx2716_fail
    add rx2716_pos, 2
.annotate 'line', 1114
  # rx subrule "O" subtype=capture negate=
    rx2716_cur."!cursor_pos"(rx2716_pos)
    $P10 = rx2716_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2716_fail
    rx2716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2716_pos = $P10."pos"()
.annotate 'line', 1109
  # rx pass
    rx2716_cur."!cursor_pass"(rx2716_pos, "infix:sym<?? !!>")
    if_null rx2716_debug, debug_1590
    rx2716_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2716_pos)
  debug_1590:
    .return (rx2716_cur)
  rx2716_restart:
.annotate 'line', 422
    if_null rx2716_debug, debug_1591
    rx2716_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1591:
  rx2716_fail:
    (rx2716_rep, rx2716_pos, $I10, $P10) = rx2716_cur."!mark_fail"(0)
    lt rx2716_pos, -1, rx2716_done
    eq rx2716_pos, -1, rx2716_fail
    jump $I10
  rx2716_done:
    rx2716_cur."!cursor_fail"()
    if_null rx2716_debug, debug_1592
    rx2716_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1592:
    .return (rx2716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("390_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2719 = self."!PREFIX__!subrule"("ws", "??")
    new $P2720, "ResizablePMCArray"
    push $P2720, $P2719
    .return ($P2720)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("391_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2722_tgt
    .local int rx2722_pos
    .local int rx2722_off
    .local int rx2722_eos
    .local int rx2722_rep
    .local pmc rx2722_cur
    .local pmc rx2722_debug
    (rx2722_cur, rx2722_pos, rx2722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2722_cur
    .local pmc match
    .lex "$/", match
    length rx2722_eos, rx2722_tgt
    gt rx2722_pos, rx2722_eos, rx2722_done
    set rx2722_off, 0
    lt rx2722_pos, 2, rx2722_start
    sub rx2722_off, rx2722_pos, 1
    substr rx2722_tgt, rx2722_tgt, rx2722_off
  rx2722_start:
    eq $I10, 1, rx2722_restart
    if_null rx2722_debug, debug_1593
    rx2722_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1593:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2723_done
    goto rxscan2723_scan
  rxscan2723_loop:
    (rx2722_pos) = rx2722_cur."from"()
    inc rx2722_pos
    rx2722_cur."!cursor_from"(rx2722_pos)
    ge rx2722_pos, rx2722_eos, rxscan2723_done
  rxscan2723_scan:
    set_addr $I10, rxscan2723_loop
    rx2722_cur."!mark_push"(0, rx2722_pos, $I10)
  rxscan2723_done:
.annotate 'line', 1118
  # rx subcapture "sym"
    set_addr $I10, rxcap_2724_fail
    rx2722_cur."!mark_push"(0, rx2722_pos, $I10)
  # rx literal  "="
    add $I11, rx2722_pos, 1
    gt $I11, rx2722_eos, rx2722_fail
    sub $I11, rx2722_pos, rx2722_off
    ord $I11, rx2722_tgt, $I11
    ne $I11, 61, rx2722_fail
    add rx2722_pos, 1
    set_addr $I10, rxcap_2724_fail
    ($I12, $I11) = rx2722_cur."!mark_peek"($I10)
    rx2722_cur."!cursor_pos"($I11)
    ($P10) = rx2722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2722_pos, "")
    rx2722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2724_done
  rxcap_2724_fail:
    goto rx2722_fail
  rxcap_2724_done:
  # rx subrule "panic" subtype=method negate=
    rx2722_cur."!cursor_pos"(rx2722_pos)
    $P10 = rx2722_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2722_fail
    rx2722_pos = $P10."pos"()
.annotate 'line', 1117
  # rx pass
    rx2722_cur."!cursor_pass"(rx2722_pos, "infix:sym<=>")
    if_null rx2722_debug, debug_1594
    rx2722_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2722_pos)
  debug_1594:
    .return (rx2722_cur)
  rx2722_restart:
.annotate 'line', 422
    if_null rx2722_debug, debug_1595
    rx2722_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1595:
  rx2722_fail:
    (rx2722_rep, rx2722_pos, $I10, $P10) = rx2722_cur."!mark_fail"(0)
    lt rx2722_pos, -1, rx2722_done
    eq rx2722_pos, -1, rx2722_fail
    jump $I10
  rx2722_done:
    rx2722_cur."!cursor_fail"()
    if_null rx2722_debug, debug_1596
    rx2722_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1596:
    .return (rx2722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("392_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2726 = self."!PREFIX__!subrule"("panic", "=")
    new $P2727, "ResizablePMCArray"
    push $P2727, $P2726
    .return ($P2727)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("393_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2729_tgt
    .local int rx2729_pos
    .local int rx2729_off
    .local int rx2729_eos
    .local int rx2729_rep
    .local pmc rx2729_cur
    .local pmc rx2729_debug
    (rx2729_cur, rx2729_pos, rx2729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2729_cur
    .local pmc match
    .lex "$/", match
    length rx2729_eos, rx2729_tgt
    gt rx2729_pos, rx2729_eos, rx2729_done
    set rx2729_off, 0
    lt rx2729_pos, 2, rx2729_start
    sub rx2729_off, rx2729_pos, 1
    substr rx2729_tgt, rx2729_tgt, rx2729_off
  rx2729_start:
    eq $I10, 1, rx2729_restart
    if_null rx2729_debug, debug_1597
    rx2729_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1597:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2730_done
    goto rxscan2730_scan
  rxscan2730_loop:
    (rx2729_pos) = rx2729_cur."from"()
    inc rx2729_pos
    rx2729_cur."!cursor_from"(rx2729_pos)
    ge rx2729_pos, rx2729_eos, rxscan2730_done
  rxscan2730_scan:
    set_addr $I10, rxscan2730_loop
    rx2729_cur."!mark_push"(0, rx2729_pos, $I10)
  rxscan2730_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2731_fail
    rx2729_cur."!mark_push"(0, rx2729_pos, $I10)
  # rx literal  ":="
    add $I11, rx2729_pos, 2
    gt $I11, rx2729_eos, rx2729_fail
    sub $I11, rx2729_pos, rx2729_off
    substr $S10, rx2729_tgt, $I11, 2
    ne $S10, ":=", rx2729_fail
    add rx2729_pos, 2
    set_addr $I10, rxcap_2731_fail
    ($I12, $I11) = rx2729_cur."!mark_peek"($I10)
    rx2729_cur."!cursor_pos"($I11)
    ($P10) = rx2729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2729_pos, "")
    rx2729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2731_done
  rxcap_2731_fail:
    goto rx2729_fail
  rxcap_2731_done:
  # rx subrule "O" subtype=capture negate=
    rx2729_cur."!cursor_pos"(rx2729_pos)
    $P10 = rx2729_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2729_fail
    rx2729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2729_pos = $P10."pos"()
  # rx pass
    rx2729_cur."!cursor_pass"(rx2729_pos, "infix:sym<:=>")
    if_null rx2729_debug, debug_1598
    rx2729_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2729_pos)
  debug_1598:
    .return (rx2729_cur)
  rx2729_restart:
.annotate 'line', 422
    if_null rx2729_debug, debug_1599
    rx2729_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1599:
  rx2729_fail:
    (rx2729_rep, rx2729_pos, $I10, $P10) = rx2729_cur."!mark_fail"(0)
    lt rx2729_pos, -1, rx2729_done
    eq rx2729_pos, -1, rx2729_fail
    jump $I10
  rx2729_done:
    rx2729_cur."!cursor_fail"()
    if_null rx2729_debug, debug_1600
    rx2729_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1600:
    .return (rx2729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("394_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2733 = self."!PREFIX__!subrule"("O", ":=")
    new $P2734, "ResizablePMCArray"
    push $P2734, $P2733
    .return ($P2734)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("395_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2736_tgt
    .local int rx2736_pos
    .local int rx2736_off
    .local int rx2736_eos
    .local int rx2736_rep
    .local pmc rx2736_cur
    .local pmc rx2736_debug
    (rx2736_cur, rx2736_pos, rx2736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2736_cur
    .local pmc match
    .lex "$/", match
    length rx2736_eos, rx2736_tgt
    gt rx2736_pos, rx2736_eos, rx2736_done
    set rx2736_off, 0
    lt rx2736_pos, 2, rx2736_start
    sub rx2736_off, rx2736_pos, 1
    substr rx2736_tgt, rx2736_tgt, rx2736_off
  rx2736_start:
    eq $I10, 1, rx2736_restart
    if_null rx2736_debug, debug_1601
    rx2736_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1601:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2737_done
    goto rxscan2737_scan
  rxscan2737_loop:
    (rx2736_pos) = rx2736_cur."from"()
    inc rx2736_pos
    rx2736_cur."!cursor_from"(rx2736_pos)
    ge rx2736_pos, rx2736_eos, rxscan2737_done
  rxscan2737_scan:
    set_addr $I10, rxscan2737_loop
    rx2736_cur."!mark_push"(0, rx2736_pos, $I10)
  rxscan2737_done:
.annotate 'line', 1121
  # rx subcapture "sym"
    set_addr $I10, rxcap_2738_fail
    rx2736_cur."!mark_push"(0, rx2736_pos, $I10)
  # rx literal  "::="
    add $I11, rx2736_pos, 3
    gt $I11, rx2736_eos, rx2736_fail
    sub $I11, rx2736_pos, rx2736_off
    substr $S10, rx2736_tgt, $I11, 3
    ne $S10, "::=", rx2736_fail
    add rx2736_pos, 3
    set_addr $I10, rxcap_2738_fail
    ($I12, $I11) = rx2736_cur."!mark_peek"($I10)
    rx2736_cur."!cursor_pos"($I11)
    ($P10) = rx2736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2736_pos, "")
    rx2736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2738_done
  rxcap_2738_fail:
    goto rx2736_fail
  rxcap_2738_done:
  # rx subrule "O" subtype=capture negate=
    rx2736_cur."!cursor_pos"(rx2736_pos)
    $P10 = rx2736_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx2736_fail
    rx2736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2736_pos = $P10."pos"()
  # rx pass
    rx2736_cur."!cursor_pass"(rx2736_pos, "infix:sym<::=>")
    if_null rx2736_debug, debug_1602
    rx2736_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2736_pos)
  debug_1602:
    .return (rx2736_cur)
  rx2736_restart:
.annotate 'line', 422
    if_null rx2736_debug, debug_1603
    rx2736_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1603:
  rx2736_fail:
    (rx2736_rep, rx2736_pos, $I10, $P10) = rx2736_cur."!mark_fail"(0)
    lt rx2736_pos, -1, rx2736_done
    eq rx2736_pos, -1, rx2736_fail
    jump $I10
  rx2736_done:
    rx2736_cur."!cursor_fail"()
    if_null rx2736_debug, debug_1604
    rx2736_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1604:
    .return (rx2736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("396_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2740 = self."!PREFIX__!subrule"("O", "::=")
    new $P2741, "ResizablePMCArray"
    push $P2741, $P2740
    .return ($P2741)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("397_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2743_tgt
    .local int rx2743_pos
    .local int rx2743_off
    .local int rx2743_eos
    .local int rx2743_rep
    .local pmc rx2743_cur
    .local pmc rx2743_debug
    (rx2743_cur, rx2743_pos, rx2743_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2743_cur
    .local pmc match
    .lex "$/", match
    length rx2743_eos, rx2743_tgt
    gt rx2743_pos, rx2743_eos, rx2743_done
    set rx2743_off, 0
    lt rx2743_pos, 2, rx2743_start
    sub rx2743_off, rx2743_pos, 1
    substr rx2743_tgt, rx2743_tgt, rx2743_off
  rx2743_start:
    eq $I10, 1, rx2743_restart
    if_null rx2743_debug, debug_1605
    rx2743_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1605:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2744_done
    goto rxscan2744_scan
  rxscan2744_loop:
    (rx2743_pos) = rx2743_cur."from"()
    inc rx2743_pos
    rx2743_cur."!cursor_from"(rx2743_pos)
    ge rx2743_pos, rx2743_eos, rxscan2744_done
  rxscan2744_scan:
    set_addr $I10, rxscan2744_loop
    rx2743_cur."!mark_push"(0, rx2743_pos, $I10)
  rxscan2744_done:
.annotate 'line', 1123
  # rx subcapture "sym"
    set_addr $I10, rxcap_2745_fail
    rx2743_cur."!mark_push"(0, rx2743_pos, $I10)
  # rx literal  ","
    add $I11, rx2743_pos, 1
    gt $I11, rx2743_eos, rx2743_fail
    sub $I11, rx2743_pos, rx2743_off
    ord $I11, rx2743_tgt, $I11
    ne $I11, 44, rx2743_fail
    add rx2743_pos, 1
    set_addr $I10, rxcap_2745_fail
    ($I12, $I11) = rx2743_cur."!mark_peek"($I10)
    rx2743_cur."!cursor_pos"($I11)
    ($P10) = rx2743_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2743_pos, "")
    rx2743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2745_done
  rxcap_2745_fail:
    goto rx2743_fail
  rxcap_2745_done:
  # rx subrule "O" subtype=capture negate=
    rx2743_cur."!cursor_pos"(rx2743_pos)
    $P10 = rx2743_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2743_fail
    rx2743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2743_pos = $P10."pos"()
  # rx pass
    rx2743_cur."!cursor_pass"(rx2743_pos, "infix:sym<,>")
    if_null rx2743_debug, debug_1606
    rx2743_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2743_pos)
  debug_1606:
    .return (rx2743_cur)
  rx2743_restart:
.annotate 'line', 422
    if_null rx2743_debug, debug_1607
    rx2743_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1607:
  rx2743_fail:
    (rx2743_rep, rx2743_pos, $I10, $P10) = rx2743_cur."!mark_fail"(0)
    lt rx2743_pos, -1, rx2743_done
    eq rx2743_pos, -1, rx2743_fail
    jump $I10
  rx2743_done:
    rx2743_cur."!cursor_fail"()
    if_null rx2743_debug, debug_1608
    rx2743_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1608:
    .return (rx2743_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("398_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    $P2747 = self."!PREFIX__!subrule"("O", ",")
    new $P2748, "ResizablePMCArray"
    push $P2748, $P2747
    .return ($P2748)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("399_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .const 'Sub' $P2756 = "400_1304523757.895" 
    capture_lex $P2756
    .local string rx2750_tgt
    .local int rx2750_pos
    .local int rx2750_off
    .local int rx2750_eos
    .local int rx2750_rep
    .local pmc rx2750_cur
    .local pmc rx2750_debug
    (rx2750_cur, rx2750_pos, rx2750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2750_cur
    .local pmc match
    .lex "$/", match
    length rx2750_eos, rx2750_tgt
    gt rx2750_pos, rx2750_eos, rx2750_done
    set rx2750_off, 0
    lt rx2750_pos, 2, rx2750_start
    sub rx2750_off, rx2750_pos, 1
    substr rx2750_tgt, rx2750_tgt, rx2750_off
  rx2750_start:
    eq $I10, 1, rx2750_restart
    if_null rx2750_debug, debug_1609
    rx2750_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1609:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2751_done
    goto rxscan2751_scan
  rxscan2751_loop:
    (rx2750_pos) = rx2750_cur."from"()
    inc rx2750_pos
    rx2750_cur."!cursor_from"(rx2750_pos)
    ge rx2750_pos, rx2750_eos, rxscan2751_done
  rxscan2751_scan:
    set_addr $I10, rxscan2751_loop
    rx2750_cur."!mark_push"(0, rx2750_pos, $I10)
  rxscan2751_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2752_fail
    rx2750_cur."!mark_push"(0, rx2750_pos, $I10)
  # rx literal  "return"
    add $I11, rx2750_pos, 6
    gt $I11, rx2750_eos, rx2750_fail
    sub $I11, rx2750_pos, rx2750_off
    substr $S10, rx2750_tgt, $I11, 6
    ne $S10, "return", rx2750_fail
    add rx2750_pos, 6
    set_addr $I10, rxcap_2752_fail
    ($I12, $I11) = rx2750_cur."!mark_peek"($I10)
    rx2750_cur."!cursor_pos"($I11)
    ($P10) = rx2750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2750_pos, "")
    rx2750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2752_done
  rxcap_2752_fail:
    goto rx2750_fail
  rxcap_2752_done:
  # rx charclass s
    ge rx2750_pos, rx2750_eos, rx2750_fail
    sub $I10, rx2750_pos, rx2750_off
    is_cclass $I11, 32, rx2750_tgt, $I10
    unless $I11, rx2750_fail
    inc rx2750_pos
  # rx subrule "O" subtype=capture negate=
    rx2750_cur."!cursor_pos"(rx2750_pos)
    $P10 = rx2750_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2750_fail
    rx2750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2750_pos = $P10."pos"()
    rx2750_cur."!cursor_pos"(rx2750_pos)
    find_lex $P2753, unicode:"$\x{a2}"
    $P2754 = $P2753."MATCH"()
    store_lex "$/", $P2754
    .const 'Sub' $P2756 = "400_1304523757.895" 
    capture_lex $P2756
    $P2758 = $P2756()
  # rx pass
    rx2750_cur."!cursor_pass"(rx2750_pos, "prefix:sym<return>")
    if_null rx2750_debug, debug_1610
    rx2750_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2750_pos)
  debug_1610:
    .return (rx2750_cur)
  rx2750_restart:
.annotate 'line', 422
    if_null rx2750_debug, debug_1611
    rx2750_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1611:
  rx2750_fail:
    (rx2750_rep, rx2750_pos, $I10, $P10) = rx2750_cur."!mark_fail"(0)
    lt rx2750_pos, -1, rx2750_done
    eq rx2750_pos, -1, rx2750_fail
    jump $I10
  rx2750_done:
    rx2750_cur."!cursor_fail"()
    if_null rx2750_debug, debug_1612
    rx2750_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1612:
    .return (rx2750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2755"  :anon :subid("400_1304523757.895") :outer("399_1304523757.895")
.annotate 'line', 1125
    new $P2757, "Integer"
    assign $P2757, 1
    store_dynamic_lex "$*RETURN_USED", $P2757
    .return ($P2757)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("401_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2760, "ResizablePMCArray"
    push $P2760, "return"
    .return ($P2760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("402_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2762_tgt
    .local int rx2762_pos
    .local int rx2762_off
    .local int rx2762_eos
    .local int rx2762_rep
    .local pmc rx2762_cur
    .local pmc rx2762_debug
    (rx2762_cur, rx2762_pos, rx2762_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2762_cur
    .local pmc match
    .lex "$/", match
    length rx2762_eos, rx2762_tgt
    gt rx2762_pos, rx2762_eos, rx2762_done
    set rx2762_off, 0
    lt rx2762_pos, 2, rx2762_start
    sub rx2762_off, rx2762_pos, 1
    substr rx2762_tgt, rx2762_tgt, rx2762_off
  rx2762_start:
    eq $I10, 1, rx2762_restart
    if_null rx2762_debug, debug_1613
    rx2762_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1613:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2763_done
    goto rxscan2763_scan
  rxscan2763_loop:
    (rx2762_pos) = rx2762_cur."from"()
    inc rx2762_pos
    rx2762_cur."!cursor_from"(rx2762_pos)
    ge rx2762_pos, rx2762_eos, rxscan2763_done
  rxscan2763_scan:
    set_addr $I10, rxscan2763_loop
    rx2762_cur."!mark_push"(0, rx2762_pos, $I10)
  rxscan2763_done:
.annotate 'line', 1126
  # rx subcapture "sym"
    set_addr $I10, rxcap_2764_fail
    rx2762_cur."!mark_push"(0, rx2762_pos, $I10)
  # rx literal  "make"
    add $I11, rx2762_pos, 4
    gt $I11, rx2762_eos, rx2762_fail
    sub $I11, rx2762_pos, rx2762_off
    substr $S10, rx2762_tgt, $I11, 4
    ne $S10, "make", rx2762_fail
    add rx2762_pos, 4
    set_addr $I10, rxcap_2764_fail
    ($I12, $I11) = rx2762_cur."!mark_peek"($I10)
    rx2762_cur."!cursor_pos"($I11)
    ($P10) = rx2762_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2762_pos, "")
    rx2762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2764_done
  rxcap_2764_fail:
    goto rx2762_fail
  rxcap_2764_done:
  # rx charclass s
    ge rx2762_pos, rx2762_eos, rx2762_fail
    sub $I10, rx2762_pos, rx2762_off
    is_cclass $I11, 32, rx2762_tgt, $I10
    unless $I11, rx2762_fail
    inc rx2762_pos
  # rx subrule "O" subtype=capture negate=
    rx2762_cur."!cursor_pos"(rx2762_pos)
    $P10 = rx2762_cur."O"("%list_prefix")
    unless $P10, rx2762_fail
    rx2762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2762_pos = $P10."pos"()
  # rx pass
    rx2762_cur."!cursor_pass"(rx2762_pos, "prefix:sym<make>")
    if_null rx2762_debug, debug_1614
    rx2762_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2762_pos)
  debug_1614:
    .return (rx2762_cur)
  rx2762_restart:
.annotate 'line', 422
    if_null rx2762_debug, debug_1615
    rx2762_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1615:
  rx2762_fail:
    (rx2762_rep, rx2762_pos, $I10, $P10) = rx2762_cur."!mark_fail"(0)
    lt rx2762_pos, -1, rx2762_done
    eq rx2762_pos, -1, rx2762_fail
    jump $I10
  rx2762_done:
    rx2762_cur."!cursor_fail"()
    if_null rx2762_debug, debug_1616
    rx2762_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1616:
    .return (rx2762_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("403_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2766, "ResizablePMCArray"
    push $P2766, "make"
    .return ($P2766)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("404_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2768_tgt
    .local int rx2768_pos
    .local int rx2768_off
    .local int rx2768_eos
    .local int rx2768_rep
    .local pmc rx2768_cur
    .local pmc rx2768_debug
    (rx2768_cur, rx2768_pos, rx2768_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2768_cur
    .local pmc match
    .lex "$/", match
    length rx2768_eos, rx2768_tgt
    gt rx2768_pos, rx2768_eos, rx2768_done
    set rx2768_off, 0
    lt rx2768_pos, 2, rx2768_start
    sub rx2768_off, rx2768_pos, 1
    substr rx2768_tgt, rx2768_tgt, rx2768_off
  rx2768_start:
    eq $I10, 1, rx2768_restart
    if_null rx2768_debug, debug_1617
    rx2768_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2769_done
    goto rxscan2769_scan
  rxscan2769_loop:
    (rx2768_pos) = rx2768_cur."from"()
    inc rx2768_pos
    rx2768_cur."!cursor_from"(rx2768_pos)
    ge rx2768_pos, rx2768_eos, rxscan2769_done
  rxscan2769_scan:
    set_addr $I10, rxscan2769_loop
    rx2768_cur."!mark_push"(0, rx2768_pos, $I10)
  rxscan2769_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2770_fail
    rx2768_cur."!mark_push"(0, rx2768_pos, $I10)
  # rx literal  "last"
    add $I11, rx2768_pos, 4
    gt $I11, rx2768_eos, rx2768_fail
    sub $I11, rx2768_pos, rx2768_off
    substr $S10, rx2768_tgt, $I11, 4
    ne $S10, "last", rx2768_fail
    add rx2768_pos, 4
    set_addr $I10, rxcap_2770_fail
    ($I12, $I11) = rx2768_cur."!mark_peek"($I10)
    rx2768_cur."!cursor_pos"($I11)
    ($P10) = rx2768_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2768_pos, "")
    rx2768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2770_done
  rxcap_2770_fail:
    goto rx2768_fail
  rxcap_2770_done:
  # rx pass
    rx2768_cur."!cursor_pass"(rx2768_pos, "term:sym<last>")
    if_null rx2768_debug, debug_1618
    rx2768_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2768_pos)
  debug_1618:
    .return (rx2768_cur)
  rx2768_restart:
.annotate 'line', 422
    if_null rx2768_debug, debug_1619
    rx2768_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1619:
  rx2768_fail:
    (rx2768_rep, rx2768_pos, $I10, $P10) = rx2768_cur."!mark_fail"(0)
    lt rx2768_pos, -1, rx2768_done
    eq rx2768_pos, -1, rx2768_fail
    jump $I10
  rx2768_done:
    rx2768_cur."!cursor_fail"()
    if_null rx2768_debug, debug_1620
    rx2768_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1620:
    .return (rx2768_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("405_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2772, "ResizablePMCArray"
    push $P2772, "last"
    .return ($P2772)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("406_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2774_tgt
    .local int rx2774_pos
    .local int rx2774_off
    .local int rx2774_eos
    .local int rx2774_rep
    .local pmc rx2774_cur
    .local pmc rx2774_debug
    (rx2774_cur, rx2774_pos, rx2774_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2774_cur
    .local pmc match
    .lex "$/", match
    length rx2774_eos, rx2774_tgt
    gt rx2774_pos, rx2774_eos, rx2774_done
    set rx2774_off, 0
    lt rx2774_pos, 2, rx2774_start
    sub rx2774_off, rx2774_pos, 1
    substr rx2774_tgt, rx2774_tgt, rx2774_off
  rx2774_start:
    eq $I10, 1, rx2774_restart
    if_null rx2774_debug, debug_1621
    rx2774_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2775_done
    goto rxscan2775_scan
  rxscan2775_loop:
    (rx2774_pos) = rx2774_cur."from"()
    inc rx2774_pos
    rx2774_cur."!cursor_from"(rx2774_pos)
    ge rx2774_pos, rx2774_eos, rxscan2775_done
  rxscan2775_scan:
    set_addr $I10, rxscan2775_loop
    rx2774_cur."!mark_push"(0, rx2774_pos, $I10)
  rxscan2775_done:
.annotate 'line', 1128
  # rx subcapture "sym"
    set_addr $I10, rxcap_2776_fail
    rx2774_cur."!mark_push"(0, rx2774_pos, $I10)
  # rx literal  "next"
    add $I11, rx2774_pos, 4
    gt $I11, rx2774_eos, rx2774_fail
    sub $I11, rx2774_pos, rx2774_off
    substr $S10, rx2774_tgt, $I11, 4
    ne $S10, "next", rx2774_fail
    add rx2774_pos, 4
    set_addr $I10, rxcap_2776_fail
    ($I12, $I11) = rx2774_cur."!mark_peek"($I10)
    rx2774_cur."!cursor_pos"($I11)
    ($P10) = rx2774_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2774_pos, "")
    rx2774_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2776_done
  rxcap_2776_fail:
    goto rx2774_fail
  rxcap_2776_done:
  # rx pass
    rx2774_cur."!cursor_pass"(rx2774_pos, "term:sym<next>")
    if_null rx2774_debug, debug_1622
    rx2774_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2774_pos)
  debug_1622:
    .return (rx2774_cur)
  rx2774_restart:
.annotate 'line', 422
    if_null rx2774_debug, debug_1623
    rx2774_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1623:
  rx2774_fail:
    (rx2774_rep, rx2774_pos, $I10, $P10) = rx2774_cur."!mark_fail"(0)
    lt rx2774_pos, -1, rx2774_done
    eq rx2774_pos, -1, rx2774_fail
    jump $I10
  rx2774_done:
    rx2774_cur."!cursor_fail"()
    if_null rx2774_debug, debug_1624
    rx2774_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1624:
    .return (rx2774_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("407_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2778, "ResizablePMCArray"
    push $P2778, "next"
    .return ($P2778)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("408_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    .local string rx2780_tgt
    .local int rx2780_pos
    .local int rx2780_off
    .local int rx2780_eos
    .local int rx2780_rep
    .local pmc rx2780_cur
    .local pmc rx2780_debug
    (rx2780_cur, rx2780_pos, rx2780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2780_cur
    .local pmc match
    .lex "$/", match
    length rx2780_eos, rx2780_tgt
    gt rx2780_pos, rx2780_eos, rx2780_done
    set rx2780_off, 0
    lt rx2780_pos, 2, rx2780_start
    sub rx2780_off, rx2780_pos, 1
    substr rx2780_tgt, rx2780_tgt, rx2780_off
  rx2780_start:
    eq $I10, 1, rx2780_restart
    if_null rx2780_debug, debug_1625
    rx2780_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2781_done
    goto rxscan2781_scan
  rxscan2781_loop:
    (rx2780_pos) = rx2780_cur."from"()
    inc rx2780_pos
    rx2780_cur."!cursor_from"(rx2780_pos)
    ge rx2780_pos, rx2780_eos, rxscan2781_done
  rxscan2781_scan:
    set_addr $I10, rxscan2781_loop
    rx2780_cur."!mark_push"(0, rx2780_pos, $I10)
  rxscan2781_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2782_fail
    rx2780_cur."!mark_push"(0, rx2780_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2780_pos, 4
    gt $I11, rx2780_eos, rx2780_fail
    sub $I11, rx2780_pos, rx2780_off
    substr $S10, rx2780_tgt, $I11, 4
    ne $S10, "redo", rx2780_fail
    add rx2780_pos, 4
    set_addr $I10, rxcap_2782_fail
    ($I12, $I11) = rx2780_cur."!mark_peek"($I10)
    rx2780_cur."!cursor_pos"($I11)
    ($P10) = rx2780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2780_pos, "")
    rx2780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2782_done
  rxcap_2782_fail:
    goto rx2780_fail
  rxcap_2782_done:
  # rx pass
    rx2780_cur."!cursor_pass"(rx2780_pos, "term:sym<redo>")
    if_null rx2780_debug, debug_1626
    rx2780_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2780_pos)
  debug_1626:
    .return (rx2780_cur)
  rx2780_restart:
.annotate 'line', 422
    if_null rx2780_debug, debug_1627
    rx2780_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1627:
  rx2780_fail:
    (rx2780_rep, rx2780_pos, $I10, $P10) = rx2780_cur."!mark_fail"(0)
    lt rx2780_pos, -1, rx2780_done
    eq rx2780_pos, -1, rx2780_fail
    jump $I10
  rx2780_done:
    rx2780_cur."!cursor_fail"()
    if_null rx2780_debug, debug_1628
    rx2780_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1628:
    .return (rx2780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("409_1304523757.895") :method :outer("38_1304523757.895")
.annotate 'line', 422
    new $P2784, "ResizablePMCArray"
    push $P2784, "redo"
    .return ($P2784)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("410_1304523757.895") :outer("38_1304523757.895")
    .param pmc param_2786
    .param pmc param_2787
.annotate 'line', 1131
    .lex "self", param_2786
    .lex "$/", param_2787
.annotate 'line', 1133
    new $P2788, "Undef"
    .lex "$t", $P2788
    find_lex $P2789, "$/"
    unless_null $P2789, vivify_1629
    $P2789 = root_new ['parrot';'ResizablePMCArray']
  vivify_1629:
    set $P2790, $P2789[0]
    unless_null $P2790, vivify_1630
    new $P2790, "Undef"
  vivify_1630:
    store_lex "$t", $P2790
    find_lex $P2791, "$/"
    unless_null $P2791, vivify_1631
    $P2791 = root_new ['parrot';'ResizablePMCArray']
  vivify_1631:
    set $P2792, $P2791[1]
    unless_null $P2792, vivify_1632
    new $P2792, "Undef"
  vivify_1632:
    find_lex $P2793, "$/"
    unless_null $P2793, vivify_1633
    $P2793 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2793
  vivify_1633:
    set $P2793[0], $P2792
    find_lex $P2794, "$t"
    unless_null $P2794, vivify_1634
    new $P2794, "Undef"
  vivify_1634:
    find_lex $P2795, "$/"
    unless_null $P2795, vivify_1635
    $P2795 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P2795
  vivify_1635:
    set $P2795[1], $P2794
.annotate 'line', 1131
    .return ($P2794)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2797"  :subid("411_1304523757.895") :outer("10_1304523757.895")
.annotate 'line', 1137
    .const 'Sub' $P2859 = "431_1304523757.895" 
    capture_lex $P2859
    .const 'Sub' $P2856 = "430_1304523757.895" 
    capture_lex $P2856
    .const 'Sub' $P2854 = "429_1304523757.895" 
    capture_lex $P2854
    .const 'Sub' $P2851 = "428_1304523757.895" 
    capture_lex $P2851
    .const 'Sub' $P2848 = "427_1304523757.895" 
    capture_lex $P2848
    .const 'Sub' $P2839 = "425_1304523757.895" 
    capture_lex $P2839
    .const 'Sub' $P2837 = "424_1304523757.895" 
    capture_lex $P2837
    .const 'Sub' $P2829 = "422_1304523757.895" 
    capture_lex $P2829
    .const 'Sub' $P2827 = "421_1304523757.895" 
    capture_lex $P2827
    .const 'Sub' $P2824 = "420_1304523757.895" 
    capture_lex $P2824
    .const 'Sub' $P2822 = "419_1304523757.895" 
    capture_lex $P2822
    .const 'Sub' $P2815 = "417_1304523757.895" 
    capture_lex $P2815
    .const 'Sub' $P2813 = "416_1304523757.895" 
    capture_lex $P2813
    .const 'Sub' $P2810 = "415_1304523757.895" 
    capture_lex $P2810
    .const 'Sub' $P2808 = "414_1304523757.895" 
    capture_lex $P2808
    .const 'Sub' $P2801 = "412_1304523757.895" 
    capture_lex $P2801
    .lex "$?PACKAGE", $P2799
    .lex "$?CLASS", $P2800
    .const 'Sub' $P2859 = "431_1304523757.895" 
    capture_lex $P2859
    .return ($P2859)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("412_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .const 'Sub' $P2805 = "413_1304523757.895" 
    capture_lex $P2805
    .local string rx2802_tgt
    .local int rx2802_pos
    .local int rx2802_off
    .local int rx2802_eos
    .local int rx2802_rep
    .local pmc rx2802_cur
    .local pmc rx2802_debug
    (rx2802_cur, rx2802_pos, rx2802_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2802_cur
    .local pmc match
    .lex "$/", match
    length rx2802_eos, rx2802_tgt
    gt rx2802_pos, rx2802_eos, rx2802_done
    set rx2802_off, 0
    lt rx2802_pos, 2, rx2802_start
    sub rx2802_off, rx2802_pos, 1
    substr rx2802_tgt, rx2802_tgt, rx2802_off
  rx2802_start:
    eq $I10, 1, rx2802_restart
    if_null rx2802_debug, debug_1636
    rx2802_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2803_done
    goto rxscan2803_scan
  rxscan2803_loop:
    (rx2802_pos) = rx2802_cur."from"()
    inc rx2802_pos
    rx2802_cur."!cursor_from"(rx2802_pos)
    ge rx2802_pos, rx2802_eos, rxscan2803_done
  rxscan2803_scan:
    set_addr $I10, rxscan2803_loop
    rx2802_cur."!mark_push"(0, rx2802_pos, $I10)
  rxscan2803_done:
.annotate 'line', 1139
  # rx literal  ":"
    add $I11, rx2802_pos, 1
    gt $I11, rx2802_eos, rx2802_fail
    sub $I11, rx2802_pos, rx2802_off
    ord $I11, rx2802_tgt, $I11
    ne $I11, 58, rx2802_fail
    add rx2802_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2802_cur."!cursor_pos"(rx2802_pos)
    .const 'Sub' $P2805 = "413_1304523757.895" 
    capture_lex $P2805
    $P10 = rx2802_cur."before"($P2805)
    unless $P10, rx2802_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2802_cur."!cursor_pos"(rx2802_pos)
    $P10 = rx2802_cur."LANG"("MAIN", "statement")
    unless $P10, rx2802_fail
    rx2802_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2802_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2802_cur."!cursor_pos"(rx2802_pos)
    $P10 = rx2802_cur."ws"()
    unless $P10, rx2802_fail
    rx2802_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2802_pos, 1
    gt $I11, rx2802_eos, rx2802_fail
    sub $I11, rx2802_pos, rx2802_off
    ord $I11, rx2802_tgt, $I11
    ne $I11, 59, rx2802_fail
    add rx2802_pos, 1
.annotate 'line', 1138
  # rx pass
    rx2802_cur."!cursor_pass"(rx2802_pos, "metachar:sym<:my>")
    if_null rx2802_debug, debug_1641
    rx2802_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2802_pos)
  debug_1641:
    .return (rx2802_cur)
  rx2802_restart:
.annotate 'line', 1137
    if_null rx2802_debug, debug_1642
    rx2802_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1642:
  rx2802_fail:
    (rx2802_rep, rx2802_pos, $I10, $P10) = rx2802_cur."!mark_fail"(0)
    lt rx2802_pos, -1, rx2802_done
    eq rx2802_pos, -1, rx2802_fail
    jump $I10
  rx2802_done:
    rx2802_cur."!cursor_fail"()
    if_null rx2802_debug, debug_1643
    rx2802_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1643:
    .return (rx2802_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2804"  :anon :subid("413_1304523757.895") :method :outer("412_1304523757.895")
.annotate 'line', 1139
    .local string rx2806_tgt
    .local int rx2806_pos
    .local int rx2806_off
    .local int rx2806_eos
    .local int rx2806_rep
    .local pmc rx2806_cur
    .local pmc rx2806_debug
    (rx2806_cur, rx2806_pos, rx2806_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2806_cur
    .local pmc match
    .lex "$/", match
    length rx2806_eos, rx2806_tgt
    gt rx2806_pos, rx2806_eos, rx2806_done
    set rx2806_off, 0
    lt rx2806_pos, 2, rx2806_start
    sub rx2806_off, rx2806_pos, 1
    substr rx2806_tgt, rx2806_tgt, rx2806_off
  rx2806_start:
    eq $I10, 1, rx2806_restart
    if_null rx2806_debug, debug_1637
    rx2806_cur."!cursor_debug"("START", "")
  debug_1637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2807_done
    goto rxscan2807_scan
  rxscan2807_loop:
    (rx2806_pos) = rx2806_cur."from"()
    inc rx2806_pos
    rx2806_cur."!cursor_from"(rx2806_pos)
    ge rx2806_pos, rx2806_eos, rxscan2807_done
  rxscan2807_scan:
    set_addr $I10, rxscan2807_loop
    rx2806_cur."!mark_push"(0, rx2806_pos, $I10)
  rxscan2807_done:
  # rx literal  "my"
    add $I11, rx2806_pos, 2
    gt $I11, rx2806_eos, rx2806_fail
    sub $I11, rx2806_pos, rx2806_off
    substr $S10, rx2806_tgt, $I11, 2
    ne $S10, "my", rx2806_fail
    add rx2806_pos, 2
  # rx pass
    rx2806_cur."!cursor_pass"(rx2806_pos, "")
    if_null rx2806_debug, debug_1638
    rx2806_cur."!cursor_debug"("PASS", "", " at pos=", rx2806_pos)
  debug_1638:
    .return (rx2806_cur)
  rx2806_restart:
    if_null rx2806_debug, debug_1639
    rx2806_cur."!cursor_debug"("NEXT", "")
  debug_1639:
  rx2806_fail:
    (rx2806_rep, rx2806_pos, $I10, $P10) = rx2806_cur."!mark_fail"(0)
    lt rx2806_pos, -1, rx2806_done
    eq rx2806_pos, -1, rx2806_fail
    jump $I10
  rx2806_done:
    rx2806_cur."!cursor_fail"()
    if_null rx2806_debug, debug_1640
    rx2806_cur."!cursor_debug"("FAIL", "")
  debug_1640:
    .return (rx2806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("414_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    new $P2809, "ResizablePMCArray"
    push $P2809, ":"
    .return ($P2809)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("415_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .local string rx2811_tgt
    .local int rx2811_pos
    .local int rx2811_off
    .local int rx2811_eos
    .local int rx2811_rep
    .local pmc rx2811_cur
    .local pmc rx2811_debug
    (rx2811_cur, rx2811_pos, rx2811_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2811_cur
    .local pmc match
    .lex "$/", match
    length rx2811_eos, rx2811_tgt
    gt rx2811_pos, rx2811_eos, rx2811_done
    set rx2811_off, 0
    lt rx2811_pos, 2, rx2811_start
    sub rx2811_off, rx2811_pos, 1
    substr rx2811_tgt, rx2811_tgt, rx2811_off
  rx2811_start:
    eq $I10, 1, rx2811_restart
    if_null rx2811_debug, debug_1644
    rx2811_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2812_done
    goto rxscan2812_scan
  rxscan2812_loop:
    (rx2811_pos) = rx2811_cur."from"()
    inc rx2811_pos
    rx2811_cur."!cursor_from"(rx2811_pos)
    ge rx2811_pos, rx2811_eos, rxscan2812_done
  rxscan2812_scan:
    set_addr $I10, rxscan2812_loop
    rx2811_cur."!mark_push"(0, rx2811_pos, $I10)
  rxscan2812_done:
.annotate 'line', 1143
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2811_pos, rx2811_off
    substr $S10, rx2811_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2811_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2811_cur."!cursor_pos"(rx2811_pos)
    $P10 = rx2811_cur."codeblock"()
    unless $P10, rx2811_fail
    rx2811_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2811_pos = $P10."pos"()
.annotate 'line', 1142
  # rx pass
    rx2811_cur."!cursor_pass"(rx2811_pos, "metachar:sym<{ }>")
    if_null rx2811_debug, debug_1645
    rx2811_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2811_pos)
  debug_1645:
    .return (rx2811_cur)
  rx2811_restart:
.annotate 'line', 1137
    if_null rx2811_debug, debug_1646
    rx2811_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1646:
  rx2811_fail:
    (rx2811_rep, rx2811_pos, $I10, $P10) = rx2811_cur."!mark_fail"(0)
    lt rx2811_pos, -1, rx2811_done
    eq rx2811_pos, -1, rx2811_fail
    jump $I10
  rx2811_done:
    rx2811_cur."!cursor_fail"()
    if_null rx2811_debug, debug_1647
    rx2811_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1647:
    .return (rx2811_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("416_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    new $P2814, "ResizablePMCArray"
    push $P2814, "{"
    .return ($P2814)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("417_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .const 'Sub' $P2819 = "418_1304523757.895" 
    capture_lex $P2819
    .local string rx2816_tgt
    .local int rx2816_pos
    .local int rx2816_off
    .local int rx2816_eos
    .local int rx2816_rep
    .local pmc rx2816_cur
    .local pmc rx2816_debug
    (rx2816_cur, rx2816_pos, rx2816_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2816_cur
    .local pmc match
    .lex "$/", match
    length rx2816_eos, rx2816_tgt
    gt rx2816_pos, rx2816_eos, rx2816_done
    set rx2816_off, 0
    lt rx2816_pos, 2, rx2816_start
    sub rx2816_off, rx2816_pos, 1
    substr rx2816_tgt, rx2816_tgt, rx2816_off
  rx2816_start:
    eq $I10, 1, rx2816_restart
    if_null rx2816_debug, debug_1648
    rx2816_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2817_done
    goto rxscan2817_scan
  rxscan2817_loop:
    (rx2816_pos) = rx2816_cur."from"()
    inc rx2816_pos
    rx2816_cur."!cursor_from"(rx2816_pos)
    ge rx2816_pos, rx2816_eos, rxscan2817_done
  rxscan2817_scan:
    set_addr $I10, rxscan2817_loop
    rx2816_cur."!mark_push"(0, rx2816_pos, $I10)
  rxscan2817_done:
.annotate 'line', 1147
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2816_pos, rx2816_off
    substr $S10, rx2816_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2816_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2816_cur."!cursor_pos"(rx2816_pos)
    .const 'Sub' $P2819 = "418_1304523757.895" 
    capture_lex $P2819
    $P10 = rx2816_cur."before"($P2819)
    unless $P10, rx2816_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2816_cur."!cursor_pos"(rx2816_pos)
    $P10 = rx2816_cur."LANG"("MAIN", "variable")
    unless $P10, rx2816_fail
    rx2816_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2816_pos = $P10."pos"()
.annotate 'line', 1146
  # rx pass
    rx2816_cur."!cursor_pass"(rx2816_pos, "metachar:sym<nqpvar>")
    if_null rx2816_debug, debug_1653
    rx2816_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2816_pos)
  debug_1653:
    .return (rx2816_cur)
  rx2816_restart:
.annotate 'line', 1137
    if_null rx2816_debug, debug_1654
    rx2816_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1654:
  rx2816_fail:
    (rx2816_rep, rx2816_pos, $I10, $P10) = rx2816_cur."!mark_fail"(0)
    lt rx2816_pos, -1, rx2816_done
    eq rx2816_pos, -1, rx2816_fail
    jump $I10
  rx2816_done:
    rx2816_cur."!cursor_fail"()
    if_null rx2816_debug, debug_1655
    rx2816_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1655:
    .return (rx2816_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2818"  :anon :subid("418_1304523757.895") :method :outer("417_1304523757.895")
.annotate 'line', 1147
    .local string rx2820_tgt
    .local int rx2820_pos
    .local int rx2820_off
    .local int rx2820_eos
    .local int rx2820_rep
    .local pmc rx2820_cur
    .local pmc rx2820_debug
    (rx2820_cur, rx2820_pos, rx2820_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2820_cur
    .local pmc match
    .lex "$/", match
    length rx2820_eos, rx2820_tgt
    gt rx2820_pos, rx2820_eos, rx2820_done
    set rx2820_off, 0
    lt rx2820_pos, 2, rx2820_start
    sub rx2820_off, rx2820_pos, 1
    substr rx2820_tgt, rx2820_tgt, rx2820_off
  rx2820_start:
    eq $I10, 1, rx2820_restart
    if_null rx2820_debug, debug_1649
    rx2820_cur."!cursor_debug"("START", "")
  debug_1649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2821_done
    goto rxscan2821_scan
  rxscan2821_loop:
    (rx2820_pos) = rx2820_cur."from"()
    inc rx2820_pos
    rx2820_cur."!cursor_from"(rx2820_pos)
    ge rx2820_pos, rx2820_eos, rxscan2821_done
  rxscan2821_scan:
    set_addr $I10, rxscan2821_loop
    rx2820_cur."!mark_push"(0, rx2820_pos, $I10)
  rxscan2821_done:
  # rx charclass .
    ge rx2820_pos, rx2820_eos, rx2820_fail
    inc rx2820_pos
  # rx charclass w
    ge rx2820_pos, rx2820_eos, rx2820_fail
    sub $I10, rx2820_pos, rx2820_off
    is_cclass $I11, 8192, rx2820_tgt, $I10
    unless $I11, rx2820_fail
    inc rx2820_pos
  # rx pass
    rx2820_cur."!cursor_pass"(rx2820_pos, "")
    if_null rx2820_debug, debug_1650
    rx2820_cur."!cursor_debug"("PASS", "", " at pos=", rx2820_pos)
  debug_1650:
    .return (rx2820_cur)
  rx2820_restart:
    if_null rx2820_debug, debug_1651
    rx2820_cur."!cursor_debug"("NEXT", "")
  debug_1651:
  rx2820_fail:
    (rx2820_rep, rx2820_pos, $I10, $P10) = rx2820_cur."!mark_fail"(0)
    lt rx2820_pos, -1, rx2820_done
    eq rx2820_pos, -1, rx2820_fail
    jump $I10
  rx2820_done:
    rx2820_cur."!cursor_fail"()
    if_null rx2820_debug, debug_1652
    rx2820_cur."!cursor_debug"("FAIL", "")
  debug_1652:
    .return (rx2820_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("419_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    new $P2823, "ResizablePMCArray"
    push $P2823, "$"
    push $P2823, "@"
    .return ($P2823)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("420_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .local string rx2825_tgt
    .local int rx2825_pos
    .local int rx2825_off
    .local int rx2825_eos
    .local int rx2825_rep
    .local pmc rx2825_cur
    .local pmc rx2825_debug
    (rx2825_cur, rx2825_pos, rx2825_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2825_cur
    .local pmc match
    .lex "$/", match
    length rx2825_eos, rx2825_tgt
    gt rx2825_pos, rx2825_eos, rx2825_done
    set rx2825_off, 0
    lt rx2825_pos, 2, rx2825_start
    sub rx2825_off, rx2825_pos, 1
    substr rx2825_tgt, rx2825_tgt, rx2825_off
  rx2825_start:
    eq $I10, 1, rx2825_restart
    if_null rx2825_debug, debug_1656
    rx2825_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2826_done
    goto rxscan2826_scan
  rxscan2826_loop:
    (rx2825_pos) = rx2825_cur."from"()
    inc rx2825_pos
    rx2825_cur."!cursor_from"(rx2825_pos)
    ge rx2825_pos, rx2825_eos, rxscan2826_done
  rxscan2826_scan:
    set_addr $I10, rxscan2826_loop
    rx2825_cur."!mark_push"(0, rx2825_pos, $I10)
  rxscan2826_done:
.annotate 'line', 1151
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2825_pos, rx2825_off
    substr $S10, rx2825_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2825_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2825_cur."!cursor_pos"(rx2825_pos)
    $P10 = rx2825_cur."codeblock"()
    unless $P10, rx2825_fail
    rx2825_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2825_pos = $P10."pos"()
.annotate 'line', 1150
  # rx pass
    rx2825_cur."!cursor_pass"(rx2825_pos, "assertion:sym<{ }>")
    if_null rx2825_debug, debug_1657
    rx2825_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2825_pos)
  debug_1657:
    .return (rx2825_cur)
  rx2825_restart:
.annotate 'line', 1137
    if_null rx2825_debug, debug_1658
    rx2825_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1658:
  rx2825_fail:
    (rx2825_rep, rx2825_pos, $I10, $P10) = rx2825_cur."!mark_fail"(0)
    lt rx2825_pos, -1, rx2825_done
    eq rx2825_pos, -1, rx2825_fail
    jump $I10
  rx2825_done:
    rx2825_cur."!cursor_fail"()
    if_null rx2825_debug, debug_1659
    rx2825_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1659:
    .return (rx2825_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("421_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    new $P2828, "ResizablePMCArray"
    push $P2828, "{"
    .return ($P2828)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("422_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .const 'Sub' $P2833 = "423_1304523757.895" 
    capture_lex $P2833
    .local string rx2830_tgt
    .local int rx2830_pos
    .local int rx2830_off
    .local int rx2830_eos
    .local int rx2830_rep
    .local pmc rx2830_cur
    .local pmc rx2830_debug
    (rx2830_cur, rx2830_pos, rx2830_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2830_cur
    .local pmc match
    .lex "$/", match
    length rx2830_eos, rx2830_tgt
    gt rx2830_pos, rx2830_eos, rx2830_done
    set rx2830_off, 0
    lt rx2830_pos, 2, rx2830_start
    sub rx2830_off, rx2830_pos, 1
    substr rx2830_tgt, rx2830_tgt, rx2830_off
  rx2830_start:
    eq $I10, 1, rx2830_restart
    if_null rx2830_debug, debug_1660
    rx2830_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2831_done
    goto rxscan2831_scan
  rxscan2831_loop:
    (rx2830_pos) = rx2830_cur."from"()
    inc rx2830_pos
    rx2830_cur."!cursor_from"(rx2830_pos)
    ge rx2830_pos, rx2830_eos, rxscan2831_done
  rxscan2831_scan:
    set_addr $I10, rxscan2831_loop
    rx2830_cur."!mark_push"(0, rx2830_pos, $I10)
  rxscan2831_done:
.annotate 'line', 1155
  # rx subcapture "zw"
    set_addr $I10, rxcap_2836_fail
    rx2830_cur."!mark_push"(0, rx2830_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2830_pos, rx2830_eos, rx2830_fail
    sub $I10, rx2830_pos, rx2830_off
    substr $S10, rx2830_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2830_fail
    inc rx2830_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2830_cur."!cursor_pos"(rx2830_pos)
    .const 'Sub' $P2833 = "423_1304523757.895" 
    capture_lex $P2833
    $P10 = rx2830_cur."before"($P2833)
    unless $P10, rx2830_fail
    set_addr $I10, rxcap_2836_fail
    ($I12, $I11) = rx2830_cur."!mark_peek"($I10)
    rx2830_cur."!cursor_pos"($I11)
    ($P10) = rx2830_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2830_pos, "")
    rx2830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2836_done
  rxcap_2836_fail:
    goto rx2830_fail
  rxcap_2836_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2830_cur."!cursor_pos"(rx2830_pos)
    $P10 = rx2830_cur."codeblock"()
    unless $P10, rx2830_fail
    rx2830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2830_pos = $P10."pos"()
.annotate 'line', 1154
  # rx pass
    rx2830_cur."!cursor_pass"(rx2830_pos, "assertion:sym<?{ }>")
    if_null rx2830_debug, debug_1665
    rx2830_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2830_pos)
  debug_1665:
    .return (rx2830_cur)
  rx2830_restart:
.annotate 'line', 1137
    if_null rx2830_debug, debug_1666
    rx2830_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1666:
  rx2830_fail:
    (rx2830_rep, rx2830_pos, $I10, $P10) = rx2830_cur."!mark_fail"(0)
    lt rx2830_pos, -1, rx2830_done
    eq rx2830_pos, -1, rx2830_fail
    jump $I10
  rx2830_done:
    rx2830_cur."!cursor_fail"()
    if_null rx2830_debug, debug_1667
    rx2830_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1667:
    .return (rx2830_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2832"  :anon :subid("423_1304523757.895") :method :outer("422_1304523757.895")
.annotate 'line', 1155
    .local string rx2834_tgt
    .local int rx2834_pos
    .local int rx2834_off
    .local int rx2834_eos
    .local int rx2834_rep
    .local pmc rx2834_cur
    .local pmc rx2834_debug
    (rx2834_cur, rx2834_pos, rx2834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2834_cur
    .local pmc match
    .lex "$/", match
    length rx2834_eos, rx2834_tgt
    gt rx2834_pos, rx2834_eos, rx2834_done
    set rx2834_off, 0
    lt rx2834_pos, 2, rx2834_start
    sub rx2834_off, rx2834_pos, 1
    substr rx2834_tgt, rx2834_tgt, rx2834_off
  rx2834_start:
    eq $I10, 1, rx2834_restart
    if_null rx2834_debug, debug_1661
    rx2834_cur."!cursor_debug"("START", "")
  debug_1661:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2835_done
    goto rxscan2835_scan
  rxscan2835_loop:
    (rx2834_pos) = rx2834_cur."from"()
    inc rx2834_pos
    rx2834_cur."!cursor_from"(rx2834_pos)
    ge rx2834_pos, rx2834_eos, rxscan2835_done
  rxscan2835_scan:
    set_addr $I10, rxscan2835_loop
    rx2834_cur."!mark_push"(0, rx2834_pos, $I10)
  rxscan2835_done:
  # rx literal  "{"
    add $I11, rx2834_pos, 1
    gt $I11, rx2834_eos, rx2834_fail
    sub $I11, rx2834_pos, rx2834_off
    ord $I11, rx2834_tgt, $I11
    ne $I11, 123, rx2834_fail
    add rx2834_pos, 1
  # rx pass
    rx2834_cur."!cursor_pass"(rx2834_pos, "")
    if_null rx2834_debug, debug_1662
    rx2834_cur."!cursor_debug"("PASS", "", " at pos=", rx2834_pos)
  debug_1662:
    .return (rx2834_cur)
  rx2834_restart:
    if_null rx2834_debug, debug_1663
    rx2834_cur."!cursor_debug"("NEXT", "")
  debug_1663:
  rx2834_fail:
    (rx2834_rep, rx2834_pos, $I10, $P10) = rx2834_cur."!mark_fail"(0)
    lt rx2834_pos, -1, rx2834_done
    eq rx2834_pos, -1, rx2834_fail
    jump $I10
  rx2834_done:
    rx2834_cur."!cursor_fail"()
    if_null rx2834_debug, debug_1664
    rx2834_cur."!cursor_debug"("FAIL", "")
  debug_1664:
    .return (rx2834_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("424_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    new $P2838, "ResizablePMCArray"
    push $P2838, "!"
    push $P2838, "?"
    .return ($P2838)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("425_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .const 'Sub' $P2845 = "426_1304523757.895" 
    capture_lex $P2845
    .local string rx2840_tgt
    .local int rx2840_pos
    .local int rx2840_off
    .local int rx2840_eos
    .local int rx2840_rep
    .local pmc rx2840_cur
    .local pmc rx2840_debug
    (rx2840_cur, rx2840_pos, rx2840_tgt, $I10) = self."!cursor_start"()
    rx2840_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2840_cur
    .local pmc match
    .lex "$/", match
    length rx2840_eos, rx2840_tgt
    gt rx2840_pos, rx2840_eos, rx2840_done
    set rx2840_off, 0
    lt rx2840_pos, 2, rx2840_start
    sub rx2840_off, rx2840_pos, 1
    substr rx2840_tgt, rx2840_tgt, rx2840_off
  rx2840_start:
    eq $I10, 1, rx2840_restart
    if_null rx2840_debug, debug_1668
    rx2840_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2841_done
    goto rxscan2841_scan
  rxscan2841_loop:
    (rx2840_pos) = rx2840_cur."from"()
    inc rx2840_pos
    rx2840_cur."!cursor_from"(rx2840_pos)
    ge rx2840_pos, rx2840_eos, rxscan2841_done
  rxscan2841_scan:
    set_addr $I10, rxscan2841_loop
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
  rxscan2841_done:
.annotate 'line', 1159
  # rx subrule "identifier" subtype=capture negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."identifier"()
    unless $P10, rx2840_fail
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2840_pos = $P10."pos"()
.annotate 'line', 1166
  # rx rxquantr2842 ** 0..1
    set_addr $I10, rxquantr2842_done
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
  rxquantr2842_loop:
  alt2843_0:
.annotate 'line', 1160
    set_addr $I10, alt2843_1
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
.annotate 'line', 1161
  # rx subrule "before" subtype=zerowidth negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    .const 'Sub' $P2845 = "426_1304523757.895" 
    capture_lex $P2845
    $P10 = rx2840_cur."before"($P2845)
    unless $P10, rx2840_fail
    goto alt2843_end
  alt2843_1:
    set_addr $I10, alt2843_2
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
.annotate 'line', 1162
  # rx literal  "="
    add $I11, rx2840_pos, 1
    gt $I11, rx2840_eos, rx2840_fail
    sub $I11, rx2840_pos, rx2840_off
    ord $I11, rx2840_tgt, $I11
    ne $I11, 61, rx2840_fail
    add rx2840_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."assertion"()
    unless $P10, rx2840_fail
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2840_pos = $P10."pos"()
    goto alt2843_end
  alt2843_2:
    set_addr $I10, alt2843_3
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
.annotate 'line', 1163
  # rx literal  ":"
    add $I11, rx2840_pos, 1
    gt $I11, rx2840_eos, rx2840_fail
    sub $I11, rx2840_pos, rx2840_off
    ord $I11, rx2840_tgt, $I11
    ne $I11, 58, rx2840_fail
    add rx2840_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."arglist"()
    unless $P10, rx2840_fail
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2840_pos = $P10."pos"()
    goto alt2843_end
  alt2843_3:
    set_addr $I10, alt2843_4
    rx2840_cur."!mark_push"(0, rx2840_pos, $I10)
.annotate 'line', 1164
  # rx literal  "("
    add $I11, rx2840_pos, 1
    gt $I11, rx2840_eos, rx2840_fail
    sub $I11, rx2840_pos, rx2840_off
    ord $I11, rx2840_tgt, $I11
    ne $I11, 40, rx2840_fail
    add rx2840_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2840_fail
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2840_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2840_pos, 1
    gt $I11, rx2840_eos, rx2840_fail
    sub $I11, rx2840_pos, rx2840_off
    ord $I11, rx2840_tgt, $I11
    ne $I11, 41, rx2840_fail
    add rx2840_pos, 1
    goto alt2843_end
  alt2843_4:
.annotate 'line', 1165
  # rx subrule "normspace" subtype=method negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."normspace"()
    unless $P10, rx2840_fail
    rx2840_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2840_cur."!cursor_pos"(rx2840_pos)
    $P10 = rx2840_cur."nibbler"()
    unless $P10, rx2840_fail
    rx2840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2840_pos = $P10."pos"()
  alt2843_end:
.annotate 'line', 1166
    set_addr $I10, rxquantr2842_done
    (rx2840_rep) = rx2840_cur."!mark_commit"($I10)
  rxquantr2842_done:
.annotate 'line', 1158
  # rx pass
    rx2840_cur."!cursor_pass"(rx2840_pos, "assertion:sym<name>")
    if_null rx2840_debug, debug_1673
    rx2840_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2840_pos)
  debug_1673:
    .return (rx2840_cur)
  rx2840_restart:
.annotate 'line', 1137
    if_null rx2840_debug, debug_1674
    rx2840_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1674:
  rx2840_fail:
    (rx2840_rep, rx2840_pos, $I10, $P10) = rx2840_cur."!mark_fail"(0)
    lt rx2840_pos, -1, rx2840_done
    eq rx2840_pos, -1, rx2840_fail
    jump $I10
  rx2840_done:
    rx2840_cur."!cursor_fail"()
    if_null rx2840_debug, debug_1675
    rx2840_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1675:
    .return (rx2840_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2844"  :anon :subid("426_1304523757.895") :method :outer("425_1304523757.895")
.annotate 'line', 1161
    .local string rx2846_tgt
    .local int rx2846_pos
    .local int rx2846_off
    .local int rx2846_eos
    .local int rx2846_rep
    .local pmc rx2846_cur
    .local pmc rx2846_debug
    (rx2846_cur, rx2846_pos, rx2846_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2846_cur
    .local pmc match
    .lex "$/", match
    length rx2846_eos, rx2846_tgt
    gt rx2846_pos, rx2846_eos, rx2846_done
    set rx2846_off, 0
    lt rx2846_pos, 2, rx2846_start
    sub rx2846_off, rx2846_pos, 1
    substr rx2846_tgt, rx2846_tgt, rx2846_off
  rx2846_start:
    eq $I10, 1, rx2846_restart
    if_null rx2846_debug, debug_1669
    rx2846_cur."!cursor_debug"("START", "")
  debug_1669:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2847_done
    goto rxscan2847_scan
  rxscan2847_loop:
    (rx2846_pos) = rx2846_cur."from"()
    inc rx2846_pos
    rx2846_cur."!cursor_from"(rx2846_pos)
    ge rx2846_pos, rx2846_eos, rxscan2847_done
  rxscan2847_scan:
    set_addr $I10, rxscan2847_loop
    rx2846_cur."!mark_push"(0, rx2846_pos, $I10)
  rxscan2847_done:
  # rx literal  ">"
    add $I11, rx2846_pos, 1
    gt $I11, rx2846_eos, rx2846_fail
    sub $I11, rx2846_pos, rx2846_off
    ord $I11, rx2846_tgt, $I11
    ne $I11, 62, rx2846_fail
    add rx2846_pos, 1
  # rx pass
    rx2846_cur."!cursor_pass"(rx2846_pos, "")
    if_null rx2846_debug, debug_1670
    rx2846_cur."!cursor_debug"("PASS", "", " at pos=", rx2846_pos)
  debug_1670:
    .return (rx2846_cur)
  rx2846_restart:
    if_null rx2846_debug, debug_1671
    rx2846_cur."!cursor_debug"("NEXT", "")
  debug_1671:
  rx2846_fail:
    (rx2846_rep, rx2846_pos, $I10, $P10) = rx2846_cur."!mark_fail"(0)
    lt rx2846_pos, -1, rx2846_done
    eq rx2846_pos, -1, rx2846_fail
    jump $I10
  rx2846_done:
    rx2846_cur."!cursor_fail"()
    if_null rx2846_debug, debug_1672
    rx2846_cur."!cursor_debug"("FAIL", "")
  debug_1672:
    .return (rx2846_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("427_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    $P2849 = self."!PREFIX__!subrule"("identifier", "")
    new $P2850, "ResizablePMCArray"
    push $P2850, $P2849
    .return ($P2850)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("428_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .local string rx2852_tgt
    .local int rx2852_pos
    .local int rx2852_off
    .local int rx2852_eos
    .local int rx2852_rep
    .local pmc rx2852_cur
    .local pmc rx2852_debug
    (rx2852_cur, rx2852_pos, rx2852_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2852_cur
    .local pmc match
    .lex "$/", match
    length rx2852_eos, rx2852_tgt
    gt rx2852_pos, rx2852_eos, rx2852_done
    set rx2852_off, 0
    lt rx2852_pos, 2, rx2852_start
    sub rx2852_off, rx2852_pos, 1
    substr rx2852_tgt, rx2852_tgt, rx2852_off
  rx2852_start:
    eq $I10, 1, rx2852_restart
    if_null rx2852_debug, debug_1676
    rx2852_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2853_done
    goto rxscan2853_scan
  rxscan2853_loop:
    (rx2852_pos) = rx2852_cur."from"()
    inc rx2852_pos
    rx2852_cur."!cursor_from"(rx2852_pos)
    ge rx2852_pos, rx2852_eos, rxscan2853_done
  rxscan2853_scan:
    set_addr $I10, rxscan2853_loop
    rx2852_cur."!mark_push"(0, rx2852_pos, $I10)
  rxscan2853_done:
.annotate 'line', 1170
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2852_pos, rx2852_off
    substr $S10, rx2852_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2852_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2852_cur."!cursor_pos"(rx2852_pos)
    $P10 = rx2852_cur."LANG"("MAIN", "variable")
    unless $P10, rx2852_fail
    rx2852_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2852_pos = $P10."pos"()
.annotate 'line', 1169
  # rx pass
    rx2852_cur."!cursor_pass"(rx2852_pos, "assertion:sym<var>")
    if_null rx2852_debug, debug_1677
    rx2852_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2852_pos)
  debug_1677:
    .return (rx2852_cur)
  rx2852_restart:
.annotate 'line', 1137
    if_null rx2852_debug, debug_1678
    rx2852_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1678:
  rx2852_fail:
    (rx2852_rep, rx2852_pos, $I10, $P10) = rx2852_cur."!mark_fail"(0)
    lt rx2852_pos, -1, rx2852_done
    eq rx2852_pos, -1, rx2852_fail
    jump $I10
  rx2852_done:
    rx2852_cur."!cursor_fail"()
    if_null rx2852_debug, debug_1679
    rx2852_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1679:
    .return (rx2852_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("429_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    new $P2855, "ResizablePMCArray"
    push $P2855, "$"
    push $P2855, "@"
    .return ($P2855)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("430_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    .local string rx2857_tgt
    .local int rx2857_pos
    .local int rx2857_off
    .local int rx2857_eos
    .local int rx2857_rep
    .local pmc rx2857_cur
    .local pmc rx2857_debug
    (rx2857_cur, rx2857_pos, rx2857_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2857_cur
    .local pmc match
    .lex "$/", match
    length rx2857_eos, rx2857_tgt
    gt rx2857_pos, rx2857_eos, rx2857_done
    set rx2857_off, 0
    lt rx2857_pos, 2, rx2857_start
    sub rx2857_off, rx2857_pos, 1
    substr rx2857_tgt, rx2857_tgt, rx2857_off
  rx2857_start:
    eq $I10, 1, rx2857_restart
    if_null rx2857_debug, debug_1680
    rx2857_cur."!cursor_debug"("START", "codeblock")
  debug_1680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2858_done
    goto rxscan2858_scan
  rxscan2858_loop:
    (rx2857_pos) = rx2857_cur."from"()
    inc rx2857_pos
    rx2857_cur."!cursor_from"(rx2857_pos)
    ge rx2857_pos, rx2857_eos, rxscan2858_done
  rxscan2858_scan:
    set_addr $I10, rxscan2858_loop
    rx2857_cur."!mark_push"(0, rx2857_pos, $I10)
  rxscan2858_done:
.annotate 'line', 1174
  # rx subrule "LANG" subtype=capture negate=
    rx2857_cur."!cursor_pos"(rx2857_pos)
    $P10 = rx2857_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2857_fail
    rx2857_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2857_pos = $P10."pos"()
.annotate 'line', 1173
  # rx pass
    rx2857_cur."!cursor_pass"(rx2857_pos, "codeblock")
    if_null rx2857_debug, debug_1681
    rx2857_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2857_pos)
  debug_1681:
    .return (rx2857_cur)
  rx2857_restart:
.annotate 'line', 1137
    if_null rx2857_debug, debug_1682
    rx2857_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1682:
  rx2857_fail:
    (rx2857_rep, rx2857_pos, $I10, $P10) = rx2857_cur."!mark_fail"(0)
    lt rx2857_pos, -1, rx2857_done
    eq rx2857_pos, -1, rx2857_fail
    jump $I10
  rx2857_done:
    rx2857_cur."!cursor_fail"()
    if_null rx2857_debug, debug_1683
    rx2857_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1683:
    .return (rx2857_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("431_1304523757.895") :method :outer("411_1304523757.895")
.annotate 'line', 1137
    $P2860 = self."!PREFIX__!subrule"("LANG", "")
    new $P2861, "ResizablePMCArray"
    push $P2861, $P2860
    .return ($P2861)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2862"  :subid("432_1304523757.895") :outer("10_1304523757.895")
.annotate 'line', 1180
    .const 'Sub' $P6896 = "605_1304523757.895" 
    capture_lex $P6896
    .const 'Sub' $P6881 = "604_1304523757.895" 
    capture_lex $P6881
    .const 'Sub' $P6876 = "603_1304523757.895" 
    capture_lex $P6876
    .const 'Sub' $P6871 = "602_1304523757.895" 
    capture_lex $P6871
    .const 'Sub' $P6866 = "601_1304523757.895" 
    capture_lex $P6866
    .const 'Sub' $P6849 = "600_1304523757.895" 
    capture_lex $P6849
    .const 'Sub' $P6838 = "599_1304523757.895" 
    capture_lex $P6838
    .const 'Sub' $P6827 = "598_1304523757.895" 
    capture_lex $P6827
    .const 'Sub' $P6819 = "597_1304523757.895" 
    capture_lex $P6819
    .const 'Sub' $P6814 = "596_1304523757.895" 
    capture_lex $P6814
    .const 'Sub' $P6799 = "595_1304523757.895" 
    capture_lex $P6799
    .const 'Sub' $P6791 = "594_1304523757.895" 
    capture_lex $P6791
    .const 'Sub' $P6733 = "593_1304523757.895" 
    capture_lex $P6733
    .const 'Sub' $P6718 = "592_1304523757.895" 
    capture_lex $P6718
    .const 'Sub' $P6710 = "591_1304523757.895" 
    capture_lex $P6710
    .const 'Sub' $P6702 = "590_1304523757.895" 
    capture_lex $P6702
    .const 'Sub' $P6694 = "589_1304523757.895" 
    capture_lex $P6694
    .const 'Sub' $P6686 = "588_1304523757.895" 
    capture_lex $P6686
    .const 'Sub' $P6678 = "587_1304523757.895" 
    capture_lex $P6678
    .const 'Sub' $P6649 = "586_1304523757.895" 
    capture_lex $P6649
    .const 'Sub' $P6634 = "585_1304523757.895" 
    capture_lex $P6634
    .const 'Sub' $P6626 = "584_1304523757.895" 
    capture_lex $P6626
    .const 'Sub' $P6612 = "583_1304523757.895" 
    capture_lex $P6612
    .const 'Sub' $P6598 = "582_1304523757.895" 
    capture_lex $P6598
    .const 'Sub' $P6584 = "581_1304523757.895" 
    capture_lex $P6584
    .const 'Sub' $P6576 = "580_1304523757.895" 
    capture_lex $P6576
    .const 'Sub' $P6546 = "579_1304523757.895" 
    capture_lex $P6546
    .const 'Sub' $P6508 = "577_1304523757.895" 
    capture_lex $P6508
    .const 'Sub' $P6500 = "576_1304523757.895" 
    capture_lex $P6500
    .const 'Sub' $P6492 = "575_1304523757.895" 
    capture_lex $P6492
    .const 'Sub' $P6461 = "574_1304523757.895" 
    capture_lex $P6461
    .const 'Sub' $P6442 = "573_1304523757.895" 
    capture_lex $P6442
    .const 'Sub' $P6434 = "572_1304523757.895" 
    capture_lex $P6434
    .const 'Sub' $P6426 = "571_1304523757.895" 
    capture_lex $P6426
    .const 'Sub' $P6318 = "568_1304523757.895" 
    capture_lex $P6318
    .const 'Sub' $P6310 = "567_1304523757.895" 
    capture_lex $P6310
    .const 'Sub' $P6300 = "566_1304523757.895" 
    capture_lex $P6300
    .const 'Sub' $P6266 = "565_1304523757.895" 
    capture_lex $P6266
    .const 'Sub' $P6224 = "563_1304523757.895" 
    capture_lex $P6224
    .const 'Sub' $P6210 = "562_1304523757.895" 
    capture_lex $P6210
    .const 'Sub' $P6200 = "561_1304523757.895" 
    capture_lex $P6200
    .const 'Sub' $P6148 = "560_1304523757.895" 
    capture_lex $P6148
    .const 'Sub' $P5919 = "555_1304523757.895" 
    capture_lex $P5919
    .const 'Sub' $P5846 = "552_1304523757.895" 
    capture_lex $P5846
    .const 'Sub' $P5838 = "551_1304523757.895" 
    capture_lex $P5838
    .const 'Sub' $P5794 = "549_1304523757.895" 
    capture_lex $P5794
    .const 'Sub' $P5779 = "548_1304523757.895" 
    capture_lex $P5779
    .const 'Sub' $P5756 = "547_1304523757.895" 
    capture_lex $P5756
    .const 'Sub' $P5653 = "546_1304523757.895" 
    capture_lex $P5653
    .const 'Sub' $P5599 = "543_1304523757.895" 
    capture_lex $P5599
    .const 'Sub' $P5470 = "540_1304523757.895" 
    capture_lex $P5470
    .const 'Sub' $P5143 = "533_1304523757.895" 
    capture_lex $P5143
    .const 'Sub' $P5135 = "532_1304523757.895" 
    capture_lex $P5135
    .const 'Sub' $P5127 = "531_1304523757.895" 
    capture_lex $P5127
    .const 'Sub' $P5002 = "529_1304523757.895" 
    capture_lex $P5002
    .const 'Sub' $P4994 = "528_1304523757.895" 
    capture_lex $P4994
    .const 'Sub' $P4979 = "527_1304523757.895" 
    capture_lex $P4979
    .const 'Sub' $P4964 = "526_1304523757.895" 
    capture_lex $P4964
    .const 'Sub' $P4949 = "525_1304523757.895" 
    capture_lex $P4949
    .const 'Sub' $P4927 = "524_1304523757.895" 
    capture_lex $P4927
    .const 'Sub' $P4919 = "523_1304523757.895" 
    capture_lex $P4919
    .const 'Sub' $P4911 = "522_1304523757.895" 
    capture_lex $P4911
    .const 'Sub' $P4903 = "521_1304523757.895" 
    capture_lex $P4903
    .const 'Sub' $P4669 = "515_1304523757.895" 
    capture_lex $P4669
    .const 'Sub' $P4661 = "514_1304523757.895" 
    capture_lex $P4661
    .const 'Sub' $P4653 = "513_1304523757.895" 
    capture_lex $P4653
    .const 'Sub' $P4645 = "512_1304523757.895" 
    capture_lex $P4645
    .const 'Sub' $P4637 = "511_1304523757.895" 
    capture_lex $P4637
    .const 'Sub' $P4629 = "510_1304523757.895" 
    capture_lex $P4629
    .const 'Sub' $P4621 = "509_1304523757.895" 
    capture_lex $P4621
    .const 'Sub' $P4418 = "503_1304523757.895" 
    capture_lex $P4418
    .const 'Sub' $P4391 = "502_1304523757.895" 
    capture_lex $P4391
    .const 'Sub' $P4377 = "501_1304523757.895" 
    capture_lex $P4377
    .const 'Sub' $P4369 = "500_1304523757.895" 
    capture_lex $P4369
    .const 'Sub' $P4361 = "499_1304523757.895" 
    capture_lex $P4361
    .const 'Sub' $P4353 = "498_1304523757.895" 
    capture_lex $P4353
    .const 'Sub' $P4345 = "497_1304523757.895" 
    capture_lex $P4345
    .const 'Sub' $P4337 = "496_1304523757.895" 
    capture_lex $P4337
    .const 'Sub' $P4329 = "495_1304523757.895" 
    capture_lex $P4329
    .const 'Sub' $P4321 = "494_1304523757.895" 
    capture_lex $P4321
    .const 'Sub' $P4313 = "493_1304523757.895" 
    capture_lex $P4313
    .const 'Sub' $P4305 = "492_1304523757.895" 
    capture_lex $P4305
    .const 'Sub' $P4297 = "491_1304523757.895" 
    capture_lex $P4297
    .const 'Sub' $P4289 = "490_1304523757.895" 
    capture_lex $P4289
    .const 'Sub' $P4281 = "489_1304523757.895" 
    capture_lex $P4281
    .const 'Sub' $P4273 = "488_1304523757.895" 
    capture_lex $P4273
    .const 'Sub' $P4257 = "487_1304523757.895" 
    capture_lex $P4257
    .const 'Sub' $P4203 = "486_1304523757.895" 
    capture_lex $P4203
    .const 'Sub' $P4186 = "485_1304523757.895" 
    capture_lex $P4186
    .const 'Sub' $P4162 = "484_1304523757.895" 
    capture_lex $P4162
    .const 'Sub' $P4139 = "483_1304523757.895" 
    capture_lex $P4139
    .const 'Sub' $P4112 = "482_1304523757.895" 
    capture_lex $P4112
    .const 'Sub' $P4075 = "481_1304523757.895" 
    capture_lex $P4075
    .const 'Sub' $P4060 = "480_1304523757.895" 
    capture_lex $P4060
    .const 'Sub' $P4048 = "479_1304523757.895" 
    capture_lex $P4048
    .const 'Sub' $P3997 = "477_1304523757.895" 
    capture_lex $P3997
    .const 'Sub' $P3972 = "476_1304523757.895" 
    capture_lex $P3972
    .const 'Sub' $P3965 = "475_1304523757.895" 
    capture_lex $P3965
    .const 'Sub' $P3923 = "474_1304523757.895" 
    capture_lex $P3923
    .const 'Sub' $P3873 = "472_1304523757.895" 
    capture_lex $P3873
    .const 'Sub' $P3856 = "471_1304523757.895" 
    capture_lex $P3856
    .const 'Sub' $P3817 = "469_1304523757.895" 
    capture_lex $P3817
    .const 'Sub' $P3809 = "468_1304523757.895" 
    capture_lex $P3809
    .const 'Sub' $P3801 = "467_1304523757.895" 
    capture_lex $P3801
    .const 'Sub' $P3784 = "466_1304523757.895" 
    capture_lex $P3784
    .const 'Sub' $P3688 = "464_1304523757.895" 
    capture_lex $P3688
    .const 'Sub' $P3644 = "462_1304523757.895" 
    capture_lex $P3644
    .const 'Sub' $P3495 = "461_1304523757.895" 
    capture_lex $P3495
    .const 'Sub' $P3464 = "460_1304523757.895" 
    capture_lex $P3464
    .const 'Sub' $P3456 = "459_1304523757.895" 
    capture_lex $P3456
    .const 'Sub' $P3327 = "453_1304523757.895" 
    capture_lex $P3327
    .const 'Sub' $P3292 = "451_1304523757.895" 
    capture_lex $P3292
    .const 'Sub' $P3287 = "450_1304523757.895" 
    capture_lex $P3287
    .const 'Sub' $P3282 = "449_1304523757.895" 
    capture_lex $P3282
    .const 'Sub' $P3169 = "446_1304523757.895" 
    capture_lex $P3169
    .const 'Sub' $P3151 = "445_1304523757.895" 
    capture_lex $P3151
    .const 'Sub' $P3076 = "443_1304523757.895" 
    capture_lex $P3076
    .const 'Sub' $P3061 = "442_1304523757.895" 
    capture_lex $P3061
    .const 'Sub' $P2974 = "441_1304523757.895" 
    capture_lex $P2974
    .const 'Sub' $P2948 = "439_1304523757.895" 
    capture_lex $P2948
    .const 'Sub' $P2932 = "438_1304523757.895" 
    capture_lex $P2932
    .const 'Sub' $P2908 = "437_1304523757.895" 
    capture_lex $P2908
    .const 'Sub' $P2872 = "434_1304523757.895" 
    capture_lex $P2872
    .const 'Sub' $P2864 = "433_1304523757.895" 
    capture_lex $P2864
.annotate 'line', 1184
    .const 'Sub' $P2864 = "433_1304523757.895" 
    newclosure $P2871, $P2864
    .lex "xblock_immediate", $P2871
.annotate 'line', 1189
    .const 'Sub' $P2872 = "434_1304523757.895" 
    newclosure $P2907, $P2872
    .lex "block_immediate", $P2907
.annotate 'line', 1199
    .const 'Sub' $P2908 = "437_1304523757.895" 
    newclosure $P2931, $P2908
    .lex "vivitype", $P2931
.annotate 'line', 1218
    .const 'Sub' $P2932 = "438_1304523757.895" 
    newclosure $P2947, $P2932
    .lex "colonpair_str", $P2947
.annotate 'line', 1391
    .const 'Sub' $P2948 = "439_1304523757.895" 
    newclosure $P2973, $P2948
    .lex "import_HOW_exports", $P2973
.annotate 'line', 1496
    .const 'Sub' $P2974 = "441_1304523757.895" 
    newclosure $P3060, $P2974
    .lex "push_block_handler", $P3060
.annotate 'line', 2002
    .const 'Sub' $P3061 = "442_1304523757.895" 
    newclosure $P3075, $P3061
    .lex "only_star_block", $P3075
.annotate 'line', 2011
    .const 'Sub' $P3076 = "443_1304523757.895" 
    newclosure $P3150, $P3076
    .lex "attach_multi_signature", $P3150
.annotate 'line', 2463
    .const 'Sub' $P3151 = "445_1304523757.895" 
    newclosure $P3168, $P3151
    .lex "control", $P3168
.annotate 'line', 2482
    .const 'Sub' $P3169 = "446_1304523757.895" 
    newclosure $P3281, $P3169
    .lex "lexical_package_lookup", $P3281
.annotate 'line', 2531
    .const 'Sub' $P3282 = "449_1304523757.895" 
    newclosure $P3286, $P3282
    .lex "is_lexical", $P3286
.annotate 'line', 2537
    .const 'Sub' $P3287 = "450_1304523757.895" 
    newclosure $P3291, $P3287
    .lex "is_package", $P3291
.annotate 'line', 2543
    .const 'Sub' $P3292 = "451_1304523757.895" 
    newclosure $P3326, $P3292
    .lex "is_scope", $P3326
.annotate 'line', 2566
    .const 'Sub' $P3327 = "453_1304523757.895" 
    newclosure $P3447, $P3327
    .lex "find_sym", $P3447
.annotate 'line', 1180
    .lex "$?PACKAGE", $P3448
    .lex "$?CLASS", $P3449
.annotate 'line', 1182
    new $P3450, "ResizablePMCArray"
    find_lex $P3451, "$?PACKAGE"
    get_who $P3452, $P3451
    set $P3452["@BLOCK"], $P3450
    find_lex $P3453, "xblock_immediate"
    find_lex $P3454, "block_immediate"
    find_lex $P3455, "vivitype"
.annotate 'line', 1210
    find_lex $P3494, "colonpair_str"
.annotate 'line', 1374
    find_lex $P3922, "import_HOW_exports"
.annotate 'line', 1489
    find_lex $P4185, "push_block_handler"
.annotate 'line', 1949
    find_lex $P5597, "only_star_block"
    find_lex $P5598, "attach_multi_signature"
.annotate 'line', 2454
    find_lex $P6865, "control"
.annotate 'line', 2476
    find_lex $P6892, "lexical_package_lookup"
    find_lex $P6893, "is_lexical"
    find_lex $P6894, "is_package"
    find_lex $P6895, "is_scope"
.annotate 'line', 2554
    find_lex $P6915, "find_sym"
.annotate 'line', 1180
    .return ($P6915)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("433_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_2865
.annotate 'line', 1184
    .lex "$xblock", param_2865
.annotate 'line', 1185
    find_lex $P2866, "$xblock"
    unless_null $P2866, vivify_1684
    $P2866 = root_new ['parrot';'ResizablePMCArray']
  vivify_1684:
    set $P2867, $P2866[1]
    unless_null $P2867, vivify_1685
    new $P2867, "Undef"
  vivify_1685:
    $P2868 = "block_immediate"($P2867)
    find_lex $P2869, "$xblock"
    unless_null $P2869, vivify_1686
    $P2869 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2869
  vivify_1686:
    set $P2869[1], $P2868
    find_lex $P2870, "$xblock"
    unless_null $P2870, vivify_1687
    new $P2870, "Undef"
  vivify_1687:
.annotate 'line', 1184
    .return ($P2870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("434_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_2873
.annotate 'line', 1189
    .const 'Sub' $P2883 = "435_1304523757.895" 
    capture_lex $P2883
    .lex "$block", param_2873
.annotate 'line', 1190
    find_lex $P2874, "$block"
    unless_null $P2874, vivify_1688
    new $P2874, "Undef"
  vivify_1688:
    $P2874."blocktype"("immediate")
.annotate 'line', 1191
    find_lex $P2878, "$block"
    unless_null $P2878, vivify_1689
    new $P2878, "Undef"
  vivify_1689:
    $P2879 = $P2878."symtable"()
    unless $P2879, unless_2877
    set $P2876, $P2879
    goto unless_2877_end
  unless_2877:
    find_lex $P2880, "$block"
    unless_null $P2880, vivify_1690
    new $P2880, "Undef"
  vivify_1690:
    $P2881 = $P2880."handlers"()
    set $P2876, $P2881
  unless_2877_end:
    if $P2876, unless_2875_end
    .const 'Sub' $P2883 = "435_1304523757.895" 
    capture_lex $P2883
    $P2883()
  unless_2875_end:
    find_lex $P2906, "$block"
    unless_null $P2906, vivify_1697
    new $P2906, "Undef"
  vivify_1697:
.annotate 'line', 1189
    .return ($P2906)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2882"  :anon :subid("435_1304523757.895") :outer("434_1304523757.895")
.annotate 'line', 1191
    .const 'Sub' $P2897 = "436_1304523757.895" 
    capture_lex $P2897
.annotate 'line', 1192
    new $P2884, "Undef"
    .lex "$stmts", $P2884
    get_hll_global $P2885, "GLOBAL"
    nqp_get_package_through_who $P2886, $P2885, "PAST"
    get_who $P2887, $P2886
    set $P2888, $P2887["Stmts"]
    find_lex $P2889, "$block"
    unless_null $P2889, vivify_1691
    new $P2889, "Undef"
  vivify_1691:
    $P2890 = $P2888."new"($P2889 :named("node"))
    store_lex "$stmts", $P2890
.annotate 'line', 1193
    find_lex $P2892, "$block"
    unless_null $P2892, vivify_1692
    new $P2892, "Undef"
  vivify_1692:
    $P2893 = $P2892."list"()
    defined $I2894, $P2893
    unless $I2894, for_undef_1693
    iter $P2891, $P2893
    new $P2903, 'ExceptionHandler'
    set_label $P2903, loop2902_handler
    $P2903."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2903
  loop2902_test:
    unless $P2891, loop2902_done
    shift $P2895, $P2891
  loop2902_redo:
    .const 'Sub' $P2897 = "436_1304523757.895" 
    capture_lex $P2897
    $P2897($P2895)
  loop2902_next:
    goto loop2902_test
  loop2902_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2904, exception, 'type'
    eq $P2904, .CONTROL_LOOP_NEXT, loop2902_next
    eq $P2904, .CONTROL_LOOP_REDO, loop2902_redo
  loop2902_done:
    pop_eh 
  for_undef_1693:
.annotate 'line', 1194
    find_lex $P2905, "$stmts"
    unless_null $P2905, vivify_1696
    new $P2905, "Undef"
  vivify_1696:
    store_lex "$block", $P2905
.annotate 'line', 1191
    .return ($P2905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2896"  :anon :subid("436_1304523757.895") :outer("435_1304523757.895")
    .param pmc param_2898
.annotate 'line', 1193
    .lex "$_", param_2898
    find_lex $P2899, "$stmts"
    unless_null $P2899, vivify_1694
    new $P2899, "Undef"
  vivify_1694:
    find_lex $P2900, "$_"
    unless_null $P2900, vivify_1695
    new $P2900, "Undef"
  vivify_1695:
    $P2901 = $P2899."push"($P2900)
    .return ($P2901)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("437_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_2909
.annotate 'line', 1199
    .lex "$sigil", param_2909
.annotate 'line', 1200
    find_lex $P2912, "$sigil"
    unless_null $P2912, vivify_1698
    new $P2912, "Undef"
  vivify_1698:
    set $S2913, $P2912
    iseq $I2914, $S2913, "%"
    if $I2914, if_2911
.annotate 'line', 1202
    find_lex $P2922, "$sigil"
    unless_null $P2922, vivify_1699
    new $P2922, "Undef"
  vivify_1699:
    set $S2923, $P2922
    iseq $I2924, $S2923, "@"
    if $I2924, if_2921
    new $P2930, "String"
    assign $P2930, "Undef"
    set $P2920, $P2930
    goto if_2921_end
  if_2921:
.annotate 'line', 1203
    get_hll_global $P2925, "GLOBAL"
    nqp_get_package_through_who $P2926, $P2925, "PAST"
    get_who $P2927, $P2926
    set $P2928, $P2927["Op"]
    $P2929 = $P2928."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2920, $P2929
  if_2921_end:
    set $P2910, $P2920
.annotate 'line', 1200
    goto if_2911_end
  if_2911:
.annotate 'line', 1201
    get_hll_global $P2915, "GLOBAL"
    nqp_get_package_through_who $P2916, $P2915, "PAST"
    get_who $P2917, $P2916
    set $P2918, $P2917["Op"]
    $P2919 = $P2918."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2910, $P2919
  if_2911_end:
.annotate 'line', 1199
    .return ($P2910)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("438_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_2933
.annotate 'line', 1218
    .lex "$ast", param_2933
.annotate 'line', 1219
    get_hll_global $P2936, "GLOBAL"
    nqp_get_package_through_who $P2937, $P2936, "PAST"
    get_who $P2938, $P2937
    set $P2939, $P2938["Op"]
    find_lex $P2940, "$ast"
    unless_null $P2940, vivify_1700
    new $P2940, "Undef"
  vivify_1700:
    $P2941 = $P2939."ACCEPTS"($P2940)
    if $P2941, if_2935
.annotate 'line', 1221
    find_lex $P2945, "$ast"
    unless_null $P2945, vivify_1701
    new $P2945, "Undef"
  vivify_1701:
    $P2946 = $P2945."value"()
    set $P2934, $P2946
.annotate 'line', 1219
    goto if_2935_end
  if_2935:
.annotate 'line', 1220
    find_lex $P2942, "$ast"
    unless_null $P2942, vivify_1702
    new $P2942, "Undef"
  vivify_1702:
    $P2943 = $P2942."list"()
    join $S2944, " ", $P2943
    new $P2934, 'String'
    set $P2934, $S2944
  if_2935_end:
.annotate 'line', 1218
    .return ($P2934)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("439_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_2949
.annotate 'line', 1391
    .const 'Sub' $P2961 = "440_1304523757.895" 
    capture_lex $P2961
    .lex "$UNIT", param_2949
.annotate 'line', 1393
    find_lex $P2952, "$UNIT"
    unless_null $P2952, vivify_1703
    new $P2952, "Undef"
  vivify_1703:
    exists $I2953, $P2952["EXPORTHOW"]
    if $I2953, if_2951
    new $P2950, 'Integer'
    set $P2950, $I2953
    goto if_2951_end
  if_2951:
.annotate 'line', 1394
    find_lex $P2955, "$UNIT"
    unless_null $P2955, vivify_1704
    $P2955 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P2956, $P2955["EXPORTHOW"]
    unless_null $P2956, vivify_1705
    new $P2956, "Undef"
  vivify_1705:
    get_who $P2957, $P2956
    defined $I2958, $P2957
    unless $I2958, for_undef_1706
    iter $P2954, $P2957
    new $P2971, 'ExceptionHandler'
    set_label $P2971, loop2970_handler
    $P2971."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2971
  loop2970_test:
    unless $P2954, loop2970_done
    shift $P2959, $P2954
  loop2970_redo:
    .const 'Sub' $P2961 = "440_1304523757.895" 
    capture_lex $P2961
    $P2961($P2959)
  loop2970_next:
    goto loop2970_test
  loop2970_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2972, exception, 'type'
    eq $P2972, .CONTROL_LOOP_NEXT, loop2970_next
    eq $P2972, .CONTROL_LOOP_REDO, loop2970_redo
  loop2970_done:
    pop_eh 
  for_undef_1706:
.annotate 'line', 1393
    set $P2950, $P2954
  if_2951_end:
.annotate 'line', 1391
    .return ($P2950)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2960"  :anon :subid("440_1304523757.895") :outer("439_1304523757.895")
    .param pmc param_2962
.annotate 'line', 1394
    .lex "$_", param_2962
.annotate 'line', 1395
    find_lex $P2963, "$_"
    unless_null $P2963, vivify_1707
    new $P2963, "Undef"
  vivify_1707:
    $P2964 = $P2963."value"()
    find_lex $P2965, "$_"
    unless_null $P2965, vivify_1708
    new $P2965, "Undef"
  vivify_1708:
    $P2966 = $P2965."key"()
    find_dynamic_lex $P2969, "%*HOW"
    unless_null $P2969, vivify_1709
    get_hll_global $P2967, "GLOBAL"
    get_who $P2968, $P2967
    set $P2969, $P2968["%HOW"]
    unless_null $P2969, vivify_1710
    die "Contextual %*HOW not found"
  vivify_1710:
    store_dynamic_lex "%*HOW", $P2969
  vivify_1709:
    set $P2969[$P2966], $P2964
.annotate 'line', 1394
    .return ($P2964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("441_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_2975
    .param pmc param_2976
.annotate 'line', 1496
    .lex "$/", param_2975
    .lex "$block", param_2976
.annotate 'line', 1497
    find_lex $P2978, "$?PACKAGE"
    get_who $P2979, $P2978
    set $P2980, $P2979["@BLOCK"]
    unless_null $P2980, vivify_1711
    $P2980 = root_new ['parrot';'ResizablePMCArray']
  vivify_1711:
    set $P2981, $P2980[0]
    unless_null $P2981, vivify_1712
    new $P2981, "Undef"
  vivify_1712:
    $P2982 = $P2981."handlers"()
    if $P2982, unless_2977_end
.annotate 'line', 1498
    find_lex $P2983, "$?PACKAGE"
    get_who $P2984, $P2983
    set $P2985, $P2984["@BLOCK"]
    unless_null $P2985, vivify_1713
    $P2985 = root_new ['parrot';'ResizablePMCArray']
  vivify_1713:
    set $P2986, $P2985[0]
    unless_null $P2986, vivify_1714
    new $P2986, "Undef"
  vivify_1714:
    new $P2987, "ResizablePMCArray"
    $P2986."handlers"($P2987)
  unless_2977_end:
.annotate 'line', 1500
    find_lex $P2989, "$block"
    unless_null $P2989, vivify_1715
    new $P2989, "Undef"
  vivify_1715:
    $P2990 = $P2989."arity"()
    if $P2990, unless_2988_end
.annotate 'line', 1501
    find_lex $P2991, "$block"
    unless_null $P2991, vivify_1716
    new $P2991, "Undef"
  vivify_1716:
.annotate 'line', 1502
    get_hll_global $P2992, "GLOBAL"
    nqp_get_package_through_who $P2993, $P2992, "PAST"
    get_who $P2994, $P2993
    set $P2995, $P2994["Op"]
.annotate 'line', 1503
    get_hll_global $P2996, "GLOBAL"
    nqp_get_package_through_who $P2997, $P2996, "PAST"
    get_who $P2998, $P2997
    set $P2999, $P2998["Var"]
    $P3000 = $P2999."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1504
    get_hll_global $P3001, "GLOBAL"
    nqp_get_package_through_who $P3002, $P3001, "PAST"
    get_who $P3003, $P3002
    set $P3004, $P3003["Var"]
    $P3005 = $P3004."new"("lexical" :named("scope"), "$_" :named("name"))
    $P3006 = $P2995."new"($P3000, $P3005, "bind" :named("pasttype"))
.annotate 'line', 1502
    $P2991."unshift"($P3006)
.annotate 'line', 1507
    find_lex $P3007, "$block"
    unless_null $P3007, vivify_1717
    new $P3007, "Undef"
  vivify_1717:
    get_hll_global $P3008, "GLOBAL"
    nqp_get_package_through_who $P3009, $P3008, "PAST"
    get_who $P3010, $P3009
    set $P3011, $P3010["Var"]
    $P3012 = $P3011."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3007."unshift"($P3012)
.annotate 'line', 1508
    find_lex $P3013, "$block"
    unless_null $P3013, vivify_1718
    new $P3013, "Undef"
  vivify_1718:
    $P3013."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1509
    find_lex $P3014, "$block"
    unless_null $P3014, vivify_1719
    new $P3014, "Undef"
  vivify_1719:
    $P3014."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1510
    find_lex $P3015, "$block"
    unless_null $P3015, vivify_1720
    new $P3015, "Undef"
  vivify_1720:
    $P3015."arity"(1)
  unless_2988_end:
.annotate 'line', 1512
    find_lex $P3016, "$block"
    unless_null $P3016, vivify_1721
    new $P3016, "Undef"
  vivify_1721:
    $P3016."blocktype"("declaration")
.annotate 'line', 1513
    find_lex $P3017, "$?PACKAGE"
    get_who $P3018, $P3017
    set $P3019, $P3018["@BLOCK"]
    unless_null $P3019, vivify_1722
    $P3019 = root_new ['parrot';'ResizablePMCArray']
  vivify_1722:
    set $P3020, $P3019[0]
    unless_null $P3020, vivify_1723
    new $P3020, "Undef"
  vivify_1723:
    $P3021 = $P3020."handlers"()
.annotate 'line', 1514
    get_hll_global $P3022, "GLOBAL"
    nqp_get_package_through_who $P3023, $P3022, "PAST"
    get_who $P3024, $P3023
    set $P3025, $P3024["Control"]
    find_lex $P3026, "$/"
    unless_null $P3026, vivify_1724
    new $P3026, "Undef"
  vivify_1724:
.annotate 'line', 1516
    get_hll_global $P3027, "GLOBAL"
    nqp_get_package_through_who $P3028, $P3027, "PAST"
    get_who $P3029, $P3028
    set $P3030, $P3029["Stmts"]
.annotate 'line', 1517
    get_hll_global $P3031, "GLOBAL"
    nqp_get_package_through_who $P3032, $P3031, "PAST"
    get_who $P3033, $P3032
    set $P3034, $P3033["Op"]
    find_lex $P3035, "$block"
    unless_null $P3035, vivify_1725
    new $P3035, "Undef"
  vivify_1725:
.annotate 'line', 1519
    get_hll_global $P3036, "GLOBAL"
    nqp_get_package_through_who $P3037, $P3036, "PAST"
    get_who $P3038, $P3037
    set $P3039, $P3038["Var"]
    $P3040 = $P3039."new"("register" :named("scope"), "exception" :named("name"))
    $P3041 = $P3034."new"($P3035, $P3040, "call" :named("pasttype"))
.annotate 'line', 1521
    get_hll_global $P3042, "GLOBAL"
    nqp_get_package_through_who $P3043, $P3042, "PAST"
    get_who $P3044, $P3043
    set $P3045, $P3044["Op"]
.annotate 'line', 1522
    get_hll_global $P3046, "GLOBAL"
    nqp_get_package_through_who $P3047, $P3046, "PAST"
    get_who $P3048, $P3047
    set $P3049, $P3048["Var"]
.annotate 'line', 1523
    get_hll_global $P3050, "GLOBAL"
    nqp_get_package_through_who $P3051, $P3050, "PAST"
    get_who $P3052, $P3051
    set $P3053, $P3052["Var"]
    $P3054 = $P3053."new"("register" :named("scope"), "exception" :named("name"))
    $P3055 = $P3049."new"($P3054, "handled", "keyed" :named("scope"))
.annotate 'line', 1522
    $P3056 = $P3045."new"($P3055, 1, "bind" :named("pasttype"))
.annotate 'line', 1521
    $P3057 = $P3030."new"($P3041, $P3056)
.annotate 'line', 1516
    $P3058 = $P3025."new"($P3057, $P3026 :named("node"))
.annotate 'line', 1514
    $P3059 = $P3021."unshift"($P3058)
.annotate 'line', 1496
    .return ($P3059)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("442_1304523757.895") :outer("432_1304523757.895")
.annotate 'line', 2003
    new $P3062, "Undef"
    .lex "$past", $P3062
    find_lex $P3063, "$?PACKAGE"
    get_who $P3064, $P3063
    set $P3065, $P3064["@BLOCK"]
    unless_null $P3065, vivify_1726
    $P3065 = root_new ['parrot';'ResizablePMCArray']
  vivify_1726:
    $P3066 = $P3065."shift"()
    store_lex "$past", $P3066
.annotate 'line', 2004
    find_lex $P3067, "$past"
    unless_null $P3067, vivify_1727
    new $P3067, "Undef"
  vivify_1727:
    $P3067."closure"(1)
.annotate 'line', 2005
    find_lex $P3068, "$past"
    unless_null $P3068, vivify_1728
    new $P3068, "Undef"
  vivify_1728:
    get_hll_global $P3069, "GLOBAL"
    nqp_get_package_through_who $P3070, $P3069, "PAST"
    get_who $P3071, $P3070
    set $P3072, $P3071["Op"]
    $P3073 = $P3072."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P3068."push"($P3073)
    find_lex $P3074, "$past"
    unless_null $P3074, vivify_1729
    new $P3074, "Undef"
  vivify_1729:
.annotate 'line', 2002
    .return ($P3074)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("443_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3077
.annotate 'line', 2011
    .const 'Sub' $P3097 = "444_1304523757.895" 
    capture_lex $P3097
    .lex "$routine", param_3077
.annotate 'line', 2015
    new $P3078, "Undef"
    .lex "$types", $P3078
.annotate 'line', 2016
    new $P3079, "Undef"
    .lex "$definednesses", $P3079
.annotate 'line', 2015
    get_hll_global $P3080, "GLOBAL"
    nqp_get_package_through_who $P3081, $P3080, "PAST"
    get_who $P3082, $P3081
    set $P3083, $P3082["Op"]
    $P3084 = $P3083."new"("list" :named("pasttype"))
    store_lex "$types", $P3084
.annotate 'line', 2016
    get_hll_global $P3085, "GLOBAL"
    nqp_get_package_through_who $P3086, $P3085, "PAST"
    get_who $P3087, $P3086
    set $P3088, $P3087["Op"]
    $P3089 = $P3088."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P3089
.annotate 'line', 2017
    find_lex $P3091, "$routine"
    unless_null $P3091, vivify_1730
    $P3091 = root_new ['parrot';'ResizablePMCArray']
  vivify_1730:
    set $P3092, $P3091[0]
    unless_null $P3092, vivify_1731
    new $P3092, "Undef"
  vivify_1731:
    $P3093 = $P3092."list"()
    defined $I3094, $P3093
    unless $I3094, for_undef_1732
    iter $P3090, $P3093
    new $P3141, 'ExceptionHandler'
    set_label $P3141, loop3140_handler
    $P3141."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3141
  loop3140_test:
    unless $P3090, loop3140_done
    shift $P3095, $P3090
  loop3140_redo:
    .const 'Sub' $P3097 = "444_1304523757.895" 
    capture_lex $P3097
    $P3097($P3095)
  loop3140_next:
    goto loop3140_test
  loop3140_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3142, exception, 'type'
    eq $P3142, .CONTROL_LOOP_NEXT, loop3140_next
    eq $P3142, .CONTROL_LOOP_REDO, loop3140_redo
  loop3140_done:
    pop_eh 
  for_undef_1732:
.annotate 'line', 2024
    find_dynamic_lex $P3145, "$*SC"
    unless_null $P3145, vivify_1742
    get_hll_global $P3143, "GLOBAL"
    get_who $P3144, $P3143
    set $P3145, $P3144["$SC"]
    unless_null $P3145, vivify_1743
    die "Contextual $*SC not found"
  vivify_1743:
  vivify_1742:
    find_lex $P3146, "$routine"
    unless_null $P3146, vivify_1744
    new $P3146, "Undef"
  vivify_1744:
    find_lex $P3147, "$types"
    unless_null $P3147, vivify_1745
    new $P3147, "Undef"
  vivify_1745:
    find_lex $P3148, "$definednesses"
    unless_null $P3148, vivify_1746
    new $P3148, "Undef"
  vivify_1746:
    $P3149 = $P3145."set_routine_signature"($P3146, $P3147, $P3148)
.annotate 'line', 2011
    .return ($P3149)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3096"  :anon :subid("444_1304523757.895") :outer("443_1304523757.895")
    .param pmc param_3098
.annotate 'line', 2017
    .lex "$_", param_3098
.annotate 'line', 2018
    get_hll_global $P3103, "GLOBAL"
    nqp_get_package_through_who $P3104, $P3103, "PAST"
    get_who $P3105, $P3104
    set $P3106, $P3105["Var"]
    find_lex $P3107, "$_"
    unless_null $P3107, vivify_1733
    new $P3107, "Undef"
  vivify_1733:
    $P3108 = $P3106."ACCEPTS"($P3107)
    if $P3108, if_3102
    set $P3101, $P3108
    goto if_3102_end
  if_3102:
    find_lex $P3109, "$_"
    unless_null $P3109, vivify_1734
    new $P3109, "Undef"
  vivify_1734:
    $S3110 = $P3109."scope"()
    iseq $I3111, $S3110, "parameter"
    new $P3101, 'Integer'
    set $P3101, $I3111
  if_3102_end:
    if $P3101, if_3100
    set $P3099, $P3101
    goto if_3100_end
  if_3100:
.annotate 'line', 2019
    find_lex $P3112, "$types"
    unless_null $P3112, vivify_1735
    new $P3112, "Undef"
  vivify_1735:
    find_lex $P3114, "$_"
    unless_null $P3114, vivify_1736
    new $P3114, "Undef"
  vivify_1736:
    $P3115 = $P3114."multitype"()
    set $P3113, $P3115
    defined $I3117, $P3113
    if $I3117, default_3116
    get_hll_global $P3118, "GLOBAL"
    nqp_get_package_through_who $P3119, $P3118, "PAST"
    get_who $P3120, $P3119
    set $P3121, $P3120["Op"]
    $P3122 = $P3121."new"("null P" :named("pirop"))
    set $P3113, $P3122
  default_3116:
    $P3112."push"($P3113)
.annotate 'line', 2020
    find_lex $P3123, "$definednesses"
    unless_null $P3123, vivify_1737
    new $P3123, "Undef"
  vivify_1737:
    find_lex $P3126, "$_"
    unless_null $P3126, vivify_1738
    $P3126 = root_new ['parrot';'Hash']
  vivify_1738:
    set $P3127, $P3126["definedness"]
    unless_null $P3127, vivify_1739
    new $P3127, "Undef"
  vivify_1739:
    set $S3128, $P3127
    iseq $I3129, $S3128, "D"
    if $I3129, if_3125
.annotate 'line', 2021
    find_lex $P3133, "$_"
    unless_null $P3133, vivify_1740
    $P3133 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3134, $P3133["definedness"]
    unless_null $P3134, vivify_1741
    new $P3134, "Undef"
  vivify_1741:
    set $S3135, $P3134
    iseq $I3136, $S3135, "U"
    if $I3136, if_3132
    new $P3138, "Integer"
    assign $P3138, 0
    set $P3131, $P3138
    goto if_3132_end
  if_3132:
    new $P3137, "Integer"
    assign $P3137, 2
    set $P3131, $P3137
  if_3132_end:
    set $P3124, $P3131
.annotate 'line', 2020
    goto if_3125_end
  if_3125:
    new $P3130, "Integer"
    assign $P3130, 1
    set $P3124, $P3130
  if_3125_end:
    $P3139 = $P3123."push"($P3124)
.annotate 'line', 2018
    set $P3099, $P3139
  if_3100_end:
.annotate 'line', 2017
    .return ($P3099)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("445_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3152
    .param pmc param_3153
.annotate 'line', 2463
    .lex "$/", param_3152
    .lex "$type", param_3153
.annotate 'line', 2464
    find_lex $P3154, "$/"
    get_hll_global $P3155, "GLOBAL"
    nqp_get_package_through_who $P3156, $P3155, "PAST"
    get_who $P3157, $P3156
    set $P3158, $P3157["Op"]
    find_lex $P3159, "$/"
    unless_null $P3159, vivify_1747
    new $P3159, "Undef"
  vivify_1747:
.annotate 'line', 2468
    get_hll_global $P3160, "GLOBAL"
    nqp_get_package_through_who $P3161, $P3160, "PAST"
    get_who $P3162, $P3161
    set $P3163, $P3162["Val"]
    find_lex $P3164, "$type"
    unless_null $P3164, vivify_1748
    new $P3164, "Undef"
  vivify_1748:
    $P3165 = $P3163."new"($P3164 :named("value"), "!except_types" :named("returns"))
    $P3166 = $P3158."new"(0, $P3165, $P3159 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2464
    $P3167 = $P3154."!make"($P3166)
.annotate 'line', 2463
    .return ($P3167)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("446_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3172
    .param pmc param_3173
.annotate 'line', 2482
    .const 'Sub' $P3226 = "447_1304523757.895" 
    capture_lex $P3226
    new $P3171, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3171, control_3170
    push_eh $P3171
    .lex "@name", param_3172
    .lex "$/", param_3173
.annotate 'line', 2488
    new $P3174, "Undef"
    .lex "$final_name", $P3174
.annotate 'line', 2489
    new $P3175, "Undef"
    .lex "$lookup", $P3175
.annotate 'line', 2484
    find_lex $P3177, "@name"
    unless_null $P3177, vivify_1749
    $P3177 = root_new ['parrot';'ResizablePMCArray']
  vivify_1749:
    set $N3178, $P3177
    iseq $I3179, $N3178, 0.0
    unless $I3179, if_3176_end
    find_lex $P3180, "$/"
    unless_null $P3180, vivify_1750
    new $P3180, "Undef"
  vivify_1750:
    $P3181 = $P3180."CURSOR"()
    $P3181."panic"("Cannot compile empty name")
  if_3176_end:
.annotate 'line', 2488
    find_lex $P3182, "@name"
    unless_null $P3182, vivify_1751
    $P3182 = root_new ['parrot';'ResizablePMCArray']
  vivify_1751:
    $P3183 = $P3182."pop"()
    store_lex "$final_name", $P3183
.annotate 'line', 2489
    get_hll_global $P3184, "GLOBAL"
    nqp_get_package_through_who $P3185, $P3184, "PAST"
    get_who $P3186, $P3185
    set $P3187, $P3186["Var"]
    find_lex $P3188, "$final_name"
    unless_null $P3188, vivify_1752
    new $P3188, "Undef"
  vivify_1752:
    set $S3189, $P3188
    $P3190 = $P3187."new"($S3189, "keyed" :named("scope"))
    store_lex "$lookup", $P3190
.annotate 'line', 2493
    find_lex $P3192, "@name"
    unless_null $P3192, vivify_1753
    $P3192 = root_new ['parrot';'ResizablePMCArray']
  vivify_1753:
    set $N3193, $P3192
    iseq $I3194, $N3193, 0.0
    if $I3194, if_3191
.annotate 'line', 2511
    .const 'Sub' $P3226 = "447_1304523757.895" 
    capture_lex $P3226
    $P3226()
    goto if_3191_end
  if_3191:
.annotate 'line', 2494
    find_lex $P3195, "$lookup"
    unless_null $P3195, vivify_1766
    new $P3195, "Undef"
  vivify_1766:
    get_hll_global $P3196, "GLOBAL"
    nqp_get_package_through_who $P3197, $P3196, "PAST"
    get_who $P3198, $P3197
    set $P3199, $P3198["Op"]
.annotate 'line', 2496
    get_hll_global $P3200, "GLOBAL"
    nqp_get_package_through_who $P3201, $P3200, "PAST"
    get_who $P3202, $P3201
    set $P3203, $P3202["Var"]
    $P3204 = $P3203."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3205 = $P3199."new"($P3204, "get_who PP" :named("pirop"))
.annotate 'line', 2494
    $P3195."unshift"($P3205)
.annotate 'line', 2498
    find_lex $P3206, "$lookup"
    unless_null $P3206, vivify_1767
    new $P3206, "Undef"
  vivify_1767:
    get_hll_global $P3207, "GLOBAL"
    nqp_get_package_through_who $P3208, $P3207, "PAST"
    get_who $P3209, $P3208
    set $P3210, $P3209["Var"]
.annotate 'line', 2500
    get_hll_global $P3211, "GLOBAL"
    nqp_get_package_through_who $P3212, $P3211, "PAST"
    get_who $P3213, $P3212
    set $P3214, $P3213["Op"]
.annotate 'line', 2502
    get_hll_global $P3215, "GLOBAL"
    nqp_get_package_through_who $P3216, $P3215, "PAST"
    get_who $P3217, $P3216
    set $P3218, $P3217["Var"]
    new $P3219, "ResizablePMCArray"
    $P3220 = $P3218."new"("GLOBAL" :named("name"), $P3219 :named("namespace"), "package" :named("scope"))
    $P3221 = $P3214."new"($P3220, "get_who PP" :named("pirop"))
.annotate 'line', 2504
    find_lex $P3222, "$final_name"
    unless_null $P3222, vivify_1768
    new $P3222, "Undef"
  vivify_1768:
    set $S3223, $P3222
    $P3224 = $P3210."new"($P3221, $S3223, "keyed" :named("scope"))
.annotate 'line', 2498
    $P3206."viviself"($P3224)
  if_3191_end:
.annotate 'line', 2526
    new $P3278, "Exception"
    set $P3278['type'], .CONTROL_RETURN
    find_lex $P3279, "$lookup"
    unless_null $P3279, vivify_1769
    new $P3279, "Undef"
  vivify_1769:
    setattribute $P3278, 'payload', $P3279
    throw $P3278
.annotate 'line', 2482
    .return ()
  control_3170:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3280, exception, "payload"
    .return ($P3280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3225"  :anon :subid("447_1304523757.895") :outer("446_1304523757.895")
.annotate 'line', 2511
    .const 'Sub' $P3257 = "448_1304523757.895" 
    capture_lex $P3257
.annotate 'line', 2512
    new $P3227, "Undef"
    .lex "$path", $P3227
    find_lex $P3230, "@name"
    unless_null $P3230, vivify_1754
    $P3230 = root_new ['parrot';'ResizablePMCArray']
  vivify_1754:
    set $P3231, $P3230[0]
    unless_null $P3231, vivify_1755
    new $P3231, "Undef"
  vivify_1755:
    $P3232 = "is_lexical"($P3231)
    if $P3232, if_3229
.annotate 'line', 2514
    get_hll_global $P3240, "GLOBAL"
    nqp_get_package_through_who $P3241, $P3240, "PAST"
    get_who $P3242, $P3241
    set $P3243, $P3242["Var"]
    new $P3244, "ResizablePMCArray"
    $P3245 = $P3243."new"("GLOBAL" :named("name"), $P3244 :named("namespace"), "package" :named("scope"))
    set $P3228, $P3245
.annotate 'line', 2512
    goto if_3229_end
  if_3229:
.annotate 'line', 2513
    get_hll_global $P3233, "GLOBAL"
    nqp_get_package_through_who $P3234, $P3233, "PAST"
    get_who $P3235, $P3234
    set $P3236, $P3235["Var"]
    find_lex $P3237, "@name"
    unless_null $P3237, vivify_1756
    $P3237 = root_new ['parrot';'ResizablePMCArray']
  vivify_1756:
    $P3238 = $P3237."shift"()
    $P3239 = $P3236."new"($P3238 :named("name"), "lexical" :named("scope"))
    set $P3228, $P3239
  if_3229_end:
.annotate 'line', 2512
    store_lex "$path", $P3228
.annotate 'line', 2515
    find_lex $P3247, "@name"
    unless_null $P3247, vivify_1757
    $P3247 = root_new ['parrot';'ResizablePMCArray']
  vivify_1757:
    set $P3248, $P3247[0]
    unless_null $P3248, vivify_1758
    new $P3248, "Undef"
  vivify_1758:
    set $S3249, $P3248
    iseq $I3250, $S3249, "GLOBAL"
    unless $I3250, if_3246_end
.annotate 'line', 2516
    find_lex $P3251, "@name"
    unless_null $P3251, vivify_1759
    $P3251 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    $P3251."shift"()
  if_3246_end:
.annotate 'line', 2518
    find_lex $P3253, "@name"
    unless_null $P3253, vivify_1760
    $P3253 = root_new ['parrot';'ResizablePMCArray']
  vivify_1760:
    defined $I3254, $P3253
    unless $I3254, for_undef_1761
    iter $P3252, $P3253
    new $P3268, 'ExceptionHandler'
    set_label $P3268, loop3267_handler
    $P3268."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3268
  loop3267_test:
    unless $P3252, loop3267_done
    shift $P3255, $P3252
  loop3267_redo:
    .const 'Sub' $P3257 = "448_1304523757.895" 
    capture_lex $P3257
    $P3257($P3255)
  loop3267_next:
    goto loop3267_test
  loop3267_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3269, exception, 'type'
    eq $P3269, .CONTROL_LOOP_NEXT, loop3267_next
    eq $P3269, .CONTROL_LOOP_REDO, loop3267_redo
  loop3267_done:
    pop_eh 
  for_undef_1761:
.annotate 'line', 2523
    find_lex $P3270, "$lookup"
    unless_null $P3270, vivify_1764
    new $P3270, "Undef"
  vivify_1764:
    get_hll_global $P3271, "GLOBAL"
    nqp_get_package_through_who $P3272, $P3271, "PAST"
    get_who $P3273, $P3272
    set $P3274, $P3273["Op"]
    find_lex $P3275, "$path"
    unless_null $P3275, vivify_1765
    new $P3275, "Undef"
  vivify_1765:
    $P3276 = $P3274."new"($P3275, "get_who PP" :named("pirop"))
    $P3277 = $P3270."unshift"($P3276)
.annotate 'line', 2511
    .return ($P3277)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3256"  :anon :subid("448_1304523757.895") :outer("447_1304523757.895")
    .param pmc param_3258
.annotate 'line', 2518
    .lex "$_", param_3258
.annotate 'line', 2519
    get_hll_global $P3259, "GLOBAL"
    nqp_get_package_through_who $P3260, $P3259, "PAST"
    get_who $P3261, $P3260
    set $P3262, $P3261["Op"]
    find_lex $P3263, "$path"
    unless_null $P3263, vivify_1762
    new $P3263, "Undef"
  vivify_1762:
.annotate 'line', 2521
    find_lex $P3264, "$_"
    unless_null $P3264, vivify_1763
    new $P3264, "Undef"
  vivify_1763:
    set $S3265, $P3264
    $P3266 = $P3262."new"($P3263, $S3265, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2519
    store_lex "$path", $P3266
.annotate 'line', 2518
    .return ($P3266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("449_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3283
.annotate 'line', 2531
    .lex "$name", param_3283
.annotate 'line', 2532
    find_lex $P3284, "$name"
    unless_null $P3284, vivify_1770
    new $P3284, "Undef"
  vivify_1770:
    $P3285 = "is_scope"($P3284, "lexical")
.annotate 'line', 2531
    .return ($P3285)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("450_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3288
.annotate 'line', 2537
    .lex "$name", param_3288
.annotate 'line', 2538
    find_lex $P3289, "$name"
    unless_null $P3289, vivify_1771
    new $P3289, "Undef"
  vivify_1771:
    $P3290 = "is_scope"($P3289, "package")
.annotate 'line', 2537
    .return ($P3290)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("451_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3295
    .param pmc param_3296
.annotate 'line', 2543
    .const 'Sub' $P3304 = "452_1304523757.895" 
    capture_lex $P3304
    new $P3294, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3294, control_3293
    push_eh $P3294
    .lex "$name", param_3295
    .lex "$wanted_scope", param_3296
.annotate 'line', 2544
    find_lex $P3298, "$?PACKAGE"
    get_who $P3299, $P3298
    set $P3300, $P3299["@BLOCK"]
    unless_null $P3300, vivify_1772
    $P3300 = root_new ['parrot';'ResizablePMCArray']
  vivify_1772:
    defined $I3301, $P3300
    unless $I3301, for_undef_1773
    iter $P3297, $P3300
    new $P3323, 'ExceptionHandler'
    set_label $P3323, loop3322_handler
    $P3323."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3323
  loop3322_test:
    unless $P3297, loop3322_done
    shift $P3302, $P3297
  loop3322_redo:
    .const 'Sub' $P3304 = "452_1304523757.895" 
    capture_lex $P3304
    $P3304($P3302)
  loop3322_next:
    goto loop3322_test
  loop3322_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3324, exception, 'type'
    eq $P3324, .CONTROL_LOOP_NEXT, loop3322_next
    eq $P3324, .CONTROL_LOOP_REDO, loop3322_redo
  loop3322_done:
    pop_eh 
  for_undef_1773:
.annotate 'line', 2543
    .return (0)
  control_3293:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3325, exception, "payload"
    .return ($P3325)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3303"  :anon :subid("452_1304523757.895") :outer("451_1304523757.895")
    .param pmc param_3306
.annotate 'line', 2545
    $P3305 = root_new ['parrot';'Hash']
    .lex "%sym", $P3305
    .lex "$_", param_3306
    find_lex $P3307, "$_"
    unless_null $P3307, vivify_1774
    new $P3307, "Undef"
  vivify_1774:
    find_lex $P3308, "$name"
    unless_null $P3308, vivify_1775
    new $P3308, "Undef"
  vivify_1775:
    $P3309 = $P3307."symbol"($P3308)
    store_lex "%sym", $P3309
.annotate 'line', 2546
    find_lex $P3312, "%sym"
    unless_null $P3312, vivify_1776
    $P3312 = root_new ['parrot';'Hash']
  vivify_1776:
    set $N3313, $P3312
    if $N3313, if_3311
    new $P3310, 'Float'
    set $P3310, $N3313
    goto if_3311_end
  if_3311:
.annotate 'line', 2547
    new $P3314, "Exception"
    set $P3314['type'], .CONTROL_RETURN
    find_lex $P3315, "%sym"
    unless_null $P3315, vivify_1777
    $P3315 = root_new ['parrot';'Hash']
  vivify_1777:
    set $P3316, $P3315["scope"]
    unless_null $P3316, vivify_1778
    new $P3316, "Undef"
  vivify_1778:
    set $S3317, $P3316
    find_lex $P3318, "$wanted_scope"
    unless_null $P3318, vivify_1779
    new $P3318, "Undef"
  vivify_1779:
    set $S3319, $P3318
    iseq $I3320, $S3317, $S3319
    new $P3321, 'Integer'
    set $P3321, $I3320
    setattribute $P3314, 'payload', $P3321
    throw $P3314
  if_3311_end:
.annotate 'line', 2544
    .return ($P3310)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("453_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3330
    .param pmc param_3331
.annotate 'line', 2566
    .const 'Sub' $P3425 = "458_1304523757.895" 
    capture_lex $P3425
    .const 'Sub' $P3385 = "456_1304523757.895" 
    capture_lex $P3385
    .const 'Sub' $P3343 = "454_1304523757.895" 
    capture_lex $P3343
    new $P3329, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3329, control_3328
    push_eh $P3329
    .lex "@name", param_3330
    .lex "$/", param_3331
.annotate 'line', 2590
    new $P3332, "Undef"
    .lex "$result", $P3332
.annotate 'line', 2568
    find_lex $P3334, "@name"
    unless_null $P3334, vivify_1780
    $P3334 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    set $N3335, $P3334
    if $N3335, unless_3333_end
    find_lex $P3336, "$/"
    unless_null $P3336, vivify_1781
    new $P3336, "Undef"
  vivify_1781:
    $P3337 = $P3336."CURSOR"()
    $P3337."panic"("Cannot look up empty name")
  unless_3333_end:
.annotate 'line', 2572
    find_lex $P3339, "@name"
    unless_null $P3339, vivify_1782
    $P3339 = root_new ['parrot';'ResizablePMCArray']
  vivify_1782:
    set $N3340, $P3339
    iseq $I3341, $N3340, 1.0
    unless $I3341, if_3338_end
    .const 'Sub' $P3343 = "454_1304523757.895" 
    capture_lex $P3343
    $P3343()
  if_3338_end:
.annotate 'line', 2590
    find_dynamic_lex $P3379, "$*GLOBALish"
    unless_null $P3379, vivify_1794
    get_hll_global $P3377, "GLOBAL"
    get_who $P3378, $P3377
    set $P3379, $P3378["$GLOBALish"]
    unless_null $P3379, vivify_1795
    die "Contextual $*GLOBALish not found"
  vivify_1795:
  vivify_1794:
    store_lex "$result", $P3379
.annotate 'line', 2591
    find_lex $P3381, "@name"
    unless_null $P3381, vivify_1796
    $P3381 = root_new ['parrot';'ResizablePMCArray']
  vivify_1796:
    set $N3382, $P3381
    isge $I3383, $N3382, 2.0
    unless $I3383, if_3380_end
    .const 'Sub' $P3385 = "456_1304523757.895" 
    capture_lex $P3385
    $P3385()
  if_3380_end:
.annotate 'line', 2609
    find_lex $P3421, "@name"
    unless_null $P3421, vivify_1809
    $P3421 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    defined $I3422, $P3421
    unless $I3422, for_undef_1810
    iter $P3420, $P3421
    new $P3443, 'ExceptionHandler'
    set_label $P3443, loop3442_handler
    $P3443."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3443
  loop3442_test:
    unless $P3420, loop3442_done
    shift $P3423, $P3420
  loop3442_redo:
    .const 'Sub' $P3425 = "458_1304523757.895" 
    capture_lex $P3425
    $P3425($P3423)
  loop3442_next:
    goto loop3442_test
  loop3442_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3444, exception, 'type'
    eq $P3444, .CONTROL_LOOP_NEXT, loop3442_next
    eq $P3444, .CONTROL_LOOP_REDO, loop3442_redo
  loop3442_done:
    pop_eh 
  for_undef_1810:
    find_lex $P3445, "$result"
    unless_null $P3445, vivify_1817
    new $P3445, "Undef"
  vivify_1817:
.annotate 'line', 2566
    .return ($P3445)
  control_3328:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3446, exception, "payload"
    .return ($P3446)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3342"  :anon :subid("454_1304523757.895") :outer("453_1304523757.895")
.annotate 'line', 2572
    .const 'Sub' $P3354 = "455_1304523757.895" 
    capture_lex $P3354
.annotate 'line', 2573
    new $P3344, "Undef"
    .lex "$final_name", $P3344
    find_lex $P3345, "@name"
    unless_null $P3345, vivify_1783
    $P3345 = root_new ['parrot';'ResizablePMCArray']
  vivify_1783:
    set $P3346, $P3345[0]
    unless_null $P3346, vivify_1784
    new $P3346, "Undef"
  vivify_1784:
    store_lex "$final_name", $P3346
.annotate 'line', 2574
    find_lex $P3348, "$?PACKAGE"
    get_who $P3349, $P3348
    set $P3350, $P3349["@BLOCK"]
    unless_null $P3350, vivify_1785
    $P3350 = root_new ['parrot';'ResizablePMCArray']
  vivify_1785:
    defined $I3351, $P3350
    unless $I3351, for_undef_1786
    iter $P3347, $P3350
    new $P3375, 'ExceptionHandler'
    set_label $P3375, loop3374_handler
    $P3375."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3375
  loop3374_test:
    unless $P3347, loop3374_done
    shift $P3352, $P3347
  loop3374_redo:
    .const 'Sub' $P3354 = "455_1304523757.895" 
    capture_lex $P3354
    $P3354($P3352)
  loop3374_next:
    goto loop3374_test
  loop3374_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3376, exception, 'type'
    eq $P3376, .CONTROL_LOOP_NEXT, loop3374_next
    eq $P3376, .CONTROL_LOOP_REDO, loop3374_redo
  loop3374_done:
    pop_eh 
  for_undef_1786:
.annotate 'line', 2572
    .return ($P3347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3353"  :anon :subid("455_1304523757.895") :outer("454_1304523757.895")
    .param pmc param_3356
.annotate 'line', 2575
    $P3355 = root_new ['parrot';'Hash']
    .lex "%sym", $P3355
    .lex "$_", param_3356
    find_lex $P3357, "$_"
    unless_null $P3357, vivify_1787
    new $P3357, "Undef"
  vivify_1787:
    find_lex $P3358, "$final_name"
    unless_null $P3358, vivify_1788
    new $P3358, "Undef"
  vivify_1788:
    $P3359 = $P3357."symbol"($P3358)
    store_lex "%sym", $P3359
.annotate 'line', 2576
    find_lex $P3362, "%sym"
    unless_null $P3362, vivify_1789
    $P3362 = root_new ['parrot';'Hash']
  vivify_1789:
    set $N3363, $P3362
    if $N3363, if_3361
    new $P3360, 'Float'
    set $P3360, $N3363
    goto if_3361_end
  if_3361:
.annotate 'line', 2577
    find_lex $P3366, "%sym"
    unless_null $P3366, vivify_1790
    $P3366 = root_new ['parrot';'Hash']
  vivify_1790:
    exists $I3367, $P3366["value"]
    if $I3367, if_3365
.annotate 'line', 2581
    new $P3371, 'String'
    set $P3371, "No compile-time value for "
    find_lex $P3372, "$final_name"
    unless_null $P3372, vivify_1791
    new $P3372, "Undef"
  vivify_1791:
    concat $P3373, $P3371, $P3372
    die $P3373
.annotate 'line', 2580
    goto if_3365_end
  if_3365:
.annotate 'line', 2578
    new $P3368, "Exception"
    set $P3368['type'], .CONTROL_RETURN
    find_lex $P3369, "%sym"
    unless_null $P3369, vivify_1792
    $P3369 = root_new ['parrot';'Hash']
  vivify_1792:
    set $P3370, $P3369["value"]
    unless_null $P3370, vivify_1793
    new $P3370, "Undef"
  vivify_1793:
    setattribute $P3368, 'payload', $P3370
    throw $P3368
  if_3365_end:
.annotate 'line', 2576
    set $P3360, $P3364
  if_3361_end:
.annotate 'line', 2574
    .return ($P3360)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3384"  :anon :subid("456_1304523757.895") :outer("453_1304523757.895")
.annotate 'line', 2591
    .const 'Sub' $P3396 = "457_1304523757.895" 
    capture_lex $P3396
.annotate 'line', 2592
    new $P3386, "Undef"
    .lex "$first", $P3386
    find_lex $P3387, "@name"
    unless_null $P3387, vivify_1797
    $P3387 = root_new ['parrot';'ResizablePMCArray']
  vivify_1797:
    set $P3388, $P3387[0]
    unless_null $P3388, vivify_1798
    new $P3388, "Undef"
  vivify_1798:
    store_lex "$first", $P3388
.annotate 'line', 2593
    find_lex $P3390, "$?PACKAGE"
    get_who $P3391, $P3390
    set $P3392, $P3391["@BLOCK"]
    unless_null $P3392, vivify_1799
    $P3392 = root_new ['parrot';'ResizablePMCArray']
  vivify_1799:
    defined $I3393, $P3392
    unless $I3393, for_undef_1800
    iter $P3389, $P3392
    new $P3418, 'ExceptionHandler'
    set_label $P3418, loop3417_handler
    $P3418."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3418
  loop3417_test:
    unless $P3389, loop3417_done
    shift $P3394, $P3389
  loop3417_redo:
    .const 'Sub' $P3396 = "457_1304523757.895" 
    capture_lex $P3396
    $P3396($P3394)
  loop3417_next:
    goto loop3417_test
  loop3417_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3419, exception, 'type'
    eq $P3419, .CONTROL_LOOP_NEXT, loop3417_next
    eq $P3419, .CONTROL_LOOP_REDO, loop3417_redo
  loop3417_done:
    pop_eh 
  for_undef_1800:
.annotate 'line', 2591
    .return ($P3389)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3395"  :anon :subid("457_1304523757.895") :outer("456_1304523757.895")
    .param pmc param_3398
.annotate 'line', 2594
    $P3397 = root_new ['parrot';'Hash']
    .lex "%sym", $P3397
    .lex "$_", param_3398
    find_lex $P3399, "$_"
    unless_null $P3399, vivify_1801
    new $P3399, "Undef"
  vivify_1801:
    find_lex $P3400, "$first"
    unless_null $P3400, vivify_1802
    new $P3400, "Undef"
  vivify_1802:
    $P3401 = $P3399."symbol"($P3400)
    store_lex "%sym", $P3401
.annotate 'line', 2595
    find_lex $P3404, "%sym"
    unless_null $P3404, vivify_1803
    $P3404 = root_new ['parrot';'Hash']
  vivify_1803:
    set $N3405, $P3404
    if $N3405, if_3403
    new $P3402, 'Float'
    set $P3402, $N3405
    goto if_3403_end
  if_3403:
.annotate 'line', 2596
    find_lex $P3408, "%sym"
    unless_null $P3408, vivify_1804
    $P3408 = root_new ['parrot';'Hash']
  vivify_1804:
    exists $I3409, $P3408["value"]
    if $I3409, if_3407
.annotate 'line', 2602
    new $P3414, 'String'
    set $P3414, "No compile-time value for "
    find_lex $P3415, "$first"
    unless_null $P3415, vivify_1805
    new $P3415, "Undef"
  vivify_1805:
    concat $P3416, $P3414, $P3415
    die $P3416
.annotate 'line', 2601
    goto if_3407_end
  if_3407:
.annotate 'line', 2597
    find_lex $P3410, "%sym"
    unless_null $P3410, vivify_1806
    $P3410 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3411, $P3410["value"]
    unless_null $P3411, vivify_1807
    new $P3411, "Undef"
  vivify_1807:
    store_lex "$result", $P3411
.annotate 'line', 2598
    find_lex $P3412, "@name"
    unless_null $P3412, vivify_1808
    $P3412 = root_new ['parrot';'ResizablePMCArray']
  vivify_1808:
    $P3412."shift"()
.annotate 'line', 2599
    set $I3413, .CONTROL_LOOP_LAST
    die 0, $I3413
  if_3407_end:
.annotate 'line', 2595
    set $P3402, $P3406
  if_3403_end:
.annotate 'line', 2593
    .return ($P3402)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3424"  :anon :subid("458_1304523757.895") :outer("453_1304523757.895")
    .param pmc param_3426
.annotate 'line', 2609
    .lex "$_", param_3426
.annotate 'line', 2610
    find_lex $P3431, "$_"
    unless_null $P3431, vivify_1811
    new $P3431, "Undef"
  vivify_1811:
    set $S3432, $P3431
    find_lex $P3429, "$result"
    unless_null $P3429, vivify_1812
    new $P3429, "Undef"
  vivify_1812:
    get_who $P3430, $P3429
    exists $I3433, $P3430[$S3432]
    if $I3433, if_3428
.annotate 'line', 2614
    new $P3438, "String"
    assign $P3438, "Could not locate compile-time value for symbol "
.annotate 'line', 2615
    find_lex $P3439, "@name"
    unless_null $P3439, vivify_1813
    $P3439 = root_new ['parrot';'ResizablePMCArray']
  vivify_1813:
    join $S3440, "::", $P3439
    concat $P3441, $P3438, $S3440
.annotate 'line', 2614
    die $P3441
.annotate 'line', 2613
    goto if_3428_end
  if_3428:
.annotate 'line', 2611
    find_lex $P3434, "$_"
    unless_null $P3434, vivify_1814
    new $P3434, "Undef"
  vivify_1814:
    find_lex $P3435, "$result"
    unless_null $P3435, vivify_1815
    new $P3435, "Undef"
  vivify_1815:
    get_who $P3436, $P3435
    set $P3437, $P3436[$P3434]
    unless_null $P3437, vivify_1816
    new $P3437, "Undef"
  vivify_1816:
    store_lex "$result", $P3437
.annotate 'line', 2610
    set $P3427, $P3437
  if_3428_end:
.annotate 'line', 2609
    .return ($P3427)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("459_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3457
    .param pmc param_3458
.annotate 'line', 1208
    .lex "self", param_3457
    .lex "$/", param_3458
    find_lex $P3459, "$/"
    find_lex $P3460, "$/"
    unless_null $P3460, vivify_1818
    $P3460 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P3461, $P3460["comp_unit"]
    unless_null $P3461, vivify_1819
    new $P3461, "Undef"
  vivify_1819:
    $P3462 = $P3461."ast"()
    $P3463 = $P3459."!make"($P3462)
    .return ($P3463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("460_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3465
    .param pmc param_3466
.annotate 'line', 1210
    .lex "self", param_3465
    .lex "$/", param_3466
.annotate 'line', 1211
    find_lex $P3467, "$/"
.annotate 'line', 1212
    find_lex $P3470, "$/"
    unless_null $P3470, vivify_1820
    $P3470 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P3471, $P3470["colonpair"]
    unless_null $P3471, vivify_1821
    new $P3471, "Undef"
  vivify_1821:
    if $P3471, if_3469
.annotate 'line', 1214
    find_lex $P3491, "$/"
    unless_null $P3491, vivify_1822
    new $P3491, "Undef"
  vivify_1822:
    set $S3492, $P3491
    new $P3468, 'String'
    set $P3468, $S3492
.annotate 'line', 1212
    goto if_3469_end
  if_3469:
    find_lex $P3472, "$/"
    unless_null $P3472, vivify_1823
    $P3472 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P3473, $P3472["identifier"]
    unless_null $P3473, vivify_1824
    new $P3473, "Undef"
  vivify_1824:
    set $S3474, $P3473
    new $P3475, 'String'
    set $P3475, $S3474
    concat $P3476, $P3475, ":"
    find_lex $P3477, "$/"
    unless_null $P3477, vivify_1825
    $P3477 = root_new ['parrot';'Hash']
  vivify_1825:
    set $P3478, $P3477["colonpair"]
    unless_null $P3478, vivify_1826
    $P3478 = root_new ['parrot';'ResizablePMCArray']
  vivify_1826:
    set $P3479, $P3478[0]
    unless_null $P3479, vivify_1827
    new $P3479, "Undef"
  vivify_1827:
    $P3480 = $P3479."ast"()
    $S3481 = $P3480."named"()
    concat $P3482, $P3476, $S3481
    concat $P3483, $P3482, "<"
.annotate 'line', 1213
    find_lex $P3484, "$/"
    unless_null $P3484, vivify_1828
    $P3484 = root_new ['parrot';'Hash']
  vivify_1828:
    set $P3485, $P3484["colonpair"]
    unless_null $P3485, vivify_1829
    $P3485 = root_new ['parrot';'ResizablePMCArray']
  vivify_1829:
    set $P3486, $P3485[0]
    unless_null $P3486, vivify_1830
    new $P3486, "Undef"
  vivify_1830:
    $P3487 = $P3486."ast"()
    $S3488 = "colonpair_str"($P3487)
    concat $P3489, $P3483, $S3488
    concat $P3490, $P3489, ">"
    set $P3468, $P3490
  if_3469_end:
.annotate 'line', 1212
    $P3493 = $P3467."!make"($P3468)
.annotate 'line', 1210
    .return ($P3493)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("461_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3496
    .param pmc param_3497
.annotate 'line', 1224
    .lex "self", param_3496
    .lex "$/", param_3497
.annotate 'line', 1225
    new $P3498, "Undef"
    .lex "$mainline", $P3498
.annotate 'line', 1226
    new $P3499, "Undef"
    .lex "$unit", $P3499
.annotate 'line', 1256
    new $P3500, "Undef"
    .lex "$main_tasks", $P3500
.annotate 'line', 1225
    find_lex $P3501, "$/"
    unless_null $P3501, vivify_1831
    $P3501 = root_new ['parrot';'Hash']
  vivify_1831:
    set $P3502, $P3501["statementlist"]
    unless_null $P3502, vivify_1832
    new $P3502, "Undef"
  vivify_1832:
    $P3503 = $P3502."ast"()
    store_lex "$mainline", $P3503
.annotate 'line', 1226
    find_lex $P3504, "$?PACKAGE"
    get_who $P3505, $P3504
    set $P3506, $P3505["@BLOCK"]
    unless_null $P3506, vivify_1833
    $P3506 = root_new ['parrot';'ResizablePMCArray']
  vivify_1833:
    $P3507 = $P3506."shift"()
    store_lex "$unit", $P3507
.annotate 'line', 1230
    find_lex $P3508, "$unit"
    unless_null $P3508, vivify_1834
    new $P3508, "Undef"
  vivify_1834:
    $P3509 = $P3508."loadinit"()
    find_dynamic_lex $P3512, "$*SC"
    unless_null $P3512, vivify_1835
    get_hll_global $P3510, "GLOBAL"
    get_who $P3511, $P3510
    set $P3512, $P3511["$SC"]
    unless_null $P3512, vivify_1836
    die "Contextual $*SC not found"
  vivify_1836:
  vivify_1835:
    $P3513 = $P3512."to_past"()
    $P3509."push"($P3513)
.annotate 'line', 1235
    find_lex $P3514, "$unit"
    unless_null $P3514, vivify_1837
    new $P3514, "Undef"
  vivify_1837:
    $P3515 = $P3514."loadinit"()
    get_hll_global $P3516, "GLOBAL"
    nqp_get_package_through_who $P3517, $P3516, "PAST"
    get_who $P3518, $P3517
    set $P3519, $P3518["Op"]
.annotate 'line', 1237
    get_hll_global $P3520, "GLOBAL"
    nqp_get_package_through_who $P3521, $P3520, "PAST"
    get_who $P3522, $P3521
    set $P3523, $P3522["Var"]
    new $P3524, "ResizablePMCArray"
    $P3525 = $P3523."new"("GLOBAL" :named("name"), $P3524 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1238
    find_dynamic_lex $P3528, "$*SC"
    unless_null $P3528, vivify_1838
    get_hll_global $P3526, "GLOBAL"
    get_who $P3527, $P3526
    set $P3528, $P3527["$SC"]
    unless_null $P3528, vivify_1839
    die "Contextual $*SC not found"
  vivify_1839:
  vivify_1838:
    find_dynamic_lex $P3531, "$*PACKAGE"
    unless_null $P3531, vivify_1840
    get_hll_global $P3529, "GLOBAL"
    get_who $P3530, $P3529
    set $P3531, $P3530["$PACKAGE"]
    unless_null $P3531, vivify_1841
    die "Contextual $*PACKAGE not found"
  vivify_1841:
  vivify_1840:
    $P3532 = $P3528."get_slot_past_for_object"($P3531)
    $P3533 = $P3519."new"($P3525, $P3532, "bind" :named("pasttype"))
.annotate 'line', 1235
    $P3515."push"($P3533)
.annotate 'line', 1244
    find_dynamic_lex $P3537, "$*HAS_YOU_ARE_HERE"
    unless_null $P3537, vivify_1842
    get_hll_global $P3535, "GLOBAL"
    get_who $P3536, $P3535
    set $P3537, $P3536["$HAS_YOU_ARE_HERE"]
    unless_null $P3537, vivify_1843
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1843:
  vivify_1842:
    if $P3537, unless_3534_end
.annotate 'line', 1245
    find_lex $P3538, "$unit"
    unless_null $P3538, vivify_1844
    new $P3538, "Undef"
  vivify_1844:
    find_lex $P3539, "self"
    $P3540 = $P3539."CTXSAVE"()
    $P3538."push"($P3540)
  unless_3534_end:
.annotate 'line', 1249
    find_lex $P3541, "$unit"
    unless_null $P3541, vivify_1845
    new $P3541, "Undef"
  vivify_1845:
    $P3541."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 1255
    find_lex $P3542, "$unit"
    unless_null $P3542, vivify_1846
    new $P3542, "Undef"
  vivify_1846:
    get_hll_global $P3543, "GLOBAL"
    nqp_get_package_through_who $P3544, $P3543, "PAST"
    get_who $P3545, $P3544
    set $P3546, $P3545["Var"]
    $P3547 = $P3546."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3542."unshift"($P3547)
.annotate 'line', 1256
    get_hll_global $P3548, "GLOBAL"
    nqp_get_package_through_who $P3549, $P3548, "PAST"
    get_who $P3550, $P3549
    set $P3551, $P3550["Stmts"]
.annotate 'line', 1257
    get_hll_global $P3552, "GLOBAL"
    nqp_get_package_through_who $P3553, $P3552, "PAST"
    get_who $P3554, $P3553
    set $P3555, $P3554["Op"]
    $P3556 = $P3555."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1258
    get_hll_global $P3557, "GLOBAL"
    nqp_get_package_through_who $P3558, $P3557, "PAST"
    get_who $P3559, $P3558
    set $P3560, $P3559["Op"]
.annotate 'line', 1260
    get_hll_global $P3561, "GLOBAL"
    nqp_get_package_through_who $P3562, $P3561, "PAST"
    get_who $P3563, $P3562
    set $P3564, $P3563["Var"]
    new $P3565, "ResizablePMCArray"
    $P3566 = $P3564."new"("ModuleLoader" :named("name"), $P3565 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1261
    get_hll_global $P3567, "GLOBAL"
    nqp_get_package_through_who $P3568, $P3567, "PAST"
    get_who $P3569, $P3568
    set $P3570, $P3569["Var"]
    get_hll_global $P3571, "GLOBAL"
    nqp_get_package_through_who $P3572, $P3571, "PAST"
    get_who $P3573, $P3572
    set $P3574, $P3573["Op"]
    $P3575 = $P3574."new"("getinterp P" :named("pirop"))
    $P3576 = $P3570."new"($P3575, "context", "keyed" :named("scope"))
    $P3577 = $P3560."new"($P3566, $P3576, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1258
    $P3578 = $P3551."new"($P3556, $P3577)
.annotate 'line', 1256
    store_lex "$main_tasks", $P3578
.annotate 'line', 1264
    find_dynamic_lex $P3582, "$*MAIN_SUB"
    unless_null $P3582, vivify_1847
    get_hll_global $P3580, "GLOBAL"
    get_who $P3581, $P3580
    set $P3582, $P3581["$MAIN_SUB"]
    unless_null $P3582, vivify_1848
    die "Contextual $*MAIN_SUB not found"
  vivify_1848:
  vivify_1847:
    unless $P3582, if_3579_end
.annotate 'line', 1265
    find_lex $P3583, "$main_tasks"
    unless_null $P3583, vivify_1849
    new $P3583, "Undef"
  vivify_1849:
    get_hll_global $P3584, "GLOBAL"
    nqp_get_package_through_who $P3585, $P3584, "PAST"
    get_who $P3586, $P3585
    set $P3587, $P3586["Op"]
.annotate 'line', 1266
    get_hll_global $P3588, "GLOBAL"
    nqp_get_package_through_who $P3589, $P3588, "PAST"
    get_who $P3590, $P3589
    set $P3591, $P3590["Val"]
    find_dynamic_lex $P3594, "$*MAIN_SUB"
    unless_null $P3594, vivify_1850
    get_hll_global $P3592, "GLOBAL"
    get_who $P3593, $P3592
    set $P3594, $P3593["$MAIN_SUB"]
    unless_null $P3594, vivify_1851
    die "Contextual $*MAIN_SUB not found"
  vivify_1851:
  vivify_1850:
    $P3595 = $P3591."new"($P3594 :named("value"))
.annotate 'line', 1267
    get_hll_global $P3596, "GLOBAL"
    nqp_get_package_through_who $P3597, $P3596, "PAST"
    get_who $P3598, $P3597
    set $P3599, $P3598["Var"]
    $P3600 = $P3599."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3601 = $P3587."new"($P3595, $P3600, "call" :named("pasttype"))
.annotate 'line', 1265
    $P3583."push"($P3601)
  if_3579_end:
.annotate 'line', 1270
    find_lex $P3602, "$mainline"
    unless_null $P3602, vivify_1852
    new $P3602, "Undef"
  vivify_1852:
    get_hll_global $P3603, "GLOBAL"
    nqp_get_package_through_who $P3604, $P3603, "PAST"
    get_who $P3605, $P3604
    set $P3606, $P3605["Op"]
.annotate 'line', 1272
    get_hll_global $P3607, "GLOBAL"
    nqp_get_package_through_who $P3608, $P3607, "PAST"
    get_who $P3609, $P3608
    set $P3610, $P3609["Var"]
    $P3611 = $P3610."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P3612, "$main_tasks"
    unless_null $P3612, vivify_1853
    new $P3612, "Undef"
  vivify_1853:
    $P3613 = $P3606."new"($P3611, $P3612, "if" :named("pasttype"))
.annotate 'line', 1270
    $P3602."push"($P3613)
.annotate 'line', 1279
    find_lex $P3614, "$unit"
    unless_null $P3614, vivify_1854
    new $P3614, "Undef"
  vivify_1854:
.annotate 'line', 1280
    get_hll_global $P3615, "GLOBAL"
    nqp_get_package_through_who $P3616, $P3615, "PAST"
    get_who $P3617, $P3616
    set $P3618, $P3617["Op"]
    find_lex $P3619, "$mainline"
    unless_null $P3619, vivify_1855
    new $P3619, "Undef"
  vivify_1855:
    $P3620 = $P3618."new"($P3619, "return" :named("pirop"))
    $P3614."push"($P3620)
.annotate 'line', 1285
    find_lex $P3621, "$unit"
    unless_null $P3621, vivify_1856
    new $P3621, "Undef"
  vivify_1856:
.annotate 'line', 1286
    get_hll_global $P3622, "GLOBAL"
    nqp_get_package_through_who $P3623, $P3622, "PAST"
    get_who $P3624, $P3623
    set $P3625, $P3624["Block"]
.annotate 'line', 1288
    get_hll_global $P3626, "GLOBAL"
    nqp_get_package_through_who $P3627, $P3626, "PAST"
    get_who $P3628, $P3627
    set $P3629, $P3628["Op"]
    get_hll_global $P3630, "GLOBAL"
    nqp_get_package_through_who $P3631, $P3630, "PAST"
    get_who $P3632, $P3631
    set $P3633, $P3632["Val"]
    find_lex $P3634, "$unit"
    unless_null $P3634, vivify_1857
    new $P3634, "Undef"
  vivify_1857:
    $P3635 = $P3633."new"($P3634 :named("value"))
    $P3636 = $P3629."new"($P3635, "call" :named("pasttype"))
    $P3637 = $P3625."new"($P3636, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1286
    $P3621."push"($P3637)
.annotate 'line', 1291
    find_lex $P3638, "$unit"
    unless_null $P3638, vivify_1858
    new $P3638, "Undef"
  vivify_1858:
    find_lex $P3639, "$/"
    unless_null $P3639, vivify_1859
    new $P3639, "Undef"
  vivify_1859:
    $P3638."node"($P3639)
.annotate 'line', 1294
    find_lex $P3640, "$unit"
    unless_null $P3640, vivify_1860
    new $P3640, "Undef"
  vivify_1860:
    $P3640."hll"("nqp")
.annotate 'line', 1296
    find_lex $P3641, "$/"
    find_lex $P3642, "$unit"
    unless_null $P3642, vivify_1861
    new $P3642, "Undef"
  vivify_1861:
    $P3643 = $P3641."!make"($P3642)
.annotate 'line', 1224
    .return ($P3643)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("462_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3645
    .param pmc param_3646
.annotate 'line', 1299
    .const 'Sub' $P3663 = "463_1304523757.895" 
    capture_lex $P3663
    .lex "self", param_3645
    .lex "$/", param_3646
.annotate 'line', 1300
    new $P3647, "Undef"
    .lex "$past", $P3647
    get_hll_global $P3648, "GLOBAL"
    nqp_get_package_through_who $P3649, $P3648, "PAST"
    get_who $P3650, $P3649
    set $P3651, $P3650["Stmts"]
    find_lex $P3652, "$/"
    unless_null $P3652, vivify_1862
    new $P3652, "Undef"
  vivify_1862:
    $P3653 = $P3651."new"($P3652 :named("node"))
    store_lex "$past", $P3653
.annotate 'line', 1301
    find_lex $P3655, "$/"
    unless_null $P3655, vivify_1863
    $P3655 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3656, $P3655["statement"]
    unless_null $P3656, vivify_1864
    new $P3656, "Undef"
  vivify_1864:
    unless $P3656, if_3654_end
.annotate 'line', 1302
    find_lex $P3658, "$/"
    unless_null $P3658, vivify_1865
    $P3658 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3659, $P3658["statement"]
    unless_null $P3659, vivify_1866
    new $P3659, "Undef"
  vivify_1866:
    defined $I3660, $P3659
    unless $I3660, for_undef_1867
    iter $P3657, $P3659
    new $P3683, 'ExceptionHandler'
    set_label $P3683, loop3682_handler
    $P3683."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3683
  loop3682_test:
    unless $P3657, loop3682_done
    shift $P3661, $P3657
  loop3682_redo:
    .const 'Sub' $P3663 = "463_1304523757.895" 
    capture_lex $P3663
    $P3663($P3661)
  loop3682_next:
    goto loop3682_test
  loop3682_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3684, exception, 'type'
    eq $P3684, .CONTROL_LOOP_NEXT, loop3682_next
    eq $P3684, .CONTROL_LOOP_REDO, loop3682_redo
  loop3682_done:
    pop_eh 
  for_undef_1867:
  if_3654_end:
.annotate 'line', 1309
    find_lex $P3685, "$/"
    find_lex $P3686, "$past"
    unless_null $P3686, vivify_1878
    new $P3686, "Undef"
  vivify_1878:
    $P3687 = $P3685."!make"($P3686)
.annotate 'line', 1299
    .return ($P3687)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3662"  :anon :subid("463_1304523757.895") :outer("462_1304523757.895")
    .param pmc param_3665
.annotate 'line', 1303
    new $P3664, "Undef"
    .lex "$ast", $P3664
    .lex "$_", param_3665
    find_lex $P3666, "$_"
    unless_null $P3666, vivify_1868
    new $P3666, "Undef"
  vivify_1868:
    $P3667 = $P3666."ast"()
    store_lex "$ast", $P3667
.annotate 'line', 1304
    find_lex $P3669, "$ast"
    unless_null $P3669, vivify_1869
    $P3669 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P3670, $P3669["sink"]
    unless_null $P3670, vivify_1870
    new $P3670, "Undef"
  vivify_1870:
    defined $I3671, $P3670
    unless $I3671, if_3668_end
    find_lex $P3672, "$ast"
    unless_null $P3672, vivify_1871
    $P3672 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P3673, $P3672["sink"]
    unless_null $P3673, vivify_1872
    new $P3673, "Undef"
  vivify_1872:
    store_lex "$ast", $P3673
  if_3668_end:
.annotate 'line', 1305
    find_lex $P3675, "$ast"
    unless_null $P3675, vivify_1873
    $P3675 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P3676, $P3675["bareblock"]
    unless_null $P3676, vivify_1874
    new $P3676, "Undef"
  vivify_1874:
    unless $P3676, if_3674_end
    find_lex $P3677, "$ast"
    unless_null $P3677, vivify_1875
    new $P3677, "Undef"
  vivify_1875:
    $P3678 = "block_immediate"($P3677)
    store_lex "$ast", $P3678
  if_3674_end:
.annotate 'line', 1306
    find_lex $P3679, "$past"
    unless_null $P3679, vivify_1876
    new $P3679, "Undef"
  vivify_1876:
    find_lex $P3680, "$ast"
    unless_null $P3680, vivify_1877
    new $P3680, "Undef"
  vivify_1877:
    $P3681 = $P3679."push"($P3680)
.annotate 'line', 1302
    .return ($P3681)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("464_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3689
    .param pmc param_3690
    .param pmc param_3691 :optional
    .param int has_param_3691 :opt_flag
.annotate 'line', 1312
    .const 'Sub' $P3699 = "465_1304523757.895" 
    capture_lex $P3699
    .lex "self", param_3689
    .lex "$/", param_3690
    if has_param_3691, optparam_1879
    new $P3692, "Undef"
    set param_3691, $P3692
  optparam_1879:
    .lex "$key", param_3691
.annotate 'line', 1313
    new $P3693, "Undef"
    .lex "$past", $P3693
.annotate 'line', 1312
    find_lex $P3694, "$past"
    unless_null $P3694, vivify_1880
    new $P3694, "Undef"
  vivify_1880:
.annotate 'line', 1314
    find_lex $P3696, "$/"
    unless_null $P3696, vivify_1881
    $P3696 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P3697, $P3696["EXPR"]
    unless_null $P3697, vivify_1882
    new $P3697, "Undef"
  vivify_1882:
    if $P3697, if_3695
.annotate 'line', 1335
    find_lex $P3775, "$/"
    unless_null $P3775, vivify_1883
    $P3775 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P3776, $P3775["statement_control"]
    unless_null $P3776, vivify_1884
    new $P3776, "Undef"
  vivify_1884:
    if $P3776, if_3774
.annotate 'line', 1336
    new $P3780, "Integer"
    assign $P3780, 0
    store_lex "$past", $P3780
    goto if_3774_end
  if_3774:
.annotate 'line', 1335
    find_lex $P3777, "$/"
    unless_null $P3777, vivify_1885
    $P3777 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P3778, $P3777["statement_control"]
    unless_null $P3778, vivify_1886
    new $P3778, "Undef"
  vivify_1886:
    $P3779 = $P3778."ast"()
    store_lex "$past", $P3779
  if_3774_end:
    goto if_3695_end
  if_3695:
.annotate 'line', 1314
    .const 'Sub' $P3699 = "465_1304523757.895" 
    capture_lex $P3699
    $P3699()
  if_3695_end:
.annotate 'line', 1337
    find_lex $P3781, "$/"
    find_lex $P3782, "$past"
    unless_null $P3782, vivify_1920
    new $P3782, "Undef"
  vivify_1920:
    $P3783 = $P3781."!make"($P3782)
.annotate 'line', 1312
    .return ($P3783)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3698"  :anon :subid("465_1304523757.895") :outer("464_1304523757.895")
.annotate 'line', 1315
    new $P3700, "Undef"
    .lex "$mc", $P3700
.annotate 'line', 1316
    new $P3701, "Undef"
    .lex "$ml", $P3701
.annotate 'line', 1315
    find_lex $P3702, "$/"
    unless_null $P3702, vivify_1887
    $P3702 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3703, $P3702["statement_mod_cond"]
    unless_null $P3703, vivify_1888
    $P3703 = root_new ['parrot';'ResizablePMCArray']
  vivify_1888:
    set $P3704, $P3703[0]
    unless_null $P3704, vivify_1889
    new $P3704, "Undef"
  vivify_1889:
    store_lex "$mc", $P3704
.annotate 'line', 1316
    find_lex $P3705, "$/"
    unless_null $P3705, vivify_1890
    $P3705 = root_new ['parrot';'Hash']
  vivify_1890:
    set $P3706, $P3705["statement_mod_loop"]
    unless_null $P3706, vivify_1891
    $P3706 = root_new ['parrot';'ResizablePMCArray']
  vivify_1891:
    set $P3707, $P3706[0]
    unless_null $P3707, vivify_1892
    new $P3707, "Undef"
  vivify_1892:
    store_lex "$ml", $P3707
.annotate 'line', 1317
    find_lex $P3708, "$/"
    unless_null $P3708, vivify_1893
    $P3708 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3709, $P3708["EXPR"]
    unless_null $P3709, vivify_1894
    new $P3709, "Undef"
  vivify_1894:
    $P3710 = $P3709."ast"()
    store_lex "$past", $P3710
.annotate 'line', 1318
    find_lex $P3712, "$mc"
    unless_null $P3712, vivify_1895
    new $P3712, "Undef"
  vivify_1895:
    unless $P3712, if_3711_end
.annotate 'line', 1319
    get_hll_global $P3713, "GLOBAL"
    nqp_get_package_through_who $P3714, $P3713, "PAST"
    get_who $P3715, $P3714
    set $P3716, $P3715["Op"]
    find_lex $P3717, "$mc"
    unless_null $P3717, vivify_1896
    $P3717 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P3718, $P3717["cond"]
    unless_null $P3718, vivify_1897
    new $P3718, "Undef"
  vivify_1897:
    $P3719 = $P3718."ast"()
    find_lex $P3720, "$past"
    unless_null $P3720, vivify_1898
    new $P3720, "Undef"
  vivify_1898:
    find_lex $P3721, "$mc"
    unless_null $P3721, vivify_1899
    $P3721 = root_new ['parrot';'Hash']
  vivify_1899:
    set $P3722, $P3721["sym"]
    unless_null $P3722, vivify_1900
    new $P3722, "Undef"
  vivify_1900:
    set $S3723, $P3722
    find_lex $P3724, "$/"
    unless_null $P3724, vivify_1901
    new $P3724, "Undef"
  vivify_1901:
    $P3725 = $P3716."new"($P3719, $P3720, $S3723 :named("pasttype"), $P3724 :named("node"))
    store_lex "$past", $P3725
  if_3711_end:
.annotate 'line', 1321
    find_lex $P3728, "$ml"
    unless_null $P3728, vivify_1902
    new $P3728, "Undef"
  vivify_1902:
    if $P3728, if_3727
    set $P3726, $P3728
    goto if_3727_end
  if_3727:
.annotate 'line', 1322
    find_lex $P3731, "$ml"
    unless_null $P3731, vivify_1903
    $P3731 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P3732, $P3731["sym"]
    unless_null $P3732, vivify_1904
    new $P3732, "Undef"
  vivify_1904:
    set $S3733, $P3732
    iseq $I3734, $S3733, "for"
    if $I3734, if_3730
.annotate 'line', 1331
    get_hll_global $P3761, "GLOBAL"
    nqp_get_package_through_who $P3762, $P3761, "PAST"
    get_who $P3763, $P3762
    set $P3764, $P3763["Op"]
    find_lex $P3765, "$ml"
    unless_null $P3765, vivify_1905
    $P3765 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3766, $P3765["cond"]
    unless_null $P3766, vivify_1906
    new $P3766, "Undef"
  vivify_1906:
    $P3767 = $P3766."ast"()
    find_lex $P3768, "$past"
    unless_null $P3768, vivify_1907
    new $P3768, "Undef"
  vivify_1907:
    find_lex $P3769, "$ml"
    unless_null $P3769, vivify_1908
    $P3769 = root_new ['parrot';'Hash']
  vivify_1908:
    set $P3770, $P3769["sym"]
    unless_null $P3770, vivify_1909
    new $P3770, "Undef"
  vivify_1909:
    set $S3771, $P3770
    find_lex $P3772, "$/"
    unless_null $P3772, vivify_1910
    new $P3772, "Undef"
  vivify_1910:
    $P3773 = $P3764."new"($P3767, $P3768, $S3771 :named("pasttype"), $P3772 :named("node"))
    store_lex "$past", $P3773
.annotate 'line', 1330
    set $P3729, $P3773
.annotate 'line', 1322
    goto if_3730_end
  if_3730:
.annotate 'line', 1323
    get_hll_global $P3735, "GLOBAL"
    nqp_get_package_through_who $P3736, $P3735, "PAST"
    get_who $P3737, $P3736
    set $P3738, $P3737["Block"]
.annotate 'line', 1324
    get_hll_global $P3739, "GLOBAL"
    nqp_get_package_through_who $P3740, $P3739, "PAST"
    get_who $P3741, $P3740
    set $P3742, $P3741["Var"]
    $P3743 = $P3742."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3744, "$past"
    unless_null $P3744, vivify_1911
    new $P3744, "Undef"
  vivify_1911:
    $P3745 = $P3738."new"($P3743, $P3744, "immediate" :named("blocktype"))
.annotate 'line', 1323
    store_lex "$past", $P3745
.annotate 'line', 1326
    find_lex $P3746, "$past"
    unless_null $P3746, vivify_1912
    new $P3746, "Undef"
  vivify_1912:
    $P3746."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1327
    find_lex $P3747, "$past"
    unless_null $P3747, vivify_1913
    new $P3747, "Undef"
  vivify_1913:
    $P3747."arity"(1)
.annotate 'line', 1328
    get_hll_global $P3748, "GLOBAL"
    nqp_get_package_through_who $P3749, $P3748, "PAST"
    get_who $P3750, $P3749
    set $P3751, $P3750["Op"]
    find_lex $P3752, "$ml"
    unless_null $P3752, vivify_1914
    $P3752 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P3753, $P3752["cond"]
    unless_null $P3753, vivify_1915
    new $P3753, "Undef"
  vivify_1915:
    $P3754 = $P3753."ast"()
    find_lex $P3755, "$past"
    unless_null $P3755, vivify_1916
    new $P3755, "Undef"
  vivify_1916:
    find_lex $P3756, "$ml"
    unless_null $P3756, vivify_1917
    $P3756 = root_new ['parrot';'Hash']
  vivify_1917:
    set $P3757, $P3756["sym"]
    unless_null $P3757, vivify_1918
    new $P3757, "Undef"
  vivify_1918:
    set $S3758, $P3757
    find_lex $P3759, "$/"
    unless_null $P3759, vivify_1919
    new $P3759, "Undef"
  vivify_1919:
    $P3760 = $P3751."new"($P3754, $P3755, $S3758 :named("pasttype"), $P3759 :named("node"))
    store_lex "$past", $P3760
.annotate 'line', 1322
    set $P3729, $P3760
  if_3730_end:
.annotate 'line', 1321
    set $P3726, $P3729
  if_3727_end:
.annotate 'line', 1314
    .return ($P3726)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("466_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3785
    .param pmc param_3786
.annotate 'line', 1340
    .lex "self", param_3785
    .lex "$/", param_3786
.annotate 'line', 1341
    find_lex $P3787, "$/"
    get_hll_global $P3788, "GLOBAL"
    nqp_get_package_through_who $P3789, $P3788, "PAST"
    get_who $P3790, $P3789
    set $P3791, $P3790["Op"]
    find_lex $P3792, "$/"
    unless_null $P3792, vivify_1921
    $P3792 = root_new ['parrot';'Hash']
  vivify_1921:
    set $P3793, $P3792["EXPR"]
    unless_null $P3793, vivify_1922
    new $P3793, "Undef"
  vivify_1922:
    $P3794 = $P3793."ast"()
    find_lex $P3795, "$/"
    unless_null $P3795, vivify_1923
    $P3795 = root_new ['parrot';'Hash']
  vivify_1923:
    set $P3796, $P3795["pblock"]
    unless_null $P3796, vivify_1924
    new $P3796, "Undef"
  vivify_1924:
    $P3797 = $P3796."ast"()
    find_lex $P3798, "$/"
    unless_null $P3798, vivify_1925
    new $P3798, "Undef"
  vivify_1925:
    $P3799 = $P3791."new"($P3794, $P3797, "if" :named("pasttype"), $P3798 :named("node"))
    $P3800 = $P3787."!make"($P3799)
.annotate 'line', 1340
    .return ($P3800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("467_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3802
    .param pmc param_3803
.annotate 'line', 1344
    .lex "self", param_3802
    .lex "$/", param_3803
.annotate 'line', 1345
    find_lex $P3804, "$/"
    find_lex $P3805, "$/"
    unless_null $P3805, vivify_1926
    $P3805 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P3806, $P3805["blockoid"]
    unless_null $P3806, vivify_1927
    new $P3806, "Undef"
  vivify_1927:
    $P3807 = $P3806."ast"()
    $P3808 = $P3804."!make"($P3807)
.annotate 'line', 1344
    .return ($P3808)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("468_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3810
    .param pmc param_3811
.annotate 'line', 1348
    .lex "self", param_3810
    .lex "$/", param_3811
.annotate 'line', 1349
    find_lex $P3812, "$/"
    find_lex $P3813, "$/"
    unless_null $P3813, vivify_1928
    $P3813 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P3814, $P3813["blockoid"]
    unless_null $P3814, vivify_1929
    new $P3814, "Undef"
  vivify_1929:
    $P3815 = $P3814."ast"()
    $P3816 = $P3812."!make"($P3815)
.annotate 'line', 1348
    .return ($P3816)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("469_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3818
    .param pmc param_3819
.annotate 'line', 1352
    .const 'Sub' $P3830 = "470_1304523757.895" 
    capture_lex $P3830
    .lex "self", param_3818
    .lex "$/", param_3819
.annotate 'line', 1353
    new $P3820, "Undef"
    .lex "$BLOCK", $P3820
    find_lex $P3821, "$?PACKAGE"
    get_who $P3822, $P3821
    set $P3823, $P3822["@BLOCK"]
    unless_null $P3823, vivify_1930
    $P3823 = root_new ['parrot';'ResizablePMCArray']
  vivify_1930:
    $P3824 = $P3823."shift"()
    store_lex "$BLOCK", $P3824
.annotate 'line', 1354
    find_lex $P3827, "$/"
    unless_null $P3827, vivify_1931
    $P3827 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P3828, $P3827["statementlist"]
    unless_null $P3828, vivify_1932
    new $P3828, "Undef"
  vivify_1932:
    if $P3828, if_3826
.annotate 'line', 1362
    find_dynamic_lex $P3847, "$*HAS_YOU_ARE_HERE"
    unless_null $P3847, vivify_1933
    get_hll_global $P3845, "GLOBAL"
    get_who $P3846, $P3845
    set $P3847, $P3846["$HAS_YOU_ARE_HERE"]
    unless_null $P3847, vivify_1934
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1934:
  vivify_1933:
    unless $P3847, if_3844_end
.annotate 'line', 1363
    find_lex $P3848, "$/"
    unless_null $P3848, vivify_1935
    new $P3848, "Undef"
  vivify_1935:
    $P3849 = $P3848."CURSOR"()
    $P3849."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3844_end:
.annotate 'line', 1365
    new $P3850, "Integer"
    assign $P3850, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3850
.annotate 'line', 1366
    find_lex $P3851, "$/"
    find_lex $P3852, "$/"
    unless_null $P3852, vivify_1936
    $P3852 = root_new ['parrot';'Hash']
  vivify_1936:
    set $P3853, $P3852["you_are_here"]
    unless_null $P3853, vivify_1937
    new $P3853, "Undef"
  vivify_1937:
    $P3854 = $P3853."ast"()
    $P3855 = $P3851."!make"($P3854)
.annotate 'line', 1361
    set $P3825, $P3855
.annotate 'line', 1354
    goto if_3826_end
  if_3826:
    .const 'Sub' $P3830 = "470_1304523757.895" 
    capture_lex $P3830
    $P3843 = $P3830()
    set $P3825, $P3843
  if_3826_end:
.annotate 'line', 1352
    .return ($P3825)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3829"  :anon :subid("470_1304523757.895") :outer("469_1304523757.895")
.annotate 'line', 1355
    new $P3831, "Undef"
    .lex "$past", $P3831
    find_lex $P3832, "$/"
    unless_null $P3832, vivify_1938
    $P3832 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P3833, $P3832["statementlist"]
    unless_null $P3833, vivify_1939
    new $P3833, "Undef"
  vivify_1939:
    $P3834 = $P3833."ast"()
    store_lex "$past", $P3834
.annotate 'line', 1356
    find_lex $P3835, "$BLOCK"
    unless_null $P3835, vivify_1940
    new $P3835, "Undef"
  vivify_1940:
    find_lex $P3836, "$past"
    unless_null $P3836, vivify_1941
    new $P3836, "Undef"
  vivify_1941:
    $P3835."push"($P3836)
.annotate 'line', 1357
    find_lex $P3837, "$BLOCK"
    unless_null $P3837, vivify_1942
    new $P3837, "Undef"
  vivify_1942:
    find_lex $P3838, "$/"
    unless_null $P3838, vivify_1943
    new $P3838, "Undef"
  vivify_1943:
    $P3837."node"($P3838)
.annotate 'line', 1358
    find_lex $P3839, "$BLOCK"
    unless_null $P3839, vivify_1944
    new $P3839, "Undef"
  vivify_1944:
    $P3839."closure"(1)
.annotate 'line', 1359
    find_dynamic_lex $P3840, "$/"
    find_lex $P3841, "$BLOCK"
    unless_null $P3841, vivify_1945
    new $P3841, "Undef"
  vivify_1945:
    $P3842 = $P3840."!make"($P3841)
.annotate 'line', 1354
    .return ($P3842)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("471_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3857
    .param pmc param_3858
.annotate 'line', 1370
    .lex "self", param_3857
    .lex "$/", param_3858
.annotate 'line', 1371
    find_lex $P3859, "$?PACKAGE"
    get_who $P3860, $P3859
    set $P3861, $P3860["@BLOCK"]
    unless_null $P3861, vivify_1946
    $P3861 = root_new ['parrot';'ResizablePMCArray']
  vivify_1946:
    get_hll_global $P3862, "GLOBAL"
    nqp_get_package_through_who $P3863, $P3862, "PAST"
    get_who $P3864, $P3863
    set $P3865, $P3864["Block"]
    get_hll_global $P3866, "GLOBAL"
    nqp_get_package_through_who $P3867, $P3866, "PAST"
    get_who $P3868, $P3867
    set $P3869, $P3868["Stmts"]
    $P3870 = $P3869."new"()
    $P3871 = $P3865."new"($P3870)
    $P3872 = $P3861."unshift"($P3871)
.annotate 'line', 1370
    .return ($P3872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("472_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3874
    .param pmc param_3875
.annotate 'line', 1374
    .const 'Sub' $P3884 = "473_1304523757.895" 
    capture_lex $P3884
    .lex "self", param_3874
    .lex "$/", param_3875
.annotate 'line', 1375
    find_dynamic_lex $P3879, "%*COMPILING"
    unless_null $P3879, vivify_1947
    get_hll_global $P3877, "GLOBAL"
    get_who $P3878, $P3877
    set $P3879, $P3878["%COMPILING"]
    unless_null $P3879, vivify_1948
    die "Contextual %*COMPILING not found"
  vivify_1948:
  vivify_1947:
    set $P3880, $P3879["%?OPTIONS"]
    unless_null $P3880, vivify_1949
    $P3880 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P3881, $P3880["outer_ctx"]
    unless_null $P3881, vivify_1950
    new $P3881, "Undef"
  vivify_1950:
    defined $I3882, $P3881
    if $I3882, unless_3876_end
    .const 'Sub' $P3884 = "473_1304523757.895" 
    capture_lex $P3884
    $P3884()
  unless_3876_end:
.annotate 'line', 1388
    find_lex $P3916, "self"
    find_lex $P3917, "$?PACKAGE"
    get_who $P3918, $P3917
    set $P3919, $P3918["@BLOCK"]
    unless_null $P3919, vivify_1966
    $P3919 = root_new ['parrot';'ResizablePMCArray']
  vivify_1966:
    set $P3920, $P3919[0]
    unless_null $P3920, vivify_1967
    new $P3920, "Undef"
  vivify_1967:
    $P3921 = $P3916."SET_BLOCK_OUTER_CTX"($P3920)
.annotate 'line', 1374
    .return ($P3921)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3883"  :anon :subid("473_1304523757.895") :outer("472_1304523757.895")
.annotate 'line', 1378
    new $P3885, "Undef"
    .lex "$SETTING", $P3885
    find_dynamic_lex $P3888, "$*SC"
    unless_null $P3888, vivify_1951
    get_hll_global $P3886, "GLOBAL"
    get_who $P3887, $P3886
    set $P3888, $P3887["$SC"]
    unless_null $P3888, vivify_1952
    die "Contextual $*SC not found"
  vivify_1952:
  vivify_1951:
    find_dynamic_lex $P3892, "%*COMPILING"
    unless_null $P3892, vivify_1953
    get_hll_global $P3890, "GLOBAL"
    get_who $P3891, $P3890
    set $P3892, $P3891["%COMPILING"]
    unless_null $P3892, vivify_1954
    die "Contextual %*COMPILING not found"
  vivify_1954:
  vivify_1953:
    set $P3893, $P3892["%?OPTIONS"]
    unless_null $P3893, vivify_1955
    $P3893 = root_new ['parrot';'Hash']
  vivify_1955:
    set $P3894, $P3893["setting"]
    unless_null $P3894, vivify_1956
    new $P3894, "Undef"
  vivify_1956:
    set $P3889, $P3894
    defined $I3896, $P3889
    if $I3896, default_3895
    new $P3897, "String"
    assign $P3897, "NQPCORE"
    set $P3889, $P3897
  default_3895:
    $P3898 = $P3888."load_setting"($P3889)
    store_lex "$SETTING", $P3898
.annotate 'line', 1383
    find_dynamic_lex $P3903, "%*COMPILING"
    unless_null $P3903, vivify_1957
    get_hll_global $P3901, "GLOBAL"
    get_who $P3902, $P3901
    set $P3903, $P3902["%COMPILING"]
    unless_null $P3903, vivify_1958
    die "Contextual %*COMPILING not found"
  vivify_1958:
  vivify_1957:
    set $P3904, $P3903["%?OPTIONS"]
    unless_null $P3904, vivify_1959
    $P3904 = root_new ['parrot';'Hash']
  vivify_1959:
    set $P3905, $P3904["setting"]
    unless_null $P3905, vivify_1960
    new $P3905, "Undef"
  vivify_1960:
    set $S3906, $P3905
    iseq $I3907, $S3906, "NULL"
    unless $I3907, unless_3900
    new $P3899, 'Integer'
    set $P3899, $I3907
    goto unless_3900_end
  unless_3900:
.annotate 'line', 1384
    find_lex $P3908, "$SETTING"
    unless_null $P3908, vivify_1961
    new $P3908, "Undef"
  vivify_1961:
    "import_HOW_exports"($P3908)
.annotate 'line', 1385
    find_dynamic_lex $P3911, "$*SC"
    unless_null $P3911, vivify_1962
    get_hll_global $P3909, "GLOBAL"
    get_who $P3910, $P3909
    set $P3911, $P3910["$SC"]
    unless_null $P3911, vivify_1963
    die "Contextual $*SC not found"
  vivify_1963:
  vivify_1962:
    find_dynamic_lex $P3914, "$*GLOBALish"
    unless_null $P3914, vivify_1964
    get_hll_global $P3912, "GLOBAL"
    get_who $P3913, $P3912
    set $P3914, $P3913["$GLOBALish"]
    unless_null $P3914, vivify_1965
    die "Contextual $*GLOBALish not found"
  vivify_1965:
  vivify_1964:
    $P3915 = $P3911."load_module"("NQPRegex", $P3914)
.annotate 'line', 1383
    set $P3899, $P3915
  unless_3900_end:
.annotate 'line', 1375
    .return ($P3899)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("474_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3924
    .param pmc param_3925
.annotate 'line', 1400
    .lex "self", param_3924
    .lex "$/", param_3925
.annotate 'line', 1404
    find_dynamic_lex $P3928, "$*SC"
    unless_null $P3928, vivify_1968
    get_hll_global $P3926, "GLOBAL"
    get_who $P3927, $P3926
    set $P3928, $P3927["$SC"]
    unless_null $P3928, vivify_1969
    die "Contextual $*SC not found"
  vivify_1969:
  vivify_1968:
    find_dynamic_lex $P3931, "%*HOW"
    unless_null $P3931, vivify_1970
    get_hll_global $P3929, "GLOBAL"
    get_who $P3930, $P3929
    set $P3931, $P3930["%HOW"]
    unless_null $P3931, vivify_1971
    die "Contextual %*HOW not found"
  vivify_1971:
  vivify_1970:
    set $P3932, $P3931["knowhow"]
    unless_null $P3932, vivify_1972
    new $P3932, "Undef"
  vivify_1972:
    $P3933 = $P3928."pkg_create_mo"($P3932, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3933
.annotate 'line', 1405
    find_dynamic_lex $P3936, "$*GLOBALish"
    unless_null $P3936, vivify_1973
    get_hll_global $P3934, "GLOBAL"
    get_who $P3935, $P3934
    set $P3936, $P3935["$GLOBALish"]
    unless_null $P3936, vivify_1974
    die "Contextual $*GLOBALish not found"
  vivify_1974:
  vivify_1973:
    get_how $P3937, $P3936
    find_dynamic_lex $P3940, "$*GLOBALish"
    unless_null $P3940, vivify_1975
    get_hll_global $P3938, "GLOBAL"
    get_who $P3939, $P3938
    set $P3940, $P3939["$GLOBALish"]
    unless_null $P3940, vivify_1976
    die "Contextual $*GLOBALish not found"
  vivify_1976:
  vivify_1975:
    $P3937."compose"($P3940)
.annotate 'line', 1406
    find_dynamic_lex $P3943, "$*SC"
    unless_null $P3943, vivify_1977
    get_hll_global $P3941, "GLOBAL"
    get_who $P3942, $P3941
    set $P3943, $P3942["$SC"]
    unless_null $P3943, vivify_1978
    die "Contextual $*SC not found"
  vivify_1978:
  vivify_1977:
    find_lex $P3944, "$?PACKAGE"
    get_who $P3945, $P3944
    set $P3946, $P3945["@BLOCK"]
    unless_null $P3946, vivify_1979
    $P3946 = root_new ['parrot';'ResizablePMCArray']
  vivify_1979:
    set $P3947, $P3946[0]
    unless_null $P3947, vivify_1980
    new $P3947, "Undef"
  vivify_1980:
    find_dynamic_lex $P3950, "$*GLOBALish"
    unless_null $P3950, vivify_1981
    get_hll_global $P3948, "GLOBAL"
    get_who $P3949, $P3948
    set $P3950, $P3949["$GLOBALish"]
    unless_null $P3950, vivify_1982
    die "Contextual $*GLOBALish not found"
  vivify_1982:
  vivify_1981:
    $P3943."install_lexical_symbol"($P3947, "GLOBALish", $P3950)
.annotate 'line', 1409
    find_dynamic_lex $P3953, "$*GLOBALish"
    unless_null $P3953, vivify_1983
    get_hll_global $P3951, "GLOBAL"
    get_who $P3952, $P3951
    set $P3953, $P3952["$GLOBALish"]
    unless_null $P3953, vivify_1984
    die "Contextual $*GLOBALish not found"
  vivify_1984:
  vivify_1983:
    store_dynamic_lex "$*PACKAGE", $P3953
.annotate 'line', 1410
    find_dynamic_lex $P3956, "$*SC"
    unless_null $P3956, vivify_1985
    get_hll_global $P3954, "GLOBAL"
    get_who $P3955, $P3954
    set $P3956, $P3955["$SC"]
    unless_null $P3956, vivify_1986
    die "Contextual $*SC not found"
  vivify_1986:
  vivify_1985:
    find_lex $P3957, "$?PACKAGE"
    get_who $P3958, $P3957
    set $P3959, $P3958["@BLOCK"]
    unless_null $P3959, vivify_1987
    $P3959 = root_new ['parrot';'ResizablePMCArray']
  vivify_1987:
    set $P3960, $P3959[0]
    unless_null $P3960, vivify_1988
    new $P3960, "Undef"
  vivify_1988:
    find_dynamic_lex $P3963, "$*PACKAGE"
    unless_null $P3963, vivify_1989
    get_hll_global $P3961, "GLOBAL"
    get_who $P3962, $P3961
    set $P3963, $P3962["$PACKAGE"]
    unless_null $P3963, vivify_1990
    die "Contextual $*PACKAGE not found"
  vivify_1990:
  vivify_1989:
    $P3964 = $P3956."install_lexical_symbol"($P3960, "$?PACKAGE", $P3963)
.annotate 'line', 1400
    .return ($P3964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("475_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3966
    .param pmc param_3967
.annotate 'line', 1413
    .lex "self", param_3966
    .lex "$/", param_3967
.annotate 'line', 1414
    find_lex $P3968, "$/"
    find_lex $P3969, "self"
    $P3970 = $P3969."CTXSAVE"()
    $P3971 = $P3968."!make"($P3970)
.annotate 'line', 1413
    .return ($P3971)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("476_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3973
    .param pmc param_3974
.annotate 'line', 1419
    .lex "self", param_3973
    .lex "$/", param_3974
.annotate 'line', 1420
    new $P3975, "Undef"
    .lex "$module", $P3975
    find_dynamic_lex $P3978, "$*SC"
    unless_null $P3978, vivify_1991
    get_hll_global $P3976, "GLOBAL"
    get_who $P3977, $P3976
    set $P3978, $P3977["$SC"]
    unless_null $P3978, vivify_1992
    die "Contextual $*SC not found"
  vivify_1992:
  vivify_1991:
    find_lex $P3979, "$/"
    unless_null $P3979, vivify_1993
    $P3979 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P3980, $P3979["name"]
    unless_null $P3980, vivify_1994
    new $P3980, "Undef"
  vivify_1994:
    set $S3981, $P3980
    find_dynamic_lex $P3984, "$*GLOBALish"
    unless_null $P3984, vivify_1995
    get_hll_global $P3982, "GLOBAL"
    get_who $P3983, $P3982
    set $P3984, $P3983["$GLOBALish"]
    unless_null $P3984, vivify_1996
    die "Contextual $*GLOBALish not found"
  vivify_1996:
  vivify_1995:
    $P3985 = $P3978."load_module"($S3981, $P3984)
    store_lex "$module", $P3985
.annotate 'line', 1421
    find_lex $P3987, "$module"
    unless_null $P3987, vivify_1997
    new $P3987, "Undef"
  vivify_1997:
    defined $I3988, $P3987
    unless $I3988, if_3986_end
.annotate 'line', 1422
    find_lex $P3989, "$module"
    unless_null $P3989, vivify_1998
    new $P3989, "Undef"
  vivify_1998:
    "import_HOW_exports"($P3989)
  if_3986_end:
.annotate 'line', 1424
    find_lex $P3990, "$/"
    get_hll_global $P3991, "GLOBAL"
    nqp_get_package_through_who $P3992, $P3991, "PAST"
    get_who $P3993, $P3992
    set $P3994, $P3993["Stmts"]
    $P3995 = $P3994."new"()
    $P3996 = $P3990."!make"($P3995)
.annotate 'line', 1419
    .return ($P3996)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("477_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_3998
    .param pmc param_3999
.annotate 'line', 1427
    .const 'Sub' $P4027 = "478_1304523757.895" 
    capture_lex $P4027
    .lex "self", param_3998
    .lex "$/", param_3999
.annotate 'line', 1428
    new $P4000, "Undef"
    .lex "$count", $P4000
.annotate 'line', 1429
    new $P4001, "Undef"
    .lex "$past", $P4001
.annotate 'line', 1428
    find_lex $P4002, "$/"
    unless_null $P4002, vivify_1999
    $P4002 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P4003, $P4002["xblock"]
    unless_null $P4003, vivify_2000
    new $P4003, "Undef"
  vivify_2000:
    set $N4004, $P4003
    new $P4005, 'Float'
    set $P4005, $N4004
    sub $P4006, $P4005, 1
    store_lex "$count", $P4006
.annotate 'line', 1429
    find_lex $P4007, "$count"
    unless_null $P4007, vivify_2001
    new $P4007, "Undef"
  vivify_2001:
    set $I4008, $P4007
    find_lex $P4009, "$/"
    unless_null $P4009, vivify_2002
    $P4009 = root_new ['parrot';'Hash']
  vivify_2002:
    set $P4010, $P4009["xblock"]
    unless_null $P4010, vivify_2003
    $P4010 = root_new ['parrot';'ResizablePMCArray']
  vivify_2003:
    set $P4011, $P4010[$I4008]
    unless_null $P4011, vivify_2004
    new $P4011, "Undef"
  vivify_2004:
    $P4012 = $P4011."ast"()
    $P4013 = "xblock_immediate"($P4012)
    store_lex "$past", $P4013
.annotate 'line', 1430
    find_lex $P4015, "$/"
    unless_null $P4015, vivify_2005
    $P4015 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4016, $P4015["else"]
    unless_null $P4016, vivify_2006
    new $P4016, "Undef"
  vivify_2006:
    unless $P4016, if_4014_end
.annotate 'line', 1431
    find_lex $P4017, "$past"
    unless_null $P4017, vivify_2007
    new $P4017, "Undef"
  vivify_2007:
    find_lex $P4018, "$/"
    unless_null $P4018, vivify_2008
    $P4018 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P4019, $P4018["else"]
    unless_null $P4019, vivify_2009
    $P4019 = root_new ['parrot';'ResizablePMCArray']
  vivify_2009:
    set $P4020, $P4019[0]
    unless_null $P4020, vivify_2010
    new $P4020, "Undef"
  vivify_2010:
    $P4021 = $P4020."ast"()
    $P4022 = "block_immediate"($P4021)
    $P4017."push"($P4022)
  if_4014_end:
.annotate 'line', 1434
    new $P4043, 'ExceptionHandler'
    set_label $P4043, loop4042_handler
    $P4043."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4043
  loop4042_test:
    find_lex $P4023, "$count"
    unless_null $P4023, vivify_2011
    new $P4023, "Undef"
  vivify_2011:
    set $N4024, $P4023
    isgt $I4025, $N4024, 0.0
    unless $I4025, loop4042_done
  loop4042_redo:
    .const 'Sub' $P4027 = "478_1304523757.895" 
    capture_lex $P4027
    $P4027()
  loop4042_next:
    goto loop4042_test
  loop4042_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4044, exception, 'type'
    eq $P4044, .CONTROL_LOOP_NEXT, loop4042_next
    eq $P4044, .CONTROL_LOOP_REDO, loop4042_redo
  loop4042_done:
    pop_eh 
.annotate 'line', 1440
    find_lex $P4045, "$/"
    find_lex $P4046, "$past"
    unless_null $P4046, vivify_2020
    new $P4046, "Undef"
  vivify_2020:
    $P4047 = $P4045."!make"($P4046)
.annotate 'line', 1427
    .return ($P4047)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4026"  :anon :subid("478_1304523757.895") :outer("477_1304523757.895")
.annotate 'line', 1436
    new $P4028, "Undef"
    .lex "$else", $P4028
.annotate 'line', 1434
    find_lex $P4029, "$count"
    unless_null $P4029, vivify_2012
    new $P4029, "Undef"
  vivify_2012:
    clone $P4030, $P4029
    dec $P4029
.annotate 'line', 1436
    find_lex $P4031, "$past"
    unless_null $P4031, vivify_2013
    new $P4031, "Undef"
  vivify_2013:
    store_lex "$else", $P4031
.annotate 'line', 1437
    find_lex $P4032, "$count"
    unless_null $P4032, vivify_2014
    new $P4032, "Undef"
  vivify_2014:
    set $I4033, $P4032
    find_lex $P4034, "$/"
    unless_null $P4034, vivify_2015
    $P4034 = root_new ['parrot';'Hash']
  vivify_2015:
    set $P4035, $P4034["xblock"]
    unless_null $P4035, vivify_2016
    $P4035 = root_new ['parrot';'ResizablePMCArray']
  vivify_2016:
    set $P4036, $P4035[$I4033]
    unless_null $P4036, vivify_2017
    new $P4036, "Undef"
  vivify_2017:
    $P4037 = $P4036."ast"()
    $P4038 = "xblock_immediate"($P4037)
    store_lex "$past", $P4038
.annotate 'line', 1438
    find_lex $P4039, "$past"
    unless_null $P4039, vivify_2018
    new $P4039, "Undef"
  vivify_2018:
    find_lex $P4040, "$else"
    unless_null $P4040, vivify_2019
    new $P4040, "Undef"
  vivify_2019:
    $P4041 = $P4039."push"($P4040)
.annotate 'line', 1434
    .return ($P4041)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("479_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4049
    .param pmc param_4050
.annotate 'line', 1443
    .lex "self", param_4049
    .lex "$/", param_4050
.annotate 'line', 1444
    new $P4051, "Undef"
    .lex "$past", $P4051
    find_lex $P4052, "$/"
    unless_null $P4052, vivify_2021
    $P4052 = root_new ['parrot';'Hash']
  vivify_2021:
    set $P4053, $P4052["xblock"]
    unless_null $P4053, vivify_2022
    new $P4053, "Undef"
  vivify_2022:
    $P4054 = $P4053."ast"()
    $P4055 = "xblock_immediate"($P4054)
    store_lex "$past", $P4055
.annotate 'line', 1445
    find_lex $P4056, "$past"
    unless_null $P4056, vivify_2023
    new $P4056, "Undef"
  vivify_2023:
    $P4056."pasttype"("unless")
.annotate 'line', 1446
    find_lex $P4057, "$/"
    find_lex $P4058, "$past"
    unless_null $P4058, vivify_2024
    new $P4058, "Undef"
  vivify_2024:
    $P4059 = $P4057."!make"($P4058)
.annotate 'line', 1443
    .return ($P4059)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("480_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4061
    .param pmc param_4062
.annotate 'line', 1449
    .lex "self", param_4061
    .lex "$/", param_4062
.annotate 'line', 1450
    new $P4063, "Undef"
    .lex "$past", $P4063
    find_lex $P4064, "$/"
    unless_null $P4064, vivify_2025
    $P4064 = root_new ['parrot';'Hash']
  vivify_2025:
    set $P4065, $P4064["xblock"]
    unless_null $P4065, vivify_2026
    new $P4065, "Undef"
  vivify_2026:
    $P4066 = $P4065."ast"()
    $P4067 = "xblock_immediate"($P4066)
    store_lex "$past", $P4067
.annotate 'line', 1451
    find_lex $P4068, "$past"
    unless_null $P4068, vivify_2027
    new $P4068, "Undef"
  vivify_2027:
    find_lex $P4069, "$/"
    unless_null $P4069, vivify_2028
    $P4069 = root_new ['parrot';'Hash']
  vivify_2028:
    set $P4070, $P4069["sym"]
    unless_null $P4070, vivify_2029
    new $P4070, "Undef"
  vivify_2029:
    set $S4071, $P4070
    $P4068."pasttype"($S4071)
.annotate 'line', 1452
    find_lex $P4072, "$/"
    find_lex $P4073, "$past"
    unless_null $P4073, vivify_2030
    new $P4073, "Undef"
  vivify_2030:
    $P4074 = $P4072."!make"($P4073)
.annotate 'line', 1449
    .return ($P4074)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("481_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4076
    .param pmc param_4077
.annotate 'line', 1455
    .lex "self", param_4076
    .lex "$/", param_4077
.annotate 'line', 1456
    new $P4078, "Undef"
    .lex "$pasttype", $P4078
.annotate 'line', 1457
    new $P4079, "Undef"
    .lex "$past", $P4079
.annotate 'line', 1456
    new $P4080, "String"
    assign $P4080, "repeat_"
    find_lex $P4081, "$/"
    unless_null $P4081, vivify_2031
    $P4081 = root_new ['parrot';'Hash']
  vivify_2031:
    set $P4082, $P4081["wu"]
    unless_null $P4082, vivify_2032
    new $P4082, "Undef"
  vivify_2032:
    set $S4083, $P4082
    concat $P4084, $P4080, $S4083
    store_lex "$pasttype", $P4084
    find_lex $P4085, "$past"
    unless_null $P4085, vivify_2033
    new $P4085, "Undef"
  vivify_2033:
.annotate 'line', 1458
    find_lex $P4087, "$/"
    unless_null $P4087, vivify_2034
    $P4087 = root_new ['parrot';'Hash']
  vivify_2034:
    set $P4088, $P4087["xblock"]
    unless_null $P4088, vivify_2035
    new $P4088, "Undef"
  vivify_2035:
    if $P4088, if_4086
.annotate 'line', 1463
    get_hll_global $P4095, "GLOBAL"
    nqp_get_package_through_who $P4096, $P4095, "PAST"
    get_who $P4097, $P4096
    set $P4098, $P4097["Op"]
    find_lex $P4099, "$/"
    unless_null $P4099, vivify_2036
    $P4099 = root_new ['parrot';'Hash']
  vivify_2036:
    set $P4100, $P4099["EXPR"]
    unless_null $P4100, vivify_2037
    new $P4100, "Undef"
  vivify_2037:
    $P4101 = $P4100."ast"()
    find_lex $P4102, "$/"
    unless_null $P4102, vivify_2038
    $P4102 = root_new ['parrot';'Hash']
  vivify_2038:
    set $P4103, $P4102["pblock"]
    unless_null $P4103, vivify_2039
    new $P4103, "Undef"
  vivify_2039:
    $P4104 = $P4103."ast"()
    $P4105 = "block_immediate"($P4104)
    find_lex $P4106, "$pasttype"
    unless_null $P4106, vivify_2040
    new $P4106, "Undef"
  vivify_2040:
    find_lex $P4107, "$/"
    unless_null $P4107, vivify_2041
    new $P4107, "Undef"
  vivify_2041:
    $P4108 = $P4098."new"($P4101, $P4105, $P4106 :named("pasttype"), $P4107 :named("node"))
    store_lex "$past", $P4108
.annotate 'line', 1462
    goto if_4086_end
  if_4086:
.annotate 'line', 1459
    find_lex $P4089, "$/"
    unless_null $P4089, vivify_2042
    $P4089 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P4090, $P4089["xblock"]
    unless_null $P4090, vivify_2043
    new $P4090, "Undef"
  vivify_2043:
    $P4091 = $P4090."ast"()
    $P4092 = "xblock_immediate"($P4091)
    store_lex "$past", $P4092
.annotate 'line', 1460
    find_lex $P4093, "$past"
    unless_null $P4093, vivify_2044
    new $P4093, "Undef"
  vivify_2044:
    find_lex $P4094, "$pasttype"
    unless_null $P4094, vivify_2045
    new $P4094, "Undef"
  vivify_2045:
    $P4093."pasttype"($P4094)
  if_4086_end:
.annotate 'line', 1466
    find_lex $P4109, "$/"
    find_lex $P4110, "$past"
    unless_null $P4110, vivify_2046
    new $P4110, "Undef"
  vivify_2046:
    $P4111 = $P4109."!make"($P4110)
.annotate 'line', 1455
    .return ($P4111)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("482_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4113
    .param pmc param_4114
.annotate 'line', 1469
    .lex "self", param_4113
    .lex "$/", param_4114
.annotate 'line', 1470
    new $P4115, "Undef"
    .lex "$past", $P4115
.annotate 'line', 1472
    new $P4116, "Undef"
    .lex "$block", $P4116
.annotate 'line', 1470
    find_lex $P4117, "$/"
    unless_null $P4117, vivify_2047
    $P4117 = root_new ['parrot';'Hash']
  vivify_2047:
    set $P4118, $P4117["xblock"]
    unless_null $P4118, vivify_2048
    new $P4118, "Undef"
  vivify_2048:
    $P4119 = $P4118."ast"()
    store_lex "$past", $P4119
.annotate 'line', 1471
    find_lex $P4120, "$past"
    unless_null $P4120, vivify_2049
    new $P4120, "Undef"
  vivify_2049:
    $P4120."pasttype"("for")
.annotate 'line', 1472
    find_lex $P4121, "$past"
    unless_null $P4121, vivify_2050
    $P4121 = root_new ['parrot';'ResizablePMCArray']
  vivify_2050:
    set $P4122, $P4121[1]
    unless_null $P4122, vivify_2051
    new $P4122, "Undef"
  vivify_2051:
    store_lex "$block", $P4122
.annotate 'line', 1473
    find_lex $P4124, "$block"
    unless_null $P4124, vivify_2052
    new $P4124, "Undef"
  vivify_2052:
    $P4125 = $P4124."arity"()
    if $P4125, unless_4123_end
.annotate 'line', 1474
    find_lex $P4126, "$block"
    unless_null $P4126, vivify_2053
    $P4126 = root_new ['parrot';'ResizablePMCArray']
  vivify_2053:
    set $P4127, $P4126[0]
    unless_null $P4127, vivify_2054
    new $P4127, "Undef"
  vivify_2054:
    get_hll_global $P4128, "GLOBAL"
    nqp_get_package_through_who $P4129, $P4128, "PAST"
    get_who $P4130, $P4129
    set $P4131, $P4130["Var"]
    $P4132 = $P4131."new"("$_" :named("name"), "parameter" :named("scope"))
    $P4127."push"($P4132)
.annotate 'line', 1475
    find_lex $P4133, "$block"
    unless_null $P4133, vivify_2055
    new $P4133, "Undef"
  vivify_2055:
    $P4133."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1476
    find_lex $P4134, "$block"
    unless_null $P4134, vivify_2056
    new $P4134, "Undef"
  vivify_2056:
    $P4134."arity"(1)
  unless_4123_end:
.annotate 'line', 1478
    find_lex $P4135, "$block"
    unless_null $P4135, vivify_2057
    new $P4135, "Undef"
  vivify_2057:
    $P4135."blocktype"("immediate")
.annotate 'line', 1479
    find_lex $P4136, "$/"
    find_lex $P4137, "$past"
    unless_null $P4137, vivify_2058
    new $P4137, "Undef"
  vivify_2058:
    $P4138 = $P4136."!make"($P4137)
.annotate 'line', 1469
    .return ($P4138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("483_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4140
    .param pmc param_4141
.annotate 'line', 1482
    .lex "self", param_4140
    .lex "$/", param_4141
.annotate 'line', 1483
    new $P4142, "Undef"
    .lex "$block", $P4142
    find_lex $P4143, "$/"
    unless_null $P4143, vivify_2059
    $P4143 = root_new ['parrot';'Hash']
  vivify_2059:
    set $P4144, $P4143["block"]
    unless_null $P4144, vivify_2060
    new $P4144, "Undef"
  vivify_2060:
    $P4145 = $P4144."ast"()
    store_lex "$block", $P4145
.annotate 'line', 1484
    find_lex $P4146, "$/"
    unless_null $P4146, vivify_2061
    new $P4146, "Undef"
  vivify_2061:
    find_lex $P4147, "$block"
    unless_null $P4147, vivify_2062
    new $P4147, "Undef"
  vivify_2062:
    "push_block_handler"($P4146, $P4147)
.annotate 'line', 1485
    find_lex $P4148, "$?PACKAGE"
    get_who $P4149, $P4148
    set $P4150, $P4149["@BLOCK"]
    unless_null $P4150, vivify_2063
    $P4150 = root_new ['parrot';'ResizablePMCArray']
  vivify_2063:
    set $P4151, $P4150[0]
    unless_null $P4151, vivify_2064
    new $P4151, "Undef"
  vivify_2064:
    $P4152 = $P4151."handlers"()
    set $P4153, $P4152[0]
    unless_null $P4153, vivify_2065
    new $P4153, "Undef"
  vivify_2065:
    $P4153."handle_types_except"("CONTROL")
.annotate 'line', 1486
    find_lex $P4154, "$/"
    get_hll_global $P4155, "GLOBAL"
    nqp_get_package_through_who $P4156, $P4155, "PAST"
    get_who $P4157, $P4156
    set $P4158, $P4157["Stmts"]
    find_lex $P4159, "$/"
    unless_null $P4159, vivify_2066
    new $P4159, "Undef"
  vivify_2066:
    $P4160 = $P4158."new"($P4159 :named("node"))
    $P4161 = $P4154."!make"($P4160)
.annotate 'line', 1482
    .return ($P4161)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("484_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4163
    .param pmc param_4164
.annotate 'line', 1489
    .lex "self", param_4163
    .lex "$/", param_4164
.annotate 'line', 1490
    new $P4165, "Undef"
    .lex "$block", $P4165
    find_lex $P4166, "$/"
    unless_null $P4166, vivify_2067
    $P4166 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P4167, $P4166["block"]
    unless_null $P4167, vivify_2068
    new $P4167, "Undef"
  vivify_2068:
    $P4168 = $P4167."ast"()
    store_lex "$block", $P4168
.annotate 'line', 1491
    find_lex $P4169, "$/"
    unless_null $P4169, vivify_2069
    new $P4169, "Undef"
  vivify_2069:
    find_lex $P4170, "$block"
    unless_null $P4170, vivify_2070
    new $P4170, "Undef"
  vivify_2070:
    "push_block_handler"($P4169, $P4170)
.annotate 'line', 1492
    find_lex $P4171, "$?PACKAGE"
    get_who $P4172, $P4171
    set $P4173, $P4172["@BLOCK"]
    unless_null $P4173, vivify_2071
    $P4173 = root_new ['parrot';'ResizablePMCArray']
  vivify_2071:
    set $P4174, $P4173[0]
    unless_null $P4174, vivify_2072
    new $P4174, "Undef"
  vivify_2072:
    $P4175 = $P4174."handlers"()
    set $P4176, $P4175[0]
    unless_null $P4176, vivify_2073
    new $P4176, "Undef"
  vivify_2073:
    $P4176."handle_types"("CONTROL")
.annotate 'line', 1493
    find_lex $P4177, "$/"
    get_hll_global $P4178, "GLOBAL"
    nqp_get_package_through_who $P4179, $P4178, "PAST"
    get_who $P4180, $P4179
    set $P4181, $P4180["Stmts"]
    find_lex $P4182, "$/"
    unless_null $P4182, vivify_2074
    new $P4182, "Undef"
  vivify_2074:
    $P4183 = $P4181."new"($P4182 :named("node"))
    $P4184 = $P4177."!make"($P4183)
.annotate 'line', 1489
    .return ($P4184)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("485_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4187
    .param pmc param_4188
.annotate 'line', 1533
    .lex "self", param_4187
    .lex "$/", param_4188
.annotate 'line', 1534
    find_lex $P4189, "$?PACKAGE"
    get_who $P4190, $P4189
    set $P4191, $P4190["@BLOCK"]
    unless_null $P4191, vivify_2075
    $P4191 = root_new ['parrot';'ResizablePMCArray']
  vivify_2075:
    set $P4192, $P4191[0]
    unless_null $P4192, vivify_2076
    new $P4192, "Undef"
  vivify_2076:
    find_lex $P4193, "$/"
    unless_null $P4193, vivify_2077
    $P4193 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4194, $P4193["blorst"]
    unless_null $P4194, vivify_2078
    new $P4194, "Undef"
  vivify_2078:
    $P4195 = $P4194."ast"()
    $P4192."push"($P4195)
.annotate 'line', 1535
    find_lex $P4196, "$/"
    get_hll_global $P4197, "GLOBAL"
    nqp_get_package_through_who $P4198, $P4197, "PAST"
    get_who $P4199, $P4198
    set $P4200, $P4199["Stmts"]
    $P4201 = $P4200."new"()
    $P4202 = $P4196."!make"($P4201)
.annotate 'line', 1533
    .return ($P4202)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("486_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4204
    .param pmc param_4205
.annotate 'line', 1538
    .lex "self", param_4204
    .lex "$/", param_4205
.annotate 'line', 1539
    new $P4206, "Undef"
    .lex "$past", $P4206
    find_lex $P4207, "$/"
    unless_null $P4207, vivify_2079
    $P4207 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P4208, $P4207["blorst"]
    unless_null $P4208, vivify_2080
    new $P4208, "Undef"
  vivify_2080:
    $P4209 = $P4208."ast"()
    store_lex "$past", $P4209
.annotate 'line', 1540
    get_hll_global $P4211, "GLOBAL"
    nqp_get_package_through_who $P4212, $P4211, "PAST"
    get_who $P4213, $P4212
    set $P4214, $P4213["Block"]
    find_lex $P4215, "$past"
    unless_null $P4215, vivify_2081
    new $P4215, "Undef"
  vivify_2081:
    $P4216 = $P4214."ACCEPTS"($P4215)
    if $P4216, unless_4210_end
.annotate 'line', 1541
    get_hll_global $P4217, "GLOBAL"
    nqp_get_package_through_who $P4218, $P4217, "PAST"
    get_who $P4219, $P4218
    set $P4220, $P4219["Block"]
    find_lex $P4221, "$past"
    unless_null $P4221, vivify_2082
    new $P4221, "Undef"
  vivify_2082:
    find_lex $P4222, "$/"
    unless_null $P4222, vivify_2083
    new $P4222, "Undef"
  vivify_2083:
    $P4223 = $P4220."new"($P4221, "immediate" :named("blocktype"), $P4222 :named("node"))
    store_lex "$past", $P4223
  unless_4210_end:
.annotate 'line', 1543
    find_lex $P4225, "$past"
    unless_null $P4225, vivify_2084
    new $P4225, "Undef"
  vivify_2084:
    $P4226 = $P4225."handlers"()
    if $P4226, unless_4224_end
.annotate 'line', 1544
    find_lex $P4227, "$past"
    unless_null $P4227, vivify_2085
    new $P4227, "Undef"
  vivify_2085:
    get_hll_global $P4228, "GLOBAL"
    nqp_get_package_through_who $P4229, $P4228, "PAST"
    get_who $P4230, $P4229
    set $P4231, $P4230["Control"]
.annotate 'line', 1546
    get_hll_global $P4232, "GLOBAL"
    nqp_get_package_through_who $P4233, $P4232, "PAST"
    get_who $P4234, $P4233
    set $P4235, $P4234["Stmts"]
.annotate 'line', 1547
    get_hll_global $P4236, "GLOBAL"
    nqp_get_package_through_who $P4237, $P4236, "PAST"
    get_who $P4238, $P4237
    set $P4239, $P4238["Op"]
.annotate 'line', 1548
    get_hll_global $P4240, "GLOBAL"
    nqp_get_package_through_who $P4241, $P4240, "PAST"
    get_who $P4242, $P4241
    set $P4243, $P4242["Var"]
.annotate 'line', 1549
    get_hll_global $P4244, "GLOBAL"
    nqp_get_package_through_who $P4245, $P4244, "PAST"
    get_who $P4246, $P4245
    set $P4247, $P4246["Var"]
    $P4248 = $P4247."new"("register" :named("scope"), "exception" :named("name"))
    $P4249 = $P4243."new"($P4248, "handled", "keyed" :named("scope"))
.annotate 'line', 1548
    $P4250 = $P4239."new"($P4249, 1, "bind" :named("pasttype"))
.annotate 'line', 1547
    $P4251 = $P4235."new"($P4250)
.annotate 'line', 1546
    $P4252 = $P4231."new"($P4251, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1544
    new $P4253, "ResizablePMCArray"
    push $P4253, $P4252
    $P4227."handlers"($P4253)
  unless_4224_end:
.annotate 'line', 1558
    find_lex $P4254, "$/"
    find_lex $P4255, "$past"
    unless_null $P4255, vivify_2086
    new $P4255, "Undef"
  vivify_2086:
    $P4256 = $P4254."!make"($P4255)
.annotate 'line', 1538
    .return ($P4256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("487_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4258
    .param pmc param_4259
.annotate 'line', 1561
    .lex "self", param_4258
    .lex "$/", param_4259
.annotate 'line', 1562
    find_lex $P4260, "$/"
.annotate 'line', 1563
    find_lex $P4263, "$/"
    unless_null $P4263, vivify_2087
    $P4263 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P4264, $P4263["block"]
    unless_null $P4264, vivify_2088
    new $P4264, "Undef"
  vivify_2088:
    if $P4264, if_4262
.annotate 'line', 1564
    find_lex $P4269, "$/"
    unless_null $P4269, vivify_2089
    $P4269 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P4270, $P4269["statement"]
    unless_null $P4270, vivify_2090
    new $P4270, "Undef"
  vivify_2090:
    $P4271 = $P4270."ast"()
    set $P4261, $P4271
.annotate 'line', 1563
    goto if_4262_end
  if_4262:
    find_lex $P4265, "$/"
    unless_null $P4265, vivify_2091
    $P4265 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P4266, $P4265["block"]
    unless_null $P4266, vivify_2092
    new $P4266, "Undef"
  vivify_2092:
    $P4267 = $P4266."ast"()
    $P4268 = "block_immediate"($P4267)
    set $P4261, $P4268
  if_4262_end:
    $P4272 = $P4260."!make"($P4261)
.annotate 'line', 1561
    .return ($P4272)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("488_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4274
    .param pmc param_4275
.annotate 'line', 1569
    .lex "self", param_4274
    .lex "$/", param_4275
    find_lex $P4276, "$/"
    find_lex $P4277, "$/"
    unless_null $P4277, vivify_2093
    $P4277 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P4278, $P4277["cond"]
    unless_null $P4278, vivify_2094
    new $P4278, "Undef"
  vivify_2094:
    $P4279 = $P4278."ast"()
    $P4280 = $P4276."!make"($P4279)
    .return ($P4280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("489_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4282
    .param pmc param_4283
.annotate 'line', 1570
    .lex "self", param_4282
    .lex "$/", param_4283
    find_lex $P4284, "$/"
    find_lex $P4285, "$/"
    unless_null $P4285, vivify_2095
    $P4285 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P4286, $P4285["cond"]
    unless_null $P4286, vivify_2096
    new $P4286, "Undef"
  vivify_2096:
    $P4287 = $P4286."ast"()
    $P4288 = $P4284."!make"($P4287)
    .return ($P4288)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("490_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4290
    .param pmc param_4291
.annotate 'line', 1572
    .lex "self", param_4290
    .lex "$/", param_4291
    find_lex $P4292, "$/"
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_2097
    $P4293 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P4294, $P4293["cond"]
    unless_null $P4294, vivify_2098
    new $P4294, "Undef"
  vivify_2098:
    $P4295 = $P4294."ast"()
    $P4296 = $P4292."!make"($P4295)
    .return ($P4296)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("491_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4298
    .param pmc param_4299
.annotate 'line', 1573
    .lex "self", param_4298
    .lex "$/", param_4299
    find_lex $P4300, "$/"
    find_lex $P4301, "$/"
    unless_null $P4301, vivify_2099
    $P4301 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P4302, $P4301["cond"]
    unless_null $P4302, vivify_2100
    new $P4302, "Undef"
  vivify_2100:
    $P4303 = $P4302."ast"()
    $P4304 = $P4300."!make"($P4303)
    .return ($P4304)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("492_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4306
    .param pmc param_4307
.annotate 'line', 1577
    .lex "self", param_4306
    .lex "$/", param_4307
    find_lex $P4308, "$/"
    find_lex $P4309, "$/"
    unless_null $P4309, vivify_2101
    $P4309 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4310, $P4309["fatarrow"]
    unless_null $P4310, vivify_2102
    new $P4310, "Undef"
  vivify_2102:
    $P4311 = $P4310."ast"()
    $P4312 = $P4308."!make"($P4311)
    .return ($P4312)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("493_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4314
    .param pmc param_4315
.annotate 'line', 1578
    .lex "self", param_4314
    .lex "$/", param_4315
    find_lex $P4316, "$/"
    find_lex $P4317, "$/"
    unless_null $P4317, vivify_2103
    $P4317 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P4318, $P4317["colonpair"]
    unless_null $P4318, vivify_2104
    new $P4318, "Undef"
  vivify_2104:
    $P4319 = $P4318."ast"()
    $P4320 = $P4316."!make"($P4319)
    .return ($P4320)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("494_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4322
    .param pmc param_4323
.annotate 'line', 1579
    .lex "self", param_4322
    .lex "$/", param_4323
    find_lex $P4324, "$/"
    find_lex $P4325, "$/"
    unless_null $P4325, vivify_2105
    $P4325 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P4326, $P4325["variable"]
    unless_null $P4326, vivify_2106
    new $P4326, "Undef"
  vivify_2106:
    $P4327 = $P4326."ast"()
    $P4328 = $P4324."!make"($P4327)
    .return ($P4328)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("495_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4330
    .param pmc param_4331
.annotate 'line', 1580
    .lex "self", param_4330
    .lex "$/", param_4331
    find_lex $P4332, "$/"
    find_lex $P4333, "$/"
    unless_null $P4333, vivify_2107
    $P4333 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P4334, $P4333["package_declarator"]
    unless_null $P4334, vivify_2108
    new $P4334, "Undef"
  vivify_2108:
    $P4335 = $P4334."ast"()
    $P4336 = $P4332."!make"($P4335)
    .return ($P4336)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("496_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4338
    .param pmc param_4339
.annotate 'line', 1581
    .lex "self", param_4338
    .lex "$/", param_4339
    find_lex $P4340, "$/"
    find_lex $P4341, "$/"
    unless_null $P4341, vivify_2109
    $P4341 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4342, $P4341["scope_declarator"]
    unless_null $P4342, vivify_2110
    new $P4342, "Undef"
  vivify_2110:
    $P4343 = $P4342."ast"()
    $P4344 = $P4340."!make"($P4343)
    .return ($P4344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("497_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4346
    .param pmc param_4347
.annotate 'line', 1582
    .lex "self", param_4346
    .lex "$/", param_4347
    find_lex $P4348, "$/"
    find_lex $P4349, "$/"
    unless_null $P4349, vivify_2111
    $P4349 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4350, $P4349["routine_declarator"]
    unless_null $P4350, vivify_2112
    new $P4350, "Undef"
  vivify_2112:
    $P4351 = $P4350."ast"()
    $P4352 = $P4348."!make"($P4351)
    .return ($P4352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("498_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4354
    .param pmc param_4355
.annotate 'line', 1583
    .lex "self", param_4354
    .lex "$/", param_4355
    find_lex $P4356, "$/"
    find_lex $P4357, "$/"
    unless_null $P4357, vivify_2113
    $P4357 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P4358, $P4357["regex_declarator"]
    unless_null $P4358, vivify_2114
    new $P4358, "Undef"
  vivify_2114:
    $P4359 = $P4358."ast"()
    $P4360 = $P4356."!make"($P4359)
    .return ($P4360)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("499_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4362
    .param pmc param_4363
.annotate 'line', 1584
    .lex "self", param_4362
    .lex "$/", param_4363
    find_lex $P4364, "$/"
    find_lex $P4365, "$/"
    unless_null $P4365, vivify_2115
    $P4365 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4366, $P4365["statement_prefix"]
    unless_null $P4366, vivify_2116
    new $P4366, "Undef"
  vivify_2116:
    $P4367 = $P4366."ast"()
    $P4368 = $P4364."!make"($P4367)
    .return ($P4368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("500_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4370
    .param pmc param_4371
.annotate 'line', 1585
    .lex "self", param_4370
    .lex "$/", param_4371
    find_lex $P4372, "$/"
    find_lex $P4373, "$/"
    unless_null $P4373, vivify_2117
    $P4373 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P4374, $P4373["pblock"]
    unless_null $P4374, vivify_2118
    new $P4374, "Undef"
  vivify_2118:
    $P4375 = $P4374."ast"()
    $P4376 = $P4372."!make"($P4375)
    .return ($P4376)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("501_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4378
    .param pmc param_4379
.annotate 'line', 1587
    .lex "self", param_4378
    .lex "$/", param_4379
.annotate 'line', 1588
    new $P4380, "Undef"
    .lex "$past", $P4380
    find_lex $P4381, "$/"
    unless_null $P4381, vivify_2119
    $P4381 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4382, $P4381["val"]
    unless_null $P4382, vivify_2120
    new $P4382, "Undef"
  vivify_2120:
    $P4383 = $P4382."ast"()
    store_lex "$past", $P4383
.annotate 'line', 1589
    find_lex $P4384, "$past"
    unless_null $P4384, vivify_2121
    new $P4384, "Undef"
  vivify_2121:
    find_lex $P4385, "$/"
    unless_null $P4385, vivify_2122
    $P4385 = root_new ['parrot';'Hash']
  vivify_2122:
    set $P4386, $P4385["key"]
    unless_null $P4386, vivify_2123
    new $P4386, "Undef"
  vivify_2123:
    $P4387 = $P4386."Str"()
    $P4384."named"($P4387)
.annotate 'line', 1590
    find_lex $P4388, "$/"
    find_lex $P4389, "$past"
    unless_null $P4389, vivify_2124
    new $P4389, "Undef"
  vivify_2124:
    $P4390 = $P4388."!make"($P4389)
.annotate 'line', 1587
    .return ($P4390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("502_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4392
    .param pmc param_4393
.annotate 'line', 1593
    .lex "self", param_4392
    .lex "$/", param_4393
.annotate 'line', 1594
    new $P4394, "Undef"
    .lex "$past", $P4394
.annotate 'line', 1595
    find_lex $P4397, "$/"
    unless_null $P4397, vivify_2125
    $P4397 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P4398, $P4397["circumfix"]
    unless_null $P4398, vivify_2126
    new $P4398, "Undef"
  vivify_2126:
    if $P4398, if_4396
.annotate 'line', 1596
    get_hll_global $P4403, "GLOBAL"
    nqp_get_package_through_who $P4404, $P4403, "PAST"
    get_who $P4405, $P4404
    set $P4406, $P4405["Val"]
    find_lex $P4407, "$/"
    unless_null $P4407, vivify_2127
    $P4407 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P4408, $P4407["not"]
    unless_null $P4408, vivify_2128
    new $P4408, "Undef"
  vivify_2128:
    isfalse $I4409, $P4408
    $P4410 = $P4406."new"($I4409 :named("value"))
    set $P4395, $P4410
.annotate 'line', 1595
    goto if_4396_end
  if_4396:
    find_lex $P4399, "$/"
    unless_null $P4399, vivify_2129
    $P4399 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P4400, $P4399["circumfix"]
    unless_null $P4400, vivify_2130
    $P4400 = root_new ['parrot';'ResizablePMCArray']
  vivify_2130:
    set $P4401, $P4400[0]
    unless_null $P4401, vivify_2131
    new $P4401, "Undef"
  vivify_2131:
    $P4402 = $P4401."ast"()
    set $P4395, $P4402
  if_4396_end:
    store_lex "$past", $P4395
.annotate 'line', 1597
    find_lex $P4411, "$past"
    unless_null $P4411, vivify_2132
    new $P4411, "Undef"
  vivify_2132:
    find_lex $P4412, "$/"
    unless_null $P4412, vivify_2133
    $P4412 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4413, $P4412["identifier"]
    unless_null $P4413, vivify_2134
    new $P4413, "Undef"
  vivify_2134:
    set $S4414, $P4413
    $P4411."named"($S4414)
.annotate 'line', 1598
    find_lex $P4415, "$/"
    find_lex $P4416, "$past"
    unless_null $P4416, vivify_2135
    new $P4416, "Undef"
  vivify_2135:
    $P4417 = $P4415."!make"($P4416)
.annotate 'line', 1593
    .return ($P4417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("503_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4419
    .param pmc param_4420
.annotate 'line', 1601
    .const 'Sub' $P4436 = "504_1304523757.895" 
    capture_lex $P4436
    .lex "self", param_4419
    .lex "$/", param_4420
.annotate 'line', 1602
    new $P4421, "Undef"
    .lex "$past", $P4421
.annotate 'line', 1601
    find_lex $P4422, "$past"
    unless_null $P4422, vivify_2136
    new $P4422, "Undef"
  vivify_2136:
.annotate 'line', 1603
    find_lex $P4424, "$/"
    unless_null $P4424, vivify_2137
    $P4424 = root_new ['parrot';'Hash']
  vivify_2137:
    set $P4425, $P4424["postcircumfix"]
    unless_null $P4425, vivify_2138
    new $P4425, "Undef"
  vivify_2138:
    if $P4425, if_4423
.annotate 'line', 1607
    .const 'Sub' $P4436 = "504_1304523757.895" 
    capture_lex $P4436
    $P4436()
    goto if_4423_end
  if_4423:
.annotate 'line', 1604
    find_lex $P4426, "$/"
    unless_null $P4426, vivify_2195
    $P4426 = root_new ['parrot';'Hash']
  vivify_2195:
    set $P4427, $P4426["postcircumfix"]
    unless_null $P4427, vivify_2196
    new $P4427, "Undef"
  vivify_2196:
    $P4428 = $P4427."ast"()
    store_lex "$past", $P4428
.annotate 'line', 1605
    find_lex $P4429, "$past"
    unless_null $P4429, vivify_2197
    new $P4429, "Undef"
  vivify_2197:
    get_hll_global $P4430, "GLOBAL"
    nqp_get_package_through_who $P4431, $P4430, "PAST"
    get_who $P4432, $P4431
    set $P4433, $P4432["Var"]
    $P4434 = $P4433."new"("$/" :named("name"))
    $P4429."unshift"($P4434)
  if_4423_end:
.annotate 'line', 1666
    find_lex $P4618, "$/"
    find_lex $P4619, "$past"
    unless_null $P4619, vivify_2198
    new $P4619, "Undef"
  vivify_2198:
    $P4620 = $P4618."!make"($P4619)
.annotate 'line', 1601
    .return ($P4620)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4435"  :anon :subid("504_1304523757.895") :outer("503_1304523757.895")
.annotate 'line', 1607
    .const 'Sub' $P4512 = "506_1304523757.895" 
    capture_lex $P4512
    .const 'Sub' $P4471 = "505_1304523757.895" 
    capture_lex $P4471
.annotate 'line', 1608
    $P4437 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4437
    get_hll_global $P4438, "GLOBAL"
    nqp_get_package_through_who $P4439, $P4438, "NQP"
    get_who $P4440, $P4439
    set $P4441, $P4440["Compiler"]
    find_lex $P4442, "$/"
    unless_null $P4442, vivify_2139
    new $P4442, "Undef"
  vivify_2139:
    set $S4443, $P4442
    $P4444 = $P4441."parse_name"($S4443)
    store_lex "@name", $P4444
.annotate 'line', 1609
    find_lex $P4447, "@name"
    unless_null $P4447, vivify_2140
    $P4447 = root_new ['parrot';'ResizablePMCArray']
  vivify_2140:
    set $N4448, $P4447
    isgt $I4449, $N4448, 1.0
    if $I4449, if_4446
.annotate 'line', 1616
    find_lex $P4465, "$/"
    unless_null $P4465, vivify_2141
    $P4465 = root_new ['parrot';'Hash']
  vivify_2141:
    set $P4466, $P4465["twigil"]
    unless_null $P4466, vivify_2142
    $P4466 = root_new ['parrot';'ResizablePMCArray']
  vivify_2142:
    set $P4467, $P4466[0]
    unless_null $P4467, vivify_2143
    new $P4467, "Undef"
  vivify_2143:
    set $S4468, $P4467
    iseq $I4469, $S4468, "*"
    if $I4469, if_4464
.annotate 'line', 1627
    find_lex $P4506, "$/"
    unless_null $P4506, vivify_2144
    $P4506 = root_new ['parrot';'Hash']
  vivify_2144:
    set $P4507, $P4506["twigil"]
    unless_null $P4507, vivify_2145
    $P4507 = root_new ['parrot';'ResizablePMCArray']
  vivify_2145:
    set $P4508, $P4507[0]
    unless_null $P4508, vivify_2146
    new $P4508, "Undef"
  vivify_2146:
    set $S4509, $P4508
    iseq $I4510, $S4509, "!"
    if $I4510, if_4505
.annotate 'line', 1656
    find_lex $P4595, "@name"
    unless_null $P4595, vivify_2147
    $P4595 = root_new ['parrot';'ResizablePMCArray']
  vivify_2147:
    set $P4596, $P4595[0]
    unless_null $P4596, vivify_2148
    new $P4596, "Undef"
  vivify_2148:
    set $S4597, $P4596
    $P4598 = "is_package"($S4597)
    if $P4598, if_4594
.annotate 'line', 1661
    get_hll_global $P4607, "GLOBAL"
    nqp_get_package_through_who $P4608, $P4607, "PAST"
    get_who $P4609, $P4608
    set $P4610, $P4609["Var"]
.annotate 'line', 1662
    find_lex $P4611, "@name"
    unless_null $P4611, vivify_2149
    $P4611 = root_new ['parrot';'ResizablePMCArray']
  vivify_2149:
    $P4612 = $P4611."pop"()
    set $S4613, $P4612
    find_lex $P4614, "$/"
    unless_null $P4614, vivify_2150
    $P4614 = root_new ['parrot';'Hash']
  vivify_2150:
    set $P4615, $P4614["sigil"]
    unless_null $P4615, vivify_2151
    new $P4615, "Undef"
  vivify_2151:
    $P4616 = "vivitype"($P4615)
    $P4617 = $P4610."new"($S4613 :named("name"), $P4616 :named("viviself"))
.annotate 'line', 1661
    store_lex "$past", $P4617
.annotate 'line', 1660
    set $P4593, $P4617
.annotate 'line', 1656
    goto if_4594_end
  if_4594:
.annotate 'line', 1657
    find_lex $P4599, "@name"
    unless_null $P4599, vivify_2152
    $P4599 = root_new ['parrot';'ResizablePMCArray']
  vivify_2152:
    find_lex $P4600, "$/"
    unless_null $P4600, vivify_2153
    new $P4600, "Undef"
  vivify_2153:
    $P4601 = "lexical_package_lookup"($P4599, $P4600)
    store_lex "$past", $P4601
.annotate 'line', 1658
    find_lex $P4602, "$past"
    unless_null $P4602, vivify_2154
    new $P4602, "Undef"
  vivify_2154:
    find_lex $P4603, "$/"
    unless_null $P4603, vivify_2155
    $P4603 = root_new ['parrot';'Hash']
  vivify_2155:
    set $P4604, $P4603["sigil"]
    unless_null $P4604, vivify_2156
    new $P4604, "Undef"
  vivify_2156:
    $P4605 = "vivitype"($P4604)
    $P4606 = $P4602."viviself"($P4605)
.annotate 'line', 1656
    set $P4593, $P4606
  if_4594_end:
    set $P4504, $P4593
.annotate 'line', 1627
    goto if_4505_end
  if_4505:
    .const 'Sub' $P4512 = "506_1304523757.895" 
    capture_lex $P4512
    $P4592 = $P4512()
    set $P4504, $P4592
  if_4505_end:
    set $P4463, $P4504
.annotate 'line', 1616
    goto if_4464_end
  if_4464:
    .const 'Sub' $P4471 = "505_1304523757.895" 
    capture_lex $P4471
    $P4503 = $P4471()
    set $P4463, $P4503
  if_4464_end:
    set $P4445, $P4463
.annotate 'line', 1609
    goto if_4446_end
  if_4446:
.annotate 'line', 1610
    find_lex $P4451, "$/"
    unless_null $P4451, vivify_2187
    $P4451 = root_new ['parrot';'Hash']
  vivify_2187:
    set $P4452, $P4451["twigil"]
    unless_null $P4452, vivify_2188
    new $P4452, "Undef"
  vivify_2188:
    unless $P4452, if_4450_end
.annotate 'line', 1611
    find_lex $P4453, "$/"
    unless_null $P4453, vivify_2189
    new $P4453, "Undef"
  vivify_2189:
    $P4454 = $P4453."CURSOR"()
    $P4454."panic"("Twigil not allowed on multi-part name")
  if_4450_end:
.annotate 'line', 1613
    find_lex $P4455, "@name"
    unless_null $P4455, vivify_2190
    $P4455 = root_new ['parrot';'ResizablePMCArray']
  vivify_2190:
    find_lex $P4456, "$/"
    unless_null $P4456, vivify_2191
    new $P4456, "Undef"
  vivify_2191:
    $P4457 = "lexical_package_lookup"($P4455, $P4456)
    store_lex "$past", $P4457
.annotate 'line', 1614
    find_lex $P4458, "$past"
    unless_null $P4458, vivify_2192
    new $P4458, "Undef"
  vivify_2192:
    find_lex $P4459, "$/"
    unless_null $P4459, vivify_2193
    $P4459 = root_new ['parrot';'Hash']
  vivify_2193:
    set $P4460, $P4459["sigil"]
    unless_null $P4460, vivify_2194
    new $P4460, "Undef"
  vivify_2194:
    $P4461 = "vivitype"($P4460)
    $P4462 = $P4458."viviself"($P4461)
.annotate 'line', 1609
    set $P4445, $P4462
  if_4446_end:
.annotate 'line', 1607
    .return ($P4445)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4511"  :anon :subid("506_1304523757.895") :outer("504_1304523757.895")
.annotate 'line', 1627
    .const 'Sub' $P4543 = "507_1304523757.895" 
    capture_lex $P4543
.annotate 'line', 1629
    new $P4513, "Undef"
    .lex "$name", $P4513
    find_lex $P4514, "@name"
    unless_null $P4514, vivify_2157
    $P4514 = root_new ['parrot';'ResizablePMCArray']
  vivify_2157:
    $P4515 = $P4514."pop"()
    set $S4516, $P4515
    new $P4517, 'String'
    set $P4517, $S4516
    store_lex "$name", $P4517
.annotate 'line', 1630
    get_hll_global $P4518, "GLOBAL"
    nqp_get_package_through_who $P4519, $P4518, "PAST"
    get_who $P4520, $P4519
    set $P4521, $P4520["Var"]
    find_lex $P4522, "$name"
    unless_null $P4522, vivify_2158
    new $P4522, "Undef"
  vivify_2158:
.annotate 'line', 1632
    find_lex $P4523, "$/"
    unless_null $P4523, vivify_2159
    $P4523 = root_new ['parrot';'Hash']
  vivify_2159:
    set $P4524, $P4523["sigil"]
    unless_null $P4524, vivify_2160
    new $P4524, "Undef"
  vivify_2160:
    $P4525 = "vivitype"($P4524)
.annotate 'line', 1633
    get_hll_global $P4526, "GLOBAL"
    nqp_get_package_through_who $P4527, $P4526, "PAST"
    get_who $P4528, $P4527
    set $P4529, $P4528["Var"]
    $P4530 = $P4529."new"("self" :named("name"))
.annotate 'line', 1634
    get_hll_global $P4531, "GLOBAL"
    nqp_get_package_through_who $P4532, $P4531, "PAST"
    get_who $P4533, $P4532
    set $P4534, $P4533["Var"]
    $P4535 = $P4534."new"("$?CLASS" :named("name"))
    $P4536 = $P4521."new"($P4530, $P4535, $P4522 :named("name"), "attribute_6model" :named("scope"), $P4525 :named("viviself"))
.annotate 'line', 1630
    store_lex "$past", $P4536
.annotate 'line', 1638
    find_dynamic_lex $P4541, "$*IN_DECL"
    unless_null $P4541, vivify_2161
    get_hll_global $P4539, "GLOBAL"
    get_who $P4540, $P4539
    set $P4541, $P4540["$IN_DECL"]
    unless_null $P4541, vivify_2162
    die "Contextual $*IN_DECL not found"
  vivify_2162:
  vivify_2161:
    unless $P4541, unless_4538
    set $P4537, $P4541
    goto unless_4538_end
  unless_4538:
    .const 'Sub' $P4543 = "507_1304523757.895" 
    capture_lex $P4543
    $P4591 = $P4543()
    set $P4537, $P4591
  unless_4538_end:
.annotate 'line', 1627
    .return ($P4537)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4542"  :anon :subid("507_1304523757.895") :outer("506_1304523757.895")
.annotate 'line', 1638
    .const 'Sub' $P4558 = "508_1304523757.895" 
    capture_lex $P4558
.annotate 'line', 1639
    new $P4544, "Undef"
    .lex "$attr", $P4544
.annotate 'line', 1638
    find_lex $P4545, "$attr"
    unless_null $P4545, vivify_2163
    new $P4545, "Undef"
  vivify_2163:
.annotate 'line', 1640
    find_dynamic_lex $P4549, "$*PACKAGE"
    unless_null $P4549, vivify_2164
    get_hll_global $P4547, "GLOBAL"
    get_who $P4548, $P4547
    set $P4549, $P4548["$PACKAGE"]
    unless_null $P4549, vivify_2165
    die "Contextual $*PACKAGE not found"
  vivify_2165:
  vivify_2164:
    get_how $P4550, $P4549
    find_dynamic_lex $P4553, "$*PACKAGE"
    unless_null $P4553, vivify_2166
    get_hll_global $P4551, "GLOBAL"
    get_who $P4552, $P4551
    set $P4553, $P4552["$PACKAGE"]
    unless_null $P4553, vivify_2167
    die "Contextual $*PACKAGE not found"
  vivify_2167:
  vivify_2166:
    $P4554 = $P4550."attributes"($P4553, 1 :named("local"))
    defined $I4555, $P4554
    unless $I4555, for_undef_2168
    iter $P4546, $P4554
    new $P4570, 'ExceptionHandler'
    set_label $P4570, loop4569_handler
    $P4570."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4570
  loop4569_test:
    unless $P4546, loop4569_done
    shift $P4556, $P4546
  loop4569_redo:
    .const 'Sub' $P4558 = "508_1304523757.895" 
    capture_lex $P4558
    $P4558($P4556)
  loop4569_next:
    goto loop4569_test
  loop4569_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4571, exception, 'type'
    eq $P4571, .CONTROL_LOOP_NEXT, loop4569_next
    eq $P4571, .CONTROL_LOOP_REDO, loop4569_redo
  loop4569_done:
    pop_eh 
  for_undef_2168:
.annotate 'line', 1646
    find_lex $P4574, "$attr"
    unless_null $P4574, vivify_2172
    new $P4574, "Undef"
  vivify_2172:
    defined $I4575, $P4574
    if $I4575, if_4573
.annotate 'line', 1652
    find_lex $P4584, "$/"
    unless_null $P4584, vivify_2173
    new $P4584, "Undef"
  vivify_2173:
    $P4585 = $P4584."CURSOR"()
    new $P4586, 'String'
    set $P4586, "Attribute '"
    find_lex $P4587, "$name"
    unless_null $P4587, vivify_2174
    new $P4587, "Undef"
  vivify_2174:
    concat $P4588, $P4586, $P4587
    concat $P4589, $P4588, "' not declared"
    $P4590 = $P4585."panic"($P4589)
.annotate 'line', 1651
    set $P4572, $P4590
.annotate 'line', 1646
    goto if_4573_end
  if_4573:
.annotate 'line', 1647
    find_lex $P4578, "$attr"
    unless_null $P4578, vivify_2175
    new $P4578, "Undef"
  vivify_2175:
    can $I4579, $P4578, "type"
    if $I4579, if_4577
    new $P4576, 'Integer'
    set $P4576, $I4579
    goto if_4577_end
  if_4577:
.annotate 'line', 1648
    find_lex $P4580, "$past"
    unless_null $P4580, vivify_2176
    new $P4580, "Undef"
  vivify_2176:
    find_lex $P4581, "$attr"
    unless_null $P4581, vivify_2177
    new $P4581, "Undef"
  vivify_2177:
    $P4582 = $P4581."type"()
    $P4583 = $P4580."type"($P4582)
.annotate 'line', 1647
    set $P4576, $P4583
  if_4577_end:
.annotate 'line', 1646
    set $P4572, $P4576
  if_4573_end:
.annotate 'line', 1638
    .return ($P4572)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4557"  :anon :subid("508_1304523757.895") :outer("507_1304523757.895")
    .param pmc param_4559
.annotate 'line', 1640
    .lex "$_", param_4559
.annotate 'line', 1641
    find_lex $P4562, "$_"
    unless_null $P4562, vivify_2169
    new $P4562, "Undef"
  vivify_2169:
    $S4563 = $P4562."name"()
    find_lex $P4564, "$name"
    unless_null $P4564, vivify_2170
    new $P4564, "Undef"
  vivify_2170:
    set $S4565, $P4564
    iseq $I4566, $S4563, $S4565
    if $I4566, if_4561
    new $P4560, 'Integer'
    set $P4560, $I4566
    goto if_4561_end
  if_4561:
.annotate 'line', 1642
    find_lex $P4567, "$_"
    unless_null $P4567, vivify_2171
    new $P4567, "Undef"
  vivify_2171:
    store_lex "$attr", $P4567
.annotate 'line', 1643
    set $I4568, .CONTROL_LOOP_LAST
    die 0, $I4568
  if_4561_end:
.annotate 'line', 1640
    .return ($P4560)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4470"  :anon :subid("505_1304523757.895") :outer("504_1304523757.895")
.annotate 'line', 1617
    new $P4472, "Undef"
    .lex "$global_fallback", $P4472
    find_lex $P4473, "$/"
    unless_null $P4473, vivify_2178
    $P4473 = root_new ['parrot';'Hash']
  vivify_2178:
    set $P4474, $P4473["sigil"]
    unless_null $P4474, vivify_2179
    new $P4474, "Undef"
  vivify_2179:
    set $S4475, $P4474
    new $P4476, 'String'
    set $P4476, $S4475
    find_lex $P4477, "$/"
    unless_null $P4477, vivify_2180
    $P4477 = root_new ['parrot';'Hash']
  vivify_2180:
    set $P4478, $P4477["desigilname"]
    unless_null $P4478, vivify_2181
    new $P4478, "Undef"
  vivify_2181:
    concat $P4479, $P4476, $P4478
    new $P4480, "ResizablePMCArray"
    push $P4480, "GLOBAL"
    push $P4480, $P4479
    find_lex $P4481, "$/"
    unless_null $P4481, vivify_2182
    new $P4481, "Undef"
  vivify_2182:
    $P4482 = "lexical_package_lookup"($P4480, $P4481)
    store_lex "$global_fallback", $P4482
.annotate 'line', 1618
    find_lex $P4483, "$global_fallback"
    unless_null $P4483, vivify_2183
    new $P4483, "Undef"
  vivify_2183:
    get_hll_global $P4484, "GLOBAL"
    nqp_get_package_through_who $P4485, $P4484, "PAST"
    get_who $P4486, $P4485
    set $P4487, $P4486["Op"]
.annotate 'line', 1619
    new $P4488, "String"
    assign $P4488, "Contextual "
    find_lex $P4489, "$/"
    unless_null $P4489, vivify_2184
    new $P4489, "Undef"
  vivify_2184:
    set $S4490, $P4489
    concat $P4491, $P4488, $S4490
    concat $P4492, $P4491, " not found"
    $P4493 = $P4487."new"($P4492, "die" :named("pirop"))
.annotate 'line', 1618
    $P4483."viviself"($P4493)
.annotate 'line', 1622
    get_hll_global $P4494, "GLOBAL"
    nqp_get_package_through_who $P4495, $P4494, "PAST"
    get_who $P4496, $P4495
    set $P4497, $P4496["Var"]
.annotate 'line', 1623
    find_lex $P4498, "@name"
    unless_null $P4498, vivify_2185
    $P4498 = root_new ['parrot';'ResizablePMCArray']
  vivify_2185:
    $P4499 = $P4498."pop"()
    set $S4500, $P4499
    find_lex $P4501, "$global_fallback"
    unless_null $P4501, vivify_2186
    new $P4501, "Undef"
  vivify_2186:
    $P4502 = $P4497."new"($S4500 :named("name"), "contextual" :named("scope"), $P4501 :named("viviself"))
.annotate 'line', 1622
    store_lex "$past", $P4502
.annotate 'line', 1616
    .return ($P4502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("509_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4622
    .param pmc param_4623
.annotate 'line', 1669
    .lex "self", param_4622
    .lex "$/", param_4623
    find_lex $P4624, "$/"
    find_lex $P4625, "$/"
    unless_null $P4625, vivify_2199
    $P4625 = root_new ['parrot';'Hash']
  vivify_2199:
    set $P4626, $P4625["package_def"]
    unless_null $P4626, vivify_2200
    new $P4626, "Undef"
  vivify_2200:
    $P4627 = $P4626."ast"()
    $P4628 = $P4624."!make"($P4627)
    .return ($P4628)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("510_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4630
    .param pmc param_4631
.annotate 'line', 1670
    .lex "self", param_4630
    .lex "$/", param_4631
    find_lex $P4632, "$/"
    find_lex $P4633, "$/"
    unless_null $P4633, vivify_2201
    $P4633 = root_new ['parrot';'Hash']
  vivify_2201:
    set $P4634, $P4633["package_def"]
    unless_null $P4634, vivify_2202
    new $P4634, "Undef"
  vivify_2202:
    $P4635 = $P4634."ast"()
    $P4636 = $P4632."!make"($P4635)
    .return ($P4636)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("511_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4638
    .param pmc param_4639
.annotate 'line', 1671
    .lex "self", param_4638
    .lex "$/", param_4639
    find_lex $P4640, "$/"
    find_lex $P4641, "$/"
    unless_null $P4641, vivify_2203
    $P4641 = root_new ['parrot';'Hash']
  vivify_2203:
    set $P4642, $P4641["package_def"]
    unless_null $P4642, vivify_2204
    new $P4642, "Undef"
  vivify_2204:
    $P4643 = $P4642."ast"()
    $P4644 = $P4640."!make"($P4643)
    .return ($P4644)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("512_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4646
    .param pmc param_4647
.annotate 'line', 1672
    .lex "self", param_4646
    .lex "$/", param_4647
    find_lex $P4648, "$/"
    find_lex $P4649, "$/"
    unless_null $P4649, vivify_2205
    $P4649 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P4650, $P4649["package_def"]
    unless_null $P4650, vivify_2206
    new $P4650, "Undef"
  vivify_2206:
    $P4651 = $P4650."ast"()
    $P4652 = $P4648."!make"($P4651)
    .return ($P4652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("513_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4654
    .param pmc param_4655
.annotate 'line', 1673
    .lex "self", param_4654
    .lex "$/", param_4655
    find_lex $P4656, "$/"
    find_lex $P4657, "$/"
    unless_null $P4657, vivify_2207
    $P4657 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P4658, $P4657["package_def"]
    unless_null $P4658, vivify_2208
    new $P4658, "Undef"
  vivify_2208:
    $P4659 = $P4658."ast"()
    $P4660 = $P4656."!make"($P4659)
    .return ($P4660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("514_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4662
    .param pmc param_4663
.annotate 'line', 1674
    .lex "self", param_4662
    .lex "$/", param_4663
    find_lex $P4664, "$/"
    find_lex $P4665, "$/"
    unless_null $P4665, vivify_2209
    $P4665 = root_new ['parrot';'Hash']
  vivify_2209:
    set $P4666, $P4665["package_def"]
    unless_null $P4666, vivify_2210
    new $P4666, "Undef"
  vivify_2210:
    $P4667 = $P4666."ast"()
    $P4668 = $P4664."!make"($P4667)
    .return ($P4668)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("515_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4670
    .param pmc param_4671
.annotate 'line', 1676
    .const 'Sub' $P4851 = "519_1304523757.895" 
    capture_lex $P4851
    .const 'Sub' $P4821 = "518_1304523757.895" 
    capture_lex $P4821
    .const 'Sub' $P4774 = "516_1304523757.895" 
    capture_lex $P4774
    .lex "self", param_4670
    .lex "$/", param_4671
.annotate 'line', 1678
    $P4672 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4672
.annotate 'line', 1679
    new $P4673, "Undef"
    .lex "$name", $P4673
.annotate 'line', 1680
    new $P4674, "Undef"
    .lex "$how", $P4674
.annotate 'line', 1683
    new $P4675, "Undef"
    .lex "$past", $P4675
.annotate 'line', 1678
    find_lex $P4676, "$/"
    unless_null $P4676, vivify_2211
    $P4676 = root_new ['parrot';'Hash']
  vivify_2211:
    set $P4677, $P4676["name"]
    unless_null $P4677, vivify_2212
    $P4677 = root_new ['parrot';'Hash']
  vivify_2212:
    set $P4678, $P4677["identifier"]
    unless_null $P4678, vivify_2213
    new $P4678, "Undef"
  vivify_2213:
    clone $P4679, $P4678
    store_lex "@ns", $P4679
.annotate 'line', 1679
    find_lex $P4680, "@ns"
    unless_null $P4680, vivify_2214
    $P4680 = root_new ['parrot';'ResizablePMCArray']
  vivify_2214:
    $P4681 = $P4680."pop"()
    set $S4682, $P4681
    new $P4683, 'String'
    set $P4683, $S4682
    store_lex "$name", $P4683
.annotate 'line', 1680
    find_dynamic_lex $P4686, "$*PKGDECL"
    unless_null $P4686, vivify_2215
    get_hll_global $P4684, "GLOBAL"
    get_who $P4685, $P4684
    set $P4686, $P4685["$PKGDECL"]
    unless_null $P4686, vivify_2216
    die "Contextual $*PKGDECL not found"
  vivify_2216:
  vivify_2215:
    find_dynamic_lex $P4689, "%*HOW"
    unless_null $P4689, vivify_2217
    get_hll_global $P4687, "GLOBAL"
    get_who $P4688, $P4687
    set $P4689, $P4688["%HOW"]
    unless_null $P4689, vivify_2218
    die "Contextual %*HOW not found"
  vivify_2218:
  vivify_2217:
    set $P4690, $P4689[$P4686]
    unless_null $P4690, vivify_2219
    new $P4690, "Undef"
  vivify_2219:
    store_lex "$how", $P4690
.annotate 'line', 1683
    find_lex $P4693, "$/"
    unless_null $P4693, vivify_2220
    $P4693 = root_new ['parrot';'Hash']
  vivify_2220:
    set $P4694, $P4693["block"]
    unless_null $P4694, vivify_2221
    new $P4694, "Undef"
  vivify_2221:
    if $P4694, if_4692
    find_lex $P4698, "$/"
    unless_null $P4698, vivify_2222
    $P4698 = root_new ['parrot';'Hash']
  vivify_2222:
    set $P4699, $P4698["comp_unit"]
    unless_null $P4699, vivify_2223
    new $P4699, "Undef"
  vivify_2223:
    $P4700 = $P4699."ast"()
    set $P4691, $P4700
    goto if_4692_end
  if_4692:
    find_lex $P4695, "$/"
    unless_null $P4695, vivify_2224
    $P4695 = root_new ['parrot';'Hash']
  vivify_2224:
    set $P4696, $P4695["block"]
    unless_null $P4696, vivify_2225
    new $P4696, "Undef"
  vivify_2225:
    $P4697 = $P4696."ast"()
    set $P4691, $P4697
  if_4692_end:
    store_lex "$past", $P4691
.annotate 'line', 1684
    find_dynamic_lex $P4706, "$*SCOPE"
    unless_null $P4706, vivify_2226
    get_hll_global $P4704, "GLOBAL"
    get_who $P4705, $P4704
    set $P4706, $P4705["$SCOPE"]
    unless_null $P4706, vivify_2227
    die "Contextual $*SCOPE not found"
  vivify_2227:
  vivify_2226:
    set $S4707, $P4706
    iseq $I4708, $S4707, "our"
    unless $I4708, unless_4703
    new $P4702, 'Integer'
    set $P4702, $I4708
    goto unless_4703_end
  unless_4703:
    find_dynamic_lex $P4711, "$*SCOPE"
    unless_null $P4711, vivify_2228
    get_hll_global $P4709, "GLOBAL"
    get_who $P4710, $P4709
    set $P4711, $P4710["$SCOPE"]
    unless_null $P4711, vivify_2229
    die "Contextual $*SCOPE not found"
  vivify_2229:
  vivify_2228:
    set $S4712, $P4711
    iseq $I4713, $S4712, ""
    new $P4702, 'Integer'
    set $P4702, $I4713
  unless_4703_end:
    unless $P4702, if_4701_end
.annotate 'line', 1685
    find_lex $P4714, "$past"
    unless_null $P4714, vivify_2230
    new $P4714, "Undef"
  vivify_2230:
    find_lex $P4715, "$/"
    unless_null $P4715, vivify_2231
    $P4715 = root_new ['parrot';'Hash']
  vivify_2231:
    set $P4716, $P4715["name"]
    unless_null $P4716, vivify_2232
    $P4716 = root_new ['parrot';'Hash']
  vivify_2232:
    set $P4717, $P4716["identifier"]
    unless_null $P4717, vivify_2233
    new $P4717, "Undef"
  vivify_2233:
    $P4714."namespace"($P4717)
  if_4701_end:
.annotate 'line', 1692
    find_lex $P4721, "$how"
    unless_null $P4721, vivify_2234
    new $P4721, "Undef"
  vivify_2234:
    can $I4722, $P4721, "parametric"
    if $I4722, if_4720
    new $P4719, 'Integer'
    set $P4719, $I4722
    goto if_4720_end
  if_4720:
    find_lex $P4723, "$how"
    unless_null $P4723, vivify_2235
    new $P4723, "Undef"
  vivify_2235:
    find_lex $P4724, "$how"
    unless_null $P4724, vivify_2236
    new $P4724, "Undef"
  vivify_2236:
    $P4725 = $P4723."parametric"($P4724)
    set $P4719, $P4725
  if_4720_end:
    if $P4719, if_4718
.annotate 'line', 1701
    find_lex $P4755, "$past"
    unless_null $P4755, vivify_2237
    new $P4755, "Undef"
  vivify_2237:
    $P4755."blocktype"("immediate")
.annotate 'line', 1702
    find_dynamic_lex $P4758, "$*SC"
    unless_null $P4758, vivify_2238
    get_hll_global $P4756, "GLOBAL"
    get_who $P4757, $P4756
    set $P4758, $P4757["$SC"]
    unless_null $P4758, vivify_2239
    die "Contextual $*SC not found"
  vivify_2239:
  vivify_2238:
    find_lex $P4759, "$past"
    unless_null $P4759, vivify_2240
    new $P4759, "Undef"
  vivify_2240:
    find_dynamic_lex $P4762, "$*PACKAGE"
    unless_null $P4762, vivify_2241
    get_hll_global $P4760, "GLOBAL"
    get_who $P4761, $P4760
    set $P4762, $P4761["$PACKAGE"]
    unless_null $P4762, vivify_2242
    die "Contextual $*PACKAGE not found"
  vivify_2242:
  vivify_2241:
    $P4758."install_lexical_symbol"($P4759, "$?PACKAGE", $P4762)
.annotate 'line', 1703
    find_dynamic_lex $P4765, "$*SC"
    unless_null $P4765, vivify_2243
    get_hll_global $P4763, "GLOBAL"
    get_who $P4764, $P4763
    set $P4765, $P4764["$SC"]
    unless_null $P4765, vivify_2244
    die "Contextual $*SC not found"
  vivify_2244:
  vivify_2243:
    find_lex $P4766, "$past"
    unless_null $P4766, vivify_2245
    new $P4766, "Undef"
  vivify_2245:
    find_dynamic_lex $P4769, "$*PACKAGE"
    unless_null $P4769, vivify_2246
    get_hll_global $P4767, "GLOBAL"
    get_who $P4768, $P4767
    set $P4769, $P4768["$PACKAGE"]
    unless_null $P4769, vivify_2247
    die "Contextual $*PACKAGE not found"
  vivify_2247:
  vivify_2246:
    $P4765."install_lexical_symbol"($P4766, "$?CLASS", $P4769)
.annotate 'line', 1700
    goto if_4718_end
  if_4718:
.annotate 'line', 1693
    find_lex $P4726, "$past"
    unless_null $P4726, vivify_2248
    new $P4726, "Undef"
  vivify_2248:
    $P4726."blocktype"("declaration")
.annotate 'line', 1694
    find_lex $P4727, "$past"
    unless_null $P4727, vivify_2249
    new $P4727, "Undef"
  vivify_2249:
    get_hll_global $P4728, "GLOBAL"
    nqp_get_package_through_who $P4729, $P4728, "PAST"
    get_who $P4730, $P4729
    set $P4731, $P4730["Var"]
    $P4732 = $P4731."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4727."unshift"($P4732)
.annotate 'line', 1695
    find_lex $P4733, "$past"
    unless_null $P4733, vivify_2250
    new $P4733, "Undef"
  vivify_2250:
    $P4733."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1696
    find_dynamic_lex $P4736, "$*SC"
    unless_null $P4736, vivify_2251
    get_hll_global $P4734, "GLOBAL"
    get_who $P4735, $P4734
    set $P4736, $P4735["$SC"]
    unless_null $P4736, vivify_2252
    die "Contextual $*SC not found"
  vivify_2252:
  vivify_2251:
    find_dynamic_lex $P4739, "$*PACKAGE"
    unless_null $P4739, vivify_2253
    get_hll_global $P4737, "GLOBAL"
    get_who $P4738, $P4737
    set $P4739, $P4738["$PACKAGE"]
    unless_null $P4739, vivify_2254
    die "Contextual $*PACKAGE not found"
  vivify_2254:
  vivify_2253:
    find_lex $P4740, "$past"
    unless_null $P4740, vivify_2255
    new $P4740, "Undef"
  vivify_2255:
    $P4736."pkg_set_body_block"($P4739, $P4740)
.annotate 'line', 1697
    find_dynamic_lex $P4743, "$*SC"
    unless_null $P4743, vivify_2256
    get_hll_global $P4741, "GLOBAL"
    get_who $P4742, $P4741
    set $P4743, $P4742["$SC"]
    unless_null $P4743, vivify_2257
    die "Contextual $*SC not found"
  vivify_2257:
  vivify_2256:
    find_lex $P4744, "$past"
    unless_null $P4744, vivify_2258
    new $P4744, "Undef"
  vivify_2258:
    find_dynamic_lex $P4747, "$*PACKAGE"
    unless_null $P4747, vivify_2259
    get_hll_global $P4745, "GLOBAL"
    get_who $P4746, $P4745
    set $P4747, $P4746["$PACKAGE"]
    unless_null $P4747, vivify_2260
    die "Contextual $*PACKAGE not found"
  vivify_2260:
  vivify_2259:
    $P4743."install_lexical_symbol"($P4744, "$?PACKAGE", $P4747)
.annotate 'line', 1698
    find_dynamic_lex $P4750, "$*SC"
    unless_null $P4750, vivify_2261
    get_hll_global $P4748, "GLOBAL"
    get_who $P4749, $P4748
    set $P4750, $P4749["$SC"]
    unless_null $P4750, vivify_2262
    die "Contextual $*SC not found"
  vivify_2262:
  vivify_2261:
    find_lex $P4751, "$past"
    unless_null $P4751, vivify_2263
    new $P4751, "Undef"
  vivify_2263:
    find_dynamic_lex $P4754, "$*PACKAGE"
    unless_null $P4754, vivify_2264
    get_hll_global $P4752, "GLOBAL"
    get_who $P4753, $P4752
    set $P4754, $P4753["$PACKAGE"]
    unless_null $P4754, vivify_2265
    die "Contextual $*PACKAGE not found"
  vivify_2265:
  vivify_2264:
    $P4750."install_lexical_symbol"($P4751, "$?ROLE", $P4754)
  if_4718_end:
.annotate 'line', 1707
    find_lex $P4771, "$/"
    unless_null $P4771, vivify_2266
    $P4771 = root_new ['parrot';'Hash']
  vivify_2266:
    set $P4772, $P4771["parent"]
    unless_null $P4772, vivify_2267
    new $P4772, "Undef"
  vivify_2267:
    if $P4772, if_4770
.annotate 'line', 1721
    find_lex $P4818, "$how"
    unless_null $P4818, vivify_2268
    new $P4818, "Undef"
  vivify_2268:
    can $I4819, $P4818, "set_default_parent"
    unless $I4819, if_4817_end
    .const 'Sub' $P4821 = "518_1304523757.895" 
    capture_lex $P4821
    $P4821()
  if_4817_end:
    goto if_4770_end
  if_4770:
.annotate 'line', 1707
    .const 'Sub' $P4774 = "516_1304523757.895" 
    capture_lex $P4774
    $P4774()
  if_4770_end:
.annotate 'line', 1728
    find_lex $P4843, "$/"
    unless_null $P4843, vivify_2294
    $P4843 = root_new ['parrot';'Hash']
  vivify_2294:
    set $P4844, $P4843["role"]
    unless_null $P4844, vivify_2295
    new $P4844, "Undef"
  vivify_2295:
    unless $P4844, if_4842_end
.annotate 'line', 1729
    find_lex $P4846, "$/"
    unless_null $P4846, vivify_2296
    $P4846 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P4847, $P4846["role"]
    unless_null $P4847, vivify_2297
    new $P4847, "Undef"
  vivify_2297:
    defined $I4848, $P4847
    unless $I4848, for_undef_2298
    iter $P4845, $P4847
    new $P4892, 'ExceptionHandler'
    set_label $P4892, loop4891_handler
    $P4892."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4892
  loop4891_test:
    unless $P4845, loop4891_done
    shift $P4849, $P4845
  loop4891_redo:
    .const 'Sub' $P4851 = "519_1304523757.895" 
    capture_lex $P4851
    $P4851($P4849)
  loop4891_next:
    goto loop4891_test
  loop4891_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4893, exception, 'type'
    eq $P4893, .CONTROL_LOOP_NEXT, loop4891_next
    eq $P4893, .CONTROL_LOOP_REDO, loop4891_redo
  loop4891_done:
    pop_eh 
  for_undef_2298:
  if_4842_end:
.annotate 'line', 1746
    find_dynamic_lex $P4896, "$*SC"
    unless_null $P4896, vivify_2312
    get_hll_global $P4894, "GLOBAL"
    get_who $P4895, $P4894
    set $P4896, $P4895["$SC"]
    unless_null $P4896, vivify_2313
    die "Contextual $*SC not found"
  vivify_2313:
  vivify_2312:
    find_dynamic_lex $P4899, "$*PACKAGE"
    unless_null $P4899, vivify_2314
    get_hll_global $P4897, "GLOBAL"
    get_who $P4898, $P4897
    set $P4899, $P4898["$PACKAGE"]
    unless_null $P4899, vivify_2315
    die "Contextual $*PACKAGE not found"
  vivify_2315:
  vivify_2314:
    $P4896."pkg_compose"($P4899)
.annotate 'line', 1748
    find_lex $P4900, "$/"
    find_lex $P4901, "$past"
    unless_null $P4901, vivify_2316
    new $P4901, "Undef"
  vivify_2316:
    $P4902 = $P4900."!make"($P4901)
.annotate 'line', 1676
    .return ($P4902)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4820"  :anon :subid("518_1304523757.895") :outer("515_1304523757.895")
.annotate 'line', 1722
    new $P4822, "Undef"
    .lex "$default", $P4822
    find_dynamic_lex $P4827, "$*PKGDECL"
    unless_null $P4827, vivify_2269
    get_hll_global $P4825, "GLOBAL"
    get_who $P4826, $P4825
    set $P4827, $P4826["$PKGDECL"]
    unless_null $P4827, vivify_2270
    die "Contextual $*PKGDECL not found"
  vivify_2270:
  vivify_2269:
    set $S4828, $P4827
    iseq $I4829, $S4828, "grammar"
    if $I4829, if_4824
    new $P4831, "ResizablePMCArray"
    push $P4831, "NQPMu"
    set $P4823, $P4831
    goto if_4824_end
  if_4824:
    new $P4830, "ResizablePMCArray"
    push $P4830, "Regex"
    push $P4830, "Cursor"
    set $P4823, $P4830
  if_4824_end:
    store_lex "$default", $P4823
.annotate 'line', 1723
    find_dynamic_lex $P4834, "$*SC"
    unless_null $P4834, vivify_2271
    get_hll_global $P4832, "GLOBAL"
    get_who $P4833, $P4832
    set $P4834, $P4833["$SC"]
    unless_null $P4834, vivify_2272
    die "Contextual $*SC not found"
  vivify_2272:
  vivify_2271:
    find_dynamic_lex $P4837, "$*PACKAGE"
    unless_null $P4837, vivify_2273
    get_hll_global $P4835, "GLOBAL"
    get_who $P4836, $P4835
    set $P4837, $P4836["$PACKAGE"]
    unless_null $P4837, vivify_2274
    die "Contextual $*PACKAGE not found"
  vivify_2274:
  vivify_2273:
.annotate 'line', 1724
    find_lex $P4838, "$default"
    unless_null $P4838, vivify_2275
    new $P4838, "Undef"
  vivify_2275:
    find_lex $P4839, "$/"
    unless_null $P4839, vivify_2276
    new $P4839, "Undef"
  vivify_2276:
    $P4840 = "find_sym"($P4838, $P4839)
    $P4841 = $P4834."pkg_add_parent_or_role"($P4837, "set_default_parent", $P4840)
.annotate 'line', 1721
    .return ($P4841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4773"  :anon :subid("516_1304523757.895") :outer("515_1304523757.895")
.annotate 'line', 1707
    .const 'Sub' $P4780 = "517_1304523757.895" 
    capture_lex $P4780
.annotate 'line', 1708
    new $P4775, "Undef"
    .lex "$parent", $P4775
.annotate 'line', 1709
    new $P4776, "Undef"
    .lex "$parent_found", $P4776
.annotate 'line', 1707
    find_lex $P4777, "$parent"
    unless_null $P4777, vivify_2277
    new $P4777, "Undef"
  vivify_2277:
    find_lex $P4778, "$parent_found"
    unless_null $P4778, vivify_2278
    new $P4778, "Undef"
  vivify_2278:
.annotate 'line', 1710
    .const 'Sub' $P4780 = "517_1304523757.895" 
    capture_lex $P4780
    $P4780()
.annotate 'line', 1714
    find_lex $P4798, "$parent_found"
    unless_null $P4798, vivify_2284
    new $P4798, "Undef"
  vivify_2284:
    if $P4798, if_4797
.annotate 'line', 1718
    find_lex $P4807, "$/"
    unless_null $P4807, vivify_2285
    new $P4807, "Undef"
  vivify_2285:
    $P4808 = $P4807."CURSOR"()
    new $P4809, "String"
    assign $P4809, "Could not find parent class '"
    find_lex $P4810, "$/"
    unless_null $P4810, vivify_2286
    $P4810 = root_new ['parrot';'Hash']
  vivify_2286:
    set $P4811, $P4810["parent"]
    unless_null $P4811, vivify_2287
    $P4811 = root_new ['parrot';'ResizablePMCArray']
  vivify_2287:
    set $P4812, $P4811[0]
    unless_null $P4812, vivify_2288
    new $P4812, "Undef"
  vivify_2288:
    set $S4813, $P4812
    concat $P4814, $P4809, $S4813
    concat $P4815, $P4814, "'"
    $P4816 = $P4808."panic"($P4815)
.annotate 'line', 1717
    set $P4796, $P4816
.annotate 'line', 1714
    goto if_4797_end
  if_4797:
.annotate 'line', 1715
    find_dynamic_lex $P4801, "$*SC"
    unless_null $P4801, vivify_2289
    get_hll_global $P4799, "GLOBAL"
    get_who $P4800, $P4799
    set $P4801, $P4800["$SC"]
    unless_null $P4801, vivify_2290
    die "Contextual $*SC not found"
  vivify_2290:
  vivify_2289:
    find_dynamic_lex $P4804, "$*PACKAGE"
    unless_null $P4804, vivify_2291
    get_hll_global $P4802, "GLOBAL"
    get_who $P4803, $P4802
    set $P4804, $P4803["$PACKAGE"]
    unless_null $P4804, vivify_2292
    die "Contextual $*PACKAGE not found"
  vivify_2292:
  vivify_2291:
    find_lex $P4805, "$parent"
    unless_null $P4805, vivify_2293
    new $P4805, "Undef"
  vivify_2293:
    $P4806 = $P4801."pkg_add_parent_or_role"($P4804, "add_parent", $P4805)
.annotate 'line', 1714
    set $P4796, $P4806
  if_4797_end:
.annotate 'line', 1707
    .return ($P4796)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4779"  :anon :subid("517_1304523757.895") :outer("516_1304523757.895")
.annotate 'line', 1710
    new $P4791, 'ExceptionHandler'
    set_label $P4791, control_4790
    $P4791."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4791
.annotate 'line', 1711
    find_lex $P4781, "$/"
    unless_null $P4781, vivify_2279
    $P4781 = root_new ['parrot';'Hash']
  vivify_2279:
    set $P4782, $P4781["parent"]
    unless_null $P4782, vivify_2280
    $P4782 = root_new ['parrot';'ResizablePMCArray']
  vivify_2280:
    set $P4783, $P4782[0]
    unless_null $P4783, vivify_2281
    $P4783 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P4784, $P4783["identifier"]
    unless_null $P4784, vivify_2282
    new $P4784, "Undef"
  vivify_2282:
    clone $P4785, $P4784
    find_lex $P4786, "$/"
    unless_null $P4786, vivify_2283
    new $P4786, "Undef"
  vivify_2283:
    $P4787 = "find_sym"($P4785, $P4786)
    store_lex "$parent", $P4787
.annotate 'line', 1712
    new $P4788, "Integer"
    assign $P4788, 1
    store_lex "$parent_found", $P4788
.annotate 'line', 1710
    pop_eh 
    goto skip_handler_4789
  control_4790:
    .local pmc exception 
    .get_results (exception) 
    new $P4794, 'Integer'
    set $P4794, 1
    set exception["handled"], $P4794
    set $I4795, exception["handled"]
    ne $I4795, 1, nothandled_4793
  handled_4792:
    .return (exception)
  nothandled_4793:
    rethrow exception
  skip_handler_4789:
    .return ($P4788)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4850"  :anon :subid("519_1304523757.895") :outer("515_1304523757.895")
    .param pmc param_4854
.annotate 'line', 1729
    .const 'Sub' $P4858 = "520_1304523757.895" 
    capture_lex $P4858
.annotate 'line', 1730
    new $P4852, "Undef"
    .lex "$role", $P4852
.annotate 'line', 1731
    new $P4853, "Undef"
    .lex "$role_found", $P4853
    .lex "$_", param_4854
.annotate 'line', 1729
    find_lex $P4855, "$role"
    unless_null $P4855, vivify_2299
    new $P4855, "Undef"
  vivify_2299:
    find_lex $P4856, "$role_found"
    unless_null $P4856, vivify_2300
    new $P4856, "Undef"
  vivify_2300:
.annotate 'line', 1732
    .const 'Sub' $P4858 = "520_1304523757.895" 
    capture_lex $P4858
    $P4858()
.annotate 'line', 1736
    find_lex $P4874, "$role_found"
    unless_null $P4874, vivify_2304
    new $P4874, "Undef"
  vivify_2304:
    if $P4874, if_4873
.annotate 'line', 1740
    find_lex $P4883, "$/"
    unless_null $P4883, vivify_2305
    new $P4883, "Undef"
  vivify_2305:
    $P4884 = $P4883."CURSOR"()
    new $P4885, "String"
    assign $P4885, "Could not find role '"
    find_lex $P4886, "$_"
    unless_null $P4886, vivify_2306
    new $P4886, "Undef"
  vivify_2306:
    set $S4887, $P4886
    concat $P4888, $P4885, $S4887
    concat $P4889, $P4888, "'"
    $P4890 = $P4884."panic"($P4889)
.annotate 'line', 1739
    set $P4872, $P4890
.annotate 'line', 1736
    goto if_4873_end
  if_4873:
.annotate 'line', 1737
    find_dynamic_lex $P4877, "$*SC"
    unless_null $P4877, vivify_2307
    get_hll_global $P4875, "GLOBAL"
    get_who $P4876, $P4875
    set $P4877, $P4876["$SC"]
    unless_null $P4877, vivify_2308
    die "Contextual $*SC not found"
  vivify_2308:
  vivify_2307:
    find_dynamic_lex $P4880, "$*PACKAGE"
    unless_null $P4880, vivify_2309
    get_hll_global $P4878, "GLOBAL"
    get_who $P4879, $P4878
    set $P4880, $P4879["$PACKAGE"]
    unless_null $P4880, vivify_2310
    die "Contextual $*PACKAGE not found"
  vivify_2310:
  vivify_2309:
    find_lex $P4881, "$role"
    unless_null $P4881, vivify_2311
    new $P4881, "Undef"
  vivify_2311:
    $P4882 = $P4877."pkg_add_parent_or_role"($P4880, "add_role", $P4881)
.annotate 'line', 1736
    set $P4872, $P4882
  if_4873_end:
.annotate 'line', 1729
    .return ($P4872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4857"  :anon :subid("520_1304523757.895") :outer("519_1304523757.895")
.annotate 'line', 1732
    new $P4867, 'ExceptionHandler'
    set_label $P4867, control_4866
    $P4867."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4867
.annotate 'line', 1733
    find_lex $P4859, "$_"
    unless_null $P4859, vivify_2301
    $P4859 = root_new ['parrot';'Hash']
  vivify_2301:
    set $P4860, $P4859["identifier"]
    unless_null $P4860, vivify_2302
    new $P4860, "Undef"
  vivify_2302:
    clone $P4861, $P4860
    find_lex $P4862, "$/"
    unless_null $P4862, vivify_2303
    new $P4862, "Undef"
  vivify_2303:
    $P4863 = "find_sym"($P4861, $P4862)
    store_lex "$role", $P4863
.annotate 'line', 1734
    new $P4864, "Integer"
    assign $P4864, 1
    store_lex "$role_found", $P4864
.annotate 'line', 1732
    pop_eh 
    goto skip_handler_4865
  control_4866:
    .local pmc exception 
    .get_results (exception) 
    new $P4870, 'Integer'
    set $P4870, 1
    set exception["handled"], $P4870
    set $I4871, exception["handled"]
    ne $I4871, 1, nothandled_4869
  handled_4868:
    .return (exception)
  nothandled_4869:
    rethrow exception
  skip_handler_4865:
    .return ($P4864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("521_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4904
    .param pmc param_4905
.annotate 'line', 1751
    .lex "self", param_4904
    .lex "$/", param_4905
    find_lex $P4906, "$/"
    find_lex $P4907, "$/"
    unless_null $P4907, vivify_2317
    $P4907 = root_new ['parrot';'Hash']
  vivify_2317:
    set $P4908, $P4907["scoped"]
    unless_null $P4908, vivify_2318
    new $P4908, "Undef"
  vivify_2318:
    $P4909 = $P4908."ast"()
    $P4910 = $P4906."!make"($P4909)
    .return ($P4910)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("522_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4912
    .param pmc param_4913
.annotate 'line', 1752
    .lex "self", param_4912
    .lex "$/", param_4913
    find_lex $P4914, "$/"
    find_lex $P4915, "$/"
    unless_null $P4915, vivify_2319
    $P4915 = root_new ['parrot';'Hash']
  vivify_2319:
    set $P4916, $P4915["scoped"]
    unless_null $P4916, vivify_2320
    new $P4916, "Undef"
  vivify_2320:
    $P4917 = $P4916."ast"()
    $P4918 = $P4914."!make"($P4917)
    .return ($P4918)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("523_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4920
    .param pmc param_4921
.annotate 'line', 1753
    .lex "self", param_4920
    .lex "$/", param_4921
    find_lex $P4922, "$/"
    find_lex $P4923, "$/"
    unless_null $P4923, vivify_2321
    $P4923 = root_new ['parrot';'Hash']
  vivify_2321:
    set $P4924, $P4923["scoped"]
    unless_null $P4924, vivify_2322
    new $P4924, "Undef"
  vivify_2322:
    $P4925 = $P4924."ast"()
    $P4926 = $P4922."!make"($P4925)
    .return ($P4926)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("524_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4928
    .param pmc param_4929
.annotate 'line', 1755
    .lex "self", param_4928
    .lex "$/", param_4929
.annotate 'line', 1756
    find_lex $P4930, "$/"
    find_lex $P4933, "$/"
    unless_null $P4933, vivify_2323
    $P4933 = root_new ['parrot';'Hash']
  vivify_2323:
    set $P4934, $P4933["declarator"]
    unless_null $P4934, vivify_2324
    new $P4934, "Undef"
  vivify_2324:
    if $P4934, if_4932
.annotate 'line', 1757
    find_lex $P4940, "$/"
    unless_null $P4940, vivify_2325
    $P4940 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P4941, $P4940["multi_declarator"]
    unless_null $P4941, vivify_2326
    new $P4941, "Undef"
  vivify_2326:
    if $P4941, if_4939
.annotate 'line', 1758
    find_lex $P4945, "$/"
    unless_null $P4945, vivify_2327
    $P4945 = root_new ['parrot';'Hash']
  vivify_2327:
    set $P4946, $P4945["package_declarator"]
    unless_null $P4946, vivify_2328
    new $P4946, "Undef"
  vivify_2328:
    $P4947 = $P4946."ast"()
    set $P4938, $P4947
.annotate 'line', 1757
    goto if_4939_end
  if_4939:
    find_lex $P4942, "$/"
    unless_null $P4942, vivify_2329
    $P4942 = root_new ['parrot';'Hash']
  vivify_2329:
    set $P4943, $P4942["multi_declarator"]
    unless_null $P4943, vivify_2330
    new $P4943, "Undef"
  vivify_2330:
    $P4944 = $P4943."ast"()
    set $P4938, $P4944
  if_4939_end:
    set $P4931, $P4938
.annotate 'line', 1756
    goto if_4932_end
  if_4932:
    find_lex $P4935, "$/"
    unless_null $P4935, vivify_2331
    $P4935 = root_new ['parrot';'Hash']
  vivify_2331:
    set $P4936, $P4935["declarator"]
    unless_null $P4936, vivify_2332
    new $P4936, "Undef"
  vivify_2332:
    $P4937 = $P4936."ast"()
    set $P4931, $P4937
  if_4932_end:
    $P4948 = $P4930."!make"($P4931)
.annotate 'line', 1755
    .return ($P4948)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("525_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4950
    .param pmc param_4951
.annotate 'line', 1761
    .lex "self", param_4950
    .lex "$/", param_4951
.annotate 'line', 1762
    find_lex $P4952, "$/"
.annotate 'line', 1763
    find_lex $P4955, "$/"
    unless_null $P4955, vivify_2333
    $P4955 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P4956, $P4955["routine_declarator"]
    unless_null $P4956, vivify_2334
    new $P4956, "Undef"
  vivify_2334:
    if $P4956, if_4954
.annotate 'line', 1764
    find_lex $P4960, "$/"
    unless_null $P4960, vivify_2335
    $P4960 = root_new ['parrot';'Hash']
  vivify_2335:
    set $P4961, $P4960["variable_declarator"]
    unless_null $P4961, vivify_2336
    new $P4961, "Undef"
  vivify_2336:
    $P4962 = $P4961."ast"()
    set $P4953, $P4962
.annotate 'line', 1763
    goto if_4954_end
  if_4954:
    find_lex $P4957, "$/"
    unless_null $P4957, vivify_2337
    $P4957 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P4958, $P4957["routine_declarator"]
    unless_null $P4958, vivify_2338
    new $P4958, "Undef"
  vivify_2338:
    $P4959 = $P4958."ast"()
    set $P4953, $P4959
  if_4954_end:
    $P4963 = $P4952."!make"($P4953)
.annotate 'line', 1761
    .return ($P4963)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("526_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4965
    .param pmc param_4966
.annotate 'line', 1767
    .lex "self", param_4965
    .lex "$/", param_4966
    find_lex $P4967, "$/"
    find_lex $P4970, "$/"
    unless_null $P4970, vivify_2339
    $P4970 = root_new ['parrot';'Hash']
  vivify_2339:
    set $P4971, $P4970["declarator"]
    unless_null $P4971, vivify_2340
    new $P4971, "Undef"
  vivify_2340:
    if $P4971, if_4969
    find_lex $P4975, "$/"
    unless_null $P4975, vivify_2341
    $P4975 = root_new ['parrot';'Hash']
  vivify_2341:
    set $P4976, $P4975["routine_def"]
    unless_null $P4976, vivify_2342
    new $P4976, "Undef"
  vivify_2342:
    $P4977 = $P4976."ast"()
    set $P4968, $P4977
    goto if_4969_end
  if_4969:
    find_lex $P4972, "$/"
    unless_null $P4972, vivify_2343
    $P4972 = root_new ['parrot';'Hash']
  vivify_2343:
    set $P4973, $P4972["declarator"]
    unless_null $P4973, vivify_2344
    new $P4973, "Undef"
  vivify_2344:
    $P4974 = $P4973."ast"()
    set $P4968, $P4974
  if_4969_end:
    $P4978 = $P4967."!make"($P4968)
    .return ($P4978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("527_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4980
    .param pmc param_4981
.annotate 'line', 1768
    .lex "self", param_4980
    .lex "$/", param_4981
    find_lex $P4982, "$/"
    find_lex $P4985, "$/"
    unless_null $P4985, vivify_2345
    $P4985 = root_new ['parrot';'Hash']
  vivify_2345:
    set $P4986, $P4985["declarator"]
    unless_null $P4986, vivify_2346
    new $P4986, "Undef"
  vivify_2346:
    if $P4986, if_4984
    find_lex $P4990, "$/"
    unless_null $P4990, vivify_2347
    $P4990 = root_new ['parrot';'Hash']
  vivify_2347:
    set $P4991, $P4990["routine_def"]
    unless_null $P4991, vivify_2348
    new $P4991, "Undef"
  vivify_2348:
    $P4992 = $P4991."ast"()
    set $P4983, $P4992
    goto if_4984_end
  if_4984:
    find_lex $P4987, "$/"
    unless_null $P4987, vivify_2349
    $P4987 = root_new ['parrot';'Hash']
  vivify_2349:
    set $P4988, $P4987["declarator"]
    unless_null $P4988, vivify_2350
    new $P4988, "Undef"
  vivify_2350:
    $P4989 = $P4988."ast"()
    set $P4983, $P4989
  if_4984_end:
    $P4993 = $P4982."!make"($P4983)
    .return ($P4993)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("528_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_4995
    .param pmc param_4996
.annotate 'line', 1769
    .lex "self", param_4995
    .lex "$/", param_4996
    find_lex $P4997, "$/"
    find_lex $P4998, "$/"
    unless_null $P4998, vivify_2351
    $P4998 = root_new ['parrot';'Hash']
  vivify_2351:
    set $P4999, $P4998["declarator"]
    unless_null $P4999, vivify_2352
    new $P4999, "Undef"
  vivify_2352:
    $P5000 = $P4999."ast"()
    $P5001 = $P4997."!make"($P5000)
    .return ($P5001)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("529_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5003
    .param pmc param_5004
.annotate 'line', 1772
    .const 'Sub' $P5038 = "530_1304523757.895" 
    capture_lex $P5038
    .lex "self", param_5003
    .lex "$/", param_5004
.annotate 'line', 1773
    new $P5005, "Undef"
    .lex "$past", $P5005
.annotate 'line', 1774
    new $P5006, "Undef"
    .lex "$sigil", $P5006
.annotate 'line', 1775
    new $P5007, "Undef"
    .lex "$name", $P5007
.annotate 'line', 1776
    new $P5008, "Undef"
    .lex "$BLOCK", $P5008
.annotate 'line', 1773
    find_lex $P5009, "$/"
    unless_null $P5009, vivify_2353
    $P5009 = root_new ['parrot';'Hash']
  vivify_2353:
    set $P5010, $P5009["variable"]
    unless_null $P5010, vivify_2354
    new $P5010, "Undef"
  vivify_2354:
    $P5011 = $P5010."ast"()
    store_lex "$past", $P5011
.annotate 'line', 1774
    find_lex $P5012, "$/"
    unless_null $P5012, vivify_2355
    $P5012 = root_new ['parrot';'Hash']
  vivify_2355:
    set $P5013, $P5012["variable"]
    unless_null $P5013, vivify_2356
    $P5013 = root_new ['parrot';'Hash']
  vivify_2356:
    set $P5014, $P5013["sigil"]
    unless_null $P5014, vivify_2357
    new $P5014, "Undef"
  vivify_2357:
    store_lex "$sigil", $P5014
.annotate 'line', 1775
    find_lex $P5015, "$past"
    unless_null $P5015, vivify_2358
    new $P5015, "Undef"
  vivify_2358:
    $P5016 = $P5015."name"()
    store_lex "$name", $P5016
.annotate 'line', 1776
    find_lex $P5017, "$?PACKAGE"
    get_who $P5018, $P5017
    set $P5019, $P5018["@BLOCK"]
    unless_null $P5019, vivify_2359
    $P5019 = root_new ['parrot';'ResizablePMCArray']
  vivify_2359:
    set $P5020, $P5019[0]
    unless_null $P5020, vivify_2360
    new $P5020, "Undef"
  vivify_2360:
    store_lex "$BLOCK", $P5020
.annotate 'line', 1777
    find_lex $P5024, "$name"
    unless_null $P5024, vivify_2361
    new $P5024, "Undef"
  vivify_2361:
    if $P5024, if_5023
    set $P5022, $P5024
    goto if_5023_end
  if_5023:
    find_lex $P5025, "$BLOCK"
    unless_null $P5025, vivify_2362
    new $P5025, "Undef"
  vivify_2362:
    find_lex $P5026, "$name"
    unless_null $P5026, vivify_2363
    new $P5026, "Undef"
  vivify_2363:
    $P5027 = $P5025."symbol"($P5026)
    set $P5022, $P5027
  if_5023_end:
    unless $P5022, if_5021_end
.annotate 'line', 1778
    find_lex $P5028, "$/"
    unless_null $P5028, vivify_2364
    new $P5028, "Undef"
  vivify_2364:
    $P5029 = $P5028."CURSOR"()
    find_lex $P5030, "$name"
    unless_null $P5030, vivify_2365
    new $P5030, "Undef"
  vivify_2365:
    $P5029."panic"("Redeclaration of symbol ", $P5030)
  if_5021_end:
.annotate 'line', 1780
    find_dynamic_lex $P5034, "$*SCOPE"
    unless_null $P5034, vivify_2366
    get_hll_global $P5032, "GLOBAL"
    get_who $P5033, $P5032
    set $P5034, $P5033["$SCOPE"]
    unless_null $P5034, vivify_2367
    die "Contextual $*SCOPE not found"
  vivify_2367:
  vivify_2366:
    set $S5035, $P5034
    iseq $I5036, $S5035, "has"
    if $I5036, if_5031
.annotate 'line', 1800
    find_dynamic_lex $P5095, "$*SCOPE"
    unless_null $P5095, vivify_2368
    get_hll_global $P5093, "GLOBAL"
    get_who $P5094, $P5093
    set $P5095, $P5094["$SCOPE"]
    unless_null $P5095, vivify_2369
    die "Contextual $*SCOPE not found"
  vivify_2369:
  vivify_2368:
    set $S5096, $P5095
    iseq $I5097, $S5096, "our"
    if $I5097, if_5092
.annotate 'line', 1810
    find_lex $P5111, "$BLOCK"
    unless_null $P5111, vivify_2370
    $P5111 = root_new ['parrot';'ResizablePMCArray']
  vivify_2370:
    set $P5112, $P5111[0]
    unless_null $P5112, vivify_2371
    new $P5112, "Undef"
  vivify_2371:
    get_hll_global $P5113, "GLOBAL"
    nqp_get_package_through_who $P5114, $P5113, "PAST"
    get_who $P5115, $P5114
    set $P5116, $P5115["Var"]
    find_lex $P5117, "$name"
    unless_null $P5117, vivify_2372
    new $P5117, "Undef"
  vivify_2372:
.annotate 'line', 1812
    find_lex $P5118, "$sigil"
    unless_null $P5118, vivify_2373
    new $P5118, "Undef"
  vivify_2373:
    $P5119 = "vivitype"($P5118)
    find_lex $P5120, "$/"
    unless_null $P5120, vivify_2374
    new $P5120, "Undef"
  vivify_2374:
    $P5121 = $P5116."new"($P5117 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5119 :named("viviself"), $P5120 :named("node"))
.annotate 'line', 1810
    $P5112."push"($P5121)
.annotate 'line', 1815
    find_lex $P5122, "$BLOCK"
    unless_null $P5122, vivify_2375
    new $P5122, "Undef"
  vivify_2375:
    find_lex $P5123, "$name"
    unless_null $P5123, vivify_2376
    new $P5123, "Undef"
  vivify_2376:
    $P5122."symbol"($P5123, "lexical" :named("scope"))
.annotate 'line', 1809
    goto if_5092_end
  if_5092:
.annotate 'line', 1804
    find_lex $P5098, "$/"
    unless_null $P5098, vivify_2377
    $P5098 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P5099, $P5098["variable"]
    unless_null $P5099, vivify_2378
    new $P5099, "Undef"
  vivify_2378:
    set $S5100, $P5099
    new $P5101, 'String'
    set $P5101, $S5100
    store_lex "$name", $P5101
.annotate 'line', 1805
    find_lex $P5102, "$name"
    unless_null $P5102, vivify_2379
    new $P5102, "Undef"
  vivify_2379:
    new $P5103, "ResizablePMCArray"
    push $P5103, $P5102
    find_lex $P5104, "$/"
    unless_null $P5104, vivify_2380
    new $P5104, "Undef"
  vivify_2380:
    $P5105 = "lexical_package_lookup"($P5103, $P5104)
    store_lex "$past", $P5105
.annotate 'line', 1806
    find_lex $P5106, "$past"
    unless_null $P5106, vivify_2381
    new $P5106, "Undef"
  vivify_2381:
    find_lex $P5107, "$sigil"
    unless_null $P5107, vivify_2382
    new $P5107, "Undef"
  vivify_2382:
    $P5108 = "vivitype"($P5107)
    $P5106."viviself"($P5108)
.annotate 'line', 1807
    find_lex $P5109, "$BLOCK"
    unless_null $P5109, vivify_2383
    new $P5109, "Undef"
  vivify_2383:
    find_lex $P5110, "$name"
    unless_null $P5110, vivify_2384
    new $P5110, "Undef"
  vivify_2384:
    $P5109."symbol"($P5110, "package" :named("scope"))
  if_5092_end:
.annotate 'line', 1800
    goto if_5031_end
  if_5031:
.annotate 'line', 1780
    .const 'Sub' $P5038 = "530_1304523757.895" 
    capture_lex $P5038
    $P5038()
  if_5031_end:
.annotate 'line', 1817
    find_lex $P5124, "$/"
    find_lex $P5125, "$past"
    unless_null $P5125, vivify_2414
    new $P5125, "Undef"
  vivify_2414:
    $P5126 = $P5124."!make"($P5125)
.annotate 'line', 1772
    .return ($P5126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5037"  :anon :subid("530_1304523757.895") :outer("529_1304523757.895")
.annotate 'line', 1787
    $P5039 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P5039
.annotate 'line', 1788
    $P5040 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P5040
.annotate 'line', 1782
    find_dynamic_lex $P5047, "$*PKGDECL"
    unless_null $P5047, vivify_2385
    get_hll_global $P5045, "GLOBAL"
    get_who $P5046, $P5045
    set $P5047, $P5046["$PKGDECL"]
    unless_null $P5047, vivify_2386
    die "Contextual $*PKGDECL not found"
  vivify_2386:
  vivify_2385:
    concat $P5048, $P5047, "-attr"
    find_dynamic_lex $P5044, "%*HOW"
    unless_null $P5044, vivify_2387
    get_hll_global $P5042, "GLOBAL"
    get_who $P5043, $P5042
    set $P5044, $P5043["%HOW"]
    unless_null $P5044, vivify_2388
    die "Contextual %*HOW not found"
  vivify_2388:
  vivify_2387:
    exists $I5049, $P5044[$P5048]
    if $I5049, unless_5041_end
.annotate 'line', 1783
    find_lex $P5050, "$/"
    unless_null $P5050, vivify_2389
    new $P5050, "Undef"
  vivify_2389:
    $P5051 = $P5050."CURSOR"()
    find_dynamic_lex $P5054, "$*PKGDECL"
    unless_null $P5054, vivify_2390
    get_hll_global $P5052, "GLOBAL"
    get_who $P5053, $P5052
    set $P5054, $P5053["$PKGDECL"]
    unless_null $P5054, vivify_2391
    die "Contextual $*PKGDECL not found"
  vivify_2391:
  vivify_2390:
    concat $P5055, $P5054, " packages do not support attributes"
    $P5051."panic"($P5055)
  unless_5041_end:
.annotate 'line', 1782
    find_lex $P5056, "%lit_args"
    unless_null $P5056, vivify_2392
    $P5056 = root_new ['parrot';'Hash']
  vivify_2392:
    find_lex $P5057, "%obj_args"
    unless_null $P5057, vivify_2393
    $P5057 = root_new ['parrot';'Hash']
  vivify_2393:
.annotate 'line', 1789
    find_lex $P5058, "$name"
    unless_null $P5058, vivify_2394
    new $P5058, "Undef"
  vivify_2394:
    find_lex $P5059, "%lit_args"
    unless_null $P5059, vivify_2395
    $P5059 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P5059
  vivify_2395:
    set $P5059["name"], $P5058
.annotate 'line', 1790
    find_lex $P5061, "$/"
    unless_null $P5061, vivify_2396
    $P5061 = root_new ['parrot';'Hash']
  vivify_2396:
    set $P5062, $P5061["typename"]
    unless_null $P5062, vivify_2397
    new $P5062, "Undef"
  vivify_2397:
    unless $P5062, if_5060_end
.annotate 'line', 1791
    find_lex $P5063, "$/"
    unless_null $P5063, vivify_2398
    $P5063 = root_new ['parrot';'Hash']
  vivify_2398:
    set $P5064, $P5063["typename"]
    unless_null $P5064, vivify_2399
    $P5064 = root_new ['parrot';'ResizablePMCArray']
  vivify_2399:
    set $P5065, $P5064[0]
    unless_null $P5065, vivify_2400
    new $P5065, "Undef"
  vivify_2400:
    set $S5066, $P5065
    new $P5067, "ResizablePMCArray"
    push $P5067, $S5066
    find_lex $P5068, "$/"
    unless_null $P5068, vivify_2401
    new $P5068, "Undef"
  vivify_2401:
    $P5069 = "find_sym"($P5067, $P5068)
    find_lex $P5070, "%obj_args"
    unless_null $P5070, vivify_2402
    $P5070 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P5070
  vivify_2402:
    set $P5070["type"], $P5069
  if_5060_end:
.annotate 'line', 1795
    find_dynamic_lex $P5073, "$*SC"
    unless_null $P5073, vivify_2403
    get_hll_global $P5071, "GLOBAL"
    get_who $P5072, $P5071
    set $P5073, $P5072["$SC"]
    unless_null $P5073, vivify_2404
    die "Contextual $*SC not found"
  vivify_2404:
  vivify_2403:
    find_dynamic_lex $P5076, "$*PACKAGE"
    unless_null $P5076, vivify_2405
    get_hll_global $P5074, "GLOBAL"
    get_who $P5075, $P5074
    set $P5076, $P5075["$PACKAGE"]
    unless_null $P5076, vivify_2406
    die "Contextual $*PACKAGE not found"
  vivify_2406:
  vivify_2405:
    find_dynamic_lex $P5079, "$*PKGDECL"
    unless_null $P5079, vivify_2407
    get_hll_global $P5077, "GLOBAL"
    get_who $P5078, $P5077
    set $P5079, $P5078["$PKGDECL"]
    unless_null $P5079, vivify_2408
    die "Contextual $*PKGDECL not found"
  vivify_2408:
  vivify_2407:
    concat $P5080, $P5079, "-attr"
    find_dynamic_lex $P5083, "%*HOW"
    unless_null $P5083, vivify_2409
    get_hll_global $P5081, "GLOBAL"
    get_who $P5082, $P5081
    set $P5083, $P5082["%HOW"]
    unless_null $P5083, vivify_2410
    die "Contextual %*HOW not found"
  vivify_2410:
  vivify_2409:
    set $P5084, $P5083[$P5080]
    unless_null $P5084, vivify_2411
    new $P5084, "Undef"
  vivify_2411:
    find_lex $P5085, "%lit_args"
    unless_null $P5085, vivify_2412
    $P5085 = root_new ['parrot';'Hash']
  vivify_2412:
    find_lex $P5086, "%obj_args"
    unless_null $P5086, vivify_2413
    $P5086 = root_new ['parrot';'Hash']
  vivify_2413:
    $P5073."pkg_add_attribute"($P5076, $P5084, $P5085, $P5086)
.annotate 'line', 1798
    get_hll_global $P5087, "GLOBAL"
    nqp_get_package_through_who $P5088, $P5087, "PAST"
    get_who $P5089, $P5088
    set $P5090, $P5089["Stmts"]
    $P5091 = $P5090."new"()
    store_lex "$past", $P5091
.annotate 'line', 1780
    .return ($P5091)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("531_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5128
    .param pmc param_5129
.annotate 'line', 1820
    .lex "self", param_5128
    .lex "$/", param_5129
    find_lex $P5130, "$/"
    find_lex $P5131, "$/"
    unless_null $P5131, vivify_2415
    $P5131 = root_new ['parrot';'Hash']
  vivify_2415:
    set $P5132, $P5131["routine_def"]
    unless_null $P5132, vivify_2416
    new $P5132, "Undef"
  vivify_2416:
    $P5133 = $P5132."ast"()
    $P5134 = $P5130."!make"($P5133)
    .return ($P5134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("532_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5136
    .param pmc param_5137
.annotate 'line', 1821
    .lex "self", param_5136
    .lex "$/", param_5137
    find_lex $P5138, "$/"
    find_lex $P5139, "$/"
    unless_null $P5139, vivify_2417
    $P5139 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5140, $P5139["method_def"]
    unless_null $P5140, vivify_2418
    new $P5140, "Undef"
  vivify_2418:
    $P5141 = $P5140."ast"()
    $P5142 = $P5138."!make"($P5141)
    .return ($P5142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("533_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5144
    .param pmc param_5145
.annotate 'line', 1823
    .const 'Sub' $P5458 = "539_1304523757.895" 
    capture_lex $P5458
    .const 'Sub' $P5167 = "534_1304523757.895" 
    capture_lex $P5167
    .lex "self", param_5144
    .lex "$/", param_5145
.annotate 'line', 1826
    new $P5146, "Undef"
    .lex "$past", $P5146
.annotate 'line', 1837
    new $P5147, "Undef"
    .lex "$block", $P5147
.annotate 'line', 1823
    find_lex $P5148, "$past"
    unless_null $P5148, vivify_2419
    new $P5148, "Undef"
  vivify_2419:
.annotate 'line', 1827
    find_lex $P5150, "$/"
    unless_null $P5150, vivify_2420
    $P5150 = root_new ['parrot';'Hash']
  vivify_2420:
    set $P5151, $P5150["onlystar"]
    unless_null $P5151, vivify_2421
    new $P5151, "Undef"
  vivify_2421:
    if $P5151, if_5149
.annotate 'line', 1831
    find_lex $P5153, "$/"
    unless_null $P5153, vivify_2422
    $P5153 = root_new ['parrot';'Hash']
  vivify_2422:
    set $P5154, $P5153["blockoid"]
    unless_null $P5154, vivify_2423
    new $P5154, "Undef"
  vivify_2423:
    $P5155 = $P5154."ast"()
    store_lex "$past", $P5155
.annotate 'line', 1832
    find_lex $P5156, "$past"
    unless_null $P5156, vivify_2424
    new $P5156, "Undef"
  vivify_2424:
    $P5156."blocktype"("declaration")
.annotate 'line', 1833
    find_dynamic_lex $P5160, "$*RETURN_USED"
    unless_null $P5160, vivify_2425
    get_hll_global $P5158, "GLOBAL"
    get_who $P5159, $P5158
    set $P5160, $P5159["$RETURN_USED"]
    unless_null $P5160, vivify_2426
    die "Contextual $*RETURN_USED not found"
  vivify_2426:
  vivify_2425:
    unless $P5160, if_5157_end
.annotate 'line', 1834
    find_lex $P5161, "$past"
    unless_null $P5161, vivify_2427
    new $P5161, "Undef"
  vivify_2427:
    $P5161."control"("return_pir")
  if_5157_end:
.annotate 'line', 1830
    goto if_5149_end
  if_5149:
.annotate 'line', 1828
    $P5152 = "only_star_block"()
    store_lex "$past", $P5152
  if_5149_end:
.annotate 'line', 1837
    find_lex $P5162, "$past"
    unless_null $P5162, vivify_2428
    new $P5162, "Undef"
  vivify_2428:
    store_lex "$block", $P5162
.annotate 'line', 1839
    find_lex $P5164, "$/"
    unless_null $P5164, vivify_2429
    $P5164 = root_new ['parrot';'Hash']
  vivify_2429:
    set $P5165, $P5164["deflongname"]
    unless_null $P5165, vivify_2430
    new $P5165, "Undef"
  vivify_2430:
    unless $P5165, if_5163_end
    .const 'Sub' $P5167 = "534_1304523757.895" 
    capture_lex $P5167
    $P5167()
  if_5163_end:
.annotate 'line', 1940
    find_lex $P5447, "$block"
    unless_null $P5447, vivify_2536
    new $P5447, "Undef"
  vivify_2536:
    find_lex $P5448, "$past"
    unless_null $P5448, vivify_2537
    $P5448 = root_new ['parrot';'Hash']
    store_lex "$past", $P5448
  vivify_2537:
    set $P5448["block_past"], $P5447
.annotate 'line', 1941
    find_lex $P5450, "$/"
    unless_null $P5450, vivify_2538
    $P5450 = root_new ['parrot';'Hash']
  vivify_2538:
    set $P5451, $P5450["trait"]
    unless_null $P5451, vivify_2539
    new $P5451, "Undef"
  vivify_2539:
    unless $P5451, if_5449_end
.annotate 'line', 1942
    find_lex $P5453, "$/"
    unless_null $P5453, vivify_2540
    $P5453 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P5454, $P5453["trait"]
    unless_null $P5454, vivify_2541
    new $P5454, "Undef"
  vivify_2541:
    defined $I5455, $P5454
    unless $I5455, for_undef_2542
    iter $P5452, $P5454
    new $P5465, 'ExceptionHandler'
    set_label $P5465, loop5464_handler
    $P5465."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5465
  loop5464_test:
    unless $P5452, loop5464_done
    shift $P5456, $P5452
  loop5464_redo:
    .const 'Sub' $P5458 = "539_1304523757.895" 
    capture_lex $P5458
    $P5458($P5456)
  loop5464_next:
    goto loop5464_test
  loop5464_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5466, exception, 'type'
    eq $P5466, .CONTROL_LOOP_NEXT, loop5464_next
    eq $P5466, .CONTROL_LOOP_REDO, loop5464_redo
  loop5464_done:
    pop_eh 
  for_undef_2542:
  if_5449_end:
.annotate 'line', 1945
    find_lex $P5467, "$/"
    find_lex $P5468, "$past"
    unless_null $P5468, vivify_2545
    new $P5468, "Undef"
  vivify_2545:
    $P5469 = $P5467."!make"($P5468)
.annotate 'line', 1823
    .return ($P5469)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5166"  :anon :subid("534_1304523757.895") :outer("533_1304523757.895")
.annotate 'line', 1839
    .const 'Sub' $P5321 = "538_1304523757.895" 
    capture_lex $P5321
    .const 'Sub' $P5208 = "535_1304523757.895" 
    capture_lex $P5208
.annotate 'line', 1840
    new $P5168, "Undef"
    .lex "$name", $P5168
    find_lex $P5169, "$/"
    unless_null $P5169, vivify_2431
    $P5169 = root_new ['parrot';'Hash']
  vivify_2431:
    set $P5170, $P5169["sigil"]
    unless_null $P5170, vivify_2432
    $P5170 = root_new ['parrot';'ResizablePMCArray']
  vivify_2432:
    set $P5171, $P5170[0]
    unless_null $P5171, vivify_2433
    new $P5171, "Undef"
  vivify_2433:
    set $S5172, $P5171
    new $P5173, 'String'
    set $P5173, $S5172
    find_lex $P5174, "$/"
    unless_null $P5174, vivify_2434
    $P5174 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P5175, $P5174["deflongname"]
    unless_null $P5175, vivify_2435
    $P5175 = root_new ['parrot';'ResizablePMCArray']
  vivify_2435:
    set $P5176, $P5175[0]
    unless_null $P5176, vivify_2436
    new $P5176, "Undef"
  vivify_2436:
    $S5177 = $P5176."ast"()
    concat $P5178, $P5173, $S5177
    store_lex "$name", $P5178
.annotate 'line', 1841
    find_lex $P5179, "$past"
    unless_null $P5179, vivify_2437
    new $P5179, "Undef"
  vivify_2437:
    find_lex $P5180, "$name"
    unless_null $P5180, vivify_2438
    new $P5180, "Undef"
  vivify_2438:
    $P5179."name"($P5180)
.annotate 'line', 1842
    find_dynamic_lex $P5188, "$*SCOPE"
    unless_null $P5188, vivify_2439
    get_hll_global $P5186, "GLOBAL"
    get_who $P5187, $P5186
    set $P5188, $P5187["$SCOPE"]
    unless_null $P5188, vivify_2440
    die "Contextual $*SCOPE not found"
  vivify_2440:
  vivify_2439:
    set $S5189, $P5188
    iseq $I5190, $S5189, ""
    unless $I5190, unless_5185
    new $P5184, 'Integer'
    set $P5184, $I5190
    goto unless_5185_end
  unless_5185:
    find_dynamic_lex $P5193, "$*SCOPE"
    unless_null $P5193, vivify_2441
    get_hll_global $P5191, "GLOBAL"
    get_who $P5192, $P5191
    set $P5193, $P5192["$SCOPE"]
    unless_null $P5193, vivify_2442
    die "Contextual $*SCOPE not found"
  vivify_2442:
  vivify_2441:
    set $S5194, $P5193
    iseq $I5195, $S5194, "my"
    new $P5184, 'Integer'
    set $P5184, $I5195
  unless_5185_end:
    unless $P5184, unless_5183
    set $P5182, $P5184
    goto unless_5183_end
  unless_5183:
    find_dynamic_lex $P5198, "$*SCOPE"
    unless_null $P5198, vivify_2443
    get_hll_global $P5196, "GLOBAL"
    get_who $P5197, $P5196
    set $P5198, $P5197["$SCOPE"]
    unless_null $P5198, vivify_2444
    die "Contextual $*SCOPE not found"
  vivify_2444:
  vivify_2443:
    set $S5199, $P5198
    iseq $I5200, $S5199, "our"
    new $P5182, 'Integer'
    set $P5182, $I5200
  unless_5183_end:
    if $P5182, if_5181
.annotate 'line', 1930
    find_lex $P5428, "$/"
    unless_null $P5428, vivify_2445
    new $P5428, "Undef"
  vivify_2445:
    $P5429 = $P5428."CURSOR"()
    find_dynamic_lex $P5432, "$*SCOPE"
    unless_null $P5432, vivify_2446
    get_hll_global $P5430, "GLOBAL"
    get_who $P5431, $P5430
    set $P5432, $P5431["$SCOPE"]
    unless_null $P5432, vivify_2447
    die "Contextual $*SCOPE not found"
  vivify_2447:
  vivify_2446:
    concat $P5433, $P5432, " scoped routines are not supported yet"
    $P5429."panic"($P5433)
.annotate 'line', 1929
    goto if_5181_end
  if_5181:
.annotate 'line', 1843
    find_dynamic_lex $P5204, "$*MULTINESS"
    unless_null $P5204, vivify_2448
    get_hll_global $P5202, "GLOBAL"
    get_who $P5203, $P5202
    set $P5204, $P5203["$MULTINESS"]
    unless_null $P5204, vivify_2449
    die "Contextual $*MULTINESS not found"
  vivify_2449:
  vivify_2448:
    set $S5205, $P5204
    iseq $I5206, $S5205, "multi"
    if $I5206, if_5201
.annotate 'line', 1894
    find_dynamic_lex $P5317, "$*MULTINESS"
    unless_null $P5317, vivify_2450
    get_hll_global $P5315, "GLOBAL"
    get_who $P5316, $P5315
    set $P5317, $P5316["$MULTINESS"]
    unless_null $P5317, vivify_2451
    die "Contextual $*MULTINESS not found"
  vivify_2451:
  vivify_2450:
    set $S5318, $P5317
    iseq $I5319, $S5318, "proto"
    if $I5319, if_5314
.annotate 'line', 1913
    find_lex $P5371, "$?PACKAGE"
    get_who $P5372, $P5371
    set $P5373, $P5372["@BLOCK"]
    unless_null $P5373, vivify_2452
    $P5373 = root_new ['parrot';'ResizablePMCArray']
  vivify_2452:
    set $P5374, $P5373[0]
    unless_null $P5374, vivify_2453
    $P5374 = root_new ['parrot';'ResizablePMCArray']
  vivify_2453:
    set $P5375, $P5374[0]
    unless_null $P5375, vivify_2454
    new $P5375, "Undef"
  vivify_2454:
    get_hll_global $P5376, "GLOBAL"
    nqp_get_package_through_who $P5377, $P5376, "PAST"
    get_who $P5378, $P5377
    set $P5379, $P5378["Var"]
    find_lex $P5380, "$name"
    unless_null $P5380, vivify_2455
    new $P5380, "Undef"
  vivify_2455:
    find_lex $P5381, "$past"
    unless_null $P5381, vivify_2456
    new $P5381, "Undef"
  vivify_2456:
    $P5382 = $P5379."new"($P5380 :named("name"), 1 :named("isdecl"), $P5381 :named("viviself"), "lexical" :named("scope"))
    $P5375."push"($P5382)
.annotate 'line', 1915
    find_lex $P5383, "$?PACKAGE"
    get_who $P5384, $P5383
    set $P5385, $P5384["@BLOCK"]
    unless_null $P5385, vivify_2457
    $P5385 = root_new ['parrot';'ResizablePMCArray']
  vivify_2457:
    set $P5386, $P5385[0]
    unless_null $P5386, vivify_2458
    new $P5386, "Undef"
  vivify_2458:
    find_lex $P5387, "$name"
    unless_null $P5387, vivify_2459
    new $P5387, "Undef"
  vivify_2459:
    $P5386."symbol"($P5387, "lexical" :named("scope"))
.annotate 'line', 1916
    find_dynamic_lex $P5391, "$*SCOPE"
    unless_null $P5391, vivify_2460
    get_hll_global $P5389, "GLOBAL"
    get_who $P5390, $P5389
    set $P5391, $P5390["$SCOPE"]
    unless_null $P5391, vivify_2461
    die "Contextual $*SCOPE not found"
  vivify_2461:
  vivify_2460:
    set $S5392, $P5391
    iseq $I5393, $S5392, "our"
    unless $I5393, if_5388_end
.annotate 'line', 1919
    find_dynamic_lex $P5396, "$*SC"
    unless_null $P5396, vivify_2462
    get_hll_global $P5394, "GLOBAL"
    get_who $P5395, $P5394
    set $P5396, $P5395["$SC"]
    unless_null $P5396, vivify_2463
    die "Contextual $*SC not found"
  vivify_2463:
  vivify_2462:
    find_dynamic_lex $P5399, "$*PACKAGE"
    unless_null $P5399, vivify_2464
    get_hll_global $P5397, "GLOBAL"
    get_who $P5398, $P5397
    set $P5399, $P5398["$PACKAGE"]
    unless_null $P5399, vivify_2465
    die "Contextual $*PACKAGE not found"
  vivify_2465:
  vivify_2464:
    find_lex $P5400, "$name"
    unless_null $P5400, vivify_2466
    new $P5400, "Undef"
  vivify_2466:
    find_lex $P5401, "$past"
    unless_null $P5401, vivify_2467
    new $P5401, "Undef"
  vivify_2467:
    $P5396."install_package_routine"($P5399, $P5400, $P5401)
.annotate 'line', 1920
    find_lex $P5402, "$?PACKAGE"
    get_who $P5403, $P5402
    set $P5404, $P5403["@BLOCK"]
    unless_null $P5404, vivify_2468
    $P5404 = root_new ['parrot';'ResizablePMCArray']
  vivify_2468:
    set $P5405, $P5404[0]
    unless_null $P5405, vivify_2469
    $P5405 = root_new ['parrot';'ResizablePMCArray']
  vivify_2469:
    set $P5406, $P5405[0]
    unless_null $P5406, vivify_2470
    new $P5406, "Undef"
  vivify_2470:
    get_hll_global $P5407, "GLOBAL"
    nqp_get_package_through_who $P5408, $P5407, "PAST"
    get_who $P5409, $P5408
    set $P5410, $P5409["Op"]
.annotate 'line', 1922
    find_lex $P5411, "$name"
    unless_null $P5411, vivify_2471
    new $P5411, "Undef"
  vivify_2471:
    new $P5412, "ResizablePMCArray"
    push $P5412, $P5411
    find_lex $P5413, "$/"
    unless_null $P5413, vivify_2472
    new $P5413, "Undef"
  vivify_2472:
    $P5414 = "lexical_package_lookup"($P5412, $P5413)
.annotate 'line', 1923
    get_hll_global $P5415, "GLOBAL"
    nqp_get_package_through_who $P5416, $P5415, "PAST"
    get_who $P5417, $P5416
    set $P5418, $P5417["Var"]
    find_lex $P5419, "$name"
    unless_null $P5419, vivify_2473
    new $P5419, "Undef"
  vivify_2473:
    $P5420 = $P5418."new"($P5419 :named("name"), "lexical" :named("scope"))
    $P5421 = $P5410."new"($P5414, $P5420, "bind" :named("pasttype"))
.annotate 'line', 1920
    $P5406."push"($P5421)
  if_5388_end:
.annotate 'line', 1912
    goto if_5314_end
  if_5314:
.annotate 'line', 1894
    .const 'Sub' $P5321 = "538_1304523757.895" 
    capture_lex $P5321
    $P5321()
  if_5314_end:
    goto if_5201_end
  if_5201:
.annotate 'line', 1843
    .const 'Sub' $P5208 = "535_1304523757.895" 
    capture_lex $P5208
    $P5208()
  if_5201_end:
.annotate 'line', 1927
    get_hll_global $P5422, "GLOBAL"
    nqp_get_package_through_who $P5423, $P5422, "PAST"
    get_who $P5424, $P5423
    set $P5425, $P5424["Var"]
    find_lex $P5426, "$name"
    unless_null $P5426, vivify_2531
    new $P5426, "Undef"
  vivify_2531:
    $P5427 = $P5425."new"($P5426 :named("name"))
    store_lex "$past", $P5427
  if_5181_end:
.annotate 'line', 1934
    find_lex $P5438, "$name"
    unless_null $P5438, vivify_2532
    new $P5438, "Undef"
  vivify_2532:
    set $S5439, $P5438
    iseq $I5440, $S5439, "MAIN"
    if $I5440, if_5437
    new $P5436, 'Integer'
    set $P5436, $I5440
    goto if_5437_end
  if_5437:
    find_dynamic_lex $P5443, "$*MULTINESS"
    unless_null $P5443, vivify_2533
    get_hll_global $P5441, "GLOBAL"
    get_who $P5442, $P5441
    set $P5443, $P5442["$MULTINESS"]
    unless_null $P5443, vivify_2534
    die "Contextual $*MULTINESS not found"
  vivify_2534:
  vivify_2533:
    set $S5444, $P5443
    isne $I5445, $S5444, "multi"
    new $P5436, 'Integer'
    set $P5436, $I5445
  if_5437_end:
    if $P5436, if_5435
    set $P5434, $P5436
    goto if_5435_end
  if_5435:
.annotate 'line', 1935
    find_lex $P5446, "$block"
    unless_null $P5446, vivify_2535
    new $P5446, "Undef"
  vivify_2535:
    store_dynamic_lex "$*MAIN_SUB", $P5446
.annotate 'line', 1934
    set $P5434, $P5446
  if_5435_end:
.annotate 'line', 1839
    .return ($P5434)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5320"  :anon :subid("538_1304523757.895") :outer("534_1304523757.895")
.annotate 'line', 1899
    new $P5322, "Undef"
    .lex "$cholder", $P5322
.annotate 'line', 1898
    find_dynamic_lex $P5326, "$*SCOPE"
    unless_null $P5326, vivify_2474
    get_hll_global $P5324, "GLOBAL"
    get_who $P5325, $P5324
    set $P5326, $P5325["$SCOPE"]
    unless_null $P5326, vivify_2475
    die "Contextual $*SCOPE not found"
  vivify_2475:
  vivify_2474:
    set $S5327, $P5326
    iseq $I5328, $S5327, "our"
    unless $I5328, if_5323_end
    die "our-scoped protos not yet implemented"
  if_5323_end:
.annotate 'line', 1899
    get_hll_global $P5329, "GLOBAL"
    nqp_get_package_through_who $P5330, $P5329, "PAST"
    get_who $P5331, $P5330
    set $P5332, $P5331["Op"]
    $P5333 = $P5332."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5333
.annotate 'line', 1900
    find_lex $P5334, "$?PACKAGE"
    get_who $P5335, $P5334
    set $P5336, $P5335["@BLOCK"]
    unless_null $P5336, vivify_2476
    $P5336 = root_new ['parrot';'ResizablePMCArray']
  vivify_2476:
    set $P5337, $P5336[0]
    unless_null $P5337, vivify_2477
    $P5337 = root_new ['parrot';'ResizablePMCArray']
  vivify_2477:
    set $P5338, $P5337[0]
    unless_null $P5338, vivify_2478
    new $P5338, "Undef"
  vivify_2478:
    get_hll_global $P5339, "GLOBAL"
    nqp_get_package_through_who $P5340, $P5339, "PAST"
    get_who $P5341, $P5340
    set $P5342, $P5341["Var"]
    find_lex $P5343, "$name"
    unless_null $P5343, vivify_2479
    new $P5343, "Undef"
  vivify_2479:
    find_lex $P5344, "$past"
    unless_null $P5344, vivify_2480
    new $P5344, "Undef"
  vivify_2480:
    $P5345 = $P5342."new"($P5343 :named("name"), 1 :named("isdecl"), $P5344 :named("viviself"), "lexical" :named("scope"))
    $P5338."push"($P5345)
.annotate 'line', 1902
    find_lex $P5346, "$?PACKAGE"
    get_who $P5347, $P5346
    set $P5348, $P5347["@BLOCK"]
    unless_null $P5348, vivify_2481
    $P5348 = root_new ['parrot';'ResizablePMCArray']
  vivify_2481:
    set $P5349, $P5348[0]
    unless_null $P5349, vivify_2482
    $P5349 = root_new ['parrot';'ResizablePMCArray']
  vivify_2482:
    set $P5350, $P5349[0]
    unless_null $P5350, vivify_2483
    new $P5350, "Undef"
  vivify_2483:
    get_hll_global $P5351, "GLOBAL"
    nqp_get_package_through_who $P5352, $P5351, "PAST"
    get_who $P5353, $P5352
    set $P5354, $P5353["Op"]
.annotate 'line', 1904
    get_hll_global $P5355, "GLOBAL"
    nqp_get_package_through_who $P5356, $P5355, "PAST"
    get_who $P5357, $P5356
    set $P5358, $P5357["Var"]
    find_lex $P5359, "$name"
    unless_null $P5359, vivify_2484
    new $P5359, "Undef"
  vivify_2484:
    $P5360 = $P5358."new"($P5359 :named("name"))
    find_lex $P5361, "$cholder"
    unless_null $P5361, vivify_2485
    new $P5361, "Undef"
  vivify_2485:
    $P5362 = $P5354."new"($P5360, $P5361, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1902
    $P5350."push"($P5362)
.annotate 'line', 1907
    find_lex $P5363, "$?PACKAGE"
    get_who $P5364, $P5363
    set $P5365, $P5364["@BLOCK"]
    unless_null $P5365, vivify_2486
    $P5365 = root_new ['parrot';'ResizablePMCArray']
  vivify_2486:
    set $P5366, $P5365[0]
    unless_null $P5366, vivify_2487
    new $P5366, "Undef"
  vivify_2487:
    find_lex $P5367, "$name"
    unless_null $P5367, vivify_2488
    new $P5367, "Undef"
  vivify_2488:
    find_lex $P5368, "$cholder"
    unless_null $P5368, vivify_2489
    new $P5368, "Undef"
  vivify_2489:
    $P5366."symbol"($P5367, "lexical" :named("scope"), 1 :named("proto"), $P5368 :named("cholder"))
.annotate 'line', 1910
    find_lex $P5369, "$past"
    unless_null $P5369, vivify_2490
    new $P5369, "Undef"
  vivify_2490:
    $P5370 = $P5369."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1894
    .return ($P5370)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5207"  :anon :subid("535_1304523757.895") :outer("534_1304523757.895")
.annotate 'line', 1843
    .const 'Sub' $P5230 = "536_1304523757.895" 
    capture_lex $P5230
.annotate 'line', 1846
    new $P5209, "Undef"
    .lex "$cholder", $P5209
.annotate 'line', 1847
    $P5210 = root_new ['parrot';'Hash']
    .lex "%sym", $P5210
.annotate 'line', 1845
    find_dynamic_lex $P5214, "$*SCOPE"
    unless_null $P5214, vivify_2491
    get_hll_global $P5212, "GLOBAL"
    get_who $P5213, $P5212
    set $P5214, $P5213["$SCOPE"]
    unless_null $P5214, vivify_2492
    die "Contextual $*SCOPE not found"
  vivify_2492:
  vivify_2491:
    set $S5215, $P5214
    iseq $I5216, $S5215, "our"
    unless $I5216, if_5211_end
    die "our-scoped multis not yet implemented"
  if_5211_end:
    find_lex $P5217, "$cholder"
    unless_null $P5217, vivify_2493
    new $P5217, "Undef"
  vivify_2493:
.annotate 'line', 1847
    find_lex $P5218, "$?PACKAGE"
    get_who $P5219, $P5218
    set $P5220, $P5219["@BLOCK"]
    unless_null $P5220, vivify_2494
    $P5220 = root_new ['parrot';'ResizablePMCArray']
  vivify_2494:
    set $P5221, $P5220[0]
    unless_null $P5221, vivify_2495
    new $P5221, "Undef"
  vivify_2495:
    find_lex $P5222, "$name"
    unless_null $P5222, vivify_2496
    new $P5222, "Undef"
  vivify_2496:
    $P5223 = $P5221."symbol"($P5222)
    store_lex "%sym", $P5223
.annotate 'line', 1848
    find_lex $P5225, "%sym"
    unless_null $P5225, vivify_2497
    $P5225 = root_new ['parrot';'Hash']
  vivify_2497:
    set $P5226, $P5225["cholder"]
    unless_null $P5226, vivify_2498
    new $P5226, "Undef"
  vivify_2498:
    if $P5226, if_5224
.annotate 'line', 1853
    .const 'Sub' $P5230 = "536_1304523757.895" 
    capture_lex $P5230
    $P5230()
    goto if_5224_end
  if_5224:
.annotate 'line', 1849
    find_lex $P5227, "%sym"
    unless_null $P5227, vivify_2526
    $P5227 = root_new ['parrot';'Hash']
  vivify_2526:
    set $P5228, $P5227["cholder"]
    unless_null $P5228, vivify_2527
    new $P5228, "Undef"
  vivify_2527:
    store_lex "$cholder", $P5228
  if_5224_end:
.annotate 'line', 1889
    find_lex $P5310, "$cholder"
    unless_null $P5310, vivify_2528
    new $P5310, "Undef"
  vivify_2528:
    find_lex $P5311, "$past"
    unless_null $P5311, vivify_2529
    new $P5311, "Undef"
  vivify_2529:
    $P5310."push"($P5311)
.annotate 'line', 1892
    find_lex $P5312, "$past"
    unless_null $P5312, vivify_2530
    new $P5312, "Undef"
  vivify_2530:
    $P5313 = "attach_multi_signature"($P5312)
.annotate 'line', 1843
    .return ($P5313)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5229"  :anon :subid("536_1304523757.895") :outer("535_1304523757.895")
.annotate 'line', 1853
    .const 'Sub' $P5246 = "537_1304523757.895" 
    capture_lex $P5246
.annotate 'line', 1860
    new $P5231, "Undef"
    .lex "$found_proto", $P5231
.annotate 'line', 1878
    new $P5232, "Undef"
    .lex "$dispatch_setup", $P5232
.annotate 'line', 1855
    find_lex $P5234, "%sym"
    unless_null $P5234, vivify_2499
    $P5234 = root_new ['parrot';'Hash']
  vivify_2499:
    set $P5235, $P5234["proto"]
    unless_null $P5235, vivify_2500
    new $P5235, "Undef"
  vivify_2500:
    unless $P5235, if_5233_end
.annotate 'line', 1858
    find_lex $P5236, "$/"
    unless_null $P5236, vivify_2501
    new $P5236, "Undef"
  vivify_2501:
    $P5237 = $P5236."CURSOR"()
    $P5237."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5233_end:
.annotate 'line', 1855
    find_lex $P5238, "$found_proto"
    unless_null $P5238, vivify_2502
    new $P5238, "Undef"
  vivify_2502:
.annotate 'line', 1861
    find_lex $P5240, "$?PACKAGE"
    get_who $P5241, $P5240
    set $P5242, $P5241["@BLOCK"]
    unless_null $P5242, vivify_2503
    $P5242 = root_new ['parrot';'ResizablePMCArray']
  vivify_2503:
    defined $I5243, $P5242
    unless $I5243, for_undef_2504
    iter $P5239, $P5242
    new $P5268, 'ExceptionHandler'
    set_label $P5268, loop5267_handler
    $P5268."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5268
  loop5267_test:
    unless $P5239, loop5267_done
    shift $P5244, $P5239
  loop5267_redo:
    .const 'Sub' $P5246 = "537_1304523757.895" 
    capture_lex $P5246
    $P5246($P5244)
  loop5267_next:
    goto loop5267_test
  loop5267_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5269, exception, 'type'
    eq $P5269, .CONTROL_LOOP_NEXT, loop5267_next
    eq $P5269, .CONTROL_LOOP_REDO, loop5267_redo
  loop5267_done:
    pop_eh 
  for_undef_2504:
.annotate 'line', 1872
    find_lex $P5271, "$found_proto"
    unless_null $P5271, vivify_2513
    new $P5271, "Undef"
  vivify_2513:
    if $P5271, unless_5270_end
.annotate 'line', 1873
    find_lex $P5272, "$/"
    unless_null $P5272, vivify_2514
    new $P5272, "Undef"
  vivify_2514:
    $P5273 = $P5272."CURSOR"()
    $P5273."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5270_end:
.annotate 'line', 1877
    get_hll_global $P5274, "GLOBAL"
    nqp_get_package_through_who $P5275, $P5274, "PAST"
    get_who $P5276, $P5275
    set $P5277, $P5276["Op"]
    $P5278 = $P5277."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5278
.annotate 'line', 1878
    get_hll_global $P5279, "GLOBAL"
    nqp_get_package_through_who $P5280, $P5279, "PAST"
    get_who $P5281, $P5280
    set $P5282, $P5281["Op"]
.annotate 'line', 1880
    get_hll_global $P5283, "GLOBAL"
    nqp_get_package_through_who $P5284, $P5283, "PAST"
    get_who $P5285, $P5284
    set $P5286, $P5285["Var"]
    find_lex $P5287, "$name"
    unless_null $P5287, vivify_2515
    new $P5287, "Undef"
  vivify_2515:
    $P5288 = $P5286."new"($P5287 :named("name"), "outer" :named("scope"))
    find_lex $P5289, "$cholder"
    unless_null $P5289, vivify_2516
    new $P5289, "Undef"
  vivify_2516:
    $P5290 = $P5282."new"($P5288, $P5289, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1878
    store_lex "$dispatch_setup", $P5290
.annotate 'line', 1883
    find_lex $P5291, "$?PACKAGE"
    get_who $P5292, $P5291
    set $P5293, $P5292["@BLOCK"]
    unless_null $P5293, vivify_2517
    $P5293 = root_new ['parrot';'ResizablePMCArray']
  vivify_2517:
    set $P5294, $P5293[0]
    unless_null $P5294, vivify_2518
    $P5294 = root_new ['parrot';'ResizablePMCArray']
  vivify_2518:
    set $P5295, $P5294[0]
    unless_null $P5295, vivify_2519
    new $P5295, "Undef"
  vivify_2519:
    get_hll_global $P5296, "GLOBAL"
    nqp_get_package_through_who $P5297, $P5296, "PAST"
    get_who $P5298, $P5297
    set $P5299, $P5298["Var"]
    find_lex $P5300, "$name"
    unless_null $P5300, vivify_2520
    new $P5300, "Undef"
  vivify_2520:
    find_lex $P5301, "$dispatch_setup"
    unless_null $P5301, vivify_2521
    new $P5301, "Undef"
  vivify_2521:
    $P5302 = $P5299."new"($P5300 :named("name"), 1 :named("isdecl"), $P5301 :named("viviself"), "lexical" :named("scope"))
    $P5295."push"($P5302)
.annotate 'line', 1885
    find_lex $P5303, "$?PACKAGE"
    get_who $P5304, $P5303
    set $P5305, $P5304["@BLOCK"]
    unless_null $P5305, vivify_2522
    $P5305 = root_new ['parrot';'ResizablePMCArray']
  vivify_2522:
    set $P5306, $P5305[0]
    unless_null $P5306, vivify_2523
    new $P5306, "Undef"
  vivify_2523:
    find_lex $P5307, "$name"
    unless_null $P5307, vivify_2524
    new $P5307, "Undef"
  vivify_2524:
    find_lex $P5308, "$cholder"
    unless_null $P5308, vivify_2525
    new $P5308, "Undef"
  vivify_2525:
    $P5309 = $P5306."symbol"($P5307, "lexical" :named("scope"), $P5308 :named("cholder"))
.annotate 'line', 1853
    .return ($P5309)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5245"  :anon :subid("537_1304523757.895") :outer("536_1304523757.895")
    .param pmc param_5248
.annotate 'line', 1862
    $P5247 = root_new ['parrot';'Hash']
    .lex "%sym", $P5247
    .lex "$_", param_5248
    find_lex $P5249, "$_"
    unless_null $P5249, vivify_2505
    new $P5249, "Undef"
  vivify_2505:
    find_lex $P5250, "$name"
    unless_null $P5250, vivify_2506
    new $P5250, "Undef"
  vivify_2506:
    $P5251 = $P5249."symbol"($P5250)
    store_lex "%sym", $P5251
.annotate 'line', 1863
    find_lex $P5256, "%sym"
    unless_null $P5256, vivify_2507
    $P5256 = root_new ['parrot';'Hash']
  vivify_2507:
    set $P5257, $P5256["proto"]
    unless_null $P5257, vivify_2508
    new $P5257, "Undef"
  vivify_2508:
    unless $P5257, unless_5255
    set $P5254, $P5257
    goto unless_5255_end
  unless_5255:
    find_lex $P5258, "%sym"
    unless_null $P5258, vivify_2509
    $P5258 = root_new ['parrot';'Hash']
  vivify_2509:
    set $P5259, $P5258["cholder"]
    unless_null $P5259, vivify_2510
    new $P5259, "Undef"
  vivify_2510:
    set $P5254, $P5259
  unless_5255_end:
    if $P5254, if_5253
.annotate 'line', 1866
    find_lex $P5263, "%sym"
    unless_null $P5263, vivify_2511
    $P5263 = root_new ['parrot';'Hash']
  vivify_2511:
    if $P5263, if_5262
    set $P5261, $P5263
    goto if_5262_end
  if_5262:
.annotate 'line', 1867
    find_lex $P5264, "$/"
    unless_null $P5264, vivify_2512
    new $P5264, "Undef"
  vivify_2512:
    $P5265 = $P5264."CURSOR"()
    $P5266 = $P5265."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1866
    set $P5261, $P5266
  if_5262_end:
    set $P5252, $P5261
.annotate 'line', 1863
    goto if_5253_end
  if_5253:
.annotate 'line', 1864
    new $P5260, "Integer"
    assign $P5260, 1
    store_lex "$found_proto", $P5260
.annotate 'line', 1863
    set $P5252, $P5260
  if_5253_end:
.annotate 'line', 1861
    .return ($P5252)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5457"  :anon :subid("539_1304523757.895") :outer("533_1304523757.895")
    .param pmc param_5459
.annotate 'line', 1942
    .lex "$_", param_5459
    find_lex $P5460, "$_"
    unless_null $P5460, vivify_2543
    new $P5460, "Undef"
  vivify_2543:
    $P5461 = $P5460."ast"()
    find_lex $P5462, "$/"
    unless_null $P5462, vivify_2544
    new $P5462, "Undef"
  vivify_2544:
    $P5463 = $P5461($P5462)
    .return ($P5463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("540_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5471
    .param pmc param_5472
.annotate 'line', 1949
    .const 'Sub' $P5588 = "542_1304523757.895" 
    capture_lex $P5588
    .const 'Sub' $P5510 = "541_1304523757.895" 
    capture_lex $P5510
    .lex "self", param_5471
    .lex "$/", param_5472
.annotate 'line', 1952
    new $P5473, "Undef"
    .lex "$past", $P5473
.annotate 'line', 1949
    find_lex $P5474, "$past"
    unless_null $P5474, vivify_2546
    new $P5474, "Undef"
  vivify_2546:
.annotate 'line', 1953
    find_lex $P5476, "$/"
    unless_null $P5476, vivify_2547
    $P5476 = root_new ['parrot';'Hash']
  vivify_2547:
    set $P5477, $P5476["onlystar"]
    unless_null $P5477, vivify_2548
    new $P5477, "Undef"
  vivify_2548:
    if $P5477, if_5475
.annotate 'line', 1957
    find_lex $P5479, "$/"
    unless_null $P5479, vivify_2549
    $P5479 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P5480, $P5479["blockoid"]
    unless_null $P5480, vivify_2550
    new $P5480, "Undef"
  vivify_2550:
    $P5481 = $P5480."ast"()
    store_lex "$past", $P5481
.annotate 'line', 1958
    find_lex $P5482, "$past"
    unless_null $P5482, vivify_2551
    new $P5482, "Undef"
  vivify_2551:
    $P5482."blocktype"("declaration")
.annotate 'line', 1959
    find_dynamic_lex $P5486, "$*RETURN_USED"
    unless_null $P5486, vivify_2552
    get_hll_global $P5484, "GLOBAL"
    get_who $P5485, $P5484
    set $P5486, $P5485["$RETURN_USED"]
    unless_null $P5486, vivify_2553
    die "Contextual $*RETURN_USED not found"
  vivify_2553:
  vivify_2552:
    unless $P5486, if_5483_end
.annotate 'line', 1960
    find_lex $P5487, "$past"
    unless_null $P5487, vivify_2554
    new $P5487, "Undef"
  vivify_2554:
    $P5487."control"("return_pir")
  if_5483_end:
.annotate 'line', 1956
    goto if_5475_end
  if_5475:
.annotate 'line', 1954
    $P5478 = "only_star_block"()
    store_lex "$past", $P5478
  if_5475_end:
.annotate 'line', 1965
    find_lex $P5489, "$past"
    unless_null $P5489, vivify_2555
    $P5489 = root_new ['parrot';'Hash']
  vivify_2555:
    set $P5490, $P5489["signature_has_invocant"]
    unless_null $P5490, vivify_2556
    new $P5490, "Undef"
  vivify_2556:
    if $P5490, unless_5488_end
.annotate 'line', 1966
    find_lex $P5491, "$past"
    unless_null $P5491, vivify_2557
    $P5491 = root_new ['parrot';'ResizablePMCArray']
  vivify_2557:
    set $P5492, $P5491[0]
    unless_null $P5492, vivify_2558
    new $P5492, "Undef"
  vivify_2558:
    get_hll_global $P5493, "GLOBAL"
    nqp_get_package_through_who $P5494, $P5493, "PAST"
    get_who $P5495, $P5494
    set $P5496, $P5495["Var"]
.annotate 'line', 1968
    find_dynamic_lex $P5499, "$*SC"
    unless_null $P5499, vivify_2559
    get_hll_global $P5497, "GLOBAL"
    get_who $P5498, $P5497
    set $P5499, $P5498["$SC"]
    unless_null $P5499, vivify_2560
    die "Contextual $*SC not found"
  vivify_2560:
  vivify_2559:
    find_dynamic_lex $P5502, "$*PACKAGE"
    unless_null $P5502, vivify_2561
    get_hll_global $P5500, "GLOBAL"
    get_who $P5501, $P5500
    set $P5502, $P5501["$PACKAGE"]
    unless_null $P5502, vivify_2562
    die "Contextual $*PACKAGE not found"
  vivify_2562:
  vivify_2561:
    $P5503 = $P5499."get_object_sc_ref_past"($P5502)
    $P5504 = $P5496."new"("self" :named("name"), "parameter" :named("scope"), $P5503 :named("multitype"))
.annotate 'line', 1966
    $P5492."unshift"($P5504)
  unless_5488_end:
.annotate 'line', 1971
    find_lex $P5505, "$past"
    unless_null $P5505, vivify_2563
    new $P5505, "Undef"
  vivify_2563:
    $P5505."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1974
    find_lex $P5507, "$/"
    unless_null $P5507, vivify_2564
    $P5507 = root_new ['parrot';'Hash']
  vivify_2564:
    set $P5508, $P5507["deflongname"]
    unless_null $P5508, vivify_2565
    new $P5508, "Undef"
  vivify_2565:
    unless $P5508, if_5506_end
    .const 'Sub' $P5510 = "541_1304523757.895" 
    capture_lex $P5510
    $P5510()
  if_5506_end:
.annotate 'line', 1995
    find_lex $P5574, "$/"
    find_lex $P5575, "$past"
    unless_null $P5575, vivify_2596
    new $P5575, "Undef"
  vivify_2596:
    $P5574."!make"($P5575)
.annotate 'line', 1996
    find_lex $P5576, "$past"
    unless_null $P5576, vivify_2597
    new $P5576, "Undef"
  vivify_2597:
    find_lex $P5577, "$past"
    unless_null $P5577, vivify_2598
    $P5577 = root_new ['parrot';'Hash']
    store_lex "$past", $P5577
  vivify_2598:
    set $P5577["block_past"], $P5576
.annotate 'line', 1997
    find_lex $P5580, "$/"
    unless_null $P5580, vivify_2599
    $P5580 = root_new ['parrot';'Hash']
  vivify_2599:
    set $P5581, $P5580["trait"]
    unless_null $P5581, vivify_2600
    new $P5581, "Undef"
  vivify_2600:
    if $P5581, if_5579
    set $P5578, $P5581
    goto if_5579_end
  if_5579:
.annotate 'line', 1998
    find_lex $P5583, "$/"
    unless_null $P5583, vivify_2601
    $P5583 = root_new ['parrot';'Hash']
  vivify_2601:
    set $P5584, $P5583["trait"]
    unless_null $P5584, vivify_2602
    new $P5584, "Undef"
  vivify_2602:
    defined $I5585, $P5584
    unless $I5585, for_undef_2603
    iter $P5582, $P5584
    new $P5595, 'ExceptionHandler'
    set_label $P5595, loop5594_handler
    $P5595."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5595
  loop5594_test:
    unless $P5582, loop5594_done
    shift $P5586, $P5582
  loop5594_redo:
    .const 'Sub' $P5588 = "542_1304523757.895" 
    capture_lex $P5588
    $P5588($P5586)
  loop5594_next:
    goto loop5594_test
  loop5594_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5596, exception, 'type'
    eq $P5596, .CONTROL_LOOP_NEXT, loop5594_next
    eq $P5596, .CONTROL_LOOP_REDO, loop5594_redo
  loop5594_done:
    pop_eh 
  for_undef_2603:
.annotate 'line', 1997
    set $P5578, $P5582
  if_5579_end:
.annotate 'line', 1949
    .return ($P5578)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5509"  :anon :subid("541_1304523757.895") :outer("540_1304523757.895")
.annotate 'line', 1976
    new $P5511, "Undef"
    .lex "$name", $P5511
.annotate 'line', 1984
    new $P5512, "Undef"
    .lex "$meta_meth", $P5512
.annotate 'line', 1985
    new $P5513, "Undef"
    .lex "$is_dispatcher", $P5513
.annotate 'line', 1976
    find_lex $P5514, "$/"
    unless_null $P5514, vivify_2566
    $P5514 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P5515, $P5514["private"]
    unless_null $P5515, vivify_2567
    new $P5515, "Undef"
  vivify_2567:
    set $S5516, $P5515
    new $P5517, 'String'
    set $P5517, $S5516
    find_lex $P5518, "$/"
    unless_null $P5518, vivify_2568
    $P5518 = root_new ['parrot';'Hash']
  vivify_2568:
    set $P5519, $P5518["deflongname"]
    unless_null $P5519, vivify_2569
    $P5519 = root_new ['parrot';'ResizablePMCArray']
  vivify_2569:
    set $P5520, $P5519[0]
    unless_null $P5520, vivify_2570
    new $P5520, "Undef"
  vivify_2570:
    $P5521 = $P5520."ast"()
    set $S5522, $P5521
    concat $P5523, $P5517, $S5522
    store_lex "$name", $P5523
.annotate 'line', 1977
    find_lex $P5524, "$past"
    unless_null $P5524, vivify_2571
    new $P5524, "Undef"
  vivify_2571:
    find_lex $P5525, "$name"
    unless_null $P5525, vivify_2572
    new $P5525, "Undef"
  vivify_2572:
    $P5524."name"($P5525)
.annotate 'line', 1981
    find_dynamic_lex $P5529, "$*MULTINESS"
    unless_null $P5529, vivify_2573
    get_hll_global $P5527, "GLOBAL"
    get_who $P5528, $P5527
    set $P5529, $P5528["$MULTINESS"]
    unless_null $P5529, vivify_2574
    die "Contextual $*MULTINESS not found"
  vivify_2574:
  vivify_2573:
    set $S5530, $P5529
    iseq $I5531, $S5530, "multi"
    unless $I5531, if_5526_end
    find_lex $P5532, "$past"
    unless_null $P5532, vivify_2575
    new $P5532, "Undef"
  vivify_2575:
    "attach_multi_signature"($P5532)
  if_5526_end:
.annotate 'line', 1984
    find_dynamic_lex $P5537, "$*MULTINESS"
    unless_null $P5537, vivify_2576
    get_hll_global $P5535, "GLOBAL"
    get_who $P5536, $P5535
    set $P5537, $P5536["$MULTINESS"]
    unless_null $P5537, vivify_2577
    die "Contextual $*MULTINESS not found"
  vivify_2577:
  vivify_2576:
    set $S5538, $P5537
    iseq $I5539, $S5538, "multi"
    if $I5539, if_5534
    new $P5541, "String"
    assign $P5541, "add_method"
    set $P5533, $P5541
    goto if_5534_end
  if_5534:
    new $P5540, "String"
    assign $P5540, "add_multi_method"
    set $P5533, $P5540
  if_5534_end:
    store_lex "$meta_meth", $P5533
.annotate 'line', 1985
    find_dynamic_lex $P5544, "$*MULTINESS"
    unless_null $P5544, vivify_2578
    get_hll_global $P5542, "GLOBAL"
    get_who $P5543, $P5542
    set $P5544, $P5543["$MULTINESS"]
    unless_null $P5544, vivify_2579
    die "Contextual $*MULTINESS not found"
  vivify_2579:
  vivify_2578:
    set $S5545, $P5544
    iseq $I5546, $S5545, "proto"
    new $P5547, 'Integer'
    set $P5547, $I5546
    store_lex "$is_dispatcher", $P5547
.annotate 'line', 1986
    find_dynamic_lex $P5550, "$*SC"
    unless_null $P5550, vivify_2580
    get_hll_global $P5548, "GLOBAL"
    get_who $P5549, $P5548
    set $P5550, $P5549["$SC"]
    unless_null $P5550, vivify_2581
    die "Contextual $*SC not found"
  vivify_2581:
  vivify_2580:
    find_dynamic_lex $P5553, "$*PACKAGE"
    unless_null $P5553, vivify_2582
    get_hll_global $P5551, "GLOBAL"
    get_who $P5552, $P5551
    set $P5553, $P5552["$PACKAGE"]
    unless_null $P5553, vivify_2583
    die "Contextual $*PACKAGE not found"
  vivify_2583:
  vivify_2582:
    find_lex $P5554, "$meta_meth"
    unless_null $P5554, vivify_2584
    new $P5554, "Undef"
  vivify_2584:
    find_lex $P5555, "$name"
    unless_null $P5555, vivify_2585
    new $P5555, "Undef"
  vivify_2585:
    find_lex $P5556, "$past"
    unless_null $P5556, vivify_2586
    new $P5556, "Undef"
  vivify_2586:
    find_lex $P5557, "$is_dispatcher"
    unless_null $P5557, vivify_2587
    new $P5557, "Undef"
  vivify_2587:
    $P5550."pkg_add_method"($P5553, $P5554, $P5555, $P5556, $P5557)
.annotate 'line', 1989
    find_dynamic_lex $P5562, "$*SCOPE"
    unless_null $P5562, vivify_2588
    get_hll_global $P5560, "GLOBAL"
    get_who $P5561, $P5560
    set $P5562, $P5561["$SCOPE"]
    unless_null $P5562, vivify_2589
    die "Contextual $*SCOPE not found"
  vivify_2589:
  vivify_2588:
    set $S5563, $P5562
    iseq $I5564, $S5563, "our"
    if $I5564, if_5559
    new $P5558, 'Integer'
    set $P5558, $I5564
    goto if_5559_end
  if_5559:
.annotate 'line', 1990
    find_dynamic_lex $P5567, "$*SC"
    unless_null $P5567, vivify_2590
    get_hll_global $P5565, "GLOBAL"
    get_who $P5566, $P5565
    set $P5567, $P5566["$SC"]
    unless_null $P5567, vivify_2591
    die "Contextual $*SC not found"
  vivify_2591:
  vivify_2590:
    find_dynamic_lex $P5570, "$*PACKAGE"
    unless_null $P5570, vivify_2592
    get_hll_global $P5568, "GLOBAL"
    get_who $P5569, $P5568
    set $P5570, $P5569["$PACKAGE"]
    unless_null $P5570, vivify_2593
    die "Contextual $*PACKAGE not found"
  vivify_2593:
  vivify_2592:
    find_lex $P5571, "$name"
    unless_null $P5571, vivify_2594
    new $P5571, "Undef"
  vivify_2594:
    find_lex $P5572, "$past"
    unless_null $P5572, vivify_2595
    new $P5572, "Undef"
  vivify_2595:
    $P5573 = $P5567."install_package_routine"($P5570, $P5571, $P5572)
.annotate 'line', 1989
    set $P5558, $P5573
  if_5559_end:
.annotate 'line', 1974
    .return ($P5558)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5587"  :anon :subid("542_1304523757.895") :outer("540_1304523757.895")
    .param pmc param_5589
.annotate 'line', 1998
    .lex "$_", param_5589
    find_lex $P5590, "$_"
    unless_null $P5590, vivify_2604
    new $P5590, "Undef"
  vivify_2604:
    $P5591 = $P5590."ast"()
    find_lex $P5592, "$/"
    unless_null $P5592, vivify_2605
    new $P5592, "Undef"
  vivify_2605:
    $P5593 = $P5591($P5592)
    .return ($P5593)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("543_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5600
    .param pmc param_5601
.annotate 'line', 2027
    .const 'Sub' $P5644 = "545_1304523757.895" 
    capture_lex $P5644
    .const 'Sub' $P5612 = "544_1304523757.895" 
    capture_lex $P5612
    .lex "self", param_5600
    .lex "$/", param_5601
.annotate 'line', 2028
    new $P5602, "Undef"
    .lex "$BLOCKINIT", $P5602
    find_lex $P5603, "$?PACKAGE"
    get_who $P5604, $P5603
    set $P5605, $P5604["@BLOCK"]
    unless_null $P5605, vivify_2606
    $P5605 = root_new ['parrot';'ResizablePMCArray']
  vivify_2606:
    set $P5606, $P5605[0]
    unless_null $P5606, vivify_2607
    $P5606 = root_new ['parrot';'ResizablePMCArray']
  vivify_2607:
    set $P5607, $P5606[0]
    unless_null $P5607, vivify_2608
    new $P5607, "Undef"
  vivify_2608:
    store_lex "$BLOCKINIT", $P5607
.annotate 'line', 2029
    find_lex $P5609, "$/"
    unless_null $P5609, vivify_2609
    $P5609 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5610, $P5609["invocant"]
    unless_null $P5610, vivify_2610
    new $P5610, "Undef"
  vivify_2610:
    unless $P5610, if_5608_end
    .const 'Sub' $P5612 = "544_1304523757.895" 
    capture_lex $P5612
    $P5612()
  if_5608_end:
.annotate 'line', 2038
    find_lex $P5639, "$/"
    unless_null $P5639, vivify_2620
    $P5639 = root_new ['parrot';'Hash']
  vivify_2620:
    set $P5640, $P5639["parameter"]
    unless_null $P5640, vivify_2621
    new $P5640, "Undef"
  vivify_2621:
    defined $I5641, $P5640
    unless $I5641, for_undef_2622
    iter $P5638, $P5640
    new $P5651, 'ExceptionHandler'
    set_label $P5651, loop5650_handler
    $P5651."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5651
  loop5650_test:
    unless $P5638, loop5650_done
    shift $P5642, $P5638
  loop5650_redo:
    .const 'Sub' $P5644 = "545_1304523757.895" 
    capture_lex $P5644
    $P5644($P5642)
  loop5650_next:
    goto loop5650_test
  loop5650_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5652, exception, 'type'
    eq $P5652, .CONTROL_LOOP_NEXT, loop5650_next
    eq $P5652, .CONTROL_LOOP_REDO, loop5650_redo
  loop5650_done:
    pop_eh 
  for_undef_2622:
.annotate 'line', 2027
    .return ($P5638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5611"  :anon :subid("544_1304523757.895") :outer("543_1304523757.895")
.annotate 'line', 2030
    new $P5613, "Undef"
    .lex "$inv", $P5613
    find_lex $P5614, "$/"
    unless_null $P5614, vivify_2611
    $P5614 = root_new ['parrot';'Hash']
  vivify_2611:
    set $P5615, $P5614["invocant"]
    unless_null $P5615, vivify_2612
    $P5615 = root_new ['parrot';'ResizablePMCArray']
  vivify_2612:
    set $P5616, $P5615[0]
    unless_null $P5616, vivify_2613
    new $P5616, "Undef"
  vivify_2613:
    $P5617 = $P5616."ast"()
    store_lex "$inv", $P5617
.annotate 'line', 2031
    find_lex $P5618, "$BLOCKINIT"
    unless_null $P5618, vivify_2614
    new $P5618, "Undef"
  vivify_2614:
    find_lex $P5619, "$inv"
    unless_null $P5619, vivify_2615
    new $P5619, "Undef"
  vivify_2615:
    $P5618."push"($P5619)
.annotate 'line', 2032
    find_lex $P5620, "$BLOCKINIT"
    unless_null $P5620, vivify_2616
    new $P5620, "Undef"
  vivify_2616:
    get_hll_global $P5621, "GLOBAL"
    nqp_get_package_through_who $P5622, $P5621, "PAST"
    get_who $P5623, $P5622
    set $P5624, $P5623["Var"]
.annotate 'line', 2034
    get_hll_global $P5625, "GLOBAL"
    nqp_get_package_through_who $P5626, $P5625, "PAST"
    get_who $P5627, $P5626
    set $P5628, $P5627["Var"]
    find_lex $P5629, "$inv"
    unless_null $P5629, vivify_2617
    new $P5629, "Undef"
  vivify_2617:
    $P5630 = $P5629."name"()
    $P5631 = $P5628."new"("lexical" :named("scope"), $P5630 :named("name"))
    $P5632 = $P5624."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5631 :named("viviself"))
.annotate 'line', 2032
    $P5620."push"($P5632)
.annotate 'line', 2036
    new $P5633, "Integer"
    assign $P5633, 1
    find_lex $P5634, "$?PACKAGE"
    get_who $P5635, $P5634
    set $P5636, $P5635["@BLOCK"]
    unless_null $P5636, vivify_2618
    $P5636 = root_new ['parrot';'ResizablePMCArray']
    set $P5635["@BLOCK"], $P5636
  vivify_2618:
    set $P5637, $P5636[0]
    unless_null $P5637, vivify_2619
    $P5637 = root_new ['parrot';'Hash']
    set $P5636[0], $P5637
  vivify_2619:
    set $P5637["signature_has_invocant"], $P5633
.annotate 'line', 2029
    .return ($P5633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5643"  :anon :subid("545_1304523757.895") :outer("543_1304523757.895")
    .param pmc param_5645
.annotate 'line', 2038
    .lex "$_", param_5645
    find_lex $P5646, "$BLOCKINIT"
    unless_null $P5646, vivify_2623
    new $P5646, "Undef"
  vivify_2623:
    find_lex $P5647, "$_"
    unless_null $P5647, vivify_2624
    new $P5647, "Undef"
  vivify_2624:
    $P5648 = $P5647."ast"()
    $P5649 = $P5646."push"($P5648)
    .return ($P5649)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("546_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5654
    .param pmc param_5655
.annotate 'line', 2041
    .lex "self", param_5654
    .lex "$/", param_5655
.annotate 'line', 2042
    new $P5656, "Undef"
    .lex "$quant", $P5656
.annotate 'line', 2043
    new $P5657, "Undef"
    .lex "$past", $P5657
.annotate 'line', 2042
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2625
    $P5658 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P5659, $P5658["quant"]
    unless_null $P5659, vivify_2626
    new $P5659, "Undef"
  vivify_2626:
    store_lex "$quant", $P5659
    find_lex $P5660, "$past"
    unless_null $P5660, vivify_2627
    new $P5660, "Undef"
  vivify_2627:
.annotate 'line', 2044
    find_lex $P5662, "$/"
    unless_null $P5662, vivify_2628
    $P5662 = root_new ['parrot';'Hash']
  vivify_2628:
    set $P5663, $P5662["named_param"]
    unless_null $P5663, vivify_2629
    new $P5663, "Undef"
  vivify_2629:
    if $P5663, if_5661
.annotate 'line', 2051
    find_lex $P5677, "$/"
    unless_null $P5677, vivify_2630
    $P5677 = root_new ['parrot';'Hash']
  vivify_2630:
    set $P5678, $P5677["param_var"]
    unless_null $P5678, vivify_2631
    new $P5678, "Undef"
  vivify_2631:
    $P5679 = $P5678."ast"()
    store_lex "$past", $P5679
.annotate 'line', 2052
    find_lex $P5681, "$quant"
    unless_null $P5681, vivify_2632
    new $P5681, "Undef"
  vivify_2632:
    set $S5682, $P5681
    iseq $I5683, $S5682, "*"
    if $I5683, if_5680
.annotate 'line', 2056
    find_lex $P5692, "$quant"
    unless_null $P5692, vivify_2633
    new $P5692, "Undef"
  vivify_2633:
    set $S5693, $P5692
    iseq $I5694, $S5693, "?"
    unless $I5694, if_5691_end
.annotate 'line', 2057
    find_lex $P5695, "$past"
    unless_null $P5695, vivify_2634
    new $P5695, "Undef"
  vivify_2634:
    find_lex $P5696, "$/"
    unless_null $P5696, vivify_2635
    $P5696 = root_new ['parrot';'Hash']
  vivify_2635:
    set $P5697, $P5696["param_var"]
    unless_null $P5697, vivify_2636
    $P5697 = root_new ['parrot';'Hash']
  vivify_2636:
    set $P5698, $P5697["sigil"]
    unless_null $P5698, vivify_2637
    new $P5698, "Undef"
  vivify_2637:
    $P5699 = "vivitype"($P5698)
    $P5695."viviself"($P5699)
  if_5691_end:
.annotate 'line', 2056
    goto if_5680_end
  if_5680:
.annotate 'line', 2053
    find_lex $P5684, "$past"
    unless_null $P5684, vivify_2638
    new $P5684, "Undef"
  vivify_2638:
    $P5684."slurpy"(1)
.annotate 'line', 2054
    find_lex $P5685, "$past"
    unless_null $P5685, vivify_2639
    new $P5685, "Undef"
  vivify_2639:
    find_lex $P5686, "$/"
    unless_null $P5686, vivify_2640
    $P5686 = root_new ['parrot';'Hash']
  vivify_2640:
    set $P5687, $P5686["param_var"]
    unless_null $P5687, vivify_2641
    $P5687 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P5688, $P5687["sigil"]
    unless_null $P5688, vivify_2642
    new $P5688, "Undef"
  vivify_2642:
    set $S5689, $P5688
    iseq $I5690, $S5689, "%"
    $P5685."named"($I5690)
  if_5680_end:
.annotate 'line', 2050
    goto if_5661_end
  if_5661:
.annotate 'line', 2045
    find_lex $P5664, "$/"
    unless_null $P5664, vivify_2643
    $P5664 = root_new ['parrot';'Hash']
  vivify_2643:
    set $P5665, $P5664["named_param"]
    unless_null $P5665, vivify_2644
    new $P5665, "Undef"
  vivify_2644:
    $P5666 = $P5665."ast"()
    store_lex "$past", $P5666
.annotate 'line', 2046
    find_lex $P5668, "$quant"
    unless_null $P5668, vivify_2645
    new $P5668, "Undef"
  vivify_2645:
    set $S5669, $P5668
    isne $I5670, $S5669, "!"
    unless $I5670, if_5667_end
.annotate 'line', 2047
    find_lex $P5671, "$past"
    unless_null $P5671, vivify_2646
    new $P5671, "Undef"
  vivify_2646:
    find_lex $P5672, "$/"
    unless_null $P5672, vivify_2647
    $P5672 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5673, $P5672["named_param"]
    unless_null $P5673, vivify_2648
    $P5673 = root_new ['parrot';'Hash']
  vivify_2648:
    set $P5674, $P5673["param_var"]
    unless_null $P5674, vivify_2649
    $P5674 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5675, $P5674["sigil"]
    unless_null $P5675, vivify_2650
    new $P5675, "Undef"
  vivify_2650:
    $P5676 = "vivitype"($P5675)
    $P5671."viviself"($P5676)
  if_5667_end:
  if_5661_end:
.annotate 'line', 2060
    find_lex $P5701, "$/"
    unless_null $P5701, vivify_2651
    $P5701 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P5702, $P5701["default_value"]
    unless_null $P5702, vivify_2652
    new $P5702, "Undef"
  vivify_2652:
    unless $P5702, if_5700_end
.annotate 'line', 2061
    find_lex $P5704, "$quant"
    unless_null $P5704, vivify_2653
    new $P5704, "Undef"
  vivify_2653:
    set $S5705, $P5704
    iseq $I5706, $S5705, "*"
    unless $I5706, if_5703_end
.annotate 'line', 2062
    find_lex $P5707, "$/"
    unless_null $P5707, vivify_2654
    new $P5707, "Undef"
  vivify_2654:
    $P5708 = $P5707."CURSOR"()
    $P5708."panic"("Can't put default on slurpy parameter")
  if_5703_end:
.annotate 'line', 2064
    find_lex $P5710, "$quant"
    unless_null $P5710, vivify_2655
    new $P5710, "Undef"
  vivify_2655:
    set $S5711, $P5710
    iseq $I5712, $S5711, "!"
    unless $I5712, if_5709_end
.annotate 'line', 2065
    find_lex $P5713, "$/"
    unless_null $P5713, vivify_2656
    new $P5713, "Undef"
  vivify_2656:
    $P5714 = $P5713."CURSOR"()
    $P5714."panic"("Can't put default on required parameter")
  if_5709_end:
.annotate 'line', 2067
    find_lex $P5715, "$past"
    unless_null $P5715, vivify_2657
    new $P5715, "Undef"
  vivify_2657:
    find_lex $P5716, "$/"
    unless_null $P5716, vivify_2658
    $P5716 = root_new ['parrot';'Hash']
  vivify_2658:
    set $P5717, $P5716["default_value"]
    unless_null $P5717, vivify_2659
    $P5717 = root_new ['parrot';'ResizablePMCArray']
  vivify_2659:
    set $P5718, $P5717[0]
    unless_null $P5718, vivify_2660
    $P5718 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P5719, $P5718["EXPR"]
    unless_null $P5719, vivify_2661
    new $P5719, "Undef"
  vivify_2661:
    $P5720 = $P5719."ast"()
    $P5715."viviself"($P5720)
  if_5700_end:
.annotate 'line', 2069
    find_lex $P5722, "$past"
    unless_null $P5722, vivify_2662
    new $P5722, "Undef"
  vivify_2662:
    $P5723 = $P5722."viviself"()
    if $P5723, unless_5721_end
    find_lex $P5724, "$?PACKAGE"
    get_who $P5725, $P5724
    set $P5726, $P5725["@BLOCK"]
    unless_null $P5726, vivify_2663
    $P5726 = root_new ['parrot';'ResizablePMCArray']
  vivify_2663:
    set $P5727, $P5726[0]
    unless_null $P5727, vivify_2664
    new $P5727, "Undef"
  vivify_2664:
    find_lex $P5728, "$?PACKAGE"
    get_who $P5729, $P5728
    set $P5730, $P5729["@BLOCK"]
    unless_null $P5730, vivify_2665
    $P5730 = root_new ['parrot';'ResizablePMCArray']
  vivify_2665:
    set $P5731, $P5730[0]
    unless_null $P5731, vivify_2666
    new $P5731, "Undef"
  vivify_2666:
    $P5732 = $P5731."arity"()
    set $N5733, $P5732
    new $P5734, 'Float'
    set $P5734, $N5733
    add $P5735, $P5734, 1
    $P5727."arity"($P5735)
  unless_5721_end:
.annotate 'line', 2073
    find_lex $P5737, "$/"
    unless_null $P5737, vivify_2667
    $P5737 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P5738, $P5737["typename"]
    unless_null $P5738, vivify_2668
    new $P5738, "Undef"
  vivify_2668:
    unless $P5738, if_5736_end
.annotate 'line', 2074
    find_lex $P5739, "$past"
    unless_null $P5739, vivify_2669
    new $P5739, "Undef"
  vivify_2669:
    find_lex $P5740, "$/"
    unless_null $P5740, vivify_2670
    $P5740 = root_new ['parrot';'Hash']
  vivify_2670:
    set $P5741, $P5740["typename"]
    unless_null $P5741, vivify_2671
    $P5741 = root_new ['parrot';'ResizablePMCArray']
  vivify_2671:
    set $P5742, $P5741[0]
    unless_null $P5742, vivify_2672
    new $P5742, "Undef"
  vivify_2672:
    $P5743 = $P5742."ast"()
    $P5739."multitype"($P5743)
  if_5736_end:
.annotate 'line', 2078
    find_lex $P5745, "$/"
    unless_null $P5745, vivify_2673
    $P5745 = root_new ['parrot';'Hash']
  vivify_2673:
    set $P5746, $P5745["definedness"]
    unless_null $P5746, vivify_2674
    new $P5746, "Undef"
  vivify_2674:
    unless $P5746, if_5744_end
.annotate 'line', 2079
    find_lex $P5747, "$/"
    unless_null $P5747, vivify_2675
    $P5747 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P5748, $P5747["definedness"]
    unless_null $P5748, vivify_2676
    $P5748 = root_new ['parrot';'ResizablePMCArray']
  vivify_2676:
    set $P5749, $P5748[0]
    unless_null $P5749, vivify_2677
    new $P5749, "Undef"
  vivify_2677:
    set $S5750, $P5749
    new $P5751, 'String'
    set $P5751, $S5750
    find_lex $P5752, "$past"
    unless_null $P5752, vivify_2678
    $P5752 = root_new ['parrot';'Hash']
    store_lex "$past", $P5752
  vivify_2678:
    set $P5752["definedness"], $P5751
  if_5744_end:
.annotate 'line', 2082
    find_lex $P5753, "$/"
    find_lex $P5754, "$past"
    unless_null $P5754, vivify_2679
    new $P5754, "Undef"
  vivify_2679:
    $P5755 = $P5753."!make"($P5754)
.annotate 'line', 2041
    .return ($P5755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("547_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5757
    .param pmc param_5758
.annotate 'line', 2085
    .lex "self", param_5757
    .lex "$/", param_5758
.annotate 'line', 2086
    new $P5759, "Undef"
    .lex "$name", $P5759
.annotate 'line', 2087
    new $P5760, "Undef"
    .lex "$past", $P5760
.annotate 'line', 2086
    find_lex $P5761, "$/"
    unless_null $P5761, vivify_2680
    new $P5761, "Undef"
  vivify_2680:
    set $S5762, $P5761
    new $P5763, 'String'
    set $P5763, $S5762
    store_lex "$name", $P5763
.annotate 'line', 2087
    get_hll_global $P5764, "GLOBAL"
    nqp_get_package_through_who $P5765, $P5764, "PAST"
    get_who $P5766, $P5765
    set $P5767, $P5766["Var"]
    find_lex $P5768, "$name"
    unless_null $P5768, vivify_2681
    new $P5768, "Undef"
  vivify_2681:
    find_lex $P5769, "$/"
    unless_null $P5769, vivify_2682
    new $P5769, "Undef"
  vivify_2682:
    $P5770 = $P5767."new"($P5768 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5769 :named("node"))
    store_lex "$past", $P5770
.annotate 'line', 2089
    find_lex $P5771, "$?PACKAGE"
    get_who $P5772, $P5771
    set $P5773, $P5772["@BLOCK"]
    unless_null $P5773, vivify_2683
    $P5773 = root_new ['parrot';'ResizablePMCArray']
  vivify_2683:
    set $P5774, $P5773[0]
    unless_null $P5774, vivify_2684
    new $P5774, "Undef"
  vivify_2684:
    find_lex $P5775, "$name"
    unless_null $P5775, vivify_2685
    new $P5775, "Undef"
  vivify_2685:
    $P5774."symbol"($P5775, "lexical" :named("scope"))
.annotate 'line', 2090
    find_lex $P5776, "$/"
    find_lex $P5777, "$past"
    unless_null $P5777, vivify_2686
    new $P5777, "Undef"
  vivify_2686:
    $P5778 = $P5776."!make"($P5777)
.annotate 'line', 2085
    .return ($P5778)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("548_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5780
    .param pmc param_5781
.annotate 'line', 2093
    .lex "self", param_5780
    .lex "$/", param_5781
.annotate 'line', 2094
    new $P5782, "Undef"
    .lex "$past", $P5782
    find_lex $P5783, "$/"
    unless_null $P5783, vivify_2687
    $P5783 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P5784, $P5783["param_var"]
    unless_null $P5784, vivify_2688
    new $P5784, "Undef"
  vivify_2688:
    $P5785 = $P5784."ast"()
    store_lex "$past", $P5785
.annotate 'line', 2095
    find_lex $P5786, "$past"
    unless_null $P5786, vivify_2689
    new $P5786, "Undef"
  vivify_2689:
    find_lex $P5787, "$/"
    unless_null $P5787, vivify_2690
    $P5787 = root_new ['parrot';'Hash']
  vivify_2690:
    set $P5788, $P5787["param_var"]
    unless_null $P5788, vivify_2691
    $P5788 = root_new ['parrot';'Hash']
  vivify_2691:
    set $P5789, $P5788["name"]
    unless_null $P5789, vivify_2692
    new $P5789, "Undef"
  vivify_2692:
    set $S5790, $P5789
    $P5786."named"($S5790)
.annotate 'line', 2096
    find_lex $P5791, "$/"
    find_lex $P5792, "$past"
    unless_null $P5792, vivify_2693
    new $P5792, "Undef"
  vivify_2693:
    $P5793 = $P5791."!make"($P5792)
.annotate 'line', 2093
    .return ($P5793)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("549_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5795
    .param pmc param_5796
.annotate 'line', 2099
    .const 'Sub' $P5808 = "550_1304523757.895" 
    capture_lex $P5808
    .lex "self", param_5795
    .lex "$/", param_5796
.annotate 'line', 2103
    $P5797 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5797
.annotate 'line', 2104
    new $P5798, "Undef"
    .lex "$found", $P5798
.annotate 'line', 2103
    get_hll_global $P5799, "GLOBAL"
    nqp_get_package_through_who $P5800, $P5799, "HLL"
    get_who $P5801, $P5800
    set $P5802, $P5801["Compiler"]
    find_lex $P5803, "$/"
    unless_null $P5803, vivify_2694
    new $P5803, "Undef"
  vivify_2694:
    set $S5804, $P5803
    $P5805 = $P5802."parse_name"($S5804)
    store_lex "@name", $P5805
.annotate 'line', 2104
    new $P5806, "Integer"
    assign $P5806, 0
    store_lex "$found", $P5806
.annotate 'line', 2105
    .const 'Sub' $P5808 = "550_1304523757.895" 
    capture_lex $P5808
    $P5808()
.annotate 'line', 2110
    find_lex $P5829, "$found"
    unless_null $P5829, vivify_2700
    new $P5829, "Undef"
  vivify_2700:
    unless $P5829, unless_5828
    set $P5827, $P5829
    goto unless_5828_end
  unless_5828:
.annotate 'line', 2111
    find_lex $P5830, "$/"
    unless_null $P5830, vivify_2701
    new $P5830, "Undef"
  vivify_2701:
    $P5831 = $P5830."CURSOR"()
    new $P5832, "String"
    assign $P5832, "Use of undeclared type '"
    find_lex $P5833, "$/"
    unless_null $P5833, vivify_2702
    new $P5833, "Undef"
  vivify_2702:
    set $S5834, $P5833
    concat $P5835, $P5832, $S5834
    concat $P5836, $P5835, "'"
    $P5837 = $P5831."panic"($P5836)
.annotate 'line', 2110
    set $P5827, $P5837
  unless_5828_end:
.annotate 'line', 2099
    .return ($P5827)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5807"  :anon :subid("550_1304523757.895") :outer("549_1304523757.895")
.annotate 'line', 2105
    new $P5822, 'ExceptionHandler'
    set_label $P5822, control_5821
    $P5822."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P5822
.annotate 'line', 2106
    new $P5809, "Undef"
    .lex "$sym", $P5809
    find_lex $P5810, "@name"
    unless_null $P5810, vivify_2695
    $P5810 = root_new ['parrot';'ResizablePMCArray']
  vivify_2695:
    find_lex $P5811, "$/"
    unless_null $P5811, vivify_2696
    new $P5811, "Undef"
  vivify_2696:
    $P5812 = "find_sym"($P5810, $P5811)
    store_lex "$sym", $P5812
.annotate 'line', 2107
    find_dynamic_lex $P5813, "$/"
    find_dynamic_lex $P5816, "$*SC"
    unless_null $P5816, vivify_2697
    get_hll_global $P5814, "GLOBAL"
    get_who $P5815, $P5814
    set $P5816, $P5815["$SC"]
    unless_null $P5816, vivify_2698
    die "Contextual $*SC not found"
  vivify_2698:
  vivify_2697:
    find_lex $P5817, "$sym"
    unless_null $P5817, vivify_2699
    new $P5817, "Undef"
  vivify_2699:
    $P5818 = $P5816."get_object_sc_ref_past"($P5817)
    $P5813."!make"($P5818)
.annotate 'line', 2108
    new $P5819, "Integer"
    assign $P5819, 1
    store_lex "$found", $P5819
.annotate 'line', 2105
    pop_eh 
    goto skip_handler_5820
  control_5821:
    .local pmc exception 
    .get_results (exception) 
    new $P5825, 'Integer'
    set $P5825, 1
    set exception["handled"], $P5825
    set $I5826, exception["handled"]
    ne $I5826, 1, nothandled_5824
  handled_5823:
    .return (exception)
  nothandled_5824:
    rethrow exception
  skip_handler_5820:
    .return ($P5819)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("551_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5839
    .param pmc param_5840
.annotate 'line', 2115
    .lex "self", param_5839
    .lex "$/", param_5840
.annotate 'line', 2116
    find_lex $P5841, "$/"
    find_lex $P5842, "$/"
    unless_null $P5842, vivify_2703
    $P5842 = root_new ['parrot';'Hash']
  vivify_2703:
    set $P5843, $P5842["trait_mod"]
    unless_null $P5843, vivify_2704
    new $P5843, "Undef"
  vivify_2704:
    $P5844 = $P5843."ast"()
    $P5845 = $P5841."!make"($P5844)
.annotate 'line', 2115
    .return ($P5845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("552_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5847
    .param pmc param_5848
.annotate 'line', 2119
    .const 'Sub' $P5856 = "553_1304523757.895" 
    capture_lex $P5856
    .lex "self", param_5847
    .lex "$/", param_5848
.annotate 'line', 2120
    find_lex $P5851, "$/"
    unless_null $P5851, vivify_2705
    $P5851 = root_new ['parrot';'Hash']
  vivify_2705:
    set $P5852, $P5851["longname"]
    unless_null $P5852, vivify_2706
    new $P5852, "Undef"
  vivify_2706:
    set $S5853, $P5852
    iseq $I5854, $S5853, "parrot_vtable"
    if $I5854, if_5850
.annotate 'line', 2133
    find_lex $P5904, "$/"
    unless_null $P5904, vivify_2707
    $P5904 = root_new ['parrot';'Hash']
  vivify_2707:
    set $P5905, $P5904["longname"]
    unless_null $P5905, vivify_2708
    new $P5905, "Undef"
  vivify_2708:
    set $S5906, $P5905
    iseq $I5907, $S5906, "pirflags"
    if $I5907, if_5903
.annotate 'line', 2137
    find_lex $P5911, "$/"
    unless_null $P5911, vivify_2709
    new $P5911, "Undef"
  vivify_2709:
    $P5912 = $P5911."CURSOR"()
    new $P5913, 'String'
    set $P5913, "Trait '"
    find_lex $P5914, "$/"
    unless_null $P5914, vivify_2710
    $P5914 = root_new ['parrot';'Hash']
  vivify_2710:
    set $P5915, $P5914["longname"]
    unless_null $P5915, vivify_2711
    new $P5915, "Undef"
  vivify_2711:
    concat $P5916, $P5913, $P5915
    concat $P5917, $P5916, "' not implemented"
    $P5918 = $P5912."panic"($P5917)
.annotate 'line', 2136
    set $P5902, $P5918
.annotate 'line', 2133
    goto if_5903_end
  if_5903:
.annotate 'line', 2134
    find_lex $P5908, "$/"
    unless_null $P5908, vivify_2712
    new $P5908, "Undef"
  vivify_2712:
    $P5909 = $P5908."CURSOR"()
    $P5910 = $P5909."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2133
    set $P5902, $P5910
  if_5903_end:
    set $P5849, $P5902
.annotate 'line', 2120
    goto if_5850_end
  if_5850:
    .const 'Sub' $P5856 = "553_1304523757.895" 
    capture_lex $P5856
    $P5901 = $P5856()
    set $P5849, $P5901
  if_5850_end:
.annotate 'line', 2119
    .return ($P5849)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5855"  :anon :subid("553_1304523757.895") :outer("552_1304523757.895")
.annotate 'line', 2120
    .const 'Sub' $P5887 = "554_1304523757.895" 
    capture_lex $P5887
.annotate 'line', 2122
    new $P5857, "Undef"
    .lex "$cpast", $P5857
.annotate 'line', 2125
    new $P5858, "Undef"
    .lex "$name", $P5858
.annotate 'line', 2126
    new $P5859, "Undef"
    .lex "$package", $P5859
.annotate 'line', 2127
    new $P5860, "Undef"
    .lex "$is_dispatcher", $P5860
.annotate 'line', 2122
    find_lex $P5861, "$/"
    unless_null $P5861, vivify_2713
    $P5861 = root_new ['parrot';'Hash']
  vivify_2713:
    set $P5862, $P5861["circumfix"]
    unless_null $P5862, vivify_2714
    $P5862 = root_new ['parrot';'ResizablePMCArray']
  vivify_2714:
    set $P5863, $P5862[0]
    unless_null $P5863, vivify_2715
    new $P5863, "Undef"
  vivify_2715:
    $P5864 = $P5863."ast"()
    store_lex "$cpast", $P5864
.annotate 'line', 2124
    get_hll_global $P5866, "GLOBAL"
    nqp_get_package_through_who $P5867, $P5866, "PAST"
    get_who $P5868, $P5867
    set $P5869, $P5868["Val"]
    find_lex $P5870, "$cpast"
    unless_null $P5870, vivify_2716
    new $P5870, "Undef"
  vivify_2716:
    $P5871 = $P5869."ACCEPTS"($P5870)
    if $P5871, unless_5865_end
.annotate 'line', 2123
    find_lex $P5872, "$/"
    unless_null $P5872, vivify_2717
    new $P5872, "Undef"
  vivify_2717:
    $P5873 = $P5872."CURSOR"()
    $P5873."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5865_end:
.annotate 'line', 2125
    find_lex $P5874, "$cpast"
    unless_null $P5874, vivify_2718
    new $P5874, "Undef"
  vivify_2718:
    $P5875 = $P5874."value"()
    store_lex "$name", $P5875
.annotate 'line', 2126
    find_dynamic_lex $P5878, "$*PACKAGE"
    unless_null $P5878, vivify_2719
    get_hll_global $P5876, "GLOBAL"
    get_who $P5877, $P5876
    set $P5878, $P5877["$PACKAGE"]
    unless_null $P5878, vivify_2720
    die "Contextual $*PACKAGE not found"
  vivify_2720:
  vivify_2719:
    store_lex "$package", $P5878
.annotate 'line', 2127
    find_dynamic_lex $P5881, "$*SCOPE"
    unless_null $P5881, vivify_2721
    get_hll_global $P5879, "GLOBAL"
    get_who $P5880, $P5879
    set $P5881, $P5880["$SCOPE"]
    unless_null $P5881, vivify_2722
    die "Contextual $*SCOPE not found"
  vivify_2722:
  vivify_2721:
    set $S5882, $P5881
    iseq $I5883, $S5882, "proto"
    new $P5884, 'Integer'
    set $P5884, $I5883
    store_lex "$is_dispatcher", $P5884
.annotate 'line', 2128
    find_dynamic_lex $P5885, "$/"
    .const 'Sub' $P5887 = "554_1304523757.895" 
    newclosure $P5899, $P5887
    $P5900 = $P5885."!make"($P5899)
.annotate 'line', 2120
    .return ($P5900)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5886"  :anon :subid("554_1304523757.895") :outer("553_1304523757.895")
    .param pmc param_5888
.annotate 'line', 2128
    .lex "$match", param_5888
.annotate 'line', 2129
    find_dynamic_lex $P5891, "$*SC"
    unless_null $P5891, vivify_2723
    get_hll_global $P5889, "GLOBAL"
    get_who $P5890, $P5889
    set $P5891, $P5890["$SC"]
    unless_null $P5891, vivify_2724
    die "Contextual $*SC not found"
  vivify_2724:
  vivify_2723:
    find_lex $P5892, "$package"
    unless_null $P5892, vivify_2725
    new $P5892, "Undef"
  vivify_2725:
    find_lex $P5893, "$name"
    unless_null $P5893, vivify_2726
    new $P5893, "Undef"
  vivify_2726:
.annotate 'line', 2130
    find_lex $P5894, "$match"
    unless_null $P5894, vivify_2727
    new $P5894, "Undef"
  vivify_2727:
    $P5895 = $P5894."ast"()
    set $P5896, $P5895["block_past"]
    unless_null $P5896, vivify_2728
    new $P5896, "Undef"
  vivify_2728:
.annotate 'line', 2129
    find_lex $P5897, "$is_dispatcher"
    unless_null $P5897, vivify_2729
    new $P5897, "Undef"
  vivify_2729:
    $P5898 = $P5891."pkg_add_method"($P5892, "add_parrot_vtable_mapping", $P5893, $P5896, $P5897)
.annotate 'line', 2128
    .return ($P5898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("555_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_5922
    .param pmc param_5923
    .param pmc param_5924 :optional
    .param int has_param_5924 :opt_flag
.annotate 'line', 2141
    .const 'Sub' $P6051 = "558_1304523757.895" 
    capture_lex $P6051
    .const 'Sub' $P6013 = "557_1304523757.895" 
    capture_lex $P6013
    .const 'Sub' $P5993 = "556_1304523757.895" 
    capture_lex $P5993
    new $P5921, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5921, control_5920
    push_eh $P5921
    .lex "self", param_5922
    .lex "$/", param_5923
    if has_param_5924, optparam_2730
    new $P5925, "Undef"
    set param_5924, $P5925
  optparam_2730:
    .lex "$key", param_5924
.annotate 'line', 2142
    $P5926 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5926
.annotate 'line', 2143
    new $P5927, "Undef"
    .lex "$name", $P5927
.annotate 'line', 2144
    new $P5928, "Undef"
    .lex "$past", $P5928
.annotate 'line', 2142
    get_hll_global $P5929, "GLOBAL"
    nqp_get_package_through_who $P5930, $P5929, "Regex"
    nqp_get_package_through_who $P5931, $P5930, "P6Regex"
    nqp_get_package_through_who $P5932, $P5931, "Actions"
    get_who $P5933, $P5932
    set $P5934, $P5933["@MODIFIERS"]
    unless_null $P5934, vivify_2731
    $P5934 = root_new ['parrot';'ResizablePMCArray']
  vivify_2731:
    store_lex "@MODIFIERS", $P5934
.annotate 'line', 2143
    find_lex $P5935, "$/"
    unless_null $P5935, vivify_2732
    $P5935 = root_new ['parrot';'Hash']
  vivify_2732:
    set $P5936, $P5935["deflongname"]
    unless_null $P5936, vivify_2733
    new $P5936, "Undef"
  vivify_2733:
    $P5937 = $P5936."ast"()
    set $S5938, $P5937
    new $P5939, 'String'
    set $P5939, $S5938
    store_lex "$name", $P5939
    find_lex $P5940, "$past"
    unless_null $P5940, vivify_2734
    new $P5940, "Undef"
  vivify_2734:
.annotate 'line', 2145
    find_lex $P5942, "$/"
    unless_null $P5942, vivify_2735
    $P5942 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P5943, $P5942["proto"]
    unless_null $P5943, vivify_2736
    new $P5943, "Undef"
  vivify_2736:
    if $P5943, if_5941
.annotate 'line', 2175
    find_lex $P6009, "$key"
    unless_null $P6009, vivify_2737
    new $P6009, "Undef"
  vivify_2737:
    set $S6010, $P6009
    iseq $I6011, $S6010, "open"
    if $I6011, if_6008
.annotate 'line', 2185
    .const 'Sub' $P6051 = "558_1304523757.895" 
    capture_lex $P6051
    $P6051()
    goto if_6008_end
  if_6008:
.annotate 'line', 2175
    .const 'Sub' $P6013 = "557_1304523757.895" 
    capture_lex $P6013
    $P6013()
  if_6008_end:
    goto if_5941_end
  if_5941:
.annotate 'line', 2147
    get_hll_global $P5944, "GLOBAL"
    nqp_get_package_through_who $P5945, $P5944, "PAST"
    get_who $P5946, $P5945
    set $P5947, $P5946["Stmts"]
.annotate 'line', 2148
    get_hll_global $P5948, "GLOBAL"
    nqp_get_package_through_who $P5949, $P5948, "PAST"
    get_who $P5950, $P5949
    set $P5951, $P5950["Block"]
    find_lex $P5952, "$name"
    unless_null $P5952, vivify_2787
    new $P5952, "Undef"
  vivify_2787:
.annotate 'line', 2149
    get_hll_global $P5953, "GLOBAL"
    nqp_get_package_through_who $P5954, $P5953, "PAST"
    get_who $P5955, $P5954
    set $P5956, $P5955["Op"]
.annotate 'line', 2150
    get_hll_global $P5957, "GLOBAL"
    nqp_get_package_through_who $P5958, $P5957, "PAST"
    get_who $P5959, $P5958
    set $P5960, $P5959["Var"]
    $P5961 = $P5960."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5962, "$name"
    unless_null $P5962, vivify_2788
    new $P5962, "Undef"
  vivify_2788:
    $P5963 = $P5956."new"($P5961, $P5962, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2149
    find_lex $P5964, "$/"
    unless_null $P5964, vivify_2789
    new $P5964, "Undef"
  vivify_2789:
    $P5965 = $P5951."new"($P5963, $P5952 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5964 :named("node"))
.annotate 'line', 2159
    get_hll_global $P5966, "GLOBAL"
    nqp_get_package_through_who $P5967, $P5966, "PAST"
    get_who $P5968, $P5967
    set $P5969, $P5968["Block"]
    new $P5970, "String"
    assign $P5970, "!PREFIX__"
    find_lex $P5971, "$name"
    unless_null $P5971, vivify_2790
    new $P5971, "Undef"
  vivify_2790:
    concat $P5972, $P5970, $P5971
.annotate 'line', 2160
    get_hll_global $P5973, "GLOBAL"
    nqp_get_package_through_who $P5974, $P5973, "PAST"
    get_who $P5975, $P5974
    set $P5976, $P5975["Op"]
.annotate 'line', 2161
    get_hll_global $P5977, "GLOBAL"
    nqp_get_package_through_who $P5978, $P5977, "PAST"
    get_who $P5979, $P5978
    set $P5980, $P5979["Var"]
    $P5981 = $P5980."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5982, "$name"
    unless_null $P5982, vivify_2791
    new $P5982, "Undef"
  vivify_2791:
    $P5983 = $P5976."new"($P5981, $P5982, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2160
    find_lex $P5984, "$/"
    unless_null $P5984, vivify_2792
    new $P5984, "Undef"
  vivify_2792:
    $P5985 = $P5969."new"($P5983, $P5972 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5984 :named("node"))
.annotate 'line', 2159
    $P5986 = $P5947."new"($P5965, $P5985)
.annotate 'line', 2147
    store_lex "$past", $P5986
.annotate 'line', 2171
    find_lex $P5988, "$past"
    unless_null $P5988, vivify_2793
    new $P5988, "Undef"
  vivify_2793:
    $P5989 = $P5988."list"()
    defined $I5990, $P5989
    unless $I5990, for_undef_2794
    iter $P5987, $P5989
    new $P6006, 'ExceptionHandler'
    set_label $P6006, loop6005_handler
    $P6006."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6006
  loop6005_test:
    unless $P5987, loop6005_done
    shift $P5991, $P5987
  loop6005_redo:
    .const 'Sub' $P5993 = "556_1304523757.895" 
    capture_lex $P5993
    $P5993($P5991)
  loop6005_next:
    goto loop6005_test
  loop6005_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6007, exception, 'type'
    eq $P6007, .CONTROL_LOOP_NEXT, loop6005_next
    eq $P6007, .CONTROL_LOOP_REDO, loop6005_redo
  loop6005_done:
    pop_eh 
  for_undef_2794:
  if_5941_end:
.annotate 'line', 2216
    find_lex $P6144, "$/"
    find_lex $P6145, "$past"
    unless_null $P6145, vivify_2801
    new $P6145, "Undef"
  vivify_2801:
    $P6146 = $P6144."!make"($P6145)
.annotate 'line', 2141
    .return ($P6146)
  control_5920:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6147, exception, "payload"
    .return ($P6147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6050"  :anon :subid("558_1304523757.895") :outer("555_1304523757.895")
.annotate 'line', 2185
    .const 'Sub' $P6083 = "559_1304523757.895" 
    capture_lex $P6083
.annotate 'line', 2186
    new $P6052, "Undef"
    .lex "$regex", $P6052
.annotate 'line', 2189
    new $P6053, "Undef"
    .lex "$prefix_meth", $P6053
.annotate 'line', 2187
    get_hll_global $P6054, "GLOBAL"
    nqp_get_package_through_who $P6055, $P6054, "Regex"
    nqp_get_package_through_who $P6056, $P6055, "P6Regex"
    nqp_get_package_through_who $P6057, $P6056, "Actions"
    get_who $P6058, $P6057
    set $P6059, $P6058["buildsub"]
    find_lex $P6060, "$/"
    unless_null $P6060, vivify_2738
    $P6060 = root_new ['parrot';'Hash']
  vivify_2738:
    set $P6061, $P6060["p6regex"]
    unless_null $P6061, vivify_2739
    new $P6061, "Undef"
  vivify_2739:
    $P6062 = $P6061."ast"()
    find_lex $P6063, "$?PACKAGE"
    get_who $P6064, $P6063
    set $P6065, $P6064["@BLOCK"]
    unless_null $P6065, vivify_2740
    $P6065 = root_new ['parrot';'ResizablePMCArray']
  vivify_2740:
    $P6066 = $P6065."shift"()
    $P6067 = $P6059($P6062, $P6066)
    store_lex "$regex", $P6067
.annotate 'line', 2188
    find_lex $P6068, "$regex"
    unless_null $P6068, vivify_2741
    new $P6068, "Undef"
  vivify_2741:
    find_lex $P6069, "$name"
    unless_null $P6069, vivify_2742
    new $P6069, "Undef"
  vivify_2742:
    $P6068."name"($P6069)
    find_lex $P6070, "$prefix_meth"
    unless_null $P6070, vivify_2743
    new $P6070, "Undef"
  vivify_2743:
.annotate 'line', 2191
    find_dynamic_lex $P6076, "$*PKGDECL"
    unless_null $P6076, vivify_2744
    get_hll_global $P6074, "GLOBAL"
    get_who $P6075, $P6074
    set $P6076, $P6075["$PKGDECL"]
    unless_null $P6076, vivify_2745
    die "Contextual $*PKGDECL not found"
  vivify_2745:
  vivify_2744:
    if $P6076, if_6073
    set $P6072, $P6076
    goto if_6073_end
  if_6073:
    find_dynamic_lex $P6079, "$*PACKAGE"
    unless_null $P6079, vivify_2746
    get_hll_global $P6077, "GLOBAL"
    get_who $P6078, $P6077
    set $P6079, $P6078["$PACKAGE"]
    unless_null $P6079, vivify_2747
    die "Contextual $*PACKAGE not found"
  vivify_2747:
  vivify_2746:
    get_how $P6080, $P6079
    can $I6081, $P6080, "add_method"
    new $P6072, 'Integer'
    set $P6072, $I6081
  if_6073_end:
    unless $P6072, if_6071_end
    .const 'Sub' $P6083 = "559_1304523757.895" 
    capture_lex $P6083
    $P6083()
  if_6071_end:
.annotate 'line', 2206
    get_hll_global $P6121, "GLOBAL"
    nqp_get_package_through_who $P6122, $P6121, "PAST"
    get_who $P6123, $P6122
    set $P6124, $P6123["Op"]
.annotate 'line', 2208
    new $P6125, "ResizablePMCArray"
    push $P6125, "Regex"
    push $P6125, "Method"
    find_lex $P6126, "$/"
    unless_null $P6126, vivify_2764
    new $P6126, "Undef"
  vivify_2764:
    $P6127 = "lexical_package_lookup"($P6125, $P6126)
    find_lex $P6128, "$regex"
    unless_null $P6128, vivify_2765
    new $P6128, "Undef"
  vivify_2765:
    $P6129 = $P6124."new"($P6127, $P6128, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2206
    store_lex "$past", $P6129
.annotate 'line', 2211
    find_lex $P6132, "$prefix_meth"
    unless_null $P6132, vivify_2766
    new $P6132, "Undef"
  vivify_2766:
    if $P6132, if_6131
    find_lex $P6140, "$regex"
    unless_null $P6140, vivify_2767
    new $P6140, "Undef"
  vivify_2767:
    set $P6130, $P6140
    goto if_6131_end
  if_6131:
.annotate 'line', 2212
    get_hll_global $P6133, "GLOBAL"
    nqp_get_package_through_who $P6134, $P6133, "PAST"
    get_who $P6135, $P6134
    set $P6136, $P6135["Stmts"]
    find_lex $P6137, "$regex"
    unless_null $P6137, vivify_2768
    new $P6137, "Undef"
  vivify_2768:
    find_lex $P6138, "$prefix_meth"
    unless_null $P6138, vivify_2769
    new $P6138, "Undef"
  vivify_2769:
    $P6139 = $P6136."new"($P6137, $P6138)
    set $P6130, $P6139
  if_6131_end:
.annotate 'line', 2211
    find_lex $P6141, "$past"
    unless_null $P6141, vivify_2770
    $P6141 = root_new ['parrot';'Hash']
    store_lex "$past", $P6141
  vivify_2770:
    set $P6141["sink"], $P6130
.annotate 'line', 2214
    find_lex $P6142, "@MODIFIERS"
    unless_null $P6142, vivify_2771
    $P6142 = root_new ['parrot';'ResizablePMCArray']
  vivify_2771:
    $P6143 = $P6142."shift"()
.annotate 'line', 2185
    .return ($P6143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6082"  :anon :subid("559_1304523757.895") :outer("558_1304523757.895")
.annotate 'line', 2196
    $P6084 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P6084
.annotate 'line', 2193
    find_dynamic_lex $P6087, "$*SC"
    unless_null $P6087, vivify_2748
    get_hll_global $P6085, "GLOBAL"
    get_who $P6086, $P6085
    set $P6087, $P6086["$SC"]
    unless_null $P6087, vivify_2749
    die "Contextual $*SC not found"
  vivify_2749:
  vivify_2748:
    find_dynamic_lex $P6090, "$*PACKAGE"
    unless_null $P6090, vivify_2750
    get_hll_global $P6088, "GLOBAL"
    get_who $P6089, $P6088
    set $P6090, $P6089["$PACKAGE"]
    unless_null $P6090, vivify_2751
    die "Contextual $*PACKAGE not found"
  vivify_2751:
  vivify_2750:
    find_lex $P6091, "$name"
    unless_null $P6091, vivify_2752
    new $P6091, "Undef"
  vivify_2752:
    find_lex $P6092, "$regex"
    unless_null $P6092, vivify_2753
    new $P6092, "Undef"
  vivify_2753:
    $P6087."pkg_add_method"($P6090, "add_method", $P6091, $P6092, 0)
.annotate 'line', 2196
    find_lex $P6093, "$/"
    unless_null $P6093, vivify_2754
    $P6093 = root_new ['parrot';'Hash']
  vivify_2754:
    set $P6094, $P6093["p6regex"]
    unless_null $P6094, vivify_2755
    new $P6094, "Undef"
  vivify_2755:
    $P6095 = $P6094."ast"()
    $P6096 = $P6095."prefix_list"()
    store_lex "@prefixes", $P6096
.annotate 'line', 2197
    get_hll_global $P6097, "GLOBAL"
    nqp_get_package_through_who $P6098, $P6097, "PAST"
    get_who $P6099, $P6098
    set $P6100, $P6099["Block"]
.annotate 'line', 2198
    new $P6101, "String"
    assign $P6101, "!PREFIX__"
    find_lex $P6102, "$name"
    unless_null $P6102, vivify_2756
    new $P6102, "Undef"
  vivify_2756:
    concat $P6103, $P6101, $P6102
.annotate 'line', 2199
    get_hll_global $P6104, "GLOBAL"
    nqp_get_package_through_who $P6105, $P6104, "PAST"
    get_who $P6106, $P6105
    set $P6107, $P6106["Op"]
    find_lex $P6108, "@prefixes"
    unless_null $P6108, vivify_2757
    $P6108 = root_new ['parrot';'ResizablePMCArray']
  vivify_2757:
    $P6109 = $P6107."new"($P6108 :flat, "list" :named("pasttype"))
    $P6110 = $P6100."new"($P6109, $P6103 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2197
    store_lex "$prefix_meth", $P6110
.annotate 'line', 2201
    find_dynamic_lex $P6113, "$*SC"
    unless_null $P6113, vivify_2758
    get_hll_global $P6111, "GLOBAL"
    get_who $P6112, $P6111
    set $P6113, $P6112["$SC"]
    unless_null $P6113, vivify_2759
    die "Contextual $*SC not found"
  vivify_2759:
  vivify_2758:
    find_dynamic_lex $P6116, "$*PACKAGE"
    unless_null $P6116, vivify_2760
    get_hll_global $P6114, "GLOBAL"
    get_who $P6115, $P6114
    set $P6116, $P6115["$PACKAGE"]
    unless_null $P6116, vivify_2761
    die "Contextual $*PACKAGE not found"
  vivify_2761:
  vivify_2760:
    find_lex $P6117, "$prefix_meth"
    unless_null $P6117, vivify_2762
    new $P6117, "Undef"
  vivify_2762:
    $P6118 = $P6117."name"()
    find_lex $P6119, "$prefix_meth"
    unless_null $P6119, vivify_2763
    new $P6119, "Undef"
  vivify_2763:
    $P6120 = $P6113."pkg_add_method"($P6116, "add_method", $P6118, $P6119, 0)
.annotate 'line', 2191
    .return ($P6120)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6012"  :anon :subid("557_1304523757.895") :outer("555_1304523757.895")
.annotate 'line', 2176
    $P6014 = root_new ['parrot';'Hash']
    .lex "%h", $P6014
.annotate 'line', 2175
    find_lex $P6015, "%h"
    unless_null $P6015, vivify_2772
    $P6015 = root_new ['parrot';'Hash']
  vivify_2772:
.annotate 'line', 2177
    find_lex $P6017, "$/"
    unless_null $P6017, vivify_2773
    $P6017 = root_new ['parrot';'Hash']
  vivify_2773:
    set $P6018, $P6017["sym"]
    unless_null $P6018, vivify_2774
    new $P6018, "Undef"
  vivify_2774:
    set $S6019, $P6018
    iseq $I6020, $S6019, "token"
    unless $I6020, if_6016_end
    new $P6021, "Integer"
    assign $P6021, 1
    find_lex $P6022, "%h"
    unless_null $P6022, vivify_2775
    $P6022 = root_new ['parrot';'Hash']
    store_lex "%h", $P6022
  vivify_2775:
    set $P6022["r"], $P6021
  if_6016_end:
.annotate 'line', 2178
    find_lex $P6024, "$/"
    unless_null $P6024, vivify_2776
    $P6024 = root_new ['parrot';'Hash']
  vivify_2776:
    set $P6025, $P6024["sym"]
    unless_null $P6025, vivify_2777
    new $P6025, "Undef"
  vivify_2777:
    set $S6026, $P6025
    iseq $I6027, $S6026, "rule"
    unless $I6027, if_6023_end
    new $P6028, "Integer"
    assign $P6028, 1
    find_lex $P6029, "%h"
    unless_null $P6029, vivify_2778
    $P6029 = root_new ['parrot';'Hash']
    store_lex "%h", $P6029
  vivify_2778:
    set $P6029["r"], $P6028
    new $P6030, "Integer"
    assign $P6030, 1
    find_lex $P6031, "%h"
    unless_null $P6031, vivify_2779
    $P6031 = root_new ['parrot';'Hash']
    store_lex "%h", $P6031
  vivify_2779:
    set $P6031["s"], $P6030
  if_6023_end:
.annotate 'line', 2179
    find_lex $P6032, "@MODIFIERS"
    unless_null $P6032, vivify_2780
    $P6032 = root_new ['parrot';'ResizablePMCArray']
  vivify_2780:
    find_lex $P6033, "%h"
    unless_null $P6033, vivify_2781
    $P6033 = root_new ['parrot';'Hash']
  vivify_2781:
    $P6032."unshift"($P6033)
.annotate 'line', 2180
    find_lex $P6034, "$name"
    unless_null $P6034, vivify_2782
    new $P6034, "Undef"
  vivify_2782:
    get_hll_global $P6035, "GLOBAL"
    nqp_get_package_through_who $P6036, $P6035, "Regex"
    nqp_get_package_through_who $P6037, $P6036, "P6Regex"
    nqp_get_package_through_who $P6038, $P6037, "Actions"
    get_who $P6039, $P6038
    set $P6039["$REGEXNAME"], $P6034
.annotate 'line', 2181
    find_lex $P6040, "$?PACKAGE"
    get_who $P6041, $P6040
    set $P6042, $P6041["@BLOCK"]
    unless_null $P6042, vivify_2783
    $P6042 = root_new ['parrot';'ResizablePMCArray']
  vivify_2783:
    set $P6043, $P6042[0]
    unless_null $P6043, vivify_2784
    new $P6043, "Undef"
  vivify_2784:
    $P6043."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2182
    find_lex $P6044, "$?PACKAGE"
    get_who $P6045, $P6044
    set $P6046, $P6045["@BLOCK"]
    unless_null $P6046, vivify_2785
    $P6046 = root_new ['parrot';'ResizablePMCArray']
  vivify_2785:
    set $P6047, $P6046[0]
    unless_null $P6047, vivify_2786
    new $P6047, "Undef"
  vivify_2786:
    $P6047."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2183
    new $P6048, "Exception"
    set $P6048['type'], .CONTROL_RETURN
    new $P6049, "Integer"
    assign $P6049, 0
    setattribute $P6048, 'payload', $P6049
    throw $P6048
.annotate 'line', 2175
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5992"  :anon :subid("556_1304523757.895") :outer("555_1304523757.895")
    .param pmc param_5994
.annotate 'line', 2171
    .lex "$_", param_5994
.annotate 'line', 2172
    find_dynamic_lex $P5997, "$*SC"
    unless_null $P5997, vivify_2795
    get_hll_global $P5995, "GLOBAL"
    get_who $P5996, $P5995
    set $P5997, $P5996["$SC"]
    unless_null $P5997, vivify_2796
    die "Contextual $*SC not found"
  vivify_2796:
  vivify_2795:
    find_dynamic_lex $P6000, "$*PACKAGE"
    unless_null $P6000, vivify_2797
    get_hll_global $P5998, "GLOBAL"
    get_who $P5999, $P5998
    set $P6000, $P5999["$PACKAGE"]
    unless_null $P6000, vivify_2798
    die "Contextual $*PACKAGE not found"
  vivify_2798:
  vivify_2797:
    find_lex $P6001, "$_"
    unless_null $P6001, vivify_2799
    new $P6001, "Undef"
  vivify_2799:
    $P6002 = $P6001."name"()
    find_lex $P6003, "$_"
    unless_null $P6003, vivify_2800
    new $P6003, "Undef"
  vivify_2800:
    $P6004 = $P5997."pkg_add_method"($P6000, "add_method", $P6002, $P6003, 0)
.annotate 'line', 2171
    .return ($P6004)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("560_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6149
    .param pmc param_6150
.annotate 'line', 2220
    .lex "self", param_6149
    .lex "$/", param_6150
.annotate 'line', 2221
    new $P6151, "Undef"
    .lex "$past", $P6151
    find_lex $P6154, "$/"
    unless_null $P6154, vivify_2802
    $P6154 = root_new ['parrot';'Hash']
  vivify_2802:
    set $P6155, $P6154["args"]
    unless_null $P6155, vivify_2803
    new $P6155, "Undef"
  vivify_2803:
    if $P6155, if_6153
    get_hll_global $P6160, "GLOBAL"
    nqp_get_package_through_who $P6161, $P6160, "PAST"
    get_who $P6162, $P6161
    set $P6163, $P6162["Op"]
    find_lex $P6164, "$/"
    unless_null $P6164, vivify_2804
    new $P6164, "Undef"
  vivify_2804:
    $P6165 = $P6163."new"($P6164 :named("node"))
    set $P6152, $P6165
    goto if_6153_end
  if_6153:
    find_lex $P6156, "$/"
    unless_null $P6156, vivify_2805
    $P6156 = root_new ['parrot';'Hash']
  vivify_2805:
    set $P6157, $P6156["args"]
    unless_null $P6157, vivify_2806
    $P6157 = root_new ['parrot';'ResizablePMCArray']
  vivify_2806:
    set $P6158, $P6157[0]
    unless_null $P6158, vivify_2807
    new $P6158, "Undef"
  vivify_2807:
    $P6159 = $P6158."ast"()
    set $P6152, $P6159
  if_6153_end:
    store_lex "$past", $P6152
.annotate 'line', 2222
    find_lex $P6167, "$/"
    unless_null $P6167, vivify_2808
    $P6167 = root_new ['parrot';'Hash']
  vivify_2808:
    set $P6168, $P6167["quote"]
    unless_null $P6168, vivify_2809
    new $P6168, "Undef"
  vivify_2809:
    if $P6168, if_6166
.annotate 'line', 2226
    find_lex $P6175, "$/"
    unless_null $P6175, vivify_2810
    $P6175 = root_new ['parrot';'Hash']
  vivify_2810:
    set $P6176, $P6175["longname"]
    unless_null $P6176, vivify_2811
    new $P6176, "Undef"
  vivify_2811:
    set $S6177, $P6176
    iseq $I6178, $S6177, "HOW"
    if $I6178, if_6174
.annotate 'line', 2229
    find_lex $P6181, "$/"
    unless_null $P6181, vivify_2812
    $P6181 = root_new ['parrot';'Hash']
  vivify_2812:
    set $P6182, $P6181["longname"]
    unless_null $P6182, vivify_2813
    new $P6182, "Undef"
  vivify_2813:
    set $S6183, $P6182
    iseq $I6184, $S6183, "WHAT"
    if $I6184, if_6180
.annotate 'line', 2232
    find_lex $P6187, "$/"
    unless_null $P6187, vivify_2814
    $P6187 = root_new ['parrot';'Hash']
  vivify_2814:
    set $P6188, $P6187["longname"]
    unless_null $P6188, vivify_2815
    new $P6188, "Undef"
  vivify_2815:
    set $S6189, $P6188
    iseq $I6190, $S6189, "WHO"
    if $I6190, if_6186
.annotate 'line', 2236
    find_lex $P6192, "$past"
    unless_null $P6192, vivify_2816
    new $P6192, "Undef"
  vivify_2816:
    find_lex $P6193, "$/"
    unless_null $P6193, vivify_2817
    $P6193 = root_new ['parrot';'Hash']
  vivify_2817:
    set $P6194, $P6193["longname"]
    unless_null $P6194, vivify_2818
    new $P6194, "Undef"
  vivify_2818:
    set $S6195, $P6194
    $P6192."name"($S6195)
.annotate 'line', 2237
    find_lex $P6196, "$past"
    unless_null $P6196, vivify_2819
    new $P6196, "Undef"
  vivify_2819:
    $P6196."pasttype"("callmethod")
.annotate 'line', 2235
    goto if_6186_end
  if_6186:
.annotate 'line', 2233
    find_lex $P6191, "$past"
    unless_null $P6191, vivify_2820
    new $P6191, "Undef"
  vivify_2820:
    $P6191."pirop"("get_who PP")
  if_6186_end:
.annotate 'line', 2232
    goto if_6180_end
  if_6180:
.annotate 'line', 2230
    find_lex $P6185, "$past"
    unless_null $P6185, vivify_2821
    new $P6185, "Undef"
  vivify_2821:
    $P6185."pirop"("get_what PP")
  if_6180_end:
.annotate 'line', 2229
    goto if_6174_end
  if_6174:
.annotate 'line', 2227
    find_lex $P6179, "$past"
    unless_null $P6179, vivify_2822
    new $P6179, "Undef"
  vivify_2822:
    $P6179."pirop"("get_how PP")
  if_6174_end:
.annotate 'line', 2226
    goto if_6166_end
  if_6166:
.annotate 'line', 2223
    find_lex $P6169, "$past"
    unless_null $P6169, vivify_2823
    new $P6169, "Undef"
  vivify_2823:
    find_lex $P6170, "$/"
    unless_null $P6170, vivify_2824
    $P6170 = root_new ['parrot';'Hash']
  vivify_2824:
    set $P6171, $P6170["quote"]
    unless_null $P6171, vivify_2825
    new $P6171, "Undef"
  vivify_2825:
    $P6172 = $P6171."ast"()
    $P6169."name"($P6172)
.annotate 'line', 2224
    find_lex $P6173, "$past"
    unless_null $P6173, vivify_2826
    new $P6173, "Undef"
  vivify_2826:
    $P6173."pasttype"("callmethod")
  if_6166_end:
.annotate 'line', 2239
    find_lex $P6197, "$/"
    find_lex $P6198, "$past"
    unless_null $P6198, vivify_2827
    new $P6198, "Undef"
  vivify_2827:
    $P6199 = $P6197."!make"($P6198)
.annotate 'line', 2220
    .return ($P6199)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("561_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6201
    .param pmc param_6202
.annotate 'line', 2244
    .lex "self", param_6201
    .lex "$/", param_6202
.annotate 'line', 2245
    find_lex $P6203, "$/"
    get_hll_global $P6204, "GLOBAL"
    nqp_get_package_through_who $P6205, $P6204, "PAST"
    get_who $P6206, $P6205
    set $P6207, $P6206["Var"]
    $P6208 = $P6207."new"("self" :named("name"))
    $P6209 = $P6203."!make"($P6208)
.annotate 'line', 2244
    .return ($P6209)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("562_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6211
    .param pmc param_6212
.annotate 'line', 2248
    .lex "self", param_6211
    .lex "$/", param_6212
.annotate 'line', 2249
    new $P6213, "Undef"
    .lex "$past", $P6213
    find_lex $P6214, "$/"
    unless_null $P6214, vivify_2828
    $P6214 = root_new ['parrot';'Hash']
  vivify_2828:
    set $P6215, $P6214["args"]
    unless_null $P6215, vivify_2829
    new $P6215, "Undef"
  vivify_2829:
    $P6216 = $P6215."ast"()
    store_lex "$past", $P6216
.annotate 'line', 2250
    find_lex $P6217, "$past"
    unless_null $P6217, vivify_2830
    new $P6217, "Undef"
  vivify_2830:
    find_lex $P6218, "$/"
    unless_null $P6218, vivify_2831
    $P6218 = root_new ['parrot';'Hash']
  vivify_2831:
    set $P6219, $P6218["deflongname"]
    unless_null $P6219, vivify_2832
    new $P6219, "Undef"
  vivify_2832:
    set $S6220, $P6219
    $P6217."name"($S6220)
.annotate 'line', 2251
    find_lex $P6221, "$/"
    find_lex $P6222, "$past"
    unless_null $P6222, vivify_2833
    new $P6222, "Undef"
  vivify_2833:
    $P6223 = $P6221."!make"($P6222)
.annotate 'line', 2248
    .return ($P6223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("563_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6225
    .param pmc param_6226
.annotate 'line', 2254
    .const 'Sub' $P6244 = "564_1304523757.895" 
    capture_lex $P6244
    .lex "self", param_6225
    .lex "$/", param_6226
.annotate 'line', 2256
    new $P6227, "Undef"
    .lex "$var", $P6227
.annotate 'line', 2266
    new $P6228, "Undef"
    .lex "$past", $P6228
.annotate 'line', 2254
    find_lex $P6229, "$var"
    unless_null $P6229, vivify_2834
    new $P6229, "Undef"
  vivify_2834:
.annotate 'line', 2257
    find_lex $P6231, "$/"
    unless_null $P6231, vivify_2835
    $P6231 = root_new ['parrot';'Hash']
  vivify_2835:
    set $P6232, $P6231["name"]
    unless_null $P6232, vivify_2836
    new $P6232, "Undef"
  vivify_2836:
    set $S6233, $P6232
    $P6234 = "is_lexical"($S6233)
    if $P6234, if_6230
.annotate 'line', 2260
    .const 'Sub' $P6244 = "564_1304523757.895" 
    capture_lex $P6244
    $P6244()
    goto if_6230_end
  if_6230:
.annotate 'line', 2258
    get_hll_global $P6235, "GLOBAL"
    nqp_get_package_through_who $P6236, $P6235, "PAST"
    get_who $P6237, $P6236
    set $P6238, $P6237["Var"]
    find_lex $P6239, "$/"
    unless_null $P6239, vivify_2842
    $P6239 = root_new ['parrot';'Hash']
  vivify_2842:
    set $P6240, $P6239["name"]
    unless_null $P6240, vivify_2843
    new $P6240, "Undef"
  vivify_2843:
    set $S6241, $P6240
    $P6242 = $P6238."new"($S6241 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6242
  if_6230_end:
.annotate 'line', 2266
    find_lex $P6253, "$var"
    unless_null $P6253, vivify_2844
    new $P6253, "Undef"
  vivify_2844:
    store_lex "$past", $P6253
.annotate 'line', 2267
    find_lex $P6255, "$/"
    unless_null $P6255, vivify_2845
    $P6255 = root_new ['parrot';'Hash']
  vivify_2845:
    set $P6256, $P6255["args"]
    unless_null $P6256, vivify_2846
    new $P6256, "Undef"
  vivify_2846:
    unless $P6256, if_6254_end
.annotate 'line', 2268
    find_lex $P6257, "$/"
    unless_null $P6257, vivify_2847
    $P6257 = root_new ['parrot';'Hash']
  vivify_2847:
    set $P6258, $P6257["args"]
    unless_null $P6258, vivify_2848
    $P6258 = root_new ['parrot';'ResizablePMCArray']
  vivify_2848:
    set $P6259, $P6258[0]
    unless_null $P6259, vivify_2849
    new $P6259, "Undef"
  vivify_2849:
    $P6260 = $P6259."ast"()
    store_lex "$past", $P6260
.annotate 'line', 2269
    find_lex $P6261, "$past"
    unless_null $P6261, vivify_2850
    new $P6261, "Undef"
  vivify_2850:
    find_lex $P6262, "$var"
    unless_null $P6262, vivify_2851
    new $P6262, "Undef"
  vivify_2851:
    $P6261."unshift"($P6262)
  if_6254_end:
.annotate 'line', 2271
    find_lex $P6263, "$/"
    find_lex $P6264, "$past"
    unless_null $P6264, vivify_2852
    new $P6264, "Undef"
  vivify_2852:
    $P6265 = $P6263."!make"($P6264)
.annotate 'line', 2254
    .return ($P6265)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6243"  :anon :subid("564_1304523757.895") :outer("563_1304523757.895")
.annotate 'line', 2261
    $P6245 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6245
    find_lex $P6246, "$/"
    unless_null $P6246, vivify_2837
    $P6246 = root_new ['parrot';'Hash']
  vivify_2837:
    set $P6247, $P6246["name"]
    unless_null $P6247, vivify_2838
    $P6247 = root_new ['parrot';'Hash']
  vivify_2838:
    set $P6248, $P6247["identifier"]
    unless_null $P6248, vivify_2839
    new $P6248, "Undef"
  vivify_2839:
    clone $P6249, $P6248
    store_lex "@ns", $P6249
.annotate 'line', 2262
    find_lex $P6250, "@ns"
    unless_null $P6250, vivify_2840
    $P6250 = root_new ['parrot';'ResizablePMCArray']
  vivify_2840:
    find_lex $P6251, "$/"
    unless_null $P6251, vivify_2841
    new $P6251, "Undef"
  vivify_2841:
    $P6252 = "lexical_package_lookup"($P6250, $P6251)
    store_lex "$var", $P6252
.annotate 'line', 2260
    .return ($P6252)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("565_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6267
    .param pmc param_6268
.annotate 'line', 2274
    .lex "self", param_6267
    .lex "$/", param_6268
.annotate 'line', 2275
    new $P6269, "Undef"
    .lex "$past", $P6269
.annotate 'line', 2276
    new $P6270, "Undef"
    .lex "$pirop", $P6270
.annotate 'line', 2275
    find_lex $P6273, "$/"
    unless_null $P6273, vivify_2853
    $P6273 = root_new ['parrot';'Hash']
  vivify_2853:
    set $P6274, $P6273["args"]
    unless_null $P6274, vivify_2854
    new $P6274, "Undef"
  vivify_2854:
    if $P6274, if_6272
    get_hll_global $P6279, "GLOBAL"
    nqp_get_package_through_who $P6280, $P6279, "PAST"
    get_who $P6281, $P6280
    set $P6282, $P6281["Op"]
    find_lex $P6283, "$/"
    unless_null $P6283, vivify_2855
    new $P6283, "Undef"
  vivify_2855:
    $P6284 = $P6282."new"($P6283 :named("node"))
    set $P6271, $P6284
    goto if_6272_end
  if_6272:
    find_lex $P6275, "$/"
    unless_null $P6275, vivify_2856
    $P6275 = root_new ['parrot';'Hash']
  vivify_2856:
    set $P6276, $P6275["args"]
    unless_null $P6276, vivify_2857
    $P6276 = root_new ['parrot';'ResizablePMCArray']
  vivify_2857:
    set $P6277, $P6276[0]
    unless_null $P6277, vivify_2858
    new $P6277, "Undef"
  vivify_2858:
    $P6278 = $P6277."ast"()
    set $P6271, $P6278
  if_6272_end:
    store_lex "$past", $P6271
.annotate 'line', 2276
    find_lex $P6285, "$/"
    unless_null $P6285, vivify_2859
    $P6285 = root_new ['parrot';'Hash']
  vivify_2859:
    set $P6286, $P6285["op"]
    unless_null $P6286, vivify_2860
    new $P6286, "Undef"
  vivify_2860:
    set $S6287, $P6286
    new $P6288, 'String'
    set $P6288, $S6287
    store_lex "$pirop", $P6288
.annotate 'line', 2277
    find_lex $P6289, "$pirop"
    unless_null $P6289, vivify_2861
    new $P6289, "Undef"
  vivify_2861:
    set $S6290, $P6289
    split $P6291, "__", $S6290
    join $S6292, " ", $P6291
    new $P6293, 'String'
    set $P6293, $S6292
    store_lex "$pirop", $P6293
.annotate 'line', 2278
    find_lex $P6294, "$past"
    unless_null $P6294, vivify_2862
    new $P6294, "Undef"
  vivify_2862:
    find_lex $P6295, "$pirop"
    unless_null $P6295, vivify_2863
    new $P6295, "Undef"
  vivify_2863:
    $P6294."pirop"($P6295)
.annotate 'line', 2279
    find_lex $P6296, "$past"
    unless_null $P6296, vivify_2864
    new $P6296, "Undef"
  vivify_2864:
    $P6296."pasttype"("pirop")
.annotate 'line', 2280
    find_lex $P6297, "$/"
    find_lex $P6298, "$past"
    unless_null $P6298, vivify_2865
    new $P6298, "Undef"
  vivify_2865:
    $P6299 = $P6297."!make"($P6298)
.annotate 'line', 2274
    .return ($P6299)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("566_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6301
    .param pmc param_6302
.annotate 'line', 2283
    .lex "self", param_6301
    .lex "$/", param_6302
.annotate 'line', 2284
    find_lex $P6303, "$/"
    get_hll_global $P6304, "GLOBAL"
    nqp_get_package_through_who $P6305, $P6304, "PAST"
    get_who $P6306, $P6305
    set $P6307, $P6306["Op"]
    $P6308 = $P6307."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6309 = $P6303."!make"($P6308)
.annotate 'line', 2283
    .return ($P6309)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("567_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6311
    .param pmc param_6312
.annotate 'line', 2289
    .lex "self", param_6311
    .lex "$/", param_6312
    find_lex $P6313, "$/"
    find_lex $P6314, "$/"
    unless_null $P6314, vivify_2866
    $P6314 = root_new ['parrot';'Hash']
  vivify_2866:
    set $P6315, $P6314["arglist"]
    unless_null $P6315, vivify_2867
    new $P6315, "Undef"
  vivify_2867:
    $P6316 = $P6315."ast"()
    $P6317 = $P6313."!make"($P6316)
    .return ($P6317)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("568_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6319
    .param pmc param_6320
.annotate 'line', 2291
    .const 'Sub' $P6334 = "569_1304523757.895" 
    capture_lex $P6334
    .lex "self", param_6319
    .lex "$/", param_6320
.annotate 'line', 2292
    new $P6321, "Undef"
    .lex "$past", $P6321
.annotate 'line', 2300
    new $P6322, "Undef"
    .lex "$i", $P6322
.annotate 'line', 2301
    new $P6323, "Undef"
    .lex "$n", $P6323
.annotate 'line', 2292
    get_hll_global $P6324, "GLOBAL"
    nqp_get_package_through_who $P6325, $P6324, "PAST"
    get_who $P6326, $P6325
    set $P6327, $P6326["Op"]
    find_lex $P6328, "$/"
    unless_null $P6328, vivify_2868
    new $P6328, "Undef"
  vivify_2868:
    $P6329 = $P6327."new"("call" :named("pasttype"), $P6328 :named("node"))
    store_lex "$past", $P6329
.annotate 'line', 2293
    find_lex $P6331, "$/"
    unless_null $P6331, vivify_2869
    $P6331 = root_new ['parrot';'Hash']
  vivify_2869:
    set $P6332, $P6331["EXPR"]
    unless_null $P6332, vivify_2870
    new $P6332, "Undef"
  vivify_2870:
    unless $P6332, if_6330_end
    .const 'Sub' $P6334 = "569_1304523757.895" 
    capture_lex $P6334
    $P6334()
  if_6330_end:
.annotate 'line', 2300
    new $P6366, "Integer"
    assign $P6366, 0
    store_lex "$i", $P6366
.annotate 'line', 2301
    find_lex $P6367, "$past"
    unless_null $P6367, vivify_2881
    new $P6367, "Undef"
  vivify_2881:
    $P6368 = $P6367."list"()
    set $N6369, $P6368
    new $P6370, 'Float'
    set $P6370, $N6369
    store_lex "$n", $P6370
.annotate 'line', 2302
    new $P6421, 'ExceptionHandler'
    set_label $P6421, loop6420_handler
    $P6421."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6421
  loop6420_test:
    find_lex $P6371, "$i"
    unless_null $P6371, vivify_2882
    new $P6371, "Undef"
  vivify_2882:
    set $N6372, $P6371
    find_lex $P6373, "$n"
    unless_null $P6373, vivify_2883
    new $P6373, "Undef"
  vivify_2883:
    set $N6374, $P6373
    islt $I6375, $N6372, $N6374
    unless $I6375, loop6420_done
  loop6420_redo:
.annotate 'line', 2303
    find_lex $P6377, "$i"
    unless_null $P6377, vivify_2884
    new $P6377, "Undef"
  vivify_2884:
    set $I6378, $P6377
    find_lex $P6379, "$past"
    unless_null $P6379, vivify_2885
    $P6379 = root_new ['parrot';'ResizablePMCArray']
  vivify_2885:
    set $P6380, $P6379[$I6378]
    unless_null $P6380, vivify_2886
    new $P6380, "Undef"
  vivify_2886:
    $S6381 = $P6380."name"()
    iseq $I6382, $S6381, "&prefix:<|>"
    unless $I6382, if_6376_end
.annotate 'line', 2304
    find_lex $P6383, "$i"
    unless_null $P6383, vivify_2887
    new $P6383, "Undef"
  vivify_2887:
    set $I6384, $P6383
    find_lex $P6385, "$past"
    unless_null $P6385, vivify_2888
    $P6385 = root_new ['parrot';'ResizablePMCArray']
  vivify_2888:
    set $P6386, $P6385[$I6384]
    unless_null $P6386, vivify_2889
    $P6386 = root_new ['parrot';'ResizablePMCArray']
  vivify_2889:
    set $P6387, $P6386[0]
    unless_null $P6387, vivify_2890
    new $P6387, "Undef"
  vivify_2890:
    find_lex $P6388, "$i"
    unless_null $P6388, vivify_2891
    new $P6388, "Undef"
  vivify_2891:
    set $I6389, $P6388
    find_lex $P6390, "$past"
    unless_null $P6390, vivify_2892
    $P6390 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6390
  vivify_2892:
    set $P6390[$I6389], $P6387
.annotate 'line', 2305
    find_lex $P6391, "$i"
    unless_null $P6391, vivify_2893
    new $P6391, "Undef"
  vivify_2893:
    set $I6392, $P6391
    find_lex $P6393, "$past"
    unless_null $P6393, vivify_2894
    $P6393 = root_new ['parrot';'ResizablePMCArray']
  vivify_2894:
    set $P6394, $P6393[$I6392]
    unless_null $P6394, vivify_2895
    new $P6394, "Undef"
  vivify_2895:
    $P6394."flat"(1)
.annotate 'line', 2306
    find_lex $P6398, "$i"
    unless_null $P6398, vivify_2896
    new $P6398, "Undef"
  vivify_2896:
    set $I6399, $P6398
    find_lex $P6400, "$past"
    unless_null $P6400, vivify_2897
    $P6400 = root_new ['parrot';'ResizablePMCArray']
  vivify_2897:
    set $P6401, $P6400[$I6399]
    unless_null $P6401, vivify_2898
    new $P6401, "Undef"
  vivify_2898:
    get_hll_global $P6402, "GLOBAL"
    nqp_get_package_through_who $P6403, $P6402, "PAST"
    get_who $P6404, $P6403
    set $P6405, $P6404["Val"]
    $P6406 = $P6401."isa"($P6405)
    if $P6406, if_6397
    set $P6396, $P6406
    goto if_6397_end
  if_6397:
.annotate 'line', 2307
    find_lex $P6407, "$i"
    unless_null $P6407, vivify_2899
    new $P6407, "Undef"
  vivify_2899:
    set $I6408, $P6407
    find_lex $P6409, "$past"
    unless_null $P6409, vivify_2900
    $P6409 = root_new ['parrot';'ResizablePMCArray']
  vivify_2900:
    set $P6410, $P6409[$I6408]
    unless_null $P6410, vivify_2901
    new $P6410, "Undef"
  vivify_2901:
    $S6411 = $P6410."name"()
    substr $S6412, $S6411, 0, 1
    iseq $I6413, $S6412, "%"
    new $P6396, 'Integer'
    set $P6396, $I6413
  if_6397_end:
    unless $P6396, if_6395_end
.annotate 'line', 2308
    find_lex $P6414, "$i"
    unless_null $P6414, vivify_2902
    new $P6414, "Undef"
  vivify_2902:
    set $I6415, $P6414
    find_lex $P6416, "$past"
    unless_null $P6416, vivify_2903
    $P6416 = root_new ['parrot';'ResizablePMCArray']
  vivify_2903:
    set $P6417, $P6416[$I6415]
    unless_null $P6417, vivify_2904
    new $P6417, "Undef"
  vivify_2904:
    $P6417."named"(1)
  if_6395_end:
  if_6376_end:
.annotate 'line', 2303
    find_lex $P6418, "$i"
    unless_null $P6418, vivify_2905
    new $P6418, "Undef"
  vivify_2905:
    clone $P6419, $P6418
    inc $P6418
  loop6420_next:
.annotate 'line', 2302
    goto loop6420_test
  loop6420_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6422, exception, 'type'
    eq $P6422, .CONTROL_LOOP_NEXT, loop6420_next
    eq $P6422, .CONTROL_LOOP_REDO, loop6420_redo
  loop6420_done:
    pop_eh 
.annotate 'line', 2313
    find_lex $P6423, "$/"
    find_lex $P6424, "$past"
    unless_null $P6424, vivify_2906
    new $P6424, "Undef"
  vivify_2906:
    $P6425 = $P6423."!make"($P6424)
.annotate 'line', 2291
    .return ($P6425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6333"  :anon :subid("569_1304523757.895") :outer("568_1304523757.895")
.annotate 'line', 2293
    .const 'Sub' $P6355 = "570_1304523757.895" 
    capture_lex $P6355
.annotate 'line', 2294
    new $P6335, "Undef"
    .lex "$expr", $P6335
    find_lex $P6336, "$/"
    unless_null $P6336, vivify_2871
    $P6336 = root_new ['parrot';'Hash']
  vivify_2871:
    set $P6337, $P6336["EXPR"]
    unless_null $P6337, vivify_2872
    new $P6337, "Undef"
  vivify_2872:
    $P6338 = $P6337."ast"()
    store_lex "$expr", $P6338
.annotate 'line', 2295
    find_lex $P6343, "$expr"
    unless_null $P6343, vivify_2873
    new $P6343, "Undef"
  vivify_2873:
    $S6344 = $P6343."name"()
    iseq $I6345, $S6344, "&infix:<,>"
    if $I6345, if_6342
    new $P6341, 'Integer'
    set $P6341, $I6345
    goto if_6342_end
  if_6342:
    find_lex $P6346, "$expr"
    unless_null $P6346, vivify_2874
    new $P6346, "Undef"
  vivify_2874:
    $P6347 = $P6346."named"()
    isfalse $I6348, $P6347
    new $P6341, 'Integer'
    set $P6341, $I6348
  if_6342_end:
    if $P6341, if_6340
.annotate 'line', 2298
    find_lex $P6363, "$past"
    unless_null $P6363, vivify_2875
    new $P6363, "Undef"
  vivify_2875:
    find_lex $P6364, "$expr"
    unless_null $P6364, vivify_2876
    new $P6364, "Undef"
  vivify_2876:
    $P6365 = $P6363."push"($P6364)
    set $P6339, $P6365
.annotate 'line', 2295
    goto if_6340_end
  if_6340:
.annotate 'line', 2296
    find_lex $P6350, "$expr"
    unless_null $P6350, vivify_2877
    new $P6350, "Undef"
  vivify_2877:
    $P6351 = $P6350."list"()
    defined $I6352, $P6351
    unless $I6352, for_undef_2878
    iter $P6349, $P6351
    new $P6361, 'ExceptionHandler'
    set_label $P6361, loop6360_handler
    $P6361."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6361
  loop6360_test:
    unless $P6349, loop6360_done
    shift $P6353, $P6349
  loop6360_redo:
    .const 'Sub' $P6355 = "570_1304523757.895" 
    capture_lex $P6355
    $P6355($P6353)
  loop6360_next:
    goto loop6360_test
  loop6360_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6362, exception, 'type'
    eq $P6362, .CONTROL_LOOP_NEXT, loop6360_next
    eq $P6362, .CONTROL_LOOP_REDO, loop6360_redo
  loop6360_done:
    pop_eh 
  for_undef_2878:
.annotate 'line', 2295
    set $P6339, $P6349
  if_6340_end:
.annotate 'line', 2293
    .return ($P6339)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6354"  :anon :subid("570_1304523757.895") :outer("569_1304523757.895")
    .param pmc param_6356
.annotate 'line', 2296
    .lex "$_", param_6356
    find_lex $P6357, "$past"
    unless_null $P6357, vivify_2879
    new $P6357, "Undef"
  vivify_2879:
    find_lex $P6358, "$_"
    unless_null $P6358, vivify_2880
    new $P6358, "Undef"
  vivify_2880:
    $P6359 = $P6357."push"($P6358)
    .return ($P6359)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("571_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6427
    .param pmc param_6428
.annotate 'line', 2316
    .lex "self", param_6427
    .lex "$/", param_6428
    find_lex $P6429, "$/"
    find_lex $P6430, "$/"
    unless_null $P6430, vivify_2907
    $P6430 = root_new ['parrot';'Hash']
  vivify_2907:
    set $P6431, $P6430["multi_declarator"]
    unless_null $P6431, vivify_2908
    new $P6431, "Undef"
  vivify_2908:
    $P6432 = $P6431."ast"()
    $P6433 = $P6429."!make"($P6432)
    .return ($P6433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("572_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6435
    .param pmc param_6436
.annotate 'line', 2318
    .lex "self", param_6435
    .lex "$/", param_6436
    find_lex $P6437, "$/"
    find_lex $P6438, "$/"
    unless_null $P6438, vivify_2909
    $P6438 = root_new ['parrot';'Hash']
  vivify_2909:
    set $P6439, $P6438["value"]
    unless_null $P6439, vivify_2910
    new $P6439, "Undef"
  vivify_2910:
    $P6440 = $P6439."ast"()
    $P6441 = $P6437."!make"($P6440)
    .return ($P6441)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("573_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6443
    .param pmc param_6444
.annotate 'line', 2320
    .lex "self", param_6443
    .lex "$/", param_6444
.annotate 'line', 2321
    find_lex $P6445, "$/"
.annotate 'line', 2322
    find_lex $P6448, "$/"
    unless_null $P6448, vivify_2911
    $P6448 = root_new ['parrot';'Hash']
  vivify_2911:
    set $P6449, $P6448["EXPR"]
    unless_null $P6449, vivify_2912
    new $P6449, "Undef"
  vivify_2912:
    if $P6449, if_6447
.annotate 'line', 2323
    get_hll_global $P6454, "GLOBAL"
    nqp_get_package_through_who $P6455, $P6454, "PAST"
    get_who $P6456, $P6455
    set $P6457, $P6456["Op"]
    find_lex $P6458, "$/"
    unless_null $P6458, vivify_2913
    new $P6458, "Undef"
  vivify_2913:
    $P6459 = $P6457."new"("list" :named("pasttype"), $P6458 :named("node"))
    set $P6446, $P6459
.annotate 'line', 2322
    goto if_6447_end
  if_6447:
    find_lex $P6450, "$/"
    unless_null $P6450, vivify_2914
    $P6450 = root_new ['parrot';'Hash']
  vivify_2914:
    set $P6451, $P6450["EXPR"]
    unless_null $P6451, vivify_2915
    $P6451 = root_new ['parrot';'ResizablePMCArray']
  vivify_2915:
    set $P6452, $P6451[0]
    unless_null $P6452, vivify_2916
    new $P6452, "Undef"
  vivify_2916:
    $P6453 = $P6452."ast"()
    set $P6446, $P6453
  if_6447_end:
    $P6460 = $P6445."!make"($P6446)
.annotate 'line', 2320
    .return ($P6460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("574_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6462
    .param pmc param_6463
.annotate 'line', 2326
    .lex "self", param_6462
    .lex "$/", param_6463
.annotate 'line', 2327
    new $P6464, "Undef"
    .lex "$past", $P6464
.annotate 'line', 2326
    find_lex $P6465, "$past"
    unless_null $P6465, vivify_2917
    new $P6465, "Undef"
  vivify_2917:
.annotate 'line', 2328
    find_lex $P6467, "$/"
    unless_null $P6467, vivify_2918
    $P6467 = root_new ['parrot';'Hash']
  vivify_2918:
    set $P6468, $P6467["EXPR"]
    unless_null $P6468, vivify_2919
    new $P6468, "Undef"
  vivify_2919:
    if $P6468, if_6466
.annotate 'line', 2335
    get_hll_global $P6483, "GLOBAL"
    nqp_get_package_through_who $P6484, $P6483, "PAST"
    get_who $P6485, $P6484
    set $P6486, $P6485["Op"]
    $P6487 = $P6486."new"("list" :named("pasttype"))
    store_lex "$past", $P6487
.annotate 'line', 2334
    goto if_6466_end
  if_6466:
.annotate 'line', 2329
    find_lex $P6469, "$/"
    unless_null $P6469, vivify_2920
    $P6469 = root_new ['parrot';'Hash']
  vivify_2920:
    set $P6470, $P6469["EXPR"]
    unless_null $P6470, vivify_2921
    $P6470 = root_new ['parrot';'ResizablePMCArray']
  vivify_2921:
    set $P6471, $P6470[0]
    unless_null $P6471, vivify_2922
    new $P6471, "Undef"
  vivify_2922:
    $P6472 = $P6471."ast"()
    store_lex "$past", $P6472
.annotate 'line', 2330
    find_lex $P6474, "$past"
    unless_null $P6474, vivify_2923
    new $P6474, "Undef"
  vivify_2923:
    $S6475 = $P6474."name"()
    isne $I6476, $S6475, "&infix:<,>"
    unless $I6476, if_6473_end
.annotate 'line', 2331
    get_hll_global $P6477, "GLOBAL"
    nqp_get_package_through_who $P6478, $P6477, "PAST"
    get_who $P6479, $P6478
    set $P6480, $P6479["Op"]
    find_lex $P6481, "$past"
    unless_null $P6481, vivify_2924
    new $P6481, "Undef"
  vivify_2924:
    $P6482 = $P6480."new"($P6481, "list" :named("pasttype"))
    store_lex "$past", $P6482
  if_6473_end:
  if_6466_end:
.annotate 'line', 2337
    find_lex $P6488, "$past"
    unless_null $P6488, vivify_2925
    new $P6488, "Undef"
  vivify_2925:
    $P6488."name"("&circumfix:<[ ]>")
.annotate 'line', 2338
    find_lex $P6489, "$/"
    find_lex $P6490, "$past"
    unless_null $P6490, vivify_2926
    new $P6490, "Undef"
  vivify_2926:
    $P6491 = $P6489."!make"($P6490)
.annotate 'line', 2326
    .return ($P6491)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("575_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6493
    .param pmc param_6494
.annotate 'line', 2341
    .lex "self", param_6493
    .lex "$/", param_6494
    find_lex $P6495, "$/"
    find_lex $P6496, "$/"
    unless_null $P6496, vivify_2927
    $P6496 = root_new ['parrot';'Hash']
  vivify_2927:
    set $P6497, $P6496["quote_EXPR"]
    unless_null $P6497, vivify_2928
    new $P6497, "Undef"
  vivify_2928:
    $P6498 = $P6497."ast"()
    $P6499 = $P6495."!make"($P6498)
    .return ($P6499)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("576_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6501
    .param pmc param_6502
.annotate 'line', 2342
    .lex "self", param_6501
    .lex "$/", param_6502
    find_lex $P6503, "$/"
    find_lex $P6504, "$/"
    unless_null $P6504, vivify_2929
    $P6504 = root_new ['parrot';'Hash']
  vivify_2929:
    set $P6505, $P6504["quote_EXPR"]
    unless_null $P6505, vivify_2930
    new $P6505, "Undef"
  vivify_2930:
    $P6506 = $P6505."ast"()
    $P6507 = $P6503."!make"($P6506)
    .return ($P6507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("577_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6509
    .param pmc param_6510
.annotate 'line', 2344
    .const 'Sub' $P6521 = "578_1304523757.895" 
    capture_lex $P6521
    .lex "self", param_6509
    .lex "$/", param_6510
.annotate 'line', 2345
    find_lex $P6513, "$/"
    unless_null $P6513, vivify_2931
    $P6513 = root_new ['parrot';'Hash']
  vivify_2931:
    set $P6514, $P6513["pblock"]
    unless_null $P6514, vivify_2932
    $P6514 = root_new ['parrot';'Hash']
  vivify_2932:
    set $P6515, $P6514["blockoid"]
    unless_null $P6515, vivify_2933
    $P6515 = root_new ['parrot';'Hash']
  vivify_2933:
    set $P6516, $P6515["statementlist"]
    unless_null $P6516, vivify_2934
    $P6516 = root_new ['parrot';'Hash']
  vivify_2934:
    set $P6517, $P6516["statement"]
    unless_null $P6517, vivify_2935
    new $P6517, "Undef"
  vivify_2935:
    set $N6518, $P6517
    isgt $I6519, $N6518, 0.0
    if $I6519, if_6512
.annotate 'line', 2350
    find_lex $P6534, "$/"
    unless_null $P6534, vivify_2936
    $P6534 = root_new ['parrot';'Hash']
  vivify_2936:
    set $P6535, $P6534["pblock"]
    unless_null $P6535, vivify_2937
    $P6535 = root_new ['parrot';'Hash']
  vivify_2937:
    set $P6536, $P6535["blockoid"]
    unless_null $P6536, vivify_2938
    $P6536 = root_new ['parrot';'Hash']
  vivify_2938:
    set $P6537, $P6536["you_are_here"]
    unless_null $P6537, vivify_2939
    new $P6537, "Undef"
  vivify_2939:
    if $P6537, if_6533
.annotate 'line', 2354
    find_lex $P6543, "$/"
    $P6544 = "vivitype"("%")
    $P6545 = $P6543."!make"($P6544)
.annotate 'line', 2353
    set $P6532, $P6545
.annotate 'line', 2350
    goto if_6533_end
  if_6533:
.annotate 'line', 2351
    find_lex $P6538, "$/"
    find_lex $P6539, "$/"
    unless_null $P6539, vivify_2940
    $P6539 = root_new ['parrot';'Hash']
  vivify_2940:
    set $P6540, $P6539["pblock"]
    unless_null $P6540, vivify_2941
    new $P6540, "Undef"
  vivify_2941:
    $P6541 = $P6540."ast"()
    $P6542 = $P6538."!make"($P6541)
.annotate 'line', 2350
    set $P6532, $P6542
  if_6533_end:
    set $P6511, $P6532
.annotate 'line', 2345
    goto if_6512_end
  if_6512:
    .const 'Sub' $P6521 = "578_1304523757.895" 
    capture_lex $P6521
    $P6531 = $P6521()
    set $P6511, $P6531
  if_6512_end:
.annotate 'line', 2344
    .return ($P6511)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6520"  :anon :subid("578_1304523757.895") :outer("577_1304523757.895")
.annotate 'line', 2346
    new $P6522, "Undef"
    .lex "$past", $P6522
    find_lex $P6523, "$/"
    unless_null $P6523, vivify_2942
    $P6523 = root_new ['parrot';'Hash']
  vivify_2942:
    set $P6524, $P6523["pblock"]
    unless_null $P6524, vivify_2943
    new $P6524, "Undef"
  vivify_2943:
    $P6525 = $P6524."ast"()
    store_lex "$past", $P6525
.annotate 'line', 2347
    new $P6526, "Integer"
    assign $P6526, 1
    find_lex $P6527, "$past"
    unless_null $P6527, vivify_2944
    $P6527 = root_new ['parrot';'Hash']
    store_lex "$past", $P6527
  vivify_2944:
    set $P6527["bareblock"], $P6526
.annotate 'line', 2348
    find_dynamic_lex $P6528, "$/"
    find_lex $P6529, "$past"
    unless_null $P6529, vivify_2945
    new $P6529, "Undef"
  vivify_2945:
    $P6530 = $P6528."!make"($P6529)
.annotate 'line', 2345
    .return ($P6530)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("579_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6547
    .param pmc param_6548
.annotate 'line', 2358
    .lex "self", param_6547
    .lex "$/", param_6548
.annotate 'line', 2359
    new $P6549, "Undef"
    .lex "$name", $P6549
    find_lex $P6552, "$/"
    unless_null $P6552, vivify_2946
    $P6552 = root_new ['parrot';'Hash']
  vivify_2946:
    set $P6553, $P6552["sigil"]
    unless_null $P6553, vivify_2947
    new $P6553, "Undef"
  vivify_2947:
    set $S6554, $P6553
    iseq $I6555, $S6554, "@"
    if $I6555, if_6551
.annotate 'line', 2360
    find_lex $P6559, "$/"
    unless_null $P6559, vivify_2948
    $P6559 = root_new ['parrot';'Hash']
  vivify_2948:
    set $P6560, $P6559["sigil"]
    unless_null $P6560, vivify_2949
    new $P6560, "Undef"
  vivify_2949:
    set $S6561, $P6560
    iseq $I6562, $S6561, "%"
    if $I6562, if_6558
    new $P6564, "String"
    assign $P6564, "item"
    set $P6557, $P6564
    goto if_6558_end
  if_6558:
    new $P6563, "String"
    assign $P6563, "hash"
    set $P6557, $P6563
  if_6558_end:
    set $P6550, $P6557
.annotate 'line', 2359
    goto if_6551_end
  if_6551:
    new $P6556, "String"
    assign $P6556, "list"
    set $P6550, $P6556
  if_6551_end:
    store_lex "$name", $P6550
.annotate 'line', 2362
    find_lex $P6565, "$/"
    get_hll_global $P6566, "GLOBAL"
    nqp_get_package_through_who $P6567, $P6566, "PAST"
    get_who $P6568, $P6567
    set $P6569, $P6568["Op"]
    find_lex $P6570, "$name"
    unless_null $P6570, vivify_2950
    new $P6570, "Undef"
  vivify_2950:
    find_lex $P6571, "$/"
    unless_null $P6571, vivify_2951
    $P6571 = root_new ['parrot';'Hash']
  vivify_2951:
    set $P6572, $P6571["semilist"]
    unless_null $P6572, vivify_2952
    new $P6572, "Undef"
  vivify_2952:
    $P6573 = $P6572."ast"()
    $P6574 = $P6569."new"($P6573, "callmethod" :named("pasttype"), $P6570 :named("name"))
    $P6575 = $P6565."!make"($P6574)
.annotate 'line', 2358
    .return ($P6575)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("580_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6577
    .param pmc param_6578
.annotate 'line', 2365
    .lex "self", param_6577
    .lex "$/", param_6578
    find_lex $P6579, "$/"
    find_lex $P6580, "$/"
    unless_null $P6580, vivify_2953
    $P6580 = root_new ['parrot';'Hash']
  vivify_2953:
    set $P6581, $P6580["statement"]
    unless_null $P6581, vivify_2954
    new $P6581, "Undef"
  vivify_2954:
    $P6582 = $P6581."ast"()
    $P6583 = $P6579."!make"($P6582)
    .return ($P6583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("581_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6585
    .param pmc param_6586
.annotate 'line', 2367
    .lex "self", param_6585
    .lex "$/", param_6586
.annotate 'line', 2368
    find_lex $P6587, "$/"
    get_hll_global $P6588, "GLOBAL"
    nqp_get_package_through_who $P6589, $P6588, "PAST"
    get_who $P6590, $P6589
    set $P6591, $P6590["Var"]
    find_lex $P6592, "$/"
    unless_null $P6592, vivify_2955
    $P6592 = root_new ['parrot';'Hash']
  vivify_2955:
    set $P6593, $P6592["EXPR"]
    unless_null $P6593, vivify_2956
    new $P6593, "Undef"
  vivify_2956:
    $P6594 = $P6593."ast"()
.annotate 'line', 2370
    $P6595 = "vivitype"("@")
    $P6596 = $P6591."new"($P6594, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6595 :named("vivibase"))
.annotate 'line', 2368
    $P6597 = $P6587."!make"($P6596)
.annotate 'line', 2367
    .return ($P6597)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("582_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6599
    .param pmc param_6600
.annotate 'line', 2373
    .lex "self", param_6599
    .lex "$/", param_6600
.annotate 'line', 2374
    find_lex $P6601, "$/"
    get_hll_global $P6602, "GLOBAL"
    nqp_get_package_through_who $P6603, $P6602, "PAST"
    get_who $P6604, $P6603
    set $P6605, $P6604["Var"]
    find_lex $P6606, "$/"
    unless_null $P6606, vivify_2957
    $P6606 = root_new ['parrot';'Hash']
  vivify_2957:
    set $P6607, $P6606["EXPR"]
    unless_null $P6607, vivify_2958
    new $P6607, "Undef"
  vivify_2958:
    $P6608 = $P6607."ast"()
.annotate 'line', 2376
    $P6609 = "vivitype"("%")
    $P6610 = $P6605."new"($P6608, "keyed" :named("scope"), "Undef" :named("viviself"), $P6609 :named("vivibase"))
.annotate 'line', 2374
    $P6611 = $P6601."!make"($P6610)
.annotate 'line', 2373
    .return ($P6611)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("583_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6613
    .param pmc param_6614
.annotate 'line', 2379
    .lex "self", param_6613
    .lex "$/", param_6614
.annotate 'line', 2380
    find_lex $P6615, "$/"
    get_hll_global $P6616, "GLOBAL"
    nqp_get_package_through_who $P6617, $P6616, "PAST"
    get_who $P6618, $P6617
    set $P6619, $P6618["Var"]
    find_lex $P6620, "$/"
    unless_null $P6620, vivify_2959
    $P6620 = root_new ['parrot';'Hash']
  vivify_2959:
    set $P6621, $P6620["quote_EXPR"]
    unless_null $P6621, vivify_2960
    new $P6621, "Undef"
  vivify_2960:
    $P6622 = $P6621."ast"()
.annotate 'line', 2382
    $P6623 = "vivitype"("%")
    $P6624 = $P6619."new"($P6622, "keyed" :named("scope"), "Undef" :named("viviself"), $P6623 :named("vivibase"))
.annotate 'line', 2380
    $P6625 = $P6615."!make"($P6624)
.annotate 'line', 2379
    .return ($P6625)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("584_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6627
    .param pmc param_6628
.annotate 'line', 2385
    .lex "self", param_6627
    .lex "$/", param_6628
.annotate 'line', 2386
    find_lex $P6629, "$/"
    find_lex $P6630, "$/"
    unless_null $P6630, vivify_2961
    $P6630 = root_new ['parrot';'Hash']
  vivify_2961:
    set $P6631, $P6630["arglist"]
    unless_null $P6631, vivify_2962
    new $P6631, "Undef"
  vivify_2962:
    $P6632 = $P6631."ast"()
    $P6633 = $P6629."!make"($P6632)
.annotate 'line', 2385
    .return ($P6633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("585_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6635
    .param pmc param_6636
.annotate 'line', 2389
    .lex "self", param_6635
    .lex "$/", param_6636
.annotate 'line', 2390
    find_lex $P6637, "$/"
    find_lex $P6640, "$/"
    unless_null $P6640, vivify_2963
    $P6640 = root_new ['parrot';'Hash']
  vivify_2963:
    set $P6641, $P6640["quote"]
    unless_null $P6641, vivify_2964
    new $P6641, "Undef"
  vivify_2964:
    if $P6641, if_6639
    find_lex $P6645, "$/"
    unless_null $P6645, vivify_2965
    $P6645 = root_new ['parrot';'Hash']
  vivify_2965:
    set $P6646, $P6645["number"]
    unless_null $P6646, vivify_2966
    new $P6646, "Undef"
  vivify_2966:
    $P6647 = $P6646."ast"()
    set $P6638, $P6647
    goto if_6639_end
  if_6639:
    find_lex $P6642, "$/"
    unless_null $P6642, vivify_2967
    $P6642 = root_new ['parrot';'Hash']
  vivify_2967:
    set $P6643, $P6642["quote"]
    unless_null $P6643, vivify_2968
    new $P6643, "Undef"
  vivify_2968:
    $P6644 = $P6643."ast"()
    set $P6638, $P6644
  if_6639_end:
    $P6648 = $P6637."!make"($P6638)
.annotate 'line', 2389
    .return ($P6648)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("586_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6650
    .param pmc param_6651
.annotate 'line', 2393
    .lex "self", param_6650
    .lex "$/", param_6651
.annotate 'line', 2394
    new $P6652, "Undef"
    .lex "$value", $P6652
    find_lex $P6655, "$/"
    unless_null $P6655, vivify_2969
    $P6655 = root_new ['parrot';'Hash']
  vivify_2969:
    set $P6656, $P6655["dec_number"]
    unless_null $P6656, vivify_2970
    new $P6656, "Undef"
  vivify_2970:
    if $P6656, if_6654
    find_lex $P6660, "$/"
    unless_null $P6660, vivify_2971
    $P6660 = root_new ['parrot';'Hash']
  vivify_2971:
    set $P6661, $P6660["integer"]
    unless_null $P6661, vivify_2972
    new $P6661, "Undef"
  vivify_2972:
    $P6662 = $P6661."ast"()
    set $P6653, $P6662
    goto if_6654_end
  if_6654:
    find_lex $P6657, "$/"
    unless_null $P6657, vivify_2973
    $P6657 = root_new ['parrot';'Hash']
  vivify_2973:
    set $P6658, $P6657["dec_number"]
    unless_null $P6658, vivify_2974
    new $P6658, "Undef"
  vivify_2974:
    $P6659 = $P6658."ast"()
    set $P6653, $P6659
  if_6654_end:
    store_lex "$value", $P6653
.annotate 'line', 2395
    find_lex $P6664, "$/"
    unless_null $P6664, vivify_2975
    $P6664 = root_new ['parrot';'Hash']
  vivify_2975:
    set $P6665, $P6664["sign"]
    unless_null $P6665, vivify_2976
    new $P6665, "Undef"
  vivify_2976:
    set $S6666, $P6665
    iseq $I6667, $S6666, "-"
    unless $I6667, if_6663_end
    find_lex $P6668, "$value"
    unless_null $P6668, vivify_2977
    new $P6668, "Undef"
  vivify_2977:
    neg $P6669, $P6668
    store_lex "$value", $P6669
  if_6663_end:
.annotate 'line', 2396
    find_lex $P6670, "$/"
    get_hll_global $P6671, "GLOBAL"
    nqp_get_package_through_who $P6672, $P6671, "PAST"
    get_who $P6673, $P6672
    set $P6674, $P6673["Val"]
    find_lex $P6675, "$value"
    unless_null $P6675, vivify_2978
    new $P6675, "Undef"
  vivify_2978:
    $P6676 = $P6674."new"($P6675 :named("value"))
    $P6677 = $P6670."!make"($P6676)
.annotate 'line', 2393
    .return ($P6677)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("587_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6679
    .param pmc param_6680
.annotate 'line', 2399
    .lex "self", param_6679
    .lex "$/", param_6680
    find_lex $P6681, "$/"
    find_lex $P6682, "$/"
    unless_null $P6682, vivify_2979
    $P6682 = root_new ['parrot';'Hash']
  vivify_2979:
    set $P6683, $P6682["quote_EXPR"]
    unless_null $P6683, vivify_2980
    new $P6683, "Undef"
  vivify_2980:
    $P6684 = $P6683."ast"()
    $P6685 = $P6681."!make"($P6684)
    .return ($P6685)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("588_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6687
    .param pmc param_6688
.annotate 'line', 2400
    .lex "self", param_6687
    .lex "$/", param_6688
    find_lex $P6689, "$/"
    find_lex $P6690, "$/"
    unless_null $P6690, vivify_2981
    $P6690 = root_new ['parrot';'Hash']
  vivify_2981:
    set $P6691, $P6690["quote_EXPR"]
    unless_null $P6691, vivify_2982
    new $P6691, "Undef"
  vivify_2982:
    $P6692 = $P6691."ast"()
    $P6693 = $P6689."!make"($P6692)
    .return ($P6693)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("589_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6695
    .param pmc param_6696
.annotate 'line', 2401
    .lex "self", param_6695
    .lex "$/", param_6696
    find_lex $P6697, "$/"
    find_lex $P6698, "$/"
    unless_null $P6698, vivify_2983
    $P6698 = root_new ['parrot';'Hash']
  vivify_2983:
    set $P6699, $P6698["quote_EXPR"]
    unless_null $P6699, vivify_2984
    new $P6699, "Undef"
  vivify_2984:
    $P6700 = $P6699."ast"()
    $P6701 = $P6697."!make"($P6700)
    .return ($P6701)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("590_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6703
    .param pmc param_6704
.annotate 'line', 2402
    .lex "self", param_6703
    .lex "$/", param_6704
    find_lex $P6705, "$/"
    find_lex $P6706, "$/"
    unless_null $P6706, vivify_2985
    $P6706 = root_new ['parrot';'Hash']
  vivify_2985:
    set $P6707, $P6706["quote_EXPR"]
    unless_null $P6707, vivify_2986
    new $P6707, "Undef"
  vivify_2986:
    $P6708 = $P6707."ast"()
    $P6709 = $P6705."!make"($P6708)
    .return ($P6709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("591_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6711
    .param pmc param_6712
.annotate 'line', 2403
    .lex "self", param_6711
    .lex "$/", param_6712
    find_lex $P6713, "$/"
    find_lex $P6714, "$/"
    unless_null $P6714, vivify_2987
    $P6714 = root_new ['parrot';'Hash']
  vivify_2987:
    set $P6715, $P6714["quote_EXPR"]
    unless_null $P6715, vivify_2988
    new $P6715, "Undef"
  vivify_2988:
    $P6716 = $P6715."ast"()
    $P6717 = $P6713."!make"($P6716)
    .return ($P6717)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("592_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6719
    .param pmc param_6720
.annotate 'line', 2404
    .lex "self", param_6719
    .lex "$/", param_6720
.annotate 'line', 2405
    find_lex $P6721, "$/"
    get_hll_global $P6722, "GLOBAL"
    nqp_get_package_through_who $P6723, $P6722, "PAST"
    get_who $P6724, $P6723
    set $P6725, $P6724["Op"]
    find_lex $P6726, "$/"
    unless_null $P6726, vivify_2989
    $P6726 = root_new ['parrot';'Hash']
  vivify_2989:
    set $P6727, $P6726["quote_EXPR"]
    unless_null $P6727, vivify_2990
    new $P6727, "Undef"
  vivify_2990:
    $P6728 = $P6727."ast"()
    $P6729 = $P6728."value"()
    find_lex $P6730, "$/"
    unless_null $P6730, vivify_2991
    new $P6730, "Undef"
  vivify_2991:
    $P6731 = $P6725."new"($P6729 :named("inline"), "inline" :named("pasttype"), $P6730 :named("node"))
    $P6732 = $P6721."!make"($P6731)
.annotate 'line', 2404
    .return ($P6732)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("593_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6736
    .param pmc param_6737
    .param pmc param_6738 :optional
    .param int has_param_6738 :opt_flag
.annotate 'line', 2410
    new $P6735, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6735, control_6734
    push_eh $P6735
    .lex "self", param_6736
    .lex "$/", param_6737
    if has_param_6738, optparam_2992
    new $P6739, "Undef"
    set param_6738, $P6739
  optparam_2992:
    .lex "$key", param_6738
.annotate 'line', 2417
    new $P6740, "Undef"
    .lex "$regex", $P6740
.annotate 'line', 2419
    new $P6741, "Undef"
    .lex "$past", $P6741
.annotate 'line', 2411
    find_lex $P6743, "$key"
    unless_null $P6743, vivify_2993
    new $P6743, "Undef"
  vivify_2993:
    set $S6744, $P6743
    iseq $I6745, $S6744, "open"
    unless $I6745, if_6742_end
.annotate 'line', 2412
    null $P6746
    get_hll_global $P6747, "GLOBAL"
    nqp_get_package_through_who $P6748, $P6747, "Regex"
    nqp_get_package_through_who $P6749, $P6748, "P6Regex"
    nqp_get_package_through_who $P6750, $P6749, "Actions"
    get_who $P6751, $P6750
    set $P6751["$REGEXNAME"], $P6746
.annotate 'line', 2413
    find_lex $P6752, "$?PACKAGE"
    get_who $P6753, $P6752
    set $P6754, $P6753["@BLOCK"]
    unless_null $P6754, vivify_2994
    $P6754 = root_new ['parrot';'ResizablePMCArray']
  vivify_2994:
    set $P6755, $P6754[0]
    unless_null $P6755, vivify_2995
    new $P6755, "Undef"
  vivify_2995:
    $P6755."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2414
    find_lex $P6756, "$?PACKAGE"
    get_who $P6757, $P6756
    set $P6758, $P6757["@BLOCK"]
    unless_null $P6758, vivify_2996
    $P6758 = root_new ['parrot';'ResizablePMCArray']
  vivify_2996:
    set $P6759, $P6758[0]
    unless_null $P6759, vivify_2997
    new $P6759, "Undef"
  vivify_2997:
    $P6759."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2415
    new $P6760, "Exception"
    set $P6760['type'], .CONTROL_RETURN
    new $P6761, "Integer"
    assign $P6761, 0
    setattribute $P6760, 'payload', $P6761
    throw $P6760
  if_6742_end:
.annotate 'line', 2418
    get_hll_global $P6762, "GLOBAL"
    nqp_get_package_through_who $P6763, $P6762, "Regex"
    nqp_get_package_through_who $P6764, $P6763, "P6Regex"
    nqp_get_package_through_who $P6765, $P6764, "Actions"
    get_who $P6766, $P6765
    set $P6767, $P6766["buildsub"]
    find_lex $P6768, "$/"
    unless_null $P6768, vivify_2998
    $P6768 = root_new ['parrot';'Hash']
  vivify_2998:
    set $P6769, $P6768["p6regex"]
    unless_null $P6769, vivify_2999
    new $P6769, "Undef"
  vivify_2999:
    $P6770 = $P6769."ast"()
    find_lex $P6771, "$?PACKAGE"
    get_who $P6772, $P6771
    set $P6773, $P6772["@BLOCK"]
    unless_null $P6773, vivify_3000
    $P6773 = root_new ['parrot';'ResizablePMCArray']
  vivify_3000:
    $P6774 = $P6773."shift"()
    $P6775 = $P6767($P6770, $P6774)
    store_lex "$regex", $P6775
.annotate 'line', 2420
    get_hll_global $P6776, "GLOBAL"
    nqp_get_package_through_who $P6777, $P6776, "PAST"
    get_who $P6778, $P6777
    set $P6779, $P6778["Op"]
.annotate 'line', 2422
    new $P6780, "ResizablePMCArray"
    push $P6780, "Regex"
    push $P6780, "Regex"
    find_lex $P6781, "$/"
    unless_null $P6781, vivify_3001
    new $P6781, "Undef"
  vivify_3001:
    $P6782 = "lexical_package_lookup"($P6780, $P6781)
    find_lex $P6783, "$regex"
    unless_null $P6783, vivify_3002
    new $P6783, "Undef"
  vivify_3002:
    $P6784 = $P6779."new"($P6782, $P6783, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2420
    store_lex "$past", $P6784
.annotate 'line', 2426
    find_lex $P6785, "$regex"
    unless_null $P6785, vivify_3003
    new $P6785, "Undef"
  vivify_3003:
    find_lex $P6786, "$past"
    unless_null $P6786, vivify_3004
    $P6786 = root_new ['parrot';'Hash']
    store_lex "$past", $P6786
  vivify_3004:
    set $P6786["sink"], $P6785
.annotate 'line', 2427
    find_lex $P6787, "$/"
    find_lex $P6788, "$past"
    unless_null $P6788, vivify_3005
    new $P6788, "Undef"
  vivify_3005:
    $P6789 = $P6787."!make"($P6788)
.annotate 'line', 2410
    .return ($P6789)
  control_6734:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6790, exception, "payload"
    .return ($P6790)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("594_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6792
    .param pmc param_6793
.annotate 'line', 2430
    .lex "self", param_6792
    .lex "$/", param_6793
    find_lex $P6794, "$/"
    find_lex $P6795, "$/"
    unless_null $P6795, vivify_3006
    $P6795 = root_new ['parrot';'Hash']
  vivify_3006:
    set $P6796, $P6795["variable"]
    unless_null $P6796, vivify_3007
    new $P6796, "Undef"
  vivify_3007:
    $P6797 = $P6796."ast"()
    $P6798 = $P6794."!make"($P6797)
    .return ($P6798)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("595_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6800
    .param pmc param_6801
.annotate 'line', 2431
    .lex "self", param_6800
    .lex "$/", param_6801
.annotate 'line', 2432
    find_lex $P6802, "$/"
    get_hll_global $P6803, "GLOBAL"
    nqp_get_package_through_who $P6804, $P6803, "PAST"
    get_who $P6805, $P6804
    set $P6806, $P6805["Op"]
.annotate 'line', 2433
    find_lex $P6807, "$/"
    unless_null $P6807, vivify_3008
    $P6807 = root_new ['parrot';'Hash']
  vivify_3008:
    set $P6808, $P6807["block"]
    unless_null $P6808, vivify_3009
    new $P6808, "Undef"
  vivify_3009:
    $P6809 = $P6808."ast"()
    $P6810 = "block_immediate"($P6809)
    find_lex $P6811, "$/"
    unless_null $P6811, vivify_3010
    new $P6811, "Undef"
  vivify_3010:
    $P6812 = $P6806."new"($P6810, "set S*" :named("pirop"), $P6811 :named("node"))
.annotate 'line', 2432
    $P6813 = $P6802."!make"($P6812)
.annotate 'line', 2431
    .return ($P6813)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("596_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6815
    .param pmc param_6816
.annotate 'line', 2436
    .lex "self", param_6815
    .lex "$/", param_6816
    find_lex $P6817, "$/"
    $P6818 = $P6817."!make"("\e")
    .return ($P6818)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("597_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6820
    .param pmc param_6821
.annotate 'line', 2440
    .lex "self", param_6820
    .lex "$/", param_6821
    find_lex $P6822, "$/"
    find_lex $P6823, "$/"
    unless_null $P6823, vivify_3011
    $P6823 = root_new ['parrot';'Hash']
  vivify_3011:
    set $P6824, $P6823["dotty"]
    unless_null $P6824, vivify_3012
    new $P6824, "Undef"
  vivify_3012:
    $P6825 = $P6824."ast"()
    $P6826 = $P6822."!make"($P6825)
    .return ($P6826)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("598_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6828
    .param pmc param_6829
.annotate 'line', 2442
    .lex "self", param_6828
    .lex "$/", param_6829
.annotate 'line', 2443
    find_lex $P6830, "$/"
    get_hll_global $P6831, "GLOBAL"
    nqp_get_package_through_who $P6832, $P6831, "PAST"
    get_who $P6833, $P6832
    set $P6834, $P6833["Op"]
.annotate 'line', 2444
    new $P6835, "ResizablePMCArray"
    push $P6835, "    clone %r, %0"
    push $P6835, "    inc %0"
    $P6836 = $P6834."new"("postfix:<++>" :named("name"), $P6835 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2443
    $P6837 = $P6830."!make"($P6836)
.annotate 'line', 2442
    .return ($P6837)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("599_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6839
    .param pmc param_6840
.annotate 'line', 2448
    .lex "self", param_6839
    .lex "$/", param_6840
.annotate 'line', 2449
    find_lex $P6841, "$/"
    get_hll_global $P6842, "GLOBAL"
    nqp_get_package_through_who $P6843, $P6842, "PAST"
    get_who $P6844, $P6843
    set $P6845, $P6844["Op"]
.annotate 'line', 2450
    new $P6846, "ResizablePMCArray"
    push $P6846, "    clone %r, %0"
    push $P6846, "    dec %0"
    $P6847 = $P6845."new"("postfix:<-->" :named("name"), $P6846 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2449
    $P6848 = $P6841."!make"($P6847)
.annotate 'line', 2448
    .return ($P6848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("600_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6850
    .param pmc param_6851
.annotate 'line', 2454
    .lex "self", param_6850
    .lex "$/", param_6851
.annotate 'line', 2455
    find_lex $P6852, "$/"
    get_hll_global $P6853, "GLOBAL"
    nqp_get_package_through_who $P6854, $P6853, "PAST"
    get_who $P6855, $P6854
    set $P6856, $P6855["Op"]
.annotate 'line', 2456
    get_hll_global $P6857, "GLOBAL"
    nqp_get_package_through_who $P6858, $P6857, "PAST"
    get_who $P6859, $P6858
    set $P6860, $P6859["Var"]
    $P6861 = $P6860."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6862, "$/"
    unless_null $P6862, vivify_3013
    new $P6862, "Undef"
  vivify_3013:
    $P6863 = $P6856."new"($P6861, "callmethod" :named("pasttype"), "!make" :named("name"), $P6862 :named("node"))
.annotate 'line', 2455
    $P6864 = $P6852."!make"($P6863)
.annotate 'line', 2454
    .return ($P6864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("601_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6867
    .param pmc param_6868
.annotate 'line', 2472
    .lex "self", param_6867
    .lex "$/", param_6868
    find_lex $P6869, "$/"
    unless_null $P6869, vivify_3014
    new $P6869, "Undef"
  vivify_3014:
    $P6870 = "control"($P6869, "CONTROL_LOOP_NEXT")
    .return ($P6870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("602_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6872
    .param pmc param_6873
.annotate 'line', 2473
    .lex "self", param_6872
    .lex "$/", param_6873
    find_lex $P6874, "$/"
    unless_null $P6874, vivify_3015
    new $P6874, "Undef"
  vivify_3015:
    $P6875 = "control"($P6874, "CONTROL_LOOP_LAST")
    .return ($P6875)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("603_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6877
    .param pmc param_6878
.annotate 'line', 2474
    .lex "self", param_6877
    .lex "$/", param_6878
    find_lex $P6879, "$/"
    unless_null $P6879, vivify_3016
    new $P6879, "Undef"
  vivify_3016:
    $P6880 = "control"($P6879, "CONTROL_LOOP_REDO")
    .return ($P6880)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("604_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6882
    .param pmc param_6883
.annotate 'line', 2476
    .lex "self", param_6882
    .lex "$/", param_6883
.annotate 'line', 2477
    find_lex $P6884, "$/"
    get_hll_global $P6885, "GLOBAL"
    nqp_get_package_through_who $P6886, $P6885, "PAST"
    get_who $P6887, $P6886
    set $P6888, $P6887["Op"]
    find_lex $P6889, "$/"
    unless_null $P6889, vivify_3017
    new $P6889, "Undef"
  vivify_3017:
    $P6890 = $P6888."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6889 :named("node"))
    $P6891 = $P6884."!make"($P6890)
.annotate 'line', 2476
    .return ($P6891)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym"  :subid("605_1304523757.895") :outer("432_1304523757.895")
    .param pmc param_6897
    .param pmc param_6898
    .param pmc param_6899
.annotate 'line', 2554
    .const 'Sub' $P6903 = "606_1304523757.895" 
    capture_lex $P6903
    .lex "self", param_6897
    .lex "$/", param_6898
    .lex "@name", param_6899
.annotate 'line', 2555
    new $P6900, "Undef"
    .lex "$known", $P6900
    new $P6901, "Integer"
    assign $P6901, 0
    store_lex "$known", $P6901
.annotate 'line', 2556
    .const 'Sub' $P6903 = "606_1304523757.895" 
    capture_lex $P6903
    $P6903()
    find_lex $P6914, "$known"
    unless_null $P6914, vivify_3020
    new $P6914, "Undef"
  vivify_3020:
.annotate 'line', 2554
    .return ($P6914)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6902"  :anon :subid("606_1304523757.895") :outer("605_1304523757.895")
.annotate 'line', 2556
    new $P6909, 'ExceptionHandler'
    set_label $P6909, control_6908
    $P6909."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6909
.annotate 'line', 2557
    find_lex $P6904, "@name"
    unless_null $P6904, vivify_3018
    $P6904 = root_new ['parrot';'ResizablePMCArray']
  vivify_3018:
    find_lex $P6905, "$/"
    unless_null $P6905, vivify_3019
    new $P6905, "Undef"
  vivify_3019:
    "find_sym"($P6904, $P6905)
.annotate 'line', 2558
    new $P6906, "Integer"
    assign $P6906, 1
    store_lex "$known", $P6906
.annotate 'line', 2556
    pop_eh 
    goto skip_handler_6907
  control_6908:
    .local pmc exception 
    .get_results (exception) 
    new $P6912, 'Integer'
    set $P6912, 1
    set exception["handled"], $P6912
    set $I6913, exception["handled"]
    ne $I6913, 1, nothandled_6911
  handled_6910:
    .return (exception)
  nothandled_6911:
    rethrow exception
  skip_handler_6907:
    .return ($P6906)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6916"  :subid("607_1304523757.895") :outer("10_1304523757.895")
.annotate 'line', 2623
    .const 'Sub' $P7010 = "614_1304523757.895" 
    capture_lex $P7010
    .const 'Sub' $P6996 = "613_1304523757.895" 
    capture_lex $P6996
    .const 'Sub' $P6978 = "612_1304523757.895" 
    capture_lex $P6978
    .const 'Sub' $P6964 = "611_1304523757.895" 
    capture_lex $P6964
    .const 'Sub' $P6950 = "610_1304523757.895" 
    capture_lex $P6950
    .const 'Sub' $P6936 = "609_1304523757.895" 
    capture_lex $P6936
    .const 'Sub' $P6920 = "608_1304523757.895" 
    capture_lex $P6920
    .lex "$?PACKAGE", $P6918
    .lex "$?CLASS", $P6919
.annotate 'line', 2657
    .const 'Sub' $P7010 = "614_1304523757.895" 
    newclosure $P7048, $P7010
.annotate 'line', 2623
    .return ($P7048)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("608_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_6921
    .param pmc param_6922
.annotate 'line', 2625
    .lex "self", param_6921
    .lex "$/", param_6922
.annotate 'line', 2626
    new $P6923, "Undef"
    .lex "$past", $P6923
    find_lex $P6924, "$/"
    unless_null $P6924, vivify_3021
    $P6924 = root_new ['parrot';'Hash']
  vivify_3021:
    set $P6925, $P6924["statement"]
    unless_null $P6925, vivify_3022
    new $P6925, "Undef"
  vivify_3022:
    $P6926 = $P6925."ast"()
    store_lex "$past", $P6926
.annotate 'line', 2627
    find_lex $P6927, "$/"
    get_hll_global $P6928, "GLOBAL"
    nqp_get_package_through_who $P6929, $P6928, "PAST"
    get_who $P6930, $P6929
    set $P6931, $P6930["Regex"]
    find_lex $P6932, "$past"
    unless_null $P6932, vivify_3023
    new $P6932, "Undef"
  vivify_3023:
    find_lex $P6933, "$/"
    unless_null $P6933, vivify_3024
    new $P6933, "Undef"
  vivify_3024:
    $P6934 = $P6931."new"($P6932, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6933 :named("node"))
    $P6935 = $P6927."!make"($P6934)
.annotate 'line', 2625
    .return ($P6935)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("609_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_6937
    .param pmc param_6938
.annotate 'line', 2631
    .lex "self", param_6937
    .lex "$/", param_6938
.annotate 'line', 2632
    find_lex $P6939, "$/"
    get_hll_global $P6940, "GLOBAL"
    nqp_get_package_through_who $P6941, $P6940, "PAST"
    get_who $P6942, $P6941
    set $P6943, $P6942["Regex"]
    find_lex $P6944, "$/"
    unless_null $P6944, vivify_3025
    $P6944 = root_new ['parrot';'Hash']
  vivify_3025:
    set $P6945, $P6944["codeblock"]
    unless_null $P6945, vivify_3026
    new $P6945, "Undef"
  vivify_3026:
    $P6946 = $P6945."ast"()
    find_lex $P6947, "$/"
    unless_null $P6947, vivify_3027
    new $P6947, "Undef"
  vivify_3027:
    $P6948 = $P6943."new"($P6946, "pastnode" :named("pasttype"), $P6947 :named("node"))
    $P6949 = $P6939."!make"($P6948)
.annotate 'line', 2631
    .return ($P6949)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("610_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_6951
    .param pmc param_6952
.annotate 'line', 2636
    .lex "self", param_6951
    .lex "$/", param_6952
.annotate 'line', 2637
    find_lex $P6953, "$/"
    get_hll_global $P6954, "GLOBAL"
    nqp_get_package_through_who $P6955, $P6954, "PAST"
    get_who $P6956, $P6955
    set $P6957, $P6956["Regex"]
    find_lex $P6958, "$/"
    unless_null $P6958, vivify_3028
    $P6958 = root_new ['parrot';'Hash']
  vivify_3028:
    set $P6959, $P6958["var"]
    unless_null $P6959, vivify_3029
    new $P6959, "Undef"
  vivify_3029:
    $P6960 = $P6959."ast"()
    find_lex $P6961, "$/"
    unless_null $P6961, vivify_3030
    new $P6961, "Undef"
  vivify_3030:
    $P6962 = $P6957."new"("!INTERPOLATE", $P6960, "subrule" :named("pasttype"), "method" :named("subtype"), $P6961 :named("node"))
    $P6963 = $P6953."!make"($P6962)
.annotate 'line', 2636
    .return ($P6963)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("611_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_6965
    .param pmc param_6966
.annotate 'line', 2641
    .lex "self", param_6965
    .lex "$/", param_6966
.annotate 'line', 2642
    find_lex $P6967, "$/"
    get_hll_global $P6968, "GLOBAL"
    nqp_get_package_through_who $P6969, $P6968, "PAST"
    get_who $P6970, $P6969
    set $P6971, $P6970["Regex"]
    find_lex $P6972, "$/"
    unless_null $P6972, vivify_3031
    $P6972 = root_new ['parrot';'Hash']
  vivify_3031:
    set $P6973, $P6972["codeblock"]
    unless_null $P6973, vivify_3032
    new $P6973, "Undef"
  vivify_3032:
    $P6974 = $P6973."ast"()
    find_lex $P6975, "$/"
    unless_null $P6975, vivify_3033
    new $P6975, "Undef"
  vivify_3033:
    $P6976 = $P6971."new"("!INTERPOLATE_REGEX", $P6974, "subrule" :named("pasttype"), "method" :named("subtype"), $P6975 :named("node"))
    $P6977 = $P6967."!make"($P6976)
.annotate 'line', 2641
    .return ($P6977)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("612_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_6979
    .param pmc param_6980
.annotate 'line', 2646
    .lex "self", param_6979
    .lex "$/", param_6980
.annotate 'line', 2647
    find_lex $P6981, "$/"
    get_hll_global $P6982, "GLOBAL"
    nqp_get_package_through_who $P6983, $P6982, "PAST"
    get_who $P6984, $P6983
    set $P6985, $P6984["Regex"]
    find_lex $P6986, "$/"
    unless_null $P6986, vivify_3034
    $P6986 = root_new ['parrot';'Hash']
  vivify_3034:
    set $P6987, $P6986["codeblock"]
    unless_null $P6987, vivify_3035
    new $P6987, "Undef"
  vivify_3035:
    $P6988 = $P6987."ast"()
.annotate 'line', 2648
    find_lex $P6989, "$/"
    unless_null $P6989, vivify_3036
    $P6989 = root_new ['parrot';'Hash']
  vivify_3036:
    set $P6990, $P6989["zw"]
    unless_null $P6990, vivify_3037
    new $P6990, "Undef"
  vivify_3037:
    set $S6991, $P6990
    iseq $I6992, $S6991, "!"
    find_lex $P6993, "$/"
    unless_null $P6993, vivify_3038
    new $P6993, "Undef"
  vivify_3038:
    $P6994 = $P6985."new"($P6988, "zerowidth" :named("subtype"), $I6992 :named("negate"), "pastnode" :named("pasttype"), $P6993 :named("node"))
.annotate 'line', 2647
    $P6995 = $P6981."!make"($P6994)
.annotate 'line', 2646
    .return ($P6995)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("613_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_6997
    .param pmc param_6998
.annotate 'line', 2652
    .lex "self", param_6997
    .lex "$/", param_6998
.annotate 'line', 2653
    find_lex $P6999, "$/"
    get_hll_global $P7000, "GLOBAL"
    nqp_get_package_through_who $P7001, $P7000, "PAST"
    get_who $P7002, $P7001
    set $P7003, $P7002["Regex"]
    find_lex $P7004, "$/"
    unless_null $P7004, vivify_3039
    $P7004 = root_new ['parrot';'Hash']
  vivify_3039:
    set $P7005, $P7004["var"]
    unless_null $P7005, vivify_3040
    new $P7005, "Undef"
  vivify_3040:
    $P7006 = $P7005."ast"()
    find_lex $P7007, "$/"
    unless_null $P7007, vivify_3041
    new $P7007, "Undef"
  vivify_3041:
    $P7008 = $P7003."new"("!INTERPOLATE_REGEX", $P7006, "subrule" :named("pasttype"), "method" :named("subtype"), $P7007 :named("node"))
    $P7009 = $P6999."!make"($P7008)
.annotate 'line', 2652
    .return ($P7009)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("614_1304523757.895") :outer("607_1304523757.895")
    .param pmc param_7011
    .param pmc param_7012
.annotate 'line', 2657
    .lex "self", param_7011
    .lex "$/", param_7012
.annotate 'line', 2658
    new $P7013, "Undef"
    .lex "$block", $P7013
.annotate 'line', 2660
    new $P7014, "Undef"
    .lex "$past", $P7014
.annotate 'line', 2658
    find_lex $P7015, "$/"
    unless_null $P7015, vivify_3042
    $P7015 = root_new ['parrot';'Hash']
  vivify_3042:
    set $P7016, $P7015["block"]
    unless_null $P7016, vivify_3043
    new $P7016, "Undef"
  vivify_3043:
    $P7017 = $P7016."ast"()
    store_lex "$block", $P7017
.annotate 'line', 2659
    find_lex $P7018, "$block"
    unless_null $P7018, vivify_3044
    new $P7018, "Undef"
  vivify_3044:
    $P7018."blocktype"("immediate")
.annotate 'line', 2661
    get_hll_global $P7019, "GLOBAL"
    nqp_get_package_through_who $P7020, $P7019, "PAST"
    get_who $P7021, $P7020
    set $P7022, $P7021["Stmts"]
.annotate 'line', 2662
    get_hll_global $P7023, "GLOBAL"
    nqp_get_package_through_who $P7024, $P7023, "PAST"
    get_who $P7025, $P7024
    set $P7026, $P7025["Op"]
.annotate 'line', 2663
    get_hll_global $P7027, "GLOBAL"
    nqp_get_package_through_who $P7028, $P7027, "PAST"
    get_who $P7029, $P7028
    set $P7030, $P7029["Var"]
    $P7031 = $P7030."new"("$/" :named("name"))
.annotate 'line', 2664
    get_hll_global $P7032, "GLOBAL"
    nqp_get_package_through_who $P7033, $P7032, "PAST"
    get_who $P7034, $P7033
    set $P7035, $P7034["Op"]
.annotate 'line', 2665
    get_hll_global $P7036, "GLOBAL"
    nqp_get_package_through_who $P7037, $P7036, "PAST"
    get_who $P7038, $P7037
    set $P7039, $P7038["Var"]
    $P7040 = $P7039."new"(unicode:"$\x{a2}" :named("name"))
    $P7041 = $P7035."new"($P7040, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2664
    $P7042 = $P7026."new"($P7031, $P7041, "bind" :named("pasttype"))
.annotate 'line', 2662
    find_lex $P7043, "$block"
    unless_null $P7043, vivify_3045
    new $P7043, "Undef"
  vivify_3045:
    $P7044 = $P7022."new"($P7042, $P7043)
.annotate 'line', 2661
    store_lex "$past", $P7044
.annotate 'line', 2673
    find_lex $P7045, "$/"
    find_lex $P7046, "$past"
    unless_null $P7046, vivify_3046
    new $P7046, "Undef"
  vivify_3046:
    $P7047 = $P7045."!make"($P7046)
.annotate 'line', 2657
    .return ($P7047)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7049"  :subid("615_1304523757.895") :outer("10_1304523757.895")
.annotate 'line', 2678
    .lex "$?PACKAGE", $P7051
    .lex "$?CLASS", $P7052
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block7063" :load :anon :subid("616_1304523757.895")
.annotate 'line', 1
    .const 'Sub' $P7065 = "10_1304523757.895" 
    $P7066 = $P7065()
    .return ($P7066)
.end

